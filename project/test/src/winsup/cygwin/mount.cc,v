head	1.107;
access;
symbols
	cygwin-1_7_35-release:1.107
	cygwin-1_7_34-release:1.107
	cygwin-1_7_33-release:1.103.2.2
	cygwin-1_7_32-release:1.103.2.1
	cygwin-1_7_31-release:1.103.2.1
	cygwin-1_7_30-release:1.103
	cygwin-1_7_29-release:1.103
	cygwin-1_7_29-release-branchpoint:1.103.0.2
	cygwin-pre-user-db:1.104
	cygwin-1_7_28-release:1.102
	cygwin-1_7_27-release:1.101
	cygwin-1_7_26-release:1.101
	cygwin-1_7_25-release:1.100
	cygwin-1_7_24-release:1.100
	cygwin-1_7_23-release:1.100
	cygwin-1_7_22-release:1.100
	cygwin-1_7_21-release:1.100
	cygwin-1_7_20-release:1.100
	cygwin-1_7_19-release:1.100
	cygwin-64bit-postmerge:1.99
	cygwin-64bit-premerge-branch:1.98.0.2
	cygwin-64bit-premerge:1.98
	cygwin-1_7_18-release:1.98
	post-ptmalloc3:1.93.2.5
	pre-ptmalloc3:1.93.2.5
	cygwin-1_7_17-release:1.95
	cygwin-64bit-branch:1.93.0.2
	cygwin-1_7_16-release:1.93
	cygwin-1_7_15-release:1.89
	cygwin-1_7_14_2-release:1.89
	cygwin-1_7_14-release:1.89
	cygwin-1_7_12-release:1.89
	cygwin-1_7_11-release:1.88
	cygwin-1_7_10-release:1.84
	signal-rewrite:1.79.0.2
	pre-notty:1.78
	cygwin-1_7_9-release:1.73
	cv-post-1_7_9:1.73.0.2
	cygwin-1_7_8-release:1.73
	cygwin-1_7_7-release:1.64
	cygwin-1_7_5-release:1.56
	cygwin-1_7_4-release:1.56
	cygwin-1_7_3-release:1.56
	cygwin-1_7_2-release:1.55
	fifo_doover3:1.52.0.2
	cygwin-1_7_1-release:1.52
	prefifo:1.48
	cv-branch-2:1.40.0.2
	pre-ripout-set_console_state_for_spawn:1.12;
locks; strict;
comment	@// @;


1.107
date	2014.11.27.16.49.41;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2014.08.22.09.21.31;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2014.06.23.14.05.16;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2014.02.08.20.57.27;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2014.02.06.20.38.34;	author corinna;	state Exp;
branches
	1.103.2.1;
next	1.102;

1.102
date	2013.12.11.10.24.52;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2013.11.24.12.13.34;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2013.04.24.10.16.12;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.98;

1.98
date	2013.03.06.14.10.23;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2012.12.14.10.45.28;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2012.08.16.23.34.44;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2012.08.14.09.49.25;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2012.07.19.09.04.02;	author yselkowitz;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2012.07.18.11.17.25;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2012.07.02.19.42.34;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2012.06.03.16.46.53;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2012.04.02.11.00.17;	author corinna;	state Exp;
branches;
next	1.88;

1.88
date	2012.02.17.14.17.12;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2012.02.16.11.02.05;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2012.02.14.11.27.43;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2012.02.07.17.34.29;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2011.12.22.12.25.09;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2011.12.12.11.03.01;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2011.10.21.17.43.00;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2011.10.21.08.29.19;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2011.06.12.20.15.26;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2011.05.24.15.09.08;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2011.05.02.15.28.34;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2011.04.04.12.23.35;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2010.11.22.14.19.50;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2010.09.28.14.49.31;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2010.09.28.14.40.18;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2010.09.27.16.10.14;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2010.09.21.16.32.22;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2010.09.13.11.17.35;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2010.09.10.10.04.28;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2010.09.06.09.47.01;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2010.09.04.08.44.59;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2010.08.25.09.20.11;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2010.08.11.10.58.06;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2010.08.09.08.18.30;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2010.04.29.10.38.04;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2010.04.29.08.47.43;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2010.04.28.15.35.52;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2010.04.23.11.07.35;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2010.04.22.17.33.28;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2010.03.30.08.55.23;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2010.03.15.21.29.15;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2010.02.15.12.42.31;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.12.14.47.46;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.02.11.42.04;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.31.13.24.06;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2009.08.25.11.27.03;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2009.07.28.10.39.55;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2009.07.23.11.46.06;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2009.07.23.07.51.55;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2009.07.22.18.49.48;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2009.07.22.18.27.47;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2009.07.22.16.21.33;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2009.07.17.09.00.19;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2009.07.16.09.56.25;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2009.07.14.17.37.42;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2009.05.19.00.42.35;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.18.04.58.21;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2009.05.14.14.44.31;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2009.05.14.09.56.45;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2009.05.14.03.25.45;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2009.05.04.09.16.42;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2009.02.13.09.05.42;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.29.20.32.08;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.24.16.30.09;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.09.16.20.26;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2009.01.03.05.12.21;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.25.15.55.31;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.13.21.05.31;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2008.11.26.17.21.03;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.11.11.45.04;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2008.09.11.04.58.44;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2008.08.15.12.33.26;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2008.08.15.12.06.38;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2008.08.13.15.30.52;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.13.15.11.25;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.27.16.59.07;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.25.15.23.56;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.24.18.32.41;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.24.18.25.49;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.17.14.14.34;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.14.20.22.02;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.13.15.22.59;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.10.17.17.44;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.25.23.51.32;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.24.15.59.01;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.24.10.07.49;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.23.16.38.51;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.23.15.33.03;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.20.15.11.23;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.30.08.49.23;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.29.20.48.09;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.21.14.00.24;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.08.16.12.24;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	;

1.103.2.1
date	2014.07.15.14.34.38;	author corinna;	state Exp;
branches;
next	1.103.2.2;

1.103.2.2
date	2014.11.13.12.53.03;	author corinna;	state Exp;
branches;
next	;

1.93.2.1
date	2012.08.14.09.54.31;	author corinna;	state Exp;
branches;
next	1.93.2.2;

1.93.2.2
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.93.2.3;

1.93.2.3
date	2012.12.10.11.45.49;	author corinna;	state Exp;
branches;
next	1.93.2.4;

1.93.2.4
date	2012.12.14.10.45.37;	author corinna;	state Exp;
branches;
next	1.93.2.5;

1.93.2.5
date	2013.01.21.13.52.08;	author corinna;	state Exp;
branches;
next	1.93.2.6;

1.93.2.6
date	2013.03.06.14.10.36;	author corinna;	state Exp;
branches;
next	1.93.2.7;

1.93.2.7
date	2013.03.14.12.09.52;	author corinna;	state Exp;
branches;
next	1.93.2.8;

1.93.2.8
date	2013.04.09.10.41.32;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.107
log
@	* mount.cc (mount_info::init): Take bool argument and allow to
	initialize mount table in two steps, system and user, depending on
	bool value.
	* mount.h (class mount_info): Align declaration of init function to
	above change.
	* shared.cc (user_info::initialize): Initialize mount table in two
	steps to allow internal_getpwsid to create valid POSIX paths from
	DOS paths given in AD.  Add comments.
	* uinfo.cc (cygheap_pwdgrp::get_home): Allow DOS paths in
	NSS_SCHEME_FREEATTR attributes.
	(cygheap_pwdgrp::get_shell): Ditto.
@
text
@/* mount.cc: mount handling.

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "miscfuncs.h"
#include <mntent.h>
#include <ctype.h>
#include <winioctl.h>
#include <cygwin/version.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "shared_info.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "cygtls.h"
#include "tls_pbuf.h"
#include <ntdll.h>
#include <wchar.h>
#include <stdio.h>
#include <assert.h>

/* Determine if path prefix matches current cygdrive */
#define iscygdrive(path) \
  (path_prefix_p (mount_table->cygdrive, (path), mount_table->cygdrive_len, false))

#define iscygdrive_device(path) \
  (isalpha (path[mount_table->cygdrive_len]) && \
   (path[mount_table->cygdrive_len + 1] == '/' || \
    !path[mount_table->cygdrive_len + 1]))

#define isproc(path) \
  (path_prefix_p (proc, (path), proc_len, false))

bool NO_COPY mount_info::got_usr_bin;
bool NO_COPY mount_info::got_usr_lib;
int NO_COPY mount_info::root_idx = -1;

/* is_unc_share: Return non-zero if PATH begins with //server/share
		 or with one of the native prefixes //./ or //?/
   This function is only used to test for valid input strings.
   The later normalization drops the native prefixes. */

static inline bool __stdcall
is_native_path (const char *path)
{
  return isdirsep (path[0])
	 && (isdirsep (path[1]) || path[1] == '?')
	 && (path[2] == '?' || path[2] == '.')
	 && isdirsep (path[3])
	 && isalpha (path[4]);
}

static inline bool __stdcall
is_unc_share (const char *path)
{
  const char *p;
  return (isdirsep (path[0])
	 && isdirsep (path[1])
	 && isalnum (path[2])
	 && ((p = strpbrk (path + 3, "\\/")) != NULL)
	 && isalnum (p[1]));
}

/* Return true if src_path is a valid, internally supported device name.
   In that case, win32_path gets the corresponding NT device name and
   dev is appropriately filled with device information. */

static bool
win32_device_name (const char *src_path, char *win32_path, device& dev)
{
  dev.parse (src_path);
  if (dev == FH_FS || dev == FH_DEV)
    return false;
  strcpy (win32_path, dev.native);
  return true;
}

/* Beginning with Samba 3.0.28a, Samba allows to get version information using
   the ExtendedInfo member returned by a FileFsObjectIdInformation request.
   We just store the samba_version information for now.  Older versions than
   3.2 are still guessed at by testing the file system flags. */
#define SAMBA_EXTENDED_INFO_MAGIC 0x536d4261 /* "SmBa" */
#define SAMBA_EXTENDED_INFO_VERSION_STRING_LENGTH 28
#pragma pack(push,4)
struct smb_extended_info {
  DWORD		samba_magic;		/* Always SAMBA_EXTENDED_INFO_MAGIC */
  DWORD		samba_version;		/* Major/Minor/Release/Revision */
  DWORD		samba_subversion;	/* Prerelease/RC/Vendor patch */
  LARGE_INTEGER samba_gitcommitdate;
  char		samba_version_string[SAMBA_EXTENDED_INFO_VERSION_STRING_LENGTH];
};
#pragma pack(pop)

#define MAX_FS_INFO_CNT 32
class fs_info_cache
{
  static muto fsi_lock;
  uint32_t count;
  struct {
    fs_info fsi;
    uint32_t hash;
  } entry[MAX_FS_INFO_CNT];

  uint32_t genhash (PFILE_FS_VOLUME_INFORMATION);

public:
  fs_info_cache () : count (0) { fsi_lock.init ("fsi_lock"); }
  fs_info *search (PFILE_FS_VOLUME_INFORMATION, uint32_t &);
  void add (uint32_t, fs_info *);
};

static fs_info_cache fsi_cache;
muto NO_COPY fs_info_cache::fsi_lock;

uint32_t
fs_info_cache::genhash (PFILE_FS_VOLUME_INFORMATION pffvi)
{
  uint32_t hash = 0;
  const uint16_t *p = (const uint16_t *) pffvi;
  const uint16_t *end = (const uint16_t *)
			((const uint8_t *) p + sizeof *pffvi
			 + pffvi->VolumeLabelLength  - sizeof (WCHAR));
  pffvi->__dummy = 0;	/* This member can have random values! */
  while (p < end)
    hash = *p++ + (hash << 6) + (hash << 16) - hash;
  return hash;
}

fs_info *
fs_info_cache::search (PFILE_FS_VOLUME_INFORMATION pffvi, uint32_t &hash)
{
  hash = genhash (pffvi);
  for (uint32_t i = 0; i < count; ++i)
    if (entry[i].hash == hash)
      return &entry[i].fsi;
  return NULL;
}

void
fs_info_cache::add (uint32_t hashval, fs_info *new_fsi)
{
  fsi_lock.acquire ();
  if (count < MAX_FS_INFO_CNT)
    {
      entry[count].fsi = *new_fsi;
      entry[count].hash = hashval;
      ++count;
    }
  fsi_lock.release ();
}

bool
fs_info::update (PUNICODE_STRING upath, HANDLE in_vol)
{
  NTSTATUS status = STATUS_OBJECT_NAME_NOT_FOUND;
  HANDLE vol;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  bool no_media = false;
  FILE_FS_DEVICE_INFORMATION ffdi;
  FILE_FS_OBJECTID_INFORMATION ffoi;
  struct {
    FILE_FS_ATTRIBUTE_INFORMATION ffai;
    WCHAR buf[NAME_MAX + 1];
  } ffai_buf;
  struct {
    FILE_FS_VOLUME_INFORMATION ffvi;
    WCHAR buf[NAME_MAX + 1];
  } ffvi_buf;
  UNICODE_STRING dir;
  UNICODE_STRING fsname;

  clear ();
  /* Always caseinsensitive.  We really just need access to the drive. */
  InitializeObjectAttributes (&attr, upath, OBJ_CASE_INSENSITIVE, NULL,
			      NULL);
  if (in_vol)
    vol = in_vol;
  else
    {
      ULONG access = READ_CONTROL;
      /* Note: Don't use the FILE_OPEN_REPARSE_POINT flag here.  The reason
	 is that symlink_info::check relies on being able to open a handle
	 to the target of a volume mount point. */
      status = NtOpenFile (&vol, access, &attr, &io, FILE_SHARE_VALID_FLAGS,
			   FILE_OPEN_FOR_BACKUP_INTENT);
      /* At least one filesystem (HGFS, VMware shared folders) doesn't like
	 to be opened with access set to just READ_CONTROL. */
      if (status == STATUS_INVALID_PARAMETER)
	{
	  access |= FILE_READ_DATA;
	  status = NtOpenFile (&vol, access, &attr, &io, FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	}
      while (!NT_SUCCESS (status)
	     && (attr.ObjectName->Length > 7 * sizeof (WCHAR)
		 || status == STATUS_NO_MEDIA_IN_DEVICE))
	{
	  RtlSplitUnicodePath (attr.ObjectName, &dir, NULL);
	  attr.ObjectName = &dir;
	  if (status == STATUS_NO_MEDIA_IN_DEVICE)
	    {
	      no_media = true;
	      dir.Length = 6 * sizeof (WCHAR);
	    }
	  else if (dir.Length > 7 * sizeof (WCHAR))
	    dir.Length -= sizeof (WCHAR);
	  status = NtOpenFile (&vol, access, &attr, &io, FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	}
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("Cannot access path %S, status %y",
			attr.ObjectName, status);
	  return false;
	}
    }
  sernum = 0;
  status = NtQueryVolumeInformationFile (vol, &io, &ffvi_buf.ffvi,
					 sizeof ffvi_buf,
					 FileFsVolumeInformation);
  uint32_t hash = 0;
  if (NT_SUCCESS (status))
    {
      fs_info *fsi = fsi_cache.search (&ffvi_buf.ffvi, hash);
      if (fsi)
	{
	  *this = *fsi;
	  if (!in_vol)
	    NtClose (vol);
	  return true;
	}
      sernum = ffvi_buf.ffvi.VolumeSerialNumber;
    }
  status = NtQueryVolumeInformationFile (vol, &io, &ffdi, sizeof ffdi,
					 FileFsDeviceInformation);
  if (!NT_SUCCESS (status))
    ffdi.DeviceType = ffdi.Characteristics = 0;

  if ((ffdi.Characteristics & FILE_REMOTE_DEVICE)
      || (!ffdi.DeviceType
	  && RtlEqualUnicodePathPrefix (attr.ObjectName, &ro_u_uncp, TRUE)))
    is_remote_drive (true);

  if (!no_media)
    status = NtQueryVolumeInformationFile (vol, &io, &ffai_buf.ffai,
					   sizeof ffai_buf,
					   FileFsAttributeInformation);
  if (no_media || !NT_SUCCESS (status))
    {
      debug_printf ("Cannot get volume attributes (%S), %y",
		    attr.ObjectName, status);
      if (!in_vol)
	NtClose (vol);
      return false;
    }
  flags (ffai_buf.ffai.FileSystemAttributes);
  name_len (ffai_buf.ffai.MaximumComponentNameLength);
  RtlInitCountedUnicodeString (&fsname, ffai_buf.ffai.FileSystemName,
			       ffai_buf.ffai.FileSystemNameLength);
  if (is_remote_drive ())
    {
/* Should be reevaluated for each new OS.  Right now this mask is valid up
   to Windows 8.  The important point here is to test only flags indicating
   capabilities and to ignore flags indicating a specific state of this
   volume.  At present these flags to ignore are FILE_VOLUME_IS_COMPRESSED,
   FILE_READ_ONLY_VOLUME, and FILE_SEQUENTIAL_WRITE_ONCE.  The additional
   filesystem flags supported since Windows 7 are also ignored for now.
   They add information, but only on W7 and later, and only for filesystems
   also supporting these flags, right now only NTFS. */
#define GETVOLINFO_VALID_MASK (0x002701ffUL)
#define TEST_GVI(f,m) (((f) & GETVOLINFO_VALID_MASK) == (m))

/* FIXME: This flag twist is getting awkward.  There should really be some
   other method.  Maybe we need mount flags to allow the user to fix file
   system problems without having to wait for a Cygwin fix. */

/* Volume quotas are potentially supported since Samba 3.0, object ids and
   the unicode on disk flag since Samba 3.2. */
#define SAMBA_IGNORE (FILE_VOLUME_QUOTAS \
		      | FILE_SUPPORTS_OBJECT_IDS \
		      | FILE_UNICODE_ON_DISK)
#define FS_IS_SAMBA TEST_GVI(flags () & ~SAMBA_IGNORE, \
			     FILE_CASE_SENSITIVE_SEARCH \
			     | FILE_CASE_PRESERVED_NAMES \
			     | FILE_PERSISTENT_ACLS)
/* Netapp DataOnTap. */
#define NETAPP_IGNORE (FILE_SUPPORTS_SPARSE_FILES \
		       | FILE_PERSISTENT_ACLS)
#define FS_IS_NETAPP_DATAONTAP TEST_GVI(flags () & ~NETAPP_IGNORE, \
			     FILE_CASE_SENSITIVE_SEARCH \
			     | FILE_CASE_PRESERVED_NAMES \
			     | FILE_UNICODE_ON_DISK \
			     | FILE_NAMED_STREAMS)
/* These are the minimal flags supported by NTFS since Windows 2000.  Every
   filesystem not supporting these flags is not a native NTFS.  We subsume
   them under the filesystem type "cifs". */
#define MINIMAL_WIN_NTFS_FLAGS (FILE_CASE_SENSITIVE_SEARCH \
				| FILE_CASE_PRESERVED_NAMES \
				| FILE_UNICODE_ON_DISK \
				| FILE_PERSISTENT_ACLS \
				| FILE_FILE_COMPRESSION \
				| FILE_VOLUME_QUOTAS \
				| FILE_SUPPORTS_SPARSE_FILES \
				| FILE_SUPPORTS_REPARSE_POINTS \
				| FILE_SUPPORTS_OBJECT_IDS \
				| FILE_SUPPORTS_ENCRYPTION \
				| FILE_NAMED_STREAMS)
#define FS_IS_WINDOWS_NTFS TEST_GVI(flags () & MINIMAL_WIN_NTFS_FLAGS, \
				    MINIMAL_WIN_NTFS_FLAGS)
/* These are the exact flags of a real Windows FAT/FAT32 filesystem.
   Anything else is a filesystem faking to be FAT. */
#define WIN_FAT_FLAGS (FILE_CASE_PRESERVED_NAMES | FILE_UNICODE_ON_DISK)
#define FS_IS_WINDOWS_FAT  TEST_GVI(flags (), WIN_FAT_FLAGS)

      if ((flags () & FILE_SUPPORTS_OBJECT_IDS)
	  && NT_SUCCESS (NtQueryVolumeInformationFile (vol, &io, &ffoi,
						   sizeof ffoi,
						   FileFsObjectIdInformation)))
	{
	  smb_extended_info *extended_info = (smb_extended_info *)
					     &ffoi.ExtendedInfo;
	  if (extended_info->samba_magic == SAMBA_EXTENDED_INFO_MAGIC)
	    {
	      is_samba (true);
	      samba_version (extended_info->samba_version);
	    }
	}
      /* First check the remote filesystems claiming to be NTFS. */
      if (!got_fs ()
	  && is_ntfs (RtlEqualUnicodeString (&fsname, &ro_u_ntfs, FALSE))
	  /* Test for older Samba releases not supporting extended info. */
	  && !is_samba (FS_IS_SAMBA)
	  /* Netapp inode info is unusable, can't handle trailing dots and
	     spaces, has a bug in "move and delete" semantics. */
	  && !is_netapp (FS_IS_NETAPP_DATAONTAP))
	/* Any other remote FS faking to be NTFS. */
	is_cifs (!FS_IS_WINDOWS_NTFS);
      /* Then check remote filesystems claiming to be FAT.  Except for real
	 FAT and Netapp, all of them are subsumed under the "CIFS" filesystem
	 type for now. */
      if (!got_fs ()
	  && is_fat (RtlEqualUnicodePathPrefix (&fsname, &ro_u_fat, TRUE))
	  && !is_netapp (FS_IS_NETAPP_DATAONTAP))
	is_cifs (!FS_IS_WINDOWS_FAT);
      /* Then check remote filesystems honest about their name. */
      if (!got_fs ()
	  /* Microsoft NFS needs distinct access methods for metadata. */
	  && !is_nfs (RtlEqualUnicodeString (&fsname, &ro_u_nfs, FALSE))
	  /* MVFS == Rational ClearCase remote filesystem.  Has a couple of
	     drawbacks, like not supporting DOS attributes other than R/O
	     and stuff like that. */
	  && !is_mvfs (RtlEqualUnicodePathPrefix (&fsname, &ro_u_mvfs, FALSE))
	  /* NWFS == Novell Netware FS.  Broken info class, see below. */
	  /* NcFsd == Novell Netware FS via own driver since Windows Vista. */
	  && !is_nwfs (RtlEqualUnicodeString (&fsname, &ro_u_nwfs, FALSE))
	  && !is_ncfsd (RtlEqualUnicodeString (&fsname, &ro_u_ncfsd, FALSE))
	  /* UNIXFS == TotalNet Advanced Server (TAS).  Doesn't support
	     FileIdBothDirectoryInformation.  See below. */
	  && !is_unixfs (RtlEqualUnicodeString (&fsname, &ro_u_unixfs, FALSE))
	  /* AFSRDRFsd == Andrew File System.  Doesn't support DOS attributes.
	     Only native symlinks are supported. */
	  && !is_afs (RtlEqualUnicodeString (&fsname, &ro_u_afs, FALSE)))
	{
	  /* Known remote file system with buggy open calls.  Further
	     explanation in fhandler.cc (fhandler_disk_file::open_fs). */
	  is_sunwnfs (RtlEqualUnicodeString (&fsname, &ro_u_sunwnfs, FALSE));
	  has_buggy_open (is_sunwnfs ());
	}
      if (got_fs ())
	{
	  /* UNIXFS is known to choke on FileIdBothDirectoryInformation.
	     Some other CIFS servers have problems with this call as well.
	     Know example: EMC NS-702.  We just don't use that info class on
	     any remote CIFS.  */
	  has_buggy_fileid_dirinfo (is_cifs () || is_unixfs ());
	  /* NWFS is known to have a broken FileBasicInformation info
	     class.  It can't be used to fetch information, only to set
	     information.  Therefore, for NWFS we have to fallback to the
	     FileNetworkOpenInformation info class.  Unfortunately we can't
	     use FileNetworkOpenInformation all the time since that fails on
	     other filesystems like NFS.
	     UNUSED, but keep in for information purposes. */
	  has_buggy_basic_info (is_nwfs ());
	  /* Netapp and NWFS/NcFsd are too dumb to allow non-DOS filenames
	     containing trailing dots and spaces when accessed from Windows
	     clients.  We subsume CIFS into this class of filesystems right
	     away since at least some of them are not capable either. */
	  has_dos_filenames_only (is_netapp () || is_nwfs ()
				  || is_ncfsd () || is_cifs ());
	  /* Netapp and NWFS don't grok re-opening a file by handle.  They
	     only support this if the filename is non-null and the handle is
	     the handle to a directory. NcFsd IR10 is supposed to be ok. */
	  has_buggy_reopen (is_netapp () || is_nwfs ());
	}
    }
  if (!got_fs ()
      && !is_ntfs (RtlEqualUnicodeString (&fsname, &ro_u_ntfs, FALSE))
      && !is_fat (RtlEqualUnicodePathPrefix (&fsname, &ro_u_fat, TRUE))
      && !is_refs (RtlEqualUnicodeString (&fsname, &ro_u_refs, FALSE))
      && !is_csc_cache (RtlEqualUnicodeString (&fsname, &ro_u_csc, FALSE))
      && is_cdrom (ffdi.DeviceType == FILE_DEVICE_CD_ROM))
    is_udf (RtlEqualUnicodeString (&fsname, &ro_u_udf, FALSE));
  if (!got_fs ())
    {
      /* The filesystem name is only used in fillout_mntent and only if
	 the filesystem isn't one of the well-known filesystems anyway. */
      sys_wcstombs (fsn, sizeof fsn, ffai_buf.ffai.FileSystemName,
		    ffai_buf.ffai.FileSystemNameLength / sizeof (WCHAR));
      strlwr (fsn);
    }
  has_acls (flags () & FS_PERSISTENT_ACLS);
  /* Netapp inode numbers are fly-by-night. */
  hasgood_inode ((has_acls () && !is_netapp ()) || is_nfs ());
  /* Case sensitivity is supported if FILE_CASE_SENSITIVE_SEARCH is set,
     except on Samba which handles Windows clients case insensitive.

     NFS doesn't set the FILE_CASE_SENSITIVE_SEARCH flag but is case
     sensitive.

     UDF on NT 5.x is broken (at least) in terms of case sensitivity.
     The UDF driver reports the FILE_CASE_SENSITIVE_SEARCH capability
     but:
     - Opening the root directory for query seems to work at first,
       but the filenames in the directory listing are mutilated.
     - When trying to open a file or directory case sensitive, the file
       appears to be non-existant. */
  caseinsensitive (((!(flags () & FILE_CASE_SENSITIVE_SEARCH) || is_samba ())
		    && !is_nfs ())
		   || (is_udf () && wincap.has_broken_udf ()));

  if (!in_vol)
    NtClose (vol);
  fsi_cache.add (hash, this);
  return true;
}

inline void
mount_info::create_root_entry (const PWCHAR root)
{
 /* Create a default root dir derived from the location of the Cygwin DLL.
    The entry is immutable, unless the "override" option is given in /etc/fstab. */
  char native_root[PATH_MAX];
  sys_wcstombs (native_root, PATH_MAX, root);
  assert (*native_root != '\0');
  if (add_item (native_root, "/",
		MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_IMMUTABLE | MOUNT_AUTOMATIC)
      < 0)
    api_fatal ("add_item (\"%s\", \"/\", ...) failed, errno %d", native_root, errno);
  /* Create a default cygdrive entry.  Note that this is a user entry.
     This allows to override it with mount, unless the sysadmin created
     a cygdrive entry in /etc/fstab. */
  cygdrive_flags = MOUNT_BINARY | MOUNT_NOPOSIX | MOUNT_CYGDRIVE;
  strcpy (cygdrive, CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX "/");
  cygdrive_len = strlen (cygdrive);
}

/* init: Initialize the mount table.  */

void
mount_info::init (bool user_init)
{
  PWCHAR pathend;
  WCHAR path[PATH_MAX];

  pathend = wcpcpy (path, cygheap->installation_root);
  if (!user_init)
    create_root_entry (path);

  pathend = wcpcpy (pathend, L"\\etc\\fstab");
  from_fstab (user_init, path, pathend);

  if (!user_init && (!got_usr_bin || !got_usr_lib))
    {
      char native[PATH_MAX];
      if (root_idx < 0)
	api_fatal ("root_idx %d, user_shared magic %y, nmounts %d", root_idx, user_shared->version, nmounts);
      char *p = stpcpy (native, mount[root_idx].native_path);
      if (!got_usr_bin)
      {
	stpcpy (p, "\\bin");
	add_item (native, "/usr/bin",
		  MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_AUTOMATIC);
      }
      if (!got_usr_lib)
      {
	stpcpy (p, "\\lib");
	add_item (native, "/usr/lib",
		  MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_AUTOMATIC);
      }
    }
}

static void
set_flags (unsigned *flags, unsigned val)
{
  *flags = val;
  if (!(*flags & PATH_BINARY))
    {
      *flags |= PATH_TEXT;
      debug_printf ("flags: text (%y)", *flags & (PATH_TEXT | PATH_BINARY));
    }
  else
    {
      *flags |= PATH_BINARY;
      debug_printf ("flags: binary (%y)", *flags & (PATH_TEXT | PATH_BINARY));
    }
}

int
mount_item::build_win32 (char *dst, const char *src, unsigned *outflags, unsigned chroot_pathlen)
{
  int n, err = 0;
  const char *real_native_path;
  int real_posix_pathlen;
  set_flags (outflags, (unsigned) flags);
  if (!cygheap->root.exists () || posix_pathlen != 1 || posix_path[0] != '/')
    {
      n = native_pathlen;
      real_native_path = native_path;
      real_posix_pathlen = chroot_pathlen ?: posix_pathlen;
    }
  else
    {
      n = cygheap->root.native_length ();
      real_native_path = cygheap->root.native_path ();
      real_posix_pathlen = posix_pathlen;
    }
  memcpy (dst, real_native_path, n + 1);
  const char *p = src + real_posix_pathlen;
  if (*p == '/')
    /* nothing */;
  else if ((isdrive (dst) && !dst[2]) || *p)
    dst[n++] = '\\';
  if ((n + strlen (p)) >= NT_MAX_PATH)
    err = ENAMETOOLONG;
  else
    backslashify (p, dst + n, 0);
  return err;
}

/* conv_to_win32_path: Ensure src_path is a pure Win32 path and store
   the result in win32_path.

   If win32_path != NULL, the relative path, if possible to keep, is
   stored in win32_path.  If the relative path isn't possible to keep,
   the full path is stored.

   If full_win32_path != NULL, the full path is stored there.

   The result is zero for success, or an errno value.

   {,full_}win32_path must have sufficient space (i.e. NT_MAX_PATH bytes).  */

int
mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
				unsigned *flags)
{
  bool chroot_ok = !cygheap->root.exists ();

  MALLOC_CHECK;

  dev = FH_FS;

  *flags = 0;
  debug_printf ("conv_to_win32_path (%s)", src_path);

  int i, rc;
  mount_item *mi = NULL;	/* initialized to avoid compiler warning */

  /* The path is already normalized, without ../../ stuff, we need to have this
     so that we can move from one mounted directory to another with relative
     stuff.

     eg mounting c:/foo /foo
     d:/bar /bar

     cd /bar
     ls ../foo

     should look in c:/foo, not d:/foo.

     converting normalizex UNIX path to a DOS-style path, looking up the
     appropriate drive in the mount table.  */

  /* See if this is a cygwin "device" */
  if (win32_device_name (src_path, dst, dev))
    {
      *flags = MOUNT_BINARY;	/* FIXME: Is this a sensible default for devices? */
      rc = 0;
      goto out_no_chroot_check;
    }

  MALLOC_CHECK;
  /* If the path is on a network drive or a //./ resp. //?/ path prefix,
     bypass the mount table.  If it's // or //MACHINE, use the netdrive
     device. */
  if (src_path[1] == '/')
    {
      if (!strchr (src_path + 2, '/'))
	{
	  dev = *netdrive_dev;
	  set_flags (flags, PATH_BINARY);
	}
      else
	{
	  /* For UNC paths, use the cygdrive prefix flags as default setting.
	     This is more natural since UNC paths, just like cygdrive paths,
	     are rather (warning, poetic description ahead) windows into the
	     native Win32 world.  This also gives the user an elegant way to
	     change the settings for those paths in a central place. */
	  set_flags (flags, (unsigned) cygdrive_flags);
	}
      backslashify (src_path, dst, 0);
      /* Go through chroot check */
      goto out;
    }
  if (isproc (src_path))
    {
      dev = *proc_dev;
      dev = fhandler_proc::get_proc_fhandler (src_path);
      if (dev == FH_NADA)
	return ENOENT;
      set_flags (flags, PATH_BINARY);
      if (isprocsys_dev (dev))
	{
	  if (src_path[procsys_len])
	    backslashify (src_path + procsys_len, dst, 0);
	  else	/* Avoid empty NT path. */
	    stpcpy (dst, "\\");
	  set_flags (flags, (unsigned) cygdrive_flags);
	}
      else
	strcpy (dst, src_path);
      goto out;
    }
  /* Check if the cygdrive prefix was specified.  If so, just strip
     off the prefix and transform it into an MS-DOS path. */
  else if (iscygdrive (src_path))
    {
      int n = mount_table->cygdrive_len - 1;
      int unit;

      if (!src_path[n])
	{
	  dst[0] = '\0';
	  if (mount_table->cygdrive_len > 1)
	    dev = *cygdrive_dev;
	}
      else if (cygdrive_win32_path (src_path, dst, unit))
	{
	  set_flags (flags, (unsigned) cygdrive_flags);
	  goto out;
	}
      else if (mount_table->cygdrive_len > 1)
	return ENOENT;
    }

  int chroot_pathlen;
  chroot_pathlen = 0;
  /* Check the mount table for prefix matches. */
  for (i = 0; i < nmounts; i++)
    {
      const char *path;
      int len;

      mi = mount + posix_sorted[i];
      if (!cygheap->root.exists ()
	  || (mi->posix_pathlen == 1 && mi->posix_path[0] == '/'))
	{
	  path = mi->posix_path;
	  len = mi->posix_pathlen;
	}
      else if (cygheap->root.posix_ok (mi->posix_path))
	{
	  path = cygheap->root.unchroot (mi->posix_path);
	  chroot_pathlen = len = strlen (path);
	}
      else
	{
	  chroot_pathlen = 0;
	  continue;
	}

      if (path_prefix_p (path, src_path, len, mi->flags & MOUNT_NOPOSIX))
	break;
    }

  if (i < nmounts)
    {
      int err = mi->build_win32 (dst, src_path, flags, chroot_pathlen);
      if (err)
	return err;
      chroot_ok = true;
    }
  else
    {
      int offset = 0;
      if (src_path[1] != '/' && src_path[1] != ':')
	offset = cygheap->cwd.get_drive (dst);
      backslashify (src_path, dst + offset, 0);
    }
 out:
  MALLOC_CHECK;
  if (chroot_ok || cygheap->root.ischroot_native (dst))
    rc = 0;
  else
    {
      debug_printf ("attempt to access outside of chroot '%s - %s'",
		    cygheap->root.posix_path (), cygheap->root.native_path ());
      rc = ENOENT;
    }

 out_no_chroot_check:
  debug_printf ("src_path %s, dst %s, flags %y, rc %d", src_path, dst, *flags, rc);
  return rc;
}

int
mount_info::get_mounts_here (const char *parent_dir, int parent_dir_len,
			     PUNICODE_STRING mount_points,
			     PUNICODE_STRING cygd)
{
  int n_mounts = 0;

  for (int i = 0; i < nmounts; i++)
    {
      mount_item *mi = mount + posix_sorted[i];
      char *last_slash = strrchr (mi->posix_path, '/');
      if (!last_slash)
	continue;
      if (last_slash == mi->posix_path)
	{
	  if (parent_dir_len == 1 && mi->posix_pathlen > 1)
	    RtlCreateUnicodeStringFromAsciiz (&mount_points[n_mounts++],
					      last_slash + 1);
	}
      else if (parent_dir_len == last_slash - mi->posix_path
	       && strncasematch (parent_dir, mi->posix_path, parent_dir_len))
	RtlCreateUnicodeStringFromAsciiz (&mount_points[n_mounts++],
					  last_slash + 1);
    }
  RtlCreateUnicodeStringFromAsciiz (cygd, cygdrive + 1);
  if (cygd->Length)
    cygd->Length -= 2;	// Strip trailing slash
  return n_mounts;
}

/* cygdrive_posix_path: Build POSIX path used as the
   mount point for cygdrives created when there is no other way to
   obtain a POSIX path from a Win32 one. */

void
mount_info::cygdrive_posix_path (const char *src, char *dst, int trailing_slash_p)
{
  int len = cygdrive_len;

  memcpy (dst, cygdrive, len + 1);

  /* Now finish the path off with the drive letter to be used.
     The cygdrive prefix always ends with a trailing slash so
     the drive letter is added after the path. */
  dst[len++] = cyg_tolower (src[0]);
  if (!src[2] || (isdirsep (src[2]) && !src[3]))
    dst[len++] = '\000';
  else
    {
      int n;
      dst[len++] = '/';
      if (isdirsep (src[2]))
	n = 3;
      else
	n = 2;
      strcpy (dst + len, src + n);
    }
  slashify (dst, dst, trailing_slash_p);
}

int
mount_info::cygdrive_win32_path (const char *src, char *dst, int& unit)
{
  int res;
  const char *p = src + cygdrive_len;
  if (!isalpha (*p) || (!isdirsep (p[1]) && p[1]))
    {
      unit = -1; /* FIXME: should be zero, maybe? */
      dst[0] = '\0';
      res = 0;
    }
  else
    {
      /* drive letter must always be uppercase for casesensitive native NT. */
      dst[0] = cyg_toupper (*p);
      dst[1] = ':';
      strcpy (dst + 2, p + 1);
      backslashify (dst, dst, !dst[2]);
      unit = dst[0];
      res = 1;
    }
  debug_printf ("src '%s', dst '%s'", src, dst);
  return res;
}

/* conv_to_posix_path: Ensure src_path is a POSIX path.

   The result is zero for success, or an errno value.
   posix_path must have sufficient space (i.e. NT_MAX_PATH bytes).
   If keep_rel_p is non-zero, relative paths stay that way.  */

/* TODO: Change conv_to_posix_path to work with native paths. */

/* src_path is a wide Win32 path. */
int
mount_info::conv_to_posix_path (PWCHAR src_path, char *posix_path,
				int keep_rel_p)
{
  bool changed = false;
  if (!wcsncmp (src_path, L"\\\\?\\", 4))
    {
      src_path += 4;
      if (src_path[1] != L':') /* native UNC path */
	{
	  *(src_path += 2) = L'\\';
	  changed = true;
	}
    }
  tmp_pathbuf tp;
  char *buf = tp.c_get ();
  sys_wcstombs (buf, NT_MAX_PATH, src_path);
  int ret = conv_to_posix_path (buf, posix_path, keep_rel_p);
  if (changed)
    src_path[0] = L'C';
  return ret;
}

int
mount_info::conv_to_posix_path (const char *src_path, char *posix_path,
				int keep_rel_p)
{
  int src_path_len = strlen (src_path);
  int relative_path_p = !isabspath (src_path);
  int trailing_slash_p;

  if (src_path_len <= 1)
    trailing_slash_p = 0;
  else
    {
      const char *lastchar = src_path + src_path_len - 1;
      trailing_slash_p = isdirsep (*lastchar) && lastchar[-1] != ':';
    }

  debug_printf ("conv_to_posix_path (%s, %s, %s)", src_path,
		keep_rel_p ? "keep-rel" : "no-keep-rel",
		trailing_slash_p ? "add-slash" : "no-add-slash");
  MALLOC_CHECK;

  if (src_path_len >= NT_MAX_PATH)
    {
      debug_printf ("ENAMETOOLONG");
      return ENAMETOOLONG;
    }

  /* FIXME: For now, if the path is relative and it's supposed to stay
     that way, skip mount table processing. */

  if (keep_rel_p && relative_path_p)
    {
      slashify (src_path, posix_path, 0);
      debug_printf ("%s = conv_to_posix_path (%s)", posix_path, src_path);
      return 0;
    }

  tmp_pathbuf tp;
  char *pathbuf = tp.c_get ();
  char *tail;
  int rc = normalize_win32_path (src_path, pathbuf, tail);
  if (rc != 0)
    {
      debug_printf ("%d = conv_to_posix_path(%s)", rc, src_path);
      return rc;
    }

  int pathbuflen = tail - pathbuf;
  for (int i = 0; i < nmounts; ++i)
    {
      mount_item &mi = mount[native_sorted[i]];
      if (!path_prefix_p (mi.native_path, pathbuf, mi.native_pathlen,
			  mi.flags & MOUNT_NOPOSIX))
	continue;

      if (cygheap->root.exists () && !cygheap->root.posix_ok (mi.posix_path))
	continue;

      /* SRC_PATH is in the mount table. */
      int nextchar;
      const char *p = pathbuf + mi.native_pathlen;

      if (!*p || !p[1])
	nextchar = 0;
      else if (isdirsep (*p))
	nextchar = -1;
      else
	nextchar = 1;

      int addslash = nextchar > 0 ? 1 : 0;
      if ((mi.posix_pathlen + (pathbuflen - mi.native_pathlen) + addslash) >= NT_MAX_PATH)
	return ENAMETOOLONG;
      strcpy (posix_path, mi.posix_path);
      if (addslash)
	strcat (posix_path, "/");
      if (nextchar)
	slashify (p,
		  posix_path + addslash + (mi.posix_pathlen == 1 ? 0 : mi.posix_pathlen),
		  trailing_slash_p);

      if (cygheap->root.exists ())
	{
	  const char *p = cygheap->root.unchroot (posix_path);
	  memmove (posix_path, p, strlen (p) + 1);
	}
      goto out;
    }

  if (!cygheap->root.exists ())
    /* nothing */;
  else if (!cygheap->root.ischroot_native (pathbuf))
    return ENOENT;
  else
    {
      const char *p = pathbuf + cygheap->root.native_length ();
      if (*p)
	slashify (p, posix_path, trailing_slash_p);
      else
	{
	  posix_path[0] = '/';
	  posix_path[1] = '\0';
	}
      goto out;
    }

  /* Not in the database.  This should [theoretically] only happen if either
     the path begins with //, or / isn't mounted, or the path has a drive
     letter not covered by the mount table.  If it's a relative path then the
     caller must want an absolute path (otherwise we would have returned
     above).  So we always return an absolute path at this point. */
  if (isdrive (pathbuf))
    cygdrive_posix_path (pathbuf, posix_path, trailing_slash_p);
  else
    {
      /* The use of src_path and not pathbuf here is intentional.
	 We couldn't translate the path, so just ensure no \'s are present. */
      slashify (src_path, posix_path, trailing_slash_p);
    }

out:
  debug_printf ("%s = conv_to_posix_path (%s)", posix_path, src_path);
  MALLOC_CHECK;
  return 0;
}

/* Return flags associated with a mount point given the win32 path. */

unsigned
mount_info::set_flags_from_win32_path (const char *p)
{
  for (int i = 0; i < nmounts; i++)
    {
      mount_item &mi = mount[native_sorted[i]];
      if (path_prefix_p (mi.native_path, p, mi.native_pathlen,
			 mi.flags & MOUNT_NOPOSIX))
	return mi.flags;
    }
  return PATH_BINARY;
}

inline char *
skip_ws (char *in)
{
  while (*in == ' ' || *in == '\t')
    ++in;
  return in;
}

inline char *
find_ws (char *in)
{
  while (*in && *in != ' ' && *in != '\t')
    ++in;
  return in;
}

inline char *
conv_fstab_spaces (char *field)
{
  register char *sp = field;
  while ((sp = strstr (sp, "\\040")) != NULL)
    {
      *sp++ = ' ';
      memmove (sp, sp + 3, strlen (sp + 3) + 1);
    }
  return field;
}

struct opt
{
  const char *name;
  unsigned val;
  bool clear;
} oopts[] =
{
  {"acl", MOUNT_NOACL, 1},
  {"auto", 0, 0},
  {"binary", MOUNT_BINARY, 0},
  {"bind", MOUNT_BIND, 0},
  {"cygexec", MOUNT_CYGWIN_EXEC, 0},
  {"dos", MOUNT_DOS, 0},
  {"exec", MOUNT_EXEC, 0},
  {"ihash", MOUNT_IHASH, 0},
  {"noacl", MOUNT_NOACL, 0},
  {"nosuid", 0, 0},
  {"notexec", MOUNT_NOTEXEC, 0},
  {"nouser", MOUNT_SYSTEM, 0},
  {"override", MOUNT_OVERRIDE, 0},
  {"posix=0", MOUNT_NOPOSIX, 0},
  {"posix=1", MOUNT_NOPOSIX, 1},
  {"sparse", MOUNT_SPARSE, 0},
  {"text", MOUNT_BINARY, 1},
  {"user", MOUNT_SYSTEM, 1}
};

static int
compare_flags (const void *a, const void *b)
{
  const opt *oa = (const opt *) a;
  const opt *ob = (const opt *) b;

  return strcmp (oa->name, ob->name);
}

extern "C" bool
fstab_read_flags (char **options, unsigned &flags, bool external)
{
  opt key;

  while (**options)
    {
      char *p = strchr (*options, ',');
      if (p)
	*p++ = '\0';
      else
	p = strchr (*options, '\0');

      key.name = *options;
      opt *o = (opt *) bsearch (&key, oopts,
				sizeof oopts / sizeof (opt),
				sizeof (opt), compare_flags);
      if (!o)
	{
	  if (!external)
	    system_printf ("invalid fstab option - '%s'", *options);
	  return false;
	}
      if (o->clear)
	flags &= ~o->val;
      else
	flags |= o->val;
      *options = p;
    }
  return true;
}

extern "C" char *
fstab_list_flags ()
{
  size_t len = 0;
  opt *o;

  for (o = oopts; o < (oopts + (sizeof (oopts) / sizeof (oopts[0]))); o++)
    len += strlen (o->name) + 1;
  char *buf = (char *) malloc (len);
  if (buf)
    {
      char *bp = buf;
      for (o = oopts; o < (oopts + (sizeof (oopts) / sizeof (oopts[0]))); o++)
	{
	  bp = stpcpy (bp, o->name);
	  *bp++ = ',';
	}
      *--bp = '\0';
    }
  return buf;
}

bool
mount_info::from_fstab_line (char *line, bool user)
{
  char *native_path, *posix_path, *fs_type;

  /* First field: Native path. */
  char *c = skip_ws (line);
  if (!*c || *c == '#')
    return true;
  char *cend = find_ws (c);
  *cend = '\0';
  native_path = conv_fstab_spaces (c);
  /* Always convert drive letter to uppercase for case sensitivity. */
  if (isdrive (native_path))
    native_path[0] = cyg_toupper (native_path[0]);
  /* Second field: POSIX path. */
  c = skip_ws (cend + 1);
  if (!*c)
    return true;
  cend = find_ws (c);
  *cend = '\0';
  posix_path = conv_fstab_spaces (c);
  /* Third field: FS type. */
  c = skip_ws (cend + 1);
  if (!*c)
    return true;
  cend = find_ws (c);
  *cend = '\0';
  fs_type = c;
  /* Forth field: Flags. */
  c = skip_ws (cend + 1);
  if (!*c)
    return true;
  cend = find_ws (c);
  *cend = '\0';
  unsigned mount_flags = MOUNT_SYSTEM | MOUNT_BINARY;
  if (!strcmp (fs_type, "cygdrive"))
    mount_flags |= MOUNT_NOPOSIX;
  if (!fstab_read_flags (&c, mount_flags, false))
    return true;
  if (mount_flags & MOUNT_BIND)
    {
      /* Prepend root path to bound path. */
      char *bound_path = native_path;
      device dev;
      unsigned flags = 0;
      native_path = (char *) alloca (PATH_MAX);
      int error = conv_to_win32_path (bound_path, native_path, dev, &flags);
      if (error || strlen (native_path) >= MAX_PATH)
	return true;
      if ((mount_flags & ~MOUNT_SYSTEM) == (MOUNT_BIND | MOUNT_BINARY))
	mount_flags = (MOUNT_BIND | flags)
		      & ~(MOUNT_IMMUTABLE | MOUNT_AUTOMATIC);
    }
  if (user)
    mount_flags &= ~MOUNT_SYSTEM;
  if (!strcmp (fs_type, "cygdrive"))
    {
      cygdrive_flags = mount_flags | MOUNT_CYGDRIVE;
      slashify (posix_path, cygdrive, 1);
      cygdrive_len = strlen (cygdrive);
    }
  else
    {
      int res = mount_table->add_item (native_path, posix_path, mount_flags);
      if (res && get_errno () == EMFILE)
	return false;
    }
  return true;
}

bool
mount_info::from_fstab (bool user, WCHAR fstab[], PWCHAR fstab_end)
{
  UNICODE_STRING upath;
  OBJECT_ATTRIBUTES attr;
  NT_readline rl;
  tmp_pathbuf tp;
  char *buf = tp.c_get ();

  if (user)
    {
      PWCHAR username;
      sys_mbstowcs (username = wcpcpy (fstab_end, L".d\\"),
		    NT_MAX_PATH - (fstab_end - fstab),
		    cygheap->user.name ());
      /* Make sure special chars in the username are converted according to
	 the rules. */
      transform_chars (username, username + wcslen (username) - 1);
    }
  RtlInitUnicodeString (&upath, fstab);
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
  debug_printf ("Try to read mounts from %W", fstab);
  if (rl.init (&attr, buf, NT_MAX_PATH))
    while ((buf = rl.gets ()))
      if (!from_fstab_line (buf, user))
	break;
  return true;
}

/* write_cygdrive_info: Store default prefix and flags
   to use when creating cygdrives to the special user shared mem
   location used to store cygdrive information. */

int
mount_info::write_cygdrive_info (const char *cygdrive_prefix, unsigned flags)
{
  /* Verify cygdrive prefix starts with a forward slash and if there's
     another character, it's not a slash. */
  if ((cygdrive_prefix == NULL) || (*cygdrive_prefix == 0) ||
      (!isslash (cygdrive_prefix[0])) ||
      ((cygdrive_prefix[1] != '\0') && (isslash (cygdrive_prefix[1]))))
    {
      set_errno (EINVAL);
      return -1;
    }
  /* Don't allow overriding of a system cygdrive prefix. */
  if (cygdrive_flags & MOUNT_SYSTEM)
    {
      set_errno (EPERM);
      return -1;
    }

  slashify (cygdrive_prefix, cygdrive, 1);
  cygdrive_flags = flags & ~MOUNT_SYSTEM;
  cygdrive_len = strlen (cygdrive);

  return 0;
}

int
mount_info::get_cygdrive_info (char *user, char *system, char *user_flags,
			       char *system_flags)
{
  if (user)
    *user = '\0';
  if (system)
    *system = '\0';
  if (user_flags)
    *user_flags = '\0';
  if (system_flags)
    *system_flags = '\0';

  char *path = (cygdrive_flags & MOUNT_SYSTEM) ? system : user;
  char *flags = (cygdrive_flags & MOUNT_SYSTEM) ? system_flags : user_flags;

  if (path)
    {
      strcpy (path, cygdrive);
      /* Strip trailing slash for backward compatibility. */
      if (cygdrive_len > 2)
	path[cygdrive_len - 1] = '\0';
    }
  if (flags)
    strcpy (flags, (cygdrive_flags & MOUNT_BINARY) ? "binmode" : "textmode");
  return 0;
}

static mount_item *mounts_for_sort;

/* sort_by_posix_name: qsort callback to sort the mount entries.  Sort
   user mounts ahead of system mounts to the same POSIX path. */
/* FIXME: should the user should be able to choose whether to
   prefer user or system mounts??? */
static int
sort_by_posix_name (const void *a, const void *b)
{
  mount_item *ap = mounts_for_sort + (*((int*) a));
  mount_item *bp = mounts_for_sort + (*((int*) b));

  /* Base weighting on longest posix path first so that the most
     obvious path will be chosen. */
  size_t alen = strlen (ap->posix_path);
  size_t blen = strlen (bp->posix_path);

  int res = blen - alen;

  if (res)
    return res;		/* Path lengths differed */

  /* The two paths were the same length, so just determine normal
     lexical sorted order. */
  res = strcmp (ap->posix_path, bp->posix_path);

  if (res == 0)
   {
     /* need to select between user and system mount to same POSIX path */
     if (!(bp->flags & MOUNT_SYSTEM))	/* user mount */
      return 1;
     else
      return -1;
   }

  return res;
}

/* sort_by_native_name: qsort callback to sort the mount entries.  Sort
   user mounts ahead of system mounts to the same POSIX path. */
/* FIXME: should the user should be able to choose whether to
   prefer user or system mounts??? */
static int
sort_by_native_name (const void *a, const void *b)
{
  mount_item *ap = mounts_for_sort + (*((int*) a));
  mount_item *bp = mounts_for_sort + (*((int*) b));

  /* Base weighting on longest win32 path first so that the most
     obvious path will be chosen. */
  size_t alen = strlen (ap->native_path);
  size_t blen = strlen (bp->native_path);

  int res = blen - alen;

  if (res)
    return res;		/* Path lengths differed */

  /* The two paths were the same length, so just determine normal
     lexical sorted order. */
  res = strcmp (ap->native_path, bp->native_path);

  if (res == 0)
   {
     /* need to select between user and system mount to same POSIX path */
     if (!(bp->flags & MOUNT_SYSTEM))	/* user mount */
      return 1;
     else
      return -1;
   }

  return res;
}

void
mount_info::sort ()
{
  for (int i = 0; i < nmounts; i++)
    native_sorted[i] = posix_sorted[i] = i;
  /* Sort them into reverse length order, otherwise we won't
     be able to look for /foo in /.  */
  mounts_for_sort = mount;	/* ouch. */
  qsort (posix_sorted, nmounts, sizeof (posix_sorted[0]), sort_by_posix_name);
  qsort (native_sorted, nmounts, sizeof (native_sorted[0]), sort_by_native_name);
}

/* Add an entry to the mount table.
   Returns 0 on success, -1 on failure and errno is set.

   This is where all argument validation is done.  It may not make sense to
   do this when called internally, but it's cleaner to keep it all here.  */

int
mount_info::add_item (const char *native, const char *posix,
		      unsigned mountflags)
{
  tmp_pathbuf tp;
  char *nativetmp = tp.c_get ();
  /* FIXME: The POSIX path is stored as value name right now, which is
     restricted to 256 bytes. */
  char posixtmp[CYG_MAX_PATH];
  char *nativetail, *posixtail, error[] = "error";
  int nativeerr, posixerr;

  /* Something's wrong if either path is NULL or empty, or if it's
     not a UNC or absolute path. */

  if (native == NULL || !isabspath (native) ||
      !(is_native_path (native) || is_unc_share (native) || isdrive (native)))
    nativeerr = EINVAL;
  else
    nativeerr = normalize_win32_path (native, nativetmp, nativetail);

  if (posix == NULL || !isabspath (posix) ||
      is_unc_share (posix) || isdrive (posix))
    posixerr = EINVAL;
  else
    posixerr = normalize_posix_path (posix, posixtmp, posixtail);

  debug_printf ("%s[%s], %s[%s], %y",
		native, nativeerr ? error : nativetmp,
		posix, posixerr ? error : posixtmp, mountflags);

  if (nativeerr || posixerr)
    {
      set_errno (nativeerr ?: posixerr);
      return -1;
    }

  /* Make sure both paths do not end in /. */
  if (nativetail > nativetmp + 1 && nativetail[-1] == '\\')
    nativetail[-1] = '\0';
  if (posixtail > posixtmp + 1 && posixtail[-1] == '/')
    posixtail[-1] = '\0';

  /* Write over an existing mount item with the same POSIX path if
     it exists and is from the same registry area. */
  int i;
  for (i = 0; i < nmounts; i++)
    {
      if (!strcmp (mount[i].posix_path, posixtmp))
	{
	  /* Don't allow overriding of a system mount with a user mount. */
	  if ((mount[i].flags & MOUNT_SYSTEM) && !(mountflags & MOUNT_SYSTEM))
	    {
	      set_errno (EPERM);
	      return -1;
	    }
	  if ((mount[i].flags & MOUNT_SYSTEM) != (mountflags & MOUNT_SYSTEM))
	    continue;
	  else if (!(mount[i].flags & MOUNT_IMMUTABLE))
	    break;
	  else if (mountflags & MOUNT_OVERRIDE)
	    {
	      mountflags |= MOUNT_IMMUTABLE;
	      break;
	    }
	  else
	    {
	      set_errno (EPERM);
	      return -1;
	    }
	}
    }

  if (i == nmounts && nmounts == MAX_MOUNTS)
    {
      set_errno (EMFILE);
      return -1;
    }

  if (i == nmounts)
    nmounts++;

  if (strcmp (posixtmp, "/usr/bin") == 0)
    got_usr_bin = true;

  if (strcmp (posixtmp, "/usr/lib") == 0)
    got_usr_lib = true;

  if (posixtmp[0] == '/' && posixtmp[1] == '\0' && !(mountflags & MOUNT_CYGDRIVE))
    root_idx = i;

  mount[i].init (nativetmp, posixtmp, mountflags);
  sort ();

  return 0;
}

/* Delete a mount table entry where path is either a Win32 or POSIX
   path. Since the mount table is really just a table of aliases,
   deleting / is ok (although running without a slash mount is
   strongly discouraged because some programs may run erratically
   without one).  If MOUNT_SYSTEM is set in flags, remove from system
   registry, otherwise remove the user registry mount.
*/

int
mount_info::del_item (const char *path, unsigned flags)
{
  tmp_pathbuf tp;
  char *pathtmp = tp.c_get ();
  int posix_path_p = false;

  /* Something's wrong if path is NULL or empty. */
  if (path == NULL || *path == 0 || !isabspath (path))
    {
      set_errno (EINVAL);
      return -1;
    }

  if (is_unc_share (path) || strpbrk (path, ":\\"))
    backslashify (path, pathtmp, 0);
  else
    {
      slashify (path, pathtmp, 0);
      posix_path_p = true;
    }
  nofinalslash (pathtmp, pathtmp);

  for (int i = 0; i < nmounts; i++)
    {
      int ent = native_sorted[i]; /* in the same order as getmntent() */
      if (((posix_path_p)
	   ? !strcmp (mount[ent].posix_path, pathtmp)
	   : strcasematch (mount[ent].native_path, pathtmp)))
	{
	  /* Don't allow removal of a system mount. */
	  if (mount[ent].flags & MOUNT_SYSTEM)
	    {
	      set_errno (EPERM);
	      return -1;
	    }
	  nmounts--; /* One less mount table entry */
	  /* Fill in the hole if not at the end of the table */
	  if (ent < nmounts)
	    memmove (mount + ent, mount + ent + 1,
		     sizeof (mount[ent]) * (nmounts - ent));
	  sort (); /* Resort the table */
	  return 0;
	}
    }
  set_errno (EINVAL);
  return -1;
}

/************************* mount_item class ****************************/

/* Don't add new fs types without adding them to fs_info_type in mount.h!
   Don't reorder without reordering fs_info_type in mount.h!*/
fs_names_t fs_names[] = {
    { "none", false },
    { "vfat", true },
    { "ntfs", true },
    { "refs", true },
    { "smbfs", false },
    { "nfs", false },
    { "netapp", false },
    { "iso9660", true },
    { "udf", true },
    { "csc-cache", false },
    { "sunwnfs", false },
    { "unixfs", false },
    { "mvfs", false },
    { "cifs", false },
    { "nwfs", false },
    { "ncfsd", false },
    { "afs", false },
    { NULL, false }
};

static mntent *
fillout_mntent (const char *native_path, const char *posix_path, unsigned flags)
{
  struct mntent& ret=_my_tls.locals.mntbuf;
  bool append_bs = false;

  /* Remove drivenum from list if we see a x: style path */
  if (strlen (native_path) == 2 && native_path[1] == ':')
    {
      int drivenum = cyg_tolower (native_path[0]) - 'a';
      if (drivenum >= 0 && drivenum <= 31)
	_my_tls.locals.available_drives &= ~(1 << drivenum);
      append_bs = true;
    }

  /* Pass back pointers to mount_table strings reserved for use by
     getmntent rather than pointers to strings in the internal mount
     table because the mount table might change, causing weird effects
     from the getmntent user's point of view. */

  ret.mnt_fsname = _my_tls.locals.mnt_fsname;
  strcpy (_my_tls.locals.mnt_dir, posix_path);
  ret.mnt_dir = _my_tls.locals.mnt_dir;

  /* Try to give a filesystem type that matches what a Linux application might
     expect. Naturally, this is a moving target, but we can make some
     reasonable guesses for popular types. */

  fs_info mntinfo;
  tmp_pathbuf tp;
  UNICODE_STRING unat;
  tp.u_get (&unat);
  get_nt_native_path (native_path, unat, false);
  if (append_bs)
    RtlAppendUnicodeToString (&unat, L"\\");
  mntinfo.update (&unat, NULL);

  if (mntinfo.what_fs () > none && mntinfo.what_fs () < max_fs_type)
    strcpy (_my_tls.locals.mnt_type, fs_names[mntinfo.what_fs ()].name);
  else
    strcpy (_my_tls.locals.mnt_type, mntinfo.fsname ());

  ret.mnt_type = _my_tls.locals.mnt_type;

  slashify (native_path, _my_tls.locals.mnt_fsname, false);

  /* mnt_opts is a string that details mount params such as
     binary or textmode, or exec.  We don't print
     `silent' here; it's a magic internal thing. */

  if (!(flags & MOUNT_BINARY))
    strcpy (_my_tls.locals.mnt_opts, (char *) "text");
  else
    strcpy (_my_tls.locals.mnt_opts, (char *) "binary");

  if (flags & MOUNT_CYGWIN_EXEC)
    strcat (_my_tls.locals.mnt_opts, (char *) ",cygexec");
  else if (flags & MOUNT_EXEC)
    strcat (_my_tls.locals.mnt_opts, (char *) ",exec");
  else if (flags & MOUNT_NOTEXEC)
    strcat (_my_tls.locals.mnt_opts, (char *) ",notexec");

  if (flags & MOUNT_NOACL)
    strcat (_my_tls.locals.mnt_opts, (char *) ",noacl");

  if (flags & MOUNT_DOS)
    strcat (_my_tls.locals.mnt_opts, (char *) ",dos");

  if (flags & MOUNT_IHASH)
    strcat (_my_tls.locals.mnt_opts, (char *) ",ihash");

  if (flags & MOUNT_NOPOSIX)
    strcat (_my_tls.locals.mnt_opts, (char *) ",posix=0");

  if (flags & MOUNT_SPARSE)
    strcat (_my_tls.locals.mnt_opts, (char *) ",sparse");

  if (!(flags & MOUNT_SYSTEM))		/* user mount */
    strcat (_my_tls.locals.mnt_opts, (char *) ",user");

  if (flags & MOUNT_CYGDRIVE)		/* cygdrive */
    strcat (_my_tls.locals.mnt_opts, (char *) ",noumount");

  if (flags & (MOUNT_AUTOMATIC | MOUNT_CYGDRIVE))
    strcat (_my_tls.locals.mnt_opts, (char *) ",auto");

  if (flags & (MOUNT_BIND))
    strcat (_my_tls.locals.mnt_opts, (char *) ",bind");

  ret.mnt_opts = _my_tls.locals.mnt_opts;

  ret.mnt_freq = 1;
  ret.mnt_passno = 1;
  return &ret;
}

struct mntent *
mount_item::getmntent ()
{
  return fillout_mntent (native_path, posix_path, flags);
}

static struct mntent *
cygdrive_getmntent ()
{
  char native_path[4];
  char posix_path[CYG_MAX_PATH];
  DWORD mask = 1, drive = 'a';
  struct mntent *ret = NULL;

  while (_my_tls.locals.available_drives)
    {
      for (/* nothing */; drive <= 'z'; mask <<= 1, drive++)
	if (_my_tls.locals.available_drives & mask)
	  break;

      __small_sprintf (native_path, "%c:\\", cyg_toupper (drive));
      if (GetFileAttributes (native_path) == INVALID_FILE_ATTRIBUTES)
	{
	  _my_tls.locals.available_drives &= ~mask;
	  continue;
	}
      native_path[2] = '\0';
      __small_sprintf (posix_path, "%s%c", mount_table->cygdrive, drive);
      ret = fillout_mntent (native_path, posix_path, mount_table->cygdrive_flags);
      break;
    }

  return ret;
}

struct mntent *
mount_info::getmntent (int x)
{
  if (x < 0 || x >= nmounts)
    return cygdrive_getmntent ();

  return mount[native_sorted[x]].getmntent ();
}

/* Fill in the fields of a mount table entry.  */

void
mount_item::init (const char *native, const char *posix, unsigned mountflags)
{
  strcpy ((char *) native_path, native);
  strcpy ((char *) posix_path, posix);

  native_pathlen = strlen (native_path);
  posix_pathlen = strlen (posix_path);

  flags = mountflags;
}

/********************** Mount System Calls **************************/

/* Mount table system calls.
   Note that these are exported to the application.  */

/* mount: Add a mount to the mount table in memory and to the registry
   that will cause paths under win32_path to be translated to paths
   under posix_path. */

extern "C" int
mount (const char *win32_path, const char *posix_path, unsigned flags)
{
  /* FIXME: Should we disallow setting MOUNT_SYSTEM in flags since it
     isn't really supported except from fstab? */
  int res = -1;

  __try
    {
      if (!*posix_path)
	set_errno (EINVAL);
      else if (strpbrk (posix_path, "\\:"))
	set_errno (EINVAL);
      else if (flags & MOUNT_CYGDRIVE) /* normal mount */
	{
	  /* When flags include MOUNT_CYGDRIVE, take this to mean that
	    we actually want to change the cygdrive prefix and flags
	    without actually mounting anything. */
	  res = mount_table->write_cygdrive_info (posix_path, flags);
	  win32_path = NULL;
	}
      else if (!*win32_path)
	set_errno (EINVAL);
      else
	{
	  char *w32_path = (char *) win32_path;
	  if (flags & MOUNT_BIND)
	    {
	      /* Prepend root path to bound path. */
	      tmp_pathbuf tp;
	      device dev;

	      unsigned conv_flags = 0;
	      const char *bound_path = w32_path;

	      w32_path = tp.c_get ();
	      int error = mount_table->conv_to_win32_path (bound_path, w32_path,
							   dev, &conv_flags);
	      if (error || strlen (w32_path) >= MAX_PATH)
		return true;
	      if ((flags & ~MOUNT_SYSTEM) == (MOUNT_BIND | MOUNT_BINARY))
		flags = (MOUNT_BIND | conv_flags)
			& ~(MOUNT_IMMUTABLE | MOUNT_AUTOMATIC);
	    }
	  /* Make sure all mounts are user mounts, even those added via
	     mount -a. */
	  flags &= ~MOUNT_SYSTEM;
	  res = mount_table->add_item (w32_path, posix_path, flags);
	}

      syscall_printf ("%R = mount(%s, %s, %y)",
		      res, win32_path, posix_path, flags);
    }
  __except (EFAULT) {}
  __endtry
  return res;
}

/* umount: The standard umount call only has a path parameter.  Since
   it is not possible for this call to specify whether to remove the
   mount from the user or global mount registry table, assume the user
   table. */

extern "C" int
umount (const char *path)
{
  __try
    {
      if (!*path)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      return cygwin_umount (path, 0);
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

/* cygwin_umount: This is like umount but takes an additional flags
   parameter that specifies whether to umount from the user or system-wide
   registry area. */

extern "C" int
cygwin_umount (const char *path, unsigned flags)
{
  int res = -1;

  if (!(flags & MOUNT_CYGDRIVE))
    res = mount_table->del_item (path, flags & ~MOUNT_SYSTEM);

  syscall_printf ("%R = cygwin_umount(%s, %d)", res,  path, flags);
  return res;
}

#define is_dev(d,s)	wcsncmp((d),(s),sizeof(s) - 1)

disk_type
get_disk_type (LPCWSTR dos)
{
  WCHAR dev[MAX_PATH], *d = dev;
  if (!QueryDosDeviceW (dos, dev, MAX_PATH))
    return DT_NODISK;
  if (is_dev (dev, L"\\Device\\"))
    {
      d += 8;
      switch (*d)
	{
	case L'C':
	  if (is_dev (d, L"CdRom"))
	    return DT_CDROM;
	  break;
	case L'F':
	  if (is_dev (d, L"Floppy"))
	    return DT_FLOPPY;
	  break;
	case L'H':
	  if (is_dev (d, L"Harddisk"))
	    return DT_HARDDISK;
	  break;
	case L'L':
	  if (is_dev (d, L"LanmanRedirector\\"))
	    return DT_SHARE_SMB;
	  break;
	case L'M':
	  if (is_dev (d, L"MRxNfs\\"))
	    return DT_SHARE_NFS;
	  break;
	}
    }
  return DT_NODISK;
}

extern "C" FILE *
setmntent (const char *filep, const char *)
{
  _my_tls.locals.iteration = 0;
  _my_tls.locals.available_drives = GetLogicalDrives ();
  /* Filter floppy drives on A: and B: */
  if ((_my_tls.locals.available_drives & 1)
      && get_disk_type (L"A:") == DT_FLOPPY)
    _my_tls.locals.available_drives &= ~1;
  if ((_my_tls.locals.available_drives & 2)
      && get_disk_type (L"B:") == DT_FLOPPY)
    _my_tls.locals.available_drives &= ~2;
  return (FILE *) filep;
}

extern "C" struct mntent *
getmntent (FILE *)
{
  return mount_table->getmntent (_my_tls.locals.iteration++);
}

extern "C" struct mntent *
getmntent_r (FILE *, struct mntent *mntbuf, char *buf, int buflen)
{
  struct mntent *mnt = mount_table->getmntent (_my_tls.locals.iteration++);
  int fsname_len, dir_len, type_len, tmplen = buflen;

  if (!mnt)
    return NULL;

  fsname_len = strlen (mnt->mnt_fsname) + 1;
  dir_len = strlen (mnt->mnt_dir) + 1;
  type_len = strlen (mnt->mnt_type) + 1;

  snprintf (buf, buflen, "%s%c%s%c%s%c%s", mnt->mnt_fsname, '\0',
	    mnt->mnt_dir, '\0', mnt->mnt_type, '\0', mnt->mnt_opts);

  mntbuf->mnt_fsname = buf;
  tmplen -= fsname_len;
  mntbuf->mnt_dir = tmplen > 0 ? buf + fsname_len : (char *)"";
  tmplen -= dir_len;
  mntbuf->mnt_type = tmplen > 0 ? buf + fsname_len + dir_len : (char *)"";
  tmplen -= type_len;
  mntbuf->mnt_opts = tmplen > 0 ? buf + fsname_len + dir_len + type_len : (char *)"";
  mntbuf->mnt_freq = mnt->mnt_freq;
  mntbuf->mnt_passno = mnt->mnt_passno;
  return mntbuf;
}

extern "C" int
endmntent (FILE *)
{
  return 1;
}

dos_drive_mappings::dos_drive_mappings ()
: mappings(0)
{
  tmp_pathbuf tp;
  wchar_t vol[64]; /* Long enough for Volume GUID string */
  wchar_t *devpath = tp.w_get ();
  wchar_t *mounts = tp.w_get ();

  /* Iterate over all volumes, fetch the first path from the list of
     DOS paths the volume is mounted to, or use the GUID volume path
     otherwise. */
  HANDLE sh = FindFirstVolumeW (vol, 64);
  if (sh == INVALID_HANDLE_VALUE)
    debug_printf ("FindFirstVolumeW, %E");
  else
    do
      {
	/* Skip drives which are not mounted. */
	DWORD len;
	if (!GetVolumePathNamesForVolumeNameW (vol, mounts, NT_MAX_PATH, &len)
	    || mounts[0] == L'\0')
	  continue;
	*wcsrchr (vol, L'\\') = L'\0';
	if (QueryDosDeviceW (vol + 4, devpath, NT_MAX_PATH))
	  {
	    /* The DOS drive mapping can be another symbolic link.  If so,
	       the mapping won't work since the section name is the name
	       after resolving all symlinks.  Resolve symlinks here, too. */
	    for (int syml_cnt = 0; syml_cnt < SYMLOOP_MAX; ++syml_cnt)
	      {
		UNICODE_STRING upath;
		OBJECT_ATTRIBUTES attr;
		NTSTATUS status;
		HANDLE h;

		RtlInitUnicodeString (&upath, devpath);
		InitializeObjectAttributes (&attr, &upath,
					    OBJ_CASE_INSENSITIVE, NULL, NULL);
		status = NtOpenSymbolicLinkObject (&h, SYMBOLIC_LINK_QUERY,
						   &attr);
		if (!NT_SUCCESS (status))
		  break;
		RtlInitEmptyUnicodeString (&upath, devpath, (NT_MAX_PATH - 1)
							    * sizeof (WCHAR));
		status = NtQuerySymbolicLinkObject (h, &upath, NULL);
		NtClose (h);
		if (!NT_SUCCESS (status))
		  break;
		devpath[upath.Length / sizeof (WCHAR)] = L'\0';
	      }
	    mapping *m = new mapping ();
	    if (m)
	      {
		m->dospath = wcsdup (mounts);
		m->ntdevpath = wcsdup (devpath);
		if (!m->dospath || !m->ntdevpath)
		  {
		    free (m->dospath);
		    free (m->ntdevpath);
		    delete m;
		    continue;
		  }
		m->doslen = wcslen (m->dospath);
		m->dospath[--m->doslen] = L'\0'; /* Drop trailing backslash */
		m->ntlen = wcslen (m->ntdevpath);
		m->next = mappings;
		mappings = m;
	      }
	  }
	else
	  debug_printf ("Unable to determine the native mapping for %ls "
			"(error %u)", vol, GetLastError ());
      }
    while (FindNextVolumeW (sh, vol, 64));
    FindVolumeClose (sh);
}

wchar_t *
dos_drive_mappings::fixup_if_match (wchar_t *path)
{
  /* Check for network drive first. */
  if (!wcsncmp (path, L"\\Device\\Mup\\", 12))
    {
      path += 10;
      path[0] = L'\\';
      return path;
    }
  /* Then test local drives. */
  for (mapping *m = mappings; m; m = m->next)
    if (!wcsncmp (m->ntdevpath, path, m->ntlen))
      {
	wchar_t *tmppath;

	if (m->ntlen > m->doslen)
	  wcsncpy (path += m->ntlen - m->doslen, m->dospath, m->doslen);
	else if ((tmppath = wcsdup (path + m->ntlen)) != NULL)
	  {
	    wcpcpy (wcpcpy (path, m->dospath), tmppath);
	    free (tmppath);
	  }
	break;
      }
  return path;
}

dos_drive_mappings::~dos_drive_mappings ()
{
  mapping *n = 0;
  for (mapping *m = mappings; m; m = n)
    {
      n = m->next;
      free (m->dospath);
      free (m->ntdevpath);
      delete m;
    }
}
@


1.106
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d471 1
a471 1
mount_info::init ()
d477 3
a479 1
  create_root_entry (path);
d481 1
d483 1
a483 4
  from_fstab (false, path, pathend);
  from_fstab (true, path, pathend);

  if (!got_usr_bin || !got_usr_lib)
@


1.105
log
@	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).
@
text
@d1703 1
a1703 8
  myfault efault;
  if (efault.faulted (EFAULT))
    /* errno set */;
  else if (!*posix_path)
    set_errno (EINVAL);
  else if (strpbrk (posix_path, "\\:"))
    set_errno (EINVAL);
  else if (flags & MOUNT_CYGDRIVE) /* normal mount */
d1705 15
a1719 12
      /* When flags include MOUNT_CYGDRIVE, take this to mean that
	we actually want to change the cygdrive prefix and flags
	without actually mounting anything. */
      res = mount_table->write_cygdrive_info (posix_path, flags);
      win32_path = NULL;
    }
  else if (!*win32_path)
    set_errno (EINVAL);
  else
    {
      char *w32_path = (char *) win32_path;
      if (flags & MOUNT_BIND)
d1721 23
a1743 15
	  /* Prepend root path to bound path. */
	  tmp_pathbuf tp;
	  device dev;

	  unsigned conv_flags = 0;
	  const char *bound_path = w32_path;

	  w32_path = tp.c_get ();
	  int error = mount_table->conv_to_win32_path (bound_path, w32_path,
						       dev, &conv_flags);
	  if (error || strlen (w32_path) >= MAX_PATH)
	    return true;
	  if ((flags & ~MOUNT_SYSTEM) == (MOUNT_BIND | MOUNT_BINARY))
	    flags = (MOUNT_BIND | conv_flags)
		    & ~(MOUNT_IMMUTABLE | MOUNT_AUTOMATIC);
d1745 3
a1747 3
      /* Make sure all mounts are user mounts, even those added via mount -a. */
      flags &= ~MOUNT_SYSTEM;
      res = mount_table->add_item (w32_path, posix_path, flags);
d1749 2
a1750 2

  syscall_printf ("%R = mount(%s, %s, %y)", res, win32_path, posix_path, flags);
d1762 1
a1762 4
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (!*path)
d1764 6
a1769 2
      set_errno (EINVAL);
      return -1;
d1771 3
a1773 1
  return cygwin_umount (path, 0);
@


1.104
log
@	* miscfuncs.h (class NT_readline): New class to implement line-wise
	reading from file using native NT functions.
	* miscfuncs.cc (NT_readline::init): New method.
	* mount.cc (mount_info::from_fstab): Utilize NT_readline to read
	fstab files.
@
text
@d180 1
d184 3
a191 3
      /* Always caseinsensitive.  We really just need access to the drive. */
      InitializeObjectAttributes (&attr, upath, OBJ_CASE_INSENSITIVE, NULL,
				  NULL);
a208 1
	  UNICODE_STRING dir;
@


1.103
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchown): Fix typo in
	comment.
	* mount.cc (mount_info::from_fstab): Use tmp_pathbuf rather than
	stack for big local buffer.
	* net.cc (cygwin_gethostname): Call GetComputerNameExA rather than
	GetComputerNameA if gethostname failed.
	* shared.cc (user_info::initialize): Fix formatting.
	* include/sys/file.h: Define flock and accompanying macros if not
	already defined in sys/_default_fcntl.h.
@
text
@d1180 1
a1180 3
  IO_STATUS_BLOCK io;
  NTSTATUS status;
  HANDLE fh;
d1182 1
d1197 3
a1199 39
  status = NtOpenFile (&fh, SYNCHRONIZE | FILE_READ_DATA, &attr, &io,
		       FILE_SHARE_VALID_FLAGS,
		       FILE_SYNCHRONOUS_IO_NONALERT
		       | FILE_OPEN_FOR_BACKUP_INTENT);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtOpenFile(%S) failed, %y", &upath, status);
      return false;
    }

  char *buf = tp.c_get ();
  char *got = buf;
  DWORD len = 0;
  unsigned line = 1;
  /* Using buffer size - 2 leaves space to append two \0. */
  while (NT_SUCCESS (NtReadFile (fh, NULL, NULL, NULL, &io, got,
				 (NT_MAX_PATH - 2) - (got - buf), NULL, NULL)))
    {
      char *end;

      len = io.Information;
      /* Set end marker. */
      got[len] = got[len + 1] = '\0';
      /* Set len to the absolute len of bytes in buf. */
      len += got - buf;
      /* Reset got to start reading at the start of the buffer again. */
      got = buf;
retry:
      bool got_nl = false;
      while (got < buf + len && (end = strchr (got, '\n')))
	{
	  got_nl = true;
	  end[end[-1] == '\r' ? -1 : 0] = '\0';
	  if (!from_fstab_line (got, user))
	    goto done;
	  got = end + 1;
	  ++line;
	}
      if (len < (NT_MAX_PATH - 2))
a1200 35
      /* Check if the buffer contained at least one \n.  If not, the
	 line length is > 32K.  We don't take such long lines.  Print
	 a debug message and skip this line entirely. */
      if (!got_nl)
	{
	  system_printf ("%W: Line %d too long, skipping...", fstab, line);
	  while (NT_SUCCESS (NtReadFile (fh, NULL, NULL, NULL, &io, buf,
					 (NT_MAX_PATH - 2), NULL, NULL)))
	    {
	      len = io.Information;
	      buf[len] = buf[len + 1] = '\0';
	      got = strchr (buf, '\n');
	      if (got)
		{
		  ++got;
		  ++line;
		  goto retry;
		}
	    }
	  got = buf;
	  break;
	}
      /* We have to read once more.  Move remaining bytes to the start of
	 the buffer and reposition got so that it points to the end of
	 the remaining bytes. */
      len = buf + len - got;
      memmove (buf, got, len);
      got = buf + len;
      buf[len] = buf[len + 1] = '\0';
    }
  /* Catch a last line without trailing \n. */
  if (got > buf)
    from_fstab_line (got, user);
done:
  NtClose (fh);
@


1.103.2.1
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@a179 1
  UNICODE_STRING dir;
a182 3
  /* Always caseinsensitive.  We really just need access to the drive. */
  InitializeObjectAttributes (&attr, upath, OBJ_CASE_INSENSITIVE, NULL,
			      NULL);
d188 3
d208 1
@


1.103.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d1775 8
a1782 1
  __try
d1784 12
a1795 5
      if (!*posix_path)
	set_errno (EINVAL);
      else if (strpbrk (posix_path, "\\:"))
	set_errno (EINVAL);
      else if (flags & MOUNT_CYGDRIVE) /* normal mount */
d1797 15
a1811 33
	  /* When flags include MOUNT_CYGDRIVE, take this to mean that
	    we actually want to change the cygdrive prefix and flags
	    without actually mounting anything. */
	  res = mount_table->write_cygdrive_info (posix_path, flags);
	  win32_path = NULL;
	}
      else if (!*win32_path)
	set_errno (EINVAL);
      else
	{
	  char *w32_path = (char *) win32_path;
	  if (flags & MOUNT_BIND)
	    {
	      /* Prepend root path to bound path. */
	      tmp_pathbuf tp;
	      device dev;

	      unsigned conv_flags = 0;
	      const char *bound_path = w32_path;

	      w32_path = tp.c_get ();
	      int error = mount_table->conv_to_win32_path (bound_path, w32_path,
							   dev, &conv_flags);
	      if (error || strlen (w32_path) >= MAX_PATH)
		return true;
	      if ((flags & ~MOUNT_SYSTEM) == (MOUNT_BIND | MOUNT_BINARY))
		flags = (MOUNT_BIND | conv_flags)
			& ~(MOUNT_IMMUTABLE | MOUNT_AUTOMATIC);
	    }
	  /* Make sure all mounts are user mounts, even those added via
	     mount -a. */
	  flags &= ~MOUNT_SYSTEM;
	  res = mount_table->add_item (w32_path, posix_path, flags);
d1813 4
d1818 1
a1818 5
      syscall_printf ("%R = mount(%s, %s, %y)",
		      res, win32_path, posix_path, flags);
    }
  __except (EFAULT) {}
  __endtry
d1830 4
a1833 1
  __try
d1835 2
a1836 6
      if (!*path)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      return cygwin_umount (path, 0);
d1838 1
a1838 3
  __except (EFAULT) {}
  __endtry
  return -1;
@


1.102
log
@	* mount.cc (fs_info::update): Fix formatting.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d1183 1
d1208 1
a1208 1
  char buf[NT_MAX_PATH];
d1214 1
a1214 1
				 (sizeof (buf) - 2) - (got - buf), NULL, NULL)))
d1236 1
a1236 1
      if (len < (sizeof (buf) - 2))
d1245 1
a1245 1
					 (sizeof (buf) - 2), NULL, NULL)))
@


1.101
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d267 2
a268 2
   flags (ffai_buf.ffai.FileSystemAttributes);
   name_len (ffai_buf.ffai.MaximumComponentNameLength);
@


1.100
log
@	* autoload.cc (CreateSymbolicLink): Define.
	* environ.cc (set_winsymlinks): Set allow_winsymlinks.
	(parse_thing): Change "winsymlinks" to set by function.
	* globals.cc (enum winsym_t): Define.
	(allow_winsymlinks): Define as winsym_t.
	(ro_u_afs): New R/O Unicode string.
	* mount.cc (fs_info::update): Fix comment.  Handle AFS.
	(fs_names): Add "afs".
	* mount.h (enum fs_info_type): Add afs.
	(class fs_info): Implement afs.
	* path.cc (symlink): Drop third parameter in call to symlink_worker.
	(symlink_nfs): New function.
	(symlink_native): New function.
	(symlink_worker): Drop third argument.  Handle native symlink type by
	calling symlink_native.  Move code to handle NFS to symlink_nfs.  Fix
	formatting.  Slightly restructure code.
	* path.h (class path_conv): Add fs_is_afs method.
	(symlink_worker): Declare here.
	* security.h: Define privilege constants as unsigned int instead of as
	unsigned long.
	* syscalls.cc (mknod_worker): Set third parameter in symlink_worker
	call to WSYM_lnk.
	* winsup.h (symlink_worker): Drop declaration here.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
a16 4
#include <wingdi.h>
#include <winuser.h>
#include <winnetwk.h>
#include <shlobj.h>
@


1.99
log
@	* Merge in cygwin-64bit-branch.
@
text
@d278 1
a278 1
   to Vista.  The important point here is to test only flags indicating
d374 4
a377 1
	  && !is_unixfs (RtlEqualUnicodeString (&fsname, &ro_u_unixfs, FALSE)))
d1604 1
@


1.98
log
@	* mount.cc (fs_names): Add trailing NULL element to avoid potential
	SEGV in format_proc_filesystems.
@
text
@d227 1
a227 1
	  debug_printf ("Cannot access path %S, status %08lx",
d265 1
a265 1
      debug_printf ("Cannot get volume attributes (%S), %08lx",
d309 3
a311 3
/* These are the minimal flags supported by NTFS since NT4.  Every filesystem
   not supporting these flags is not a native NTFS.  We subsume them under
   the filesystem type "cifs". */
d316 7
a322 1
				| FILE_FILE_COMPRESSION)
d488 1
a488 1
	api_fatal ("root_idx %d, user_shared magic %p, nmounts %d", root_idx, user_shared->version, nmounts);
d512 1
a512 1
      debug_printf ("flags: text (%p)", *flags & (PATH_TEXT | PATH_BINARY));
d517 1
a517 1
      debug_printf ("flags: binary (%p)", *flags & (PATH_TEXT | PATH_BINARY));
d726 1
a726 1
  debug_printf ("src_path %s, dst %s, flags %p, rc %d", src_path, dst, *flags, rc);
d1204 1
a1204 1
      debug_printf ("NtOpenFile(%S) failed, %p", &upath, status);
d1453 1
a1453 1
  debug_printf ("%s[%s], %s[%s], %p",
d1817 1
a1817 1
  syscall_printf ("%R = mount(%s, %s, %p)", res, win32_path, posix_path, flags);
a1948 35
static bool
get_volume_path_names_for_volume_name (LPCWSTR vol, LPWSTR mounts)
{
  DWORD len;
  if (GetVolumePathNamesForVolumeNameW (vol, mounts, NT_MAX_PATH, &len))
    return true;

  /* Windows 2000 doesn't have GetVolumePathNamesForVolumeNameW.
     Just assume that mount points are not longer than MAX_PATH. */
  WCHAR drives[MAX_PATH], dvol[MAX_PATH], mp[MAX_PATH + 3];
  if (!GetLogicalDriveStringsW (MAX_PATH, drives))
    return false;
  for (PWCHAR drive = drives; *drive; drive = wcschr (drive, '\0') + 1)
    {
      if (!GetVolumeNameForVolumeMountPointW (drive, dvol, MAX_PATH))
	continue;
      if (!wcscasecmp (vol, dvol))
	mounts = wcpcpy (mounts, drive) + 1;
      wcscpy (mp, drive);
      HANDLE h = FindFirstVolumeMountPointW (dvol, mp + 3, MAX_PATH);
      if (h == INVALID_HANDLE_VALUE)
	continue;
      do
	{
	  if (GetVolumeNameForVolumeMountPointW (mp, dvol, MAX_PATH))
	    if (!wcscasecmp (vol, dvol))
	      mounts = wcpcpy (mounts, drive) + 1;
	}
      while (FindNextVolumeMountPointW (h, mp, MAX_PATH));
      FindVolumeMountPointClose (h);
    }
  *mounts = L'\0';
  return true;
}

d1967 2
a1968 1
	if (!get_volume_path_names_for_volume_name (vol, mounts)
d2020 1
a2020 1
			"(error %lu)", vol, GetLastError ());
@


1.97
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d1594 2
a1595 1
    { "ncfsd", false }
@


1.96
log
@	* fhandler.cc (fhandler_base::write): Don't attempt to sparsify
	an already sparse file.  Drop check for FILE_SUPPORTS_SPARSE_FILES
	flag.  Explicitely set FILE_ATTRIBUTE_SPARSE_FILE attribute in
	cached attributes.
	(fhandler_base::lseek): Only set did_lseek if sparseness is supported.
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Don't attempt
	to sparsify an already sparse file.  Explicitely set
	FILE_ATTRIBUTE_SPARSE_FILE attribute in cached attributes.
	* mount.cc (oopt): Add "sparse" flag.
	(fillout_mntent): Ditto.
	* path.h (enum path_types): Add PATH_SPARSE.
	(path_conv::support_sparse): New method.
	(path_conv::fs_flags): Constify.
	(path_conv::fs_name_len): Ditto.
	include/sys/mount.h: Replace unused MOUNT_MIXED flag with MOUNT_SPARSE.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.95
log
@whitespace cleanup
@
text
@d1031 1
d1671 3
@


1.94
log
@	* mount.cc (fs_names): Add missing ReFS entry.  Change comment.
	* mount.h (enum fs_info_type): Add comment.
@
text
@d100 3
a102 3
  DWORD         samba_magic;             /* Always SAMBA_EXTENDED_INFO_MAGIC */
  DWORD         samba_version;           /* Major/Minor/Release/Revision */
  DWORD         samba_subversion;        /* Prerelease/RC/Vendor patch */
d104 1
a104 1
  char          samba_version_string[SAMBA_EXTENDED_INFO_VERSION_STRING_LENGTH];
@


1.93
log
@	* mount.cc (getmntent_r): Remove unused but set variable.
@
text
@d1575 2
a1576 1
/* Order must be identical to mount.h, enum fs_info_type. */
d1581 1
@


1.93.2.1
log
@Pull in changes from HEAD
@
text
@d1575 1
a1575 2
/* Don't add new fs types without adding them to fs_info_type in mount.h!
   Don't reorder without reordering fs_info_type in mount.h!*/
a1579 1
    { "refs", true },
@


1.93.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d100 3
a102 3
  DWORD		samba_magic;		/* Always SAMBA_EXTENDED_INFO_MAGIC */
  DWORD		samba_version;		/* Major/Minor/Release/Revision */
  DWORD		samba_subversion;	/* Prerelease/RC/Vendor patch */
d104 1
a104 1
  char		samba_version_string[SAMBA_EXTENDED_INFO_VERSION_STRING_LENGTH];
@


1.93.2.3
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d227 1
a227 1
	  debug_printf ("Cannot access path %S, status %y",
d265 1
a265 1
      debug_printf ("Cannot get volume attributes (%S), %y",
d482 1
a482 1
	api_fatal ("root_idx %d, user_shared magic %y, nmounts %d", root_idx, user_shared->version, nmounts);
d506 1
a506 1
      debug_printf ("flags: text (%y)", *flags & (PATH_TEXT | PATH_BINARY));
d511 1
a511 1
      debug_printf ("flags: binary (%y)", *flags & (PATH_TEXT | PATH_BINARY));
d720 1
a720 1
  debug_printf ("src_path %s, dst %s, flags %y, rc %d", src_path, dst, *flags, rc);
d1197 1
a1197 1
      debug_printf ("NtOpenFile(%S) failed, %y", &upath, status);
d1446 1
a1446 1
  debug_printf ("%s[%s], %s[%s], %y",
d1806 1
a1806 1
  syscall_printf ("%R = mount(%s, %s, %y)", res, win32_path, posix_path, flags);
d2043 1
a2043 1
			"(error %u)", vol, GetLastError ());
@


1.93.2.4
log
@Pull in changes from HEAD
@
text
@a1030 1
  {"sparse", MOUNT_SPARSE, 0},
a1669 3
  if (flags & MOUNT_SPARSE)
    strcat (_my_tls.locals.mnt_opts, (char *) ",sparse");

@


1.93.2.5
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.93.2.6
log
@Pull in change from HEAD
@
text
@d1594 1
a1594 2
    { "ncfsd", false },
    { NULL, false }
@


1.93.2.7
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@d309 1
a309 1
/* These are the minimal flags supported by NTFS since XP.  Every filesystem
d316 1
a316 7
				| FILE_FILE_COMPRESSION \
				| FILE_VOLUME_QUOTAS \
				| FILE_SUPPORTS_SPARSE_FILES \
				| FILE_SUPPORTS_REPARSE_POINTS \
				| FILE_SUPPORTS_OBJECT_IDS \
				| FILE_SUPPORTS_ENCRYPTION \
				| FILE_NAMED_STREAMS)
d1943 35
d1996 1
a1996 2
	DWORD len;
	if (!GetVolumePathNamesForVolumeNameW (vol, mounts, NT_MAX_PATH, &len)
@


1.93.2.8
log
@	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Fix comment.
@
text
@d309 3
a311 3
/* These are the minimal flags supported by NTFS since Windows 2000.  Every
   filesystem not supporting these flags is not a native NTFS.  We subsume
   them under the filesystem type "cifs". */
@


1.92
log
@	* cygwin.din (getmntent_r): Export.
	* mount.cc (getmntent_r): New function.
	* posix.sgml (std-gnu): Add getmntent_r.
	* include/mntent.h (getmntent_r): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d1906 1
a1906 1
  int fsname_len, dir_len, type_len, opts_len, tmplen = buflen;
a1913 1
  opts_len = strlen (mnt->mnt_opts) + 1;
@


1.91
log
@* mount.cc (mount_info::conv_to_win32_path): Eliminate unneeded assignment
found by CLANG.
* path.cc (symlink_info::check): Remove unneeded/unused variable found by
CLANG.
@
text
@d1902 29
@


1.90
log
@	* globals.cc (ro_u_refs): New R/O unicode string.
	* mount.cc (fs_info::update): Recognize ReFS.
	* mount.h (enum fs_info_type): Add refs.
	(class fs_info): Add refs flag and accessor methods.
	* ntdll.h (RtlAddAccessAllowedAceEx): Declare.
	(RtlAddAccessDeniedAceEx): Declare.
	* path.h (path_conv::fs_is_refs): Define.
	* sec_helper.cc (_recycler_sd): New function to create security
	descriptors suitable for the recycler bin starting with Vista.
	* security.cc (add_access_allowed_ace): Use RtlAddAccessAllowedAceEx
	and drop code to set AceFlags explicitely.
	(add_access_denied_ace): Use RtlAddAccessDeniedAceEx and drop code to
	set AceFlags explicitely.
	* security.h (_recycler_sd): Declare.
	(recycler_sd): Define.
	* syscalls.cc (desktop_ini): Change formatting.
	(desktop_ini_ext): Define third line of recycler desktop.ini file
	since Vista,
	(try_to_bin): Handle ReFS just like NTFS.  Write Vista and later
	Recycler in all uppercase, just like shell32 does when recreating it.
	Fix comments to include ReFS.  Don't implicitely reuse object
	attributes from earlier NtOpenFile call, rather recreate it for safety.
	Use recycler_sd call when creating security descriptor for Recycler
	dirs and files on Vista and later.  Write third line of desktop.ini
	when on Vista and later.
@
text
@a650 1
	  unit = 0;
@


1.89
log
@	* mount.cc (fillout_mntent): Use "none" rather than 0 when checking
	FS type.
@
text
@d405 1
@


1.88
log
@	* mount.cc (get_disk_type): Drop unneeded toupper call.  Convert case
	constants to wide chars.
@
text
@d1631 1
a1631 1
  if (mntinfo.what_fs () > 0 && mntinfo.what_fs () < max_fs_type)
@


1.87
log
@	* autoload.cc (NetUseGetInfo): Define.
	* fhandler_disk_file.cc (fhandler_cygdrive::opendir): Rename flptst
	to drive.  Call new get_disk_type function rather than is_floppy and
	check SMB drives with the NetUseGetInfo function.  Explain why.
	* mount.cc (get_disk_type): New function to evaluate disk type from
	native NT device name.
	(is_floppy): Remove.
	* mount.h (enum disk_type): Define.
	(get_disk_type): Declare.
	* path.h (is_floppy): Drop declaration.
@
text
@d1854 1
a1854 1
      switch (toupper (*d))
d1856 1
a1856 1
	case 'C':
d1860 1
a1860 1
	case 'F':
d1864 1
a1864 1
	case 'H':
d1868 1
a1868 1
	case 'L':
d1872 1
a1872 1
	case 'M':
@


1.86
log
@	* cygheap.cc (init_cygheap::init_installation_root): Convert function
	init_installation_root into a cygheap method.
	* cygheap.h (struct init_cygheap): Move installation_root,
	installation_key, and installation_key_buf from shared
	.cygwin_dll_common DLL section to cygheap.  Declare new method
	init_installation_root.
	* dtable.cc (handle_to_fn): Accommodate the move of installation strings
	to the cygheap.
	* external.cc (cygwin_internal): Ditto.
	* fhandler_console.cc (fhandler_console::open_shared_console): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Ditto.
	* fhandler_tty.cc: Ditto, throughout.
	* mount.cc (mount_info::init): Ditto.
	* pipe.cc (fhandler_pipe::create): Ditto.
	* shared.cc: Ditto, throughout.
	(installation_root): Remove.
	(installation_key): Move to cygheap.
	(installation_key_buf): Ditto.
	(installation_root_inited): Remove.
	(SPIN_WAIT): Remove.
	(init_installation_root): Move to cygheap.
	(memory_init): Call cygheap->init_installation_root right after
	cygheap->user.init.  Drop call of init_installation_root function.
	* shared_info.h (init_installation_root): Drop declaration.
	(installation_root): Ditto.
	(installation_key): Ditto.
	* uinfo.cc (pwdgrp::load): Accommodate the move of installation strings
	to the cygheap.
@
text
@d1843 4
a1846 2
bool
is_floppy (const char *dos)
d1848 31
a1878 4
  char dev[256];
  if (!QueryDosDevice (dos, dev, 256))
    return false;
  return ascii_strncasematch (dev, "\\Device\\Floppy", 14);
d1887 2
a1888 1
  if ((_my_tls.locals.available_drives & 1) && is_floppy ("A:"))
d1890 2
a1891 1
  if ((_my_tls.locals.available_drives & 2) && is_floppy ("B:"))
@


1.85
log
@	* mount.cc (mount_info::create_root_entry): Fix format specifier in
	api_fatal message.
@
text
@d470 1
a470 1
  pathend = wcpcpy (path, installation_root);
@


1.84
log
@	* external.cc (cygwin_internal): Implement CW_ALLOC_DRIVE_MAP,
	CW_MAP_DRIVE_MAP, CW_FREE_DRIVE_MAP.
	* fhandler_process.cc: Include mount.h.
	(get_volume_path_names_for_volume_name): Move to mount.cc.
	(struct dos_drive_mappings): Ditto.
	* mount.cc (get_volume_path_names_for_volume_name): Move here.
	(dos_drive_mappings::dos_drive_mappings): Ditto.
	(dos_drive_mappings::fixup_if_match): Ditto.
	(dos_drive_mappings::~dos_drive_mappings): Ditto.
	* mount.h (class dos_drive_mappings): Declare her.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_ALLOC_DRIVE_MAP,
	CW_MAP_DRIVE_MAP, CW_FREE_DRIVE_MAP.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d453 1
a453 1
    api_fatal ("add_item (\"%W\", \"/\", ...) failed, errno %d", native_root, errno);
@


1.83
log
@	* mount.cc (fs_info::update): Set has_buggy_reopen for Netapps as well.
@
text
@d1876 151
@


1.82
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d396 2
a397 2
	  /* NWFS does not grok re-opening a file by handle.  It only
	     supports this if the filename is non-null and the handle is
d399 1
a399 1
	  has_buggy_reopen (is_nwfs ());
@


1.81
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Check invalid
	success only on Samba shares.
	* mount.cc (fs_info::update): Drop has_buggy_basic_info flag for
	NcFsd.
	* syscalls.cc (unlink_nt): Fix typo in comment.
@
text
@d884 1
a884 1
      debug_printf ("%d = conv_to_posix_path (%s)", rc, src_path);
d1804 1
a1804 1
  syscall_printf ("%d = mount (%s, %s, %p)", res, win32_path, posix_path, flags);
d1839 1
a1839 1
  syscall_printf ("%d = cygwin_umount (%s, %d)", res,  path, flags);
@


1.80
log
@	* globals.cc (ro_u_ncfsd): New R/O unicode string.
	* mount.cc (fs_info::update): Check for "NcFsd" FS.  Set flags and
	change comments accordingly.
	(fs_names): Add entry for NcFsd FS.
	* mount.h (enum fs_info_type): Add ncfsd.
	(class fs_info): Add ncfsd flag and accessor methods.
	* path.h (class path_conv): Add fs_is_ncfsd method.
	* syscalls.cc (unlink_nt): Experimentally try delete-on-close on NcFsd
	in STATUS_CANNOT_DELETE case.
@
text
@d382 1
a382 1
	  /* NWFS/NcFsd is known to have a broken FileBasicInformation info
d389 1
a389 1
	  has_buggy_basic_info (is_nwfs () || is_ncfsd ());
@


1.79
log
@Rename FH_BAD to FH_NADA throughout.
* devices.h (FH_ERROR): New value.
(iscons_dev): Extend to detect all the console device types.
* devices.in: Set aside storage for FH_ERROR.
* dtable.cc (dtable::init_std_file_from_handle): Use iscons_dev to detect when
device is a console.
(fh_alloc): Pass device to console constructor.
(build_fh_pc): Short circuit when we detect that the constructor saw an error.
* fhandler.h (fhandler_console::fhandler_console): Accept fh_devices parameter.
(get_tty_stuff): Change to void.
* fhandler_console (fhandler_console::set_unit): Set device to FH_ERROR on
attempt to access anything other than the current console.
(fhandler_console::get_tty_stuff): Change to void return.
(fhandler_console::open): Return EPERM on FH_ERROR device type.
(fhandler_console::fhandler_console): Set the device type appropriately before
calling get_tty_stuff and rely on that function to reset it if necessary.
@
text
@d363 1
d365 1
d382 3
a384 3
	  /* NWFS is known to have a broken FileBasicInformation info class.
	     It can't be used to fetch information, only to set information.
	     Therefore, for NWFS we have to fallback to the
d389 2
a390 2
	  has_buggy_basic_info (is_nwfs ());
	  /* Netapp and NWFS are too dumb to allow non-DOS filenames
d394 2
a395 1
	  has_dos_filenames_only (is_netapp () || is_nwfs () || is_cifs ());
d398 1
a398 1
	     the handle to a directory. */
d1590 2
a1591 1
    { "nwfs", false }
@


1.78
log
@whitespace elimination
@
text
@d623 1
a623 1
      if (dev == FH_BAD)
@


1.77
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d135 1
a135 1
		        ((const uint8_t *) p + sizeof *pffvi
d196 1
a196 1
         is that symlink_info::check relies on being able to open a handle
d201 1
a201 1
         to be opened with access set to just READ_CONTROL. */
d203 1
a203 1
      	{
d408 1
a408 1
         the filesystem isn't one of the well-known filesystems anyway. */
d1086 1
a1086 1
      	{
@


1.76
log
@	* mount.cc (mount_info::conv_to_win32_path): Remove unused code.
	* mount.h (class mount_info): Remove sys_mount_table_counter member.
	* shared_info.h (class shared_info): Ditto.
	(CURR_SHARED_MAGIC): Update.
@
text
@d564 1
a564 1
  dev.devn = FH_FS;
d622 2
a623 2
      dev.devn = fhandler_proc::get_proc_fhandler (src_path);
      if (dev.devn == FH_BAD)
d626 1
a626 1
      if (isprocsys_dev (dev.devn))
@


1.75
log
@Eliminate trailing whitespace in some files.

* dll_init.cc (dll_list::alloc): Reset 'p' in forked process.
* select.cc (select_stuff::wait): Move cleanup() closer to WFMO to minimize
unavoidable (?) race.
@
text
@d561 1
a561 6
  while (sys_mount_table_counter < cygwin_shared->sys_mount_table_counter)
    {
      int current = cygwin_shared->sys_mount_table_counter;
      init ();
      sys_mount_table_counter = current;
    }
@


1.74
log
@	Drop NT4 support.
	* autoload.cc (DnsQuery_A): Fatal if not available.
	(DnsRecordListFree): Ditto.
	(DsGetDcNameW): Ditto.
	(NetGetAnyDCName): Remove.
	(NetGetDCName): Remove.
	(EnumProcessModules): Fatal if not available.
	(GetModuleFileNameExW): Ditto.
	(GetModuleInformation): Ditto.
	(GetProcessMemoryInfo): Ditto.
	(QueryWorkingSet): Ditto.
	(LsaRegisterLogonProcess): Ditto.
	* fenv.cc (_feinitialise): Drop supports_sse condition.
	* fhandler_disk_file.cc (path_conv::isgood_inode): Fix comment.
	(fhandler_base::fstat_by_name): Drop has_fileid_dirinfo condition.
	(fhandler_disk_file::opendir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Fix comment.
	* fhandler_proc.cc (format_proc_partitions): Drop NT4-only code.
	* fhandler_process.cc (get_process_state): Ditto.
	* kernel32.cc (GetWindowsDirectoryW): Remove.
	(GetWindowsDirectoryA): Remove.
	* miscfuncs.cc (nice_to_winprio): Drop NT4-only code.
	* mount.cc (fs_info::update): Fix comments.
	* net.cc (get_2k_ifs): Drop NT4-only code.
	* sec_auth.cc (get_logon_server): Ditto.
	(lsaauth): Drop NT4-specific error handling.
	* security.cc (alloc_sd): Set SE_DACL_PROTECTED unconditionally.
	* select.cc (select_stuff::wait): Always use MWMO_INPUTAVAILABLE.
	(peek_windows): Drop NT4-only condition in call to PeekMessage.
	* syscalls.cc (gethostid): Remove NT4-only workaround.
	* wincap.cc: Througout, drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse from
	wincaps.
	(wincap_nt4sp4): Remove.
	(wincap_minimal): Set to wincap_2000.
	(wincapc::init): Rely on availability of OSVERSIONINFOEX structure.
	Treat error from GetVersionEx as fatal.  Treat NT4 as fatal.
	* wincap.h (struct wincaps): Drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse flags
	and methods.
	* winlean.h (GetWindowsDirectoryW) Define as GetSystemWindowsDirectoryW.
	(GetWindowsDirectoryA): Define as GetSystemWindowsDirectoryA.
@
text
@d134 1
a134 1
  const uint16_t *end = (const uint16_t *) 
d381 1
a381 1
	     It can't be used to fetch information, only to set information. 
d1058 1
a1058 1
      
@


1.73
log
@	* mount.cc (NETAPP_IGNORE): Add FILE_PERSISTENT_ACLS.
	(FS_IS_NETAPP_DATAONTAP): Drop test for FILE_PERSISTENT_ACLS.
	(fs_info::update): Set filetype to ntfs in remote case, too.  Fix a
	couple of comments.  Add test for Netapps faking to be FAT.

	* mount.h (IMPLEMENT_FS_FLAG): Simplify definition and usage.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
a323 1
      /* This always fails on NT4. */
d340 1
a340 2
	  /* Test for Samba on NT4 or for older Samba releases not supporting
	     extended info. */
@


1.72
log
@	Revert accidental previous login.
@
text
@d302 2
a303 1
#define NETAPP_IGNORE FILE_SUPPORTS_SPARSE_FILES
a307 1
			     | FILE_PERSISTENT_ACLS \
d338 3
a340 2
      /* First check the remote filesystems faking to be NTFS. */
      if (!got_fs () && RtlEqualUnicodeString (&fsname, &ro_u_ntfs, FALSE)
d344 2
a345 1
	  /* Netapp inode info is unusable. */
d349 3
a351 2
      /* Then check the remote filesystems faking to be FAT.  Right now all
	 of them are subsumed under the "CIFS" filesystem type. */
d353 2
a354 1
	  && is_fat (RtlEqualUnicodePathPrefix (&fsname, &ro_u_fat, TRUE)))
d390 1
a390 1
	  /* Netapp ans NWFS are too dumb to allow non-DOS filesystems
@


1.71
log
@	* Makefile.in (DLL_IMPORTS): Remove libadvapi32.a.
	* autoload.cc: Add all advapi32 entry points.
	* mount.cc (mount_info::init): Read user fstab only if we have a
	username.
	* passwd.cc (pwdgrp::read_passwd): Only use username if we have one.
	* shared.cc (user_info::initialize): Set cb last so as not to override
	planned behaviour in pwdgrp::read_passwd.
	* uinfo.cc (cygheap_user::init): Fetch Windows username from environment
	variable $USERNAME.  Don't set name in cygheap if variable is empty.
	(internal_getlogin): If we still have no username, try GetUserNameW.
@
text
@d470 1
a470 2
  if (cygheap->user.name () && *cygheap->user.name ())
    from_fstab (true, path, pathend);
@


1.70
log
@	* mount.cc (fs_info::update): Remove erroneous NtClose on random handle
	value.
@
text
@d470 2
a471 1
  from_fstab (true, path, pathend);
@


1.69
log
@	* mount.h (class fs_info): Add has_buggy_reopen flag and accessor
	methods.
	* mount.cc (fs_info::update): Set has_buggy_reopen flag for NWFS.
	Add comment.
	* path.h (path_conv::get_object_attr) Make inline method.
	(path_conv::init_reopen_attr): New inline method.
	* path.cc (path_conv::get_object_attr): Remove.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Use
	path_conv::init_reopen_attr method to initialize OBJECT_ATTRIBUTE for
	reopening file.
	(fhandler_disk_file::fchmod): Ditto.
	(fhandler_base::utimens_fs): Ditto.
	(fhandler_disk_file::rewinddir): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
@
text
@a228 1
	  NtClose (vol);
@


1.68
log
@	* fhandler.h (class fhandler_base): Change inheritance of fstat_helper
	and fstat_by_...  methods to private.
	(fhandler_base::fstat_helper): Drop all redundant arguments.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call
	to fstat_by_nfs_ea here.  Drop fetching basic file information.
	Drop setting file attributes.  Accommodate change in fstat_helper call.
	(fhandler_base::fstat_by_name): Simplify.  Only fetch directory
	information to get the inode number.  Drop setting file attributes.
	Accommodate change in fstat_helper call.
	(fhandler_base::fstat_fs): Call fstat_by_nfs_ea if on NFS.
	(fhandler_base::fstat_helper): Drop all redundant arguments.  Use
	information already collected in the fhandler.  Move heading comment
	into code and drop dwFileAttributes comment.
	* mmap.cc (mmap64): Call fstat_fs rather than fstat_by_handle.
	* mount.cc (fs_info::update): Note that has_buggy_basic_info is unused.
	* path.cc (symlink_info::check_reparse_point): Add comment.
	(symlink_info::check): Fetch FileNetworkOpenInformation rather than
	FileBasicInformation throughout, except on NFS.  Explain why.  Store
	FILE_NETWORK_OPEN_INFORMATION in conv_hdl.  Remove
	FILE_ATTRIBUTE_DIRECTORY attribute in conv_hdl for reparse point
	symlinks.
	* path.h (class path_conv_handle): Add FILE_NETWORK_OPEN_INFORMATION
	member _fnoi.
	(path_conv_handle::fnoi): New accessor method for _fnoi.
	(path_conv::fnoi): New accessor method for cubv_hdl._fnoi.

	* fhandler_tty.cc (fhandler_tty_slave::init): Use tty::setpgid method.
@
text
@d392 4
@


1.67
log
@	* mount.cc (class fs_info_cache): New class to cache filesystem
	information.
	(fs_info::update): Check FileFsVolumeInformation against filesystem
	cache and use it, if filesystem is already available.  Add filesystem
	to cache, if not.  Only request FileFsObjectIdInformation if
	FILE_SUPPORTS_OBJECT_IDS is set in filesystem flags.
	* ntdll.h (struct _FILE_FS_VOLUME_INFORMATION): Add pragma pack so the
	structure size is matching the OS expectations.  Add __dummy member
	used in filesystem cache.
@
text
@d384 2
a385 1
	     other filesystems like NFS. */
@


1.66
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procsys.o.
	* devices.h (enum fh_devices): Add FH_PROCSYS.
	* devices.in (dev_procsys_storage): New device.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add code to allocate fhandler_procsys.
	* fhandler.h (proc_len): Convert to size_t.
	(procsys): Declare.
	(procsys_len): Declare.
	(enum virtual_ftype_t): Move here from fhandler_virtual.h.
	Add members supported by fhandler_procsys.
	(fhandler_virtual::exists): Return virtual_ftype_t.  Change
	in all derived classes.
	(class fhandler_procsys): New class.
	(fhandler_union): Add fhandler_procnet and fhandler_procsys members.
	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Use
	ro_u_proc.
	(fhandler_base::fstat_by_handle): Don't copy attributes if file is an
	NT device.
	(fhandler_base::fstat_by_name): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::exists): Return
	virtual_ftype_t.
	* fhandler_proc.cc (proc_tab): Sort alphabetically.  Use _VN macro
	to store length.
	(proc_len): Change to size_t.
	(proc_tab_cmp): New static function.
	(virt_tab_search): New function to search entry in virt_tab_t
	arrays.  Use throughout in /proc and sibling classes instead of
	loop.
	(fhandler_proc::exists): Return virtual_ftype_t.
	* fhandler_process.cc (process_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_process::exists): Return virtual_ftype_t.
	(fhandler_process::open): Simplify code.
	* fhandler_procnet.cc (procnet_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_procnet::exists): Return virtual_ftype_t.
	(fhandler_procnet::open): Simplify.
	* fhandler_procsys.cc: New file.
	* fhandler_registry.cc (fhandler_registry::exists): Return
	virtual_ftype_t.
	* fhandler_virtual.cc (fhandler_virtual::exists): Ditto.
	* fhandler_virtual.h (enum virtual_ftype_t): Move to fhandler.h.
	(virt_tab_t): Add name_len member.
	(_VN): New macro.
	(virt_tab_search): Declare.
	* mount.cc (mount_info::conv_to_win32_path): Fix comment.  Backslashify
	isprocsys_dev paths.
	* ntdll.h (STATUS_OBJECT_TYPE_MISMATCH): Define
	(STATUS_INSTANCE_NOT_AVAILABLE): Define.
	(STATUS_PIPE_NOT_AVAILABLE): Define.
	(STATUS_INVALID_PIPE_STATE): Define.
	(STATUS_PIPE_BUSY): Define.
	(SYMBOLIC_LINK_QUERY): Define.
	(NtOpenSymbolicLinkObject): Declare.
	(NtQuerySymbolicLinkObject): Declare.
	* path.cc (path_conv::check): Accommodate fact that exists method
	returns virtual_ftype_t now.  Add cases for new virtual_ftype_t
	types.
	(cygwin_conv_path): Add GLOBALROOT prefix to native device paths.
	Make sure to strip \\?\ prefix only for actual filesystem-based
	paths, not for all paths.
	* path.h (isproc_dev): Add FH_PROCSYS.
	(isprocsys_dev): Define.
@
text
@d108 58
d233 1
a233 1

d237 13
a249 1
  sernum = NT_SUCCESS (status) ? ffvi_buf.ffvi.VolumeSerialNumber : 0;
d326 4
a329 3
      status = NtQueryVolumeInformationFile (vol, &io, &ffoi, sizeof ffoi,
					     FileFsObjectIdInformation);
      if (NT_SUCCESS (status))
d429 1
@


1.65
log
@	* mount.cc (mount_info::from_fstab_line): Reorder to make sure all
	mounts from user fstab are user mounts.
	(mount): Make sure all mounts are user mounts, even those added via
	mount -a.
@
text
@d523 1
a523 1
  /* If the path is on a network drive or a //./ resp.//?/ path prefix,
d553 10
a562 1
      strcpy (dst, src_path);
@


1.64
log
@	* mount.cc (fs_info::update): Fix comments.
@
text
@a1052 2
  if (user)
    mount_flags &= ~MOUNT_SYSTEM;
d1067 2
d1713 2
@


1.63
log
@	* mount.cc (struct opt): Add "bind" option.
	(mount_info::from_fstab_line): Handle "bind" option.
	(fillout_mntent): Add "bind" option to mnt_opts.
	(mount): Handle "bind" option.
	* include/sys/mount.h (MOUNT_BIND): New mount flag.
@
text
@d292 2
a293 2
	  /* Known remote file system which can't handle calls to
	     NtQueryDirectoryFile(FileIdBothDirectoryInformation) */
a294 2
	/* Known remote file system with buggy open calls.  Further
	   explanation in fhandler.cc (fhandler_disk_file::open). */
d296 2
@


1.62
log
@	* fhandler_proc.cc: Add /proc/filesystems virtual file.
	(format_proc_filesystems): New function.
	* mount.cc (fs_names): Move to global scope. Redefine as array
	of { "name", block_device? } structs.
	(fillout_mntent): Use name member of fs_names.
	* mount.h (fs_names): New prototype.
@
text
@d934 1
d1055 14
d1591 3
d1693 22
a1714 1
    res = mount_table->add_item (win32_path, posix_path, flags);
@


1.61
log
@	* mount.cc (struct opt): Add "dos" and "ihash" options.
	(fillout_mntent): Ditto.
	* path.cc (path_conv::get_nt_native_path): Use path_conv's
	has_dos_filenames_only method.
	(path_conv::check): Add PATH_IHASH flag if FS has unreliable inode
	numbers.
	(symlink_info::check_shortcut): Or symlink flags to pflags.
	(symlink_info::check_sysfile): Ditto.  Change test accordingly.
	(symlink_info::check_reparse_point): Ditto.
	(symlink_info::check_nfs_symlink): Ditto.
	(symlink_info::check): Check PATH_DOS flag in call to get_nt_native_path
	to utilize mount flag.  Ditto in test for potential restarting.  Set
	PATH_DOS if FS only allows DOS filename rules.
	* path.h (enum path_types): Add PATH_DOS and PATH_IHASH.
	(path_conv::hasgood_inode): Check PATH_IHASH instead of
	fs.hasgood_inode.
	(path_conv::has_dos_filenames_only): New method.
	* include/sys/mount.h (MOUNT_DOS): New mount flag.
	(MOUNT_IHASH): Ditto.
@
text
@d1475 18
a1529 18
  /* Order must be identical to mount.h, enum fs_info_type. */
  const char *fs_names[] = {
    "none",
    "vfat",
    "ntfs",
    "smbfs",
    "nfs",
    "netapp",
    "iso9660",
    "udf",
    "csc-cache",
    "sunwnfs",
    "unixfs",
    "mvfs",
    "cifs",
    "nwfs"
  };

d1531 1
a1531 1
    strcpy (_my_tls.locals.mnt_type, fs_names[mntinfo.what_fs ()]);
@


1.60
log
@	* external.cc (cygwin_internal): Add CW_CVT_MNT_OPTS to allow mount
	flag parsing.  Add CW_LST_MNT_OPTS case to allow mount flag listing.
	* mount.cc (fstab_read_flags): Rename from read_flags.  Make externally
	available.  Change input string to char ** to allow returning faulty
	option.  Add flag for avoiding debug output.
	(fstab_list_flags): New function to create list of options.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_CVT_MNT_OPTS and
	CW_LST_MNT_OPTS.
@
text
@d935 1
d937 1
d1558 6
@


1.59
log
@	* mount.cc (compare_flags): New function.
	(read_flags): Replace loop with bsearch.  Simplify error check.
@
text
@d956 2
a957 2
static bool
read_flags (char *options, unsigned &flags)
d961 1
a961 1
  while (*options)
d963 1
a963 1
      char *p = strchr (options, ',');
d967 1
a967 1
	p = strchr (options, '\0');
d969 3
a971 2
      key.name = options;
      opt *o = (opt *) bsearch (&key, oopts, sizeof oopts / sizeof (opt),
d975 2
a976 1
	  system_printf ("invalid fstab option - '%s'", options);
d983 1
a983 1
      options = p;
d988 22
d1048 1
a1048 1
  if (!read_flags (c, mount_flags))
@


1.58
log
@	* path.h (get_nt_native_path): Add third parameter to declaration and
	declare with regparms.
	* path.cc (get_nt_native_path): Add third parameter to allow conversion
	of leading and trailing dots and spaces on filesystems only supporting
	filenames following DOS rules.
	(path_conv::get_nt_native_path): Call get_nt_native_path according to
	fs.has_dos_filenames_only flag.
	(getfileattr): Accommodate new parameter to get_nt_native_path.
	(symlink_info::check): Revamp fs_update_called handling to call
	fs.update only once per call.  Call get_nt_native_path according to
	fs.has_dos_filenames_only flag.  Streamline filesystem dependent code
	not to be called more than once unnecessarily.  Drop code tweaking
	incoming path for broken filesystems only allowing DOS pathnames.
	Rely on changed get_nt_native_path instead.
	* mount.cc (fillout_mntent): Accommodate new parameter to
	get_nt_native_path.
	* strfuncs.cc (tfx_rev_chars): New conversion table with comment.
	(sys_cp_wcstombs): Use tfx_rev_chars rather than tfx_chars.
@
text
@d947 9
d959 2
d968 13
a980 16

      for (opt *o = oopts;
	   o < (oopts + (sizeof (oopts) / sizeof (oopts[0])));
	   o++)
	if (strcmp (options, o->name) == 0)
	  {
	    if (o->clear)
	      flags &= ~o->val;
	    else
	      flags |= o->val;
	    goto gotit;
	  }
      system_printf ("invalid fstab option - '%s'", options);
      return false;

    gotit:
@


1.57
log
@	* mount.cc (GETVOLINFO_VALID_MASK): Drop FILE_SEQUENTIAL_WRITE_ONCE
	from mask.  Expand the comment a bit.
	(WIN_FAT_FLAGS): New define.
	(FS_IS_WINDOWS_FAT): New macro.
	(fs_info::update): Handle remote FS faking to be FAT.  Subsume under
	CIFS.  Check for NWFS and has_buggy_basic_info only for remote
	filesystems.  Add check for has_dos_filenames_only.
	* mount.h (class fs_info): Add has_dos_filenames_only status flag.
	Implement accessors.
	* path.cc (symlink_info::check): Rearrange variable definitions to
	clear them up.  Add a restart label to allow a clean restart within
	the method.  Add a check for broken filesystems only allowing DOS
	pathnames in case we encounter a STATUS_OBJECT_NAME_NOT_FOUND status.
	If all checks point to one of that, restart method with tweaked
	incoming path.  Add lengthy comments to explain what we do.
@
text
@d1473 1
a1473 1
  get_nt_native_path (native_path, unat);
@


1.56
log
@	* mount.cc (fs_info::update): Allow variable FILE_SUPPORTS_SPARSE_FILES
	flag in netapp flag test.  Add comment.
@
text
@d211 6
a216 3
   volume.  At present these flags to ignore are FILE_VOLUME_IS_COMPRESSED
   and FILE_READ_ONLY_VOLUME. */
#define GETVOLINFO_VALID_MASK (0x003701ffUL)
d250 5
d277 5
d290 2
a300 4
      /* Not only UNIXFS is known to choke on FileIdBothDirectoryInformation.
	 Some other CIFS servers have problems with this call as well.
	 Know example: EMC NS-702.  We just don't use that info class on
	 any remote CIFS.  */
d302 19
a320 1
	has_buggy_fileid_dirinfo (is_cifs () || is_unixfs ());
a325 1
      && !is_nwfs (RtlEqualUnicodeString (&fsname, &ro_u_nwfs, FALSE))
a338 6
  /* NWFS is known to have a broken FileBasicInformation info class.  It
     can't be used to fetch information, only to set information.  Therefore,
     for NWFS we have to fallback to the FileNetworkOpenInformation info
     class.  Unfortunately we can't use FileNetworkOpenInformation all the
     time since that fails on other filesystems like NFS. */
  has_buggy_basic_info (is_nwfs ());
@


1.55
log
@* shared_info.h (user_info): Add dll_crt0_1 as a friend.
(user_info::version): Make LONG to accommodate spinlock use.
(user_info::create): New static function renamed from user_info_create.
(user_info::initialize): New private function renamed from
user_info_initialize.
(SHARED_VERSION): Delete.
(SHARED_VERSION_MAGIC): Ditto.
(USER_VERSION_MAGIC): Ditto.
(SHARED_INFO_CB): Ditto.
(USER_VERSION): Ditto.
(USER_VERSION_MAGIC): Ditto.
(CURR_SHARED_MAGIC): Update.
(CURR_USER_MAGIC): Ditto.
(shared_info::version): Make LONG to accommodate spinlock use.
(shared_info::create): New static function mirroring user_info::create.
(dll_crt0_1): Accommodate change to user_info::initialize.
* spinlock.h (spinlock::setto): New variable member.
(spinlock::done): New function.
(spinlock::spinlock): Generalize to allow arbitrary values and timeouts.  Call
done() when lock is not needed.
* ntdll.h: Make multiple-inclusion safe.
(NtQuerySystemTime): Declare.
* shared.cc (installation_root_inited): Rename from shared_mem_inited.
(init_installation_root): Make inline.  Use a spinlock to ensure that this is
initialized only once per session.
(user_info::initialize): Rename from user_shared_initialize.  Protect with
spinlock on sversion and remove other spinlock-like things.  Remove reference
to user_shared since it is now implicit.  Refer to spinlock version of
multiple_cygwin_problem to ensure that any spinlock is released.
(user_info::create): Rename from user_shared_create.  Accommodate change from
user_shared_initialize to user_info::initialize.
(shared_info::create): New inline function.
(shared_info::initialize): Protect with spinlock on sversion.  Move heap_init
back under specific control of shared_info spinlock.  Remove reference to
SHARED_INFO_CB and just use sizeof(*this).
(memory_init): Move all locking into respective functions where it is needed.
Accommodate name changes.  Remove call to heap_init().
* syscalls.cc (seteuid32): Accommodate name change to user_info::create().
* mount.cc (mount_info::create_root_entry): Report on errors from add_item
since they should be nonexistent.
(mount_info::init): Don't initialize nmounts.  It should already be zero.  Give
more verbose error when root_idx < 0.  Implicitly use this pointer rather than
explicitly referencing mount_table->.
(mount_info::add_item): Minor whitespace fix.
@
text
@d216 4
d229 3
a231 2
/* Netapp DataOnTap.  TODO: Find out if that's the only flag combination. */
#define FS_IS_NETAPP_DATAONTAP TEST_GVI(flags (), \
@


1.54
log
@	* mount.cc (mount_info::conv_to_win32_path): Set UNC path flags to
	cygdrive prefix path flags.
@
text
@d341 5
a345 2
  mount_table->add_item (native_root, "/",
			 MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_IMMUTABLE | MOUNT_AUTOMATIC);
a358 1
  nmounts = 0;
d372 2
a373 1
      assert (root_idx != -1);
d378 2
a379 2
	mount_table->add_item (native, "/usr/bin",
			       MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_AUTOMATIC);
d384 2
a385 2
	mount_table->add_item (native, "/usr/lib",
			       MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_AUTOMATIC);
d1291 1
a1291 1
      set_errno (nativeerr?:posixerr);
@


1.53
log
@	* globals.cc (ro_u_nwfs): New R/O unicode string.
	* mount.cc (fs_info::update): Check for NWFS filesystem.  Set
	has_buggy_basic_info, if so.  Add comment to explain why.
	(fillout_mntent): Add "nwfs" string to fs_names array.
	* mount.h (enum fs_info_type): Add nwfs.
	(class fs_info): Add has_buggy_basic_info status flag.  Add accessors
	for has_buggy_basic_info and is_nwfs.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Accommodate
	filesystems with broken FileBasicInformation handling.
	* path.cc (symlink_info::check): Ditto.
	* path.h (path_conv::has_buggy_basic_info): Add method.
@
text
@d503 9
@


1.52
log
@	* miscfuncs.h (transform_chars): Declare.  Define inline variation here.
	* mount.cc (mount_info::from_fstab): Remove extern declaration of
	transform_chars.
	* path.cc (tfx_chars): Move to strfuncs.cc.
	(transform_chars): Ditto.
	* strfunc.cc (tfx_chars): Moved here from path.cc.
	(transform_chars): Ditto.
	(sys_cp_wcstombs): Make UNICODE private use area conversion roundtrip
	save for all characters.
	(sys_cp_mbstowcs): Ditto, by removing special case for UTF-8 sequences
	representing U+f0XX UNICODE chars.  Fix typo in comment.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009 Red Hat, Inc.
d292 1
d304 1
a304 1
  /* Netapp inodes numbers are fly-by-night. */
d306 6
d1453 2
a1454 1
    "cifs"
@


1.51
log
@	* cygprops.h: New file.
	* dtable.cc (handle_to_fn): Add check for correct installation_key
	string in object name for pipes and ttys.
	* external.cc (cygwin_internal): Add CW_GET_INSTKEY to allow fetching
	the installation_key from cygserver.
	* fhandler_fifo.cc (fhandler_fifo::fifo_name): Add installation_key
	to fifo name.
	* globals.cc: Include cygprops.h.
	(_RDATA): Move slightly and add comment.
	(cygwin_props): Define.
	* mount.cc (mount_info::init): Accommodate the fact that
	installation_root is now a global variable in DLL common shared memory,
	rather than a member of cygwin_shared.
	* pipe.cc (fhandler_pipe::create_selectable): Add installation_key to
	pipe name.
	* shared.cc (installation_root): Define here for storage in DLL
	common shared memory.
	(installation_key): Ditto.
	(installation_key_buf): Ditto.
	(init_installation_root): Convert from shared_info method to ordinary
	function.  Add initializing installation_key.  Invalidate
	installation_key depending of value of disable_key property.  Add
	comment to explain.
	(get_shared_parent_dir): Add installation_key to directory name.
	(get_session_parent_dir): Ditto.
	(shared_info::initialize): Move call to init_installation_root from
	here...
	(memory_init): ...to here.  Add debug output to print installation root
	and installation key.  Add comment to explain why.
	* shared_info.h (SHARED_INFO_CB): Recalculate.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Remove definition of installation_root and
	declaration of init_installation_root.
	(init_installation_root): Declare.
	(installation_root): Declare.
	(installation_key): Declare.
	* uinfo.cc (pwdgrp::load): Accommodate the fact that installation_root
	is now a global variable in DLL common shared memory.
	* include/cygwin/version.h: Bump API minor number.
	(CYGWIN_INFO_INSTALLATIONS_NAME): Add.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_INSTKEY.
@
text
@a999 1
      extern void transform_chars (PWCHAR, PWCHAR);
@


1.50
log
@	* mount.cc (fs_info::update): Add comment.
	* path.cc (symlink_info::check_reparse_point): Return -1 for volume
	mount points.  Explain why.
	(symlink_info::check): Call fs.update again for volume mount points.
	Explain why.
@
text
@d353 1
a353 1
  pathend = wcpcpy (path, cygwin_shared->installation_root);
@


1.49
log
@	* mount.h (enum fs_info_type): New type.
	(IMPLEMENT_FS_FLAG): New define.
	(class fs_info): Convert filesystem type status flags into an enum
	fs_info_type.  Add cifs FS.  Revert change to has_buggy_open and
	has_buggy_fileid_dirinfo.  Make them normal; status flags again.
	Implement is_FS functions using IMPLEMENT_FS_FLAG.
	* mount.cc (fs_info::update): Define MINIMAL_WIN_NTFS_FLAGS and
	FS_IS_WINDOWS_NTFS.  Add comment.  Only test remote filesystems
	for "NTFS" once.  Add is_cifs check using FS_IS_WINDOWS_NTFS.
	Set has_buggy_open flag for SUNWNFS.  Set has_buggy_fileid_dirinfo
	flag for UNIXFS and all cifs type filesystems.  Only check for
	caseinsensitivity once.
	(fillout_mntent): Create locale fs_names array.  Use for setting
	_my_tls.locals.mnt_type.
@
text
@d137 3
@


1.48
log
@	* mount.h (fs_info::fsn): New member.
	(fs_info::clear): Clear fsn.
	(fs_info::fsname): New read accessor for fsn.
	* mount.cc (fs_info::update): Fill in fsn member with lowercased
	filesystem name if filesystem is not well-known.  Fall back to
	"unknown" if filesystem name is missing.
	(fillout_mntent): Print filesystem name retrieved in fs_info::update
	rather than static string "unknown".
@
text
@d201 4
d222 1
d229 10
a238 4
  RtlInitCountedUnicodeString (&fsname, ffai_buf.ffai.FileSystemName,
			       ffai_buf.ffai.FileSystemNameLength);
  if (is_remote_drive ())
    {
d252 2
a253 1
      if (!got_fs ()
d256 1
a256 2
	  && !is_samba (RtlEqualUnicodeString (&fsname, &ro_u_ntfs, FALSE)
			&& FS_IS_SAMBA)
d258 5
a262 2
	  && !is_netapp (RtlEqualUnicodeString (&fsname, &ro_u_ntfs, FALSE)
			 && FS_IS_NETAPP_DATAONTAP)
d274 10
a283 1
	is_sunwnfs (RtlEqualUnicodeString (&fsname, &ro_u_sunwnfs, FALSE));
d290 1
a290 12
    {
      is_udf (RtlEqualUnicodeString (&fsname, &ro_u_udf, FALSE));
      /* UDF on NT 5.x is broken (at least) in terms of case sensitivity.
	 The UDF driver reports the FILE_CASE_SENSITIVE_SEARCH capability
	 but:
	 - Opening the root directory for query seems to work at first,
	   but the filenames in the directory listing are mutilated.
	 - When trying to open a file or directory case sensitive, the file
	   appears to be non-existant. */
      if (is_udf () && wincap.has_broken_udf ())
	caseinsensitive (true);
    }
d304 1
d306 12
a317 3
     sensitive. */
  caseinsensitive ((!(flags () & FILE_CASE_SENSITIVE_SEARCH) || is_samba ())
		   && !is_nfs ());
d1430 19
a1448 22
  if (mntinfo.is_ntfs ())
    strcpy (_my_tls.locals.mnt_type, (char *) "ntfs");
  else if (mntinfo.is_fat ())
    strcpy (_my_tls.locals.mnt_type, (char *) "vfat");
  else if (mntinfo.is_samba())
    strcpy (_my_tls.locals.mnt_type, (char *) "smbfs");
  else if (mntinfo.is_nfs ())
    strcpy (_my_tls.locals.mnt_type, (char *) "nfs");
  else if (mntinfo.is_udf ())
    strcpy (_my_tls.locals.mnt_type, (char *) "udf");
  else if (mntinfo.is_cdrom ())
    strcpy (_my_tls.locals.mnt_type, (char *) "iso9660");
  else if (mntinfo.is_netapp ())
    strcpy (_my_tls.locals.mnt_type, (char *) "netapp");
  else if (mntinfo.is_csc_cache ())
    strcpy (_my_tls.locals.mnt_type, (char *) "csc-cache");
  else if (mntinfo.is_mvfs ())
    strcpy (_my_tls.locals.mnt_type, (char *) "mvfs");
  else if (mntinfo.is_unixfs ())
    strcpy (_my_tls.locals.mnt_type, (char *) "unixfs");
  else if (mntinfo.is_sunwnfs ())
    strcpy (_my_tls.locals.mnt_type, (char *) "sunwnfs");
@


1.47
log
@	* mount.cc (fs_info::update): Revert to open filesystem with access set
	to READ_CONTROL.  If that fails, try additionally with FILE_READ_DATA.
@
text
@d279 8
a286 1

d1431 1
a1431 1
    strcpy (_my_tls.locals.mnt_type, (char *) "unknown");
@


1.46
log
@	* mount.cc (fs_info::update): Open filesystem with access set to 0.
	Explain why.
@
text
@d133 1
d137 2
d140 7
a146 4
         to be opened with acces set to just READ_CONTROL.  No worries, since
	 filesystem information is available without any access bit set. */
      status = NtOpenFile (&vol, 0, &attr, &io, FILE_SHARE_VALID_FLAGS,
			   FILE_OPEN_FOR_BACKUP_INTENT);
d161 1
a161 1
	  status = NtOpenFile (&vol, 0, &attr, &io, FILE_SHARE_VALID_FLAGS,
@


1.45
log
@	* mount.cc: Revert accidental checkin.
@
text
@d136 5
a140 2
      status = NtOpenFile (&vol, READ_CONTROL, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
d155 1
a155 2
	  status = NtOpenFile (&vol, READ_CONTROL, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
@


1.44
log
@	* mount.cc (fillout_mntent): Fix typo (noexec -> notexec).
@
text
@d313 1
a313 1
  pathend = wcpcpy (path, installation_root);
@


1.43
log
@	* globals.cc: Improve comment on R/O UNICODE_STRINGs.
	* mount.h (class fs_info): Add is_mvfs bit.
	* mount.cc (fs_info::update): Recognize MVFS remote filesystem.
	(fillout_mntent): Reorder filesystem checks for speed.  Add
	mvfs, unixfs, and sunwnfs filesystem types.
	* path.h (class path_conv): Add fs_is_mvfs method.
	* path.cc (symlink_worker): On MVFS, always create symlinks as
	Windows shortcuts.  Explain why.
@
text
@d313 1
a313 1
  pathend = wcpcpy (path, cygwin_shared->installation_root);
d1436 1
a1436 1
    strcat (_my_tls.locals.mnt_opts, (char *) ",noexec");
@


1.42
log
@	* globals.cc: Reorder constant UNICODE_STRINGs for clarity.
	* mount.h (fs_info::sttaus): Move filesystem type flags into
	substructure.  Add union to allow simple test for having set any
	one filesystem type flag.  Replace has_buggy_open flag with is_sunwnfs
	flag.  Replace has_buggy_fileid_dirinfo with is_unixfs flag.
	(fs_info::got_fs): New private method.
	(fs_info::has_buggy_open): New explicit implementation.
	(fs_info::has_buggy_fileid_dirinfo): Ditto.
	* mount.cc (fs_info::update): Optimize filesystem checks for speed.
	* winsup.h (IMPLEMENT_STATUS_FLAG): Change write accessor to return
	value just set.
@
text
@d243 4
d1393 5
a1397 1
  if (mntinfo.is_samba())
a1400 6
  else if (mntinfo.is_fat ())
    strcpy (_my_tls.locals.mnt_type, (char *) "vfat");
  else if (mntinfo.is_ntfs ())
    strcpy (_my_tls.locals.mnt_type, (char *) "ntfs");
  else if (mntinfo.is_netapp ())
    strcpy (_my_tls.locals.mnt_type, (char *) "netapp");
d1405 2
d1409 6
@


1.41
log
@	Throughout avoid having to initialize constant UNICODE_STRINGs.
	* globals.cc: Define constant UNICODE_STRINGs and store in .rdata
	section.
	* fhandler_disk_file.cc: Throughout, use readonly UNICODE_STRINGs
	rather then initializing local UNICODE_STRING variable where
	applicable.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* flock.cc (inode_t::inode_t): Ditto.
	* mmap.cc: Ditto.
	* syscalls.cc: Ditto.
	* mount.cc (fs_info::update): Ditto.
	* path.cc: Ditto.

	* ntdll.h (RtlEqualUnicodePathPrefix): Redefine to take prefix as
	UNICODE_STRING.
	(RtlEqualUnicodePathSuffix): Redefine to take suffix as UNICODE_STRING.
	* fhandler_disk_file.cc: Accommodate throughout.
	* mount.cc (fs_info::update): Ditto.
	* path.cc (cwdstuff::set): Ditto.
	* syscalls.cc: Ditto.
@
text
@d174 1
a174 1
  if (ffdi.Characteristics & FILE_REMOTE_DEVICE
a177 2
  else
    is_remote_drive (false);
a217 2
  is_fat (RtlEqualUnicodePathPrefix (&fsname, &ro_u_fat, TRUE));
  is_csc_cache (RtlEqualUnicodeString (&fsname, &ro_u_csc, FALSE));
d233 33
a265 27
      /* Test for Samba on NT4 or for older Samba releases not supporting
	 extended info. */
      if (!is_samba ())
	is_samba (RtlEqualUnicodeString (&fsname, &ro_u_ntfs, FALSE)
		  && FS_IS_SAMBA);

      if (!is_samba ())
	{
	  is_netapp (RtlEqualUnicodeString (&fsname, &ro_u_ntfs, FALSE)
		     && FS_IS_NETAPP_DATAONTAP);

	  is_nfs (RtlEqualUnicodeString (&fsname, &ro_u_nfs, FALSE));

	  if (!is_nfs ())
	    {
	      /* Known remote file systems which can't handle calls to
		 NtQueryDirectoryFile(FileIdBothDirectoryInformation) */
	      has_buggy_fileid_dirinfo (RtlEqualUnicodeString (&fsname,
							       &ro_u_unixfs,
							       FALSE));

	      /* Known remote file systems with buggy open calls.  Further
		 explanation in fhandler.cc (fhandler_disk_file::open). */
	      has_buggy_open (RtlEqualUnicodeString (&fsname, &ro_u_sunwnfs,
						     FALSE));
	    }
	}
a266 2
  is_ntfs (RtlEqualUnicodeString (&fsname, &ro_u_ntfs, FALSE)
	   && !is_samba () && !is_netapp ());
d269 2
a270 2
  hasgood_inode (((flags () & FILE_PERSISTENT_ACLS) && !is_netapp ())
		 || is_nfs ());
a277 14
  is_cdrom (ffdi.DeviceType == FILE_DEVICE_CD_ROM);
  if (is_cdrom ())
    {
      is_udf (RtlEqualUnicodeString (&fsname, &ro_u_udf, FALSE));
      /* UDF on NT 5.x is broken (at least) in terms of case sensitivity.  The
	 UDF driver reports the FILE_CASE_SENSITIVE_SEARCH capability but:
	 - Opening the root directory for query seems to work at first, but the
	   filenames in the directory listing are mutilated.
	 - When trying to open a file or directory case sensitive, the file
	   appears to be non-existant. */
      if (is_udf () && wincap.has_broken_udf ())
	caseinsensitive (true);
    }

@


1.40
log
@* mount.cc (mount_info::add_item): Avoid using any-old '/' as indicating root.
@
text
@d126 1
a126 1
  UNICODE_STRING fsname, testname;
d176 1
a176 1
	  && RtlEqualUnicodePathPrefix (attr.ObjectName, L"\\??\\UNC\\", TRUE)))
d220 2
a221 4
  is_fat (RtlEqualUnicodePathPrefix (&fsname, L"FAT", TRUE));
  RtlInitUnicodeString (&testname, L"CSC-CACHE");
  is_csc_cache (RtlEqualUnicodeString (&fsname, &testname, FALSE));
  RtlInitUnicodeString (&testname, L"NTFS");
d240 1
a240 1
	is_samba (RtlEqualUnicodeString (&fsname, &testname, FALSE)
d245 1
a245 1
	  is_netapp (RtlEqualUnicodeString (&fsname, &testname, FALSE)
d248 1
a248 2
	  RtlInitUnicodeString (&testname, L"NFS");
	  is_nfs (RtlEqualUnicodeString (&fsname, &testname, FALSE));
a253 1
	      RtlInitUnicodeString (&testname, L"UNIXFS");
d255 1
a255 1
							       &testname,
d260 1
a260 2
	      RtlInitUnicodeString (&testname, L"SUNWNFS");
	      has_buggy_open (RtlEqualUnicodeString (&fsname, &testname,
d265 1
a265 1
  is_ntfs (RtlEqualUnicodeString (&fsname, &testname, FALSE)
d281 1
a281 2
      RtlInitUnicodeString (&testname, L"UDF");
      is_udf (RtlEqualUnicodeString (&fsname, &testname, FALSE));
@


1.39
log
@* mount.cc (mount_info::got_usr_bin): Mark as NO_COPY.
(mount_info::got_usr_lib): Ditto.
(mount_info::root_idx): Ditto.
@
text
@d1304 1
a1304 1
  if (posixtmp[0] == '/' && posixtmp[1] == '\0')
@


1.38
log
@* mount.cc (mount_info::init): Remove MOUNT_CYGWIN_EXEC setting when
auto-mounting /usr/bin.
@
text
@d48 3
a50 3
bool mount_info::got_usr_bin;
bool mount_info::got_usr_lib;
int mount_info::root_idx = -1;
@


1.37
log
@	* mount.cc (oopts): Add a no-op "auto" option.
	(mount_info::create_root_entry): Set root dir to MOUNT_IMMUTABLE rather
	than to MOUNT_OVERRIDE.
@
text
@d345 1
a345 1
			       MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_AUTOMATIC | MOUNT_CYGWIN_EXEC);
@


1.36
log
@cygwin ChangeLog
2009-05-13  Corinna Vinschen  <corinna@@vinschen.de>
	    Christopher Faylor  <me+cygwin@@cgf.cx>

	* mount.cc (mount_info::got_usr_bin): Define.
	(mount_info::got_usr_lib): Ditto.
	(mount_info::root_idx): Ditto.
	(mount_info::create_root_entry): Create root entry as immutable and
	flag as automatic.
	(mount_info::init): Remove "Huh?  No /etc/fstab..." warning.
	Unconditionally call from_fstab for user and system tables.  Fill in
	/usr/bin and /usr/lib if they have not been specified in /etc/fstab.
	(oopts): Alphabetize.  Add "override" option to allow overriding
	immutable mount points.
	(mount_info::add_item): Accommodate new MOUNT_IMMUTABLE flag intended
	for root mount.
	(mount_info::add_item): Detect "/usr/bin", "/usr/lib", and "/" and set
	appropriate global state.
	(fillout_mntent): Add ,auto to mount points added by Cygwin DLL.
	(mount): Remove masking of MOUNT_SYSTEM.  Allow user to shoot
	themselves.  Add comment.
	* mount.h (mount_info::got_usr_bin): Declare.
	(mount_info::got_usr_lib): Ditto.
	(mount_info::root_idx): Ditto.
	* include/sys/mount.h: Reformat enum.
	Add MOUNT_{OVERRIDE,IMMUTABLE,AUTOMATIC}.

doc ChangeLog
2009-05-13  Corinna Vinschen  <corinna@@vinschen.de>
	    Christopher Faylor  <me+cygwin@@cgf.cx>

	* pathnames.sgml (mount-table): Sort mount options and add override
	option.  Add description of root mount handling.

utils ChangeLog
2009-05-13  Corinna Vinschen  <corinna@@vinschen.de>
	    Christopher Faylor  <me+cygwin@@cgf.cx>

	* mount.cc (oopts): Sort.  Add override option.  Add dummy "auto"
	option for consistency.
	(mount_entries): Avoid adding auto-mounted entries to -m output.

	* utils.sgml: Sort mount options.  Add description of override option.
@
text
@d311 1
a311 1
			 MOUNT_SYSTEM | MOUNT_BINARY | MOUNT_OVERRIDE | MOUNT_AUTOMATIC);
d862 1
@


1.35
log
@	* security.cc (set_file_sd): Drop using FILE_OPEN_FOR_RECOVERY flag in
	call to NtOpenFile.
	* exceptions.cc (open_stackdumpfile): Ditto in call to NtCreateFile.
	* fhandler.cc (fhandler_base::open): Ditto.  Simplify setting
	create_options.

	* mount.cc (fs_info::update): Recognize offline storage.
	(fillout_mntent): Report UDF and offline storage.
	* mount.h (class fs_info): Add is_csc_cache status flag.
@
text
@d34 1
d48 4
d306 2
a307 1
  /* Create a default root dir from the path the Cygwin DLL is in. */
d310 2
a311 1
  mount_table->add_item (native_root, "/", MOUNT_SYSTEM | MOUNT_BINARY);
a331 3
  if (from_fstab (false, path, pathend)   /* The single | is correct! */
      | from_fstab (true, path, pathend))
      return;
d333 21
a353 2
  /* FIXME: Remove warning message before releasing 1.7.0. */
  small_printf ("Huh?  No /etc/fstab file in %W?  Using default root and cygdrive prefix...\n", path);
d861 1
a861 2
  {"user", MOUNT_SYSTEM, 1},
  {"nouser", MOUNT_SYSTEM, 0},
d863 1
a863 1
  {"text", MOUNT_BINARY, 1},
d865 2
d868 3
a870 4
  {"cygexec", MOUNT_CYGWIN_EXEC, 0},
  {"nosuid", 0, 0},
  {"acl", MOUNT_NOACL, 1},
  {"noacl", MOUNT_NOACL, 0},
d872 2
a873 1
  {"posix=0", MOUNT_NOPOSIX, 0}
d1081 1
a1081 1
  /* Don't allow to override a system cygdrive prefix. */
d1265 1
a1265 1
	  /* Don't allow to override a system mount with a user mount. */
d1271 3
a1273 1
	  if ((mount[i].flags & MOUNT_SYSTEM) == (mountflags & MOUNT_SYSTEM))
d1275 10
d1296 10
d1350 2
a1351 2
	  /* Don't allow to remove a system mount. */
	  if ((mount[ent].flags & MOUNT_SYSTEM))
d1456 1
a1456 1
  if ((flags & MOUNT_CYGDRIVE))		/* cygdrive */
d1459 3
d1539 2
a1541 1
  flags &= ~MOUNT_SYSTEM;
@


1.34
log
@	* mount.cc (mount_info::from_fstab_line): Make cygdrive posix=0 by
	default as documented.
@
text
@d216 2
d1372 2
d1376 2
@


1.33
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Fix inode number
	evaluation for faked "." entry.

	* mount.cc (fs_info::update): Move setting of is_cdrom after checking
	for caseinsensitivity.  Recognize UDF in is_cdrom case and set
	caseinsensitive flag according to UDF brokenness determined by OS.
	Add comment to explain why.
	* mount.h (class fs_info): Add is_udf status flag.
	* path.cc (symlink_info::check): Add workaround for UDF bug in
	terms of casesensitivity on certain OSes.
	* wincap.h (wincaps::has_broken_udf): New element.
	(wincaps::has_broken_udf): New element
@
text
@d917 2
@


1.32
log
@	* mount.cc (mount_info::from_fstab): Open fstab file with
	FILE_OPEN_FOR_BACKUP_INTENT flag.
@
text
@a264 1
  is_cdrom (ffdi.DeviceType == FILE_DEVICE_CD_ROM);
d276 15
@


1.31
log
@	* mount.cc (mount_info::from_fstab_line): Always convert drive
	letter in native path to uppercase.
	* path.cc (normalize_win32_path): Ditto.
	(path_prefix_p): Revert previous patch.

	* path.cc (symlink_info::check): Check for STATUS_INVALID_PARAMETER
	return code to circumvent weird behaviour of Samba 3.2.x shares.
@
text
@d946 3
a948 1
		       FILE_SHARE_VALID_FLAGS, FILE_SYNCHRONOUS_IO_NONALERT);
@


1.30
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d879 3
@


1.29
log
@* mount.cc: Change comment.
(smb_extended_info): Move here from path.cc.
(fs_info::update): Ditto.
(mount_info::create_root_entry): Delay conversion to slashes and use passed in
buffer to figure out fs type.
* path.cc (smb_extended_info): Move.
(fs_info::update): Ditto.
* mount.h: New file.  Move mount information here.
* path.h: (fs_info::update): Move.
* shared_info.h (mount_item): Ditto.
@
text
@d4 1
a4 1
   2006, 2007, 2008 Red Hat, Inc.
d33 1
@


1.28
log
@* cygheap.cc (cygheap_user::~cygheap_user): Remove unneeded if 0'ed code.
* fhandler_registry.cc (fhandler_registry::exists): Recode goto as if/else to
avoid a gcc4 compiler warning.
(fhandler_registry::open): Ditto.  Use one goto rather than two.
* gentls_offsets: Fix compiler warning in generated output.
* tlsoffsets.h: Regenerate.
* mount.cc (fillout_mntent): slashify native paths returned via getmntent.
@
text
@d1 1
a1 1
/* path.cc: path support.
d16 1
d25 1
a28 1
#include "shared_info.h"
d86 195
a1320 1
  slashify (native_path, _my_tls.locals.mnt_fsname, false);
d1333 1
a1333 1
  get_nt_native_path (_my_tls.locals.mnt_fsname, unat);
d1355 2
@


1.27
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d1125 1
a1125 1
  strcpy (_my_tls.locals.mnt_fsname, native_path);
d1138 1
a1138 1
  get_nt_native_path (native_path, unat);
@


1.26
log
@	* mount.cc (mount_info::cygdrive_win32_path): Always upper case
	DOS drive letter to accommodate case sensitivity.
	(cygdrive_getmntent): Ditto.
	* path.cc (path_conv::check): Invalidate wide_path after making path
	relative.
@
text
@d45 2
a46 2
/* is_unc_share: Return non-zero if PATH begins with //server/share 
                 or with one of the native prefixes //./ or //?/ 
d108 1
a108 1
  
d619 1
a619 1
{   
d646 1
a646 1
        *p++ = '\0';
d648 1
a648 1
        p = strchr (options, '\0');
d653 8
a660 8
        if (strcmp (options, o->name) == 0)
          {
            if (o->clear)
              flags &= ~o->val;
            else
              flags |= o->val;
            goto gotit;
          }
d739 1
a739 1
         the rules. */
d773 1
a773 1
        {
d782 1
a782 1
        break;
d784 1
a784 1
         line length is > 32K.  We don't take such long lines.  Print
d787 1
a787 1
        {
d790 1
a790 1
	  				 (sizeof (buf) - 2), NULL, NULL)))
d796 1
a796 1
	        {
d806 1
a806 1
         the buffer and reposition got so that it points to the end of
d872 1
a872 1
        path[cygdrive_len - 1] = '\0';
d1020 1
a1020 1
        {
@


1.25
log
@* net.cc (in6addr_any, in6addr_loopback): Add appropriate number of braces
around initializer.
(dup_ent): Try harder to coerce the first argument to deal with more stringent
compiler.
(get_2k_ifs): Remove extraneous typedef.
(get_2k_ifs): Reorganize expression to avoid a compiler warning.
(get_xp_ifs): Ditto.
(get_nt_ifs): Ditto.
@
text
@d406 2
a407 1
      dst[0] = cyg_tolower (*p);
d1215 1
a1215 1
      __small_sprintf (native_path, "%c:\\", drive);
@


1.24
log
@	* mount.cc (mount_info::get_mounts_here): Don't subtract 2 from
	Length if it's 0 anyway.
@
text
@d609 1
a609 1
  while (sp = strstr (sp, "\\040"))
@


1.23
log
@	* mount.cc (mount_info::create_root_entry): Create default cygdrive
	prefix with MOUNT_NOPOSIX flag.
@
text
@d358 2
a359 1
  cygd->Length -= 2;	// Strip trailing slash
@


1.22
log
@	* mount.cc (fillout_mntent): Always print noumount option last.
@
text
@d95 1
a95 1
  cygdrive_flags = MOUNT_BINARY | MOUNT_CYGDRIVE;
@


1.21
log
@	* mount.cc (fillout_mntent): Print options as taken in fstab and mount.
@
text
@d1180 3
a1185 3
  if (!(flags & MOUNT_SYSTEM))		/* user mount */
    strcat (_my_tls.locals.mnt_opts, (char *) ",user");

@


1.20
log
@* mount.cc (mount_info::init): Add location where we're looking for fstab to
temporary message.
* lib/cygwin_crt0.c (cygwin_crt0): Simplify by eliminating accommodations for
ancient cygwin DLLs.
* lib/crt0.h: Include <windows.h> directly since it is needed.
@
text
@d1163 1
a1163 1
    strcpy (_my_tls.locals.mnt_opts, (char *) "textmode");
d1165 1
a1165 1
    strcpy (_my_tls.locals.mnt_opts, (char *) "binmode");
a1184 2
  else					/* system mount */
    strcat (_my_tls.locals.mnt_opts, (char *) ",system");
@


1.19
log
@	* dcrt0.cc (dll_crt0_0): Call malloc_init and user_shared_initialize_1
	here in case we're dynamically loaded.  Explain why.
	(dll_crt0_1): Call user_shared_initialize_1 from here.
	* mount.cc (is_native_path): New inline function testing for native
	and long Win32 path prefix.
	(is_unc_share): Remove long WIn32 path prefix test.
	(mount_info::create_root_entry): Use PATH_MAX buffer.
	(mount_info::init): Ditto.
	(mount_info::add_item): Test for is_native_path as well.
	* path.cc (normalize_win32_path): Simplify native path prefix code.
	* shared.cc (user_shared_initialize_1): New function taking user
	shared initialization code relying on malloc and cygtls.
	(user_shared_initialize): Move mountinfo initialization to
	user_shared_initialize_1.
	* shared_info.h (user_shared_initialize_1): Declare.
	* syscalls.cc (seteuid32): Call user_shared_initialize_1 after user
	changed.
@
text
@d117 1
a117 1
  small_printf ("Huh?  No /etc/fstab file?  Using default root and cygdrive prefix...\n");
@


1.18
log
@	* mount.cc (mount_info::from_fstab): Change system_printf to
	debug_printf on NtOpenFile failure.
@
text
@d51 10
d66 1
a66 1
	 && (isalnum (path[2]) || path[2] == '.' || path[2] == '?')
d89 2
a90 2
  char native_root[NT_MAX_PATH];
  sys_wcstombs (native_root, NT_MAX_PATH, root);
d107 1
a107 1
  WCHAR path[NT_MAX_PATH];
d985 1
a985 1
      !(is_unc_share (native) || isdrive (native)))
@


1.17
log
@	* shared.cc (user_shared_initialize): Fetch potentially changed Cygwin
	username from /etc/passwd before loading mount table.
	(shared_info::init_installation_root): New function fetching Cygwin's
	installation root dir and storing as native NT path in global shared
	memory.
	(shared_info::initialize): Call init_installation_root exactly once at
	first startup.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add installation_root member.
	(shared_info::init_installation_root): Declare.

	* grp.cc (pwdgrp::read_group): Call pwdgrp::load with native WCHAR path.
	* passwd.cc (pwdgrp::read_passwd): Ditto.  Avoid recursion.
	(etc::init): Take POBJECT_ATTRIBUTES instead of path_conv.
	* path.h (etc::init): Change prototype accordingly.
	* pwdgrp.h (class pwdgrp): Store path as UNICODE_STRING/PWCHAR instead
	of as path_conv.
	(pwdgrp::load): Accommodate prototype.
	* uinfo.cc (pwdgrp::load): Change argument type from char to wchar_t.
	Create native NT path here instead of calling path_conv.

	* mount.cc (find_root_from_cygwin_dll): Drop in favor of global
	initializaion in shared_info.
	(mount_info::init): Fetch native NT root dir from cygwin_shared.
	(mount_info::from_fstab): Expect native NT path and use native NT
	functions to access file.  Convert username part in user fstab path
	according to special char transformation rules.
	* path.cc (tfx_chars): Convert slash to backslash.
	(transform_chars): Implement for path given as PWCHAR.
	(transform_chars): PUNICODE_STRING version calls PWCHAR version.
	Remove useless commented code.
@
text
@d737 1
a737 1
      system_printf ("NtOpenFile(%S) failed, %p", &upath, status);
@


1.16
log
@	* mount.cc (mount_info::from_fstab_line): Default to binary mount.
@
text
@a74 26
/* Use absolute path of cygwin1.dll to derive a "root".
   Return false if GetModuleFileNameW fails or path is "funny".
   Otherwise return true.  */
static inline PWCHAR
find_root_from_cygwin_dll (WCHAR *path)
{
  if (!GetModuleFileNameW (cygwin_hmodule, path, NT_MAX_PATH))
    {
      debug_printf ("GetModuleFileNameW(%p, %p, %u), %E", cygwin_hmodule, path, NT_MAX_PATH);
      return NULL;
    }
  PWCHAR w = wcsrchr (path, L'\\');
  if (w)
    {
      *w = L'\0';
      w = wcsrchr (path, L'\\');
    }
  if (!w)
    {
      debug_printf ("Invalid DLL path");
      return NULL;
    }
  *w = L'\0';
  return w;
}

d98 7
a104 8
  if ((pathend = find_root_from_cygwin_dll (path)))
    {
      create_root_entry (path);
      pathend = wcpcpy (pathend, L"\\etc\\fstab");
      if (from_fstab (false, path, pathend)   /* The single | is correct! */
	  | from_fstab (true, path, pathend))
	  return;
    }
d713 6
d720 12
a731 3
    sys_mbstowcs (wcpcpy (fstab_end, L".d\\"),
		  NT_MAX_PATH - (fstab_end - fstab),
		  cygheap->user.name ());
d733 3
a735 3
  HANDLE h = CreateFileW (fstab, GENERIC_READ, FILE_SHARE_READ, &sec_none_nih,
			  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (h == INVALID_HANDLE_VALUE)
d737 1
a737 1
      debug_printf ("CreateFileW, %E");
d740 1
d746 2
a747 1
  while (ReadFile (h, got, (sizeof (buf) - 2) - (got - buf), &len, NULL))
d751 1
d777 2
a778 1
	  while (ReadFile (h, buf, (sizeof (buf) - 2), &len, NULL))
d780 1
d805 1
a805 1
  CloseHandle (h);
@


1.15
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@d717 1
a717 1
  unsigned mount_flags = MOUNT_SYSTEM;
@


1.14
log
@	Throughout drop allow_ntsec and allow_smbntsec handling.
	* environ.cc (set_ntsec): Remove.
	(set_smbntsec): Remove.
	(known): Remove ntsec and smbntsec options.
	* external.cc (check_ntsec): Return true if no filename is given.
	* mount.cc (oopts): Add "acl" and "noacl" options.  Set MOUNT_NOACL
	flag accordingly.
	(fillout_mntent): Handle MOUNT_NOACL flag.
	* path.h (enum path_types): Add PATH_NOACL.
	* security.cc (allow_ntsec): Remove.
	(allow_smbntsec): Remove.
	* security.h (allow_ntsec): Drop declaration.
	(allow_smbntsec): Drop declaration.
	* include/sys/mount.h (MOUNT_NOACL): Define.
@
text
@d35 1
a35 1
  (path_prefix_p (mount_table->cygdrive, (path), mount_table->cygdrive_len))
d43 1
a43 1
  (path_prefix_p (proc, (path), proc_len))
a152 155
static char dot_special_chars[] =
    "."
    "\001" "\002" "\003" "\004" "\005" "\006" "\007" "\010"
    "\011" "\012" "\013" "\014" "\015" "\016" "\017" "\020"
    "\021" "\022" "\023" "\024" "\025" "\026" "\027" "\030"
    "\031" "\032" "\033" "\034" "\035" "\036" "\037" ":"
    "\\"   "*"    "?"    "%"     "\""   "<"    ">"    "|"
    "A"    "B"    "C"    "D"    "E"    "F"    "G"    "H"
    "I"    "J"    "K"    "L"    "M"    "N"    "O"    "P"
    "Q"    "R"    "S"    "T"    "U"    "V"    "W"    "X"
    "Y"    "Z";
static char *special_chars = dot_special_chars + 1;
static char special_introducers[] =
    "anpcl";

static char
special_char (const char *s, const char *valid_chars = special_chars)
{
  if (*s != '%' || strlen (s) < 3)
    return 0;

  char *p;
  char hex[] = {s[1], s[2], '\0'};
  unsigned char c = strtoul (hex, &p, 16);
  p = strechr (valid_chars, c);
  return *p;
}

/* Determines if name is "special".  Assumes that name is empty or "absolute" */
static int
special_name (const char *s, int inc = 1)
{
  if (!*s)
    return false;

  s += inc;

  if (strcmp (s, ".") == 0 || strcmp (s, "..") == 0)
    return false;

  int n;
  const char *p = NULL;
  if (ascii_strncasematch (s, "conin$", n = 5)
      || ascii_strncasematch (s, "conout$", n = 7)
      || ascii_strncasematch (s, "nul", n = 3)
      || ascii_strncasematch (s, "aux", 3)
      || ascii_strncasematch (s, "prn", 3)
      || ascii_strncasematch (s, "con", 3))
    p = s + n;
  else if (ascii_strncasematch (s, "com", 3)
	   || ascii_strncasematch (s, "lpt", 3))
    strtoul (s + 3, (char **) &p, 10);
  if (p && (*p == '\0' || *p == '.'))
    return -1;

  return (strchr (s, '\0')[-1] == '.')
	 || (strpbrk (s, special_chars) && !ascii_strncasematch (s, "%2f", 3));
}

bool
fnunmunge (char *dst, const char *src)
{
  bool converted = false;
  char c;

  if ((c = special_char (src, special_introducers)))
    {
      __small_sprintf (dst, "%c%s", c, src + 3);
      if (special_name (dst, 0))
	{
	  *dst++ = c;
	  src += 3;
	}
    }

  while (*src)
    if (!(c = special_char (src, dot_special_chars)))
      *dst++ = *src++;
    else
      {
	converted = true;
	*dst++ = c;
	src += 3;
      }

  *dst = *src;
  return converted;
}

static bool
copy1 (char *&d, const char *&src, int& left)
{
  left--;
  if (left || !*src)
    *d++ = *src++;
  else
    return true;
  return false;
}

static bool
copyenc (char *&d, const char *&src, int& left)
{
  char buf[16];
  int n = __small_sprintf (buf, "%%%02x", (unsigned char) *src++);
  left -= n;
  if (left <= 0)
    return true;
  strcpy (d, buf);
  d += n;
  return false;
}

int
mount_item::fnmunge (char *dst, const char *src, int& left)
{
  int name_type;
  if (!(name_type = special_name (src)))
    {
      if ((int) strlen (src) >= left)
	return ENAMETOOLONG;
      else
	strcpy (dst, src);
    }
  else
    {
      char *d = dst;
      if (copy1 (d, src, left))
	  return ENAMETOOLONG;
      if (name_type < 0 && copyenc (d, src, left))
	return ENAMETOOLONG;

      while (*src)
	if (!strchr (special_chars, *src) || (*src == '%' && !special_char (src)))
	  {
	    if (copy1 (d, src, left))
	      return ENAMETOOLONG;
	  }
	else if (copyenc (d, src, left))
	  return ENAMETOOLONG;

      char dot[] = ".";
      const char *p = dot;
      if (*--d != '.')
	d++;
      else if (copyenc (d, p, left))
	return ENAMETOOLONG;

      *d = *src;
    }

  backslashify (dst, dst, 0);
  return 0;
}

d176 1
a176 1
  else if ((!(flags & MOUNT_ENC) && isdrive (dst) && !dst[2]) || *p)
d178 2
a179 8
  //if (!*p || !(flags & MOUNT_ENC))
    //{
      if ((n + strlen (p)) >= NT_MAX_PATH)
	err = ENAMETOOLONG;
      else
	backslashify (p, dst + n, 0);
#if 0
    }
d181 1
a181 20
    {
      int left = NT_MAX_PATH - n;
      while (*p)
	{
	  char slash = 0;
	  char *s = strchr (p + 1, '/');
	  if (s)
	    {
	      slash = *s;
	      *s = '\0';
	    }
	  err = fnmunge (dst += n, p, left);
	  if (!s || err)
	    break;
	  n = strlen (dst);
	  *s = slash;
	  p = s;
	}
    }
#endif
d316 1
a316 1
      if (path_prefix_p (path, src_path, len))
d516 2
a517 1
      if (!path_prefix_p (mi.native_path, pathbuf, mi.native_pathlen))
a549 8
#if 0
      if (mi.flags & MOUNT_ENC)
	{
	  char *tmpbuf = tp.c_get ();
	  if (fnunmunge (tmpbuf, posix_path))
	    strcpy (posix_path, tmpbuf);
	}
#endif
d598 2
a599 1
      if (path_prefix_p (mi.native_path, p, mi.native_pathlen))
a647 1
  {"managed", MOUNT_ENC, 0},
d649 3
a651 1
  {"noacl", MOUNT_NOACL, 0}
d1014 1
a1014 1
      if (strcasematch (mount[i].posix_path, posixtmp))
d1076 1
a1076 1
	   ? strcasematch (mount[ent].posix_path, pathtmp)
d1133 1
a1133 1
  get_nt_native_path (native_path, unat, flags & MOUNT_ENC);
a1169 2
  if (flags & MOUNT_ENC)
    strcat (_my_tls.locals.mnt_opts, ",managed");
d1174 3
@


1.13
log
@	* mount.cc (mount_info::get_cygdrive_info): Fix usage of user and
	system arguments.  Strip trailing slash from path for backward
	compatibility.
@
text
@d834 3
a836 1
  {"managed", MOUNT_ENC, 0}
d1358 3
@


1.12
log
@	* mount.cc (mount_info::from_fstab): Read sizeof (buf) - 2 bytes.
	Add code to handle overly long lines.
@
text
@d1030 2
a1031 2
mount_info::get_cygdrive_info (char *user, char *system, char* user_flags,
			       char* system_flags)
d1035 2
a1036 1
  /* Get the user flags, if appropriate */
d1039 2
d1042 2
a1043 6
  if (system)
    strcpy (system, cygdrive);

  if (system_flags)
    strcpy (system_flags,
	    (cygdrive_flags & MOUNT_BINARY) ? "binmode" : "textmode");
d1045 9
@


1.11
log
@* mount.cc (mount_info::from_fstab): Use proper buffer size.
@
text
@d938 3
a940 2
  /* Using buffer size - 1 leaves space to append two \0. */
  while (ReadFile (h, got, (sizeof (buf) - 1) - (got - buf), &len, NULL))
d950 2
d954 1
d959 1
d961 1
a961 1
      if (len < (sizeof (buf) - 1))
d963 20
d991 1
@


1.10
log
@* mount.cc (mount_info::init): Revert previous change.
(mount_info::from_fstab): Change system_printf to debug_printf.  Just use a
local NT_MAX_PATH sized temporary buffer.
@
text
@d938 2
a939 3
  /* Using NT_MAX_PATH-1 leaves space to append two \0. */
  while (ReadFile (h, got, (NT_MAX_PATH - 1) * sizeof (WCHAR) - (got - buf),
		   &len, NULL))
d956 1
a956 1
      if (len < (NT_MAX_PATH - 1) * sizeof (WCHAR))
@


1.9
log
@	* mount.cc (mount_info::init): Recreate path when trying to read the
	user fstab file.
@
text
@d129 1
a129 2
	  | from_fstab (true, path, wcpcpy (find_root_from_cygwin_dll (path),
				    L"\\etc\\fstab")))
d927 1
a927 1
  system_printf ("Try to read mounts from %W", fstab);
d935 1
a935 1
  char *const buf = reinterpret_cast<char *const> (fstab);
@


1.8
log
@* mount.cc (find_root_from_cygwin_dll): New function factored from from_fstab.
Avoid use of tls since it isn't necessarily initialized when cygwin1.dll is
dynamically loaded.
(mount_info::create_root_entry): Ditto.
(mount_info::init): Calculate cygwin root once.  Use create_root_entry to
record it.  Pass fstab location to from_fstab.
(mount_info::from_fstab): Move root calculation stuff elsewhere, as per above.
* shared_info.h (mount_info::from_fstab_line): Make private.
(mount_info::fstab): Ditto.  Accommodate new arguments.
@
text
@d128 3
a130 1
      if (from_fstab (false, path, pathend) | from_fstab (true, path, pathend))   /* The single | is correct! */
d928 1
a928 1
  debug_printf ("Try to read mounts from %W", fstab);
@


1.7
log
@* mount.cc (mount_info::from_fstab): Use cygwin_hmodule rather than trying to
find handle based on cygwin1.dll.
* path.cc (symlink_info::check): Remove unused variable.
@
text
@d75 41
d122 9
a130 3

  if (from_fstab (false) | from_fstab (true))   /* The single | is correct! */
      return;
d920 1
a920 1
mount_info::from_fstab (bool user)
a921 38
  tmp_pathbuf tp;
  PWCHAR path_buf = tp.w_get ();
  PWCHAR path = path_buf;
  PWCHAR w;
  
  if (!GetModuleFileNameW (cygwin_hmodule, path, NT_MAX_PATH))
    {
      debug_printf ("GetModuleFileNameW(%p, path, %u), %E", cygwin_hmodule, NT_MAX_PATH);
      return false;
    }
  w = wcsrchr (path, L'\\');
  if (w)
    {
      *w = L'\0';
      w = wcsrchr (path, L'\\');
    }
  if (!w)
    {
      debug_printf ("Invalid DLL path");
      return false;
    }

  if (!user)
    {
      /* Create a default root dir from the path the Cygwin DLL is in. */
      *w = L'\0';
      char *native_root = tp.c_get ();
      sys_wcstombs (native_root, NT_MAX_PATH, path);
      mount_table->add_item (native_root, "/", MOUNT_SYSTEM | MOUNT_BINARY);
      /* Create a default cygdrive entry.  Note that this is a user entry.
         This allows to override it with mount, unless the sysadmin created
	 a cygdrive entry in /etc/fstab. */
      cygdrive_flags = MOUNT_BINARY | MOUNT_CYGDRIVE;
      strcpy (cygdrive, CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX "/");
      cygdrive_len = strlen (cygdrive);
    }

  PWCHAR u = wcpcpy (w, L"\\etc\\fstab");
d923 2
a924 1
    sys_mbstowcs (wcpcpy (u, L".d\\"), NT_MAX_PATH - (u - path),
d926 2
a927 2
  debug_printf ("Try to read mounts from %W", path);
  HANDLE h = CreateFileW (path, GENERIC_READ, FILE_SHARE_READ, &sec_none_nih,
d934 1
a934 1
  char *const buf = reinterpret_cast<char *const> (path);
@


1.6
log
@	* Makefile.in (DLL_OFILES): Add nfs.o.
	* fhandler.cc (fhandler_base::open): Open files on NFS shares with
	correct access flags and EAs.
	* fhandler.h (fhandler_base::fstat_by_nfs_ea): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): New method.
	(fhandler_base::fstat_by_handle): Call fstat_by_nfs_ea for files on
	NFS shares.
	(fhandler_disk_file::fchmod): Use NFS specific method to set mode for
	files on NFS shares.  Don't overrule errno from call to
	set_file_attribute with errno from NtSetInformationFile call.
	(fhandler_disk_file::fchown): Add comment.
	* mount.cc (fillout_mntent): Accommodate change in second parameter
	to fs_info::update.
	* nfs.cc: New file.
	* nfs.h: New file.
	* path.cc (fs_info::update): Take handle instead of bool as second
	parameter.  Use that handle if it's not NULL.  Only close handle if
	it has been opened here.  Use static defined buffers instead of
	alloca'd buffers.
	(path_conv::check): Call symlink_info::check with reference to fs.
	Don't call fs.update here if file exists.
	(conv_path_list): Prefer tmp_pathbuf buffer over using alloca.
	(symlink_worker): Use NFS specific method to create symlinks on NFS
	shares.  Prefer tmp_pathbuf buffer over using alloca.
	(symlink_info::check_shortcut): Reopen file from incoming handle
	with necessary FILE_GENERIC_READ flag.  Prefer tmp_pathbuf buffer over
	using alloca.
	(symlink_info::check_sysfile): Ditto.
	(symlink_info::check_reparse_point): Use tmp_pathbuf buffer to
	allocate REPARSE_DATA_BUFFER.
	(symlink_info::check_nfs_symlink): New method.
	(enum symlink_t): Remove.
	(symlink_info::check): Don't use NtQueryAttributesFile.  Rather, open
	file with necessary access flags and call NtQueryInformationFile.  Fix
	error handling in case file can't be opened.  For existing files, call
	fs_info::update here.  Restructure symlink checking to accommodate the
	fact that the file is already open.  Add case for NFS symlinks.
	* path.h (fs_info::update): Take handle instead of bool as second
	parameter.
@
text
@d880 1
a880 2
  if (!GetModuleFileNameW (GetModuleHandleW (L"cygwin1.dll"),
			   path, NT_MAX_PATH))
d882 1
a882 1
      debug_printf ("GetModuleFileNameW, %E");
@


1.5
log
@	* mount.cc (is_unc_share): Allow \\?\ prefix as well.  Enhance comment.
	(mount_info::from_fstab): Remove patch from 2008-04-29.

	* mount.cc (mount_info::conv_to_posix_path): Simplify test for native
	UNC path.
	* path.cc (normalize_win32_path): Ditto.
	(symlink_worker): Ditto.
	(symlink_info::posixify): Ditto.
	(cygwin_conv_path): Ditto.
@
text
@d1276 1
a1276 1
  mntinfo.update (&unat, true);  /* this pulls from a cache, usually. */
@


1.4
log
@	* mount.cc (mount_info::from_fstab): Skip native path prefix in
	module path.
@
text
@d45 4
a48 1
/* is_unc_share: Return non-zero if PATH begins with //UNC/SHARE */
d56 1
a56 1
	 && (isalnum (path[2]) || path[2] == '.')
d582 1
a582 1
      if (!wcsncmp (src_path, L"UNC\\", 4))
d584 1
a584 2
	  src_path += 2;
	  src_path[0] = L'\\';
a885 6
  if (!wcsncmp (path, L"\\\\?\\", 4))
    {
      path += 4;
      if (path[1] != L':')
        *(path += 2) = L'\\';
    }
@


1.3
log
@	* mount.cc (mount_info::init): Remove call to from_registry.  Print
	message that fstab is missing.
	(mount_info::from_fstab): Use CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX
	instead of constant string.
	(mount_info::read_mounts): Remove.
	(mount_info::from_registry): Remove.
	(mount_info::read_cygdrive_info_from_registry): Remove.
	* postinstall: Enable code to create fstab entries from old registry
	entries.
	* registry.cc (reg_key::reg_key): Drop CYGWIN_INFO_CYGNUS_REGISTRY_NAME
	from registry key.
	* shared_info.h (mount_info::read_mounts): Remove declaration.
	(mount_info::from_registry): Ditto.
	(mount_info::to_registry): Ditto.
	(mount_info::read_cygdrive_info_from_registry): Ditto.
	* winver.rc (CYGWIN_REGISTRY_KEY): Remove.
	(LegalCopyright): Fix to include 2008.
	(RegistryKey): Set to CYGWIN_INFO_CYGWIN_REGISTRY_NAME.
	* include/cygwin/version.h (CYGWIN_INFO_CYGNUS_REGISTRY_NAME): Remove.
@
text
@d874 2
a875 1
  PWCHAR path = tp.w_get ();
d884 6
@


1.2
log
@	* mount.cc (mount_info::from_fstab): Read user fstab files from
	/etc/fstab.d/$USER to avoid user write access to /etc.
	* postinstall: Use variables for filenames.  Create /etc/fstab.d dir
	with 01777 permissions.
@
text
@a27 1
#include "registry.h"
d79 2
a80 2
  if (from_fstab (false) | from_fstab (true))	/* The single | is correct! */
    return;
d82 2
a83 6
  /* FIXME: Remove fetching from registry before releasing 1.7.0. */

  /* Fetch the mount table and cygdrive-related information from
     the registry.  */
  system_printf ("Fallback to fetching mounts from registry");
  from_registry ();
d906 1
a906 1
      strcpy (cygdrive, "/cygdrive/");
a960 116
/* read_mounts: Given a specific regkey, read mounts from under its
   key. */
/* FIXME: Remove before releasing 1.7.0. */

void
mount_info::read_mounts (reg_key& r)
{
  tmp_pathbuf tp;
  char *native_path = tp.c_get ();
  /* FIXME: The POSIX path is stored as value name right now, which is
     restricted to 256 bytes. */
  char posix_path[CYG_MAX_PATH];
  HKEY key = r.get_key ();
  DWORD i, posix_path_size;
  int res;

  /* Loop through subkeys */
  /* FIXME: we would like to not check MAX_MOUNTS but the heap in the
     shared area is currently statically allocated so we can't have an
     arbitrarily large number of mounts. */
  for (i = 0; ; i++)
    {
      int mount_flags;

      posix_path_size = sizeof (posix_path);
      /* FIXME: if maximum posix_path_size is 256, we're going to
	 run into problems if we ever try to store a mount point that's
	 over 256 but is under CYG_MAX_PATH. */
      res = RegEnumKeyEx (key, i, posix_path, &posix_path_size, NULL,
			  NULL, NULL, NULL);

      if (res == ERROR_NO_MORE_ITEMS)
	break;
      else if (res != ERROR_SUCCESS)
	{
	  debug_printf ("RegEnumKeyEx failed, error %d!", res);
	  break;
	}

      /* Get a reg_key based on i. */
      reg_key subkey = reg_key (key, KEY_READ, posix_path, NULL);

      /* Fetch info from the subkey. */
      subkey.get_string ("native", native_path, NT_MAX_PATH, "");
      mount_flags = subkey.get_int ("flags", 0);

      /* Add mount_item corresponding to registry mount point. */
      res = mount_table->add_item (native_path, posix_path, mount_flags);
      if (res && get_errno () == EMFILE)
	break; /* The number of entries exceeds MAX_MOUNTS */
    }
}

/* from_registry: Build the entire mount table from the registry.  Also,
   read in cygdrive-related information from its registry location. */
/* FIXME: Remove before releasing 1.7.0. */

void
mount_info::from_registry ()
{

  /* Retrieve cygdrive-related information. */
  read_cygdrive_info_from_registry ();

  nmounts = 0;

  /* First read mounts from user's table.
     Then read mounts from system-wide mount table while deimpersonated . */
  for (int i = 0; i < 2; i++)
    {
      if (i)
	cygheap->user.deimpersonate ();
      reg_key r (i, KEY_READ, CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);
      read_mounts (r);
      if (i)
	cygheap->user.reimpersonate ();
    }
}

/* read_cygdrive_info_from_registry: Read the default prefix and flags
   to use when creating cygdrives from the special user registry
   location used to store cygdrive information. */
/* FIXME: Remove before releasing 1.7.0. */

void
mount_info::read_cygdrive_info_from_registry ()
{
  /* First read cygdrive from user's registry.
     If failed, then read cygdrive from system-wide registry
     while deimpersonated. */
  for (int i = 0; i < 2; i++)
    {
      if (i)
	cygheap->user.deimpersonate ();
      reg_key r (i, KEY_READ, CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);
      if (i)
	cygheap->user.reimpersonate ();

      if (r.get_string (CYGWIN_INFO_CYGDRIVE_PREFIX, cygdrive, sizeof (cygdrive),
			CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX) != ERROR_SUCCESS && i == 0)
	continue;

      /* Fetch user cygdrive_flags from registry; returns MOUNT_CYGDRIVE on error. */
      cygdrive_flags = r.get_int (CYGWIN_INFO_CYGDRIVE_FLAGS,
				  MOUNT_CYGDRIVE | MOUNT_BINARY);
      /* Sanitize */
      if (i == 0)
	cygdrive_flags &= ~MOUNT_SYSTEM;
      else
	cygdrive_flags |= MOUNT_SYSTEM;
      slashify (cygdrive, cygdrive, 1);
      cygdrive_len = strlen (cygdrive);
      break;
    }
}

@


1.1
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@d917 1
a917 1
    sys_mbstowcs (wcpcpy (u, L"."), NT_MAX_PATH - (u - path),
@

