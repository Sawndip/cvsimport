head	1.43;
access;
symbols
	cygwin-1_7_35-release:1.43
	cygwin-1_7_34-release:1.42
	cygwin-1_7_33-release:1.40.2.2
	cygwin-1_7_32-release:1.40.2.1
	cygwin-1_7_31-release:1.40.2.1
	cygwin-1_7_30-release:1.40.2.1
	cygwin-1_7_29-release:1.40.2.1
	cygwin-1_7_29-release-branchpoint:1.40.0.2
	cygwin-pre-user-db:1.40
	cygwin-1_7_28-release:1.40
	cygwin-1_7_27-release:1.40
	cygwin-1_7_26-release:1.40
	cygwin-1_7_25-release:1.40
	cygwin-1_7_24-release:1.40
	cygwin-1_7_23-release:1.40
	cygwin-1_7_22-release:1.40
	cygwin-1_7_21-release:1.40
	cygwin-1_7_20-release:1.40
	cygwin-1_7_19-release:1.40
	cygwin-64bit-postmerge:1.40
	cygwin-64bit-premerge-branch:1.39.0.2
	cygwin-64bit-premerge:1.39
	cygwin-1_7_18-release:1.39
	post-ptmalloc3:1.38.8.3
	pre-ptmalloc3:1.38.8.3
	cygwin-1_7_17-release:1.38
	cygwin-64bit-branch:1.38.0.8
	cygwin-1_7_16-release:1.38
	cygwin-1_7_15-release:1.38
	cygwin-1_7_14_2-release:1.38
	cygwin-1_7_14-release:1.38
	cygwin-1_7_12-release:1.38
	cygwin-1_7_11-release:1.38
	cygwin-1_7_10-release:1.38
	signal-rewrite:1.38.0.6
	pre-notty:1.38
	cygwin-1_7_9-release:1.38
	cv-post-1_7_9:1.38.0.4
	cygwin-1_7_8-release:1.38
	cygwin-1_7_7-release:1.38
	cygwin-1_7_5-release:1.38
	cygwin-1_7_4-release:1.38
	cygwin-1_7_3-release:1.38
	cygwin-1_7_2-release:1.38
	fifo_doover3:1.38.0.2
	cygwin-1_7_1-release:1.37
	prefifo:1.37
	cv-branch-2:1.37.0.2
	pre-ripout-set_console_state_for_spawn:1.35
	EOL_registry_mounts:1.34
	preoverlapped:1.31
	drop_9x_support_start:1.31
	cr-0x5f1:1.31.0.8
	cv-branch:1.31.0.6
	pre-ptymaster-archetype:1.31
	cr-0x3b58:1.31.0.4
	cr-0x5ef:1.31.0.2
	after-mmap-privanon-noreserve:1.31
	after-mmap-revamp:1.31
	before-mmap-revamp:1.31
	cgf-more-exit-sync:1.31
	post_wait_sig_exit:1.31
	pre_wait_sig_exit:1.31
	reparent-point:1.30
	noreparent:1.30.0.2
	cr-0x5e6:1.28.0.2
	cr-0x9e:1.25.0.6
	cr-0x9d:1.25.0.4
	cgf-deleteme:1.25.0.2
	pre-sigrewrite:1.24
	corinna-01:1.21
	cr-0x9c:1.20.0.4
	cr-0x9b:1.20.0.2
	cr-0x99:1.20
	Z-emcb-cygwin_daemon:1.19.0.2
	w32api-2_2:1.15
	mingw-runtime-2_4:1.15
	pre-cgf-merge:1.20
	cgf-dev-branch:1.15.0.16
	cygwin_daemon_merge_HEAD:1.1
	Z-cygwin_daemon_merge_HEAD:1.15
	Z-cygwin_daemon_merge-new_HEAD:1.15
	cygwin_daemon:1.1.0.2;
locks; strict;
comment	@// @;


1.43
date	2015.03.03.17.09.29;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2014.08.22.09.21.31;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.07.11.25.58;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches
	1.38.8.1;
next	1.37;

1.37
date	2009.03.31.14.58.14;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.21.17.14.37;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.06.13.29.53;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.05.15.25.55;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.05.10.15.31;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.03.02.40.29;	author cgf;	state Exp;
branches
	1.31.8.1;
next	1.30;

1.30
date	2004.07.20.16.08.49;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.30.15.20.04;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.28.21.01.33;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.26.16.24.24;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.21.22.22.08;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.20.18.09.44;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.19.18.50.21;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.22.10.07.58;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.31.00.40.16;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.25.18.21.07;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.02.03.16.00;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.09.21.51.00;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.22.12.04.15;	author scottc;	state Exp;
branches
	1.15.16.1;
next	1.14;

1.14
date	2002.09.21.13.03.23;	author scottc;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.23.22.56.56;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.06.11.17.50;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.05.04.01.43;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.29.15.04.27;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.28.14.10.52;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.05.12.58.24;	author rbcollins;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.04.08.12.53;	author rbcollins;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.04.07.22.08;	author rbcollins;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.03.12.50.06;	author rbcollins;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.28.14.30.28;	author rbcollins;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.25.06.31.04;	author rbcollins;	state dead;
branches
	1.1.2.1;
next	;

1.40.2.1
date	2014.04.07.11.26.16;	author corinna;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2014.11.13.12.53.06;	author corinna;	state Exp;
branches;
next	;

1.38.8.1
date	2012.12.05.10.31.56;	author corinna;	state Exp;
branches;
next	1.38.8.2;

1.38.8.2
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.38.8.3;

1.38.8.3
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	1.38.8.4;

1.38.8.4
date	2013.03.01.10.57.55;	author corinna;	state Exp;
branches;
next	;

1.31.8.1
date	2007.11.12.15.30.20;	author corinna;	state Exp;
branches;
next	;

1.15.16.1
date	2003.03.10.00.07.01;	author cgf;	state Exp;
branches;
next	1.15.16.2;

1.15.16.2
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.15.16.3;

1.15.16.3
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.15.16.4;

1.15.16.4
date	2003.09.02.02.31.08;	author cgf;	state Exp;
branches;
next	;

1.1.2.1
date	2001.09.25.06.31.04;	author rbcollins;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.09.30.13.56.37;	author rbcollins;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.02.06.46.06;	author rbcollins;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.02.12.55.10;	author rbcollins;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.10.07.21.58.20;	author rbcollins;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2002.06.13.14.34.11;	author rbcollins;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2002.06.15.21.01.45;	author scottc;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2002.06.15.23.39.46;	author scottc;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2002.06.16.12.15.23;	author scottc;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2002.06.16.14.44.56;	author scottc;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2002.06.17.21.35.33;	author scottc;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2002.06.24.10.55.35;	author scottc;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2002.06.28.18.04.02;	author scottc;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2002.07.02.14.54.27;	author scottc;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	2002.07.03.02.40.49;	author scottc;	state Exp;
branches;
next	1.1.2.16;

1.1.2.16
date	2002.07.03.15.35.43;	author scottc;	state Exp;
branches;
next	1.1.2.17;

1.1.2.17
date	2002.07.10.14.40.16;	author scottc;	state Exp;
branches;
next	1.1.2.18;

1.1.2.18
date	2002.07.11.18.15.40;	author scottc;	state Exp;
branches;
next	1.1.2.19;

1.1.2.19
date	2002.07.11.21.49.08;	author scottc;	state Exp;
branches;
next	1.1.2.20;

1.1.2.20
date	2002.07.27.01.16.35;	author scottc;	state Exp;
branches;
next	1.1.2.21;

1.1.2.21
date	2002.09.21.09.52.33;	author scottc;	state Exp;
branches;
next	1.1.2.22;

1.1.2.22
date	2002.09.22.10.31.45;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.43
log
@	* msg.cc: Throughout, drop raising SIGSYS if cygserver is not running.
	* sem.cc: Ditto.
	* shm.cc: Ditto.
@
text
@/* shm.cc: XSI IPC interface for Cygwin.

   Copyright 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2012, 2013, 2014,
   2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <sys/queue.h>
#include <unistd.h>

#include "pinfo.h"
#include "sigproc.h"

#include "cygserver_shm.h"
#include "cygtls.h"
#include "sync.h"
#include "ntdll.h"

/*
 * client_request_shm Constructors
 */

client_request_shm::client_request_shm (int shmid,
					const void *shmaddr,
					int shmflg)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmat;
  ipc_set_proc_info (_parameters.in.ipcblk);

  _parameters.in.atargs.shmid = shmid;
  _parameters.in.atargs.shmaddr = shmaddr;
  _parameters.in.atargs.shmflg = shmflg;

  msglen (sizeof (_parameters.in));
}

client_request_shm::client_request_shm (int shmid,
					int cmd,
					struct shmid_ds *buf)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmctl;
  ipc_set_proc_info (_parameters.in.ipcblk);

   _parameters.in.ctlargs.shmid = shmid;
   _parameters.in.ctlargs.cmd = cmd;
   _parameters.in.ctlargs.buf = buf;

  msglen (sizeof (_parameters.in));
}

client_request_shm::client_request_shm (const void *shmaddr)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmdt;
  ipc_set_proc_info (_parameters.in.ipcblk);

  _parameters.in.dtargs.shmaddr = shmaddr;

  msglen (sizeof (_parameters.in));
}

client_request_shm::client_request_shm (key_t key,
					size_t size,
					int shmflg)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmget;
  ipc_set_proc_info (_parameters.in.ipcblk);

  _parameters.in.getargs.key = key;
  _parameters.in.getargs.size = size;
  _parameters.in.getargs.shmflg = shmflg;

  msglen (sizeof (_parameters.in));
}

client_request_shm::client_request_shm (proc *p1)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmfork;
  ipc_set_proc_info (_parameters.in.ipcblk, true);

  _parameters.in.forkargs = *p1;
}

/* List of shmid's with file mapping HANDLE and size, returned by shmget. */
struct shm_shmid_list {
  SLIST_ENTRY (shm_shmid_list) ssh_next;
  int shmid;
  vm_object_t hdl;
  size_t size;
  int ref_count;
};

static SLIST_HEAD (, shm_shmid_list) ssh_list;

/* List of attached mappings, as returned by shmat. */
struct shm_attached_list {
  SLIST_ENTRY (shm_attached_list) sph_next;
  vm_object_t ptr;
  shm_shmid_list *parent;
  ULONG access;
};

static SLIST_HEAD (, shm_attached_list) sph_list;

static NO_COPY muto shm_guard;
#define SLIST_LOCK()	(shm_guard.init ("shm_guard")->acquire ())
#define SLIST_UNLOCK()	(shm_guard.release ())

int __stdcall
fixup_shms_after_fork ()
{
  if (!SLIST_FIRST (&sph_list))
    return 0;
  pinfo p (myself->ppid);
  proc parent = { myself->ppid, p->dwProcessId, p->uid, p->gid };

  client_request_shm request (&parent);
  if (request.make_request () == -1 || request.retval () == -1)
    {
      syscall_printf ("-1 [%d] = fixup_shms_after_fork ()", request.error_code ());
      set_errno (request.error_code ());
      return 0;
    }
  shm_attached_list *sph_entry;
  /* Reconstruct map from list... */
  SLIST_FOREACH (sph_entry, &sph_list, sph_next)
    {
      NTSTATUS status;
      vm_object_t ptr = sph_entry->ptr;
      SIZE_T viewsize = sph_entry->parent->size;
      status = NtMapViewOfSection (sph_entry->parent->hdl, NtCurrentProcess (),
				   &ptr, 0, sph_entry->parent->size, NULL,
				   &viewsize, ViewShare, 0, sph_entry->access);
      if (!NT_SUCCESS (status) || ptr != sph_entry->ptr)
	api_fatal ("fixup_shms_after_fork: NtMapViewOfSection (%p), status %y.  Terminating.",
		   sph_entry->ptr, status);
    }
  return 0;
}

/*
 * XSI shmaphore API.  These are exported by the DLL.
 */

extern "C" void *
shmat (int shmid, const void *shmaddr, int shmflg)
{
  syscall_printf ("shmat (shmid = %d, shmaddr = %p, shmflg = %y)",
		  shmid, shmaddr, shmflg);

  SLIST_LOCK ();
  shm_shmid_list *ssh_entry;
  SLIST_FOREACH (ssh_entry, &ssh_list, ssh_next)
    {
      if (ssh_entry->shmid == shmid)
	break;
    }
  if (!ssh_entry)
    {
      /* The shmid is unknown to this process so far.  Try to get it from
	 the server if it exists.  Use special internal call to shmget,
	 which interprets the key as a shmid and only returns a valid
	 shmid if one exists.  Since shmctl inserts a new entry for this
	 shmid into ssh_list automatically, we just have to go through
	 that list again.  If that still fails, well, bad luck. */
      if (shmid && shmget ((key_t) shmid, 0, IPC_KEY_IS_SHMID) != -1)
	{
	  SLIST_FOREACH (ssh_entry, &ssh_list, ssh_next)
	    {
	      if (ssh_entry->shmid == shmid)
		break;
	    }
	}
      if (!ssh_entry)
	{
	  /* Invalid shmid */
	  set_errno (EINVAL);
	  SLIST_UNLOCK ();
	  return (void *) -1;
	}
    }
  /* Early increment ref counter.  This allows further actions to run with
     unlocked lists, because shmdt or shmctl(IPC_RMID) won't delete this
     ssh_entry. */
  ++ssh_entry->ref_count;
  SLIST_UNLOCK ();

  vm_object_t attach_va = NULL;
  if (shmaddr)
    {
      if (shmflg & SHM_RND)
	attach_va = (vm_object_t)((vm_offset_t)shmaddr & ~(SHMLBA-1));
      else
	attach_va = (vm_object_t)shmaddr;
      /* Don't even bother to call anything if shmaddr is NULL or
	 not aligned. */
      if (!attach_va || (vm_offset_t)attach_va % SHMLBA)
	{
	  set_errno (EINVAL);
	  --ssh_entry->ref_count;
	  return (void *) -1;
	}
    }
  /* Try allocating memory before calling cygserver. */
  shm_attached_list *sph_entry = new (shm_attached_list);
  if (!sph_entry)
    {
      set_errno (ENOMEM);
      --ssh_entry->ref_count;
      return (void *) -1;
    }
  NTSTATUS status;
  vm_object_t ptr = NULL;
  SIZE_T viewsize = ssh_entry->size;
  ULONG access = (shmflg & SHM_RDONLY) ? PAGE_READONLY : PAGE_READWRITE;
  status = NtMapViewOfSection (ssh_entry->hdl, NtCurrentProcess (), &ptr, 0,
			       ssh_entry->size, NULL, &viewsize, ViewShare,
			       MEM_TOP_DOWN, access);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      delete sph_entry;
      --ssh_entry->ref_count;
      return (void *) -1;
    }
  /* Use returned ptr address as is, so it's stored using the exact value
     in cygserver. */
  client_request_shm request (shmid, ptr, shmflg & ~SHM_RND);
  if (request.make_request () == -1 || request.ptrval () == NULL)
    {
      syscall_printf ("-1 [%d] = shmat ()", request.error_code ());
      UnmapViewOfFile (ptr);
      delete sph_entry;
      set_errno (request.error_code ());
      --ssh_entry->ref_count;
      return (void *) -1;
    }
  sph_entry->ptr = ptr;
  sph_entry->parent = ssh_entry;
  sph_entry->access = access;
  SLIST_LOCK ();
  SLIST_INSERT_HEAD (&sph_list, sph_entry, sph_next);
  SLIST_UNLOCK ();
  return ptr;
}

extern "C" int
shmctl (int shmid, int cmd, struct shmid_ds *buf)
{
  syscall_printf ("shmctl (shmid = %d, cmd = %d, buf = %p)",
		  shmid, cmd, buf);
  __try
    {
      client_request_shm request (shmid, cmd, buf);
      if (request.make_request () == -1 || request.retval () == -1)
	{
	  syscall_printf ("-1 [%d] = shmctl ()", request.error_code ());
	  set_errno (request.error_code ());
	  __leave;
	}
      if (cmd == IPC_RMID)
	{
	  /* Cleanup */
	  shm_shmid_list *ssh_entry, *ssh_next_entry;
	  SLIST_LOCK ();
	  SLIST_FOREACH_SAFE (ssh_entry, &ssh_list, ssh_next, ssh_next_entry)
	    {
	      if (ssh_entry->shmid == shmid)
		{
		  /* Remove this entry from the list and close the handle
		     only if it's not in use anymore. */
		  if (ssh_entry->ref_count <= 0)
		    {
		      SLIST_REMOVE (&ssh_list, ssh_entry, shm_shmid_list,
				    ssh_next);
		      CloseHandle (ssh_entry->hdl);
		      delete ssh_entry;
		    }
		  break;
		}
	    }
	  SLIST_UNLOCK ();
	}
      return request.retval ();
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}

extern "C" int
shmdt (const void *shmaddr)
{
  syscall_printf ("shmdt (shmaddr = %p)", shmaddr);
  client_request_shm request (shmaddr);
  if (request.make_request () == -1 || request.retval () == -1)
    {
      syscall_printf ("-1 [%d] = shmdt ()", request.error_code ());
      set_errno (request.error_code ());
      return -1;
    }
  shm_attached_list *sph_entry, *sph_next_entry;
  /* Remove map from list... */
  SLIST_LOCK ();
  SLIST_FOREACH_SAFE (sph_entry, &sph_list, sph_next, sph_next_entry)
    {
      if (sph_entry->ptr == shmaddr)
	{
	  SLIST_REMOVE (&sph_list, sph_entry, shm_attached_list, sph_next);
	  /* ...unmap view... */
	  UnmapViewOfFile (sph_entry->ptr);
	  /* ...and, if this was the last reference to this shared section... */
	  shm_shmid_list *ssh_entry = sph_entry->parent;
	  if (--ssh_entry->ref_count <= 0)
	    {
	      /* ...delete parent entry and close handle. */
	      SLIST_REMOVE (&ssh_list, ssh_entry, shm_shmid_list, ssh_next);
	      CloseHandle (ssh_entry->hdl);
	      delete ssh_entry;
	    }
	  delete sph_entry;
	  break;
	}
    }
  SLIST_UNLOCK ();
  return request.retval ();
}

extern "C" int
shmget (key_t key, size_t size, int shmflg)
{
  syscall_printf ("shmget (key = %U, size = %d, shmflg = %y)",
		  key, size, shmflg);
  /* Try allocating memory before calling cygserver. */
  shm_shmid_list *ssh_new_entry = new (shm_shmid_list);
  if (!ssh_new_entry)
    {
      set_errno (ENOMEM);
      return -1;
    }
  client_request_shm request (key, size, shmflg);
  if (request.make_request () == -1 || request.retval () == -1)
    {
      syscall_printf ("-1 [%d] = shmget ()", request.error_code ());
      delete ssh_new_entry;
      set_errno (request.error_code ());
      return -1;
    }
  int shmid = request.retval ();	/* Shared mem ID */
  vm_object_t hdl = request.objval ();	/* HANDLE associated with it. */
  shm_shmid_list *ssh_entry;
  SLIST_LOCK ();
  SLIST_FOREACH (ssh_entry, &ssh_list, ssh_next)
    {
      if (ssh_entry->shmid == shmid)
	{
	  /* We already maintain an entry for this shmid.  That means,
	     the hdl returned by cygserver is a superfluous duplicate
	     of the original hdl maintained by cygserver.  We can safely
	     delete it. */
	  CloseHandle (hdl);
	  delete ssh_new_entry;
	  SLIST_UNLOCK ();
	  return shmid;
	}
    }
  /* We arrive here only if shmid is a new one for this process.  Add the
     shmid and hdl value to the list. */
  ssh_new_entry->shmid = shmid;
  ssh_new_entry->hdl = hdl;
  ssh_new_entry->size = size;
  ssh_new_entry->ref_count = 0;
  SLIST_INSERT_HEAD (&ssh_list, ssh_new_entry, ssh_next);
  SLIST_UNLOCK ();
  return shmid;
}
@


1.42
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d3 2
a4 2
   Copyright 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2012, 2013, 2014
   Red Hat, Inc.
a244 2
      if (request.error_code () == ENOSYS)
	raise (SIGSYS);
a267 2
	  if (request.error_code () == ENOSYS)
	    raise (SIGSYS);
a308 2
      if (request.error_code () == ENOSYS)
	raise (SIGSYS);
a355 2
      if (request.error_code () == ENOSYS)
	raise (SIGSYS);
@


1.41
log
@	* cygserver_ipc.h (ipc_set_proc_info): Add bool parameter to specify
	whether or not to send signal_arrived.
	* shm.cc (client_request_shm::client_request_shm): Call
	ipc_set_proc_info with bool parameter set to true to not send
	signal_arrived.
@
text
@d263 1
a263 5
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  client_request_shm request (shmid, cmd, buf);
  if (request.make_request () == -1 || request.retval () == -1)
d265 10
a274 12
      syscall_printf ("-1 [%d] = shmctl ()", request.error_code ());
      set_errno (request.error_code ());
      if (request.error_code () == ENOSYS)
	raise (SIGSYS);
      return -1;
    }
  if (cmd == IPC_RMID)
    {
      /* Cleanup */
      shm_shmid_list *ssh_entry, *ssh_next_entry;
      SLIST_LOCK ();
      SLIST_FOREACH_SAFE (ssh_entry, &ssh_list, ssh_next, ssh_next_entry)
d276 4
a279 1
	  if (ssh_entry->shmid == shmid)
d281 1
a281 3
	      /* Remove this entry from the list and close the handle
		 only if it's not in use anymore. */
	      if (ssh_entry->ref_count <= 0)
d283 10
a292 3
		  SLIST_REMOVE (&ssh_list, ssh_entry, shm_shmid_list, ssh_next);
		  CloseHandle (ssh_entry->hdl);
		  delete ssh_entry;
a293 1
	      break;
d295 1
d297 1
a297 1
      SLIST_UNLOCK ();
d299 3
a301 1
  return request.retval ();
@


1.40
log
@	* Merge in cygwin-64bit-branch.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2012, 2013
d88 1
a88 1
  ipc_set_proc_info (_parameters.in.ipcblk);
@


1.40.2.1
log
@	* cygserver_ipc.h (ipc_set_proc_info): Add bool parameter to specify
	whether or not to send signal_arrived.
	* shm.cc (client_request_shm::client_request_shm): Call
	ipc_set_proc_info with bool parameter set to true to not send
	signal_arrived.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2012, 2013, 2014
d88 1
a88 1
  ipc_set_proc_info (_parameters.in.ipcblk, true);
@


1.40.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d263 5
a267 1
  __try
d269 12
a280 10
      client_request_shm request (shmid, cmd, buf);
      if (request.make_request () == -1 || request.retval () == -1)
	{
	  syscall_printf ("-1 [%d] = shmctl ()", request.error_code ());
	  set_errno (request.error_code ());
	  if (request.error_code () == ENOSYS)
	    raise (SIGSYS);
	  __leave;
	}
      if (cmd == IPC_RMID)
d282 1
a282 4
	  /* Cleanup */
	  shm_shmid_list *ssh_entry, *ssh_next_entry;
	  SLIST_LOCK ();
	  SLIST_FOREACH_SAFE (ssh_entry, &ssh_list, ssh_next, ssh_next_entry)
d284 3
a286 1
	      if (ssh_entry->shmid == shmid)
d288 3
a290 10
		  /* Remove this entry from the list and close the handle
		     only if it's not in use anymore. */
		  if (ssh_entry->ref_count <= 0)
		    {
		      SLIST_REMOVE (&ssh_list, ssh_entry, shm_shmid_list,
				    ssh_next);
		      CloseHandle (ssh_entry->hdl);
		      delete ssh_entry;
		    }
		  break;
d292 1
a293 1
	  SLIST_UNLOCK ();
d295 1
a295 1
      return request.retval ();
d297 1
a297 3
  __except (EFAULT) {}
  __endtry
  return -1;
@


1.39
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d3 2
a4 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009 Red Hat, Inc.
d139 1
a139 1
      ULONG viewsize = sph_entry->parent->size;
d144 1
a144 1
	api_fatal ("fixup_shms_after_fork: NtMapViewOfSection (%p), status %p.  Terminating.",
d157 1
a157 1
  syscall_printf ("shmat (shmid = %d, shmaddr = %p, shmflg = 0x%x)",
d223 1
a223 1
  ULONG viewsize = ssh_entry->size;
d261 1
a261 1
  syscall_printf ("shmctl (shmid = %d, cmd = %d, buf = 0x%x)",
d343 1
a343 1
  syscall_printf ("shmget (key = %U, size = %d, shmflg = 0x%x)",
@


1.38
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2007, 2009 Red Hat, Inc.
@


1.38.8.1
log
@	* shm.cc (fixup_shms_after_fork): Fix initialization of local variable
	parent.
@
text
@d123 1
a123 5
#ifdef __x86_64__
  proc parent = { myself->ppid, p->dwProcessId, true, false, p->uid, p->gid };
#else
  proc parent = { myself->ppid, p->dwProcessId, false, false, p->uid, p->gid };
#endif
@


1.38.8.2
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2007, 2009, 2012 Red Hat, Inc.
d142 1
a142 1
      SIZE_T viewsize = sph_entry->parent->size;
d147 1
a147 1
	api_fatal ("fixup_shms_after_fork: NtMapViewOfSection (%p), status %y.  Terminating.",
d160 1
a160 1
  syscall_printf ("shmat (shmid = %d, shmaddr = %p, shmflg = %y)",
d226 1
a226 1
  SIZE_T viewsize = ssh_entry->size;
d264 1
a264 1
  syscall_printf ("shmctl (shmid = %d, cmd = %d, buf = %p)",
d346 1
a346 1
  syscall_printf ("shmget (key = %U, size = %d, shmflg = %y)",
@


1.38.8.3
log
@Pull in changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2012 Red Hat, Inc.
@


1.38.8.4
log
@	* cygserver.h (struct header_t): Revert msglen to simple member.
	Drop accessor methods.
	* cygserver_ipc.h (struct proc): Drop enforced 4 byte struct packing.
	Remove members for 64<->32 bit IPC.  Revert to original member order.
	(ipc_set_proc_info): Remove 64<->32 handling.
	(conv_timespec32_to_timespec): Delete.
	(conv_timespec_to_timespec32): Delete.
	* pinfo.h (struct win_heap_info): Remove.
	* shm.cc (fixup_shms_after_fork): Revert parent initialization.
	* winlean.h: Remove _TYPE64_CLR and _TYPE64_SET macros.  Remove
	usage throughout code.
	* include/cygwin/ipc.h: Drop 64<->32 bit helper structures.
	* include/cygwin/msg.h: Ditto.  Drop enforced 4 byte struct packing.
	* include/cygwin/sem.h: Ditto.
	* include/cygwin/shm.h: Ditto.
	* include/cygwin/sysproto.h: Drop enforced 4 byte struct packing.
@
text
@d3 1
a3 2
   Copyright 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2012, 2013
   Red Hat, Inc.
d123 5
a127 1
  proc parent = { myself->ppid, p->dwProcessId, p->uid, p->gid };
@


1.37
log
@	* shm.cc (struct shm_attached_list): Convert access type to ULONG.
	(fixup_shms_after_fork): Fix comment.  Use NtMapViewOfSection rather
	than MapViewOfFileEx to recreate shared memory regions.  Add function
	name to api_fatal output.
	(shmat): Use NtMapViewOfSection to create shared memory region
	top-down.
@
text
@d139 1
a139 1
      status = NtMapViewOfSection (sph_entry->parent->hdl, GetCurrentProcess (),
d224 1
a224 1
  status = NtMapViewOfSection (ssh_entry->hdl, GetCurrentProcess (), &ptr, 0,
@


1.36
log
@ChangeLog:

	* configure.in: Remove --enable-server option.  Allways add the
	cygserver directory to $SUBDIRS.
	* configure: Regenerate.

cygwin/ChangeLog:

	Remove USE_SERVER define.  Accommodate throughout.
	* configure.in: Remove --enable-server option.
	* configure: Regenerate.
	* environ.cc: Remove CYGWIN=server setting.

cygserver/ChangeLog:

	* client.cc (allow_server): Remove variable.
	(client_request_get_version::client_request_get_version): Drop checking
	allow_server.

utils/ChangeLog:

	* passwd.c: Remove CYGWIN=server requirement from usage text.

doc/ChangeLog:

	* cygserver.sgml: Remove the "How to use the Cygserver services"
	section.
	* cygwinenv.sgml: Move "(no)server" to the removed options section.
	* faq-programming.xml: Remove CYGWIN=server requirement for running
	the Cygwin testsuite.
	* ntsec.sgml: Ditto for using `passwd -R'.
@
text
@d21 1
d108 1
a108 1
  int access;
d133 1
a133 1
  /* Remove map from list... */
d136 9
a144 6
      vm_object_t ptr = MapViewOfFileEx (sph_entry->parent->hdl,
					 sph_entry->access, 0, 0,
					 sph_entry->parent->size,
					 sph_entry->ptr);
      if (ptr != sph_entry->ptr)
	api_fatal ("MapViewOfFileEx (%p), %E.  Terminating.", sph_entry->ptr);
d220 8
a227 4
  DWORD access = (shmflg & SHM_RDONLY) ? FILE_MAP_READ : FILE_MAP_WRITE;
  vm_object_t ptr = MapViewOfFileEx (ssh_entry->hdl, access, 0, 0,
				     ssh_entry->size, attach_va);
  if (!ptr)
d229 1
a229 1
      __seterrno ();
@


1.35
log
@Remove unneeded header files from source files throughout.
@
text
@d3 1
a3 1
   Copyright 2003 Red Hat, Inc.
a11 1
#ifdef USE_SERVER
a143 1
#endif /* USE_SERVER */
a151 1
#ifdef USE_SERVER
a246 5
#else
  set_errno (ENOSYS);
  raise (SIGSYS);
  return (void *) -1;
#endif
a251 1
#ifdef USE_SERVER
a288 5
#else
  set_errno (ENOSYS);
  raise (SIGSYS);
  return -1;
#endif
a293 1
#ifdef USE_SERVER
a328 5
#else
  set_errno (ENOSYS);
  raise (SIGSYS);
  return -1;
#endif
a333 1
#ifdef USE_SERVER
a379 5
#else
  set_errno (ENOSYS);
  raise (SIGSYS);
  return -1;
#endif
@


1.34
log
@	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.
@
text
@a11 2
#include "cygerrno.h"
#include <signal.h>
a12 1
#include <sys/types.h>
a13 1
#include <stdio.h>
a18 1
#include "cygserver_ipc.h"
@


1.33
log
@	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.
@
text
@d26 1
d103 1
d112 1
a112 2
  vm_object_t hdl;
  size_t size;
d118 4
d141 4
a144 2
      vm_object_t ptr = MapViewOfFileEx (sph_entry->hdl, sph_entry->access,
					 0, 0, sph_entry->size, sph_entry->ptr);
d163 1
d190 1
d194 6
d212 1
d221 1
d231 1
d243 1
d249 1
a249 2
  sph_entry->hdl = ssh_entry->hdl;
  sph_entry->size = ssh_entry->size;
d251 1
d253 1
d282 1
a282 1
      /* The process must cleanup its own storage... */
d284 1
d289 3
a291 3
	      bool in_use = false;
	      shm_attached_list *sph_entry;
	      SLIST_FOREACH (sph_entry, &sph_list, sph_next)
d293 3
a295 5
		  if (sph_entry->hdl == ssh_entry->hdl)
		    {
		      in_use = true;
		      break;
		    }
a296 5
	      SLIST_REMOVE (&ssh_list, ssh_entry, shm_shmid_list, ssh_next);
	      /* ...and close the handle if it's not in use anymore. */
	      if (!in_use)
		CloseHandle (ssh_entry->hdl);
	      delete ssh_entry;
d300 1
d326 1
d332 1
a332 1
	  /* ...and unmap view. */
d334 9
d347 1
d382 1
d393 1
d402 1
d404 1
@


1.32
log
@	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.
@
text
@d268 3
a270 3
	      shm_attached_list *sph_entry, *sph_next_entry;
	      SLIST_FOREACH_SAFE (sph_entry, &sph_list, sph_next,
				  sph_next_entry)
d274 2
a275 5
		      SLIST_REMOVE (&sph_list, sph_entry, shm_attached_list,
				    sph_next);
		      /* ...unmap all views for this handle... */
		      UnmapViewOfFile (sph_entry->ptr);
		      delete sph_entry;
d279 3
a281 2
	      /* ...and close the handle. */
	      CloseHandle (ssh_entry->hdl);
@


1.31
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d268 13
@


1.31.8.1
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@a25 1
#include "sync.h"
a101 1
  int ref_count;
d110 2
a111 1
  shm_shmid_list *parent;
a116 4
static NO_COPY muto shm_guard;
#define SLIST_LOCK()	(shm_guard.init ("shm_guard")->acquire ())
#define SLIST_UNLOCK()	(shm_guard.release ())

d136 2
a137 4
      vm_object_t ptr = MapViewOfFileEx (sph_entry->parent->hdl,
					 sph_entry->access, 0, 0,
					 sph_entry->parent->size,
					 sph_entry->ptr);
a155 1
  SLIST_LOCK ();
a181 1
	  SLIST_UNLOCK ();
a184 6
  /* Early increment ref counter.  This allows further actions to run with
     unlocked lists, because shmdt or shmctl(IPC_RMID) won't delete this
     ssh_entry. */
  ++ssh_entry->ref_count;
  SLIST_UNLOCK ();

a196 1
	  --ssh_entry->ref_count;
a204 1
      --ssh_entry->ref_count;
a213 1
      --ssh_entry->ref_count;
a224 1
      --ssh_entry->ref_count;
d230 2
a231 1
  sph_entry->parent = ssh_entry;
a232 1
  SLIST_LOCK ();
a233 1
  SLIST_UNLOCK ();
d262 1
a262 1
      /* Cleanup */
a263 1
      SLIST_LOCK ();
d268 4
a271 8
	      /* Remove this entry from the list and close the handle
		 only if it's not in use anymore. */
	      if (ssh_entry->ref_count <= 0)
		{
		  SLIST_REMOVE (&ssh_list, ssh_entry, shm_shmid_list, ssh_next);
		  CloseHandle (ssh_entry->hdl);
		  delete ssh_entry;
		}
a274 1
      SLIST_UNLOCK ();
a299 1
  SLIST_LOCK ();
d305 1
a305 1
	  /* ...unmap view... */
a306 9
	  /* ...and, if this was the last reference to this shared section... */
	  shm_shmid_list *ssh_entry = sph_entry->parent;
	  if (--ssh_entry->ref_count <= 0)
	    {
	      /* ...delete parent entry and close handle. */
	      SLIST_REMOVE (&ssh_list, ssh_entry, shm_shmid_list, ssh_next);
	      CloseHandle (ssh_entry->hdl);
	      delete ssh_entry;
	    }
a310 1
  SLIST_UNLOCK ();
a344 1
  SLIST_LOCK ();
a354 1
	  SLIST_UNLOCK ();
a362 1
  ssh_new_entry->ref_count = 0;
a363 1
  SLIST_UNLOCK ();
@


1.30
log
@	* shm.cc: Whitespace fixes.
@
text
@d25 1
d248 3
a250 22
  switch (cmd)
    {
      case IPC_STAT:
      case IPC_SET:
	if (__check_null_invalid_struct_errno (buf, sizeof (struct shmid_ds)))
	  return -1;
	break;
      case IPC_INFO:
	/* shmid == 0: Request for shminfo struct. */
	if (!shmid
	    && __check_null_invalid_struct_errno (buf, sizeof (struct shminfo)))
	    return -1;
	/* Otherwise, request shmid entries from internal shmid_ds array. */
	if (shmid)
	  if (__check_null_invalid_struct_errno (buf, shmid * sizeof (struct shmid_ds)))
	    return -1;
	break;
      case SHM_INFO:
	if (__check_null_invalid_struct_errno (buf, sizeof (struct shm_info)))
	  return -1;
	break;
    }
@


1.29
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d97 1
a97 1
  SLIST_ENTRY(shm_shmid_list) ssh_next;
d103 1
a103 1
static SLIST_HEAD(, shm_shmid_list) ssh_list;
d107 1
a107 1
  SLIST_ENTRY(shm_attached_list) sph_next;
d114 1
a114 1
static SLIST_HEAD(, shm_attached_list) sph_list;
d135 2
a136 2
      vm_object_t ptr = MapViewOfFileEx(sph_entry->hdl, sph_entry->access,
					0, 0, sph_entry->size, sph_entry->ptr);
d207 2
a208 2
  vm_object_t ptr = MapViewOfFileEx(ssh_entry->hdl, access, 0, 0,
				    ssh_entry->size, attach_va);
@


1.28
log
@	* shm.cc (shmat): If shmid is unknown, call a special variation
	of shmget to retrieve the shared memory segment from Cygserver
	instead of failing immediately.
	* include/cygwin/ipc.h (IPC_KEY_IS_SHMID): New internal flag for
	shmget when called from shmat.
@
text
@d136 1
a136 1
      					0, 0, sph_entry->size, sph_entry->ptr);
d138 1
a138 1
        api_fatal ("MapViewOfFileEx (%p), %E.  Terminating.", sph_entry->ptr);
d164 1
a164 1
         the server if it exists.  Use special internal call to shmget,
d170 1
a170 1
        {
d178 1
a178 1
        {
d188 1
a188 1
        attach_va = (vm_object_t)((vm_offset_t)shmaddr & ~(SHMLBA-1));
d192 1
a192 1
         not aligned. */
d225 1
a225 1
        raise (SIGSYS);
d253 1
a253 1
        break;
d263 1
a263 1
        break;
d265 1
a265 1
        if (__check_null_invalid_struct_errno (buf, sizeof (struct shm_info)))
d267 1
a267 1
        break;
d275 1
a275 1
        raise (SIGSYS);
d283 1
a283 1
        {
d313 1
a313 1
        raise (SIGSYS);
d321 1
a321 1
        {
d357 1
a357 1
        raise (SIGSYS);
d366 1
a366 1
        {
@


1.27
log
@	* shm.cc (shmat): Return (void *) -1 on error instead of NULL.
@
text
@d163 20
a182 3
      /* Invalid shmid */
      set_errno (EINVAL);
      return (void *) -1;
@


1.26
log
@	* sem.cc (semget): Fix debug string.
	(semop): Ditto.
	* shm.cc (fixup_shms_after_fork): Ditto.
	(shmat): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.
@
text
@d165 1
a165 1
      return NULL;
d179 1
a179 1
	  return NULL;
d187 1
a187 1
      return NULL;
d196 1
a196 1
      return NULL;
d209 1
a209 1
      return NULL;
d220 1
a220 1
  return NULL;
@


1.25
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d127 1
a127 1
      syscall_printf ("-1 [%d] = shmctl ()", request.error_code ());
d203 1
a203 1
      syscall_printf ("-1 [%d] = shmctl ()", request.error_code ());
d289 1
a289 1
  syscall_printf ("shmget (shmaddr = %p)", shmaddr);
d293 1
a293 1
      syscall_printf ("-1 [%d] = shmctl ()", request.error_code ());
d336 1
a336 1
      syscall_printf ("-1 [%d] = shmctl ()", request.error_code ());
@


1.24
log
@* sem.cc: Always include signal.h to handle SIGSYS raise when !USE_SERVER.
* shm.cc: Ditto.
* msg.cc: Always include signal.h to handle SIGSYS raise when !USE_SERVER.
@
text
@a151 1
  sigframe thisframe (mainthread);
a227 1
  sigframe thisframe (mainthread);
a288 1
  sigframe thisframe (mainthread);
a323 1
  sigframe thisframe (mainthread);
@


1.23
log
@	* msg.cc (msgctl): Raise SIGSYS if call not available.
	(msgget): Ditto.
	(msgrcv): Ditto.
	(msgsnd): Ditto.
	* sem.cc (semctl): Ditto.
	(semget): Ditto.
	(semop): Ditto.
	* shm.cc (shmat): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto.
	(shmdt): Ditto.
@
text
@d13 1
@


1.22
log
@	* cygserver.h (client_request::request_code_t): Add
	CYGSERVER_REQUEST_MSG and CYGSERVER_REQUEST_SEM.
	(admininstrator_group_sid): Add extern declaration.
	* cygserver_ipc.h: Rewrite.
	* cygserver_msg.h: New file.
	* cygserver_sem.h: New file.
	* cygserver_shm.h: More or less rewrite.
	* cygwin.din: Add msgctl, msgget, msgrcv, msgsnd, semctl, semget and
	semop.
	* msg.cc: Rewrite.
	* safe_memory.h: Remove.
	* sem.cc: Rewrite.
	* shm.cc: Rewrite.
	* include/cygwin/ipc.h: Use appropriate guard.
	(struct ipc_perm): Add seq.
	(IPCID_TO_IX): New define from BSD.
	(IPCID_TO_SEQ): Ditto.
	(IXSEQ_TO_IPCID): Ditto.
	(IPC_R): Ditto.
	(IPC_W): Ditto.
	(IPC_M): Ditto.
	* include/cygwin/msg.h: Use appropriate guard. #ifdef _KERNEL all stuff
	not explicitely defined by SUSv3. Use signed types in structs to match
	types used in BSD.
	(msgqnum_t): Define unsigned.
	(msglen_t): Ditto.
	(struct msqid_ds): Add msg_first and msg_last.
	(struct msginfo): Remove msgpool. Add msgssz and msgseg.
	* include/cygwin/sem.h: Use appropriate guard. #ifdef _KERNEL all stuff
	not explicitely defined by SUSv3. Use signed types in structs to match
	types used in BSD.
	(SEM_UNDO): Define appropriately.
	(struct semid_ds): Add sem_base.
	(struct seminfo): Add semmap and semusz.
	(SEM_A): New define from BSD.
	(SEM_R): Ditto.
	(SEM_ALLOC): Ditto.
	(union semun): Define.
	* include/cygwin/shm.h: Use appropriate guard. #ifdef _KERNEL all stuff
	not explicitely defined by SUSv3. Use signed types in structs to match
	types used in BSD.
	(SHMLBA): Define using cygwin_internal(CW_GET_SHMLBA) call.
	(struct shmid_ds): Add shm_internal.
	(struct shm_info): Rename shm_ids to used_ids as in BSD.  Add define
	for shm_ids.
	* include/cygwin/sysproto.h: New file.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/ipc.h: New file.
	* include/sys/msg.h: New file.
	* include/sys/queue.h: New file from BSD.
	* include/sys/sem.h: New file.
	* include/sys/shm.h: New file.
	* include/sys/sysproto.h: New file.
@
text
@d207 2
d219 1
d258 2
d281 1
d297 2
d317 1
d342 2
d371 1
@


1.21
log
@	* Makefile.in: Add $(LIBSERVER) rule.
	* cygserver.h: Moved from include/cygwin to here.
	* cygserver_ipc.h: Moved from ../cygserver to here.
	* cygserver_shm.h: Ditto.
	* cygwin.din: Add shmat, shmctl, shmdt and shmget.
	* fhandler_tty.cc (fhandler_tty_slave::open): Don't warn about handle
	dup'ing if not build with USE_SERVER.
	* shm.cc: Include cygerrno.h unconditionally.
	(shmat): Set errno to ENOSYS and return -1 if not build with
	USE_SERVER.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.
	* woutsup.h: Remove.
	* include/cygwin/cygserver_process.h: Moved to ../cygserver directory.
	* include/cygwin/cygserver_transport.h: Ditto.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d1 1
a1 1
/* shm.cc: Single unix specification IPC interface for Cygwin.
d3 1
a3 4
   Copyright 2002,2003 Red Hat, Inc.

   Written by Conrad Scott <conrad.scott@@dsl.pipex.com>.
   Based on code by Robert Collins <robert.collins@@hotmail.com>.
d15 1
a15 2

#include <assert.h>
d19 1
a19 1
#include "safe_memory.h"
d25 3
a27 5
/*---------------------------------------------------------------------------*
 * class client_shmmgr
 *
 * A singleton class.
 *---------------------------------------------------------------------------*/
d29 4
a32 3
#define shmmgr (client_shmmgr::instance ())

class client_shmmgr
d34 2
a35 8
private:
  class segment_t
  {
  public:
    const int shmid;
    const void *const shmaddr;
    const int shmflg;
    HANDLE hFileMap;		// Updated by fixup_shms_after_fork ().
d37 3
a39 1
    segment_t *next;
d41 2
a42 6
    segment_t (const int shmid, const void *const shmaddr, const int shmflg,
	       const HANDLE hFileMap)
      : shmid (shmid), shmaddr (shmaddr), shmflg (shmflg), hFileMap (hFileMap),
	next (NULL)
    {}
  };
d44 4
a47 47
public:
  static client_shmmgr & instance ();

  void *shmat (int shmid, const void *, int shmflg);
  int shmctl (int shmid, int cmd, struct shmid_ds *);
  int shmdt (const void *);
  int shmget (key_t, size_t, int shmflg);

  int fixup_shms_after_fork ();

private:
  static NO_COPY client_shmmgr *_instance;

  CRITICAL_SECTION _segments_lock;
  static segment_t *_segments_head; // List of attached segs by shmaddr.

  static long _shmat_cnt;	// No. of attached segs; for info. only.

  client_shmmgr ();
  ~client_shmmgr ();

  // Undefined (as this class is a singleton):
  client_shmmgr (const client_shmmgr &);
  client_shmmgr & operator= (const client_shmmgr &);

  segment_t *find (const void *, segment_t **previous = NULL);

  void *attach (int shmid, const void *, int shmflg, HANDLE & hFileMap);

  segment_t *new_segment (int shmid, const void *, int shmflg, HANDLE);
};

/* static */ NO_COPY client_shmmgr *client_shmmgr::_instance;

/* The following two variables must be inherited by child processes
 * since they are used by fixup_shms_after_fork () to re-attach to the
 * parent's shm segments.
 */
/* static */ client_shmmgr::segment_t *client_shmmgr::_segments_head;
/* static */ long client_shmmgr::_shmat_cnt;

/*---------------------------------------------------------------------------*
 * client_shmmgr::instance ()
 *---------------------------------------------------------------------------*/

client_shmmgr &
client_shmmgr::instance ()
d49 2
a50 2
  if (!_instance)
    _instance = safe_new0 (client_shmmgr);
d52 3
a54 1
  assert (_instance);
d56 1
a56 1
  return *_instance;
d59 2
a60 8
/*---------------------------------------------------------------------------*
 * client_shmmgr::shmat ()
 *---------------------------------------------------------------------------*/

void *
client_shmmgr::shmat (const int shmid,
		      const void *const shmaddr,
		      const int shmflg)
d62 2
a63 2
  syscall_printf ("shmat (shmid = %d, shmaddr = %p, shmflg = 0%o)",
		  shmid, shmaddr, shmflg);
d65 1
a65 1
  EnterCriticalSection (&_segments_lock);
d67 1
a67 16
  HANDLE hFileMap = NULL;

  void *const ptr = attach (shmid, shmaddr, shmflg, hFileMap);

  if (ptr)
    new_segment (shmid, ptr, shmflg, hFileMap);

  LeaveCriticalSection (&_segments_lock);

  if (ptr)
    syscall_printf ("%p = shmat (shmid = %d, shmaddr = %p, shmflg = 0%o)",
		    ptr, shmid, shmaddr, shmflg);
  // else
    // See the syscall_printf in client_shmmgr::attach ().

  return (ptr ? ptr : (void *) -1);
d70 4
a73 8
/*---------------------------------------------------------------------------*
 * client_shmmgr::shmctl ()
 *---------------------------------------------------------------------------*/

int
client_shmmgr::shmctl (const int shmid,
		       const int cmd,
		       struct shmid_ds *const buf)
d75 2
a76 2
  syscall_printf ("shmctl (shmid = %d, cmd = 0x%x, buf = %p)",
		  shmid, cmd, buf);
d78 3
a80 1
  // Check parameters and set up in parameters as required.
d82 1
a82 93
  const struct shmid_ds *in_buf = NULL;

  switch (cmd)
    {
    case IPC_SET:
      if (__check_invalid_read_ptr_errno (buf, sizeof (struct shmid_ds)))
	{
	  syscall_printf (("-1 [EFAULT] = "
			   "shmctl (shmid = %d, cmd = 0x%x, buf = %p)"),
			  shmid, cmd, buf);
	  set_errno (EFAULT);
	  return -1;
	}
      in_buf = buf;
      break;

    case IPC_STAT:
    case SHM_STAT:
      if (__check_null_invalid_struct_errno (buf, sizeof (struct shmid_ds)))
	{
	  syscall_printf (("-1 [EFAULT] = "
			   "shmctl (shmid = %d, cmd = 0x%x, buf = %p)"),
			  shmid, cmd, buf);
	  set_errno (EFAULT);
	  return -1;
	}
      break;

    case IPC_INFO:
      if (__check_null_invalid_struct_errno (buf, sizeof (struct shminfo)))
	{
	  syscall_printf (("-1 [EFAULT] = "
			   "shmctl (shmid = %d, cmd = 0x%x, buf = %p)"),
			  shmid, cmd, buf);
	  set_errno (EFAULT);
	  return -1;
	}
      break;

    case SHM_INFO:
      if (__check_null_invalid_struct_errno (buf, sizeof (struct shm_info)))
	{
	  syscall_printf (("-1 [EFAULT] = "
			   "shmctl (shmid = %d, cmd = 0x%x, buf = %p)"),
			  shmid, cmd, buf);
	  set_errno (EFAULT);
	  return -1;
	}
      break;
    }

  // Create and issue the command.

  client_request_shm request (shmid, cmd, in_buf);

  if (request.make_request () == -1 || request.error_code ())
    {
      syscall_printf (("-1 [%d] = "
		       "shmctl (shmid = %d, cmd = 0x%x, buf = %p)"),
		      request.error_code (), shmid, cmd, buf);
      set_errno (request.error_code ());
      return -1;
    }

  // Some commands require special processing for their out parameters.

  int result = 0;

  switch (cmd)
    {
    case IPC_STAT:
      *buf = request.ds ();
      break;

    case IPC_INFO:
      *(struct shminfo *) buf = request.shminfo ();
      break;

    case SHM_STAT:		// ipcs(8) i'face.
      result = request.shmid ();
      *buf = request.ds ();
      break;

    case SHM_INFO:		// ipcs(8) i'face.
      result = request.shmid ();
      *(struct shm_info *) buf = request.shm_info ();
      break;
    }

  syscall_printf ("%d = shmctl (shmid = %d, cmd = 0x%x, buf = %p)",
		  result, shmid, cmd, buf);

  return result;
d85 2
a86 11
/*---------------------------------------------------------------------------*
 * client_shmmgr::shmdt ()
 *
 * According to Posix, the only error condition for this system call
 * is EINVAL if shmaddr is not the address of the start of an attached
 * shared memory segment.  Given that, all other errors just generate
 * tracing noise.
 *---------------------------------------------------------------------------*/

int
client_shmmgr::shmdt (const void *const shmaddr)
d88 2
a89 1
  syscall_printf ("shmdt (shmaddr = %p)", shmaddr);
d91 2
a92 1
  EnterCriticalSection (&_segments_lock);
d94 7
a100 1
  segment_t *previous = NULL;
d102 1
a102 1
  segment_t *const segptr = find (shmaddr, &previous);
d104 8
a111 7
  if (!segptr)
    {
      LeaveCriticalSection (&_segments_lock);
      syscall_printf ("-1 [EINVAL] = shmdt (shmaddr = %p)", shmaddr);
      set_errno (EINVAL);
      return -1;
    }
d113 1
a113 1
  assert (previous ? previous->next == segptr : _segments_head == segptr);
d115 2
a116 43
  if (previous)
    previous->next = segptr->next;
  else
    _segments_head = segptr->next;

  LeaveCriticalSection (&_segments_lock);

  const long cnt = InterlockedDecrement (&_shmat_cnt);
  assert (cnt >= 0);

  if (!UnmapViewOfFile ((void *) shmaddr))
    syscall_printf (("failed to unmap view "
		     "[shmid = %d, handle = %p, shmaddr = %p]:"
		     "%E"),
		    segptr->shmid, segptr->hFileMap, shmaddr);

  assert (segptr->hFileMap);

  if (!CloseHandle (segptr->hFileMap))
    syscall_printf (("failed to close file map handle "
		     "[shmid = %d, handle = %p]: %E"),
		    segptr->shmid, segptr->hFileMap);

  client_request_shm request (segptr->shmid);

  if (request.make_request () == -1 || request.error_code ())
    syscall_printf ("shmdt request failed [shmid = %d, handle = %p]: %s",
		    segptr->shmid, segptr->hFileMap,
		    strerror (request.error_code ()));

  safe_delete (segptr);

  syscall_printf ("0 = shmdt (shmaddr = %p)", shmaddr);

  return 0;
}

/*---------------------------------------------------------------------------*
 * client_shmmgr::shmget ()
 *---------------------------------------------------------------------------*/

int
client_shmmgr::shmget (const key_t key, const size_t size, const int shmflg)
d118 4
a121 4
  syscall_printf ("shmget (key = 0x%016X, size = %u, shmflg = 0%o)",
		  key, size, shmflg);

  client_request_shm request (key, size, shmflg);
d123 2
a124 1
  if (request.make_request () == -1 || request.error_code ())
d126 1
a126 4
      syscall_printf (("-1 [%d] = "
		       "shmget (key = 0x%016X, size = %u, shmflg = 0%o)"),
		      request.error_code (),
		      key, size, shmflg);
d128 10
a137 1
      return -1;
a138 50

  syscall_printf (("%d = shmget (key = 0x%016X, size = %u, shmflg = 0%o)"),
		  request.shmid (),
		  key, size, shmflg);

  return request.shmid ();
}

/*---------------------------------------------------------------------------*
 * client_shmmgr::fixup_shms_after_fork ()
 *
 * The hFileMap handles are non-inheritable: so they have to be
 * re-acquired from cygserver.
 *
 * Nb. This routine need not be thread-safe as it is only called at startup.
 *---------------------------------------------------------------------------*/

int
client_shmmgr::fixup_shms_after_fork ()
{
  debug_printf ("re-attaching to shm segments: %d attached", _shmat_cnt);

  {
    int length = 0;
    for (segment_t *segptr = _segments_head; segptr; segptr = segptr->next)
      length += 1;

    if (_shmat_cnt != length)
      {
	system_printf (("state inconsistent: "
			"_shmat_cnt = %d, length of segments list = %d"),
		       _shmat_cnt, length);
	return 1;
      }
  }

  for (segment_t *segptr = _segments_head; segptr; segptr = segptr->next)
    if (!attach (segptr->shmid,
		 segptr->shmaddr,
		 segptr->shmflg & ~SHM_RND,
		 segptr->hFileMap))
      {
	system_printf ("fatal error re-attaching to shm segment %d",
		       segptr->shmid);
	return 1;
      }

  if (_shmat_cnt)
    debug_printf ("re-attached all %d shm segments", _shmat_cnt);

d141 1
d143 3
a145 3
/*---------------------------------------------------------------------------*
 * client_shmmgr::client_shmmgr ()
 *---------------------------------------------------------------------------*/
d147 2
a148 1
client_shmmgr::client_shmmgr ()
d150 4
a153 15
  InitializeCriticalSection (&_segments_lock);
}

/*---------------------------------------------------------------------------*
 * client_shmmgr::~client_shmmgr ()
 *---------------------------------------------------------------------------*/

client_shmmgr::~client_shmmgr ()
{
  DeleteCriticalSection (&_segments_lock);
}

/*---------------------------------------------------------------------------*
 * client_shmmgr::find ()
 *---------------------------------------------------------------------------*/
d155 2
a156 32
client_shmmgr::segment_t *
client_shmmgr::find (const void *const shmaddr, segment_t **previous)
{
  if (previous)
    *previous = NULL;

  for (segment_t *segptr = _segments_head; segptr; segptr = segptr->next)
    if (segptr->shmaddr == shmaddr)
      return segptr;
    else if (segptr->shmaddr > shmaddr) // The list is sorted by shmaddr.
      return NULL;
    else if (previous)
      *previous = segptr;

  return NULL;
}

/*---------------------------------------------------------------------------*
 * client_shmmgr::attach ()
 *
 * The body of shmat (), also used by fixup_shms_after_fork ().
 *---------------------------------------------------------------------------*/

void *
client_shmmgr::attach (const int shmid,
		       const void *shmaddr,
		       const int shmflg,
		       HANDLE & hFileMap)
{
  client_request_shm request (shmid, shmflg);

  if (request.make_request () == -1 || request.error_code ())
d158 2
a159 5
      syscall_printf (("-1 [%d] = "
		       "shmat (shmid = %d, shmaddr = %p, shmflg = 0%o)"),
		      request.error_code (), shmid, shmaddr, shmflg);
      set_errno (request.error_code ());
      return NULL;
d161 1
a161 12

  int result = 0;

  const DWORD access = (shmflg & SHM_RDONLY) ? FILE_MAP_READ : FILE_MAP_WRITE;

  if (shmaddr && (shmflg & SHM_RND))
    shmaddr = (char *) shmaddr - ((ssize_t) shmaddr % SHMLBA);

  void *const ptr =
    MapViewOfFileEx (request.hFileMap (), access, 0, 0, 0, (void *) shmaddr);

  if (!ptr)
d163 3
a165 4
      syscall_printf (("failed to map view "
		       "[shmid = %d, handle = %p, shmaddr = %p]: %E"),
		      shmid, request.hFileMap (), shmaddr);
      result = EINVAL;		// FIXME
d167 2
a168 1
  else if (shmaddr && ptr != shmaddr)
d170 11
a180 6
      syscall_printf (("failed to map view at requested address "
		       "[shmid = %d, handle = %p]: "
		       "requested address = %p, mapped address = %p"),
		      shmid, request.hFileMap (),
		      shmaddr, ptr);
      result = EINVAL;		// FIXME
d182 3
a184 2

  if (result != 0)
d186 1
a186 13
      if (!CloseHandle (request.hFileMap ()))
	syscall_printf (("failed to close file map handle "
			 "[shmid = %d, handle = %p]: %E"),
			shmid, request.hFileMap ());

      client_request_shm dt_req (shmid);

      if (dt_req.make_request () == -1 || dt_req.error_code ())
	syscall_printf ("shmdt request failed [shmid = %d, handle = %p]: %s",
			shmid, request.hFileMap (),
			strerror (dt_req.error_code ()));

      set_errno (result);
d189 4
a192 37

  hFileMap = request.hFileMap ();
  return ptr;
}

/*---------------------------------------------------------------------------*
 * client_shmmgr::new_segment ()
 *
 * Allocate a new segment for the given shmid, file map and address
 * and insert into the segment map.
 *---------------------------------------------------------------------------*/

client_shmmgr::segment_t *
client_shmmgr::new_segment (const int shmid,
			    const void *const shmaddr,
			    const int shmflg,
			    const HANDLE hFileMap)
{
  assert (ipc_ext2int_subsys (shmid) == IPC_SHMOP);
  assert (hFileMap);
  assert (shmaddr);

  segment_t *previous = NULL;	// Insert pointer.

  const segment_t *const tmp = find (shmaddr, &previous);

  assert (!tmp);
  assert (previous							\
	  ? (!previous->next || previous->next->shmaddr > shmaddr)	\
	  : (!_segments_head || _segments_head->shmaddr > shmaddr));

  segment_t *const segptr =
    safe_new (segment_t, shmid, shmaddr, shmflg, hFileMap);

  assert (segptr);

  if (previous)
d194 3
a196 2
      segptr->next = previous->next;
      previous->next = segptr;
d198 10
a207 4
  else
    {
      segptr->next = _segments_head;
      _segments_head = segptr;
d209 6
a214 114

  const long cnt = InterlockedIncrement (&_shmat_cnt);
  assert (cnt > 0);

  return segptr;
}

/*---------------------------------------------------------------------------*
 * fixup_shms_after_fork ()
 *---------------------------------------------------------------------------*/

int __stdcall
fixup_shms_after_fork ()
{
  return shmmgr.fixup_shms_after_fork ();
}

/*---------------------------------------------------------------------------*
 * client_request_shm::client_request_shm ()
 *---------------------------------------------------------------------------*/

client_request_shm::client_request_shm (const int shmid, const int shmflg)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmat;

  _parameters.in.shmid = shmid;
  _parameters.in.shmflg = shmflg;

  _parameters.in.cygpid = getpid ();
  _parameters.in.winpid = GetCurrentProcessId ();
  _parameters.in.uid = geteuid32 ();
  _parameters.in.gid = getegid32 ();

  msglen (sizeof (_parameters.in));
}

/*---------------------------------------------------------------------------*
 * client_request_shm::client_request_shm ()
 *---------------------------------------------------------------------------*/

client_request_shm::client_request_shm (const int shmid,
					const int cmd,
					const struct shmid_ds *const buf)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmctl;

  _parameters.in.shmid = shmid;
  _parameters.in.cmd = cmd;
  if (buf)
    _parameters.in.ds = *buf;

  _parameters.in.cygpid = getpid ();
  _parameters.in.winpid = GetCurrentProcessId ();
  _parameters.in.uid = geteuid32 ();
  _parameters.in.gid = getegid32 ();

  msglen (sizeof (_parameters.in));
}

/*---------------------------------------------------------------------------*
 * client_request_shm::client_request_shm ()
 *---------------------------------------------------------------------------*/

client_request_shm::client_request_shm (const int shmid)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmdt;

  _parameters.in.shmid = shmid;

  _parameters.in.cygpid = getpid ();
  _parameters.in.winpid = GetCurrentProcessId ();
  _parameters.in.uid = geteuid32 ();
  _parameters.in.gid = getegid32 ();

  msglen (sizeof (_parameters.in));
}

/*---------------------------------------------------------------------------*
 * client_request_shm::client_request_shm ()
 *---------------------------------------------------------------------------*/

client_request_shm::client_request_shm (const key_t key,
					const size_t size,
					const int shmflg)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmget;

  _parameters.in.key = key;
  _parameters.in.size = size;
  _parameters.in.shmflg = shmflg;

  _parameters.in.cygpid = getpid ();
  _parameters.in.winpid = GetCurrentProcessId ();
  _parameters.in.uid = geteuid32 ();
  _parameters.in.gid = getegid32 ();

  msglen (sizeof (_parameters.in));
}
#endif /* USE_SERVER */

/*---------------------------------------------------------------------------*
 * shmat ()
 *---------------------------------------------------------------------------*/

extern "C" void *
shmat (const int shmid, const void *const shmaddr, const int shmflg)
{
#ifdef USE_SERVER
  sigframe thisframe (mainthread);
  return shmmgr.shmat (shmid, shmaddr, shmflg);
d217 1
a217 1
  return (void *) -1;
a220 4
/*---------------------------------------------------------------------------*
 * shmctl ()
 *---------------------------------------------------------------------------*/

d222 1
a222 1
shmctl (const int shmid, const int cmd, struct shmid_ds *const buf)
d226 48
a273 1
  return shmmgr.shmctl (shmid, cmd, buf);
a279 4
/*---------------------------------------------------------------------------*
 * shmdt ()
 *---------------------------------------------------------------------------*/

d281 1
a281 1
shmdt (const void *const shmaddr)
d285 22
a306 1
  return shmmgr.shmdt (shmaddr);
a312 4
/*---------------------------------------------------------------------------*
 * shmget ()
 *---------------------------------------------------------------------------*/

d314 1
a314 1
shmget (const key_t key, const size_t size, const int shmflg)
d318 40
a357 1
  return shmmgr.shmget (key, size, shmflg);
@


1.20
log
@change copyright
@
text
@d15 1
a22 1
#include "cygerrno.h"
a554 44
 * shmat ()
 *---------------------------------------------------------------------------*/

extern "C" void *
shmat (const int shmid, const void *const shmaddr, const int shmflg)
{
  sigframe thisframe (mainthread);
  return shmmgr.shmat (shmid, shmaddr, shmflg);
}

/*---------------------------------------------------------------------------*
 * shmctl ()
 *---------------------------------------------------------------------------*/

extern "C" int
shmctl (const int shmid, const int cmd, struct shmid_ds *const buf)
{
  sigframe thisframe (mainthread);
  return shmmgr.shmctl (shmid, cmd, buf);
}

/*---------------------------------------------------------------------------*
 * shmdt ()
 *---------------------------------------------------------------------------*/

extern "C" int
shmdt (const void *const shmaddr)
{
  sigframe thisframe (mainthread);
  return shmmgr.shmdt (shmaddr);
}

/*---------------------------------------------------------------------------*
 * shmget ()
 *---------------------------------------------------------------------------*/

extern "C" int
shmget (const key_t key, const size_t size, const int shmflg)
{
  sigframe thisframe (mainthread);
  return shmmgr.shmget (key, size, shmflg);
}

/*---------------------------------------------------------------------------*
d650 64
@


1.19
log
@Throughout, change USE_CYGSERVER to USE_SERVER.
* Makefile.in (LIBSERVER): Define and use.
* configure.in: Set LIBSERVER as appropriate.
* environ.cc: Rename allow_daemon to allow_server.  Only recognize when
USE_SERVER is defined.
@
text
@d3 1
a3 1
   Copyright 2002 Red Hat, Inc.
@


1.18
log
@* Makefile.in: Remove cygserver stuff.
* acconfig.h: Add USE_CYGSERVER define.
* config.h.in: Regenerate.
* configure.in: Add --enable-server setting.
* configure: Regenerate.
* fhandler_tty.cc (fhandler_tty_slave::open): Conditionalize compilation of
cygserver stuff.
* fork.cc (fork_child): Ditto.
* shm.cc: Ditto.
* tty.cc (tty::common_init): Ditto.
* dcrt0.cc: Use bool rather than BOOL for CYGWIN environment variable
definitions.
* environ.cc: Ditto.
* ntea.cc: Ditto.
* security.cc: Ditto.
* security.h: Ditto.
* syscalls.cc (check_posix_perm): Remove externs that were already declared in
a header.
* winsup.h: Ditto.  Declare _MT_SAFE here.  Delete it someday since cygwin
should always be _MT_SAFE.
@
text
@d15 1
a15 1
#ifdef USE_CYGSERVER
d693 1
a693 1
#endif /* USE_CYGSERVER */
@


1.17
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d15 1
a15 1

d693 1
@


1.16
log
@	Switch to 32/64 datatypes:
	* Makefile.in (OBSOLETE_FUNCTIONS): Add open acl aclcheck aclfrommode
	aclfrompbits aclfromtext aclsort acltomode acltopbits acltotext chown
	facl fchown fgetpos fopen freopen fseeko fsetpos fstat ftello
	ftruncate getegid geteuid getgid getgrent getgrgid getgrnam getgroups
	getpwuid getpwuid_r getuid initgroups lchown lseek lstat mknod mmap
	seekdir setegid seteuid setgid setgroups setregid setreuid setuid stat
	telldir truncate.
	(NEW_FUNCTIONS): Add _open64 acl32 aclcheck32 aclfrommode32
	aclfrompbits32 aclfromtext32 aclsort32 acltomode32 acltopbits32
	acltotext32 chown32 facl32 fchown32 fgetpos64 fopen64 freopen64
	fseeko64 fsetpos64 fstat64 ftello64 ftruncate64 getegid32 geteuid32
	getgid32 getgrent32 getgrgid32 getgrnam32 getgroups32 getpwuid32
	getpwuid_r32 getuid32 initgroups32 lchown32 lseek64 lstat64 mknod32
	mmap64 seekdir64 setegid32 seteuid32 setgid32 setgroups32 setregid32
	setreuid32 setuid32 stat64 telldir64 truncate64 to substitute the
	above.
	* cygserver_shm.h (class client_request_shm): Change uid_t and gid_t
	members to __uid32_t and __gid32_t.
	* cygwin.din: Add symbols acl32 aclcheck32 aclfrommode32
	aclfrompbits32 aclfromtext32 aclsort32 acltomode32 acltopbits32
	acltotext32 facl32 fgetpos64 fopen64 freopen64 fseeko64 fsetpos64
	_fstat64 ftello64 _lseek64 mknod32 _open64.
	* glob.c: Include perprocess.h.
	(globtilde): Call getpwuid32 and getuid32 instead of getpwuid and
	getuid.
	(g_lstat): Check for applications API version to call the appropriate
	typed gl_lstat function.
	(g_stat): Ditto for gl_stat.
	* shm.cc (client_request_shm::client_request_shm): Call geteuid32
	and getegid32 instead of geteuid and getegid throughout.
	* syscalls.cc (_open64): New alias for open.
	(_lseek64): New alias for lseek64.
	(_fstat64): New alias for fseek64.
	(mknod32): New function.
	(mknod): Calls mknod32 now.
	* winsup.h: Make function declarations for getuid32, geteuid32,
	and getpwuid32 accessible for plain C sources.  Add declarations
	for getegid32 and getpwnam.
	* include/cygwin/version.h: Bum API minor number to 78.
	* include/sys/cygwin.h: Guard C++ specific members of struct
	per_process against inclusion in plain C sources.
	* include/sys/mman.h (mman): Add guard to avoid type clash when
	compiling Cygwin.
@
text
@a18 1
#include <errno.h>
@


1.15
log
@2002-09-22  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	GNUify non-GNU formatted functions calls throughout.

2002-09-22  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (with_strerr): Remove macro.
	(server_shmmgr::segment_t::~segment_t): Remove calls to with_strerr.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::new_segment): Ditto.
	* shm.cc (with_strerr): Remove macro.
	(client_shmmgr::shmdt): Remove calls to with_strerr.
	(client_shmmgr::attach): Ditto.

2002-09-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/sys/ipc.h: Move to "include/cygwin/ipc.h".
	* include/sys/msg.h: Move to "include/cygwin/msg.h".
	* include/sys/sem.h: Move to "include/cygwin/sem.h".
	* include/sys/shm.h: Move to "include/cygwin/shm.h".
	* include/cygwin/ipc.h: New file.
	* include/cygwin/msg.h: Ditto.
	* include/cygwin/sem.h: Ditto.
	* include/cygwin/shm.h: Ditto.
	* cygserver_shm.h: Update includes.
	* msg.cc: Ditto.
	* sem.cc: Ditto.

2002-09-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h (safe_delete): Make a templated function.
	* cygserver.cc (~server_request): Update use of safe_delete.
	(main): Ditto.
	* cygserver_client.cc (client_request::handle_request): Ditto.
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::remove): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	* cygserver_shm.cc (server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* shm.cc (client_shmmgr::shmdt): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.

2002-08-29  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: Replace #include <new> with an explicit
	definition of the placement new operator.
	(safe_delete): Remove unnecessary ## operator.

2002-07-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (class server_shmmgr): Remove `cleanup_t'
	friend declaration.
	(cleanup_t::cleanup_t): Use the segment's shmid as the key rather
	than the segment pointer itself.
	(cleanup_t::segptr): Remove method.
	(cleanup_t::shmid): New method.
	(cleanup_t::cleanup): Update for new key value.
	(server_shmmgr::find (segment_t *)): Remove method.
	* include/cygwin/cygserver_process.h (cleanup_routine::key): Make
	method const.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_process.h
	(cleanup_routine::_key): New field.
	(cleanup_routine::cleanup_routine): Initialise new field with new
	argument.
	(cleanup_routine::operator==): New method.
	(cleanup_routine::key): New method.
	(cleanup_routine::cleanup): Make argument non-const.
	(process::is_active): New method.
	(process::remove): Ditto.
	(process::check_exit_code): Rename method.
	* cygserver_process.cc (process::add): Reorganize code.
	(process::remove): New method.
	(process::check_exit_code): Rename method.
	(process::cleanup): Use new `process::is_active' method.
	(process_cache::process): Ditto.
	(process_cache::sync_wait_array): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr): Make `cleanup_t' a friend.
	(segment_t::detach): Make argument non-const.  Remove cleanup
	object from client if appropriate.
	(cleanup_t::_segptr): Remove field.
	(cleanup_t::cleanup_t): Initialise parent explicitly.  Remove
	field.
	(cleanup_t::segptr): New method.
	(cleanup_t::cleanup): Add error checking and reporting.
	(server_shmmgr::shmdt): Make argument non-const.
	(server_shmmgr::find (segment_t *)): New method.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (client_request_shutdown::client_request_shutdown):
	Comment out verbose tracing statement.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Ditto.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	* cygserver_shm.cc (client_request_shm::client_request_shm):
	Ditto.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc (transport_layer_pipes::listen):
	Set `_is_listening_endpoint' appropriately.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(transport_layer_base::listen): Change return type.
	(transport_layer_base::connect): Ditto.
	* include/cygwin/cygserver_transport_pipes.h
	(transport_layer_pipes::listen): Change return type.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::_sec_none_nih): Remove unused field.
	(transport_layer_pipes::_is_listening_endpoint): New field.
	* cygserver_transport_pipes.cc: Synchronize with sockets code.
	(transport_layer_pipes::transport_layer_pipes): Initialise new
	field.  Separate out asserts.
	(transport_layer_pipes::listen): Change return type.  Add asserts.
	(transport_layer_pipes::accept): Add asserts.
	(transport_layer_pipes::read): Change conditional to an assert.
	Add assert.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Change return type.  Change
	conditional to an assert.  Add asserts.  Rationalize error code
	slightly.
	(transport_layer_pipes::impersonate_client): Add asserts.
	* include/cygwin/cygserver_transport_sockets.h
	(transport_layer_sockets::listen): Change return type.
	(transport_layer_sockets::connect): Ditto.
	(transport_layer_sockets::_addr): Change type of field.
	(transport_layer_sockets::_addr_len): Ditto.
	(transport_layer_sockets::_is_accepted_endpoint): New field.
	(transport_layer_sockets::_is_listening_endpoint): Ditto.
	* cygserver_transport_sockets.cc
	(MAX_CONNECT_RETRY): New constant.
	(transport_layer_sockets::transport_layer_sockets): Initialise new
	fields.  Only initialise the socket address where necessary.
	(transport_layer_sockets::listen): Change return type.  Rewrite.
	(transport_layer_sockets::accept): Add asserts.  Add tracing
	statements.  Use a local variable to hold the accepted address.
	(transport_layer_sockets::close): Add tracing statements.  Unlink
	the UNIX domain socket file as appropriate.  Close the socket
	cleanly.
	(transport_layer_sockets::read): Rewrite method.
	(transport_layer_sockets::write): Ditto.
	(transport_layer_sockets::connect): Change return type.  Rewrite.
	* cygserver.cc (server_submission_loop::request_loop): Run the
	listening thread at high priority with special handling for
	shutdown.
	(main): Print the request error code rather than errno in shutdown
	request code.  Install signal handlers with sigaction(2) to avoid
	setting SA_RESTART.  Check value of the listen method call, now it
	has one.
	* cygserver_client.cc (client_request::make_request): Check new
	return value on connect method call.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport_pipes.h
	(cygserver_transport_pipes::_sd): Rename field.
	(cygserver_transport_pipes::_sec_none_nih): Ditto.
	(cygserver_transport_pipes::_sec_all_nih): Ditto.
	(cygserver_transport_pipes::_pipe_name): Ditto.
	(cygserver_transport_pipes::_hPipe): Ditto.
	(cygserver_transport_pipes::_is_accepted_endpoint): Ditto.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::transport_layer_pipes): Rename fields.
	(transport_layer_pipes::init_security): Ditto.
	(transport_layer_pipes::listen): Ditto.
	(transport_layer_pipes::accept): Ditto.
	(transport_layer_pipes::close): Ditto.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.
	(transport_layer_pipes::revert_to_self): Ditto.
	* include/cygwin/cygserver_transport_sockets.h
	(cygserver_transport_sockets::_fd): Rename field.
	(cygserver_transport_sockets::_addr): Ditto.
	(cygserver_transport_sockets::_addr_len): Ditto.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::transport_layer_sockets): Rename fields.
	(transport_layer_sockets::listen): Ditto.
	(transport_layer_sockets::accept): Ditto.
	(transport_layer_sockets::close): Ditto.
	(transport_layer_sockets::read): Ditto.
	(transport_layer_sockets::write): Ditto.
	(transport_layer_sockets::connect): Ditto.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (with_strerr): Fix use of %p format.
	* shm.cc (client_shmmgr::shmat): Ditto.
	(client_shmmgr::shmctl): Ditto.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::attach): Ditto.

2002-07-14  Christopher Faylor  <cgf@@redhat.com>

	* woutsup.h (system_printf): Remove extraneous semicolon from macro
	definition.

2002-07-14  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc
	(transport_layer_pipes::connect): Use ProtectHandle in DLL code.
	(transport_layer_pipes::close): Use ForceCloseHandle in DLL code.

2002-07-13  Nicholas Wourms  <nwourms@@netscape.com>

	* threaded_queue.h (class queue_submission_loop): Correct friend
	declaration for GCC 3.1.1.
	* include/cygwin/cygserver_process.h (class process): Ditto.
	(class process_cache): Ditto.

2002-07-12  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::shmdt): Only call
	delete_segment if the segment exists [sic].

2002-07-12  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: Include <new> rather than <new.h> for gcc 3.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: New file extracted from "woutsup.h".
	* woutsup.h: Move the "safe" new/delete macros into the new
	"safe_memory.h" header file and include that here.
	* cygserver_client.cc: Explicitly include "safe_memory.h" for
	client-side code.
	(client_request::make_request): Use the "safe" new/delete macros
	unconditionally, i.e. use them on the client side as well as on
	the server side.
	* cygserver_transport.cc: Explicitly include "safe_memory.h" for
	client-side code.
	(create_server_transport): Use the "safe" new/delete macros
	unconditionally, i.e. use them on the client side as well as on
	the server side.
	* shm.cc: Include "safe_memory.h".
	(client_shmmgr::instance): Use the "safe" new/delete macros.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::new_segment): Ditto.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_process (process::process): Add the client's cygpid
	and winpid to all tracing statements as appropriate.
	(process::exit_code): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::shmat): Ditto.
	(server_shmmgr::shmdt): Ditto.
	(server_shmmgr::shmctl): Add a process object argument and remove
	the explicit cygpid argument.  Add the client's cygpid and winpid
	to all tracing statements as appropriate.
	(server_shmmgr::shmget): Ditto.
	(client_request_shm::serve): Update for the new signature of the
	shmctl and shmget methods.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (client_request_shutdown::serve): Don't set the
	shutdown flag directly, but send a SIGINT, as the signal handler
	sets the flag and the signal breaks the pause(2) in the main loop.
	(print_usage): Add new options.
	(main): Add new --cleanup-threads and --request-threads options to
	set the number of threads used by the daemon.  Use pause(2) rather
	the win32 Sleep in the main loop.
	* shm.cc (shmat): Add sigframe.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Automatically detach processes from any
	segments they are attached to at exit.
	(class server_shmmgr::attach_t): New class.
	(server_shmmgr::segment_t::IS_DELETED): Rename and make private.
	(server_shmmgr::segment_t::_sequence): Make private.
	(server_shmmgr::segment_t::_flg): Ditto.
	(server_shmmgr::segment_t::_hFileMap): Ditto.
	(server_shmmgr::segment_t::_attach_head): New private field.
	(server_shmmgr::segment_t::segment_t): Initialise new fields.
	Make non-inline.
	(server_shmmgr::segment_t::~segment_t): New method.
	(server_shmmgr::segment_t::is_deleted): Ditto.
	(server_shmmgr::segment_t::is_pending_delete): Ditto.
	(server_shmmgr::segment_t::mark_deleted): Ditto.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::segment_t::find): Ditto.
	(class server_shmmgr::cleanup_t): New class.
	(server_shmmgr::_shm_atts): New private field.
	(server_shmmgr::shmat): Add a process object argument to replace
	the removed process_cache, cygpid and winpid arguments.  Remove
	the process_cache manipulations.  Move body of code to the
	segment_t::attach method.  Increment _shm_atts when required.
	Update tracing statements.
	(server_shmmgr::shmdt): Add a process object argument to replace
	the removed cygpid argument.  Move body of code to the
	segment_t::detach method.  Decrement _shm_atts when required.
	Update tracing statements.
	(server_shmmgr::shmget): Use the new segment_t::is_deleted method.
	(server_shmmgr::server_shmmgr): Initialise the new _shm_atts
	field.
	(server_shmmgr::delete_segment): Remove the CloseHandle code, as
	this is now done in the segment_t destructor.
	(client_request_shm::serve): Look up the client's process object
	and pass to the server_shmmgr::shmat and server_shmmgr::shmdt
	methods rather than passing the cache, winpid and cygpid.
	* cygserver_process.h: Add a cygpid to the process object to make
	it more useful and then pass process objects rather than winpids
	where possible.
	(cleanup_routine::cleanup): Change argument to be a pointer to a
	process object.
	(class process): Re-order fields for no discernible reason.
	(process::_cygpid): New field.
	(process::process): Add a cygpid argument.
	(process::winpid): New method.
	(process::cygpid): Ditto.
	(process::add): Make public, as it always should have been.
	(process_cache::process): Add a cygpid argument.
	* cygserver_process.cc (process::process): Add a cygpid argument
	and use it to initialise the `_cygpid' field.  Re-order
	initialisers to match new field order.
	(process::cleanup): Pass `this' rather than just the winpid to
	cleanup_routine::cleanup.
	(process_cache::process): Add a cygpid argument and pass it to the
	process object constructor.
	* include/sys/shm.h (shmatt_t): Make unsigned as per SUSv3.
	(shm_info::shm_atts): New field.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (class server_shmmgr::segment_t): Add `_'
	prefix to the names of all fields.

2002-07-10  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* msg.cc: New file of stub functions, no functionality.
	* sem.cc: Ditto.
	* shm.cc (client_shmmgr::shmctl): Add support for an out shm_info
	buffer for the SHM_INFO command.
	(client_shmmgr::shmget): Use %X to print keys.
	* include/sys/ipc.h: Comment all fields and values.
	(IPC_PRIVATE): Change to be non-negative.
	* include/sys/msg.h: New file with SUSv3 and ipcs(8) interfaces.
	* include/sys/sem.h: Ditto.
	* include/sys/shm.h: Comment all fields and values.
	(struct shm_info): New struct.
	* cygserver_shm.h (client_request_shm::shminfo): Rename.
	(client_request_shm::shm_info): New method.
	(client_request_shm::_parameters.out.hFileMap): Move into union.
	(client_request_shm::_parameters.out.shminfo): Rename.
	(client_request_shm::_parameters.out.shm_info): New field.
	* cygserver_shm.cc (server_shmmgr::_shm_ids): Rename.
	(server_shmmgr::_shm_tot): New field.
	(server_shmmgr::shmctl): Rename `out_shminfo' argument.  Add
	`out_shm_info' argument.  Fill in the `out_shm_info' argument in
	the SHM_INFO command.
	(server_shmmgr::shmget): Check `shmflg' against the mode of
	existing segments as per Stevens 1990, p. 123.
	(server_shmmgr::server_shmmgr): Initialise the new `_shm_tot'
	field.
	(server_shmmgr::new_segment): Set ENOMEM if CreateFileMapping
	fails.  Pass `size' to new_segment.
	(server_shmmgr::new_segment): Add size argument and use it to
	check against and update the new `_shm_tot' field.
	(server_shmmgr::delete_segment): Update the new `_shm_tot' field.
	* Makefile.in (DLL_OFILES): Add new DLL object files.

2002-07-09  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc: The main change is to make the
	client try harder to connect to the server if it's previously
	connected, and so has good grounds for believing that the server
	is running.
	(MAX_WAIT_NAMED_PIPE_RETRY): Change to be an enumerator.
	(WAIT_NAMED_PIPE_TIMEOUT): Ditto.
	(transport_layer_pipes::accept): Use interlocked operators on
	`pipe_instance'.
	(transport_layer_pipes::close): Rearrange so that FlushFileBuffers
	and DisconnectNamedPipe are only called for accepted endpoints.
	Use interlocked operators on `pipe_instance'.
	(transport_layer_pipes::read): Use set_errno where required.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Add local static variable
	`assume_cygserver'.  Set it if a connection is made to cygserver,
	clear it if a connection is not made even after retrying.  If set,
	ignore all errors from CreateFile and retry the connection.  Catch
	the situation where WaitNamedPipe fails to wait [sic] and add a
	`Sleep (0)' so that the server gets a chance to run.

2002-07-03  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* dcrt0.cc: Only check for cygserver if and when required.
	(dll_crt0_1): Remove call to `cygserver_init ()'.
	* fhandler_tty.cc (fhandler_tty_slave::open): Change the cygserver
	logic to allow for the fact that `cygserver_init ()' may not yet
	have been called.
	(fhandler_tty_slave::cygserver_attach_tty): Tweak the cygserver
	request logic to conform to the practice elsewhere in the code.
	* tty.cc (tty::common_init): Add an explicit call to
	`cygserver_init ()' if it hasn't already been called.
	* include/cygwin/cygserver.h (CYGSERVER_UNAVAIL): Rename from
	`CYGSERVER_DEAD'.
	(client_request_get_version::check_version): Make available in
	cygserver as well the DLL.
	(check_cygserver_available): Ditto.  Remove `check_version_too'
	argument.
	(cygserver_init): Ditto.  And likewise.
	* cygserver_client.cc (client_request_get_version::check_version):
	Make available in cygserver as well the DLL.
	(client_request::make_request): This may now be called without
	`cygserver_init ()' having been called first.  Detect this and
	call it as required.  Add tracing.
	(check_cygserver_available): Make available in cygserver as well
	the DLL.  Remove `check_version_too' argument and always check the
	version information.  And since this is called from within
	`cygserver_init ()', force `cygserver_running' before calling
	`client_request::make_request ()'.
	(cygserver_init): Make available in cygserver as well the DLL.
	Remove `check_version_too' argument.

2002-07-03  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Implement the ipcs(8) interfaces, IPC_INFO,
	SHM_STAT and SHM_INFO.
	(server_shmmgr::segment_t::sequence): New static field.
	(server_shmmgr::segment_t::key): Remove field, use the new
	ds.shm_perm.key field instead.
	(server_shmmgr::segment_t::shmid): Remove field.
	(server_shmmgr::segment_t::intid): New field.
	(server_shmmgr::segment_t::segment_t): Use the `key' argument to
	initialise `ds.shm_perm.key'.  Change from using `shmid' to
	`intid'.
	(server_shmmgr::_shmseg_cnt): Renamed from `_shmid_cnt'.
	(server_shmmgr::_intid_max): Renamed from `_shmid_max.
	(server_shmmgr::shmat): Move the out arguments to the start of the
	argument list.  Rename the `pid' argument as `cygpid'.  Add
	tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmctl): Add separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add support for the ipcs(8)
	interfaces.  Add tracing.  Pass an intid to `find ()', not a
	shmid.
	(server_shmmgr::shmdt): Rename the `pid' argument as `cygpid'.
	Add tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmget): Add a separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add tracing.
	(server_shmmgr::server_shmmgr): Update for new field names.
	(server_shmmgr::find_by_key): Update for the new `ds.shm_perm.key'
	field.
	(server_shmmgr::find): Update to use the new `segment_t::intid'
	field.
	(server_shmmgr::new_segment): Rename the `pid' argument as
	`cygpid'.  Check that the requested size is within bounds.  Handle
	new error result from `new_segment (key, HANDLE)'.
	(server_shmmgr::new_segment): Work with intids, not shmids.  Check
	that the new intid is within bounds.  Update for new field names.
	(server_shmmgr::delete_segment): Pass an intid to `find ()', not a
	shmid.  Update for new field names.
	(client_request_shm::serve): Check that the incoming message
	length is the size of the `_parameters.in' struct, not of the
	whole in/out parameter union.  Likewise, set the outgoing message
	length to the size of the `_parameters.out' struct.  Update for
	the new server_shmmgr interfaces.
	* include/sys/ipc.h (ipc_perm::key): New field.
	* include/sys/shm.h (SHM_INFO): New constant.
	* cygserver_ipc.h (IPCMNI): New constant.
	(ipc_int2ext): Add `sequence' argument and munge this into the
	external ipc id.
	(ipc_ext2int_subsys): Unmunge the sequence number from the
	external ipc id.
	(ipc_ext2int): Ditto.
	(ipc_inc_id): Remove.
	(ipc_dec_id): Remove.
	* cygserver_shm.h (SHMMAX): New constant.
	(SHMMIN): Ditto.
	(SHMMNI): Ditto.
	(SHMSEG): Ditto.
	(SHMALL): Ditto.
	(client_request_shm::_parameters): Re-arrange as a union of two
	separate structs, one for in arguments, the other for out.
	(client_request_shm::shmid): Update for the new parameter layout.
	(client_request_shm::ds): Ditto.
	(client_request_shm::info): New method.
	* shm.cc (client_shmmgr::_shmat_cnt): New static field.
	(client_shmmgr::shmat): Add locking.  Add tracing.
	(client_shmmgr::shmctl): Update for ipcs(8) commands.  Add
	tracing.  Add more argument checking.
	(client_shmmgr::shmdt): Add locking.  Add tracing.  Update the new
	`_shmat_cnt' field.
	(client_shmmgr::shmget): Add tracing.
	(client_shmmgr::fixup_shms_after_fork): Add tracing.  Add
	consistency checking.
	(client_shmmgr::attach): Add more tracing.
	(client_shmmgr::new_segment): Update the new `_shmat_cnt' field.
	(client_request_shm::client_request_shm): Update for the new
	parameter layout.  Set the outgoing message length to the size of
	the `_parameters.in' struct, not of the whole in/out parameter
	union.

2002-07-02  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* shm.cc: Remove the use of a static client_shmmgr object.
	(client_shmmgr::_instance): New static variable.
	(client_shmmgr::instance): Allocate a new shmmgr on the heap,
	rather than using a local static object.

2002-07-01  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport.cc (create_server_transport): Fix
	cut-and-paste error.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::handle_request): Don't
	bother with the client request activity marker when compiled with
	debugging output.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc
	(MAX_WAIT_NAMED_PIPE_RETRY): New constant.
	(WAIT_NAMED_PIPE_TIMEOUT): Ditto.
	(transport_layer_pipes::close): The `pipe' field is now either
	NULL or a valid handle, and it should never have the value
	`INVALID_HANDLE_VALUE'.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.
	(transport_layer_pipes::connect): Ditto.  New, but still bogus,
	retry logic.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::server_shmmgr): All fields have
	to be initialized now that the singleton is no longer static.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::_instance): New static field.
	(server_shmmgr::_instance_once): Ditto.
	(server_shmmgr::initialise_instance): New static method.
	(server_shmmgr::instance): Use a pthread_once_t rather than
	relying on a local static variable.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h: Remove all uses of the C++ new and delete operators
	throughout cygserver until they are fully thread-safe.
	(safe_new0): New macro to replace the C++ new operator.
	(safe_new): Ditto.
	(safe_delete): New macro to replace the C++ delete operator.
	* cygserver_client.cc (client_request::handle_request): Replace
	all uses of the C++ new and delete operators with the new macros
	from "woutsup.h".
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::new_segment): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* cygserver_transport.cc (create_server_transport): Ditto.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::accept): Ditto.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::accept): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.
	(threaded_queue::stop): Replace sleep(3) with win32 Sleep.
	* cygserver.cc (~server_request): Replace all uses of the C++ new
	and delete operators with the new macros from "woutsup.h".
	(server_submission_loop::request_loop): Ditto.
	(main): Ditto.  Replace sleep(3) with win32 Sleep.  Replace
	iostreams with FILEs.
	(print_usage): Replace iostreams with FILEs.
	(print_version): Ditto.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_sockets.cc
	(transport_layer_sockets::accept): Rename local variable
	`accept_fd' to avoid shadowing the `fd' field.

2002-06-29  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygwin_ipc.h: Moved (back) to "include/sys/ipc.h".
	* cygwin_shm.h: Moved (back) to "include/sys/shm.h".
	* include/sys/ipc.h: New file.
	* include/sys/shm.h: New file.
	* cygserver_shm.h: Update for new header file locations.
	* ipc.cc: Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::make_request): Comment out
	a verbose tracing statement.
	* cygserver_process.cc (process_cache::sync_wait_array): Fix
	broken assert.
	* include/cygwin/cygserver.h (class client_request): Remove excess
	use of `class' qualifier in declarations.
	(class client_request_get_version): Ditto.
	(class client_request_shutdown): Ditto.
	(class client_request_attach_tty): Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_ipc.h: New file.
	* cygserver_shm.h: Re-written from scratch.
	* cygserver_shm.cc: Ditto.
	* shm.cc: Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* threaded_queue.h (class queue_request): Re-write.
	(threaded_queue_thread_function): Remove.
	(class queue_process_param): Remove.
	(class threaded_queue): Re-write.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	(TInterlockedExchangePointer): New templated function.
	(TInterlockedCompareExchangePointer): Ditto.
	* threaded_queue.cc (worker_function): Remove.
	(class threaded_queue): Re-write.
	(class queue_process_param): Remove.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	* include/cygwin/cygserver_process.h (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver_process.cc (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver.cc (request_count): Remove unused variable.
	(class server_request): Move methods inline.
	(class server_process_param): Remove.
	(class server_request_queue): Remove.
	(request_queue): Move into `main ()' and change type to
	`threaded_queue'.
	(request_loop): Remove.
	(class server_submission_loop): New version of the old
	`server_process_param' class.
	(shutdown_server): New variable.
	(client_request_shutdown::serve): Set `shutdown_server' to trigger
	shutdown.
	(handle_signal): Ditto.
	(main): Install signal handler for SIGINT rather than SIGQUIT.
	Use new interfaces for the `request_queue' and the `cache'.
	Create a `server_submission_loop' and add to the `request_queue'.
	Add check for the `shutdown_server' variable to the main loop.
	* cygserver_shm.cc (client_request_shm::serve): Release the
	process object after use.

2002-06-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::handle_request): Correct
	tracing statement.
	* cygserver_transport_pipes.cc: Remove local definition of
	FILE_FLAG_FIRST_PIPE_INSTANCE constant.
	* cygwin_ipc.h: Update copyright notice.
	* cygwin_shm.h: Ditto.
	* woutsup.h: Add definition of _WIN32_WINNT.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client (client_request::make_request): Replace my
	inappropriate use of set_errno () with error_code () throughout.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h: Add forward declarations of class
	transport_layer_base and class process_cache to reduce
	dependencies between header files.
	* include/cygwin/cygserver_process.h: Add include of
	"threaded_queue.h".
	* cygserver.cc: Remove unnecessary cygserver header files.
	* cygserver_client.cc: Ditto.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_shm.h: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* dcrt0.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.h: Replace <sys/shm.h> with "cygwin_shm.h" after
	merge from HEAD.
	* cygwin_ipc.h: Update with changes to include/sys/ipc.h lost in
	merge from HEAD.
	* cygwin_shm.h: Ditto.

2002-06-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc: The tests for a duplicate server instance are now
	the responsibility of the transport layer.
	(request_loop): Use new `recoverable' flag in call to
	`cygserver_transport::accept ()' and shutdown on an unrecoverable
	error.
	(main): Never call `cygserver_init ()'.  Fake `cygserver_running'
	just for sending a shutdown request.
	* cygserver_client.cc (client_request::send): Comment out
	message-size tracing statements as verbose.
	(client_request::handle): Ditto.
	(client_request_get_version::check_version): #ifdef as DLL-only.
	(check_cygserver_available): Ditto.
	(cygserver_init): Ditto.
	* include/cygwin/cygserver.h
	(client_request_get_version::check_version): #ifdef as DLL-only.
	(check_cygserver_available): Ditto.
	(cygserver_init): Ditto.
	* include/cygwin/cygserver_transport.h
	(transport_layer_base::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_base::revert_to_self): Ditto.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.  Add a `recoverable' out
	flag for error handling.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	(transport_layer_pipes): Change type of the `pipe_name' field.
	Remove the `inited' field, as unnecessary.  Add new
	`is_accepted_endpoint' field.
	* include/cygwin/cygserver_transport.cc
	(transport_layer_base::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_base::revert_to_self): Ditto.
	* include/cygwin/cygserver_transport_sockets.cc
	(transport_layer_sockets::listen): #ifdef as cygserver-only.
	(transport_layer_sockets::accept): #ifdef as cygserver-only.
	Analyse any errno from `accept ()' and set `recoverable' as
	appropriate.
	* cygserver_transport_pipes.cc: Add local #define of
	`FILE_FLAG_FIRST_PIPE_INSTANCE'.
	(pipe_instance_lock_once): New variable.
	(pipe_instance_lock): Ditto.
	(pipe_instance): Ditto.
	(initialise_pipe_instance_lock): New function.
	(transport_layer_pipes::transport_layer_pipes): Change
	initialization of `pipe_name'.  Initialize `is_accepted_endpoint'
	as appropriate.  Remove use of `inited'.
	(transport_layer_pipes::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_pipes::revert_to_self): Ditto.
	(transport_layer_pipes::listen): Ditto.
	(transport_layer_pipes::accept): Ditto.  Keep track of how often
	many named pipes have been created, in the `pipe_instance'
	variable, and pass the `FILE_FLAG_FIRST_PIPE_INSTANCE' flag on the
	open of the first instance.  Analyse the error code from
	`CreateNamedPipe ()' and set the `recoverable' flag as
	appropriate.
	(transport_layer_pipes::close): Update the `pipe_instance' count.

2002-06-18  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h (cygserver_running): Add declaration.
	(api_fatal): Eliminate.
	* include/cygwin/cygserver.h
	(client_request_get_version::check_version): Change return type to
	bool.
	(check_cygserver_available): New function.
	(cygserver_init): Add check_version_too argument.
	* cygserver_client.cc (allow_daemon): Make a bool.
	(client_request_get_version::make_request): See errno on error.
	Remove special case for CYGSERVER_REQUEST_GET_VERSION; this is now
	handled in cygserver_init().
	(client_request_get_version::check_version): Use syscall_printf()
	instead of api_fatal(). Return true if cygserver version is
	compatible.
	(check_cygserver_available): New function; code moved here from
	cygserver_init().
	(cygserver_init): Move some code into check_cygserver_available().
	* cygserver.cc (__set_errno): Copy from debug.cc so that
	set_errno() can be used when __OUTSIDE_CYGWIN__.
	(main): Call cygserver_init() to set up cygserver_running and add
	checks against this to (try and) prevent multiple copies of
	cygserver running simultaneously.  Remember to delete all
	transport connections so that (one day) the transport classes can
	tidy up on cygserver shutdown.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (main): Adjust tracing output for a cleaner display
	when compiled without --enable-debugging.
	* threaded_queue.cc (threaded_queue::cleanup): Ditto.
	(queue_process_param::stop): Ditto.
	* include/cygwin/cygserver.h
	(client_request::make_request): Make non-virtual.
	(client_request::send): Make virtual and protected, not private.
	(client_request_attach_tty::send): New virtual method.
	* cygserver_client.cc: Use the `msglen()' accessor rather than
	`_header.msglen' throughout.
	(client_request_attach_tty::send): New method.
	(client_request::make_request): Remove the explicit close of
	`transport' as it is closed on deletion.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h: Change the client_request classes to
	give greater encapsulation and to allow variable length requests
	and replies.
	(enum cygserver_request_code): Now client_request::request_code_t.
	(class request_header): Now client_request::header_t.  Make a
	union of the request_code and the error_code.  The `cb' field,
	which was the buffer length, is now the `size_t msglen' field.
	(struct request_get_version): Now
	client_request_get_version::request_get_version.
	(struct request_shutdown): Remove unused type.
	(struct request_attach_tty): Now
	client_request_attach_tty::request_attach_tty.
	(client_request::_buf): Make field const.
	(client_request::_buflen): New const private field.
	(client_request::request_code): New accessor.
	(client_request::error_code): Ditto.
	(client_request::msglen): Ditto.
	(client_request::handle_request): New static method.
	(client_request::make_request): New virtual method.
	(client_request::handle): New method.
	(client_request::send): Make private.
	(client_request_get_version::check_version): New method.
	(client_request_get_version::serve): Make private.
	(client_request_get_version::version): Ditto.
	(client_request_shutdown::serve): Ditto.
	(client_request_attach_tty::req): Ditto.
	(client_request_attach_tty::serve): Ditto.
	(client_request_attach_tty::from_master): Make method const.
	(client_request_attach_tty::from_master): Ditto.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Track
	changes to the client_request classes.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	(client_request_get_version::check_version): New method to
	encapsulate code from cygserver_init().
	(client_request_shutdown::client_request_shutdown): Move into
	"cygserver.cc".
	(client_request::send): Track changes to the client_request
	classes.  Add more error checking.
	(client_request::handle_request): New static method containing the
	first half of the old server_request::process() code.
	(client_request::make_request): New method to replace the old
	cygserver_request() function.
	(client_request::handle): New method containing the second half of
	the old server_request::process() code.
	(cygserver_init): Track changes to the client_request classes.  In
	particular, some code moved into the
	client_request_get_version::check_version() method.
	* cygserver.cc (client_request_attach_tty::serve): Track changes
	to the client_request classes.  In particular, only return a reply
	body if some handles are successfully duplicated for the client.
	And remove goto's.
	(client_request_get_version::serve): Track changes to the
	client_request classes.
	(client_request_shutdown::serve): Ditto.
	(class client_request_invalid): Dead, and so young too.
	(server_request::request_buffer): Remove unnecessary field.
	(client_request_shutdown::client_request_shutdown): Moved here
	from "cygserver_client.cc".
	(server_request::process): Implementation moved into the new
	client_request::handle_request() and client_request::handle()
	methods.
	* cygserver_shm.h (class client_request_shm): Put client- and
	server-specific interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__
	guards.
	(client_request_shm::serve): Make private.
	* cygserver_shm.cc
	(client_request_shm::client_request_shm): Track changes to the
	client_request classes.
	(client_request_shm::serve): Ditto
	* shm.cc (client_request_shm::client_request_shm): Ditto.  Use
	alloc_sd() rather than set_security_attribute() to get access to
	the SECURITY_DESCRIPTOR length, so that we can use it to set the
	request body length.
	(shmat): Track changes to the client_request classes. In
	particular, allocate client_request objects on the stack rather
	than on the heap, and use the client_request::make_request()
	method rather than the old cygserver_request() function.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::cygserver_attach_tty): Ditto.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(cygserver_transport::read): Change buffer type to void *.
	(cygserver_transport::write): Ditto.
	* include/cygwin/cygserver_transport_sockets.h
	(cygserver_transport_sockets::read): Ditto.
	(cygserver_transport_sockets::write): Ditto.
	* include/cygwin/cygserver_transport_pipes.h
	(cygserver_transport_pipes::read): Ditto.
	(cygserver_transport_pipes::write): Ditto.
	* cygserver_transport_sockets.cc
	(cygserver_transport_sockets::read): Ditto.
	(cygserver_transport_sockets::write): Ditto.
	* cygserver_transport_pipes.cc
	(cygserver_transport_pipes::read): Ditto. Set errno on error, to
	match behaviour of cygserver_transport_sockets class.
	(cygserver_transport_pipes::write): Ditto.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (version): New static variable.
	(server_request_queue::add_connection): Remove my gratuitous use
	of studly caps.
	(setup_privileges): Declare static.
	(handle_signal): Ditto.
	(longopts): Make a local variable of main().
	(opts): Ditto.
	(print_usage): New function.
	(print_version): Ditto (tip of the hat to Joshua Daniel Franklin
	for inspiration here).
	(main): More argument checking.  Add --help and --version options.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h (client_request::serve): Make pure
	virtual.
	* cygserver.cc (client_request::serve): Remove definition of pure
	virtual method.
	(class client_request_invalid): New class.
	(server_request::process): Use new client_request_invalid
	class. And remove goto's.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (class server_request): Add virtual destructor.
	(server_request_queue::addConnection): New method to replace bad
	virtual add() method.
	(request_loop): Replace call to queue->add() with call to
	queue->addConnection().
	(server_request::server_request): Use field initialization.
	(server_request::~server_request): New virtual destructor.
	(server_request::process): Remove close and delete of
	transport_layer_base object. It is deleted by the server_request's
	own destructor and closed by its own destructor.
	* include/cygwin/cygserver.h
	(client_request::operator request_header): Remove unused method.
	* cygserver_client.cc: Ditto.
	* include/cygwin/cygserver_process.h
	(class cleanup_routine): Add virtual destructor.
	(cleanup_routine::cleanup): Make pure virtual.
	(class process_cache): Make destructor non-virtual.
	(process_cache::add): Ditto.
	* cygserver_process.cc
	(cleanup_routine::~cleanup_routine): New virtual destructor.
	* include/cygwin/cygserver_transport.h
	(class transport_layer_base): Add virtual destructor.
	* cygserver_transport.cc
	(transport_layer_base::~transport_layer_base): New virtual
	destructor.
	* include/cygwin/cygserver_transport_pipes.h
	(class transport_layer_pipes): Add virtual destructor.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::~transport_layer_pipes): New virtual
	destructor.
	(transport_layer_pipes::close): Null out handle after closing.
	* include/cygwin/cygserver_transport_sockets.h
	(class transport_layer_sockets): Add virtual destructor.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::~transport_layer_sockets): New virtual
	destructor.
	(transport_layer_sockets::close): Null out fd after closing.
	* threaded_queue.h (class queue_request): Add virtual destructor.
	(queue_request::process): Make pure virtual.
	* threaded_queue.cc (~queue_request): New virtual destructor.
	(queue_request::process): Remove definition of pure virtual
	method.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h (client_request::send): Make
	non-virtual.
	(class client_request_attach_tty): Put client- and server-specific
	interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__ guards.
	* cygserver_client.cc: Ditto.
	(cygserver_init): Fix error handling.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc: Throughout the code, check and correct level of
	the XXX_printf() functions used. Comment out several of the
	debug_printf() calls with "// verbose:".  Reformat and correct
	typos of some of the XXX_printf() formats.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* shm.cc (hi_ulong): New function to allow printing of a 64-bit
	key with current small_printf implementation.
	(lo_ulong): Ditto.
	(client_request_shm::client_request_shm): Use hi_ulong() and
	lo_ulong() in call to debug_printf().

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Remove #define __INSIDE_CYGWIN__ from around
	<sys/shm.h> as it no longer contains any internal code.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/sys/ipc.h (IPC_PRIVATE): Add cast to key_t.
	(IPC_INFO): New flag for ipcs(8).
	(IPC_RMID IPC_SET IPC_STAT): Renumber.
	* include/sys/shm.h (SHM_RDONLY SHM_RND): Renumber with distinct
	values [sic].
	(class _shmattach): Internal type moved to "cygserver_shm.h".
	(class shmnode): Ditto.
	(class shmid_ds): Ditto.
	(struct shmid_ds): Add spare fields.
	(struct shminfo): New type for IPC_INFO interface.
	* cygserver_shm.h: Remove obsolete #if 0 ... #endif block.
	(class shm_cleanup): Remove unused class.
	(struct _shmattach): Internal type moved from <sys/shm.h>.
	(struct shmnode): Ditto.
	(struct int_shmid_ds): Ditto. Renamed to avoid name clash with
	public interface struct shmid_ds. Use the shmid_bs structure as a
	field.
	* cygserver_shm.cc: Remove obsolete #if 0 ... #endif block.
	(client_request_shm::serve): Update for redefinition of
	int_shmid_ds structure.
	* shm.cc (build_inprocess_shmds): Ditto.
	(fixup_shms_after_fork): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove obsolete #if 0 ... #endif code.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(transport_layer_base::transport_layer_base): Remove since it is
	now redundant.
	(transport_layer_base::listen): Make a pure virtual method.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.
	* cygserver_transport.cc
	(transport_layer_base::transport_layer_base): Remove since it is
	now redundant.
	(transport_layer_base::listen): Remove since it is now a pure
	virtual method.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (check_and_dup_handle): Only use security code if
	running on NT, i.e. if wincap.has_security().
	(client_request_attach_tty::serve): Add check for has_security().
	* cygserver_process.cc (process_cache::process): Use DWORD winpid
	throughout to avoid win32 vs. cygwin pid confusion.
	(process::process): Ditto.
	* cygserver_shm.cc (client_request_shm::serve): Only use security
	code if running on NT, i.e. if wincap.has_security().
	* cygserver_shm.h (client_request_shm::parameters.in): Replace the
	ambiguous pid field with cygpid and winpid fields.
	(client_request_shm::client_request_shm): Reduce to only two
	client-side constructors: one for SHM_CREATE, another for all the
	other requests.
	* shm.cc (client_request_shm::client_request_shm):
	Ditto. Initialize cygpid and winpid fields here. On NT initialize
	sd_buf here using set_security_attribute() to make use of the euid
	and egid.
	(shmat): Use new client_request_shm constructor.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove security code, now performed in the
	relevant client_request_shm constructor.
	* include/cygwin/cygserver_process.h: (class cleanup_routine):
	Change winpid type to DWORD.
	(class process): Ditto.

2002-06-15  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h: New file.
	* cygserver.cc: Use "woutsup.h" and new XXX_printf macros.
	(getfunc): New function, copied verbatim from "strace.cc".
	(__cygserver__printf): New function.
	* cygserver_client.cc: Use "woutsup.h" and new XXX_printf macros.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* threaded_queue.cc: Ditto.
	* shm.cc: Remove trailing \n from XXX_printf format strings.
	* Makefile.in: Remove special __OUTSIDE_CYGWIN__ case for
	cygserver_shm.cc.
@
text
@d623 2
a624 2
  _parameters.in.uid = geteuid ();
  _parameters.in.gid = getegid ();
d647 2
a648 2
  _parameters.in.uid = geteuid ();
  _parameters.in.gid = getegid ();
d666 2
a667 2
  _parameters.in.uid = geteuid ();
  _parameters.in.gid = getegid ();
d689 2
a690 2
  _parameters.in.uid = geteuid ();
  _parameters.in.gid = getegid ();
@


1.15.16.1
log
@merge from trunk
@
text
@d623 2
a624 2
  _parameters.in.uid = geteuid32 ();
  _parameters.in.gid = getegid32 ();
d647 2
a648 2
  _parameters.in.uid = geteuid32 ();
  _parameters.in.gid = getegid32 ();
d666 2
a667 2
  _parameters.in.uid = geteuid32 ();
  _parameters.in.gid = getegid32 ();
d689 2
a690 2
  _parameters.in.uid = geteuid32 ();
  _parameters.in.gid = getegid32 ();
@


1.15.16.2
log
@merge from trunk
@
text
@d15 1
a15 1
#ifdef USE_CYGSERVER
d19 1
a693 1
#endif /* USE_CYGSERVER */
@


1.15.16.3
log
@merge from trunk
@
text
@d15 1
a15 1
#ifdef USE_SERVER
d693 1
a693 1
#endif /* USE_SERVER */
@


1.15.16.4
log
@merge from trunk
@
text
@d3 1
a3 1
   Copyright 2002,2003 Red Hat, Inc.
@


1.14
log
@	* cygwin_ipc.h: Move to "include/cygwin/ipc.h".
	* cygwin_shm.h: Move to "include/cygwin/shm.h".
	* include/cygwin/ipc.h: New file.
	* include/cygwin/shm.h: New file.
	* ipc.c:c Update <cygwin/ipc.h> include.
	* cygserver_shm.cc: Update <cygwin/shm.h> include.
	* shm.cc: Ditto.
@
text
@d1 1
a1 1
/* shm.cc: Single unix specification IPC interface for Cygwin
d3 1
a3 1
Copyright 2001, 2002 Red Hat, Inc.
d5 2
a6 1
Originally written by Robert Collins <robert.collins@@hotmail.com>
d15 4
a18 1
#include <sys/stat.h>
d20 3
d24 4
a27 9
#include <unistd.h>
#include "security.h"
#include "fhandler.h"
#include "path.h"
#include "dtable.h"
#include "cygheap.h"
#include <stdio.h>
#include "thread.h"
#include <cygwin/shm.h>
d30 65
a94 6
// FIXME IS THIS CORRECT
/* Implementation notes: We use two shared memory regions per key:
 * One for the control structure, and one for the shared memory.
 * While this has a higher overhead tham a single shared area,
 * It allows more flexability. As the entire code is transparent to the user
 * We can merge these in the future should it be needed.
d96 6
a101 11
extern "C" size_t
getsystemallocgranularity ()
{
  SYSTEM_INFO sysinfo;
  static size_t buffer_offset = 0;
  if (buffer_offset)
    return buffer_offset;
  GetSystemInfo (&sysinfo);
  buffer_offset = sysinfo.dwAllocationGranularity;
  return buffer_offset;
}
d103 2
a104 2
client_request_shm::client_request_shm (int ntype, int nshm_id):
client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
d106 2
a107 5
  buffer = (char *) &parameters;
  parameters.in.shm_id = nshm_id;
  parameters.in.type = SHM_REATTACH;
  parameters.in.pid = GetCurrentProcessId ();
}
d109 1
a109 8
client_request_shm::client_request_shm (int ntype, int nshm_id, pid_t npid):
client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
{
  buffer = (char *) &parameters;
  parameters.in.shm_id = nshm_id;
  parameters.in.type = ntype;
  parameters.in.pid = npid;
}
d111 1
a111 13
client_request_shm::client_request_shm (key_t nkey, size_t nsize,
						int nshmflg,
						char psdbuf[4096],
						pid_t npid):
client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
{
  buffer = (char *) &parameters;
  parameters.in.key = nkey;
  parameters.in.size = nsize;
  parameters.in.shmflg = nshmflg;
  parameters.in.type = SHM_CREATE;
  parameters.in.pid = npid;
  memcpy (parameters.in.sd_buf, psdbuf, 4096);
d114 3
a116 1
static shmnode *shm_head = NULL;
d118 4
a121 3
static shmnode *
build_inprocess_shmds (HANDLE hfilemap, HANDLE hattachmap, key_t key,
		       int shm_id)
d123 2
a124 12
  HANDLE filemap = hfilemap;
  void *mapptr = MapViewOfFile (filemap, FILE_MAP_WRITE, 0, 0, 0);

  if (!mapptr)
    {
      CloseHandle (hfilemap);
      CloseHandle (hattachmap);
      //FIXME: close filemap and free the mutex
      /* we couldn't access the mapped area with the requested permissions */
      set_errno (EACCES);
      return NULL;
    }
d126 1
a126 13
  /* Now get the user data */
  HANDLE attachmap = hattachmap;
  shmid_ds *shmtemp = new shmid_ds;
  if (!shmtemp)
    {
      system_printf ("failed to malloc shm node\n");
      set_errno (ENOMEM);
      UnmapViewOfFile (mapptr);
      CloseHandle (filemap);
      CloseHandle (attachmap);
      /* exit mutex */
      return NULL;
    }
d128 1
a128 2
  /* get the system node data */
  *shmtemp = *(shmid_ds *) mapptr;
d130 1
a130 2
  /* process local data */
  shmnode *tempnode = new shmnode;
d132 2
a133 3
  tempnode->filemap = filemap;
  tempnode->attachmap = attachmap;
  shmtemp->mapptr = mapptr;
d135 1
a135 7
  /* no need for InterlockedExchange here, we're serialised by the global mutex */
  tempnode->shmds = shmtemp;
  tempnode->shm_id = shm_id;
  tempnode->key = key;
  tempnode->next = shm_head;
  tempnode->attachhead = NULL;
  shm_head = tempnode;
d137 5
a141 1
  /* FIXME: leave the system wide shm mutex */
d143 1
a143 1
  return tempnode;
d146 8
a153 2
static void
delete_inprocess_shmds (shmnode **nodeptr)
d155 2
a156 1
  shmnode *node = *nodeptr;
d158 3
a160 22
  // remove from the list
  if (node == shm_head)
    shm_head = shm_head->next;
  else
    {
      shmnode *tempnode = shm_head;
      while (tempnode && tempnode->next != node)
	tempnode = tempnode->next;
      if (tempnode)
	tempnode->next = node->next;
      // else log the unexpected !
    }

  // release the shared data view
  UnmapViewOfFile (node->shmds);
  CloseHandle (node->filemap);
  CloseHandle (node->attachmap);

  // free the memory
  delete node;
  nodeptr = NULL;
}
d162 1
a162 5
int __stdcall
fixup_shms_after_fork ()
{
  shmnode *tempnode = shm_head;
  while (tempnode)
d164 2
a165 3
      void *newshmds =
	MapViewOfFile (tempnode->filemap, FILE_MAP_WRITE, 0, 0, 0);
      if (!newshmds)
d167 5
a171 4
	  /* don't worry about handle cleanup, we're dying! */
	  system_printf ("failed to reattach to shm control file view %x\n",
			 tempnode);
	  return 1;
d173 6
a178 4
      tempnode->shmds = (class shmid_ds *) newshmds;
      tempnode->shmds->mapptr = newshmds;
      _shmattach *attachnode = tempnode->attachhead;
      while (attachnode)
d180 5
a184 12
	  void *newdata = MapViewOfFileEx (tempnode->attachmap,
					   (attachnode->shmflg & SHM_RDONLY) ?
					   FILE_MAP_READ : FILE_MAP_WRITE, 0,
					   0, 0, attachnode->data);
	  if (newdata != attachnode->data)
	    {
	      /* don't worry about handle cleanup, we're dying! */
	      system_printf ("failed to reattach to mapped file view %x\n",
			     attachnode->data);
	      return 1;
	    }
	  attachnode = attachnode->next;
d186 1
a186 31
      tempnode = tempnode->next;
    }
  return 0;
}

/* this is ugly. Yes, I know that.
 * FIXME: abstract the lookup functionality,
 * So that it can be an array, list, whatever without us being worried
 */

/* FIXME: after fork, every memory area needs to have the attach count
 * incremented. This should be done in the server?
 */

/* FIXME: tell the daemon when we attach, so at process close it can clean up
 * the attach count
 */
extern "C" void *
shmat (int shmid, const void *shmaddr, int shmflg)
{
  shmnode *tempnode = shm_head;
  while (tempnode && tempnode->shm_id != shmid)
    tempnode = tempnode->next;

  if (!tempnode)
    {
      /* couldn't find a currently open shm control area for the key - probably because
       * shmget hasn't been called.
       * Allocate a new control block - this has to be handled by the daemon */
      client_request_shm *req =
	new client_request_shm (SHM_REATTACH, shmid, GetCurrentProcessId ());
d188 2
a189 2
      int rc;
      if ((rc = cygserver_request (req)))
d191 5
a195 3
	  delete req;
	  set_errno (ENOSYS);	/* daemon communication failed */
	  return (void *) -1;
d197 1
d199 2
a200 1
      if (req->header.error_code)	/* shm_get failed in the daemon */
d202 5
a206 3
	  set_errno (req->header.error_code);
	  delete req;
	  return (void *) -1;
d208 2
d211 1
a211 12
      /* we've got the id, now we open the memory area ourselves.
       * This tests security automagically
       * FIXME: make this a method of shmnode ?
       */
      tempnode =
	build_inprocess_shmds (req->parameters.out.filemap,
			       req->parameters.out.attachmap,
			       req->parameters.out.key,
			       req->parameters.out.shm_id);
      delete req;
      if (!tempnode)
	return (void *) -1;
d213 9
d224 3
a226 1
  // class shmid_ds *shm = tempnode->shmds;
d228 1
a228 1
  if (shmaddr)
d230 3
a232 4
      //FIXME: requested base address ?! (Don't forget to fix the fixup_after_fork too)
      set_errno (EINVAL);
      return (void *) -1;
    }
d234 3
a236 3
  void *rv = MapViewOfFile (tempnode->attachmap,
			    (shmflg & SHM_RDONLY) ? FILE_MAP_READ :
			    FILE_MAP_WRITE, 0, 0, 0);
d238 9
a246 5
  if (!rv)
    {
      //FIXME: translate GetLastError()
      set_errno (EACCES);
      return (void *) -1;
a247 9
  /* tell the daemon we have attached */
  client_request_shm *req =
    new client_request_shm (SHM_ATTACH, shmid);
  int rc;
  if ((rc = cygserver_request (req)))
    {
      debug_printf ("failed to tell deaemon that we have attached\n");
    }
  delete req;
d249 2
a250 6
  _shmattach *attachnode = new _shmattach;
  attachnode->data = rv;
  attachnode->shmflg = shmflg;
  attachnode->next =
    (_shmattach *) InterlockedExchangePointer (&tempnode->attachhead,
					       attachnode);
d252 2
d255 8
a262 2
  return rv;
}
d264 2
a265 4
/* FIXME: tell the daemon when we detach so it doesn't cleanup incorrectly.
 */
extern "C" int
shmdt (const void *shmaddr)
d267 9
a275 16
  /* this should be "rare" so a hefty search is ok. If this is common, then we
   * should alter the data structs to allow more optimisation
   */
  shmnode *tempnode = shm_head;
  _shmattach *attachnode;
  while (tempnode)
    {
      // FIXME: Race potential
      attachnode = tempnode->attachhead;
      while (attachnode && attachnode->data != shmaddr)
	attachnode = attachnode->next;
      if (attachnode)
	break;
      tempnode = tempnode->next;
    }
  if (!tempnode)
d277 2
a278 1
      // dt cannot be called by an app that hasn't alreadu at'd
d283 35
a317 10
  UnmapViewOfFile (attachnode->data);
  /* tell the daemon we have attached */
  client_request_shm *req =
      new client_request_shm (SHM_DETACH, tempnode->shm_id);
  int rc;
  if ((rc = cygserver_request (req)))
    {
      debug_printf ("failed to tell deaemon that we have detached\n");
    }
  delete req;
d322 6
a327 3
//FIXME: who is allowed to perform STAT?
extern "C" int
shmctl (int shmid, int cmd, struct shmid_ds *buf)
d329 4
a332 10
  shmnode *tempnode = shm_head;
  while (tempnode && tempnode->shm_id != shmid)
    tempnode = tempnode->next;
  if (!tempnode)
    {
      /* couldn't find a currently open shm control area for the key - probably because
       * shmget hasn't been called.
       * Allocate a new control block - this has to be handled by the daemon */
      client_request_shm *req =
	new client_request_shm (SHM_REATTACH, shmid, GetCurrentProcessId ());
d334 13
a346 7
      int rc;
      if ((rc = cygserver_request (req)))
	{
	  delete req;
	  set_errno (ENOSYS);	/* daemon communication failed */
	  return -1;
	}
d348 2
a349 6
      if (req->header.error_code)	/* shm_get failed in the daemon */
	{
	  set_errno (req->header.error_code);
	  delete req;
	  return -1;
	}
d351 18
a368 13
      /* we've got the id, now we open the memory area ourselves.
       * This tests security automagically
       * FIXME: make this a method of shmnode ?
       */
      tempnode =
	build_inprocess_shmds (req->parameters.out.filemap,
			       req->parameters.out.attachmap,
			       req->parameters.out.key,
			       req->parameters.out.shm_id);
      delete req;
      if (!tempnode)
	return -1;
    }
d370 1
a370 13
  switch (cmd)
    {
    case IPC_STAT:
      buf->shm_perm = tempnode->shmds->shm_perm;
      buf->shm_segsz = tempnode->shmds->shm_segsz;
      buf->shm_lpid = tempnode->shmds->shm_lpid;
      buf->shm_cpid = tempnode->shmds->shm_cpid;
      buf->shm_nattch = tempnode->shmds->shm_nattch;
      buf->shm_atime = tempnode->shmds->shm_atime;
      buf->shm_dtime = tempnode->shmds->shm_dtime;
      buf->shm_ctime = tempnode->shmds->shm_ctime;
      break;
    case IPC_RMID:
d372 6
a377 30
	/* TODO: check permissions. Or possibly, the daemon gets to be the only
	 * one with write access to the memory area?
	 */
	if (tempnode->shmds->shm_nattch)
	  system_printf
	    ("call to shmctl with cmd= IPC_RMID when memory area still has"
	     " attachees\n");
	/* how does this work?
	   * we mark the ds area as "deleted", and the at and get calls all fail from now on
	   * on, when nattch becomes 0, the mapped data area is destroyed.
	   * and each process, as they touch this area detaches. eventually only the
	   * daemon has an attach. The daemon gets asked to detach immediately.
	 */
	//waiting for the daemon to handle terminating process's
	client_request_shm *req =
	  new client_request_shm (SHM_DEL, shmid, GetCurrentProcessId ());
	int rc;
	if ((rc = cygserver_request (req)))
	  {
	    delete req;
	    set_errno (ENOSYS);	/* daemon communication failed */
	    return -1;
	  }

	if (req->header.error_code)	/* shm_del failed in the daemon */
	  {
	    set_errno (req->header.error_code);
	    delete req;
	    return -1;
	  }
d379 10
a388 2
	/* the daemon has deleted it's references */
	/* now for us */
d390 2
a391 2
	// FIXME: create a destructor
	delete_inprocess_shmds (&tempnode);
a392 7
      }
      break;
    case IPC_SET:
    default:
      set_errno (EINVAL);
      return -1;
    }
d396 8
a403 4
/* FIXME: evaluate getuid32() and getgid32() against the requested mode. Then
 * choose PAGE_READWRITE | PAGE_READONLY and FILE_MAP_WRITE  |  FILE_MAP_READ
 * appropriately
 */
d405 3
a407 2
/* FIXME: shmid should be a verifyable object
 */
d409 1
a409 4
/* FIXME: on NT we should check everything against the SD. On 95 we just emulate.
 */
extern "C" int
shmget (key_t key, size_t size, int shmflg)
d411 53
a463 8
  DWORD sd_size = 4096;
  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;
  /* create a sd for our open requests based on shmflag & 0x01ff */
  InitializeSecurityDescriptor (psd,
				    SECURITY_DESCRIPTOR_REVISION);
  psd = alloc_sd (getuid32 (), getgid32 (),
		  shmflg & 0x01ff, psd, &sd_size);
d465 11
a475 1
  if (key == (key_t) - 1)
d477 6
a482 2
      set_errno (ENOENT);
      return -1;
d485 1
a485 8
  /* FIXME: enter the checking for existing keys mutex. This mutex _must_ be system wide
   * to prevent races on shmget.
   */

  /* walk the list of currently open keys and return the id if found
   */
  shmnode *tempnode = shm_head;
  while (tempnode)
d487 14
a500 21
      if (tempnode->key == key && key != IPC_PRIVATE)
	{
	  // FIXME: free the mutex
	  if (size && tempnode->shmds->shm_segsz < size)
	    {
	      set_errno (EINVAL);
	      return -1;
	    }
	  if ((shmflg & IPC_CREAT) && (shmflg & IPC_EXCL))
	    {
	      set_errno (EEXIST);
	      // FIXME: free the mutex
	      return -1;
	    }
	  // FIXME: do we need to other tests of the requested mode with the
	  // tempnode->shmid mode ? testcase on unix needed.
	  // FIXME do we need a security test? We are only examining the keys we already have open.
	  // FIXME: what are the sec implications for fork () if we don't check here?
	  return tempnode->shm_id;
	}
      tempnode = tempnode->next;
a501 5
  /* couldn't find a currently open shm control area for the key.
   * Allocate a new control block - this has to be handled by the daemon */
  client_request_shm *req =
    new client_request_shm (key, size, shmflg, sd_buf,
				GetCurrentProcessId ());
d503 36
a538 2
  int rc;
  if ((rc = cygserver_request (req)))
d540 2
a541 3
      delete req;
      set_errno (ENOSYS);	/* daemon communication failed */
      return -1;
d543 1
a543 2

  if (req->header.error_code)	/* shm_get failed in the daemon */
d545 2
a546 3
      set_errno (req->header.error_code);
      delete req;
      return -1;
d549 142
a690 31
  /* we've got the id, now we open the memory area ourselves.
   * This tests security automagically
   * FIXME: make this a method of shmnode ?
   */
  shmnode *shmtemp = build_inprocess_shmds (req->parameters.out.filemap,
					    req->parameters.out.attachmap,
					    key,
					    req->parameters.out.shm_id);
  delete req;
  if (shmtemp)
    return shmtemp->shm_id;
  return -1;


#if 0
  /* fill out the node data */
  shmtemp->shm_perm.cuid = getuid32 ();
  shmtemp->shm_perm.uid = shmtemp->shm_perm.cuid;
  shmtemp->shm_perm.cgid = getgid32 ();
  shmtemp->shm_perm.gid = shmtemp->shm_perm.cgid;
  shmtemp->shm_perm.mode = shmflg & 0x01ff;
  shmtemp->shm_lpid = 0;
  shmtemp->shm_nattch = 0;
  shmtemp->shm_atime = 0;
  shmtemp->shm_dtime = 0;
  shmtemp->shm_ctime = time (NULL);
  shmtemp->shm_segsz = size;
  *(shmid_ds *) mapptr = *shmtemp;
  shmtemp->filemap = filemap;
  shmtemp->attachmap = attachmap;
  shmtemp->mapptr = mapptr;
d692 1
a692 1
#endif
@


1.13
log
@Use cygwin_{shm,ipc}.h instead of /sys/{shm,ipc}.h throughout.
* sys/ipc.h: Remove.
* sys/shm.h: Remove.
* cygwin_ipc.h: New file.
* cygwin_shm.h: New file.
@
text
@d25 1
a25 1
#include "cygwin_shm.h"
@


1.12
log
@	* sec_helper.cc (lookup_name): Suppress.
	* security.cc (alloc_sd): Remove logsrv argument.
	Remove two calls to lookup_name.
	(set_security_attribute): Remove logsrv argument.
	Remove logsrv argument in call to alloc_sd.
	(set_nt_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_security_attribute.
	(set_file_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_nt_attribute.
	(set_file_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_file_attribute.
	* syscalls.cc (chown_worker): Remove logserver argument in
	call to set_file_attribute.
	(chmod): Ditto.
	* shm.cc (shmget): Remove logsrv argument in call to alloc_sd.
	* uinfo.cc (internal_getlogin): Replace calls to
	lookup_name by call to LookupAccountName.
	* security.h: Remove logsrv in declarations of set_file_attribute
	and alloc_sd. Remove declaration of lookup_name.
@
text
@d25 1
a25 1
#include <sys/shm.h>
@


1.11
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d464 1
a464 1
  psd = alloc_sd (getuid32 (), getgid32 (), cygheap->user.logsrv (),
@


1.10
log
@	Change internal uid datatype from __uid16_t to __uid32_t
	throughout.
	* cygwin.din: Export new symbols getpwuid32, getpwuid_r32, getuid32,
	geteuid32, setuid32, seteuid32.
	* passwd.cc (getpwuid32): New function.
	(getpwuid_r32): Ditto.
	* syscalls.cc (seteuid32): Ditto.
	(setuid32): Ditto.
	* uinfo.cc (getuid32): Ditto.
	(geteuid32): Ditto.
	* winsup.h (uid16touid32): New macro, correclt casting from __uid16_t
	to __uid32_t.
	(gid16togid32): Ditto fir gids.
	(getuid32): Declare.
	(geteuid32): Ditto.
	(getpwuid32): Ditto.
	* include/sys/cygwin.h (struct external_pinfo): Add members uid32 and
	gid32.
@
text
@d3 1
a3 1
Copyright 2001 Red Hat, Inc.
@


1.9
log
@	Change internal gid datatype from __gid16_t to __gid32_t
	throughout.
	* cygwin.din: Export new symbols chown32, fchown32, getegid32,
	getgid32, getgrgid32, getgrnam32, getgroups32, initgroups32, lchown32,
	setgid32, setegid32, getgrent32.
	* grp.cc (grp32togrp16): New static function.
	(getgrgid32): New function.
	(getgrnam32): Ditto.
	(getgrent32): Ditto.
	(getgroups32): Change name of internal function from getgroups.
	(getgroups32): New function.
	(initgroups32): Ditto.
	* syscalls.cc (chown32): Ditto.
	(lchown32): Ditto.
	(fchown32): Ditto.
	(setegid32): Ditto.
	(setgid32): Ditto.
	* uinfo.cc (getgid32): Ditto.
	(getegid32): Ditto.
	* include/cygwin/grp.h: Remove declaration of getgrgid() and getgrnam().
	Declare getgrgid32() and getgrnam32() instead.  Declare getgid32().
@
text
@d445 1
a445 1
/* FIXME: evaluate getuid() and getgid32() against the requested mode. Then
d464 1
a464 1
  psd = alloc_sd (getuid (), getgid32 (), cygheap->user.logsrv (),
d541 1
a541 1
  shmtemp->shm_perm.cuid = getuid ();
@


1.8
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d445 1
a445 1
/* FIXME: evaluate getuid() and getgid() against the requested mode. Then
d464 1
a464 1
  psd = alloc_sd (getuid (), getgid (), cygheap->user.logsrv (),
d543 1
a543 1
  shmtemp->shm_perm.cgid = getgid ();
@


1.7
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d3 1
a3 1
   Copyright 2001 Red Hat, Inc.
d5 1
a5 1
   Originally written by Robert Collins <robert.collins@@hotmail.com>
d7 1
a7 1
   This file is part of Cygwin.
d9 3
a11 3
   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */
d66 3
a68 3
                                                int nshmflg,
                                                char psdbuf[4096],
                                                pid_t npid):
d148 1
a148 1
        tempnode = tempnode->next;
d153 1
a153 1
  
d224 1
a224 1
       * shmget hasn't been called. 
d336 1
a336 1
  
d340 1
a340 1
//FIXME: who is allowed to perform STAT? 
d398 1
a398 1
	/* TODO: check permissions. Or possibly, the daemon gets to be the only 
d405 1
a405 1
	/* how does this work? 
d408 1
a408 1
	   * and each process, as they touch this area detaches. eventually only the 
d434 1
a434 1
	
d463 1
a463 1
                                    SECURITY_DESCRIPTOR_REVISION);
@


1.6
log
@2002-03-05  Robert Collins  <rbtcollins@@hotmail.com>

        * cygserver_transport_pipes.cc (transport_layer_pipes::transport_layer_pipes):
        Always init - until static members work correctly.
        * shm.cc (shmget): Initialize the security descriptor - thanks Corinna!
        * include/sys/ipc.h: Make the ipc control constants partitioned off from the sem
        control constants.
@
text
@a25 1
#include "perprocess.h"
@


1.5
log
@2002-03-04  Robert Collins  <rbtcollins@@hotmail.com>

        * cygserver_shm.cc (client_request_shm::serve): Implement SHM_DETACH.
        * shm.cc (shmdt): Implement.
@
text
@d463 2
@


1.4
log
@2002-03-04  Robert Collins  <rbtcollins@@hotmail.com>

        * cygserver_shm.cc: Run indent.
        (deleted_head): New global for storing shm id's pending deletion.
        (client_request_shm::serve): Return ENOSYS for invalid request types.
        Implement SHM_DEL - delete a shm id.
        * cygserver_shm.h (SHM_DEL): New type value.
        * shm.cc (delete_inprocess_shmds): New function, does what it's name implies.
        (shmctl): Implement shm_rmid control type.
@
text
@d308 31
a338 2
  set_errno (ENOTSUP);
  return -1;
@


1.3
log
@2002-03-03  Robert Collins  <rbtcollins@@hotmail.com>

        * shm.cc (shmat): Prevent a compile error.
        (shmdt): Set errno as this function is incomplete.
@
text
@d137 28
d383 1
a383 2
#if 0
//waiting for the daemon to handle terminating process's
d403 3
a406 2
#endif	

@


1.2
log
@2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* Merged cygwin_daemon into head minus the new shm and ipc exports.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* fhandler_tty.cc (fhandler_tty_slave::open): More debugging.
	(fhandler_tty_slave::read): Fix printf type for the handle.
	* tty.cc (tty::common_init): Add a FIXME for security.

2002-01-29  Robert Collins  <rbtcollins@@hotmail.com>

	* Makefile.in (OBJS): Remove duplicate localtime.o.

2002-01-17  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (check_and_dup_handle): Consolidate the two variants for
	simplicity.
	Add Some basic debug output.
	(client_request_attach_tty::serve): Use the new debug_printf for clarity.
	Mark the duplicated handles as inheritable - fixup_after_fork() doesn't reopen
	tty's.

2002-01-16  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (transport): Correct scope.
	(client_request_attach_tty::serve): Add more debug information.
	Fix erroneous use of transport instead of conn.
	* cygserver_transport_pipes.cc (transport_layer_pipes::close): More debug.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.

Mon Oct  8  7:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (server_request::process): Rename client_request_shm_get to
	client_request_shm.
	* cygserver_process.cc (process_cache::add): Rename to add_task.
	Use process_cleanup instead of process_request.
	(process_cache::remove_process): New method.
	(process::process): Initialize new members.
	(process::~process): New member.
	(process::cleanup): New method.
	(process::add_cleanup_routine): New method.
	(process_request::process): Rename to process_cleanup.
	Call the process object's cleanup method and then delete it.
	(process_process_param::request_loop): Remove the signalling process.
	* cygserver_shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm_get::serve): Handle attach request counting.
	* cygserver_shm.h: Globally rename client_request_shm_get to client_request_shm.
	(class shm_cleanup): New class.
	* shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm::client_request_shm): New constructor for attach requests.
	(shmat): Use it.
	* include/cygwin/cygserver_process.h (class process_request): Rename to
	process_cleanup.
	(class cleanup_routine): New class.
	(class process): New members and methods to allow calling back when the process
	terminates.

Thu Oct  4 14:12:00 2001  Robert Collins <rbtcollins@@hotmail.com>
	* cygserver.cc (request_loop): Make static.
	(main): Use new cache constructor syntax.
	Start cache worker threads.
	Cleanup the cache at shutdown.
	* cygserver_process.cc: Run indent.
	(process_cache::process_cache): Add a trigger to use when adding a process.
	(process_cache::process): Move process_entry to process.
	Insert at the end of the list.
	Trigger the request loop when new process's inserted.
	(process_cache::process_requests): Do it.
	(process_cache::add): New method.
	(process_cache::handle_snapshot): New method.
	(process::process): Merge in the process_entry fields.
	(process::handle): Make a stub function.
	(process::exit_code): New method.
	(process_request::process): New method.
	(process_process_param::request_loop): New method.
	* cygserver_shm.cc: New header dependency - threaded_queue.h.
	* threaded_queue.cc (threaded_queue::cleanup): Clearer messages.
	(queue_process_param::stop): Short spinlock on interruptible threads.
	* threaded_queue.h (class threaded_queue): New constructor.
	* include/cygwin/cygserver_process.h (process_request): New class.
	(process_entry): Remove.
	(process): Merge in process_entry.
	(process_cache): Inherit from threaded_queue.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (class server_process_param): Use new constructor syntax.
	* cygserver_process.cc (process_cache::~process_cache): New function.
	* threaded_queue.cc: Define condition debug_printf.
	Run indent.
	(threaded_queue::cleanup): Move queue_process_param guts to a method.
	(threaded_queue::process_requests): Ditto.
	(queue_process_param::queue_process_param): New method.
	(queue_process_param::~queue_process_param): Ditto.
	(queue_process_param::start): Ditto.
	(queue_process_param::stop): Ditto.
	* threaded_queue.h (class queue_process_param): Add support for
	interruptible request loops.
	* cygwin/include/cygwin/cygserver_process.h (class process_cache): Add
	destructor.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver_client.cc: New flag allow_daemon to disable the daemon completely.
	(cygserver_request): Check it.
	(cygserver_init): Ditto.
	* environ.cc (parse_thing): Add (no)daemon option.

Tue Oct  2 23:00:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* shm.cc: Update to handle include changes from HEAD.

Tue Oct  2 16:06:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Remove cygserver_shm.o from cygwin1.dll.
	Rename cygserver_shm_outside.o to cygserver_shm.o.
	* cygserver.cc (server_request::process): Use the new client_request
	constructor.
	* cygserver_client.cc: Remove the #ifdef's stubs for the server method
	within cygwin.
	(client_request_attach_tty::client_request_attach_tty): Use the new
	client_request constructor.
	(client_request_shutdown::client_request_shutdown): Ditto.
	(client_request::client_request): Ditto.
	* cygserver_shm.cc (client_request_shm_get::serve): Remove the
	#ifdef'd stub for in-cygwin builds.
	(client_request_shm_get::client_request_shm_get): Use the new
	client_request constructor, and remove the in-cygwin variants.
	* cygserver_shm.h (class client_request_shm_get): #ifndef test the
	serve method - it's only used in cygserver.
	* shm.cc (client_request_shm_get::client_request_shm_get): New function.
	* include/cygwin/cygserver.h (request_header): New constructor.
	(class client_request): Use it.
	New constructor accepting the header size.
	#ifndef test the server method - it's only used within cygserver.
	(client_request_get_version): #ifdef test the server method.
	(client_request_shutdown): Ditto.
	(client_request_attach_tty): Ditto.

Tue Oct  2  9:57:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: add threaded_queue.o to cygserver.exe.
	* cygserver.cc: Include threaded_queue.h
	(class server_request): Inherit from queue_request.
	(class server_process_param): Inherit from queue_process_param.
	(class server_request_queue): Inherit from threaded_queue.
	(request_loop): Adjust for new types.
	(server_request_queue::process_requests): Remove guts to
	threaded_queue::process_requests.
	(server_request::server_request): Adjust for new types.
	(worker_function): Delete.
	(server_request_queue::create_workers): Delete.
	(server_request_queue::cleanup): Delete.
	(server_request_queue::add): Move guts to threaded_queue::add.
	* threaded_queue.cc: New file.
	* threaded_queue.h: New file.

Mon Oct  1 12:38:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (client_request::serve): New function.
	* cygserver_process.cc: Inlude <pthread.h> for pthread_once.
	(process_cache::process_cache): Initialise a crtiical section for write access.
	(process_cache::process): Use the critical section. Also add missing entries to
	the cache.
	(do_process_init): New function to initalise class process static variables.
	(process::process): Ensure that the process access critical section is
	initialised.
	(process::handle): Close the handle of old process's when they have terminated
	and we are returning the handle for a process with the same pid.
	* cygserver_shm.cc: Run indent.
	Include cygserver_process.h to allow process cache functionality.
	(client_request_shm_get::serve): New parameter for process cache support.
	Use the process cache, not OpenProcess to get a handle to the originating process.
	Fix a handle leak with token_handle.
	* cygserver_shm.h (class client_request_shm_get): Update ::serve for process
	cache support.
	* cygserver_transport_pipes.cc: Redefine debug_printf to be conditional on DEBUG.
	* include/cygwin/cygserver.h: Do not implement client_request::serve in the
	header.
	* include/cygwin/cygserver_process.h (class process_cache): Add a write access
	critical section to prevent races when requests from a  multithreaded
	application arrive.

Sun Sep 30 23:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_process.o to cygserver.exe.
	* cygserver.cc: Include signal.h and cygwin_version.h.
	Define debug_printf as a macro.
	Define DEBUG to a value.
	(client_request_attach_tty::serve): Add beginning of process cache support.
	Change from #ifdef DEBUG to work with new DEBUG style.
	(client_request_get_version::serve): Add beginning of process cache support.
	(class server_request): New prototype for support of process cache.
	(class queue_process_param): New class to allow request loop threading.
	(class server_request_queue): Add beginning of process cache support.
	Allow request loop threading.
	(request_loop): Thread function for request loops.
	(server_request_queue::process_requests): Initiator for threaded request loops.
	(client_request_shutdown::serve): Add beginning of process cache support.
	(server_request::server_request): Ditto.
	(server_request::process): Use debug_printf. Add beginning of process cache
	support.
	(server_request_queue::cleanup): Kill off any request loop threads.
	(server_request_queue::add): Add beginning of process cache support.
	(handle_signal): Trigger a shutdown.
	(main): Print out some useful info at startup - version, date time.
	Add process cache support.
	Spawn a separate thread for the transport request loop, thus allowing concurrent
	support for multiple transports.
	* cygserver_client.cc (client_request_get_version::serve): Add process cache
	support.
	(client_request_attach_tty::serve): Add process cache support.
	(client_request_shutdown::serve): Add process cache support.
	* cygsserver_process.cc: New file with the process cache support.
	* cygserver_shm.cc: Redefine debug_printf to allow conditional output.
	* cygwin.din: Export shmdt().
	* shm.cc: Run indent.
	Update FIXME's.
	(shmdt): New function.
	* include/cygwin/cygserver.h (class client_request): Add process cache support.
	(class client_request_get_version): Ditto.
	(class client_request_shutdown): Ditto.
	(class client_request_attach_tty): Ditto.
	* include/cygwin/cygserver_process.h: New header for process cache support.

Sun Sep 30  8:52:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* include/cygwin/cygserver_transport.h: Add copyright header.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.

Sat Sep 29 20:40:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_transport_sockets.o to DLL_OFILES.
	Add cygserver_transport_sockets_outside.o to cygserver.exe.
	* cygserver.cc: Include new include files.
	* cygserver_client.cc: Ditto.
	* cygserver_shm.h: No need to include <sys/socket.h> now.
	* cygerver_transport.cc: Include new include files.
	(transport_layer_base::transport_layer_base): Strip back to a stub.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.
	* cygserver_transport_pipes.cc: Include new header
	"cygwin/cygserver_transport_pipes.h".
	* cygserver_transport_sockets.cc: New file.
	* dcrt0.cc: No need to include <sys/socket.h> now.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.
	* include/cygwin/cygserver_transport.h: Strip the base class to a stub.
	Remove the cygserver_transport_pipes class.
	* include/cygwin/cygserver_transport_pipes.h: New file.
	* include/cygwin/cygserver_transport_sockets.h: New file.

Tue Sep 25 16:22:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* autoload.cc: Add dynamic load statement for 'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when obtaining
	handles from the parent process. On failure or 9x use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
	* cygserver.cc: New file.
	* cygserver_client.cc: New file.
	* cygserver_shm.cc: New file.
	* cygserver_shm.h: New file.
	* cygserver_transport.cc: New file.
	* cygserver_transport_pipes.cc: New file.
	* ipc.cc: New file.
	* shm.cc: New file.
	* include/cygwin/cygserver.h: New file.
	* include/cygwin/cygserver_transport.h: New file.
	* include/sys/ipc.h: New file.
	* include/sys/shm.h: New file.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* thread.cc (semaphore::TryWait): Set errno as required by posix 1003.1.
	(__sem_wait): Ditto.
	(__sem_trywait): Ditto.
@
text
@d232 1
a232 1
  class shmid_ds *shm = tempnode->shmds;
d280 2
a281 1
  
@


1.1
log
@file shm.cc was initially added on branch cygwin_daemon.
@
text
@d1 499
@


1.1.2.1
log
@Tue Sep 25 16:22:00 2001 Robert Collins <rbtcollins@@hotmail.com>

        * autoload.cc: Add dynamic load statement for
	'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build
	instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when
	obtaining handles from the parent process. On failure or 9x
	use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
										CVS: ----------------------------------------------------------------------
@
text
@a0 446
/* shm.cc: Single unix specification IPC interface for Cygwin

   Copyright 2001 Red Hat, Inc.

   Originally written by Robert Collins <robert.collins@@hotmail.com>

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */

#include "winsup.h"
#include <sys/stat.h>
#include <errno.h>
#include "cygerrno.h"
#include <unistd.h>
#include "security.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include <stdio.h>
#include "thread.h"
#include <sys/shm.h>
#include "perprocess.h"
#include "cygserver_shm.h"

// FIXME IS THIS CORRECT
/* Implementation notes: We use two shared memory regions per key:
 * One for the control structure, and one for the shared memory.
 * While this has a higher overhead tham a single shared area,
 * It allows more flexability. As the entire code is transparent to the user
 * We can merge these in the future should it be needed.
 */
extern "C" size_t
getsystemallocgranularity ()
{
  SYSTEM_INFO sysinfo;
  static size_t buffer_offset = 0;
  if (buffer_offset)
    return buffer_offset;
  GetSystemInfo (&sysinfo);
  buffer_offset = sysinfo.dwAllocationGranularity;
  return buffer_offset;
}

static shmnode *shm_head = NULL;

static shmnode *
build_inprocess_shmds (HANDLE hfilemap, HANDLE hattachmap, key_t key,
		       int shm_id)
{
  HANDLE filemap = hfilemap;
  void *mapptr = MapViewOfFile (filemap, FILE_MAP_WRITE, 0, 0, 0);

  if (!mapptr)
    {
      CloseHandle (hfilemap);
      CloseHandle (hattachmap);
      //FIXME: close filemap and free the mutex
      /* we couldn't access the mapped area with the requested permissions */
      set_errno (EACCES);
      return NULL;
    }

  /* Now get the user data */
  HANDLE attachmap = hattachmap;
  shmid_ds *shmtemp = new shmid_ds;
  if (!shmtemp)
    {
      system_printf ("failed to malloc shm node\n");
      set_errno (ENOMEM);
      UnmapViewOfFile (mapptr);
      CloseHandle (filemap);
      CloseHandle (attachmap);
      /* exit mutex */
      return NULL;
    }

  /* get the system node data */
  *shmtemp = *(shmid_ds *) mapptr;

  /* process local data */
  shmnode *tempnode = new shmnode;

  tempnode->filemap = filemap;
  tempnode->attachmap = attachmap;
  shmtemp->mapptr = mapptr;

  /* no need for InterlockedExchange here, we're serialised by the global mutex */
  tempnode->shmds = shmtemp;
  tempnode->shm_id = shm_id;
  tempnode->key = key;
  tempnode->next = shm_head;
  tempnode->attachhead = NULL;
  shm_head = tempnode;

  /* FIXME: leave the system wide shm mutex */

  return tempnode;
}

int __stdcall
fixup_shms_after_fork ()
{
  shmnode *tempnode = shm_head;
  while (tempnode)
    {
      void *newshmds =
	MapViewOfFile (tempnode->filemap, FILE_MAP_WRITE, 0, 0, 0);
      if (!newshmds)
	{
	  /* don't worry about handle cleanup, we're dying! */
	  system_printf("failed to reattach to shm control file view %x\n",tempnode);
	  return 1;
	}
      tempnode->shmds = (class shmid_ds *) newshmds;
      tempnode->shmds->mapptr = newshmds;
      _shmattach *attachnode = tempnode->attachhead;
      while (attachnode)
	{
	  void *newdata = MapViewOfFileEx (tempnode->attachmap,
					   (attachnode->shmflg & SHM_RDONLY) ?
					   FILE_MAP_READ : FILE_MAP_WRITE, 0,
					   0, 0, attachnode->data);
	  if (newdata != attachnode->data)
	    {
	      /* don't worry about handle cleanup, we're dying! */
		system_printf("failed to reattach to mapped file view %x\n",attachnode->data);
	      return 1;
	    }
	  attachnode = attachnode->next;
	}
      tempnode = tempnode->next;
    }
  return 0;
}

/* this is ugly. Yes, I know that.
 * FIXME: abstract the lookup functionality,
 * So that it can be an array, list, whatever without us being worried
 */

/* FIXME: after fork, every memory area needs to have the attach count
 * incremented and the mappings potentially reestablished, perhaps allowing
 * inherit will work?!?
 */

/* FIXME: are inherited mapped IPC_PRIVATE id's shared between process's
 * YES from linux.
 */

extern "C" void *
shmat (int shmid, const void *shmaddr, int shmflg)
{
  shmnode *tempnode = shm_head;
  while (tempnode && tempnode->shm_id != shmid)
    tempnode = tempnode->next;

  if (!tempnode)
    {
      /* couldn't find a currently open shm control area for the key - probably because
       * shmget hasn't been called. 
       * Allocate a new control block - this has to be handled by the daemon */
      client_request_shm_get *req =
	new client_request_shm_get (shmid, GetCurrentProcessId ());

      int rc;
      if ((rc = cygserver_request (req)))
	{
	  delete req;
	  set_errno (ENOSYS);	/* daemon communication failed */
	  return (void *) -1;
	}

      if (req->header.error_code)	/* shm_get failed in the daemon */
	{
	  set_errno (req->header.error_code);
	  delete req;
	  return (void *) -1;
	}

      /* we've got the id, now we open the memory area ourselves.
       * This tests security automagically
       * FIXME: make this a method of shmnode ?
       */
      tempnode =
	build_inprocess_shmds (req->parameters.out.filemap,
			       req->parameters.out.attachmap,
			       req->parameters.out.key,
			       req->parameters.out.shm_id);
      delete req;
      if (!tempnode)
	return (void *) -1;

    }

  class shmid_ds *shm = tempnode->shmds;

  if (shmaddr)
    {
      //FIXME: requested base address ?! (Don't forget to fix the fixup_after_fork too)
      set_errno (EINVAL);
      return (void *) -1;
    }

  void *rv = MapViewOfFile (tempnode->attachmap,
			    (shmflg & SHM_RDONLY) ? FILE_MAP_READ :
			    FILE_MAP_WRITE, 0, 0, 0);

  if (!rv)
    {
      //FIXME: translate GetLastError()
      set_errno (EACCES);
      return (void *) -1;
    }

  InterlockedIncrement (&shm->shm_nattch);
  _shmattach *attachnode = new _shmattach;

  attachnode->data = rv;
  attachnode->shmflg = shmflg;
  attachnode->next =
    (_shmattach *) InterlockedExchangePointer (&tempnode->attachhead, attachnode);


  return rv;
}

//FIXME: who is allowed to perform STAT? 
extern "C" int
shmctl (int shmid, int cmd, struct shmid_ds *buf)
{
  shmnode *tempnode = shm_head;
  while (tempnode && tempnode->shm_id != shmid)
    tempnode = tempnode->next;
  if (!tempnode)
  {
    /* couldn't find a currently open shm control area for the key - probably because
     * shmget hasn't been called.
     * Allocate a new control block - this has to be handled by the daemon */
    client_request_shm_get *req =
      new client_request_shm_get (shmid, GetCurrentProcessId ());

    int rc;
    if ((rc = cygserver_request (req)))
      {
        delete req;
        set_errno (ENOSYS);   /* daemon communication failed */
        return -1;
      }

    if (req->header.error_code)       /* shm_get failed in the daemon */
      {
        set_errno (req->header.error_code);
        delete req;
        return -1;
      }

    /* we've got the id, now we open the memory area ourselves.
     * This tests security automagically
     * FIXME: make this a method of shmnode ?
     */
    tempnode =
      build_inprocess_shmds (req->parameters.out.filemap,
                             req->parameters.out.attachmap,
                             req->parameters.out.key,
                             req->parameters.out.shm_id);
    delete req;
    if (!tempnode)
      return -1;
  }
  
  switch (cmd)
    {
    case IPC_STAT:
      buf->shm_perm = tempnode->shmds->shm_perm; 
      buf->shm_segsz = tempnode->shmds->shm_segsz;
      buf->shm_lpid = tempnode->shmds->shm_lpid;
      buf->shm_cpid = tempnode->shmds->shm_cpid;
      buf->shm_nattch = tempnode->shmds->shm_nattch;
      buf->shm_atime = tempnode->shmds->shm_atime;
      buf->shm_dtime = tempnode->shmds->shm_dtime;
      buf->shm_ctime = tempnode->shmds->shm_ctime;
      break;
    case IPC_RMID:
      {
      /* TODO: check permissions. Or possibly, the daemon gets to be the only 
       * one with write access to the memory area?
       */
      if (tempnode->shmds->shm_nattch)
	system_printf ("call to shmctl with cmd= IPC_RMID when memory area still has"
			" attachees\n");
      /* how does this work? 
	* we mark the ds area as "deleted", and the at and get calls all fail from now on
	* on, when nattch becomes 0, the mapped data area is destroyed.
        * and each process, as they touch this area detaches. eventually only the 
 	* daemon has an attach. The daemon gets asked to detach immediately.
	*/
#if 0
      client_request_shm_get *req =
	  new client_request_shm_get (SHM_DEL, shmid, GetCurrentProcessId ());
    int rc;
    if ((rc = cygserver_request (req)))
      {
        delete req;
        set_errno (ENOSYS);   /* daemon communication failed */
        return -1;
      }

    if (req->header.error_code)       /* shm_del failed in the daemon */
      {
        set_errno (req->header.error_code);
        delete req;
        return -1;
      }

     /* the daemon has deleted it's references */
     /* now for us */
#endif
}
      break;
    case IPC_SET:
    default:
      set_errno (EINVAL);
      return -1;
    }
  return 0;
}

/* FIXME: evaluate getuid() and getgid() against the requested mode. Then
 * choose PAGE_READWRITE | PAGE_READONLY and FILE_MAP_WRITE  |  FILE_MAP_READ
 * appropriately
 */

/* Test result from openbsd: shm ids are persistent cross process if a handle is left
 * open. This could lead to resource starvation: we're not copying that behaviour 
 * unless we have to. (It will involve acygwin1.dll gloal shared list :[ ).
 */
/* FIXME: shmid should be a verifyable object
 */

/* FIXME: on NT we should check everything against the SD. On 95 we just emulate.
 */
extern "C" int
shmget (key_t key, size_t size, int shmflg)
{
  DWORD sd_size = 4096;
  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) sd_buf;
  /* create a sd for our open requests based on shmflag & 0x01ff */
  psd = alloc_sd (getuid (), getgid (), cygheap->user.logsrv (),
		  shmflg & 0x01ff, psd, &sd_size);

  if (key == (key_t) - 1)
    {
      set_errno (ENOENT);
      return -1;
    }

  /* FIXME: enter the checking for existing keys mutex. This mutex _must_ be system wide
   * to prevent races on shmget.
   */

  /* walk the list of currently open keys and return the id if found
   */
  shmnode *tempnode = shm_head;
  while (tempnode)
    {
      if (tempnode->key == key && key != IPC_PRIVATE)
	{
	  // FIXME: free the mutex
	  if (size && tempnode->shmds->shm_segsz < size)
	    {
	      set_errno (EINVAL);
	      return -1;
	    }
	  if ((shmflg & IPC_CREAT) && (shmflg & IPC_EXCL))
	    {
	      set_errno (EEXIST);
	      // FIXME: free the mutex
	      return -1;
	    }
	  // FIXME: do we need to other tests of the requested mode with the
	  // tempnode->shmid mode ? testcase on unix needed.
	  // FIXME do we need a security test? We are only examining the keys we already have open.
	  // FIXME: what are the sec implications for fork () if we don't check here?
	  return tempnode->shm_id;
	}
      tempnode = tempnode->next;
    }
  /* couldn't find a currently open shm control area for the key.
   * Allocate a new control block - this has to be handled by the daemon */
  client_request_shm_get *req =
    new client_request_shm_get (key, size, shmflg, sd_buf,
				GetCurrentProcessId ());

  int rc;
  if ((rc = cygserver_request (req)))
    {
      delete req;
      set_errno (ENOSYS);	/* daemon communication failed */
      return -1;
    }

  if (req->header.error_code)	/* shm_get failed in the daemon */
    {
      set_errno (req->header.error_code);
      delete req;
      return -1;
    }

  /* we've got the id, now we open the memory area ourselves.
   * This tests security automagically
   * FIXME: make this a method of shmnode ?
   */
  shmnode *shmtemp = build_inprocess_shmds (req->parameters.out.filemap,
					    req->parameters.out.attachmap,
					    key,
					    req->parameters.out.shm_id);
  delete req;
  if (shmtemp)
    return shmtemp->shm_id;
  return -1;


#if 0
  /* fill out the node data */
  shmtemp->shm_perm.cuid = getuid ();
  shmtemp->shm_perm.uid = shmtemp->shm_perm.cuid;
  shmtemp->shm_perm.cgid = getgid ();
  shmtemp->shm_perm.gid = shmtemp->shm_perm.cgid;
  shmtemp->shm_perm.mode = shmflg & 0x01ff;
  shmtemp->shm_lpid = 0;
  shmtemp->shm_nattch = 0;
  shmtemp->shm_atime = 0;
  shmtemp->shm_dtime = 0;
  shmtemp->shm_ctime = time (NULL);
  shmtemp->shm_segsz = size;
  *(shmid_ds *) mapptr = *shmtemp;
  shmtemp->filemap = filemap;
  shmtemp->attachmap = attachmap;
  shmtemp->mapptr = mapptr;

#endif
}
@


1.1.2.2
log
@Sun Sep 30 23:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * Makefile.in: Add cygserver_process.o to cygserver.exe.
        * cygserver.cc: Include signal.h and cygwin_version.h.
        Define debug_printf as a macro.
        Define DEBUG to a value.
        (client_request_attach_tty::serve): Add beginning of process cache support.
        Change from #ifdef DEBUG to work with new DEBUG style.
        (client_request_get_version::serve): Add beginning of process cache support.
        (class server_request): New prototype for support of process cache.
        (class queue_process_param): New class to allow request loop threading.
        (class server_request_queue): Add beginning of process cache support.
        Allow request loop threading.
        (request_loop): Thread function for request loops.
        (server_request_queue::process_requests): Initiator for threaded request loops.
        (client_request_shutdown::serve): Add beginning of process cache support.
        (server_request::server_request): Ditto.
        (server_request::process): Use debug_printf. Add beginning of process cache support.
        (server_request_queue::cleanup): Kill off any request loop threads.
        (server_request_queue::add): Add beginning of process cache support.
        (handle_signal): Trigger a shutdown.
        (main): Print out some useful info at startup - version, date time.
        Add process cache support.
        Spawn a separate thread for the transport request loop, thus allowing concurrent
        support for multiple transports.
        * cygserver_client.cc (client_request_get_version::serve): Add process cache support.
        (client_request_attach_tty::serve): Add process cache support.
        (client_request_shutdown::serve): Add process cache support.
        * cygsserver_process.cc: New file with the process cache support.
        * cygserver_shm.cc: Redefine debug_printf to allow conditional output.
        * cygwin.din: Export shmdt().
        * shm.cc: Run indent.
        Update FIXME's.
        (shmdt): New function.
        * include/cygwin/cygserver.h (class client_request): Add process cache support.
        (class client_request_get_version): Ditto.
        (class client_request_shutdown): Ditto.
        (class client_request_attach_tty): Ditto.
        * include/cygwin/cygserver_process.h: New header for process cache support.
@
text
@d114 1
a114 2
	  system_printf ("failed to reattach to shm control file view %x\n",
			 tempnode);
d129 1
a129 2
	      system_printf ("failed to reattach to mapped file view %x\n",
			     attachnode->data);
d145 2
a146 1
 * incremented. This should be done in the server?
d149 2
a150 2
/* FIXME: tell the daemon when we attach, so at process close it can clean up
 * the attach count
d152 1
d224 1
a224 2
    (_shmattach *) InterlockedExchangePointer (&tempnode->attachhead,
					       attachnode);
a229 11
/* FIXME: tell the daemon when we detach so it doesn't cleanup incorrectly.
 */
extern "C" int
shmdt (const void *shmaddr)
{
  /* this should be "rare" so a hefty search is ok. If this is common, then we
   * should alter the data structs to allow more optimisation
   */
  
}

d238 6
a243 6
    {
      /* couldn't find a currently open shm control area for the key - probably because
       * shmget hasn't been called.
       * Allocate a new control block - this has to be handled by the daemon */
      client_request_shm_get *req =
	new client_request_shm_get (shmid, GetCurrentProcessId ());
d245 7
a251 7
      int rc;
      if ((rc = cygserver_request (req)))
	{
	  delete req;
	  set_errno (ENOSYS);	/* daemon communication failed */
	  return -1;
	}
d253 6
a258 20
      if (req->header.error_code)	/* shm_get failed in the daemon */
	{
	  set_errno (req->header.error_code);
	  delete req;
	  return -1;
	}

      /* we've got the id, now we open the memory area ourselves.
       * This tests security automagically
       * FIXME: make this a method of shmnode ?
       */
      tempnode =
	build_inprocess_shmds (req->parameters.out.filemap,
			       req->parameters.out.attachmap,
			       req->parameters.out.key,
			       req->parameters.out.shm_id);
      delete req;
      if (!tempnode)
	return -1;
    }
d260 14
d277 1
a277 1
      buf->shm_perm = tempnode->shmds->shm_perm;
d288 12
a299 13
	/* TODO: check permissions. Or possibly, the daemon gets to be the only 
	 * one with write access to the memory area?
	 */
	if (tempnode->shmds->shm_nattch)
	  system_printf
	    ("call to shmctl with cmd= IPC_RMID when memory area still has"
	     " attachees\n");
	/* how does this work? 
	   * we mark the ds area as "deleted", and the at and get calls all fail from now on
	   * on, when nattch becomes 0, the mapped data area is destroyed.
	   * and each process, as they touch this area detaches. eventually only the 
	   * daemon has an attach. The daemon gets asked to detach immediately.
	 */
d301 1
a301 2
//waiting for the daemon to handle terminating process's
	client_request_shm_get *req =
d303 7
a309 19
	int rc;
	if ((rc = cygserver_request (req)))
	  {
	    delete req;
	    set_errno (ENOSYS);	/* daemon communication failed */
	    return -1;
	  }

	if (req->header.error_code)	/* shm_del failed in the daemon */
	  {
	    set_errno (req->header.error_code);
	    delete req;
	    return -1;
	  }

	/* the daemon has deleted it's references */
	/* now for us */
	
#endif	
d311 5
d317 5
d336 4
@


1.1.2.3
log
@Tue Oct  2 16:06:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * Makefile.in: Remove cygserver_shm.o from cygwin1.dll.
        Rename cygserver_shm_outside.o to cygserver_shm.o.
        * cygserver.cc (server_request::process): Use the new client_request
        constructor.
        * cygserver_client.cc: Remove the #ifdef's stubs for the server method
        within cygwin.
        (client_request_attach_tty::client_request_attach_tty): Use the new
        client_request constructor.
        (client_request_shutdown::client_request_shutdown): Ditto.
        (client_request::client_request): Ditto.
        * cygserver_shm.cc (client_request_shm_get::serve): Remove the
        #ifdef'd stub for in-cygwin builds.
        (client_request_shm_get::client_request_shm_get): Use the new
        client_request constructor, and remove the in-cygwin variants.
        * cygserver_shm.h (class client_request_shm_get): #ifndef test the
        serve method - it's only used in cygserver.
        * shm.cc (client_request_shm_get::client_request_shm_get): New function.
        * include/cygwin/cygserver.h (request_header): New constructor.
        (class client_request): Use it.
        New constructor accepting the header size.
        #ifndef test the server method - it's only used within cygserver.
        (client_request_get_version): #ifdef test the server method.
        (client_request_shutdown): Ditto.
        (client_request_attach_tty): Ditto.
@
text
@a46 24
client_request_shm_get::client_request_shm_get (int nshm_id, pid_t npid):
client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
{
  buffer = (char *) &parameters;
  parameters.in.shm_id = nshm_id;
  parameters.in.type = SHM_REATTACH;
  parameters.in.pid = npid;
}

client_request_shm_get::client_request_shm_get (key_t nkey, size_t nsize,
                                                int nshmflg,
                                                char psdbuf[4096],
                                                pid_t npid):
client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
{
  buffer = (char *) &parameters;
  parameters.in.key = nkey;
  parameters.in.size = nsize;
  parameters.in.shmflg = nshmflg;
  parameters.in.type = SHM_CREATE;
  parameters.in.pid = npid;
  memcpy (parameters.in.sd_buf, psdbuf, 4096);
}

@


1.1.2.4
log
@Tue Oct  2 23:00:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * shm.cc: Update to handle include changes from HEAD.
@
text
@a19 1
#include "path.h"
@


1.1.2.5
log
@Mon Oct  8  7:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * cygserver.cc (server_request::process): Rename client_request_shm_get to
        client_request_shm.
        * cygserver_process.cc (process_cache::add): Rename to add_task.
        Use process_cleanup instead of process_request.
        (process_cache::remove_process): New method.
        (process::process): Initialize new members.
        (process::~process): New member.
        (process::cleanup): New method.
        (process::add_cleanup_routine): New method.
        (process_request::process): Rename to process_cleanup.
        Call the process object's cleanup method and then delete it.
        (process_process_param::request_loop): Remove the signalling process.
        * cygserver_shm.cc: Globally rename client_request_shm_get to client_request_shm.
        (client_request_shm_get::serve): Handle attach request counting.
        * cygserver_shm.h: Globally rename client_request_shm_get to client_request_shm.
        (class shm_cleanup): New class.
        * shm.cc: Globally rename client_request_shm_get to client_request_shm.
        (client_request_shm::client_request_shm): New constructor for attach requests.
        (shmat): Use it.
        * include/cygwin/cygserver_process.h (class process_request): Rename to
        process_cleanup.
        (class cleanup_routine): New class.
        (class process): New members and methods to allow calling back when the process
        terminates.
@
text
@d48 1
a48 1
client_request_shm::client_request_shm (int ntype, int nshm_id):
a53 9
  parameters.in.pid = GetCurrentProcessId ();
}

client_request_shm::client_request_shm (int ntype, int nshm_id, pid_t npid):
client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
{
  buffer = (char *) &parameters;
  parameters.in.shm_id = nshm_id;
  parameters.in.type = ntype;
d57 1
a57 1
client_request_shm::client_request_shm (key_t nkey, size_t nsize,
d190 2
a191 2
      client_request_shm *req =
	new client_request_shm (SHM_REATTACH, shmid, GetCurrentProcessId ());
a241 9
  /* tell the daemon we have attached */
  client_request_shm *req =
    new client_request_shm (SHM_ATTACH, shmid);
  int rc;
  if ((rc = cygserver_request (req)))
    {
      debug_printf ("failed to tell deaemon that we have attached\n");
    }
  delete req;
d243 1
d245 1
d279 2
a280 2
      client_request_shm *req =
	new client_request_shm (SHM_REATTACH, shmid, GetCurrentProcessId ());
d340 2
a341 2
	client_request_shm *req =
	  new client_request_shm (SHM_DEL, shmid, GetCurrentProcessId ());
d431 2
a432 2
  client_request_shm *req =
    new client_request_shm (key, size, shmflg, sd_buf,
@


1.1.2.6
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
Copyright 2001, 2002 Red Hat, Inc.
d5 1
a5 1
Originally written by Robert Collins <robert.collins@@hotmail.com>
d7 1
a7 1
This file is part of Cygwin.
d9 3
a11 3
This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
d26 1
d67 3
a69 3
						int nshmflg,
						char psdbuf[4096],
						pid_t npid):
a136 28
static void
delete_inprocess_shmds (shmnode **nodeptr)
{
  shmnode *node = *nodeptr;

  // remove from the list
  if (node == shm_head)
    shm_head = shm_head->next;
  else
    {
      shmnode *tempnode = shm_head;
      while (tempnode && tempnode->next != node)
	tempnode = tempnode->next;
      if (tempnode)
	tempnode->next = node->next;
      // else log the unexpected !
    }

  // release the shared data view
  UnmapViewOfFile (node->shmds);
  CloseHandle (node->filemap);
  CloseHandle (node->attachmap);

  // free the memory
  delete node;
  nodeptr = NULL;
}

d197 1
a197 1
       * shmget hasn't been called.
d232 1
a232 1
  // class shmid_ds *shm = tempnode->shmds;
d280 1
a280 31
  shmnode *tempnode = shm_head;
  _shmattach *attachnode;
  while (tempnode)
    {
      // FIXME: Race potential
      attachnode = tempnode->attachhead;
      while (attachnode && attachnode->data != shmaddr)
	attachnode = attachnode->next;
      if (attachnode)
	break;
      tempnode = tempnode->next;
    }
  if (!tempnode)
    {
      // dt cannot be called by an app that hasn't alreadu at'd
      set_errno (EINVAL);
      return -1;
    }

  UnmapViewOfFile (attachnode->data);
  /* tell the daemon we have attached */
  client_request_shm *req =
      new client_request_shm (SHM_DETACH, tempnode->shm_id);
  int rc;
  if ((rc = cygserver_request (req)))
    {
      debug_printf ("failed to tell deaemon that we have detached\n");
    }
  delete req;

  return 0;
d283 1
a283 1
//FIXME: who is allowed to perform STAT?
d341 1
a341 1
	/* TODO: check permissions. Or possibly, the daemon gets to be the only
d348 1
a348 1
	/* how does this work?
d351 1
a351 1
	   * and each process, as they touch this area detaches. eventually only the
d354 2
a355 1
	//waiting for the daemon to handle terminating process's
d375 2
a376 3

	// FIXME: create a destructor
	delete_inprocess_shmds (&tempnode);
d388 1
a388 1
/* FIXME: evaluate getuid32() and getgid32() against the requested mode. Then
d405 1
a405 3
  InitializeSecurityDescriptor (psd,
				    SECURITY_DESCRIPTOR_REVISION);
  psd = alloc_sd (getuid32 (), getgid32 (),
d482 1
a482 1
  shmtemp->shm_perm.cuid = getuid32 ();
d484 1
a484 1
  shmtemp->shm_perm.cgid = getgid32 ();
@


1.1.2.7
log
@	* woutsup.h: New file.
	* cygserver.cc: Use "woutsup.h" and new XXX_printf macros.
	(getfunc): New function, copied verbatim from "strace.cc".
	(__cygserver__printf): New function.
	* cygserver_client.cc: Use "woutsup.h" and new XXX_printf macros.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* threaded_queue.cc: Ditto.
	* shm.cc: Remove trailing \n from XXX_printf format strings.
	* Makefile.in: Remove redundant __OUTSIDE_CYGWIN__ case for
	cygserver_shm.cc.
@
text
@d104 1
a104 1
      system_printf ("failed to malloc shm node");
d175 1
a175 1
	  system_printf ("failed to reattach to shm control file view %x",
d191 1
a191 1
	      system_printf ("failed to reattach to mapped file view %x",
d284 1
a284 1
      debug_printf ("failed to tell deaemon that we have attached");
d333 1
a333 1
      debug_printf ("failed to tell deaemon that we have detached");
d404 1
a404 1
	     " attachees");
@


1.1.2.8
log
@	* cygserver.cc (check_and_dup_handle): Only use security code if
	running on NT, i.e. if wincap.has_security().
	(client_request_attach_tty::serve): Add check for has_security().
	* cygserver_process.cc (process_cache::process): Use DWORD winpid
	throughout to avoid win32 vs. cygwin pid confusion.
	(process::process): Ditto.
	* cygserver_shm.cc (client_request_shm::serve): Only use security
	code if running on NT, i.e. if wincap.has_security().
	* cygserver_shm.h (client_request_shm::parameters.in): Replace the
	ambiguous pid field with cygpid and winpid fields.
	(client_request_shm::client_request_shm): Reduce to only two
	client-side constructors: one for SHM_CREATE, another for all the
	other requests.
	* shm.cc (client_request_shm::client_request_shm):
	Ditto. Initialize cygpid and winpid fields here. On NT initialize
	sd_buf here using set_security_attribute() to make use of the euid
	and egid.
	(shmat): Use new client_request_shm constructor.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove security code, now performed in the
	relevant client_request_shm constructor.
	* include/cygwin/cygserver_process.h: (class cleanup_routine):
	Change winpid type to DWORD.
	(class process): Ditto.
@
text
@a14 1
#include <assert.h>
d47 2
a48 5
/*
 * Used for: SHM_ATTACH, SHM_DETACH, SHM_REATTACH, and SHM_DEL.
 */
client_request_shm::client_request_shm (int ntype, int nshmid)
  : client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
d50 5
a54 4
  assert (ntype == SHM_REATTACH			\
	  || ntype == SHM_ATTACH		\
	  || ntype == SHM_DETACH		\
	  || ntype == SHM_DEL);
d56 3
d60 1
a60 1

d62 1
a62 8
  parameters.in.cygpid = getpid ();
  parameters.in.winpid = GetCurrentProcessId ();
  parameters.in.shm_id = nshmid;

  assert (parameters.in.cygpid > 0);
  assert (parameters.in.winpid != 0);

  debug_printf ("created: ntype = %d, shmid = %d", ntype, nshmid);
d65 5
a69 5
/*
 * Used for: SHM_CREATE.
 */
client_request_shm::client_request_shm (key_t nkey, size_t nsize, int nshmflg)
  : client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
a70 3
  assert (nkey != (key_t) -1);
  assert (nsize >= 0);

a71 4

  parameters.in.type = SHM_CREATE;
  parameters.in.cygpid = getpid ();
  parameters.in.winpid = GetCurrentProcessId ();
d75 3
a77 14

  assert (parameters.in.cygpid > 0);
  assert (parameters.in.winpid != 0);

  if (wincap.has_security ())
    {
      SECURITY_ATTRIBUTES sa = sec_none;
      set_security_attribute (nshmflg & 0777, &sa,
			      parameters.in.sd_buf,
			      sizeof (parameters.in.sd_buf));
    }

  debug_printf ("created: key = 0x%0llx, size = %ld, shmflg = %o",
		nkey, nsize, nshmflg);
d226 2
a227 1
      client_request_shm *req = new client_request_shm (SHM_REATTACH, shmid);
d279 2
a280 1
  client_request_shm *req = new client_request_shm (SHM_ATTACH, shmid);
d329 1
a329 1
    new client_request_shm (SHM_DETACH, tempnode->shm_id);
d352 2
a353 1
      client_request_shm *req = new client_request_shm (SHM_REATTACH, shmid);
d412 2
a413 1
	client_request_shm *req = new client_request_shm (SHM_DEL, shmid);
d458 9
d506 3
a508 1
  client_request_shm *req = new client_request_shm (key, size, shmflg);
@


1.1.2.9
log
@	* include/sys/ipc.h (IPC_PRIVATE): Add cast to key_t.
	(IPC_INFO): New flag for ipcs(8).
	(IPC_RMID IPC_SET IPC_STAT): Renumber.
	* include/sys/shm.h (SHM_RDONLY SHM_RND): Renumber with distinct
	values [sic].
	(class _shmattach): Internal type moved to "cygserver_shm.h".
	(class shmnode): Ditto.
	(class shmid_ds): Ditto.
	(struct shmid_ds): Add spare fields.
	(struct shminfo): New type for IPC_INFO interface.
	* cygserver_shm.h: Remove obsolete #if 0 ... #endif block.
	(class shm_cleanup): Remove unused class.
	(struct _shmattach): Internal type moved from <sys/shm.h>.
	(struct shmnode): Ditto.
	(struct int_shmid_ds): Ditto. Renamed to avoid name clash with
	public interface struct shmid_ds. Use the shmid_bs structure as a
	field.
	* cygserver_shm.cc: Remove obsolete #if 0 ... #endif block.
	(client_request_shm::serve): Update for redefinition of
	int_shmid_ds structure.
	* shm.cc (build_inprocess_shmds): Ditto.
	(fixup_shms_after_fork): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove obsolete #if 0 ... #endif code.
@
text
@d3 1
a3 1
   Copyright 2001, 2002 Red Hat, Inc.
d5 1
a5 1
   Originally written by Robert Collins <robert.collins@@hotmail.com>
d126 1
a126 1
  int_shmid_ds *shmtemp = new int_shmid_ds;
d139 1
a139 1
  shmtemp->ds = *(shmid_ds *) mapptr;
d204 1
a204 1
      tempnode->shmds->ds = *(shmid_ds *) newshmds;
d409 8
a416 1
      *buf = tempnode->shmds->ds;
d423 1
a423 1
	if (tempnode->shmds->ds.shm_nattch)
d497 1
a497 1
	  if (size && tempnode->shmds->ds.shm_segsz < size)
d547 21
@


1.1.2.10
log
@	* cygserver.cc: Throughout the code, check and correct level of
	the XXX_printf() functions used. Comment out several of the
	debug_printf() calls with "// verbose:".  Reformat and correct
	typos of some of the XXX_printf() formats.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* shm.cc (hi_ulong): New function to allow printing of a 64-bit
	key with current small_printf implementation.
	(lo_ulong): Ditto.
	(client_request_shm::client_request_shm): Use hi_ulong() and
	lo_ulong() in call to debug_printf().
@
text
@a17 1
#include <limits.h>
d24 1
a28 20
/*
 * FIXME: These must be defined somewhere? i.e. get the high and low
 * double words of a quad word?  They are required here to allow keys
 * to be printed out via XXX_printf (i.e. small_printf()).  Note that
 * even if the key is only 32 bits (the old default), these routine
 * should still give sensible results, i.e. hi_ulong() => 0.
 */

inline long int hi_ulong (const key_t key)
{
  return (unsigned long)
    (((unsigned long long) key >> 32) & ULONG_MAX);
}

inline long int lo_ulong (const key_t key)
{
  return (unsigned long)
    ((unsigned long long) key & ULONG_MAX);
}

d101 2
a102 2
  debug_printf ("created: key = 0x%x%08x, size = %ld, shmflg = %o",
		hi_ulong(nkey), lo_ulong(nkey), nsize, nshmflg);
d307 1
a307 1
      debug_printf ("failed to tell daemon that we have attached");
d356 1
a356 1
      debug_printf ("failed to tell daemon that we have detached");
@


1.1.2.11
log
@	* include/cygwin/cygserver.h: Change the client_request classes to
	give greater encapsulation and to allow variable length requests
	and replies.
	(enum cygserver_request_code): Now client_request::request_code_t.
	(class request_header): Now client_request::header_t.  Make a
	union of the request_code and the error_code.  The `cb' field,
	which was the buffer length, is now the `size_t msglen' field.
	(struct request_get_version): Now
	client_request_get_version::request_get_version.
	(struct request_shutdown): Remove unused type.
	(struct request_attach_tty): Now
	client_request_attach_tty::request_attach_tty.
	(client_request::_buf): Make field const.
	(client_request::_buflen): New const private field.
	(client_request::request_code): New accessor.
	(client_request::error_code): Ditto.
	(client_request::msglen): Ditto.
	(client_request::handle_request): New static method.
	(client_request::make_request): New virtual method.
	(client_request::handle): New method.
	(client_request::send): Make private.
	(client_request_get_version::check_version): New method.
	(client_request_get_version::serve): Make private.
	(client_request_get_version::version): Ditto.
	(client_request_shutdown::serve): Ditto.
	(client_request_attach_tty::req): Ditto.
	(client_request_attach_tty::serve): Ditto.
	(client_request_attach_tty::from_master): Make method const.
	(client_request_attach_tty::from_master): Ditto.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Track
	changes to the client_request classes.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	(client_request_get_version::check_version): New method to
	encapsulate code from cygserver_init().
	(client_request_shutdown::client_request_shutdown): Move into
	"cygserver.cc".
	(client_request::send): Track changes to the client_request
	classes.  Add more error checking.
	(client_request::handle_request): New static method containing the
	first half of the old server_request::process() code.
	(client_request::make_request): New method to replace the old
	cygserver_request() function.
	(client_request::handle): New method containing the second half of
	the old server_request::process() code.
	(cygserver_init): Track changes to the client_request classes.  In
	particular, some code moved into the
	client_request_get_version::check_version() method.
	* cygserver.cc (client_request_attach_tty::serve): Track changes
	to the client_request classes.  In particular, only return a reply
	body if some handles are successfully duplicated for the client.
	And remove goto's.
	(client_request_get_version::serve): Track changes to the
	client_request classes.
	(client_request_shutdown::serve): Ditto.
	(class client_request_invalid): Dead, and so young too.
	(server_request::request_buffer): Remove unnecessary field.
	(client_request_shutdown::client_request_shutdown): Moved here
	from "cygserver_client.cc".
	(server_request::process): Implementation moved into the new
	client_request::handle_request() and client_request::handle()
	methods.
	* cygserver_shm.h (class client_request_shm): Put client- and
	server-specific interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__
	guards.
	(client_request_shm::serve): Make private.
	* cygserver_shm.cc
	(client_request_shm::client_request_shm): Track changes to the
	client_request classes.
	(client_request_shm::serve): Ditto
	* shm.cc (client_request_shm::client_request_shm): Ditto.  Use
	alloc_sd() rather than set_security_attribute() to get access to
	the SECURITY_DESCRIPTOR length, so that we can use it to set the
	request body length.
	(shmat): Track changes to the client_request classes. In
	particular, allocate client_request objects on the stack rather
	than on the heap, and use the client_request::make_request()
	method rather than the old cygserver_request() function.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::cygserver_attach_tty): Ditto.
@
text
@d72 1
a72 1
  : client_request (CYGSERVER_REQUEST_SHM, &parameters, sizeof (parameters))
d79 2
d89 1
a89 4
  msglen (sizeof (parameters.in) - sizeof (parameters.in.sd_buf));

  syscall_printf ("created: type = %d, shmid = %d",
		  parameters.in.type, parameters.in.shm_id);
d96 1
a96 1
  : client_request (CYGSERVER_REQUEST_SHM, &parameters, sizeof (parameters))
d101 2
a112 2
  DWORD sd_buf_size = 0;

d116 3
a118 8
      sd_buf_size = sizeof (parameters.in.sd_buf);

      PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) parameters.in.sd_buf;

      InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION);

      alloc_sd (geteuid32 (), getegid32 (), parameters.in.shmflg & 0777,
		psd, &sd_buf_size);
d121 2
a122 8
  msglen (sizeof (parameters.in) - sizeof (parameters.in.sd_buf)
	  + sd_buf_size);

  syscall_printf (("created: type = %d, "
		   "key = 0x%x%08x, size = %ld, shmflg = %o"),
		  parameters.in.type,
		  hi_ulong(parameters.in.key), lo_ulong(parameters.in.key),
		  parameters.in.size, parameters.in.shmflg);
d271 1
a271 1
      client_request_shm req (SHM_REATTACH, shmid);
d273 2
a274 1
      if (req.make_request () == -1)
d276 1
d281 1
a281 1
      if (req.error_code ())	/* shm_get failed in the daemon */
d283 2
a284 1
	  set_errno (req.error_code ());
d293 5
a297 4
	build_inprocess_shmds (req.parameters.out.filemap,
			       req.parameters.out.attachmap,
			       req.parameters.out.key,
			       req.parameters.out.shm_id);
d323 3
a325 3
  client_request_shm req (SHM_ATTACH, shmid);

  if (req.make_request () == -1)
d329 1
d371 4
a374 3
  client_request_shm req (SHM_DETACH, tempnode->shm_id);

  if (req.make_request () == -1)
d378 1
d395 1
a395 1
      client_request_shm req (SHM_REATTACH, shmid);
d397 2
a398 1
      if (req.make_request () == -1)
d400 1
d405 1
a405 1
      if (req.error_code ())	/* shm_get failed in the daemon */
d407 2
a408 1
	  set_errno (req.error_code ());
d417 5
a421 4
	build_inprocess_shmds (req.parameters.out.filemap,
			       req.parameters.out.attachmap,
			       req.parameters.out.key,
			       req.parameters.out.shm_id);
d447 3
a449 3
	client_request_shm req (SHM_DEL, shmid);

	if (req.make_request () == -1)
d451 1
d456 1
a456 1
	if (req.error_code ())	/* shm_del failed in the daemon */
d458 2
a459 1
	    set_errno (req.error_code ());
d531 1
a531 1
  client_request_shm req (key, size, shmflg);
d533 2
a534 1
  if (req.make_request () == -1)
d536 1
d541 1
a541 1
  if (req.error_code ())	/* shm_get failed in the daemon */
d543 2
a544 1
      set_errno (req.error_code ());
d552 2
a553 2
  shmnode *shmtemp = build_inprocess_shmds (req.parameters.out.filemap,
					    req.parameters.out.attachmap,
d555 2
a556 1
					    req.parameters.out.shm_id);
@


1.1.2.12
log
@Merged changes from HEAD
@
text
@d26 1
a26 1
#include "cygwin_shm.h"
@


1.1.2.13
log
@	* cygserver_ipc.h: New file.
	* cygserver_shm.h: Re-written from scratch.
	* cygserver_shm.cc: Ditto.
	* shm.cc: Ditto.
@
text
@d1 1
a1 1
/* shm.cc: Single unix specification IPC interface for Cygwin.
d3 1
a3 1
   Copyright 2002 Red Hat, Inc.
d5 1
a5 2
   Written by Conrad Scott <conrad.scott@@dsl.pipex.com>.
   Based on code by Robert Collins <robert.collins@@hotmail.com>.
d14 14
d29 7
a35 1
#include <sys/types.h>
d37 5
a41 3
#include <errno.h>
#include <stdio.h>
#include <unistd.h>
d43 5
a47 1
#include "cygerrno.h"
d49 18
a66 2
#include "cygserver_ipc.h"
#include "cygserver_shm.h"
d68 5
a72 139
/*---------------------------------------------------------------------------*
 * with_strerr ()
 *---------------------------------------------------------------------------*/

#define with_strerr(MSG, ACTION)					\
  do									\
    {									\
      const DWORD lasterr = GetLastError ();				\
      char *MSG = NULL;							\
      if (!FormatMessage ((FORMAT_MESSAGE_ALLOCATE_BUFFER		\
			   | FORMAT_MESSAGE_FROM_SYSTEM			\
			   | FORMAT_MESSAGE_IGNORE_INSERTS),		\
			  NULL,						\
			  lasterr,					\
			  MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),	\
			  reinterpret_cast<char *>(&MSG),		\
			  0,						\
			  NULL))					\
	{								\
	  MSG = static_cast<char *>					\
	    (LocalAlloc (LMEM_FIXED, 24)); /* Big enough. */		\
	  if (!MSG)							\
	    {								\
	      system_printf (("failure in LocalAlloc(LMEM_FIXED, 16): "	\
			      "error = %lu"),				\
			     GetLastError ());				\
	    }								\
	  else								\
	    {								\
	      snprintf (MSG, 24, "error = %lu", lasterr);		\
	    }								\
	}								\
      SetLastError (lasterr);						\
      { ACTION; }							\
      if (MSG && !LocalFree (MSG))					\
	{								\
	  system_printf ("failed to free memory at %p, error = %lu",	\
			 MSG, GetLastError ());				\
	}								\
      SetLastError (lasterr);						\
    } while (false)

/*---------------------------------------------------------------------------*
 * class client_shmmgr
 *
 * A singleton class.
 *---------------------------------------------------------------------------*/

#define shmmgr (client_shmmgr::instance ())

class client_shmmgr
{
private:
  class segment_t
  {
  public:
    const int shmid;
    const void *const shmaddr;
    const int shmflg;
    HANDLE hFileMap;		// Updated by fixup_shms_after_fork ().

    segment_t *next;

    segment_t (const int shmid, const void *const shmaddr, const int shmflg,
	       const HANDLE hFileMap)
      : shmid (shmid), shmaddr (shmaddr), shmflg (shmflg), hFileMap (hFileMap),
	next (NULL)
    {}
  };

public:
  static client_shmmgr & instance ();

  void *shmat (int shmid, const void *, int shmflg);
  int shmctl (int shmid, int cmd, struct shmid_ds *);
  int shmdt (const void *);
  int shmget (key_t, size_t, int shmflg);

  int fixup_shms_after_fork ();

private:
  CRITICAL_SECTION _segments_lock;
  static segment_t *_segments_head; // A list sorted by shmaddr.

  client_shmmgr ();
  ~client_shmmgr ();

  // Undefined (as this class is a singleton):
  client_shmmgr (const client_shmmgr &);
  client_shmmgr & operator= (const client_shmmgr &);

  segment_t *find (const void *, segment_t **previous = NULL);

  void *attach (int shmid, const void *, int shmflg, HANDLE & hFileMap);

  segment_t *new_segment (int shmid, const void *, int shmflg, HANDLE);
};

client_shmmgr::segment_t *client_shmmgr::_segments_head;

/*---------------------------------------------------------------------------*
 * client_shmmgr::instance ()
 *---------------------------------------------------------------------------*/

client_shmmgr &
client_shmmgr::instance ()
{
  static NO_COPY client_shmmgr instance;

  return instance;
}

/*---------------------------------------------------------------------------*
 * client_shmmgr::shmat ()
 *---------------------------------------------------------------------------*/

void *
client_shmmgr::shmat (const int shmid,
		      const void *const shmaddr,
		      const int shmflg)
{
  HANDLE hFileMap = NULL;

  void *const ptr = attach (shmid, shmaddr, shmflg, hFileMap);

  if (ptr)
    new_segment (shmid, ptr, shmflg, hFileMap);

  return (ptr ? ptr : (void *) -1);
}

/*---------------------------------------------------------------------------*
 * client_shmmgr::shmctl ()
 *---------------------------------------------------------------------------*/

int
client_shmmgr::shmctl (const int shmid,
		       const int cmd,
		       struct shmid_ds *const buf)
d74 4
a77 1
  client_request_shm request (shmid, cmd, buf);
d79 4
a82 5
  if (request.make_request () == -1 || request.error_code ())
    {
      set_errno (request.error_code ());
      return -1;
    }
d84 2
a85 1
  // Some commands require special processing, e.g. for out parameters.
d87 1
a87 6
  switch (cmd)
    {
    case IPC_STAT:
      *buf = request.ds ();
      break;
    }
d89 2
a90 1
  return 0;
d93 15
a107 8
/*---------------------------------------------------------------------------*
 * client_shmmgr::shmdt ()
 *
 * According to Posix, the only error condition for this system call
 * is EINVAL if shmaddr is not the address of the start of an attached
 * shared memory segment.  Given that, all other errors just generate
 * tracing noise.
 *---------------------------------------------------------------------------*/
d109 2
a110 4
int
client_shmmgr::shmdt (const void *const shmaddr)
{
  segment_t *previous = NULL;
d112 1
a112 1
  segment_t *const segptr = find (shmaddr, &previous);
d114 1
a114 1
  if (!segptr)
d116 2
a117 3
      set_errno (EINVAL);
      return -1;
    }
d119 1
a119 1
  assert (previous ? previous->next == segptr : _segments_head == segptr);
d121 1
a121 4
  if (previous)
    previous->next = segptr->next;
  else
    _segments_head = segptr->next;
d123 3
a125 24
  if (!UnmapViewOfFile ((void *) shmaddr))
    with_strerr (msg,
		 syscall_printf (("failed to unmap view "
				  "[shmid = %d, handle = %p, shmaddr = %p]:"
				  "%s"),
				 segptr->shmid, segptr->hFileMap, shmaddr,
				 msg));

  assert (segptr->hFileMap);

  if (!CloseHandle (segptr->hFileMap))
    with_strerr (msg,
		 syscall_printf (("failed to close file map handle "
				  "[shmid = %d, handle = %p]:"
				  "%s"),
				 segptr->shmid, segptr->hFileMap,
				 msg));

  client_request_shm request (segptr->shmid);

  if (request.make_request () == -1 || request.error_code ())
    syscall_printf ("shmdt request failed [shmid = %d, handle = %p]: %s",
		    segptr->shmid, segptr->hFileMap,
		    strerror (request.error_code ()));
d127 2
a128 1
  delete segptr;
d130 5
a134 1
  return 0;
d137 1
a137 3
/*---------------------------------------------------------------------------*
 * client_shmmgr::shmget ()
 *---------------------------------------------------------------------------*/
d139 3
a141 2
int
client_shmmgr::shmget (const key_t key, const size_t size, const int shmflg)
d143 2
a144 1
  client_request_shm request (key, size, shmflg);
d146 1
a146 1
  if (request.make_request () == -1 || request.error_code ())
d148 6
a153 2
      set_errno (request.error_code ());
      return -1;
d156 13
a168 2
  return request.shmid ();
}
d170 2
a171 18
/*---------------------------------------------------------------------------*
 * client_shmmgr::fixup_shms_after_fork ()
 *
 * The hFileMap handles are non-inheritable: so the 
 *---------------------------------------------------------------------------*/

int
client_shmmgr::fixup_shms_after_fork ()
{
  for (segment_t *segptr = _segments_head; segptr; segptr = segptr->next)
    if (!attach (segptr->shmid,
		 segptr->shmaddr,
		 segptr->shmflg & ~SHM_RND,
		 segptr->hFileMap))
      {
	system_printf ("fatal error re-attaching to shared memory segments");
	return 1;
      }
d173 2
a174 2
  return 0;
}
d176 3
a178 3
/*---------------------------------------------------------------------------*
 * client_shmmgr::client_shmmgr ()
 *---------------------------------------------------------------------------*/
d180 7
a186 4
client_shmmgr::client_shmmgr ()
{
  InitializeCriticalSection (&_segments_lock);
}
d188 1
a188 3
/*---------------------------------------------------------------------------*
 * client_shmmgr::~client_shmmgr ()
 *---------------------------------------------------------------------------*/
d190 1
a190 3
client_shmmgr::~client_shmmgr ()
{
  DeleteCriticalSection (&_segments_lock);
d193 2
a194 6
/*---------------------------------------------------------------------------*
 * client_shmmgr::find ()
 *---------------------------------------------------------------------------*/

client_shmmgr::segment_t *
client_shmmgr::find (const void *const shmaddr, segment_t **previous)
d196 1
a196 2
  if (previous)
    *previous = NULL;
d198 12
a209 7
  for (segment_t *segptr = _segments_head; segptr; segptr = segptr->next)
    if (segptr->shmaddr == shmaddr)
      return segptr;
    else if (segptr->shmaddr > shmaddr) // The list is sorted by shmaddr.
      return NULL;
    else if (previous)
      *previous = segptr;
d211 8
a218 1
  return NULL;
d221 2
a222 11
/*---------------------------------------------------------------------------*
 * client_shmmgr::attach ()
 *
 * The body of shmat (), also used by fixup_shms_after_fork ().
 *---------------------------------------------------------------------------*/

void *
client_shmmgr::attach (const int shmid,
		       const void *shmaddr,
		       const int shmflg,
		       HANDLE & hFileMap)
d224 2
a225 3
  client_request_shm request (shmid, shmflg);

  if (request.make_request () == -1 || request.error_code ())
d227 28
a254 2
      set_errno (request.error_code ());
      return NULL;
d256 2
d259 18
a276 1
  int result = 0;
d278 30
a307 1
  const DWORD access = (shmflg & SHM_RDONLY) ? FILE_MAP_READ : FILE_MAP_WRITE;
d309 1
a309 2
  if (shmaddr && (shmflg & SHM_RND))
    shmaddr = (char *) shmaddr - ((ssize_t) shmaddr % SHMLBA);
d311 1
a311 2
  void *const ptr =
    MapViewOfFileEx (request.hFileMap (), access, 0, 0, 0, (void *) shmaddr);
d313 1
a313 1
  if (!ptr)
d315 3
a317 7
      with_strerr (msg,
		   syscall_printf (("failed to map view "
				    "[shmid = %d, handle = %p, shmaddr = %p]:"
				    "%s"),
				   shmid, request.hFileMap (), shmaddr,
				   msg));
      result = EINVAL;		// FIXME
d319 6
a324 1
  else if (shmaddr && ptr != shmaddr)
d326 3
a328 6
      syscall_printf (("failed to map view at requested address "
		       "[shmid = %d, handle = %p]: "
		       "requested address = %p, mapped address = %p"),
		      shmid, request.hFileMap (),
		      shmaddr, ptr);
      result = EINVAL;		// FIXME
d330 2
d333 1
a333 1
  if (result != 0)
d335 2
a336 7
      if (!CloseHandle (request.hFileMap ()))
	with_strerr (msg,
		     syscall_printf (("failed to close file map handle "
				      "[shmid = %d, handle = %p]:"
				      "%s"),
				     shmid, request.hFileMap (),
				     msg));
d338 6
a343 1
      client_request_shm dt_req (shmid);
a344 4
      if (dt_req.make_request () == -1 || dt_req.error_code ())
	syscall_printf ("shmdt request failed [shmid = %d, handle = %p]: %s",
			shmid, request.hFileMap (),
			strerror (dt_req.error_code ()));
d346 1
a346 6
      set_errno (result);
      return NULL;
    }

  hFileMap = request.hFileMap ();
  return ptr;
d349 4
a352 12
/*---------------------------------------------------------------------------*
 * client_shmmgr::new_segment ()
 *
 * Allocate a new segment for the given shmid, file map and address
 * and insert into the segment map.
 *---------------------------------------------------------------------------*/

client_shmmgr::segment_t *
client_shmmgr::new_segment (const int shmid,
			    const void *const shmaddr,
			    const int shmflg,
			    const HANDLE hFileMap)
d354 6
a359 18
  assert (ipc_ext2int_subsys (shmid) == IPC_SHMOP);
  assert (hFileMap);
  assert (shmaddr);

  segment_t *previous = NULL;	// Insert pointer.

  const segment_t *const tmp = find (shmaddr, &previous);

  assert (!tmp);
  assert (previous							\
	  ? (!previous->next || previous->next->shmaddr > shmaddr)	\
	  : (!_segments_head || _segments_head->shmaddr > shmaddr));

  segment_t *const segptr = new segment_t (shmid, shmaddr, shmflg, hFileMap);

  assert (segptr);

  if (previous)
d361 7
a367 2
      segptr->next = previous->next;
      previous->next = segptr;
d369 1
a369 1
  else
d371 3
a373 2
      segptr->next = _segments_head;
      _segments_head = segptr;
d376 3
a378 2
  return segptr;
}
d380 4
a383 3
/*---------------------------------------------------------------------------*
 * shmat ()
 *---------------------------------------------------------------------------*/
d385 1
a385 4
extern "C" void *
shmat (const int shmid, const void *const shmaddr, const int shmflg)
{
  return shmmgr.shmat (shmid, shmaddr, shmflg);
d388 1
a388 4
/*---------------------------------------------------------------------------*
 * shmctl ()
 *---------------------------------------------------------------------------*/

d390 1
a390 1
shmctl (const int shmid, const int cmd, struct shmid_ds *const buf)
d392 34
a425 2
  return shmmgr.shmctl (shmid, cmd, buf);
}
d427 34
a460 3
/*---------------------------------------------------------------------------*
 * shmdt ()
 *---------------------------------------------------------------------------*/
d462 2
a463 5
extern "C" int
shmdt (const void *const shmaddr)
{
  return shmmgr.shmdt (shmaddr);
}
d465 2
a466 3
/*---------------------------------------------------------------------------*
 * shmget ()
 *---------------------------------------------------------------------------*/
d468 8
a475 4
extern "C" int
shmget (const key_t key, const size_t size, const int shmflg)
{
  return shmmgr.shmget (key, size, shmflg);
d478 4
a481 3
/*---------------------------------------------------------------------------*
 * fixup_shms_after_fork ()
 *---------------------------------------------------------------------------*/
d483 2
a484 5
int __stdcall
fixup_shms_after_fork ()
{
  return shmmgr.fixup_shms_after_fork ();
}
d486 4
a489 6
/*---------------------------------------------------------------------------*
 * client_request_shm::client_request_shm ()
 *---------------------------------------------------------------------------*/

client_request_shm::client_request_shm (const int shmid, const int shmflg)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
d491 5
a495 1
  _parameters.in.shmop = SHMOP_shmat;
d497 34
a530 2
  _parameters.shmid = shmid;
  _parameters.in.shmflg = shmflg;
d532 5
a536 5
  _parameters.in.cygpid = getpid ();
  _parameters.in.winpid = GetCurrentProcessId ();
  _parameters.in.uid = geteuid ();
  _parameters.in.gid = getegid ();
}
d538 5
a542 53
/*---------------------------------------------------------------------------*
 * client_request_shm::client_request_shm ()
 *---------------------------------------------------------------------------*/

client_request_shm::client_request_shm (const int shmid,
					const int cmd,
					const struct shmid_ds * const buf)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmctl;

  _parameters.shmid = shmid;
  if (cmd == IPC_SET)
    _parameters.ds = *buf;
  _parameters.in.cmd = cmd;

  _parameters.in.cygpid = getpid ();
  _parameters.in.winpid = GetCurrentProcessId ();
  _parameters.in.uid = geteuid ();
  _parameters.in.gid = getegid ();
}

/*---------------------------------------------------------------------------*
 * client_request_shm::client_request_shm ()
 *---------------------------------------------------------------------------*/

client_request_shm::client_request_shm (const int shmid)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmdt;

  _parameters.shmid = shmid;

  _parameters.in.cygpid = getpid ();
  _parameters.in.winpid = GetCurrentProcessId ();
  _parameters.in.uid = geteuid ();
  _parameters.in.gid = getegid ();
}

/*---------------------------------------------------------------------------*
 * client_request_shm::client_request_shm ()
 *---------------------------------------------------------------------------*/

client_request_shm::client_request_shm (const key_t key,
					const size_t size,
					const int shmflg)
  : client_request (CYGSERVER_REQUEST_SHM, &_parameters, sizeof (_parameters))
{
  _parameters.in.shmop = SHMOP_shmget;

  _parameters.in.key = key;
  _parameters.in.size = size;
  _parameters.in.shmflg = shmflg;
d544 11
a554 4
  _parameters.in.cygpid = getpid ();
  _parameters.in.winpid = GetCurrentProcessId ();
  _parameters.in.uid = geteuid ();
  _parameters.in.gid = getegid ();
@


1.1.2.14
log
@	* shm.cc: Remove the use of a static client_shmmgr object.
	(client_shmmgr::_instance): New static variable.
	(client_shmmgr::instance): Allocate a new shmmgr on the heap,
	rather than using a local static object.
@
text
@a107 2
  static NO_COPY client_shmmgr *_instance;

d125 1
a125 2
/* static */ NO_COPY client_shmmgr *client_shmmgr::_instance;
/* static */ client_shmmgr::segment_t *client_shmmgr::_segments_head;
d134 1
a134 4
  if (!_instance)
    _instance = new client_shmmgr;

  assert (_instance);
d136 1
a136 1
  return *_instance;
@


1.1.2.15
log
@	* cygserver_shm.cc: Implement the ipcs(8) interfaces, IPC_INFO,
	SHM_STAT and SHM_INFO.
	(server_shmmgr::segment_t::sequence): New static field.
	(server_shmmgr::segment_t::key): Remove field, use the new
	ds.shm_perm.key field instead.
	(server_shmmgr::segment_t::shmid): Remove field.
	(server_shmmgr::segment_t::intid): New field.
	(server_shmmgr::segment_t::segment_t): Use the `key' argument to
	initialise `ds.shm_perm.key'.  Change from using `shmid' to
	`intid'.
	(server_shmmgr::_shmseg_cnt): Renamed from `_shmid_cnt'.
	(server_shmmgr::_intid_max): Renamed from `_shmid_max.
	(server_shmmgr::shmat): Move the out arguments to the start of the
	argument list.  Rename the `pid' argument as `cygpid'.  Add
	tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmctl): Add separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add support for the ipcs(8)
	interfaces.  Add tracing.  Pass an intid to `find ()', not a
	shmid.
	(server_shmmgr::shmdt): Rename the `pid' argument as `cygpid'.
	Add tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmget): Add a separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add tracing.
	(server_shmmgr::server_shmmgr): Update for new field names.
	(server_shmmgr::find_by_key): Update for the new `ds.shm_perm.key'
	field.
	(server_shmmgr::find): Update to use the new `segment_t::intid'
	field.
	(server_shmmgr::new_segment): Rename the `pid' argument as
	`cygpid'.  Check that the requested size is within bounds.  Handle
	new error result from `new_segment (key, HANDLE)'.
	(server_shmmgr::new_segment): Work with intids, not shmids.  Check
	that the new intid is within bounds.  Update for new field names.
	(server_shmmgr::delete_segment): Pass an intid to `find ()', not a
	shmid.  Update for new field names.
	(client_request_shm::serve): Check that the incoming message
	length is the size of the `_parameters.in' struct, not of the
	whole in/out parameter union.  Likewise, set the outgoing message
	length to the size of the `_parameters.out' struct.  Update for
	the new server_shmmgr interfaces.
	* include/sys/ipc.h (ipc_perm::key): New field.
	* include/sys/shm.h (SHM_INFO): New constant.
	* cygserver_ipc.h (IPCMNI): New constant.
	(ipc_int2ext): Add `sequence' argument and munge this into the
	external ipc id.
	(ipc_ext2int_subsys): Unmunge the sequence number from the
	external ipc id.
	(ipc_ext2int): Ditto.
	(ipc_inc_id): Remove.
	(ipc_dec_id): Remove.
	* cygserver_shm.h (SHMMAX): New constant.
	(SHMMIN): Ditto.
	(SHMMNI): Ditto.
	(SHMSEG): Ditto.
	(SHMALL): Ditto.
	(client_request_shm::_parameters): Re-arrange as a union of two
	separate structs, one for in arguments, the other for out.
	(client_request_shm::shmid): Update for the new parameter layout.
	(client_request_shm::ds): Ditto.
	(client_request_shm::info): New method.
	* shm.cc (client_shmmgr::_shmat_cnt): New static field.
	(client_shmmgr::shmat): Add locking.  Add tracing.
	(client_shmmgr::shmctl): Update for ipcs(8) commands.  Add
	tracing.  Add more argument checking.
	(client_shmmgr::shmdt): Add locking.  Add tracing.  Update the new
	`_shmat_cnt' field.
	(client_shmmgr::shmget): Add tracing.
	(client_shmmgr::fixup_shms_after_fork): Add tracing.  Add
	consistency checking.
	(client_shmmgr::attach): Add more tracing.
	(client_shmmgr::new_segment): Update the new `_shmat_cnt' field.
	(client_request_shm::client_request_shm): Update for the new
	parameter layout.  Set the outgoing message length to the size of
	the `_parameters.in' struct, not of the whole in/out parameter
	union.
@
text
@a17 1
#include <assert.h>
d101 1
a101 1
  int shmctl (int shmid, int cmd, shmid_ds *);
d111 1
a111 3
  static segment_t *_segments_head; // List of attached segs by shmaddr.

  static long _shmat_cnt;	// No. of attached segs; for info. only.
a128 1
/* static */ long client_shmmgr::_shmat_cnt;
a153 5
  syscall_printf ("shmat (shmid = %d, shmaddr = 0x%p, shmflg = 0%o)",
		  shmid, shmaddr, shmflg);

  EnterCriticalSection (&_segments_lock);

a160 8
  LeaveCriticalSection (&_segments_lock);

  if (ptr)
    syscall_printf ("0x%p = shmat (shmid = %d, shmaddr = 0x%p, shmflg = 0%o)",
		    ptr, shmid, shmaddr, shmflg);
  // else
    // See the syscall_printf in client_shmmgr::attach ().

d171 1
a171 1
		       shmid_ds *const buf)
d173 1
a173 48
  syscall_printf ("shmctl (shmid = %d, cmd = 0x%x, buf = 0x%p)",
		  shmid, cmd, buf);

  // Check parameters and set up in parameters as required.

  const shmid_ds *in_buf = NULL;

  switch (cmd)
    {
    case IPC_SET:
      if (__check_invalid_read_ptr_errno (buf, sizeof (shmid_ds)))
	{
	  syscall_printf (("-1 [EFAULT] = "
			   "shmctl (shmid = %d, cmd = 0x%x, buf = 0x%p)"),
			  shmid, cmd, buf);
	  set_errno (EFAULT);
	  return -1;
	}
      in_buf = buf;
      break;

    case IPC_STAT:
    case SHM_STAT:
      if (__check_null_invalid_struct_errno (buf, sizeof (shmid_ds)))
	{
	  syscall_printf (("-1 [EFAULT] = "
			   "shmctl (shmid = %d, cmd = 0x%x, buf = 0x%p)"),
			  shmid, cmd, buf);
	  set_errno (EFAULT);
	  return -1;
	}
      break;

    case IPC_INFO:
      if (__check_null_invalid_struct_errno (buf, sizeof (shminfo)))
	{
	  syscall_printf (("-1 [EFAULT] = "
			   "shmctl (shmid = %d, cmd = 0x%x, buf = 0x%p)"),
			  shmid, cmd, buf);
	  set_errno (EFAULT);
	  return -1;
	}
      break;
    }

  // Create and issue the command.

  client_request_shm request (shmid, cmd, in_buf);
a176 3
      syscall_printf (("-1 [%d] = "
		       "shmctl (shmid = %d, cmd = 0x%x, buf = 0x%p)"),
		      request.error_code (), shmid, cmd, buf);
d181 1
a181 3
  // Some commands require special processing for their out parameters.

  int result = 0;
a187 13

    case IPC_INFO:
      *(shminfo *) buf = request.info ();
      break;

    case SHM_STAT:		// ipcs(8) i'face.
      *buf = request.ds ();
      result = request.shmid ();
      break;

    case SHM_INFO:		// ipcs(8) i'face.
      result = request.shmid ();
      break;
d190 1
a190 4
  syscall_printf ("%d = shmctl (shmid = %d, cmd = 0x%x, buf = 0x%p)",
		  result, shmid, cmd, buf);

  return result;
a204 4
  syscall_printf ("shmdt (shmaddr = 0x%p)", shmaddr);

  EnterCriticalSection (&_segments_lock);

a210 2
      LeaveCriticalSection (&_segments_lock);
      syscall_printf ("-1 [EINVAL] = shmdt (shmaddr = 0x%p)", shmaddr);
a221 5
  LeaveCriticalSection (&_segments_lock);

  const long cnt = InterlockedDecrement (&_shmat_cnt);
  assert (cnt >= 0);

a248 2
  syscall_printf ("0 = shmdt (shmaddr = 0x%p)", shmaddr);

a253 3
 *
 * The `key = 0x%08x%08x' contortions in the tracing statements is
 * because small_printf () doesn't support 64-bit integers.
a258 3
  syscall_printf ("shmget (key = 0x%08x%08x, size = %u, shmflg = 0%o)",
		  (unsigned) (key >> 32), (unsigned) key, size, shmflg);

a262 4
      syscall_printf (("-1 [%d] = "
		       "shmget (key = 0x%08x%08x, size = %u, shmflg = 0%o)"),
		      request.error_code (),
		      (unsigned) (key >> 32), (unsigned) key, size, shmflg);
a266 4
  syscall_printf (("%d = shmget (key = 0x%08x%08x, size = %u, shmflg = 0%o)"),
		  request.shmid (),
		  (unsigned) (key >> 32), (unsigned) key, size, shmflg);

d273 1
a273 4
 * The hFileMap handles are non-inheritable: so they have to be
 * re-acquired from cygserver.
 *
 * Nb. This routine need not be thread-safe as it is only called at startup.
a278 16
  debug_printf ("re-attaching to shm segments: %d attached", _shmat_cnt);

  {
    int length = 0;
    for (segment_t *segptr = _segments_head; segptr; segptr = segptr->next)
      length += 1;

    if (_shmat_cnt != length)
      {
	system_printf (("state inconsistent: "
			"_shmat_cnt = %d, length of segments list = %d"),
		       _shmat_cnt, length);
	return 1;
      }
  }

d285 1
a285 2
	system_printf ("fatal error re-attaching to shm segment %d",
		       segptr->shmid);
a288 3
  if (_shmat_cnt)
    debug_printf ("re-attached all %d shm segments", _shmat_cnt);

a346 3
      syscall_printf (("-1 [%d] = "
		       "shmat (shmid = %d, shmaddr = 0x%p, shmflg = 0%o)"),
		      request.error_code (), shmid, shmaddr, shmflg);
a446 3
  const long cnt = InterlockedIncrement (&_shmat_cnt);
  assert (cnt > 0);

d465 1
a465 1
shmctl (const int shmid, const int cmd, shmid_ds *const buf)
d509 1
a509 1
  _parameters.in.shmid = shmid;
a515 2

  msglen (sizeof (_parameters.in));
d524 1
a524 1
					const shmid_ds *const buf)
d529 3
a531 1
  _parameters.in.shmid = shmid;
a532 2
  if (buf)
    _parameters.in.ds = *buf;
a537 2

  msglen (sizeof (_parameters.in));
d549 1
a549 1
  _parameters.in.shmid = shmid;
a554 2

  msglen (sizeof (_parameters.in));
a575 2

  msglen (sizeof (_parameters.in));
@


1.1.2.16
log
@	* dcrt0.cc: Only check for cygserver if and when required.
	(dll_crt0_1): Remove call to `cygserver_init ()'.
	* fhandler_tty.cc (fhandler_tty_slave::open): Change the cygserver
	logic to allow for the fact that `cygserver_init ()' may not yet
	have been called.
	(fhandler_tty_slave::cygserver_attach_tty): Tweak the cygserver
	request logic to conform to the practice elsewhere in the code.
	* tty.cc (tty::common_init): Add an explicit call to
	`cygserver_init ()' if it hasn't already been called.
	* include/cygwin/cygserver.h (CYGSERVER_UNAVAIL): Rename from
	`CYGSERVER_DEAD'.
	(client_request_get_version::check_version): Make available in
	cygserver as well the DLL.
	(check_cygserver_available): Ditto.  Remove `check_version_too'
	argument.
	(cygserver_init): Ditto.  And likewise.
	* cygserver_client.cc (client_request_get_version::check_version):
	Make available in cygserver as well the DLL.
	(client_request::make_request): This may now be called without
	`cygserver_init ()' having been called first.  Detect this and
	call it as required.  Add tracing.
	(check_cygserver_available): Make available in cygserver as well
	the DLL.  Remove `check_version_too' argument and always check the
	version information.  And since this is called from within
	`cygserver_init ()', force `cygserver_running' before calling
	`client_request::make_request ()'.
	(cygserver_init): Make available in cygserver as well the DLL.
	Remove `check_version_too' argument.
@
text
@a130 5

/* The following two variables must be inherited by child processes
 * since they are used by fixup_shms_after_fork () to re-attach to the
 * parent's shm segments.
 */
@


1.1.2.17
log
@	* msg.cc: New file of stub functions, no functionality.
	* sem.cc: Ditto.
	* shm.cc (client_shmmgr::shmctl): Add support for an out shm_info
	buffer for the SHM_INFO command.
	(client_shmmgr::shmget): Use %X to print keys.
	* include/sys/ipc.h: Comment all fields and values.
	(IPC_PRIVATE): Change to be non-negative.
	* include/sys/msg.h: New file with SUSv3 and ipcs(8) interfaces.
	* include/sys/sem.h: Ditto.
	* include/sys/shm.h: Comment all fields and values.
	(struct shm_info): New struct.
	* cygserver_shm.h (client_request_shm::shminfo): Rename.
	(client_request_shm::shm_info): New method.
	(client_request_shm::_parameters.out.hFileMap): Move into union.
	(client_request_shm::_parameters.out.shminfo): Rename.
	(client_request_shm::_parameters.out.shm_info): New field.
	* cygserver_shm.cc (server_shmmgr::_shm_ids): Rename.
	(server_shmmgr::_shm_tot): New field.
	(server_shmmgr::shmctl): Rename `out_shminfo' argument.  Add
	`out_shm_info' argument.  Fill in the `out_shm_info' argument in
	the SHM_INFO command.
	(server_shmmgr::shmget): Check `shmflg' against the mode of
	existing segments as per Stevens 1990, p. 123.
	(server_shmmgr::server_shmmgr): Initialize the new `_shm_tot'
	field.
	(server_shmmgr::new_segment): Set ENOMEM if CreateFileMapping
	fails.  Pass `size' to new_segment.
	(server_shmmgr::new_segment): Add size argument and use it to
	check against and update the new `_shm_tot' field.
	(server_shmmgr::delete_segment): Update the new `_shm_tot' field.
	* cygwin.din: Add the SysV IPC msg and sem interfaces.
	* Makefile.in (DLL_OFILES): Add new DLL object files.
@
text
@d102 1
a102 1
  int shmctl (int shmid, int cmd, struct shmid_ds *);
d193 1
a193 1
		       struct shmid_ds *const buf)
d200 1
a200 1
  const struct shmid_ds *in_buf = NULL;
d205 1
a205 1
      if (__check_invalid_read_ptr_errno (buf, sizeof (struct shmid_ds)))
d218 1
a218 1
      if (__check_null_invalid_struct_errno (buf, sizeof (struct shmid_ds)))
d229 1
a229 12
      if (__check_null_invalid_struct_errno (buf, sizeof (struct shminfo)))
	{
	  syscall_printf (("-1 [EFAULT] = "
			   "shmctl (shmid = %d, cmd = 0x%x, buf = 0x%p)"),
			  shmid, cmd, buf);
	  set_errno (EFAULT);
	  return -1;
	}
      break;

    case SHM_INFO:
      if (__check_null_invalid_struct_errno (buf, sizeof (struct shm_info)))
d264 1
a264 1
      *(struct shminfo *) buf = request.shminfo ();
d268 1
a269 1
      *buf = request.ds ();
a273 1
      *(struct shm_info *) buf = request.shm_info ();
d357 3
d365 2
a366 2
  syscall_printf ("shmget (key = 0x%016X, size = %u, shmflg = 0%o)",
		  key, size, shmflg);
d373 1
a373 1
		       "shmget (key = 0x%016X, size = %u, shmflg = 0%o)"),
d375 1
a375 1
		      key, size, shmflg);
d380 1
a380 1
  syscall_printf (("%d = shmget (key = 0x%016X, size = %u, shmflg = 0%o)"),
d382 1
a382 1
		  key, size, shmflg);
d611 1
a611 1
shmctl (const int shmid, const int cmd, struct shmid_ds *const buf)
d672 1
a672 1
					const struct shmid_ds *const buf)
@


1.1.2.18
log
@	* cygserver.cc (client_request_shutdown::serve): Don't set the
	shutdown flag directly, but send a SIGINT, as the signal handler
	sets the flag and the signal breaks the pause(2) in the main loop.
	(print_usage): Add new options.
	(main): Add new --cleanup-threads and --request-threads options to
	set the number of threads used by the daemon.  Use pause(2) rather
	the win32 Sleep in the main loop.
	* shm.cc (shmat): Add sigframe.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.
@
text
@a23 1
#include "sigproc.h"
a611 1
  sigframe thisframe (mainthread);
a621 1
  sigframe thisframe (mainthread);
a631 1
  sigframe thisframe (mainthread);
a641 1
  sigframe thisframe (mainthread);
@


1.1.2.19
log
@	* safe_memory.h: New file extracted from "woutsup.h".
	* woutsup.h: Move the "safe" new/delete macros into the new
	"safe_memory.h" header file and include that here.
	* cygserver_client.cc: Explicitly include "safe_memory.h" for
	client-side code.
	(client_request::make_request): Use the "safe" new/delete macros
	unconditionally, i.e. use them on the client side as well as on
	the server side.
	* cygserver_transport.cc: Explicitly include "safe_memory.h" for
	client-side code.
	(create_server_transport): Use the "safe" new/delete macros
	unconditionally, i.e. use them on the client side as well as on
	the server side.
	* shm.cc: Include "safe_memory.h".
	(client_shmmgr::instance): Use the "safe" new/delete macros.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::new_segment): Ditto.
@
text
@a23 1
#include "safe_memory.h"
d148 1
a148 1
    _instance = safe_new0 (client_shmmgr);
d361 1
a361 1
  safe_delete (segment_t, segptr);
d585 1
a585 2
  segment_t *const segptr =
    safe_new (segment_t, shmid, shmaddr, shmflg, hFileMap);
@


1.1.2.20
log
@	* cygserver_shm.cc (with_strerr): Fix use of %p format.
	* shm.cc (client_shmmgr::shmat): Ditto.
	(client_shmmgr::shmctl): Ditto.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::attach): Ditto.
@
text
@d165 1
a165 1
  syscall_printf ("shmat (shmid = %d, shmaddr = %p, shmflg = 0%o)",
d180 1
a180 1
    syscall_printf ("%p = shmat (shmid = %d, shmaddr = %p, shmflg = 0%o)",
d197 1
a197 1
  syscall_printf ("shmctl (shmid = %d, cmd = 0x%x, buf = %p)",
d210 1
a210 1
			   "shmctl (shmid = %d, cmd = 0x%x, buf = %p)"),
d223 1
a223 1
			   "shmctl (shmid = %d, cmd = 0x%x, buf = %p)"),
d234 1
a234 1
			   "shmctl (shmid = %d, cmd = 0x%x, buf = %p)"),
d245 1
a245 1
			   "shmctl (shmid = %d, cmd = 0x%x, buf = %p)"),
d260 1
a260 1
		       "shmctl (shmid = %d, cmd = 0x%x, buf = %p)"),
d291 1
a291 1
  syscall_printf ("%d = shmctl (shmid = %d, cmd = 0x%x, buf = %p)",
d309 1
a309 1
  syscall_printf ("shmdt (shmaddr = %p)", shmaddr);
d320 1
a320 1
      syscall_printf ("-1 [EINVAL] = shmdt (shmaddr = %p)", shmaddr);
d364 1
a364 1
  syscall_printf ("0 = shmdt (shmaddr = %p)", shmaddr);
d499 1
a499 1
		       "shmat (shmid = %d, shmaddr = %p, shmflg = 0%o)"),
@


1.1.2.21
log
@	* safe_memory.h (safe_delete): Make a templated function.
	* cygserver.cc (~server_request): Update use of safe_delete.
	(main): Ditto.
	* cygserver_client.cc (client_request::handle_request): Ditto.
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::remove): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	* cygserver_shm.cc (server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* shm.cc (client_shmmgr::shmdt): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.
@
text
@d362 1
a362 1
  safe_delete (segptr);
@


1.1.2.22
log
@	* cygserver_shm.cc (with_strerr): Remove macro.
	(server_shmmgr::segment_t::~segment_t): Remove calls to with_strerr.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::new_segment): Ditto.
	* shm.cc (with_strerr): Remove macro.
	(client_shmmgr::shmdt): Remove calls to with_strerr.
	(client_shmmgr::attach): Ditto.
@
text
@d31 42
d338 6
a343 4
    syscall_printf (("failed to unmap view "
		     "[shmid = %d, handle = %p, shmaddr = %p]:"
		     "%E"),
		    segptr->shmid, segptr->hFileMap, shmaddr);
d348 6
a353 3
    syscall_printf (("failed to close file map handle "
		     "[shmid = %d, handle = %p]: %E"),
		    segptr->shmid, segptr->hFileMap);
d517 6
a522 3
      syscall_printf (("failed to map view "
		       "[shmid = %d, handle = %p, shmaddr = %p]: %E"),
		      shmid, request.hFileMap (), shmaddr);
d538 6
a543 3
	syscall_printf (("failed to close file map handle "
			 "[shmid = %d, handle = %p]: %E"),
			shmid, request.hFileMap ());
@


