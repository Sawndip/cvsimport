head	1.442;
access;
symbols
	cygwin-1_7_35-release:1.442
	cygwin-1_7_34-release:1.441
	cygwin-1_7_33-release:1.440
	cygwin-1_7_32-release:1.440
	cygwin-1_7_31-release:1.440
	cygwin-1_7_30-release:1.440
	cygwin-1_7_29-release:1.440
	cygwin-1_7_29-release-branchpoint:1.440.0.2
	cygwin-pre-user-db:1.440
	cygwin-1_7_28-release:1.440
	cygwin-1_7_27-release:1.440
	cygwin-1_7_26-release:1.440
	cygwin-1_7_25-release:1.435
	cygwin-1_7_24-release:1.435
	cygwin-1_7_23-release:1.435
	cygwin-1_7_22-release:1.435
	cygwin-1_7_21-release:1.435
	cygwin-1_7_20-release:1.434
	cygwin-1_7_19-release:1.434
	cygwin-64bit-postmerge:1.432
	cygwin-64bit-premerge-branch:1.431.0.2
	cygwin-64bit-premerge:1.431
	cygwin-1_7_18-release:1.431
	post-ptmalloc3:1.428.2.9
	pre-ptmalloc3:1.428.2.9
	cygwin-1_7_17-release:1.429
	cygwin-64bit-branch:1.428.0.2
	cygwin-1_7_16-release:1.428
	cygwin-1_7_15-release:1.427
	cygwin-1_7_14_2-release:1.427
	cygwin-1_7_14-release:1.427
	cygwin-1_7_12-release:1.427
	cygwin-1_7_11-release:1.424
	cygwin-1_7_10-release:1.424
	signal-rewrite:1.398.0.2
	pre-notty:1.392
	cygwin-1_7_9-release:1.380
	cv-post-1_7_9:1.379.0.2
	cygwin-1_7_8-release:1.375
	cygwin-1_7_7-release:1.369
	cygwin-1_7_5-release:1.366
	cygwin-1_7_4-release:1.366
	cygwin-1_7_3-release:1.366
	cygwin-1_7_2-release:1.362
	fifo_doover3:1.359.0.2
	cygwin-1_7_1-release:1.358
	prefifo:1.351
	cv-branch-2:1.342.0.2
	pre-ripout-set_console_state_for_spawn:1.325
	EOL_registry_mounts:1.319
	preoverlapped:1.290
	drop_9x_support_start:1.276
	cr-0x5f1:1.256.0.2
	cv-branch:1.255.0.2
	pre-ptymaster-archetype:1.253
	cr-0x3b58:1.248.0.4
	cr-0x5ef:1.248.0.2
	after-mmap-privanon-noreserve:1.245
	after-mmap-revamp:1.245
	before-mmap-revamp:1.245
	cgf-more-exit-sync:1.244
	post_wait_sig_exit:1.242
	pre_wait_sig_exit:1.241
	reparent-point:1.206
	noreparent:1.206.0.2
	cr-0x5e6:1.194.0.2
	cr-0x9e:1.168.0.6
	cr-0x9d:1.168.0.4
	cgf-deleteme:1.168.0.2
	pre-sigrewrite:1.163
	corinna-01:1.161
	cr-0x9c:1.156.0.4
	cr-0x9b:1.156.0.2
	cr-0x99:1.155
	Z-emcb-cygwin_daemon:1.154.0.2
	w32api-2_2:1.143
	mingw-runtime-2_4:1.143
	pre-cgf-merge:1.157
	cgf-dev-branch:1.143.0.6
	predaemon:1.113
	cygwin_daemon_merge_HEAD:1.113
	pregp02r1:1.112.0.2
	cygnus_cvs_20020108_pre:1.109
	Z-cygwin_daemon_merge-new_HEAD:1.137
	Z-cygwin_daemon_merge_HEAD:1.137
	cygwin_daemon:1.87.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.442
date	2015.02.24.11.05.02;	author corinna;	state Exp;
branches;
next	1.441;

1.441
date	2014.08.28.12.38.51;	author corinna;	state Exp;
branches;
next	1.440;

1.440
date	2013.10.31.14.26.42;	author corinna;	state Exp;
branches;
next	1.439;

1.439
date	2013.10.24.15.26.21;	author cgf;	state Exp;
branches;
next	1.438;

1.438
date	2013.10.24.09.41.16;	author corinna;	state Exp;
branches;
next	1.437;

1.437
date	2013.10.23.09.58.12;	author corinna;	state Exp;
branches;
next	1.436;

1.436
date	2013.10.22.20.41.09;	author cgf;	state Exp;
branches;
next	1.435;

1.435
date	2013.07.03.20.26.44;	author cgf;	state Exp;
branches;
next	1.434;

1.434
date	2013.06.04.10.24.42;	author corinna;	state Exp;
branches;
next	1.433;

1.433
date	2013.05.01.01.20.36;	author yselkowitz;	state Exp;
branches;
next	1.432;

1.432
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.431;

1.431
date	2013.01.21.04.34.50;	author cgf;	state Exp;
branches;
next	1.430;

1.430
date	2012.12.14.10.45.27;	author corinna;	state Exp;
branches;
next	1.429;

1.429
date	2012.08.16.23.34.43;	author cgf;	state Exp;
branches;
next	1.428;

1.428
date	2012.06.17.20.50.23;	author cgf;	state Exp;
branches
	1.428.2.1;
next	1.427;

1.427
date	2012.03.12.21.29.36;	author cgf;	state Exp;
branches;
next	1.426;

1.426
date	2012.03.08.09.36.11;	author corinna;	state Exp;
branches;
next	1.425;

1.425
date	2012.02.28.14.03.01;	author ericb;	state Exp;
branches;
next	1.424;

1.424
date	2012.02.01.05.27.42;	author cgf;	state Exp;
branches;
next	1.423;

1.423
date	2012.01.31.23.52.51;	author cgf;	state Exp;
branches;
next	1.422;

1.422
date	2012.01.22.06.45.07;	author cgf;	state Exp;
branches;
next	1.421;

1.421
date	2011.12.21.18.34.57;	author cgf;	state Exp;
branches;
next	1.420;

1.420
date	2011.12.18.04.07.47;	author cgf;	state Exp;
branches;
next	1.419;

1.419
date	2011.12.17.07.01.20;	author cgf;	state Exp;
branches;
next	1.418;

1.418
date	2011.12.17.00.03.31;	author cgf;	state Exp;
branches;
next	1.417;

1.417
date	2011.12.16.16.29.34;	author cgf;	state Exp;
branches;
next	1.416;

1.416
date	2011.12.16.05.27.14;	author cgf;	state Exp;
branches;
next	1.415;

1.415
date	2011.12.13.04.11.45;	author cgf;	state Exp;
branches;
next	1.414;

1.414
date	2011.12.09.16.02.55;	author cgf;	state Exp;
branches;
next	1.413;

1.413
date	2011.12.04.17.58.24;	author cgf;	state Exp;
branches;
next	1.412;

1.412
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.411;

1.411
date	2011.12.03.20.35.36;	author corinna;	state Exp;
branches;
next	1.410;

1.410
date	2011.12.03.14.21.30;	author corinna;	state Exp;
branches;
next	1.409;

1.409
date	2011.11.29.15.34.48;	author cgf;	state Exp;
branches;
next	1.408;

1.408
date	2011.11.07.20.05.48;	author cgf;	state Exp;
branches;
next	1.407;

1.407
date	2011.11.07.10.06.45;	author corinna;	state Exp;
branches;
next	1.406;

1.406
date	2011.11.03.17.47.33;	author corinna;	state Exp;
branches;
next	1.405;

1.405
date	2011.10.30.04.50.35;	author cgf;	state Exp;
branches;
next	1.404;

1.404
date	2011.10.22.16.26.26;	author cgf;	state Exp;
branches;
next	1.403;

1.403
date	2011.10.20.14.02.54;	author cgf;	state Exp;
branches;
next	1.402;

1.402
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.401;

1.401
date	2011.10.11.23.20.38;	author cgf;	state Exp;
branches;
next	1.400;

1.400
date	2011.08.27.20.01.29;	author corinna;	state Exp;
branches;
next	1.399;

1.399
date	2011.08.25.13.35.43;	author corinna;	state Exp;
branches;
next	1.398;

1.398
date	2011.07.21.20.21.46;	author cgf;	state Exp;
branches;
next	1.397;

1.397
date	2011.07.05.12.02.10;	author corinna;	state Exp;
branches;
next	1.396;

1.396
date	2011.07.05.09.59.34;	author corinna;	state Exp;
branches;
next	1.395;

1.395
date	2011.07.04.05.08.28;	author cgf;	state Exp;
branches;
next	1.394;

1.394
date	2011.07.01.11.23.43;	author corinna;	state Exp;
branches;
next	1.393;

1.393
date	2011.06.17.11.04.44;	author corinna;	state Exp;
branches;
next	1.392;

1.392
date	2011.06.04.00.12.25;	author cgf;	state Exp;
branches;
next	1.391;

1.391
date	2011.05.31.00.26.37;	author cgf;	state Exp;
branches;
next	1.390;

1.390
date	2011.05.30.17.16.24;	author cgf;	state Exp;
branches;
next	1.389;

1.389
date	2011.05.29.15.30.27;	author cgf;	state Exp;
branches;
next	1.388;

1.388
date	2011.05.28.18.49.13;	author cgf;	state Exp;
branches;
next	1.387;

1.387
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.386;

1.386
date	2011.05.06.20.12.20;	author cgf;	state Exp;
branches;
next	1.385;

1.385
date	2011.05.05.22.30.53;	author cgf;	state Exp;
branches;
next	1.384;

1.384
date	2011.05.05.17.44.42;	author cgf;	state Exp;
branches;
next	1.383;

1.383
date	2011.05.05.09.05.04;	author corinna;	state Exp;
branches;
next	1.382;

1.382
date	2011.05.03.10.11.19;	author corinna;	state Exp;
branches;
next	1.381;

1.381
date	2011.04.29.08.27.10;	author corinna;	state Exp;
branches;
next	1.380;

1.380
date	2011.03.13.20.20.57;	author cgf;	state Exp;
branches;
next	1.379;

1.379
date	2011.03.09.22.48.05;	author cgf;	state Exp;
branches
	1.379.2.1;
next	1.378;

1.378
date	2011.03.09.16.55.54;	author cgf;	state Exp;
branches;
next	1.377;

1.377
date	2011.03.09.16.47.44;	author cgf;	state Exp;
branches;
next	1.376;

1.376
date	2011.03.08.14.26.14;	author corinna;	state Exp;
branches;
next	1.375;

1.375
date	2011.02.21.03.18.30;	author cgf;	state Exp;
branches;
next	1.374;

1.374
date	2011.02.15.15.56.00;	author corinna;	state Exp;
branches;
next	1.373;

1.373
date	2011.02.01.08.46.48;	author corinna;	state Exp;
branches;
next	1.372;

1.372
date	2010.09.30.13.52.33;	author corinna;	state Exp;
branches;
next	1.371;

1.371
date	2010.09.24.16.22.52;	author corinna;	state Exp;
branches;
next	1.370;

1.370
date	2010.09.21.16.07.19;	author corinna;	state Exp;
branches;
next	1.369;

1.369
date	2010.07.23.10.08.34;	author corinna;	state Exp;
branches;
next	1.368;

1.368
date	2010.07.05.16.59.55;	author corinna;	state Exp;
branches;
next	1.367;

1.367
date	2010.06.15.12.05.14;	author corinna;	state Exp;
branches;
next	1.366;

1.366
date	2010.04.02.18.54.58;	author cgf;	state Exp;
branches;
next	1.365;

1.365
date	2010.03.31.04.26.11;	author cgf;	state Exp;
branches;
next	1.364;

1.364
date	2010.03.29.15.02.50;	author corinna;	state Exp;
branches;
next	1.363;

1.363
date	2010.03.28.17.49.35;	author cgf;	state Exp;
branches;
next	1.362;

1.362
date	2010.02.18.15.07.38;	author cgf;	state Exp;
branches;
next	1.361;

1.361
date	2010.02.15.01.45.05;	author cgf;	state Exp;
branches;
next	1.360;

1.360
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.359;

1.359
date	2009.12.18.20.32.03;	author corinna;	state Exp;
branches;
next	1.358;

1.358
date	2009.10.30.19.58.52;	author corinna;	state Exp;
branches;
next	1.357;

1.357
date	2009.10.24.08.40.15;	author corinna;	state Exp;
branches;
next	1.356;

1.356
date	2009.10.24.08.26.01;	author corinna;	state Exp;
branches;
next	1.355;

1.355
date	2009.09.26.15.51.53;	author ericb;	state Exp;
branches;
next	1.354;

1.354
date	2009.09.25.13.44.45;	author ericb;	state Exp;
branches;
next	1.353;

1.353
date	2009.08.26.19.37.34;	author corinna;	state Exp;
branches;
next	1.352;

1.352
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.351;

1.351
date	2009.07.22.15.46.36;	author corinna;	state Exp;
branches;
next	1.350;

1.350
date	2009.07.03.18.05.50;	author cgf;	state Exp;
branches;
next	1.349;

1.349
date	2009.06.30.14.36.11;	author cgf;	state Exp;
branches;
next	1.348;

1.348
date	2009.06.28.19.23.13;	author cgf;	state Exp;
branches;
next	1.347;

1.347
date	2009.06.28.18.23.35;	author cgf;	state Exp;
branches;
next	1.346;

1.346
date	2009.06.16.20.33.45;	author cgf;	state Exp;
branches;
next	1.345;

1.345
date	2009.06.16.19.05.43;	author cgf;	state Exp;
branches;
next	1.344;

1.344
date	2009.06.14.23.42.08;	author cgf;	state Exp;
branches;
next	1.343;

1.343
date	2009.06.14.05.38.55;	author cgf;	state Exp;
branches;
next	1.342;

1.342
date	2009.05.04.09.16.42;	author corinna;	state Exp;
branches;
next	1.341;

1.341
date	2009.01.27.05.21.08;	author cgf;	state Exp;
branches;
next	1.340;

1.340
date	2008.12.23.18.22.32;	author cgf;	state Exp;
branches;
next	1.339;

1.339
date	2008.12.20.19.20.00;	author cgf;	state Exp;
branches;
next	1.338;

1.338
date	2008.11.26.17.21.03;	author cgf;	state Exp;
branches;
next	1.337;

1.337
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.336;

1.336
date	2008.08.25.17.27.06;	author cgf;	state Exp;
branches;
next	1.335;

1.335
date	2008.08.22.04.06.01;	author cgf;	state Exp;
branches;
next	1.334;

1.334
date	2008.08.20.02.25.06;	author cgf;	state Exp;
branches;
next	1.333;

1.333
date	2008.08.19.02.56.28;	author cgf;	state Exp;
branches;
next	1.332;

1.332
date	2008.08.14.14.05.04;	author corinna;	state Exp;
branches;
next	1.331;

1.331
date	2008.08.07.16.20.03;	author corinna;	state Exp;
branches;
next	1.330;

1.330
date	2008.07.18.12.21.22;	author corinna;	state Exp;
branches;
next	1.329;

1.329
date	2008.07.18.08.16.40;	author corinna;	state Exp;
branches;
next	1.328;

1.328
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.327;

1.327
date	2008.07.14.20.46.27;	author corinna;	state Exp;
branches;
next	1.326;

1.326
date	2008.07.14.20.22.02;	author corinna;	state Exp;
branches;
next	1.325;

1.325
date	2008.05.20.15.11.20;	author corinna;	state Exp;
branches;
next	1.324;

1.324
date	2008.04.25.16.59.41;	author corinna;	state Exp;
branches;
next	1.323;

1.323
date	2008.04.25.16.50.29;	author corinna;	state Exp;
branches;
next	1.322;

1.322
date	2008.04.25.16.33.01;	author corinna;	state Exp;
branches;
next	1.321;

1.321
date	2008.04.24.09.59.54;	author corinna;	state Exp;
branches;
next	1.320;

1.320
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.319;

1.319
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.318;

1.318
date	2008.04.01.10.22.33;	author corinna;	state Exp;
branches;
next	1.317;

1.317
date	2008.03.31.18.03.25;	author corinna;	state Exp;
branches;
next	1.316;

1.316
date	2008.03.24.14.48.58;	author corinna;	state Exp;
branches;
next	1.315;

1.315
date	2008.03.08.01.33.22;	author briand;	state Exp;
branches;
next	1.314;

1.314
date	2008.03.06.10.16.07;	author corinna;	state Exp;
branches;
next	1.313;

1.313
date	2008.03.06.10.01.33;	author corinna;	state Exp;
branches;
next	1.312;

1.312
date	2008.03.05.18.31.09;	author corinna;	state Exp;
branches;
next	1.311;

1.311
date	2008.02.16.09.43.19;	author corinna;	state Exp;
branches;
next	1.310;

1.310
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.309;

1.309
date	2008.02.10.15.43.04;	author corinna;	state Exp;
branches;
next	1.308;

1.308
date	2007.12.16.21.21.23;	author cgf;	state Exp;
branches;
next	1.307;

1.307
date	2007.11.08.14.37.59;	author cgf;	state Exp;
branches;
next	1.306;

1.306
date	2007.11.08.14.36.49;	author cgf;	state Exp;
branches;
next	1.305;

1.305
date	2007.10.30.12.32.16;	author corinna;	state Exp;
branches;
next	1.304;

1.304
date	2007.10.18.12.40.27;	author corinna;	state Exp;
branches;
next	1.303;

1.303
date	2007.10.15.08.25.38;	author corinna;	state Exp;
branches;
next	1.302;

1.302
date	2007.09.17.16.48.14;	author corinna;	state Exp;
branches;
next	1.301;

1.301
date	2007.08.20.15.16.27;	author corinna;	state Exp;
branches;
next	1.300;

1.300
date	2007.08.13.15.08.25;	author corinna;	state Exp;
branches;
next	1.299;

1.299
date	2007.08.12.15.42.02;	author corinna;	state Exp;
branches;
next	1.298;

1.298
date	2007.08.01.08.36.38;	author corinna;	state Exp;
branches;
next	1.297;

1.297
date	2007.07.29.17.24.54;	author cgf;	state Exp;
branches;
next	1.296;

1.296
date	2007.07.29.05.22.05;	author cgf;	state Exp;
branches;
next	1.295;

1.295
date	2007.07.27.08.38.00;	author corinna;	state Exp;
branches;
next	1.294;

1.294
date	2007.07.20.14.29.43;	author corinna;	state Exp;
branches;
next	1.293;

1.293
date	2007.07.19.11.41.16;	author corinna;	state Exp;
branches;
next	1.292;

1.292
date	2007.07.17.14.39.02;	author corinna;	state Exp;
branches;
next	1.291;

1.291
date	2007.07.07.17.00.33;	author cgf;	state Exp;
branches;
next	1.290;

1.290
date	2007.06.29.15.13.00;	author corinna;	state Exp;
branches;
next	1.289;

1.289
date	2007.06.12.08.28.44;	author corinna;	state Exp;
branches;
next	1.288;

1.288
date	2007.05.29.17.25.36;	author corinna;	state Exp;
branches;
next	1.287;

1.287
date	2007.03.06.14.48.24;	author corinna;	state Exp;
branches;
next	1.286;

1.286
date	2007.03.01.15.13.47;	author cgf;	state Exp;
branches;
next	1.285;

1.285
date	2007.02.27.12.58.55;	author corinna;	state Exp;
branches;
next	1.284;

1.284
date	2007.02.26.14.19.00;	author corinna;	state Exp;
branches;
next	1.283;

1.283
date	2007.02.23.15.15.49;	author corinna;	state Exp;
branches;
next	1.282;

1.282
date	2007.02.23.14.20.28;	author corinna;	state Exp;
branches;
next	1.281;

1.281
date	2007.02.23.09.49.49;	author corinna;	state Exp;
branches;
next	1.280;

1.280
date	2007.02.22.17.09.46;	author corinna;	state Exp;
branches;
next	1.279;

1.279
date	2007.02.22.16.22.38;	author corinna;	state Exp;
branches;
next	1.278;

1.278
date	2007.02.22.11.17.01;	author corinna;	state Exp;
branches;
next	1.277;

1.277
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.276;

1.276
date	2007.02.20.00.16.14;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2007.02.07.17.22.40;	author corinna;	state Exp;
branches;
next	1.274;

1.274
date	2007.01.04.09.17.55;	author corinna;	state Exp;
branches;
next	1.273;

1.273
date	2006.12.11.18.55.28;	author cgf;	state Exp;
branches;
next	1.272;

1.272
date	2006.12.11.09.07.22;	author corinna;	state Exp;
branches;
next	1.271;

1.271
date	2006.12.10.16.20.43;	author corinna;	state Exp;
branches;
next	1.270;

1.270
date	2006.12.10.16.18.51;	author corinna;	state Exp;
branches;
next	1.269;

1.269
date	2006.12.10.12.56.50;	author corinna;	state Exp;
branches;
next	1.268;

1.268
date	2006.11.28.09.57.01;	author corinna;	state Exp;
branches;
next	1.267;

1.267
date	2006.11.27.19.14.24;	author corinna;	state Exp;
branches;
next	1.266;

1.266
date	2006.11.07.17.59.54;	author corinna;	state Exp;
branches;
next	1.265;

1.265
date	2006.10.22.19.31.33;	author corinna;	state Exp;
branches;
next	1.264;

1.264
date	2006.10.22.09.38.47;	author corinna;	state Exp;
branches;
next	1.263;

1.263
date	2006.10.21.11.05.32;	author corinna;	state Exp;
branches;
next	1.262;

1.262
date	2006.10.16.12.26.59;	author corinna;	state Exp;
branches;
next	1.261;

1.261
date	2006.08.10.14.16.24;	author cgf;	state Exp;
branches;
next	1.260;

1.260
date	2006.08.10.14.15.00;	author cgf;	state Exp;
branches;
next	1.259;

1.259
date	2006.08.07.19.29.14;	author corinna;	state Exp;
branches;
next	1.258;

1.258
date	2006.07.27.03.32.51;	author cgf;	state Exp;
branches;
next	1.257;

1.257
date	2006.07.25.19.23.23;	author corinna;	state Exp;
branches;
next	1.256;

1.256
date	2006.07.13.20.56.24;	author cgf;	state Exp;
branches
	1.256.2.1;
next	1.255;

1.255
date	2006.07.03.18.30.08;	author corinna;	state Exp;
branches
	1.255.2.1;
next	1.254;

1.254
date	2006.06.02.15.41.34;	author cgf;	state Exp;
branches;
next	1.253;

1.253
date	2006.05.25.05.40.51;	author cgf;	state Exp;
branches;
next	1.252;

1.252
date	2006.05.24.03.43.54;	author cgf;	state Exp;
branches;
next	1.251;

1.251
date	2006.03.22.16.42.44;	author cgf;	state Exp;
branches;
next	1.250;

1.250
date	2006.02.22.16.40.42;	author corinna;	state Exp;
branches;
next	1.249;

1.249
date	2006.01.26.16.58.53;	author corinna;	state Exp;
branches;
next	1.248;

1.248
date	2005.12.29.20.46.34;	author cgf;	state Exp;
branches;
next	1.247;

1.247
date	2005.12.14.16.38.22;	author corinna;	state Exp;
branches;
next	1.246;

1.246
date	2005.12.14.15.54.33;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2005.11.08.23.25.55;	author cgf;	state Exp;
branches;
next	1.244;

1.244
date	2005.09.28.19.22.21;	author corinna;	state Exp;
branches;
next	1.243;

1.243
date	2005.09.28.19.02.48;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2005.09.13.17.08.53;	author cgf;	state Exp;
branches;
next	1.241;

1.241
date	2005.08.20.06.19.54;	author cgf;	state Exp;
branches;
next	1.240;

1.240
date	2005.07.29.17.04.44;	author cgf;	state Exp;
branches;
next	1.239;

1.239
date	2005.07.06.20.05.00;	author cgf;	state Exp;
branches;
next	1.238;

1.238
date	2005.07.05.03.16.43;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2005.06.30.17.00.10;	author corinna;	state Exp;
branches;
next	1.236;

1.236
date	2005.06.24.09.12.15;	author corinna;	state Exp;
branches;
next	1.235;

1.235
date	2005.06.07.18.41.31;	author cgf;	state Exp;
branches;
next	1.234;

1.234
date	2005.05.25.04.32.58;	author cgf;	state Exp;
branches;
next	1.233;

1.233
date	2005.04.28.03.41.09;	author cgf;	state Exp;
branches;
next	1.232;

1.232
date	2005.04.22.13.58.05;	author cgf;	state Exp;
branches;
next	1.231;

1.231
date	2005.04.16.05.20.00;	author cgf;	state Exp;
branches;
next	1.230;

1.230
date	2005.04.13.16.41.30;	author corinna;	state Exp;
branches;
next	1.229;

1.229
date	2005.04.13.16.17.36;	author cgf;	state Exp;
branches;
next	1.228;

1.228
date	2005.04.12.14.26.30;	author corinna;	state Exp;
branches;
next	1.227;

1.227
date	2005.04.04.10.26.34;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2005.03.04.13.54.59;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2005.02.23.12.30.31;	author corinna;	state Exp;
branches;
next	1.224;

1.224
date	2005.02.22.15.30.07;	author corinna;	state Exp;
branches;
next	1.223;

1.223
date	2005.02.20.13.28.23;	author corinna;	state Exp;
branches;
next	1.222;

1.222
date	2005.02.20.11.44.31;	author corinna;	state Exp;
branches;
next	1.221;

1.221
date	2005.02.19.21.53.36;	author corinna;	state Exp;
branches;
next	1.220;

1.220
date	2005.02.11.15.37.26;	author corinna;	state Exp;
branches;
next	1.219;

1.219
date	2005.02.11.15.24.15;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2005.02.06.05.04.34;	author cgf;	state Exp;
branches;
next	1.217;

1.217
date	2005.02.02.22.42.05;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2005.02.01.15.11.40;	author corinna;	state Exp;
branches;
next	1.215;

1.215
date	2005.01.31.21.29.59;	author cgf;	state Exp;
branches;
next	1.214;

1.214
date	2005.01.31.10.28.51;	author corinna;	state Exp;
branches;
next	1.213;

1.213
date	2005.01.14.22.03.39;	author corinna;	state Exp;
branches;
next	1.212;

1.212
date	2004.12.26.02.10.29;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2004.12.23.21.37.43;	author cgf;	state Exp;
branches;
next	1.210;

1.210
date	2004.12.12.02.15.34;	author bavag;	state Exp;
branches;
next	1.209;

1.209
date	2004.12.05.07.28.27;	author bavag;	state Exp;
branches;
next	1.208;

1.208
date	2004.12.05.01.53.47;	author bavag;	state Exp;
branches;
next	1.207;

1.207
date	2004.11.20.23.42.36;	author phumblet;	state Exp;
branches;
next	1.206;

1.206
date	2004.09.12.03.47.56;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2004.09.10.08.34.37;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2004.08.28.15.46.57;	author corinna;	state Exp;
branches;
next	1.203;

1.203
date	2004.08.19.15.47.51;	author corinna;	state Exp;
branches;
next	1.202;

1.202
date	2004.08.14.03.01.21;	author phumblet;	state Exp;
branches;
next	1.201;

1.201
date	2004.06.17.15.25.09;	author corinna;	state Exp;
branches;
next	1.200;

1.200
date	2004.06.17.13.34.24;	author phumblet;	state Exp;
branches;
next	1.199;

1.199
date	2004.06.17.07.03.09;	author corinna;	state Exp;
branches;
next	1.198;

1.198
date	2004.06.03.22.27.25;	author cgf;	state Exp;
branches;
next	1.197;

1.197
date	2004.06.03.21.33.29;	author cgf;	state Exp;
branches;
next	1.196;

1.196
date	2004.06.03.21.29.43;	author cgf;	state Exp;
branches;
next	1.195;

1.195
date	2004.05.28.19.50.05;	author cgf;	state Exp;
branches;
next	1.194;

1.194
date	2004.05.11.15.39.50;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2004.04.30.17.36.36;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2004.04.30.14.02.37;	author corinna;	state Exp;
branches;
next	1.191;

1.191
date	2004.04.21.08.16.13;	author corinna;	state Exp;
branches;
next	1.190;

1.190
date	2004.04.20.15.51.24;	author corinna;	state Exp;
branches;
next	1.189;

1.189
date	2004.04.20.11.01.21;	author corinna;	state Exp;
branches;
next	1.188;

1.188
date	2004.04.20.10.24.37;	author corinna;	state Exp;
branches;
next	1.187;

1.187
date	2004.04.19.19.29.10;	author corinna;	state Exp;
branches;
next	1.186;

1.186
date	2004.04.16.21.22.13;	author corinna;	state Exp;
branches;
next	1.185;

1.185
date	2004.04.14.16.36.26;	author corinna;	state Exp;
branches;
next	1.184;

1.184
date	2004.04.14.13.40.07;	author corinna;	state Exp;
branches;
next	1.183;

1.183
date	2004.04.13.20.36.58;	author corinna;	state Exp;
branches;
next	1.182;

1.182
date	2004.04.10.19.24.55;	author corinna;	state Exp;
branches;
next	1.181;

1.181
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2004.04.09.08.43.28;	author corinna;	state Exp;
branches;
next	1.179;

1.179
date	2004.04.08.07.57.28;	author corinna;	state Exp;
branches;
next	1.178;

1.178
date	2004.03.23.18.52.39;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2004.02.17.20.03.01;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2004.02.09.04.04.22;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2004.02.02.20.33.09;	author cgf;	state Exp;
branches;
next	1.174;

1.174
date	2004.01.25.23.39.26;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2004.01.24.20.34.27;	author cgf;	state Exp;
branches;
next	1.172;

1.172
date	2004.01.24.03.40.33;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2004.01.23.23.05.32;	author cgf;	state Exp;
branches;
next	1.170;

1.170
date	2004.01.22.15.08.08;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2004.01.21.18.19.29;	author cgf;	state Exp;
branches;
next	1.168;

1.168
date	2003.12.15.04.16.41;	author cgf;	state Exp;
branches
	1.168.6.1;
next	1.167;

1.167
date	2003.12.11.06.12.41;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2003.12.03.16.35.52;	author corinna;	state Exp;
branches;
next	1.165;

1.165
date	2003.12.01.17.26.28;	author corinna;	state Exp;
branches;
next	1.164;

1.164
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2003.11.26.13.23.27;	author corinna;	state Exp;
branches;
next	1.162;

1.162
date	2003.11.17.22.18.42;	author corinna;	state Exp;
branches;
next	1.161;

1.161
date	2003.10.25.12.32.56;	author corinna;	state Exp;
branches;
next	1.160;

1.160
date	2003.10.24.12.11.20;	author corinna;	state Exp;
branches;
next	1.159;

1.159
date	2003.09.30.21.46.08;	author corinna;	state Exp;
branches;
next	1.158;

1.158
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2003.09.14.01.58.03;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2003.09.07.02.22.58;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2003.09.01.02.05.32;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2003.08.05.04.49.44;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2003.07.28.21.13.17;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2003.07.09.01.33.06;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2003.06.06.08.11.18;	author corinna;	state Exp;
branches;
next	1.149;

1.149
date	2003.06.02.14.07.48;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2003.05.26.15.43.54;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2003.05.26.09.54.01;	author corinna;	state Exp;
branches;
next	1.146;

1.146
date	2003.04.01.17.17.46;	author corinna;	state Exp;
branches;
next	1.145;

1.145
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.144;

1.144
date	2003.02.21.04.33.53;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2002.12.20.01.48.22;	author phumblet;	state Exp;
branches
	1.143.4.1
	1.143.6.1;
next	1.142;

1.142
date	2002.12.14.19.11.42;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2002.12.14.18.01.08;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2002.12.14.04.01.32;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2002.11.01.01.47.29;	author phumblet;	state Exp;
branches;
next	1.138;

1.138
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2002.09.19.15.12.48;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2002.08.30.15.47.09;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2002.07.14.19.15.32;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2002.07.13.20.00.25;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2002.07.03.18.02.53;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2002.06.24.02.23.14;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2002.06.20.00.36.40;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2002.06.06.15.35.06;	author corinna;	state Exp;
branches;
next	1.127;

1.127
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2002.06.04.01.40.53;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2002.06.02.03.13.22;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2002.06.01.02.31.53;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2002.05.31.22.53.25;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2002.05.31.20.48.14;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2002.05.31.00.15.22;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2002.05.24.05.44.10;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2002.05.17.19.30.52;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2002.05.02.04.13.45;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2002.04.09.13.01.00;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2002.02.25.17.47.46;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2002.02.19.22.06.50;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2002.02.10.13.38.48;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2002.01.14.20.39.59;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2001.11.24.03.11.39;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2001.11.22.05.59.07;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2001.11.21.06.47.57;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2001.11.14.21.47.41;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2001.11.13.21.49.06;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2001.11.05.06.09.07;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2001.11.03.05.42.21;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2001.11.01.21.15.53;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2001.10.31.02.03.00;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2001.10.29.20.30.47;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2001.10.24.04.16.45;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2001.10.22.21.09.41;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2001.10.22.18.39.21;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2001.10.16.16.58.28;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2001.10.15.23.39.32;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2001.10.14.04.14.23;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2001.10.09.16.54.18;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2001.10.06.01.04.24;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2001.10.05.04.21.41;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2001.09.22.21.44.07;	author cgf;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2001.09.22.16.55.02;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2001.09.20.20.58.29;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2001.09.20.08.02.00;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2001.09.06.03.39.18;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2001.09.01.05.17.34;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2001.08.15.07.49.15;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2001.08.14.07.41.45;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2001.08.07.15.09.54;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2001.08.07.00.01.42;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2001.07.21.03.20.01;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.26.21.03.08;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.24.22.26.50;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.20.07.44.33;	author duda;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.15.00.21.06;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.14.18.21.17;	author duda;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.05.09.21.39;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2001.05.31.19.58.59;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2001.05.31.05.25.46;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2001.04.24.02.07.57;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2001.04.13.15.28.20;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2001.04.12.21.21.37;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2001.04.02.14.35.17;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2001.03.31.21.24.48;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2001.03.13.13.07.15;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2001.02.22.14.51.16;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2001.02.22.11.06.25;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2001.02.21.22.59.11;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2001.02.21.21.49.36;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2001.02.05.16.10.06;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2000.12.19.19.52.57;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2000.11.28.18.45.42;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2000.11.26.21.45.16;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2000.11.03.04.27.01;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2000.10.31.23.14.29;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2000.10.25.08.47.23;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2000.10.24.18.15.25;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2000.10.23.20.29.31;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2000.10.23.20.16.52;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.23.03.35.50;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.20.21.45.50;	author dj;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.12.04.38.29;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.07.18.12.11;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.07.16.23.50;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.24.17.54.43;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.10.19.33.54;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.10.19.20.11;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.27.14.26.03;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.17.19.18.21;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.09.16.21.55;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.09.05.29.51;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.01.03.51.55;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.18.17.43.45;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.08.13.56.28;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.31.14.43.23;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.09.21.55.11;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.08.16.13.54;	author dj;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.07.03.29.08;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.25.16.31.14;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.20.04.38.10;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.08.04.47.15;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.17.17.22.53;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.16.19.35.18;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.15.04.49.36;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.12.06.29.54;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.07.05.33.09;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.26.01.13.02;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.26.01.11.54;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.21.23.38.57;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.00.31.55;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.428.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.428.2.2;

1.428.2.2
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.428.2.3;

1.428.2.3
date	2012.10.30.17.52.12;	author corinna;	state Exp;
branches;
next	1.428.2.4;

1.428.2.4
date	2012.10.31.17.00.07;	author corinna;	state Exp;
branches;
next	1.428.2.5;

1.428.2.5
date	2012.11.16.09.41.12;	author corinna;	state Exp;
branches;
next	1.428.2.6;

1.428.2.6
date	2012.12.10.11.45.46;	author corinna;	state Exp;
branches;
next	1.428.2.7;

1.428.2.7
date	2012.12.14.10.45.37;	author corinna;	state Exp;
branches;
next	1.428.2.8;

1.428.2.8
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.428.2.9;

1.428.2.9
date	2013.02.18.11.38.26;	author corinna;	state Exp;
branches;
next	1.428.2.10;

1.428.2.10
date	2013.03.11.16.30.36;	author corinna;	state Exp;
branches;
next	1.428.2.11;

1.428.2.11
date	2013.03.14.12.09.51;	author corinna;	state Exp;
branches;
next	1.428.2.12;

1.428.2.12
date	2013.04.12.17.17.00;	author corinna;	state Exp;
branches;
next	;

1.379.2.1
date	2011.03.14.09.32.04;	author corinna;	state Exp;
branches;
next	;

1.256.2.1
date	2006.10.16.12.46.34;	author corinna;	state Exp;
branches;
next	1.256.2.2;

1.256.2.2
date	2006.11.29.13.23.24;	author corinna;	state Exp;
branches;
next	1.256.2.3;

1.256.2.3
date	2007.01.15.11.56.06;	author corinna;	state Exp;
branches;
next	1.256.2.4;

1.256.2.4
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	1.256.2.5;

1.256.2.5
date	2008.02.21.17.37.32;	author cgf;	state Exp;
branches;
next	1.256.2.6;

1.256.2.6
date	2008.03.05.18.17.39;	author corinna;	state Exp;
branches;
next	;

1.255.2.1
date	2006.07.14.08.23.32;	author corinna;	state Exp;
branches;
next	1.255.2.2;

1.255.2.2
date	2006.07.18.13.58.51;	author corinna;	state Exp;
branches;
next	;

1.168.6.1
date	2004.01.21.19.17.55;	author cgf;	state Exp;
branches;
next	1.168.6.2;

1.168.6.2
date	2004.01.22.20.57.45;	author cgf;	state Exp;
branches;
next	1.168.6.3;

1.168.6.3
date	2004.01.24.01.53.56;	author cgf;	state Exp;
branches;
next	1.168.6.4;

1.168.6.4
date	2004.01.24.03.41.29;	author cgf;	state Exp;
branches;
next	1.168.6.5;

1.168.6.5
date	2004.01.24.20.36.51;	author cgf;	state Exp;
branches;
next	1.168.6.6;

1.168.6.6
date	2004.01.25.23.39.55;	author cgf;	state Exp;
branches;
next	;

1.143.4.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	1.143.4.2;

1.143.4.2
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.143.4.3;

1.143.4.3
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	1.143.4.4;

1.143.4.4
date	2002.12.29.06.14.14;	author cgf;	state Exp;
branches;
next	1.143.4.5;

1.143.4.5
date	2003.01.01.18.16.37;	author cgf;	state Exp;
branches;
next	1.143.4.6;

1.143.4.6
date	2003.01.02.06.16.17;	author cgf;	state Exp;
branches;
next	1.143.4.7;

1.143.4.7
date	2003.01.05.03.01.16;	author cgf;	state Exp;
branches;
next	1.143.4.8;

1.143.4.8
date	2003.01.05.06.48.55;	author cgf;	state Exp;
branches;
next	;

1.143.6.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.143.6.2;

1.143.6.2
date	2003.02.14.03.03.27;	author cgf;	state Exp;
branches;
next	1.143.6.3;

1.143.6.3
date	2003.02.14.05.21.51;	author cgf;	state Exp;
branches;
next	1.143.6.4;

1.143.6.4
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.143.6.5;

1.143.6.5
date	2003.02.23.07.03.23;	author cgf;	state Exp;
branches;
next	1.143.6.6;

1.143.6.6
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.143.6.7;

1.143.6.7
date	2003.05.26.19.39.05;	author cgf;	state Exp;
branches;
next	1.143.6.8;

1.143.6.8
date	2003.06.06.00.27.50;	author cgf;	state Exp;
branches;
next	1.143.6.9;

1.143.6.9
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.143.6.10;

1.143.6.10
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.143.6.11;

1.143.6.11
date	2003.09.02.02.31.08;	author cgf;	state Exp;
branches;
next	1.143.6.12;

1.143.6.12
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	;

1.87.2.1
date	2001.10.02.12.09.53;	author rbcollins;	state Exp;
branches;
next	1.87.2.2;

1.87.2.2
date	2002.01.04.03.56.07;	author rbcollins;	state Exp;
branches;
next	1.87.2.3;

1.87.2.3
date	2002.01.15.12.52.50;	author rbcollins;	state Exp;
branches;
next	1.87.2.4;

1.87.2.4
date	2002.02.28.12.53.23;	author rbcollins;	state Exp;
branches;
next	1.87.2.5;

1.87.2.5
date	2002.06.13.14.34.03;	author rbcollins;	state Exp;
branches;
next	1.87.2.6;

1.87.2.6
date	2002.06.20.10.33.29;	author scottc;	state Exp;
branches;
next	1.87.2.7;

1.87.2.7
date	2002.06.24.10.55.35;	author scottc;	state Exp;
branches;
next	1.87.2.8;

1.87.2.8
date	2002.07.04.20.09.46;	author scottc;	state Exp;
branches;
next	1.87.2.9;

1.87.2.9
date	2002.07.13.20.39.24;	author scottc;	state Exp;
branches;
next	1.87.2.10;

1.87.2.10
date	2002.07.14.19.26.23;	author scottc;	state Exp;
branches;
next	1.87.2.11;

1.87.2.11
date	2002.08.30.22.08.50;	author scottc;	state Exp;
branches;
next	1.87.2.12;

1.87.2.12
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	1.87.2.13;

1.87.2.13
date	2002.09.19.21.51.22;	author scottc;	state Exp;
branches;
next	1.87.2.14;

1.87.2.14
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.442
log
@	* fhandler.h (class fhandler_base): Add was_nonblocking status flag.
	* fhandler.cc (fhandler_base::set_flags): Set was_nonblocking if the
	O_NONBLOCK flag has been specified.
	(fhandler_base_overlapped::close): Check for was_nonblocking instead
	of for is_nonblocking.  Explain why.
	(fhandler_base::set_nonblocking): Set was_nonblocking if noblocking
	mode gets enabled.
@
text
@/* fhandler.cc.  See console.cc for fhandler_console functions.

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <unistd.h>
#include <stdlib.h>
#include <sys/uio.h>
#include <sys/acl.h>
#include <sys/param.h>
#include "cygerrno.h"
#include "perprocess.h"
#include "security.h"
#include "cygwin/version.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "pinfo.h"
#include <assert.h>
#include <winioctl.h>
#include "ntdll.h"
#include "cygtls.h"
#include "sigproc.h"
#include "shared_info.h"
#include <asm/socket.h>
#include "cygwait.h"

#define MAX_OVERLAPPED_WRITE_LEN (64 * 1024 * 1024)
#define MIN_OVERLAPPED_WRITE_LEN (1 * 1024 * 1024)

static const int CHUNK_SIZE = 1024; /* Used for crlf conversions */

struct __cygwin_perfile *perfile_table;

HANDLE NO_COPY fhandler_base_overlapped::asio_done;
LONG NO_COPY fhandler_base_overlapped::asio_close_counter;

void
fhandler_base::reset (const fhandler_base *from)
{
  pc << from->pc;
  rabuf = NULL;
  ralen = 0;
  raixget = 0;
  raixput = 0;
  rabuflen = 0;
  _refcnt = 0;
}

int
fhandler_base::puts_readahead (const char *s, size_t len)
{
  int success = 1;
  while ((len == (size_t) -1 ? *s : len--)
	 && (success = put_readahead (*s++) > 0))
    continue;
  return success;
}

int
fhandler_base::put_readahead (char value)
{
  char *newrabuf;
  if (raixput < rabuflen)
    /* Nothing to do */;
  else if ((newrabuf = (char *) realloc (rabuf, rabuflen += 32)))
    rabuf = newrabuf;
  else
    return 0;

  rabuf[raixput++] = value;
  ralen++;
  return 1;
}

int
fhandler_base::get_readahead ()
{
  int chret = -1;
  if (raixget < ralen)
    chret = ((unsigned char) rabuf[raixget++]) & 0xff;
  /* FIXME - not thread safe */
  if (raixget >= ralen)
    raixget = raixput = ralen = 0;
  return chret;
}

int
fhandler_base::peek_readahead (int queryput)
{
  int chret = -1;
  if (!queryput && raixget < ralen)
    chret = ((unsigned char) rabuf[raixget]) & 0xff;
  else if (queryput && raixput > 0)
    chret = ((unsigned char) rabuf[raixput - 1]) & 0xff;
  return chret;
}

void
fhandler_base::set_readahead_valid (int val, int ch)
{
  if (!val)
    ralen = raixget = raixput = 0;
  if (ch != -1)
    put_readahead (ch);
}

int
fhandler_base::eat_readahead (int n)
{
  int oralen = ralen;
  if (n < 0)
    n = ralen;
  if (n > 0 && ralen)
    {
      if ((int) (ralen -= n) < 0)
	ralen = 0;

      if (raixget >= ralen)
	raixget = raixput = ralen = 0;
      else if (raixput > ralen)
	raixput = ralen;
    }

  return oralen;
}

int
fhandler_base::get_readahead_into_buffer (char *buf, size_t buflen)
{
  int ch;
  int copied_chars = 0;

  while (buflen)
    if ((ch = get_readahead ()) < 0)
      break;
    else
      {
	buf[copied_chars++] = (unsigned char)(ch & 0xff);
	buflen--;
      }

  return copied_chars;
}

/* Record the file name. and name hash */
void
fhandler_base::set_name (path_conv &in_pc)
{
  pc << in_pc;
}

char *fhandler_base::get_proc_fd_name (char *buf)
{
  if (get_name ())
    return strcpy (buf, get_name ());
  if (dev ().name)
    return strcpy (buf, dev ().name);
  return strcpy (buf, "");
}

/* Detect if we are sitting at EOF for conditions where Windows
   returns an error but UNIX doesn't.  */
int __stdcall
is_at_eof (HANDLE h)
{
  IO_STATUS_BLOCK io;
  FILE_POSITION_INFORMATION fpi;
  FILE_STANDARD_INFORMATION fsi;

  if (NT_SUCCESS (NtQueryInformationFile (h, &io, &fsi, sizeof fsi,
					  FileStandardInformation))
      && NT_SUCCESS (NtQueryInformationFile (h, &io, &fpi, sizeof fpi,
					     FilePositionInformation))
      && fsi.EndOfFile.QuadPart == fpi.CurrentByteOffset.QuadPart)
    return 1;
  return 0;
}

void
fhandler_base::set_flags (int flags, int supplied_bin)
{
  int bin;
  int fmode;
  debug_printf ("flags %y, supplied_bin %y", flags, supplied_bin);
  if ((bin = flags & (O_BINARY | O_TEXT)))
    debug_printf ("O_TEXT/O_BINARY set in flags %y", bin);
  else if (rbinset () && wbinset ())
    bin = rbinary () ? O_BINARY : O_TEXT;	// FIXME: Not quite right
  else if ((fmode = get_default_fmode (flags)) & O_BINARY)
    bin = O_BINARY;
  else if (fmode & O_TEXT)
    bin = O_TEXT;
  else if (supplied_bin)
    bin = supplied_bin;
  else
    bin = wbinary () || rbinary () ? O_BINARY : O_TEXT;

  openflags = flags | bin;
  if (openflags & O_NONBLOCK)
    was_nonblocking (true);

  bin &= O_BINARY;
  rbinary (bin ? true : false);
  wbinary (bin ? true : false);
  syscall_printf ("filemode set to %s", bin ? "binary" : "text");
}

/* Normal file i/o handlers.  */

/* Cover function to ReadFile to achieve (as much as possible) Posix style
   semantics and use of errno.  */
void __reg3
fhandler_base::raw_read (void *ptr, size_t& len)
{
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  int try_noreserve = 1;

retry:
  status = NtReadFile (get_handle (), NULL, NULL, NULL, &io, ptr, len,
		       NULL, NULL);
  if (NT_SUCCESS (status))
    len = io.Information;
  else
    {
      /* Some errors are not really errors.  Detect such cases here.  */
      switch (status)
	{
	case STATUS_END_OF_FILE:
	case STATUS_PIPE_BROKEN:
	  /* This is really EOF.  */
	  len = 0;
	  break;
	case STATUS_MORE_ENTRIES:
	case STATUS_BUFFER_OVERFLOW:
	  /* `io.Information' is supposedly valid.  */
	  len = io.Information;
	  break;
	case STATUS_ACCESS_VIOLATION:
	  if (is_at_eof (get_handle ()))
	    {
	      len = 0;
	      break;
	    }
	  if (try_noreserve)
	    {
	      try_noreserve = 0;
	      switch (mmap_is_attached_or_noreserve (ptr, len))
		{
		case MMAP_NORESERVE_COMMITED:
		  goto retry;
		case MMAP_RAISE_SIGBUS:
		  raise(SIGBUS);
		case MMAP_NONE:
		  break;
		}
	    }
	  /*FALLTHRU*/
	case STATUS_INVALID_DEVICE_REQUEST:
	case STATUS_INVALID_PARAMETER:
	case STATUS_INVALID_HANDLE:
	  if (pc.isdir ())
	    {
	      set_errno (EISDIR);
	      len = (size_t) -1;
	      break;
	    }
	default:
	  __seterrno_from_nt_status (status);
	  len = (size_t) -1;
	  break;
	}
    }
}

/* Cover function to WriteFile to provide Posix interface and semantics
   (as much as possible).  */
ssize_t __reg3
fhandler_base::raw_write (const void *ptr, size_t len)
{
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  static _RDATA LARGE_INTEGER off_current =
			  { QuadPart:FILE_USE_FILE_POINTER_POSITION };
  static _RDATA LARGE_INTEGER off_append =
			  { QuadPart:FILE_WRITE_TO_END_OF_FILE };

  status = NtWriteFile (get_output_handle (), NULL, NULL, NULL, &io,
			(PVOID) ptr, len,
			(get_flags () & O_APPEND) ? &off_append : &off_current,
			NULL);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      if (get_errno () == EPIPE)
	raise (SIGPIPE);
      return -1;
    }
  return io.Information;
}

int
fhandler_base::get_default_fmode (int flags)
{
  int fmode = __fmode;
  if (perfile_table)
    {
      size_t nlen = strlen (get_name ());
      unsigned accflags = (flags & O_ACCMODE);
      for (__cygwin_perfile *pf = perfile_table; pf->name; pf++)
	if (!*pf->name && (pf->flags & O_ACCMODE) == accflags)
	  {
	    fmode = pf->flags & ~O_ACCMODE;
	    break;
	  }
	else
	  {
	    size_t pflen = strlen (pf->name);
	    const char *stem = get_name () + nlen - pflen;
	    if (pflen > nlen || (stem != get_name () && !isdirsep (stem[-1])))
	      continue;
	    else if ((pf->flags & O_ACCMODE) == accflags
		     && pathmatch (stem, pf->name, !!pc.objcaseinsensitive ()))
	      {
		fmode = pf->flags & ~O_ACCMODE;
		break;
	      }
	  }
    }
  return fmode;
}

bool
fhandler_base::device_access_denied (int flags)
{
  int mode = 0;

  if (flags & O_RDWR)
    mode |= R_OK | W_OK;
  if (flags & (O_WRONLY | O_APPEND))
    mode |= W_OK;
  if (!mode)
    mode |= R_OK;

  return fhaccess (mode, true);
}

int
fhandler_base::fhaccess (int flags, bool effective)
{
  int res = -1;
  if (error ())
    {
      set_errno (error ());
      goto done;
    }

  if (!exists ())
    {
      set_errno (ENOENT);
      goto done;
    }

  if (!(flags & (R_OK | W_OK | X_OK)))
    return 0;

  if (is_fs_special ())
    /* short circuit */;
  else if (has_attribute (FILE_ATTRIBUTE_READONLY) && (flags & W_OK)
	   && !pc.isdir ())
    goto eaccess_done;
  else if (has_acls ())
    {
      res = check_file_access (pc, flags, effective);
      goto done;
    }
  else if (get_device () == FH_REGISTRY && open (O_RDONLY, 0) && get_handle ())
    {
      res = check_registry_access (get_handle (), flags, effective);
      close ();
      return res;
    }

  struct stat st;
  if (fstat (&st))
    goto done;

  if (flags & R_OK)
    {
      if (st.st_uid == (effective ? myself->uid : cygheap->user.real_uid))
	{
	  if (!(st.st_mode & S_IRUSR))
	    goto eaccess_done;
	}
      else if (st.st_gid == (effective ? myself->gid : cygheap->user.real_gid))
	{
	  if (!(st.st_mode & S_IRGRP))
	    goto eaccess_done;
	}
      else if (!(st.st_mode & S_IROTH))
	goto eaccess_done;
    }

  if (flags & W_OK)
    {
      if (st.st_uid == (effective ? myself->uid : cygheap->user.real_uid))
	{
	  if (!(st.st_mode & S_IWUSR))
	    goto eaccess_done;
	}
      else if (st.st_gid == (effective ? myself->gid : cygheap->user.real_gid))
	{
	  if (!(st.st_mode & S_IWGRP))
	    goto eaccess_done;
	}
      else if (!(st.st_mode & S_IWOTH))
	goto eaccess_done;
    }

  if (flags & X_OK)
    {
      if (st.st_uid == (effective ? myself->uid : cygheap->user.real_uid))
	{
	  if (!(st.st_mode & S_IXUSR))
	    goto eaccess_done;
	}
      else if (st.st_gid == (effective ? myself->gid : cygheap->user.real_gid))
	{
	  if (!(st.st_mode & S_IXGRP))
	    goto eaccess_done;
	}
      else if (!(st.st_mode & S_IXOTH))
	goto eaccess_done;
    }

  res = 0;
  goto done;

eaccess_done:
  set_errno (EACCES);
done:
  if (!res && (flags & W_OK) && get_device () == FH_FS
      && (pc.fs_flags () & FILE_READ_ONLY_VOLUME))
    {
      set_errno (EROFS);
      res = -1;
    }
  debug_printf ("returning %d", res);
  return res;
}

int
fhandler_base::open_with_arch (int flags, mode_t mode)
{
  int res;
  if (!(res = (archetype && archetype->io_handle)
	|| open (flags, (mode & 07777) & ~cygheap->umask)))
    {
      if (archetype)
	delete archetype;
    }
  else if (archetype)
    {
      if (!archetype->get_io_handle ())
	{
	  copyto (archetype);
	  archetype_usecount (1);
	  archetype->archetype = NULL;
	  usecount = 0;
	}
      else
	{
	  char *name;
	  /* Preserve any name (like /dev/tty) derived from build_fh_pc. */
	  if (!get_name ())
	    name = NULL;
	  else
	    {
	      name = (char *) alloca (strlen (get_name ()) + 1);
	      strcpy (name, get_name ());
	    }
	  fhandler_base *arch = archetype;
	  archetype->copyto (this);
	  if (name)
	    set_name (name);
	  archetype = arch;
	  archetype_usecount (1);
	  usecount = 0;
	}
      open_setup (flags);
    }

  close_on_exec (flags & O_CLOEXEC);
  /* A unique ID is necessary to recognize fhandler entries which are
     duplicated by dup(2) or fork(2).  This is used in BSD flock calls
     to identify the descriptor.  Skip nohandle fhandlers since advisory
     locking is unusable for those anyway. */
  if (!nohandle ())
    set_unique_id ();
  return res;
}

/* Open a fake handle to \\Device\\Null.  This is a helper function for
   fhandlers which just need some handle to keep track of BSD flock locks. */
int
fhandler_base::open_null (int flags)
{
  int res = 0;
  HANDLE fh;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  NTSTATUS status;

  InitializeObjectAttributes (&attr, &ro_u_null, OBJ_CASE_INSENSITIVE |
			      ((flags & O_CLOEXEC) ? 0 : OBJ_INHERIT),
			      NULL, NULL);
  status = NtCreateFile (&fh, GENERIC_READ | SYNCHRONIZE, &attr, &io, NULL, 0,
			 FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
			 FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      goto done;
    }
  set_io_handle (fh);
  set_flags (flags, pc.binmode ());
  res = 1;
  set_open_status ();
done:
  debug_printf ("%y = NtCreateFile (%p, ... %S ...)", status, fh, &ro_u_null);
  syscall_printf ("%d = fhandler_base::open_null (%y)", res, flags);
  return res;
}

/* Open system call handler function. */
int
fhandler_base::open (int flags, mode_t mode)
{
  int res = 0;
  HANDLE fh;
  ULONG file_attributes = 0;
  ULONG shared = (get_major () == DEV_TAPE_MAJOR ? 0 : FILE_SHARE_VALID_FLAGS);
  ULONG create_disposition;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  NTSTATUS status;
  PFILE_FULL_EA_INFORMATION p = NULL;
  ULONG plen = 0;

  syscall_printf ("(%S, %y)", pc.get_nt_native_path (), flags);

  pc.get_object_attr (attr, *sec_none_cloexec (flags));

  options = FILE_OPEN_FOR_BACKUP_INTENT;
  switch (query_open ())
    {
    case query_read_control:
      access = READ_CONTROL;
      break;
    case query_read_attributes:
      access = READ_CONTROL | FILE_READ_ATTRIBUTES;
      break;
    case query_write_control:
      access = READ_CONTROL | WRITE_OWNER | WRITE_DAC | FILE_WRITE_ATTRIBUTES;
      break;
    case query_write_dac:
      access = READ_CONTROL | WRITE_DAC | FILE_WRITE_ATTRIBUTES;
      break;
    case query_write_attributes:
      access = READ_CONTROL | FILE_WRITE_ATTRIBUTES;
      break;
    default:
      switch (flags & O_ACCMODE)
	{
	case O_RDONLY:
	  access = GENERIC_READ;
	  break;
	case O_WRONLY:
	  access = GENERIC_WRITE | READ_CONTROL | FILE_READ_ATTRIBUTES;
	  break;
	default:
	  access = GENERIC_READ | GENERIC_WRITE;
	  break;
	}
      if (flags & O_SYNC)
	options |= FILE_WRITE_THROUGH;
      if (flags & O_DIRECT)
	options |= FILE_NO_INTERMEDIATE_BUFFERING;
      if (get_major () != DEV_SERIAL_MAJOR && get_major () != DEV_TAPE_MAJOR)
	{
	  options |= FILE_SYNCHRONOUS_IO_NONALERT;
	  access |= SYNCHRONIZE;
	}
      break;
    }

  /* Don't use the FILE_OVERWRITE{_IF} flags here.  See below for an
     explanation, why that's not such a good idea. */
  if ((flags & O_EXCL) && (flags & O_CREAT))
    create_disposition = FILE_CREATE;
  else
    create_disposition = (flags & O_CREAT) ? FILE_OPEN_IF : FILE_OPEN;

  if (get_device () == FH_FS)
    {
      /* Add the reparse point flag to native symlinks, otherwise we open the
	 target, not the symlink.  This would break lstat. */
      if (pc.is_rep_symlink ())
	options |= FILE_OPEN_REPARSE_POINT;

      if (pc.fs_is_nfs ())
	{
	  /* Make sure we can read EAs of files on an NFS share.  Also make
	     sure that we're going to act on the file itself, even if it's a
	     a symlink. */
	  access |= FILE_READ_EA;
	  if (query_open ())
	    {
	      if (query_open () >= query_write_control)
		access |=  FILE_WRITE_EA;
	      plen = sizeof nfs_aol_ffei;
	      p = (PFILE_FULL_EA_INFORMATION) &nfs_aol_ffei;
	    }
	}

      /* Trying to overwrite an already existing file with FILE_ATTRIBUTE_HIDDEN
	 and/or FILE_ATTRIBUTE_SYSTEM attribute set, NtCreateFile fails with
	 STATUS_ACCESS_DENIED.  Per MSDN you have to create the file with the
	 same attributes as already specified for the file. */
      if (create_disposition == FILE_CREATE
	  && has_attribute (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM))
	file_attributes |= pc.file_attributes ();

      if (flags & O_CREAT)
	{
	  file_attributes |= FILE_ATTRIBUTE_NORMAL;

	  if (pc.fs_is_nfs ())
	    {
	      /* When creating a file on an NFS share, we have to set the
		 file mode by writing a NFS fattr3 structure with the
		 correct mode bits set. */
	      access |= FILE_WRITE_EA;
	      plen = sizeof (FILE_FULL_EA_INFORMATION) + sizeof (NFS_V3_ATTR)
		     + sizeof (fattr3);
	      p = (PFILE_FULL_EA_INFORMATION) alloca (plen);
	      p->NextEntryOffset = 0;
	      p->Flags = 0;
	      p->EaNameLength = sizeof (NFS_V3_ATTR) - 1;
	      p->EaValueLength = sizeof (fattr3);
	      strcpy (p->EaName, NFS_V3_ATTR);
	      fattr3 *nfs_attr = (fattr3 *) (p->EaName
					     + p->EaNameLength + 1);
	      memset (nfs_attr, 0, sizeof (fattr3));
	      nfs_attr->type = NF3REG;
	      nfs_attr->mode = mode;
	    }
	  else if (!has_acls () && !(mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
	    /* If mode has no write bits set, and ACLs are not used, we set
	       the DOS R/O attribute. */
	    file_attributes |= FILE_ATTRIBUTE_READONLY;
	  /* The file attributes are needed for later use in, e.g. fchmod. */
	  pc.file_attributes (file_attributes);
	  /* Never set the WRITE_DAC flag here.  Calls to fstat may return
	     wrong st_ctime information after calls to fchmod, fchown, etc
	     because Windows only guarantees the update of metadata when
	     the handle is closed or flushed.  However, flushing the file
	     on every fstat to enforce POSIXy stat behaviour is excessivly
	     slow, compared to an extra open/close to change the file's
	     security descriptor. */
	}
    }

  status = NtCreateFile (&fh, access, &attr, &io, NULL, file_attributes, shared,
			 create_disposition, options, p, plen);
  if (!NT_SUCCESS (status))
    {
      /* Trying to create a directory should return EISDIR, not ENOENT. */
      PUNICODE_STRING upath = pc.get_nt_native_path ();
      if (status == STATUS_OBJECT_NAME_INVALID && (flags & O_CREAT)
	  && upath->Buffer[upath->Length / sizeof (WCHAR) - 1] == '\\')
	set_errno (EISDIR);
      else
	__seterrno_from_nt_status (status);
      if (!nohandle ())
	goto done;
   }

  /* Always create files using a NULL SD.  Create correct permission bits
     afterwards, maintaining the owner and group information just like chmod.

     This is done for two reasons.

     On Windows filesystems we need to create the file with default
     permissions to allow inheriting ACEs.  When providing an explicit DACL
     in calls to [Nt]CreateFile, the created file will not inherit default
     permissions from the parent object.  This breaks not only Windows
     inheritance, but also POSIX ACL inheritance.

     Another reason to do this are remote shares.  Files on a remote share
     are created as the user used for authentication.  In a domain that's
     usually the user you're logged in as.  Outside of a domain you're
     authenticating using a local user account on the sharing machine.
     If the SIDs of the client machine are used, that's entirely
     unexpected behaviour.  Doing it like we do here creates the expected SD
     in a domain as well as on standalone servers.
     This is the result of a discussion on the samba-technical list, starting at
     http://lists.samba.org/archive/samba-technical/2008-July/060247.html */
  if (io.Information == FILE_CREATED && has_acls ())
    set_file_attribute (fh, pc, ILLEGAL_UID, ILLEGAL_GID, S_JUSTCREATED | mode);

  /* If you O_TRUNC a file on Linux, the data is truncated, but the EAs are
     preserved.  If you open a file on Windows with FILE_OVERWRITE{_IF} or
     FILE_SUPERSEDE, all streams are truncated, including the EAs.  So we don't
     use the FILE_OVERWRITE{_IF} flags, but instead just open the file and set
     the size of the data stream explicitely to 0.  Apart from being more Linux
     compatible, this implementation has the pleasant side-effect to be more
     than 5% faster than using FILE_OVERWRITE{_IF} (tested on W7 32 bit). */
  if ((flags & O_TRUNC)
      && (flags & O_ACCMODE) != O_RDONLY
      && io.Information != FILE_CREATED
      && get_device () == FH_FS)
    {
      FILE_END_OF_FILE_INFORMATION feofi = { EndOfFile:{ QuadPart:0 } };
      status = NtSetInformationFile (fh, &io, &feofi, sizeof feofi,
				     FileEndOfFileInformation);
      /* In theory, truncating the file should never fail, since the opened
	 handle has FILE_WRITE_DATA permissions, which is all you need to
	 be allowed to truncate a file.  Better safe than sorry. */
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  NtClose (fh);
	  goto done;
	}
    }

  set_io_handle (fh);
  set_flags (flags, pc.binmode ());

  res = 1;
  set_open_status ();
done:
  debug_printf ("%y = NtCreateFile "
		"(%p, %y, %S, io, NULL, %y, %y, %y, %y, NULL, 0)",
		status, fh, access, pc.get_nt_native_path (), file_attributes,
		shared, create_disposition, options);

  syscall_printf ("%d = fhandler_base::open(%S, %y)",
		  res, pc.get_nt_native_path (), flags);
  return res;
}

void
fhandler_base::open_setup (int)
{
}

/* states:
   open buffer in binary mode?  Just do the read.

   open buffer in text mode?  Scan buffer for control zs and handle
   the first one found.  Then scan buffer, converting every \r\n into
   an \n.  If last char is an \r, look ahead one more char, if \n then
   modify \r, if not, remember char.
*/
void __reg3
fhandler_base::read (void *in_ptr, size_t& len)
{
  char *ptr = (char *) in_ptr;
  ssize_t copied_chars = get_readahead_into_buffer (ptr, len);

  if (copied_chars || !len)
    {
      len = (size_t) copied_chars;
      goto out;
    }

  raw_read (ptr, len);

  if (rbinary () || (ssize_t) len <= 0)
    goto out;

  /* Scan buffer and turn \r\n into \n */
  char *src, *dst, *end;
  src = (char *) ptr;
  dst = (char *) ptr;
  end = src + len - 1;

  /* Read up to the last but one char - the last char needs special handling */
  while (src < end)
    {
      if (*src == '\r' && src[1] == '\n')
	src++;
      *dst++ = *src++;
    }

  /* If not beyond end and last char is a '\r' then read one more
     to see if we should translate this one too */
  if (src > end)
    /* nothing */;
  else if (*src != '\r')
    *dst++ = *src;
  else
    {
      char c1;
      size_t c1len = 1;
      raw_read (&c1, c1len);
      if (c1len <= 0)
	/* nothing */;
      else if (c1 == '\n')
	*dst++ = '\n';
      else
	{
	  set_readahead_valid (1, c1);
	  *dst++ = *src;
	}
    }

  len = dst - (char *) ptr;

out:
  debug_printf ("returning %d, %s mode", len, rbinary () ? "binary" : "text");
}

ssize_t __stdcall
fhandler_base::write (const void *ptr, size_t len)
{
  int res;

  if (did_lseek ())
    {
      IO_STATUS_BLOCK io;
      FILE_POSITION_INFORMATION fpi;
      FILE_STANDARD_INFORMATION fsi;

      did_lseek (false); /* don't do it again */

      if (!(get_flags () & O_APPEND)
	  && !has_attribute (FILE_ATTRIBUTE_SPARSE_FILE)
	  && NT_SUCCESS (NtQueryInformationFile (get_output_handle (),
						 &io, &fsi, sizeof fsi,
						 FileStandardInformation))
	  && NT_SUCCESS (NtQueryInformationFile (get_output_handle (),
						 &io, &fpi, sizeof fpi,
						 FilePositionInformation))
	  && fpi.CurrentByteOffset.QuadPart
	     >= fsi.EndOfFile.QuadPart + (128 * 1024))
	{
	  /* If the file system supports sparse files and the application
	     is writing after a long seek beyond EOF, convert the file to
	     a sparse file. */
	  NTSTATUS status;
	  status = NtFsControlFile (get_output_handle (), NULL, NULL, NULL,
				    &io, FSCTL_SET_SPARSE, NULL, 0, NULL, 0);
	  if (NT_SUCCESS (status))
	    pc.file_attributes (pc.file_attributes ()
				| FILE_ATTRIBUTE_SPARSE_FILE);
	  debug_printf ("%y = NtFsControlFile(%S, FSCTL_SET_SPARSE)",
			status, pc.get_nt_native_path ());
	}
    }

  if (wbinary ())
    res = raw_write (ptr, len);
  else
    {
      debug_printf ("text write");
      /* This is the Microsoft/DJGPP way.  Still not ideal, but it's
	 compatible.
	 Modified slightly by CGF 2000-10-07 */

      int left_in_data = len;
      char *data = (char *)ptr;
      res = 0;

      while (left_in_data > 0)
	{
	  char buf[CHUNK_SIZE + 1], *buf_ptr = buf;
	  int left_in_buf = CHUNK_SIZE;

	  while (left_in_buf > 0 && left_in_data > 0)
	    {
	      char ch = *data++;
	      if (ch == '\n')
		{
		  *buf_ptr++ = '\r';
		  left_in_buf--;
		}
	      *buf_ptr++ = ch;
	      left_in_buf--;
	      left_in_data--;
	      if (left_in_data > 0 && ch == '\r' && *data == '\n')
		{
		  *buf_ptr++ = *data++;
		  left_in_buf--;
		  left_in_data--;
		}
	    }

	  /* We've got a buffer-full, or we're out of data.  Write it out */
	  int nbytes;
	  int want = buf_ptr - buf;
	  if ((nbytes = raw_write (buf, want)) == want)
	    {
	      /* Keep track of how much written not counting additional \r's */
	      res = data - (char *)ptr;
	      continue;
	    }

	  if (nbytes == -1)
	    res = -1;		/* Error */
	  else
	    res += nbytes;	/* Partial write.  Return total bytes written. */
	  break;		/* All done */
	}
    }

  return res;
}

ssize_t __stdcall
fhandler_base::readv (const struct iovec *const iov, const int iovcnt,
		      ssize_t tot)
{
  assert (iov);
  assert (iovcnt >= 1);

  size_t len = tot;
  if (iovcnt == 1)
    {
      len = iov->iov_len;
      read (iov->iov_base, len);
      return len;
    }

  if (tot == -1)		// i.e. if not pre-calculated by the caller.
    {
      len = 0;
      const struct iovec *iovptr = iov + iovcnt;
      do
	{
	  iovptr -= 1;
	  len += iovptr->iov_len;
	}
      while (iovptr != iov);
    }

  if (!len)
    return 0;

  char *buf = (char *) malloc (len);

  if (!buf)
    {
      set_errno (ENOMEM);
      return -1;
    }

  read (buf, len);
  ssize_t nbytes = (ssize_t) len;

  const struct iovec *iovptr = iov;

  char *p = buf;
  while (nbytes > 0)
    {
      const int frag = MIN (nbytes, (ssize_t) iovptr->iov_len);
      memcpy (iovptr->iov_base, p, frag);
      p += frag;
      iovptr += 1;
      nbytes -= frag;
    }

  free (buf);
  return len;
}

ssize_t __stdcall
fhandler_base::writev (const struct iovec *const iov, const int iovcnt,
		       ssize_t tot)
{
  assert (iov);
  assert (iovcnt >= 1);

  if (iovcnt == 1)
    return write (iov->iov_base, iov->iov_len);

  if (tot == -1)		// i.e. if not pre-calculated by the caller.
    {
      tot = 0;
      const struct iovec *iovptr = iov + iovcnt;
      do
	{
	  iovptr -= 1;
	  tot += iovptr->iov_len;
	}
      while (iovptr != iov);
    }

  assert (tot >= 0);

  if (tot == 0)
    return 0;

  char *const buf = (char *) malloc (tot);

  if (!buf)
    {
      set_errno (ENOMEM);
      return -1;
    }

  char *bufptr = buf;
  const struct iovec *iovptr = iov;
  int nbytes = tot;

  while (nbytes != 0)
    {
      const int frag = MIN (nbytes, (ssize_t) iovptr->iov_len);
      memcpy (bufptr, iovptr->iov_base, frag);
      bufptr += frag;
      iovptr += 1;
      nbytes -= frag;
    }
  ssize_t ret = write (buf, tot);
  free (buf);
  return ret;
}

off_t
fhandler_base::lseek (off_t offset, int whence)
{
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  FILE_POSITION_INFORMATION fpi;
  FILE_STANDARD_INFORMATION fsi;

  /* Seeks on text files is tough, we rewind and read till we get to the
     right place.  */

  if (whence != SEEK_CUR || offset != 0)
    {
      if (whence == SEEK_CUR)
	offset -= ralen - raixget;
      set_readahead_valid (0);
    }

  switch (whence)
    {
    case SEEK_SET:
      fpi.CurrentByteOffset.QuadPart = offset;
      break;
    case SEEK_CUR:
      status = NtQueryInformationFile (get_handle (), &io, &fpi, sizeof fpi,
				       FilePositionInformation);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  return -1;
	}
      fpi.CurrentByteOffset.QuadPart += offset;
      break;
    default: /* SEEK_END */
      status = NtQueryInformationFile (get_handle (), &io, &fsi, sizeof fsi,
				       FileStandardInformation);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  return -1;
	}
      fpi.CurrentByteOffset.QuadPart = fsi.EndOfFile.QuadPart + offset;
      break;
    }

  debug_printf ("setting file pointer to %U", fpi.CurrentByteOffset.QuadPart);
  status = NtSetInformationFile (get_handle (), &io, &fpi, sizeof fpi,
				 FilePositionInformation);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  off_t res = fpi.CurrentByteOffset.QuadPart;

  /* When next we write(), we will check to see if *this* seek went beyond
     the end of the file and if so, potentially sparsify the file. */
  if (pc.support_sparse ())
    did_lseek (true);

  /* If this was a SEEK_CUR with offset 0, we still might have
     readahead that we have to take into account when calculating
     the actual position for the application.  */
  if (whence == SEEK_CUR)
    res -= ralen - raixget;

  return res;
}

ssize_t __reg3
fhandler_base::pread (void *, size_t, off_t)
{
  set_errno (ESPIPE);
  return -1;
}

ssize_t __reg3
fhandler_base::pwrite (void *, size_t, off_t)
{
  set_errno (ESPIPE);
  return -1;
}

int
fhandler_base::close_with_arch ()
{
  int res;
  fhandler_base *fh;
  if (usecount)
    {
      /* This was the archetype itself. */
      if (--usecount)
	{
	  debug_printf ("not closing passed in archetype %p, usecount %d", archetype, usecount);
	  return 0;
	}
      debug_printf ("closing passed in archetype %p, usecount %d", archetype, usecount);
      /* Set archetype temporarily so that it will eventually be deleted. */
      archetype = fh = this;
    }
  else if (!archetype)
    fh = this;
  else if (archetype_usecount (-1) == 0)
    {
      debug_printf ("closing archetype");
      fh = archetype;
    }
  else
    {
      debug_printf ("not closing archetype");
      return 0;
    }

  cleanup ();
  res = fh->close ();
  if (archetype)
    {
      cygheap->fdtab.delete_archetype (archetype);
      archetype = NULL;
    }
  return res;
}

void
fhandler_base::cleanup ()
{
  /* Delete all POSIX locks on the file.  Delete all flock locks on the
     file if this is the last reference to this file. */
  if (unique_id)
    del_my_locks (on_close);
}

int
fhandler_base::close ()
{
  int res = -1;

  syscall_printf ("closing '%s' handle %p", get_name (), get_handle ());
  if (nohandle () || CloseHandle (get_handle ()))
    res = 0;
  else
    {
      paranoid_printf ("CloseHandle failed, %E");
      __seterrno ();
    }
  return res;
}

DWORD WINAPI
flush_async_io (void *arg)
{
  fhandler_base_overlapped *fh = (fhandler_base_overlapped *) arg;
  debug_only_printf ("waiting for write I/O for %s", fh->get_name ());
  DWORD nbytes;
  bool res = GetOverlappedResult (fh->get_output_handle (),
				  fh->get_overlapped (), &nbytes, true);
  debug_printf ("finished waiting for I/O from %s, res %d", fh->get_name (),
		res);
  fh->close ();
  delete fh;

  InterlockedDecrement (&fhandler_base_overlapped::asio_close_counter);
  SetEvent (fhandler_base_overlapped::asio_done);

  _my_tls._ctinfo->auto_release ();
  return 0;
}

void
fhandler_base_overlapped::flush_all_async_io ()
{
  while (asio_close_counter > 0)
    if (WaitForSingleObject (asio_done, INFINITE) != WAIT_OBJECT_0)
      {
	system_printf ("WaitForSingleObject failed, possible data loss in pipe, %E");
	break;
      }
  asio_close_counter = 0;
  if (asio_done)
    CloseHandle (asio_done);
}

/* Start a thread to handle closing of overlapped asynchronous I/O since
   Windows amazingly does not seem to always flush I/O on close.  */
void
fhandler_base_overlapped::check_later ()
{
  set_close_on_exec (true);
  char buf[MAX_PATH];
  if (!asio_done
      && !(asio_done = CreateEvent (&sec_none_nih, false, false,
				    shared_name (buf, "asio",
						 GetCurrentProcessId ()))))
    api_fatal ("CreateEvent failed, %E");

  InterlockedIncrement (&asio_close_counter);
  if (!new cygthread(flush_async_io, this, "flasio"))
    api_fatal ("couldn't create a thread to track async I/O, %E");
  debug_printf ("started thread to handle asynchronous closing for %s", get_name ());
}

int
fhandler_base_overlapped::close ()
{
  int res;
  int writer = (get_access () & GENERIC_WRITE);
  /* Need to treat non-blocking I/O specially because Windows appears to
     be brain-dead.  We're checking here if the descriptor was ever set
     to nonblocking, rather than checking if it's nonblocking at close time.
     The reason is that applications may switch back to blocking (for the
     sake of some other application accessing this descriptor) without
     performaing any further I/O.  These applications would suffer data
     loss, which this workaround is trying to fix. */
  if (writer && was_nonblocking () && has_ongoing_io ())
    {
      clone (HEAP_3_FHANDLER)->check_later ();
      res = 0;
    }
  else
    {
     /* Cancelling seems to be necessary for cases where a reader is
	 still executing when a signal handler performs a close.  */
      if (!writer)
	CancelIo (get_io_handle ());
      destroy_overlapped ();
      res = fhandler_base::close ();
    }
  return res;
}

int
fhandler_base::ioctl (unsigned int cmd, void *buf)
{
  int res;

  switch (cmd)
    {
    case FIONBIO:
      set_nonblocking (*(int *) buf);
      res = 0;
      break;
    case FIONREAD:
    case TIOCSCTTY:
      set_errno (ENOTTY);
      res = -1;
      break;
    default:
      set_errno (EINVAL);
      res = -1;
      break;
    }

  syscall_printf ("%d = ioctl(%x, %p)", res, cmd, buf);
  return res;
}

int __reg2
fhandler_base::fstat (struct stat *buf)
{
  if (is_fs_special ())
    return fstat_fs (buf);

  switch (get_device ())
    {
    case FH_PIPE:
      buf->st_mode = S_IFIFO | S_IRUSR | S_IWUSR;
      break;
    case FH_PIPEW:
      buf->st_mode = S_IFIFO | S_IWUSR;
      break;
    case FH_PIPER:
      buf->st_mode = S_IFIFO | S_IRUSR;
      break;
    default:
      buf->st_mode = S_IFCHR | STD_RBITS | STD_WBITS | S_IWGRP | S_IWOTH;
      break;
    }

  buf->st_uid = geteuid32 ();
  buf->st_gid = getegid32 ();
  buf->st_nlink = 1;
  buf->st_blksize = PREFERRED_IO_BLKSIZE;

  buf->st_ctim.tv_sec = 1164931200L;	/* Arbitrary value: 2006-12-01 */
  buf->st_ctim.tv_nsec = 0L;
  buf->st_birthtim = buf->st_ctim;
  buf->st_mtim.tv_sec = time (NULL);	/* Arbitrary value: current time,
					   like Linux */
  buf->st_mtim.tv_nsec = 0L;
  buf->st_atim = buf->st_mtim;

  return 0;
}

int __reg2
fhandler_base::fstatvfs (struct statvfs *sfs)
{
  /* If we hit this base implementation, it's some device in /dev.
     Just call statvfs on /dev for simplicity. */
  path_conv pc ("/dev", PC_KEEP_HANDLE);
  fhandler_disk_file fh (pc);
  return fh.fstatvfs (sfs);
}

int
fhandler_base::init (HANDLE f, DWORD a, mode_t bin)
{
  set_io_handle (f);
  access = a;
  a &= GENERIC_READ | GENERIC_WRITE;
  int flags = 0;
  if (a == GENERIC_READ)
    flags = O_RDONLY;
  else if (a == GENERIC_WRITE)
    flags = O_WRONLY;
  else if (a == (GENERIC_READ | GENERIC_WRITE))
    flags = O_RDWR;
  set_flags (flags | bin);
  set_open_status ();
  debug_printf ("created new fhandler_base for handle %p, bin %d", f, rbinary ());
  return 1;
}

int
fhandler_base::dup (fhandler_base *child, int)
{
  debug_printf ("in fhandler_base dup");

  HANDLE nh;
  if (!nohandle () && !archetype)
    {
      if (!DuplicateHandle (GetCurrentProcess (), get_handle (),
			    GetCurrentProcess (), &nh,
			    0, TRUE, DUPLICATE_SAME_ACCESS))
	{
	  debug_printf ("dup(%s) failed, handle %p, %E",
			get_name (), get_handle ());
	  __seterrno ();
	  return -1;
	}

      VerifyHandle (nh);
      child->set_io_handle (nh);
    }
  return 0;
}

int
fhandler_base_overlapped::dup (fhandler_base *child, int flags)
{
  int res = fhandler_base::dup (child, flags) ||
	    ((fhandler_base_overlapped *) child)->setup_overlapped ();
  return res;
}

int fhandler_base::fcntl (int cmd, intptr_t arg)
{
  int res;

  switch (cmd)
    {
    case F_GETFD:
      res = close_on_exec () ? FD_CLOEXEC : 0;
      break;
    case F_SETFD:
      set_close_on_exec ((arg & FD_CLOEXEC) ? 1 : 0);
      res = 0;
      break;
    case F_GETFL:
      res = get_flags ();
      debug_printf ("GETFL: %y", res);
      break;
    case F_SETFL:
      {
	/* Only O_APPEND, O_ASYNC and O_NONBLOCK/O_NDELAY are allowed.
	   Each other flag will be ignored.
	   Since O_ASYNC isn't defined in fcntl.h it's currently
	   ignored as well.  */
	const int allowed_flags = O_APPEND | O_NONBLOCK_MASK;
	int new_flags = arg & allowed_flags;
	/* Carefully test for the O_NONBLOCK or deprecated OLD_O_NDELAY flag.
	   Set only the flag that has been passed in.  If both are set, just
	   record O_NONBLOCK.   */
	if ((new_flags & OLD_O_NDELAY) && (new_flags & O_NONBLOCK))
	  new_flags &= ~OLD_O_NDELAY;
	set_flags ((get_flags () & ~allowed_flags) | new_flags);
      }
      res = 0;
      break;
    case F_GETLK:
    case F_SETLK:
    case F_SETLKW:
	{
	  struct flock *fl = (struct flock *) arg;
	  fl->l_type &= F_RDLCK | F_WRLCK | F_UNLCK;
	  res = mandatory_locking () ? mand_lock (cmd, fl) : lock (cmd, fl);
	}
      break;
    default:
      set_errno (EINVAL);
      res = -1;
      break;
    }
  return res;
}

/* Base terminal handlers.  These just return errors.  */

int
fhandler_base::tcflush (int)
{
  set_errno (ENOTTY);
  return -1;
}

int
fhandler_base::tcsendbreak (int)
{
  set_errno (ENOTTY);
  return -1;
}

int
fhandler_base::tcdrain ()
{
  set_errno (ENOTTY);
  return -1;
}

int
fhandler_base::tcflow (int)
{
  set_errno (ENOTTY);
  return -1;
}

int
fhandler_base::tcsetattr (int, const struct termios *)
{
  set_errno (ENOTTY);
  return -1;
}

int
fhandler_base::tcgetattr (struct termios *)
{
  set_errno (ENOTTY);
  return -1;
}

int
fhandler_base::tcsetpgrp (const pid_t)
{
  set_errno (ENOTTY);
  return -1;
}

int
fhandler_base::tcgetpgrp ()
{
  set_errno (ENOTTY);
  return -1;
}

pid_t
fhandler_base::tcgetsid ()
{
  set_errno (ENOTTY);
  return -1;
}

int
fhandler_base::ptsname_r (char *, size_t)
{
  set_errno (ENOTTY);
  return ENOTTY;
}

/* Normal I/O constructor */
fhandler_base::fhandler_base () :
  status (),
  open_status (),
  access (0),
  io_handle (NULL),
  ino (0),
  _refcnt (0),
  openflags (0),
  rabuf (NULL),
  ralen (0),
  raixget (0),
  raixput (0),
  rabuflen (0),
  unique_id (0),
  archetype (NULL),
  usecount (0)
{
  isclosed (false);
}

/* Normal I/O destructor */
fhandler_base::~fhandler_base ()
{
  if (rabuf)
    free (rabuf);
}

/**********************************************************************/
/* /dev/null */

fhandler_dev_null::fhandler_dev_null () :
	fhandler_base ()
{
}

void
fhandler_base::set_no_inheritance (HANDLE &h, bool not_inheriting)
{
  if (!SetHandleInformation (h, HANDLE_FLAG_INHERIT,
			     not_inheriting ? 0 : HANDLE_FLAG_INHERIT))
    debug_printf ("SetHandleInformation failed, %E");
#ifdef DEBUGGING_AND_FDS_PROTECTED
  if (h)
    setclexec (oh, h, not_inheriting);
#endif
}

bool
fhandler_base::fork_fixup (HANDLE parent, HANDLE &h, const char *name)
{
  HANDLE oh = h;
  bool res = false;
  if (/* !is_socket () && */ !close_on_exec ())
    debug_printf ("handle %p already opened", h);
  else if (!DuplicateHandle (parent, h, GetCurrentProcess (), &h,
			     0, !close_on_exec (), DUPLICATE_SAME_ACCESS))
    system_printf ("%s - %E, handle %s<%p>", get_name (), name, h);
  else
    {
      if (oh != h)
	VerifyHandle (h);
      res = true;
    }
  return res;
}

void
fhandler_base::set_close_on_exec (bool val)
{
  if (!nohandle ())
    set_no_inheritance (io_handle, val);
  close_on_exec (val);
  debug_printf ("set close_on_exec for %s to %d", get_name (), val);
}

void
fhandler_base::fixup_after_fork (HANDLE parent)
{
  debug_printf ("inheriting '%s' from parent", get_name ());
  if (!nohandle ())
    fork_fixup (parent, io_handle, "io_handle");
  /* POSIX locks are not inherited across fork. */
  if (unique_id)
    del_my_locks (after_fork);
}

void
fhandler_base_overlapped::fixup_after_fork (HANDLE parent)
{
  setup_overlapped ();
  fhandler_base::fixup_after_fork (parent);
}

void
fhandler_base::fixup_after_exec ()
{
  debug_printf ("here for '%s'", get_name ());
  if (unique_id && close_on_exec ())
    del_my_locks (after_exec);
  mandatory_locking (false);
}
void
fhandler_base_overlapped::fixup_after_exec ()
{
  setup_overlapped ();
  fhandler_base::fixup_after_exec ();
}

bool
fhandler_base::is_nonblocking ()
{
  return (openflags & O_NONBLOCK_MASK) != 0;
}

void
fhandler_base::set_nonblocking (int yes)
{
  int current = openflags & O_NONBLOCK_MASK;
  int new_flags = yes ? (!current ? O_NONBLOCK : current) : 0;
  openflags = (openflags & ~O_NONBLOCK_MASK) | new_flags;
  if (new_flags)
    was_nonblocking (true);
}

int
fhandler_base::mkdir (mode_t)
{
  if (exists ())
    set_errno (EEXIST);
  else
    set_errno (EROFS);
  return -1;
}

int
fhandler_base::rmdir ()
{
  if (!exists ())
    set_errno (ENOENT);
  else if (!pc.isdir ())
    set_errno (ENOTDIR);
  else
    set_errno (EROFS);
  return -1;
}

DIR *
fhandler_base::opendir (int fd)
{
  set_errno (ENOTDIR);
  return NULL;
}

int
fhandler_base::readdir (DIR *, dirent *)
{
  return ENOTDIR;
}

long
fhandler_base::telldir (DIR *)
{
  set_errno (ENOTDIR);
  return -1;
}

void
fhandler_base::seekdir (DIR *, long)
{
  set_errno (ENOTDIR);
}

void
fhandler_base::rewinddir (DIR *)
{
  set_errno (ENOTDIR);
}

int
fhandler_base::closedir (DIR *)
{
  set_errno (ENOTDIR);
  return -1;
}

int
fhandler_base::fchmod (mode_t mode)
{
  extern int chmod_device (path_conv& pc, mode_t mode);
  if (pc.is_fs_special ())
    return chmod_device (pc, mode);
  /* By default, just succeeds. */
  return 0;
}

int
fhandler_base::fchown (uid_t uid, gid_t gid)
{
  if (pc.is_fs_special ())
    return ((fhandler_disk_file *) this)->fhandler_disk_file::fchown (uid, gid);
  /* By default, just succeeds. */
  return 0;
}

int
fhandler_base::facl (int cmd, int nentries, aclent_t *aclbufp)
{
  int res = -1;
  switch (cmd)
    {
      case SETACL:
	/* By default, just succeeds. */
	res = 0;
	break;
      case GETACL:
	if (!aclbufp)
	  set_errno(EFAULT);
	else if (nentries < MIN_ACL_ENTRIES)
	  set_errno (ENOSPC);
	else
	  {
	    aclbufp[0].a_type = USER_OBJ;
	    aclbufp[0].a_id = myself->uid;
	    aclbufp[0].a_perm = (S_IRUSR | S_IWUSR) >> 6;
	    aclbufp[1].a_type = GROUP_OBJ;
	    aclbufp[1].a_id = myself->gid;
	    aclbufp[1].a_perm = (S_IRGRP | S_IWGRP) >> 3;
	    aclbufp[2].a_type = OTHER_OBJ;
	    aclbufp[2].a_id = ILLEGAL_GID;
	    aclbufp[2].a_perm = S_IROTH | S_IWOTH;
	    res = MIN_ACL_ENTRIES;
	  }
	break;
      case GETACLCNT:
	res = MIN_ACL_ENTRIES;
	break;
      default:
	set_errno (EINVAL);
	break;
    }
  return res;
}

ssize_t
fhandler_base::fgetxattr (const char *name, void *value, size_t size)
{
  set_errno (ENOTSUP);
  return -1;
}

int
fhandler_base::fsetxattr (const char *name, const void *value, size_t size,
			  int flags)
{
  set_errno (ENOTSUP);
  return -1;
}

int
fhandler_base::fadvise (off_t offset, off_t length, int advice)
{
  set_errno (EINVAL);
  return -1;
}

int
fhandler_base::ftruncate (off_t length, bool allow_truncate)
{
  set_errno (EINVAL);
  return -1;
}

int
fhandler_base::link (const char *newpath)
{
  set_errno (EPERM);
  return -1;
}

int
fhandler_base::utimens (const struct timespec *tvp)
{
  if (is_fs_special ())
    return utimens_fs (tvp);

  set_errno (EINVAL);
  return -1;
}

int
fhandler_base::fsync ()
{
  if (!get_handle () || nohandle ())
    {
      set_errno (EINVAL);
      return -1;
    }
  if (pc.isdir ()) /* Just succeed. */
    return 0;
  if (FlushFileBuffers (get_handle ()))
    return 0;

  /* Ignore ERROR_INVALID_FUNCTION because FlushFileBuffers() always fails
     with this code on raw devices which are unbuffered by default.  */
  DWORD errcode = GetLastError();
  if (errcode == ERROR_INVALID_FUNCTION)
    return 0;

  __seterrno_from_win_error (errcode);
  return -1;
}

int
fhandler_base::fpathconf (int v)
{
  int ret;

  switch (v)
    {
    case _PC_LINK_MAX:
      return pc.fs_is_ntfs () || pc.fs_is_samba () || pc.fs_is_nfs ()
	     ? LINK_MAX : 1;
    case _PC_MAX_CANON:
      if (is_tty ())
	return MAX_CANON;
      set_errno (EINVAL);
      break;
    case _PC_MAX_INPUT:
      if (is_tty ())
	return MAX_INPUT;
      set_errno (EINVAL);
      break;
    case _PC_NAME_MAX:
      /* NAME_MAX is without trailing \0 */
      if (!pc.isdir ())
	return NAME_MAX;
      ret = NT_MAX_PATH - strlen (get_name ()) - 2;
      return ret < 0 ? 0 : ret > NAME_MAX ? NAME_MAX : ret;
    case _PC_PATH_MAX:
      /* PATH_MAX is with trailing \0 */
      if (!pc.isdir ())
	return PATH_MAX;
      ret = NT_MAX_PATH - strlen (get_name ()) - 1;
      return ret < 0 ? 0 : ret > PATH_MAX ? PATH_MAX : ret;
    case _PC_PIPE_BUF:
      if (pc.isdir ()
	  || get_device () == FH_FIFO || get_device () == FH_PIPE
	  || get_device () == FH_PIPER || get_device () == FH_PIPEW)
	return PIPE_BUF;
      set_errno (EINVAL);
      break;
    case _PC_CHOWN_RESTRICTED:
      return 1;
    case _PC_NO_TRUNC:
      return 1;
    case _PC_VDISABLE:
      if (is_tty ())
	return _POSIX_VDISABLE;
      set_errno (EINVAL);
      break;
    case _PC_ASYNC_IO:
    case _PC_PRIO_IO:
      break;
    case _PC_SYNC_IO:
      return 1;
    case _PC_FILESIZEBITS:
      return FILESIZEBITS;
    case _PC_2_SYMLINKS:
      return 1;
    case _PC_SYMLINK_MAX:
      return SYMLINK_MAX;
    case _PC_POSIX_PERMISSIONS:
    case _PC_POSIX_SECURITY:
      if (get_device () == FH_FS)
	return pc.has_acls () || pc.fs_is_nfs ();
      set_errno (EINVAL);
      break;
    default:
      set_errno (EINVAL);
      break;
    }
  return -1;
}

/* Overlapped I/O */

int __reg1
fhandler_base_overlapped::setup_overlapped ()
{
  OVERLAPPED *ov = get_overlapped_buffer ();
  memset (ov, 0, sizeof (*ov));
  set_overlapped (ov);
  ov->hEvent = CreateEvent (&sec_none_nih, true, true, NULL);
  io_pending = false;
  return ov->hEvent ? 0 : -1;
}

void __reg1
fhandler_base_overlapped::destroy_overlapped ()
{
  OVERLAPPED *ov = get_overlapped ();
  if (ov && ov->hEvent)
    {
      SetEvent (ov->hEvent);
      CloseHandle (ov->hEvent);
      ov->hEvent = NULL;
    }
  io_pending = false;
  get_overlapped () = NULL;
}

bool __reg1
fhandler_base_overlapped::has_ongoing_io ()
{
  if (!io_pending)
    return false;

  if (!IsEventSignalled (get_overlapped ()->hEvent))
    return true;
  io_pending = false;
  DWORD nbytes;
  GetOverlappedResult (get_output_handle (), get_overlapped (), &nbytes, false);
  return false;
}

fhandler_base_overlapped::wait_return __reg3
fhandler_base_overlapped::wait_overlapped (bool inres, bool writing, DWORD *bytes, bool nonblocking, DWORD len)
{
  if (!get_overlapped ())
    return inres ? overlapped_success : overlapped_error;

  wait_return res = overlapped_unknown;
  DWORD err;
  if (inres)
    /* handle below */;
  else if ((err = GetLastError ()) != ERROR_IO_PENDING)
    res = overlapped_error;
  else if (!nonblocking)
    /* handle below */;
  else if (!writing)
    SetEvent (get_overlapped ()->hEvent);	/* Force immediate WFMO return */
  else
    {
      *bytes = len;				/* Assume that this worked */
      io_pending = true;			/*  but don't allow subsequent */
      res = overlapped_success;			/*  writes until completed */
    }
  if (res == overlapped_unknown)
    {
      DWORD wfres = cygwait (get_overlapped ()->hEvent);
      HANDLE h = writing ? get_output_handle () : get_handle ();
      BOOL wores;
      if (isclosed ())
	{
	  switch (wfres)
	    {
	    case WAIT_OBJECT_0:
	      err = ERROR_INVALID_HANDLE;
	      break;
	    case WAIT_SIGNALED:
	      err = ERROR_INVALID_AT_INTERRUPT_TIME;
	      break;
	    default:
	      err = GetLastError ();
	      break;
	    }
	  res = overlapped_error;
	}
      else
	{
	  /* Cancelling here to prevent races.  It's possible that the I/O has
	     completed already, in which case this is a no-op.  Otherwise,
	     WFMO returned because 1) This is a non-blocking call, 2) a signal
	     arrived, or 3) the operation was cancelled.  These cases may be
	     overridden by the return of GetOverlappedResult which could detect
	     that I/O completion occurred.  */
	  CancelIo (h);
	  wores = GetOverlappedResult (h, get_overlapped (), bytes, false);
	  err = GetLastError ();
	  ResetEvent (get_overlapped ()->hEvent);	/* Probably not needed but CYA */
	  debug_printf ("wfres %u, wores %d, bytes %u", wfres, wores, *bytes);
	  if (wores)
	    res = overlapped_success;	/* operation succeeded */
	  else if (wfres == WAIT_OBJECT_0 + 1)
	    {
	      err = ERROR_INVALID_AT_INTERRUPT_TIME; /* forces an EINTR below */
	      debug_printf ("signal");
	      res = overlapped_error;
	    }
	  else if (wfres == WAIT_OBJECT_0 + 2)
	    pthread::static_cancel_self ();		/* never returns */
	  else if (nonblocking)
	    res = overlapped_nonblocking_no_data;	/* more handling below */
	  else
	    {
	      debug_printf ("GetOverlappedResult failed, h %p, bytes %u, %E", h, *bytes);
	      res = overlapped_error;
	    }
	}
    }

  if (res == overlapped_success)
    {
      debug_printf ("normal %s, %u bytes ispipe() %d", writing ? "write" : "read", *bytes, ispipe ());
      if (*bytes == 0 && !writing && ispipe ())
	res = overlapped_nullread;
    }
  else if (res == overlapped_nonblocking_no_data)
    {
      *bytes = (DWORD) -1;
      set_errno (EAGAIN);
      debug_printf ("no data to read for nonblocking I/O");
    }
  else if (err == ERROR_HANDLE_EOF || err == ERROR_BROKEN_PIPE)
    {
      debug_printf ("EOF, %E");
      *bytes = 0;
      res = overlapped_success;
      if (writing && err == ERROR_BROKEN_PIPE)
	raise (SIGPIPE);
    }
  else
    {
      debug_printf ("res %u, Win32 Error %u", (unsigned) res, err);
      *bytes = (DWORD) -1;
      __seterrno_from_win_error (err);
      if (writing && err == ERROR_NO_DATA)
	raise (SIGPIPE);
    }

  return res;
}

void __reg3
fhandler_base_overlapped::raw_read (void *ptr, size_t& len)
{
  DWORD nbytes;
  bool keep_looping;
  do
    {
      bool res = ReadFile (get_handle (), ptr, len, &nbytes,
			   get_overlapped ());
      switch (wait_overlapped (res, false, &nbytes, is_nonblocking ()))
	{
	case overlapped_nullread:
	  keep_looping = true;
	  break;
	default:	/* Added to quiet gcc */
	case overlapped_success:
	case overlapped_error:
	  keep_looping = false;
	  break;
	}
    }
  while (keep_looping);
  len = (nbytes == (DWORD) -1) ? (size_t) -1 : (size_t) nbytes;
}

ssize_t __reg3
fhandler_base_overlapped::raw_write (const void *ptr, size_t len)
{
  size_t nbytes;
  if (has_ongoing_io ())
    {
      set_errno (EAGAIN);
      nbytes = (size_t) -1;
    }
  else
    {
      size_t chunk;
      if (!max_atomic_write || len < max_atomic_write)
	chunk = MIN (len, INT_MAX);
      else if (is_nonblocking ())
	chunk = len = max_atomic_write;
      else
	chunk = max_atomic_write;

      nbytes = 0;
      DWORD nbytes_now = 0;
      /* Write to fd in smaller chunks, accumulating a total.
	 If there's an error, just return the accumulated total
	 unless the first write fails, in which case return value
	 from wait_overlapped(). */
      while (nbytes < len)
	{
	  size_t left = len - nbytes;
	  size_t len1;
	  if (left > chunk)
	    len1 = chunk;
	  else
	    len1 = left;
	  bool res = WriteFile (get_output_handle (), ptr, len1, &nbytes_now,
				get_overlapped ());
	  switch (wait_overlapped (res, true, &nbytes_now,
				   is_nonblocking (), len1))
	    {
	    case overlapped_success:
	      ptr = ((char *) ptr) + chunk;
	      nbytes += nbytes_now;
	      /* fall through intentionally */
	    case overlapped_error:
	      len = 0;		/* terminate loop */
	    case overlapped_unknown:
	    case overlapped_nullread:
	    case overlapped_nonblocking_no_data:
	      break;
	    }
	}
      if (!nbytes)
	nbytes = (nbytes_now == (DWORD) -1) ? (size_t) -1 : nbytes_now;
    }
  return nbytes;
}
@


1.441
log
@	* fhandler.cc (fhandler_base::facl): Drop CLASS_OBJ entry.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Ditto in noacl case.
	* sec_acl.cc (getacl): Compute useful fake CLASS_OBJ and DEF_CLASS_OBJ
	permission bits based on how these values are generated on Linux.
	Add commants to explain what the code is doing.
	* security.cc (get_attribute_from_acl): Compute group permission based
	on the actual primary group permissions and all secondary user and group
	ACCESS_ALLOWED_ACEs to emulate Linux' behaviour more closely.
	(check_access): Fix typos im comment.
	* include/cygwin/acl.h (MIN_ACL_ENTRIES): Redefine as 3.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d208 2
d1247 7
a1253 2
     be brain-dead  */
  if (writer && is_nonblocking () && has_ongoing_io ())
d1639 2
@


1.440
log
@	* devices.in (dev_cygdrive_storage): Revert mapping to \Device\Null.
	(dev_storage): Ditto for /dev.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::open_null): New method to open a fake
	\Device\Null handler.
	(fhandler_base::open): Fix formatting.  Change O_ACCMODE test to a
	switch statement.  Simplify a test which still tested for a now unused
	create_disposition.
	* fhandler.h (fhandler_base::open_null): Declare.
	(fhandler_netdrive::close): Declare.
	* fhandler_dev.cc (fhandler_dev::open): Open fake \Device\Null handle
	by just calling new open_null method.
	* fhandler_disk_file.cc (fhandler_cygdrive::open): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::open): Call open_null
	rather than setting nohandle.
	(fhandler_netdrive::close): New method.
	* fhandler_registry.cc (fetch_hkey): Fix token in RegOpenUserClassesRoot
	call.  Create valid key for HKEY_CURRENT_CONFIG by mapping to real key
	HKEY_LOCAL_MACHINE\System\CurrentControlSet\Hardware Profiles\Current.
	(fhandler_registry::open): Set nohandle only when using pseudo registry
	handle.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Call open rather
	than just setting nohandle here.
	* fhandler_virtual::fstatvfs): Set ST_RDONLY fs flag.
	* globals.cc (ro_u_null): New readonly UNICODE_STRING for \Device\Null.
	* path.h (path_conv::set_path): Revert previous change caring for
	wide_path.
@
text
@a1739 3
	    aclbufp[3].a_type = CLASS_OBJ;
	    aclbufp[3].a_id = ILLEGAL_GID;
	    aclbufp[3].a_perm = S_IRWXU | S_IRWXG | S_IRWXO;
@


1.439
log
@* external.cc (fillout_pinfo): If start_time is 0, wait a while before
returning the pinfo structure.
* fhandler.cc (fhandler_base::open_setup): Convert from inline.
* fhandler.h (fhandler_base::open_setup): Declare.
* fhandler_console.cc (fhandler_console::open_setup): Always call
fhandler_base::open_setup.
* fhandler_tty.cc (fhandler_pty_slave::open_setup): Ditto.
(fhandler_pty_master::open_setup): Ditto.
@
text
@d510 32
d564 19
a582 17
      case query_read_control:
	access = READ_CONTROL;
	break;
      case query_read_attributes:
	access = READ_CONTROL | FILE_READ_ATTRIBUTES;
	break;
      case query_write_control:
	access = READ_CONTROL | WRITE_OWNER | WRITE_DAC | FILE_WRITE_ATTRIBUTES;
	break;
      case query_write_dac:
	access = READ_CONTROL | WRITE_DAC | FILE_WRITE_ATTRIBUTES;
	break;
      case query_write_attributes:
	access = READ_CONTROL | FILE_WRITE_ATTRIBUTES;
	break;
      default:
	if ((flags & O_ACCMODE) == O_RDONLY)
d584 2
a585 1
	else if ((flags & O_ACCMODE) == O_WRONLY)
d587 2
a588 1
	else
d590 12
a601 10
	if (flags & O_SYNC)
	  options |= FILE_WRITE_THROUGH;
	if (flags & O_DIRECT)
	  options |= FILE_NO_INTERMEDIATE_BUFFERING;
	if (get_major () != DEV_SERIAL_MAJOR && get_major () != DEV_TAPE_MAJOR)
	  {
	    options |= FILE_SYNCHRONOUS_IO_NONALERT;
	    access |= SYNCHRONIZE;
	  }
	break;
d637 1
a637 1
      if (((flags & O_CREAT) || create_disposition == FILE_OVERWRITE)
@


1.438
log
@	* devices.in (dev_storage): Map /dev/zero and /dev/full to \Device\Null.
	* devices.cc: Regenerate.
	* dtable.h (struct dtable): Make fhandler_base friend, rather
	than fhandler_disk_file.
	* fhandler.cc (fhandler_base::open_with_arch): Create unique id.
	(fhandler_base::cleanup): Call del_my_locks.
	(fhandler_base::fcntl): Handle F_GETLK, F_SETLK and F_SETLKW.
	* fhandler.h (fhandler_base::get_dev): Return real device number.
	(fhandler_base::set_unique_id): New inline method.
	(fhandler_disk_file::lock): Drop declaration.
	(fhandler_disk_file::get_dev): New method, return pc.fs_serial_number.
	(fhandler_dev_zero::open): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::close): Move
	del_my_locks call to fhandler_base::open_with_arch.
	(fhandler_disk_file::fcntl): Move handling of locking commands to
	fhandler_base::fcntl.
	(fhandler_base::open_fs): Drop call to NtAllocateLocallyUniqueId.
	* fhandler_zero.cc (fhandler_dev_zero::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	* flock.cc (fixup_lockf_after_exec): Finding a single fhandler is
	enough here.
	(fhandler_base::lock): Replace fhandler_disk_file::lock.  Refuse to lock
	nohandle devices.  Handle read/write test using POSIX flags.  Explain
	why.  Never fail on SEEK_CUR or SEEK_END, rather assume position 0,
	just as Linux.
	* net.cc (fdsock): Create unique id.
@
text
@d723 5
@


1.437
log
@	* fhandler.cc (fhandler_base::fstat): Drop FH_FULL case to align
	/dev/full permissions to Linux.
@
text
@d501 6
d1121 4
d1379 9
@


1.436
log
@* fhandler.h (fhandler_base::cleanup): Mark as extern rather than inline.
* fhandler_base.cc (fhandler_base::cleanup): Define.
* fhandler_tty.cc (fhandler_pty_slave::cleanup): Call fhandler_base::cleanup.
(fhandler_pty_master::cleanup): Ditto.
@
text
@a1252 3
    case FH_FULL:
      buf->st_mode = S_IFCHR | S_IRUSR | S_IWUSR | S_IWGRP | S_IWOTH;
      break;
@


1.435
log
@* fhandler.cc (fhandler_base::close_with_arch): Make sure that the archetype is
deleted when close_with_arch is referenced *via* the archetype.
@
text
@d1112 5
@


1.434
log
@	* fhandler.cc (fhandler_base::lock): Move to flock.cc.
	(fhandler_base::fixup_after_exec): Reset mandatory_locking.
	* fhandler.h (class fhandler_base): Add mandatory_locking status flag.
	Add mandatory_locking accessor methods.  Accommodate change throughout.
	(fhandler_base::mand_lock): Declare.
	(class fhandler_disk_file): Drop in favor of new status flag.
	* (fhandler_disk_file::fcntl): Call need_fork_fixup if mandatory_locking
	flag gets set.
	* flock.cc (fhandler_base::lock): Define here.
	(flock): Handle mandatory_locking.
	(lockf): Ditto.
	(fhandler_base::mand_lock): Define.
@
text
@d1079 2
a1080 3
      if (!--usecount)
	debug_printf ("closing passed in archetype, usecount %d", usecount);
      else
d1082 1
a1082 1
	  debug_printf ("not closing passed in archetype, usecount %d", usecount);
d1085 3
a1087 1
      fh = this;
d1091 5
d1098 2
a1099 11
      cleanup ();
      if (archetype_usecount (-1) == 0)
	{
	  debug_printf ("closing archetype");
	  fh = archetype;
	}
      else
	{
	  debug_printf ("not closing archetype");
	  return 0;
	}
d1102 1
@


1.433
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@a1232 7
int
fhandler_base::lock (int, struct flock *)
{
  set_errno (EINVAL);
  return -1;
}

d1549 1
@


1.432
log
@	* Merge in cygwin-64bit-branch.
@
text
@d219 1
a219 1
void __stdcall
d285 1
a285 1
ssize_t __stdcall
d725 1
a725 1
void __stdcall
d1058 1
a1058 1
ssize_t __stdcall
d1065 1
a1065 1
ssize_t __stdcall
d1281 1
a1281 1
int __stdcall
@


1.431
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d193 1
a193 1
  debug_printf ("flags %p, supplied_bin %p", flags, supplied_bin);
d195 1
a195 1
    debug_printf ("O_TEXT/O_BINARY set in flags %p", bin);
d220 1
a220 1
fhandler_base::raw_read (void *ptr, size_t& ulen)
d222 2
a223 2
#define bytes_read ulen

a224 1
  DWORD len = ulen;
d227 5
a231 3
  ulen = (size_t) -1;
  BOOL res = ReadFile (get_handle (), ptr, len, (DWORD *) &ulen, NULL);
  if (!res)
d234 1
a234 3

      DWORD  errcode = GetLastError ();
      switch (errcode)
d236 2
a237 1
	case ERROR_BROKEN_PIPE:
d239 1
a239 1
	  bytes_read = 0;
d241 4
a244 2
	case ERROR_MORE_DATA:
	  /* `bytes_read' is supposedly valid.  */
d246 1
a246 1
	case ERROR_NOACCESS:
d249 1
a249 1
	      bytes_read = 0;
d266 3
a268 3
	case ERROR_INVALID_FUNCTION:
	case ERROR_INVALID_PARAMETER:
	case ERROR_INVALID_HANDLE:
d272 1
a272 1
	      bytes_read = (size_t) -1;
d276 2
a277 3
	  syscall_printf ("ReadFile %s(%p) failed, %E", get_name (), get_handle ());
	  __seterrno_from_win_error (errcode);
	  bytes_read = (size_t) -1;
a280 1
#undef bytes_read
d391 1
a391 1
  struct __stat64 st;
d519 1
a519 1
  syscall_printf ("(%S, %p)", pc.get_nt_native_path (), flags);
d589 4
a592 5
      /* Starting with Windows 2000, when trying to overwrite an already
	 existing file with FILE_ATTRIBUTE_HIDDEN and/or FILE_ATTRIBUTE_SYSTEM
	 attribute set, CreateFile fails with ERROR_ACCESS_DENIED.
	 Per MSDN you have to create the file with the same attributes as
	 already specified for the file. */
d707 2
a708 2
  debug_printf ("%x = NtCreateFile "
		"(%p, %x, %S, io, NULL, %x, %x, %x, %x, NULL, 0)",
d712 1
a712 1
  syscall_printf ("%d = fhandler_base::open(%S, %p)",
d731 1
a731 1
  if (copied_chars)
d737 1
a737 14
  len -= copied_chars;
  if (!len)
    {
      len = (size_t) copied_chars;
      goto out;
    }

  raw_read (ptr + copied_chars, len);
  if (!copied_chars)
    /* nothing */;
  else if ((ssize_t) len > 0)
    len += copied_chars;
  else
    len = copied_chars;
a779 18
#ifndef NOSTRACE
  if (strace.active ())
    {
      char buf[16 * 6 + 1];
      char *p = buf;

      for (int i = 0; i < copied_chars && i < 16; ++i)
	{
	  unsigned char c = ((unsigned char *) ptr)[i];
	  __small_sprintf (p, " %c", c);
	  p += strlen (p);
	}
      *p = '\0';
      debug_printf ("read %d bytes (%s%s)", copied_chars, buf,
		    copied_chars > 16 ? " ..." : "");
    }
#endif

d817 1
a817 1
	  debug_printf ("%p = NtFsControlFile(%S, FSCTL_SET_SPARSE)",
d989 2
a990 2
_off64_t
fhandler_base::lseek (_off64_t offset, int whence)
d1042 1
a1042 1
  _off64_t res = fpi.CurrentByteOffset.QuadPart;
d1059 1
a1059 1
fhandler_base::pread (void *, size_t, _off64_t)
d1066 1
a1066 1
fhandler_base::pwrite (void *, size_t, _off64_t)
d1234 1
a1234 1
fhandler_base::lock (int, struct __flock64 *)
d1241 1
a1241 1
fhandler_base::fstat (struct __stat64 *buf)
d1322 1
a1322 1
	  debug_printf ("dup(%s) failed, handle %x, %E",
d1342 1
a1342 1
int fhandler_base::fcntl (int cmd, void *arg)
d1352 1
a1352 1
      set_close_on_exec (((int) arg & FD_CLOEXEC) ? 1 : 0);
d1357 1
a1357 1
      debug_printf ("GETFL: %p", res);
d1366 1
a1366 1
	int new_flags = (int) arg & allowed_flags;
d1650 1
a1650 1
fhandler_base::fchown (__uid32_t uid, __gid32_t gid)
d1659 1
a1659 1
fhandler_base::facl (int cmd, int nentries, __aclent32_t *aclbufp)
d1716 1
a1716 1
fhandler_base::fadvise (_off64_t offset, _off64_t length, int advice)
d1723 1
a1723 1
fhandler_base::ftruncate (_off64_t length, bool allow_truncate)
d1937 1
a1937 1
	  debug_printf ("wfres %d, wores %d, bytes %u", wfres, wores, *bytes);
d1952 1
a1952 1
	      debug_printf ("GetOverLappedResult failed, h %p, bytes %u, %E", h, *bytes);
d2012 1
a2012 1
  len = (size_t) nbytes;
d2022 1
a2022 1
      nbytes = (DWORD) -1;
d2028 1
a2028 1
	chunk = len;
d2036 1
a2036 1
      /* Write to fd in smaller chunks, accumlating a total.
d2066 1
a2066 1
	nbytes = nbytes_now;
@


1.430
log
@	* fhandler.cc (fhandler_base::write): Don't attempt to sparsify
	an already sparse file.  Drop check for FILE_SUPPORTS_SPARSE_FILES
	flag.  Explicitely set FILE_ATTRIBUTE_SPARSE_FILE attribute in
	cached attributes.
	(fhandler_base::lseek): Only set did_lseek if sparseness is supported.
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Don't attempt
	to sparsify an already sparse file.  Explicitely set
	FILE_ATTRIBUTE_SPARSE_FILE attribute in cached attributes.
	* mount.cc (oopt): Add "sparse" flag.
	(fillout_mntent): Ditto.
	* path.h (enum path_types): Add PATH_SPARSE.
	(path_conv::support_sparse): New method.
	(path_conv::fs_flags): Constify.
	(path_conv::fs_name_len): Ditto.
	include/sys/mount.h: Replace unused MOUNT_MIXED flag with MOUNT_SPARSE.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d1272 1
a1272 1
int __stdcall
d1875 1
a1875 1
int __stdcall __attribute__ ((regparm (1)))
d1886 1
a1886 1
void __stdcall __attribute__ ((regparm (1)))
d1900 1
a1900 1
bool __stdcall __attribute__ ((regparm (1)))
d1914 1
a1914 1
fhandler_base_overlapped::wait_return __stdcall __attribute__ ((regparm (3)))
d2022 1
a2022 1
void __stdcall __attribute__ ((regparm (3)))
d2047 1
a2047 1
ssize_t __stdcall __attribute__ ((regparm (3)))
@


1.429
log
@whitespace cleanup
@
text
@a819 3
  IO_STATUS_BLOCK io;
  FILE_POSITION_INFORMATION fpi;
  FILE_STANDARD_INFORMATION fsi;
d823 4
d830 1
d838 1
a838 2
	     >= fsi.EndOfFile.QuadPart + (128 * 1024)
	  && (pc.fs_flags () & FILE_SUPPORTS_SPARSE_FILES))
d846 3
d1078 2
a1079 1
  did_lseek (true);
@


1.428
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d1225 1
a1225 1
         still executing when a signal handler performs a close.  */
@


1.428.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d391 1
a391 1
  struct stat st;
d1017 2
a1018 2
off_t
fhandler_base::lseek (off_t offset, int whence)
d1070 1
a1070 1
  off_t res = fpi.CurrentByteOffset.QuadPart;
d1086 1
a1086 1
fhandler_base::pread (void *, size_t, off_t)
d1093 1
a1093 1
fhandler_base::pwrite (void *, size_t, off_t)
d1261 1
a1261 1
fhandler_base::lock (int, struct flock *)
d1268 1
a1268 1
fhandler_base::fstat (struct stat *buf)
d1677 1
a1677 1
fhandler_base::fchown (uid_t uid, gid_t gid)
d1743 1
a1743 1
fhandler_base::fadvise (off_t offset, off_t length, int advice)
d1750 1
a1750 1
fhandler_base::ftruncate (off_t length, bool allow_truncate)
@


1.428.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d1225 1
a1225 1
	 still executing when a signal handler performs a close.  */
@


1.428.2.3
log
@	* fcntl.cc (fcntl64): Make arg an intptr_t.  Add comment to explain a
	potential type problem.  Fix syscall_printf.
	(_fcntl): Make arg an intptr_t.
	* fhandler.cc (fhandler_base::fcntl): Ditto.
	* fhandler_socket.cc (fhandler_socket::fcntl): Ditto.
	* fhandler.h: Align declarations.
@
text
@d1369 1
a1369 1
int fhandler_base::fcntl (int cmd, intptr_t arg)
d1379 1
a1379 1
      set_close_on_exec ((arg & FD_CLOEXEC) ? 1 : 0);
d1393 1
a1393 1
	int new_flags = arg & allowed_flags;
@


1.428.2.4
log
@	* cygthread.cc: Fix usage of %p in debug printfs, throughout.
	* dcrt0.cc: Ditto.
	* dtable.cc: Ditto.
	* errno.cc: Ditto.
	* exceptions.cc: Ditto.
	* fhandler.cc: Ditto.
	* fhandler_console.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.

	* fhandler_clipboard.cc (cygnativeformat): Define as UINT.
	(fhandler_dev_clipboard::read): Ditto for local format variable.
	Use casts to compare off_t with size_t value.
	* fhandler_console.cc (fhandler_console::ioctl): Avoid compiler
	warnings.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Fix cast.
	* include/sys/dirent.h (struct __DIR): Define __d_internal as uintptr_t,
	rather than unsigned int.

	And pull in changes from HEAD.
@
text
@d193 1
a193 1
  debug_printf ("flags %y, supplied_bin %y", flags, supplied_bin);
d195 1
a195 1
    debug_printf ("O_TEXT/O_BINARY set in flags %y", bin);
d519 1
a519 1
  syscall_printf ("(%S, %y)", pc.get_nt_native_path (), flags);
d708 1
a708 1
  debug_printf ("%y = NtCreateFile "
d713 1
a713 1
  syscall_printf ("%d = fhandler_base::open(%S, %y)",
d845 1
a845 1
	  debug_printf ("%y = NtFsControlFile(%S, FSCTL_SET_SPARSE)",
d1384 1
a1384 1
      debug_printf ("GETFL: %y", res);
@


1.428.2.5
log
@	* include/cygwin/acl.h (struct __acl32): Drop.  Use struct acl or
	aclent_t throughout instead.
	* sec_acl.cc (aclcheck32): Mark currently unused variables as unused.
	(lacl32): Disable on x86_64.
	(acl): Alias to acl32 on x86_64.
	(facl): Alias to facl32 on x86_64.
	(aclcheck): Alias to aclcheck32 on x86_64.
	(aclsort): Alias to aclsort32 on x86_64.
	(acltomode): Alias to acltomode32 on x86_64.
	(aclfrommode): Alias to aclfrommode32 on x86_64.
	(acltopbits): Alias to acltopbits32 on x86_64.
	(aclfrompbits): Alias to aclfrompbits32 on x86_64.
	(acltotext): Alias to acltotext32 on x86_64.
	(aclfromtext): Alias to aclfromtext32 on x86_64.
	* resource.cc (getrlimit): Use correct cast to rlim_t rather than DWORD.
	* sched.cc (sched_setparam): Drop ThreadPriority and all code setting
	it.
@
text
@d1686 1
a1686 1
fhandler_base::facl (int cmd, int nentries, aclent_t *aclbufp)
@


1.428.2.6
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d709 1
a709 1
		"(%p, %y, %S, io, NULL, %y, %y, %y, %y, NULL, 0)",
d1349 1
a1349 1
	  debug_printf ("dup(%s) failed, handle %p, %E",
d1964 1
a1964 1
	  debug_printf ("wfres %u, wores %d, bytes %u", wfres, wores, *bytes);
@


1.428.2.7
log
@Pull in changes from HEAD
@
text
@d820 3
a825 4
      IO_STATUS_BLOCK io;
      FILE_POSITION_INFORMATION fpi;
      FILE_STANDARD_INFORMATION fsi;

a828 1
	  && !has_attribute (FILE_ATTRIBUTE_SPARSE_FILE)
d836 2
a837 1
	     >= fsi.EndOfFile.QuadPart + (128 * 1024))
a844 3
	  if (NT_SUCCESS (status))
	    pc.file_attributes (pc.file_attributes ()
				| FILE_ATTRIBUTE_SPARSE_FILE);
d1074 1
a1074 2
  if (pc.support_sparse ())
    did_lseek (true);
@


1.428.2.8
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d1272 1
a1272 1
int __reg2
d1875 1
a1875 1
int __reg1
d1886 1
a1886 1
void __reg1
d1900 1
a1900 1
bool __reg1
d1914 1
a1914 1
fhandler_base_overlapped::wait_return __reg3
d2022 1
a2022 1
void __reg3
d2047 1
a2047 1
ssize_t __reg3
@


1.428.2.9
log
@	* fhandler.cc (fhandler_base::raw_read): Rearrange code to use
	NtReadFile and to fix problem using pointer to wrongly sized variable
	on x86_64.
	(fhandler_base::read): Drop redundant code.
	* fhandler_disk_file.cc (fhandler_disk_file::pread): Fix function
	to not read the information twice.  Handle STATUS_END_OF_FILE.
@
text
@d220 1
a220 1
fhandler_base::raw_read (void *ptr, size_t& len)
d222 2
a223 2
  NTSTATUS status;
  IO_STATUS_BLOCK io;
d225 1
d228 3
a230 5
  status = NtReadFile (get_handle (), NULL, NULL, NULL, &io, ptr, len,
		       NULL, NULL);
  if (NT_SUCCESS (status))
    len = io.Information;
  else
d233 3
a235 1
      switch (status)
d237 1
a237 2
	case STATUS_END_OF_FILE:
	case STATUS_PIPE_BROKEN:
d239 1
a239 1
	  len = 0;
d241 2
a242 4
	case STATUS_MORE_ENTRIES:
	case STATUS_BUFFER_OVERFLOW:
	  /* `io.Information' is supposedly valid.  */
	  len = io.Information;
d244 1
a244 1
	case STATUS_ACCESS_VIOLATION:
d247 1
a247 1
	      len = 0;
d270 1
a270 1
	      len = (size_t) -1;
d274 3
a276 2
	  __seterrno_from_nt_status (status);
	  len = (size_t) -1;
d280 1
d732 1
a732 1
  if (copied_chars || !len)
d738 14
a751 1
  raw_read (ptr, len);
d794 18
@


1.428.2.10
log
@	* fhandler.cc (fhandler_base::raw_read): Replace accidentally left in
	Win32 error codes with equivalent status codes.
@
text
@d266 3
a268 3
	case STATUS_INVALID_DEVICE_REQUEST:
	case STATUS_INVALID_PARAMETER:
	case STATUS_INVALID_HANDLE:
@


1.428.2.11
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@d589 5
a593 4
      /* Trying to overwrite an already existing file with FILE_ATTRIBUTE_HIDDEN
	 and/or FILE_ATTRIBUTE_SYSTEM attribute set, NtCreateFile fails with
	 STATUS_ACCESS_DENIED.  Per MSDN you have to create the file with the
	 same attributes as already specified for the file. */
@


1.428.2.12
log
@	* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Fix typo in
	debug_printf.
	(fhandler_base_overlapped::raw_read): Handle size difference between
	DWORD and {s}size_t platform-independently.
	(fhandler_base_overlapped::raw_write): Ditto.  Fix typo in comment.
@
text
@d1952 1
a1952 1
	      debug_printf ("GetOverlappedResult failed, h %p, bytes %u, %E", h, *bytes);
d2012 1
a2012 1
  len = (nbytes == (DWORD) -1) ? (size_t) -1 : (size_t) nbytes;
d2022 1
a2022 1
      nbytes = (size_t) -1;
d2028 1
a2028 1
	chunk = MIN (len, INT_MAX);
d2036 1
a2036 1
      /* Write to fd in smaller chunks, accumulating a total.
d2066 1
a2066 1
	nbytes = (nbytes_now == (DWORD) -1) ? (size_t) -1 : nbytes_now;
@


1.427
log
@Christopher Faylor <me.cygwin2012@@cgf.cx>
* fhandler.h (wait_return): Add overlapped_nullread.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Detect zero-byte
read as a special case.
(fhandler_base_overlapped::raw_read): Keep looping when zero-byte read detected
without EOF.
(fhandler_base_overlapped::raw_write): Quiet gcc warning by adding
overlapped_nullread to switch statement even though it will never actually be
hit.
@
text
@d34 1
d1943 1
a1943 1
	    case WAIT_OBJECT_0 + 1:
@


1.426
log
@	* Throughout, replace usage of w32api's min with MIN from sys/param.h.
@
text
@d1985 5
a1989 1
    debug_printf ("normal %s, %u bytes", writing ? "write" : "read", *bytes);
d2027 3
d2086 1
@


1.425
log
@tcgetsid: fix return type

* include/sys/termios.h (tcgetsid): Fix return type.
* termios.cc (tcgetsid): Likewise.
* fhandler_termios.cc (fhandler_termios::tcgetsid): Likewise.
* fhandler.h (fhandler_base): Likewise.
* fhandler.cc (fhandler_base::tcgetsid): Likewise.
@
text
@d17 1
d953 1
a953 1
      const int frag = min (nbytes, (ssize_t) iovptr->iov_len);
d1005 1
a1005 1
      const int frag = min (nbytes, (ssize_t) iovptr->iov_len);
@


1.424
log
@* fhandler.cc (fhandler_base_overlapped::has_ongoing_io): Don't block
GetOverlappedResult since previous IsEventSignalled will have reset the handle.
* select.cc (cygwin_select): Remove space before parentheses in syscall
debugging output.
(pipe_data_available): Streamline if block.
@
text
@d1467 1
a1467 1
int
@


1.423
log
@* syscalls.cc (dup3): Fix debug typo.
* fhandler.cc (flush_async_io): Assume only called for writer.  Call
GetOverlappedResult directly rather than kluding call to has_ongoing_io.
(fhandler_base_overlapped::close): Only start flush thread when closing write
handle.  Only cancel I/O when reading.
@
text
@d1903 1
a1903 1
  GetOverlappedResult (get_output_handle (), get_overlapped (), &nbytes, true);
@


1.422
log
@* cygheap.h (cygheap_fdget::~cygheap_fdget): Simplify now that refcnt reports
reference count changes itself.
* fhandler.cc (fhandler_base::reset): Set _refcnt to 0.
* fhandler.h (fhandler_base::refcnt): Report refcnt when debugging.
* select.cc (cygwin_select): Set return_on_signal to indicate when select
should be interrupted.
(select_stuff::wait): Keep looping unless return_on_signal is set.
* select.h (select_stuff::return_on_signal): New variable.
(select_stuff::select_stuff): Zero return_on_signal.
@
text
@d1159 4
a1162 5
  debug_only_printf ("waiting for %s I/O for %s",
		     (fh->get_access () & GENERIC_WRITE) ? "write" : "read",
		     fh->get_name ());
  SetEvent (fh->get_overlapped ()->hEvent); /* force has_ongoing_io to block */
  bool res = fh->has_ongoing_io ();
d1212 1
d1215 1
a1215 1
  if (is_nonblocking () && has_ongoing_io ())
d1224 2
a1225 1
      CancelIo (get_io_handle ());
@


1.421
log
@* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use correct value in
switch statement.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d53 1
@


1.420
log
@* fhandler.cc (fhandler_base::close): Move setting isclosed() from here to
closed().
(fhandler_base_overlapped::close): Correct comment.
(fhandler_base_overlapped::destroy_overlapped): Signal overlapped event before
closing it to potentially wake up a waiting thread.
(fhandler_base_overlapped::wait_overlapped): Expand setting of err when closed
to encompass non-signal event.  Test for a cancel event before making
nonblocking decisions.
* syscalls.cc (close): Set closed flag here so that any concurrently executing
functions will be notified ASAP.
@
text
@d1934 1
a1934 1
	  switch (err)
@


1.419
log
@* exceptions.cc (set_signal_mask): Remove useless debugging output.
* fhandler.cc (fhandler_base::write): Ditto.
(fhandler_base_overlapped::close): Cancel any ongoing I/O before closing.
* syscalls.cc (write): Default to always reporting all writes in strace output
via syscall_printf.
* wait.cc (wait4): Fix debugging output.  Use standard syscall leaver output.
@
text
@a1150 1
  isclosed (true);
d1221 2
a1222 3
      /* Cancelling seems to be necessary for cases where a reader is
	 still executing either in another thread or when a signal handler
	 performs a close.  */
d1883 1
d1933 15
a1947 1
	wores = 0;	/* closed in another thread or via signal handler */
d1961 17
a1977 17
	}
      if (wores)
	res = overlapped_success;	/* operation succeeded */
      else if (wfres == WAIT_OBJECT_0 + 1)
	{
	  err = ERROR_INVALID_AT_INTERRUPT_TIME; /* forces an EINTR below */
	  debug_printf ("signal");
	  res = overlapped_error;
	}
      else if (nonblocking)
	res = overlapped_nonblocking_no_data;	/* more handling below */
      else if (wfres == WAIT_OBJECT_0 + 2)
	pthread::static_cancel_self ();		/* never returns */
      else
	{
	  debug_printf ("GetOverLappedResult failed, h %p, bytes %u, %E", h, *bytes);
	  res = overlapped_error;
@


1.418
log
@Implement fhandler reference counting.
* cygheap.h
(cygheap_fdmanip::release): Make virtual.
(cygheap_fdnew::~cygheap_fdnew): New destructor increments reference count when
fd has been allocated.
(cygheap_fdget::fh): New (old?) field.
(cygheap_fdget::cygheap_fdget): Increment reference count when we've found an
active fd.  Set fh appropriately.
(cygheap_fdget::~cygheap_fdget): Decrement reference count when appropriate.
Delete fh if reference count goes to zero.
(cygheap_fdget::release): New function.  Do more bookkeping on release.
* dtable.cc (dtable::release): Change from void to boolean return.  Only delete
the fhandler when its reference count is <= 0 (this should be a fairly unusual
case).  Return true if fhandler has been deleted.
(cygwin_attach_handle_to_fd): Increment reference count when fh is assigned.
(dtable::init_std_file_from_handle): Ditto.
* dtable.h (dtable::release): Change return to boolean.
* fhandler.cc (fhandler_base::fhandler_base): Set new isclosed flag to false.
Set _refcnt to zero.
(fhandler_base::close): Simplify paranoid debugging output.  Set new isclosed()
flag.
(fhandler_base_overlapped::wait_overlapped): Use isclosed() flag to avoid
querying the exception handle.
* fhandler.h (fhandler_base::_refcnt): New field.
(fhandler_base::refcnt): New function.
(fhandler_base::isclosed): Implement.
(fhandler_base::fhandler_base): Set isclosed to false.
* syscalls.cc: Remove space after function before parentheses for several
strace printfs.
(dup): Add standard strace "leaver" code.
(dup2): Ditto.
(dup3): Ditto.
(remove): Ditto.
(getpid): Ditto.
(getppid): Ditto.
(lseek64): Fix strace debugging to correctly use %R.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Avoid sending signals to
other processes if we're debugging since it can cause a deadlock with the
calling debugger.
* exceptions.cc (_cygtls::call_signal_handler): Add debugging-only strace
output.
@
text
@d842 2
a843 2
	  syscall_printf ("%p = NtFsControlFile(%S, FSCTL_SET_SPARSE)",
			  status, pc.get_nt_native_path ());
d848 1
a848 4
    {
      debug_printf ("binary write");
      res = raw_write (ptr, len);
    }
d1222 4
@


1.417
log
@* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Fix unresolved
access of wores in successful situations.
@
text
@d1151 1
a1151 3
      paranoid_printf ("CloseHandle (%d <%s>) failed", get_handle (),
		       get_name ());

d1154 1
d1487 1
d1498 1
d1932 2
a1933 2
      if (wfres == WAIT_OBJECT_0 + 1 && !get_overlapped ())
	wores = 0;
@


1.416
log
@* exceptions.cc (_cygtls::call_signal_handler): Fix debugging to not go to
console.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Add temporary kludge
to work around problem of make closing a handler while it is being read.
* gendef (sigdelayed): Don't call a function if sig has been cleared.
* sigproc.h (cygwait): Simplify slightly.
@
text
@d1942 1
a1942 1
	  BOOL wores = GetOverlappedResult (h, get_overlapped (), bytes, false);
@


1.415
log
@* cygthread.h (cygthread::name): Very minor formatting tweak.
* exceptions.cc (_cygtls::call_signal_handler): Add paranoid debugging output.
* sigproc.h (cygwait): Call signal handler when signal is detected and loop as
appropriate.
* fhandler.h (fhandler_base_overlapped::wait_return): Remove overlapped_signal.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Remove restartable
signal accommodations in light of cygwait improvements.
(fhandler_base_overlapped::raw_read): Remove now-obsolete signal loop behavior.
(fhandler_base_overlapped::raw_write): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* ioctl.cc (ioctl): Add standard syscall introducer and leaver debug output.
@
text
@d1928 1
d1930 17
a1946 12
      DWORD wfres = cygwait (get_overlapped ()->hEvent);
      /* Cancelling here to prevent races.  It's possible that the I/O has
	 completed already, in which case this is a no-op.  Otherwise,
	 WFMO returned because 1) This is a non-blocking call, 2) a signal
	 arrived, or 3) the operation was cancelled.  These cases may be
	 overridden by the return of GetOverlappedResult which could detect
	 that I/O completion occurred.  */
      CancelIo (h);
      BOOL wores = GetOverlappedResult (h, get_overlapped (), bytes, false);
      err = GetLastError ();
      ResetEvent (get_overlapped ()->hEvent);	/* Probably not needed but CYA */
      debug_printf ("wfres %d, wores %d, bytes %u", wfres, wores, *bytes);
d1952 1
a1952 1
	  debug_printf ("unhandled signal");
@


1.414
log
@Rename cygWFMO to cygwait throughout and use the magic of polymorphism to "wait
for stuff".
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use simplified arg
form of cygwait.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_audio.cc (fhandler_dev_dsp::Audio_out::waitforspac): Ditto.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* select.cc (cygwin_select): Ditto.
* sigproc.h (cygwait): Rename from cygWFMO.  Define two argument and single
argument forms of this function.
* fhandler_tty.cc (fhandler_pty_slave::open): Use method to query if tty is
open.
(fhandler_pty_slave::read): Send SIGHUP when master is detected as closed.
(fhandler_pty_common::close): Close input_available_event in callers since
master may need to signal it first.
(fhandler_pty_master::close): Lie and set input_available_event when closing,
then close input_available_event.
(fhandler_pty_slave::close): Close input_available_event explicitly here.
* tty.h (tty::is_master_closed): Declare new method.
@
text
@d1945 3
a1947 8
	  if (_my_tls.call_signal_handler ())
	    res = overlapped_signal;
	  else
	    {
	      err = ERROR_INVALID_AT_INTERRUPT_TIME; /* forces an EINTR below */
	      debug_printf ("unhandled signal");
	      res = overlapped_error;
	    }
a1961 2
  else if (res == overlapped_signal)
    debug_printf ("handled signal");
a1998 3
	case overlapped_signal:
	  keep_looping = true;
	  break;
a2051 2
	    case overlapped_signal:
	      break;			/* keep looping */
@


1.413
log
@* exceptions.cc (exception::handle): Drop abbreviation for "exception" since I
never remember what it stands for.
(sig_handle_tty_stop): Remove obsolete call to sig_handle_tty_stop.
(_cygtls::call_signal_handler): Rework to grab signal information from
_main_tls if none is set for _my_tls.  Try harder to keep thread locked.
(reset_signal_arrived): Delete.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use new cygWFMO call
to wait for an event + standard cygwin stuff.  Modify debug output to
acccomodate new function.
* fhandler_console.cc (fhandler_console::read): Replace WaitForMultipleObjects
with cygWFMO.
* fhandler_socket.cc (get_inet_addr): Add comment.
* gendef (_sigdelayed): Remove call to reset_signal_arrived.
* sigproc.cc (_cygtls::signal_exit): Don't close my_readsig here unless we're
in the signal thread.
(create_signal_arrived): Create signal_arrived as auto-reset so that only one
thread is woken when a signal arrives.
* sigproc.h (cygWFMO): New function.
(reset_signal_arrived): Delete declaration.
@
text
@d1929 1
a1929 1
      DWORD wfres = cygWFMO (1, INFINITE, get_overlapped ()->hEvent);
@


1.412
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@a1927 3
      HANDLE w4[3] = { get_overlapped ()->hEvent, signal_arrived,
		       pthread::get_cancel_event () };
      DWORD n = w4[2] ? 3 : 2;
d1929 1
a1929 1
      DWORD wfres = WaitForMultipleObjects (n, w4, false, INFINITE);
d1960 1
a1960 1
	  debug_printf ("GetOverLappedResult failed, h %p, bytes %u, w4: %p, %p, %p %E", h, *bytes, w4[0], w4[1], w4[2]);
@


1.411
log
@	* fhandler.cc (fhandler_base::open): Fix comment a bit more.
@
text
@d710 1
a710 1
  syscall_printf ("%d = fhandler_base::open (%S, %p)",
d1254 1
a1254 1
  syscall_printf ("%d = ioctl (%x, %p)", res, cmd, buf);
@


1.410
log
@	* fhandler.cc (fhandler_base::open): Fix typos in comment.
@
text
@d627 1
a627 1
	     because Windows only guarantees to update the metadata when
@


1.409
log
@* sigproc.cc (remove_proc): Don't terminate the currently executing thread.
@
text
@d627 1
a627 1
	     because Windows only gurantees to update the metadata when
d629 2
a630 2
	     on every fstat to enforce POSIXy stat behaviour is exceessivly
	     slow, compared to open/close the file when changing the file's
@


1.408
log
@* cygwin.din (ptsname_r): Export.
* fhandler.cc (fhandler_base::ptsname_r): Define.
* fhandler.h (fhandler_base::ptsname): Delete.
(fhandler_base::ptsname_r): Declare.
(fhandler_pty_master::ptsname_r): Declare.
* fhandler_tty.cc (fhandler_pty_master::ptsname): Delete.
(fhandler_pty_master::ptsname_r): New reentrant function derived from previous
ptsname.
* syscalls.cc (ptsname_r): Implement new function with functionality similar to
Linux.
(ptsname): Use ptsname_r () to fill out buf.
* include/cygwin/stdlib.h (ptsname_r): Declare.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 255 to reflect
export of ptsname_r.
* pinfo.cc (pinfo::wait): Return bool rather than int.
* pinfo.h (info::wait): Ditto.
(pinfo::reattach): Define !defined(_SIGPROC_H) case for consistency.
* sigproc.cc (child_info_spawn::reattach_children): Use correct dwProcessId
rather than pid when duplicating handle.
@
text
@d31 1
d41 3
d1159 53
d1216 9
a1224 1
  if (is_nonblocking () && io_pending)
d1226 2
a1227 2
      DWORD bytes;
      wait_overlapped (1, !!(get_access () & GENERIC_WRITE), &bytes, false);
d1229 1
a1229 2
  destroy_overlapped ();
  return fhandler_base::close ();
a1480 6
void
fhandler_base::operator delete (void *p)
{
  cfree (p);
}

d1897 1
a1897 4
    {
      set_errno (EAGAIN);
      return true;
    }
d1900 1
a1900 1
  GetOverlappedResult (get_output_handle (), get_overlapped (), &nbytes, 0);
d1988 1
a1988 1
      debug_printf ("res %u, err %u", (unsigned) res, err);
d2028 4
a2031 1
    nbytes = (DWORD) -1;
@


1.407
log
@	* fhandler.cc (CHUNK_SIZE): Drop NO_COPY.
@
text
@d1410 7
@


1.406
log
@	* fhandler.cc (off_current): Define local in fhandler_base::raw_write.
	Drop erroneous NO_COPY, add _RDATA to make R/O.
	(off_append): Ditto.
	* globals.cc (_RDATA): Move definition from here...
	* winsup.h: ...to here.
@
text
@d36 1
a36 1
static NO_COPY const int CHUNK_SIZE = 1024; /* Used for crlf conversions */
@


1.405
log
@* fhandler.h (fhandler_pipe::create_selectable): Remove optional argument, take
an options argument for CreateNamedPipe/CreateFile.  Change handle arguments to
expect pointers.
(fhandler_fifo::fifo_state): Delete.
(fhandler_fifo::dummy_client): Ditto.
(fhandler_fifo::open_nonserver): Ditto.
(fhandler_fifo::wait_state): Ditto.
(fhandler_fifo::raw_write): Ditto.
(fhandler_fifo::read_ready): New field.
(fhandler_fifo::write_ready): Ditto.
(fhandler_fifo::wait): Modify argument.
(fhandler_fifo::fifo_name): Add a new argument.
(fhandler_fifo::fixup_after_fork): New function.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove initialization of
expunged elements.  Initialize new handles to NULL.
(fhandler_fifo::open_nonserver): Delete.
(fnevent): New macro for creating a named event.
(fnpipe): New macro for creating a unique named pipe name.
(create_pipe): New macro for simplification of named pipe creation.
(fhandler_fifo::fifo_name): Use new argument when creating a shared name.
(fhandler_fifo::open): Rewrite.  Use events to synchronize.
(pure_debug_printf): New macro, active only when DEBUGGING.
(fhandler_fifo::wait): Rewrite to wait for new fifo events which are supplied
as a parameter.
(fhandler_fifo::raw_read): Rewrite to use handle mechanism to detect
client-side disconnect.
(fhandler_fifo::raw_write): Delete.
(fhandler_fifo::close): Remove accommodations for expunged fields.  Close event
handles.
(fhandler_fifo::dup): Remove accommodations for expunged fields.  Duplicate
event handles.
(fhandler_fifo::fixup_after_fork): New function.  Perform fixups on event
handles.
(fhandler_fifo::set_close_on_exec): Remove accommodations for expunged fields.
Set inheritance for new handle fields.
* miscfuncs.cc (CreatePipeOverlapped): Accommodate changes in
fhandler_pipe::create_selectable.
* tty.cc (tty::not_allocated): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create_selectable): Accept an extra open_mode argument.  Pass
arguments by reference and allow opening one end of the pipe at a time.
* sys/strace.h (debug_only_printf): Define new macro which calls debug_printf
only when DEBUGGING is defined.
@
text
@a277 3
static NO_COPY LARGE_INTEGER off_current = { QuadPart:FILE_USE_FILE_POINTER_POSITION };
static NO_COPY LARGE_INTEGER off_append = { QuadPart:FILE_WRITE_TO_END_OF_FILE };

d283 4
@


1.404
log
@* dtable.cc (dtable::delete_archetype): Improve debugging output.
(dtable::init_std_file_from_handle): Close console handle early, before
initialization.  Build up openflags for passing to open_setup, just to be safe.
(last_tty_dev): New variable.
(fh_last_tty_dev): New macro.
(fh_alloc): Try again to keep track of previously opened tty, this time by just
saving the device and using that to potentially open an archetype.  Avoid
setting the "/dev/tty" name if the creation of the fhandler failed.
(build_fh_pc): Remove unused second argument.  Reorganize how and where the
name is set.  Set last_tty_dev as appropriate.  Avoid a NULL dereference in a
debug printf.
* dtable.h (build_fh_pc): Reflect removal of second parameter.
* fhandler.cc (fhandler_base::reset): Use new '<<' operator to copy pc since it
preserves any potentially previously set name.
(fhandler_base::set_name): Ditto.
* fhandler.h (fhandler_*::clone): Throughout use ccalloc to allocate new
fhandler, primarily to make sure that pc field is properly zeroed.
(fhandler_termios::last): Eliminate.
(fhandler_termios): Remove setting of last.
(fhandler_base::~fhandler_termios): Ditto.
* fhandler_console.cc (fhandler_console::open): Don't make decisions about
opening close-on-exec handles here since it makes no sense for archetypes.
(fhandler_console::init): Assume that input handle has already been opened.
* fhandler_termios.cc (fhandler_termios::last): Delete.
* path.h (path_conv::eq_worker): New function.  Move bulk of operator = here.
(operator <<): New function.
(operator =): Use eq_worker to perform old functionality.
@
text
@d278 2
a279 2
static LARGE_INTEGER off_current = { QuadPart:FILE_USE_FILE_POINTER_POSITION };
static LARGE_INTEGER off_append = { QuadPart:FILE_WRITE_TO_END_OF_FILE };
d1917 1
a1917 1
      debug_printf ("EOF");
@


1.403
log
@Throughout change TTY_* to PTY_*, tty_* to pty_*, and ttym_* to ptmx_*.
* devices.cc: Regenerate.
* dtable.cc: (fh_alloc): Preserve /dev/tty name when that's what we opened.
(build_fh_pc): Preserve any existing name.
* fhandler.cc (fhandler_base::open_with_arch): Ditto.
* fhandler_tty.cc (fhandler_pty_master::fhandler_pty_master): Force the name to
/dev/ptmx while preserving other pty master device information.
* path.h (cfree_maybe): New macro.
(path_conv::operator =): Free any allocated strings in target.
(path_conv::free_strings): Delete unused function.
* sigproc.cc (proc_terminate): Remove previous accommodation for execed
processes since it didn't have the desired effect.  Change comment to a FIXME.
* spawn.cc (chExeced): Mark NO_COPY.
(exe_suffixes): Ditto.
@
text
@d43 1
a43 1
  pc = from->pc;
d151 1
a151 1
  pc = in_pc;
@


1.402
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d472 9
d483 2
@


1.401
log
@* cygwin.din: Remove some _tc* exports.  Add tcgetsid().
* dtable.cc (fh_alloc): Revert ill-advised setting of major/minor.  Use new
is_dev_tty to remember that this device was opened as /dev/tty.
* fhandler.cc (fhandler_base::fstat): Remove leftover debugging statement.
(fhandler_base::tcgetsid): New function.
* fhandler.h ((fhandler_base::tcgetsid): Declare new function.
(fhandler_base::is_dev_tty): Ditto.
(fhandler_termios::opened_as_dev_tty): Declare new field.
(fhandler_termios::is_dev_tty): Declare new function.
(fhandler_termios::tcgetsid): Ditto.
(fhandler_pty_common::use_archetype): Move here from subclass.
(fhandler_pty_slave::use_archetype): Move up.
(fhandler_pty_master::use_archetype): Ditto.
* fhandler_console.cc (fhandler_console::ioctl): Rename second argument from
`buf' to `arg' for consistency.  Call ioctl_termios for common fhandler_termios
ioctl handling.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Call ioctl_termios for common
fhandler_termios ioctl handling.
(fhandler_pty_master::ioctl): Ditto.
* fhandler_termios.cc (fhandler_termios::tcgetsid): Implement new function.
(fhandler_termios::ioctl_termios): Ditto.  Implements TIOCSCTTY handling.
* syscalls.cc (stat_worker): Set /dev/tty device info when appropriate.
* termios.cc (tcgetpgrp): Avoid extraneous "isatty" check.
(tcgetsid): Implement new function.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 253.
* include/sys/termios.h (TIOCSCTTY): Define.
@
text
@d40 2
a41 2
inline fhandler_base&
fhandler_base::operator =(fhandler_base& x)
d43 1
a43 2
  memcpy (this, &x, size ());
  pc = x.pc;
a48 1
  return *this;
d463 1
a463 1
      if (!archetype->io_handle)
d465 1
a465 2
	  usecount = 0;
	  *archetype = *this;
d468 1
d473 1
a473 1
	  *this = *archetype;
d1260 1
a1260 1
fhandler_base::dup (fhandler_base *child)
d1284 1
a1284 1
fhandler_base_overlapped::dup (fhandler_base *child)
d1286 1
a1286 1
  int res = fhandler_base::dup (child) ||
@


1.400
log
@	* fhandler.cc (fhandler_base::open): Fix typo in comment.
	(fhandler_base::close): Move call to del_my_locks from here...
	* fhandler_disk_file.cc (fhandler_disk_file::open): ...to here.
	* flock.cc (struct lockfattr_t): New type.
	(lockf_t::close_lock_obj): New method, use throughout.
	(lockf_t::create_lock_obj_attr): New method.
	(lockf_t::create_lock_obj): Use create_lock_obj_attr method.  Handle
	STATUS_OBJECT_NAME_COLLISION in F_FLOCK case gracefully.  Add lengthy
	comments to explain why and how.
	(lockf_t::open_lock_obj): Use create_lock_obj_attr method.
	(lockf_t::del_lock_obj): Call NtSetEvent rather than SetEvent for
	symmetry.
	(fhandler_disk_file::lock): Define n only where it's used.  Call
	need_fork_fixup only if call was successful.  Handle EINTR and
	ECANCELED return values from lf_setlock.
	(lf_setlock): Drop WAIT_UNLOCKED and WAIT_PROC_EXITED.  Don't wait
	for event object handle count to become <= 1 in F_LOCK case.
	Simplify WFMO return value handling.  Don't handle signal and cancel
	events here; just return with appropriate error code instead.
	(lf_getblock): Ignore locks for which the handle can't be opened.
	Use IsEventSignalled.
	* ntdll.h (STATUS_INVALID_INFO_CLASS): Undef if defined elsewhere to
	make sure the definition is casted to NTSTATUS.
	(STATUS_INVALID_HANDLE): Define and ditto.
	(STATUS_OBJECT_NAME_COLLISION): Define.
	(NtSetEvent): Declare.
@
text
@d1170 1
a1193 2
  debug_printf ("here");

d1393 7
@


1.399
log
@	* fhandler.cc (fhandler_base::open): Never open files with
	FILE_OVERWITE/FILE_OVERWRITE_IF.  Set file size to 0 explicitely if
	regular, existing file has been opened for writing with O_TRUNC flag
	set.  Explain why.
@
text
@d675 1
a675 1
	 handle has FILE_READ_DATA permissions, which is all you need to
a1132 4
  /* Delete all POSIX locks on the file.  Delete all flock locks on the
     file if this is the last reference to this file. */
  if (unique_id)
    del_my_locks (on_close);
@


1.398
log
@Corinna Vinschen <corinna@@vinschen.de>
* fhandler.cc: Add #include for asm/socket.h for dealing with FIONREAD.
(fhandler_base::ioctl): Special-case errno for FIONREAD.
* fhandler_dsp.cc (fhandler_dev_dsp::ioctl): Rename parameter for consistency.
Call fhandler_base::ioctl to decode default condition.
* fhandler_serial.cc (fhandler_serial::ioctl): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Call fhandler_base::ioctl to
decode default condition.
* fhandler_windows.cc (fhandler_windows::ioctl): Ditto.
@
text
@d543 2
a544 12
  if ((flags & O_TRUNC) && ((flags & O_ACCMODE) != O_RDONLY))
    {
      if (flags & O_CREAT)
	create_disposition = FILE_OVERWRITE_IF;
      else
	create_disposition = FILE_OVERWRITE;
    }
  else if (flags & O_CREAT)
    create_disposition = FILE_OPEN_IF;
  else
    create_disposition = FILE_OPEN;

d547 2
d659 26
@


1.397
log
@	* fhandler.cc (fhandler_base::open): Never create files with WRITE_DAC
	access.  Explain why.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Improve debug
	output.
@
text
@d31 1
d1155 4
@


1.396
log
@	* fhandler.cc (fhandler_base::open): Don't open file with WRITE_DAC
	access on remote filesystem.  Explain why.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto for
	directories.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for sockets.
	* path.cc (symlink_worker): Ditto for symlinks.
@
text
@a615 12
	  else if (!exists () && has_acls () && !isremote ())
	    /* If we are about to create the file and the filesystem supports
	       ACLs, we will overwrite the DACL after the call to NtCreateFile.
	       This requires a handle with additional WRITE_DAC access,
	       otherwise set_file_sd has to open the file again.
	       FIXME: On remote NTFS shares open sometimes fails because even
	       the creator of the file doesn't have the right to change the
	       DACL.  I don't know what setting that is or howq to recognize
	       such a share, so for now we don't request WRITE_DAC on remote
	       drives. */
	    access |= WRITE_DAC;

d618 7
@


1.395
log
@* fhandler.cc (fhandler_base::open_with_arch): Call close_on_exec last to avoid
setting close_on_exec for archetype.
* fhandler_tty.cc (fhandler_pty_master::setup): Protect {from,to}_pty handles.
Use consistent naming in debug output.  Use inheritable handles and...
(fhandler_pty_master::fixup_after_fork): ...avoid duplicating handles here.
(fhandler_pty_slave::open): Don't set close_on_exec flag here.
@
text
@d616 1
a616 1
	  else if (!exists () && has_acls ())
d620 6
a625 1
	       otherwise set_file_sd has to open the file again. */
@


1.394
log
@	* fhandler.cc (fhandler_base::open): Move NFS-specific code into the
	code block handling FH_FS stuff.
@
text
@a455 1
  close_on_exec (flags & O_CLOEXEC);
d482 1
@


1.393
log
@	* fhandler.cc (fhandler_base::open): Drop local create_options variable.
	Use options member instead.
	* fhandler.h (class fhandler_base): Change type of access member to
	ACCESS_MASK.  Change get_access and set_access methods accordingly.
	Add options member.  Add get_options and set_options methods.
	(class fhandler_disk_file): Add prw_handle.
	(fhandler_disk_file::prw_open): Declare.
	(fhandler_disk_file::close): Declare.
	(fhandler_disk_file::dup): Declare.
	(fhandler_disk_file::fixup_after_fork): Declare.
	* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file):
	Initialize prw_handle to NULL.
	(fhandler_disk_file::close): Close prw_handle.
	(fhandler_disk_file::dup): New method.
	(fhandler_disk_file::fixup_after_fork): Set prw_handle to NULL since
	prw_handle is not inherited.
	(fhandler_disk_file::prw_open): New method.  Add long comment to
	explain current behaviour.
	(fhandler_disk_file::pread): Revert previous change.  Change to use
	prw_handle if possible.
	(fhandler_disk_file::pwrite): Change to use prw_handle if possible.
@
text
@a541 15
  if (pc.fs_is_nfs ())
    {
      /* Make sure we can read EAs of files on an NFS share.  Also make
	 sure that we're going to act on the file itself, even if it's a
	 a symlink. */
      access |= FILE_READ_EA;
      if (query_open ())
	{
	  if (query_open () >= query_write_control)
	    access |=  FILE_WRITE_EA;
	  plen = sizeof nfs_aol_ffei;
	  p = (PFILE_FULL_EA_INFORMATION) &nfs_aol_ffei;
	}
    }

d564 15
@


1.392
log
@* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Only raise SIGPIPE
when writing.
* fhandler.h: Include "tty.h".
(fhandler_termios::_tc): Rename from tc.
(fhandler_termios::tc): New method.
(fhandler_termios::tcinit): Remove an argument.
(fhandler_termios::get_ttyp): Use method to retrieve value.
(fhandler_console::console_state): Move here.
(fhandler_console::dev_state): Delete.
(fhandler_console::shared_console_info): Define.
(fhandler_console::open_shared_console): Move this function under
fhandler_console umbrella.
(fhandler_console::tc): Define.  Return static value.
(fhandler_console::focus_aware): Accommodate deletion of dev_state.
(fhandler_console): Add tty_list::get_cttyp as a friend.
* fhandler_console.cc (dev_state): Redefine as a pointer within
shared_console_info and change dev-> to dev.  throughout.
(fhandler_console::shared_console_info): Move into fhandler_console.
(fhandler_console::open_shared_console): Move into fhandler_console change
argument to simple bool.
(enum_windows): Accommodate changes to console_state and open_shared_console.
(console_unit::console_unit): Ditto.
(fhandler_console::get_tty_stuff): Accommodate change to dev_state.
(tty_list::get_cttyp): Accommodate change to
handler_console::shared_console_info.
(fhandler_console::read): Accommodate change from tc to tc ().
(fhandler_console::set_input_state): Ditto.
(fhandler_console::open): Accommodate tcinit argument change and change from tc
to tc().
(fhandler_console::input_tcsetattr): Accomodate change from tc to tc().
(fhandler_console::input_tcsetattr): Ditto.
(fhandler_console::write_normal): Ditto.
(fhandler_console::init): Ditto.
(fhandler_console::igncr_enabled): Ditto.
* fhandler_termios.cc (fhandler_termios::tcinit): Remove first argument.
Expect tc() to have been set up first.  Use tc() rather than tc.
(fhandler_termios::tcsetpgrp): Accomodate change from tc to tc().
(fhandler_termios::tcgetpgrp): Ditto.
(fhandler_termios::bg_check): Ditto.
(fhandler_termios::line_edit: Ditto.
(fhandler_tty_master::set_winsize): Ditto.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::init): Ditto.
(fhandler_pty_master::write): Ditto.
(fhandler_pty_master::setup): Ditto.  Accommodate change in arguments to
tcinit.
(fhandler_tty_slave::fch_open_handles): Set _tc directly.
(tty_min::is_orphaned_process_group): Don't assume that parent pid exists.
* pinfo.cc (_pinfo::set_ctty): Reset myself->{pgid,sid} here if we were started
by a non-Cygwin process but the tty exists.
* shared_info.h (console_state): Delete from here.
* tty.h: Make multiple inclusion safe.
@
text
@a494 1
  ULONG create_options = FILE_OPEN_FOR_BACKUP_INTENT;
d505 1
d531 1
a531 1
	  create_options |= FILE_WRITE_THROUGH;
d533 1
a533 1
	  create_options |= FILE_NO_INTERMEDIATE_BUFFERING;
d536 1
a536 1
	    create_options |= FILE_SYNCHRONOUS_IO_NONALERT;
d577 1
a577 1
	create_options |= FILE_OPEN_REPARSE_POINT;
d629 1
a629 1
			 create_disposition, create_options, p, plen);
d675 1
a675 1
		shared, create_disposition, create_options);
@


1.391
log
@* dtable.cc (dtable::select_write): Add missing argument to debug_printf.
* fhandler.cc (fhandler_base_overlapped::setup_overlapped): Explicitly set
io_pending to false.
(fhandler_base_overlapped::has_ongoing_io): Call GetOverlappedResult to force
completion of I/O.
(fhandler_base_overlapped::wait_overlapped): Rewrite to correctly deal with
nonblocking reads and to make more race proof.
(fhandler_base_overlapped::raw_write): Deal with new enum values.
(fhandler_base_overlapped::raw_read): Ditto.  Don't deal with ongoing I/O here
since it makes no sense in the read context.
* fhandler.h (enum wait_return): Add overlapped_unknown,
overlapped_nonblocking_no_data.
* pipe.cc (pipe): Add debugging output.
@
text
@d1886 2
d1894 1
a1894 1
      if (writing && (err == ERROR_NO_DATA || err == ERROR_BROKEN_PIPE))
@


1.390
log
@* dll_init.cc (dll_list::append): Eliminate increment of unused tot variable.
* dll_init.h (dll_list::tot): Delete.
(dll_list::populate_all_deps): Delete undefined function.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Move EPIPE handling
under error condition.
@
text
@d1773 1
d1795 1
d1802 2
d1813 5
a1817 22
  wait_return res;
  DWORD err = GetLastError ();
  if (nonblocking)
    {
      if (inres)
	res = overlapped_success;
      else if (err != ERROR_IO_PENDING)
	res = overlapped_error;
      else
	{
	  if (writing)
	    *bytes = len;
	  else
	    {
	      set_errno (EAGAIN);
	      *bytes = (DWORD) -1;
	    }
	  res = overlapped_success;
	  io_pending = true;
	}
    }
  else if (!inres && err != ERROR_IO_PENDING)
d1819 4
d1825 6
a1830 4
#ifdef DEBUGGING
      if (!get_overlapped ()->hEvent)
	system_printf ("hEvent is zero?");
#endif
d1836 7
a1842 3
      if (wfres != WAIT_OBJECT_0)
	CancelIo (h);
      *bytes = 0;
d1844 6
a1849 3
      bool signalled = !wores && (wfres == WAIT_OBJECT_0 + 1);
      bool canceled = !wores && (wfres == WAIT_OBJECT_0 + 2);
      if (signalled)
a1850 1
	  debug_printf ("got a signal");
d1855 2
a1856 1
	      set_errno (EINTR);
a1857 1
	      err = 0;
d1860 5
a1864 3
      else if (canceled)
	pthread::static_cancel_self ();
      else if (!wores)
d1866 1
a1866 2
	  err = GetLastError ();
	  debug_printf ("GetOverLappedResult failed, bytes %u", *bytes);
a1868 5
      else
	{
	  debug_printf ("normal %s, %u bytes", writing ? "write" : "read", *bytes);
	  res = overlapped_success;
	}
d1872 9
a1880 1
    /* nothing to do */;
d1889 1
a1889 4
      debug_printf ("err %u", err);
      HANDLE h = writing ? get_output_handle () : get_handle ();
      CancelIo (h);
      ResetEvent (get_overlapped ());
d1891 3
a1893 6
      if (res == overlapped_error)
	{
	  __seterrno_from_win_error (err);
	  if (writing && (err == ERROR_NO_DATA || err == ERROR_BROKEN_PIPE))
	    raise (SIGPIPE);
	}
d1903 2
a1904 3
  if (has_ongoing_io ())
    nbytes = (DWORD) -1;
  else
d1906 12
a1917 16
      bool keep_looping;
      do
	{
	  bool res = ReadFile (get_handle (), ptr, len, &nbytes,
			       get_overlapped ());
	  switch (wait_overlapped (res, false, &nbytes, is_nonblocking ()))
	    {
	    case overlapped_signal:
	      keep_looping = true;
	      break;
	    default:	/* Added to quiet gcc */
	    case overlapped_success:
	    case overlapped_error:
	      keep_looping = false;
	      break;
	    }
a1918 1
      while (keep_looping);
d1920 1
d1967 2
@


1.389
log
@* fhandler.cc (fhandler_overlapped::wait_overlapped): Make sure that I/O is
cancelled on signal.
@
text
@d1890 1
d1892 5
a1896 2
	__seterrno_from_win_error (err);
      *bytes = (DWORD) -1;
a1898 2
  if (writing && (err == ERROR_NO_DATA || err == ERROR_BROKEN_PIPE))
    raise (SIGPIPE);
@


1.388
log
@* fhandler.cc (handler_base_overlapped::wait_overlapped): Rework to attempt to
properly set errno and bytes read for non-blocking case.  Change to just rely
on res to indicate error conditions.
@
text
@d1876 1
a1876 1
  if (res != overlapped_error)
d1890 1
a1890 1
      if (err)
@


1.387
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d1813 3
a1815 1
      if (!inres && err != ERROR_IO_PENDING)
d1819 1
a1819 2
	  io_pending = !inres && err == ERROR_IO_PENDING;
	  if (writing && !inres)
d1821 5
d1827 1
a1827 1
	  err = 0;
d1858 1
a1859 2
	  *bytes = (DWORD) -1;
	  err = 0;
a1870 1
	  err = 0;
d1876 1
a1876 1
  if (!err)
d1890 2
a1891 1
      __seterrno_from_win_error (err);
@


1.386
log
@* fhandler.cc (fhandler_base::dup): Avoid duping a handle when an fhandler has
an archetype.
* fhandler_console.cc (fhandler_console::invisible_console): Move to the top.
(fhandler_console::set_close_on_exec): Don't set close-on-exec on handle since
it's an archetype and you don't know how many things could be using it.
@
text
@d696 1
a696 1
  if (copied_chars && is_slow ())
d1817 1
a1817 1
	  io_pending = err == ERROR_IO_PENDING;
@


1.385
log
@* cygheap.cc (cygheap::close_ctty): Close ctty via close_with_arch().
* debug.cc (close_handle): Call debugger on failure.
* devices.in (device::tty_to_real_device): Delete.
* devices.h (device::tty_to_real_device): Ditto.
* devices.cc: Regenerate.
* dtable.cc: Delete old ifdef'ed vfork code.
(dtable::release): Don't handle archetype here.
(dtable::init_std_file_from_handle): Consolidate console tests.  Generate
major/minor for tty ASAP.  Fix incorrect setting of DEV_TTYS* for serial.
(fh_alloc): New function derived from build_fh_pc.  Pass current tty when
building tty.
(build_pc_pc): Use fh_alloc to create.  Set name from fh->dev if appropriate.
Generate an archetype or point to one here.
(dtable::dup_worker): Deal with archetypes.  Rely on = operator copying whole
class rather than just fhandler_base.
(dtable::fixup_after_exec): Call close_with_arch to handle closing of fhandlers
with archetypes.
* fhandler.cc (fhandler_base::operator =): Call memcpy with fhandler's size()
rather than sizeof fhandler_base.
(fhandler_base::open_with_arch): New function.  Handles opening of fhandler's
with archetypes, dealing with usecounts, etc.
(fhandler_base::close_with_arch): Ditto for close.
* fhandler.h: Many changes for archetypes.
(fhandler_base::set_name): Set both normalized path and regular path.
(fhandler_base::open_with_arch): New function.
(fhandler_base::open_setup): Ditto.
(fhandler_base::use_archetype): Ditto.
(fhandler_base::_archetype_usecount): Ditto.
(fhandler_*::size): Ditto.
(fhandler_dev_tape::open): Remove virtual decoration.
(fhandler_console::use_archetype): New function.  Return true.
(fhandler_console::open_setup): New function.
(fhandler_console::dup): Delete.
(fhandler_tty_slave::fhandler_tty_slave): Redeclare to take an argument.
(fhandler_tty_slave::use_archetype): New function.  Return true.
(fhandler_tty_slave::cleanup): New function.
(fhandler_pty_master::use_archetype): New function.  Return true.
(fhandler_pty_master::cleanup): New function.
(fhandler_pty_master::is_tty_master): New function.  Return false.
(fhandler_tty_master::is_tty_master): New function.  Return true.
(fhandler_dev_dsp::fhandler_dev_dsp): New function.  Return true.
(report_tty_counts): Only report on archetype's usecount if there is one.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove handling of
setsid, set_ctty, set_flags, and manage_console_count.
(fhandler_console::open_setup): New function.  Implement functionality removed
from get_tty_stuff.
(fhandler_console::dup): Delete.
(fhandler_console::output_tcsetattr): Set errno on error.
(fhandler_console::fhandler_console): Set device early.
(fhandler_console::init): Use open_with_arch to open console handles.
(fhandler_console::fixup_after_fork_exec): Nuke most of the stuff for dealing
with console handles.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Remove archetype handling.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
(fhandler_dev_dsp::close): Ditto.
(fhandler_dev_dsp::dup): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Add a little
more debugging.
(fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_pty_master::process_slave_output): Ditto.  Don't do signal handling
or pthread_cancel handling in the tty master thread.
(process_output): Minor reorg.
(fhandler_tty_slave::fhandler_tty_slave): Set device based on new ntty
argument.
(fhandler_tty_slave::open): Remove archetype handling.  Move some processing
into open_setup().
(fhandler_tty_slave::open_setup): New function.
(fhandler_tty_slave::cleanup): New function.
(fhandler_tty_slave::close): Remove archetype handling.  Move some processing
into cleanup().
(fhandler_tty_slave::init): Rename argument from f to h.  Open device using
open_with_arch().  Remove archetype handling.
(fhandler_pty_master::dup): Ditto.
(fhandler_pty_master::open): Ditto.
(fhandler_pty_master::close): Ditto.  Move some handling to cleanup().
(fhandler_pty_master::cleanup): New function.
(fhandler_tty_master::init_console): Give unique name to captive console
fhandler.
* pinfo.cc (_pinfo::set_ctty): Rename argument from arch to fh.  Eliminate
archetype assumption.
* syscalls.cc (close_all_files): Use close_with_arch for closing.
(open): Use open_with_arch() rather than open().
(close): Use close_with_arch() rather than close().
@
text
@d1249 1
a1249 1
  if (!nohandle ())
@


1.384
log
@* fhandler.cc (fhandler_base_overlapped::raw_read): Rename from
read_overlapped.
(fhandler_base_overlapped::raw_e): Rename from write_overlapped.
* fhandler.h (fhandler_*::raw_read): Add reparm decoration.
(fhandler_*::raw_write): Ditto.
(fhandler_base_overlapped::raw_read): Rename from read_overlapped.
(fhandler_base_overlapped::raw_write): Rename from write_overlapped.
(fhandler_pipe::raw_read): Delete.
(fhandler_pipe::raw_write): Ditto.
(fhandler_mailslot::raw_read): Ditto.
* fhandler_fifo.cc (fhandler_fifo::raw_read): Reflect read_overlapped ->
raw_read rename.
(fhandler_fifo::raw_write): Ditto.
* fhandler_mailslot.cc (fhandler_mailslot::raw_read): Delete.
(fhandler_mailslot::raw_write): Reflect read_overlapped -> raw_read rename.
* pipe.cc (fhandler_pipe::raw_read): Delete.
(fhandler_pipe::raw_write): Ditto.
@
text
@d42 1
a42 1
  memcpy (this, &x, sizeof *this);
d452 34
d1067 42
@


1.383
log
@	* fhandler.cc (is_at_eof): Drop static storage class.  Drop err
	parameter since we don't change the Win32 error here anymore.
	(fhandler_base::raw_read): Accommodate change to is_at_eof.

	* fhandler_disk_file.cc (fhandler_disk_file::pread): In binary mode use
	direct call to NtReadFile, rather than lseek/read.
	(fhandler_disk_file::pwrite): In binary mode use direct call to
	NtWriteFile, rather than lseek/write.
@
text
@d1820 1
a1820 1
fhandler_base_overlapped::read_overlapped (void *ptr, size_t& len)
d1850 1
a1850 1
fhandler_base_overlapped::write_overlapped (const void *ptr, size_t len)
@


1.382
log
@	* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Make
	cancelable.  Remove test for main thread, always add signal_arrived
	to waited objects.
@
text
@d166 2
a167 2
static int __stdcall
is_at_eof (HANDLE h, DWORD err)
a178 1
  SetLastError (err);
d239 1
a239 1
	  if (is_at_eof (get_handle (), errcode))
@


1.381
log
@	* ntdll.h (IsEventSignalled): New inline function.
	* cygthread.cc (cygthread::terminate_thread): Use IsEventSignalled in
	place of WaitForSingleObject on event with 0 timeout.
	* fhandler.cc (fhandler_base_overlapped::has_ongoing_io): Ditto.
	* fhandler_fifo.cc (fhandler_fifo::open_nonserver): Ditto.
	(fhandler_fifo::wait): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* select.cc (verify_tty_slave): Ditto.
	* thread.cc (pthread::testcancel): Ditto.
@
text
@d1757 3
a1759 5
      DWORD n = 1;
      HANDLE w4[2];
      w4[0] = get_overlapped ()->hEvent;
      if (&_my_tls == _main_tls)
	w4[n++] = signal_arrived;
d1767 1
d1781 2
@


1.380
log
@* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Remove special
treatment for ERROR_NO_SYSTEM_RESOURCES.  Cancel I/O and reset the overlapped
handle on error.
(fhandler_base_overlapped::write_overlapped): Limit writes to max_atomic_write
bytes in blocking case.  Incorporate code from now-defunct
write_overlapped_fallback.  Fix serious oversight where ptr was not advanced as
buffer was written.
(fhandler_base_overlapped::write_overlapped_fallback): Eliminate.
* fhandler.h (fhandler_base_overlapped::write_overlapped_fallback): Ditto for
declaration.
(DEFAULT_PIPEBUFSIZE): Lower size to slightly less than documented worst-case
atomic write size.
(fhandler_overlapped::wait_return): Remove unused element.
@
text
@d1719 1
a1719 1
  if (WaitForSingleObject (get_overlapped ()->hEvent, 0) != WAIT_OBJECT_0)
@


1.379
log
@* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Handle
overlapped_fallback error condition like other error conditions.  Set res
carefully and specifically for each condition rather than resorting to a
default.
(fhandler_base_overlapped::write_overlapped): Preserve errno in
overlapped_fallback condition.  Correct write_overlapped_fallback to avoid
inappropriate looping.
(fhandler_base_overlapped::write_overlapped_fallback): Add some more comments.
@
text
@d1736 1
a1736 3
  if (err == ERROR_NO_SYSTEM_RESOURCES)
    res = overlapped_fallback;
  else if (nonblocking)
d1807 3
a1839 1
	    case overlapped_fallback:
d1852 1
a1852 1
  DWORD nbytes;
d1857 23
a1879 7
      int last_errno = get_errno ();
      bool keep_looping;
      if (is_nonblocking () && max_atomic_write && len > max_atomic_write)
	len = max_atomic_write;
      do
	{
	  bool res = WriteFile (get_output_handle (), ptr, len, &nbytes,
d1881 2
a1882 1
	  switch (wait_overlapped (res, true, &nbytes, is_nonblocking (), (size_t) len))
d1884 4
d1889 1
a1889 8
	      keep_looping = true;
	      break;
	    case overlapped_fallback:
	      set_errno (last_errno);	/* Avoid setting a random EFBIG errno */
	      nbytes = write_overlapped_fallback (ptr, len);
	      /* fall through intentionally */;
	    default:	/* Added to quiet gcc */
	    case overlapped_success:
d1891 1
a1891 1
	      keep_looping = false;
d1895 2
a1896 55
      while (keep_looping);
    }
  debug_printf ("returning %u", nbytes);
  return nbytes;
}

/* On XP (at least) the size of the buffer that can be used to write to a pipe
   (pipes are currently the only thing using the overlapped methods) is
   limited.  This function is a fallback for when that problem is detected.
   It writes to the pipe using smaller buffers but masks this behavior
   to the caller.  */
ssize_t __stdcall __attribute__ ((regparm (3)))
fhandler_base_overlapped::write_overlapped_fallback (const void *ptr, size_t orig_len)
{
  size_t chunk;
  /* So far, in testing, only the first if test has been necessary */
  if (orig_len > MAX_OVERLAPPED_WRITE_LEN)
    chunk = MAX_OVERLAPPED_WRITE_LEN;
  else if (orig_len > MIN_OVERLAPPED_WRITE_LEN)
    chunk = MIN_OVERLAPPED_WRITE_LEN;
  else
    chunk = orig_len / 4;
  ssize_t nbytes = 0;
  DWORD nbytes_now = 0;
  /* Write to fd in smaller chunks, accumlating a total.
     If there's an error, just return the accumulated total
     unless the first write fails, in which case return value
     from wait_overlapped(). */
  while ((size_t) nbytes < orig_len)
    {
      size_t left = orig_len - nbytes;
      size_t len;
      if (left > chunk)
	len = chunk;
      else
	len = left;
      bool res = WriteFile (get_output_handle (), ptr, len, &nbytes_now,
			    get_overlapped ());
      /* The nonblocking case is not going to be used currently and may
	 eventually disappear. */
      switch (wait_overlapped (res, true, &nbytes_now,
			       left <= chunk ? is_nonblocking () : false,
			       (size_t) len))
	{
	case overlapped_success:
	  nbytes += nbytes_now;
	  /* fall through intentionally */
	case overlapped_signal:
	  break;			/* keep looping */
	case overlapped_error:
	case overlapped_fallback:	/* XXX Could make this more adaptive
					   if needed */
	  orig_len = 0;			/* terminate loop */
	  break;
	}
a1897 2
  if (!nbytes)
    nbytes = nbytes_now;
@


1.379.2.1
log
@	* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Remove
	special treatment for ERROR_NO_SYSTEM_RESOURCES.  Cancel I/O and reset
	the overlapped handle on error.
	(fhandler_base_overlapped::write_overlapped): Limit writes to
	max_atomic_write bytes in blocking case.  Incorporate code from
	now-defunct write_overlapped_fallback.  Fix serious oversight where ptr
	was not advanced as buffer was written.
	(fhandler_base_overlapped::write_overlapped_fallback): Eliminate.
	* fhandler.h (fhandler_base_overlapped::write_overlapped_fallback):
	Ditto for declaration.
	(DEFAULT_PIPEBUFSIZE): Lower size to slightly less than documented
	worst-case atomic write size.
	(fhandler_overlapped::wait_return): Remove unused element.
@
text
@d1736 3
a1738 1
  if (nonblocking)
a1808 3
      HANDLE h = writing ? get_output_handle () : get_handle ();
      CancelIo (h);
      ResetEvent (get_overlapped ());
d1839 1
d1852 1
a1852 1
  size_t nbytes;
d1857 7
a1863 23
      size_t chunk;
      if (!max_atomic_write || len < max_atomic_write)
	chunk = len;
      else if (is_nonblocking ())
	chunk = len = max_atomic_write;
      else
	chunk = max_atomic_write;

      nbytes = 0;
      DWORD nbytes_now = 0;
      /* Write to fd in smaller chunks, accumlating a total.
	 If there's an error, just return the accumulated total
	 unless the first write fails, in which case return value
	 from wait_overlapped(). */
      while (nbytes < len)
	{
	  size_t left = len - nbytes;
	  size_t len1;
	  if (left > chunk)
	    len1 = chunk;
	  else
	    len1 = left;
	  bool res = WriteFile (get_output_handle (), ptr, len1, &nbytes_now,
d1865 1
a1865 2
	  switch (wait_overlapped (res, true, &nbytes_now,
				   is_nonblocking (), len1))
d1867 8
a1875 5
	      ptr = ((char *) ptr) + chunk;
	      nbytes += nbytes_now;
	      /* fall through intentionally */
	    case overlapped_signal:
	      break;			/* keep looping */
d1877 1
a1877 1
	      len = 0;		/* terminate loop */
d1881 55
a1935 2
      if (!nbytes)
	nbytes = nbytes_now;
d1937 2
@


1.378
log
@* fhandler.cc (fhandler_base_overlapped::write_overlapp): Oops! Accommodate
change in arguments to wait_overlapped.
@
text
@d1734 1
d1737 2
a1738 4
    return overlapped_fallback;

  wait_return res = overlapped_error;
  if (nonblocking)
d1740 3
a1742 1
      if (inres || err == ERROR_IO_PENDING)
d1751 3
a1753 1
  else if (inres || err == ERROR_IO_PENDING)
d1774 2
a1775 2
	  if (!_my_tls.call_signal_handler ())
	    set_errno (EINTR);
d1777 4
a1780 1
	    res = overlapped_signal;
d1788 1
d1792 1
a1794 1
	  err = 0;
d1800 7
a1806 1
  else if (err != ERROR_HANDLE_EOF && err != ERROR_BROKEN_PIPE)
a1810 7
      res = overlapped_error;
    }
  else
    {
      debug_printf ("EOF");
      *bytes = 0;
      res = overlapped_success;
d1857 1
d1867 3
d1871 1
a1873 3
	    case overlapped_signal:
	      keep_looping = true;
	      break;
d1896 1
d1905 4
d1929 1
a1929 1
	  break;	/* keep looping */
d1931 1
a1931 1
	case overlapped_fallback:	/* Could make this more adaptive
d1933 1
a1933 1
	  orig_len = 0;	/* terminate loop */
@


1.377
log
@* errno.cc (errmap): Change mapping of NO_SYSTEM_RESOURCES to EFBIG.
* fhandler.cc (MAX_OVERLAPPED_WRITE_LEN): New constant.
(MIN_OVERLAPPED_WRITE_LEN): Ditto.
(fhandler_base_overlapped::close): Accommodate change in arguments to
wait_overlapped.
(fhandler_base_overlapped::setup_overlapped): Add __stdcall and regparm
modifiers.
(fhandler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Ditto.
(fhandler_base_overlapped::wait_overlapped): Modify to return an enum returning
various states.  Accept nonblocking parameter.
(fhandler_base_overlapped::read_overlapped): Add __stdcall and regparm
modifiers.  Rework to attempt to be smarter about reacting to states returned
by wait_overlapped.
(fhandler_base_overlapped::write_overlapped): Ditto.  Add fallback option for
when wait_overlapped detects that smaller chunks must be written.
(fhandler_base_overlapped::write_overlapped_fallback): Ditto.
* fhandler.h (DEFAULT_PIPEBUFSIZE): Move definition here from pipe.cc.
(fhandler_base::has_ongoing_io): Define with __stdcall and regparm modifiers.
(fhandler_base_overlapped::wait_return): New enum.
(fhandler_base_overlapped::max_atomic_write): New variable.
(fhandler_base_overlapped:: wait_overlapped): Accommodate changes mentioned
above to arguments and modifiers.
(fhandler_base_overlapped::setup_overlapped): Ditto for modifiers.
(fhandler_base_overlapped::read_overlapped): Ditto.
(fhandler_base_overlapped::write_overlapped): Ditto.
(fhandler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Ditto.
(fhandler_base_overlapped::fhandler_base_overlapped): Zero max_atomic_write.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Set max_atomic_write to the
size of the DEFAULT_PIPEBUFSIZE.
(fhandler_fifo::wait): Accommodate change in arguments to wait_overlapped.
* pipe.cc (fhandler_pipe::fhandler_pipe): Set max_atomic_write to the size of
the DEFAULT_PIPEBUFSIZE.
(fhandler_pipe::create_selectable): Allow minimum size of DEFAULT_PIPEBUFSIZE.
(DEFAULT_PIPEBUFSIZE): Delete here, move to fhandler.h.
@
text
@d1858 1
a1858 1
	  switch (wait_overlapped (res, true, &nbytes, (size_t) len))
@


1.376
log
@	* fhandler.cc (fhandler_base::open): When creating a file on a
	filesystem supporting ACLs, create the file with WRITE_DAC access.
	Explain why.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto for
	directories.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for sockets.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Always call GetSecurityInfo for directories
	on XP and Server 2003.  Improve comment to explain why.
	(set_file_attribute): Explicitely cast mode_t value to bool in call to
	get_file_sd.
	* wincap.h (wincaps::use_get_sec_info_on_dirs): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d32 3
d1062 1
a1062 2
      set_nonblocking (false);
      wait_overlapped (1, !!(get_access () & GENERIC_WRITE), &bytes);
d1691 1
a1691 1
int
d1701 1
a1701 1
void
d1714 1
a1714 1
bool
d1728 2
a1729 2
int
fhandler_base_overlapped::wait_overlapped (bool inres, bool writing, DWORD *bytes, DWORD len)
d1732 1
a1732 1
    return inres;
d1734 3
a1736 1
  int res = 0;
d1738 2
a1739 2
  DWORD err = GetLastError ();
  if (is_nonblocking ())
d1745 2
a1746 6
	    *bytes = len;	/* This really isn't true but it seems like
				   this is a corner-case for linux's
				   non-blocking I/O implementation.  How can
				   you know how many bytes were written until
				   the I/O operation really completes? */
	  res = 1;
d1771 4
a1774 1
	  set_errno (EINTR);
a1775 1
	  res = 0;
d1786 1
a1786 1
	  res = 1;
d1798 1
a1798 1
      res = 0;
d1802 1
a1802 1
      res = 1;
d1804 1
a1804 2
      err = 0;
      debug_printf ("EOF");
d1812 1
a1812 1
void __stdcall
d1819 21
a1839 8
    while (1)
      {
	bool res = ReadFile (get_handle (), ptr, len, &nbytes,
			     get_overlapped ());
	int wres = wait_overlapped (res, false, &nbytes);
	if (wres || !_my_tls.call_signal_handler ())
	  break;
      }
d1843 1
a1843 1
ssize_t __stdcall
d1850 71
a1920 6
    while (1)
      {
	bool res = WriteFile (get_output_handle (), ptr, len, &nbytes,
			      get_overlapped ());
	int wres = wait_overlapped (res, true, &nbytes, (size_t) len);
	if (wres || !_my_tls.call_signal_handler ())
d1922 4
a1925 2
      }
  debug_printf ("returning %u", nbytes);
@


1.375
log
@* fhandler.cc (fhandler_base_overlapped::close): Finish any pending I/O before
closing.
(fhandler_base_overlapped::wait_overlapped): Defensively zero bytes read.  Add
more info to debugging output.
@
text
@d580 7
@


1.374
log
@	* Throughout fix copyright dates.
@
text
@d1049 6
d1758 1
d1772 1
a1772 1
	  debug_printf ("GetOverLappedResult failed");
@


1.373
log
@	* fhandler.cc (fhandler_base::fsync): Ignore ERROR_INVALID_FUNCTION
	error from FlushFileBuffers().
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
@


1.372
log
@	* fhandler.cc: Drop including nfs.h.
	* fhandler_disk_file.cc: Ditto.
	(fhandler_base::fstat_by_nfs_ea): Use fattr3 from path_conv member,
	unless called from fstat.
	* path.cc: Drop including nfs.h.
	(symlink_info::check): Rearrange definition of file info buffers.
	Fetch fattr3 info for files on NFS and store in conv_hdl for later
	use in fhandler_base::fstat_by_nfs_ea.  Use fattr3 file type to
	recognize symlink on NFS and try to fetch symlink target only for
	actual symlinks.
	* path.h: Include nfs.h.
	(class path_conv_handle): Change file info storage to union of
	FILE_NETWORK_OPEN_INFORMATION and fattr3 structures.
	(path_conv_handle::fnoi): Align to aforementioned change.
	(path_conv_handle::nfsattr): New method.
	(path_conv::nfsattr): New method.
@
text
@d1591 8
a1598 1
  __seterrno ();
@


1.371
log
@	* fhandler.cc (fhandler_base::open): Handle query_write_dac flag.
	* fhandler.h (enum query_state): Add query_write_dac flag.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Open file
	with query_write_dac instead of query_write_control.
@
text
@a30 1
#include "nfs.h"
@


1.370
log
@	* fhandler.cc (fhandler_base::open): Always open NFS files with
	FILE_READ_EA, even when opening with O_WRONLY to allow fstat.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Call
	FlushFileBuffers if file has been opened for writing.  Explain why.
	(fhandler_base::fstat_by_handle): Renew content of pc.fnoi if called
	via fstat.  Explain why.  Fix formatting.
	* path.cc (symlink_info::check): Try to open file the second time with
	FILE_READ_EA permissions since it's needed in later calls to
	fhandler_base::fstat_by_nfs_ea.
@
text
@d482 3
@


1.369
log
@	* fhandler.cc (fhandler_base::raw_write): Remove STATUS_DISK_FULL
	special handling.
@
text
@d504 1
a504 1
  if (query_open () && pc.fs_is_nfs ())
d507 1
a507 1
	 sure that we're going to act on the file itself, even if it'a
d510 7
a516 4
      if (query_open () >= query_write_control)
	access |=  FILE_WRITE_EA;
      plen = sizeof nfs_aol_ffei;
      p = (PFILE_FULL_EA_INFORMATION) &nfs_aol_ffei;
@


1.368
log
@	Align seekdir and telldir API to POSIX definition.
	* Makefile.in (NEW_FUNCTIONS): Remove seekdir and telldir mappings.
	* dir.cc (telldir): Move functionality from telldir64 here.  Use
	long, rather than _off_t.
	(telldir64): Just call telldir.  Only keep for backward compatibility.
	(seekdir): Move functionality from seekdir64 here.  Use long, rather
	than _off_t.
	(seekdir64): Just call seekdir.  Only keep for backward compatibility.
	* fhandler.h: Throughout, change prototypes of seekdir and telldir
	methods to use long, rather than _off64_t.
	* fhandler_disk_file.cc: Change aforementioned methods accordingly.
	* fhandler_netdrive.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* include/sys/dirent.h (struct __DIR): Change __d_position from
	_off_t to long to reflect API change.
	(telldir): Change prototype to use long, rather than off_t.
	(seekdir): Ditto.
@
text
@a292 2
      if (status == STATUS_DISK_FULL && io.Information > 0)
	goto written;
a297 1
written:
@


1.367
log
@	* dtable.cc (dtable::dup_worker): Reset path_conv handle in duplicated
	fhandler.
	* fhandler.cc (fhandler_base::fstatvfs): Keep handle in created
	path_conv.
	* fhandler.h (fhandler_base::get_stat_access): New method.
	(fhandler_base::get_stat_handle): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Use handle
	returned by get_stat_handle.  Only request inode from system if it
	isn't already set in the fhandler, and only for filesystems supporting
	them.
	(fhandler_base::fstat_fs): Use handle returned by get_stat_handle.
	Change the way open_fs is called.  Explain why.
	(fhandler_base::fstat_helper): Use handle returned by get_stat_handle.
	Never use 0 inode number.  Simplify executable recognition by re-using
	get_stat_handle if file could be opened with sufficient rights.
	(fhandler_disk_file::fstatvfs): Use handle returned by get_stat_handle.
	(fhandler_disk_file::facl): Use handle returned by get_stat_handle in
	GETACL and GETACLCNT cases.
	(fhandler_disk_file::link): Use handle returned by get_stat_handle
	instead of opening file here again.  Add comment.
	(readdir_get_ino): Keep handle in created path_conv and drop
	opening file.
	* ntdll.h (wait_pending): New helper function.
	* path.cc (symlink_info::check): Drop unused 'opt' parameter from
	declaration.  Add path_conv_handle argument.
	(path_conv::check): Make sure conv_handle is closed.  Keep
	PC_KEEP_HANDLE flag in pflags_or.  Accommodate call to sym.check to
	new args.
	(path_conv::~path_conv): Close conv_handle.
	(symlink_info::check_shortcut): Don't re-open file here, just use
	incoming handle.  Drop goto's and label out.
	(symlink_info::check_sysfile): Don't re-open file here, just use
	incoming handle.  Keep track of file position to accommodate the fact
	that file has been opened asynchronously in calling function.
	(symlink_info::check_nfs_symlink): Don't re-open file here, just use
	incoming handle.
	(symlink_info::check): Drop unused 'opt' parameter.  Add
	path_conv_handle argument.  Always try to open file with GENERIC_READ
	rights first to allow reading file content w/o having to re-open the
	file.  Drop back to READ_CONTROL | FILE_READ_ATTRIBUTES otherwise.
	Call symlink test functions (except for check_reparse_point) only if
	file could be opened with GENERIC_READ.  Keep file handle open if
	PC_KEEP_HANDLE is set in pflags.
	* path.h (enum pathconv_arg): Add PC_KEEP_HANDLE flag.
	(class path_conv_handle): New class.
	(class path_conv): Add conv_handle member.
	(path_conv::operator =): Duplicate conv_handle.
	(path_conv::handle): New method.
	(path_conv::access): New method.
	(path_conv::reset_conv_handle): New method.
	(path_conv::close_conv_handle): New method.
@
text
@d1444 1
a1444 1
_off64_t
d1452 1
a1452 1
fhandler_base::seekdir (DIR *, _off64_t)
@


1.366
log
@* fhandler.h (fhandler_base::setup_overlapped): Delete virtual declaration.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base_overlapped): Remove now-unneeded friend.
(fhandler_base_overlapped::setup_overlapped): Return int, remove parameter.
(fhandler_base_overlapped::get_overlapped): Return reference.
(fhandler_base_overlapped::fhandler_base_overlapped): Be more assertive about
zeroing everything.
(fhandler_base_overlapped::fixup_after_fork): Declare new function.
(fhandler_base_overlapped::fixup_after_exec): Ditto.
(fhandler_base_overlapped::dup): Ditto.
(fhandler_base_overlapped::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo::dup): Call fhandler_base_overlapped::dup
rather than fhandler_base::dup.
* pipe.cc (fhandler_pipe::dup): Ditto.
(fhandler_pipe::init): Accommodate change in setup_overlapped arguments for
"opened_properly" case.
@
text
@d1127 1
a1127 1
  path_conv pc ("/dev");
@


1.365
log
@* fhandler.cc (fhandler_base::dup): Call setup_overlapped unconditionally.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::fixup_after_fork): Ditto.
(fhandler_base::fixup_after_exec): Ditto.
(fhandler_base_overlapped::setup_overlapped): Move to this class from
fhandler_base.
(handler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::wait_overlapped): Ditto.  Track when we expect
pending I/O.
(fhandler_base_overlapped::read_overlapped): Move to this class from
fhandler_base.  Return error if ongoing I/O.
(fhandler_base_overlapped::write_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Semi-reinstate previous function.
* fhandler.h (fhandler_base::wait_overlapped): Move to fhandler_base_overlapped
class.
(fhandler_base::write_overlapped): Ditto.
(fhandler_base::get_overlapped): Ditto.
(fhandler_base::get_overlapped_buffer): Ditto.
(fhandler_base_overlapped): New class.
(fhandler_pipe): Inherit from fhandler_base_overlapped.  Remove overlapped
stuff as a result.
(fhandler_fifo): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Initialize fhandler_base_overlapped.
(pipe): Put a descriptive name in the fhandler.
@
text
@d1040 7
d1048 1
a1048 1
  return res;
a1171 1
  child->setup_overlapped ();
d1175 8
a1350 1
  setup_overlapped ();
a1368 1
  setup_overlapped ();
d1375 7
a1384 1
  setup_overlapped ();
d1388 6
d1667 2
a1668 2
bool
fhandler_base_overlapped::setup_overlapped (bool doit)
d1672 3
a1674 12
  bool res;
  if (doit)
    {
      set_overlapped (ov);
      res = !!(ov->hEvent = CreateEvent (&sec_none_nih, true, true, NULL));
    }
  else
    {
      set_overlapped (NULL);
      res = false;
    }
  return res;
d1686 2
@


1.364
log
@	* fhandler.cc (fhandler_base::fstat): Keep st_ctime and st_birthtime
	fixed to 2006-12-01 00:00 UTC.
@
text
@d1165 1
a1165 2
  if (get_overlapped ())
    child->setup_overlapped ();
d1337 1
a1337 2
  if (get_overlapped ())
    setup_overlapped ();
d1356 1
a1356 2
  if (get_overlapped ())
    setup_overlapped ();
d1366 1
a1366 2
  if (get_overlapped ())
    setup_overlapped ();
d1644 1
a1644 1
fhandler_base::setup_overlapped (bool doit)
d1663 1
a1663 1
fhandler_base::destroy_overlapped ()
d1673 14
d1688 1
a1688 1
fhandler_base::wait_overlapped (bool inres, bool writing, DWORD *bytes, DWORD len)
d1700 1
d1772 1
a1772 1
fhandler_base::read_overlapped (void *ptr, size_t& len)
d1775 11
a1785 8
  while (1)
    {
      bool res = ReadFile (get_handle (), ptr, len, &nbytes,
			   get_overlapped ());
      int wres = wait_overlapped (res, false, &nbytes);
      if (wres || !_my_tls.call_signal_handler ())
	break;
    }
d1790 1
a1790 1
fhandler_base::write_overlapped (const void *ptr, size_t len)
d1793 11
a1803 8
  while (1)
    {
      bool res = WriteFile (get_output_handle (), ptr, len, &nbytes,
			    get_overlapped ());
      int wres = wait_overlapped (res, true, &nbytes, (size_t) len);
      if (wres || !_my_tls.call_signal_handler ())
	break;
    }
@


1.363
log
@* fhandler.cc (fhandler_base::fstat): Set st_mtime time to current time.
@
text
@d1103 5
a1107 1
  buf->st_ctim.tv_sec = time (NULL);	/* Arbitrary value: current time,
d1109 3
a1111 2
  buf->st_ctim.tv_nsec = 0L;
  buf->st_atim = buf->st_mtim = buf->st_birthtim = buf->st_ctim;
@


1.362
log
@* fhandler.cc (fhandler_base::setup_overlapped): Revert to starting with handle
in signalled state as it seems to fix some hangs.
@
text
@d1103 2
a1104 1
  buf->st_ctim.tv_sec = 1164931200L;	/* Arbitrary value: 2006-12-01 */
@


1.361
log
@* fhandler.cc (fhandler_base::setup_overlapped): Don't set signalled state to
true initially.
(fhandler_base::has_ongoing_io): Delete ill-advised function.
(fhandler_base::read_overlapped): Rely on caller having checked nonblocking
state.  Don't attempt to (incorrectly) check it here.
(fhandler_base::write_overlapped): Remove call to has_ongoing_io.
* select.cc (peek_pipe): Ditto.
* fhandler.h (fhandler_base::has_ongoing_io): Delete declaration.
@
text
@d1650 1
a1650 1
      res = !!(ov->hEvent = CreateEvent (&sec_none_nih, true, false, NULL));
@


1.360
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d1650 1
a1650 1
      res = !!(ov->hEvent = CreateEvent (&sec_none_nih, true, true, NULL));
a1753 12
bool __stdcall
fhandler_base::has_ongoing_io (bool testit)
{
  if (testit && get_overlapped () && get_overlapped ()->hEvent
      && WaitForSingleObject (get_overlapped ()->hEvent, 0) != WAIT_OBJECT_0)
    {
      set_errno (EAGAIN);
      return true;
    }
  return false;
}

a1759 5
      if (has_ongoing_io (is_nonblocking ()))
	{
	  nbytes = (DWORD) -1;
	  break;
	}
a1774 5
      if (has_ongoing_io (is_nonblocking ()))
	{
	  nbytes = (DWORD) -1;
	  break;
	}
@


1.359
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d472 1
a472 1
  pc.get_object_attr (attr, sec_none);
@


1.358
log
@	* sec_helper.cc (security_descriptor::free): If sd_size is 0, call
	LocalFree instead of ::free.

	* sec_acl.cc: Throughout replace old ACE flag definitions with current
	definitions as used in MSDN man pages.
	* security.cc: Ditto.

	* fhandler.cc (fhandler_base::open): Make sure file has really been
	just created before fixing file permissions.  Add S_JUSTCREATED
	attribute to set_file_attribute call.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Always create dir
	with default security descriptor and fix descriptor afterwards.
	Add S_JUSTCREATED flag to set_file_attribute call.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Call GetSecurityInfo rather than
	NtQuerySecurityObject.  Explain why.  Change error handling accordingly.
	(alloc_sd): Skip non-inherited, non-standard entries in ACL if
	S_JUSTCREATED attribute is set.  Explain why.  Minor format fixes.
	* security.h (S_JUSTCREATED): New define.
	(security_descriptor::operator=): New operator.
@
text
@d1146 3
a1148 2
      if (!DuplicateHandle (hMainProc, get_handle (), hMainProc, &nh, 0, TRUE,
			    DUPLICATE_SAME_ACCESS))
d1323 2
a1324 2
  else if (!DuplicateHandle (parent, h, hMainProc, &h, 0, !close_on_exec (),
			     DUPLICATE_SAME_ACCESS))
@


1.357
log
@	* fhandler.cc (fhandler_base::open): Remove unused variables sa and sd.
@
text
@d618 2
a619 2
  if ((flags & O_CREAT) && has_acls ())
    set_file_attribute (fh, pc, ILLEGAL_UID, ILLEGAL_GID, mode);
@


1.356
log
@	* fhandler.cc (fhandler_base::open): Always create file with default
	security descriptor and fix descriptor afterwards.  Change comment to
	explain why.
	* security.cc (alloc_sd): Drop setting the SE_DACL_PROTECTED flag.
	* wincap.cc: Remove has_dacl_protect throughout.
	* wincap.h: Ditto.
@
text
@a463 2
  SECURITY_ATTRIBUTES sa = sec_none;
  security_descriptor sd;
d472 1
a472 1
  pc.get_object_attr (attr, sa);
@


1.355
log
@Fix some POSIX-compliance bugs in link, rename, mkdir.

* syscalls.cc (link): Delete obsolete comment.  Reject directories
and missing source up front.
(rename): Use correct errno for trailing '.'.  Detect empty
strings.  Allow trailing slash to newpath iff oldpath is
directory.
* dir.cc (mkdir): Reject dangling symlink with trailing slash.
* fhandler_disk_file.cc (fhandler_disk_file::link): Reject
trailing slash.
* fhandler.cc (fhandler_base::link): Match Linux errno.
@
text
@d556 1
a556 14
	  /* If mode has no write bits set, and ACLs are not used, we set
	     the DOS R/O attribute. */
	  if (!has_acls () && !(mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
	    file_attributes |= FILE_ATTRIBUTE_READONLY;

	  /* If the file should actually be created and has ACLs,
	     set files attributes, except on remote file systems.
	     See below. */
	  if (has_acls () && !pc.isremote ())
	    {
	      set_security_attribute (pc, mode, &sa, sd);
	      attr.SecurityDescriptor = sa.lpSecurityDescriptor;
	    }
	  else if (pc.fs_is_nfs ())
d576 4
d600 4
a603 2
  /* After some discussion on the samba-technical list, starting here:
     http://lists.samba.org/archive/samba-technical/2008-July/060247.html
d605 8
a612 7
     Always create files on a remote share using a NULL SD.  Create
     correct permission bits afterwards, maintaing the owner and group
     information just like chmod.

     The reason to do this is to maintain the Windows behaviour when
     creating files on a remote share.  Files on a remote share are
     created as the user used for authentication.  In a domain that's
d616 5
a620 5
     unexpected behaviour.

     Doing it like we do here creates the expected SD in a domain as
     well as on standalone servers. */
  if ((flags & O_CREAT) && has_acls () && pc.isremote ())
@


1.354
log
@Fix faccessat(,0) and access() semantics.

* fhandler.h (fhandler_base::fhaccess): Add parameter.
* security.h (check_file_access, check_registry_access): Likewise.
* security.cc (check_file_access, check_registry_access)
(check_access): Implement new parameter.
* fhandler.cc (fhandler_base::fhaccess): Likewise.
(device_access_denied): Update caller.
* syscalls.cc (access, faccessat): Update callers.
* spawn.cc (find_exec, fixup): Likewise.
@
text
@d1544 1
a1544 1
  set_errno (EINVAL);
@


1.353
log
@	* fhandler.cc (fhandler_base::open): Only set R/O attribute if ACLs
	are not used.
@
text
@d347 1
a347 1
  return fhaccess (mode);
d351 1
a351 1
fhandler_base::fhaccess (int flags)
d376 1
a376 1
      res = check_file_access (pc, flags);
d381 1
a381 1
      res = check_registry_access (get_handle (), flags);
d392 1
a392 1
      if (st.st_uid == myself->uid)
d397 1
a397 1
      else if (st.st_gid == myself->gid)
d408 1
a408 1
      if (st.st_uid == myself->uid)
d413 1
a413 1
      else if (st.st_gid == myself->gid)
d424 1
a424 1
      if (st.st_uid == myself->uid)
d429 1
a429 1
      else if (st.st_gid == myself->gid)
@


1.352
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d556 3
a558 2
	  /* If mode has no write bits set, we set the R/O attribute. */
	  if (!(mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
@


1.351
log
@	* fhandler.h (enum del_lock_called_from): New enumeration.
	(fhandler_base::del_my_locks): Declare taking a del_lock_called_from
	as argument.
	* fhandler.cc (fhandler_base::close): Call del_my_locks with "on_close".
	(fhandler_base::fixup_after_fork): Call del_my_locks with "after_fork".
	(fhandler_base::fixup_after_exec): Call del_my_locks with "after_exec".
	* flock.cc (fhandler_base::del_my_locks): Take del_lock_called_from
	as argument.  Call node->del_my_locks with NULL handle in after_exec
	case.  Explain why.
@
text
@d212 1
a212 1
void
d281 1
a281 1
int
d652 1
a652 1
void
d679 1
a679 1
  if (rbinary () || len <= 0)
d742 1
a742 1
int
d837 1
a837 1
ssize_t
d894 1
a894 1
ssize_t
d1685 1
a1685 1
  DWORD err;
d1688 1
a1688 1
      if (inres || GetLastError () == ERROR_IO_PENDING)
a1698 5
      else
	{
	  res = 0;
	  err = GetLastError ();
	}
d1700 1
a1700 1
  else if (inres || ((err = GetLastError ()) == ERROR_IO_PENDING))
a1702 2
      if (!get_overlapped ())
	system_printf ("get_overlapped is zero?");
d1745 1
a1745 1
      res = -1;
d1792 1
a1792 1
int __stdcall
@


1.350
log
@* dcrt0.cc (jit_debug): New global.
(initial_env): Set jit_debug when we are automatically starting a gdb process.
* dtable.cc (dtable::get_debugger_info): Don't tty tricks when we are being
debugged by our own captive gdb, as determined by jit_debug == true.
(dtable::init_std_file_from_handle): Detect errors when initializing a tty
early rather than at random points later.
* fhandler.h (fhandler_*::init): Return int to indicate success/failure.
* fhandler.cc (fhandler_base::init): Reflect change in return value.
* pipe.cc (fhandler_pipe::init): Ditto.
(fhandler_pipe::create_selectable): Don't say we're retrying when we aren't.
* fhandler_console.cc (fhandler_console::init): Ditto.  Return success/failure.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
(fhandler_tty_slave::open): Make debugging output more detailed.
* tty.cc (tty_list::terminate): Don't close I/O handles before all slaves have
checked in.
(tty::slave_alive): Make a non-inlined function.  Check if tty pipe handles can
be created as an additional exists check.
* tty.h (tty::slave_alive): Just define here.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
d1037 1
a1037 1
    del_my_locks (false);
d1362 1
a1362 1
    del_my_locks (true);
d1372 1
a1372 1
    del_my_locks (false);
@


1.349
log
@* fhandler.cc (fhandler_base::has_ongoing_io): Accept an argument indicating
whether the overlapped event should be tested.
(fhandler_base::read_overlapped): Pass is_overlapped state to has_ongoing_io.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::has_ongoing_io): Accommodate argument change.
* select.cc (peek_pipe): Ditto.
@
text
@d1126 1
a1126 1
void
d1142 1
@


1.348
log
@* fhandler.h (fhandler_base::has_ongoing_io): Declare new function.
* fhandler.cc (fhandler_base::has_ongoing_io): Define new function.
(fhandler_base::read_overlapped): Use has_ongoing_io to avoid writing when
handle has not completed last I/O.
(fhandler_base::write_overlapped): Ditto.
* select.cc (peek_pipe): Be more careful about accessing hEvent field from
get_overlapped().
@
text
@d1767 1
a1767 1
fhandler_base::has_ongoing_io ()
d1769 1
a1769 1
  if (get_overlapped () && get_overlapped ()->hEvent
d1784 1
a1784 1
      if (has_ongoing_io ())
d1804 1
a1804 1
      if (has_ongoing_io ())
@


1.347
log
@* gendef (cleanup): Rename from 'nocr'.  Remove comments and trailing spaces.
* cygwin.din: Add long-needed comment describing what dll_crt0__FP11per_process
demangles to.
@
text
@d1766 13
a1778 1
void
d1781 1
a1781 1
  DWORD bytes_read;
d1784 6
a1789 1
      bool res = ReadFile (get_handle (), ptr, len, &bytes_read,
d1791 1
a1791 1
      int wres = wait_overlapped (res, false, &bytes_read);
d1795 1
a1795 1
  len = (size_t) bytes_read;
d1798 1
a1798 1
int
d1801 1
a1801 1
  DWORD bytes_written;
d1804 6
a1809 1
      bool res = WriteFile (get_output_handle (), ptr, len, &bytes_written,
d1811 1
a1811 1
      int wres = wait_overlapped (res, true, &bytes_written, (size_t) len);
d1815 2
a1816 2
  debug_printf ("returning %u", bytes_written);
  return bytes_written;
@


1.346
log
@* fhandler.cc (fhandler_base::read_overlapped): Use a better variable name.
@
text
@d1655 1
a1655 1
      res = !!(ov->hEvent = CreateEvent (&sec_none_nih, true, false, NULL));
a1760 6
  /* Make sure the event is unsignalled (this is a potential race in a multi-threaded
     app.  Sigh.).  Must do this after WFMO and GetOverlappedResult or suffer
     occasional sporadic problems:
	http://cygwin.com/ml/cygwin/2008-08/msg00511.html */
  if (err != ERROR_IO_PENDING)
    ResetEvent (get_overlapped ()->hEvent);
@


1.345
log
@* fhandler.cc (fhandler_base::read_overlapped): Preserve len when looping due
to received signal.
@
text
@d1775 1
a1775 1
  DWORD bytes_written;
d1778 1
a1778 1
      bool res = ReadFile (get_handle (), ptr, len, &bytes_written,
d1780 1
a1780 1
      int wres = wait_overlapped (res, false, &bytes_written);
d1784 1
a1784 1
  len = (size_t) bytes_written;
@


1.344
log
@* errno.cc (errmap): Add mapping for ERROR_IO_INCOMPLETE.
* fhandler.cc (fhandler_base::fcntl): Fix comment.
(fhandler_base::wait_overlapped): Accept an optional len parameter.  Use the
len parameter when WriteFile fails with ERROR_IO_PENDING.  Make debug output
less alarming.
(fhandler_base::write_overlapped): Pass len to wait_overlapped.
* fhandler.h (fhandler_base::wait_overlapped): Add an optional argument
denoting the number of characters intended to be written.
* fhandler_tty.cc (fhandler_pty_master::close): Don't close archetype handles
when cygwin is still initializing since the handles aren't actually opened at
that point.
@
text
@d1775 1
d1778 1
a1778 1
      bool res = ReadFile (get_handle (), ptr, len, (DWORD *) &len,
d1780 1
a1780 1
      int wres = wait_overlapped (res, false, (DWORD *) &len);
d1784 1
a1790 1

@


1.343
log
@* fhandler.cc (fhandler_base::wait_overlapped): Honor nonblocking flag for
writes.  Don't reset event handle when we see a ERROR_IO_PENDING.
* sigproc.cc (stopped_or_terminated): Use bool constants for consistency.
* wait.cc (wait4): Remove nonsensical comment.
@
text
@d1188 4
a1191 6
	/*
	 * Only O_APPEND, O_ASYNC and O_NONBLOCK/O_NDELAY are allowed.
	 * Each other flag will be ignored.
	 * Since O_ASYNC isn't defined in fcntl.h it's currently
	 * ignored as well.
	 */
d1677 1
a1677 1
fhandler_base::wait_overlapped (bool inres, bool writing, DWORD *bytes)
d1687 16
a1702 2
      err = GetLastError ();
      res = inres;
d1734 1
a1734 1
	  debug_printf ("general error");
d1794 1
a1794 1
      int wres = wait_overlapped (res, true, &bytes_written);
@


1.342
log
@	* security.cc (set_file_sd): Drop using FILE_OPEN_FOR_RECOVERY flag in
	call to NtOpenFile.
	* exceptions.cc (open_stackdumpfile): Ditto in call to NtCreateFile.
	* fhandler.cc (fhandler_base::open): Ditto.  Simplify setting
	create_options.

	* mount.cc (fs_info::update): Recognize offline storage.
	(fillout_mntent): Report UDF and offline storage.
	* mount.h (class fs_info): Add is_csc_cache status flag.
@
text
@d1687 7
a1693 2
  if (inres || ((err = GetLastError ()) == ERROR_IO_PENDING))
   {
d1753 2
a1754 1
  ResetEvent (get_overlapped ()->hEvent);
@


1.341
log
@* fhandler.cc (fhandler_base::wait_overlapped): Set bytes to -1 on EINTR or
real error.
(fhandler_base::write_overlapped): Assume that bytes_written will contain
proper error value.
* pipe.cc (fhandler_pipe::fhandler_pipe): Set uninterruptible_io since signals
are handled by pipe functions now.
@
text
@d463 1
a463 1
  ULONG create_options;
a479 1
	create_options = FILE_OPEN_FOR_BACKUP_INTENT;
a482 1
	create_options = FILE_OPEN_FOR_BACKUP_INTENT;
a485 1
	create_options = FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_FOR_RECOVERY;
a488 1
	create_options = FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_FOR_RECOVERY;
d492 1
a492 4
	  {
	    access = GENERIC_READ;
	    create_options = FILE_OPEN_FOR_BACKUP_INTENT;
	  }
d494 1
a494 5
	  {
	    access = GENERIC_WRITE | READ_CONTROL | FILE_READ_ATTRIBUTES;
	    create_options = FILE_OPEN_FOR_BACKUP_INTENT
			     | FILE_OPEN_FOR_RECOVERY;
	  }
d496 1
a496 5
	  {
	    access = GENERIC_READ | GENERIC_WRITE;
	    create_options = FILE_OPEN_FOR_BACKUP_INTENT
			     | FILE_OPEN_FOR_RECOVERY;
	  }
@


1.340
log
@* fhandler.h (fhandler_base_setup_overlapped): Add new argument.
(fhandler_base::get_overlapped_buffer): Declare new function.
(fhandler_base::set_overlapped): Ditto.
(fhandler_pipe::overlapped): New variable.
(fhandler_pipe::get_overlapped): Rework to return contents of overlapped
variable.
(fhandler_pipe::set_overlapped): Set overlapped variable based on argument.
(fhandler_fifo::get_overlapped_buffer): Return pointer to io_status.
* fhandler.cc (handler_base::setup_overlapped): Set to overlapped pointer to
NULL if new doit parameter is false.  Otherwise set up overlapped event as
usual.
(fhandler_base::wait_overlapped): Return inres if this isn't an overlapped
operation.
(fhandler_base::read_overlapped): Remove inappropriate asserts.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero overlapped element.
(struct pipesync): Delete.
(getov_result): Ditto.
(pipe_handler): Ditto.
(pipesync::pipesync): Ditto.
(fhandler_pipe::init): Don't set up pipesync thread.  Just pass opened_properly
flag along to overlapped setup.
@
text
@d1700 1
a1700 1
  *bytes = (DWORD) -1;
d1725 1
d1736 1
a1736 1
	  debug_printf ("normal read");
d1748 1
a1791 2
      if (wres < 0)
	return -1;
d1795 1
@


1.339
log
@* fhandler.cc (fhandler_base::wait_overlapped): Reorganize to eliminate gotos
and to hopefully eliminate one race when a signal is detected or there is a
WFMO error.
@
text
@d1664 1
a1664 1
fhandler_base::setup_overlapped ()
d1666 1
a1666 1
  OVERLAPPED *ov = get_overlapped ();
d1668 12
a1679 1
  return (ov->hEvent = CreateEvent (&sec_none_nih, true, false, NULL));
d1696 3
a1769 4
#ifdef DEBUGGING
  assert (get_overlapped ());
  assert (get_overlapped ()->hEvent);
#endif
@


1.338
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d1685 1
a1685 1
  int res;
d1687 3
a1689 11
  DWORD err = GetLastError ();
  if (!inres && err != ERROR_IO_PENDING)
    {
      if (err != ERROR_HANDLE_EOF && err != ERROR_BROKEN_PIPE)
	goto err;
      res = 1;
      *bytes = 0;
      err = 0;
    }
  else
    {
d1702 6
a1707 3
      DWORD wres = WaitForMultipleObjects (n, w4, false, INFINITE);
      err = 0;
      switch (wres)
a1708 11
	case WAIT_OBJECT_0:
	  debug_printf ("normal read");
	  if (GetOverlappedResult (h, get_overlapped (), bytes, false))
	    res = 1;
	  else
	    {
	      err = GetLastError ();
	      goto err;
	    }
	  break;
	case WAIT_OBJECT_0 + 1:
a1709 1
	  CancelIo (h);
d1712 4
a1715 2
	  break;
	default:
d1717 1
a1717 3
	  debug_printf ("WFMO error, %E");
	  goto err;
	  break;
d1719 22
a1741 1
  goto out;
a1742 4
err:
  __seterrno_from_win_error (err);
  res = -1;
out:
@


1.337
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d527 1
a527 1
         sure that we're going to act on the file itself, even if it'a
d531 1
a531 1
        access |=  FILE_WRITE_EA;
d586 1
a586 1
	         file mode by writing a NFS fattr3 structure with the
d598 1
a598 1
	                                     + p->EaNameLength + 1);
d637 1
a637 1
     
d1612 1
a1612 1
        return NAME_MAX;
@


1.336
log
@add comments
@
text
@d1668 1
a1668 1
  return ov->hEvent = CreateEvent (&sec_none_nih, true, false, NULL);
d1710 1
a1710 1
      DWORD res = WaitForMultipleObjects (n, w4, false, INFINITE);
d1712 1
a1712 1
      switch (res)
@


1.335
log
@* fhandler.cc (fhandler_base::wait_overlapped): Reorganize again to accommodate
what appears to be an MSDN hint about not resetting the overlapped event prior
to calling GetOverlappedResult.
@
text
@d1743 4
@


1.334
log
@* fhandler.cc (fhandler_base::wait_overlapped): Always assume that bytes will
be non-NULL.  Distinguish input result from result derived from WFMO and
GetOverlappedResult or res can never be -1.  Only raise SIGPIPE when writing.
* fhandler.h (fhandler_base::wait_overlapped): Pass first argument by value.
* fhandler_fifo.cc (fhandler_fifo::wait): Pass in dummy byte count to
wait_overlapped.
* pipe.cc (DEFAULT_PIPEBUFSIZE): Define to 65536 explicitly.
@
text
@d1694 1
d1711 1
a1711 1
      ResetEvent (get_overlapped ()->hEvent);
d1742 2
a1745 1
out:
@


1.333
log
@* fhandler.cc (fhandler_base::wait_overlapped): Don't treat ERROR_BROKEN_PIPE
as a non-error.  Do raise SIGPIPE when it is detected.
@
text
@d1683 1
a1683 1
fhandler_base::wait_overlapped (bool& res, bool writing, DWORD *bytes)
d1685 2
a1686 2
  if (bytes)
    *bytes = (DWORD) -1;
d1688 1
a1688 1
  if (!res && err != ERROR_IO_PENDING)
d1690 1
a1690 1
      if (err != ERROR_HANDLE_EOF)
d1693 1
a1693 2
      if (*bytes)
	*bytes = 0;
d1709 3
a1711 1
      switch (WaitForMultipleObjects (n, w4, false, INFINITE))
d1715 1
a1715 2
	  if (!bytes ||
	      GetOverlappedResult (h, get_overlapped (), bytes, false))
d1741 1
a1741 1
  if (err == ERROR_NO_DATA || err == ERROR_BROKEN_PIPE)
a1743 1
  ResetEvent (get_overlapped ()->hEvent);
@


1.332
log
@	* external.cc (cygwin_internal): Call set_security_attribute with
	additional path_conv argument.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Never set DOS
	R/O attribute when using ACLs.
	(fhandler_disk_file::mkdir): Ditto.  Set
	security descriptor on remote dirs after creating the dir, same as in
	fhandler_base::open.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for remote AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto. for remote symlinks.
	* security.cc (alloc_sd): Take additional path_conv argument.
	Accommodate throughout.  Drop setting FILE_WRITE_EA/FILE_READ_EA
	flags unconditionally (was only necessary for "ntea"). Don't set
	FILE_READ_ATTRIBUTES and FILE_WRITE_ATTRIBUTES unconditionally on
	Samba.  Add comment to explain.  Drop useless setting of
	STANDARD_RIGHTS_WRITE, it's in FILE_GENERIC_WRITE anyway.
	Remove FILE_READ_ATTRIBUTES bit from FILE_GENERIC_EXECUTE so as not
	to enforce read permissions on Samba.
	(set_security_attribute): Take additional path_conv argument.
	* security.h (set_security_attribute): Change prototype accordingly.
@
text
@d1690 1
a1690 1
      if (err != ERROR_HANDLE_EOF && err != ERROR_BROKEN_PIPE)
d1741 1
a1741 1
  if (err == ERROR_NO_DATA)
@


1.331
log
@	* fhandler.cc (fhandler_base::open): Use Samba workaround generally
	for all remote filesystems supporting ACLs.  Change comment and
	explain why.  Refer to the discussion which led to this.
@
text
@d580 1
a580 1
	      set_security_attribute (mode, &sa, sd);
@


1.330
log
@	* fhandler.cc (fhandler_base::open): Rename x to fh.  On Samba, always
	create file with NULL security descriptor and set the permissions
	afterwards.  Explain why.
@
text
@d576 3
a578 2
	     set files attributes, except on Samba.  See below. */
	  if (has_acls () && !pc.fs_is_samba ())
d623 18
a640 15
  /* Samba weirdness:
     The local user SID is used in set_security_attribute, but the
     actual owner on the Samba share is the SID of the Unix account.
     There's no transparent mapping between these accounts.

     FIXME: Really?

     And Samba has a strange behaviour when creating a file.  Apparently
     it *first* creates the file, *then* it looks if the security
     descriptor matches.  The result is that the file gets created, but
     then NtCreateFile doesn't return a handle to the file and fails
     with STATUS_ACCESS_DENIED.  That's why we first create the file
     with default SD and afterwards set the permissions while ignoring
     the owner and group. */
  if ((flags & O_CREAT) && has_acls () && pc.fs_is_samba ())
@


1.329
log
@	* environ.cc (known): Remove "binmode" option.
	* fhandler.cc (binmode): Remove.
	(fhandler_base::set_flags): Accommodate binmode removal.
	* path.h (path_conv::set_binary): Remove.
	* pipe.cc (pipe): Create pipes always as binary pipes.
	* winsup.h (binmode): Remove declaration.
@
text
@d459 1
a459 1
  HANDLE x;
d575 3
a577 13
	  /* If the file should actually be created and ntsec is on,
	     set files attributes. */
	  /* TODO: Don't remove the call to has_acls() unless there's a
	     solution for the security descriptor problem on remote samba
	     drives.  The local user SID is used in set_security_attribute,
	     but the actual owner on the Samba share is the SID of the Unix
	     account.  There's no transparent mapping between these accounts.
	     And Samba has a strange behaviour when creating a file.  Apparently
	     it *first* creates the file, *then* it looks if the security
	     descriptor matches.  The result is that the file gets created, but
	     then NtCreateFile doesn't return a handle to the file and fails
	     with STATUS_ACCESS_DENIED.  Go figure! */
	  if (has_acls ())
d607 1
a607 1
  status = NtCreateFile (&x, access, &attr, &io, NULL, file_attributes, shared,
d622 18
a639 1
  set_io_handle (x);
d647 1
a647 1
		status, x, access, pc.get_nt_native_path (), file_attributes,
@


1.328
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@a36 2
DWORD binmode;

d198 1
a198 2
    bin = wbinary () || rbinary () || (binmode != O_TEXT)
	  ? O_BINARY : O_TEXT;
@


1.327
log
@	* fhandler.cc (fhandler_base::fpathconf): On _PC_POSIX_PERMISSIONS
	and _PC_POSIX_SECURITY, return true for NFS, too.
@
text
@d328 1
a328 1
		     && strcasematch (stem, pf->name))
@


1.326
log
@	Throughout drop allow_ntsec and allow_smbntsec handling.
	* environ.cc (set_ntsec): Remove.
	(set_smbntsec): Remove.
	(known): Remove ntsec and smbntsec options.
	* external.cc (check_ntsec): Return true if no filename is given.
	* mount.cc (oopts): Add "acl" and "noacl" options.  Set MOUNT_NOACL
	flag accordingly.
	(fillout_mntent): Handle MOUNT_NOACL flag.
	* path.h (enum path_types): Add PATH_NOACL.
	* security.cc (allow_ntsec): Remove.
	(allow_smbntsec): Remove.
	* security.h (allow_ntsec): Drop declaration.
	(allow_smbntsec): Drop declaration.
	* include/sys/mount.h (MOUNT_NOACL): Define.
@
text
@d1643 1
a1643 1
	return pc.has_acls ();
@


1.325
log
@	* Makefile.in (DLL_OFILES): Add nfs.o.
	* fhandler.cc (fhandler_base::open): Open files on NFS shares with
	correct access flags and EAs.
	* fhandler.h (fhandler_base::fstat_by_nfs_ea): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): New method.
	(fhandler_base::fstat_by_handle): Call fstat_by_nfs_ea for files on
	NFS shares.
	(fhandler_disk_file::fchmod): Use NFS specific method to set mode for
	files on NFS shares.  Don't overrule errno from call to
	set_file_attribute with errno from NtSetInformationFile call.
	(fhandler_disk_file::fchown): Add comment.
	* mount.cc (fillout_mntent): Accommodate change in second parameter
	to fs_info::update.
	* nfs.cc: New file.
	* nfs.h: New file.
	* path.cc (fs_info::update): Take handle instead of bool as second
	parameter.  Use that handle if it's not NULL.  Only close handle if
	it has been opened here.  Use static defined buffers instead of
	alloca'd buffers.
	(path_conv::check): Call symlink_info::check with reference to fs.
	Don't call fs.update here if file exists.
	(conv_path_list): Prefer tmp_pathbuf buffer over using alloca.
	(symlink_worker): Use NFS specific method to create symlinks on NFS
	shares.  Prefer tmp_pathbuf buffer over using alloca.
	(symlink_info::check_shortcut): Reopen file from incoming handle
	with necessary FILE_GENERIC_READ flag.  Prefer tmp_pathbuf buffer over
	using alloca.
	(symlink_info::check_sysfile): Ditto.
	(symlink_info::check_reparse_point): Use tmp_pathbuf buffer to
	allocate REPARSE_DATA_BUFFER.
	(symlink_info::check_nfs_symlink): New method.
	(enum symlink_t): Remove.
	(symlink_info::check): Don't use NtQueryAttributesFile.  Rather, open
	file with necessary access flags and call NtQueryInformationFile.  Fix
	error handling in case file can't be opened.  For existing files, call
	fs_info::update here.  Restructure symlink checking to accommodate the
	fact that the file is already open.  Add case for NFS symlinks.
	* path.h (fs_info::update): Take handle instead of bool as second
	parameter.
@
text
@d377 1
a377 1
  else if (has_acls () && allow_ntsec)
d382 1
a382 2
  else if (get_device () == FH_REGISTRY && allow_ntsec && open (O_RDONLY, 0)
	   && get_handle ())
d590 1
a590 1
	  if (allow_ntsec && has_acls ())
@


1.324
log
@	* fhandler.cc (fhandler_base::open): Move handling FILE_ATTRIBUTE_NORMAL
	back to its old place.  Or it to file_attributes instead of setting it.
@
text
@d31 1
d473 2
d528 12
d596 20
d622 1
a622 1
			 create_disposition, create_options, NULL, 0);
@


1.323
log
@	* fhandler.cc (fhandler_base::open): *Only* handle SYSTEM and HIDDEN
	attributes in FILE_OVERWRITE case.
@
text
@a541 1
      file_attributes = FILE_ATTRIBUTE_NORMAL;
d558 2
@


1.322
log
@	* fhandler.cc (fhandler_base::open): Handle SYSTEM and HIDDEN attributes
	in FILE_OVERWRITE case as well.
@
text
@d542 1
d548 10
a557 1
      if ((flags & O_CREAT) || create_disposition == FILE_OVERWRITE)
a558 1
	  file_attributes = FILE_ATTRIBUTE_NORMAL;
a561 7
	  /* Starting with Windows 2000, when trying to overwrite an already
	     existing file with FILE_ATTRIBUTE_HIDDEN and/or FILE_ATTRIBUTE_SYSTEM
	     attribute set, CreateFile fails with ERROR_ACCESS_DENIED.
	     Per MSDN you have to create the file with the same attributes as
	     already specified for the file. */
	  if (has_attribute (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM))
	    file_attributes |= pc.file_attributes ();
@


1.321
log
@	* cygwin.din (futimens): Export.
	(utimensat): Export.
	* fhandler.cc (fhandler_base::utimens): Replace fhandler_base::utimes.
	Call utimens_fs.
	* fhandler.h (class fhandler_base): Declare utimens_fs instead of
	utimes_fs, utimens instead of utimes.
	(class fhandler_disk_file): Declare utimens instead of utimes.
	* fhandler_disk_file.cc (fhandler_disk_file::utimens): Replace
	fhandler_disk_file::utimes.
	(fhandler_base::utimens_fs): Replace fhandler_base::utimes_fs.
	Implement tv_nsec handling according to SUSv4.
	* syscalls.cc (utimensat): New function.
	* times.cc (timespec_to_filetime): New function.
	(timeval_to_timespec): New function.
	(utimens_worker): Replace utimes_worker.
	(utimes): Convert timeval to timespec and call utimens_worker.
	(lutimes): Ditto.
	(futimens): Take over implementation from futimes.
	(futimes): Convert timeval to timespec and call futimens.
	* winsup.h (timespec_to_filetime): Declare.
	* include/cygwin/version.h: Bump API minor number.
	* posix.sgml: Add SUSv4 section.  Add futimens and utimensat to it.
@
text
@d547 1
a547 1
      if (flags & O_CREAT)
@


1.320
log
@Remove unneeded header files from source files throughout.
@
text
@d1519 1
a1519 1
fhandler_base::utimes (const struct timeval *tvp)
d1522 1
a1522 1
    return utimes_fs (tvp);
@


1.319
log
@	* Fix copyright dates.
@
text
@a14 1
#include <sys/cygwin.h>
a16 2
#include <sys/statvfs.h>
#include <signal.h>
a24 1
#include "shared_info.h"
a26 1
#include <limits.h>
a27 1
#include <ntdef.h>
@


1.318
log
@	Throughout, call fcntl64 instead of fcntl or fcntl_worker.
	* fcntl.cc (fcntl_worker): Remove.
	(fcntl64): Add fault handler.  Move fcntl_worker stuff here.  Add case
	for locking and call fhandler's lock method directly.  Make sure that
	F_FLOCK flag isn't set in lock call.
	(_fcntl): Add fault handler.
	* fhandler.cc (fhandler_base::fcntl): Drop lock cases.
	* flock.cc (flock): Add fault handler.  Simplify code.  Call fhandlers
	lock method directly instead of fcntl_worker.  Add debug output.
	(lockf): Add fault handler.  Call fhandlers lock method directly
	instead of fcntl_worker.  Add debug output.
	* winsup.h (fcntl_worker): Drop declaration.
	(fcntl64): Declare.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
@


1.317
log
@	* smallprint.cc (__small_vswprintf): Fix uninitialized usage of `w'.

	Revamp advisory file locking to avoid cross reference pointers as well
	as to allow BSD flock semantics.  More agressively delete unused nodes
	and sync objects.
	* fhandler.h (fhandler_base::ino): Rename from namehash.  Fix comment.
	(fhandler_base::node): Remove.
	(fhandler_base::unique_id): Add.
	(fhandler_base::del_my_locks): New method.
	(get_ino): Rename from get_namehash.  Change usage throughout Cygwin.
	(get_unique_id): New method.
	* fhandler.cc (fhandler_base::close): Call own del_my_locks method.
	Fix comment.
	(fhandler_base::fhandler_base): Accommodate new and changed members.
	(fhandler_base::fixup_after_fork): Call del_my_locks.
	(fhandler_base::fixup_after_exec): Ditto for files with close-on-exec
	flag set.
	* fhandler_disk_file.cc (get_ino_by_handle): Rename from
	readdir_get_ino_by_handle.  Accommodate throughout.
	(fhandler_base::open_fs): Fill ino with inode number if FS has good
	inodes.  Allocate a LUID and store in unique_id to recognize file
	descriptors referencing the same file object.
	* flock.cc: Drop flock TODO comments.  Use explicit types __dev32_t
	and __ino64_t instead of dev_t and ino_t.
	(LOCK_OBJ_NAME_LEN): Change to reflect longer lf_id length.
	(get_obj_handle_count): New method.
	(lockf_t::lf_id): Change type to long long.
	(inode_t::get_lock_obj_handle_count): Drop in favor of static function
	get_obj_handle_count.
	(inode_t::del_locks): Remove.
	(inode_t::get): Add create_if_missing flag argument.
	(inode_t::del_my_locks): Reimplement to handle POSIX and BSD flock
	locks.  Return if node can be deleted or not.
	(inode_t::~inode_t): Ditto.  Close handles to i_dir and i_mtx.
	(fixup_lockf_after_fork): Remove.
	(fhandler_base::del_my_locks): New method.
	(fixup_lockf_after_exec): Check if node can be deleted.
	(inode_t::get): Only create node if create_if_missing is set.  Lock
	the returned node here before unlocking the node list.
	(inode_t::get_all_locks_list): Accommodate new lf_id length.
	(inode_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.  Change return type to bool.  De-const.
	Set lf_obj instead of returning a handle.
	(lockf_t::del_lock_obj): Call SetEvent only if new incoming parameters
	allow it.  Explain how it's supposed to work.
	(fhandler_disk_file::lock): Only fetch file length in SEEK_END case.
	Use NtQueryInformationFile(FileStandardInformation) instead of
	calling fstat_by_handle.  Always unlock node before returning.
	Use fhandler's unique id to create lf_id for BSD flock locks.
	Rely on node lock from inode_t::get.  Call del_lock_obj on removed
	locks here to allow explicit unlocking.  Delete node if no lock exists
	on the file anymore.
	(lf_setlock): Get file handle as additional parameter.  Handle the fact
	that lf_getblock now always opens the attached event object.  Reactivate
	erroneously applied patch which deactivates setting thread priority.
	Additionally handle blocking on BSD flock locks.
	(lf_clearlock): Get file handle as additional parameter.
	(lf_getlock): Close event handle opened by lf_getblock.
	(lf_getblock): Open potentially blocking event object here and check
	its signal state if it's a BSD flock lock.
	(lf_wakelock): Get file handle as additional parameter.
	* fork.cc (frok::child): Drop call to fixup_lockf_after_fork.
	* ntdll.h (struct _EVENT_BASIC_INFORMATION): Define.
	(enum _EVENT_INFORMATION_CLASS): Define.
	(NtQueryEvent): Declare.

	* fhandler.h (fhandler_base::fs_flags): Remove.
	(fhandler_base::set_fs_flags): Remove.
	(fhandler_base::get_fs_flags): Remove.
	* fhandler.cc (fhandler_base::write): Check for sparse file using
	pc.fs_flags().
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.

	The return of the volume serial number in fs_info.
	* fhandler.h (get_dev): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call to
	NtQueryVolumeInformationFile(FileFsVolumeInformation).  Just use
	get_dev() method.
	* fhandler_fifo.cc (fhandler_fifo::open) Use device ID and inode number
	to generate fifo name.
	* path.h (fs_info::sernum): New member.
	(fs_info::serial_number): New method.
	(path_conv::fs_serial_number): New method.
	* path.cc (fs_info::update): Fetch volume serial number and store in
	sernum.
@
text
@a1180 5
    case F_GETLK:
    case F_SETLK:
    case F_SETLKW:
      res = lock (cmd, (struct __flock64 *) arg);
      break;
@


1.316
log
@	* fhandler.cc (fhandler_base::dup): Drop setting flags in the parent.

	Implement advisory file locking.
	* cygheap.h (struct init_cygheap): Add inode_list member.
	* cygwin.din (lockf): Export.
	* dcrt0.cc (child_info_spawn::handle_spawn): Call
	fixup_lockf_after_exec.
	* dtable.h (class dtable): Add fhandler_disk_file as friend class.
	* fhandler.cc (fhandler_base::close): Call del_my_locks if node is set.
	(fhandler_base::fhandler_base): Initialize node to NULL.
	(fhandler_base::fixup_after_fork): Ditto.
	* fhandler.h (class fhandler_base): Add member node.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Delete.
	* flock.cc: Implement all advisory file locking here.
	(fhandler_disk_file::lock): Implement here.
	(flock): Call fcntl with F_FLOCK bit set.  Remove test main function.
	(lockf): New function.
	* fork.cc (frok::child): Call fixup_lockf_after_fork.
	* ntdll.h (DIRECTORY_ALL_ACCESS): Define.
	(struct _OBJECT_BASIC_INFORMATION): Define.
	(enum _EVENT_TYPE): Define.
	(NtCreateDirectoryObject): Declare.
	(NtCreateEvent): Declare.
	(NtCreateMutant): Declare.
	(NtOpenEvent): Declare.
	(NtOpenMutant): Declare.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d739 1
a739 1
	  && get_fs_flags (FILE_SUPPORTS_SPARSE_FILES))
a1006 1
  extern void del_my_locks (inode_t *);
d1010 4
a1013 3
  /* Delete all POSIX locks on the file. */
  if (node)
    del_my_locks (node);
d1264 1
a1264 1
  namehash (0),
d1271 1
a1271 2
  node (NULL),
  fs_flags (0),
d1342 3
a1344 4
  /* POSIX locks are not inherited across fork.  The lock structures
     are deleted globally in fixup_lockf_after_fork.  Here we just
     have to reset the pointer. */
  node = NULL;
d1353 2
@


1.315
log
@	* fhandler.cc (fhandler_base::open): Use %S for PUNICODE_STRING.
	* syscalls.cc (setmode): Ditto.
@
text
@d1007 1
d1011 3
a1141 1
  set_flags (child->get_flags ());
d1271 1
d1343 4
@


1.314
log
@	* fhandler.cc (fhandler_base::open_): Add missing test for O_CREAT.
	Fix comment.
@
text
@d615 1
a615 1
  syscall_printf ("%d = fhandler_base::open (%s, %p)",
@


1.313
log
@s/open/create/
@
text
@d595 1
a595 1
      if (status == STATUS_OBJECT_NAME_INVALID
@


1.312
log
@	* child_info.h (~child_info_spawn): Check moreinfo->myself_pinfo for
	NULL before closing.
	* spawn.cc (spawn_guts): Don't close moreinfo->myself_pinfo explicitely
	in case of failing CloseProcess.

	* fhandler.cc (fhandler_base::open_): Return EISDIR when trying to
	create a directory.
	* path.cc (path_conv::check): If input path had a trailing dir
	separator, tack it on to the native path if directory doesn't exist.
@
text
@d593 1
a593 1
      /* Trying to open a directory should return EISDIR, not ENOENT. */
@


1.311
log
@	* fhandler.cc (fhandler_base::fpathconf): Fix _PC_NAME_MAX and
	_PC_PATH_MAX cases.
@
text
@d593 7
a599 1
      __seterrno_from_nt_status (status);
@


1.310
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d1544 2
d1563 4
a1566 1
      return pc.isdir () ? PATH_MAX - strlen (get_name ()) - 2 : NAME_MAX;
d1569 4
a1572 1
      return pc.isdir () ? PATH_MAX - strlen (get_name ()) - 1 : PATH_MAX;
@


1.309
log
@	* Makefile.in (DLL_OFILES): Add ntea.o.
	* cygwin.din (getxattr, listxattr, removexattr, setxattr, lgetxattr,
	llistxattr, lremovexattr, lsetxattr, fgetxattr, flistxattr,
	fremovexattr, fsetxattr): Export Linux extended attribute functions.
	Sort.
	* errno.cc (errmap): Add mappings for ERROR_EAS_DIDNT_FIT,
	ERROR_EAS_NOT_SUPPORTED, ERROR_EA_LIST_INCONSISTENT,
	ERROR_EA_TABLE_FULL, ERROR_FILE_CORRUPT, ERROR_INVALID_EA_NAME.
	* fhandler.h (class fhandler_base): Declare new fgetxattr and
	fsetxattr methods.
	(class fhandler_disk_file): Ditto.
	* fhandler.cc (fhandler_base::fgetxattr): New method.
	(fhandler_base::fsetxattr): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::fgetxattr): New method.
	(fhandler_disk_file::fsetxattr): New method.
	* ntdll.h (STATUS_EA_TOO_LARGE): Define.
	(STATUS_NONEXISTENT_EA_ENTRY): Define.
	(STATUS_NO_EAS_ON_FILE): Define.
	* ntea.cc (read_ea): Rewrite for long pathnames and for using with
	Linux extended attribute functions.
	(write_ea): Ditto.
	(getxattr_worker): New static function.
	(getxattr): New function.
	(lgetxattr): New function.
	(fgetxattr): New function.
	(listxattr): New function.
	(llistxattr): New function.
	(flistxattr): New function.
	(setxattr_worker): New static function.
	(setxattr): New function.
	(lsetxattr): New function.
	(fsetxattr): New function.
	(removexattr): New function.
	(lsetxattr): New function.
	(fsetxattr): New function.
	* security.h (read_ea): Change declaration according to above changes.
	(write_ea): Ditto.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d943 1
a943 1
        {
d953 1
a953 1
        {
@


1.308
log
@* dtable.cc (POSIX_NAMED_PIPE): New define.
(POSIX_NAMED_PIPE_LEN): Ditto.
(dtable::add_archetype): Use crealloc_abort.
(dtable::init_std_file_from_handle): Specifically detect pipe stdin/stdout.
Pass name to build_fh_dev so that proper name is recorded.  Use binmode of fh
if it is set before using get_default_mode.  Set proper read/write access when
calling init().
(handle_to_fn): Handle pipes.
* fhandler.cc (fhandler_base::wait_overlapped): Add some debugging.
* fhandler.h (fhandler_base::set_name): Default to just setting the path_conv
name.
(fhandler_pipe::init): Declare.
* pipe.cc (struct pipesync): New struct.
(getov_result): New function.  Blocks and retrieves the result of an overlay
I/O operation.
(pipe_handler): New function.
(pipesync::pipesync): New function.  Initializer for pipesync struct.
(handler_pipe::init): Define.  Detects attempts to set up a "native" pipe
fhandler and creates a thread which accepts input from or output to the
non-cygwin pipe, creating a cygwin pipe wrapper around the non-cygwin pipe.
(fhandler_pipe::create): Add pipe-specific flags to call to init().
* exceptions.cc (ctrl_c_handler): Lock process while we determine what to do.
@
text
@d1479 15
@


1.307
log
@revert premature checkin
@
text
@d1642 1
d1653 1
d1660 1
@


1.306
log
@* dllfixdbg: Eliminate extra objcopy step.
@
text
@a1641 1
	  debug_printf ("normal read");
a1651 1
	  debug_printf ("got a signal");
a1657 1
	  debug_printf ("WFMO error, %E");
@


1.305
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.
@
text
@d1642 1
d1653 1
d1660 1
@


1.304
log
@	* fhandler.cc (fhandler_base::open): Open native symlinks with
	FILE_OPEN_REPARSE_POINT flag.  Fix typo in comment.
@
text
@d379 2
a380 1
  else if (has_attribute (FILE_ATTRIBUTE_READONLY) && (flags & W_OK))
@


1.303
log
@	* fhandler.cc (is_at_eof): Rewrite using NT functions.
	(off_current): New static variable.
	(off_append): Ditto.
	(fhandler_base::raw_write): Use NtWriteFile.  Accommodate O_APPEND here.
	(fhandler_base::write): Drop O_APPEND hack.  Use NT functions.
	(fhandler_base::lseek): Rewrite using NT functions.
	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Add space in
	debug output.
	(fhandler_disk_file::ftruncate): Ditto.
	* ntdll.h (STATUS_DISK_FULL): Define.
	(FILE_USE_FILE_POINTER_POSITION): Define.
	(FILE_WRITE_TO_END_OF_FILE): Define.
@
text
@d545 1
a545 1
  if (flags & O_CREAT && get_device () == FH_FS)
d547 6
a552 25
      file_attributes = FILE_ATTRIBUTE_NORMAL;
      /* If mode has no write bits set, we set the R/O attribute. */
      if (!(mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
	file_attributes |= FILE_ATTRIBUTE_READONLY;
      /* Starting with Windows 2000, when trying to overwrite an already
	 existing file with FILE_ATTRIBUTE_HIDDEN and/or FILE_ATTRIBUTE_SYSTEM
	 attribute set, CreateFile fails with ERROR_ACCESS_DENIED.
	 Per MSDN you have to create the file with the same attributes as
	 already specified for the file. */
      if (has_attribute (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM))
	file_attributes |= pc.file_attributes ();

      /* If the file should actually be created and ntsec is on,
	 set files attributes. */
      /* TODO: Don't remove the call to has_acls() unless there's a
	 solution for the security descriptor problem on remote samba
	 drives.  The local user SID is used in set_security_attribute,
	 but the actual owner on the Samba share is the SID of the Unix
	 account.  There's no transparent mapping between these accounts.
	 And Samba has a strange behaviour when creating a file.  Apparently
	 it *first*( creates the file, *then* it looks if the security
	 descriptor matches.  The result is that the file gets created, but
	 then NtCreateFile doesn't return a handle to the file and fails
	 with STATUS_ACCESS_DENIED.  Go figure! */
      if (allow_ntsec && has_acls ())
d554 31
a584 2
	  set_security_attribute (mode, &sa, sd);
	  attr.SecurityDescriptor = sa.lpSecurityDescriptor;
a585 2
      /* The file attributes are needed for later use in, e.g. fchmod. */
      pc.file_attributes (file_attributes);
@


1.302
log
@	* fhandler.cc (fhandler_base::open): Partly revert change from
	2007-08-24:  Call has_acls to avoid permission problems getting
	a handle to a file on a remote share.  Add comment.
@
text
@d174 3
a176 10
  DWORD size, upper1, curr;

  size = GetFileSize (h, &upper1);
  if (size != INVALID_FILE_SIZE || GetLastError () == NO_ERROR)
    {
      LONG upper2 = 0;
      curr = SetFilePointer (h, 0, &upper2, FILE_CURRENT);
      if (curr == size && upper1 == (DWORD) upper2)
	return 1;
    }
d178 6
d286 3
d292 2
a293 1
  DWORD bytes_written;
d295 5
a299 1
  if (!WriteFile (get_output_handle (), ptr, len, &bytes_written, 0))
d301 1
a301 1
      if (GetLastError () == ERROR_DISK_FULL && bytes_written > 0)
d303 1
a303 1
      __seterrno ();
d309 1
a309 1
  return bytes_written;
d707 3
d711 1
a711 1
  if (get_flags () & O_APPEND)
a712 15
      LONG off_high = 0;
      DWORD ret = SetFilePointer (get_output_handle (), 0, &off_high, FILE_END);
      if (ret == INVALID_SET_FILE_POINTER && GetLastError () != NO_ERROR)
	{
	  debug_printf ("Seeking to EOF in append mode failed");
	  __seterrno ();
	  return -1;
	}
    }
  else if (did_lseek ())
    {
      _off64_t actual_length, current_position;
      DWORD size_high = 0;
      LONG pos_high = 0;

d715 9
a723 8
      actual_length = GetFileSize (get_output_handle (), &size_high);
      actual_length += ((_off64_t) size_high) << 32;

      current_position = SetFilePointer (get_output_handle (), 0, &pos_high,
					 FILE_CURRENT);
      current_position += ((_off64_t) pos_high) << 32;

      if (current_position >= actual_length + (128 * 1024)
d729 5
a733 6
	  DWORD dw;
	  HANDLE h = get_output_handle ();
	  BOOL r = DeviceIoControl (h, FSCTL_SET_SPARSE, NULL, 0, NULL,
				    0, &dw, NULL);
	  syscall_printf ("%d = DeviceIoControl(%p, FSCTL_SET_SPARSE)",
			  r, h);
d910 4
a913 1
  _off64_t res;
d925 26
a950 1
  debug_printf ("lseek (%s, %D, %d)", get_name (), offset, whence);
d952 4
a955 9
  DWORD win32_whence = whence == SEEK_SET ? FILE_BEGIN
		       : (whence == SEEK_CUR ? FILE_CURRENT : FILE_END);

  LONG off_low = ((__uint64_t) offset) & UINT32_MAX;
  LONG off_high = ((__uint64_t) offset) >> 32LL;

  debug_printf ("setting file pointer to %u (high), %u (low)", off_high, off_low);
  res = SetFilePointer (get_handle (), off_low, &off_high, win32_whence);
  if (res == INVALID_SET_FILE_POINTER && GetLastError ())
d957 2
a958 2
      __seterrno ();
      res = -1;
d960 1
a960 3
  else
    {
      res += (_off64_t) off_high << 32;
d962 9
a970 10
      /* When next we write(), we will check to see if *this* seek went beyond
	 the end of the file and if so, potentially sparsify the file. */
      did_lseek (true);

      /* If this was a SEEK_CUR with offset 0, we still might have
	 readahead that we have to take into account when calculating
	 the actual position for the application.  */
      if (whence == SEEK_CUR)
	res -= ralen - raixget;
    }
@


1.301
log
@	* fhandler.cc (rootdir): Delete.
	* winsup.h (rootdir): Drop declaration.
@
text
@d554 11
a564 1
      if (allow_ntsec)
@


1.300
log
@	* devices.in (dev_storage): Use native NT device name for kmsg mailslot.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::operator =): Use path_conv assignment
	operator.
	(fhandler_base::set_name): Ditto.
	(fhandler_base::open): Use NT native path in debug output.
	* fhandler_mailslot.cc: Convert to NT native function calls.
	* ntdll.h (struct _FILE_MAILSLOT_SET_INFORMATION): Define.
	(NtCreateMailslotFile): Declare.
	* path.cc (path_conv::set_normalized_path): Don't set wide_path to NULL.
	(path_conv::set_name): Remove unused function.
	* path.h (path_conv::set_name): Drop declaration.
	(path_conv::operator =): Define.
@
text
@a1010 89
extern "C" char * __stdcall
rootdir (const char *full_path, char *root_path)
{
  /* Possible choices:
   * d:... -> d:/
   * \\server\share... -> \\server\share\
   */
  int len;
  char *rootp = root_path;

  if (full_path[1] == ':')
    {
      *rootp++ = *full_path;
      *rootp++ = ':';
    }
  else if (full_path[0] == '\\' && full_path[1] == '\\')
    {
      const char *cp = strchr (full_path + 2, '\\');
      if (!cp)
	return NULL;
      while (*++cp && *cp != '\\')
	;
      memcpy (root_path, full_path, (len = cp - full_path));
      rootp = root_path + len;
    }
  else
    return NULL;

  *rootp++ = '\\';
  *rootp = '\0';

  /* This determines whether reparse points are available.  Volume reparse
     points on remote shares are neither recognized by Windows functions
     like GetVolumeInformation, nor by their native NT counterparts. */
  if (!wincap.has_guid_volumes () || GetDriveType (root_path) == DRIVE_REMOTE)
    return root_path;

  PREPARSE_DATA_BUFFER rp = (PREPARSE_DATA_BUFFER)
			    alloca (MAXIMUM_REPARSE_DATA_BUFFER_SIZE);

  char *test_path = (char *) alloca (CYG_MAX_PATH);
  strcpy (test_path, full_path);

  /* This determines the minimum length of the path we test for mount points.
     If we're below this value, it's the root dir of the path itself. */
  char *min_c = test_path + (rootp - root_path);
  char *c = min_c;
  while (*c)
    ++c;
  while (c > min_c)
    {
      *c = '\0';

#     define MOUNTPT_ATTR (FILE_ATTRIBUTE_DIRECTORY \
			   | FILE_ATTRIBUTE_REPARSE_POINT)
      DWORD attr = GetFileAttributes (test_path);
      if (attr != INVALID_FILE_ATTRIBUTES
	  && (attr & MOUNTPT_ATTR) == MOUNTPT_ATTR)
	{
	  HANDLE h = CreateFile (test_path, GENERIC_READ, FILE_SHARE_READ,
				 &sec_none_nih, OPEN_EXISTING,
				 FILE_FLAG_OPEN_REPARSE_POINT
				 | FILE_FLAG_BACKUP_SEMANTICS, NULL);
	  if (h != INVALID_HANDLE_VALUE)
	    {
	      DWORD size;
	      BOOL ret = DeviceIoControl (h, FSCTL_GET_REPARSE_POINT, NULL,
					  0, (LPVOID) rp,
					  MAXIMUM_REPARSE_DATA_BUFFER_SIZE,
					  &size, NULL);
	      CloseHandle (h);
	      if (ret
		  && rp->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT
		  && !rp->SymbolicLinkReparseBuffer.PrintNameLength)
		{
		  memcpy (root_path, test_path, len = c - test_path);
		  strcpy (root_path + len, "\\");
		  CloseHandle (h);
		  break;
		}
	    }
	}
      while (--c > min_c && *c != '\\')
	;
    }

  return root_path;
}

@


1.299
log
@	* fhandler.cc (fhandler_base::open): Remove HIDDEN_DOT_FILES code.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto.
	* path.cc (symlink_worker): Ditto.
@
text
@d48 1
a48 1
  pc.set_normalized_path (x.pc.normalized_path, false);
d157 1
a157 2
  memcpy (&pc, &in_pc, in_pc.size ());
  pc.set_normalized_path (in_pc.normalized_path, false);
d471 1
a471 1
  syscall_printf ("(%s, %p)", get_win32_name (), flags);
d579 3
a581 3
		"(%p, %x, %s, io, NULL, %x, %x, %x, %x, NULL, 0)",
		status, x, access, get_win32_name (), file_attributes, shared,
		create_disposition, create_options);
d583 2
a584 2
  syscall_printf ("%d = fhandler_base::open (%s, %p)", res, get_win32_name (),
		  flags);
@


1.298
log
@	* fhandler.cc (check_posix_perms): Remove.
	(fhandler_base::fpathconf): Return value of pc.has_acls () instead
	of calling check_posix_perms.
@
text
@a544 5
#ifdef HIDDEN_DOT_FILES
      char *c = strrchr (get_win32_name (), '\\');
      if ((c && c[1] == '.') || *get_win32_name () == '.')
	file_attributes |= FILE_ATTRIBUTE_HIDDEN;
#endif
@


1.297
log
@* fhandler.cc (fhandler_base::wait_overlapped): Handle read EOF better and
issue a SIGPIPE when we get ERROR_NO_DATA.
@
text
@a1586 25
/* Helper function for Cygwin specific pathconf flags _PC_POSIX_PERMISSIONS
   and _PC_POSIX_SECURITY. */
static int
check_posix_perm (const char *fname, int v)
{
  if (!allow_ntsec)
    return 0;

  char *root = rootdir (fname, (char *)alloca (strlen (fname) + 2));

  if (!allow_smbntsec
      && ((root[0] == '\\' && root[1] == '\\')
	  || GetDriveType (root) == DRIVE_REMOTE))
    return 0;

  DWORD vsn, len, flags;
  if (!GetVolumeInformation (root, NULL, 0, &vsn, &len, &flags, NULL, 16))
    {
      __seterrno ();
      return 0;
    }

  return (flags & FS_PERSISTENT_ACLS) ? 1 : 0;
}

d1641 1
a1641 1
	return check_posix_perm (get_win32_name (), v);
@


1.296
log
@* cygtls.h (_cygtls::inside_kernel): Move function declaration into _cygtls
class.
* exceptions.cc (_cygtls::inside_kernel): Move function definition into _cygtls
class.
* fhandler.cc (fhandler_base::wait_overlapped): Make return tri-state to detect
when there is a EINTR situation.  Add a pointer to a length parameter.  Move
GetOverlappedResult into this function.
(fhandler_base::read_overlapped): Accommodate above changes and loop if we
receive a restartable signal.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::wait_overlapped): Reflect above changes.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
@
text
@d1702 9
a1710 2
  if (!res && GetLastError () != ERROR_IO_PENDING)
    __seterrno ();
d1733 2
a1734 2
	      __seterrno ();
	      res = -1;
d1743 2
a1744 2
	  __seterrno ();
	  res = -1;
d1748 8
@


1.295
log
@	* fhandler.h (enum query_state): Drop redundant query_stat_control.
	* fhandler.cc (fhandler_base::open): Ditto.  Add READ_CONTROL to
	access and FILE_OPEN_FOR_BACKUP_INTENT to create_options when opening
	for writing.  Always set security attributes to avoid calling
	has_acls.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Don't try to
	open file twice.
@
text
@d1697 2
a1698 2
bool
fhandler_base::wait_overlapped (bool& res, bool writing)
d1700 2
d1717 1
d1721 8
a1728 1
	  res = true;
d1731 1
a1731 1
	  CancelIo (writing ? get_output_handle () : get_handle ());
d1733 5
a1737 1
	  res = false;
d1752 8
a1759 5
  bool res = ReadFile (get_handle (), ptr, len, (DWORD *) &len,
		       get_overlapped ());
  if (!wait_overlapped (res, false)
      || !GetOverlappedResult (get_handle (), get_overlapped (), (DWORD *) &len, false))
    len = 0;
d1767 10
a1776 6
  bool res = WriteFile (get_output_handle (), ptr, len, &bytes_written,
			get_overlapped ());
  if (!wait_overlapped (res, true)
      || !GetOverlappedResult (get_handle (), get_overlapped (),
			       &bytes_written, false))
    return -1;
@


1.294
log
@	* fhandler.cc (fhandler_base::fhaccess): Accommodate interface changes
	of access control functions throughout.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* sec_acl.cc: Drop unnecessary includes.
	(setacl): Take path_conv instead of file name as parameter.
	Accommodate interface changes of access control functions.
	(getacl): Ditto.
	* sec_auth.cc: New file, taking over all authentication related
	functions from security.cc.
	* sec_helper.cc: Drop unnecessary includes.
	* security.cc: Ditto.  Move all authentication related functions to
	sec_auth.cc.
	(ALL_SECURITY_INFORMATION): New define.  Use throughout.
	(set_file_sd): New function, replacing read_sd and the file related
	part of get_nt_object_security.
	(get_reg_sd): Rename from get_reg_security.  Drop type parameter.
	(get_reg_attribute): New function, replacing the registry related part
	of get_nt_object_security.
	(get_file_attribute): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(set_file_attribute): Ditto plus new set_file_sd.  Drop unnecessary
	implementation without uid/gid parameters.
	(check_file_access): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(check_registry_access): Use new get_reg_sd call.
	* security.h: Accommodate above interface changes.
@
text
@a485 4
      case query_stat_control:
	access = READ_CONTROL | FILE_READ_ATTRIBUTES;
	create_options = FILE_OPEN_FOR_BACKUP_INTENT;
	break;
d502 3
a504 2
	    access = GENERIC_WRITE | FILE_READ_ATTRIBUTES;
	    create_options = FILE_OPEN_FOR_RECOVERY;
d560 1
a560 1
      if (allow_ntsec && has_acls ())
@


1.293
log
@	* fhandler.cc (fhandler_base::open): Drop local wpath and upath
	variables.  Call pc.get_object_attr to create object attributes.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
	* path.cc (path_conv::set_normalized_path): Set wide_path to NULL.
	(path_conv::get_nt_native_path): Drop parameter.  Create path in
	wide_path/uni_path members.
	(path_conv::get_object_attr): New method to create object attributes.
	(path_conv::get_wide_win32_path): New method to create Win32 wide path.
	(path_conv::check): Initialize wide_path to NULL.
	(path_conv::~path_conv): cfree wide_path.
	* path.h (class path_conv): New members wide_path and uni_path.
	Add declarations of get_object_attr and get_wide_win32_path.
	(path_conv::path_conv): Initialize wide_path to NULL.
	(path_conv::get_nt_native_path): Drop parameter.
@
text
@d377 1
a377 1
      res = check_file_access (get_win32_name (), flags);
@


1.292
log
@	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.
	* security.cc (check_registry_access): Set errno to EROFS when checking
	for W_OK.
@
text
@a459 4
  WCHAR wpath[CYG_MAX_PATH + 10];
  UNICODE_STRING upath = {0, sizeof (wpath), wpath};
  pc.get_nt_native_path (upath);

d474 1
a474 2
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
			      NULL, sa.lpSecurityDescriptor);
@


1.291
log
@Preliminary change to make fifos/pipes interruptible and fifos reliable.
* dtable.cc (dtable::find_fifo): Eliminate definition.
* dtable.h (dtable::find_fifo): Ditto for declaration.
* fhandler.cc (fhandler_base::raw_read): Remove pipe-specific stuff.
(fhandler_base::fhandler_base): Ditto.
(fhandler_base::close): Handle overlapped I/O structure if appropriate.
(fhandler_base::dup): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::setup_overlapped): Define new function.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::get_overlapped): Declare new function.
(fhandler_base::setup_overlapped): Ditto.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
(fhandler_base::get_guard): Eliminate.
(fhandler_pipe::*): Rework to eliminate most Win9x related cruft, removing many
variables and defining a new overlapped capability.
(fhandler_fifo::*): Ditto.
(fifo_state): Declare new enum.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove old Win9x stuff.
Initialize overlapped handle to NULL.
(fhandler_fifo::set_use): Eliminate.
(fhandler_fifo::open_nonserver): Define.
(fhandler_fifo::open): Rework to use named pipes and overlapped I/O.
(fhandler_fifo::wait): Define new function to wait for named pipe connection.
(fhandler_fifo::read): Rework to use wait() and new overlapped I/O
functionality.
(fhandler_fifo::write): Ditto.
(fhandler_fifo::dup): Eliminate.
* pinfo.cc (commune_process): Remove fifo handling.
(_pinfo::commune_request): Ditto.
* pinfo.h (picom): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Remove Win9x stuff.  Initialize
overlapped handle to NULL.
(fhandler_pipe::open): Eliminate Win9x stuff.
(fhandler_pipe::set_close_on_exec): Eliminate.
(read_pipe): Eliminate.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::fixup_after_exec): Ditto.
(fhandler_pipe::fixup_in_child): Ditto.
(fhandler_pipe::read): Rework to use overlapped I/O.
(fhandler_pipe::write): New function using overlapped I/O.
(fhandler_pipe::dup): Rework to eliminate Win9x stuff.
(fhandler_pipe::create_selectable): Rework to eliminate Win9x and use
overlapped I/O.
* select.cc (peek_pipe): Rework to eliminate Win9x stuff and use overlapped
I/O.
(fhandler_base::ready_for_read): Ditto.
@
text
@d446 6
@


1.290
log
@	* cygwin.din: Export fdopendir.
	* dir.cc (opendir): Call fhandler's opendir with fd set to -1.
	(fdopendir): New function.
	(seekdir64): Use dirent_info_mask.
	(rewinddir): Ditto.
	(closedir): Only release underlying file descriptor if it has been
	reserved by opendir itself.
	* fhandler.cc (fhandler_base::opendir): Accommodate new parameter.
	* fhandler.h (dirent_states): Add dirent_valid_fd and dirent_info_mask.
	(fhander_XXX::opendir): Add file descriptor parameter.  Use regparms.
	(fhandler_procnet::opendir): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
	If called from fdopendir, use existing handle to re-open directory
	with valid flags.  Rename fd to cfd.  Use only if no valid incoming fd.
	(fhandler_cygdrive::opendir): Accommodate new parameter.
	* fhandler_process.cc (fhandler_process::opendir): Ditto.
	* fhandler_procnet.cc (fhandler_procnet::opendir): Drop definition.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Accommodate new
	parameter.  Only create new file descriptor entry if called from
	opendir.  Remove duplicated setting of dir->__flags.
	* posix.sgml: Add fdopendir to list of implemented Solaris functions.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/dirent.h: Declare fdopendir.
@
text
@d35 2
a226 2
  HANDLE h = NULL;	/* grumble */
  int prio = 0;		/* ditto */
d232 1
a232 13
  if (read_state)
    {
      h = GetCurrentThread ();
      prio = GetThreadPriority (h);
      SetThreadPriority (h, THREAD_PRIORITY_TIME_CRITICAL);
      signal_read_state (1);
    }
  BOOL res = ReadFile (get_handle (), ptr, len, (DWORD *) &ulen, 0);
  if (read_state)
    {
      signal_read_state (1);
      SetThreadPriority (h, prio);
    }
d704 1
a704 1
        {
d987 1
d1193 2
a1325 1
  read_state (NULL),
d1374 2
d1394 2
d1402 2
d1677 83
@


1.289
log
@	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.
@
text
@d1447 1
a1447 1
fhandler_base::opendir ()
@


1.288
log
@	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.
@
text
@d1130 1
a1130 1
      buf->st_mode = S_IFIFO | STD_RBITS | STD_WBITS | S_IWGRP | S_IWOTH;
d1133 1
a1133 1
      buf->st_mode = S_IFIFO | STD_WBITS | S_IWGRP | S_IWOTH;
d1136 1
a1136 1
      buf->st_mode = S_IFIFO | STD_RBITS;
@


1.287
log
@	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Set new stat member
	st_birthtim to useful value.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Take
	additional parameter for creation time.  Fill st_birthtim with it.
	Accomodate additional creation time parameter throughout.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Set new stat member
	st_birthtim to useful value.
	* fhandler.cc (fhandler_base::fstat): Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Ditto.
	* include/cygwin/version.h: Bump API minor number.
	* include/cygwin/stat.h (struct __stat64): Replace st_spare4 with
	timestruc_t st_birthtim.
	(struct stat): Ditto if __CYGWIN_USE_BIG_TYPES__ is defined.
	(st_birthtime): Define if __CYGWIN_USE_BIG_TYPES__ is defined.
@
text
@a552 3
  if (flags & O_APPEND)
    append_mode (true);

d711 11
a721 2
  if (append_mode ())
    SetFilePointer (get_output_handle (), 0, 0, FILE_END);
@


1.286
log
@* Makefile (DLL_OFILES): Remove ntea.o
* environ.cc (set_ntea): Delete.
(parse_thing): Delete "ntea" setting.
* fhandler.cc (fhandler_base::open): Remove allow_ntea considerations.
(check_posix_perm): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Ditto.
(fhandler_base::open_fs): Ditto.
(fhandler_disk_file::mkdir): Ditto.
* path.cc (symlink_worker): Ditto.
* security.cc (get_file_attribute): Ditto.
(set_file_attribute): Ditto.
* security.h: Remove allow_ntea declaration.
@
text
@d1146 1
a1146 1
  buf->st_atim = buf->st_mtim = buf->st_ctim;
@


1.285
log
@	* fhandler.cc(fhandler_base::open): Open with READ_CONTROL only in
	case of query_open flag set to query_read_control.  Add case for
	new query_read_attributes flag.
	(fhandler_base::fstatvfs): New method.
	* fhandler.h (enum query_state): Add query_read_attributes flag.
	(class fhandler_base): Declare new virtual fstatvfs method.
	(class fhandler_socket): Ditto.
	(class fhandler_pipe): Ditto.
	(class fhandler_fifo): Ditto.
	(class fhandler_disk_file): Ditto.
	(class fhandler_virtual): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Open with
	query_read_attributes instead of query_read_control.
	(fhandler_disk_file::fstatvfs): New method.
	(fhandler_disk_file::facl): Open with query_read_attributes instead of
	query_read_control.
	* fhandler_fifo.cc (fhandler_fifo::fstatvfs): New method.
	* fhandler_socket.cc (fhandler_socket::fstatvfs): New method.
	(fhandler_socket::fchmod): Return with EBADF in the default case.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::fstatvfs): Ditto.
	* ntdll.h (struct _FILE_FS_ATTRIBUTE_INFORMATION): Define.
	(struct _FILE_FS_FULL_SIZE_INFORMATION): Define.
	* pipe.cc (fhandler_pipe::fstatvfs): New method.
	* syscalls.cc (fstatvfs): Just call the fhandler's fstatvfs.
	(statvfs): Ditto.
	(fstatfs): Call fstatvfs.
	(statfs): Drop EFAULT handling.
@
text
@d498 1
a498 2
	access = READ_CONTROL | FILE_READ_ATTRIBUTES
		 | (allow_ntea ? FILE_READ_EA : 0);
d502 1
a502 2
	access = READ_CONTROL | WRITE_OWNER | WRITE_DAC | FILE_WRITE_ATTRIBUTES
		 | (allow_ntea ? FILE_WRITE_EA : 0);
a1591 5
  /* ntea is ok for supporting permission bits but it doesn't support
     full POSIX security settings. */
  if (v == _PC_POSIX_PERMISSIONS && allow_ntea)
    return 1;

@


1.284
log
@	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.
@
text
@d18 1
d490 4
d1152 10
@


1.283
log
@	Throughout remove all usage of wincap.has_security.
	* environ.cc (environ_init): Drop setting allow_ntsec here.
	* grp.cc (initgroups32): Drop usage of label "out".
	* security.cc (allow_ntsec): Set to true by default.
	* syscalls.cc (seteuid32): Remove label success_9x.
	* wincap.cc: Remove has_security throughout.
	* wincap.h: Ditto.
@
text
@d1141 2
a1142 1
  time_as_timestruc_t (&buf->st_ctim);
@


1.282
log
@	* devices.in: Change native device name to native NT device name for
	/dev/null, /dev/comX and /dev/ttySx.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::open_9x): Remove.
	(fhandler_base::open): Don't test for DOS device name, don't call
	open_9x.
	(fhandler_dev_null::open): Remove.
	* fhandler.h (class fhandler_base): Drop open_9x declaration.
	(class fhandler_dev_null): Drop open declaration.
@
text
@a1577 4
  /* Windows 95/98/ME don't support file system security at all. */
  if (!wincap.has_security ())
    return 0;

@


1.281
log
@	* fhandler.cc (fhandler_base::lseek): Drop 9x considerations.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Ditto.
	* wincap.cc: Remove lock_file_highword and has_64bit_file_access
	throughout.
	* wincap.h: Ditto.
@
text
@a462 113
fhandler_base::open_9x (int flags, mode_t mode)
{
  int res = 0;
  HANDLE x;
  int file_attributes;
  int creation_distribution;
  SECURITY_ATTRIBUTES sa = sec_none;

  syscall_printf ("(%s, %p)", get_win32_name (), flags);

  switch (query_open ())
    {
      case query_read_control:
      case query_stat_control:
	access = GENERIC_READ;
	break;
      case query_write_control:
      case query_write_attributes:
	access = GENERIC_READ | FILE_WRITE_ATTRIBUTES;
	break;
      default:
	if ((flags & O_ACCMODE) == O_RDONLY)
	  access = GENERIC_READ;
	else if ((flags & O_ACCMODE) == O_WRONLY)
	  access = GENERIC_WRITE;
	else
	  access = GENERIC_READ | GENERIC_WRITE;
	break;
    }

  if ((flags & O_TRUNC) && ((flags & O_ACCMODE) != O_RDONLY))
    {
      if (flags & O_CREAT)
	creation_distribution = CREATE_ALWAYS;
      else
	creation_distribution = TRUNCATE_EXISTING;
    }
  else if (flags & O_CREAT)
    creation_distribution = OPEN_ALWAYS;
  else
    creation_distribution = OPEN_EXISTING;

  if ((flags & O_EXCL) && (flags & O_CREAT))
    creation_distribution = CREATE_NEW;

  if (flags & O_APPEND)
    append_mode (true);

  file_attributes = FILE_ATTRIBUTE_NORMAL;
  if (flags & O_DIROPEN)
    file_attributes |= FILE_FLAG_BACKUP_SEMANTICS;
  if (flags & O_SYNC)
    file_attributes |= FILE_FLAG_WRITE_THROUGH;
  if (flags & O_DIRECT)
    file_attributes |= FILE_FLAG_NO_BUFFERING;
  if (get_major () == DEV_SERIAL_MAJOR)
    file_attributes |= FILE_FLAG_OVERLAPPED;

#ifdef HIDDEN_DOT_FILES
  if (flags & O_CREAT && get_device () == FH_FS)
    {
      char *c = strrchr (get_win32_name (), '\\');
      if ((c && c[1] == '.') || *get_win32_name () == '.')
	file_attributes |= FILE_ATTRIBUTE_HIDDEN;
    }
#endif

  if (flags & O_CREAT && get_device () == FH_FS)
    {
      /* If mode has no write bits set, we set the R/O attribute. */
      if (!(mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
	file_attributes |= FILE_ATTRIBUTE_READONLY;
      /* The file attributes are needed for later use in, e.g. fchmod. */
      pc.file_attributes (file_attributes & FILE_ATTRIBUTE_VALID_SET_FLAGS);
    }

  x = CreateFile (get_win32_name (), access, FILE_SHARE_VALID_FLAGS, &sa, creation_distribution,
		  file_attributes, 0);

  if (x == INVALID_HANDLE_VALUE)
    {
      if (pc.isdir ())
	{
	  if ((flags & O_ACCMODE) != O_RDONLY)
	    set_errno (EISDIR);
	  else
	    nohandle (true);
	}
      else if (GetLastError () == ERROR_INVALID_HANDLE)
	set_errno (ENOENT);
      else
	__seterrno ();
      if (!nohandle ())
	goto done;
   }

  set_io_handle (x);
  set_flags (flags, pc.binmode ());

  res = 1;
  set_open_status ();
done:
  debug_printf ("%p = CreateFile (%s, %p, %p, %p, %p, %p, 0)",
		x, get_win32_name (), access, FILE_SHARE_VALID_FLAGS, &sa,
		creation_distribution, file_attributes);

  syscall_printf ("%d = fhandler_base::open (%s, %p)", res, get_win32_name (),
		  flags);
  return res;
}

/* Open system call handler function. */
int
a468 3
  if (RtlIsDosDeviceName_U (upath.Buffer))
    return fhandler_base::open_9x (flags, mode);

a1335 9
int
fhandler_dev_null::open (int flags, mode_t mode)
{
  char posix[strlen (get_name ()) + 1];
  strcpy (posix, get_name ());
  pc.set_name ("NUL", posix);
  return fhandler_base::open_9x (flags, mode);
}

@


1.280
log
@	* fhandler.cc (fhandler_base::set_no_inheritance): Always use
	SetHandleInformation.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Always use
	UnlockFileEx/LockFileEx functions.
	* net.cc (fdsock): Don't bother to duplicate socket for inheritance.
	* sysconf.cc (get_nproc_values): Take NT for granted.
	(get_avphys): Ditto.
	* syslog.cc (WIN95_EVENT_LOG_PATH): Remove define.
	(get_win95_event_log_path): Remove.
	(vsyslog): Fix formatting.  Take NT for granted.
	* wincap.cc: Remove has_lock_file_ex, has_signal_object_and_wait,
	has_eventlog, has_set_handle_information,
	has_set_handle_information_on_console_handles and supports_smp
	throughout.
	* wincap.h: Ditto.
@
text
@a1033 12
  /* 9x/Me doesn't support 64bit offsets.  We trap that here and return
     EINVAL.  It doesn't make sense to simulate bigger offsets by a
     SetFilePointer sequence since FAT and FAT32 don't support file
     size >= 4GB anyway. */
  if (!wincap.has_64bit_file_access ()
      && (offset < LONG_MIN || offset > LONG_MAX))
    {
      debug_printf ("Win9x, offset not 32 bit.");
      set_errno (EINVAL);
      return (_off64_t)-1;
    }

d1050 1
a1050 8
  LONG *poff_high, off_high;
  if (!wincap.has_64bit_file_access ())
    poff_high = NULL;
  else
    {
      off_high =  ((__uint64_t) offset) >> 32LL;
      poff_high = &off_high;
    }
d1053 1
a1053 1
  res = SetFilePointer (get_handle (), off_low, poff_high, win32_whence);
d1061 1
a1061 2
      if (poff_high)
	res += (_off64_t) *poff_high << 32;
d1064 1
a1064 1
	 the end of the file, and back-seek and fill with zeros if so - DJ */
@


1.279
log
@	* fhandler.cc (fhandler_base::write): Remove wincap.has_lseek_bug case.
	Simplify seek beyond EOF case.
	* times.cc (times): Remove wincap.has_get_process_times case.
	* wincap.cc: Remove has_delete_on_close, has_page_guard,
	has_get_process_times and has_lseek_bug throughout.
	* wincap.h: Ditto.
@
text
@d1484 3
a1486 15
  if (wincap.has_set_handle_information ())
    {
      if (!SetHandleInformation (h, HANDLE_FLAG_INHERIT, not_inheriting ? 0 : HANDLE_FLAG_INHERIT))
	debug_printf ("SetHandleInformation failed, %E");
    }
  else
    {
      HANDLE oh = h;
      if (!DuplicateHandle (hMainProc, oh, hMainProc, &h, 0, !not_inheriting,
			    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
	debug_printf ("DuplicateHandle failed, %E");

	if (oh != h)
	  VerifyHandle (h);
    }
@


1.278
log
@	Throughout replace all usage of wincap.shared with the constant
	FILE_SHARE_VALID_FLAGS.
	* fhandler.cc (fhandler_base::open_9x): Drop local variable shared.
	* wincap.cc: Remove shared member throughout.
	* wincap.h: Ditto.
@
text
@d844 2
a845 1
      if (current_position > actual_length)
d847 9
a855 58
	  if ((get_fs_flags (FILE_SUPPORTS_SPARSE_FILES))
	      && current_position >= actual_length + (128 * 1024))
	    {
	      /* If the file systemn supports sparse files and the application
		 is writing after a long seek beyond EOF, convert the file to
		 a sparse file. */
	      DWORD dw;
	      HANDLE h = get_output_handle ();
	      BOOL r = DeviceIoControl (h, FSCTL_SET_SPARSE, NULL, 0, NULL,
					0, &dw, NULL);
	      syscall_printf ("%d = DeviceIoControl(%p, FSCTL_SET_SPARSE)",
			      r, h);
	    }
	  else if (wincap.has_lseek_bug ())
	    {
	      /* Oops, this is the bug case - Win95 uses whatever is on the
		 disk instead of some known (safe) value, so we must seek
		 back and fill in the gap with zeros. - DJ
		 Note: this bug doesn't happen on NT4, even though the
		 documentation for WriteFile() says that it *may* happen
		 on any OS. */
	      /* Check there is enough space */
	      if (!SetEndOfFile (get_output_handle ()))
		{
		  __seterrno ();
		  return -1;
		}
	      char zeros[512];
	      int number_of_zeros_to_write = current_position - actual_length;
	      memset (zeros, 0, 512);
	      SetFilePointer (get_output_handle (), actual_length, NULL,
			      FILE_BEGIN);
	      while (number_of_zeros_to_write > 0)
		{
		  DWORD zeros_this_time = (number_of_zeros_to_write > 512
					 ? 512 : number_of_zeros_to_write);
		  DWORD written;
		  DWORD ret = WriteFile (get_output_handle (), zeros,
					 zeros_this_time, &written, NULL);
		  if (!ret || written < zeros_this_time)
		    {
		      if (!ret)
			{
			  __seterrno ();
			  if (get_errno () == EPIPE)
			    raise (SIGPIPE);
			}
		      else
			set_errno (ENOSPC);
		      /* This might fail, but it's the best we can hope for */
		      SetFilePointer (get_output_handle (), current_position,
				      NULL, FILE_BEGIN);
		      return -1;

		    }
		  number_of_zeros_to_write -= written;
		}
	    }
@


1.277
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@a467 1
  int shared;
a510 3
  /* These flags are host dependent. */
  shared = wincap.shared ();

d539 1
a539 1
  x = CreateFile (get_win32_name (), access, shared, &sa, creation_distribution,
d566 1
a566 1
		x, get_win32_name (), access, shared, &sa,
d588 1
a588 1
  ULONG shared = (get_major () == DEV_TAPE_MAJOR ? 0 : wincap.shared ());
@


1.276
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@a581 3
  if (!wincap.is_winnt ())
    return fhandler_base::open_9x (flags, mode);

@


1.275
log
@	* cygmalloc.h (MALLOC_FAILURE_ACTION): Define empty.
	* cygwin.din (posix_madvise): Export.
	(posix_memalign): Export.
	* fhandler.cc (fhandler_base::fpathconf): Return useful values in
	_PC_VDISABLE, _PC_SYNC_IO and _PC_SYMLINK_MAX cases.
	* malloc_wrapper.cc (malloc): Set errno here since it's not set in
	dlmalloc.c anymore.
	(realloc): Ditto.
	(calloc): Ditto.
	(memalign): Ditto.
	(valloc): Ditto.
	(posix_memalign): New function.
	* mmap.cc (posix_madvise): New function.
	* sysconf.cc (get_open_max): New function.
	(get_page_size): Ditto.
	(get_nproc_values): Ditto.
	(get_avphys): Ditto.
	(sc_type): New type.
	(sca): New array to map _SC_xxx options to sysconf return values.
	(sysconf): Reimplement using sca array.
	* include/limits.h: Add all missing values as defined by SUSv3.
	* include/pthread.h (PTHREAD_DESTRUCTOR_ITERATIONS): Move definition
	to sys/limits.h.
	(PTHREAD_KEYS_MAX): Ditto.
	* include/semaphore.h (SEM_VALUE_MAX): Ditto.
	* include/cygwin/stdlib.h (posix_memalign): Declare.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/mman.h: Add posix_madvise flags.
	(posix_madvise): Declare.
	* include/sys/termios.h (_POSIX_VDISABLE): Move definition to
	sys/limits.h.
@
text
@d693 1
a693 1
        file_attributes |= pc.file_attributes ();
d1295 1
a1295 1
        ;
d1829 1
a1829 1
        return MAX_CANON;
d1834 1
a1834 1
        return MAX_INPUT;
d1847 1
a1847 1
        return PIPE_BUF;
d1856 1
a1856 1
        return _POSIX_VDISABLE;
d1873 1
a1873 1
        return check_posix_perm (get_win32_name (), v);
@


1.274
log
@	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.
@
text
@d1855 3
a1857 2
      if (!is_tty ())
        set_errno (EINVAL);
d1861 1
d1863 1
a1863 1
      break;
d1869 1
a1869 1
      break;
@


1.273
log
@* child_info.h (child_info_spawn::__stdin): New element.
(child_info_spawn::__stdin): Ditto.
(CURR_CHILD_INFO_MAGIC): Regenerate.
* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
(child_info_spawn::handle_spawn): Handle new __std* elements by calling
move_fd.
* dtable.cc (dtable::move_fd): Define new function.
* dtable.h (dtable::move_fd): Declare new function.
* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
(fhandler_pipe::dup): Ditto.
* spawn.cc (handle): Change second argument to bool.
(spawn_guts): Accept __stdin/__stdout arguments and set them appropriately in
child_info structure and in STARTUPINFO structure.
* syscalls.cc (popen): New cygwin-specific implementation using spawn.
(pclose): Ditto.
* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.
* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.
* child_info.h (child_info::msv_count): Rename from the now-inappropriate
"zero".
(child_info_spawn::filler): Add filler to work around Vista bug.
(child_info_fork::filler): Ditto.
* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is now
always filled out.
* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
* sigproc.cc (child_info::child_info): Initialize starter[].
* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
d1331 1
a1331 1
  buf->st_blksize = S_BLKSIZE;
@


1.272
log
@	* fhandler.cc (rootdir): Fix typo in comment.
	* syscalls.cc (try_to_bin): Ditto.
@
text
@d1537 1
a1537 1
fhandler_base::set_no_inheritance (HANDLE &h, int not_inheriting)
d1539 15
a1553 11
  HANDLE oh = h;
  /* Note that we could use SetHandleInformation here but it is not available
     on all platforms.  Test cases seem to indicate that using DuplicateHandle
     in this fashion does not actually close the original handle, which is
     what we want.  If this changes in the future, we may be forced to use
     SetHandleInformation on newer OS's */
  if (!DuplicateHandle (hMainProc, oh, hMainProc, &h, 0, !not_inheriting,
			     DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
    debug_printf ("DuplicateHandle failed, %E");
  if (oh != h)
    VerifyHandle (h);
@


1.271
log
@	* fhandler.cc (rootdir): Clarify comment.
@
text
@d1244 2
a1245 2
     points on remote shares are not recognized by Windows functions like
     GetVoluemInformation, nor by their native NT counterparts. */
@


1.270
log
@	* fhandler.cc (rootdir): Don't look for volume mount points on remote
	shares.
@
text
@d1243 3
a1245 2
  /* This determines whether reparse points are available.  Reparse points
     on remote shares are not recognized by Windows. */
@


1.269
log
@	* fhandler.cc (rootdir): Drop useless post-increment.  Take volume
	mount points into account.
	(check_posix_perm): Allocate space for root directory big enough.
@
text
@d1243 3
a1245 2
  /* This also determines whether reparse points are available. */
  if (!wincap.has_guid_volumes ())
@


1.268
log
@	* fhandler.cc (fhandler_base::open): Fix previous patch to handle the
	SYSTEM attribute as well.
@
text
@d1224 1
a1224 1
      *rootp++ = *full_path++;
d1242 54
d1796 1
a1796 1
  char *root = rootdir (fname, (char *)alloca (strlen (fname)));
@


1.267
log
@	* fhandler.cc (fhandler_base::open): Fix handling of files with
	HIDDEN attribute set.
@
text
@d688 5
a692 4
	 existing file with FILE_ATTRIBUTE_HIDDEN attribute set, CreateFile
	 fails with "Permission denied".  Per MSDN you have to create the
	 file with the same attributes as already specified for the file. */
      if (exists () && has_attribute (FILE_ATTRIBUTE_HIDDEN))
@


1.266
log
@	* fhandler.cc (check_posix_perm): Moved here from syscalls.cc.
	(fhandler_base::fpathconf): New method implementing (f)pathconf.
	* fhandler.h (class fhandler_base): Declare fpathconf method.
	* path.cc (path_conv::check): Replace MAX_LINK_DEPTH with SYMLOOP_MAX.
	* path.h (MAX_LINK_DEPTH): Delete.
	* syscalls.cc (check_posix_perm): Move to fhandler.cc.
	(fpathconf): Call fhandler's fpathconf method.
	(pathconf): Build fhandler and call fhandler's fpathconf method.
	* sysconf.cc (sysconf): Reorder switch according to order of flags
	in sys/unistd.h.  Add handling for some missing flags.
	* include/limits.h: Reorder according to SUSv3 description.  Add some
	missing definitions.  Add comments.
	* include/sys/syslimits.h: New file overriding newlib's syslimits.h
	file.
@
text
@d687 7
@


1.265
log
@	* fhandler_disk_file.cc (fhandler_disk_file::facl): Fix whitespace.
	* external.cc: Update copyright.
	* fhandler.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.h: Ditto.
	* security.cc: Ditto.
	(check_registry_access): Return -1 if W_OK is requested.
@
text
@d1716 96
@


1.264
log
@	* fhandler.cc (fhandler_base::fhaccess): Check if opening registry
	actually created a handle.  This handles the registry root dir.
	* fhandler_registry.cc (fhandler_registry::open): Set io_handle in
	case of opening one of the predefined registry keys.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
@


1.263
log
@	* fhandler.cc (fhandler_base::fhaccess): Call check_registry_access
	for registry keys/values if ntsec is on.
	* security.cc (check_access): New static function derived from
	check_file_access, but object type agnostic.
	(check_file_access): Only do file specific stuff.  Call check_access.
	(check_registry_access): New access check function for registry keys/
	values.
	* security.h (check_registry_access): Declare.
@
text
@d391 2
a392 1
  else if (get_device () == FH_REGISTRY && allow_ntsec && open (O_RDONLY, 0))
@


1.262
log
@	* autoload.cc (PrivilegeCheck): Define.
	* fhandler.cc (fhandler_base::open): Always try opening with backup
	resp. restore intent.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Always try
	opening with backup intent.
	(fhandler_disk_file::readdir): Ditto when trying to retrieve file id
	explicitely.
	* security.cc (check_file_access): Replace pbuf with correctly
	PPRIVILEGE_SET typed pset.  Check explicitely for backup and/or restore
	privileges when AccessCheck fails, to circumvent AccessCheck
	shortcoming.  Add comment to explain.
@
text
@d391 6
@


1.261
log
@revert erroneous checkin
@
text
@a622 1
	create_options = 0;
d624 4
a627 1
	  access = GENERIC_READ;
d629 4
a632 1
	  access = GENERIC_WRITE | FILE_READ_ATTRIBUTES;
d634 5
a638 1
	  access = GENERIC_READ | GENERIC_WRITE;
@


1.260
log
@* winsup.h: Turn on DEBUGGING by default for now.
@
text
@a33 1
#include "mmap_helper.h"
d226 1
d229 1
d238 1
a238 1
  BOOL res = mmReadFile (get_handle (), ptr, len, (DWORD *) &ulen, 0);
d264 13
@


1.259
log
@	* autoload.cc (NtSetInformationFile): Define.
	* cygwin.din: Export posix_fadvise and posix_fallocate.
	* fhandler.cc (fhandler_base::fadvise): New method.
	(fhandler_base::ftruncate): Add allow_truncate parameter.
	* fhandler.h (class fhandler_base): Add fadvise method.  Accomodate
	new parameter to ftruncate.
	(class fhandler_pipe): Add fadvise and ftruncate methods.
	(class fhandler_disk_file): Add fadvise method.  Accomodate new
	parameter to ftruncate.
	* fhandler_disk_file.cc (fhandler_disk_file::fadvise): New method.
	(fhandler_disk_file::ftruncate): Accomodate new allow_truncate
	parameter.  Set EOF using NtSetInformationFile on NT.
	* ntdll.h (struct _FILE_END_OF_FILE_INFORMATION): Define.
	(NtSetInformationFile): Declare.
	* pipe.cc (fhandler_pipe::fadvise): New method.
	(fhandler_pipe::ftruncate): Ditto.
	* syscalls.cc (posix_fadvise): New function.
	(posix_fallocate): Ditto.
	(ftruncate64): Accomodate second parameter to fhandler's ftruncate
	method.
	* include/fcntl.h: Add POSIX_FADV_* flags.  Add declarations of
	posix_fadvise and posix_fallocate.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d34 1
a226 1
  int try_noreserve = 1;
a228 1
retry:
d237 1
a237 1
  BOOL res = ReadFile (get_handle (), ptr, len, (DWORD *) &ulen, 0);
a262 13
	  if (try_noreserve)
	    {
	      try_noreserve = 0;
	      switch (mmap_is_attached_or_noreserve (ptr, len))
		{
		case MMAP_NORESERVE_COMMITED:
		  goto retry;
		case MMAP_RAISE_SIGBUS:
		  raise(SIGBUS);
		case MMAP_NONE:
		  break;
		}
	    }
@


1.258
log
@* fhandler.cc (fhandler_base::read): Call get_readahead_into_buffer instead of
duplicating it.
@
text
@d1655 8
a1662 1
fhandler_base::ftruncate (_off64_t length)
@


1.257
log
@2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h: Bump DLL version to 1.7.0.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.

2006-07-18  Brian Ford  <Brian.Ford@@FlightSafety.com>
	    Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.

2006-07-18  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din (posix_openpt): Export.
	* tty.cc (posix_openpt): New function.
	* include/cygwin/stdlib.h (posix_openpt): Declare.
	* include/cygwin/version.h: Bump API minor number.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netinet/in.h: Update copyright.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netdb.h: Declare rcmd, rcmd_af, rexec, rresvport,
	rresvport_af, iruserok, iruserok_sa, ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.

2006-07-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.

2006-07-10  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.

2006-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/in6.h (struct in6_addr): Fix typo.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@d719 1
a719 11
  ssize_t copied_chars = 0;
  int c;

  while (len)
    if ((c = get_readahead ()) < 0)
      break;
    else
      {
	ptr[copied_chars++] = (unsigned char) (c & 0xff);
	len--;
      }
d727 1
@


1.256
log
@* fhandler.cc (fhandler_base::raw_read): Only return EISDIR when we're really
trying to read a directory.
* sigproc.cc: Use "Static" where appropriate.
@
text
@d226 1
d229 1
d264 14
@


1.256.2.1
log
@	* include/asm/byteorder.h: Fix copyright dates.

	* autoload.cc (PrivilegeCheck): Define.
	* fhandler.cc (fhandler_base::open): Always try opening with backup
	resp. restore intent.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Always try
	opening with backup intent.
	(fhandler_disk_file::readdir): Ditto when trying to retrieve file id
	explicitely.
	* security.cc (check_file_access): Replace pbuf with correctly
	PPRIVILEGE_SET typed pset.  Check explicitely for backup and/or restore
	privileges when AccessCheck fails, to circumvent AccessCheck
	shortcoming.  Add comment to explain.

	* include/asm/byteorder.h: Correct typo.

	* include/asm/byteorder.h: Don't #define n* macros if -fnoinline is
	specified.

	* environ.cc (build_env): Don't put an empty environment variable into
	the environment.  Optimize use of "len".
	* errno.cc (ERROR_MORE_DATA): Translate to EMSGSIZE rather than EAGAIN.
@
text
@d607 1
d609 1
a609 4
	  {
	    access = GENERIC_READ;
	    create_options = FILE_OPEN_FOR_BACKUP_INTENT;
	  }
d611 1
a611 4
	  {
	    access = GENERIC_WRITE | FILE_READ_ATTRIBUTES;
	    create_options = FILE_OPEN_FOR_RECOVERY;
	  }
d613 1
a613 5
	  {
	    access = GENERIC_READ | GENERIC_WRITE;
	    create_options = FILE_OPEN_FOR_BACKUP_INTENT
			     | FILE_OPEN_FOR_RECOVERY;
	  }
@


1.256.2.2
log
@2006-11-28  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (create_token): Revert erroneous change to test
	subauth_token for INVAILD_HANDLE_VALUE.
	* syscalls.cc (seteuid32): Set create_token's subauth_token parameter
	back to NULL.

2006-11-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::open): Fix previous patch to handle the
	SYSTEM attribute as well.

2006-11-27  Christopher Faylor  <cgf@@timesys.com>

	* include/cygwin/signal.h: Add __extension__ to various anonymous
	unions and structs.  (thanks to V.Haisman)
@
text
@a663 8
      /* Starting with Windows 2000, when trying to overwrite an already
	 existing file with FILE_ATTRIBUTE_HIDDEN and/or FILE_ATTRIBUTE_SYSTEM
	 attribute set, CreateFile fails with ERROR_ACCESS_DENIED.
	 Per MSDN you have to create the file with the same attributes as
	 already specified for the file. */
      if (has_attribute (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM))
	file_attributes |= pc.file_attributes ();

@


1.256.2.3
log
@2007-01-13  Christopher Faylor  <me@@cgf.cx>

	* glob.cc: Update copyright notice with latest from FreeBSD.
	(glob0): Use correct type for c variable to propagate previously
	detected protection.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.

2006-12-12  Christopher Faylor  <me@@cgf.cx>

	* syscalls.cc (popen): Allow '[rw][bt]'.

2006-12-11  Christopher Faylor  <me@@cgf.cx>

	* sigproc.cc (child_info::child_info): Move old comment about msv_count
	here.  Edit it slightly to reflect new sensibilities.

2006-12-11  Christopher Faylor  <me+cygwin@@cgf.cx>

	* child_info.h (child_info_spawn::__stdin): New element.
	(child_info_spawn::__stdin): Ditto.
	(CURR_CHILD_INFO_MAGIC): Regenerate.
	* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
	(child_info_spawn::handle_spawn): Handle new __std* elements by calling
	move_fd.
	* dtable.cc (dtable::move_fd): Define new function.
	* dtable.h (dtable::move_fd): Declare new function.
	* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
	* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
	* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
	(fhandler_pipe::dup): Ditto.
	* spawn.cc (handle): Change second argument to bool.
	(spawn_guts): Accept __stdin/__stdout arguments and set them
	appropriately in child_info structure and in STARTUPINFO structure.
	* syscalls.cc (popen): New cygwin-specific implementation using spawn.
	(pclose): Ditto.
	* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.

	* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
	* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.

	* child_info.h (child_info::msv_count): Rename from the now-inappropriate
	"zero".
	(child_info_spawn::filler): Add filler to work around Vista bug.
	(child_info_fork::filler): Ditto.
	* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is
	now always filled out.
	* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
	* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
	* sigproc.cc (child_info::child_info): Initialize starter[].

	* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
	* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d1467 1
a1467 1
fhandler_base::set_no_inheritance (HANDLE &h, bool not_inheriting)
d1469 11
a1479 15
  if (wincap.has_set_handle_information ())
    {
      if (!SetHandleInformation (h, HANDLE_FLAG_INHERIT, not_inheriting ? 0 : HANDLE_FLAG_INHERIT))
	debug_printf ("SetHandleInformation failed, %E");
    }
  else
    {
      HANDLE oh = h;
      if (!DuplicateHandle (hMainProc, oh, hMainProc, &h, 0, !not_inheriting,
			    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
	debug_printf ("DuplicateHandle failed, %E");

	if (oh != h)
	  VerifyHandle (h);
    }
@


1.256.2.4
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
d368 1
a368 2
  else if (has_attribute (FILE_ATTRIBUTE_READONLY) && (flags & W_OK)
	   && !pc.isdir ())
a433 9
#ifndef FILE_READ_ONLY_VOLUME
#define FILE_READ_ONLY_VOLUME 0x80000
#endif
  if (!res && (flags & W_OK) && get_device () == FH_FS
      && (pc.fs_flags () & FILE_READ_ONLY_VOLUME))
    {
      set_errno (EROFS);
      res = -1;
    }
d486 3
d650 3
d820 2
a821 11
  if (get_flags () & O_APPEND)
    {
      LONG off_high = 0;
      DWORD ret = SetFilePointer (get_output_handle (), 0, &off_high, FILE_END);
      if (ret == INVALID_SET_FILE_POINTER && GetLastError () != NO_ERROR)
        {
	  debug_printf ("Seeking to EOF in append mode failed");
	  __seterrno ();
	  return -1;
	}
    }
d1242 1
a1242 1
      buf->st_mode = S_IFIFO | S_IRUSR | S_IWUSR;
d1245 1
a1245 1
      buf->st_mode = S_IFIFO | S_IWUSR;
d1248 1
a1248 1
      buf->st_mode = S_IFIFO | S_IRUSR;
d1261 2
a1262 3
  buf->st_blksize = PREFERRED_IO_BLKSIZE;
  buf->st_ctim.tv_sec = 1164931200L;   /* Arbitrary value: 2006-12-01 */
  buf->st_ctim.tv_nsec = 0L;
@


1.256.2.5
log
@* dtable.cc (dtable::init_std_file_from_handle): Try harder to make a pipe into
a full-cygwin device.
(handle_to_fn): Change \ to / when necessary.
* fhandler.cc (fhandler_base::init): Change bin to mode.
* fhandler.h (fhandler_pipe::init): Declare.
* pipe.cc (fhandler_pipe::init): Define.
(handler_pipe::open): Move initialization code into init.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
d1282 1
a1282 1
fhandler_base::init (HANDLE f, DWORD a, mode_t mode)
d1294 1
a1294 1
  set_flags (flags | mode);
@


1.256.2.6
log
@2008-03-05  Corinna Vinschen  <corinna@@vinschen.de>

	* child_info.h (~child_info_spawn): Check moreinfo->myself_pinfo for
	NULL before closing.
	* spawn.cc (spawn_guts): Don't close moreinfo->myself_pinfo explicitely
	in case of failing CloseProcess.

	* exceptions.cc (_cygtls::handle_exceptions): Replace top level SEH
	installed by Windows with our own handler.

	* fhandler.cc (fhandler_base::open_): Return EISDIR when trying to
	create a directory.
	(fhandler_base::open_9x): Ditto.
	* ntdll.h (STATUS_OBJECT_NAME_INVALID): Define.
	* path.cc (path_conv::check): If input path had a trailing dir
	separator, tack it on to the native path if directory doesn't exist.

2008-03-05  Christopher Faylor  <me+cygwin@@cgf.cx>

	* exceptions.cc (_cygtls::handle_exceptions): Detect when signal is
	masked and treat as if it was not caught.  Revert to a 'return 0'
	rather than using a goto.
@
text
@a540 4
      else if (GetLastError () == ERROR_PATH_NOT_FOUND
	       && (flags & O_CREAT)
	       && get_win32_name ()[strlen (get_win32_name ()) - 1] == '\\')
	set_errno (EISDIR);
d691 1
a691 6
      /* Trying to create a directory should return EISDIR, not ENOENT. */
      if (status == STATUS_OBJECT_NAME_INVALID && (flags & O_CREAT)
	  && upath.Buffer[upath.Length / sizeof (WCHAR) - 1] == '\\')
	set_errno (EISDIR);
      else
	__seterrno_from_nt_status (status);
@


1.255
log
@	* autoload.cc (NtQueryEaFile): Define.
	(NtSetEaFile): Define.
	* fhandler.cc (fhandler_base::open): Use appropriate open flags
	in query case when allow_ntea is set.
	* ntdll.h (struct _FILE_GET_EA_INFORMATION): Define.
	(struct _FILE_FULL_EA_INFORMATION): Define.
	(NtQueryEaFile): Declare.
	(NtSetEaFile): Declare.
	* ntea.cc (read_ea): Rename from NTReadEA and rewrite using
	NtQueryEaFile.
	(write_ea): Rename from NTWriteEA and rewrite using NtSetEaFile.
	* path.cc (get_symlink_ea): Make static.  Add handle parameter to
	accomodate new read_ea call.
	(set_symlink_ea): Make static.  Add handle parameter to accomodate new
	write_ea call.
	(symlink_worker): Call set_symlink_ea while file is still open.
	(symlink_info::check): Call get_symlink_ea after file has been opened.
	* security.cc (get_file_attribute): Accomodate new read_ea call.
	(set_file_attribute): Accomodate new write_ea call.
	* security.h (read_ea): Change declaration accordingly.
	(write_ea): Ditto.
@
text
@d265 1
a265 1
	  if (openflags & O_DIROPEN)
@


1.255.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@d265 1
a265 1
	  if (pc.isdir ())
@


1.255.2.2
log
@	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.
@
text
@a225 1
  int try_noreserve = 1;
a227 1
retry:
a261 14
	  if (try_noreserve)
	    {
	      try_noreserve = 0;
	      switch (mmap_is_attached_or_noreserve (ptr, len))
		{
		case MMAP_NORESERVE_COMMITED:
		  goto retry;
		case MMAP_RAISE_SIGBUS:
		  raise(SIGBUS);
		case MMAP_NONE:
		  break;
		}
	    }
	  /*FALLTHRU*/
@


1.254
log
@* fhandler.cc (fhandler_base::fixup_after_exec): Declare here.
* fhandler.h (fhandler_base::fixup_after_exec): Make non-inline.
(fhandler_termios::fixup_after_fork): Delete declaration.
(fhandler_termios::fixup_after_exec): Ditto.
(fhandler_tty_common::inuse): Remove.
(fhandler_tty_common::dup): Delete declaration.
(fhandler_tty_common::fixup_after_fork): Ditto.
(fhandler_tty_slave::fixup_after_exec): Declare new function.
(fhandler_pty_master::dwProcessId): New variable.
(fhandler_pty_master::from_master): Ditto.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::setup): New function.
(fhandler_pty_master::fixup_after_fork): Ditto.
(fhandler_pty_master::fixup_after_exec): Ditto.
* fhandler_termios.cc (fhandler_termios::fixup_after_exec): Delete definition.
(fhandler_termios::fixup_after_fork): Ditto.
* fhandler_tty.cc (fhandler_tty_master::init): Use fhandler_pty_master setup
function rather than obsolete tty::common_init.  Delete obsolete inuse setting.
(fhandler_tty_slave::fhandler_tty_slave): Set inuse to NULL here.
(fhandler_tty_slave::open): Change debugging output for clarity.  Check for
different things when doing a sanity check on the tty.  Reflect the fact that
master_pid now is the cygwin pid rather than the windows pid.  Use "arch"
rather than "archetype" for consistency.
(fhandler_tty_slave::close): Close inuse here.
(fhandler_tty_slave::dup): Remove old if 0'ed code.
(fhandler_pty_master::dup): New function.  Handles pty master archetype.
(fhandler_pty_master::fhandler_pty_master): Zero pty_master specific fields.
(fhandler_pty_master::open): Implement using archetypes, similar to slave.  Use
fhandler_pty_master setup function rather than obsolete tty::common_init.
Don't set inuse.
(fhandler_tty_common::close): Don't deal with inuse.  Delete old if 0'ed code.
(fhandler_pty_master::close): Implement using archetypes.  Close from_master
and to_master.
(fhandler_tty_common::set_close_on_exec): Just set close_on_exec flag here
since everything uses archetypes now.
(fhandler_tty_common::fixup_after_fork): Delete definition.
(fhandler_tty_slave::fixup_after_exec): Define new function.
(fhandler_pty_master::setup): New function, derived from tty::common_init.
(fhandler_pty_master::fixup_after_fork): New function.
(shared_info.h): Reset SHARED_INFO_CB to reflect new tty size.
* tty.cc (tty_list::terminate): Close individual handles from tty_master.
(tty::master_alive): Delete.
(tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* tty.h (tty::from_slave): Delete.
(tty::to_slave): Ditto.
(tty::common_init): Delete declaration.
(tty::make_pipes): Ditto.
(tty::master_pid): Define as pid_t since it is now a cygwin pid.
@
text
@d593 2
a594 1
	access = READ_CONTROL | FILE_READ_ATTRIBUTES | FILE_READ_DATA;
d598 2
a599 1
	access = READ_CONTROL | WRITE_OWNER | WRITE_DAC | FILE_WRITE_ATTRIBUTES;
@


1.253
log
@* debug.h (ModifyHandle): Define new macro.
(modify_handle): Declare new function.
* debug.cc (modify_handle): Define new function.
* fhandler.h (fhandler_base::fork_fixup): Change return value from void to
bool.
* fhandler.cc (fhandler_base::fork_fixup): Return true if fork fixup has been
done.
* pipe.cc (fhandler_pipe::set_close_on_exec): Set inheritance of protected
handle via ModifyHandle if DEBUGGING.
(fhandler_pipe::fixup_after_fork): Protect guard handle if fork fixup has been
done.
@
text
@d1503 6
@


1.252
log
@* fhandler.cc (readv): Remove nonsensical assert.
@
text
@d1467 1
a1467 1
void
d1471 1
d1477 7
a1483 2
  else if (oh != h)
    VerifyHandle (h);
@


1.251
log
@* fhandler.cc (fcntl): Print flags in hex.
* dcrt0.cc (dll_crt0_0): Semi-revert 2006-03-14 change which moved pinfo_init
and uinfo_init here.
(dll_crt0_1): Ditto.
(__dll_crt0): Ditto.  Don't call update_envptrs here.
(dll_crt0_1): Ditto.  Move wait_for_sigthread call here from dll_crt0_0.
* environ.cc (environ_init): Call it here instead.
* sigproc.cc (my_readsig): New static variable.
(wait_for_sigthread): Set up read pipe here since we are assured that we have
the proper privileges when this is called.
(talktome): Eliminate second argument since it is available as a global now.
(wait_sig): Reflect use of my_readsig.
@
text
@a968 2
  assert (tot >= 0);

@


1.250
log
@	* fhandler.cc (fhandler_base::open): Add FILE_READ_ATTRIBUTES to
	access flags in case of query_read_control case, add FILE_READ_DATA
	in case of query_stat_control.
@
text
@d1307 1
a1307 1
      debug_printf ("GETFL: %d", res);
@


1.249
log
@	* fhandler.cc (fhandler_base::open): Fix bug in argument order to
	InitializeObjectAttributes call.
@
text
@d589 1
a589 1
	access = READ_CONTROL;
d593 1
a593 1
	access = READ_CONTROL | FILE_READ_ATTRIBUTES;
@


1.248
log
@*** cygwin DLL Changes:
* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::dwProcessId): Delete.
(child_info::straced): New variable.
(child_info::handle_fork): New member function.
* dcrt0.cc (in_forkee): New global variable.
(__cygwin_user_data::forkee): Mark as obsolete.
(do_global_ctors): Use in_forkee rather than user_data->forkee.
(get_cygwin_startup_info): Ditto.  Deal with new straced field to allow strace
to deal with children of attached processes.
(initial_env): Accommodate changes to strace::hello.
(child_info_fork::handle_fork): Rename from plain old 'handle_fork'.  Move
alloc_stack() call elsewhere.
(dll_crt0_0): Fill out more of user_data.  Reference handle_fork via fork_info.
Add some debugging output.
(_dll_crt0): Don't wait for sync thread if sync_startup is invalid.  Zero
sync_startup here.  Call alloc_stack() here, if appropriate.
(dll_crt0_1): Use in_forkee rather than user_data->forkee.
(dll_crt0): Ditto.
* malloc_wrapper.cc (malloc_init): Ditto.
* dll_init.cc (in_forkee): Remove local static version of this variable.
(dll_list::load_after_fork): Don't set in_forkee here.
* external.cc (cygwin_internal): Use strace method rather than accessing field
directly.
* fhandler.cc (fhandler_base::read): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fork.cc (frok::parent): Invoke strace write_childpid to communicate with
potential strace.
(child_copy): Add more detail to debugging output.
* init.cc (calibration_id): New static variable.
(prime_threads): Set sync_startup to invalid handle if we already know about
thread_func_ix.  Use static calibration_id to hold calibration thread id.
* munge_threadfunc (munge_threadfunc): Don't try to debug if we don't find
threadfunc_ix.
(dll_entry): Avoid calling munge_threadfunc and _cygtls::remove on non-cygwin
threads invoked during process startup.
* pinfo.cc (set_myself): Always call strace.hello here regardless of DEBUGGING.
* sigproc.cc (child_info::child_info): Remove spurious handling of dwProcessId.
Set straced as appropriate.
* spawn.cc (spawn_guts): Rename ciresrv to ch.  Invoke strace write_childpid to
communicate with potential strace.
* strace.cc: Include child_info.h.
(strace::hello): Remove inited test.  Use active() method to test if strace has
been activated.  Handle case where we are started before
(mypid): New function.
(strace::vsprntf): Try to deal more intelligently with case where progname may
not be filled out.  Put pid in parentheses if it is a windows pid rather than a
cygwin pid.  myself has been filled out.
(strace::write_childpid): New function for notifying strace about the creation
of children.
(strace::vprntf): Use strace method rather than accessing field directly.
(strace_printf): Ditto.
(strace::wm): Ditto.
* winsup.h (in_forkee): Declare.
* include/sys/strace.h (strace::write_childpid): Declare new function.
(strace::attached): Define new function.
(strace::active): Ditto.
(strace::active_val): Ditto.
(_STRACE_ON): Delete.
(_STRACE_OFF): Ditto.
(define_strace0): Use strace method rather than accessing field directly.
(strace_printf_wrap): Ditto.
(strace_printf_wrap1): Ditto.

*** cygwin utils changes:
* strace.cc (nprocesses): Make static global.
(quiet): New variable.
(strace_active): Ditto.
(add_child): Increment nprocesses here.  Don't add a child if it is already
added (windows bug?).  Report on child if not quiet.
(get_child): Just return NULL if child not found.
(remove_child): Report on child if not quiet.
(attach_process): Don't complain if given a windows process.  Use windows pid
in error.
(handle_output_debug_string): Issue error if trying to manipulate a process
that we don't know about.  Handle _STRACE_CHILD_PID - attach to reported child
when we get this.
(proc_child): Move nprocesses to file scope.  Report on exceptions.
(longopts): Implement "--quiet".
(opts): Implement "-q".
(main): Manipulate quiet flag.
* utils.sgml (strace): Add words describing '-q'.
@
text
@d584 1
a584 1
			      sa.lpSecurityDescriptor, NULL);
@


1.247
log
@	* fhandler.cc (ACCFLAGS): Remove macro.
	(fhandler_base::get_default_fmode): Use O_ACCMODE instead of ACCFLAGS
	and or'ed read/write flags.
	(fhandler_base::open_9x): Use O_ACCMODE instead of or'ed read/write
	flags.
	(fhandler_base::open): Ditto.
	* fhandler_disk_file.cc (fhandler_base::open_fs): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
@
text
@d775 1
a775 1
  if (strace.active)
@


1.246
log
@	* fhandler.cc (fhandler_base::open_9x): Handle O_SYNC and O_DIRECT
	flags.
	(fhandler_base::open): Ditto.
	* fhandler_floppy.cc (fhandler_dev_floppy::open): Don't allocate devbuf
	in O_DIRECT case.
	* fhandler_raw.cc (fhandler_dev_raw::ioctl): Don't allow buffer
	changes in O_DIRECT case.  Allow returning a buffer size 0, which
	indicates O_DIRECT.
	* fhandler_tape.cc (fhandler_dev_tape::open): Use O_SYNC flag to
	hand down the !buffer_writes case.  Don't allocate devbuf in O_DIRECT
	case.
	(fhandler_dev_tape::raw_read): Don't mess with devbuf if it's NULL.
	* include/fcntl.h: Define _FDIRECT, O_DIRECT, O_DSYNC and O_RSYNC.
	* include/cygwin/version.h: Bump API minor version.
@
text
@a300 1
#define ACCFLAGS(x) (x & (O_RDONLY | O_WRONLY | O_RDWR))
d308 1
a308 1
      unsigned accflags = ACCFLAGS (flags);
d310 1
a310 1
	if (!*pf->name && ACCFLAGS (pf->flags) == accflags)
d312 1
a312 1
	    fmode = pf->flags & ~(O_RDONLY | O_WRONLY | O_RDWR);
d321 2
a322 1
	    else if (ACCFLAGS (pf->flags) == accflags && strcasematch (stem, pf->name))
d324 1
a324 1
		fmode = pf->flags & ~(O_RDONLY | O_WRONLY | O_RDWR);
d462 1
a462 1
	if ((flags & (O_RDONLY | O_WRONLY | O_RDWR)) == O_RDONLY)
d464 1
a464 1
	else if ((flags & (O_RDONLY | O_WRONLY | O_RDWR)) == O_WRONLY)
d527 1
a527 1
	  if (flags & (O_WRONLY | O_RDWR))
d606 1
a606 1
	if ((flags & (O_RDONLY | O_WRONLY | O_RDWR)) == O_RDONLY)
d608 1
a608 1
	else if ((flags & (O_RDONLY | O_WRONLY | O_RDWR)) == O_WRONLY)
@


1.245
log
@* fhandler_base.cc (fhandler_base::readv): Free buf, not a pointer into the
middle of buf.
@
text
@d495 4
a605 6
	if (get_major () == DEV_TAPE_MAJOR && (flags & O_TEXT))
	  {
	    /* O_TEXT is used to indicate write-through on tape devices */
	    create_options |= FILE_WRITE_THROUGH;
	    flags &= ~O_TEXT;
	  }
d612 4
@


1.244
log
@	Revert erroneous checkin.
@
text
@d972 1
a972 1
  char *buf = (char *) malloc (tot);
d985 1
d989 2
a990 2
      memcpy (iovptr->iov_base, buf, frag);
      buf += frag;
@


1.243
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d558 6
a563 7
  UNICODE_STRING upath;
  if (!pc.get_nt_native_path (upath))
    {
      syscall_printf ("0 = fhandler_base::open (%s, %p)",
		      get_win32_name (), flags);
      return 0;
    }
d579 1
a579 2
  InitializeObjectAttributes (&attr, &upath,
			      OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
a683 1
  RtlFreeUnicodeString (&upath);
d1266 1
a1266 1
fhandler_base::dup (fhandler_base *child, HANDLE from_proc)
a1270 1
  set_flags (child->get_flags ());
d1273 1
a1273 1
      if (!DuplicateHandle (from_proc, get_handle (), hMainProc, &nh, 0, TRUE,
d1285 1
@


1.242
log
@* dcrt0.cc (do_exit): Rely on sigproc_terminate to set exit_state
appropriately.
* pinfo.cc (pinfo::exit): Always call sigproc_terminate here.  Rely on
sigproc_terminate to signal signal thread to handle eventual process exit.
* sigproc.cc (no_signals_available): Change criteria for determining if this
process can handle signals to itself.
(my_sendsig): New variable.  Copy of my sendsig handle.
(proc_can_be_signalled): Don't send signals if exit code is set.
(sigproc_terminate): Use and set exit_state appropriately to determine when to
do anything.  Send __SIGEXIT to self to control process exit.
(sig_send): Use my_sendsig for sending signals.  Don't call
proc_can_be_signalled for myself since the criteria is now different for
sending signals to myself.
(wait_sig): Copy myself->sendsig to my_sendsig for future use.  Exit signal
loop when __SIGEXIT is received.  Wait for main thread to exit and use its exit
status to actually exit process.
* sigproc.h (__SIGEXIT): New enum.
* dcrt0.cc (alloc_stack): Eliminate superfluous "return;".
* debug.cc (add_handle): Ditto.
* devices.in (device::parse): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
(dtable::vfork_child_fixup): Ditto.
* environ.cc (parse_options): Ditto.
* errno.cc (seterrno_from_win_error): Ditto.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(set_signal_mask): Ditto.
* fhandler.cc (fhandler_base::read): Ditto.
(fhandler_base::operator delete): Ditto.
(fhandler_base::seekdir): Ditto.
(fhandler_base::rewinddir): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* sigproc.cc (sigproc_init): Ditto.
(sigproc_terminate): Ditto.

* devices.cc: Regenerate.
@
text
@d558 7
a564 6
  WCHAR wpath[CYG_MAX_PATH + 10];
  UNICODE_STRING upath = {0, sizeof (wpath), wpath};
  pc.get_nt_native_path (upath);

  if (RtlIsDosDeviceName_U (upath.Buffer))
    return fhandler_base::open_9x (flags, mode);
d580 2
a581 1
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
d686 1
d1269 1
a1269 1
fhandler_base::dup (fhandler_base *child)
d1274 1
d1277 1
a1277 1
      if (!DuplicateHandle (hMainProc, get_handle (), hMainProc, &nh, 0, TRUE,
a1288 1
  set_flags (child->get_flags ());
@


1.241
log
@* cygerrno.h (geterrno_from_win_error): Change declaration to default to using
GetLastError and EACCESS.
* cygwin.din: Export readdir_r.
* include/cygwin/version.h: Bump API version number to 138.
* syscalls.cc (readdir_worker): New function, renamed from old readdir()
function.
(readdir): Use readdir_worker.
(readdir_r): New function.
* fhandler.h (fhandler_base::readdir): Accommodate second argument indicating
dirent buffer.
(fhandler_disk_file::readdir): Ditto.
(fhandler_cygdrive::readdir): Ditto.
(fhandler_proc::readdir): Ditto.
(fhandler_netdrive::readdir): Ditto.
(fhandler_registry::readdir): Ditto.
(fhandler_process::readdir): Ditto.
* fhandler.cc (fhandler_base::readdir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Ditto.
* fhandler_cygdrive.cc (fhandler_cygdrive::readdir): Ditto.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_netdrive.cc (fhandler_netdrive::readdir): Ditto.
* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
* fhandler_process.cc (fhandler_process::readdir): Ditto.
@
text
@a791 1
  return;
a1399 1
  return;
a1555 1
  return;
a1561 1
  return;
@


1.240
log
@* fhandler.h (fhandler_base::pread): Declare new function.
(fhandler_base::pwrite): Ditto.
(fhandler_disk_file::pread): Ditto.
(fhandler_disk_file::pwrite): Ditto.
* fhandler.cc (fhandler_base::pread): Define new function.
(fhandler_base::pwrite): Ditto.
* fhandler_disk_file.cc (fhandler_base::pread): Ditto.
(fhandler_base::pwrite): Ditto.
* syscalls.cc (pread): Define new function.
(pwrite): Ditto.
* cygwin.din: Export pread, pwrite.
* include/sys/ioctl.h: Guard some _IO* declarations to avoid conflict with
socket.h.
@
text
@d1541 2
a1542 2
struct dirent *
fhandler_base::readdir (DIR *)
d1544 1
a1544 2
  set_errno (ENOTDIR);
  return NULL;
@


1.239
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d1119 14
@


1.238
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d233 1
a233 1
      (void) SetThreadPriority (h, THREAD_PRIORITY_TIME_CRITICAL);
d240 1
a240 1
      (void) SetThreadPriority (h, prio);
@


1.237
log
@	* fhandler.cc (fhandler_base::readv): Use malloc/free instead of alloca.
	(fhandler_base::writev): Ditto.
@
text
@a1251 6
void
fhandler_base::dump (void)
{
  paranoid_printf ("here");
}

d1342 1
a1342 1
fhandler_base::tcdrain (void)
d1377 1
a1377 1
fhandler_base::tcgetpgrp (void)
d1411 1
a1411 1
fhandler_base::~fhandler_base (void)
a1424 6
void
fhandler_dev_null::dump (void)
{
  paranoid_printf ("here");
}

@


1.236
log
@	* fhandler.cc (rootdir): Don't set errno.
	* syscalls.cc (statvfs): Set errno to ENOTDIR if rootdir() failed.
@
text
@d973 1
a973 1
  char *buf = (char *) alloca (tot);
d995 1
d1026 1
a1026 1
  char *const buf = (char *) alloca (tot);
d1046 3
a1048 2

  return write (buf, tot);
@


1.235
log
@* cygthread.cc (cygthread::detach): Make error message a little more detailed.
* fhandler.cc (fhandler_base::raw_read): Ditto for debug message.
* dcrt0.cc (do_exit): Add some more synchronization tests.
* fhandler_fifo.cc (fhandler_fifo::dup): Don't duplicate a nonexistent handle.
Use derived return value rather than always retuning 0.
* fhandler_netdrive.cc (fhandler_netdrive::exists): Wnet -> WNet.
* winsup.h (exit_states): Add a couple of new exit states.
@
text
@d1182 1
a1182 1
	goto error;
d1189 1
a1189 5
    {
    error:
      set_errno (ENOTDIR);
      return NULL;
    }
@


1.234
log
@* fhandler.h (fhandler_base::mkdir): New virtual method.
(fhandler_base::rmdir): Ditto.
(fhandler_disk_file:mkdir): New method.
(fhandler_disk_file:rmdir): Ditto.
* dir.cc (mkdir): Implement with fhandlers.
(rmdir): Ditto.
* fhandler.cc (fhandler_base::mkdir): New virtual method.
(fhandler_base::rmdir): Ditto.
(fhandler_disk_file::mkdir): New method.
(fhandler_disk_file::rmdir): Ditto.

fhandler_random.cc: white space.
@
text
@d272 1
a272 1
	  syscall_printf ("ReadFile %s failed, %E", get_name ());
@


1.233
log
@(check in files that should have been checked in previously)
* fhandler.cc (fhandler_base::open_9x): Remove (broken) check for
O_CREAT|O_EXCL.
* syscalls.cc (open): Do O_CREAT|O_EXCL check here first.
@
text
@d1512 22
@


1.232
log
@* fhandler.cc (fhandler_base::read): Remove unused signal state tweaks.
* fhandler.h (fhandler_pipe::create_selectable): Declare.
(fhandler_fifo::close_one_end): Declare.
* fhandler_fifo.cc (fhandler_fifo::close_one_end): Define.
(fhandler_fifo::open_not_mine): Use close_one_end to close appropriate end of
pipe.
* pinfo.cc (_pinfo::commune_recv): Ditto.
* pipe.cc (fhandler_pipe::create_selectable): Rename from
create_selectable_pipe.  Reorganize.
(fhandler_pipe::create): Use create_selectable.
@
text
@d523 1
a523 3
	  if (flags & (O_CREAT | O_EXCL) == (O_CREAT | O_EXCL))
	    set_errno (EEXIST);
	  else if (flags & (O_WRONLY | O_RDWR))
@


1.231
log
@* fhandler.cc (fhandler::dup): Duplicate flags, too.
* fhandler.h (fhandler_fifo::owner): Eliminate.
* fhandler_disk_file.cc (fhandler_base::fstat_fs): Handle on-disk devices
better.
(fhandler_base::fstat_helper): Ditto.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Don't initialize obsolete
"owner".
(fhandler_fifo::open_not_mine): Add some debugging.  Duplicate correct handle
when we own it.
(fhandler_fifo::open): Set flags from input, not from first pipe.  Flag that
fork fixup is needed.
(fhandler_fifo::dup): Set errno correctly when DuplicateHandle fails.
* pinfo.cc (commune_send): Add debugging for fifo.
* cygwin/version.h: Bump API minor version to 127 to reflect exporting of
sigrelese.
@
text
@a701 1
  bool need_signal = !!read_state;
a724 1
  need_signal = false;
a792 3
  if (need_signal)
    signal_read_state (2);

@


1.230
log
@	* cygerrno.h (__seterrno_from_nt_status): Define. Always set Win32
	error code as well as errno. Use throughout where errno is set from
	NT status.
	(set_errno): Evaluate val only once.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Fix typo in
	debug output.
	* fhandler_mem.cc (fhandler_dev_mem::open): Rely on
	__seterrno_from_nt_status setting Win32 error code in debug output.
	* fhandler_proc.cc (format_proc_uptime): Ditto.
	(format_proc_stat): Ditto.
	* fhandler_process.cc (format_process_stat): Ditto.
	* sysconf.cc (sysconf): Ditto.
@
text
@d1287 1
@


1.229
log
@* fhandler.h (fhandler_base::utimes_fs): New method.
* fhandler.cc (fhandler_base::utimes): Call utimes_fs if on-disk special file.
* fhandler_disk_file.cc (fhandler_disk_file::utimes): Use utimes_fs.
(fhandler_base::utimes_fs): Handle on-disk device files.
@
text
@d668 1
a668 1
      __seterrno_from_win_error (RtlNtStatusToDosError (status));
@


1.228
log
@	* autoload.cc (NtQueryVolumeInformationFile): Add.
	* fhandler.cc (fhandler_base::raw_write): Don't touch has_changed flag.
	* fhandler.h (enum change_state): Remove.
	(fhandler_base::status): Revert has_changed to a simple bit.
	(fhandler_base::fstat_helper): Add nAllocSize parameter.  Rename
	ftCreationTime to ftChangeTime.
	* fhandler_disk_file.cc:
	Call fstat_helper with additional
	allocation size throughout.
	(fhandler_base::fstat_by_handle): Use NT native functions to get
	full file information on NT.  Call fstat_helper with LastWriteTime
	as ctime, if ChangeTime is not available.
	(fhandler_base::fstat_by_name): Call fstat_helper with LastWriteTime
	as ctime.
	(fhandler_base::fstat_helper): Add comment. Drop special FAT
	handling since it's useless. Use nAllocSize for st_blocks if available.
	(fhandler_disk_file::touch_ctime): Only touch LastWriteTime.
	(fhandler_disk_file::fchmod): Set has_changed on 9x only.
	(fhandler_disk_file::fchown): Don't set has_changed.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::ftruncate): Ditto.
	(fhandler_disk_file::link): Set has_changed on 9x only and on original
	file only.
	(fhandler_base::open_fs): Don't set has_changed in O_TRUNC case.
	* ntdll.h (FILE_BASIC_INFORMATION): Define.
	(FILE_STANDARD_INFORMATION): Define.
	(FILE_INTERNAL_INFORMATION): Define.
	(FILE_EA_INFORMATION): Define.
	(FILE_ACCESS_INFORMATION): Define.
	(FILE_POSITION_INFORMATION): Define.
	(FILE_MODE_INFORMATION): Define.
	(FILE_ALIGNMENT_INFORMATION): Define.
	(FILE_NAME_INFORMATION): Don't define with arbitrary FileName size.
	(FILE_ALL_INFORMATION): Define.
	(FILE_INFORMATION_CLASS): Add FileAllInformation.
	(FILE_FS_VOLUME_INFORMATION): Define.
	(FS_INFORMATION_CLASS): Define.
	(NtQueryVolumeInformationFile): Define.
@
text
@d1638 3
@


1.227
log
@	* dcrt0.cc (dll_crt0_1): Don't call set_cygwin_privileges on 9x.

	* fhandler.h (enum change_state): Add.
	(fhandler_base::status): Add a bit to has_changed flag.
	(fhandler_base::has_changed): Implement with type change_state.
	* fhandler.cc (fhandler_base::raw_write): Accomodate type change
	of has_changed.
	* fhandler_disk_file.cc )fhandler_disk_file::touch_ctime): Also
	touch modification time if has_changed == data_changed.
	(fhandler_disk_file::fchmod): Also open on 9x, otherwise we can't
	touch ctime.  Accomodate type change of has_changed.
	(fhandler_disk_file::fchown): Accomodate type change of has_changed.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::ftruncate): Ditto.
	(fhandler_disk_file::link): Ditto.
	(fhandler_base::open_fs): Ditto.
@
text
@a297 1
  has_changed (data_changed);
@


1.226
log
@	* fhandler.cc (fhandler_base::open_9x): Satisfy query_open values.
@
text
@d298 1
a298 1
  has_changed (true);
@


1.225
log
@	* devices.h: Switch FH_ZERO and FH_PORT as on Linux.  Add FH_FULL.
	* devices.in: Add /dev/full.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add FH_FULL.
	* fhandler.cc (fhandler_base::fstat): Set FH_FULL permission bits
	correctly.
	* fhandler_zero.cc (fhandler_dev_zero::write): Set errno to ENOSPC
	and return -1 if device is FH_FULL.
@
text
@d452 19
a470 6
  if ((flags & (O_RDONLY | O_WRONLY | O_RDWR)) == O_RDONLY)
    access = GENERIC_READ;
  else if ((flags & (O_RDONLY | O_WRONLY | O_RDWR)) == O_WRONLY)
    access = GENERIC_WRITE;
  else
    access = GENERIC_READ | GENERIC_WRITE;
@


1.224
log
@	* cygwin.din (fdatasync): Export.
	* fhandler.cc (fhandler_base::fsync): Return with EINVAL if no
	handle is available.
	* syscalls.cc (fdatasync): Create export alias to fsync.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d1214 3
@


1.223
log
@	* autoload.cc (FindFirstVolumeA): Add.
	(FindNextVolumeA): Add.
	(FindVolumeClose): Add.
	(GetVolumePathNamesForVolumeNameA): Add.
	* fhandler.h (class fhandler_base): Declare new method fsync.
	* fhandler.cc (fhandler_base::fsync): New method.
	* syscalls.cc (fsync): Move functionality into fhandler method fsync.
	Just call this method from here.
	(sync_worker): New static function.
	(sync): Fill with life for NT systems.
	* wincap.h (wincaps::has_guid_volumes): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d1630 5
@


1.222
log
@	* fhandler.h (enum query_state): Add query_write_attributes state.
	(fhandler_base::status.query_open): Add a bit to make room for more
	states.
	(class fhandler_base): Declare new method utimes.
	(class fhandler_socket): Ditto.
	(class fhandler_disk_file): Ditto.
	(fhandler_disk_file::fhandler_disk_file): Add constructor with
	path_conv parameter.
	* fhandler.cc (fhandler_base::open): Add query_write_attributes
	handling.
	(fhandler_base::utimes): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Simplify.
	Open file with query_write_attributes instead of query_write_control.
	(fhandler_disk_file::utimes): New method.
	(fhandler_disk_file::fhandler_disk_file): Add constructor with
	path_conv parameter setting pc member immediately.
	* fhandler_socket.cc (fhandler_socket::fchmod): Use new
	fhandler_disk_file constructor.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	(fhandler_socket::link): Ditto.
	(fhandler_socket::utimes): New method.
	* times.cc: Include dtable.h.
	(timeval_to_filetime): Make non-static.
	(utimes): Move functionality into fhandler method utimes. Just call
	this method from here.
	* winsup.h: Simplify declarations of time helper functions.
	(timeval_to_filetime): Add extern declaration.
@
text
@d1626 11
@


1.221
log
@	* fhandler.h (class fhandler_base): Declare new method link.
	(class fhandler_socket): Ditto.
	(class fhandler_disk_file): Ditto.
	* fhandler.cc (fhandler_base::open): Add FILE_WRITE_ATTRIBUTES
	to query_write_control access flags.
	(fhandler_base::link): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Don't try to
	open with O_WRONLY since query_write_control includes
	FILE_WRITE_ATTRIBUTES.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::link): New method.  Touch st_ctime on successful
	link.
	* fhandler_socket.cc (fhandler_socket::link): New method.
	* syscalls.cc (link): Move functionality into fhandler method link.
	Just call this method from here.
@
text
@d586 4
d1619 7
@


1.220
log
@	* fhandler.cc (fhandler_base::raw_write): Mark as changed on
	successful write.
	* fhandler.h (fhandler_base::status_flags): Add 'has_changed' flag.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Call
	fhandler_disk_file's own open and close instead of open_fs and
	close_fs.  Mark as changed on success.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::ftruncate): Ditto.
	(fhandler_base::open_fs): Mark as changed when O_TRUNC flag on existing
	file is set.
	(fhandler_disk_file::close): Set st_ctime if has_changed flag is set.
@
text
@d583 1
a583 1
	access = READ_CONTROL | WRITE_OWNER | WRITE_DAC;
d1608 7
@


1.219
log
@* cygthread.cc (cygthread::release): Reset ev here if it exists.
(cygthread::terminate_thread): Eliminat racy code which reset ev and
thread_sync.  Remove a few nonsensical inuse checks.  Exit at the bottom.
(cygthread::detach): Rewrite to again try to ensure that we don't say we're
signalled when we are not signalled.
* fhandler.cc (fhandler_base::raw_read): Revert to signalling read success
quickly.
* pipe.cc (fhandler_pipe::close): Use base method to close handle.
* sigproc.h (WAIT_SIG_PRIORITY): Just trundle along at normal priority to allow
the pipe thread to do its thing if possible.
* pinfo.h (pinfo::zap_cwd): Declare new function.
(pinfo::zap_cwd): Move 'cd out of the way code' here.
(pinfo::exit): Use it here.
* spawn.cc (spawn_guts): And here.
@
text
@d291 1
a291 1
	return bytes_written;
d297 2
@


1.218
log
@* cygthread.h (cygthread::terminate_thread): Reflect return value.
* cygthread.cc (cygthread::detach): Be more careful about ensuring that sigwait
is properly waited for to avoid later missynchronization.
(cygthread::terminate_thread): Return true if thread was actually terminated
and all handles were closed.
* fhandler_base.cc (fhandler_base::raw_read): Use signal_read_state rather than
raw calls to win32 api.
(fhandler_base::read): Ditto.
* fhandler.h (fhandler_pipe::fixup_after_exec): Use method to create read_state
signalling.
(fhandler_pipe::create): Ditto.
* Makefile.in: Make some more files -fomit-frame-pointer.
@
text
@d237 5
a277 5
  if (read_state)
    {
      signal_read_state (1);
      (void) SetThreadPriority (h, prio);
    }
@


1.217
log
@	* fhandler.h (fhandler_base::ftruncate): Define new virtual method.
	(fhandler_disk_file::ftruncate): Ditto.
	* fhandler.cc (fhandler_base::ftruncate): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.
	* syscalls.cc (ftruncate64): Move functionality into fhandlers.
	Call fhandler method from here.
@
text
@d234 1
a234 1
      SetEvent (read_state);
a236 5
  if (read_state)
    {
      SetEvent (read_state);
      (void) SetThreadPriority (h, prio);
    }
d273 5
d708 1
a709 1
  need_signal = false;
d778 1
a778 1
    SetEvent (read_state);
@


1.216
log
@	* fhandler.cc (fhandler_base::get_proc_fd_name): Don't generate
	"device:" entry.
	* fhandler.h (fhandler_socket::open): New method.
	(fhandler_pipe::open): New method.
	* fhandler_proc.cc (fhandler_proc::exists): Return -2 in case of
	/proc/self.
	* fhandler_process.cc (fhandler_process::exists): Return -2 in
	case of symlinks, -3 for pipes and -4 for sockets.
	(fhandler_process::fstat): Handle pipes and sockets.
	(fhandler_process::open): Handle opening /proc/<pid>/fd.
	(fhandler_process::fill_filebuf): Generate empty names for
	non exisiting file descriptors.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Always
	generate "socket:[number]" strings as on Linux.
	(fhandler_socket::open): New method.
	(fhandler_socket::fstat): Always return socket type.
	* path.cc (symlink_info::set): Remove unused second parameter.
	(path_conv::check): Handle pipes and sockets in /proc.
	Set correct device type for AF_LOCAL sockets.
	* pinfo.cc (_pinfo::commune_recv): Generate empty names for
	non exisiting file descriptors.
	(_pinfo::fd): Ditto.
	* pipe.cc (fhandler_pipe::open): New method.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d818 2
a819 2
	      syscall_printf ("%d = DeviceIoControl(%p, FSCTL_SET_SPARSE, "
			      "NULL, 0, NULL, 0, &dw, NULL)", r, h);
d1599 7
@


1.215
log
@* path.h (path_conv::set_name): Declare new function.
* path.cc (path_conv::set_name): Define new function.
* fhandler.h (fhandler_dev_null::open): Declare new function.
* fhandler.cc (fhandler_dev_null::open): Define new function.
@
text
@d163 1
a163 2
  __small_sprintf (buf, "device:[%d:%d]", get_major (), get_minor ());
  return buf;
@


1.214
log
@	* cygheap.h (class cygheap_fdenum): New class to enumerate used
	fhandlers.
	* dtable.h (class dtable): Add cygheap_fdenum as friend class.
	* fhandler.h (fhandler_base::get_proc_fd_name): New virtual method
	to return a name for /proc/<pid>/fd.
	(fhandler_socket::get_proc_fd_name): Ditto.
	(fhandler_pipe::get_proc_fd_name): Ditto.
	(fhandler_virtual::opendir): Make virtual method.
	(fhandler_process::opendir): New method.
	* fhandler.cc (fhandler_base::get_proc_fd_name): New method.
	* fhandler_process.cc: Include ctype.h.
	(PROCESS_FD): Define.
	(process_listing): Add "fd".
	(fhandler_process::exists): Fix comment.  Return 1 in case of "fd"
	directory. Handle files below "fd".
	(fhandler_process::fstat): Drop "self" handling.  Set correct link
	count for directories.
	(fhandler_process::opendir): New method to handle "fd" directory.
	(fhandler_process::readdir): Add "fd" handling.
	(fhandler_process::open): Drop "self" handling.
	(fhandler_process::fill_filebuf): Ditto.  Add "fd" handling.  Fix
	"maps" output string.
	* fhandler_registry.cc (fhandler_registry::fstat): Set correct link
	count for directories.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): New method.
	* path.cc (symlink_info::set): Fix thinko.
	* pinfo.cc (_pinfo::commune_recv): Rename pathbuf to path throughout.
	Drop local path variable in PICOM_FIFO case.  Fix debug output.
	Close handles as early as possible. Add PICOM_FDS and PICOM_FD
	handling.
	(_pinfo::commune_send): Add PICOM_FDS and PICOM_FD handling.
	(_pinfo::fd): New method.
	(_pinfo::fds): New method.
	* pinfo.h (enum picom): Add PICOM_FDS and PICOM_FD.
	(_pinfo::fd): Declare.
	(_pinfo::fds): Declare.
	* pipe.cc (fhandler_pipe::get_proc_fd_name): New method.
@
text
@d1424 9
@


1.213
log
@	* fhandler_disk_file.cc (fhandler_disk_file::facl): Pretend successful
	SETACL if no acls are available.
	* fhandler.cc (fhandler_base::facl): Implement to return sensible
	values on GETACL and GETACLCNT.  Pretend successful SETACL.
	* fhandler_virtual.cc (fhandler_virtual::facl): Ditto.
@
text
@d157 10
@


1.212
log
@* fhandler.cc (fhandler_base::fchmod): Do the right thing when changing an "on
disk" device or fifo.
(fhandler_base::fchown): Ditto for changing ownership.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Accommodate device files
on ntfs partitions.
* path.cc (path_conv::check): Use isfs function to figure out if a path exists
on a filesystem to make sure that device files are caught.
@
text
@d1542 37
a1578 2
  /* By default, just succeeds. */
  return 0;
@


1.211
log
@* path.h (path_conv::set_normalized_path): Add second argument and fill it in
throughout.
* path.cc (path_conv::check): Declare, set and use "strip_tail".
(path_conv::set_normalized_path): Add and use second argument, replacing all
tail stripping tests.
@
text
@d1523 3
d1533 2
@


1.210
log
@* fhandler.cc (fhandler_base::puts_readahead): Fix end-condition.
@
text
@d44 1
a44 1
  pc.set_normalized_path (x.pc.normalized_path);
d154 1
a154 1
  pc.set_normalized_path (in_pc.normalized_path);
@


1.209
log
@* fhandler.cc (fhandler_base::read): Remove superfluous check in
__small_printf format for strace.
@
text
@d57 1
a57 1
  while ((*s || (len != (size_t) -1 && len--))
@


1.208
log
@* fhandler.cc (fhandler_base::read): Don't debug_printf garbage when
copied_chars is zero.
@
text
@d757 1
a757 2
	  /* >= 33 so space prints in hex */
	  __small_sprintf (p, c >= 33 && c <= 127 ? " %c" : " %p", c);
@


1.207
log
@2004-11-20  Pierre Humblet <pierre.humblet@@ieee.org>

	* fhandler.cc (fhandler::write): Remove debug_printf.
	* pipe.cc (fhandler_pipe::create): Edit syscall_printf format.
@
text
@d761 1
@


1.206
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@a916 1
  debug_printf ("%d = write (%p, %d)", res, ptr, len);
@


1.205
log
@	* fhandler.cc (fhandler_base::dup): Use debug_printf.
@
text
@d487 1
a487 1
        file_attributes |= FILE_ATTRIBUTE_READONLY;
d490 1
a490 1
    } 
d821 1
a821 1
	        {
d840 1
a840 1
		        {
@


1.204
log
@	* fhandler.cc (fhandler_base::write): In the lseek_bug case, set EOF
	before zero filling. Combine similar error handling statements.
@
text
@d1248 2
a1249 2
	  system_printf ("dup(%s) failed, handle %x, %E",
			 get_name (), get_handle ());
@


1.203
log
@	* fhandler.cc (fhandler_base::open): Set shared flags to 0 when
	opening a tape device.
@
text
@d819 6
d828 2
a829 1
	      SetFilePointer (get_output_handle (), 0, NULL, FILE_END);
d835 3
a837 2
		  if (!WriteFile (get_output_handle (), zeros, zeros_this_time,
				  &written, NULL))
d839 8
a846 3
		      __seterrno ();
		      if (get_errno () == EPIPE)
			raise (SIGPIPE);
d848 2
a849 2
		      SetFilePointer (get_output_handle (), current_position, NULL,
				      FILE_BEGIN);
a852 8
		  if (written < zeros_this_time) /* just in case */
		    {
		      set_errno (ENOSPC);
		      /* This might fail, but it's the best we can hope for */
		      SetFilePointer (get_output_handle (), current_position, NULL,
				      FILE_BEGIN);
		      return -1;
		    }
@


1.202
log
@2004-08-14  Pierre Humblet <pierre.humblet@@ieee.org>

	* fhandler.cc (fhandler_base::open_9x): Set file attributes
	for new files.
@
text
@d546 1
a546 1
  ULONG shared = wincap.shared ();
@


1.201
log
@	* fhandler.cc (fhandler_base::open): Remove 9x specific code.
@
text
@d483 8
a490 3
  /* If mode has no write bits set, we set the R/O attribute. */
  if (!(mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
    file_attributes |= FILE_ATTRIBUTE_READONLY;
@


1.200
log
@2004-06-17  Pierre Humblet <pierre.humblet@@ieee.org>

        * fhandler.cc (fhandler_base::open_9x): Do not check for null name.
        Move debug_printf to common code line.
        (fhandler_base::open): Ditto. Initialize upath. Remove second argument
        of pc.get_nt_native_path.
        * path.h (path_conv::get_nt_native_path): Remove second argument.
        * path.cc (path_conv::get_nt_native_path): Ditto. Call str2uni_cat.
        * security.h (str2buf2uni_cat): Delete declaration.
        (str2uni_cat): New declaration.
        * security.cc (str2buf2uni): Get length from sys_mbstowcs call.
        (str2buf2uni_cat): Delete function.
        (str2uni_cat): New function.
        * miscfuncs.cc (sys_mbstowcs): Add debug_printf.
@
text
@a634 9
      if (!wincap.can_open_directories () && pc.isdir ())
	{
	  if (flags & (O_CREAT | O_EXCL) == (O_CREAT | O_EXCL))
	    set_errno (EEXIST);
	  else if (flags & (O_WRONLY | O_RDWR))
	    set_errno (EISDIR);
	  else
	    nohandle (true);
	}
@


1.199
log
@	* fhandler.cc (fhandler_base::open): Substitute FILE_SUPERSEDE with
	FILE_OVERWRITE_IF.
@
text
@a439 6
  if (get_win32_name () == NULL)
    {
      set_errno (ENOENT);
      goto done;
    }

a508 4
  syscall_printf ("%p = CreateFile (%s, %p, %p, %p, %p, %p, 0)",
		  x, get_win32_name (), access, shared, &sa,
		  creation_distribution, file_attributes);

d515 4
a530 1
  UNICODE_STRING upath;
d532 2
a533 1
  pc.get_nt_native_path (upath, wpath);
d535 1
a535 1
  if (RtlIsDosDeviceName_U (wpath))
a550 5
  if (get_win32_name () == NULL)
    {
      set_errno (ENOENT);
      goto done;
    }
a648 5
  syscall_printf ("%x = NtCreateFile "
		  "(%p, %x, %s, io, NULL, %x, %x, %x, %x, NULL, 0)",
		  status, x, access, get_win32_name (), file_attributes, shared,
		  create_disposition, create_options);

d655 5
@


1.198
log
@* autoload.cc (IsDosDeviceName_U): Define.
* ntdll.h (IsDosDeviceName_U): Declare.
* fhandler.cc (fhandler_base::open): Check to see if win32_name is a dos device
and just call the 9x open if so.
@
text
@d605 1
a605 1
	create_disposition = FILE_SUPERSEDE;
@


1.197
log
@revert accidental checkin
@
text
@d537 7
a551 2
  UNICODE_STRING upath;
  WCHAR wpath[CYG_MAX_PATH + 10];
d563 1
a563 2
  InitializeObjectAttributes (&attr, pc.get_nt_native_path (upath, wpath),
			      OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
@


1.196
log
@* winbase.h (ilockincr): More changes from the inexplicable world of gcc asm
magic.
(ilockdecr): Ditto.
@
text
@d534 1
a534 3
  UNICODE_STRING upath;
  WCHAR wpath[CYG_MAX_PATH + 10];
  if (!wincap.is_winnt () || RtlIsDosDeviceName_U(wpath))
d545 2
d558 2
a559 1
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
@


1.195
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d534 3
a536 1
  if (!wincap.is_winnt ())
a546 2
  UNICODE_STRING upath;
  WCHAR wpath[CYG_MAX_PATH + 10];
d558 1
a558 2
  InitializeObjectAttributes (&attr, pc.get_nt_native_path (upath, wpath),
			      OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
@


1.194
log
@	* fhandler.cc (fhandler_base::open): Set file attributes to correct
	value when creating files.
	* path.h (class path_conv): Add write accessor for file_attributes.
@
text
@d565 3
a567 3
        access = READ_CONTROL;
        create_options = FILE_OPEN_FOR_BACKUP_INTENT;
        break;
d569 3
a571 3
        access = READ_CONTROL | FILE_READ_ATTRIBUTES;
        create_options = FILE_OPEN_FOR_BACKUP_INTENT;
        break;
d573 3
a575 3
        access = READ_CONTROL | WRITE_OWNER | WRITE_DAC;
        create_options = FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_FOR_RECOVERY;
        break;
d577 1
a577 1
        create_options = 0;
d639 1
a639 1
  			 create_disposition, create_options, NULL, 0);
d657 1
a657 1
  		  "(%p, %x, %s, io, NULL, %x, %x, %x, %x, NULL, 0)",
d813 1
a813 1
	         is writing after a long seek beyond EOF, convert the file to
d818 1
a818 1
	      				0, &dw, NULL);
d825 1
a825 1
	         disk instead of some known (safe) value, so we must seek
d827 2
a828 2
	         Note: this bug doesn't happen on NT4, even though the
	         documentation for WriteFile() says that it *may* happen
d1087 1
a1087 1
        res += (_off64_t) *poff_high << 32;
@


1.193
log
@	* fhandler.cc (fhandler_base::open): Call path_conv::get_nt_native_path
	for evaluating NT path.
	* path.cc (normalize_posix_path): Remove trailing dots and spaces.
	(path_conv::get_nt_native_path): New function.
	* path.h (class path_conv): Declare get_nt_native_path method.
@
text
@d634 2
@


1.192
log
@	* fhandler.cc (fhandler_base::open): Fix NT native path evaluation
	to allow opening serial ports.
@
text
@d558 2
a559 20
  if (get_win32_name ()[0] != '\\')		/* X:\...  or NUL, etc. */
    {
      str2buf2uni (upath, wpath, "\\??\\");
      str2buf2uni_cat (upath, get_win32_name ());
    }
  else if (get_win32_name ()[1] != '\\')	/* \Device\... */
    str2buf2uni (upath, wpath, get_win32_name ());
  else if (get_win32_name ()[2] != '.'
  	   || get_win32_name ()[3] != '\\')	/* \\server\share\... */
    {
      str2buf2uni (upath, wpath, "\\??\\UNC\\");
      str2buf2uni_cat (upath, get_win32_name () + 2);
    }
  else						/* \\.\device */
    {
      str2buf2uni (upath, wpath, "\\??\\");
      str2buf2uni_cat (upath, get_win32_name () + 4);
    }

  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
@


1.191
log
@	* syscalls.cc (lseek64): Fix debug_printf format string.
	(truncate64): Ditto.

	* fhandler.cc (fhandler_base::lseek): Force res to -1 on error.
@
text
@d557 2
a558 1
  if (get_win32_name ()[0] == '\\')
d560 2
a561 7
      if (get_win32_name ()[1] == '\\')
        {
	  str2buf2uni (upath, wpath, "\\??\\UNC");
	  str2buf2uni_cat (upath, get_win32_name () + 1);
	}
      else
	str2buf2uni (upath, wpath, get_win32_name ());
d563 9
a571 1
  else
d574 1
a574 1
      str2buf2uni_cat (upath, get_win32_name ());
d576 1
@


1.190
log
@	* fhandler_disk_file.cc (fhandler_base::open_fs): Change
	set_file_attribute call to indicate that NT security isn't used.
	(fhandler_disk_file::fchmod): Rearrange to isolate 9x related
	statements.
	Do not set FILE_ATTRIBUTE_SYSTEM.
	(fhandler_disk_file::fchown): Check noop case first.
	* fhandler.cc (fhandler_base::open9x): Remove ntsec related statements.
	(fhandler_base::set_name): Do not set namehash.
	* fhandler.h (fhandler_base::get_namehash): Compute and set namehash if
	needed.
	* syscalls.cc (access): Verify that fh is not NULL. Do not set PC_FULL.
	(chmod): Ditto.
	(chown_worker): Ditto.
	(stat_worker): Ditto. Verify if the path exists.
@
text
@d1093 1
@


1.189
log
@	* fhandler.cc (fhandler_base::open): Remove special DEV_FLOPPY_MAJOR
	treatment.
	* fhandler_raw.cc (fhandler_dev_raw::open): Simplify write-only case.
	* fhandler_tape.cc (fhandler_dev_tape::raw_write): Add accidentally
	dropped condition.
@
text
@a154 1
  namehash = hash_path_name (0, get_win32_name ());
a436 1
  security_descriptor sd;
a492 5
  /* If the file should actually be created and ntsec is on,
     set files attributes. */
  if (flags & O_CREAT && get_device () == FH_FS && allow_ntsec && has_acls ())
    set_security_attribute (mode, &sa, sd);

d498 1
a498 1
      if (!wincap.can_open_directories () && pc.isdir ())
@


1.188
log
@	* fhandler.cc (fhandler_base::open): Add FILE_READ_ATTRIBUTES when
	only GENERIC_WRITE access is requested.
@
text
@d610 1
a610 5
	/* Allow reliable lseek on disk devices. */
	if (get_major () == DEV_FLOPPY_MAJOR)
	  access |= GENERIC_READ;
	else if (get_major () != DEV_SERIAL_MAJOR
		 && get_major () != DEV_TAPE_MAJOR)
@


1.187
log
@	* errno.cc (errmap): Handle ERROR_IO_PENDING.
	* fhandler.cc (fhandler_base::open): Make tape I/O asynchronous.
	* fhandler.h (class fhandler_dev_tape): Add mt_evt member.
	* fhandler_tape.cc (mtinfo_drive::initialize): Initialize async_writes.
	(mtinfo_drive::close): Handle async writes.
	(mtinfo_drive::read): Add mt_evt parameter.  Use overlapped I/O.
	(mtinfo_drive::async_wait): New function.
	(mtinfo_drive::write): Add mt_evt parameter.  Use overlapped I/O.
	Handle async writes.
	(mtinfo_drive::_set_pos): Handle async writes.
	(mtinfo_drive::set_partition): Ditto.
	(mtinfo_drive::prepare): Ditto.
	(mtinfo_drive::get_status): Drop useless "else".  Handle async_writes
	flag.
	(mtinfo_drive::set_options): Handle async_writes flags.
	(fhandler_dev_tape::close): Close mt_evt handle.
	(fhandler_dev_tape::raw_read): Create mt_evt handle and use in call
	to mtinfo_drive::read.
	(fhandler_dev_tape::raw_write): Create mt_evt handle and use in call
	to mtinfo_drive::write.
	* mtinfo.h (MTINFO_VERSION): Bump.
	(enum dirty_state): Add async_write_pending state.
	(class mtinfo_drive): Add OVERLAPPED struct "ov".  Add async_writes
	flag.
	(mtinfo_drive::async_wait): Add declaration.
	(mtinfo_drive::read): Add mt_evt parameter.
	(mtinfo_drive::write): Ditto.

	* registry.cc (load_registry_hive): Call enable_restore_privilege
	instead of set_process_privilege.
@
text
@d607 1
a607 1
	  access = GENERIC_WRITE;
@


1.186
log
@	* autoload.cc (NtCreateFile): Add.
	* dir.cc (mkdir): Change set_file_attribute call to indicate that
	NT security isn't used.
	* fhandler.cc (fhandler_base::open_9x): New method, created from
	fhandler_base::open.
	(fhandler_base::open): Rearrange to use NtCreateFile instead of
	CreateFile.
	* fhandler.h (enum query_state): Redefine query_null_access to
	query_stat_control.  query_null_access isn't allowed in NtCreateFile.
	(fhandler_base::open_9x): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use
	query_stat_control first, query_read_control if that fails.
	(fhandler_disk_file::fchmod): Call enable_restore_privilege before
	trying to open for query_write_control.  Don't fall back to
	opening for query_read_control.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl):  Only request restore privilege and query
	access necessary for given cmd.
	* fhandler_raw.cc (fhandler_dev_raw::open): Call fhandler_base::open
	instead of opening device here.
	* ntdll.h (NtCreateFile): Declare.
	* path.cc (symlink_worker): Change set_file_attribute call to indicate
	that NT security isn't used.
	* sec_acl.cc (getacl): Fix bracketing.
	* sec_helper.cc (enable_restore_privilege): New function.
	* security.cc (str2buf2uni_cat): New function.
	(write_sd): Don't request restore permission here.
	* security.h (set_process_privileges): Drop stale declaration.
	(str2buf2uni): Declare.
	(str2buf2uni_cat): Declare.
	(enable_restore_privilege): Declare.
	* syscalls.cc (fchown32): Return immediate success on 9x.
@
text
@d613 2
a614 1
	else if (get_major () != DEV_SERIAL_MAJOR)
@


1.185
log
@	* fhandler.cc (fhandler_base::open): Simplify access evaluation
	expression.
	(fhandler_base::facl): New method.
	* fhandler.h: Declare facl method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): New method.
	* fhandler_virtual.cc (fhandler_virtual::facl): New method.
	* sec_acl.cc: Remove forward declaration for aclsort32 and acl32.
	(setacl): Remove static.  Add and use handle parameter.
	(getacl): Ditto.
	(acl_worker): Reorganize to call fhandler's facl method eventually.
	(facl32): Ditto.
	* security.cc (get_nt_object_security): Remove static.
	* security.h: Add extern declarations for get_nt_object_security,
	aclsort32, acl32, getacl and setacl.


	Apply missing syscalls.cc patch and ChangeLog of previous check in.
	* syscalls.cc (chown_worker): Reorganize to call fhandler's fchown
	method eventually.
	(fchown): Ditto.
@
text
@d31 2
d430 1
a430 1
fhandler_base::open (int flags, mode_t mode)
d440 1
a440 1
  syscall_printf ("(%s, %p) query_open %d", get_win32_name (), flags, query_open ());
d448 6
a453 28
  switch (query_open ())
    {
      case query_null_access:
	access = 0;
	break;
      case query_read_control:
	access = READ_CONTROL;
	break;
      case query_write_control:
	access = READ_CONTROL | WRITE_OWNER | WRITE_DAC;
	break;
      default:
	if (get_major () == DEV_TAPE_MAJOR)
	  access = GENERIC_READ | GENERIC_WRITE;
	else if ((flags & (O_RDONLY | O_WRONLY | O_RDWR)) == O_RDONLY)
	  access = GENERIC_READ;
	else if ((flags & (O_RDONLY | O_WRONLY | O_RDWR)) == O_WRONLY)
	  access = GENERIC_WRITE;
	else
	  access = GENERIC_READ | GENERIC_WRITE;
        break;
    }

  /* Allow reliable lseek on disk devices. */
  if (get_major () == DEV_FLOPPY_MAJOR)
    access |= GENERIC_READ;

  /* FIXME: O_EXCL handling?  */
a490 10
  /* CreateFile() with dwDesiredAccess == 0 when called on remote
     share returns some handle, even if file doesn't exist. This code
     works around this bug. */
  if (query_open () && isremote () &&
      creation_distribution == OPEN_EXISTING && !pc.exists ())
    {
      set_errno (ENOENT);
      goto done;
    }

d525 156
@


1.184
log
@	* fhandler.cc (fhandler_base::open): Accomodate query_write_control
	query_state.
	(fhandler_base::fchown): New method.
	* fhandler.h: Declare fchown method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	(enum query_state): Add query_write_control.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Set query_state
	to query_write_control.  Only remove FILE_ATTRIBUTE_READONLY if not
	setting security descriptor.
	(fhandler_disk_file::fchown): New method.
	* fhandler_virtual.cc (fhandler_virtual::fchown): New method.
	* sec_acl.cc (setacl): Call write_sd with additional handle attribute.
	* security.cc (write_sd): Take handle argument.  Only request owner
	if getting SE_RESTORE_NAME privilege failed.  Only open file if
	NtSetSecurityObject failed or handle is NULL.
	(set_nt_attribute): Call write_sd with additional handle attribute.
	* security.h (write_sd): Declare with additional handle argument.
@
text
@d16 1
d446 22
a467 21
  if (query_open ())
    switch (query_open ())
      {
	case query_null_access:
	  access = 0;
	  break;
	case query_read_control:
	  access = READ_CONTROL;
	  break;
	case query_write_control:
	  access = READ_CONTROL | WRITE_OWNER | WRITE_DAC;
	  break;
      }
  else if (get_major () == DEV_TAPE_MAJOR)
    access = GENERIC_READ | GENERIC_WRITE;
  else if ((flags & (O_RDONLY | O_WRONLY | O_RDWR)) == O_RDONLY)
    access = GENERIC_READ;
  else if ((flags & (O_RDONLY | O_WRONLY | O_RDWR)) == O_WRONLY)
    access = GENERIC_WRITE;
  else
    access = GENERIC_READ | GENERIC_WRITE;
d1430 7
@


1.183
log
@	* dir.cc (mkdir): Call set_file_attribute with additional handle
	argument.
	* fhandler.cc (fhandler_base::fchmod): New method.
	* fhandler.h: Declare fchmod method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): New method.
	(fhandler_base::open_fs): Call set_file_attribute with additional
	handle argument.
	* fhandler_virtual.cc (fhandler_virtual::fchmod): New method.
	* path.cc (symlink_worker): Call set_file_attribute with additional
	handle argument.
	* security.cc (get_nt_object_security): New function.
	(get_nt_object_attribute): Call get_nt_object_security.
	(set_nt_attribute): Add handle argument.  Call get_nt_object_security
	first, read_sd only if that fails.
	(set_file_attribute): Add handle argument.
	* security.h (set_file_attribute): Declare with additional handle
	argument.
	* syscalls.cc (stat_suffixes): Move to beginning of file.
	(chown_worker): Call set_file_attribute with additional handle argument.
	(chmod): Reorganize to call fhandler's fchmod method eventually.
	(fchmod): Ditto.
@
text
@d446 12
a457 1
    access = (query_open () == query_read_control ? READ_CONTROL : 0);
d1421 7
@


1.182
log
@	* fhandler.cc (rootdir): Add and use second argument.
	* winsup.h (rootdir): Add second argument in declaration.
	* path.cc (fs_info::update): Modify call to rootdir.
	* syscalls.cc (check_posix_perm): Ditto.
	(statfs): Ditto. Move syscall_printf near top.
@
text
@d1407 7
@


1.181
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d1031 1
a1031 1
rootdir (char *full_path)
a1035 1
   * else current drive.
d1037 2
a1038 1
  char *root = full_path;
d1041 4
a1044 1
    strcpy (full_path + 2, "\\");
d1047 7
a1053 12
      char *cp = full_path + 2;
      while (*cp && *cp != '\\')
	cp++;
      if (!*cp)
	{
	  set_errno (ENOTDIR);
	  return NULL;
	}
      cp++;
      while (*cp && *cp != '\\')
	cp++;
      strcpy (cp, "\\");
d1056 5
a1060 1
    root = NULL;
d1062 3
a1064 1
  return root;
@


1.180
log
@	* fhandler.cc (fhandler_base::write): Use bool parameter in calls to
	set_did_lseek.
	(fhandler_base::fhandler_base): Accomodate new status and open_status
	constructor.
	* fhandler.h: Remove status bit enumerator.
	(FHDEVN): Remove.
	(FHISSETF): Remove.
	(FHSETF): Remove.
	(FHCLEARF): Remove.
	(FHCONDSETF): Remove.
	(FHSTATOFF): Remove.
	(UNCONNECTED, CONNECT_PENDING, CONNECTED): Substitute by enum
	connect_state.
	(fhandler_base::status): Define as bitfield struct type status_flags.
	Remove unused flags entirely.  Accomodate all status access methods.
	(open_status): Define as bitfield struct type status_flags.
	(fhandler_socket): Move socket related status bits to here.  Redefine
	had_connect_or_listen to be part of these status bits.  Accomodate
	related access methods.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Use pc.issymlink
	instead of dropped method get_symlink_p.
	(fhandler_base::open_fs): Remove setting dropped status flags.
	* fhandler_socket.cc: Use values from enum connect_state throughout.
	(fhandler_socket::fhandler_socket): Initialize status bits.
	* fhandler_virtual.cc (fhandler_virtual::open): Remove setting dropped
	status flags.
	* net.cc: Use values from enum connect_state throughout.
	* select.cc: Ditto.
	* shared_info.h: Protect struct console_state using _FHANDLER_H_
	instead of FHDEVN.
@
text
@d183 2
a184 2
  else if (get_r_binset () && get_w_binset ())
    bin = get_r_binary () ? O_BINARY : O_TEXT;	// FIXME: Not quite right
d192 1
a192 1
    bin = get_w_binary () || get_r_binary () || (binmode != O_TEXT)
d198 2
a199 2
  set_r_binary (bin);
  set_w_binary (bin);
d437 1
a437 1
  syscall_printf ("(%s, %p) query_open %d", get_win32_name (), flags, get_query_open ());
d445 2
a446 2
  if (get_query_open ())
    access = get_query_open () == query_read_control ? READ_CONTROL : 0;
d478 1
a478 1
    set_append_p ();
d501 1
a501 1
  if (get_query_open () && isremote () &&
d529 1
a529 1
	    set_nohandle (true);
d535 1
a535 1
      if (!get_nohandle ())
d600 1
a600 1
  if (get_r_binary () || len <= 0)
d663 1
a663 2
  debug_printf ("returning %d, %s mode", len,
		get_r_binary () ? "binary" : "text");
d672 1
a672 1
  if (get_append_p ())
d674 1
a674 1
  else if (get_did_lseek ())
d680 1
a680 1
      set_did_lseek (false); /* don't do it again */
d747 1
a747 1
  if (get_w_binary ())
d972 1
a972 1
      set_did_lseek (true);
d990 1
a990 1
  if (get_nohandle () || CloseHandle (get_handle ()))
d1111 1
a1111 1
  debug_printf ("created new fhandler_base for handle %p, bin %d", f, get_r_binary ());
d1126 1
a1126 1
  if (!get_nohandle ())
d1150 1
a1150 1
      res = get_close_on_exec () ? FD_CLOEXEC : 0;
d1153 1
a1153 1
      set_close_on_exec ((int) arg);
d1322 1
a1322 1
  if (/* !is_socket () && */ !get_close_on_exec ())
d1324 1
a1324 1
  else if (!DuplicateHandle (parent, h, hMainProc, &h, 0, !get_close_on_exec (),
d1332 1
a1332 1
fhandler_base::set_close_on_exec (int val)
d1334 1
a1334 1
  if (!get_nohandle ())
d1336 1
a1336 1
  set_close_on_exec_flag (val);
d1344 1
a1344 1
  if (!get_nohandle ())
@


1.179
log
@	* fhandler.cc (fhandler_base::open): Set query access mode according
	to query_open setting.
	(fhandler_base::fhandler_base): Initialize query_open.
	* fhandler.h (FH_QUERYOPEN): Drop.
	(enum query_state): Add.
	(class fhandler_base): Add query_open member.
	(fhandler_base::get_query_open): Redefine to use query_open.
	(fhandler_base::set_query_open): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Remove O_DIROPEN
	from open_flags since it's added in open_fs anyway.  Remove
	query_open_already.  Use new query_open settings.  Rearrange slightly.
	(fhandler_base::fstat_helper): Add get_io_handle as parameter to
	get_file_attribute.
	* security.cc (get_nt_object_attribute): Make returning an int.
	Return -1 on error, 0 otherwise.
	(get_file_attribute): Take an object handle as argument. Move down
	to allow calling get_nt_object_attribute in case a non-NULL handle
	is given.
	* security.h (get_file_attribute): Add handle to argument list.
	* syscalls.cc (chown_worker): Accomodate new definition of
	get_file_attribute.
@
text
@d681 1
a681 1
      set_did_lseek (0); /* don't do it again */
d973 1
a973 1
      set_did_lseek ();
d1259 3
a1261 3
fhandler_base::fhandler_base ():
  status (0),
  query_open (no_query),
a1270 1
  open_status (0),
@


1.178
log
@white space fixup
@
text
@d446 1
a446 1
    access = 0;
d1261 1
@


1.177
log
@* Makefile.in (clean): Clean libserver, too.
* fhandler.cc (fhandler_base::~fhandler_base): Remove path_conv cleanup.
* syscalls.cc (chroot): Ditto.
* path.cc (path_conv::~path_conv): Define new destructor.
(conv_path_list_buf_size): Remove explicit path_conv cleanup.
* path.h (path_conv::~path_conv): Declare new destructor.
@
text
@d532 1
a532 1
       set_errno (ENOENT);
d534 1
a534 1
       __seterrno ();
d536 1
a536 1
       goto done;
@


1.176
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@a1280 2
  if (!pc.normalized_path_size && pc.normalized_path)
    cfree (pc.normalized_path);
@


1.175
log
@Throughout, change name from set_inheritance to set_no_inheritance to better
reflect input arguments of this function.
* cygheap.h (CYGHEAPSIZE): Increase size of cygheap to something closer to the
21st century.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.174
log
@* fhandler.cc (fhandler_base::fhaccess): Avoid always setting errno to EACCESS
when return value is < 0.  Rely on errno being set properly.
@
text
@d1302 1
a1302 1
fhandler_base::set_inheritance (HANDLE &h, int not_inheriting)
d1338 1
a1338 1
    set_inheritance (io_handle, val);
@


1.173
log
@* fhandler.h (fhandler_base::fhaccess): Return int for compatibility with
access.
* fhandler.cc (fhandler_base::fhaccess): Return int.  Use consistent variable
name for exit value.  Exit at bottom, printing debugging information, like
other cygwin functions.
@
text
@d356 2
d359 1
a359 1
      set_errno (EACCES);
a361 2
  else if (has_acls () && allow_ntsec)
    return check_file_access (get_win32_name (), flags);
d372 1
a372 1
	    goto done;
d377 1
a377 1
	    goto done;
d380 1
a380 1
	goto done;
d388 1
a388 1
	    goto done;
d393 1
a393 1
	    goto done;
d396 1
a396 1
	goto done;
d404 1
a404 1
	    goto done;
d409 1
a409 1
	    goto done;
d412 1
a412 1
	goto done;
d414 1
d416 4
a420 2
  if (res)
    set_errno (EACCES);
@


1.172
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@d334 1
a334 1
bool
d337 1
d341 1
a341 1
      return -1;
d347 1
a347 1
      return -1;
d358 1
a358 1
      return -1;
d364 3
a366 4
  int r = fstat (&st);
  if (r)
    return -1;
  r = -1;
d382 1
d398 1
d414 1
a414 1
  r = 0;
d416 1
a416 1
  if (r)
d418 2
a419 1
  return r;
@


1.171
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d331 86
a416 1
  return access_worker (pc, mode, this);
@


1.170
log
@* fhandler.cc (fhandler_base::open): Revert isfs change.
@
text
@d1047 1
a1212 1
#ifdef DEBUGGING_AND_FDS_PROTECTED
a1213 1
#endif
d1219 1
a1219 1
  if (!DuplicateHandle (hMainProc, h, hMainProc, &h, 0, !not_inheriting,
d1222 2
d1233 1
d1239 2
a1240 6
#ifdef DEBUGGING_AND_FDS_PROTECTED
  else if (get_close_on_exec ())
    ProtectHandle (h);	/* would have to be fancier than this */
  else
    /* ProtectHandleINH (h) */;	/* Should already be protected */
#endif
@


1.169
log
@* fhandler.cc (fhandler_base::open): Use major numbers rather than device
numbers to control special behavior for devices which take units.
* fhandler_raw.cc (fhandler_dev_raw::writebuf): Ditto.
(fhandler_dev_raw::fstat): Ditto.
(fhandler_dev_raw::open): Ditto.
(fhandler_dev_raw::ioctl): Ditto.
@
text
@d399 1
a399 1
  if (flags & O_CREAT && dev ().isfs ())
d423 1
a423 1
  if (flags & O_CREAT && dev ().isfs () && allow_ntsec && has_acls ())
@


1.168
log
@* winsup.h (access_worker): Declare with added fhandler_base parameter.
* syscalls.cc (access_worker): Accommodate extra fhandler_base argument.  Use
it instead of stat_worker to determine stat information, when appropriate.
* fhandler.cc (fhandler_base::device_access_denied): Pass fhandler pointer to
access_worker so that it can use the proper method for determining stat
information.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
@
text
@d356 1
a356 1
  else if (get_device () == FH_TAPE)
d366 1
a366 1
  if (get_device () == FH_FLOPPY)
d395 1
a395 1
  if (get_device () == FH_SERIAL)
d399 1
a399 1
  if (flags & O_CREAT && get_device () == FH_FS)
d423 1
a423 1
  if (flags & O_CREAT && get_device () == FH_FS && allow_ntsec && has_acls ())
@


1.168.6.1
log
@* devices.in: Change raw com device to more correct form.
* fhandler.cc (fhandler_base::open): Use major numbers rather than device
numbers to control special behavior for devices which take units.
* fhandler_raw.cc (fhandler_dev_raw::writebuf): Ditto.
(fhandler_dev_raw::fstat): Ditto.
(fhandler_dev_raw::open): Ditto.
(fhandler_dev_raw::ioctl): Ditto.
@
text
@d356 1
a356 1
  else if (get_major () == DEV_TAPE_MAJOR)
d366 1
a366 1
  if (get_major () == DEV_FLOPPY_MAJOR)
d395 1
a395 1
  if (get_major () == DEV_SERIAL_MAJOR)
d399 1
a399 1
  if (flags & O_CREAT && dev ().isfs ())
d423 1
a423 1
  if (flags & O_CREAT && dev ().isfs () && allow_ntsec && has_acls ())
@


1.168.6.2
log
@missed checkin
@
text
@d399 1
a399 1
  if (flags & O_CREAT && get_device () == FH_FS)
d423 1
a423 1
  if (flags & O_CREAT && get_device () == FH_FS && allow_ntsec && has_acls ())
@


1.168.6.3
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a1046 1
      VerifyHandle (nh);
d1212 1
d1214 1
d1220 1
a1220 1
  if (!DuplicateHandle (hMainProc, oh, hMainProc, &h, 0, !not_inheriting,
a1222 2
  if (oh != h)
    VerifyHandle (h);
a1231 1
  HANDLE oh = h;
d1237 6
a1242 2
  else if (oh != h)
    VerifyHandle (h);
@


1.168.6.4
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@d331 1
a331 86
  return fhaccess (mode);
}

bool
fhandler_base::fhaccess (int flags)
{
  if (error ())
    {
      set_errno (error ());
      return -1;
    }

  if (!exists ())
    {
      set_errno (ENOENT);
      return -1;
    }

  if (!(flags & (R_OK | W_OK | X_OK)))
    return 0;

  if (is_fs_special ())
    /* short circuit */;
  else if (has_attribute (FILE_ATTRIBUTE_READONLY) && (flags & W_OK))
    {
      set_errno (EACCES);
      return -1;
    }
  else if (has_acls () && allow_ntsec)
    return check_file_access (get_win32_name (), flags);

  struct __stat64 st;
  int r = fstat (&st);
  if (r)
    return -1;
  r = -1;
  if (flags & R_OK)
    {
      if (st.st_uid == myself->uid)
	{
	  if (!(st.st_mode & S_IRUSR))
	    goto done;
	}
      else if (st.st_gid == myself->gid)
	{
	  if (!(st.st_mode & S_IRGRP))
	    goto done;
	}
      else if (!(st.st_mode & S_IROTH))
	goto done;
    }
  if (flags & W_OK)
    {
      if (st.st_uid == myself->uid)
	{
	  if (!(st.st_mode & S_IWUSR))
	    goto done;
	}
      else if (st.st_gid == myself->gid)
	{
	  if (!(st.st_mode & S_IWGRP))
	    goto done;
	}
      else if (!(st.st_mode & S_IWOTH))
	goto done;
    }
  if (flags & X_OK)
    {
      if (st.st_uid == myself->uid)
	{
	  if (!(st.st_mode & S_IXUSR))
	    goto done;
	}
      else if (st.st_gid == myself->gid)
	{
	  if (!(st.st_mode & S_IXGRP))
	    goto done;
	}
      else if (!(st.st_mode & S_IXOTH))
	goto done;
    }
  r = 0;
done:
  if (r)
    set_errno (EACCES);
  return r;
@


1.168.6.5
log
@* fhandler.h (fhandler_base::fhaccess): Return int for compatibility with
access.
* fhandler.cc (fhandler_base::fhaccess): Return int.  Use consistent variable
name for exit value.  Exit at bottom, printing debugging information, like
other cygwin functions.
@
text
@d334 1
a334 1
int
a336 1
  int res = -1;
d340 1
a340 1
      goto done;
d346 1
a346 1
      goto done;
d357 1
a357 1
      goto done;
d363 4
a366 3
  if (fstat (&st))
    goto done;

a381 1

a396 1

d412 1
a412 1
  res = 0;
d414 1
a414 1
  if (res)
d416 1
a416 2
  debug_printf ("returning %d", res);
  return res;
@


1.168.6.6
log
@* fhandler.cc (fhandler_base::fhaccess): Avoid always setting errno to EACCESS
when return value is < 0.  Rely on errno being set properly.
@
text
@a355 2
    goto eaccess_done;
  else if (has_acls () && allow_ntsec)
d357 1
a357 1
      res = check_file_access (get_win32_name (), flags);
d360 2
d372 1
a372 1
	    goto eaccess_done;
d377 1
a377 1
	    goto eaccess_done;
d380 1
a380 1
	goto eaccess_done;
d388 1
a388 1
	    goto eaccess_done;
d393 1
a393 1
	    goto eaccess_done;
d396 1
a396 1
	goto eaccess_done;
d404 1
a404 1
	    goto eaccess_done;
d409 1
a409 1
	    goto eaccess_done;
d412 1
a412 1
	goto eaccess_done;
a413 1

a414 4
  goto done;

eaccess_done:
  set_errno (EACCES);
d416 2
@


1.167
log
@* cygheap.h (cygheap_types): Add HEAP_ARCHETYPES.
(init_cheap::ctty): Change to pointer.
* dtable.h (dtable::find_archetype): Declare new function.
(dtable::add_archetype): Declare new function.
(dtable::delete_archetype): Declare new function.
(dtable::narchetypes): Declare.
(dtable::farchetypes): Declare.
(dtable::initial_archetype_size): Declare.
(dtable::dtable): Initialize new fields.
(dtable::initial_archetype_size): Declare.
* dtable.cc (dtable::find_archetype): Define new function.
(dtable::add_archetype): Define new function.
(dtable::delete_archetype): Define new function.
(dtable::initial_archetype_size): Define.
* fhandler.h (fhandler_base::archetype): Declare.
(fhandler_base::usecount): Declare.
* fhandler.cc (fhandler_base::fhandler_base): Initialize new fields.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass NULL to third
argument of set_ctty.
* fhandler_tty.cc (fhandler_tty_slave::open): Accommodate new archetype method
to create only one instance of a tty.
(fhandler_tty_slave::close): Don't close handles unless archetype usecount is
zero.  When that happens, close archetype too.
(fhandler_tty_slave::dup): Just copy archetype.  Set use count appropriately.
Set ctty, if appropriate.
(fhandler_tty_common::dup): Remove slave considerations.
(fhandler_tty_common::set_close_on_exec): Remove cygheap->ctty considerations.
* pinfo.cc (_pinfo::set_ctty): Accommodate new archetype methods.
* pinfo.h (_pinfo::set_ctty): Make third argument explicit.
* syscalls.cc (close_all_files): Decrement controlling tty use count before
closing all handles to allow controlling tty to be closed.  Remove previous
controlling tty considerations.
@
text
@d331 1
a331 1
  return access_worker (pc, mode);
@


1.166
log
@	Substitute 0x7fffffff and 0xffffffff by INT32_MAX and UINT32_MAX
	throughout, except in assembler code.
@
text
@d1180 3
a1182 1
  read_state (NULL)
@


1.165
log
@	* Makefile.in (OBSOLETE_FUNCTIONS): Add fcntl.
	(NEW_FUNCTIONS): Add fcntl64.
	* cygwin.din: Export fcntl64.  Make fcntl being SIGFE.
	* fcntl.cc (fcntl_worker): New function.
	(fcntl64): New function.
	(_fcntl): Call fcntl_worker.  Convert 32 bit flock structure into
	64 bit flock structure and vice versa.
	* fhandler.cc (fhandler_base::lock): Change 2nd parameter to
	struct __flock64 *.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Ditto.  Rework
	to be 64 bit aware.
	* fhandler.h: Accomodate above method argument changes.
	* include/cygwin/types.h: Add struct __flock32 and __flock64.
	Define struct flock according to setting of __CYGWIN_USE_BIG_TYPES__.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d859 1
a859 1
  LONG off_low = ((__uint64_t) offset) & 0xffffffffLL;
@


1.164
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d934 1
a934 1
fhandler_base::lock (int, struct flock *)
d1091 1
a1091 1
      res = lock (cmd, (struct flock *) arg);
@


1.163
log
@	* dir.cc (mkdir): Use local security_descriptor. Call
	set_security_attribute appropriately.
	* external.cc (cygwin_internal): Ditto.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
	* sec_acl.cc (setacl): Ditto. Call read_sd appropriately.
	(getace): Ditto.
	* sec_helper.cc (security_descriptor::malloc): New method.
	(security_descriptor::realloc): New method.
	(security_descriptor::free): New method.
	* security.cc (read_sd): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	Allocate the security_descriptor buffer according to size returned by
	a call to GetFileSecurity. Return buffer size on success.
	(write_sd): Get security_descriptor as parameter instead of
	PSECURITY_DESCRIPTOR and a size.
	(get_nt_attribute): Use local security_descriptor.
	(get_nt_object_attribute): Ditto in case of type == SE_REGISTRY_KEY.
	Allocate security_descriptor buffer according to size returned by
	a call to RegGetKeySecurity.
	(alloc_sd): Make static. Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	(set_security_attribute): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size.
	(set_nt_attribute): Use local security_descriptor.
	(check_file_access): Ditto.
	* security.h: Add class security_descriptor.
	(read_sd): Change declaration to get security_descriptor as parameter
	instead of PSECURITY_DESCRIPTOR and a size.
	(write_sd): Ditto.
	(set_security_attribute): Ditto.
	(alloc_sd): Remove declaration.
	* thread.cc (semaphore::semaphore): Use local security_descriptor. Call
	set_security_attribute appropriately.
@
text
@a322 1
  int access_worker (path_conv&, int);
@


1.162
log
@	* fhandler.cc (fhandler_base::lseek): Include high order offset
	bits in return value.
@
text
@d345 1
d425 1
a425 1
    set_security_attribute (mode, &sa, alloca (4096), 4096);
@


1.161
log
@	* fhandler.cc (fhandler_base::ioctl): Handle FIONBIO.
@
text
@d877 3
@


1.160
log
@	* fhandler.cc (fhandler_base::fcntl): Don't clobber O_APPEND when
	both O_NONBLOCK/O_NDELAY are set for F_SETFL.
@
text
@d912 1
a912 4
  if (cmd == FIONBIO)
    syscall_printf ("ioctl (FIONBIO, %p)", buf);
  else
    syscall_printf ("ioctl (%x, %p)", cmd, buf);
d914 14
a927 2
  set_errno (EINVAL);
  return -1;
@


1.159
log
@	* fhandler.cc (fhandler_base::fstat): Drop FH_FLOPPY case.
@
text
@d1071 1
a1071 1
	  new_flags = O_NONBLOCK;
@


1.158
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@a979 3
    case FH_FLOPPY:
      buf->st_mode = S_IFBLK | STD_RBITS | STD_WBITS | S_IWGRP | S_IWOTH;
      break;
@


1.157
log
@* Makefile.in: Make malloc_wrapper -fomit-frame-pointer.
* cygwin.din: Remove extraneous mallinfo definition.
* dcrt0.cc (quoted): Use strechr for efficiency.
* fhandler.cc (fhandler_base::write): Correctly use get_output_handle rather
than get_handle.
(fhandler_base::lseek): Use method for accessing name in debug output.
@
text
@d21 1
a22 1
#include "path.h"
d38 1
a38 1
fhandler_base::operator =(fhandler_base &x)
d41 1
a41 2
  unix_path_name = x.unix_path_name ? cstrdup (x.unix_path_name) : NULL;
  win32_path_name = x.win32_path_name ? cstrdup (x.win32_path_name) : NULL;
d146 3
a148 7
/* Record the file name.
   Filenames are used mostly for debugging messages, and it's hoped that
   in cases where the name is really required, the filename wouldn't ever
   be too long (e.g. devices or some such).
   The unix_path_name is also used by virtual fhandlers.  */
bool
fhandler_base::set_name (const char *unix_path, const char *win32_path, int unit)
d150 3
a152 49
  if (unix_path == NULL || !*unix_path)
    return false;

  if (win32_path)
    win32_path_name = cstrdup (win32_path);
  else
    {
      const char *fmt = get_native_name ();
      char *w =  (char *) cmalloc (HEAP_STR, strlen (fmt) + 16);
      if (w)
	__small_sprintf (w, fmt, unit);
      win32_path_name = w;
    }

  if (win32_path_name == NULL)
    {
      system_printf ("fatal error. strdup failed");
      set_errno (ENOMEM);
      return false;
    }

  assert (unix_path_name == NULL);
  /* FIXME: This isn't really right.  It ignores the first argument if we're
     building names for a device and just converts the device name from the
     win32 name since it has theoretically been previously detected by
     path_conv. Ideally, we should pass in a format string and build the
     unix_path, too. */
  if (!is_device () || *win32_path_name != '\\')
    unix_path_name = unix_path;
  else
    {
      char *p = cstrdup (win32_path_name);
      unix_path_name = p;
      if (p)
	while ((p = strchr (p, '\\')) != NULL)
	  *p++ = '/';
      if (unix_path)
	cfree ((void *) unix_path);
    }

  if (unix_path_name == NULL)
    {
      system_printf ("fatal error. strdup failed");
      free ((void *) win32_path_name);
      set_errno (ENOMEM);
      return false;
    }
  namehash = hash_path_name (0, win32_path_name);
  return true;
d260 1
a260 1
	  syscall_printf ("ReadFile %s failed, %E", unix_path_name);
d276 1
a276 1
  if (!WriteFile (get_handle (), ptr, len, &bytes_written, 0))
d319 16
d337 1
a337 1
fhandler_base::open (path_conv *pc, int flags, mode_t mode)
d399 1
a399 1
  if (flags & O_CREAT && get_device () == FH_DISK)
d411 1
a411 1
      creation_distribution == OPEN_EXISTING && pc && !pc->exists ())
d423 1
a423 1
  if (flags & O_CREAT && get_device () == FH_DISK && allow_ntsec && has_acls ())
d431 9
a439 9
      if (!wincap.can_open_directories () && pc && pc->isdir ())
       {
	 if (flags & (O_CREAT | O_EXCL) == (O_CREAT | O_EXCL))
	   set_errno (EEXIST);
	 else if (flags & (O_WRONLY | O_RDWR))
	   set_errno (EISDIR);
	 else
	   set_nohandle (true);
       }
d453 1
a453 1
  set_flags (flags, pc ? pc->binmode () : 0);
d962 1
a962 1
fhandler_base::fstat (struct __stat64 *buf, path_conv *)
d965 4
d1158 2
a1159 2
fhandler_base::fhandler_base (DWORD devtype, int unit):
  status (devtype),
a1168 2
  unix_path_name (NULL),
  win32_path_name (NULL),
d1178 2
a1179 4
  if (unix_path_name != NULL)
    cfree ((void *) unix_path_name);
  if (win32_path_name != NULL)
    cfree ((void *) win32_path_name);
a1181 1
  unix_path_name = win32_path_name = NULL;
d1188 1
a1188 1
	fhandler_base (FH_NULL)
d1266 1
a1266 1
fhandler_base::opendir (path_conv&)
@


1.156
log
@Remove left coercion throughout.
@
text
@d618 1
a618 1
    SetFilePointer (get_handle (), 0, 0, FILE_END);
d627 1
a627 1
      actual_length = GetFileSize (get_handle (), &size_high);
d630 1
a630 1
      current_position = SetFilePointer (get_handle (), 0, &pos_high,
d643 1
a643 1
	      HANDLE h = get_handle ();
d660 1
a660 1
	      SetFilePointer (get_handle (), 0, NULL, FILE_END);
d666 1
a666 1
		  if (!WriteFile (get_handle (), zeros, zeros_this_time,
d673 1
a673 1
		      SetFilePointer (get_handle (), current_position, NULL,
d682 1
a682 1
		      SetFilePointer (get_handle (), current_position, NULL,
d889 1
a889 1
  debug_printf ("lseek (%s, %D, %d)", unix_path_name, offset, whence);
@


1.155
log
@* cygheap.cc (cygheap_init): Allocate space for sigaction array in cygheap.
* cygheap.h (cygheap_types): Add HEAP_SIGS.
* exceptions.cc (signal_fixup_after_exec): Remove from this file.
* pinfo.h (pinfo::getsig): Just return global_sigs array.
(pinfo::sigs): Delete.
* sigproc.cc (signal_fixup_after_exec): Move it here.
(global_sigs): New global array, moved from pinfo structure.
(sigalloc): New function.  Allocate global sigaction array here.
(proc_subproc): Remove copysigs call.  It's automatic now.
* include/sys/cygwin.h (PID_NOCLDSTOP): New value.
* signal.cc (sigaction): Set myself->PID_NODCLDSTOP when appropriate.
* sigproc.h (sigalloc): Declare.
* fnmatch.c (fnmatch): Use C90 parameters.
(rangematch): Ditto.
* fhandler.cc (fhandler_base::raw_read): Use right coercion to avoid a compiler
warning.
@
text
@d261 1
a261 1
#define bytes_read ((ssize_t) ulen)
d307 1
a307 1
	      bytes_read = -1;
d313 1
a313 1
	  bytes_read = -1;
@


1.154
log
@* path.cc (cygdrive_getmntent): Do not skip over drives of type
DRIVE_REMOVABLE.
* fhandler.cc (fhandler_base::lseek): Be more paranoid when constructing
offsets from 64 bit value.
* syscalls.cc (logout): Avoid temp buffer memcpy since new scheme does not
require it.
(utmp_data): Rework as a macro which returns a pointer into a buffer.
(getutent): Use new buffer allocation mechanism to grab a utmp buffer.
(getutid): Ditto.
(pututline): Ditto.
@
text
@d267 1
a267 1
  (ssize_t) ulen = -1;
@


1.153
log
@* fhandler_base.cc (fhandler_base::readv): Rework to properly return number of
bytes from read.
@
text
@d894 1
a894 1
  LONG off_low = offset & 0xffffffff;
d900 1
a900 1
      off_high =  offset >> 32;
@


1.152
log
@* cygheap.cc (creturn): Set appropriate errno when out of memory.
(ccalloc): Only issue system_printf when debugging.
* dtable.cc (dtable::extend): Only allocate 100 * the incremental growth size
max.  Set errno appropriately.
(dtable::build_fhandler): Check for error from set_name.
* fhandler.cc (fhandler_base::set_name): Set errno and return error on OOM.
* fhandler.h (fhandler_base::set_name): Change to bool.
* fhandler_process.cc (format_process_stat): Fix formatting.
* resource.cc (getrlimit): Return greater of OPEN_MAX or fd table size.
* sysconf.cc (sysconf): Ditto.
@
text
@d761 1
d764 1
a764 1
      size_t len = iov->iov_len;
d771 1
a771 1
      tot = 0;
d776 1
a776 1
	  tot += iovptr->iov_len;
d783 1
a783 1
  if (tot == 0)
d794 2
a795 1
  read (buf, (size_t) tot);
a797 1
  int nbytes = tot;
d808 1
a808 1
  return tot;
@


1.151
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d152 1
a152 1
void
d156 1
a156 1
    return;
d164 2
a165 1
      __small_sprintf (w, fmt, unit);
d172 2
a173 1
      exit (ENOMEM);
d188 3
a190 2
      while ((p = strchr (p, '\\')) != NULL)
	*p++ = '/';
d198 3
a200 1
      exit (ENOMEM);
d203 1
@


1.150
log
@	* cygwin.din: Add vsyslog.
	* fhandler.cc (fhandler_base::write): Only make file sparse if the
	seeked area is >= 128K.
	* syslog.cc (vsyslog): New function, overtaking functionality from
	syslog.
	(syslog): Just call vsyslog.
	* include/cygwin/version.h: Bump API minor.
	* include/sys/syslog.h: Add vsyslog declaration.
@
text
@a11 1
#include <errno.h>
@


1.149
log
@* fhandler.cc (fhandler_base::write): Correct minor printf formatting style
glitch.
@
text
@d632 1
a632 1
	      && current_position >= actual_length + (64 * 1024))
@


1.148
log
@	* fhandler.cc (is_at_eof): Fix conditional.  Use INVALID_FILE_SIZE
	instead of numeric constant.
@
text
@d641 1
a641 1
	      syscall_printf ("%d = DeviceIoControl(0x%x, FSCTL_SET_SPARSE, "
@


1.147
log
@	* fhandler.h: Rename FH_W95LSBUG flag to FH_LSEEKED.
	(fhandler_base::set_did_lseek): Rename from set_check_win95_lseek_bug.
	(fhandler_base::get_did_lseek): Rename from get_check_win95_lseek_bug.
	(fhandler_base::set_fs_flags): New method.
	(fhandler_base::get_fs_flags): Ditto.
	* fhandler.cc (fhandler_base::write): Make 64 bit clean.  Convert file
	to a "sparse" file when writing after a long lseek (>64K) beyond EOF.
	(fhandler_base::lseek): Call set_did_lseek() instead of
	set_check_win95_lseek_bug().
	(fhandler_base::fhandler_base): Initialize fs_flags to 0.
	* fhandler_disk_file.cc (fhandler_disk_file::open): Don't create files
	as "sparse" unconditionally.  Set fs_flags member.
@
text
@d209 1
a209 1
  if (upper1 != 0xffffffff || GetLastError () == NO_ERROR)
@


1.146
log
@	* fhandler.cc (fhandler_base::fstat): Set the uid and gid fields
	from the current effective ids.
	* fhandler_socket.cc (fhandler_socket::fstat): Keep the uid and gid set
	by fhandler_base::fstat.
	* security.cc (get_nt_attribute): Do not test wincap.has_security ().
	(get_nt_object_attribute): Ditto.
	(get_file_attribute): Add test for wincap.has_security ().
	(get_object_attribute): Ditto.
@
text
@d30 1
d614 1
a614 1
  else if (wincap.has_lseek_bug () && get_check_win95_lseek_bug ())
d616 13
a628 6
      /* Note: this bug doesn't happen on NT4, even though the documentation
	 for WriteFile() says that it *may* happen on any OS. */
      int actual_length, current_position;
      set_check_win95_lseek_bug (0); /* don't do it again */
      actual_length = GetFileSize (get_handle (), NULL);
      current_position = SetFilePointer (get_handle (), 0, 0, FILE_CURRENT);
d631 2
a632 8
	  /* Oops, this is the bug case - Win95 uses whatever is on the disk
	     instead of some known (safe) value, so we must seek back and
	     fill in the gap with zeros. - DJ */
	  char zeros[512];
	  int number_of_zeros_to_write = current_position - actual_length;
	  memset (zeros, 0, 512);
	  SetFilePointer (get_handle (), 0, 0, FILE_END);
	  while (number_of_zeros_to_write > 0)
d634 23
a656 15
	      DWORD zeros_this_time = (number_of_zeros_to_write > 512
				     ? 512 : number_of_zeros_to_write);
	      DWORD written;
	      if (!WriteFile (get_handle (), zeros, zeros_this_time, &written,
			      NULL))
		{
		  __seterrno ();
		  if (get_errno () == EPIPE)
		    raise (SIGPIPE);
		  /* This might fail, but it's the best we can hope for */
		  SetFilePointer (get_handle (), current_position, 0, FILE_BEGIN);
		  return -1;

		}
	      if (written < zeros_this_time) /* just in case */
d658 24
a681 4
		  set_errno (ENOSPC);
		  /* This might fail, but it's the best we can hope for */
		  SetFilePointer (get_handle (), current_position, 0, FILE_BEGIN);
		  return -1;
a682 1
	      number_of_zeros_to_write -= written;
d908 1
a908 1
      set_check_win95_lseek_bug ();
d1197 1
@


1.145
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@d984 2
@


1.144
log
@* fhandler.cc (fhandler_base::open): Move some filesystem specific stuff.
(fhandler_disk_file::open): Accept some filesystem specific stuff.
* sigproc.cc (wait_for_sigthread): Become slightly more thread safe.
(sig_send): Don't assume that signal thread is ready.
@
text
@d827 2
a828 2
__off64_t
fhandler_base::lseek (__off64_t offset, int whence)
d830 1
a830 1
  __off64_t res;
d841 1
a841 1
      return (__off64_t)-1;
d1277 1
a1277 1
__off64_t
d1285 1
a1285 1
fhandler_base::seekdir (DIR *, __off64_t)
@


1.143
log
@
2002-12-19  Pierre Humblet <pierre.humblet@@ieee.org>

        * fhandler.cc (fhandler_base::open): Use "flags" rather than "mode"
	in Win9X directory code.
@
text
@a457 4
  syscall_printf ("%p = CreateFile (%s, %p, %p, %p, %p, %p, 0)",
		  x, get_win32_name (), access, shared, &sa,
		  creation_distribution, file_attributes);

d461 8
a468 8
	{
	  if (flags & (O_CREAT | O_EXCL) == (O_CREAT | O_EXCL))
	    set_errno (EEXIST);
	  else if (flags & (O_WRONLY | O_RDWR))
	    set_errno (EISDIR);
	  else
	    set_nohandle (true);
	}
d470 1
a470 1
	set_errno (ENOENT);
d472 1
a472 1
	__seterrno ();
d474 2
a475 2
	goto done;
    }
d477 3
a479 7
  /* Attributes may be set only if a file is _really_ created.
     This code is now only used for ntea here since the files
     security attributes are set in CreateFile () now. */
  if (flags & O_CREAT && get_device () == FH_DISK
      && GetLastError () != ERROR_ALREADY_EXISTS
      && !allow_ntsec && allow_ntea)
    set_file_attribute (has_acls (), get_win32_name (), mode);
@


1.143.6.1
log
@merge from trunk
@
text
@d153 1
a153 1
fhandler_base::set_name (const char *unix_path, const char *win32_path)
d164 1
a164 1
      __small_sprintf (w, fmt, get_unit ());
d180 1
a180 1
  if (!is_auto_device () || *win32_path_name != '\\')
d321 1
a321 1
  if (!WriteFile (get_output_handle (), ptr, len, &bytes_written, 0))
a363 14
bool
fhandler_base::device_access_denied (int flags)
{
  int mode = 0;
  if (flags & O_RDWR)
    mode |= R_OK | W_OK;
  if (flags & (O_WRONLY | O_APPEND))
    mode |= W_OK;
  if (!mode)
    mode |= R_OK;

  return ::access (get_win32_name (), mode);
}

d428 1
a428 1
  if (flags & O_CREAT && get_device () == FH_FS)
d452 1
a452 1
  if (flags & O_CREAT && get_device () == FH_FS && allow_ntsec && has_acls ())
d484 1
a484 1
  if (flags & O_CREAT && get_device () == FH_FS
d620 1
a620 1
    SetFilePointer (get_output_handle (), 0, 0, FILE_END);
d627 2
a628 2
      actual_length = GetFileSize (get_output_handle (), NULL);
      current_position = SetFilePointer (get_output_handle (), 0, 0, FILE_CURRENT);
d637 1
a637 1
	  SetFilePointer (get_output_handle (), 0, 0, FILE_END);
d643 1
a643 1
	      if (!WriteFile (get_output_handle (), zeros, zeros_this_time, &written,
d650 1
a650 1
		  SetFilePointer (get_output_handle (), current_position, 0, FILE_BEGIN);
d658 1
a658 1
		  SetFilePointer (get_output_handle (), current_position, 0, FILE_BEGIN);
d970 1
a970 1
fhandler_base::fstat (struct __stat64 *buf, path_conv *pc)
a972 4

  if (is_fs_special ())
    return fstat_fs (buf, pc);

d1160 2
a1161 2
fhandler_base::fhandler_base ():
  status (0),
d1194 1
a1194 1
	fhandler_base ()
@


1.143.6.2
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d22 1
a23 1
#include "fhandler.h"
d41 2
a42 1
  pc.normalized_path = cstrdup (pc.normalized_path);
d147 5
a151 1
/* Record the file name. and name hash */
d153 1
a153 1
fhandler_base::set_name (path_conv &in_pc)
d155 43
a197 2
  memcpy (&pc, &in_pc, in_pc.size ());
  namehash = hash_path_name (0, get_win32_name ());
d305 1
a305 1
	  syscall_printf ("ReadFile %s failed, %E", get_name ());
d380 1
a380 1
fhandler_base::open (int flags, mode_t mode)
d454 1
a454 1
      creation_distribution == OPEN_EXISTING && !pc.exists ())
d478 1
a478 1
      if (!wincap.can_open_directories () && pc.isdir ())
d504 1
a504 1
  set_flags (flags, pc.binmode ());
d876 1
a876 1
  debug_printf ("lseek (%s, %D, %d)", get_name (), offset, whence);
d984 1
a984 1
fhandler_base::fstat (struct __stat64 *buf)
d989 1
a989 1
    return fstat_fs (buf);
d1189 2
d1199 4
a1202 2
  if (pc.normalized_path)
    cfree (pc.normalized_path);
d1205 1
d1290 1
a1290 1
fhandler_base::opendir ()
@


1.143.6.3
log
@* path.h (path_conv::set_normalized_path): Declare.
(path_conv::normalized_path_size): Declare.
(path_conv::return_and_clear_normalized_path): Delete declaration.
* path.cc (path_conv::set_normalized_path): Define.  Puts normalized path in
path buf if there is room.
(path_conv::check): Call set_normalized_path.
(path_conv::return_and_clear_normalized_path): Delete definition.
* dtable.cc (build_fh_dev): Ditto.
* fhandler.cc (fhandler_base::operator =): Ditto.
(fhandler_base::~fhandler_base): Only free normalized_path when appropriate.
@
text
@d41 1
a41 1
  pc.set_normalized_path (pc.normalized_path);
d1151 1
a1151 1
  if (!pc.normalized_path_size && pc.normalized_path)
@


1.143.6.4
log
@merge from trunk
@
text
@d38 1
a38 1
fhandler_base::operator =(fhandler_base& x)
d41 1
a41 1
  pc.set_normalized_path (x.pc.normalized_path);
a150 1
  pc.set_normalized_path (in_pc.normalized_path);
d426 4
d442 1
a442 1
       set_errno (ENOENT);
d444 1
a444 1
       __seterrno ();
d446 2
a447 2
       goto done;
   }
d449 7
a455 3
  syscall_printf ("%p = CreateFile (%s, %p, %p, %p, %p, %p, 0)",
		  x, get_win32_name (), access, shared, &sa,
		  creation_distribution, file_attributes);
@


1.143.6.5
log
@* cygwin-gperf: Fix typo in FH_FS static storage.
* devices.gperf (device::parse): Default to fs "device" when nothing else is
found.
* fhandler.cc (fhandler_base::device_access_denied): Use access_worker rather
than access to avoid reparsing pc.
* fhandler_nodevice.cc (fhandler_nodevice::open): Set errno to ENXIO rather
than ENODEV.
* path.cc (path_conv::check): Default to FH_FS rather than FH_BAD.
(mount_info::conv_to_win32_path): Ditto.
(win32_device_name): Don't do device handling if FH_FS.
* path.h (path_conv::get_devn): Just return raw device number.
* syscalls.cc (access_worker): New function, split from access().  Correctly
deal with special devices in light of recent ntsec changes.
(access): Use access_worker.
@
text
@a322 2
  int access_worker (path_conv&, int);

d330 1
a330 1
  return access_worker (pc, mode);
@


1.143.6.6
log
@merge from trunk
@
text
@d798 2
a799 2
_off64_t
fhandler_base::lseek (_off64_t offset, int whence)
d801 1
a801 1
  _off64_t res;
d812 1
a812 1
      return (_off64_t)-1;
a958 2
  buf->st_uid = geteuid32 ();
  buf->st_gid = getegid32 ();
d1247 1
a1247 1
_off64_t
d1255 1
a1255 1
fhandler_base::seekdir (DIR *, _off64_t)
@


1.143.6.7
log
@merge from trunk
@
text
@a29 1
#include <winioctl.h>
d163 1
a163 1
  if (size != INVALID_FILE_SIZE || GetLastError () == NO_ERROR)
d584 1
a584 1
  else if (get_did_lseek ())
d586 6
a591 13
      _off64_t actual_length, current_position;
      DWORD size_high = 0;
      LONG pos_high = 0;

      set_did_lseek (0); /* don't do it again */

      actual_length = GetFileSize (get_output_handle (), &size_high);
      actual_length += ((_off64_t) size_high) << 32;

      current_position = SetFilePointer (get_output_handle (), 0, &pos_high,
					 FILE_CURRENT);
      current_position += ((_off64_t) pos_high) << 32;

d594 8
a601 2
	  if ((get_fs_flags (FILE_SUPPORTS_SPARSE_FILES))
	      && current_position >= actual_length + (64 * 1024))
d603 15
a617 23
	      /* If the file systemn supports sparse files and the application
	         is writing after a long seek beyond EOF, convert the file to
		 a sparse file. */
	      DWORD dw;
	      HANDLE h = get_output_handle ();
	      BOOL r = DeviceIoControl (h, FSCTL_SET_SPARSE, NULL, 0, NULL,
	      				0, &dw, NULL);
	      syscall_printf ("%d = DeviceIoControl(0x%x, FSCTL_SET_SPARSE, "
			      "NULL, 0, NULL, 0, &dw, NULL)", r, h);
	    }
	  else if (wincap.has_lseek_bug ())
	    {
	      /* Oops, this is the bug case - Win95 uses whatever is on the
	         disk instead of some known (safe) value, so we must seek
		 back and fill in the gap with zeros. - DJ
	         Note: this bug doesn't happen on NT4, even though the
	         documentation for WriteFile() says that it *may* happen
		 on any OS. */
	      char zeros[512];
	      int number_of_zeros_to_write = current_position - actual_length;
	      memset (zeros, 0, 512);
	      SetFilePointer (get_output_handle (), 0, NULL, FILE_END);
	      while (number_of_zeros_to_write > 0)
d619 4
a622 24
		  DWORD zeros_this_time = (number_of_zeros_to_write > 512
					 ? 512 : number_of_zeros_to_write);
		  DWORD written;
		  if (!WriteFile (get_output_handle (), zeros, zeros_this_time,
				  &written, NULL))
		    {
		      __seterrno ();
		      if (get_errno () == EPIPE)
			raise (SIGPIPE);
		      /* This might fail, but it's the best we can hope for */
		      SetFilePointer (get_output_handle (), current_position, NULL,
				      FILE_BEGIN);
		      return -1;

		    }
		  if (written < zeros_this_time) /* just in case */
		    {
		      set_errno (ENOSPC);
		      /* This might fail, but it's the best we can hope for */
		      SetFilePointer (get_output_handle (), current_position, NULL,
				      FILE_BEGIN);
		      return -1;
		    }
		  number_of_zeros_to_write -= written;
d624 1
d850 1
a850 1
      set_did_lseek ();
a1140 1
  fs_flags (0),
@


1.143.6.8
log
@merge from trunk
@
text
@d612 1
a612 1
	      syscall_printf ("%d = DeviceIoControl(%p, FSCTL_SET_SPARSE, "
@


1.143.6.9
log
@merge from trunk
@
text
@d12 1
d603 1
a603 1
	      && current_position >= actual_length + (128 * 1024))
@


1.143.6.10
log
@merge from trunk
@
text
@a725 1
  size_t len = tot;
d728 1
a728 1
      len = iov->iov_len;
d735 1
a735 1
      len = 0;
d740 1
a740 1
	  len += iovptr->iov_len;
d747 1
a747 1
  if (!len)
d758 1
a758 2
  read (buf, len);
  ssize_t nbytes = (ssize_t) len;
d761 1
d772 1
a772 1
  return len;
d858 1
a858 1
  LONG off_low = ((__uint64_t) offset) & 0xffffffffLL;
d864 1
a864 1
      off_high =  ((__uint64_t) offset) >> 32LL;
@


1.143.6.11
log
@merge from trunk
@
text
@d216 1
a216 1
  ulen = (size_t) -1;
@


1.143.6.12
log
@merge from trunk
@
text
@d210 1
a210 1
#define bytes_read ulen
d256 1
a256 1
	      bytes_read = (size_t) -1;
d262 1
a262 1
	  bytes_read = (size_t) -1;
@


1.143.4.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d153 1
a153 1
fhandler_base::set_name (const char *unix_path, const char *win32_path)
d164 1
a164 1
      __small_sprintf (w, fmt, get_unit ());
d428 1
a428 1
  if (flags & O_CREAT && get_device () == FH_FS)
d452 1
a452 1
  if (flags & O_CREAT && get_device () == FH_FS && allow_ntsec && has_acls ())
d484 1
a484 1
  if (flags & O_CREAT && get_device () == FH_FS
@


1.143.4.2
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d1160 1
a1160 1
fhandler_base::fhandler_base (DWORD devtype):
@


1.143.4.3
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d1160 2
a1161 2
fhandler_base::fhandler_base ():
  status (0),
d1194 1
a1194 1
	fhandler_base ()
@


1.143.4.4
log
@* cygwin-gperf: New file.
* Makefile.in: Use cygwin-gperf script to build devices.cc.
* configure.in: Remove some comments.
* configure: Regenerate.
* devices.gperf: Remove max unit determination from FH_TTY.  Add /dev/kmem.
Add /dev/fifo.  Add /dev/rawdrive.  Remove specific "const device *"
declarations since they are now autogenerated.
(device::parse): Treat FH_TTY specially.  Move logic for determining real tty
device to separate function.
(device::init): Reduce to nothing.
(device::parse): New function taking different arguments.
(device::parse): Ditto.
(device::tty_to_real_device): New function.
* devices.h (struct device): Define above new functions.
(device::dev_on_fs): New element.
(device::setfs): New function.
(device::isfs): Ditto.
* dtable.cc (dtable::build_fhandler): Treat FH_TTY specially.
* fhandler.cc (fhandler_base::set_name): Make special determination for
non-disk-resident devices.
* fhandler.h (fhandler_base::isdevice): Renamed from 'is_device'.
(fhandler_disk_file::isdevice): Ditto.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_device): New function.
(fhandler_tty_slave::get_unit): Declare.
(fhandler_disk_file::readdir): Take special .lnk consideration for devices as
well as symlinks.
* fhandler_tty.cc: Use get_unit () rather than dev.minor throughout.
(fhandler_tty_slave::get_unit): Define new function.
* path.cc (symlink_info::major): New element.
(symlink_info::major): Ditto.
(symlink_info::devtype): Ditto.
(path_conv::check): Handle devices detected by symlink_info::check.
(win32_device_name): Eliminate special FH_TTY handling.
(symlink): Move bulk of procesing to symlink_worker.
(symlink_worker): New function.  Handles devices.
(symlink_info::parse_device): Parse info from potential device file into
symlink_info elements.
(symlink_info::check): If contents of .lnk file begin with a ':' then treat the
file as a device file.
* path.h (isdevice): Renamed from is_device.
(is_auto_device): New function.
(is_fs_device): Ditto.
* syscalls.cc (chown_worker): Allow setting of ownership for on-disk devices.
(chmod): Ditto.
(mknod): Implement.
* winsup.h (symlink_worker): Declare.
@
text
@d180 1
a180 1
  if (!is_auto_device () || *win32_path_name != '\\')
@


1.143.4.5
log
@* sysconf.cc (sysconf): Return arbitrary values for _SC_GETGR_R_SIZE_MAX,
_SC_LOGIN_NAME_MAX, _SC_GETPW_R_SIZE_MAX.
* passwd.cc (getpwuid_r32): Add uid/gid fields to size check calculation.
* exceptions.cc (events_init): Display name of mutex on failure.
* windows.cc (setitimer): Return ENOSYS on invalid argument.
@
text
@d970 1
a970 1
fhandler_base::fstat (struct __stat64 *buf, path_conv *pc)
a972 4

  if (is_fs_device ())
    return fstat_fs (buf, pc);

@


1.143.4.6
log
@* devices.h (_devtype_t): Eliminate.
(_mode_t): New typedef.
(device::mode): Replace type.
* fhandler.h (fhandler_base::device_access_denied): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Define new function.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Just copy mode directly
from dev.mode to st_mode if it is a disk device.
* path.cc (path_conv::check): Set device mode from sym mode.
(symlink_worker): Let "exists" check happen when file is attempted to be
opened, or not, in the case of creating a device.
(symlink_info::parse_device): Change device type argument to device mode
argument.
(mknod_worker): New function.
(chmod_device): Ditto.
(chmod): Use chmod_device to set protection if it is an fs device.
(mknod): Use mknod_worker to actually create the device.  Don't take any
special action with the protection since it is now implicit.
@
text
@a363 13
bool
fhandler_base::device_access_denied (int flags)
{
  int mode = 0;
  if (flags & O_RDONLY)
    mode |= R_OK;
  if (flags & O_RDWR)
    mode |= R_OK | W_OK;
  if (flags & O_WRONLY)
    mode |= W_OK;
  return ::access (get_win32_name (), mode);
}

@


1.143.4.7
log
@Replace is_fs_device with is_fs_special throughout.
* Makefile.in (DLL_OFILES): Add fhandler_fifo.o.
* devices.h (fh_devices): Renumber some minor numbers to fit in 8 bits.
* dtable.cc (dtable::build_fhandler): Handle FH_FIFO.  Set errno to ENODEV if
device not found.
* dtable::find_fifo: Define new function.
* dtable.h (dtable::find_fifo): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Fix O_RDONLY test.
(fhandler_base::write): Use output file handle for writing.
(fhandler_base::fstat): Use is_fs_special rather than is_fs_device.
* fhandler.h (fhandler_base::is_fs_special): Rename from is_fs_device.
(fhandler_pipe): Make private elements protected so that fhandler_fifo can use
them too.
(fhandler_pipe::create): New function derived from make_pipe.
(fhandler_fifo): Add more needed elements.
(fhandler_pty_master::slave): Add to track slave device.
(fhandler_pty_master::get_unit): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Register slave device.
(fhandler_pty_master::open): Ditto.
(symlink_info::parse_device): Handle fifo specially.
* pinfo.cc (_pinfo::commune_recv): Initial fifo implementation.
(_pinfo::commune_send): Ditto.
* pinfo.h (picom): Add PICOM_FIFO.
* pipe.cc (fhandler_pipe::close): Close input handle here specifically.
(fhandler_pipe::create): Rename from make_pipe.  Create fhandlers rather than
fds.
(pipe): Use fhandler_pipe::create to create pipe.
(_pipe): Ditto.
* syscalls.cc (mknod): Accommodate fifos.
@
text
@d368 2
d372 1
a372 1
  if (flags & (O_WRONLY | O_APPEND))
a373 3
  if (!mode)
    mode |= R_OK;

d633 1
a633 1
    SetFilePointer (get_output_handle (), 0, 0, FILE_END);
d640 2
a641 2
      actual_length = GetFileSize (get_output_handle (), NULL);
      current_position = SetFilePointer (get_output_handle (), 0, 0, FILE_CURRENT);
d650 1
a650 1
	  SetFilePointer (get_output_handle (), 0, 0, FILE_END);
d656 1
a656 1
	      if (!WriteFile (get_output_handle (), zeros, zeros_this_time, &written,
d663 1
a663 1
		  SetFilePointer (get_output_handle (), current_position, 0, FILE_BEGIN);
d671 1
a671 1
		  SetFilePointer (get_output_handle (), current_position, 0, FILE_BEGIN);
d987 1
a987 1
  if (is_fs_special ())
@


1.143.4.8
log
@* pinfo.cc (_pinfo::commune_send): Use myself->lock rather than just lock when
leaving.
@
text
@d321 1
a321 1
  if (!WriteFile (get_output_handle (), ptr, len, &bytes_written, 0))
@


1.142
log
@* fhandler.cc (fhandler_base::read): Signal event, if necessary, and raw_read
hasn't done so.
@
text
@d466 1
a466 1
	  if (mode & (O_CREAT | O_EXCL) == (O_CREAT | O_EXCL))
d468 1
a468 1
	  else if (mode & (O_WRONLY | O_RDWR))
@


1.141
log
@* fhandler.cc (fhandler_base::raw_read): Reset priorities to minimize window
where thread termination may cause data loss.
(fhandler_base::read): Always return at end of function.  Just set len to
copied_chars when len is zero.  Return immediately after raw_read if len <= 0.
Remove in_len setting and just check end instead.  Fix CRLF handling at end of
buffer.
@
text
@d513 1
d538 1
d606 3
@


1.140
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d257 2
d260 1
d263 6
a268 1
    SetEvent (read_state);
d271 4
a274 1
    SetEvent (read_state);
a510 1
  size_t in_len = len;
d527 1
a527 1
      return;
d530 1
a530 11
  if (len)
    {
      raw_read (ptr + copied_chars, len);
      if (!copied_chars)
	/* nothing */;
      else if ((ssize_t) len > 0)
	len += copied_chars;
      else
	len = copied_chars;
    }
  else if (copied_chars <= 0)
d533 1
a533 1
      return;
d536 7
a542 5
  if (get_r_binary ())
    {
      debug_printf ("returning %d chars, binary mode", len);
      return;
    }
d544 2
a545 17
#if 0
  char *ctrlzpos;
  /* Scan buffer for a control-z and shorten the buffer to that length */

  ctrlzpos = (char *) memchr ((char *) ptr, 0x1a, copied_chars);
  if (ctrlzpos)
    {
      lseek ((ctrlzpos - ((char *) ptr + copied_chars)), SEEK_CUR);
      copied_chars = ctrlzpos - (char *) ptr;
    }

  if (copied_chars == 0)
    {
      debug_printf ("returning 0 chars, text mode, CTRL-Z found");
      return 0;
    }
#endif
d548 4
a551 3
  char *src = (char *) ptr;
  char *dst = (char *) ptr;
  char *end = src + len - 1;
d561 12
a572 9
  len = dst - (char *) ptr;

  /* if last char is a '\r' then read one more to see if we should
     translate this one too */
  if (len < in_len && *src == '\r')
    {
      size_t clen = 1;
      raw_read (&c, clen);
      if (clen <= 0)
d574 2
a575 2
      else if (c != '\n')
	set_readahead_valid (1, c);
d578 2
a579 2
	  *dst++ = '\n';
	  len++;
d583 1
d603 3
a605 1
  debug_printf ("returning %d chars, text mode", len);
@


1.139
log
@2002-10-31  Pierre Humblet <pierre.humblet@@ieee.org>

	* fhandler.cc (fhandler_base::open): Verify pc isn't NULL.
@
text
@d252 2
a253 2
int
fhandler_base::raw_read (void *ptr, size_t ulen)
d255 1
a255 1
  DWORD bytes_read;
d257 8
a264 1
  if (!ReadFile (get_handle (), ptr, ulen, &bytes_read, 0))
a265 2
      int errcode;

d268 1
a268 1
      errcode = GetLastError ();
d280 4
a283 1
	    return 0;
d290 2
a291 1
	      return -1;
d296 1
a296 1
	  return -1;
d300 1
a300 2

  return bytes_read;
d497 2
a498 2
int
fhandler_base::read (void *in_ptr, size_t in_len)
d500 1
a500 1
  int len = (int) in_len;
d502 1
a502 1

a503 1
  int copied_chars = 0;
d515 4
a518 1
    return copied_chars;
d522 12
a533 5
      int readlen = raw_read (ptr + copied_chars, len);
      if (copied_chars == 0)
	copied_chars = readlen;		/* Propagate error or EOF */
      else if (readlen > 0)		/* FIXME: should flag EOF for next read */
	copied_chars += readlen;
a535 2
  if (copied_chars <= 0)
    return copied_chars;
d538 2
a539 2
      debug_printf ("returning %d chars, binary mode", copied_chars);
      return copied_chars;
d561 3
a563 3
  register char *src = (char *) ptr;
  register char *dst = (char *) ptr;
  register char *end = src + copied_chars - 1;
d568 3
a570 3
      *dst = *src++;
      if (*dst != '\r' || *src != '\n')
	dst++;
d573 2
a574 1
  c = *src;
d577 1
a577 1
  if (c == '\r')
d579 3
a581 3
      char c1 = 0;
      len = raw_read (&c1, 1);
      if (len <= 0)
d583 2
a584 2
      else if (c1 == '\n')
	c = '\n';
d586 4
a589 1
	set_readahead_valid (1, c1);
a591 2
  *dst++ = c;
  copied_chars = dst - (char *) ptr;
d611 2
a612 2
  debug_printf ("returning %d chars, text mode", copied_chars);
  return copied_chars;
d737 5
a741 1
    return read (iov->iov_base, iov->iov_len);
d768 1
a768 1
  const ssize_t res = read (buf, tot);
d771 1
a771 1
  int nbytes = res;
d782 1
a782 1
  return res;
d1174 2
a1175 1
  open_status (0)
@


1.138
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d445 1
a445 1
      if (pc->isdir () && !wincap.can_open_directories ())
@


1.137
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d620 1
a620 1
	  memset(zeros, 0, 512);
@


1.136
log
@Cleanup calls to CreateFile throughout.
* dcrt0.cc (__api_fatal): Correctly check for failing return from CreateFile.
* assert.cc (__assert): Don't check return value from CreateFile for NULL.
* fhandler_console.cc (set_console_state_for_spawn): Ditto.
* fork.cc (fork_parent): Ditto.
@
text
@d106 1
a106 1
    put_readahead(ch);
d163 1
a163 1
      char *w =  (char *) cmalloc (HEAP_STR, strlen(fmt) + 16);
d257 1
a257 1
  if (!ReadFile (get_handle(), ptr, ulen, &bytes_read, 0))
d302 1
a302 1
  if (!WriteFile (get_handle(), ptr, len, &bytes_written, 0))
d397 1
a397 1
    set_append_p();
d604 1
a604 1
    SetFilePointer (get_handle(), 0, 0, FILE_END);
d858 1
a858 1
  res = SetFilePointer (get_handle(), off_low, poff_high, win32_whence);
d884 2
a885 2
  syscall_printf ("closing '%s' handle %p", get_name (), get_handle());
  if (get_nohandle () || CloseHandle (get_handle()))
d889 1
a889 1
      paranoid_printf ("CloseHandle (%d <%s>) failed", get_handle(),
d917 1
a917 1
rootdir(char *full_path)
d1009 1
a1009 4
  if (get_nohandle ())
    nh = INVALID_HANDLE_VALUE;
  else if (!DuplicateHandle (hMainProc, get_handle(), hMainProc, &nh, 0, TRUE,
			DUPLICATE_SAME_ACCESS))
d1011 10
a1020 4
      system_printf ("dup(%s) failed, handle %x, %E",
		     get_name (), get_handle());
      __seterrno ();
      return -1;
a1021 2

  child->set_io_handle (nh);
@


1.135
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d439 1
a439 1
  syscall_printf ("%p = CreateFileA (%s, %p, %p, %p, %p, %p, 0)",
@


1.134
log
@* miscfuncs.cc (check_iovec_for_read): Don't check buffer when zero length
iov_len.
(check_iovec_for_write): Ditto.
* fhandler.h (fhandler_base::readv): New method.
(fhandler_base::writev): Ditto.
* fhandler.cc (fhandler_base::readv): New method.
(fhandler_base::writev): Ditto.
* syscalls.cc (_read): Delegate to readv(2).
(_write): Ditto, mutatis mutandi.
(readv): Rewrite, based on the old _read code, to use the new
fhandler_base::readv method.  Improve access mode handling and ensure all calls
reach the final strace statement.
(writev): Ditto, mutatis mutandi.
* include/sys/uio.h (struct iovec): Change field types to match SUSv3.
* winsup.h (check_iovec_for_read): New function.
(check_iovec_for_write): Ditto.
* miscfuncs.cc (check_iovec_for_read): Ditto.
(check_iovec_for_write): Ditto.
@
text
@d237 2
a238 2
    bin = get_w_binary () || get_r_binary () || (binmode != O_TEXT) ?
      	  O_BINARY : O_TEXT;
d278 1
d445 10
a454 1
      if (GetLastError () == ERROR_INVALID_HANDLE)
d458 2
a459 1
      goto done;
d726 1
a726 1
      do 
d778 1
a778 1
      do 
d885 1
a885 1
  if (CloseHandle (get_handle()))
d912 1
a912 1
  set_errno (ENOSYS);
d1010 1
a1010 1
    nh = NULL;
d1221 2
a1222 1
  set_inheritance (io_handle, val);
d1231 2
a1232 1
  fork_fixup (parent, io_handle, "io_handle");
@


1.133
log
@* dcrt0.cc (dll_crt0_1): Move debug_init call back to here.  Avoid a compiler
warning.
* shared.cc (memory_init): Remove debug_init call.
* debug.h (handle_list): Change "clexec" to "inherited".
* debug.cc: Remove a spurious declaration.
(setclexec): Conditionalize away since it is currently unused.
(add_handle): Use inherited field rather than clexec.
(debug_fixup_after_fork_exec): Ditto.  Move debugging output to delete_handle.
(delete_handle): Add debugging output.
* fhandler.cc (fhandler_base::set_inheritance): Don't bother setting
inheritance in debugging table since the handle was never protected anyway.
(fhandler_base::fork_fixup): Ditto.
* exceptions.cc (debugger_command): Revert.
@
text
@d16 1
d699 103
@


1.132
log
@* debug.h (handle_list): Move here from debug.cc.  Add "inherit" flag
functionality.
* cygheap.cc (init_cheap): Move cygheap_max calculation to _csbrk.
(_csbrk): Reorganize to not assume first allocation is <= 1 page.
(cygheap_setup_for_child): Mark protected handle as inheritable.
* cygheap.h (cygheap_debug): New struct.
(init_cygheap): Add new structure when debugging.
* dcrt0.cc (dll_crt0_1): Remove call to debug_init.  Close ppid_handle here, if
appropriate.  Don't protect subproc_ready, since it is already protected in the
parent.  Call memory_init prior to ProtectHandle to ensure that cygheap is set
up.  Call debug_fixup_after_fork_exec when appropriate.
(_dll_crt0): Don't close ppid_handle here.
* debug.cc: Use cygheap debug structure rather than static elements throughout.
(add_handle): Don't issue a warning if attempt to protect handle in exactly the
same way from exactly the same place.  Add pid info to warning output.  Accept
additional argument controlling whether handle is to be inherited.  Add pid to
stored information.
(debug_fixup_after_fork_exec): Renamed from debug_fixup_after_fork.  Reorganize
to avoid erroneously skipping handles.
(mark_closed): Add pid info to warning output.
(setclexec): Rename from setclexec_pid.
* fhandler.cc (fhandler_base::get_default_fmode): Minor reorg.
(fhandler_base::fstat): Add debugging output.
(fhandler_base::set_inheritance): Call setclexec rather than setclexec_pid.
(fhandler_base::fork_fixup): Ditto.
* fhandler_console.cc (get_tty_stuff): Mark protected handle as inheritable.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* tty.cc (tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* fork.cc (fork_parent): Ditto.
(fork_child): Close protected handles with correct name.  Remove
debug_fixup_after_fork call.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Mark protected
handle as inheritable/non-inheritable, as appropriate.
* shared.cc (memory_init): Mark protected handle as inheritable.  Call
debug_init here.
* sigproc.cc (wait_sig): Close protected handle with correct name.
* spawn.cc (spawn_guts): Rename spr to subproc_ready and mark it as
inheritable.
* exceptions.cc (debugger_command): Try to run dumper.exe, if found.
* syscalls.cc (fstat64): Don't follow symlinks for path_conv lookup since path
is already resolved.
@
text
@d1070 1
a1070 1
#ifdef DEBUGGING
d1081 1
a1081 1
#ifdef DEBUGGING
a1089 3
#ifdef DEBUGGING
  HANDLE oh = h;
#endif
d1095 3
a1097 1
#ifdef DEBUGGING
d1099 1
a1099 5
    {
      debug_printf ("%s success - oldh %p, h %p", get_name (), oh, h);
      // someday, maybe ProtectHandle2 (h, name);
      setclexec (oh, h, !get_close_on_exec ());
    }
@


1.131
log
@* dtable.cc (cygwin_attach_handle_to_fd): Default to implicit bin mode if none
specified.
* fhandler.cc (fhandler_base::init): Make bin argument a guarantee rather than
a suggestion.
* path.cc (path_conv::check): Load flag returned from cygwin_conv_to_win32_path
into path_flags.
@
text
@d316 1
d323 4
a326 1
	  return pf->flags & ~(O_RDONLY | O_WRONLY | O_RDWR);
d334 4
a337 1
	      return pf->flags & ~(O_RDONLY | O_WRONLY | O_RDWR);
d340 1
a340 1
  return __fmode;
d837 1
d1083 1
a1083 1
    setclexec_pid (oh, h, not_inheriting);
d1103 1
a1103 1
      setclexec_pid (oh, h, !get_close_on_exec ());
@


1.130
log
@* fhandler.cc (fhandler_base::fstat): Set S_IFIFO for pipes.
* fhandler_socket.cc (fhandler_socket.cc::fstat): Set S_IFSOCK.
@
text
@d869 1
a869 1
  set_flags (flags, bin);
@


1.129
log
@* fhandler.cc (fhandler_base::set_flags): Change priority of "linked in"
default binmode setting so that it has priority over optional setting.
@
text
@d832 3
d836 1
a836 1
      buf->st_mode = STD_WBITS | S_IWGRP | S_IWOTH;
d839 4
a842 1
      buf->st_mode = STD_RBITS;
d845 1
a845 1
      buf->st_mode = STD_RBITS | STD_WBITS | S_IWGRP | S_IWOTH;
a848 1
  buf->st_mode |= get_device () == FH_FLOPPY ? S_IFBLK : S_IFCHR;
@


1.128
log
@	* fhandler.cc (fhandler_base::fstat): Initialise tv_nsec member of
	st_atim, st_mtim, and st_ctim fields.
	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Ditto.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	* glob.c (stat32_to_STAT): Copy across the whole st_atim,
	st_mtime, and st_ctim fields.
	* syscalls.cc (stat64_to_stat32): Ditto.
	* times.cc (to_timestruc_t): New function.
	(time_as_timestruc_t): New function.
	* winsup.h: Add to_timestruc_t and time_as_timestruc_t functions.
	* include/cygwin/stat.h: Replace time_t with timestruc_t
	throughout for all file times, removing the st_spare1, st_spare2,
	and st_spare3 fields in the process. Add macros to access tv_sec
	fields by old names.
	* include/cygwin/types.h: Typedef timespec_t and timestruc_t as
	struct timespec.
@
text
@a59 27
void
fhandler_base::set_flags (int flags, int supplied_bin)
{
  int bin;
  int fmode;
  debug_printf ("flags %p, supplied_bin %p", flags, supplied_bin);
  if ((bin = flags & (O_BINARY | O_TEXT)))
    debug_printf ("O_TEXT/O_BINARY set in flags %p", bin);
  else if (get_r_binset () && get_w_binset ())
    bin = get_r_binary () ? O_BINARY : O_TEXT;	// FIXME: Not quite right
  else if (supplied_bin)
    bin = supplied_bin;
  else if ((fmode = get_default_fmode (flags)) & O_BINARY)
    bin = O_BINARY;
  else if (fmode & O_TEXT)
    bin = O_TEXT;
  else
    bin = get_w_binary () || get_r_binary () || (binmode != O_TEXT) ?
      	  O_BINARY : O_TEXT;

  openflags = flags | bin;

  set_r_binary (bin & O_BINARY);
  set_w_binary (bin & O_BINARY);
  syscall_printf ("filemode set to %s", bin ? "binary" : "text");
}

d217 28
@


1.127
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d845 2
a846 1
  buf->st_atime = buf->st_mtime = buf->st_ctime = time (NULL) - 1;
@


1.126
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@a1023 10
#if 0
  int bin = __fmode & O_TEXT ? 0 : 1;
  if (status != FH_DISK && status != FH_CONSOLE)
    {
      if (!get_r_binset ())
	set_r_binary (bin);
      if (!get_w_binset ())
	set_w_binary (bin);
    }
#endif
@


1.125
log
@* fhandler.cc (fhandler_base::open): Don't set binmode if already set.  Don't
check for file.  Files should already be set.  Report on binary mode for
debugging.
(fhandler_base::fhandler_base): Don't set default binmode here.  That's for
later.
* fhandler_console.cc (fhandler_console::output_tcsetattr): Don't set binmode,
ever, for console.
* fhandler_disk_file.cc (fhandler_disk_file::open): Always set the binary mode
to the value derived from mount table.
* path.cc (mount_info::conv_to_win32_path): Default to binmode if path does not
translate into anything in the mount table.
@
text
@a11 1
#include <sys/fcntl.h>
d60 27
d410 2
a411 4
  if (get_query_open () &&
      isremote () &&
      creation_distribution == OPEN_EXISTING &&
      !pc->exists ())
d451 1
a451 24
  if (get_w_binset () && get_r_binset ())
    syscall_printf ("filemode already set to %d/%d", get_r_binary (), get_w_binary ());
  else
    {
      int bin;
      int fmode;
      if ((bin = flags & (O_BINARY | O_TEXT)))
	/* nothing to do */;
      else if ((fmode = get_default_fmode (flags)) & O_BINARY)
	bin = O_BINARY;
      else if (fmode & O_TEXT)
	bin = O_TEXT;
      else
	bin = get_w_binary () || get_r_binary () || (binmode != O_TEXT);

      if (bin & O_TEXT)
	bin = 0;

      set_flags (flags | (bin ? O_BINARY : O_TEXT));

      set_r_binary (bin);
      set_w_binary (bin);
      syscall_printf ("filemode set to %s", bin ? "binary" : "text");
    }
a852 2
  set_r_binary (bin);
  set_w_binary (bin);
d855 1
a855 1
  int oflags = 0;
d857 1
a857 1
    oflags = O_RDONLY;
d859 1
a859 1
    oflags = O_WRONLY;
d861 2
a862 2
    oflags = O_RDWR;
  set_flags (oflags | (bin ? O_BINARY : O_TEXT));
@


1.124
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d427 2
a428 10
  int bin;
  int fmode;
  if ((bin = flags & (O_BINARY | O_TEXT)))
    /* nothing to do */;
  else if ((fmode = get_default_fmode (flags)) & O_BINARY)
    bin = O_BINARY;
  else if (fmode & O_TEXT)
    bin = O_TEXT;
  else if (get_device () == FH_DISK)
    bin = get_w_binary () || get_r_binary () || 1;
d430 11
a440 1
    bin = get_w_binary () || get_r_binary () || (binmode != O_TEXT);
d442 2
a443 2
  if (bin & O_TEXT)
    bin = 0;
d445 1
a445 1
  set_flags (flags | (bin ? O_BINARY : O_TEXT));
d447 4
a450 3
  set_r_binary (bin);
  set_w_binary (bin);
  syscall_printf ("filemode set to %s", bin ? "binary" : "text");
d865 1
a865 1
  debug_printf ("created new fhandler_base for handle %p", f);
d1025 1
d1034 1
@


1.123
log
@* fhandler.cc (fhandler_base::fstat): Move dev and ino calculation into caller.
* syscalls.cc (stat_worker): Calculate dev and ino calculation here, if zero.
* fhandler_proc.cc (fhandler_proc::fhandler_proc): Minor reorg for debugging.
* fhandler_process.cc (fhandler_process::exists): Return 0 on nonexistence.
(fhandler_process::fstat): Simplify pid logic.
* fhandler_tape.cc (fhandler_dev_tape::fstat): Minor reformatting.
@
text
@a26 1
#include "sigproc.h"
@


1.122
log
@remove accidentally checked in test version.
@
text
@a841 2
  buf->st_dev = buf->st_rdev = FHDEVN (get_device ()) << 8 | (get_unit () & 0xff);
  buf->st_ino = get_namehash ();
@


1.121
log
@* fhandler_console.cc (fhandler_console::open): Reinstate setting of flags.
@
text
@a1171 2
bool fhandler_base::get_w_binary () { return FHISSETF (WBINSET) ? FHISSETF (WBINARY) : 1; }
bool fhandler_base::get_r_binary () { return FHISSETF (RBINSET) ? FHISSETF (RBINARY) : 1; }
@


1.120
log
@* fhandler.cc (fhandler_base::open): Make default open mode == binmode.
(fhandler_base::init): Set open flags based on derived binmode argument.
@
text
@d1172 2
@


1.119
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat): Always call fstat_by_name
if fd is not opened to allow fstat_by_name to properly set errno.
* fhandler.cc (binmode): Default to binmode when mode is not known.
@
text
@d437 1
a437 1
    bin = get_w_binary () || get_r_binary () || O_BINARY;
d439 1
a439 1
    bin = (binmode == O_BINARY) || get_w_binary () || get_r_binary ();
d856 1
d858 6
a863 5
    set_flags (O_RDONLY);
  if (a == GENERIC_WRITE)
    set_flags (O_WRONLY);
  if (a == (GENERIC_READ | GENERIC_WRITE))
    set_flags (O_RDWR);
@


1.118
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d437 1
a437 1
    bin = get_w_binary () || get_r_binary ();
@


1.117
log
@* dtable.cc (dtable::build_fhandler_from_name): Just pass posix path along to
set_name via return_and_clear_normalized_path.
(dtable::build_fhandler): New method with const char * argument.
(dtable::reset_unix_path_name): Eliminate.
(dtable::dup_worker): Use correct build_fhandler method.
* mmap.cc (mmap_record::alloc_fh): Ditto.
* dtable.h (dtable::build_fhandler): New method.
(dtable::reset_unix_path_name): Eliminate.
* fhandler.cc (fhandler_base::set_name): Assume that unix_name has already been
cmalloced.
(fhandler_base::reset_unix_path_name): Eliminate.
(fhandler_base::~fhandler_base): Coercion for cfree.
* fhandler.h (fhandler_base::unix_path_name): Make const char *.
(fhandler_base::win32_path_name): Ditto.
(fhandler_base::reset_unix_path_name): Eliminate.
* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Accommodate const char
*ness of win32_path_name.
* fhandler_socket.cc (fhandler_socket::fstat): Accommodate new set_name
requirements.
* path.cc (path_conv::return_and_clear_normalized_path): New method.
(path_conv::clear_normalized_path): Eliminate.
(path_conv::~path_conv): Ditto.
(path_conv::check): Accommodate new build_fhandler method.
* path.h (path_conv::~path_conv): Eliminate.
(path_conv::clear_normalized_path): Ditto.
(path_conv::return_and_clear_normalized_path): Declare new method.
@
text
@d312 1
a312 1
fhandler_base::open (path_conv *, int flags, mode_t mode)
d321 1
a321 1
  syscall_printf ("(%s, %p)", get_win32_name (), flags);
d378 1
a378 1
        file_attributes |= FILE_ATTRIBUTE_HIDDEN;
d388 1
a388 1
      GetFileAttributes (get_win32_name ()) == INVALID_FILE_ATTRIBUTES)
a448 10

  if (get_device () != FH_TAPE
      && get_device () != FH_FLOPPY
      && get_device () != FH_SERIAL)
    {
      if (flags & O_APPEND)
	SetFilePointer (get_handle(), 0, 0, FILE_END);
      else
	SetFilePointer (get_handle(), 0, 0, FILE_BEGIN);
    }
@


1.116
log
@* fhandler.cc (fhandler_base::lseek): Avoid calling SetFilePointer with high
order part of 64 bit address on OS's which do not support that kind of
operation.  Otherwise Windows 95 will become confused.
@
text
@d164 3
a166 2
      win32_path_name = (char *) cmalloc (HEAP_STR, strlen(fmt) + 16);
      __small_sprintf (win32_path_name, fmt, unit);
d182 1
a182 1
    unix_path_name = cstrdup (unix_path);
d185 6
a190 3
      unix_path_name = cstrdup (win32_path_name);
      for (char *p = unix_path_name; (p = strchr (p, '\\')); p++)
	*p = '/';
a200 7
void
fhandler_base::reset_unix_path_name (const char *unix_path)
{
  cfree (unix_path_name);
  unix_path_name = cstrdup (unix_path);
}

d1047 1
a1047 1
    cfree (unix_path_name);
d1049 1
a1049 1
    cfree (win32_path_name);
@


1.115
log
@* path.h (pathconv_arg): Add PC_POSIX.
(path_conv): Add normalized_path field.
* path.cc (path_conv::~path_conv): New destructor.
(path_conv::check): Set normalized_path, where appropriate.
* dtable.cc (build_fhandler_from_name): Use normalized path from path_conv.
* syscalls.cc (chroot): Ditto.
* cygheap.h: Remove path_prefix_p declaration.  Christopher Faylor
<cgf@@redhat.com> (minor fixups)
* Makefile.in: Add fhandler_proc.o, fhandler_registry.o, fhandler_process.o and
fhandler_virtual.o.
* dtable.cc (dtable::build_fhandler): Add entries for FH_PROC, FH_REGISTRY and
FH_PROCESS.  Set unix_name to the normalized posix path.
* fhandler.h: Add constants for FH_PROC, FH_REGISTRY and FH_PROCESS.  Add class
declarations for fhandler_virtual, fhandler_proc, fhandler_registry and
fhandler_virtual.  Update fhandler_union accordingly.
* fhandler_proc.cc: New file.  Add implementation for fhandler_proc.
* fhandler_virtual.cc: New file.  Add implementation for fhandler_virtual.
* fhandler_process.cc: New file.  Add implementation for fhandler_process.
* fhandler_registry.cc: New file.  Add implementation for fhandler_registry.
* path.cc: Add isproc and isvirtual_dev macros.
* path.cc (path_conv::check): Add check for virtual devices.
* path.cc (mount_info::conv_to_win32_path): Convert paths in /proc to empty
Win32 paths.
* path.cc (chdir): Replace check for FH_CYGDRIVE with more generic
isvirtual_dev macro.  Force setting of posix path for virtual fhandlers.
* path.h: Add externally visible path_prefix_p and normalized_posix_path
prototypes.
@
text
@d735 8
a742 1
  LONG off_high = wincap.has_64bit_file_access () ? offset >> 32 : 0;
d744 2
a745 1
  res = SetFilePointer (get_handle(), off_low, &off_high, win32_whence);
@


1.114
log
@	* fhandler.cc (fhandler_base::open): Set read-only bit in
	file_attributes when adequate.
@
text
@d151 2
a152 1
   be too long (e.g. devices or some such).  */
@


1.113
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@d396 4
@


1.112
log
@* fhandler.cc (fhandler_base::puts_readahead): Remove default parameter
setting.  Newer gcc's complain about this.
(fhandler_base::set_readahead_valid): Ditto.
* fhandler_dsp.cc (Audio::open): Ditto.
(fhandler_dev_dsp::open): Ditto.
@
text
@d30 1
d697 2
a698 2
__off32_t
fhandler_base::lseek (__off32_t offset, int whence)
d700 13
a712 1
  __off32_t res;
d724 1
a724 58
  debug_printf ("lseek (%s, %d, %d)", unix_path_name, offset, whence);

#if 0	/* lseek has no business messing about with text-mode stuff */

  if (!get_r_binary ())
    {
      int newplace;

      if (whence == 0)
	{
	  newplace = offset;
	}
      else if (whence ==1)
	{
	  newplace = rpos +  offset;
	}
      else
	{
	  /* Seek from the end of a file.. */
	  if (rsize == -1)
	    {
	      /* Find the size of the file by reading till the end */

	      char b[CHUNK_SIZE];
	      while (read (b, sizeof (b)) > 0)
		;
	      rsize = rpos;
	    }
	  newplace = rsize + offset;
	}

      if (rpos > newplace)
	{
	  SetFilePointer (handle, 0, 0, 0);
	  rpos = 0;
	}

      /* You can never shrink something more than 50% by turning CRLF into LF,
	 so we binary chop looking for the right place */

      while (rpos < newplace)
	{
	  char b[CHUNK_SIZE];
	  size_t span = (newplace - rpos) / 2;
	  if (span == 0)
	    span = 1;
	  if (span > sizeof (b))
	    span = sizeof (b);

	  debug_printf ("lseek (%s, %d, %d) span %d, rpos %d newplace %d",
		       name, offset, whence,span,rpos, newplace);
	  read (b, span);
	}

      debug_printf ("Returning %d", newplace);
      return newplace;
    }
#endif	/* end of deleted code dealing with text mode */
d729 5
a733 2
  res = SetFilePointer (get_handle(), offset, 0, win32_whence);
  if (res == -1)
d824 1
a824 1
fhandler_base::fstat (struct stat *buf, path_conv *)
d1143 1
a1143 1
__off32_t
d1151 1
a1151 1
fhandler_base::seekdir (DIR *, __off32_t)
@


1.111
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d52 1
a52 1
fhandler_base::puts_readahead (const char *s, size_t len = (size_t) -1)
d101 1
a101 1
fhandler_base::set_readahead_valid (int val, int ch = -1)
@


1.110
log
@	* dir.cc: Use INVALID_FILE_ATTRIBUTES instead of "(DWORD) -1"
	for file attributes throughout.
	* fhandler.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* syscalls.cc: Ditto.
	* times.cc (utimes): Use path_conv::isdir() instead of explicit
	GetFileAttributes() call.
@
text
@d696 2
a697 2
off_t
fhandler_base::lseek (off_t offset, int whence)
d699 1
a699 1
  off_t res;
d1184 1
a1184 1
off_t
d1192 1
a1192 1
fhandler_base::seekdir (DIR *, off_t)
@


1.109
log
@* dtable.cc (dtable::vfork_parent_restore): Add debugging statement.
* exceptions.cc (try_to_debug): Spin only as long as we don't have a debugger
attached.
* fhandler.h (fhandler_base::set_nohandle): New method.
(fhandler_base::get_nohandle): New method.
* fhandler.cc (fhandler_base::dup): Avoid duplicating handle if there is no
handle.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set nohandle flag on
dummy fd.
* Makefile.in: Make intermediate library for eventual inclusion in libcygwin.a
* fhandler.h (fhandler_pipe::fhandler_pipe): Remove default argument setting
since it is no longer used.
* miscfuncs.cc (check_null_str): New function.
(+check_null_str_errno): Ditto.
* net.cc: Add defensive buffer checking throughout.
(cygwin_sendto): Protect against invalid fd.
(cygwin_recvfrom): Ditto.
(cygwin_getpeername): Ditto.
(cygwin_recv): Ditto.
(cygwin_send): Ditto.
* winsup.h: Declare a new function.
* select.cc (set_bits): Fix conditional for setting fd in exceptfds.
* dtable.cc (dtable::build_fhandler): Create fhandler_pipe using correct device
type.
* path.cc (get_devn): Set correct pipe device type from device name.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
d389 1
a389 1
      GetFileAttributes (get_win32_name ()) == (DWORD) -1)
@


1.108
log
@* path.cc (conv_path_list): Fix wild indexing into path due to conflicting
methods for setting src pointer.
* dir.cc (opendir): Only pass path_conv argument to opendir, since name is
already part of the fhandler.
* dtable.cc (dtable::build_fhandler): Accomodate new FH_CYGDRIVE type.
* fhandler.cc (fhandler_base::opendir): Nuke name argument.
* fhandler.h: Add FH_CYGDRIVE to "device" enum.
(fhandler_base::opendir): Nuke name argument.
(fhandler_disk_file::opendir): Ditto.
(fhandler_disk_file::fhandler_disk_file): Declare new method which passes
devtype through.
(fhandler_cygdrive): Add elements for tracking drives.
(fhandler_cygdrive::set_drives): Declare new method.
(fhandler_cygdrive::iscygdrive_root): Declare new method.
(fhandler_cygdrive::opendir): Declare new method.
(fhandler_cygdrive::readdir): Declare new method.
(fhandler_cygdrive::telldir): Declare new method.
(fhandler_cygdrive::seekdir): Declare new method.
(fhandler_cygdrive::rewinddir): Declare new method.
(fhandler_cygdrive::closedir): Declare new method.
(fhandler_cygdrive::fstat): Declare new method.
* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file): Define new
method which passes devtype through.
(fhandler_disk_file::open): Tweak debug output.
(fhandler_disk_file::opendir): Nuke first argument.  Use info from path_conv
and class rather than calling fstat.
(fhandler_cygdrive::set_drives): New method.
(fhandler_cygdrive::iscygdrive_root): New method.
(fhandler_cygdrive::opendir): New method.
(fhandler_cygdrive::readdir): New method.
(fhandler_cygdrive::telldir): New method.
(fhandler_cygdrive::seekdir): New method.
(fhandler_cygdrive::rewinddir): New method.
(fhandler_cygdrive::closedir): New method.
(fhandler_cygdrive::fstat): New method.
* path.cc (iscygdrive_device): Assume cygdriveness is already verified.
(path_conv::check): Treat FH_CYGDRIVE "method" as a special case, setting file
attributes as needed.
(mount_info::conv_to_win32_path): Allow stand-alone /cygdrive, meaning "the
directory which contains all of the drives on the system".
(fillout_mntent): Use cyg_tolower for conversions.
(mount_info::cygdrive_win32_path): Replace unused argument with unit number.
* shared_info.h (mount_info::cygdrive_win32_path): Reflect argument change.
@
text
@d919 3
a921 1
  if (!DuplicateHandle (hMainProc, get_handle(), hMainProc, &nh, 0, TRUE,
d1156 1
a1156 1
int
@


1.107
log
@* Makefile.in (DLL_OFILES): Add fhandler_disk_file.o.
* cygheap.h (cygheap_fdnew::operator =): New operator.
* dir.cc: Add invalid struct checking throughout.  Use methods for all
directory manipulation throughout.
* fhandler.cc: Move fhandler_disk_file stuff to own file.
(fhandler_base::opendir): New method.
(fhandler_base::readdir): New method.
(fhandler_base::telldir): New method.
(fhandler_base::seekdir): New method.
(fhandler_base::rewinddir): New method.
(fhandler_base::closedir): New method.
* fhandler_disk_file.cc: New file.
* fhandler.h (fhandler_base): Declare new virtual methods.
(fhandler_disk_file): Ditto.
(fhandler_cygdrive): New class.
* path.cc (conv_path_list): Use strccpy to break apart path.
@
text
@d1169 1
a1169 1
fhandler_base::opendir (const char *, path_conv&)
@


1.106
log
@	* fhandler.cc (fhandler_disk_file::fstat): Add setting access time
	and creation time to last modification time for files on filesystems
	not supporting multiple timestamps.
	(fhandler_disk_file::fstat_helper): Set access time and creation
	time in incoming Windows structure instead of in stat buf to avoid
	incorrectly overwriting Epoch timestamp.
@
text
@a888 307
static int
num_entries (const char *win32_name)
{
  WIN32_FIND_DATA buf;
  HANDLE handle;
  char buf1[MAX_PATH];
  int count = 0;

  strcpy (buf1, win32_name);
  int len = strlen (buf1);
  if (len == 0 || isdirsep (buf1[len - 1]))
    strcat (buf1, "*");
  else
    strcat (buf1, "/*");	/* */

  handle = FindFirstFileA (buf1, &buf);

  if (handle == INVALID_HANDLE_VALUE)
    return 0;
  count ++;
  while (FindNextFileA (handle, &buf))
    {
      if ((buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	count ++;
    }
  FindClose (handle);
  return count;
}

int
fhandler_disk_file::fstat (struct stat *buf, path_conv *pc)
{
  int res = -1;
  int oret;
  uid_t uid;
  gid_t gid;
  int open_flags = O_RDONLY | O_BINARY | O_DIROPEN;

  if (!pc)
    return fstat_helper (buf);

  if ((oret = open (pc, open_flags, 0)))
    /* ok */;
  else
    {
      int ntsec_atts = 0;
      /* If we couldn't open the file, try a "query open" with no permissions.
	 This will allow us to determine *some* things about the file, at least. */
      set_query_open (TRUE);
      if ((oret = open (pc, open_flags, 0)))
	/* ok */;
      else if (allow_ntsec && pc->has_acls () && get_errno () == EACCES
		&& !get_file_attribute (TRUE, get_win32_name (), &ntsec_atts, &uid, &gid)
		&& !ntsec_atts && uid == myself->uid && gid == myself->gid)
	{
	  /* Check a special case here. If ntsec is ON it happens
	     that a process creates a file using mode 000 to disallow
	     other processes access. In contrast to UNIX, this results
	     in a failing open call in the same process. Check that
	     case. */
	  set_file_attribute (TRUE, get_win32_name (), 0400);
	  oret = open (pc, open_flags, 0);
	  set_file_attribute (TRUE, get_win32_name (), ntsec_atts);
	}
    }
  if (oret)
    {
      res = fstat_helper (buf);
      /* The number of links to a directory includes the
	 number of subdirectories in the directory, since all
	 those subdirectories point to it.
	 This is too slow on remote drives, so we do without it and
	 set the number of links to 2. */
      /* Unfortunately the count of 2 confuses `find (1)' command. So
	 let's try it with `1' as link count. */
      if (pc->isdir ())
	buf->st_nlink = (pc->isremote ()
			 ? 1 : num_entries (pc->get_win32 ()));
      close ();
    }
  else if (pc->exists ())
    {
      /* Unfortunately, the above open may fail if the file exists, though.
	 So we have to care for this case here, too. */
      WIN32_FIND_DATA wfd;
      HANDLE handle;
      buf->st_nlink = 1;
      if (pc->isdir () && pc->isremote ())
	buf->st_nlink = num_entries (pc->get_win32 ());
      buf->st_dev = FHDEVN (FH_DISK) << 8;
      buf->st_ino = hash_path_name (0, pc->get_win32 ());
      if (pc->isdir ())
	buf->st_mode = S_IFDIR;
      else if (pc->issymlink ())
	buf->st_mode = S_IFLNK;
      else if (pc->issocket ())
	buf->st_mode = S_IFSOCK;
      else
	buf->st_mode = S_IFREG;
      if (!pc->has_acls ()
	  || get_file_attribute (TRUE, pc->get_win32 (),
				 &buf->st_mode,
				 &buf->st_uid, &buf->st_gid))
	{
	  buf->st_mode |= STD_RBITS | STD_XBITS;
	  if (!(pc->has_attribute (FILE_ATTRIBUTE_READONLY)))
	    buf->st_mode |= STD_WBITS;
	  if (pc->issymlink ())
	    buf->st_mode |= S_IRWXU | S_IRWXG | S_IRWXO;
	  get_file_attribute (FALSE, pc->get_win32 (),
			      NULL, &buf->st_uid, &buf->st_gid);
	}
      if ((handle = FindFirstFile (pc->get_win32 (), &wfd))
	  != INVALID_HANDLE_VALUE)
	{
	  /* This is for FAT filesystems, which don't support atime/ctime */
	  if (wfd.ftLastAccessTime.dwLowDateTime == 0
	      && wfd.ftLastAccessTime.dwHighDateTime == 0)
	    wfd.ftLastAccessTime = wfd.ftLastWriteTime;
	  if (wfd.ftCreationTime.dwLowDateTime == 0
	      && wfd.ftCreationTime.dwHighDateTime == 0)
	    wfd.ftCreationTime = wfd.ftLastWriteTime;

	  buf->st_atime   = to_time_t (&wfd.ftLastAccessTime);
	  buf->st_mtime   = to_time_t (&wfd.ftLastWriteTime);
	  buf->st_ctime   = to_time_t (&wfd.ftCreationTime);
	  buf->st_size    = wfd.nFileSizeLow;
	  buf->st_blksize = S_BLKSIZE;
	  buf->st_blocks  = ((unsigned long) buf->st_size +
			    S_BLKSIZE-1) / S_BLKSIZE;
	  FindClose (handle);
	}
      res = 0;
    }

  return res;
}

int
fhandler_disk_file::fstat_helper (struct stat *buf)
{
  int res = 0;	// avoid a compiler warning
  BY_HANDLE_FILE_INFORMATION local;
  save_errno saved_errno;

  /* NT 3.51 seems to have a bug when attempting to get vol serial
     numbers.  This loop gets around this. */
  for (int i = 0; i < 2; i++)
    {
      if (!(res = GetFileInformationByHandle (get_handle (), &local)))
	break;
      if (local.dwVolumeSerialNumber && (long) local.dwVolumeSerialNumber != -1)
	break;
    }
  debug_printf ("%d = GetFileInformationByHandle (%s, %d)",
		res, get_win32_name (), get_handle ());
  if (res == 0)
    {
      /* GetFileInformationByHandle will fail if it's given stdin/out/err
	 or a pipe*/
      DWORD lsize, hsize;

      if (GetFileType (get_handle ()) != FILE_TYPE_DISK)
	buf->st_mode = S_IFCHR;

      lsize = GetFileSize (get_handle (), &hsize);
      if (lsize == 0xffffffff && GetLastError () != NO_ERROR)
	buf->st_mode = S_IFCHR;
      else
	buf->st_size = lsize;
      /* We expect these to fail! */
      buf->st_mode |= STD_RBITS | STD_WBITS;
      buf->st_blksize = S_BLKSIZE;
      buf->st_ino = get_namehash ();
      syscall_printf ("0 = fstat (, %p)",  buf);
      return 0;
    }

  if (!get_win32_name ())
    {
      saved_errno.set (ENOENT);
      return -1;
    }

  /* This is for FAT filesystems, which don't support atime/ctime */
  if (local.ftLastAccessTime.dwLowDateTime == 0
      && local.ftLastAccessTime.dwHighDateTime == 0)
    local.ftLastAccessTime = local.ftLastWriteTime;
  if (local.ftCreationTime.dwLowDateTime == 0
      && local.ftCreationTime.dwHighDateTime == 0)
    local.ftCreationTime = local.ftLastWriteTime;

  buf->st_atime   = to_time_t (&local.ftLastAccessTime);
  buf->st_mtime   = to_time_t (&local.ftLastWriteTime);
  buf->st_ctime   = to_time_t (&local.ftCreationTime);
  buf->st_nlink   = local.nNumberOfLinks;
  buf->st_dev     = local.dwVolumeSerialNumber;
  buf->st_size    = local.nFileSizeLow;

  /* Allocate some place to determine the root directory. Need to allocate
     enough so that rootdir can add a trailing slash if path starts with \\. */
  char root[strlen (get_win32_name ()) + 3];
  strcpy (root, get_win32_name ());

  /* Assume that if a drive has ACL support it MAY have valid "inodes".
     It definitely does not have valid inodes if it does not have ACL
     support. */
  switch (has_acls () ? GetDriveType (rootdir (root)) : DRIVE_UNKNOWN)
    {
    case DRIVE_FIXED:
    case DRIVE_REMOVABLE:
    case DRIVE_CDROM:
    case DRIVE_RAMDISK:
      /* Although the documentation indicates otherwise, it seems like
	 "inodes" on these devices are persistent, at least across reboots. */
      buf->st_ino = local.nFileIndexHigh | local.nFileIndexLow;
      break;
    default:
      /* Either the nFileIndex* fields are unreliable or unavailable.  Use the
	 next best alternative. */
      buf->st_ino = get_namehash ();
      break;
    }

  buf->st_blksize = S_BLKSIZE;
  buf->st_blocks  = ((unsigned long) buf->st_size + S_BLKSIZE-1) / S_BLKSIZE;

  buf->st_mode = 0;
  /* Using a side effect: get_file_attibutes checks for
     directory. This is used, to set S_ISVTX, if needed.  */
  if (local.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    buf->st_mode = S_IFDIR;
  else if (get_symlink_p ())
    buf->st_mode = S_IFLNK;
  else if (get_socket_p ())
    buf->st_mode = S_IFSOCK;
  if (get_file_attribute (has_acls (), get_win32_name (), &buf->st_mode,
			  &buf->st_uid, &buf->st_gid) == 0)
    {
      /* If read-only attribute is set, modify ntsec return value */
      if ((local.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
	  && !get_symlink_p ())
	buf->st_mode &= ~(S_IWUSR | S_IWGRP | S_IWOTH);

      if (!(buf->st_mode & S_IFMT))
	buf->st_mode |= S_IFREG;
    }
  else
    {
      buf->st_mode |= STD_RBITS;

      if (!(local.dwFileAttributes & FILE_ATTRIBUTE_READONLY))
	buf->st_mode |= STD_WBITS;
      /* | S_IWGRP | S_IWOTH; we don't give write to group etc */

      if (buf->st_mode & S_IFDIR)
	buf->st_mode |= S_IFDIR | STD_XBITS;
      else if (buf->st_mode & S_IFMT)
	/* nothing */;
      else if (get_socket_p ())
	buf->st_mode |= S_IFSOCK;
      else
	switch (GetFileType (get_handle ()))
	  {
	  case FILE_TYPE_CHAR:
	  case FILE_TYPE_UNKNOWN:
	    buf->st_mode |= S_IFCHR;
	    break;
	  case FILE_TYPE_DISK:
	    buf->st_mode |= S_IFREG;
	    if (!dont_care_if_execable () && !get_execable_p ())
	      {
		DWORD cur, done;
		char magic[3];

		/* First retrieve current position, set to beginning
		   of file if not already there. */
		cur = SetFilePointer (get_handle(), 0, NULL, FILE_CURRENT);
		if (cur != INVALID_SET_FILE_POINTER &&
		    (!cur ||
		     SetFilePointer (get_handle(), 0, NULL, FILE_BEGIN)
		     != INVALID_SET_FILE_POINTER))
		  {
		    /* FIXME should we use /etc/magic ? */
		    magic[0] = magic[1] = magic[2] = '\0';
		    if (ReadFile (get_handle (), magic, 3, &done, NULL) &&
			has_exec_chars (magic, done))
			set_execable_p ();
		    SetFilePointer (get_handle(), cur, NULL, FILE_BEGIN);
		  }
	      }
	    if (get_execable_p ())
	      buf->st_mode |= STD_XBITS;
	    break;
	  case FILE_TYPE_PIPE:
	    buf->st_mode |= S_IFSOCK;
	    break;
	  }
    }

  syscall_printf ("0 = fstat (, %p) st_atime=%x st_size=%d, st_mode=%p, st_ino=%d, sizeof=%d",
		 buf, buf->st_atime, buf->st_size, buf->st_mode,
		 (int) buf->st_ino, sizeof (*buf));

  return 0;
}

a1084 228
/* fhandler_disk_file */

fhandler_disk_file::fhandler_disk_file () :
	fhandler_base (FH_DISK)
{
}

int
fhandler_disk_file::open (path_conv *real_path, int flags, mode_t mode)
{
  if (real_path->case_clash && flags & O_CREAT)
    {
      debug_printf ("Caseclash detected.");
      set_errno (ECASECLASH);
      return 0;
    }

  if (real_path->isbinary ())
    {
      set_r_binary (1);
      set_w_binary (1);
    }

  set_has_acls (real_path->has_acls ());
  set_isremote (real_path->isremote ());

  if (real_path->isdir ())
    flags |= O_DIROPEN;

  int res = this->fhandler_base::open (real_path, flags, mode);

  if (!res)
    goto out;

  /* This is for file systems known for having a buggy CreateFile call
     which might return a valid HANDLE without having actually opened
     the file.
     The only known file system to date is the SUN NFS Solstice Client 3.1
     which returns a valid handle when trying to open a file in a nonexistent
     directory. */
  if (real_path->has_buggy_open ()
      && GetFileAttributes (win32_path_name) == (DWORD) -1)
    {
      debug_printf ("Buggy open detected.");
      close ();
      set_errno (ENOENT);
      return 0;
    }

  if (flags & O_APPEND)
    SetFilePointer (get_handle(), 0, 0, FILE_END);

  set_symlink_p (real_path->issymlink ());
  set_execable_p (real_path->exec_state ());
  set_socket_p (real_path->issocket ());

out:
  syscall_printf ("%d = fhandler_disk_file::open (%s, %p)", res,
		  get_win32_name (), flags);
  return res;
}

int
fhandler_disk_file::close ()
{
  int res = this->fhandler_base::close ();
  if (!res)
    cygwin_shared->delqueue.process_queue ();
  return res;
}

/*
 * FIXME !!!
 * The correct way to do this to get POSIX locking
 * semantics is to keep a linked list of posix lock
 * requests and map them into Win32 locks. The problem
 * is that Win32 does not deal correctly with overlapping
 * lock requests. Also another pain is that Win95 doesn't do
 * non-blocking or non exclusive locks at all. For '95 just
 * convert all lock requests into blocking,exclusive locks.
 * This shouldn't break many apps but denying all locking
 * would.
 * For now just convert to Win32 locks and hope for the best.
 */

int
fhandler_disk_file::lock (int cmd, struct flock *fl)
{
  int win32_start;
  int win32_len;
  DWORD win32_upper;
  DWORD startpos;

  /*
   * We don't do getlck calls yet.
   */

  if (cmd == F_GETLK)
    {
      set_errno (ENOSYS);
      return -1;
    }

  /*
   * Calculate where in the file to start from,
   * then adjust this by fl->l_start.
   */

  switch (fl->l_whence)
    {
      case SEEK_SET:
	startpos = 0;
	break;
      case SEEK_CUR:
	if ((off_t) (startpos = lseek (0, SEEK_CUR)) == (off_t)-1)
	  return -1;
	break;
      case SEEK_END:
	{
	  BY_HANDLE_FILE_INFORMATION finfo;
	  if (GetFileInformationByHandle (get_handle(), &finfo) == 0)
	    {
	      __seterrno ();
	      return -1;
	    }
	  startpos = finfo.nFileSizeLow; /* Nowhere to keep high word */
	  break;
	}
      default:
	set_errno (EINVAL);
	return -1;
    }

  /*
   * Now the fun starts. Adjust the start and length
   *  fields until they make sense.
   */

  win32_start = startpos + fl->l_start;
  if (fl->l_len < 0)
    {
      win32_start -= fl->l_len;
      win32_len = -fl->l_len;
    }
  else
    win32_len = fl->l_len;

  if (win32_start < 0)
    {
      /* watch the signs! */
      win32_len -= -win32_start;
      if (win32_len <= 0)
	{
	  /* Failure ! */
	  set_errno (EINVAL);
	  return -1;
	}
      win32_start = 0;
    }

  /*
   * Special case if len == 0 for POSIX means lock
   * to the end of the entire file (and all future extensions).
   */
  if (win32_len == 0)
    {
      win32_len = 0xffffffff;
      win32_upper = wincap.lock_file_highword ();
    }
  else
    win32_upper = 0;

  BOOL res;

  if (wincap.has_lock_file_ex ())
    {
      DWORD lock_flags = (cmd == F_SETLK) ? LOCKFILE_FAIL_IMMEDIATELY : 0;
      lock_flags |= (fl->l_type == F_WRLCK) ? LOCKFILE_EXCLUSIVE_LOCK : 0;

      OVERLAPPED ov;

      ov.Internal = 0;
      ov.InternalHigh = 0;
      ov.Offset = (DWORD)win32_start;
      ov.OffsetHigh = 0;
      ov.hEvent = (HANDLE) 0;

      if (fl->l_type == F_UNLCK)
	{
	  res = UnlockFileEx (get_handle (), 0, (DWORD)win32_len, win32_upper, &ov);
	}
      else
	{
	  res = LockFileEx (get_handle (), lock_flags, 0, (DWORD)win32_len,
							win32_upper, &ov);
	  /* Deal with the fail immediately case. */
	  /*
	   * FIXME !! I think this is the right error to check for
	   * but I must admit I haven't checked....
	   */
	  if ((res == 0) && (lock_flags & LOCKFILE_FAIL_IMMEDIATELY) &&
			    (GetLastError () == ERROR_LOCK_FAILED))
	    {
	      set_errno (EAGAIN);
	      return -1;
	    }
	}
    }
  else
    {
      /* Windows 95 -- use primitive lock call */
      if (fl->l_type == F_UNLCK)
	res = UnlockFile (get_handle (), (DWORD)win32_start, 0, (DWORD)win32_len,
							win32_upper);
      else
	res = LockFile (get_handle (), (DWORD)win32_start, 0, (DWORD)win32_len, win32_upper);
    }

  if (res == 0)
    {
      __seterrno ();
      return -1;
    }

  return 0;
}

/**********************************************************************/
d1166 42
@


1.105
log
@	* dir.cc (mkdir): Add HIDDEN file attribute if file has leading dot
	and HIDDEN_DOT_FILES is defined.
	* fhandler.cc (fhandler_base::open): Ditto.
	* path.cc (symlink): Ditto.
	* syscalls.cc (_rename): Ditto and remove HIDDEN file attribute if
	new filename does not begin with a dot.
@
text
@d1004 8
d1073 8
a1086 6

  /* This is for FAT filesystems, which don't support atime/ctime */
  if (buf->st_atime == 0)
    buf->st_atime = buf->st_mtime;
  if (buf->st_ctime == 0)
    buf->st_ctime = buf->st_mtime;
@


1.104
log
@Eliminate excess whitespace.
@
text
@d374 9
@


1.103
log
@* fhandler.cc (fhandler_base::read): Return just read ahead characters if slow
device.
* fhandler.h (fhandler_base::set_eof): New virtual method.
(fhandler_pipe::set_eof): New method.
* pipe.cc (fhandler_pipe::fhandler_pipe): Clear saweof flag.
(fhandler_pipe::read): Return immediately if hit eof.
(fhandler_pipe::hit_eof): Return true if saweof flag is set.
* select.cc (peek_pipe): Don't call PeekNamedPipe if we couldn't grab the guard
mutex.
@
text
@d392 1
a392 1
      		  file_attributes, 0);
d930 1
a930 1
        /* ok */;
d934 1
a934 1
        {
d943 1
a943 1
        }
@


1.102
log
@* dtable.cc (dtable::build_fhandler): Issue internal error on unknown device.
* fhandler.cc (fhandler_base::close): Show both name and handle in debugging
output.
* fhandler.h (fhandler_base::get_guard): New virtual method.
(fhandler_pipe::get_guard): New method.
(fhandler_socket::ready_for_read): Delete declaration.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(struct select_record::peek): Declare new method.
* select.cc (MAKEready): Delete.
(peek_pipe): Use get_guard method to retrieve potential guard mutex handle.
(fhandler_base::ready_for_read): Rewrite as generic ready-for-read handler.
Should only be called for "slow" devices.
(fhandler_socket::ready_for_read): Delete definition.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(fhandler_pipe::select_read): Fill in new peek record in select_record
structure.
(fhandler_console::select_read): Ditto.
(fhandler_tty_common::select_read): Ditto.
(fhandler_serial::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_tty_slave::ready_for_read): Check for tty not open.  Set errnos
appropriately.
* syscalls.cc (_read): Allow ready_for_read to set errno.
* pinfo.cc (pinfo::init): Return spawn/NO_WAIT process as valid if it is
initializing.
* sigproc.cc (getsem): Adjust wait for process to initialize downward to avoid
huge waits.
@
text
@d482 3
@


1.101
log
@* fhandler.cc (fhandler_base::fork_fixup): Pass old handle to setclexec_pid.
@
text
@d787 1
a787 1
  syscall_printf ("handle %p", get_handle());
@


1.100
log
@* fhandler.cc (fhandler_base::set_name): Set namehash here to catch name
changes.
(fhandler_base::open): Remove namehash setting.
(fhandler_base::fstat): Subtract 1 from arbitrary time setting to avoid strange
ls -l granularity problem.
* shared_info.h (MOUNT_VE
@
text
@d1647 1
a1647 1
      setclexec_pid (h, h, !get_close_on_exec ());
@


1.99
log
@Ensure that all fhandler_*::read definitions are __stdcall throughout.
* fhandler.cc (fhandler_base::set_inheritance): Be more defensive in debugging
code.
* fhandler.h: Adjust regparms throughout to reflect passing 'this' parameter.
* fhandler_console.cc (fhandler_console::read): Remove unneeded test.  Only
honor "key down" events.
* miscfuncs.cc (strcasestr): Reorganize for efficient code use.
(check_null_empty_str_errno): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
* syscalls.cc (_read): Return 0 when length == 0, as per Single UNIX
Specification.
@
text
@d192 1
a414 1
  namehash = hash_path_name (0, get_win32_name ());
d873 1
a873 1
  buf->st_atime = buf->st_mtime = buf->st_ctime = time (NULL);
@


1.98
log
@* debug.cc (set_errno): Return value of errno that was set, just like the
macro.
(setclexec_pid): Replace old handle with new handle.
* debug.h: Reflect change in arguments for setclexec_pid.
* fhandler.cc (fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* cygerrno.h: Reflect return value change for set_errno.
@
text
@d1614 1
d1616 1
d1626 2
a1627 1
  setclexec_pid (oh, h, not_inheriting);
@


1.97
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d1614 1
d1624 1
a1624 1
  setclexec_pid (h, not_inheriting);
d1644 1
a1644 1
      setclexec_pid (h, !get_close_on_exec ());
@


1.96
log
@* fhandler.cc (fhandler_base::fork_fixup): Guard against compiler warning.
@
text
@d1333 1
a1346 1
  status = devtype;
a1374 1
  set_cb (sizeof *this);
a1602 1
  set_cb (sizeof *this);
@


1.95
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d1632 1
d1634 1
@


1.94
log
@* autoload.cc (load_wsock32): Declare dummy function to force loading of
winsock.
* fhandler.cc (fhandler_base::set_inheritance): Make debugging output more
verbose.
* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Force loading of
winsock32 if winsock2 not available.
* net.cc (set_socket_inheritance): Use DuplicateHandle in all cases to set
inheritance correctly.
(fdsock): Use winsock2_active macro to determine when to set socket
inheritance.  Remove fdtab resource locking since this function should already
be protected.
(cygwin_accept): Simplify logic.  Ensure that fdtab unlock is not called
inappropriately.
(cygwin_rcmd): Use fdtab locking.
(cygwin_rresvport): Ditto.
(cygwin_rexec): Ditto.
* select.cc (peek_socket): Set errno appropriately if winsock select fails.
* winsup.h: Declare check_pty_fds.
* syscalls.cc (check_pty_fds): Rename from check_ttys_fds.  Also check pty
master.
(setsid): Use check_pty_fds.
* dtable.cc (dtable::dec_console_fds): Add check on pty fds.
@
text
@d1642 1
a1642 1
      ProtectHandle1 (h, name);
@


1.93
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d1632 2
a1633 1
  if (!get_close_on_exec ())
d1635 1
a1635 1
  else if (!DuplicateHandle (parent, h, hMainProc, &h, 0, 0,
d1638 1
a1638 1
#ifdef DEBUG
d1641 1
d1643 1
a1643 1
      setclexec_pid (h, 0);
@


1.92
log
@        * fhandler.cc (fhandler_disk_file::open): Add missing case clash check.
@
text
@d1332 1
a1332 1
fhandler_base::fhandler_base (DWORD devtype, const char *name, int unit):
d1372 2
a1373 2
fhandler_disk_file::fhandler_disk_file (const char *name) :
	fhandler_base (FH_DISK, name)
d1601 2
a1602 2
fhandler_dev_null::fhandler_dev_null (const char *name) :
	fhandler_base (FH_NULL, name)
@


1.91
log
@* fhandler.cc (fhandler_base::fork_fixup): Protect dup'ed handle and record it
as non-inheritable for debugging purposes in case there is a subsequent fork or
exec.
* fhandler_tty.cc (fhandler_tty_common::fixup_after_fork): Allow fork_fixup to
call ProtecHandle.
@
text
@d1381 7
@


1.90
log
@Add second path_conv * argument to fstat()s throughout.
* fhandler.h: Change read and fstat to regparm/stdcall throughout.
(fhandler_base::fstat): Just declare.  Don't define.
(fhandler_disk_file::fstat_helper): Declare.
* fhandler.cc (fhandler_base::fstat): Move here from fhandler.h, adapt from
former stat_dev().
(fhandler_disk_file::fstat): Move most of the disk-file-specific logic from
stat_worker to here.  Use fstat_helper to derive final fstat output.
(fhandler_disk_file::fstat_helper): New method, renamed from former fstat
method.
(num_entries): Moved here from syscalls.cc.
* fhandler_mem.cc (fhandler_dev_mem::fstat): Use base class to initialize most
stuff.  Invert has_physical_mem_access test for establishing permissions.
* fhandler_raw.cc (fhandler_dev_raw::fstat): Eliminate unneed test and memory
clearing.  Use base class to initialize most stuff.
* syscalls.cc (stat_dev): Eliminate.
(stat_worker): Simply call fstat method to generate fstat output.  Move all
device specific code to appropriate fstats.
* dir.cc (opendir): Pass correct arg to stat_worker to allow following
symlinks.
@
text
@d1627 2
a1628 2
  else if (!DuplicateHandle (parent, h, hMainProc, &h, 0, !get_close_on_exec (),
			DUPLICATE_SAME_ACCESS))
d1630 7
@


1.89
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d27 2
d852 54
d907 102
a1008 1
fhandler_disk_file::fstat (struct stat *buf)
a1012 2

  memset (buf, 0, sizeof (*buf));
@


1.88
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d308 1
d310 1
a310 9
fhandler_base::open (path_conv& real_path, int flags, mode_t mode)
{
  return open ((char *) real_path, flags, mode);
}

/* Open system call handler function.
   Path is now already checked for symlinks */
int
fhandler_base::open (int flags, mode_t mode)
d388 2
a389 4
  x = CreateFileA (get_win32_name (), access, shared,
		   &sa, creation_distribution,
		   file_attributes,
		   0);
d392 2
a393 3
		  x, get_win32_name (), access, shared,
		  &sa, creation_distribution,
		  file_attributes);
d1224 1
a1224 24
fhandler_disk_file::open (const char *path, int flags, mode_t mode)
{
  syscall_printf ("(%s, %p)", path, flags);

  /* O_NOSYMLINK is an internal flag for implementing lstat, nothing more. */
  path_conv real_path (path, (flags & O_NOSYMLINK) ?
			     PC_SYM_NOFOLLOW : PC_SYM_FOLLOW);

  if (real_path.error &&
      (flags & O_NOSYMLINK || real_path.error != ENOENT
       || !(flags & O_CREAT) || real_path.case_clash))
    {
      set_errno (flags & O_CREAT && real_path.case_clash ? ECASECLASH
							 : real_path.error);
      syscall_printf ("0 = fhandler_disk_file::open (%s, %p)", path, flags);
      return 0;
    }

  set_name (path, real_path.get_win32 ());
  return open (real_path, flags, mode);
}

int
fhandler_disk_file::open (path_conv& real_path, int flags, mode_t mode)
d1226 1
a1226 1
  if (real_path.isbinary ())
d1232 2
a1233 2
  set_has_acls (real_path.has_acls ());
  set_isremote (real_path.isremote ());
d1235 1
a1235 1
  if (real_path.isdir ())
d1238 1
a1238 1
  int res = this->fhandler_base::open (flags, mode);
d1249 1
a1249 1
  if (real_path.has_buggy_open ()
d1261 3
a1263 3
  set_symlink_p (real_path.issymlink ());
  set_execable_p (real_path.exec_state ());
  set_socket_p (real_path.issocket ());
@


1.87
log
@* dtable.cc (dtable::build_fhandler): Accept an optional path_conv argument.
If available, use this to calculate path name and device number.
* dtable.h (dtable): Reflect above change.
* fhandler.h (fhandler_base): Declare virtual method which accepts path_conv
rather than path string as first argument.
* fhandler.cc (fhandler_base::open): Define above new method.
* syscalls.cc (_open): Set aside a path_conv variable for use in build_fhandler
and subsequent call to open.
@
text
@d23 1
a25 1
#include "path.h"
d27 1
a30 2
static NO_COPY char fhandler_disk_dummy_name[] = "some disk file";

d148 1
a148 3
   be too long (e.g. devices or some such).
*/

a151 9
  if (!no_free_names ())
    {
      if (unix_path_name != NULL && unix_path_name != fhandler_disk_dummy_name)
	cfree (unix_path_name);
      if (win32_path_name != NULL && unix_path_name != fhandler_disk_dummy_name)
	cfree (win32_path_name);
    }

  unix_path_name = win32_path_name = NULL;
a154 7
  unix_path_name = cstrdup (unix_path);
  if (unix_path_name == NULL)
    {
      system_printf ("fatal error. strdup failed");
      exit (ENOMEM);
    }

d169 28
d247 7
d335 1
a335 3
    {
      access = 0;
    }
d337 1
a337 3
    {
      access = GENERIC_READ | GENERIC_WRITE;
    }
d339 1
a339 3
    {
      access = GENERIC_READ;
    }
d341 1
a341 3
    {
      access = GENERIC_WRITE;
    }
d343 1
a343 3
    {
      access = GENERIC_READ | GENERIC_WRITE;
    }
d347 1
a347 3
    {
      access |= GENERIC_READ;
    }
d354 1
a354 3
	{
	  creation_distribution = CREATE_ALWAYS;
	}
d356 1
a356 3
	{
	  creation_distribution = TRUNCATE_EXISTING;
	}
d364 1
a364 3
    {
      creation_distribution = CREATE_NEW;
    }
a868 3
  if (is_device ())
    return stat_dev (get_device (), get_unit (), get_namehash (), buf);

d1197 2
a1209 2
  unix_path_name  = win32_path_name  = NULL;
  set_name (name, NULL, unit);
d1215 4
a1218 7
  if (!no_free_names ())
    {
      if (unix_path_name != NULL && unix_path_name != fhandler_disk_dummy_name)
	cfree (unix_path_name);
      if (win32_path_name != NULL && win32_path_name != fhandler_disk_dummy_name)
	cfree (win32_path_name);
    }
a1230 2
  set_no_free_names ();
  unix_path_name = win32_path_name = fhandler_disk_dummy_name;
a1252 1
  set_no_free_names (0);
a1258 6
  if (get_win32_name () == fhandler_disk_dummy_name)
    {
      win32_path_name = real_path.get_win32 ();
      set_no_free_names ();
    }

d1268 1
a1268 2
  if (real_path.file_attributes () != (DWORD)-1
      && (real_path.file_attributes () & FILE_ATTRIBUTE_DIRECTORY))
@


1.87.2.1
log
@Merged changes from HEAD
@
text
@a22 1
#include "path.h"
d25 1
a26 1
#include <assert.h>
d30 2
d149 3
a151 1
   be too long (e.g. devices or some such).  */
d155 9
d167 7
a187 28

  assert (unix_path_name == NULL);
  /* FIXME: This isn't really right.  It ignores the first argument if we're
     building names for a device and just converts the device name from the
     win32 name since it has theoretically been previously detected by
     path_conv. Ideally, we should pass in a format string and build the
     unix_path, too. */
  if (!is_device () || *win32_path_name != '\\')
    unix_path_name = cstrdup (unix_path);
  else
    {
      unix_path_name = cstrdup (win32_path_name);
      for (char *p = unix_path_name; (p = strchr (p, '\\')); p++)
	*p = '/';
    }

  if (unix_path_name == NULL)
    {
      system_printf ("fatal error. strdup failed");
      exit (ENOMEM);
    }
}

void
fhandler_base::reset_unix_path_name (const char *unix_path)
{
  cfree (unix_path_name);
  unix_path_name = cstrdup (unix_path);
a237 7
	case ERROR_INVALID_FUNCTION:
	case ERROR_INVALID_PARAMETER:
	  if (openflags & O_DIROPEN)
	    {
	      set_errno (EISDIR);
	      return -1;
	    }
d319 3
a321 1
    access = 0;
d323 3
a325 1
    access = GENERIC_READ | GENERIC_WRITE;
d327 3
a329 1
    access = GENERIC_READ;
d331 3
a333 1
    access = GENERIC_WRITE;
d335 3
a337 1
    access = GENERIC_READ | GENERIC_WRITE;
d341 3
a343 1
    access |= GENERIC_READ;
d350 3
a352 1
	creation_distribution = CREATE_ALWAYS;
d354 3
a356 1
	creation_distribution = TRUNCATE_EXISTING;
d364 3
a366 1
    creation_distribution = CREATE_NEW;
d871 3
a1201 2
  unix_path_name (NULL),
  win32_path_name (NULL),
d1213 2
d1220 7
a1226 4
  if (unix_path_name != NULL)
    cfree (unix_path_name);
  if (win32_path_name != NULL)
    cfree (win32_path_name);
d1239 2
d1263 1
d1270 6
d1285 2
a1286 1
  if (real_path.isdir ())
@


1.87.2.2
log
@Merged changes from HEAD
@
text
@a26 2
#include "sigproc.h"
#include "pinfo.h"
a189 1
  namehash = hash_path_name (0, win32_path_name);
a307 1
/* Open system call handler function. */
d309 9
a317 1
fhandler_base::open (path_conv *, int flags, mode_t mode)
a377 9
#ifdef HIDDEN_DOT_FILES
  if (flags & O_CREAT && get_device () == FH_DISK)
    {
      char *c = strrchr (get_win32_name (), '\\');
      if ((c && c[1] == '.') || *get_win32_name () == '.')
        file_attributes |= FILE_ATTRIBUTE_HIDDEN;
    }
#endif

d395 4
a398 2
  x = CreateFile (get_win32_name (), access, shared, &sa, creation_distribution,
		  file_attributes, 0);
d401 3
a403 2
		  x, get_win32_name (), access, shared, &sa,
		  creation_distribution, file_attributes);
d422 1
a489 3
  if (copied_chars && is_slow ())
    return copied_chars;

d795 1
a795 1
  syscall_printf ("closing '%s' handle %p", get_name (), get_handle());
d860 2
a861 2
int __stdcall
fhandler_base::fstat (struct stat *buf, path_conv *)
d863 18
a880 1
  switch (get_device ())
d882 56
a937 5
    case FH_PIPEW:
      buf->st_mode = STD_WBITS | S_IWGRP | S_IWOTH;
      break;
    case FH_PIPER:
      buf->st_mode = STD_RBITS;
d940 3
a942 1
      buf->st_mode = STD_RBITS | STD_WBITS | S_IWGRP | S_IWOTH;
a945 2
  buf->st_mode |= get_device () == FH_FLOPPY ? S_IFBLK : S_IFCHR;
  buf->st_nlink = 1;
d947 79
a1025 3
  buf->st_dev = buf->st_rdev = FHDEVN (get_device ()) << 8 | (get_unit () & 0xff);
  buf->st_ino = get_namehash ();
  buf->st_atime = buf->st_mtime = buf->st_ctime = time (NULL) - 1;
d1059 1
a1059 3
  if (get_nohandle ())
    nh = NULL;
  else if (!DuplicateHandle (hMainProc, get_handle(), hMainProc, &nh, 0, TRUE,
d1187 1
a1187 2
fhandler_base::fhandler_base (DWORD devtype, int unit):
  status (devtype),
d1201 1
d1225 245
d1472 2
a1473 2
fhandler_dev_null::fhandler_dev_null () :
	fhandler_base (FH_NULL)
d1475 1
a1486 3
#ifdef DEBUGGING
  HANDLE oh = h;
#endif
d1496 1
a1496 2
  if (h)
    setclexec_pid (oh, h, not_inheriting);
d1503 1
a1503 4
#ifdef DEBUGGING
  HANDLE oh = h;
#endif
  if (/* !is_socket () && */ !get_close_on_exec ())
d1506 1
a1506 1
			     DUPLICATE_SAME_ACCESS))
a1507 8
#ifdef DEBUGGING
  else
    {
      debug_printf ("%s success - oldh %p, h %p", get_name (), oh, h);
      // someday, maybe ProtectHandle2 (h, name);
      setclexec_pid (oh, h, !get_close_on_exec ());
    }
#endif
d1525 1
a1525 1
bool
a1536 42
}

DIR *
fhandler_base::opendir (path_conv&)
{
  set_errno (ENOTDIR);
  return NULL;
}

struct dirent *
fhandler_base::readdir (DIR *)
{
  set_errno (ENOTDIR);
  return NULL;
}

off_t
fhandler_base::telldir (DIR *)
{
  set_errno (ENOTDIR);
  return -1;
}

void
fhandler_base::seekdir (DIR *, off_t)
{
  set_errno (ENOTDIR);
  return;
}

void
fhandler_base::rewinddir (DIR *)
{
  set_errno (ENOTDIR);
  return;
}

int
fhandler_base::closedir (DIR *)
{
  set_errno (ENOTDIR);
  return -1;
@


1.87.2.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d389 1
a389 1
      GetFileAttributes (get_win32_name ()) == INVALID_FILE_ATTRIBUTES)
@


1.87.2.4
log
@Merged changes from HEAD
@
text
@a29 1
#include <limits.h>
d52 1
a52 1
fhandler_base::puts_readahead (const char *s, size_t len)
d101 1
a101 1
fhandler_base::set_readahead_valid (int val, int ch)
d696 2
a697 2
__off64_t
fhandler_base::lseek (__off64_t offset, int whence)
d699 1
a699 13
  __off64_t res;

  /* 9x/Me doesn't support 64bit offsets.  We trap that here and return
     EINVAL.  It doesn't make sense to simulate bigger offsets by a
     SetFilePointer sequence since FAT and FAT32 don't support file
     size >= 4GB anyway. */
  if (!wincap.has_64bit_file_access ()
      && (offset < LONG_MIN || offset > LONG_MAX))
    {
      debug_printf ("Win9x, offset not 32 bit.");
      set_errno (EINVAL);
      return (__off64_t)-1;
    }
d711 58
a768 1
  debug_printf ("lseek (%s, %D, %d)", unix_path_name, offset, whence);
d773 2
a774 5
  LONG off_low = offset & 0xffffffff;
  LONG off_high = wincap.has_64bit_file_access () ? offset >> 32 : 0;

  res = SetFilePointer (get_handle(), off_low, &off_high, win32_whence);
  if (res == INVALID_SET_FILE_POINTER && GetLastError ())
d865 1
a865 1
fhandler_base::fstat (struct __stat64 *buf, path_conv *)
d1184 1
a1184 1
__off64_t
d1192 1
a1192 1
fhandler_base::seekdir (DIR *, __off64_t)
@


1.87.2.5
log
@Merged changes from HEAD
@
text
@d12 1
d27 1
a61 27
void
fhandler_base::set_flags (int flags, int supplied_bin)
{
  int bin;
  int fmode;
  debug_printf ("flags %p, supplied_bin %p", flags, supplied_bin);
  if ((bin = flags & (O_BINARY | O_TEXT)))
    debug_printf ("O_TEXT/O_BINARY set in flags %p", bin);
  else if (get_r_binset () && get_w_binset ())
    bin = get_r_binary () ? O_BINARY : O_TEXT;	// FIXME: Not quite right
  else if (supplied_bin)
    bin = supplied_bin;
  else if ((fmode = get_default_fmode (flags)) & O_BINARY)
    bin = O_BINARY;
  else if (fmode & O_TEXT)
    bin = O_TEXT;
  else
    bin = get_w_binary () || get_r_binary () || (binmode != O_TEXT) ?
      	  O_BINARY : O_TEXT;

  openflags = flags | bin;

  set_r_binary (bin & O_BINARY);
  set_w_binary (bin & O_BINARY);
  syscall_printf ("filemode set to %s", bin ? "binary" : "text");
}

d151 1
a151 2
   be too long (e.g. devices or some such).
   The unix_path_name is also used by virtual fhandlers.  */
d163 2
a164 3
      char *w =  (char *) cmalloc (HEAP_STR, strlen(fmt) + 16);
      __small_sprintf (w, fmt, unit);
      win32_path_name = w;
d180 1
a180 1
    unix_path_name = unix_path;
d183 3
a185 6
      char *p = cstrdup (win32_path_name);
      unix_path_name = p;
      while ((p = strchr (p, '\\')) != NULL)
	*p++ = '/';
      if (unix_path)
	cfree ((void *) unix_path);
d196 7
d314 1
a314 1
fhandler_base::open (path_conv *pc, int flags, mode_t mode)
d323 1
a323 1
  syscall_printf ("(%s, %p) query_open %d", get_win32_name (), flags, get_query_open ());
d380 1
a380 1
	file_attributes |= FILE_ATTRIBUTE_HIDDEN;
d387 4
a390 2
  if (get_query_open () && isremote () &&
      creation_distribution == OPEN_EXISTING && pc && !pc->exists ())
a395 4
  /* If mode has no write bits set, we set the R/O attribute. */
  if (!(mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
    file_attributes |= FILE_ATTRIBUTE_READONLY;

d426 31
a456 1
  set_flags (flags, pc ? pc->binmode () : 0);
d730 1
a730 8
  LONG *poff_high, off_high;
  if (!wincap.has_64bit_file_access ())
    poff_high = NULL;
  else
    {
      off_high =  offset >> 32;
      poff_high = &off_high;
    }
d732 1
a732 2
  debug_printf ("setting file pointer to %u (high), %u (low)", off_high, off_low);
  res = SetFilePointer (get_handle(), off_low, poff_high, win32_whence);
d842 3
a844 2
  time_as_timestruc_t (&buf->st_ctim);
  buf->st_atim = buf->st_mtim = buf->st_ctim;
d852 2
a855 1
  int flags = 0;
d857 5
a861 6
    flags = O_RDONLY;
  else if (a == GENERIC_WRITE)
    flags = O_WRONLY;
  else if (a == (GENERIC_READ | GENERIC_WRITE))
    flags = O_RDWR;
  set_flags (flags, bin);
d863 1
a863 1
  debug_printf ("created new fhandler_base for handle %p, bin %d", f, get_r_binary ());
d1023 8
d1037 1
a1037 1
    cfree ((void *) unix_path_name);
d1039 1
a1039 1
    cfree ((void *) win32_path_name);
@


1.87.2.6
log
@Merged changes from HEAD
@
text
@d60 27
a243 28
}

void
fhandler_base::set_flags (int flags, int supplied_bin)
{
  int bin;
  int fmode;
  debug_printf ("flags %p, supplied_bin %p", flags, supplied_bin);
  if ((bin = flags & (O_BINARY | O_TEXT)))
    debug_printf ("O_TEXT/O_BINARY set in flags %p", bin);
  else if (get_r_binset () && get_w_binset ())
    bin = get_r_binary () ? O_BINARY : O_TEXT;	// FIXME: Not quite right
  else if ((fmode = get_default_fmode (flags)) & O_BINARY)
    bin = O_BINARY;
  else if (fmode & O_TEXT)
    bin = O_TEXT;
  else if (supplied_bin)
    bin = supplied_bin;
  else
    bin = get_w_binary () || get_r_binary () || (binmode != O_TEXT) ?
      	  O_BINARY : O_TEXT;

  openflags = flags | bin;

  bin &= O_BINARY;
  set_r_binary (bin);
  set_w_binary (bin);
  syscall_printf ("filemode set to %s", bin ? "binary" : "text");
@


1.87.2.7
log
@Merged changes from HEAD
@
text
@a831 3
    case FH_PIPE:
      buf->st_mode = S_IFIFO | STD_RBITS | STD_WBITS | S_IWGRP | S_IWOTH;
      break;
d833 1
a833 1
      buf->st_mode = S_IFIFO | STD_WBITS | S_IWGRP | S_IWOTH;
d836 1
a836 4
      buf->st_mode = S_IFIFO | STD_RBITS;
      break;
    case FH_FLOPPY:
      buf->st_mode = S_IFBLK | STD_RBITS | STD_WBITS | S_IWGRP | S_IWOTH;
d839 1
a839 1
      buf->st_mode = S_IFCHR | STD_RBITS | STD_WBITS | S_IWGRP | S_IWOTH;
d843 1
@


1.87.2.8
log
@Merged changes from HEAD
@
text
@d869 1
a869 1
  set_flags (flags | bin);
@


1.87.2.9
log
@Merged changes from HEAD
@
text
@a315 1
  int fmode = __fmode;
d322 1
a322 4
	  {
	    fmode = pf->flags & ~(O_RDONLY | O_WRONLY | O_RDWR);
	    break;
	  }
d330 1
a330 4
	      {
		fmode = pf->flags & ~(O_RDONLY | O_WRONLY | O_RDWR);
		break;
	      }
d333 1
a333 1
  return fmode;
a829 1
  debug_printf ("here");
d1075 1
a1075 1
    setclexec (oh, h, not_inheriting);
d1095 1
a1095 1
      setclexec (oh, h, !get_close_on_exec ());
@


1.87.2.10
log
@Merged changes from HEAD
@
text
@d1070 1
a1070 1
#ifdef DEBUGGING_AND_FDS_PROTECTED
d1081 1
a1081 1
#ifdef DEBUGGING_AND_FDS_PROTECTED
d1090 3
d1098 1
a1098 3
#ifdef DEBUGGING_AND_FDS_PROTECTED
  else if (get_close_on_exec ())
    ProtectHandle (h);	/* would have to be fancier than this */
d1100 5
a1104 1
    /* ProtectHandleINH (h) */;	/* Should already be protected */
@


1.87.2.11
log
@Merged changes from HEAD
@
text
@a15 1
#include <sys/uio.h>
a697 103
}

ssize_t
fhandler_base::readv (const struct iovec *const iov, const int iovcnt,
		      ssize_t tot)
{
  assert (iov);
  assert (iovcnt >= 1);

  if (iovcnt == 1)
    return read (iov->iov_base, iov->iov_len);

  if (tot == -1)		// i.e. if not pre-calculated by the caller.
    {
      tot = 0;
      const struct iovec *iovptr = iov + iovcnt;
      do 
	{
	  iovptr -= 1;
	  tot += iovptr->iov_len;
	}
      while (iovptr != iov);
    }

  assert (tot >= 0);

  if (tot == 0)
    return 0;

  char *buf = (char *) alloca (tot);

  if (!buf)
    {
      set_errno (ENOMEM);
      return -1;
    }

  const ssize_t res = read (buf, tot);

  const struct iovec *iovptr = iov;
  int nbytes = res;

  while (nbytes > 0)
    {
      const int frag = min (nbytes, (ssize_t) iovptr->iov_len);
      memcpy (iovptr->iov_base, buf, frag);
      buf += frag;
      iovptr += 1;
      nbytes -= frag;
    }

  return res;
}

ssize_t
fhandler_base::writev (const struct iovec *const iov, const int iovcnt,
		       ssize_t tot)
{
  assert (iov);
  assert (iovcnt >= 1);

  if (iovcnt == 1)
    return write (iov->iov_base, iov->iov_len);

  if (tot == -1)		// i.e. if not pre-calculated by the caller.
    {
      tot = 0;
      const struct iovec *iovptr = iov + iovcnt;
      do 
	{
	  iovptr -= 1;
	  tot += iovptr->iov_len;
	}
      while (iovptr != iov);
    }

  assert (tot >= 0);

  if (tot == 0)
    return 0;

  char *const buf = (char *) alloca (tot);

  if (!buf)
    {
      set_errno (ENOMEM);
      return -1;
    }

  char *bufptr = buf;
  const struct iovec *iovptr = iov;
  int nbytes = tot;

  while (nbytes != 0)
    {
      const int frag = min (nbytes, (ssize_t) iovptr->iov_len);
      memcpy (bufptr, iovptr->iov_base, frag);
      bufptr += frag;
      iovptr += 1;
      nbytes -= frag;
    }

  return write (buf, tot);
@


1.87.2.12
log
@Merged changes from HEAD
@
text
@d237 2
a238 2
    bin = get_w_binary () || get_r_binary () || (binmode != O_TEXT)
	  ? O_BINARY : O_TEXT;
a277 1
	case ERROR_INVALID_HANDLE:
d444 1
a444 10
      if (pc->isdir () && !wincap.can_open_directories ())
	{
	  if (mode & (O_CREAT | O_EXCL) == (O_CREAT | O_EXCL))
	    set_errno (EEXIST);
	  else if (mode & (O_WRONLY | O_RDWR))
	    set_errno (EISDIR);
	  else
	    set_nohandle (true);
	}
      else if (GetLastError () == ERROR_INVALID_HANDLE)
d448 1
a448 2
      if (!get_nohandle ())
	goto done;
d715 1
a715 1
      do
d767 1
a767 1
      do
d874 1
a874 1
  if (get_nohandle () || CloseHandle (get_handle()))
d901 1
a901 1
  set_errno (EINVAL);
d999 1
a999 1
    nh = INVALID_HANDLE_VALUE;
d1210 1
a1210 2
  if (!get_nohandle ())
    set_inheritance (io_handle, val);
d1219 1
a1219 2
  if (!get_nohandle ())
    fork_fixup (parent, io_handle, "io_handle");
@


1.87.2.13
log
@Merged changes from HEAD
@
text
@d439 1
a439 1
  syscall_printf ("%p = CreateFile (%s, %p, %p, %p, %p, %p, 0)",
@


1.87.2.14
log
@Merged changes from HEAD
@
text
@d106 1
a106 1
    put_readahead (ch);
d163 1
a163 1
      char *w =  (char *) cmalloc (HEAP_STR, strlen (fmt) + 16);
d257 1
a257 1
  if (!ReadFile (get_handle (), ptr, ulen, &bytes_read, 0))
d302 1
a302 1
  if (!WriteFile (get_handle (), ptr, len, &bytes_written, 0))
d397 1
a397 1
    set_append_p ();
d604 1
a604 1
    SetFilePointer (get_handle (), 0, 0, FILE_END);
d858 1
a858 1
  res = SetFilePointer (get_handle (), off_low, poff_high, win32_whence);
d884 2
a885 2
  syscall_printf ("closing '%s' handle %p", get_name (), get_handle ());
  if (get_nohandle () || CloseHandle (get_handle ()))
d889 1
a889 1
      paranoid_printf ("CloseHandle (%d <%s>) failed", get_handle (),
d917 1
a917 1
rootdir (char *full_path)
d1009 4
a1012 1
  if (!get_nohandle ())
d1014 5
a1018 8
      if (!DuplicateHandle (hMainProc, get_handle (), hMainProc, &nh, 0, TRUE,
			    DUPLICATE_SAME_ACCESS))
	{
	  system_printf ("dup(%s) failed, handle %x, %E",
			 get_name (), get_handle ());
	  __seterrno ();
	  return -1;
	}
d1020 1
a1020 2
      child->set_io_handle (nh);
    }
@


1.86
log
@* exceptions.cc (setup_handler): Always relinquish lock after we've
interrupted.
* fhandler.cc: Move pipe methods to pipe.cc.
* fhandler.h (fhandler_pipe): Add new methods.
* fork.cc (sync_with_parent): Make error messages more informative.
* pipe.cc (fhandler_pipe::fhandler_pipe): Move here from fhandler.cc.
(fhandler_pipe::lseek): Ditto.
(fhandler_pipe::set_close_on_exec): New method.
(fhandler_pipe::read): Ditto.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::dup): Ditto.
(make_pipe): Create the guard mutex on the read side of the pipe.
* select.cc (peek_pipe): Use guard_mutex to discover if we have the right to
read on this pipe.
(fhandler_pipe::readh_for_read): Pass the read pipe guard mutex to peek_pipe.
* syscalls.cc (_read): Always detect signal catchers, for now.
* debug.cc (makethread): Eliminate hack to make thread inheritable.
* sigproc.cc (subproc_init): Don't use hack to make thread inheritable.
@
text
@d292 6
@


1.85
log
@* fhandler.cc (fhandler_base::set_inheritance): Just use DUPLICATE_CLOSE_SOURCE
to change inheritance.  Eliminate all other logic dealing with closed handles.
* fhandler.h (fhandler_base::set_inheritance): Reflect above change.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Ditto.
@
text
@d1292 2
a1293 2
     which returns a valid handle when trying to open a file in a non
     existant directory. */
a1493 17
}

/**********************************************************************/
/* fhandler_pipe */

fhandler_pipe::fhandler_pipe (const char *name, DWORD devtype) :
	fhandler_base (devtype, name)
{
  set_cb (sizeof *this);
}

off_t
fhandler_pipe::lseek (off_t offset, int whence)
{
  debug_printf ("(%d, %d)", offset, whence);
  set_errno (ESPIPE);
  return -1;
@


1.84
log
@        * fhandler.cc (fhandler_base::set_inheritance): If available,
        use SetHandleInformation() to set inheritance.
        * wincap.cc: Set flag has_set_handle_information_on_console_handles
        appropriately.
        * wincap.h: Add flag has_set_handle_information_on_console_handles.
@
text
@a1512 6
#ifdef DEBUGGING
#define nameparm name
#else
#define nameparm
#endif

d1514 1
a1514 2
fhandler_base::set_inheritance (HANDLE &h, int not_inheriting, const char *nameparm)
#undef nameparm
d1516 9
a1524 28
  HANDLE newh;

  if (wincap.has_set_handle_information () && (!is_console () ||
      wincap.has_set_handle_information_on_console_handles ()))
    (void) SetHandleInformation (h, HANDLE_FLAG_INHERIT,
    				 not_inheriting ? 0 : HANDLE_FLAG_INHERIT);
  else if (!DuplicateHandle (hMainProc, h, hMainProc, &newh, 0, !not_inheriting,
			     DUPLICATE_SAME_ACCESS))
    debug_printf ("DuplicateHandle %E");
#ifndef DEBUGGING
  else
    {
      hclose (h);
      h = newh;
    }
#else
  else if (!name)
    {
      hclose (h);
      h = newh;
    }
  else
  /* FIXME: This won't work with sockets */
    {
      ForceCloseHandle2 (h, name);
      h = newh;
      ProtectHandle2 (h, name);
    }
@


1.83
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d1525 6
a1530 2
  if (!DuplicateHandle (hMainProc, h, hMainProc, &newh, 0, !not_inheriting,
			DUPLICATE_SAME_ACCESS))
@


1.82
log
@Update copyrights.
@
text
@a26 1
#include "host_dependent.h"
d366 1
a366 1
  shared = host_dependent.shared;
d581 1
a581 1
  else if (!iswinnt && get_check_win95_lseek_bug ())
d1421 1
a1421 1
      win32_upper = host_dependent.win32_upper;
d1428 1
a1428 1
  if (iswinnt)
@


1.81
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Cygnus Solutions.
@


1.80
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d963 1
a963 1
          && !get_symlink_p ())
d1097 1
a1097 1
        const int allowed_flags = O_APPEND | O_NONBLOCK_MASK;
d1099 1
a1099 1
        /* Carefully test for the O_NONBLOCK or deprecated OLD_O_NDELAY flag.
d1252 1
a1252 1
      							 : real_path.error);
@


1.79
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d31 1
a31 1
static char fhandler_disk_dummy_name[] = "some disk file";
@


1.78
log
@* cygheap.h (init_cygheap): Move bucket array here from cygheap.cc.
* cygheap.cc: Throughout use bucket array from cygheap.
* sigproc.cc (proc_subproc): Dynamically allocate zombie buffer to save DLL
space.
(sigproc_fixup_after_fork): Free zombie array after a fork.
* sigproc.h (sigproc_fixup_after_fork): Declare.
* dir.cc (mkdir): Expand buffer for security descriptor to 4K to avoid stack
corruption.
* fhandler.cc (fhandler_base::open): Ditto.
* path.cc (symlink): Ditto.
@
text
@d33 1
a33 1
struct __cygwin_perfile *perfile_table = NULL;
d35 1
a35 1
DWORD binmode = 0;
@


1.77
log
@* debug.cc (mark_closed): Rename from debug_mark_closed and make static.
(setclexec_pid): New function for marking saved handle as close-on-exec.
(delete_handle): New function.
(debug_fixup_after_fork): New function.
* debug.h: Declare new functions, remove obsolete ones.
* fork.cc (debug_fixup_after_fork): Call to cleanup close-on-exec handles.
* fhandler.cc (fhandler_disk_file::close): Minor reorg.
(fhandler_base::set_inheritance): Set flag appropriately for debugging when
close-on-exec so forked process can delete closed handles.
* tty.h (open_output_mutex): Eliminate unneeded argument.
(open_input_mutex): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): reflect open_*_mutex argument
changes.
* fhandler.h (fhandler_socket): Make saw_shutdown_* functions type bool.
* tty.cc (tty::get_event): Eliminate unneeded argument.
(tty::common_init): Reflect change to get_event.  Events should always be
inherited.
@
text
@d390 1
a390 1
    set_security_attribute (mode, &sa, alloca (256), 256);
@


1.76
log
@        * fhandler.cc (fhandler_base::is_nonblocking): New method.
        (fhandler_base::set_nonblocking): Ditto.
        * fhandler.h (fhandler_base): Declare new methods `is_nonblocking' and
        `set_nonblocking'.
        * fhandler_socket.cc (fhandler_socket::ioctl): Use `set_nonblocking'.
        * fhandler_tty.cc (fhandler_pty_master::process_slave_output):
        Use `is_nonblocking'.
        (fhandler_tty_slave::read): Ditto.
        (fhandler_tty_slave::ioctl): Use `set_nonblocking'.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (cygwin_sendto): Fallback to winsock 1 functionality
        in case of nonblocking IO.
        (cygwin_recvfrom): Ditto.
        (cygwin_recv): Ditto.
        (cygwin_send): Ditto.
        * syscalls.cc (_read): Use `is_nonblocking'.
@
text
@d788 1
a788 1
fhandler_base::close (void)
d1320 2
a1321 2
  int res;
  if ((res = this->fhandler_base::close ()) == 0)
d1548 1
@


1.75
log
@        * fhandler.cc (fhandler_base::fcntl): Use new O_NONBLOCK_MASK define.
        * fhandler.h: Move definitions of O_NOSYMLINK, O_DIROPEN and
        OLD_O_NDELAY from winsup.h to here. Add O_NONBLOCK_MASK define.
        * fhandler_socket.cc (fhandler_socket::close): Add hack to allow
        a graceful shutdown even if shutdown() hasn't been called by the
        application. Add debug output.
        (fhandler_socket::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_socket::fcntl): Use new O_NONBLOCK_MASK define. Actually
        set `request' before using it.
        * fhandler_tty.cc: Use new O_NONBLOCK_MASK define throughout.
        (fhandler_tty_slave::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (wsock_event::prepare): Compare WSACreateEvent return code
        with `WSA_INVALID_EVENT' according to MSDN.
        * syscalls.cc (_read): Use new O_NONBLOCK_MASK define.
@
text
@d1575 14
@


1.74
log
@        * dir.cc (mkdir): Set security attributes correctly for
        CreateDirectoryA () call if ntsec is on. Don't call
        set_file_attributes () then.
        * fhandler.cc (fhandler_base::open): Ditto for CreateFileA () call.
        * path.cc (symlink): Ditto.
        * security.cc (set_security_attribute): New function.
        * security.h: Add declaration for `allow_ntea' and
        `set_security_attribute'.
@
text
@d1097 1
a1097 1
        const int allowed_flags = O_APPEND | O_NONBLOCK | OLD_O_NDELAY;
@


1.73
log
@* cygheap.cc (cygheap_root::set): Avoid treating '/' specially.
* fhandler.cc (fhandler_base::fcntl): Only set specific O_NDELAY style flag
passed in from application.
* fhandler_socket.cc (fhandler_socket::fcntl): Ditto.
* fhandler.h: Set constant for future use.
* winsup.h: Define OLD_O_NDELAY only for old programs.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_OLD_O_NONBLOCK.
@
text
@d303 1
d386 6
d393 1
a393 1
		   &sec_none, creation_distribution,
d399 1
a399 1
		  &sec_none, creation_distribution,
d411 3
a413 1
  // Attributes may be set only if a file is _really_ created.
d415 2
a416 1
      && GetLastError () != ERROR_ALREADY_EXISTS)
@


1.72
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d21 1
d1088 7
a1094 9

        /* Care for the old O_NDELAY flag. If one of the flags is set,
           both flags are set. */
	int new_flags = (int) arg;
        if (new_flags & (O_NONBLOCK | OLD_O_NDELAY))
          new_flags |= O_NONBLOCK | OLD_O_NDELAY;

        int flags = get_flags () & ~allowed_flags;
        set_flags (flags | (new_flags & allowed_flags));
@


1.71
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d571 1
a571 1
  else if (os_being_run != winNT && get_check_win95_lseek_bug ())
d1420 1
a1420 1
  if (os_being_run == winNT)
@


1.70
log
@* cygheap.cc (cygheap_fixup_in_child): Attempt Win95 workaround.
* dtable.cc (dtable::dup_worker): Add debugging output.
(dtable::vfork_child_dup): Correctly set close_on_exec.
* fhandler.cc (fhandler_base::fork_fixup): Don't mess with handle if there is
no need to get it from the parent.
* fhandler_tty.cc (fhandler_tty_common::close): Add debugging output.
@
text
@d20 1
a26 1
#include "security.h"
@


1.69
log
@* fhandler.cc (fhandler_disk_file::fstat): Don't rely on exactly 3 characters
being read for executable test since we could be checking for less than that.
* syscalls.cc (stat_worker): Try opening the file the "correct" way first so
that #! processing can potentially happen.  If that fails, then use "query
open" method.
* spawn.cc (spawn_guts): Delay processing of signal until after we've notified
parent about reparenting.
@
text
@d1545 3
a1547 1
  if (!DuplicateHandle (parent, h, hMainProc, &h, 0, !get_close_on_exec (),
@


1.68
log
@forced commit
@
text
@d996 2
a997 2
		    if (ReadFile (get_handle (), magic, 3, &done, 0) &&
			done == 3 && has_exec_chars (magic, done))
@


1.67
log
@* fhandler.cc (fhandler_base::open): Work around windows bug when
CreateFile() with dwDesiredAccess == 0 called on remote share returns
valid handle even if file doesn't exist.
@
text
@@


1.66
log
@* fhandler.cc (fhandler_disk_file::fstat): Properly set executable bits for
directory when !ntsec && !ntea.  Also move common code prior to call to
get_attributes.
@
text
@d373 11
@


1.65
log
@* fhandler.cc (fhandler_base::open): Set win32 access flags
to 0, when requested.
* fhandler.h: New status flag FH_QUERYOPEN.
(fhandler::get_query_open): New function.
(fhandler::set_query_open): Ditto.
* syscalls.cc (stat_worker): Request query-only open mode.
@
text
@d931 7
a937 8
    buf->st_mode |= S_IFDIR;
  if (get_symlink_p ())
    buf->st_mode |= S_IFLNK;
  if (!get_file_attribute (has_acls (),
			   get_win32_name (),
			   &buf->st_mode,
			   &buf->st_uid,
			   &buf->st_gid))
d944 1
a944 7
      if (buf->st_mode & S_IFMT)
	/* already set */;
      else if (get_socket_p ())
	buf->st_mode |= S_IFSOCK;
      else if (local.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	buf->st_mode |= S_IFDIR;
      else
d955 4
a958 2
      if (buf->st_mode & S_IFMT)
	/* already set */;
d969 13
a981 6
	    if (local.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	      buf->st_mode |= S_IFDIR | STD_XBITS;
	   else
	     {
		buf->st_mode |= S_IFREG;
		if (!dont_care_if_execable () && !get_execable_p ())
d983 6
a988 18
		    DWORD cur, done;
		    char magic[3];

		    /* First retrieve current position, set to beginning
		       of file if not already there. */
		    cur = SetFilePointer (get_handle(), 0, NULL, FILE_CURRENT);
		    if (cur != INVALID_SET_FILE_POINTER &&
		        (!cur ||
			 SetFilePointer (get_handle(), 0, NULL, FILE_BEGIN)
			 != INVALID_SET_FILE_POINTER))
		      {
			/* FIXME should we use /etc/magic ? */
			magic[0] = magic[1] = magic[2] = '\0';
			if (ReadFile (get_handle (), magic, 3, &done, 0) &&
			    done == 3 && has_exec_chars (magic, done))
			    set_execable_p ();
			SetFilePointer (get_handle(), cur, NULL, FILE_BEGIN);
		      }
d990 3
a992 3
		if (get_execable_p ())
		  buf->st_mode |= STD_XBITS;
	     }
@


1.64
log
@        * fhandler.cc (fhandler_disk_file::fstat): Always reset file position
        to original value after checking for executable magic.
@
text
@d311 5
a315 1
  if (get_device () == FH_TAPE)
@


1.63
log
@* fhandler.cc (fhandler_disk_file::fstat): Avoid clearing S_IFMT bits since
we've already pre-cleared everything anyway.
@
text
@d977 1
a977 1
		    DWORD done;
d979 8
a986 4
		    /* FIXME should we use /etc/magic ? */
		    magic[0] = magic[1] = magic[2] = '\0';
		    if (ReadFile (get_handle (), magic, 3, &done, 0)
			&& done == 3)
d988 6
a993 3
			if (has_exec_chars (magic, done))
			  set_execable_p ();
			SetFilePointer (get_handle(), -(LONG) done, NULL, FILE_CURRENT);
@


1.62
log
@* path.cc (chdir): Always send unsigned chars to isspace since newlib's isspace
doesn't deal well with "negative" chars.
* fhandler.cc (fhandler_disk_file::open): Propagate remote status of file
garnered from path_conv.  Move #! checking to fstat.
(fhandler_disk_file::fstat): Reorganize st_mode setting to eliminate
duplication.  Move check for #! here from fhandler::open.
* fhandler.h (fhandler_base::isremote): New method.
(fhandler_base::set_isremote): Ditto.
(fhandler_base::set_execable_p): Also record "don't care if executable state".
(fhandler_base::dont_care_if_execable): New method.
* path.cc (path_conv::check): Clear new flags.  Appropriately set vol_flags,
drive_type, and is_remote_drive.
* path.h: Add new flags and methods for manipulating them.
* syscalls.cc (_unlink): Use isremote() to determine if a path is remote rather
than calling GetDriveType.
(stat_worker): Ditto.
* security.cc (get_file_attribute): Or attribute with result of NTReadEA to be
consistent with get_nt_attribute.
@
text
@d941 3
a943 2
      buf->st_mode &= ~S_IFMT;
      if (get_socket_p ())
d958 3
a960 1
      if (get_socket_p ())
@


1.61
log
@Remove trailing underscore from fhandler_base and friends, throughout.
* fhandler.h (fhandler_base::set_open_status): New method.  Stores original
open status.
(fhandler_base::get_open_status): New method.  Retrieves original open status.
(fhandler_base::reset_to_open_binmode): New method.
* fhandler.cc (fhandler_base::open): Save open status.
(fhandler_base::init): Ditto.
* fhandler_clipboard.cc (fhandler_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
* fhandler_dsp.cc (fhandler_dsp::open): Ditto.
* fhandler_dev_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_dev_random.cc (fhandler_dev_random::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tty_slave.cc (fhandler_tty_slave::open): Ditto.
* fhandler_tty_master.cc (fhandler_tty_master::open): Ditto.
* fhandler_dev_zero.cc (fhandler_dev_zero::open): Ditto.
* syscalls.cc (setmode): Rework so that 0 mode value causes reversion to open
state.
* fhandler_tty_slave.cc (fhandler_tty_slave::read): Use correct multiplier when
converting from deciseconds to milliseconds.
@
text
@d923 1
d942 1
a942 3
      if (get_symlink_p ())
	buf->st_mode |= S_IFLNK;
      else if (get_socket_p ())
a950 1
      buf->st_mode = 0;
d957 1
a957 3
      if (get_symlink_p ())
	buf->st_mode |= S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;
      else if (get_socket_p ())
d967 2
a968 2
	   if (local.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	     buf->st_mode |= S_IFDIR | STD_XBITS;
d971 15
a985 1
	       buf->st_mode |= S_IFREG;
d1254 1
a1277 18
    }

  extern BOOL allow_ntea;

  if (real_path.isdisk ()
      && !(real_path.file_attributes () & FILE_ATTRIBUTE_DIRECTORY)
      && (real_path.exec_state () == dont_know_if_executable)
      && !allow_ntea && (!allow_ntsec || !real_path.has_acls ()))
    {
      DWORD done;
      char magic[3];
      /* FIXME should we use /etc/magic ? */
      magic[0] = magic[1] = magic[2] = '\0';
      ReadFile (get_handle (), magic, 3, &done, 0);
      if (has_exec_chars (magic, done))
	real_path.set_exec ();
      if (!(flags & O_APPEND))
	SetFilePointer (get_handle(), 0, 0, FILE_BEGIN);
@


1.60
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d40 2
a41 2
  unix_path_name_ = x.unix_path_name_ ? cstrdup (x.unix_path_name_) : NULL;
  win32_path_name_ = x.win32_path_name_ ? cstrdup (x.win32_path_name_) : NULL;
d157 4
a160 4
      if (unix_path_name_ != NULL && unix_path_name_ != fhandler_disk_dummy_name)
	cfree (unix_path_name_);
      if (win32_path_name_ != NULL && unix_path_name_ != fhandler_disk_dummy_name)
	cfree (win32_path_name_);
d163 1
a163 1
  unix_path_name_ = win32_path_name_ = NULL;
d167 2
a168 2
  unix_path_name_ = cstrdup (unix_path);
  if (unix_path_name_ == NULL)
d175 1
a175 1
    win32_path_name_ = cstrdup (win32_path);
d179 2
a180 2
      win32_path_name_ = (char *) cmalloc (HEAP_STR, strlen(fmt) + 16);
      __small_sprintf (win32_path_name_, fmt, unit);
d183 1
a183 1
  if (win32_path_name_ == NULL)
d239 1
a239 1
	  syscall_printf ("ReadFile %s failed, %E", unix_path_name_);
d313 1
a313 1
      access_ = GENERIC_READ | GENERIC_WRITE;
d317 1
a317 1
      access_ = GENERIC_READ;
d321 1
a321 1
      access_ = GENERIC_WRITE;
d325 1
a325 1
      access_ = GENERIC_READ | GENERIC_WRITE;
d331 1
a331 1
      access_ |= GENERIC_READ;
d369 1
a369 1
  x = CreateFileA (get_win32_name (), access_, shared,
d375 1
a375 1
		  x, get_win32_name (), access_, shared,
d393 1
a393 1
  namehash_ = hash_path_name (0, get_win32_name ());
d428 1
d678 1
a678 1
  debug_printf ("lseek (%s, %d, %d)", unix_path_name_, offset, whence);
d999 1
a999 1
  access_ = a;
d1007 1
d1154 1
a1154 1
  access_ (0),
d1156 2
a1157 2
  namehash_ (0),
  openflags_ (0),
d1162 2
a1163 1
  rabuflen (0)
d1174 1
a1174 1
  unix_path_name_  = win32_path_name_  = NULL;
d1183 4
a1186 4
      if (unix_path_name_ != NULL && unix_path_name_ != fhandler_disk_dummy_name)
	cfree (unix_path_name_);
      if (win32_path_name_ != NULL && win32_path_name_ != fhandler_disk_dummy_name)
	cfree (win32_path_name_);
d1190 1
a1190 1
  unix_path_name_ = win32_path_name_ = NULL;
d1201 1
a1201 1
  unix_path_name_ = win32_path_name_ = fhandler_disk_dummy_name;
d1233 1
a1233 1
      win32_path_name_ = real_path.get_win32 ();
d1261 1
a1261 1
      && GetFileAttributes (win32_path_name_) == (DWORD) -1)
@


1.59
log
@* fork.cc (fork_child): Call the __pthread_atforkchild function.
(fork_parent): Call the __pthread_atforkparent function.
* cygwin.din: Export pthread_atfork.
* thread.h (callback): New class.
(MTinterface): Use it.
* thread.cc (__pthread_atforkprepare): New function.
(__pthread_atforkparent): New function.
(__pthread_atforkchild): New function.
(__pthread_atfork): New function.
* pthread.cc (pthread_atfork): New function.
@
text
@a15 1
#include "cygheap.h"
d21 2
d81 1
a81 1
    chret = ((unsigned char)rabuf[raixget++]) & 0xff;
@


1.58
log
@        * dir.cc (mkdir): Check for case clash.
        * environ.cc: Add extern declaration for `pcheck_case'.
        (check_case_init): New function.
        (struct parse_thing): Add "check_case" option.
        * errno.cc (_sys_nerrlist): Add text for ECASECLASH.
        (strerror): Add case branch for ECASECLASH.
        * fhandler.cc (fhandler_disk_file::open): Check for case clash.
        * path.cc: Add global variable `pcheck_case'.
        (struct symlink_info): Add member `case_clash' and method `case_check'.
        (path_prefix_p_): Call `pathnmatch' instead of `strncasematch'.
        (pathnmatch): New funtion.
        (pathmatch): Ditto.
        (path_conv::check): Add handling for case checking.
        (symlink): Check for case clash.
        (symlink_info::check): Add parameter for case checking.
        Handle case checking.
        (symlink_info::case_check): New method.
        (chdir): Don't use unconverted path if pcheck_case==PCHECK_STRICT.
        * path.h: Add extern declarations for `pathmatch' and
        `pathnmatch'.
        (enum case_checking): New enumeration type describing
        the case checking behaviour of path conversion routines.
        (class path_conv): Add member `case_clash'.
        * syscalls.cc (_link): Check for case clash.
@
text
@d373 2
a374 3
  syscall_printf ("%d = CreateFileA (%s, %p, %p, %p, %p, %p, 0)",
		  x,
		  get_win32_name (), access_, shared,
@


1.57
log
@        * fhandler.cc (fhandler_disk_file::open): Avoid checking a magic
	number of a directory.
@
text
@d1211 2
a1212 1
      (flags & O_NOSYMLINK || real_path.error != ENOENT || !(flags & O_CREAT)))
d1214 2
a1215 1
      set_errno (real_path.error);
@


1.56
log
@* fhandler.cc (fhandler_base::read): Remove special handling of CTRL-Z.
@
text
@d1267 1
@


1.55
log
@        * fhandler.cc (fhandler_disk_file::fstat): Add correct modes to
        symlinks when stat'ing on FAT or FAT32 file systems.
@
text
@a445 1
  char *ctrlzpos;
d477 2
d493 1
@


1.54
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@d957 1
a957 1
	buf->st_mode |= S_IFLNK;
@


1.53
log
@        * cygerrno.h: Revert previous patch.
        * errno.cc: Ditto.
        * dir.cc: Eliminate `dir_suffixes'.
        (opendir): Remove usage of `dir_suffixes'.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::open): Remove usage of
        `inner_suffixes'.
        * path.cc: Rename `inner_suffixes' to `lnk_suffixes'.
        (path_conv::check): Remove usage of `inner_suffixes'.
        (symlink): Ditto.
        (symlink_info::check): Handle checking for `.lnk' in path_conv
        exclusively here.
        (chdir): Remove usage of `dir_suffixes'.
        * shortcut.c: Eliminate debug_printf lines.
        (check_shortcut): Don't set error except on failing ReadFile.
        * spawn.cc: Remove ".lnk" from `std_suffixes'.
        * syscalls.cc (_unlink): Remove usage of `inner_suffixes'.
        Remove ".lnk" from `stat_suffixes'.
        (_rename): Add check for renaming a symlink to keep the ".lnk"
        suffix after renaming.
@
text
@d20 1
a24 1
#include "perprocess.h"
a1228 3
  /* If necessary, do various other things to see if path is a program.  */
  if (!real_path.isexec ())
    real_path.set_exec (check_execable_p (get_win32_name ()));
d1264 3
a1266 3
  if (!real_path.isexec () && !allow_ntea
      && (!allow_ntsec || !real_path.has_acls ())
      && GetFileType (get_handle ()) == FILE_TYPE_DISK)
d1283 1
a1283 1
  set_execable_p (real_path.isexec ());
a1453 15
  return 0;
}

/* Perform various heuristics on PATH to see if it's a program. */

int
fhandler_disk_file::check_execable_p (const char *path)
{
  int len = strlen (path);
  const char *ch = path + (len > 4 ? len - 4 : len);

  if (strcasematch (".exe", ch)
      || strcasematch (".bat", ch)
      || strcasematch (".com", ch))
    return 1;
@


1.52
log
@        * fhandler.cc (fhandler_disk_file::open): Use `inner_suffixes' when
        resolving real_path.
        * path.cc (symlink): Ditto for win32_topath.
@
text
@a1201 2
  extern suffix_info inner_suffixes[];

d1206 1
a1206 1
			     PC_SYM_NOFOLLOW : PC_SYM_FOLLOW, inner_suffixes);
@


1.51
log
@Add copyright year 2001
@
text
@d1202 2
d1208 1
a1208 1
			     PC_SYM_NOFOLLOW : PC_SYM_FOLLOW);
@


1.50
log
@        * Makefile.in: Add `-lshell32 -luuid' to link pass for new-cygwin1.dll.
        * autoload.cc: Add LoadDLLinitfunc for ole32.dll.
        Add LoadDLLfuncEx statements for CoInitialize@@4, CoUninitialize@@0
        and CoCreateInstance@@20.
        * dir.cc (dir_suffixes): New datastructure.
        (readdir): Check for R/O *.lnk files to hide the suffix.
        (opendir): Use `dir_suffixes' in path conversion.
        (rmdir): Ditto.
        * fhandler.cc (fhandler_disk_file::fstat): Add S_IFLNK flag
        before calling `get_file_attribute'. Take FILE_ATTRIBUTE_READONLY
        into account only if the file is no symlink.
        * path.cc (inner_suffixes): New datastructure.
        (SYMLINKATTR): Eliminated.
        (path_conv::check): Use `inner_suffixes' on inner path components.
        (shortcut_header): New global static variable.
        (shortcut_initalized): Ditto.
        (create_shortcut_header): New function.
        (cmp_shortcut_header): Ditto.
        (symlink): Create symlinks by creating windows shortcuts. Preserve
        the old code.
        (symlink_info::check_shortcut): New method.
        (symlink_info::check_sysfile): Ditto.
        (symlink_info::check): Check for shortcuts. Move code reading
        old system attribute symlinks into symlink_info::check_sysfile().
        (chdir): Use `dir_suffixes' in path conversion.
        * security.cc (get_file_attribute): Check for S_IFLNK flag.
        Force 0777 permissions then.
        * spawn.cc (std_suffixes): Add ".lnk" suffix.
        * syscalls.cc (_unlink): Use `inner_suffixes' in path conversion.
        Check for shortcut symlinks to eliminate R/O attribute before
        calling DeleteFile().
        (stat_suffixes): Add ".lnk" suffix.
        (stat_worker): Force 0777 permissions if file is a symlink.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.49
log
@        * fhandler.cc (fhandler_base::open): Always add GENERIC_READ access
        when opening raw disk devices.
        * fhandler_floppy.cc (fhandler_dev_floppy::lseek): Implement bytewise
        access.
        * fhandler_raw.cc (fhandler_dev_raw::open): Always open raw disk device
        binary.
        (fhandler_dev_raw::raw_write): Don't drop read buffer content when
        writing after read.
@
text
@d924 2
d933 2
a934 1
      if (local.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
@


1.48
log
@        * environ.cc (struct parse_thing): Add entry for new CYGWIN option
        `smbntsec'.
        * path.cc (path_conv::check): Check path for being a remote path.
        If so and `allow_smbntsec' is set to FALSE, set has_acls to FALSE.
        * security.cc: Add global definition for `allow_smbntsec'.
        * security.h: Add extern declaration for `allow_smbntsec'.
        * fhandler.cc (fhandler_disk_file::open): Eliminate extern declaration
        of `allow_ntsec'.
        * syscalls.cc: Ditto.
@
text
@d327 6
@


1.47
log
@        * fhandler.cc (fhandler_disk_file::open): Check for buggy CreateFile
        condition.
        * path.cc (path_conv::check): Get file system type in call to
        GetVolumeInformation to check for file systems with buggy CreateFile.
        * path.h (enum path_types): Add PATH_HASBUGGYOPEN.
        (class path_conv): Add methods `has_buggy_open' and
        `set_has_buggy_open'.
@
text
@a1256 1
  extern BOOL allow_ntsec;
@


1.46
log
@* fhandler.cc (is_at_eof): New function.
(fhandler_base::raw_read): Detect special case where last error ==
ERROR_NOACCESS but the file is at EOF.  Most UNIXes do not consider this to be
an error.
@
text
@d1241 15
@


1.45
log
@* pinfo.cc (pinfo::init): Reverse order of setting status and pid info in an
execed process to avoid a race.
* sigproc.cc (wait_subproc): Print more info when a WFSO error occurs.
* automode.c: New file.
* syscalls.cc (close_all_files): Streamline slightly.
* cygheap.cc (ccalloc): Clear *entire* allocated array.
@
text
@d189 20
d234 3
@


1.44
log
@* path.h (has_exec_chars): Standard function for checking for executable magic
numbers.
* path.cc (symlink_info::check): Use the above function.
* fhandler.cc (fhandler_disk_file::open): Ditto.
@
text
@a144 3
/**********************************************************************/
/* fhandler_base */

d253 11
a263 8
	{
	  size_t pflen = strlen (pf->name);
	  const char *stem = get_name () + nlen - pflen;
	  if (pflen > nlen || (stem != get_name () && !isdirsep (stem[-1])))
	    continue;
	  else if (ACCFLAGS (pf->flags) == accflags && strcasematch (stem, pf->name))
	    return pf->flags & ~(O_RDONLY | O_WRONLY | O_RDWR);
	}
@


1.43
log
@	* fhandler.cc (fhandler_base::fcntl): Treat O_NONBLOCK and OLD_O_NDELAY
	as exactly the same. If one is set, both are set.
	* net.cc (fhandler_socket::fcntl): Ditto.
@
text
@d1230 1
a1230 2
      if ((magic[0] == ':' && magic[1] == '\n') ||
	  (magic[0] == '#' && magic[1] == '!'))
@


1.42
log
@        * fhandler.cc (fhandler_base::fcntl): Behave properly when passed
        previous version of O_NDELAY.
        * syscalls.cc: Move OLD_O_NDELAY to winsup.h.
        * winsup.h: Define OLD_O_NDELAY now.
@
text
@a1023 1
	 * There's no functionality at all, so...
d1027 6
d1034 1
a1034 1
        set_flags (flags | ((int)arg & allowed_flags));
@


1.41
log
@        * fhandler.cc (fhandler_base::fcntl): Setting flags in F_SETFL
        branch according to Linux documentation.
@
text
@d1015 1
d1020 1
a1020 1
	 * Only O_APPEND, O_ASYNC and O_NONBLOCK are allowed.
d1026 4
a1029 4
        int flags = get_flags ();
        flags &= ~(O_APPEND | O_NONBLOCK);
      	flags |= ((int) arg & (O_APPEND | O_NONBLOCK));
        set_flags (flags);
@


1.40
log
@        * fcntl.cc (_fcntl): Rearrange as wrapper function. Move all
        functionality except F_DUPFD to fhandler classes.
        * fhandler.cc (fhandler_base::fcntl): New method.
        * net.cc (fhandler_socket::fcntl): Ditto.
        * fhandler.h (class fhandler_base): Add method prototype for fcntl().
        (class fhandler_socket): Ditto.
@
text
@a1003 2
  /*int temp = 0;*/

d1017 13
a1029 10
      /* Only O_APPEND, O_NONBLOCK and O_ASYNC may be set. */
      /*
      if (arg & O_RDONLY)
	temp |= GENERIC_READ;
      if (arg & O_WRONLY)
	temp |= GENERIC_WRITE;
      syscall_printf ("fcntl (F_SETFL, %d)", (int) arg);
      set_access (temp);
      */
      set_flags ((int) arg);
@


1.39
log
@* fork.cc (fork): Set sigframe here, since it can pause for a considerable
amount of time.
* environ.cc (_addenv): Add debugging.
* fhandler.cc: Eliminate unneeded include.
* smallprint.c: Ditto.
@
text
@d1000 44
@


1.38
log
@* times.cc (to_time_t): pass zero time as epoch
* fhandler.cc (fstat): copy atime/ctime from mtime if they're zero
@
text
@a16 1
#include <string.h>
@


1.37
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d858 6
@


1.36
log
@* errno.cc (seterrno_from_win_error): Fix debugging output.
* fhandler.cc (fhandler_base::fstat): Move to inline method in fhandler.h.
(fhandler_base::set_io_handle): Ditto.
* fhandler.h (fhandler_base): Make some methods inline.
* fhandler_console.cc (fhandler_console::write_normal): Make buffer larger.
* sigproc.h (sigframe::sigframe): Actually use set ebp parameter correctly.
* spawn.cc (spawn_guts): Set dwProcessId when exec'ing.  Just exit immediately
after reparenting.
* syscalls.cc: Sprinkle sigframe stuff throughout.
* wait.cc (wait4): Set signal frame here.
* dcrt0.cc (__api_fatal): Don't rely on small_printf to display errors.  Always
display problems to the console, if possible.
@
text
@d466 1
a466 1
  register char *src= (char *) ptr;
d775 1
a775 1
  char *root=full_path;
@


1.35
log
@* fhandler.h (fhandler_base): Remove obsolete _rpos and _rsize elements.
* fhandler.cc (fhandler_base::open): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Ditto.
(fhandler_base::read): Ditto.  Add more debugging output.  Don't issue a \r
when \r\n detected.
* pipe.cc (make_pipe): Streamline slightly.  Make debug output more
interesting.
* strace.cc (strace::vsprintf): Use __progname where appropriate to distinguish
strace output when exec'ing.
@
text
@a766 7
int
fhandler_base::fstat (struct stat *buf)
{
  return stat_dev (get_device (), get_unit (), get_namehash (), buf);
  return 0;
}

a973 7
}

void
fhandler_base::set_io_handle (HANDLE x)
{
  debug_printf ("set handle to %p", x);
  io_handle = x;
@


1.34
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@a366 2
  rpos_ = 0;
  rsize_ = -1;
d442 1
a442 1
  if (copied_chars <= 0 || get_r_binary ())
d444 5
d460 4
a463 1
    return 0;
a495 2
  rpos_ += copied_chars;

d514 1
d572 1
d577 1
a577 50
#ifdef NOTDEF
      /* Keep track of previous \rs, we don't want to turn existing
	 \r\n's into \r\n\n's */
      register int pr = 0;

      /* Copy things in chunks */
      char buf[CHUNK_SIZE];

      for (unsigned int i = 0; i < len; i += sizeof (buf) / 2)
	{
	  register const char *src = (char *)ptr + i;
	  int todo;
	  if ((todo = len - i) > sizeof (buf) / 2)
	    todo = sizeof (buf) / 2;
	  register const char *end = src + todo;
	  register char *dst = buf;
	  while (src < end)
	    {
	      if (*src == '\n' && !pr)
		{
		  /* Emit a cr lf here */
		  *dst ++ = '\r';
		  *dst ++ = '\n';
		}
	      else if (*src == '\r')
		{
		  *dst ++ = '\r';
		  pr = 1;
		}
	      else
		{
		  *dst ++ = *src;
		  pr = 0;
		}
	      src++;
	    }
	  int want = dst - buf;
	  if ((res = raw_write (buf, want)) != want)
	    {
	      if (res == -1)
		return -1;
	      /* FIXME: */
	      /* Tricky... Didn't write everything we wanted.. How can
		 we work out exactly which chars were sent?  We don't...
		 This will only happen in pretty nasty circumstances. */
	      rpos_ += i;
	      return i;
	    }
	}
#else
d579 2
a580 1
	 compatible. */
d584 1
d588 1
a588 1
	  char buf[CHUNK_SIZE], *buf_ptr = buf;
d593 2
a594 1
	      if (*data == '\n')
a595 5
		  if (left_in_buf == 1)
		    {
		      /* Not enough room for \r and \n */
		      break;
		    }
d599 1
a599 1
	      *buf_ptr++ = *data++;
d602 6
d611 1
d613 1
a613 1
	  if ((res = raw_write (buf, want)) != want)
d615 3
a617 15
	      if (res == -1)
		return -1;
	      /* FIXME: */
	      /* Tricky... Didn't write everything we wanted.. How can
		 we work out exactly which chars were sent?  We don't...
		 This will only happen in pretty nasty circumstances. */
	      int i = (len-left_in_data) - left_in_buf;
	      rpos_ += i;
	      /* just in case the math is off, guarantee it looks like
		 a disk full error */
	      if (i >= (int)len)
		i = len-1;
	      if (i < 0)
		i = 0;
	      return i;
d619 6
d626 1
a626 1
#endif
d628 1
a628 7
      /* Done everything, update by the chars that the user sent */
      rpos_ += len;
      /* Length of file has changed */
      rsize_ = -1;
      res = len;
      debug_printf ("after write, name %s, rpos %d", unix_path_name_, rpos_);
    }
a1077 2
  rpos_ (0),
  rsize_ (0),
@


1.33
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@d18 2
a22 1
#include "tty.h"
d24 3
@


1.32
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d21 2
@


1.31
log
@* environ.cc (parse_thing): nobinmode should force O_TEXT.
(regopt): Use correct path to find LOCAL_MACHINE registry options.
* fhandler.cc (fhandler_base::open): Set binary mode only when binmode ==
O_BINARY.
* pipe.cc (pipe): Pipe handling should rely on binmode not _fmode now that the
two are different.
@
text
@d16 1
d30 14
d49 1
a49 1
         && (success = put_readahead (*s++) > 0))
d155 1
a155 1
	free (unix_path_name_);
d157 1
a157 1
	free (win32_path_name_);
d164 1
a164 1
  unix_path_name_ = strdup (unix_path);
d172 1
a172 1
    win32_path_name_ = strdup (win32_path);
d176 1
a176 1
      win32_path_name_ = (char *) malloc (strlen(fmt) + 16);
d214 1
a214 1
          __seterrno_from_win_error (errcode);
a222 31
int
fhandler_base::linearize (unsigned char *buf)
{
  unsigned char *orig_buf = buf;
#define cbuf ((char *)buf)
  strcpy (cbuf, get_name() ?: "");
  char *p = strcpy (strchr (cbuf, '\0') + 1, get_win32_name ());
  buf = (unsigned char *)memcpy (strchr (p, '\0') + 1, this, cb);
  debug_printf ("access_ %p, status %p, io_handle %p, output_handle %p",
		access_, status, get_io_handle (), get_output_handle ());
  return (buf + cb) - orig_buf;
#undef cbuf
}

int
fhandler_base::de_linearize (const char *buf, const char *unix_name,
			     const char *win32_name)
{
  int thiscb = cb;
  memcpy(this, buf, cb);
  unix_path_name_ = win32_path_name_ = NULL;
  set_name (unix_name, win32_name);
  debug_printf ("access_ %p, status %p, io_handle %p, output_handle %p",
		access_, status, get_io_handle (), get_output_handle ());
  if (thiscb != cb)
    system_printf ("mismatch in linearize/delinearize %d != %d", thiscb, cb);
  raixput = raixget = ralen = rabuflen = 0;
  rabuf = NULL;
  return cb;
}

d941 5
a945 5
  if (! get_file_attribute (has_acls (),
                            get_win32_name (),
                            &buf->st_mode,
                            &buf->st_uid,
                            &buf->st_gid))
d966 1
a966 1
      if (! (local.dwFileAttributes & FILE_ATTRIBUTE_READONLY))
d1111 7
d1151 1
a1151 1
	free (unix_path_name_);
d1153 1
a1153 1
	free (win32_path_name_);
d1155 2
@


1.30
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d27 1
a27 1
DWORD binmode;
d390 1
a390 1
    bin = binmode || get_w_binary () || get_r_binary ();
@


1.29
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d18 2
@


1.28
log
@* winsup.h: Change strchr inline for strange gcc problem.
* select.cc (select_stuff::wait): Bounds check w4 array.
@
text
@d17 1
@


1.27
log
@* dir.cc (readdir): Ensure that errno is *only* set when we've run out of
filenames.
* fhandler.cc (fhandler_disk_file::fstat): Use modern method for saving errno,
making it effective for the whole function.
@
text
@d16 1
@


1.26
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d868 1
a868 1
  int old_errno = get_errno ();
d910 1
a910 1
      set_errno (ENOENT);
a912 2

  set_errno (old_errno);
@


1.25
log
@* fhandler.cc (fhandler_disk_file::fstat): Allow block calculation to succeed
for files >= 2GB and <= 4GB.
@
text
@d11 1
a15 1
#include "winsup.h"
@


1.24
log
@Throughout, eliminate third argument to path_conv and use new PC_* constants
for second argument.
* path.h: Generalize SYMLINK_* constants to PC_*.
(path_conv): Create a new method.  Fold third argument into second.
* dll_init.cc (dll_list::alloc): Try harder to find space to allocate dll
struct.
(dll_dllcrt0): Don't check sanity if we've already called dll_crt0.
* path.cc (path_conv::check): Don't check for a null or empty path unless
specifically told with a flag setting.
(check_null_empty_path): New function, adapted from macro.
* syscalls.cc (_rename): Use already-determined file attributes rather than
checking again.
* lib/cygwin/cygwin_attach.dll.c (cygwin_attach_dll): Use a static per_process
structure since this is apparently supposed to be zeroed.
* lib/cygwin_crt0.c (cygwin_crt0): Zero per_process structure sent to older
DLLs.
@
text
@d949 1
a949 1
  buf->st_blocks  = (buf->st_size + S_BLKSIZE-1) / S_BLKSIZE;
@


1.23
log
@Slight optimization.
@
text
@d1182 2
a1183 1
  path_conv real_path (path, (flags & O_NOSYMLINK) ? SYMLINK_NOFOLLOW:SYMLINK_FOLLOW);
@


1.22
log
@* cygwin.din: Export _getmode and getmode to allow querying of binary state of
an fd.
* external.cc (cygwin_internal): Add handling of perfile_table setting.
* fhandler.cc (perfile_table): New global.
(fhandler_base::get_default_fmode): New method to return a file's default mode
based on its name.
(fhandler_base::open): Use get_default_mode method to determine a file's mode.
Record file mode in file flags.
* fhandler.h (fhandler_base): Declare get_default_fmode
* syscalls.cc (getmode): New function.
* sys/cygwin.h (__cygwin_perfile): New structure.
(cygwin_getinfo_types): Move outside of WINVER conditional.
(per_process): Move inside of WINVER conditional.
@
text
@d268 1
a268 1
	  else if (strcasematch (stem, pf->name) && ACCFLAGS (pf->flags) == accflags)
@


1.21
log
@* Makefile.in: Use variables rather than configure constructs where
appropriate.
(LIBCOS): Find additional stub library stuff in their own subdirectory.
* dcrt0.cc: Convert user_data pointer to static __cygwin_user_data area.
(do_global_ctors): Check magic_bisquit for initialization.
(dll_crt0_1): First group of premain functions prior to fd initialization.  Run
second group before calling main.
(dll_crt0 ()): New function, called from new initialization code.
(dll_crt0 (per_process *uptr)): Call new dll_crt0 () function on
initialization.
* debug.cc (thread_stub): Initialize bottom of stack with per-thread info.
* environ.cc (parse_thing): Use binmode global to control CYGWIN=binmode
behavior.
* fhandler.cc (fhandler_base::open): Allow explicit setting of __fmode to
O_BINARY or O_TEXT to override disk mount settings.
* libcmain.cc: Move to lib subdirectory.
* libccrt0.cc: Ditto.
* dll_main.cc: Ditto.
* dll_entry.cc: Ditto.
* getopt.c: Ditto.
* thread.cc (thread_init_wrapper): Call ExitThread explicitly rather than
returning, as a preliminary step towards placing per thread info at the bottom
of the stack.
* winsup.h: Move per_process class to include/sys/cygwin.h.  Declare new
dll_crt0().
* include/cygwin/version.h: Bump API minor version.
* binmode.c: New file.
* textmode.c: Ditto.
* lib/_cygwin_crt0_common.cc: Ditto.
* lib/crt0.h: Ditto.
* lib/cygwin_attach_dll.c: Ditto.
* lib/cygwin_crt0.c: Ditto.
* lib/dll_entry.cc: Ditto.
* lib/dll_main.cc: Ditto.
* lib/getopt.c: Ditto.
* lib/libcmain.c: Ditto.
* lib/premain0.c: Ditto.
* lib/premain1.c: Ditto.
* lib/premain2.c: Ditto.
* lib/premain3.c: Ditto.
@
text
@d21 2
d254 21
a287 2
  set_flags (flags);

d376 4
a379 3
  if (flags & (O_BINARY | O_TEXT))
    bin = flags & O_TEXT ? 0 : O_BINARY;
  else if (__fmode & O_BINARY)
d381 1
a381 1
  else if (__fmode & O_TEXT)
d387 5
@


1.20
log
@* fhandler.h (set_name): Don't use 'unix' as name since this is defined by gcc
now.
* fhandler.cc (set_name): Ditto.
@
text
@d21 2
d357 4
d364 1
a364 1
    bin = (__fmode & O_BINARY) || get_w_binary () || get_r_binary ();
@


1.19
log
@        * fhandler.cc (fhandler_disk_file::open): Check for directory
        to set O_DIROPEN on directories anyway.
@
text
@d127 1
a127 1
fhandler_base::set_name (const char *unix, const char *win32, int unit)
d138 1
a138 1
  if (unix == NULL || !*unix)
d141 1
a141 1
  unix_path_name_ = strdup (unix);
d148 2
a149 2
  if (win32)
    win32_path_name_ = strdup (win32);
@


1.18
log
@        * fhandler.cc (fhandler_disk_file::open): Check for executable
        even if ntsec is on if filesystem doesn't support ACLs.
@
text
@d1184 4
@


1.17
log
@        * fhandler.cc (fhandler_base::puts_readahead): Change
        while condition to disallow wild runs.
@
text
@d1192 3
a1194 2
  if (!real_path.isexec () && !allow_ntea && !allow_ntsec &&
      GetFileType (get_handle ()) == FILE_TYPE_DISK)
@


1.16
log
@* fhandler.cc (lock): use signed math to allow checking ranges
properly.
@
text
@d25 2
a26 2
  while ((((len == (size_t) -1) && *s) || len--) &&
	 (success = put_readahead (*s++) > 0))
@


1.15
log
@* dcrt0.cc (insert_file): Eliminate unused parameter.
(build_argv): Ditto.
* exceptions.cc (stack): Eliminate unused parameters.
(stackdump): Ditto.
(cygwin_stackdump): Reflect above changes.
(sig_handle): Ditto.
* fhandler.cc (fhandler_base::set_inheritance): Use kludge to avoid unused
parameter warning.
@
text
@d1246 2
a1247 2
  DWORD win32_start;
  DWORD win32_len;
d1307 2
a1308 1
      win32_len -= win32_start;
d1341 1
a1341 1
      ov.Offset = win32_start;
d1347 1
a1347 1
	  res = UnlockFileEx (get_handle (), 0, win32_len, win32_upper, &ov);
d1351 1
a1351 1
	  res = LockFileEx (get_handle (), lock_flags, 0, win32_len,
d1370 1
a1370 1
	res = UnlockFile (get_handle (), win32_start, 0, win32_len,
d1373 1
a1373 1
	res = LockFile (get_handle (), win32_start, 0, win32_len, win32_upper);
@


1.14
log
@        * fhandler.cc (fhandler_disk_file::open): Check for allow_ntsec
        when determining exec flag.
        * path.cc (symlink_info::check): Remove call to get_file_attribute().
        * security.cc (read_sd): Rename, ditto for variables to conform
        to common naming convention. Use GetFileSecurity() instead of
        BackupRead() to avoid permission problems when reading ACLs.
        (write_sd): Same renaming as for read_sd().
        (alloc_sd): Change default permissions according to Linux permissions
        for group and world when write permission is set.
        * syscalls.cc (stat_worker): Avoid different permission problems
        when requesting file informations.
@
text
@d1431 6
d1438 2
a1439 1
fhandler_base::set_inheritance (HANDLE &h, int not_inheriting, const char *name)
@


1.13
log
@* fhandler.h (fhandler_base::hclose): New virtual method.
(fhandler_base::set_inheritance): Make this a method so that we can use the
appropriate close methods.
* fhandler.cc (fhandler_base::set_inheritance): Ditto.
* path.cc (normalize_posix_path): Eliminate /.  trailing path component.
@
text
@d1190 1
d1192 1
a1192 1
  if (!real_path.isexec () && !allow_ntea &&
@


1.12
log
@* fhandler.cc (fhandler_disk_file::fstat): Allocate enough space for root dir
determination or overflow an array.
@
text
@d1430 2
a1431 2
void __stdcall
set_inheritance (HANDLE &h, int not_inheriting, const char *name)
d1441 1
a1441 1
      CloseHandle (h);
d1447 1
a1447 1
      CloseHandle (h);
d1451 1
@


1.11
log
@* fhandler.cc (fhandler_base::open): Call set_file_attribute() only if a file is really created.
@
text
@d890 3
a892 2
  /* Allocate some place to determine the root directory. */
  char root[strlen (get_win32_name ()) + 1];
@


1.10
log
@        * security.cc (set_process_privileges): Removed `static'.
        (get_nt_attribute): Returns uid and gid additionally. Removed call
        to set_process_privileges().
        (get_file_attribute): Returns uid and gid additionally. Don't
        call ntea if ntsec is ON.
        (set_nt_attribute): Removed call to set_process_privileges().
        Don't call ntea if ntsec is ON.
        (acl): Removed call to set_process_privileges().
        * dcrt0.cc (dll_crt0_1): Calls set_process_privileges() now.
        * winsup.h: New prototype for set_process_privileges(),
        changed prototype for get_file_attribute().
        * fhandler.cc (get_file_owner): Discarded.
        (get_file_group): Ditto.
        (fhandler_disk_file::fstat): Discard calls to get_file_owner() and
        get_file_group().
        * path.cc (path_conv::path_conv): Added debugging output for result
        of GetVolumeInformation().
        (mount_info::conv_to_win32_path): Call backslashify() with pathbuf
        instead of src_path.
        * syscalls.cc (chown): Reformatted.
        (chmod): Replace get_file_owner() and get_file_group() calls
        by a call to get_file_attribute(). Discard local variable has_acls.
        Slightly reformatted.
        (stat_worker): Replaced idiot's (it's me) root dir check by call
        to rootdir(). Don't call num_entries() on remote drives.
        Discard local variable has_acls.
@
text
@d343 3
a345 1
  if (flags & O_CREAT && get_device () == FH_DISK)
@


1.9
log
@Pipe changes throughout suggested by Eric Fifer <EFifer@@sanwaint.com>
* debug.cc (threadname_init): Pass name of lock as arg 2 of new_muto.
* malloc.cc (malloc_init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* exceptions.cc (events_init): Ditto.
(call_handler): Eliminate special case for hExeced.  Report locked thread in
debugging output.
* fhandler.cc (fhandker_pipe::fhandler_pipe): Propagate device type to base
class.
* fhandler.h (fhandler_pipe): Ditto.
* hinfo.cc (hinfo::build_fhandler): Pass specific type of pipe to constructor.
* spawn.cc (spawn_guts): Eliminate dependency on signal when waiting for
subprocess.
* strace.cc: Remove obsolete #ifdef.
* sync.cc (muto::muto): Save the name of the muto.
(muto:~muto): Also release the muto.
* sync.h: Add a muto name field.
* select.cc (peek_pipe): Avoid doing a PeekNamedPipe on the write end of a
pipe.
@
text
@a116 48
uid_t __stdcall
get_file_owner (int use_ntsec, const char *filename)
{
  if (use_ntsec && allow_ntsec)
    {
      extern LONG ReadSD(const char *, PSECURITY_DESCRIPTOR, LPDWORD);
      DWORD sd_size = 4096;
      char psd_buffer[4096];
      PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) psd_buffer;
      PSID psid;
      BOOL bOwnerDefaulted = TRUE;

      if (ReadSD (filename, psd, &sd_size) <= 0)
        return getuid();

      if (!GetSecurityDescriptorOwner (psd, &psid, &bOwnerDefaulted))
        return getuid ();

      return psid ? get_uid_from_sid (psid) : getuid ();
    }

  return getuid();
}

gid_t __stdcall
get_file_group (int use_ntsec, const char *filename)
{
  if (use_ntsec && allow_ntsec)
    {
      extern LONG ReadSD(const char *, PSECURITY_DESCRIPTOR, LPDWORD);
      DWORD sd_size = 4096;
      char psd_buffer[4096];
      PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) psd_buffer;
      PSID psid;
      BOOL bGroupDefaulted = TRUE;

      if (ReadSD (filename, psd, &sd_size) <= 0)
        return getgid();

      if (!GetSecurityDescriptorGroup (psd, &psid, &bGroupDefaulted))
        return getgid ();

      return psid ? get_gid_from_sid (psid) : getuid ();
    }

  return getgid ();
}

a913 2
  buf->st_uid     = get_file_owner (has_acls (), get_win32_name ());
  buf->st_gid     = get_file_group (has_acls (), get_win32_name ());
d919 5
a923 1
  if (! get_file_attribute (has_acls (), get_win32_name (), &buf->st_mode))
@


1.8
log
@* fhandler.cc (fhandler_base::get_readahead_into_buffer): New function.
* fhandler.h: Declare new function.  Add extra argument to
process_slave_output.
* fhandler_console.cc (fhandler_console::read): Move read ahead code to new
function.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Move common code
here.
(fhandler_tty_slave::read): Understand readahead.
(fhandler_pty_master::read): Move code to process_slave_output.
* select.cc (peek_pipe): Avoid performing certain checks when non-read and on
inappropriate fh types.
@
text
@d1459 2
a1460 2
fhandler_pipe::fhandler_pipe (const char *name) :
	fhandler_base (FH_PIPE, name)
@


1.7
log
@Throughout use strace class in place of individual functions and variables.
* cygwin.din: Eliminate _strace_wm.
* sigproc.cc (wait_sig): Temporarily add more debugging output.
* include/cygwin/version.h: Bump minor api to reflect export change.
@
text
@d99 18
@


1.6
log
@Remove unneeded include.
@
text
@d494 1
a494 1
  if (strace_active)
@


1.5
log
@* exceptions.cc (interruptible): Make a little more structured.
(call_handler): Allow signals to be sent even if signalled thread is stopped.
Change order of signal_arrived arming/waiting threads clearing to eliminate a
race.
(reset_signal_arrived): New helper function.
* malloc.cc (malloc_init): Use mutos so that signal handler can keep track of
who owns the lock.
(__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* sync.h (new_muto): Actually use a muto for the "buffer".
* Makefile.in: Fix a dependency.
@
text
@a15 1
#include "sync.h"
@


1.4
log
@* fhandler.cc (set_inheritance): Revert previous patch which got rid of 'name'
parameter.
@
text
@d16 1
@


1.3
log
@Respond to a multitude of g++ warnings.
@
text
@d1456 1
a1456 1
set_inheritance (HANDLE &h, int not_inheriting, const char *)
@


1.2
log
@*** empty log message ***
@
text
@d87 1
a87 1
      if ((ralen -= n) < 0)
d1062 1
a1062 1
fhandler_base::tcflush (int queue)
d1069 1
a1069 1
fhandler_base::tcsendbreak (int duration)
d1083 1
a1083 1
fhandler_base::tcflow (int action)
d1090 1
a1090 1
fhandler_base::tcsetattr (int a, const struct termios *t)
d1097 1
a1097 1
fhandler_base::tcgetattr (struct termios *t)
d1104 1
a1104 1
fhandler_base::tcsetpgrp (const pid_t pid)
d1296 1
a1296 1
	if ((startpos = lseek (0, SEEK_CUR)) < 0)
d1456 1
a1456 1
set_inheritance (HANDLE &h, int not_inheriting, const char *name)
@


1.1
log
@Initial revision
@
text
@d953 4
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
