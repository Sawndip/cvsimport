head	1.97;
access;
symbols
	cygwin-1_7_35-release:1.97
	cygwin-1_7_34-release:1.97
	cygwin-1_7_33-release:1.97
	cygwin-1_7_32-release:1.97
	cygwin-1_7_31-release:1.97
	cygwin-1_7_30-release:1.97
	cygwin-1_7_29-release:1.97
	cygwin-1_7_29-release-branchpoint:1.97.0.2
	cygwin-pre-user-db:1.97
	cygwin-1_7_28-release:1.97
	cygwin-1_7_27-release:1.97
	cygwin-1_7_26-release:1.97
	cygwin-1_7_25-release:1.97
	cygwin-1_7_24-release:1.97
	cygwin-1_7_23-release:1.97
	cygwin-1_7_22-release:1.97
	cygwin-1_7_21-release:1.97
	cygwin-1_7_20-release:1.97
	cygwin-1_7_19-release:1.97
	cygwin-64bit-postmerge:1.97
	cygwin-64bit-premerge-branch:1.96.0.2
	cygwin-64bit-premerge:1.96
	cygwin-1_7_18-release:1.96
	post-ptmalloc3:1.93.2.4
	pre-ptmalloc3:1.93.2.4
	cygwin-1_7_17-release:1.94
	cygwin-64bit-branch:1.93.0.2
	cygwin-1_7_16-release:1.91
	cygwin-1_7_15-release:1.89
	cygwin-1_7_14_2-release:1.89
	cygwin-1_7_14-release:1.89
	cygwin-1_7_12-release:1.89
	cygwin-1_7_11-release:1.89
	cygwin-1_7_10-release:1.89
	signal-rewrite:1.85.0.2
	pre-notty:1.84
	cygwin-1_7_9-release:1.83
	cv-post-1_7_9:1.83.0.2
	cygwin-1_7_8-release:1.83
	cygwin-1_7_7-release:1.82
	cygwin-1_7_5-release:1.80
	cygwin-1_7_4-release:1.80
	cygwin-1_7_3-release:1.80
	cygwin-1_7_2-release:1.80
	fifo_doover3:1.79.0.4
	cygwin-1_7_1-release:1.79
	prefifo:1.79
	cv-branch-2:1.79.0.2
	pre-ripout-set_console_state_for_spawn:1.78
	EOL_registry_mounts:1.76
	preoverlapped:1.76
	drop_9x_support_start:1.76
	cr-0x5f1:1.76.0.4
	cv-branch:1.76.0.2
	pre-ptymaster-archetype:1.75
	cr-0x3b58:1.72.0.4
	cr-0x5ef:1.72.0.2
	after-mmap-privanon-noreserve:1.72
	after-mmap-revamp:1.72
	before-mmap-revamp:1.72
	cgf-more-exit-sync:1.71
	post_wait_sig_exit:1.71
	pre_wait_sig_exit:1.70
	reparent-point:1.44
	noreparent:1.44.0.4
	cr-0x5e6:1.44.0.2
	cr-0x9e:1.41.0.4
	cr-0x9d:1.41.0.2
	cgf-deleteme:1.40.0.2
	pre-sigrewrite:1.37
	corinna-01:1.37
	cr-0x9c:1.36.0.6
	cr-0x9b:1.36.0.4
	cr-0x99:1.36
	Z-emcb-cygwin_daemon:1.36.0.2
	w32api-2_2:1.25
	mingw-runtime-2_4:1.25
	pre-cgf-merge:1.36
	cgf-dev-branch:1.25.0.2
	Z-cygwin_daemon_merge_HEAD:1.8
	cygwin_daemon:1.2.0.2
	Z-cygwin_daemon_merge-new_HEAD:1.8;
locks; strict;
comment	@// @;


1.97
date	2013.04.23.09.44.31;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2013.03.29.17.00.35;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2012.09.14.03.32.51;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2012.07.23.04.36.48;	author cgf;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2012.06.19.00.38.01;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2012.06.19.00.31.14;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2011.12.17.23.39.46;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2011.11.24.21.38.17;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2011.09.21.04.33.57;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2011.08.25.19.37.38;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2011.07.30.20.50.23;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2011.04.29.08.27.10;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2010.09.01.18.24.10;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2010.08.20.15.28.28;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2010.07.30.18.04.22;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2010.03.12.23.13.47;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2009.01.03.05.12.20;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2006.06.03.21.44.01;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2006.03.01.21.31.24;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2006.03.01.18.23.24;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2006.02.28.01.27.41;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2005.10.17.23.27.00;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2005.09.21.19.29.50;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.12.21.19.07;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2005.07.29.14.29.33;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2005.07.06.20.04.58;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2005.06.15.22.50.31;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2005.06.09.23.48.08;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2005.06.07.18.41.31;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2005.05.18.23.30.02;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.28.19.31.22;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2005.03.27.01.57.37;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2005.03.03.16.53.52;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2005.02.13.18.17.28;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2005.02.11.15.24.15;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2005.02.08.16.56.02;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2005.02.06.05.04.34;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2005.02.01.16.49.11;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2005.01.29.05.39.07;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.03.18.16.46;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2005.01.02.02.22.25;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2004.12.28.01.27.26;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2004.12.23.15.36.59;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2004.12.23.14.57.07;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.22.18.12.29;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.22.17.10.19;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.22.16.59.03;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.22.16.19.27;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2004.11.26.04.15.06;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.16.04.18.50;	author cgf;	state Exp;
branches
	1.44.4.1;
next	1.43;

1.43
date	2004.02.09.04.04.22;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.19.05.46.54;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.14.15.45.36;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.14.07.09.22;	author cgf;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2003.12.05.05.29.17;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.03.05.21.55;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2003.11.07.18.21.05;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.16.03.24.09;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.05.19.18.33;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.21.22.02;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.09.17.56.58;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.11.02.16.17;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.10.05.27.34;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.04.18.52.11;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.04.06.03.52;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.04.05.58.06;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.02.23.01.11;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.27.15.09.31;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.10.12.32.45;	author corinna;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2003.01.10.03.13.45;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.25.17.43.37;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.14.04.01.31;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.11.04.00.03;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.13.19.36.12;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.22.20.16.31;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.21.01.00.56;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.20.18.17.43;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2002.10.19.00.35.20;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.14.03.51.44;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.14.02.37.49;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.13.18.16.33;	author cgf;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2002.10.09.05.55.40;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.09.04.08.05;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.06.01.01.58;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.29.02.19.35;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.19.03.30.19;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.29.03.33.50;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.11.19.31.24;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.06.05.08.55;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.05.16.15.46;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.02.02.10.24;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.01.16.27.29;	author cgf;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.08.01.16.20.31;	author cgf;	state Exp;
branches;
next	;

1.93.2.1
date	2012.10.16.15.18.37;	author corinna;	state Exp;
branches;
next	1.93.2.2;

1.93.2.2
date	2012.10.31.17.00.04;	author corinna;	state Exp;
branches;
next	1.93.2.3;

1.93.2.3
date	2012.12.10.11.45.45;	author corinna;	state Exp;
branches;
next	1.93.2.4;

1.93.2.4
date	2013.01.21.13.52.04;	author corinna;	state Exp;
branches;
next	1.93.2.5;

1.93.2.5
date	2013.03.29.17.00.58;	author corinna;	state Exp;
branches;
next	;

1.44.4.1
date	2004.11.16.06.02.05;	author cgf;	state Exp;
branches;
next	1.44.4.2;

1.44.4.2
date	2004.11.16.15.16.55;	author cgf;	state Exp;
branches;
next	1.44.4.3;

1.44.4.3
date	2004.11.18.00.48.39;	author cgf;	state Exp;
branches;
next	;

1.40.2.1
date	2004.01.11.18.13.52;	author cgf;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2004.01.12.05.15.19;	author cgf;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2004.01.19.05.38.23;	author cgf;	state Exp;
branches;
next	;

1.25.2.1
date	2003.02.11.03.13.08;	author cgf;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2003.02.27.15.10.22;	author cgf;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2003.04.04.05.58.29;	author cgf;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2003.04.04.18.56.46;	author cgf;	state Exp;
branches;
next	1.25.2.6;

1.25.2.6
date	2003.05.10.17.20.52;	author cgf;	state Exp;
branches;
next	1.25.2.7;

1.25.2.7
date	2003.06.06.00.27.50;	author cgf;	state Exp;
branches;
next	1.25.2.8;

1.25.2.8
date	2003.07.06.05.10.42;	author cgf;	state Exp;
branches;
next	;

1.13.4.1
date	2002.10.14.03.31.59;	author cgf;	state Exp;
branches;
next	;

1.2.2.1
date	2002.08.01.20.34.06;	author scottc;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.08.02.02.23.44;	author scottc;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.08.06.07.14.59;	author scottc;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2002.08.12.14.06.34;	author scottc;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2002.08.29.19.19.27;	author scottc;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.97
log
@	* Merge in cygwin-64bit-branch.
@
text
@/* cygthread.cc

   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2008, 2009,
   2010, 2011, 2012, 2013 Red Hat, Inc.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "miscfuncs.h"
#include <stdlib.h>
#include "sigproc.h"
#include "cygtls.h"
#include "ntdll.h"

#undef CloseHandle

static cygthread NO_COPY threads[64];
#define NTHREADS (sizeof (threads) / sizeof (threads[0]))

DWORD NO_COPY cygthread::main_thread_id;
bool NO_COPY cygthread::exiting;

void
cygthread::callfunc (bool issimplestub)
{
  void *pass_arg;
  if (arg == cygself)
    pass_arg = this;
  else if (!arglen)
    pass_arg = arg;
  else
    {
      if (issimplestub)
	ev = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
      pass_arg = alloca (arglen);
      memcpy (pass_arg, arg, arglen);
      SetEvent (ev);
    }
  if (issimplestub)
    {
      /* Wait for main thread to assign 'h' */
      while (!h)
	yield ();
      if (ev)
	CloseHandle (ev);
      ev = h;
    }
  /* Cygwin threads should not call ExitThread directly */
  func (pass_arg);
  /* ...so the above should always return */
}

/* Initial stub called by cygthread constructor. Performs initial
   per-thread initialization and loops waiting for another thread function
   to execute.  */
DWORD WINAPI
cygthread::stub (VOID *arg)
{
  cygthread *info = (cygthread *) arg;
  _my_tls._ctinfo = info;
  if (info->arg == cygself)
    {
      if (info->ev)
	{
	  CloseHandle (info->ev);
	  CloseHandle (info->thread_sync);
	}
      info->ev = info->thread_sync = info->stack_ptr = NULL;
    }
  else
    {
      info->stack_ptr = &arg;
      debug_printf ("thread '%s', id %y, stack_ptr %p", info->name (), info->id, info->stack_ptr);
      if (!info->ev)
	{
	  info->ev = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
	  info->thread_sync = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
	}
    }

  while (1)
    {
      if (!info->__name)
#ifdef DEBUGGING
	system_printf ("erroneous thread activation, name is NULL prev thread name = '%s'", info->__oldname);
#else
	system_printf ("erroneous thread activation, name is NULL");
#endif
      else
	{
	  info->callfunc (false);

	  HANDLE notify = info->notify_detached;
	  /* If func is NULL, the above function has set that to indicate
	     that it doesn't want to alert anyone with a SetEvent and should
	     just be marked as no longer inuse.  Hopefully the function knows
	     what it is doing.  */
	  if (!info->func)
	    info->release (false);
	  else
	    {
#ifdef DEBUGGING
	      info->func = NULL;	// catch erroneous activation
	      info->__oldname = info->__name;
#endif
	      info->__name = NULL;
	      SetEvent (info->ev);
	    }
	  if (notify)
	    SetEvent (notify);
	}
      switch (WaitForSingleObject (info->thread_sync, INFINITE))
	{
	case WAIT_OBJECT_0:
	  continue;
	default:
	  api_fatal ("WFSO failed, %E");
	  break;
	}
    }
}

/* Overflow stub called by cygthread constructor. Calls specified function
   and then exits the thread.  */
DWORD WINAPI
cygthread::simplestub (VOID *arg)
{
  cygthread *info = (cygthread *) arg;
  _my_tls._ctinfo = info;
  info->stack_ptr = &arg;
  HANDLE notify = info->notify_detached;
  info->callfunc (true);
  if (notify)
     SetEvent (notify);
  return 0;
}

/* Start things going.  Called from dll_crt0_1. */
void
cygthread::init ()
{
  main_thread_id = GetCurrentThreadId ();
}

cygthread *
cygthread::freerange ()
{
  cygthread *self = (cygthread *) calloc (1, sizeof (*self));
  self->is_freerange = true;
  self->inuse = 1;
  return self;
}

void * cygthread::operator
new (size_t)
{
  cygthread *info;

  /* Search the threads array for an empty slot to use */
  for (info = threads; info < threads + NTHREADS; info++)
    if (!InterlockedExchange (&info->inuse, 1))
      {
	/* available */
#ifdef DEBUGGING
	if (info->__name)
	  api_fatal ("name not NULL? %s, id %y, i %ld", info->__name, info->id, info - threads);
#endif
	goto out;
      }

#ifdef DEBUGGING
  if (!getenv ("CYGWIN_FREERANGE_NOCHECK"))
    api_fatal ("overflowed cygwin thread pool");
  else
    thread_printf ("overflowed cygwin thread pool");
#endif

  info = freerange ();	/* exhausted thread pool */

out:
  return info;
}

/* This function is called via QueueUserAPC.  Apparently creating threads
   asynchronously is a huge performance win on Win64.  */
void CALLBACK
cygthread::async_create (ULONG_PTR arg)
{
  cygthread *that = (cygthread *) arg;
  that->create ();
  ::SetThreadPriority (that->h, THREAD_PRIORITY_HIGHEST);
  that->zap_h ();
}

void
cygthread::create ()
{
  thread_printf ("name %s, id %y, this %p", __name, id, this);
  HANDLE htobe;
  if (h)
    {
      if (ev)
	ResetEvent (ev);
      while (!thread_sync)
	yield ();
      SetEvent (thread_sync);
      thread_printf ("activated name '%s', thread_sync %p for id %y", __name, thread_sync, id);
      htobe = h;
    }
  else
    {
      stack_ptr = NULL;
      htobe = CreateThread (&sec_none_nih, 0, is_freerange ? simplestub : stub,
			    this, 0, &id);
      if (!htobe)
	api_fatal ("CreateThread failed for %s - %p<%y>, %E", __name, h, id);
      thread_printf ("created name '%s', thread %p, id %y", __name, h, id);
#ifdef DEBUGGING
      terminated = false;
#endif
    }

  if (arglen)
    {
      while (!ev)
	yield ();
      WaitForSingleObject (ev, INFINITE);
      ResetEvent (ev);
    }
  h = htobe;
}

/* Return the symbolic name of the current thread for debugging.
 */
const char *
cygthread::name (DWORD tid)
{
  const char *res = NULL;
  if (!tid)
    tid = GetCurrentThreadId ();

  if (tid == main_thread_id)
    return "main";

  for (DWORD i = 0; i < NTHREADS; i++)
    if (threads[i].id == tid)
      {
	res = threads[i].__name ?: "exiting thread";
	break;
      }

  if (res)
    /* ok */;
  else if (!_main_tls)
    res = "main";
  else
    {
      __small_sprintf (_my_tls.locals.unknown_thread_name, "unknown (%y)", tid);
      res = _my_tls.locals.unknown_thread_name;
    }
  return res;
}

cygthread::operator
HANDLE ()
{
  while (!ev)
    yield ();
  return ev;
}

void
cygthread::release (bool nuke_h)
{
  if (nuke_h)
    h = NULL;
#ifdef DEBUGGING
  __oldname = __name;
  debug_printf ("released thread '%s'", __oldname);
#endif
  __name = NULL;
  func = NULL;
  /* Must be last */
  if (!InterlockedExchange (&inuse, 0))
#ifdef DEBUGGING
    api_fatal ("released a thread that was not inuse");
#else
    system_printf ("released a thread that was not inuse");
#endif
}

/* Forcibly terminate a thread. */
bool
cygthread::terminate_thread ()
{
  bool terminated = true;
  debug_printf ("thread '%s', id %y, inuse %d, stack_ptr %p", __name, id, inuse, stack_ptr);
  while (inuse && !stack_ptr)
    yield ();

  if (!inuse)
    goto force_notterminated;

  TerminateThread (h, 0);
  WaitForSingleObject (h, INFINITE);
  CloseHandle (h);

  if (!inuse || exiting)
    goto force_notterminated;

  if (ev && !(terminated = !IsEventSignalled (ev)))
    ResetEvent (ev);

  if (!wincap.terminate_thread_frees_stack ())
    {
      MEMORY_BASIC_INFORMATION m;
      memset (&m, 0, sizeof (m));
      VirtualQuery (stack_ptr, &m, sizeof m);

      if (!m.RegionSize)
	system_printf ("m.RegionSize 0?  stack_ptr %p", stack_ptr);
      else if (!VirtualFree (m.AllocationBase, 0, MEM_RELEASE))
	debug_printf ("VirtualFree of allocation base %p<%p> failed, %E",
		       stack_ptr, m.AllocationBase);
    }

  if (is_freerange)
    free (this);
  else
    {
#ifdef DEBUGGING
      terminated = true;
#endif
      release (true);
    }

  goto out;

force_notterminated:
  terminated = false;
out:
  return terminated;
}

/* Detach the cygthread from the current thread.  Note that the
   theory is that cygthreads are only associated with one thread.
   So, there should be never be multiple threads doing waits
   on the same cygthread. */
bool
cygthread::detach (HANDLE sigwait)
{
  bool signalled = false;
  bool thread_was_reset = false;
  if (!inuse)
    system_printf ("called detach but inuse %d, thread %y?", inuse, id);
  else
    {
      DWORD res;

      if (!sigwait)
	/* If the caller specified a special handle for notification, wait for that.
	   This assumes that the thread in question is auto releasing. */
	res = WaitForSingleObject (*this, INFINITE);
      else
	{
	  /* Lower our priority and give priority to the read thread */
	  HANDLE hth = GetCurrentThread ();
	  LONG prio = GetThreadPriority (hth);
	  ::SetThreadPriority (hth, THREAD_PRIORITY_BELOW_NORMAL);

	  HANDLE w4[2];
	  unsigned n = 2;
	  DWORD howlong = INFINITE;
	  w4[0] = sigwait;
	  set_signal_arrived here (w4[1]);
	  /* For a description of the below loop see the end of this file */
	  for (int i = 0; i < 2; i++)
	    switch (res = WaitForMultipleObjects (n, w4, FALSE, howlong))
	      {
	      case WAIT_OBJECT_0:
		if (n == 1)
		  howlong = 50;
		break;
	      case WAIT_OBJECT_0 + 1:
		n = 1;
		if (i--)
		  howlong = 50;
		break;
	      case WAIT_TIMEOUT:
		break;
	      default:
		if (!exiting)
		  {
		    system_printf ("WFMO failed waiting for cygthread '%s', %E", __name);
		    for (unsigned j = 0; j < n; j++)
		      switch (WaitForSingleObject (w4[j], 0))
			{
			case WAIT_OBJECT_0:
			case WAIT_TIMEOUT:
			  break;
			default:
			  system_printf ("%s handle %p is bad", (j ? "signal_arrived" : "semaphore"), w4[j]);
			  break;
			}
		    api_fatal ("exiting on fatal error");
		  }
		break;
	      }
	  /* WAIT_OBJECT_0 means that the thread successfully read something,
	     so wait for the cygthread to "terminate". */
	  if (res == WAIT_OBJECT_0)
	    WaitForSingleObject (*this, INFINITE);
	  else
	    {
	      /* Thread didn't terminate on its own, so maybe we have to
		 do it. */
	      signalled = terminate_thread ();
	      /* Possibly the thread completed *just* before it was
		 terminated.  Detect this. If this happened then the
		 read was not terminated on a signal. */
	      if (WaitForSingleObject (sigwait, 0) == WAIT_OBJECT_0)
		signalled = false;
	      if (signalled)
		set_sig_errno (EINTR);
	      thread_was_reset = true;
	    }
	  ::SetThreadPriority (hth, prio);
	}

      thread_printf ("%s returns %d, id %y", sigwait ? "WFMO" : "WFSO",
		     res, id);

      if (thread_was_reset)
	/* already handled */;
      else if (is_freerange)
	{
	  CloseHandle (h);
	  free (this);
	}
      else
	{
	  ResetEvent (*this);
	  /* Mark the thread as available by setting inuse to zero */
	  InterlockedExchange (&inuse, 0);
	}
    }
  return signalled;
}

void
cygthread::terminate ()
{
  exiting = 1;
}

/* The below is an explanation of synchronization loop in cygthread::detach.
   The intent is that the loop will always try hard to wait for both
   synchronization events from the reader thread but will exit with
   res == WAIT_TIMEOUT if a signal occurred and the reader thread is
   still blocked.

    case 0 - no signal

    i == 0 (howlong == INFINITE)
	W0 activated
	howlong not set because n != 1
	just loop

    i == 1 (howlong == INFINITE)
	W0 activated
	howlong not set because n != 1
	just loop (to exit loop) - no signal

    i == 2 (howlong == INFINITE)
	exit loop

    case 1 - signal before thread initialized

    i == 0 (howlong == INFINITE)
	WO + 1 activated
	n set to 1
	howlong untouched because i-- == 0
	loop

    i == 0 (howlong == INFINITE)
	W0 must be activated
	howlong set to 50 because n == 1

    i == 1 (howlong == 50)
	W0 activated
	loop (to exit loop) - no signal

	WAIT_TIMEOUT activated
	signal potentially detected
	loop (to exit loop)

    i == 2 (howlong == 50)
	exit loop

    case 2 - signal after thread initialized

    i == 0 (howlong == INFINITE)
	W0 activated
	howlong not set because n != 1
	loop

    i == 1 (howlong == INFINITE)
	W0 + 1 activated
	n set to 1
	howlong set to 50 because i-- != 0
	loop

    i == 1 (howlong == 50)
	W0 activated
	loop (to exit loop) - no signal

	WAIT_TIMEOUT activated
	loop (to exit loop) - signal

    i == 2 (howlong == 50)
	exit loop
*/
@


1.96
log
@	* cygthread.cc (cygthread::terminate_thread): Only try to free
	thread stack on systems not freeing it by themselves.
	* wincap.h (wincaps::terminate_thread_frees_stack): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d75 1
a75 1
      debug_printf ("thread '%s', id %p, stack_ptr %p", info->name (), info->id, info->stack_ptr);
d168 1
a168 1
	  api_fatal ("name not NULL? %s, id %p, i %d", info->__name, info->id, info - threads);
d200 1
a200 1
  thread_printf ("name %s, id %p, this %p", __name, id, this);
d209 1
a209 1
      thread_printf ("activated name '%s', thread_sync %p for id %p", __name, thread_sync, id);
d218 2
a219 2
	api_fatal ("CreateThread failed for %s - %p<%p>, %E", __name, h, id);
      thread_printf ("created name '%s', thread %p, id %p", __name, h, id);
d260 1
a260 1
      __small_sprintf (_my_tls.locals.unknown_thread_name, "unknown (%p)", tid);
d299 1
a299 1
  debug_printf ("thread '%s', id %p, inuse %d, stack_ptr %p", __name, id, inuse, stack_ptr);
d357 1
a357 1
    system_printf ("called detach but inuse %d, thread %p?", inuse, id);
d432 1
a432 1
      thread_printf ("%s returns %d, id %p", sigwait ? "WFMO" : "WFSO",
@


1.95
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d4 1
a4 1
   2010, 2011, 2012 Red Hat, Inc.
d316 12
a327 9
  MEMORY_BASIC_INFORMATION m;
  memset (&m, 0, sizeof (m));
  VirtualQuery (stack_ptr, &m, sizeof m);

  if (!m.RegionSize)
    system_printf ("m.RegionSize 0?  stack_ptr %p", stack_ptr);
  else if (!VirtualFree (m.AllocationBase, 0, MEM_RELEASE))
    debug_printf ("VirtualFree of allocation base %p<%p> failed, %E",
		   stack_ptr, m.AllocationBase);
@


1.94
log
@* cygthread.cc (cygthread::stub): Remove old, unnecessary, FIXMEd code.
* spawn.cc (child_info_spawn::worker): Avoid calling close_all_files() twice.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2008,
   2009, 2010, 2011 Red Hat, Inc.
@


1.93
log
@Change "set_thread_waiting" to "set_signal_arrived" throughout.
@
text
@a92 6
	  if (exiting)
	    {
	      info->inuse = false;	// FIXME: Do we need this?
	      return 0;
	    }

@


1.93.2.1
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d93 6
@


1.93.2.2
log
@	* cygthread.cc: Fix usage of %p in debug printfs, throughout.
	* dcrt0.cc: Ditto.
	* dtable.cc: Ditto.
	* errno.cc: Ditto.
	* exceptions.cc: Ditto.
	* fhandler.cc: Ditto.
	* fhandler_console.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.

	* fhandler_clipboard.cc (cygnativeformat): Define as UINT.
	(fhandler_dev_clipboard::read): Ditto for local format variable.
	Use casts to compare off_t with size_t value.
	* fhandler_console.cc (fhandler_console::ioctl): Avoid compiler
	warnings.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Fix cast.
	* include/sys/dirent.h (struct __DIR): Define __d_internal as uintptr_t,
	rather than unsigned int.

	And pull in changes from HEAD.
@
text
@d75 1
a75 1
      debug_printf ("thread '%s', id %y, stack_ptr %p", info->name (), info->id, info->stack_ptr);
d168 1
a168 1
	  api_fatal ("name not NULL? %s, id %y, i %d", info->__name, info->id, info - threads);
d200 1
a200 1
  thread_printf ("name %s, id %y, this %p", __name, id, this);
d209 1
a209 1
      thread_printf ("activated name '%s', thread_sync %p for id %y", __name, thread_sync, id);
d218 2
a219 2
	api_fatal ("CreateThread failed for %s - %p<%y>, %E", __name, h, id);
      thread_printf ("created name '%s', thread %p, id %y", __name, h, id);
d260 1
a260 1
      __small_sprintf (_my_tls.locals.unknown_thread_name, "unknown (%y)", tid);
d299 1
a299 1
  debug_printf ("thread '%s', id %y, inuse %d, stack_ptr %p", __name, id, inuse, stack_ptr);
d354 1
a354 1
    system_printf ("called detach but inuse %d, thread %y?", inuse, id);
d429 1
a429 1
      thread_printf ("%s returns %d, id %y", sigwait ? "WFMO" : "WFSO",
@


1.93.2.3
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012 Red Hat, Inc.
d168 1
a168 1
	  api_fatal ("name not NULL? %s, id %y, i %ld", info->__name, info->id, info - threads);
@


1.93.2.4
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2008, 2009,
   2010, 2011, 2012 Red Hat, Inc.
@


1.93.2.5
log
@Pull in changes from HEAD
@
text
@d4 1
a4 1
   2010, 2011, 2012, 2013 Red Hat, Inc.
d316 9
a324 12
  if (!wincap.terminate_thread_frees_stack ())
    {
      MEMORY_BASIC_INFORMATION m;
      memset (&m, 0, sizeof (m));
      VirtualQuery (stack_ptr, &m, sizeof m);

      if (!m.RegionSize)
	system_printf ("m.RegionSize 0?  stack_ptr %p", stack_ptr);
      else if (!VirtualFree (m.AllocationBase, 0, MEM_RELEASE))
	debug_printf ("VirtualFree of allocation base %p<%p> failed, %E",
		       stack_ptr, m.AllocationBase);
    }
@


1.92
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d380 1
a380 1
	  set_thread_waiting here (w4[1]);
@


1.91
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@d380 1
a380 1
	  w4[1] = signal_arrived;
@


1.90
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d376 2
d379 2
d383 1
a383 1
	    switch (res = cygwait (sigwait, howlong))
d389 1
a389 1
	      case WAIT_SIGNALED:
d398 14
a411 1
		  api_fatal ("WFMO failed waiting for cygthread '%s', %E", __name);
@


1.89
log
@Clean up whitespace.
@
text
@a375 2
	  HANDLE w4[2];
	  unsigned n = 2;
a376 2
	  w4[0] = sigwait;
	  w4[1] = signal_arrived;
d379 1
a379 1
	    switch (res = WaitForMultipleObjects (n, w4, FALSE, howlong))
d385 1
a385 1
	      case WAIT_OBJECT_0 + 1:
d394 1
a394 14
		  {
		    system_printf ("WFMO failed waiting for cygthread '%s', %E", __name);
		    for (unsigned j = 0; j < n; j++)
		      switch (WaitForSingleObject (w4[j], 0))
			{
			case WAIT_OBJECT_0:
			case WAIT_TIMEOUT:
			  break;
			default:
			  system_printf ("%s handle %p is bad", (j ? "signal_arrived" : "semaphore"), w4[j]);
			  break;
			}
		    api_fatal ("exiting on fatal error");
		  }
@


1.88
log
@missed this in previous checkin
@
text
@a142 1
    
@


1.87
log
@* tty.cc (grantpt): Check for valid fd.
(unlockpt): Ditto.
@
text
@d261 5
a265 1
  if (!res)
a269 1

@


1.86
log
@* cygthread.cc (cygthread::simplestub): Notify that the thread has detached
also in freerange thread case.
@
text
@d19 1
a19 1
static cygthread NO_COPY threads[32];
@


1.85
log
@* cygthread.cc (cygthread::async_create): Define new function.
* cygthread.h (cygthread::create): Use correct regparm.
(cygthread::standalone): Delete from class and from all constructors.
(cygthread::cygthread): Use three only arguments for detached threads, and
start the thread via QueueUserAPC/async_create.
* dcrt0.cc (dll_crt0_0): Remove handling for wincap.has_buggy_thread_startup.
(dll_crt0_1): Ditto.
* wincap.cc: Ditto throughout.
* wincap.h: Ditto.
@
text
@d139 1
d141 3
@


1.84
log
@	* ntdll.h (IsEventSignalled): New inline function.
	* cygthread.cc (cygthread::terminate_thread): Use IsEventSignalled in
	place of WaitForSingleObject on event with 0 timeout.
	* fhandler.cc (fhandler_base_overlapped::has_ongoing_io): Ditto.
	* fhandler_fifo.cc (fhandler_fifo::open_nonserver): Ditto.
	(fhandler_fifo::wait): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* select.cc (verify_tty_slave): Ditto.
	* thread.cc (pthread::testcancel): Ditto.
@
text
@d189 11
@


1.83
log
@* cygthread.cc (cygthread::create): Fix incorrect use of name rather than
__name.
* cygthread.h (cygthread::cygthread): Create versions which eliminate 'n'
parameter.
* dcrt0.cc (dll_crt0_1): Remove check for threadfunc_ix.  Remove obsolete
comments.  Set process_state to active here.
* fhandler_netdrive.cc (create_thread_and_wait): Use shortened cygthread
constructor.
* timer.cc (timer_tracker::settime): Ditto.
* window.cc (HWND): Ditto.
* fhandler_tty.cc: Use shortened cygthread constructor, where appropriate,
throughout.
* select.cc: Ditto.
* fork.cc (frok::child): Remove wait_for_sigthread.
(fork): Reformat if for slightly better clarity.
* init.cc (dll_finished_loading): New variable.
(dll_entry): Use dll_finished_loading to determine when we should call
merge_threadfunc.
* sigproc.cc (no_signals_available): Simplify by using my_readsig.
(wait_sig_inited): Delete.
(wait_sig): Define as void function.
(pending_signals): Accommodate change to wait_sig definition.
(wait_for_sigthread): Delete definition.
(sigproc_init): Initialize signal pipe here, before wait_sig thread is created.
Use void form of cygthread creation.
(init_sig_pipe): Delete.
(wait_sig): Return void rather than DWORD.  Assume previous initialization of
signal pipe.  Set my_sendsig to NULL when exiting.
* sigproc.h (wait_for_sigthread): Delete declaration.
@
text
@d4 1
a4 1
   2009 2010 Red Hat, Inc.
d15 1
d302 1
a302 1
  if (ev && !(terminated = WaitForSingleObject (ev, 0) != WAIT_OBJECT_0))
@


1.82
log
@* cygthread.cc: Update copyright.
@
text
@d191 1
a191 1
  thread_printf ("name %s, id %p", name, id);
d200 1
a200 1
      thread_printf ("activated name '%s', thread_sync %p for thread %p", name, thread_sync, id);
d209 2
a210 2
	api_fatal ("CreateThread failed for %s - %p<%p>, %E", name, h, id);
      thread_printf ("created name '%s', thread %p, id %p", name, h, id);
@


1.81
log
@* cygthread.h (LPVOID_THREAD_START_ROUTINE): Define.
(cygthread::create): Rename from cygthread::cygthread.
(cygthread::cygthread): Define new constructor which accepts
LPVOID_THREAD_START_ROUTINE as the first argument.  Call cygthread::create.
* cygthread.cc (cygthread::create): Rename from cygthread::cygthread.  Use
'arglen' rather than 'n' since 'n' is no longer supplied.
* fhandler_tty.cc (process_input): Define as void/noreturn.
(process_output): Ditto.
(process_ioctl): Ditto.
(fhandler_tty_master::init): Don't "zap_h" cygthreads which are noreturn.  It's
now implied.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2008, 2009
   Red Hat, Inc.
@


1.80
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@d188 2
a189 3
cygthread::cygthread (LPTHREAD_START_ROUTINE start, size_t n, void *param,
		      const char *name, HANDLE notify)
 : __name (name), func (start), arglen (n), arg (param), notify_detached (notify)
d216 1
a216 1
  if (n)
@


1.79
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d44 1
a44 1
	low_priority_sleep (0);
d199 1
a199 1
	low_priority_sleep (0);
d220 1
a220 1
	low_priority_sleep (0);
d259 1
a259 1
    low_priority_sleep (0);
d290 1
a290 1
    low_priority_sleep (0);
@


1.78
log
@Remove unneeded header files from source files throughout.
@
text
@d3 2
a4 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
a13 1
#include "thread.h"
@


1.77
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a10 1
#include <windows.h>
a11 4
#include "exceptions.h"
#include "security.h"
#include "sync.h"
#include "cygerrno.h"
@


1.76
log
@* cygthread.cc (cygthread::terminate_thread): In debugging output, use name of
thread being terminated rather than thread doing terminating.
* fhandler.h (fhandler_pty_master::slave): Delete.
(fhandler_pty_master::get_unit): Ditto.
(fhandler_pty_master::setup): Change argument declaration to accommodate new
usage.
* fhandler_tty.cc (fhandler_tty_master::init): Remove obsolete slave
assignment.  Pass argument to setup indicating that this is a tty.
(fhandler_tty_slave::open): Use dev() method rather than referencing pc.dev
directly.
(fhandler_pty_master::open): Don't create archetype based on ptym device
number.  Set device number to use DEV_TTYM_MAJOR and tty number.  Pass argument
to setup indicating that this is a pty.
(fhandler_pty_master::setup): Change single argument to a flag indicating
whether we're creating a pty and use appropriately.  Calculate 't' variable
here rather than in caller.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Use dev() method rather than
referencing pc.dev directly.
@
text
@d10 1
@


1.75
log
@* cygwin.din: Fix some erroneous SIGFE/NOSIGFE settings.
* cygthread.cc (cygthread::callfunc): Revert below change.  Make ev a manual
reset event again.  so that it will be reset by WaitFor*Object as appropriate.
(cygthread::stub): Ditto.
(cygthread::terminate_thread): Reset ev if it was found to have been set.
@
text
@d292 1
a292 1
  debug_printf ("thread '%s', id %p, inuse %d, stack_ptr %p", name (), id, inuse, stack_ptr);
@


1.74
log
@* cygthread.cc (cygthread::callfunc): Create ev as an auto-reset event so that
it will be reset by WaitFor*Object as appropriate.
(cygthread::stub): Ditto.
(cygthread::terminate_thread): Remove forced setting of thread termination.
@
text
@d39 1
a39 1
	ev = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
d81 1
a81 1
	  info->ev = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
d306 2
a307 2
  if (ev)
    terminated = WaitForSingleObject (ev, 0) != WAIT_OBJECT_0;
d322 6
a327 1
    release (true);
@


1.73
log
@* cygthread.cc (cygthread::release): Add a comment.
@
text
@d39 1
a39 1
	ev = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
d81 1
a81 1
	  info->ev = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
d322 1
a322 6
    {
#ifdef DEBUGGING
      terminated = true;
#endif
      release (true);
    }
@


1.72
log
@Change process_lock to lock_process throughout.  Change all calls to new
cygthread to handle extra argument, throughout.
* cygthread.h (cygthread::callproc): Declare new method.
(cygthread::cygthread): Add optional length argument to allow copying arguments
to executing thread.
* cygthread.cc (cygthread::callproc): Define new method.
(cygthread::stub): Use callfunc to invoke thread func to allow potentially
allocating stack memory which will be returned.
(cygthread::simplestub): Ditto.
(cygthread::cygthread): Accept arglen argument.  Reset ev here prior to
activating thread.  Wait for ev after activating thread if we're copying
contents to the thread.  Wait until the end before setting h, to allow thread
synchronization.
(cygthread::release): Don't reset ev here.  Rely on that happening the next
time the thread is activated.
* pinfo.h (commune_process): Rename declaration from _pinfo::commune_process.
* pinfo.cc (commune_process): Ditto for definition.  Modify slightly to allow
running as a separate cygthread.
* sigproc.cc (child_info::sync): Always wait for both subproc_ready and any
hProcess if we have a cygwin parent.
(talktome): Change argument to be a pointer to siginfo_t.  Contiguously
allocate whole siginfo_t structure + any needed extra for eventual passing to
commune_process thread.
(wait_sig): Accommodate change in talktome argument.
* pipe.cc (fhandler_pipe::fixup_after_exec): Remove debugging.
@
text
@d278 1
@


1.71
log
@* cygthread.cc (cygthread::operator new): Just use getenv() to look for
CYGWIN_FREERANGE_NOCHECK since the Windows environment may be truncated by
being previously execed.
@
text
@d28 30
d102 1
a102 3
	  /* Cygwin threads should not call ExitThread directly */
	  info->func (info->arg == cygself ? info : info->arg);
	  /* ...so the above should always return */
d142 1
a142 5
  /* Wait for main thread to assign 'h' */
  while (!info->h)
    low_priority_sleep (0);
  info->ev = info->h;
  info->func (info->arg == cygself ? info : info->arg);
d192 1
a192 1
cygthread::cygthread (LPTHREAD_START_ROUTINE start, LPVOID param,
d194 1
a194 1
 : __name (name), func (start), arg (param), notify_detached (notify)
d197 1
d200 2
d206 1
d211 3
a213 3
      h = CreateThread (&sec_none_nih, 0, is_freerange ? simplestub : stub,
			this, 0, &id);
      if (!h)
d220 9
a277 2
  if (ev)
    ResetEvent (ev);
@


1.70
log
@* cygthread.cc (cygthread::cygthread): Add more info to fatal error.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Temporarily remove
insertion of /dev into root directory.
* path.cc (path_conv::check): Ditto.
@
text
@d156 2
a157 3
  char buf[1024];
  if (!GetEnvironmentVariable ("CYGWIN_FREERANGE_NOCHECK", buf, sizeof (buf)))
    api_fatal ("Overflowed cygwin thread pool");
d159 1
a159 1
    thread_printf ("Overflowed cygwin thread pool");
@


1.69
log
@* cygthread.cc (cygthread::simplestub): Wait for h to be filled out by main
thread before assigning it.
@
text
@d187 1
a187 1
	api_fatal ("thread handle not set - %p<%p>, %E", h, id);
@


1.68
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d114 3
@


1.67
log
@* cygthread.cc (cygthread::detach): Fix debugging output.
* dcrt0.cc (dll_crt0_1): Create signal_arrived early -- before any filename
manipulation.
* sigproc.cc (sigproc_init): Don't create signal_arrived here.
* fork.cc (fork_child): Ditto.
@
text
@d261 2
a262 2
  (void) TerminateThread (h, 0);
  (void) WaitForSingleObject (h, INFINITE);
d273 1
a273 1
  (void) VirtualQuery (stack_ptr, &m, sizeof m);
d323 1
a323 1
	  (void) ::SetThreadPriority (hth, THREAD_PRIORITY_BELOW_NORMAL);
d366 1
a366 1
	    (void) WaitForSingleObject (*this, INFINITE);
d381 1
a381 1
	  (void) ::SetThreadPriority (hth, prio);
d398 1
a398 1
	  (void) InterlockedExchange (&inuse, 0);
@


1.66
log
@* cygthread.cc (cygthread::detach): Improve diagnostics for what should be an
impossible failure condition.
@
text
@d356 1
a356 1
			  system_printf ("%s handle %p is bad", j ? "semaphore" : "signal_arrived", w4[j]);
@


1.65
log
@* cygthread.cc (cygthread::detach): Make error message a little more detailed.
* fhandler.cc (fhandler_base::raw_read): Ditto for debug message.
* dcrt0.cc (do_exit): Add some more synchronization tests.
* fhandler_fifo.cc (fhandler_fifo::dup): Don't duplicate a nonexistent handle.
Use derived return value rather than always retuning 0.
* fhandler_netdrive.cc (fhandler_netdrive::exists): Wnet -> WNet.
* winsup.h (exit_states): Add a couple of new exit states.
@
text
@d347 14
a360 1
		  api_fatal ("WFMO failed waiting for cygthread '%s', %E", __name);
@


1.64
log
@* cygtls.h (_local_storage::unknown_thread_name): New buffer.
* tlsoffsets.h: Regenerate.
* cygthread.cc (cygthread::name): Use new thread-local buffer.
* exceptions.cc (handle_exceptions): Avoid unnecessary initialization of static
variables to zero.
* fork.cc (slow_pid_reuse) Ditto.
@
text
@d347 1
a347 1
		  api_fatal ("WFMO failed waiting for cygthread '%s'", __name);
@


1.63
log
@* cygthread.cc (cygthread::detach): Revert to just waiting for thred event
since waiting for anything else is racy.
* timer.cc (timer_tracker::hcancel): Rename from cancel.
(timer_tracker::cancel): New method.
(timer_tracker::th): Remove.
(timer_tracker::~timer_tracker): Call cancel method.
(timer_tracker::timer_tracker): Ditto.
(timer_tracker::timer_tracker): Always, clear cancel, even though it is
probably not strictly necessary for ttstart.
(timer_thread): Accommodate cancel -> hcancel rename.
(timer_tracker::settime): Ditto.
(timer_tracker::gettime): Ditto.
(timer_delete): Ditto.
* cygwin.din: Export _ctype_.
* include/ctype.h: Mark that _ctype_ is imported.
@
text
@d213 2
a214 3
      static char buf[30] NO_COPY = {0};
      __small_sprintf (buf, "unknown (%p)", tid);
      res = buf;
@


1.62
log
@* wininfo.h (wininfo::timer_active): Delete.
(wininfo::itv): Ditto.
(wininfo::start_time): Ditto.
(wininfo::window_started): Ditto.
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(wininfo::wininfo): Ditto.
(wininfo::lock): New method.
(wininfo::release): Ditto.
* window.cc: Use new lock/acquire wininfo methods throughout.
(wininfo::wininfo): Delete
(wininfo::getitimer): Ditto.
(wininfo::setitimer): Ditto.
(getitimer): Ditto.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
(wininfo::lock): Define new function.
(wininfo::release): Ditto.
(wininfo::process): Delete WM_TIMER handling.
* timer.cc (struct timetracker): Delete it, flags.  Add it_interval,
interval_us, sleepto_us, running, init_muto(), syncthread, and gettime().
(ttstart): Make NO_COPY.
(lock_timer_tracker): New class.
(timer_tracker::timer_tracker): Distinguish ttstart case.
(timer_tracker::~timer_tracker): New destructor.  Clean out events, and reset
magic.
(timer_tracker::init_muto): New method.
(to_us): Round up as per POSIX.
(timer_thread): Reorganize to match timer_tracker::settime and
timer_tracker::gettime.  Call sig_send without wait.  Call auto_release.
(timer_tracker::settime): Reorganize logic to avoid race.  Call gettime to
recover old value.
(timer_tracker::gettime): New method.
(timer_create): Properly set errno on invalid timerid.  Use new
lock_timer_tracker method.
(timer_delete): Ditto.  Simplify code slightly.
(timer_gettime): New function.
(fixup_timers_after_fork): Reinit ttstart.
(getitimer): New implementation.
(setitimer): Ditto.
(ualarm): Ditto.
(alarm): Ditto.
* cygwin.din: Export timer_gettime.
* winsup.h: Remove has has_visible_window_station declaration.
* Makefile.in (DLL_OFILES): Add lsearch.o.
* cygthread.h (cygthread::notify_detached): New element.
(cygthread::cygthread): Take optional fourth argument signifying event to
signal on thread completion.
* cygthread.cc (cygthread::stub): Signal notify_detached event, if it exists.
(cygthread::cygthread): Initialize notify_detached from fourth argument.
(cygthread::detach): Wait for notify_detached field is present.
* lsearch.cc: New file.
* search.h: Ditto.
* include/cygwin/version.h: Bump API minor number to 126.
* cygwin.din: Export lsearch, lfind.
@
text
@d318 1
a318 1
	res = WaitForSingleObject (notify_detached ?: *this, INFINITE);
@


1.61
log
@* cygthread.cc (cygthread::detach): Use a slightly higher priority when waiting
for thread signalling.
@
text
@d29 1
a29 1
   per-thread initialization and loops waiting for new thread functions
d76 1
d80 1
a80 1
	     that it is doing.  */
d92 2
d167 2
a168 2
		      const char *name): __name (name),
					 func (start), arg (param)
d316 3
a318 1
	res = WaitForSingleObject (*this, INFINITE);
@


1.60
log
@white space
@
text
@d319 1
a319 1
	  (void) ::SetThreadPriority (hth, THREAD_PRIORITY_IDLE);
@


1.59
log
@* cygthread.cc (cygthread::release): Reset ev here if it exists.
(cygthread::terminate_thread): Eliminat racy code which reset ev and
thread_sync.  Remove a few nonsensical inuse checks.  Exit at the bottom.
(cygthread::detach): Rewrite to again try to ensure that we don't say we're
signalled when we are not signalled.
* fhandler.cc (fhandler_base::raw_read): Revert to signalling read success
quickly.
* pipe.cc (fhandler_pipe::close): Use base method to close handle.
* sigproc.h (WAIT_SIG_PRIORITY): Just trundle along at normal priority to allow
the pipe thread to do its thing if possible.
* pinfo.h (pinfo::zap_cwd): Declare new function.
(pinfo::zap_cwd): Move 'cd out of the way code' here.
(pinfo::exit): Use it here.
* spawn.cc (spawn_guts): And here.
@
text
@d258 1
a258 1
    
d288 1
a288 1
  
@


1.58
log
@	* cygthread.cc (cygthread::detach): Just test thread handle after
	signal arrived, don't wait infinitely for it.
@
text
@d237 2
a251 13
  /* FIXME: The if (!inuse) stuff below should be handled better.  The
     problem is that terminate_thread could be called while a thread
     is terminating and either the thread could be handling its own
     release or, if this is being called during exit, some other
     thread may be attempting to free up this resource.  In the former
     case, setting some kind of "I deal with my own exit" type of
     flag may be the way to handle this. */
  if (!is_freerange)
    {
      ResetEvent (*this);
      ResetEvent (thread_sync);
    }

d257 2
a258 2
    return false;

d261 5
a267 7
  if (!inuse || exiting)
    return false;

  CloseHandle (h);

  if (!inuse)
    return false;
a278 2
  if (!inuse)
    /* nothing */;
d288 6
d305 1
a305 1
  bool terminated = false;
d316 5
d322 3
a324 1
	  w4[0] = *this;
d326 22
a347 4
	  res = WaitForSingleObject (sigwait, INFINITE);
	  if (res != WAIT_OBJECT_0)
	    system_printf ("WFSO sigwait %p failed, res %u, %E", sigwait, res);
	  res = WaitForMultipleObjects (2, w4, FALSE, INFINITE);
d349 1
a349 5
	    signalled = false;
	  else if (res != WAIT_OBJECT_0 + 1)
	    api_fatal ("WFMO failed waiting for cygthread '%s'", __name);
	  else if ((res = WaitForSingleObject (*this, 0)) == WAIT_OBJECT_0)
	    signalled = false;
d352 2
a353 1
	      terminated = true;
d355 8
d364 1
a364 5
	  if (WaitForSingleObject (sigwait, 0) == WAIT_OBJECT_0)
	    signalled = false;
	  else if (signalled)
	    set_sig_errno (EINTR);    /* caller should be dealing with return
					 values. */
d370 1
a370 1
      if (terminated)
d392 68
@


1.57
log
@* cygthread.h (cygthread::terminate_thread): Reflect return value.
* cygthread.cc (cygthread::detach): Be more careful about ensuring that sigwait
is properly waited for to avoid later missynchronization.
(cygthread::terminate_thread): Return true if thread was actually terminated
and all handles were closed.
* fhandler_base.cc (fhandler_base::raw_read): Use signal_read_state rather than
raw calls to win32 api.
(fhandler_base::read): Ditto.
* fhandler.h (fhandler_pipe::fixup_after_exec): Use method to create read_state
signalling.
(fhandler_pipe::create): Ditto.
* Makefile.in: Make some more files -fomit-frame-pointer.
@
text
@d336 1
a336 1
	  else if ((res = WaitForSingleObject (*this, INFINITE)) == WAIT_OBJECT_0)
@


1.56
log
@* cygthread.cc (cygthread::terminate_thread): Wait briefly for notification
event in the event that the thread was actually in the process of exiting.
* pipe.cc (fhandler_pipe::dup): read_state is not supposed to be inheritable.
Fix that.
* path.cc (path_conv::check): Set symlen = 0 to avoid a compiler warning.
* devices.h (devices::parsedisk): Declare new function.
* devices.in (devices::parsedisk): Define new function.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
name.
* fhandler_proc.cc (format_proc_partitions): Use parsedisk to generate disk
names from numeric codes.  (This was broken on two of my systems previously and
is still broken now)
@
text
@d246 1
a246 1
void
d249 1
d268 1
a268 1
    return;
d273 1
a273 1
    WaitForSingleObject (ev, 0);
d275 1
a275 1
    return;
d280 1
a280 1
    return;
d303 1
d314 1
d333 6
a338 4
	    /* nothing */;
	  else if (WaitForSingleObject (sigwait, 0) == WAIT_OBJECT_0)
	    res = WaitForSingleObject (*this, INFINITE);
	  else if ((res = WaitForSingleObject (*this, 0)) != WAIT_OBJECT_0)
d340 2
a341 4
	      signalled = true;
	      terminate_thread ();
	      set_sig_errno (EINTR);	/* caller should be dealing with return
					   values. */
d343 5
d353 1
a353 1
      if (signalled)
@


1.55
log
@* cygthread.cc (new): Add a little more debugging.
* thread.cc (pthread_null::exit): Add a _my_tls.remove() for safety.
@
text
@d76 1
a76 1
	  /* If stack_ptr is NULL, the above function has set that to indicate
a177 4
#ifdef DEBUGGING
      if (__oldname)
	system_printf ("__oldname %s, terminated %d", __oldname, terminated);
#endif
d271 2
@


1.54
log
@Update copyrights.
@
text
@d144 1
a144 1
	  api_fatal ("name not NULL? id %p, i %d", info->id, info - threads);
@


1.53
log
@* cygthread.cc (cygthread::stub): Set inuse to false when exiting.
(cygthread::cygthread): Actually pass name as argument to debugging output to
avoid SEGV when strace'ing.
(cygthread::release): Don't set stack_ptr to NULL, since it is only set once on
first entry to a stub not on each stub iteration.
(cygthead::exit_thread): Remove obsolete function.
* cygthread.h (cygthread::exit_thread): Ditto.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.52
log
@* cygthread.cc (cygthread::stub): Add better debug output.
(cygthread::cygthread): Ditto.
(cygthread::terminate_thread): Ditto.  Move inuse test earlier or suffer
infinite loop.
* pinfo.cc (_pinfo::dup_proc_pipe): Close handle if DuplicateHandle fails and
process no longer exists.
* spawn.cc (spawn_guts): Create process in suspended state if OS demands it.
* wincap.cc: Add "start_proc_suspended" throughout.
* wincap.h (wincaps): Ditto.
(wincapc): Ditto.
@
text
@d66 5
a70 2
	  if (!info->func || exiting)
	    return 0;
d173 1
a173 1
      thread_printf ("activated name '%s', thread_sync %p for thread %p", thread_sync, id);
d186 1
a186 1
      thread_printf ("created name '%s', thread %p, id %p", __name, h, id);
a229 10
/* Should only be called when the process is exiting since it
   leaves an open thread slot. */
void
cygthread::exit_thread ()
{
  if (!is_freerange)
    SetEvent (*this);
  ExitThread (0);
}

d237 1
a239 1
  stack_ptr = NULL;
@


1.51
log
@* cygthread.cc (cygthread::cygthread): Guard debugging variable with "ifdef
DEBUGGING".
(cygthread::release): Ditto.
@
text
@d48 1
d170 1
a170 1
      thread_printf ("activated thread_sync %p", thread_sync);
d183 1
a183 1
      thread_printf ("created thread %p", h);
d272 5
d279 1
d282 1
a282 1
  if (!inuse)
a286 3
  while (inuse && !stack_ptr)
    low_priority_sleep (0);

@


1.50
log
@* cygthread.cc (cygthread::stub): Detect if thread function wants to release
itself here, to avoid a race.
(cygthread::release): Clear more stuff.  Add a diagnostic for an internal
error.
* cygthread.h (auto_release): New function.
* pinfo.h (pinfo::remember): Add an argument to denote whether child is
detached.
* fork.cc (fork_parent): Reflect change in arguments to pinfo::remember.
* pinfo.cc (_pinfo::exit): Signal exit more forcibly.
(proc_waiter): Use cygthread::auto_release to signify that cygthread::stub
should release the thread.  This should avoid a race.
(pinfo::alert_parent): Don't signify an error when wr_proc_pipe == NULL.
* sigproc.cc (proc_subproc): Add support for PROC_DETACHED_CHILD.
* sigproc.h: Ditto.
* spawn.cc (spawn_guts): Specify whether child is detached or not when calling
pinfo::remember.
@
text
@d183 1
d185 1
d241 1
d243 1
@


1.49
log
@* cygheap.cc (cygheap_setup_for_child): Add api_fatal to catch failing
MapViewOfFileEx.
* cygthread.cc (cygthread::stub): Previous change to make diagnostic output
more informative was really a bust.  Try again.  Capture previous name in a new
field in cygthread for diagnostic purposes.
(cygthread::cygthread): Ditto.
(cygthread::release): Add an argument to control whether h should be cleared or
not.
(cygthread::terminate_thread): Use 'inuse' for tests rather than 'h'.
(cygthread): Add some diagnostic fields.
(cygthread::release): Add an argument.
* pinfo.cc (proc_waiter): Accommodate change to cygthread::release.
@
text
@d72 8
d81 2
a82 2
	  info->func = NULL;	// catch erroneous activation
	  info->__oldname = info->__name;
d84 3
a86 3
	  info->__name = NULL;
	  if (info->inuse)
	    SetEvent (info->ev);
d242 7
a248 1
  (void) InterlockedExchange (&inuse, 0); /* No longer in use */
@


1.48
log
@* cygthread.cc (cygthread::stub): Make diagnostic output more informative.
@
text
@d57 6
a62 3
      const char *name = info->__name;
      if (!name)
	system_printf ("erroneous thread activation, name is non-NULL '%s'", name);
d74 1
d166 4
d175 1
d227 1
a227 1
cygthread::release ()
d229 3
a231 1
  h = NULL;
d241 1
a241 1
  /* FIXME: The if (!h) stuff below should be handled better.  The
d253 1
a253 1
  if (!h)
d257 1
a257 1
  if (!h)
d262 1
a262 1
  while (h && !stack_ptr)
d265 1
a265 1
  if (!h)
d278 2
d283 6
a288 1
    release ();
@


1.47
log
@* pinfo.cc (proc_waiter): Zero wait_thread in child to avoid races with process
termination.
* cygthread.cc (cygthread::terminate): Clumsily detect when h has gone away and
attempt no further action.
@
text
@d57 3
a59 2
      if (!info->__name)
	system_printf ("erroneous thread activation");
@


1.46
log
@* cygthread.h (cygthread::release): Just declare here.
* cygthread.cc (cygthread::release): Define here.  Use InterlockedExchange to
set inuse or suffer potential races.
(cygthread::terminate): Use release().
@
text
@d229 7
d241 2
d245 3
d250 1
a250 1
  while (!stack_ptr)
d253 3
@


1.45
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d216 9
d254 1
a254 6
    {
      h = NULL;
      __name = NULL;
      stack_ptr = NULL;
      (void) InterlockedExchange (&inuse, 0); /* No longer in use */
    }
@


1.44
log
@* cygthread.cc (cygthread::is): Eliminate.
* cygthread.h (cygthread::is): Eliminate declaratin.
* fhandler_console.cc (fhandler_console::read): Only wait for signal_arrived in
the main thread.
* fhandler_socket.cc: Include new "wininfo.h".
(fhandler_socket::ioctl): Use 'winmsg' rather than 'gethwnd()'.
* sync.cc (muto::grab): Define new function.
(muto::acquire): Use tls pointer rather than tid.
(muto::acquired): Ditto.
(muto::reset): Delete.
(muto::release): Ditto.  Also implement "close on last release".
* sync.h (muto::tid): Delete.
(muto::tls): New field.
(muto::ismine): Delete.
(muto::owner): Delete.
(muto::unstable): Delete.
(muto::reset): Delete.
(muto::upforgrabs): New method.
(muto::grab): Ditto.
(new_muto_name): New define.
* wininfo.h: New file.
(wininfo): New class.
* window.cc: Rework throughout to use winfo class for controlling invisible
window operation.
(gethwnd): Delete definition.
* winsup.h (gethwnd): Delete declaration.
@
text
@a13 1
#include "cygthread.h"
d35 1
d72 2
a73 1
	  SetEvent (info->ev);
d92 1
@


1.44.4.1
log
@experimental branch which removes cygwin's reparenting code, in favor of a pipe.
@
text
@d23 1
a23 1
static cygthread NO_COPY threads[128];
@


1.44.4.2
log
@Use cygthread.  Add release mechanism to cygthread so that it can be
used by threads which detach themselves.
@
text
@d14 1
a35 1
  _my_tls._ctinfo = info;
d72 1
a72 2
	  if (info->inuse)
	    SetEvent (info->ev);
a90 1
  _my_tls._ctinfo = info;
@


1.44.4.3
log
@checkpoint
@
text
@d22 1
a22 1
static cygthread NO_COPY threads[32];
@


1.43
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@a103 12
bool
cygthread::is ()
{
  DWORD tid = GetCurrentThreadId ();

  for (DWORD i = 0; i < NTHREADS; i++)
    if (threads[i].id == tid)
      return 1;

  return 0;
}

@


1.42
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.41
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d23 1
a23 1
static cygthread NO_COPY threads[18];
@


1.40
log
@* cygthread.cc (cygthread::stub): Revert previous change and again subsume
cygthread::stub2.  Just return from function now since ExitThread is guaranteed
by automatic _threadinfo wrapper.  Define as per ThreadProc convention.
(cygthread::stub2): Remove.
(cygthread::simplestub): Perform similar operations to cygthread::stub.
(cygthread::simplestub2): Remove.
* cygthread.h (cygthread::stub): Declare as per ThreadProc convention.
(cygthread::stub2): Remove declaration.
(cygthread::simplestub): Declare as per ThreadProc convention.
(cygthread::simplestub2): Remove declaration.
* cygtls.h (_threadinfo::call): Define first argument as per ThreadProc
convention.
(_threadinfo::call2): Ditto.
(_tlsbase): Define as char * pointer.
(_tlstop): New definition.
(_main_tls): Define here.
* dcrt0.cc (alloc_stack): Revert previous change which called init_thread since
information would be overwritten by fork later anyway.
(dll_crt0_1): Use _tlsbase and _tlstop for setting stack bottom, top.
* exceptions.cc: Move _main_tls declaration to cygtls.h.
(_threadinfo::call): Define first argument as per ThreadProc convention.
(_threadinfo::call2): Call ExitThread with thread function return value.
(_threadinfo::init_thread): Don't initialize cygtls to zero if input arg is
NULL.
* fork.cc (fork_child): Reset _main_tls here.  Reinitialize parts of _my_tls
after copying data from parent.
* init.cc (threadfunc_fe): New function.  Front-end for all threads created in
cygwin processes.
(munge_threadfunc): New function.
(dll_entry): Call munge_threadfunc to force the call of a thread wrapper.
* thread.cc (pthread::thread_init_wrapper): Perform similar operations to
cygthread::stub.
(pthread::thread_init_wrapper2): Remove.
* thread.h (pthread::thread_init_wrapper): Declare as per ThreadProc
convention.
(pthread::thread_init_wrapper2): Remove declaration.
* window.cc (Winmain): Just return from function now since ExitThread is
guaranteed by automatic _threadinfo wrapper.
@
text
@a34 6
  exception_list except_entry;
  /* Initialize this thread's ability to respond to things like
     SIGSEGV or SIGFPE. */
  init_exceptions (&except_entry);
  _my_tls.remove ();	// Remove me from signal chain -- not signalable.

d43 1
a43 1
    info->ev = info->thread_sync = info->stack_ptr = NULL;
d54 1
a89 6
  exception_list except_entry;
  /* Initialize this thread's ability to respond to things like
     SIGSEGV or SIGFPE. */
  init_exceptions (&except_entry);
  _my_tls.remove ();	// Remove me from signal chain -- not signalable.

@


1.40.2.1
log
@* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d35 6
d95 6
@


1.40.2.2
log
@* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
@
text
@d43 1
a43 1
      info->ev = info->thread_sync = info->stack_ptr = NULL;
a53 1

@


1.40.2.3
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
@
text
@d23 1
a23 1
static cygthread NO_COPY threads[32];
@


1.39
log
@* cygthread.cc (cygthread::stub2): Remove myself from the list of threads
monitored by signals since this thread will never call raise or sigwait.
(cygthread::simplestub2): Ditto.  Set ev here.
(cygthread::cygthread): Don't set ev here for freerange thread.
@
text
@a34 7
  _threadinfo::call (stub2, arg);
  return 0;
}

void
cygthread::stub2 (void *arg, void *)
{
d67 1
a67 1
	    ExitThread (0);
a94 7
  _threadinfo::call (simplestub2, arg);
  return 0;
}

void
cygthread::simplestub2 (void *arg, void *)
{
d105 1
a105 1
  ExitThread (0);
@


1.38
log
@* cygthread.cc (cygthread::stub): Properly establish _threadinfo environment.
(cygthread::stub2): New function.
(cygthread::simplestub): Ditto.
(cygthread::simplestub2): New function.
* cygthread.h (cygthread::stub2): Declare new function.
(cygthread::simplestub2): Ditto.
* cygtls.h (_threadinfo::call): Declare new function.
(_threadinfo::call2): Ditto.
* dcrt0.cc (dll_crt0_1): Accommodate new _threadinfo::init which doesn't return
pointer to tls.
(_dll_crt0): Remove obsolete DECLARE_TLS_STORAGE.
(dll_crt0): Ditto.
* exceptions.cc (_threadinfo::call): New function.
(_threadinfo::call2): Ditto.
(_threadinfo::init): Don't return pointer.
* thread.cc (pthread::thread_init_wrapper): Properly establish _threadinfo
environment.
(pthread::thread_init_wrapper2): New function.
* thread.h (pthread::thread_init_wrapper): Remove noreturn attribute
(pthread::thread_init_wrapper2): Declare new function.
* winbase.h: Remove obsolete code.
@
text
@a42 1

d46 1
a46 1

a109 1

d113 1
d117 1
a199 2
      if (is_freerange)
	ev = h;
@


1.37
log
@* cygthread.cc (cygthread::freerange): Set inuse count.  Avoid setting ev from
h as h would be NULL at this point.
(cygthread::operator new): Issue debugging info when overflowing the thread
pool.
(cygthread::cygthread): Set ev from h here after h has been initialized.
@
text
@d18 2
d35 7
a41 1
  DECLARE_TLS_STORAGE;
d48 1
d103 7
a109 1
  DECLARE_TLS_STORAGE;
@


1.36
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d131 1
a131 1
  self->ev = self->h;
d156 2
d185 2
@


1.35
log
@* cygthread.cc (cygthread::terminate_thread): Change system_printf to
debug_printf.
@
text
@a11 1
#include <errno.h>
@


1.34
log
@* cygthread.h (cygthread::terminate_thread): Mark private.
* cygthread.cc (cygthread::terminate_thread): Deallocate free_range thread
stuff.
@
text
@d258 1
a258 1
    system_printf ("VirtualFree of allocation base %p<%p> failed, %E",
@


1.33
log
@* cygthread.cc (cygthread::detach): Prioritize waiting for I/O completion over
waiting for signal delivery.
@
text
@d261 9
a269 4
  h = NULL;
  __name = NULL;
  stack_ptr = NULL;
  (void) InterlockedExchange (&inuse, 0); /* No longer in use */
@


1.32
log
@* cygthread.cc (cygthread::stub): Initialize stack pointer earlier.
(cygthread::simplestub): Initialize stack pointer.
(cygthread::terminate_thread): Account for possibility that stack pointer has
not been set.  Issue warnings for unusual conditions.
@
text
@d286 2
a287 2
	  w4[0] = signal_arrived;
	  w4[1] = *this;
d292 1
a292 1
	  if (res != WAIT_OBJECT_0)
d294 1
a294 1
	  else if (WaitForSingleObject (sigwait, 5) == WAIT_OBJECT_0)
d296 1
a296 1
	  else
@


1.31
log
@* cygthread.h: Change 'avail' cygthread element to 'inuse' throughout.
* cygthread.cc: Ditto.
(cygthread::stub): Don't initialize already initialized events.
(cygthread::freerange): Don't create thread here.
(cygthread::cygthread): Create thread here.  Die if thread not created.
(cygthread::operator new): Simplify.  Just grab a thread structure from the
pool.  Don't try to start the thread.
(cygthread::terminate_thread): Don't close event handles.  Just reuse them.
Call MEM_RELEASE rather than MEM_DECOMMIT (from Joe Buehler).
@
text
@d53 1
a58 1
      info->stack_ptr = &arg;
d103 1
d179 1
d248 2
d255 5
a259 2
  if (m.RegionSize)
    (void) VirtualFree (m.AllocationBase, 0, MEM_RELEASE);
@


1.30
log
@* cygthread.h (cygthread::avail): Make LONG for easier use with Interlocked*
functions.
* cygthread.cc (cygthread::init): Eliminate unneeded muto.
(cygthread::operator new): Don't lock.  Instead change use of avail variable
into tri-state: available (1), not available (-1), uninitialized (0).
(cygthread::terminate_thread): Set avail to uninitialized.
(cygthread::detach): Eliminate local 'avail'.  Always set avail to 1 unless
signalled.
* cygthread.cc (cygthread::operator new): Be more defensive when messing with
@
text
@d43 6
d50 1
d53 5
a57 2
      info->ev = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
      info->thread_sync = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
a130 2
  self->h = CreateThread (&sec_none_nih, 0, cygthread::simplestub, self,
			  CREATE_SUSPENDED, &self->id);
a137 1
  LONG is_avail;
d142 1
a142 3
    if ((is_avail = InterlockedExchange (&info->avail, -1)) < 0)
      /* in use */;
    else if (is_avail > 0)
a147 2
	if (!info->h)
	  api_fatal ("h not set? id %p, i %d", info->id, info - threads);
a150 7
    else
      {
	/* Uninitialized.  Available as soon as thread is created */
	info->h = CreateThread (&sec_none_nih, 0, cygthread::stub, info,
				CREATE_SUSPENDED, &info->id);
	goto out;
      }
d165 2
a166 1
		      const char *name): func (start), arg (param)
a167 4
#ifdef DEBUGGGING
  if (!__name)
    api_fatal ("name should never be NULL");
#endif
d169 1
a169 4
  while (!h)
#ifndef DEBUGGING
    low_priority_sleep (0);
#else
d171 4
a174 2
      system_printf ("waiting for %s<%p> to become active", __name, h);
      low_priority_sleep (0);
a175 4
#endif
  __name = name;
  if (!thread_sync)
    ResumeThread (h);
d177 7
a183 1
    SetEvent (thread_sync);
d238 4
a241 1
    SetEvent (*this);
d244 2
d252 1
a252 1
    (void) VirtualFree (m.AllocationBase, m.RegionSize, MEM_DECOMMIT);
d254 1
a254 9
  if (is_freerange)
    is_freerange = false;
  else
    {
      CloseHandle (ev);
      CloseHandle (thread_sync);
    }
  CloseHandle (h);
  thread_sync = ev = h = NULL;
d256 2
a257 2
  id = 0;
  (void) InterlockedExchange (&avail, 0); /* No longer initialized */
d268 2
a269 2
  if (avail >= 0)
    system_printf ("called detach but avail %d, thread %d?", avail, id);
d311 2
a312 2
	  /* Mark the thread as available by setting avail to positive value */
	  (void) InterlockedExchange (&avail, 1);
@


1.29
log
@add comments
@
text
@a96 1
static NO_COPY muto *cygthread_protect;
a100 1
  new_muto (cygthread_protect);
d130 1
a130 1
  DWORD id;
a132 2
  cygthread_protect->acquire ();

d135 3
a137 3
    if ((LONG) (id = (DWORD) InterlockedExchange ((LPLONG) &info->avail, -1)) < 0)
      /* being considered */;
    else if (id > 0)
d139 1
d142 1
a142 1
	  api_fatal ("name not NULL? id %p, i %d", id, info - threads);
d144 1
a144 1
	  api_fatal ("h not set? id %p, i %d", id, info - threads);
a147 2
    else if (info->id)
      InterlockedExchange ((LPLONG) &info->avail, 0);	/* Not available yet */
d150 1
a150 1
	/* Available as soon as thread is created */
d158 1
a158 1
  if (!GetEnvironmentVariable ("CYGWIN_NOFREERANGE_NOCHECK", buf, sizeof (buf)))
a164 2
  InterlockedExchange ((LPLONG) &info->avail, 0);
  cygthread_protect->release ();
d266 1
d271 2
a272 2
   So, there should be no problems with multiple threads doing waits
   on the one cygthread. */
d277 2
a278 2
  if (avail)
    system_printf ("called detach on available thread %d?", avail);
a280 1
      DWORD avail = id;
d300 1
a303 2
	      avail = 0;
	      signalled = true;
d310 1
a310 1
      if (!avail)
d320 2
a321 2
	  /* Mark the thread as available by setting avail to non-zero */
	  (void) InterlockedExchange ((LPLONG) &this->avail, avail);
@


1.28
log
@* cygthread.cc (operator new): Be more defensive when messing with threads that
are marked "unavailable".
@
text
@d152 1
a152 1
      InterlockedExchange ((LPLONG) &info->avail, 0);
d155 1
@


1.27
log
@* external.cc (check_ntsec): New function.
(cygwin_internal): Add CW_CHECK_NTSEC handling to call check_ntsec() from
applications.
* include/cygwin/version.h: Bump API minor number.
* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_CHECK_NTSEC.
* cygthread.cc (cygthread::new): Add more defensive debugging.
@
text
@d139 3
a141 1
    if ((id = (DWORD) InterlockedExchange ((LPLONG) &info->avail, 0)))
d151 3
a153 1
    else if (!info->id)
d169 1
@


1.26
log
@* cygthread::detach: Improve error message.
@
text
@d144 2
@


1.25
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d291 1
a291 1
	    system_printf ("WFSO sigwait failed, res %u", res);
@


1.25.2.1
log
@merge from trunk
@
text
@d279 1
a279 1
      DWORD newavail = id;
d302 1
a302 1
	      newavail = 0;
d310 1
a310 1
      if (!newavail)
d321 1
a321 1
	  (void) InterlockedExchange ((LPLONG) &avail, newavail);
@


1.25.2.2
log
@merge from trunk
@
text
@d291 1
a291 1
	    system_printf ("WFSO sigwait %p failed, res %u, %E", sigwait, res);
@


1.25.2.3
log
@merge from trunk
@
text
@a143 2
	if (!info->h)
	  api_fatal ("h not set? id %p, i %d", id, info - threads);
@


1.25.2.4
log
@merge from trunk
@
text
@d139 1
a139 3
    if ((LONG) (id = (DWORD) InterlockedExchange ((LPLONG) &info->avail, -1)) < 0)
      /* being considered */;
    else if (id > 0)
d149 1
a149 3
    else if (info->id)
      InterlockedExchange ((LPLONG) &info->avail, 0);
    else
a164 1
  InterlockedExchange ((LPLONG) &info->avail, 0);
@


1.25.2.5
log
@merge from trunk
@
text
@d97 1
d102 1
d132 1
a132 1
  LONG is_avail;
d135 2
d139 3
a141 3
    if ((is_avail = InterlockedExchange (&info->avail, -1)) < 0)
      /* in use */;
    else if (is_avail > 0)
a142 1
	/* available */
d145 1
a145 1
	  api_fatal ("name not NULL? id %p, i %d", info->id, info - threads);
d147 1
a147 1
	  api_fatal ("h not set? id %p, i %d", info->id, info - threads);
d151 2
a154 1
	/* Uninitialized.  Available as soon as thread is created */
d162 1
a162 1
  if (!GetEnvironmentVariable ("CYGWIN_FREERANGE_NOCHECK", buf, sizeof (buf)))
d169 2
a271 1
  (void) InterlockedExchange (&avail, 0); /* No longer initialized */
d276 2
a277 2
   So, there should be never be multiple threads doing waits
   on the same cygthread. */
d282 2
a283 2
  if (avail >= 0)
    system_printf ("called detach but avail %d, thread %d?", avail, id);
d286 1
a305 1
	      signalled = true;
d309 2
d317 1
a317 1
      if (signalled)
d327 2
a328 2
	  /* Mark the thread as available by setting avail to positive value */
	  (void) InterlockedExchange (&avail, 1);
@


1.25.2.6
log
@merge from trunk
@
text
@a42 6
    {
      if (info->ev)
	{
	  CloseHandle (info->ev);
	  CloseHandle (info->thread_sync);
	}
a43 1
    }
d46 2
a48 5
      if (!info->ev)
	{
	  info->ev = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
	  info->thread_sync = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
	}
a92 1
  info->stack_ptr = &arg;
d121 2
d130 1
d135 3
a137 1
    if (!InterlockedExchange (&info->inuse, 1))
d143 2
d148 7
d169 1
a169 2
		      const char *name): __name (name),
					 func (start), arg (param)
d171 4
d176 4
a179 1
  if (h)
d181 2
a182 4
      while (!thread_sync)
	low_priority_sleep (0);
      SetEvent (thread_sync);
      thread_printf ("activated thread_sync %p", thread_sync);
d184 4
d189 1
a189 8
    {
      stack_ptr = NULL;
      h = CreateThread (&sec_none_nih, 0, is_freerange ? simplestub : stub,
			this, 0, &id);
      if (!h)
	api_fatal ("thread handle not set - %p<%p>, %E", h, id);
      thread_printf ("created thread %p", h);
    }
d244 1
a244 4
    {
      ResetEvent (*this);
      ResetEvent (thread_sync);
    }
a246 4
  CloseHandle (h);

  while (!stack_ptr)
    low_priority_sleep (0);
d252 2
a253 5
  if (!m.RegionSize)
    system_printf ("m.RegionSize 0?  stack_ptr %p", stack_ptr);
  else if (!VirtualFree (m.AllocationBase, 0, MEM_RELEASE))
    system_printf ("VirtualFree of allocation base %p<%p> failed, %E",
		   stack_ptr, m.AllocationBase);
d255 9
a263 1
  h = NULL;
d265 2
a266 2
  stack_ptr = NULL;
  (void) InterlockedExchange (&inuse, 0); /* No longer in use */
d277 2
a278 2
  if (!inuse)
    system_printf ("called detach but inuse %d, thread %p?", inuse, id);
d288 2
a289 2
	  w4[0] = *this;
	  w4[1] = signal_arrived;
d294 1
a294 1
	  if (res == WAIT_OBJECT_0)
d296 1
a296 1
	  else if (WaitForSingleObject (sigwait, 0) == WAIT_OBJECT_0)
d298 1
a298 1
	  else if ((res = WaitForSingleObject (*this, 0)) != WAIT_OBJECT_0)
d320 2
a321 2
	  /* Mark the thread as available by setting inuse to zero */
	  (void) InterlockedExchange (&inuse, 0);
@


1.25.2.7
log
@merge from trunk
@
text
@d258 1
a258 1
    debug_printf ("VirtualFree of allocation base %p<%p> failed, %E",
d261 4
a264 9
  if (is_freerange)
    free (this);
  else
    {
      h = NULL;
      __name = NULL;
      stack_ptr = NULL;
      (void) InterlockedExchange (&inuse, 0); /* No longer in use */
    }
@


1.25.2.8
log
@merge from trunk
@
text
@d12 1
@


1.24
log
@* cygthread.cc (cygthread::cygthread): Be more noisy about odd condition.
* miscfuncs.cc (low_priority_sleep): Sleep in regular priority if that's what
we're currently running at.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.23
log
@* cygthread.cc (cygthread::detach): Set errno with set_sig_errno so that EINTR
is properly restored after signal.
@
text
@d180 1
a180 1
      thread_printf ("waiting for %s<%p> to become active", __name, h);
@


1.22
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d300 1
a300 1
	      set_errno (EINTR);	/* caller should be dealing with return
@


1.21
log
@* cygthread.h (cygthread::stack_ptr): New element.
(cygthread::detach): Accept a "wait_for_signal" argument.
(cygthread::terminate_thread): New function.
* cygthread.cc (cygthread::stub): Set stack pointer argument.
(cygthread::terminate_thread): New function.  Forcibly terminate thread.
(cygthread::detach): Optionally wait for signals and kill thread when signal
arrives.
* exceptions.cc (signal_exit): Set signal_arrived prior to exiting to wake up
anything blocking on signals.
* fhandler.h (fhandler_base::set_r_no_interrupt): Change to accept bool
argument.
(fhandler_pipe::ready_for_read): Declare.
* pipe.cc (pipeargs): New structure.
(read_pipe): New thread stub wrapper for normal pipe read.
(fhandler_pipe::read): Modify to call reader in a cygthread, terminating on
signal, as appropriate.
* select.cc (fhandler_pipe::ready_for_read): Define new function.
@
text
@d271 2
a272 2
void
cygthread::detach (bool wait_for_sig)
d274 1
d282 1
a282 1
      if (!wait_for_sig)
d289 3
d293 5
a297 1
	  if (res == WAIT_OBJECT_0)
d303 1
d307 1
a307 1
      thread_printf ("%s returns %d, id %p", wait_for_sig ? "WFMO" : "WFSO",
d324 1
@


1.20
log
@* miscfuncs.cc (low_priority_sleep): New function.  Use throughout where code
is supposed to be giving up time slice.
* fhandler_console.cc (fhandler_console::read): Switch button 2/3 output escape
sequences to be consistent with xterm.
@
text
@d12 1
d17 2
d22 1
a22 1
static cygthread NO_COPY threads[9];
d43 1
a43 1
    info->ev = info->thread_sync = NULL;
d48 1
d238 29
d272 1
a272 1
cygthread::detach ()
d279 21
a299 2
      DWORD res = WaitForSingleObject (*this, INFINITE);
      thread_printf ("WFSO returns %d, id %p", res, id);
d301 3
a303 1
      if (is_freerange)
@


1.19
log
@* cygthread.cc (cygthread::exiting): New variable.
(cygthread::initialized): Delete.
(cygthread::stub): Use exiting variable to determine when to exit.
(cygthread::runner): Delete.
(cygthread_protect): New variable.
(cygthread::init): Don't start runner thread.  Initialize muto for list
protection.
(cygthread::freerange): Return pointer to cygthread.
(cygthread::operator new): Change logic to start threads on an as-needed basis.
(cygthread::detach): Don't zero id.
(cygthread::terminate): Don't kill any executing threads.  Just set exiting
flag.
* cygthread.h (cygthread): Reflect above changes.
* dcrt0.cc (dll_crt0_1): Move cygthread initialization later.
* fork.cc (fork_child): Do fdtab fixup after dll fixup or (apparently) winsock
may allocate memory in dll load address.
@
text
@d173 1
a173 1
    Sleep (0);
d177 1
a177 1
      Sleep (0);
d220 1
a220 1
    Sleep (0);
@


1.18
log
@Change _function() to function() throughout.
* cygwin.din: Remove last vestiges (?) of newlib wrappers.
* cygthread.cc (cygthread::detach): Always wait for event or suffer an
apparently inavoidable race.
* dcrt0.cc (dll_crt0_1): Allocate threads after stack has been relocated.
* debub.cc (lock_debug): Don't acquire lock on exit.
* fork.cc (fork_child): Recreate mmaps before doing anything else since Windows
has a habit of using blocks of memory in the child that could previously have
been occupied by shared memory in the parent.
* mmap.cc (fhandler_disk_file::fixup_mmap_after_fork): Issue error here and
provide some details about what went wrong.
(fixup_mmaps_after_fork): Remove error message.
* shared.cc (open_shared): Move warning message so that more detail is
possible.
* sigproc.cc (sigproc_init): Initialize sync_proc_subproc to avoid a race.
(sigproc_terminate): Specifically wait for process thread to terminate.
@
text
@d15 1
d23 1
a23 1
int NO_COPY cygthread::initialized;
d52 1
a52 1
	  if (!info->func || initialized < 0)
d93 1
a93 19
/* This function runs in a secondary thread and starts up a bunch of
   other suspended threads for use in the cygthread pool. */
DWORD WINAPI
cygthread::runner (VOID *arg)
{
  for (unsigned i = 0; i < NTHREADS; i++)
    if (!initialized)
      threads[i].h = CreateThread (&sec_none_nih, 0, cygthread::stub,
				   &threads[i], CREATE_SUSPENDED,
				   &threads[i].avail);
    else
      ExitThread (0);

  initialized ^= 1;
  ExitThread (0);
}

HANDLE NO_COPY runner_handle;
DWORD NO_COPY runner_tid;
d98 1
a98 4
  runner_handle = CreateThread (&sec_none_nih, 0, cygthread::runner, NULL, 0,
				&runner_tid);
  if (!runner_handle)
    api_fatal ("can't start thread_runner, %E");
d114 1
a114 1
void *
d131 6
a136 11
  for (;;)
    {
      int was_initialized = initialized;
      if (was_initialized < 0)
	ExitThread (0);

      /* Search the threads array for an empty slot to use */
      for (info = threads + NTHREADS - 1; info >= threads; info--)
	if ((id = (DWORD) InterlockedExchange ((LPLONG) &info->avail, 0)))
	  {
	    info->id = id;
d138 2
a139 2
	    if (info->__name)
	      api_fatal ("name not NULL? id %p, i %d", id, info - threads);
d141 8
a148 2
	    return info;
	  }
a149 7
      if (was_initialized < 0)
	ExitThread (0);

      if (!was_initialized)
	Sleep (0); /* thread_runner is not finished yet. */
      else
	{
d151 3
a153 3
	  char buf[1024];
	  if (!GetEnvironmentVariable ("CYGWIN_NOFREERANGE_NOCHECK", buf, sizeof (buf)))
	    api_fatal ("Overflowed cygwin thread pool");
d155 6
a160 3
	  return freerange ();
	}
    }
d180 1
a180 3
  __name = name;	/* Need to set after thread has woken up to
			   ensure that it won't be cleared by exiting
			   thread. */
a255 1
	  id = 0;
d266 1
a266 33
  /* Wow.  All of this seems to be necessary or (on Windows 9x at least) the
     process will sometimes deadlock if there are suspended threads.  I assume
     that something funky is happening like a suspended thread being created
     while the process is exiting or something.  In particular, it seems like
     the WaitForSingleObjects are necessary since it appears that the
     TerminateThread call may happen asynchronously, i.e., when TerminateThread
     returns, the thread may not yet have terminated. */
  if (runner_handle && initialized >= 0)
    {
      /* Don't care about detaching (or attaching) threads now */
      if (cygwin_hmodule && !DisableThreadLibraryCalls (cygwin_hmodule))
	system_printf ("DisableThreadLibraryCalls (%p) failed, %E",
		       cygwin_hmodule);
      initialized = -1;
      (void) TerminateThread (runner_handle, 0);
      (void) WaitForSingleObject (runner_handle, INFINITE);
      (void) CloseHandle (runner_handle);
      HANDLE hthreads[NTHREADS];
      int n = 0;
      for (unsigned i = 0; i < NTHREADS; i++)
	if (threads[i].h)
	  {
	    hthreads[n] = threads[i].h;
	    threads[i].h = NULL;
	    TerminateThread (hthreads[n++], 0);
	  }
      if (n)
	{
	  (void) WaitForMultipleObjects (n, hthreads, TRUE, INFINITE);
	  while (--n >= 0)
	    CloseHandle (hthreads[n]);
	}
    }
@


1.17
log
@* cygthread.cc (cygthread::stub): Fix typo.
(cygthread::terminate): Don't zero thread handle prior to using it.
@
text
@a66 1
	  // ResetEvent (info->thread_sync);
d206 3
a208 1
  if (thread_sync)
a209 2
  else
    ResumeThread (h);
d271 3
a273 9
      /* Checking for __name here is just a minor optimization to avoid
	 an OS call. */
      if (!__name)
	thread_printf ("thread id %p returned.  No need to wait.", id);
      else
	{
	  DWORD res = WaitForSingleObject (*this, INFINITE);
	  thread_printf ("WFSO returns %d, id %p", res, id);
	}
d281 1
a282 2
	  id = 0;
	  __name = NULL;
@


1.16
log
@* cygthread.cc: Bump number of cygthreads up to accommodate applications which
use ttys.
@
text
@d48 1
a48 1
	system_printf ("errnoneous thread activation");
d322 3
a324 2
	    hthreads[n++] = threads[i].h;
	    TerminateThread (threads[i].h, 0);
@


1.15
log
@* cygthread.cc (cygthread::stub): Reintroduce clearing of __name but do it
before SetEvent to eliminate a race.
(cygthread::terminate): Accumulate list of threads to check for termination and
call WaitForMultipleObjects on list rather than waiting for each thread
individually.
* sigproc.cc (subproc_init): Zap hwait_subproc thread handle since it is no
longer used.
* spawn.cc (spawn_guts): Fix so that cygthread::terminate is *really* called
only for exec.
@
text
@d18 1
a18 1
static cygthread NO_COPY threads[6];
@


1.14
log
@* cygthread.cc (cygthread::stub): Don't zero __name here.  That introduces a
race.
@
text
@d61 1
d317 2
d322 1
a323 5
	    (void) WaitForSingleObject (threads[i].h, INFINITE);
	    (void) CloseHandle (threads[i].h);
#ifdef DEBUGGING
	    threads[i].h = NULL;
#endif
d325 6
@


1.13
log
@* cygthread.cc (cygthread::stub): Don't create event for long-running threads.
Initialize thread_sync event here which is used to Suspend using an event
rather than relying on SuspendThread/ResumeThread.
(cygthread::init): Save handle to runner thread for future termination.
(cygthread::cygthread): Only resume thread when it is actually suspended.
Otherwise signal thread completion event.
(cygthread::terminate): Forcibly terminate runner thread and any helper
threads.  Call DisableThreadLibrary calls if execing.
* cygthread.h (cygthread::thread_sync): Declare.
* dcrt0.cc (do_exit): Eliminate calls to obsolete window_terminate and
shared_terminate.
* exceptions.cc (events_terminate): Don't bother closing title_mutex since it
is going away anyway.
* pinfo.cc (_pinfo::exit): Call cygthread::terminate to ensure that threads are
shut down before process exit or otherwise strange races seem to occur.
* shared.cc (shared_terminate): Eliminate.
* shared.h (shared_terminate): Eliminate declaration.
* winsup.h (window_terminate): Eliminate declaration.
* spawn.cc (spawn_guts): Call cygthread::terminate early in process if execing.
Call DisableThreadLibrary calls if execing.
* window.cc (Winmain): Call ExitThread to force exit.
(window_terminate): Eliminate.
* dcrt0.cc (do_exit): Track exit state more closely.
@
text
@d47 6
a52 2
      if (!info->func || initialized < 0)
	ExitThread (0);
d54 3
a56 3
      /* Cygwin threads should not call ExitThread directly */
      info->func (info->arg == cygself ? info : info->arg);
      /* ...so the above should always return */
d59 1
a59 1
      info->func = NULL;	// catch erroneous activation
d61 2
a62 2
      SetEvent (info->ev);
      info->__name = NULL;
d66 1
@


1.13.4.1
log
@* spawn.cc (spawn_guts): Fix so that cygthread::terminate is *really* called
only for exec.
* cygthread.cc (cygthread::stub): Don't zero __name here.  That introduces a
race.
@
text
@d47 2
a48 6
      if (!info->__name)
	system_printf ("errnoneous thread activation");
      else
	{
	  if (!info->func || initialized < 0)
	    ExitThread (0);
d50 3
a52 3
	  /* Cygwin threads should not call ExitThread directly */
	  info->func (info->arg == cygself ? info : info->arg);
	  /* ...so the above should always return */
d55 1
a55 1
	  info->func = NULL;	// catch erroneous activation
d57 2
a58 2
	  SetEvent (info->ev);
	}
a61 1
	  // ResetEvent (info->thread_sync);
@


1.12
log
@* cygthread.cc (cygthread::stub): Don't create an event for "cygself" threads.
Assume that they exit via an ExitThread call.
* cygthread.h (cygthread::SetThreadPriority): New function.
(cygthread::zap_h): New function.
* dcrt0.cc (do_exit): Move cygthread::terminate earlier and establish
exit_state guard.
* fhandler.h (fhandler_tty_master::output_thread): Delete.
* fhandler_tty.cc (fhandler_tty_master::init): Set priority for threads via
method.  Zap handles when done.  Don't treat process_output specially.
(process_output): Call ExitThread directly.
(fhandler_tty_master::fixup_after_fork): Don't worry about output_thread.
(fhandler_tty_master::fixup_after_exec): Ditto.
* sigproc.cc (proc_terminate): Don't detach from hwait_subproc.  Just let it
exit.
(sigproc_init): Close thread handle after initialization.
(wait_sig): Use GetCurrentThread() as SetThreadPriority call rather than
*event* handle.  Call ExitThread directly on termination.
(wait_subproc): Call ExitThread directly on termination.
* tty.cc (tty_list::terminate): Don't attempt t detach from output_thread.
@
text
@a27 18
cygthread::simplestub (VOID *arg)
{
  DECLARE_TLS_STORAGE;
  exception_list except_entry;

  /* Initialize this thread's ability to respond to things like
     SIGSEGV or SIGFPE. */
  init_exceptions (&except_entry);

  cygthread *info = (cygthread *) arg;
  info->func (info->arg == cygself ? info : info->arg);
  ExitThread (0);
}

/* Initial stub called by cygthread constructor. Performs initial
   per-thread initialization and loops waiting for new thread functions
   to execute.  */
DWORD WINAPI
d39 1
a39 1
    info->ev = NULL;
d41 4
a44 1
    info->ev = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
d47 1
a47 1
      if (!info->func)
d59 8
a66 4
      if (initialized >= 0)
	SuspendThread (info->h);
      else
	ExitThread (0);
d70 17
d104 2
d110 3
a112 3
  DWORD tid;
  HANDLE h = CreateThread (&sec_none_nih, 0, cygthread::runner, NULL, 0, &tid);
  if (!h)
a113 1
  CloseHandle (h);
d189 1
a189 1
  while (!h || ResumeThread (h) != 1)
d201 4
d255 1
a255 1
   theory is that cygthread's are only associated with one thread.
d294 28
a321 5
  initialized = -1;
  /* Signal the event for all running threads */
  for (cygthread *info = threads + NTHREADS - 1; info >= threads; info--)
    if (!InterlockedExchange ((LPLONG) &info->avail, 0) && info->ev)
      SetEvent (info->ev);
@


1.11
log
@* cygheap.cc (dup_now): Make fatal error a little more informative.
(cygheap_setup_for_child): Detect when default size of shared region is less
than the current size and allocate that much.
(_cbrk): Just return NULL on inability to allocate.
(_cmalloc): Ditto.
* cygheap.h (CYGHEAPSIZE): Change size to reflect newer, tinier fhandler sizes.
* spawn.cc (av::error): New element, reflects potential errno from cmalloc.
(av::~av): Don't free NULL pointers.
(av::replace0_maybe): Detect out-of-memory conditions.
(av::dup_maybe): Ditto.
(av::dup_all): Ditto.
(av::unshift): Ditto.
(spawn_guts): Set errno and return if argv creation ran into problems.
* fhandler.h (fhandler_union): Change member names to something safer.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Always set
fhandler_console::dev_state regardless of whether shared region is initialized.
* cygthread.cc (cygthread::runner): Use ExitThread rather than return
(planning for future).
@
text
@d56 4
a59 1
  info->ev = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
@


1.10
log
@* cygthread.cc (cygthread::stub): Very minor cleanup.
(cygthread::stub): Report overflows in cygwin thread pool when DEBUGGING is on
and special environment variable is not set.
(cygthread::terminate): Set event only when event actually exists.
* exceptions.cc (signal_exit): Set priority of main thread to low before
setting current thread to high.
@
text
@d89 1
a89 1
      return 0;
d92 1
a92 1
  return 0;
@


1.9
log
@* cygthread.h (cygthread::terminate): Declare new function.
(cygthread::initialized): Change to 'int'.
* cygthread.cc (cygthread::stub): Exit thread if initialized < 0.
(cygthread::new): Ditto.
(cygthread::runner): Ditto.  Set initialized using xor to preserve sign.
(cygthread::terminate): New function.
* dcrt0.cc (do_exit): Call cygthread::terminate.
@
text
@d71 3
a73 1
      if (initialized < 0)
a74 2
      else
	SuspendThread (info->h);
d163 1
a163 1
	  if (GetEnvironmentVariable ("CYGWIN_NOFREERANGE", buf, sizeof (buf)))
d281 1
d283 1
a283 1
    if (!(DWORD) InterlockedExchange ((LPLONG) &info->avail, 0) && info->id)
@


1.8
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d22 1
a22 1
bool NO_COPY cygthread::initialized;
d71 4
a74 1
      SuspendThread (info->h);
d84 8
a91 3
    threads[i].h = CreateThread (&sec_none_nih, 0, cygthread::stub, &threads[i],
				 CREATE_SUSPENDED, &threads[i].avail);
  cygthread::initialized = true;
d138 4
a141 1
      bool was_initialized = initialized;
d154 3
d275 9
@


1.7
log
@* cygthread.cc (hthreads): Remove unneeded global.
(cygthread::simplestub): New static member function.
(cygthread::runner): Don't set hthreads.
(cygthread::freerange): New member function.
(cygthread::operator new): Call freerange if all cygwin slots are used up.
(cygthread::exit_thread): Don't mess with event if freerange thread.
(cygthread::detach): Ditto.
* cygthread.h (class cygthread): Declare new member functions and variables.
@
text
@d22 1
a22 1
bool cygthread::initialized;
d130 1
d132 1
a132 1
      for (info = threads; info < threads + NTHREADS; info++)
d143 2
a144 2
      if (!initialized)
	Sleep (0); /* thread_runner is not be finished yet. */
d146 8
a153 1
	return freerange ();
@


1.6
log
@* cygthread.cc (cygthread::cygthread): Close another race.
@
text
@d11 1
d18 1
a18 1
static cygthread NO_COPY threads[8];
d21 11
a31 1
static HANDLE NO_COPY hthreads[NTHREADS];
d33 8
a40 1
DWORD NO_COPY cygthread::main_thread_id;
d81 3
a83 3
    hthreads[i] = threads[i].h =
      CreateThread (&sec_none_nih, 0, cygthread::stub, &threads[i],
		    CREATE_SUSPENDED, &threads[i].avail);
d111 11
d142 4
a145 2
      /* thread_runner may not be finished yet. */
      Sleep (0);
d213 2
a214 1
  SetEvent (*this);
d239 13
a251 5
      ResetEvent (*this);
      id = 0;
      __name = NULL;
      /* Mark the thread as available by setting avail to non-zero */
      (void) InterlockedExchange ((LPLONG) &this->avail, avail);
@


1.5
log
@* cygthread.cc (cygthread::stub): Accept flag to pass info structure to thread
function.
(cygthread::operator new): Add defense debugging output.
(cygthread::cygthread): Add debugging output.  Set name after thread has been
awakened to avoid a race.
(cygthread::exit_thread): Use handle operator rather than using ev directly.
(cygthread::exit_thread): Reorganize to provide debugging.  Set __name to NULL.
* cygthread.h (cygself): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Use cygself as argument so that
invoked thread can access its own info.
(process_output): Derive cygthread info of thread from thread argument.
* sigproc.cc (sigproc_init): Use cygself as argument so that invoked thread can
access its own info.
(wait_sig): Derive cygthread info of thread from thread argument.
@
text
@d126 2
a127 1
  while (ResumeThread (h) == 0)
d129 6
@


1.4
log
@* cygthread.cc (cygthread::stub): Change event creation to manual reset.  Set
__name after calling SetEvent to prevent races.
(cygthread::detach): Always reset event here to prevent races.
@
text
@d44 7
a50 4
      /* Cygwin threads should not call ExitThread */
      info->func (info->arg);

      debug_printf ("returned from function %p", info->func);
d106 4
d119 1
a119 1
		      const char *name): __name (name), func (start), arg (param)
d121 5
d128 3
d175 1
a175 1
  SetEvent (ev);
d186 3
a188 1
  if (!avail)
d194 1
a194 1
	debug_printf ("thread routine returned.  No need to wait.");
d198 1
a198 1
	  debug_printf ("WFSO returns %d", res);
d202 1
@


1.3
log
@* cygthread.cc (cygthread::exit_thread): Define new method.
* cygthread.h (cygthread::exit_thread): Declare new method.
* fhandler.h (fhandler_tty_master::hThread): Delete.
(fhandler_tty_master::output_thread): Define.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Adjust
constructor.
(fhandler_tty_master::init): Use cygthread rather than handle.
(process_output): Use cygthread method to exit.
(fhandler_tty_master::fixup_after_fork): Set output_thread to NULL after fork.
(fhandler_tty_master::fixup_after_exec): Set output_thread to NULL after
spawn/exec.
* tty.cc (tty_list::terminate): Detach from output_thread using cygthread
method.
@
text
@d10 1
a13 1
#include <windows.h>
d24 3
a26 2
/* Initial stub called by makethread. Performs initial per-thread
   initialization.  */
d38 1
a38 1
  info->ev = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
d47 2
a49 1
      SetEvent (info->ev);
d54 2
d66 1
d94 1
a94 1
  cygthread *info; /* Various information needed by the newly created thread */
d155 2
d164 4
d174 5
a178 1
      if (__name)
d183 1
d185 1
@


1.2
log
@* cygthread.cc: Remove cruft.
@
text
@d151 7
@


1.2.2.1
log
@Merged changes from HEAD
@
text
@@


1.2.2.2
log
@Merged changes from HEAD
@
text
@a150 7
cygthread::exit_thread ()
{
  SetEvent (ev);
  ExitThread (0);
}

void
@


1.2.2.3
log
@Merged changes from HEAD
@
text
@a9 1
#include <windows.h>
d13 1
d24 2
a25 3
/* Initial stub called by cygthread constructor. Performs initial
   per-thread initialization and loops waiting for new thread functions
   to execute.  */
d37 1
a37 1
  info->ev = CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
d43 4
a46 7
      /* Cygwin threads should not call ExitThread directly */
      info->func (info->arg == cygself ? info : info->arg);
      /* ...so the above should always return */

#ifdef DEBUGGING
      info->func = NULL;	// catch erroneous activation
#endif
a47 1
      info->__name = NULL;
a51 2
/* This function runs in a secondary thread and starts up a bunch of
   other suspended threads for use in the cygthread pool. */
a61 1
/* Start things going.  Called from dll_crt0_1. */
d89 1
a89 1
  cygthread *info;
a97 4
#ifdef DEBUGGING
	    if (info->__name)
	      api_fatal ("name not NULL? id %p, i %d", id, info - threads);
#endif
d107 1
a107 1
		      const char *name): func (start), arg (param)
a108 5
#ifdef DEBUGGGING
  if (!__name)
    api_fatal ("name should never be NULL");
#endif
  thread_printf ("name %s, id %p", name, id);
a110 3
  __name = name;	/* Need to set after thread has woken up to
			   ensure that it won't be cleared by exiting
			   thread. */
a149 2
/* Should only be called when the process is exiting since it
   leaves an open thread slot. */
d153 1
a153 1
  SetEvent (*this);
a156 4
/* Detach the cygthread from the current thread.  Note that the
   theory is that cygthread's are only associated with one thread.
   So, there should be no problems with multiple threads doing waits
   on the one cygthread. */
d160 1
a160 3
  if (avail)
    system_printf ("called detach on available thread %d?", avail);
  else
d163 1
a163 5
      /* Checking for __name here is just a minor optimization to avoid
	 an OS call. */
      if (!__name)
	thread_printf ("thread id %p returned.  No need to wait.", id);
      else
d166 1
a166 1
	  thread_printf ("WFSO returns %d, id %p", res, id);
a167 1
      ResetEvent (*this);
a168 2
      __name = NULL;
      /* Mark the thread as available by setting avail to non-zero */
@


1.2.2.4
log
@Merged changes from HEAD
@
text
@d126 1
a126 2
  while (!h || ResumeThread (h) != 1)
#ifndef DEBUGGING
a127 6
#else
    {
      thread_printf ("waiting for %s<%p> to become active", __name, h);
      Sleep (0);
    }
#endif
@


1.2.2.5
log
@Merged changes from HEAD
@
text
@a10 1
#include <stdlib.h>
d17 1
a17 1
static cygthread NO_COPY threads[6];
d20 2
a22 19
bool cygthread::initialized;

/* Initial stub called by cygthread constructor. Performs initial
   per-thread initialization and loops waiting for new thread functions
   to execute.  */
DWORD WINAPI
cygthread::simplestub (VOID *arg)
{
  DECLARE_TLS_STORAGE;
  exception_list except_entry;

  /* Initialize this thread's ability to respond to things like
     SIGSEGV or SIGFPE. */
  init_exceptions (&except_entry);

  cygthread *info = (cygthread *) arg;
  info->func (info->arg == cygself ? info : info->arg);
  ExitThread (0);
}
d63 3
a65 3
    threads[i].h = CreateThread (&sec_none_nih, 0, cygthread::stub, &threads[i],
				 CREATE_SUSPENDED, &threads[i].avail);
  cygthread::initialized = true;
a92 11
void *
cygthread::freerange ()
{
  cygthread *self = (cygthread *) calloc (1, sizeof (*self));
  self->is_freerange = true;
  self->h = CreateThread (&sec_none_nih, 0, cygthread::simplestub, self,
			  CREATE_SUSPENDED, &self->id);
  self->ev = self->h;
  return self;
}

d113 2
a114 4
      if (!initialized)
	Sleep (0); /* thread_runner is not be finished yet. */
      else
	return freerange ();
d182 1
a182 2
  if (!is_freerange)
    SetEvent (*this);
d207 5
a211 13
      if (is_freerange)
	{
	  CloseHandle (h);
	  free (this);
	}
      else
	{
	  ResetEvent (*this);
	  id = 0;
	  __name = NULL;
	  /* Mark the thread as available by setting avail to non-zero */
	  (void) InterlockedExchange ((LPLONG) &this->avail, avail);
	}
@


1.2.2.6
log
@Merged changes from HEAD
@
text
@d22 1
a22 1
bool NO_COPY cygthread::initialized;
a129 1
      bool was_initialized = initialized;
d131 1
a131 1
      for (info = threads + NTHREADS - 1; info >= threads; info--)
d142 2
a143 2
      if (!was_initialized)
	Sleep (0); /* thread_runner is not finished yet. */
d145 1
a145 8
	{
#ifdef DEBUGGING
	  char buf[1024];
	  if (GetEnvironmentVariable ("CYGWIN_NOFREERANGE", buf, sizeof (buf)))
	    api_fatal ("Overflowed cygwin thread pool");
#endif
	  return freerange ();
	}
@


1.1
log
@* Makefile.in (DLL_OFILES): Add cygthread.o.
* dcrt0.cc (dll_crt0_1): Eliminate various thread initialization functions in
favor of new cygthread class.
* debug.cc: Remove thread manipulation functions.
* debug.h: Ditto.
* external.cc (cygwin_internal): Use cygthread method for determining thread
name.  Remove capability for setting thread name.
* fhandler_console.cc (fhandler_console::read): Use cygthread method rather
than iscygthread function.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Use cygthread
methods to create threads.
(fhandler_tty_common::__acquire_output_mutex): Use cygthread method to retrieve
thread name.
* select.cc (pipeinf): Use cygthread pointer rather than handle.
(start_thread_pipe): Ditto.
(pipe_cleanup): Ditto.
(serialinf): Ditto.
(start_thread_serial): Ditto.
(serial_cleanup): Ditto.
(socketinf): Ditto.
(start_thread_socket): Ditto.
(socket_cleanup): Ditto.
* sigproc.cc (hwait_sig): Ditto.
(hwait_subproc): Ditto.
(proc_terminate): Ditto.
(sigproc_terminate): Ditto.
(sigproc_init): Initialize cygthread hwait_sig pointer.
(subproc_init): Initialize cygthread hwait_subproc pointer.
(wait_sig): Rely on cygthread HANDLE operator.
* strace.cc (strace::vsprntf): Use cygthread::name rather than threadname.
* window.cc (gethwnd): Use cygthread method to initialize thread.
@
text
@a8 22
class cygthread
{
  DWORD avail;
  DWORD id;
  HANDLE h;
  HANDLE ev;
  const char *__name;
  LPTHREAD_START_ROUTINE func;
  VOID *arg;
  static DWORD main_thread_id;
  static DWORD WINAPI runner (VOID *);
  static DWORD WINAPI stub (VOID *);
 public:
  static const char * name (DWORD = 0);
  cygthread (LPTHREAD_START_ROUTINE, LPVOID, const char *);
  cygthread () {};
  static void init ();
  void detach ();
  operator HANDLE ();
  static bool is ();
  void * operator new (size_t);
};
@

