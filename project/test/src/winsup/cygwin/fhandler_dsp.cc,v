head	1.71;
access;
symbols
	cygwin-1_7_35-release:1.71
	cygwin-1_7_34-release:1.71
	cygwin-1_7_33-release:1.66.2.6
	cygwin-1_7_32-release:1.66.2.6
	cygwin-1_7_31-release:1.66.2.6
	cygwin-1_7_30-release:1.66.2.6
	cygwin-1_7_29-release:1.66.2.5
	cygwin-1_7_29-release-branchpoint:1.66.0.2
	cygwin-pre-user-db:1.66
	cygwin-1_7_28-release:1.66
	cygwin-1_7_27-release:1.66
	cygwin-1_7_26-release:1.66
	cygwin-1_7_25-release:1.64
	cygwin-1_7_24-release:1.64
	cygwin-1_7_23-release:1.64
	cygwin-1_7_22-release:1.64
	cygwin-1_7_21-release:1.64
	cygwin-1_7_20-release:1.64
	cygwin-1_7_19-release:1.64
	cygwin-64bit-postmerge:1.63
	cygwin-64bit-premerge-branch:1.62.0.4
	cygwin-64bit-premerge:1.62
	cygwin-1_7_18-release:1.62
	post-ptmalloc3:1.62.2.3
	pre-ptmalloc3:1.62.2.3
	cygwin-1_7_17-release:1.62
	cygwin-64bit-branch:1.62.0.2
	cygwin-1_7_16-release:1.62
	cygwin-1_7_15-release:1.61
	cygwin-1_7_14_2-release:1.61
	cygwin-1_7_14-release:1.61
	cygwin-1_7_12-release:1.61
	cygwin-1_7_11-release:1.61
	cygwin-1_7_10-release:1.60
	signal-rewrite:1.56.0.2
	pre-notty:1.55
	cygwin-1_7_9-release:1.52
	cv-post-1_7_9:1.52.0.4
	cygwin-1_7_8-release:1.52
	cygwin-1_7_7-release:1.52
	cygwin-1_7_5-release:1.52
	cygwin-1_7_4-release:1.52
	cygwin-1_7_3-release:1.52
	cygwin-1_7_2-release:1.52
	fifo_doover3:1.52.0.2
	cygwin-1_7_1-release:1.52
	prefifo:1.51
	cv-branch-2:1.51.0.2
	pre-ripout-set_console_state_for_spawn:1.50
	EOL_registry_mounts:1.49
	preoverlapped:1.46
	drop_9x_support_start:1.46
	cr-0x5f1:1.46.0.4
	cv-branch:1.46.0.2
	pre-ptymaster-archetype:1.45
	cr-0x3b58:1.45.0.4
	cr-0x5ef:1.45.0.2
	after-mmap-privanon-noreserve:1.45
	after-mmap-revamp:1.45
	before-mmap-revamp:1.45
	cgf-more-exit-sync:1.44
	post_wait_sig_exit:1.42
	pre_wait_sig_exit:1.41
	reparent-point:1.40
	noreparent:1.40.0.2
	cr-0x5e6:1.36.0.2
	cr-0x9e:1.28.0.6
	cr-0x9d:1.28.0.4
	cgf-deleteme:1.28.0.2
	pre-sigrewrite:1.28
	corinna-01:1.28
	cr-0x9c:1.27.0.6
	cr-0x9b:1.27.0.4
	cr-0x99:1.27
	Z-emcb-cygwin_daemon:1.27.0.2
	w32api-2_2:1.25
	mingw-runtime-2_4:1.25
	pre-cgf-merge:1.27
	cgf-dev-branch:1.25.0.2
	predaemon:1.18
	cygwin_daemon_merge_HEAD:1.18
	pregp02r1:1.17.0.2
	cygnus_cvs_20020108_pre:1.14
	Z-cygwin_daemon_merge-new_HEAD:1.21
	Z-cygwin_daemon_merge_HEAD:1.21
	cygwin_daemon:1.9.0.4;
locks; strict;
comment	@// @;


1.71
date	2014.05.02.15.14.17;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2014.03.20.02.23.52;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2014.03.19.20.43.15;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2014.03.18.20.17.03;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2014.03.17.04.41.35;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2013.10.26.13.23.54;	author corinna;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2013.10.24.17.51.41;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.63;

1.63
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2012.06.17.20.50.24;	author cgf;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2012.02.09.15.23.17;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2011.12.25.04.05.31;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2011.12.09.16.02.56;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2011.12.04.18.32.00;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.21.20.21.46;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2011.06.06.05.02.10;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2011.05.05.22.30.53;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2011.05.04.11.41.22;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.07.18.59.40;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2006.06.03.21.44.01;	author cgf;	state Exp;
branches
	1.46.4.1;
next	1.45;

1.45
date	2005.11.14.04.28.44;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.28.19.22.22;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2005.09.28.19.02.49;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.14.14.27.54;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2004.09.12.03.47.56;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.17.09.52.50;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.19.13.13.48;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.28.19.50.05;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.07.07.54.28;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.13.09.38.32;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.05.08.30.41;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.24.08.57.17;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.23.11.05.56;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.09.04.04.22;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.02.21.00.07;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.15.10.21.23;	author corinna;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2003.01.14.02.08.35;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.14.04.01.32;	author cgf;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2002.09.30.04.35.17;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.03.03.20.50;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.04.11.18.46;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.25.17.47.46;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.19.22.06.50;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.05.06.09.07;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.24.04.16.45;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.22.18.39.22;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.06.29.02.20.01;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.26.14.47.48;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.05.20.17;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.20.17.31.06;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.25.07.26.54;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.24.02.07.58;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.16.03.27.16;	author cgf;	state Exp;
branches;
next	;

1.66.2.1
date	2014.03.17.01.54.13;	author cgf;	state Exp;
branches;
next	1.66.2.2;

1.66.2.2
date	2014.03.17.04.36.17;	author cgf;	state Exp;
branches;
next	1.66.2.3;

1.66.2.3
date	2014.03.18.20.17.17;	author cgf;	state Exp;
branches;
next	1.66.2.4;

1.66.2.4
date	2014.03.19.20.42.52;	author cgf;	state Exp;
branches;
next	1.66.2.5;

1.66.2.5
date	2014.03.20.02.23.32;	author cgf;	state Exp;
branches;
next	1.66.2.6;

1.66.2.6
date	2014.05.19.11.47.53;	author corinna;	state Exp;
branches;
next	;

1.62.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2012.11.05.17.20.20;	author corinna;	state Exp;
branches;
next	1.62.2.3;

1.62.2.3
date	2012.12.10.11.45.47;	author corinna;	state Exp;
branches;
next	;

1.46.4.1
date	2008.03.04.22.30.27;	author corinna;	state Exp;
branches;
next	;

1.25.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.23.4.1
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	;

1.9.4.1
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2002.02.28.12.53.24;	author rbcollins;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2002.06.13.14.34.05;	author rbcollins;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2002.07.03.16.01.46;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.71
log
@* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.
@
text
@/* fhandler_dev_dsp: code to emulate OSS sound model /dev/dsp

   Copyright 2001, 2002, 2003, 2004, 2008, 2011, 2012, 2013 Red Hat, Inc

   Written by Andy Younger (andy@@snoogie.demon.co.uk)
   Extended by Gerd Spalink (Gerd.Spalink@@t-online.de)
     to support recording from the audio input

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <sys/soundcard.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "sigproc.h"
#include "cygwait.h"

/*------------------------------------------------------------------------
  Simple encapsulation of the win32 audio device.

  Implementation Notes
  1. Audio structures are malloced just before the first read or
     write to /dev/dsp. The actual buffer size is determined at that time,
     such that one buffer holds about 125ms of audio data.
     At the time of this writing, 12 buffers are allocated,
     so that up to 1.5 seconds can be buffered within Win32.
     The buffer size can be queried with the ioctl SNDCTL_DSP_GETBLKSIZE,
     but for this implementation only returns meaningful results if
     sampling rate, number of channels and number of bits per sample
     are not changed afterwards.
     The audio structures are freed when the device is reset or closed,
     and they are not passed to exec'ed processes.
     The dev_ member is cleared after a fork. This forces the child
     to reopen the audio device._

  2. Every open call creates a new instance of the handler. After a
     successful open, every subsequent open from the same process
     to the device fails with EBUSY.
     The structures are shared between duped handles, but not with
     children. They only inherit the settings from the parent.
 */

class fhandler_dev_dsp::Audio
{ // This class contains functionality common to Audio_in and Audio_out
 public:
   Audio (fhandler_dev_dsp *my_fh);
   ~Audio ();

  class queue;

  bool isvalid ();
  void setconvert (int format);
  void convert_none (unsigned char *buffer, int size_bytes) { }
  void convert_U8_S8 (unsigned char *buffer, int size_bytes);
  void convert_S16LE_U16LE (unsigned char *buffer, int size_bytes);
  void convert_S16LE_U16BE (unsigned char *buffer, int size_bytes);
  void convert_S16LE_S16BE (unsigned char *buffer, int size_bytes);
  void fillFormat (WAVEFORMATEX * format,
		   int rate, int bits, int channels);
  unsigned blockSize (int rate, int bits, int channels);
  void (fhandler_dev_dsp::Audio::*convert_)
    (unsigned char *buffer, int size_bytes);

  enum { MAX_BLOCKS = 12 };
  int bufferIndex_;  // offset into pHdr_->lpData
  WAVEHDR *pHdr_;    // data to be filled by write
  WAVEHDR wavehdr_[MAX_BLOCKS];
  char *bigwavebuffer_; // audio samples only
  // Member variables below must be locked
  queue *Qisr2app_; // blocks passed from wave callback

  fhandler_dev_dsp *fh;
};

class fhandler_dev_dsp::Audio::queue
{ // non-blocking fixed size queues for buffer management
 public:
   queue (int depth = 4);
  ~queue ();

  bool send (WAVEHDR *);  // queue an item, returns true if successful
  bool recv (WAVEHDR **); // retrieve an item, returns true if successful
  void reset ();
  int query (); // return number of items queued
  inline void lock () { EnterCriticalSection (&lock_); }
  inline void unlock () { LeaveCriticalSection (&lock_); }
  inline void dellock () { debug_printf ("Deleting Critical Section"); DeleteCriticalSection (&lock_); }
  bool isvalid () { return storage_; }
 private:
  CRITICAL_SECTION lock_;
  int head_;
  int tail_;
  int depth_;
  WAVEHDR **storage_;
};

static void CALLBACK waveOut_callback (HWAVEOUT hWave, UINT msg,
				       DWORD_PTR instance, DWORD_PTR param1,
				       DWORD_PTR param2);

class fhandler_dev_dsp::Audio_out: public Audio
{
 public:
  Audio_out (fhandler_dev_dsp *my_fh) : Audio (my_fh) {}

  void fork_fixup (HANDLE parent);
  bool query (int rate, int bits, int channels);
  bool start ();
  void stop (bool immediately = false);
  int write (const char *pSampleData, int nBytes);
  void buf_info (audio_buf_info *p, int rate, int bits, int channels);
  void callback_sampledone (WAVEHDR *pHdr);
  bool parsewav (const char *&pData, int &nBytes,
		 int rate, int bits, int channels);

 private:
  void init (unsigned blockSize);
  void waitforallsent ();
  bool waitforspace ();
  bool sendcurrent ();

  enum { MAX_BLOCKS = 12 };
  HWAVEOUT dev_;     // The wave device
  /* Private copies of audiofreq_, audiobits_, audiochannels_,
     possibly set from wave file */
  int freq_;
  int bits_;
  int channels_;
};

static void CALLBACK waveIn_callback (HWAVEIN hWave, UINT msg,
				      DWORD_PTR instance, DWORD_PTR param1,
				      DWORD_PTR param2);

class fhandler_dev_dsp::Audio_in: public Audio
{
public:
  Audio_in (fhandler_dev_dsp *my_fh) : Audio (my_fh) {}

  void fork_fixup (HANDLE parent);
  bool query (int rate, int bits, int channels);
  bool start (int rate, int bits, int channels);
  void stop ();
  bool read (char *pSampleData, int &nBytes);
  void buf_info (audio_buf_info *p, int rate, int bits, int channels);
  void callback_blockfull (WAVEHDR *pHdr);

private:
  bool init (unsigned blockSize);
  bool queueblock (WAVEHDR *pHdr);
  bool waitfordata (); // blocks until we have a good pHdr_ unless O_NONBLOCK

  HWAVEIN dev_;
};

/* --------------------------------------------------------------------
   Implementation */

// Simple fixed length FIFO queue implementation for audio buffer management
fhandler_dev_dsp::Audio::queue::queue (int depth)
{
  // allow space for one extra object in the queue
  // so we can distinguish full and empty status
  depth_ = depth;
  storage_ = new WAVEHDR *[depth_ + 1];
}

fhandler_dev_dsp::Audio::queue::~queue ()
{
  delete[] storage_;
}

void
fhandler_dev_dsp::Audio::queue::reset ()
 {
   /* When starting, after reset and after fork */
   head_ = tail_ = 0;
   debug_printf ("InitializeCriticalSection");
   memset (&lock_, 0, sizeof (lock_));
   InitializeCriticalSection (&lock_);
 }

bool
fhandler_dev_dsp::Audio::queue::send (WAVEHDR *x)
{
  bool res = false;
  lock ();
  if (query () == depth_)
    system_printf ("Queue overflow");
  else
    {
      storage_[tail_] = x;
      if (++tail_ > depth_)
	tail_ = 0;
      res = true;
    }
  unlock ();
  return res;
}

bool
fhandler_dev_dsp::Audio::queue::recv (WAVEHDR **x)
{
  bool res = false;
  lock ();
  if (query () != 0)
    {
      *x = storage_[head_];
      if (++head_ > depth_)
	head_ = 0;
      res = true;
    }
  unlock ();
  return res;
}

int
fhandler_dev_dsp::Audio::queue::query ()
{
  int n = tail_ - head_;
  if (n < 0)
    n += depth_ + 1;
  return n;
}

// Audio class implements functionality need for both read and write
fhandler_dev_dsp::Audio::Audio (fhandler_dev_dsp *my_fh)
{
  bigwavebuffer_ = NULL;
  Qisr2app_ = new queue (MAX_BLOCKS);
  convert_ = &fhandler_dev_dsp::Audio::convert_none;
  fh = my_fh;
}

fhandler_dev_dsp::Audio::~Audio ()
{
  debug_printf("");
  delete Qisr2app_;
  delete[] bigwavebuffer_;
}

inline bool
fhandler_dev_dsp::Audio::isvalid ()
{
  return bigwavebuffer_ && Qisr2app_ && Qisr2app_->isvalid ();
}

void
fhandler_dev_dsp::Audio::setconvert (int format)
{
  switch (format)
    {
    case AFMT_S8:
      convert_ = &fhandler_dev_dsp::Audio::convert_U8_S8;
      debug_printf ("U8_S8");
      break;
    case AFMT_U16_LE:
      convert_ = &fhandler_dev_dsp::Audio::convert_S16LE_U16LE;
      debug_printf ("S16LE_U16LE");
      break;
    case AFMT_U16_BE:
      convert_ = &fhandler_dev_dsp::Audio::convert_S16LE_U16BE;
      debug_printf ("S16LE_U16BE");
      break;
    case AFMT_S16_BE:
      convert_ = &fhandler_dev_dsp::Audio::convert_S16LE_S16BE;
      debug_printf ("S16LE_S16BE");
      break;
    default:
      convert_ = &fhandler_dev_dsp::Audio::convert_none;
      debug_printf ("none");
    }
}

void
fhandler_dev_dsp::Audio::convert_U8_S8 (unsigned char *buffer,
					int size_bytes)
{
  while (size_bytes-- > 0)
    {
      *buffer ^= (unsigned char)0x80;
      buffer++;
    }
}

void
fhandler_dev_dsp::Audio::convert_S16LE_U16BE (unsigned char *buffer,
					      int size_bytes)
{
  int size_samples = size_bytes / 2;
  unsigned char hi, lo;
  while (size_samples-- > 0)
    {
      hi = buffer[0];
      lo = buffer[1];
      *buffer++ = lo;
      *buffer++ = hi ^ (unsigned char)0x80;
    }
}

void
fhandler_dev_dsp::Audio::convert_S16LE_U16LE (unsigned char *buffer,
					      int size_bytes)
{
  int size_samples = size_bytes / 2;
  while (size_samples-- > 0)
    {
      buffer++;
      *buffer ^= (unsigned char)0x80;
      buffer++;
    }
}

void
fhandler_dev_dsp::Audio::convert_S16LE_S16BE (unsigned char *buffer,
					      int size_bytes)
{
  int size_samples = size_bytes / 2;
  unsigned char hi, lo;
  while (size_samples-- > 0)
    {
      hi = buffer[0];
      lo = buffer[1];
      *buffer++ = lo;
      *buffer++ = hi;
    }
}

void
fhandler_dev_dsp::Audio::fillFormat (WAVEFORMATEX * format,
				     int rate, int bits, int channels)
{
  memset (format, 0, sizeof (*format));
  format->wFormatTag = WAVE_FORMAT_PCM;
  format->wBitsPerSample = bits;
  format->nChannels = channels;
  format->nSamplesPerSec = rate;
  format->nAvgBytesPerSec = format->nSamplesPerSec * format->nChannels
    * (bits / 8);
  format->nBlockAlign = format->nChannels * (bits / 8);
}

// calculate a good block size
unsigned
fhandler_dev_dsp::Audio::blockSize (int rate, int bits, int channels)
{
  unsigned blockSize;
  blockSize = ((bits / 8) * channels * rate) / 8; // approx 125ms per block
  // round up to multiple of 64
  blockSize +=  0x3f;
  blockSize &= ~0x3f;
  return blockSize;
}

//=======================================================================
void
fhandler_dev_dsp::Audio_out::fork_fixup (HANDLE parent)
{
  /* Null dev_.
     It will be necessary to reset the queue, open the device
     and create a lock when writing */
  debug_printf ("parent=%p", parent);
  dev_ = NULL;
}


bool
fhandler_dev_dsp::Audio_out::query (int rate, int bits, int channels)
{
  WAVEFORMATEX format;
  MMRESULT rc;

  fillFormat (&format, rate, bits, channels);
  rc = waveOutOpen (NULL, WAVE_MAPPER, &format, 0L, 0L, WAVE_FORMAT_QUERY);
  debug_printf ("%u = waveOutOpen(freq=%d bits=%d channels=%d)", rc, rate, bits, channels);
  return (rc == MMSYSERR_NOERROR);
}

bool
fhandler_dev_dsp::Audio_out::start ()
{
  WAVEFORMATEX format;
  MMRESULT rc;
  unsigned bSize = blockSize (freq_, bits_, channels_);

  if (dev_)
    return true;

  /* In case of fork bigwavebuffer may already exist */
  if (!bigwavebuffer_)
    bigwavebuffer_ = new char[MAX_BLOCKS * bSize];

  if (!isvalid ())
    return false;

  fillFormat (&format, freq_, bits_, channels_);
  rc = waveOutOpen (&dev_, WAVE_MAPPER, &format, (DWORD_PTR) waveOut_callback,
		     (DWORD_PTR) this, CALLBACK_FUNCTION);
  if (rc == MMSYSERR_NOERROR)
    init (bSize);

  debug_printf ("%u = waveOutOpen(freq=%d bits=%d channels=%d)", rc, freq_, bits_, channels_);

  return (rc == MMSYSERR_NOERROR);
}

void
fhandler_dev_dsp::Audio_out::stop (bool immediately)
{
  MMRESULT rc;
  WAVEHDR *pHdr;

  debug_printf ("dev_=%p", dev_);
  if (dev_)
    {
      if (!immediately)
	{
	  sendcurrent ();	// force out last block whatever size..
	  waitforallsent ();	// block till finished..
	}

      rc = waveOutReset (dev_);
      debug_printf ("%u = waveOutReset()", rc);
      while (Qisr2app_->recv (&pHdr))
	{
	  rc = waveOutUnprepareHeader (dev_, pHdr, sizeof (WAVEHDR));
	  debug_printf ("%u = waveOutUnprepareHeader(%p)", rc, pHdr);
	}

      no_thread_exit_protect for_now (true);
      rc = waveOutClose (dev_);
      debug_printf ("%u = waveOutClose()", rc);

      Qisr2app_->dellock ();
    }
}

void
fhandler_dev_dsp::Audio_out::init (unsigned blockSize)
{
  int i;

  // internally queue all of our buffer for later use by write
  Qisr2app_->reset ();
  for (i = 0; i < MAX_BLOCKS; i++)
    {
      wavehdr_[i].lpData = &bigwavebuffer_[i * blockSize];
      wavehdr_[i].dwUser = (int) blockSize;
      wavehdr_[i].dwFlags = 0;
      if (!Qisr2app_->send (&wavehdr_[i]))
	{
	  system_printf ("Internal Error i=%d", i);
	  break; // should not happen
	}
    }
  pHdr_ = NULL;
}

int
fhandler_dev_dsp::Audio_out::write (const char *pSampleData, int nBytes)
{
  int bytes_to_write = nBytes;
  while (bytes_to_write != 0)
    { // Block if all blocks used until at least one is free
      if (!waitforspace ())
	{
	  if (bytes_to_write != nBytes)
	    break;
	  return -1;
	}

      int sizeleft = (int)pHdr_->dwUser - bufferIndex_;
      if (bytes_to_write < sizeleft)
	{ // all data fits into the current block, with some space left
	  memcpy (&pHdr_->lpData[bufferIndex_], pSampleData, bytes_to_write);
	  bufferIndex_ += bytes_to_write;
	  bytes_to_write = 0;
	  break;
	}
      else
	{ // data will fill up the current block
	  memcpy (&pHdr_->lpData[bufferIndex_], pSampleData, sizeleft);
	  bufferIndex_ += sizeleft;
	  sendcurrent ();
	  pSampleData += sizeleft;
	  bytes_to_write -= sizeleft;
	}
    }
  return nBytes - bytes_to_write;
}

void
fhandler_dev_dsp::Audio_out::buf_info (audio_buf_info *p,
				       int rate, int bits, int channels)
{
  p->fragstotal = MAX_BLOCKS;
  if (this && dev_)
    {
      /* If the device is running we use the internal values,
	 possibly set from the wave file. */
      p->fragsize = blockSize (freq_, bits_, channels_);
      p->fragments = Qisr2app_->query ();
      if (pHdr_ != NULL)
	p->bytes = (int)pHdr_->dwUser - bufferIndex_
	  + p->fragsize * p->fragments;
      else
	p->bytes = p->fragsize * p->fragments;
    }
  else
    {
      p->fragsize = blockSize (rate, bits, channels);
      p->fragments = MAX_BLOCKS;
      p->bytes = p->fragsize * p->fragments;
    }
}

/* This is called on an interupt so use locking.. Note Qisr2app_
   is used so we should wrap all references to it in locks. */
inline void
fhandler_dev_dsp::Audio_out::callback_sampledone (WAVEHDR *pHdr)
{
  Qisr2app_->send (pHdr);
}

bool
fhandler_dev_dsp::Audio_out::waitforspace ()
{
  WAVEHDR *pHdr;
  MMRESULT rc = WAVERR_STILLPLAYING;

  if (pHdr_ != NULL)
    return true;
  while (!Qisr2app_->recv (&pHdr))
    {
      if (fh->is_nonblocking ())
	{
	  set_errno (EAGAIN);
	  return false;
	}
      debug_printf ("100ms");
      switch (cygwait (100))
	{
	case WAIT_SIGNALED:
	  if (!_my_tls.call_signal_handler ())
	    {
	      set_errno (EINTR);
	      return false;
	    }
	  break;
	case WAIT_CANCELED:
	  pthread::static_cancel_self ();
	  /*NOTREACHED*/
	default:
	  break;
	}
    }
  if (pHdr->dwFlags)
    {
      /* Errors are ignored here. They will probbaly cause a failure
	 in the subsequent PrepareHeader */
      rc = waveOutUnprepareHeader (dev_, pHdr, sizeof (WAVEHDR));
      debug_printf ("%u = waveOutUnprepareHeader(%p)", rc, pHdr);
    }
  pHdr_ = pHdr;
  bufferIndex_ = 0;
  return true;
}

void
fhandler_dev_dsp::Audio_out::waitforallsent ()
{
  while (Qisr2app_->query () != MAX_BLOCKS)
    {
      debug_printf ("%d blocks in Qisr2app", Qisr2app_->query ());
      Sleep (100);
    }
}

// send the block described by pHdr_ and bufferIndex_ to wave device
bool
fhandler_dev_dsp::Audio_out::sendcurrent ()
{
  WAVEHDR *pHdr = pHdr_;
  MMRESULT rc;
  debug_printf ("pHdr=%p bytes=%d", pHdr, bufferIndex_);

  if (pHdr_ == NULL)
    return false;
  pHdr_ = NULL;

  // Sample buffer conversion
  (this->*convert_) ((unsigned char *)pHdr->lpData, bufferIndex_);

  // Send internal buffer out to the soundcard
  pHdr->dwBufferLength = bufferIndex_;
  rc = waveOutPrepareHeader (dev_, pHdr, sizeof (WAVEHDR));
  debug_printf ("%u = waveOutPrepareHeader(%p)", rc, pHdr);
  if (rc == MMSYSERR_NOERROR)
    {
      rc = waveOutWrite (dev_, pHdr, sizeof (WAVEHDR));
      debug_printf ("%u = waveOutWrite(%p)", rc, pHdr);
    }
  if (rc == MMSYSERR_NOERROR)
    return true;

  /* FIXME: Should we return an error instead ?*/
  pHdr->dwFlags = 0; /* avoid calling UnprepareHeader again */
  Qisr2app_->send (pHdr);
  return false;
}

//------------------------------------------------------------------------
// Call back routine
static void CALLBACK
waveOut_callback (HWAVEOUT hWave, UINT msg, DWORD_PTR instance,
		  DWORD_PTR param1, DWORD_PTR param2)
{
  if (msg == WOM_DONE)
    {
      fhandler_dev_dsp::Audio_out *ptr =
	(fhandler_dev_dsp::Audio_out *) instance;
      ptr->callback_sampledone ((WAVEHDR *) param1);
    }
}

//------------------------------------------------------------------------
// wav file detection..
#pragma pack(1)
struct wavchunk
{
  char id[4];
  unsigned int len;
};
struct wavformat
{
  unsigned short wFormatTag;
  unsigned short wChannels;
  unsigned int dwSamplesPerSec;
  unsigned int dwAvgBytesPerSec;
  unsigned short wBlockAlign;
  unsigned short wBitsPerSample;
};
#pragma pack()

bool
fhandler_dev_dsp::Audio_out::parsewav (const char * &pData, int &nBytes,
				       int dev_freq, int dev_bits, int dev_channels)
{
  int len;
  const char *end = pData + nBytes;
  const char *pDat;
  int skip = 0;

  /* Start with default values from the device handler */
  freq_ = dev_freq;
  bits_ = dev_bits;
  channels_ = dev_channels;
  setconvert (bits_ == 8 ? AFMT_U8 : AFMT_S16_LE);

  // Check alignment first: A lot of the code below depends on it
  if (((uintptr_t)pData & 0x3) != 0)
    return false;
  if (!(pData[0] == 'R' && pData[1] == 'I'
	&& pData[2] == 'F' && pData[3] == 'F'))
    return false;
  if (!(pData[8] == 'W' && pData[9] == 'A'
	&& pData[10] == 'V' && pData[11] == 'E'))
    return false;

  len = *(int *) &pData[4];
  len -= 12;
  pDat = pData + 12;
  skip = 12;
  while ((len > 0) && (pDat + sizeof (wavchunk) < end))
    { /* We recognize two kinds of wavchunk:
	 "fmt " for the PCM parameters (only PCM supported here)
	 "data" for the start of PCM data */
      wavchunk * pChunk = (wavchunk *) pDat;
      int blklen = pChunk-> len;
      if (pChunk->id[0] == 'f' && pChunk->id[1] == 'm'
	  && pChunk->id[2] == 't' && pChunk->id[3] == ' ')
	{
	  wavformat *format = (wavformat *) (pChunk + 1);
	  if ((char *) (format + 1) >= end)
	    return false;
	  // We have found the parameter chunk
	  if (format->wFormatTag == 0x0001)
	    { // Micr*s*ft PCM; check if parameters work with our device
	      if (query (format->dwSamplesPerSec, format->wBitsPerSample,
			 format->wChannels))
		{ // return the parameters we found
		  freq_ = format->dwSamplesPerSec;
		  bits_ = format->wBitsPerSample;
		  channels_ = format->wChannels;
		}
	    }
	}
      else
	{
	  if (pChunk->id[0] == 'd' && pChunk->id[1] == 'a'
	      && pChunk->id[2] == 't' && pChunk->id[3] == 'a')
	    { // throw away all the header & not output it to the soundcard.
	      skip += sizeof (wavchunk);
	      debug_printf ("Discard %d bytes wave header", skip);
	      pData += skip;
	      nBytes -= skip;
	      setconvert (bits_ == 8 ? AFMT_U8 : AFMT_S16_LE);
	      return true;
	    }
	}
      pDat += blklen + sizeof (wavchunk);
      skip += blklen + sizeof (wavchunk);
      len -= blklen + sizeof (wavchunk);
    }
  return false;
}

/* ========================================================================
   Buffering concept for Audio_in:
   On the first read, we queue all blocks of our bigwavebuffer
   for reception and start the wave-in device.
   We manage queues of pointers to WAVEHDR
   When a block has been filled, the callback puts the corresponding
   WAVEHDR pointer into a queue.
   The function read() blocks (polled, sigh) until at least one good buffer
   has arrived, then the data is copied into the buffer provided to read().
   After a buffer has been fully used by read(), it is queued again
   to the wave-in device immediately.
   The function read() iterates until all data requested has been
   received, there is no way to interrupt it */

void
fhandler_dev_dsp::Audio_in::fork_fixup (HANDLE parent)
{
  /* Null dev_.
     It will be necessary to reset the queue, open the device
     and create a lock when reading */
  debug_printf ("parent=%p", parent);
  dev_ = NULL;
}

bool
fhandler_dev_dsp::Audio_in::query (int rate, int bits, int channels)
{
  WAVEFORMATEX format;
  MMRESULT rc;

  fillFormat (&format, rate, bits, channels);
  rc = waveInOpen (NULL, WAVE_MAPPER, &format, 0L, 0L, WAVE_FORMAT_QUERY);
  debug_printf ("%u = waveInOpen(freq=%d bits=%d channels=%d)", rc, rate, bits, channels);
  return (rc == MMSYSERR_NOERROR);
}

bool
fhandler_dev_dsp::Audio_in::start (int rate, int bits, int channels)
{
  WAVEFORMATEX format;
  MMRESULT rc;
  unsigned bSize = blockSize (rate, bits, channels);

  if (dev_)
    return true;

  /* In case of fork bigwavebuffer may already exist */
  if (!bigwavebuffer_)
    bigwavebuffer_ = new char[MAX_BLOCKS * bSize];

  if (!isvalid ())
    return false;

  fillFormat (&format, rate, bits, channels);
  rc = waveInOpen (&dev_, WAVE_MAPPER, &format, (DWORD_PTR) waveIn_callback,
		   (DWORD_PTR) this, CALLBACK_FUNCTION);
  debug_printf ("%u = waveInOpen(rate=%d bits=%d channels=%d)", rc, rate, bits, channels);

  if (rc == MMSYSERR_NOERROR)
    {
      if (!init (bSize))
	return false;
    }
  return (rc == MMSYSERR_NOERROR);
}

void
fhandler_dev_dsp::Audio_in::stop ()
{
  MMRESULT rc;
  WAVEHDR *pHdr;

  debug_printf ("dev_=%p", dev_);
  if (dev_)
    {
      /* Note that waveInReset calls our callback for all incomplete buffers.
	 Since all the win32 wave functions appear to use a common lock,
	 we must not call into the wave API from the callback.
	 Otherwise we end up in a deadlock. */
      rc = waveInReset (dev_);
      debug_printf ("%u = waveInReset()", rc);

      while (Qisr2app_->recv (&pHdr))
	{
	  rc = waveInUnprepareHeader (dev_, pHdr, sizeof (WAVEHDR));
	  debug_printf ("%u = waveInUnprepareHeader(%p)", rc, pHdr);
	}

      no_thread_exit_protect for_now (true);
      rc = waveInClose (dev_);
      debug_printf ("%u = waveInClose()", rc);

      Qisr2app_->dellock ();
    }
}

bool
fhandler_dev_dsp::Audio_in::queueblock (WAVEHDR *pHdr)
{
  MMRESULT rc;
  rc = waveInPrepareHeader (dev_, pHdr, sizeof (WAVEHDR));
  debug_printf ("%u = waveInPrepareHeader(%p)", rc, pHdr);
  if (rc == MMSYSERR_NOERROR)
    {
      rc = waveInAddBuffer (dev_, pHdr, sizeof (WAVEHDR));
      debug_printf ("%u = waveInAddBuffer(%p)", rc, pHdr);
    }
  if (rc == MMSYSERR_NOERROR)
    return true;

  /* FIXME: Should the calling function return an error instead ?*/
  pHdr->dwFlags = 0;  /* avoid calling UnprepareHeader again */
  pHdr->dwBytesRecorded = 0;  /* no data will have been read */
  Qisr2app_->send (pHdr);
  return false;
}

bool
fhandler_dev_dsp::Audio_in::init (unsigned blockSize)
{
  MMRESULT rc;
  int i;

  // try to queue all of our buffer for reception
  Qisr2app_->reset ();
  for (i = 0; i < MAX_BLOCKS; i++)
    {
      wavehdr_[i].lpData = &bigwavebuffer_[i * blockSize];
      wavehdr_[i].dwBufferLength = blockSize;
      wavehdr_[i].dwFlags = 0;
      if (!queueblock (&wavehdr_[i]))
	break;
    }
  pHdr_ = NULL;
  rc = waveInStart (dev_);
  debug_printf ("%u = waveInStart(), queued=%d", rc, i);
  return (rc == MMSYSERR_NOERROR);
}

bool
fhandler_dev_dsp::Audio_in::read (char *pSampleData, int &nBytes)
{
  int bytes_to_read = nBytes;
  nBytes = 0;
  debug_printf ("pSampleData=%p nBytes=%d", pSampleData, bytes_to_read);
  while (bytes_to_read != 0)
    { // Block till next sound has been read
      if (!waitfordata ())
	{
	  if (nBytes)
	    return true;
	  nBytes = -1;
	  return false;
	}

      // Handle gathering our blocks into smaller or larger buffer
      int sizeleft = pHdr_->dwBytesRecorded - bufferIndex_;
      if (bytes_to_read < sizeleft)
	{ // The current buffer holds more data than requested
	  memcpy (pSampleData, &pHdr_->lpData[bufferIndex_], bytes_to_read);
	  (this->*convert_) ((unsigned char *)pSampleData, bytes_to_read);
	  nBytes += bytes_to_read;
	  bufferIndex_ += bytes_to_read;
	  debug_printf ("got %d", bytes_to_read);
	  break; // done; use remaining data in next call to read
	}
      else
	{ // not enough or exact amount in the current buffer
	  if (sizeleft)
	    { // use up what we have
	      memcpy (pSampleData, &pHdr_->lpData[bufferIndex_], sizeleft);
	      (this->*convert_) ((unsigned char *)pSampleData, sizeleft);
	      nBytes += sizeleft;
	      bytes_to_read -= sizeleft;
	      pSampleData += sizeleft;
	      debug_printf ("got %d", sizeleft);
	    }
	  queueblock (pHdr_); // re-queue this block to ISR
	  pHdr_ = NULL;       // need to wait for a new block
	  // if more samples are needed, we need a new block now
	}
    }
  debug_printf ("end nBytes=%d", nBytes);
  return true;
}

bool
fhandler_dev_dsp::Audio_in::waitfordata ()
{
  WAVEHDR *pHdr;
  MMRESULT rc;

  if (pHdr_ != NULL)
    return true;
  while (!Qisr2app_->recv (&pHdr))
    {
      if (fh->is_nonblocking ())
	{
	  set_errno (EAGAIN);
	  return false;
	}
      debug_printf ("100ms");
      switch (cygwait (100))
	{
	case WAIT_SIGNALED:
	  if (!_my_tls.call_signal_handler ())
	    {
	      set_errno (EINTR);
	      return false;
	    }
	  break;
	case WAIT_CANCELED:
	  pthread::static_cancel_self ();
	  /*NOTREACHED*/
	default:
	  break;
	}
    }
  if (pHdr->dwFlags) /* Zero if queued following error in queueblock */
    {
      /* Errors are ignored here. They will probbaly cause a failure
	 in the subsequent PrepareHeader */
      rc = waveInUnprepareHeader (dev_, pHdr, sizeof (WAVEHDR));
      debug_printf ("%u = waveInUnprepareHeader(%p)", rc, pHdr);
    }
  pHdr_ = pHdr;
  bufferIndex_ = 0;
  return true;
}

void
fhandler_dev_dsp::Audio_in::buf_info (audio_buf_info *p,
				      int rate, int bits, int channels)
{
  p->fragstotal = MAX_BLOCKS;
  p->fragsize = blockSize (rate, bits, channels);
  if (this && dev_)
    {
      p->fragments = Qisr2app_->query ();
      if (pHdr_ != NULL)
	p->bytes = pHdr_->dwBytesRecorded - bufferIndex_
	  + p->fragsize * p->fragments;
      else
	p->bytes = p->fragsize * p->fragments;
    }
  else
    {
      p->fragments = 0;
      p->bytes = 0;
    }
}

inline void
fhandler_dev_dsp::Audio_in::callback_blockfull (WAVEHDR *pHdr)
{
  Qisr2app_->send (pHdr);
}

static void CALLBACK
waveIn_callback (HWAVEIN hWave, UINT msg, DWORD_PTR instance, DWORD_PTR param1,
		 DWORD_PTR param2)
{
  if (msg == WIM_DATA)
    {
      fhandler_dev_dsp::Audio_in *ptr =
	(fhandler_dev_dsp::Audio_in *) instance;
      ptr->callback_blockfull ((WAVEHDR *) param1);
    }
}


/* ------------------------------------------------------------------------
   /dev/dsp handler
   ------------------------------------------------------------------------ */
fhandler_dev_dsp::fhandler_dev_dsp ():
  fhandler_base ()
{
  audio_in_ = NULL;
  audio_out_ = NULL;
  dev ().parse (FH_OSS_DSP);
}

ssize_t __stdcall
fhandler_dev_dsp::write (const void *ptr, size_t len)
{
  return base ()->_write (ptr, len);
}

void __reg3
fhandler_dev_dsp::read (void *ptr, size_t& len)
{
  return base ()->_read (ptr, len);
}

int
fhandler_dev_dsp::ioctl (unsigned int cmd, void *buf)
{
  return base ()->_ioctl (cmd, buf);
}

void
fhandler_dev_dsp::fixup_after_fork (HANDLE parent)
{
  base ()->_fixup_after_fork (parent);
}

void
fhandler_dev_dsp::fixup_after_exec ()
{
  base ()->_fixup_after_exec ();
}


int
fhandler_dev_dsp::open (int flags, mode_t mode)
{
  int ret = 0, err = 0;
  UINT num_in = 0, num_out = 0;
  set_flags ((flags & ~O_TEXT) | O_BINARY);
  // Work out initial sample format & frequency, /dev/dsp defaults
  audioformat_ = AFMT_U8;
  audiofreq_ = 8000;
  audiobits_ = 8;
  audiochannels_ = 1;
  switch (flags & O_ACCMODE)
    {
    case O_RDWR:
      if ((num_in = waveInGetNumDevs ()) == 0)
	err = ENXIO;
      /* Fall through */
    case O_WRONLY:
      if ((num_out = waveOutGetNumDevs ()) == 0)
	err = ENXIO;
      break;
    case O_RDONLY:
      if ((num_in = waveInGetNumDevs ()) == 0)
	err = ENXIO;
      break;
    default:
      err = EINVAL;
    }

  if (err)
    set_errno (err);
  else
    ret = fhandler_base::open (flags, mode);

  debug_printf ("ACCMODE=%y audio_in=%d audio_out=%d, err=%d, ret=%d",
		flags & O_ACCMODE, num_in, num_out, err, ret);
  return ret;
}

#define IS_WRITE() ((get_flags() & O_ACCMODE) != O_RDONLY)
#define IS_READ() ((get_flags() & O_ACCMODE) != O_WRONLY)

ssize_t __stdcall
fhandler_dev_dsp::_write (const void *ptr, size_t len)
{
  debug_printf ("ptr=%p len=%ld", ptr, len);
  int len_s = len;
  const char *ptr_s = static_cast <const char *> (ptr);

  if (audio_out_)
    /* nothing to do */;
  else if (IS_WRITE ())
    {
      debug_printf ("Allocating");
      if (!(audio_out_ = new Audio_out (this)))
	return -1;

      /* check for wave file & get parameters & skip header if possible. */

      if (audio_out_->parsewav (ptr_s, len_s,
				audiofreq_, audiobits_, audiochannels_))
	debug_printf ("=> ptr_s=%p len_s=%d", ptr_s, len_s);
    }
  else
    {
      set_errno (EBADF); // device was opened for read?
      return -1;
    }

  /* Open audio device properly with callbacks.
     Private parameters were set in call to parsewav.
     This is a no-op when there are successive writes in the same process */
  if (!audio_out_->start ())
    {
      set_errno (EIO);
      return -1;
    }

  int written = audio_out_->write (ptr_s, len_s);
  if (written < 0)
    {
      if (len - len_s > 0)
	return len - len_s;
      return -1;
    }
  return len - len_s + written;
}

void __reg3
fhandler_dev_dsp::_read (void *ptr, size_t& len)
{
  debug_printf ("ptr=%p len=%ld", ptr, len);

  if (audio_in_)
    /* nothing to do */;
  else if (IS_READ ())
    {
      debug_printf ("Allocating");
      if (!(audio_in_ = new Audio_in (this)))
	{
	  len = (size_t)-1;
	  return;
	}
      audio_in_->setconvert (audioformat_);
    }
  else
    {
      len = (size_t)-1;
      set_errno (EBADF); // device was opened for write?
      return;
    }

  /* Open audio device properly with callbacks.
     This is a noop when there are successive reads in the same process */
  if (!audio_in_->start (audiofreq_, audiobits_, audiochannels_))
    {
      len = (size_t)-1;
      set_errno (EIO);
      return;
    }

  audio_in_->read ((char *)ptr, (int&)len);
}

void __reg1
fhandler_dev_dsp::close_audio_in ()
{
  if (audio_in_)
    {
      audio_in_->stop ();
      delete audio_in_;
      audio_in_ = NULL;
    }
}

void __reg2
fhandler_dev_dsp::close_audio_out (bool immediately)
{
  if (audio_out_)
    {
      audio_out_->stop (immediately);
      delete audio_out_;
      audio_out_ = NULL;
    }
}

int
fhandler_dev_dsp::close ()
{
  debug_printf ("audio_in=%p audio_out=%p", audio_in_, audio_out_);
  close_audio_in ();
  close_audio_out ();
  return fhandler_base::close ();
}

int
fhandler_dev_dsp::_ioctl (unsigned int cmd, void *buf)
{
  debug_printf ("audio_in=%p audio_out=%p", audio_in_, audio_out_);
  int *intbuf = (int *) buf;
  switch (cmd)
    {
#define CASE(a) case a : debug_printf ("/dev/dsp: ioctl %s", #a);

      CASE (SNDCTL_DSP_RESET)
	close_audio_in ();
	close_audio_out (true);
	return 0;
	break;

      CASE (SNDCTL_DSP_GETBLKSIZE)
	/* This is valid even if audio_X is NULL */
	if (IS_WRITE ())
	  {
	    *intbuf = audio_out_->blockSize (audiofreq_,
					     audiobits_,
					     audiochannels_);
	  }
	else
	  { // I am very sure that IS_READ is valid
	    *intbuf = audio_in_->blockSize (audiofreq_,
					    audiobits_,
					    audiochannels_);
	  }
	return 0;

      CASE (SNDCTL_DSP_SETFMT)
      {
	int nBits;
	switch (*intbuf)
	  {
	  case AFMT_QUERY:
	    *intbuf = audioformat_;
	    return 0;
	    break;
	  case AFMT_U16_BE:
	  case AFMT_U16_LE:
	  case AFMT_S16_BE:
	  case AFMT_S16_LE:
	    nBits = 16;
	    break;
	  case AFMT_U8:
	  case AFMT_S8:
	    nBits = 8;
	    break;
	  default:
	    nBits = 0;
	  }
	if (nBits && IS_WRITE ())
	  {
	    close_audio_out ();
	    if (audio_out_->query (audiofreq_, nBits, audiochannels_))
	      {
		audiobits_ = nBits;
		audioformat_ = *intbuf;
	      }
	    else
	      {
		*intbuf = audiobits_;
		return -1;
	      }
	  }
	if (nBits && IS_READ ())
	  {
	    close_audio_in ();
	    if (audio_in_->query (audiofreq_, nBits, audiochannels_))
	      {
		audiobits_ = nBits;
		audioformat_ = *intbuf;
	      }
	    else
	      {
		*intbuf = audiobits_;
		return -1;
	      }
	  }
	return 0;
      }

      CASE (SNDCTL_DSP_SPEED)
	if (IS_WRITE ())
	  {
	    close_audio_out ();
	    if (audio_out_->query (*intbuf, audiobits_, audiochannels_))
	      audiofreq_ = *intbuf;
	    else
	      {
		*intbuf = audiofreq_;
		return -1;
	      }
	  }
	if (IS_READ ())
	  {
	    close_audio_in ();
	    if (audio_in_->query (*intbuf, audiobits_, audiochannels_))
	      audiofreq_ = *intbuf;
	    else
	      {
		*intbuf = audiofreq_;
		return -1;
	      }
	  }
	return 0;

      CASE (SNDCTL_DSP_STEREO)
      {
	int nChannels = *intbuf + 1;
	int res = _ioctl (SNDCTL_DSP_CHANNELS, &nChannels);
	*intbuf = nChannels - 1;
	return res;
      }

      CASE (SNDCTL_DSP_CHANNELS)
      {
	int nChannels = *intbuf;

	if (IS_WRITE ())
	  {
	    close_audio_out ();
	    if (audio_out_->query (audiofreq_, audiobits_, nChannels))
	      audiochannels_ = nChannels;
	    else
	      {
		*intbuf = audiochannels_;
		return -1;
	      }
	  }
	if (IS_READ ())
	  {
	    close_audio_in ();
	    if (audio_in_->query (audiofreq_, audiobits_, nChannels))
	      audiochannels_ = nChannels;
	    else
	      {
		*intbuf = audiochannels_;
		return -1;
	      }
	  }
	return 0;
      }

      CASE (SNDCTL_DSP_GETOSPACE)
      {
	if (!IS_WRITE ())
	  {
	    set_errno(EBADF);
	    return -1;
	  }
	audio_buf_info *p = (audio_buf_info *) buf;
	audio_out_->buf_info (p, audiofreq_, audiobits_, audiochannels_);
	debug_printf ("buf=%p frags=%d fragsize=%d bytes=%d",
		      buf, p->fragments, p->fragsize, p->bytes);
	return 0;
      }

      CASE (SNDCTL_DSP_GETISPACE)
      {
	if (!IS_READ ())
	  {
	    set_errno(EBADF);
	    return -1;
	  }
	audio_buf_info *p = (audio_buf_info *) buf;
	audio_in_->buf_info (p, audiofreq_, audiobits_, audiochannels_);
	debug_printf ("buf=%p frags=%d fragsize=%d bytes=%d",
		      buf, p->fragments, p->fragsize, p->bytes);
	return 0;
      }

      CASE (SNDCTL_DSP_SETFRAGMENT)
	// Fake!! esound & mikmod require this on non PowerPC platforms.
	//
	return 0;

      CASE (SNDCTL_DSP_GETFMTS)
	*intbuf = AFMT_S16_LE | AFMT_U8; // only native formats returned here
	return 0;

      CASE (SNDCTL_DSP_GETCAPS)
	*intbuf = DSP_CAP_BATCH | DSP_CAP_DUPLEX;
	return 0;

      CASE (SNDCTL_DSP_POST)
      CASE (SNDCTL_DSP_SYNC)
	// Stop audio out device
	close_audio_out ();
	// Stop audio in device
	close_audio_in ();
	return 0;

    default:
      return fhandler_base::ioctl (cmd, buf);
      break;

#undef CASE
    }
}

void
fhandler_dev_dsp::_fixup_after_fork (HANDLE parent)
{ // called from new child process
  debug_printf ("audio_in=%p audio_out=%p",
		audio_in_, audio_out_);

  fhandler_base::fixup_after_fork (parent);
  if (audio_in_)
    audio_in_->fork_fixup (parent);
  if (audio_out_)
    audio_out_->fork_fixup (parent);
}

void
fhandler_dev_dsp::_fixup_after_exec ()
{
  debug_printf ("audio_in=%p audio_out=%p, close_on_exec %d",
		audio_in_, audio_out_, close_on_exec ());
  if (!close_on_exec ())
    {
      audio_in_ = NULL;
      audio_out_ = NULL;
    }
}
@


1.70
log
@* fhandler_dsp.cc (fhandler_dev_dsp::ioctl): Actually pass ioctl argument to
_ioctl.
@
text
@d1306 1
a1306 1
	int res = ioctl (SNDCTL_DSP_CHANNELS, &nChannels);
@


1.69
log
@* fhandler.h (fhandler_dev_dsp): Remove variable names from declarations.
(fhandler_dev_dsp::close_audio_in): Make __reg1.
(fhandler_dev_dsp::close_audio_out): Make __reg2.
* fhandler_dev_dsp.cc (fhandler_dev_dsp::close_audio_in): Make __reg1.
(fhandler_dev_dsp::close_audio_out): Make __reg2.
(fhandler_dev_dsp::close): Don't abruptly terminate sound just because we are
exiting.
@
text
@d1021 1
a1021 1
fhandler_dev_dsp::ioctl (unsigned int cmd, void *)
d1023 1
a1023 1
  return base ()->_ioctl (cmd, NULL);
@


1.68
log
@* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_fork): Actually call
_fixup_after_fork rather than looping forever.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
@
text
@d1163 1
a1163 1
void
d1174 1
a1174 1
void
d1190 1
a1190 1
  close_audio_out (exit_state != ES_NOT_EXITING);
@


1.67
log
@* sigproc.h (no_thread_exit_protect): New class.
* sigproc.cc (thread_exit): Use no_thread_exit_protect to determine if we need
to coordinate ThreadExit/ExitProcess.
* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::stop): Use
no_thread_exit_protect to kludge around waiting for waveOutClose as it waits
for a thread that never exits.
(fhandler_dev_dsp::Audio_in::stop): Ditto for waveInClose.
* fhandler.h (fhandler_dev_dsp::base): New method.
(fhandler_dev_dsp::_read): Ditto.
(fhandler_dev_dsp::_write): Ditto.
(fhandler_dev_dsp::_ioctl): Ditto.
(fhandler_dev_dsp::_fixup_after_fork): Ditto.
(fhandler_dev_dsp::_fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::read): Call real function via base()
pointer.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
(fhandler_dev_dsp::_read): Rename by adding an leading underscore.
(fhandler_dev_dsp::_write): Ditto.
(fhandler_dev_dsp::_ioctl): Ditto.
(fhandler_dev_dsp::_fixup_after_fork): Ditto.
(fhandler_dev_dsp::_fixup_after_exec): Ditto.
@
text
@d1029 1
a1029 1
  base ()->fixup_after_fork (parent);
d1035 1
a1035 1
  base ()->fixup_after_exec ();
@


1.66
log
@	* devices.in (dev_storage): Map /dev/dsp to \Device\Null.
	* devices.cc: Regenerate.
	* fhandler_dsp.cc (fhandler_dev_dsp::open): Call fhandler_base::open.
	(fhandler_dev_dsp::close): Call fhandler_base::close.
	(fhandler_dev_dsp::fixup_after_fork): Call
	fhandler_base::fixup_after_fork.

	* fhandler_raw.cc (fhandler_dev_raw::fixup_after_fork): Call
	fhandler_base::fixup_after_fork.
@
text
@d438 1
d814 1
d1008 31
d1082 1
a1082 1
fhandler_dev_dsp::write (const void *ptr, size_t len)
d1128 1
a1128 1
fhandler_dev_dsp::read (void *ptr, size_t& len)
d1195 1
a1195 1
fhandler_dev_dsp::ioctl (unsigned int cmd, void *buf)
d1398 1
a1398 1
fhandler_dev_dsp::fixup_after_fork (HANDLE parent)
d1411 1
a1411 1
fhandler_dev_dsp::fixup_after_exec ()
@


1.66.2.1
log
@* fhandler.h (fhandler_dev_dsp::base): New method.
(fhandler_dev_dsp::_read): Ditto.
(fhandler_dev_dsp::_write): Ditto.
(fhandler_dev_dsp::_ioctl): Ditto.
(fhandler_dev_dsp::_fixup_after_fork): Ditto.
(fhandler_dev_dsp::_fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::read): Call real function via base()
pointer.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
(fhandler_dev_dsp::_read): Rename by adding an leading underscore.
(fhandler_dev_dsp::_write): Ditto.
(fhandler_dev_dsp::_ioctl): Ditto.
(fhandler_dev_dsp::_fixup_after_fork): Ditto.
(fhandler_dev_dsp::_fixup_after_exec): Ditto.
@
text
@a1005 31
ssize_t __stdcall
fhandler_dev_dsp::write (const void *ptr, size_t len)
{
  return base ()->_write (ptr, len);
}

void __reg3
fhandler_dev_dsp::read (void *ptr, size_t& len)
{
  return base ()->_read (ptr, len);
}

int
fhandler_dev_dsp::ioctl (unsigned int cmd, void *)
{
  return base ()->_ioctl (cmd, NULL);
}

void
fhandler_dev_dsp::fixup_after_fork (HANDLE parent)
{
  base ()->fixup_after_fork (parent);
}

void
fhandler_dev_dsp::fixup_after_exec ()
{
  base ()->fixup_after_exec ();
}


d1049 1
a1049 1
fhandler_dev_dsp::_write (const void *ptr, size_t len)
d1095 1
a1095 1
fhandler_dev_dsp::_read (void *ptr, size_t& len)
d1162 1
a1162 1
fhandler_dev_dsp::_ioctl (unsigned int cmd, void *buf)
d1365 1
a1365 1
fhandler_dev_dsp::_fixup_after_fork (HANDLE parent)
d1378 1
a1378 1
fhandler_dev_dsp::_fixup_after_exec ()
@


1.66.2.2
log
@* sigproc.h (no_thread_exit_protect): New class.
* sigproc.cc (thread_exit): Use no_thread_exit_protect to determine if we need
to coordinate ThreadExit/ExitProcess.
* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::stop): Use
no_thread_exit_protect to kludge around waiting for waveOutClose as it waits
for a thread that never exits.
(fhandler_dev_dsp::Audio_in::stop): Ditto for waveInClose.
@
text
@a437 1
      no_thread_exit_protect for_now (true);
a812 1
      no_thread_exit_protect for_now (true);
@


1.66.2.3
log
@* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_fork): Actually call
_fixup_after_fork rather than looping forever.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
@
text
@d1029 1
a1029 1
  base ()->_fixup_after_fork (parent);
d1035 1
a1035 1
  base ()->_fixup_after_exec ();
@


1.66.2.4
log
@* fhandler.h (fhandler_dev_dsp): Remove variable names from declarations.
(fhandler_dev_dsp::close_audio_in): Make __reg1.
(fhandler_dev_dsp::close_audio_out): Make __reg2.
* fhandler_dev_dsp.cc (fhandler_dev_dsp::close_audio_in): Make __reg1.
(fhandler_dev_dsp::close_audio_out): Make __reg2.
(fhandler_dev_dsp::close): Don't abruptly terminate sound just because we are
exiting.
@
text
@d1163 1
a1163 1
void __reg1
d1174 1
a1174 1
void __reg2
d1190 1
a1190 1
  close_audio_out ();
@


1.66.2.5
log
@* fhandler_dsp.cc (fhandler_dev_dsp::ioctl): Actually pass ioctl argument to
_ioctl.
@
text
@d1021 1
a1021 1
fhandler_dev_dsp::ioctl (unsigned int cmd, void *buf)
d1023 1
a1023 1
  return base ()->_ioctl (cmd, buf);
@


1.66.2.6
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@d1306 1
a1306 1
	int res = _ioctl (SNDCTL_DSP_CHANNELS, &nChannels);
@


1.65
log
@	* fhandler.h (fhandler_dev_zero::lseek): Convert to inline method.
	(class fhandler_dev_random): Drop dummy_offset.
	(fhandler_dev_random::lseek): Convert to inline method.
	(fhandler_dev_dsp::lseek): Ditto.
	* fhandler_dsp.cc (fhandler_dev_dsp::lseek): Drop here.
	* fhandler_random.cc (fhandler_dev_random::open): Drop setting
	dummy_offset.
	(fhandler_dev_random::lseek): Drop here.
	* fhandler_tape.cc (fhandler_dev_tape::lseek): Make no-op, but keep
	old code for reference.
	* fhandler_zero.cc (fhandler_dev_zero::lseek): Drop here.
@
text
@d1009 1
a1009 1
  int err = 0;
d1035 2
a1036 6
  if (!err)
    {
      set_open_status ();
      need_fork_fixup (true);
      nohandle (true);
    }
d1038 1
a1038 1
    set_errno (err);
d1040 3
a1042 3
  debug_printf ("ACCMODE=%y audio_in=%d audio_out=%d, err=%d",
		flags & O_ACCMODE, num_in, num_out, err);
  return !err;
d1158 1
a1158 1
  return 0;
d1370 1
@


1.64
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2008, 2011, 2012 Red Hat, Inc
a1133 6
off_t
fhandler_dev_dsp::lseek (off_t offset, int whence)
{
  return 0;
}

@


1.63
log
@	* Merge in cygwin-64bit-branch.
@
text
@d1098 1
a1098 1
void __stdcall
@


1.62
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d105 3
a107 2
static void CALLBACK waveOut_callback (HWAVEOUT hWave, UINT msg, DWORD instance,
				       DWORD param1, DWORD param2);
d139 3
a141 2
static void CALLBACK waveIn_callback (HWAVEIN hWave, UINT msg, DWORD instance,
				      DWORD param1, DWORD param2);
d370 1
a370 1
  debug_printf ("parent=0x%08x", parent);
d383 1
a383 1
  debug_printf ("%d = waveOutOpen(freq=%d bits=%d channels=%d)", rc, rate, bits, channels);
d405 2
a406 2
  rc = waveOutOpen (&dev_, WAVE_MAPPER, &format, (DWORD) waveOut_callback,
		     (DWORD) this, CALLBACK_FUNCTION);
d410 1
a410 1
  debug_printf ("%d = waveOutOpen(freq=%d bits=%d channels=%d)", rc, freq_, bits_, channels_);
d421 1
a421 1
  debug_printf ("dev_=%08x", (int)dev_);
d431 1
a431 1
      debug_printf ("%d = waveOutReset()", rc);
d435 1
a435 1
	  debug_printf ("%d = waveOutUnprepareHeader(0x%08x)", rc, pHdr);
d439 1
a439 1
      debug_printf ("%d = waveOutClose()", rc);
d569 1
a569 1
      debug_printf ("%d = waveOutUnprepareHeader(0x%08x)", rc, pHdr);
d592 1
a592 1
  debug_printf ("pHdr=0x%08x bytes=%d", pHdr, bufferIndex_);
d604 1
a604 1
  debug_printf ("%d = waveOutPrepareHeader(0x%08x)", rc, pHdr);
d608 1
a608 1
      debug_printf ("%d = waveOutWrite(0x%08x)", rc, pHdr);
d622 2
a623 2
waveOut_callback (HWAVEOUT hWave, UINT msg, DWORD instance, DWORD param1,
		  DWORD param2)
d668 1
a668 1
  if (((int)pData & 0x3) != 0)
d745 1
a745 1
  debug_printf ("parent=0x%08x", parent);
d757 1
a757 1
  debug_printf ("%d = waveInOpen(freq=%d bits=%d channels=%d)", rc, rate, bits, channels);
d779 3
a781 3
  rc = waveInOpen (&dev_, WAVE_MAPPER, &format, (DWORD) waveIn_callback,
		   (DWORD) this, CALLBACK_FUNCTION);
  debug_printf ("%d = waveInOpen(rate=%d bits=%d channels=%d)", rc, rate, bits, channels);
d797 1
a797 1
  debug_printf ("dev_=%08x", (int)dev_);
d805 1
a805 1
      debug_printf ("%d = waveInReset()", rc);
d810 1
a810 1
	  debug_printf ("%d = waveInUnprepareHeader(0x%08x)", rc, pHdr);
d814 1
a814 1
      debug_printf ("%d = waveInClose()", rc);
d825 1
a825 1
  debug_printf ("%d = waveInPrepareHeader(0x%08x)", rc, pHdr);
d829 1
a829 1
      debug_printf ("%d = waveInAddBuffer(0x%08x)", rc, pHdr);
d859 1
a859 1
  debug_printf ("%d = waveInStart(), queued=%d", rc, i);
d868 1
a868 1
  debug_printf ("pSampleData=%08x nBytes=%d", pSampleData, bytes_to_read);
d947 1
a947 1
      debug_printf ("%d = waveInUnprepareHeader(0x%08x)", rc, pHdr);
d983 2
a984 2
waveIn_callback (HWAVEIN hWave, UINT msg, DWORD instance, DWORD param1,
		 DWORD param2)
d1044 1
a1044 1
  debug_printf ("ACCMODE=0x%08x audio_in=%d audio_out=%d, err=%d",
d1055 1
a1055 1
  debug_printf ("ptr=%08x len=%d", ptr, len);
d1071 1
a1071 1
	debug_printf ("=> ptr_s=%08x len_s=%d", ptr_s, len_s);
d1101 1
a1101 1
  debug_printf ("ptr=%08x len=%d", ptr, len);
d1134 2
a1135 2
_off64_t
fhandler_dev_dsp::lseek (_off64_t offset, int whence)
d1165 1
a1165 2
  debug_printf ("audio_in=%08x audio_out=%08x",
		(int)audio_in_, (int)audio_out_);
d1174 1
a1174 2
  debug_printf ("audio_in=%08x audio_out=%08x",
		(int)audio_in_, (int)audio_out_);
d1377 2
a1378 2
  debug_printf ("audio_in=%08x audio_out=%08x",
		(int)audio_in_, (int)audio_out_);
d1389 2
a1390 2
  debug_printf ("audio_in=%08x audio_out=%08x, close_on_exec %d",
		(int) audio_in_, (int) audio_out_, close_on_exec ());
@


1.62.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d1132 2
a1133 2
off_t
fhandler_dev_dsp::lseek (off_t offset, int whence)
@


1.62.2.2
log
@	* cpuid.h (can_set_flag): Implement for x86_64.
	* fhandler.h (class fhandler_dev_raw): Define devbuf members taking
	numerical values as DWORD, rather than size_t.
	* fhandler_dsp.cc: Fix debug printf calls to be type safe.
	(waveOut_callback): Align parameter types to latest MSDN description.
	(waveIn_callback): Ditto.
	(fhandler_dev_dsp::Audio_out::start): Change casts in call to
	waveOutOpen according to MSDN.
	(fhandler_dev_dsp::Audio_out::parsewav): Fix a cast.
	(fhandler_dev_dsp::Audio_in::start): Change casts in call to
	waveInOpen according to MSDN.
	* fhandler_floppy.cc: Fix debug printf calls to be type safe.
	(fhandler_dev_floppy::ioctl): Add casts to be on the safe side.
	* fhandler_proc.cc: Fix debug printf calls to be type safe.
@
text
@d105 2
a106 3
static void CALLBACK waveOut_callback (HWAVEOUT hWave, UINT msg,
				       DWORD_PTR instance, DWORD_PTR param1,
				       DWORD_PTR param2);
d138 2
a139 3
static void CALLBACK waveIn_callback (HWAVEIN hWave, UINT msg,
				      DWORD_PTR instance, DWORD_PTR param1,
				      DWORD_PTR param2);
d403 2
a404 2
  rc = waveOutOpen (&dev_, WAVE_MAPPER, &format, (DWORD_PTR) waveOut_callback,
		     (DWORD_PTR) this, CALLBACK_FUNCTION);
d419 1
a419 1
  debug_printf ("dev_=%p", dev_);
d620 2
a621 2
waveOut_callback (HWAVEOUT hWave, UINT msg, DWORD_PTR instance,
		  DWORD_PTR param1, DWORD_PTR param2)
d666 1
a666 1
  if (((uintptr_t)pData & 0x3) != 0)
d777 2
a778 2
  rc = waveInOpen (&dev_, WAVE_MAPPER, &format, (DWORD_PTR) waveIn_callback,
		   (DWORD_PTR) this, CALLBACK_FUNCTION);
d795 1
a795 1
  debug_printf ("dev_=%p", dev_);
d981 2
a982 2
waveIn_callback (HWAVEIN hWave, UINT msg, DWORD_PTR instance, DWORD_PTR param1,
		 DWORD_PTR param2)
d1163 2
a1164 1
  debug_printf ("audio_in=%p audio_out=%p", audio_in_, audio_out_);
d1173 2
a1174 1
  debug_printf ("audio_in=%p audio_out=%p", audio_in_, audio_out_);
d1377 2
a1378 2
  debug_printf ("audio_in=%p audio_out=%p",
		audio_in_, audio_out_);
d1389 2
a1390 2
  debug_printf ("audio_in=%p audio_out=%p, close_on_exec %d",
		audio_in_, audio_out_, close_on_exec ());
@


1.62.2.3
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d370 1
a370 1
  debug_printf ("parent=%p", parent);
d383 1
a383 1
  debug_printf ("%u = waveOutOpen(freq=%d bits=%d channels=%d)", rc, rate, bits, channels);
d410 1
a410 1
  debug_printf ("%u = waveOutOpen(freq=%d bits=%d channels=%d)", rc, freq_, bits_, channels_);
d431 1
a431 1
      debug_printf ("%u = waveOutReset()", rc);
d435 1
a435 1
	  debug_printf ("%u = waveOutUnprepareHeader(%p)", rc, pHdr);
d439 1
a439 1
      debug_printf ("%u = waveOutClose()", rc);
d569 1
a569 1
      debug_printf ("%u = waveOutUnprepareHeader(%p)", rc, pHdr);
d592 1
a592 1
  debug_printf ("pHdr=%p bytes=%d", pHdr, bufferIndex_);
d604 1
a604 1
  debug_printf ("%u = waveOutPrepareHeader(%p)", rc, pHdr);
d608 1
a608 1
      debug_printf ("%u = waveOutWrite(%p)", rc, pHdr);
d745 1
a745 1
  debug_printf ("parent=%p", parent);
d757 1
a757 1
  debug_printf ("%u = waveInOpen(freq=%d bits=%d channels=%d)", rc, rate, bits, channels);
d781 1
a781 1
  debug_printf ("%u = waveInOpen(rate=%d bits=%d channels=%d)", rc, rate, bits, channels);
d805 1
a805 1
      debug_printf ("%u = waveInReset()", rc);
d810 1
a810 1
	  debug_printf ("%u = waveInUnprepareHeader(%p)", rc, pHdr);
d814 1
a814 1
      debug_printf ("%u = waveInClose()", rc);
d825 1
a825 1
  debug_printf ("%u = waveInPrepareHeader(%p)", rc, pHdr);
d829 1
a829 1
      debug_printf ("%u = waveInAddBuffer(%p)", rc, pHdr);
d859 1
a859 1
  debug_printf ("%u = waveInStart(), queued=%d", rc, i);
d868 1
a868 1
  debug_printf ("pSampleData=%p nBytes=%d", pSampleData, bytes_to_read);
d947 1
a947 1
      debug_printf ("%u = waveInUnprepareHeader(%p)", rc, pHdr);
d1044 1
a1044 1
  debug_printf ("ACCMODE=%y audio_in=%d audio_out=%d, err=%d",
d1055 1
a1055 1
  debug_printf ("ptr=%p len=%ld", ptr, len);
d1071 1
a1071 1
	debug_printf ("=> ptr_s=%p len_s=%d", ptr_s, len_s);
d1101 1
a1101 1
  debug_printf ("ptr=%p len=%ld", ptr, len);
@


1.61
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::write): Set
	bytes_to_write to 0 in case it fits into the buffer, otherwise suffer
	early EOF in caller.
@
text
@d24 1
d548 1
a548 1
	case WAIT_OBJECT_0:
d555 1
a555 1
	case WAIT_OBJECT_0 + 1:
d926 1
a926 1
	case WAIT_OBJECT_0:
d933 1
a933 1
	case WAIT_OBJECT_0 + 1:
@


1.60
log
@* fhandler_dsp.cc (fhandler_dev_dsp::fhandler_dev_dsp): Set up device.
* syscalls.cc (open): Very minor formatting tweak.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2008, 2011 Red Hat, Inc
d481 1
@


1.59
log
@Rename cygWFMO to cygwait throughout and use the magic of polymorphism to "wait
for stuff".
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use simplified arg
form of cygwait.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_audio.cc (fhandler_dev_dsp::Audio_out::waitforspac): Ditto.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* select.cc (cygwin_select): Ditto.
* sigproc.h (cygwait): Rename from cygWFMO.  Define two argument and single
argument forms of this function.
* fhandler_tty.cc (fhandler_pty_slave::open): Use method to query if tty is
open.
(fhandler_pty_slave::read): Send SIGHUP when master is detected as closed.
(fhandler_pty_common::close): Close input_available_event in callers since
master may need to signal it first.
(fhandler_pty_master::close): Lie and set input_available_event when closing,
then close input_available_event.
(fhandler_pty_slave::close): Close input_available_event explicitly here.
* tty.h (tty::is_master_closed): Declare new method.
@
text
@a996 1
  debug_printf ("0x%08x", (int)this);
d999 1
@


1.58
log
@* sigproc.cc (cygWFMO): Don't assume that cancellable event is always
available.
* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::waitforspace): Use cygWFMO
instead of WaitForMultipleObjects.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto for degenerate case.
@
text
@d544 1
a544 1
      switch (cygWFMO (0, 100))
d922 1
a922 1
      switch (cygWFMO (0, 100))
@


1.57
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@a542 2
      HANDLE w4[2] = { signal_arrived, pthread::get_cancel_event () };
      DWORD cnt = w4[1] ? 2 : 1;
d544 1
a544 1
      switch (WaitForMultipleObjects (cnt, w4, FALSE, 100))
a920 2
      HANDLE w4[2] = { signal_arrived, pthread::get_cancel_event () };
      DWORD cnt = w4[1] ? 2 : 1;
d922 1
a922 1
      switch (WaitForMultipleObjects (cnt, w4, FALSE, 100))
@


1.56
log
@Corinna Vinschen <corinna@@vinschen.de>
* fhandler.cc: Add #include for asm/socket.h for dealing with FIONREAD.
(fhandler_base::ioctl): Special-case errno for FIONREAD.
* fhandler_dsp.cc (fhandler_dev_dsp::ioctl): Rename parameter for consistency.
Call fhandler_base::ioctl to decode default condition.
* fhandler_serial.cc (fhandler_serial::ioctl): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Call fhandler_base::ioctl to
decode default condition.
* fhandler_windows.cc (fhandler_windows::ioctl): Ditto.
@
text
@d380 1
a380 1
  debug_printf ("%d = waveOutOpen (freq=%d bits=%d channels=%d)", rc, rate, bits, channels);
d407 1
a407 1
  debug_printf ("%d = waveOutOpen (freq=%d bits=%d channels=%d)", rc, freq_, bits_, channels_);
d428 1
a428 1
      debug_printf ("%d = waveOutReset ()", rc);
d432 1
a432 1
	  debug_printf ("%d = waveOutUnprepareHeader (0x%08x)", rc, pHdr);
d436 1
a436 1
      debug_printf ("%d = waveOutClose ()", rc);
d567 1
a567 1
      debug_printf ("%d = waveOutUnprepareHeader (0x%08x)", rc, pHdr);
d602 1
a602 1
  debug_printf ("%d = waveOutPrepareHeader (0x%08x)", rc, pHdr);
d606 1
a606 1
      debug_printf ("%d = waveOutWrite (0x%08x)", rc, pHdr);
d755 1
a755 1
  debug_printf ("%d = waveInOpen (freq=%d bits=%d channels=%d)", rc, rate, bits, channels);
d779 1
a779 1
  debug_printf ("%d = waveInOpen (rate=%d bits=%d channels=%d)", rc, rate, bits, channels);
d803 1
a803 1
      debug_printf ("%d = waveInReset ()", rc);
d808 1
a808 1
	  debug_printf ("%d = waveInUnprepareHeader (0x%08x)", rc, pHdr);
d812 1
a812 1
      debug_printf ("%d = waveInClose ()", rc);
d823 1
a823 1
  debug_printf ("%d = waveInPrepareHeader (0x%08x)", rc, pHdr);
d827 1
a827 1
      debug_printf ("%d = waveInAddBuffer (0x%08x)", rc, pHdr);
d857 1
a857 1
  debug_printf ("%d = waveInStart (), queued=%d", rc, i);
d947 1
a947 1
      debug_printf ("%d = waveInUnprepareHeader (0x%08x)", rc, pHdr);
@


1.55
log
@whitespace elimination
@
text
@d1173 1
a1173 1
fhandler_dev_dsp::ioctl (unsigned int cmd, void *ptr)
d1177 1
a1177 1
  int *intptr = (int *) ptr;
d1192 1
a1192 1
	    *intptr = audio_out_->blockSize (audiofreq_,
d1198 1
a1198 1
	    *intptr = audio_in_->blockSize (audiofreq_,
d1207 1
a1207 1
	switch (*intptr)
d1210 1
a1210 1
	    *intptr = audioformat_;
d1232 1
a1232 1
		audioformat_ = *intptr;
d1236 1
a1236 1
		*intptr = audiobits_;
d1246 1
a1246 1
		audioformat_ = *intptr;
d1250 1
a1250 1
		*intptr = audiobits_;
d1261 2
a1262 2
	    if (audio_out_->query (*intptr, audiobits_, audiochannels_))
	      audiofreq_ = *intptr;
d1265 1
a1265 1
		*intptr = audiofreq_;
d1272 2
a1273 2
	    if (audio_in_->query (*intptr, audiobits_, audiochannels_))
	      audiofreq_ = *intptr;
d1276 1
a1276 1
		*intptr = audiofreq_;
d1284 1
a1284 1
	int nChannels = *intptr + 1;
d1286 1
a1286 1
	*intptr = nChannels - 1;
d1292 1
a1292 1
	int nChannels = *intptr;
d1301 1
a1301 1
		*intptr = audiochannels_;
d1312 1
a1312 1
		*intptr = audiochannels_;
d1326 1
a1326 1
	audio_buf_info *p = (audio_buf_info *) ptr;
d1328 2
a1329 2
	debug_printf ("ptr=%p frags=%d fragsize=%d bytes=%d",
		      ptr, p->fragments, p->fragsize, p->bytes);
d1340 1
a1340 1
	audio_buf_info *p = (audio_buf_info *) ptr;
d1342 2
a1343 2
	debug_printf ("ptr=%p frags=%d fragsize=%d bytes=%d",
		      ptr, p->fragments, p->fragsize, p->bytes);
d1353 1
a1353 1
	*intptr = AFMT_S16_LE | AFMT_U8; // only native formats returned here
d1357 1
a1357 1
	*intptr = DSP_CAP_BATCH | DSP_CAP_DUPLEX;
d1369 1
a1369 1
      debug_printf ("/dev/dsp: ioctl 0x%08x not handled yet! FIXME:", cmd);
d1373 1
a1373 3
    };
  set_errno (EINVAL);
  return -1;
@


1.54
log
@* cygheap.cc (cygheap::close_ctty): Close ctty via close_with_arch().
* debug.cc (close_handle): Call debugger on failure.
* devices.in (device::tty_to_real_device): Delete.
* devices.h (device::tty_to_real_device): Ditto.
* devices.cc: Regenerate.
* dtable.cc: Delete old ifdef'ed vfork code.
(dtable::release): Don't handle archetype here.
(dtable::init_std_file_from_handle): Consolidate console tests.  Generate
major/minor for tty ASAP.  Fix incorrect setting of DEV_TTYS* for serial.
(fh_alloc): New function derived from build_fh_pc.  Pass current tty when
building tty.
(build_pc_pc): Use fh_alloc to create.  Set name from fh->dev if appropriate.
Generate an archetype or point to one here.
(dtable::dup_worker): Deal with archetypes.  Rely on = operator copying whole
class rather than just fhandler_base.
(dtable::fixup_after_exec): Call close_with_arch to handle closing of fhandlers
with archetypes.
* fhandler.cc (fhandler_base::operator =): Call memcpy with fhandler's size()
rather than sizeof fhandler_base.
(fhandler_base::open_with_arch): New function.  Handles opening of fhandler's
with archetypes, dealing with usecounts, etc.
(fhandler_base::close_with_arch): Ditto for close.
* fhandler.h: Many changes for archetypes.
(fhandler_base::set_name): Set both normalized path and regular path.
(fhandler_base::open_with_arch): New function.
(fhandler_base::open_setup): Ditto.
(fhandler_base::use_archetype): Ditto.
(fhandler_base::_archetype_usecount): Ditto.
(fhandler_*::size): Ditto.
(fhandler_dev_tape::open): Remove virtual decoration.
(fhandler_console::use_archetype): New function.  Return true.
(fhandler_console::open_setup): New function.
(fhandler_console::dup): Delete.
(fhandler_tty_slave::fhandler_tty_slave): Redeclare to take an argument.
(fhandler_tty_slave::use_archetype): New function.  Return true.
(fhandler_tty_slave::cleanup): New function.
(fhandler_pty_master::use_archetype): New function.  Return true.
(fhandler_pty_master::cleanup): New function.
(fhandler_pty_master::is_tty_master): New function.  Return false.
(fhandler_tty_master::is_tty_master): New function.  Return true.
(fhandler_dev_dsp::fhandler_dev_dsp): New function.  Return true.
(report_tty_counts): Only report on archetype's usecount if there is one.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove handling of
setsid, set_ctty, set_flags, and manage_console_count.
(fhandler_console::open_setup): New function.  Implement functionality removed
from get_tty_stuff.
(fhandler_console::dup): Delete.
(fhandler_console::output_tcsetattr): Set errno on error.
(fhandler_console::fhandler_console): Set device early.
(fhandler_console::init): Use open_with_arch to open console handles.
(fhandler_console::fixup_after_fork_exec): Nuke most of the stuff for dealing
with console handles.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Remove archetype handling.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
(fhandler_dev_dsp::close): Ditto.
(fhandler_dev_dsp::dup): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Add a little
more debugging.
(fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_pty_master::process_slave_output): Ditto.  Don't do signal handling
or pthread_cancel handling in the tty master thread.
(process_output): Minor reorg.
(fhandler_tty_slave::fhandler_tty_slave): Set device based on new ntty
argument.
(fhandler_tty_slave::open): Remove archetype handling.  Move some processing
into open_setup().
(fhandler_tty_slave::open_setup): New function.
(fhandler_tty_slave::cleanup): New function.
(fhandler_tty_slave::close): Remove archetype handling.  Move some processing
into cleanup().
(fhandler_tty_slave::init): Rename argument from f to h.  Open device using
open_with_arch().  Remove archetype handling.
(fhandler_pty_master::dup): Ditto.
(fhandler_pty_master::open): Ditto.
(fhandler_pty_master::close): Ditto.  Move some handling to cleanup().
(fhandler_pty_master::cleanup): New function.
(fhandler_tty_master::init_console): Give unique name to captive console
fhandler.
* pinfo.cc (_pinfo::set_ctty): Rename argument from arch to fh.  Eliminate
archetype assumption.
* syscalls.cc (close_all_files): Use close_with_arch for closing.
(open): Use open_with_arch() rather than open().
(close): Use close_with_arch() rather than close().
@
text
@d1 1
a1 1
/* Fhandler_dev_dsp: code to emulate OSS sound model /dev/dsp
d870 1
a870 1
      	{
@


1.53
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::Audio): Add fh member.
	(fhandler_dev_dsp::Audio_out::Audio_out): Take pointer to encapsulating
	fhandler_dev_dsp as parameter.
	(fhandler_dev_dsp::Audio_in::Audio_in): Ditto.
	(fhandler_dev_dsp::Audio::Audio): Take pointer to encapsulating
	fhandler_dev_dsp as parameter and store in fh.
	(fhandler_dev_dsp::Audio_out::write): Change return type to int and
	return number of bytes written.  Return -1 if waitforspace returns false
	and no bytes have been written so far.
	(fhandler_dev_dsp::Audio_out::waitforspace): Change return type to bool.
	Handle O_NONBLOCK.  Make waiting loop interruptible and cancelable.
	Return false in any of these cases, otherwise true.
	(fhandler_dev_dsp::Audio_in::read): Set returned nBytes to -1 if
	waitfordata returns false and nothing has been read so far.
	(fhandler_dev_dsp::Audio_in::waitfordata): Change return type to bool.
	Handle O_NONBLOCK.  Make waiting loop interruptible and cancelable.
	Return false in any of these cases, otherwise true.
	(fhandler_dev_dsp::write): Call Audio_out constructor with this as
	parameter.
	(fhandler_dev_dsp::read): Call Audio_in constructor with this as
	parameter.
@
text
@a1008 5
  if (cygheap->fdtab.find_archetype (dev ()))
    {
      set_errno (EBUSY);
      return 0;
    }
a1039 7

      // FIXME: Do this better someday
      fhandler_dev_dsp *arch = (fhandler_dev_dsp *) cmalloc_abort (HEAP_ARCHETYPES, sizeof (*this));
      archetype = arch;
      *((fhandler_dev_dsp **) cygheap->fdtab.add_archetype ()) = arch;
      *arch = *this;
      archetype->usecount = 1;
a1055 3
  if ((fhandler_dev_dsp *) archetype != this)
    return ((fhandler_dev_dsp *)archetype)->write(ptr, len);

a1101 2
  if ((fhandler_dev_dsp *) archetype != this)
    return ((fhandler_dev_dsp *)archetype)->read(ptr, len);
d1167 2
a1168 21
  if (!hExeced)
    {
      if ((fhandler_dev_dsp *) archetype != this)
	return ((fhandler_dev_dsp *) archetype)->close ();

      if (--usecount == 0)
	{
	  close_audio_in ();
	  close_audio_out (exit_state != ES_NOT_EXITING);
	}
    }
  return 0;
}

int
fhandler_dev_dsp::dup (fhandler_base * child)
{
  debug_printf ("");
  child->archetype = archetype;
  child->set_flags (get_flags ());
  archetype->usecount++;
a1176 3
  if ((fhandler_dev_dsp *) archetype != this)
    return ((fhandler_dev_dsp *)archetype)->ioctl(cmd, ptr);

a1382 2
  if (archetype != this)
    return ((fhandler_dev_dsp *)archetype)->fixup_after_fork (parent);
d1385 1
a1385 1
    audio_in_ ->fork_fixup (parent);
a1396 3
      if (archetype != this)
	return ((fhandler_dev_dsp *) archetype)->fixup_after_exec ();

@


1.52
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2008 Red Hat, Inc
d23 1
d53 1
a53 1
   Audio ();
d78 2
d110 2
d116 1
a116 1
  bool write (const char *pSampleData, int nBytes);
d125 1
a125 1
  void waitforspace ();
d143 2
d156 1
a156 1
  void waitfordata (); // blocks until we have a good pHdr_
d232 1
a232 1
fhandler_dev_dsp::Audio::Audio ()
d237 1
d463 1
a463 1
bool
d466 2
a467 1
  while (nBytes != 0)
d469 6
a474 1
      waitforspace ();
d477 1
a477 1
      if (nBytes < sizeleft)
d479 2
a480 2
	  memcpy (&pHdr_->lpData[bufferIndex_], pSampleData, nBytes);
	  bufferIndex_ += nBytes;
d489 1
a489 1
	  nBytes -= sizeleft;
d492 1
a492 1
  return true;
d528 1
a528 1
void
d535 1
a535 1
    return;
d538 7
d546 15
a560 1
      Sleep (100);
d571 1
d869 7
a875 1
      waitfordata ();
d908 1
a908 1
void
d915 1
a915 1
    return;
d918 7
d926 15
a940 1
      Sleep (100);
d951 1
d1079 1
a1079 1
      if (!(audio_out_ = new Audio_out))
d1103 8
a1110 2
  audio_out_->write (ptr_s, len_s);
  return len;
d1125 1
a1125 1
      if (!(audio_in_ = new Audio_in))
@


1.51
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d1000 1
a1000 1
int
@


1.50
log
@Remove unneeded header files from source files throughout.
@
text
@d1010 6
a1015 16
  if (!audio_out_)
    if (IS_WRITE ())
      {
	debug_printf ("Allocating");
	if (!(audio_out_ = new Audio_out))
	  return -1;

	/* check for wave file & get parameters & skip header if possible. */

	if (audio_out_->parsewav (ptr_s, len_s,
				  audiofreq_, audiobits_, audiochannels_))
	  debug_printf ("=> ptr_s=%08x len_s=%d", ptr_s, len_s);
      }
    else
      {
	set_errno (EBADF); // device was opened for read?
d1017 12
a1028 1
      }
d1050 18
a1067 17
  if (!audio_in_)
    if (IS_READ ())
      {
	debug_printf ("Allocating");
	if (!(audio_in_ = new Audio_in))
	  {
	    len = (size_t)-1;
	    return;
	  }
	audio_in_->setconvert (audioformat_);
      }
    else
      {
	len = (size_t)-1;
	set_errno (EBADF); // device was opened for write?
	return;
      }
@


1.49
log
@	* Fix copyright dates.
@
text
@a15 2
#include <stdio.h>
#include <windows.h>
a16 1
#include <mmsystem.h>
@


1.48
log
@	* dtable.cc (dtable::init_std_file_from_handle): Set access to
	read/write of handle is connected to a tty or console.
	* fhandler_dsp.cc (fhandler_dev_dsp::dup): Set open flags correctly
	after duplicating from archetype.
	* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
	(fhandler_pty_master::dup): Ditto.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004 Red Hat, Inc
@


1.47
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d1134 1
@


1.46
log
@* cygthread.cc (cygthread::terminate_thread): In debugging output, use name of
thread being terminated rather than thread doing terminating.
* fhandler.h (fhandler_pty_master::slave): Delete.
(fhandler_pty_master::get_unit): Ditto.
(fhandler_pty_master::setup): Change argument declaration to accommodate new
usage.
* fhandler_tty.cc (fhandler_tty_master::init): Remove obsolete slave
assignment.  Pass argument to setup indicating that this is a tty.
(fhandler_tty_slave::open): Use dev() method rather than referencing pc.dev
directly.
(fhandler_pty_master::open): Don't create archetype based on ptym device
number.  Set device number to use DEV_TTYM_MAJOR and tty number.  Pass argument
to setup indicating that this is a pty.
(fhandler_pty_master::setup): Change single argument to a flag indicating
whether we're creating a pty and use appropriately.  Calculate 't' variable
here rather than in caller.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Use dev() method rather than
referencing pc.dev directly.
@
text
@d986 1
a986 1
      fhandler_dev_dsp *arch = (fhandler_dev_dsp *) cmalloc (HEAP_ARCHETYPES, sizeof (*this));
@


1.46.4.1
log
@	* dtable.cc (dtable::init_std_file_from_handle): Set access to
	read/write if handle is connected to a tty or console.
	* fhandler_dsp.cc (fhandler_dev_dsp::dup): Set open flags correctly
	after duplicating from archetype.
	* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
	(fhandler_pty_master::dup): Ditto.
@
text
@a1133 1
  child->set_flags (get_flags ());
@


1.45
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@d948 1
a948 1
  if (cygheap->fdtab.find_archetype (pc.dev))
@


1.44
log
@	Revert erroneous checkin.
@
text
@d1364 6
a1369 4
  debug_printf ("audio_in=%08x audio_out=%08x",
		(int)audio_in_, (int)audio_out_);
  if (archetype != this)
    return ((fhandler_dev_dsp *)archetype)->fixup_after_exec ();
d1371 3
a1373 2
  audio_in_ = NULL;
  audio_out_ = NULL;
@


1.43
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d1130 1
a1130 1
fhandler_dev_dsp::dup (fhandler_base * child, HANDLE from_proc)
@


1.42
log
@Remove some more unneeded 'return;'s throughout.
@
text
@d1130 1
a1130 1
fhandler_dev_dsp::dup (fhandler_base * child)
@


1.41
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@a1079 1
  return;
@


1.40
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d1112 1
a1112 1
fhandler_dev_dsp::close (void)
d1116 4
a1119 2
  if ((fhandler_dev_dsp *) archetype != this)
    return ((fhandler_dev_dsp *)archetype)->close ();
d1121 5
a1125 4
  if (--usecount == 0)
    {
      close_audio_in ();
      close_audio_out (exit_state != ES_NOT_EXITING);
a1348 6
fhandler_dev_dsp::dump ()
{
  paranoid_printf ("here");
}

void
@


1.39
log
@	* fhandler.h (fhandler_dev_dsp:~fhandler_dev_dsp): Delete.
	(fhandler_dev_dsp::open_count): Delete.
	(fhandler_dev_dsp::close_audio_in): New method declaration.
	(fhandler_dev_dsp::close_audio_in): Ditto.
	* fhandler_dsp.cc: Add and edit debug_printf throughout.
	(fhandler_dev_dsp::Audio::denyAccess): Delete.
	(fhandler_dev_dsp::Audio::fork_fixup): Ditto.
	(fhandler_dev_dsp::Audio::getOwner): Ditto.
	(fhandler_dev_dsp::Audio::clearOwner): Ditto.
	(fhandler_dev_dsp::Audio::owner_): Ditto.
	(fhandler_dev_dsp::Audio::setformat): Ditto, rename to setconvert.
	(fhandler_dev_dsp::Audio::lock): Ditto, move to queue.
	(fhandler_dev_dsp::Audio::unlock): Ditto.
	(fhandler_dev_dsp::Audio::lock_): Ditto.
	(fhandler_dev_dsp::Audio::bufferIndex_): New member, from Audio_out
	and Audio_in.
	(fhandler_dev_dsp::Audio::pHdr_): Ditto.
	(fhandler_dev_dsp::Audio::wavehdr_): Ditto.
	(fhandler_dev_dsp::Audio::bigwavebuffer_): ditto.
	(fhandler_dev_dsp::Audio::Qisr2app_): Ditto.
	(fhandler_dev_dsp::Audio::setconvert): New method, from old setformat.
	(fhandler_dev_dsp::Audio::queue::lock): New method.
	(fhandler_dev_dsp::Audio::queue::unlock): Ditto.
	(fhandler_dev_dsp::Audio::queue::dellock): Ditto.
	(fhandler_dev_dsp::Audio::queue::isvalid): Ditto.
	(fhandler_dev_dsp::Audio::queue::lock_): New member.
	(fhandler_dev_dsp::Audio::queue::depth1_): Delete.
	(fhandler_dev_dsp::Audio_out::fork_fixup): New method.
	(fhandler_dev_dsp::Audio_out::isvalid): New method.
	(fhandler_dev_dsp::Audio_out::start): Remove arguments.
	(fhandler_dev_dsp::Audio_out::parsewav): Change arguments and set
	internal state.
	(fhandler_dev_dsp::Audio_out::emptyblocks): Delete.
	(fhandler_dev_dsp::Audio_out::Qapp2app_): Ditto.
	(fhandler_dev_dsp::Audio_out::Qisr2app_): Ditto, move to Audio.
	(fhandler_dev_dsp::Audio_out::bufferIndex_): Ditto.
	(fhandler_dev_dsp::Audio_out::pHdr_): Ditto.
	(fhandler_dev_dsp::Audio_out::wavehdr_): Ditto.
	(fhandler_dev_dsp::Audio_out::bigwavefuffer_): Ditto.
	(fhandler_dev_dsp::Audio_out::freq_): New member.
	(fhandler_dev_dsp::Audio_out::bits_): New member.
	(fhandler_dev_dsp::Audio_out::channels_): New member.
	(fhandler_dev_dsp::Audio_in::fork_fixup): New method.
	(fhandler_dev_dsp::Audio_in::isvalid): New method.
	(fhandler_dev_dsp::Audio_in::Qapp2app_): Delete.
	(fhandler_dev_dsp::Audio_in::Qisr2app_): Ditto, move to Audio.
	(fhandler_dev_dsp::Audio_in::bufferIndex_): Ditto.
	(fhandler_dev_dsp::Audio_in::pHdr_): Ditto.
	(fhandler_dev_dsp::Audio_in::wavehdr_): Ditto.
	(fhandler_dev_dsp::Audio_in::bigwavefuffer_): Ditto.
	(fhandler_dev_dsp::Audio::queue::queue): Simplify.
	(fhandler_dev_dsp::Audio::queue::send): Use lock.
	(fhandler_dev_dsp::Audio::queue::query): Do not use depth1_.
	(fhandler_dev_dsp::Audio::queue::recv): Ditto.
	(fhandler_dev_dsp::Audio::Audio): Adapt to new class members.
	(fhandler_dev_dsp::Audio::~Audio): Ditto
	(fhandler_dev_dsp::Audio_out::start): Reorganize.
	(fhandler_dev_dsp::Audio_out::stop): Simplify.
	(fhandler_dev_dsp::Audio_out::init): Reset the queue and clear flag.
	(fhandler_dev_dsp::Audio_out::write): Reorganize to allocate audio_out.
	(fhandler_dev_dsp::Audio_out::buf_info): Use appropriate block size.
	(fhandler_dev_dsp::Audio_out::callback_sampledone): Do not use lock.
	(fhandler_dev_dsp::Audio_out::waitforspace): Simplify.
	(fhandler_dev_dsp::Audio_out::waitforallsent):Ditto.
	(fhandler_dev_dsp::Audio_out::sendcurrent): Reorganize.
	Clear flag before requeuing.
	(fhandler_dev_dsp::Audio_out::parsewav):
	(fhandler_dev_dsp::Audio_in::start): Reorganize.
	(fhandler_dev_dsp::Audio_in::stop): Simplify.
	(fhandler_dev_dsp::Audio_in::queueblock): Ditto.
	Requeue header in case of error.
	(fhandler_dev_dsp::Audio_in::init): Reset the queue and clear flag.
	(fhandler_dev_dsp::Audio_in::waitfordata): Simplify.
	Do not UnprepareHeader if the flag is zero.
	(fhandler_dev_dsp::Audio_in::buf_info): Ditto.
	(fhandler_dev_dsp::Audio_in::callback_blockfull): Do not use lock.
	(fhandler_dev_dsp::open_count): Delete.
	(fhandler_dev_dsp::open): Only check existence, do not allocate
	anything. Set flags appropriately. Create archetype.
	(fhandler_dev_dsp::write): Call archetype as needed. Create audio_out.
	(fhandler_dev_dsp::read): Call archetype as needed. Create audio_in.
	(fhandler_dev_dsp::close): Call archetype as needed.
	Call close_audio_in and close_audio_out.
	(fhandler_dev_dsp::close_audio_in): New function.
	(fhandler_dev_dsp::close_audio_out): New function.
	(fhandler_dev_dsp::dup): Use archetypes.
	(fhandler_dev_dsp::ioctl): Call archetype as needed. Reorganize for
	new structures.
	(fhandler_dev_dsp::fixup_after_fork): Call archetype as needed.
	(fhandler_dev_dsp::fixup_after_exec): Call archetype as needed.
	Clear audio_in and audio_out.
@
text
@d885 1
a885 1
         in the subsequent PrepareHeader */
d1152 1
a1152 1
        return 0;
d1331 2
a1332 2
        // Stop audio in device
        close_audio_in ();
@


1.38
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::init): Fix non-ISO
	expression.
	* fhandler_floppy.cc (fhandler_dev_floppy::open): Remove unused
	variable.
	* fhandler_proc.cc (format_proc_meminfo): Fix compiler warning.
@
text
@d1 1
a1 1
/* fhandler_dev_dsp: code to emulate OSS sound model /dev/dsp
d24 2
d31 1
a31 1
  1. Audio buffers are created dynamically just before the first read or
d40 4
d45 1
a45 3
  2. Every open call creates a new instance of the handler. To cope
     with the fact that only a single wave device exists, the static
     variable open_count tracks opens for one process. After a
d48 2
a49 10
     If different processes open the audio device simultaneously,
     the results are unpredictable - usually the first one wins.

  3. The wave device is reserved within a process from the time that
     the first read or write call has been successful until /dev/dsp
     has been closed by that process. During this reservation period
     child processes that use the same file descriptor cannot
     do read, write or ioctls that change the device properties.
     This means that a parent can open the device, do some ioctl,
     spawn children, and any one of them can do the data read/write
d56 1
a56 1
  ~Audio ();
d60 2
a61 6
  bool denyAccess ();
  void fork_fixup (HANDLE parent);
  inline DWORD getOwner () { return owner_; }
  void setOwner () { owner_ = GetCurrentProcessId (); }
  inline void clearOwner () { owner_ = 0L; }
  void setformat (int format);
a69 1

d72 8
a79 5
  inline void lock () { EnterCriticalSection (&lock_); }
  inline void unlock () { LeaveCriticalSection (&lock_); }
 private:
  DWORD owner_; /* Process ID when wave operation started, else 0 */
  CRITICAL_SECTION lock_;
d90 6
a95 2
  int query ();		  // return number of items queued

d97 1
d100 1
a100 1
  int depth_, depth1_;
d110 1
a110 3
   Audio_out ();
  ~Audio_out ();

d112 1
a112 1
  bool start (int rate, int bits, int channels);
d118 1
a118 1
		 int &rate, int &bits, int &channels);
a124 1
  int emptyblocks ();
a126 1
  queue *Qapp2app_;  // empty and unprepared blocks
d128 5
a132 7
  int bufferIndex_;  // offset into pHdr_->lpData
  WAVEHDR *pHdr_;    // data to be filled by write
  WAVEHDR wavehdr_[MAX_BLOCKS];
  char *bigwavebuffer_; // audio samples only

  // Member variables below must be locked
  queue *Qisr2app_; // empty blocks passed from wave callback
d141 1
a141 3
   Audio_in ();
  ~Audio_in ();

a153 2
  enum { MAX_BLOCKS = 12 }; // read ahead of 1.5 seconds
  queue *Qapp2app_;    // filled and unprepared blocks
a154 7
  int bufferIndex_;    // offset into pHdr_->lpData
  WAVEHDR *pHdr_;      // successfully recorded data
  WAVEHDR wavehdr_[MAX_BLOCKS];
  char *bigwavebuffer_; // audio samples

  // Member variables below must be locked
  queue *Qisr2app_; // filled blocks passed from wave callback
a162 4
  head_ = 0;
  tail_ = 0;
  depth_ = depth;
  depth1_ = depth + 1;
d165 2
a166 1
  storage_ = new WAVEHDR *[depth1_];
d174 10
d187 2
d190 10
a199 6
    return false;
  storage_[tail_] = x;
  tail_++;
  if (tail_ == depth1_)
    tail_ = 0;
  return true;
d205 11
a215 7
  if (query () == 0)
    return false;
  *x = storage_[head_];
  head_++;
  if (head_ == depth1_)
    head_ = 0;
  return true;
d223 1
a223 1
    n += depth1_;
d230 2
a231 1
  InitializeCriticalSection (&lock_);
a232 1
  owner_ = 0L;
d237 3
a239 8
  DeleteCriticalSection (&lock_);
}

void
fhandler_dev_dsp::Audio::fork_fixup (HANDLE parent)
{
  debug_printf ("parent=0x%08x", parent);
  InitializeCriticalSection (&lock_);
d242 2
a243 2
bool
fhandler_dev_dsp::Audio::denyAccess ()
d245 1
a245 3
  if (owner_ == 0L)
    return false;
  return (GetCurrentProcessId () != owner_);
d249 1
a249 1
fhandler_dev_dsp::Audio::setformat (int format)
d356 2
a357 1
fhandler_dev_dsp::Audio_out::Audio_out (): Audio ()
d359 5
a363 3
  bigwavebuffer_ = NULL;
  Qisr2app_ = new queue (MAX_BLOCKS);
  Qapp2app_ = new queue (MAX_BLOCKS);
a365 6
fhandler_dev_dsp::Audio_out::~Audio_out ()
{
  stop ();
  delete Qapp2app_;
  delete Qisr2app_;
}
d375 1
a375 2
  debug_printf ("freq=%d bits=%d channels=%d %s", rate, bits, channels,
		(rc != MMSYSERR_NOERROR) ? "FAIL" : "OK");
d380 1
a380 1
fhandler_dev_dsp::Audio_out::start (int rate, int bits, int channels)
d384 8
a391 4
  unsigned bSize = blockSize (rate, bits, channels);
  bigwavebuffer_ = new char[MAX_BLOCKS * bSize];
  if (bigwavebuffer_ == NULL)
    return false;
d393 1
a393 3
  int nDevices = waveOutGetNumDevs ();
  debug_printf ("number devices=%d, blocksize=%d", nDevices, bSize);
  if (nDevices <= 0)
d396 1
a396 1
  fillFormat (&format, rate, bits, channels);
d400 1
a400 4
    {
      setOwner ();
      init (bSize);
    }
d402 1
a402 2
  debug_printf ("freq=%d bits=%d channels=%d %s", rate, bits, channels,
		(rc != MMSYSERR_NOERROR) ? "FAIL" : "OK");
a411 1
  bool gotblock;
d413 2
a414 3
  debug_printf ("dev_=%08x pid=%d owner=%d", (int)dev_,
		GetCurrentProcessId (), getOwner ());
  if (getOwner () && !denyAccess ())
d423 2
a424 2
      debug_printf ("waveOutReset rc=%d", rc);
      do
d426 2
a427 9
	  lock ();
	  gotblock = Qisr2app_->recv (&pHdr);
	  unlock ();
	  if (gotblock)
	    {
	      rc = waveOutUnprepareHeader (dev_, pHdr, sizeof (WAVEHDR));
	      debug_printf ("waveOutUnprepareHeader Block 0x%08x %s", pHdr,
			    (rc != MMSYSERR_NOERROR) ? "FAIL" : "OK");
	    }
a428 3
      while (gotblock);
      while (Qapp2app_->recv (&pHdr))
	/* flush queue */;
d431 1
a431 1
      debug_printf ("waveOutClose rc=%d", rc);
d433 1
a433 7
      clearOwner ();
    }

  if (bigwavebuffer_)
    {
      delete[] bigwavebuffer_;
      bigwavebuffer_ = NULL;
d443 1
d448 2
a449 1
      if (!Qapp2app_->send (&wavehdr_[i]))
d451 1
a451 1
	  debug_printf ("Internal Error i=%d", i);
a483 12
// return number of (completely) empty blocks back.
int
fhandler_dev_dsp::Audio_out::emptyblocks ()
{
  int n;
  lock ();
  n = Qisr2app_->query ();
  unlock ();
  n += Qapp2app_->query ();
  return n;
}

d489 1
a489 2
  p->fragsize = blockSize (rate, bits, channels);
  if (getOwner ())
d491 4
a494 1
      p->fragments = emptyblocks ();
d503 1
d511 1
a511 1
void
a513 1
  lock ();
a514 1
  unlock ();
a520 1
  bool gotblock;
d525 1
a525 1
  while (Qapp2app_->recv (&pHdr) == false)
d527 9
a535 26
      lock ();
      gotblock = Qisr2app_->recv (&pHdr);
      unlock ();
      if (gotblock)
	{
	  if ((pHdr->dwFlags & WHDR_DONE)
	      && ((rc = waveOutUnprepareHeader (dev_, pHdr, sizeof (WAVEHDR)))
	       == MMSYSERR_NOERROR))
	    {
	      Qapp2app_->send (pHdr);
	    }
	  else
	    {
	      debug_printf ("error UnprepareHeader 0x%08x, rc=%d, 100ms",
			    pHdr, rc);
	      lock ();
	      Qisr2app_->send (pHdr);
	      unlock ();
	      Sleep (100);
	    }
	}
      else
	{
	  debug_printf ("100ms");
	  Sleep (100);
	}
d544 1
a544 1
  while (emptyblocks () != MAX_BLOCKS)
d546 1
a546 2
      debug_printf ("100ms Qisr=%d Qapp=%d",
		    Qisr2app_->query (), Qapp2app_->query ());
d556 3
d568 3
a570 2
  pHdr->dwFlags = 0;
  if (waveOutPrepareHeader (dev_, pHdr, sizeof (WAVEHDR)) == MMSYSERR_NOERROR)
d572 2
a573 17
      if (waveOutWrite (dev_, pHdr, sizeof (WAVEHDR)) == MMSYSERR_NOERROR)
	{
	  debug_printf ("waveOutWrite bytes=%d", bufferIndex_);
	  return true;
	}
      else
	{
	  debug_printf ("waveOutWrite failed");
	  lock ();
	  Qisr2app_->send (pHdr);
	  unlock ();
	}
    }
  else
    {
      debug_printf ("waveOutPrepareHeader failed");
      Qapp2app_->send (pHdr);
d575 6
d619 1
a619 1
				       int &rate, int &bits, int &channels)
d625 7
d664 3
a666 3
		  rate = format->dwSamplesPerSec;
		  bits = format->wBitsPerSample;
		  channels = format->wChannels;
d679 1
d696 1
a696 3
   WAVEHDR pointer into a queue. We need a second queue to distinguish
   blocks with data from blocks that have been unprepared and are ready
   to be used by read().
d704 2
a705 1
fhandler_dev_dsp::Audio_in::Audio_in () : Audio ()
d707 5
a711 10
  bigwavebuffer_ = NULL;
  Qisr2app_ = new queue (MAX_BLOCKS);
  Qapp2app_ = new queue (MAX_BLOCKS);
}

fhandler_dev_dsp::Audio_in::~Audio_in ()
{
  stop ();
  delete Qapp2app_;
  delete Qisr2app_;
d722 1
a722 2
  debug_printf ("freq=%d bits=%d channels=%d %s", rate, bits, channels,
		(rc != MMSYSERR_NOERROR) ? "FAIL" : "OK");
a731 3
  bigwavebuffer_ = new char[MAX_BLOCKS * bSize];
  if (bigwavebuffer_ == NULL)
    return false;
d733 8
a740 3
  int nDevices = waveInGetNumDevs ();
  debug_printf ("number devices=%d, blocksize=%d", nDevices, bSize);
  if (nDevices <= 0)
d746 2
a749 1
      setOwner ();
d751 1
a751 4
	{
	  stop ();
	  return false;
	}
a752 4

  debug_printf ("freq=%d bits=%d channels=%d %s", rate, bits, channels,
		(rc != MMSYSERR_NOERROR) ? "FAIL" : "OK");

a760 1
  bool gotblock;
d762 2
a763 3
  debug_printf ("dev_=%08x pid=%d owner=%d", (int)dev_,
		GetCurrentProcessId (), getOwner ());
  if (getOwner () && !denyAccess ())
a764 1
      rc = waveInReset (dev_);
d769 2
a770 1
      debug_printf ("waveInReset rc=%d", rc);
d772 1
a772 1
      do
d774 2
a775 9
	  lock ();
	  gotblock = Qisr2app_->recv (&pHdr);
	  unlock ();
	  if (gotblock)
	    {
	      rc = waveInUnprepareHeader (dev_, pHdr, sizeof (WAVEHDR));
	      debug_printf ("waveInUnprepareHeader Block 0x%08x %s", pHdr,
			    (rc != MMSYSERR_NOERROR) ? "FAIL" : "OK");
	    }
a776 3
      while (gotblock);
      while (Qapp2app_->recv (&pHdr))
	/* flush queue */;
d779 1
a779 1
      debug_printf ("waveInClose rc=%d", rc);
d781 1
a781 7
      clearOwner ();
    }

  if (bigwavebuffer_)
    {
      delete[] bigwavebuffer_;
      bigwavebuffer_ = NULL;
a788 1
  pHdr->dwFlags = 0;
d790 1
d792 12
a803 4
    rc = waveInAddBuffer (dev_, pHdr, sizeof (WAVEHDR));
  debug_printf ("waveInAddBuffer Block 0x%08x %s", pHdr,
		(rc != MMSYSERR_NOERROR) ? "FAIL" : "OK");
  return (rc == MMSYSERR_NOERROR);
d813 1
d818 1
d824 1
a824 2
  debug_printf ("waveInStart=%d %s queued=%d",
		rc, (rc != MMSYSERR_NOERROR) ? "FAIL" : "OK", i);
a872 1
  bool gotblock;
d877 1
a877 1
  while (Qapp2app_->recv (&pHdr) == false)
d879 9
a887 16
      lock ();
      gotblock = Qisr2app_->recv (&pHdr);
      unlock ();
      if (gotblock)
	{
	  rc = waveInUnprepareHeader (dev_, pHdr, sizeof (WAVEHDR));
	  if (rc == MMSYSERR_NOERROR)
	    Qapp2app_->send (pHdr);
	  else
	    debug_printf ("error UnprepareHeader 0x%08x", pHdr);
	}
      else
	{
	  debug_printf ("100ms");
	  Sleep (100);
	}
d899 1
a899 1
  if (getOwner ())
a900 1
      lock ();
a901 2
      unlock ();
      p->fragments += Qapp2app_->query ();
d915 1
a915 2
// This is called on an interrupt so use locking..
void
a917 1
  lock ();
a918 1
  unlock ();
d936 1
a936 4
   ------------------------------------------------------------------------
   instances of the handler statics */
int fhandler_dev_dsp::open_count = 0;

a944 6
fhandler_dev_dsp::~fhandler_dev_dsp ()
{
  close ();
  debug_printf ("0x%08x end", (int)this);
}

d948 1
a948 2
  open_count++;
  if (open_count > 1)
d953 2
d963 4
d968 2
a969 6
      audio_out_ = new Audio_out;
      if (!audio_out_->query (audiofreq_, audiobits_, audiochannels_))
	{
	  delete audio_out_;
	  audio_out_ = NULL;
	}
d972 2
a973 26
      audio_in_ = new Audio_in;
      if (!audio_in_->query (audiofreq_, audiobits_, audiochannels_))
	{
	  delete audio_in_;
	  audio_in_ = NULL;
	}
      break;
    case O_RDWR:
      audio_out_ = new Audio_out;
      if (audio_out_->query (audiofreq_, audiobits_, audiochannels_))
	{
	  audio_in_ = new Audio_in;
	  if (!audio_in_->query (audiofreq_, audiobits_, audiochannels_))
	    {
	      delete audio_in_;
	      audio_in_ = NULL;
	      audio_out_->stop ();
	      delete audio_out_;
	      audio_out_ = NULL;
	    }
	}
      else
	{
	  delete audio_out_;
	  audio_out_ = NULL;
	}
d976 5
a980 7
      set_errno (EINVAL);
      return 0;
    } // switch (flags & O_ACCMODE)
  int rc;
  if (audio_in_ || audio_out_)
    { /* All tried query () succeeded */
      rc = 1;
d983 8
a990 1
      close_on_exec (true);
d993 5
a997 7
    { /* One of the tried query () failed */
      rc = 0;
      set_errno (EIO);
    }
  debug_printf ("ACCMODE=0x%08x audio_in=%08x audio_out=%08x, rc=%d",
		flags & O_ACCMODE, (int)audio_in_, (int)audio_out_, rc);
  return rc;
d1000 2
a1001 6
#define RETURN_ERROR_WHEN_BUSY(audio)\
  if ((audio)->denyAccess ())    \
    {\
      set_errno (EBUSY);\
      return -1;\
    }
d1006 4
a1012 1
  debug_printf ("ptr=%08x len=%d", ptr, len);
d1014 22
d1037 1
a1037 1
      set_errno (EACCES); // device was opened for read?
a1039 18
  RETURN_ERROR_WHEN_BUSY (audio_out_);
  if (audio_out_->getOwner () == 0L)
    { // No owner yet, lets do it
      // check for wave file & get parameters & skip header if possible.
      if (audio_out_->parsewav (ptr_s, len_s,
				audiofreq_, audiobits_, audiochannels_))
	{ // update our format conversion
	  debug_printf ("=> ptr_s=%08x len_s=%d", ptr_s, len_s);
	  audioformat_ = ((audiobits_ == 8) ? AFMT_U8 : AFMT_S16_LE);
	  audio_out_->setformat (audioformat_);
	}
      // Open audio device properly with callbacks.
      if (!audio_out_->start (audiofreq_, audiobits_, audiochannels_))
	{
	  set_errno (EIO);
	  return -1;
	}
    }
d1049 3
d1053 20
d1075 1
a1075 1
      set_errno (EACCES); // device was opened for write?
d1078 1
a1078 16
  if (audio_in_->denyAccess ())
    {
      len = (size_t)-1;
      set_errno (EBUSY);
      return;
    }
  if (audio_in_->getOwner () == 0L)
    { // No owner yet. Let's take it
      // Open audio device properly with callbacks.
      if (!audio_in_->start (audiofreq_, audiobits_, audiochannels_))
	{
	  len = (size_t)-1;
	  set_errno (EIO);
	  return;
	}
    }
d1089 2
a1090 2
int
fhandler_dev_dsp::close (void)
a1091 2
  debug_printf ("audio_in=%08x audio_out=%08x",
		(int)audio_in_, (int)audio_out_);
d1094 1
d1098 5
d1105 1
a1105 5
      if (exit_state != ES_NOT_EXITING)
       { // emergency close due to call to exit() or Ctrl-C:
	 // do not wait for all pending audio to be played
	 audio_out_->stop (true);
       }
d1109 15
a1123 2
  if (open_count > 0)
    open_count--;
d1131 2
a1132 7
  fhandler_dev_dsp *fhc = (fhandler_dev_dsp *) child;

  fhc->set_flags (get_flags ());
  fhc->audiochannels_ = audiochannels_;
  fhc->audiobits_ = audiobits_;
  fhc->audiofreq_ = audiofreq_;
  fhc->audioformat_ = audioformat_;
a1138 1
  int *intptr = (int *) ptr;
d1141 4
d1150 3
a1152 11
	if (audio_out_)
	  {
	    RETURN_ERROR_WHEN_BUSY (audio_out_);
	    audio_out_->stop (true);
	  }
	if (audio_in_)
	  {
	    RETURN_ERROR_WHEN_BUSY (audio_in_);
	    audio_in_->stop ();
	  }
	return 0;
d1156 2
a1157 1
	if (audio_out_)
d1164 1
a1164 1
	  { // I am very sure that audio_in_ is valid
a1169 1
	break;
d1193 1
a1193 1
	if (nBits && audio_out_)
d1195 1
a1195 3
	    RETURN_ERROR_WHEN_BUSY (audio_out_);
	    audio_out_->stop ();
	    audio_out_->setformat (*intptr);
d1207 1
a1207 1
	if (nBits && audio_in_)
d1209 1
a1209 3
	    RETURN_ERROR_WHEN_BUSY (audio_in_);
	    audio_in_->stop ();
	    audio_in_->setformat (*intptr);
a1222 1
      break;
d1225 1
a1225 2
      {
	if (audio_out_)
d1227 1
a1227 2
	    RETURN_ERROR_WHEN_BUSY (audio_out_);
	    audio_out_->stop ();
d1236 1
a1236 1
	if (audio_in_)
d1238 1
a1238 2
	    RETURN_ERROR_WHEN_BUSY (audio_in_);
	    audio_in_->stop ();
a1247 2
      }
      break;
d1252 3
a1254 26

	if (audio_out_)
	  {
	    RETURN_ERROR_WHEN_BUSY (audio_out_);
	    audio_out_->stop ();
	    if (audio_out_->query (audiofreq_, audiobits_, nChannels))
	      audiochannels_ = nChannels;
	    else
	      {
		*intptr = audiochannels_ - 1;
		return -1;
	      }
	  }
	if (audio_in_)
	  {
	    RETURN_ERROR_WHEN_BUSY (audio_in_);
	    audio_in_->stop ();
	    if (audio_in_->query (audiofreq_, audiobits_, nChannels))
	      audiochannels_ = nChannels;
	    else
	      {
		*intptr = audiochannels_ - 1;
		return -1;
	      }
	  }
	return 0;
a1255 1
      break;
d1261 1
a1261 1
	if (audio_out_)
d1263 1
a1263 2
	    RETURN_ERROR_WHEN_BUSY (audio_out_);
	    audio_out_->stop ();
d1272 1
a1272 1
	if (audio_in_)
d1274 1
a1274 2
	    RETURN_ERROR_WHEN_BUSY (audio_in_);
	    audio_in_->stop ();
a1284 1
      break;
d1288 1
a1288 2
	audio_buf_info *p = (audio_buf_info *) ptr;
	if (audio_out_)
d1290 2
a1291 4
	    RETURN_ERROR_WHEN_BUSY (audio_out_);
	    audio_out_->buf_info (p, audiofreq_, audiobits_, audiochannels_);
	    debug_printf ("ptr=%p frags=%d fragsize=%d bytes=%d",
			  ptr, p->fragments, p->fragsize, p->bytes);
d1293 4
a1298 1
      break;
d1302 1
a1302 2
	audio_buf_info *p = (audio_buf_info *) ptr;
	if (audio_in_)
d1304 2
a1305 4
	    RETURN_ERROR_WHEN_BUSY (audio_in_);
	    audio_in_->buf_info (p, audiofreq_, audiobits_, audiochannels_);
	    debug_printf ("ptr=%p frags=%d fragsize=%d bytes=%d",
			  ptr, p->fragments, p->fragsize, p->bytes);
d1307 4
a1312 1
      break;
a1314 1
      {
a1317 2
      }
      break;
a1319 1
      {
a1321 2
      }
      break;
a1323 1
      {
a1325 2
      }
      break;
d1329 4
a1332 13
      {
	if (audio_out_)
	  {
	    // Stop audio out device
	    RETURN_ERROR_WHEN_BUSY (audio_out_);
	    audio_out_->stop ();
	  }
	if (audio_in_)
	  {
	    // Stop audio in device
	    RETURN_ERROR_WHEN_BUSY (audio_in_);
	    audio_in_->stop ();
	  }
a1333 2
      }
      break;
d1356 4
a1359 1
  if (audio_in_ )
d1370 5
a1375 2


@


1.37
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d478 1
a478 1
      (int)wavehdr_[i].dwUser = blockSize;
@


1.36
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::stop): Move delete of
	bigwavebuffer_ so that it is always cleaned, also in child processes.
	(fhandler_dev_dsp::Audio_in::stop): Ditto.
	(fhandler_dev_dsp::close): Stop audio play immediately in case of
	abnormal exit.
@
text
@d46 1
a46 1
    
d96 1
a96 1
  int query ();           // return number of items queued
d134 1
a134 1
  WAVEHDR *pHdr_;    // data to be filled by write  
d359 1
a359 1
  blockSize &= ~0x3f; 
d417 1
a417 1
  
d434 2
a435 2
	  sendcurrent ();           // force out last block whatever size..
	  waitforallsent ();        // block till finished..
d820 1
a820 1
  
d923 1
a923 1
	  debug_printf ("got %d", bytes_to_read); 
d975 1
a975 1
  bufferIndex_ = 0; 
d1072 1
a1072 1
      if (!audio_in_->query (audiofreq_, audiobits_, audiochannels_)) 
d1116 1
a1116 1
                flags & O_ACCMODE, (int)audio_in_, (int)audio_out_, rc);
d1212 2
a1213 2
         // do not wait for all pending audio to be played
         audio_out_->stop (true);
d1338 1
a1338 1
	  {	    
d1370 1
a1370 1
	  {	    
d1402 1
a1402 1
	  {	    
@


1.35
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::stop): Add optional
	boolean argument so that playing can be stopped without playing
	pending buffers.
	(fhandler_dev_dsp::ioctl): Stop playback immediately for
	SNDCTL_DSP_RESET.  Do not reset audio parameters in this case.
	Add support for ioctl SNDCTL_DSP_GETISPACE.
	(fhandler_dev_dsp::Audio_out::emptyblocks): Now returns the number of
	completely empty blocks.
	(fhandler_dev_dsp::Audio_out::buf_info): p->fragments is now the number
	of completely empty blocks. This conforms with the OSS specification.
	(fhandler_dev_dsp::Audio_out::parsewav): Ignore wave headers that are
	not aligned on four byte boundary.
	(fhandler_dev_dsp::Audio_in::buf_info): New, needed for
	SNDCTL_DSP_GETISPACE.
@
text
@d460 1
d462 4
a465 5
      if (bigwavebuffer_)
	{
	  delete[] bigwavebuffer_;
	  bigwavebuffer_ = NULL;
	}
d862 1
d864 4
a867 5
      if (bigwavebuffer_)
	{
	  delete[] bigwavebuffer_;
	  bigwavebuffer_ = NULL;
	}
d1210 5
@


1.34
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d116 1
a116 1
  void stop ();
d155 1
d422 1
a422 1
fhandler_dev_dsp::Audio_out::stop ()
d432 5
a436 2
      sendcurrent ();		// force out last block whatever size..
      waitforallsent ();        // block till finished..
d514 1
a514 1
// return number of (partially) empty blocks back.
a522 2
  if (pHdr_ != NULL)
    n++;
d536 2
a537 2
	p->bytes = p->fragsize - bufferIndex_ +
	  p->fragsize * (p->fragments - 1);
d690 3
a692 1
  
d978 25
d1246 1
a1246 6
	    audioformat_ = AFMT_U8;
	    audiofreq_ = 8000;
	    audiobits_ = 8;
	    audiochannels_ = 1;
	    audio_out_->stop ();
	    audio_out_->setformat (audioformat_);
a1250 4
	    audioformat_ = AFMT_U8;
	    audiofreq_ = 8000;
	    audiobits_ = 8;
	    audiochannels_ = 1;
a1251 1
	    audio_in_->setformat (audioformat_);
d1431 14
@


1.33
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::ioctl): Add implementation
	for ioctl codes SNDCTL_DSP_CHANNELS and SNDCTL_DSP_GETCAPS.
@
text
@d1078 2
a1079 2
      set_need_fork_fixup ();
      set_close_on_exec_flag (1);
@


1.32
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::write): Remove type
	cast from argument to audio_out_->parsewav() to make reference
	work properly. Now .wav file headers are properly discarded.
@
text
@d1373 32
d1430 7
@


1.31
log
@	* autoload.cc: Load eight more functions for waveIn support.
	* fhandler.h (class fhandler_dev_dsp): Add class Audio, class Audio_in
	and class Audio_out members and audio_in_, audio_out_ pointers so
	that future changes are restricted to file fhandler_dsp.cc.
	* fhandler_dsp.cc (fhandler_dev_dsp::Audio): Add this class to treat
	things common to audio recording and playback.
	Add more format conversions.
	(fhandler_dev_dsp::Audio::queue): New queues for buffer management
	to fix incomplete cleanup of buffers passed to the wave device.
	(fhandler_dev_dsp::Audio_in): New, added class to implement audio
	recording.
	(fhandler_dev_dsp::Audio_out): Rework to use functionality provided
	by fhandler_dev_dsp::Audio.  Allocate memory audio buffers late,
	just before write.
	(fhandler_dev_dsp::Audio_out::start): Size of wave buffer allocated
	here depends on audio rate/bits/channels.
	(fhandler_dev_dsp::Audio_in::start): Ditto.
	(fhandler_dev_dsp::setupwav): Replaced by following function.
	(fhandler_dev_dsp::Audio_out::parsewav): Does not setup wave device
	any more. Discard wave header properly.
	(fhandler_dev_dsp::open): Add O_RDONLY and_RDWR as legal modes.
	Protect against re-open. Activate fork_fixup.
	(fhandler_dev_dsp::ioctl): Protect against actions when audio is
	active.  SNDCTL_DSP_GETFMTS only returns formats supported by
	mmsystem wave API, not all supported formats.  SNDCTL_DSP_GETBLKSIZE
	result now depends on current audio format.
	(fhandler_dev_dsp::fixup_after_fork): Call fork_fixup for the Audio
	classes to let them duplicate the CRITICAL_SECTION.
@
text
@d1101 3
a1103 1
  int len_s = len; 
d1114 1
a1114 1
      if (audio_out_->parsewav ((const char *) ptr, len_s,
d1117 1
d1129 1
a1129 1
  audio_out_->write ((char *)ptr, len_s);
@


1.30
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d6 2
d25 121
a145 6
//------------------------------------------------------------------------
// Simple encapsulation of the win32 audio device.
//
static void CALLBACK wave_callback (HWAVE hWave, UINT msg, DWORD instance,
				    DWORD param1, DWORD param2);
class Audio
d148 2
a149 19
  enum
  {
    MAX_BLOCKS = 12,
    BLOCK_SIZE = 16384,
    TOT_BLOCK_SIZE = BLOCK_SIZE + sizeof (WAVEHDR)
   };

    Audio ();
   ~Audio ();

  bool open (int rate, int bits, int channels, bool bCallback = false);
  void close ();
  int getvolume ();
  void setvolume (int newVolume);
  bool write (const void *pSampleData, int nBytes);
  int blocks ();
  void callback_sampledone (void *pData);
  void setformat (int format) {formattype_ = format;}
  int numbytesoutput ();
d151 5
a155 1
  void *operator new (size_t, void *p) {return p;}
d158 11
a168 12
  char *initialisebuffer ();
  void waitforcallback ();
  bool flush ();

  HWAVEOUT dev_;
  volatile int nBlocksInQue_;
  int nBytesWritten_;
  char *buffer_;
  int bufferIndex_;
  CRITICAL_SECTION lock_;
  char *freeblocks_[MAX_BLOCKS];
  int formattype_;
d170 2
a171 1
  char bigwavebuffer_[MAX_BLOCKS * TOT_BLOCK_SIZE];
d174 19
a192 1
static char audio_buf[sizeof (class Audio)];
d194 35
a228 1
Audio::Audio ()
d231 2
a232 3
  memset (bigwavebuffer_, 0, sizeof (bigwavebuffer_));
  for (int i = 0; i < MAX_BLOCKS; i++)
    freeblocks_[i] =  &bigwavebuffer_[i * TOT_BLOCK_SIZE];
d235 1
a235 1
Audio::~Audio ()
a236 2
  if (dev_)
    close ();
d240 7
d248 1
a248 1
Audio::open (int rate, int bits, int channels, bool bCallback)
d250 1
a250 8
  WAVEFORMATEX format;
  int nDevices = waveOutGetNumDevs ();

  nBytesWritten_ = 0L;
  bufferIndex_ = 0;
  buffer_ = 0L;
  debug_printf ("number devices %d", nDevices);
  if (nDevices <= 0)
d252 2
d255 4
a258 19
  debug_printf ("trying to map device freq %d, bits %d, "
		"channels %d, callback %d", rate, bits, channels,
		bCallback);

  int bytesperSample = bits / 8;

  memset (&format, 0, sizeof (format));
  format.wFormatTag = WAVE_FORMAT_PCM;
  format.wBitsPerSample = bits;
  format.nChannels = channels;
  format.nSamplesPerSec = rate;
  format.nAvgBytesPerSec = format.nSamplesPerSec * format.nChannels *
    bytesperSample;
  format.nBlockAlign = format.nChannels * bytesperSample;

  nBlocksInQue_ = 0;
  HRESULT res = waveOutOpen (&dev_, WAVE_MAPPER, &format, (DWORD) wave_callback,
			     (DWORD) this, bCallback ? CALLBACK_FUNCTION : 0);
  if (res == S_OK)
d260 19
a278 2
      debug_printf ("Sucessfully opened!");
      return true;
d280 7
a286 1
  else
d288 2
a289 2
      debug_printf ("failed to open");
      return false;
d294 2
a295 1
Audio::close ()
d297 3
a299 1
  if (dev_)
d301 6
a306 1
      flush ();			// force out last block whatever size..
d308 12
a319 2
      while (blocks ())		// block till finished..
	waitforcallback ();
d321 12
a332 3
      waveOutReset (dev_);
      waveOutClose (dev_);
      dev_ = 0L;
a333 1
  nBytesWritten_ = 0L;
d336 17
a352 2
int
Audio::numbytesoutput ()
d354 6
a359 1
  return nBytesWritten_;
d362 2
a363 2
int
Audio::getvolume ()
d365 4
a368 1
  DWORD volume;
d370 5
a374 2
  waveOutGetVolume (dev_, &volume);
  return ((volume >> 16) + (volume & 0xffff)) >> 1;
d377 2
a378 2
void
Audio::setvolume (int newVolume)
d380 8
a387 1
  waveOutSetVolume (dev_, (newVolume << 16) | newVolume);
d390 2
a391 2
char *
Audio::initialisebuffer ()
d393 16
a408 3
  EnterCriticalSection (&lock_);
  WAVEHDR *pHeader = 0L;
  for (int i = 0; i < MAX_BLOCKS; i++)
d410 27
a436 2
      char *pData = freeblocks_[i];
      if (pData)
d438 4
a441 2
	  pHeader = (WAVEHDR *) pData;
	  if (pHeader->dwFlags & WHDR_DONE)
d443 3
a445 1
	      waveOutUnprepareHeader (dev_, pHeader, sizeof (WAVEHDR));
d447 14
a460 2
	  freeblocks_[i] = 0L;
	  break;
d463 1
a463 1
  LeaveCriticalSection (&lock_);
d465 7
a471 1
  if (pHeader)
d473 7
a479 4
      memset (pHeader, 0, sizeof (WAVEHDR));
      pHeader->dwBufferLength = BLOCK_SIZE;
      pHeader->lpData = (LPSTR) (&pHeader[1]);
      return (char *) pHeader->lpData;
d481 1
a481 1
  return 0L;
d485 1
a485 1
Audio::write (const void *pSampleData, int nBytes)
d487 19
a505 6
  // split up big blocks into smaller BLOCK_SIZE chunks
  while (nBytes > BLOCK_SIZE)
    {
      write (pSampleData, BLOCK_SIZE);
      nBytes -= BLOCK_SIZE;
      pSampleData = (void *) ((char *) pSampleData + BLOCK_SIZE);
d507 2
d510 13
a522 3
  // Block till next sound is flushed
  if (blocks () == MAX_BLOCKS)
    waitforcallback ();
d524 7
a530 2
  // Allocate new wave buffer if necessary
  if (buffer_ == 0L)
d532 6
a537 3
      buffer_ = initialisebuffer ();
      if (buffer_ == 0L)
	return false;
d539 1
a539 5


  // Handle gathering blocks into larger buffer
  int sizeleft = BLOCK_SIZE - bufferIndex_;
  if (nBytes < sizeleft)
d541 2
a542 4
      memcpy (&buffer_[bufferIndex_], pSampleData, nBytes);
      bufferIndex_ += nBytes;
      nBytesWritten_ += nBytes;
      return true;
a543 16

  // flushing when we reach our limit of BLOCK_SIZE
  memcpy (&buffer_[bufferIndex_], pSampleData, sizeleft);
  bufferIndex_ += sizeleft;
  nBytesWritten_ += sizeleft;
  flush ();

  // change pointer to rest of sample, and size accordingly
  pSampleData = (void *) ((char *) pSampleData + sizeleft);
  nBytes -= sizeleft;

  // if we still have some sample left over write it out
  if (nBytes)
    return write (pSampleData, nBytes);

  return true;
d546 4
a549 3
// return number of blocks back.
int
Audio::blocks ()
d551 3
a553 4
  EnterCriticalSection (&lock_);
  int ret = nBlocksInQue_;
  LeaveCriticalSection (&lock_);
  return ret;
a555 2
// This is called on an interupt so use locking.. Note nBlocksInQue_ is
// modified by it so we should wrap all references to it in locks.
d557 1
a557 1
Audio::callback_sampledone (void *pData)
d559 3
a561 1
  EnterCriticalSection (&lock_);
d563 33
a595 9
  nBlocksInQue_--;
  for (int i = 0; i < MAX_BLOCKS; i++)
    if (!freeblocks_[i])
      {
	freeblocks_[i] = (char *) pData;
	break;
      }

  LeaveCriticalSection (&lock_);
d599 1
a599 1
Audio::waitforcallback ()
d601 1
a601 4
  int n = blocks ();
  if (!n)
    return;
  do
d603 3
a605 1
      Sleep (250);
a606 1
  while (n == blocks ());
d609 1
d611 1
a611 1
Audio::flush ()
d613 2
a614 1
  if (!buffer_)
d616 4
d622 3
a624 5
  WAVEHDR *pHeader = ((WAVEHDR *) buffer_) - 1;
  pHeader->dwBufferLength = bufferIndex_;

  // Quick bit of sample buffer conversion
  if (formattype_ == AFMT_S8)
d626 1
a626 2
      unsigned char *p = ((unsigned char *) buffer_);
      for (int i = 0; i < bufferIndex_; i++)
d628 9
a636 1
	  p[i] -= 0x7f;
a638 11

  if (waveOutPrepareHeader (dev_, pHeader, sizeof (WAVEHDR)) == S_OK &&
      waveOutWrite (dev_, pHeader, sizeof (WAVEHDR)) == S_OK)
    {
      EnterCriticalSection (&lock_);
      nBlocksInQue_++;
      LeaveCriticalSection (&lock_);
      bufferIndex_ = 0;
      buffer_ = 0L;
      return true;
    }
d641 2
a642 8
      EnterCriticalSection (&lock_);
      for (int i = 0; i < MAX_BLOCKS; i++)
	if (!freeblocks_[i])
	  {
	    freeblocks_[i] = (char *) pHeader;
	    break;
	  }
      LeaveCriticalSection (&lock_);
d650 2
a651 2
wave_callback (HWAVE hWave, UINT msg, DWORD instance, DWORD param1,
	       DWORD param2)
d655 3
a657 2
      Audio *ptr = (Audio *) instance;
      ptr->callback_sampledone ((void *) param1);
a661 4
// /dev/dsp handler
static Audio *s_audio;		// static instance of the Audio handler

//------------------------------------------------------------------------
d681 2
a682 1
fhandler_dev_dsp::setupwav (const char *pData, int nBytes)
d686 5
a690 3

  if (!(pData[0] == 'R' && pData[1] == 'I' &&
	pData[2] == 'F' && pData[3] == 'F'))
d692 2
a693 2
  if (!(pData[8] == 'W' && pData[9] == 'A' &&
	pData[10] == 'V' && pData[11] == 'E'))
d697 8
a704 4
  pData += 12;
  while (len && pData < end)
    {
      wavchunk * pChunk = (wavchunk *) pData;
d706 2
a707 2
      if (pChunk->id[0] == 'f' && pChunk->id[1] == 'm' &&
	  pChunk->id[2] == 't' && pChunk->id[3] == ' ')
d710 1
a710 1
	  if ((char *) (format + 1) > end)
d712 125
d838 6
a843 7
	  // Open up audio device with correct frequency for wav file
	  //
	  // FIXME: should through away all the header & not output
	  // it to the soundcard.
	  s_audio->close ();
	  if (s_audio->open (format->dwSamplesPerSec, format->wBitsPerSample,
			     format->wChannels) == false)
d845 3
a847 1
	      s_audio->open (audiofreq_, audiobits_, audiochannels_);
d849 112
d962 6
a967 6
	    {
	      audiofreq_ = format->dwSamplesPerSec;
	      audiobits_ = format->wBitsPerSample;
	      audiochannels_ = format->wChannels;
	    }
	  return true;
d969 4
d974 18
a991 1
      pData += blklen + sizeof (wavchunk);
a992 1
  return false;
d995 7
a1001 1
//------------------------------------------------------------------------
d1005 3
d1012 2
d1019 2
a1020 2
  // currently we only support writing
  if ((flags & (O_WRONLY | O_RDONLY | O_RDWR)) != O_WRONLY)
d1022 1
a1022 1
      set_errno (EACCES);
a1024 1

d1026 2
a1027 7

  if (!s_audio)
    s_audio = new (audio_buf) Audio;

  // Work out initial sample format & frequency
      // dev/dsp defaults
  audioformat_ = AFMT_S8;
d1031 1
a1031 5

  int res;
  if (!s_audio->open (audiofreq_, audiobits_, audiochannels_))
    res = 0;
  else
d1033 44
d1078 2
a1079 1
      res = 1;
d1081 9
d1091 6
a1096 3
  debug_printf ("returns %d", res);
  return res;
}
d1101 3
a1103 1
  if (s_audio->numbytesoutput () == 0)
d1105 13
a1117 3
      // check for wave file & setup frequencys properly if possible.
      setupwav ((const char *) ptr, len);

d1119 5
a1123 3
      s_audio->close ();
      if (!s_audio->open (audiofreq_, audiobits_, audiochannels_, true))
	return 0;
d1126 1
a1126 1
  s_audio->write (ptr, len);
d1133 24
d1169 14
a1182 1
  s_audio->close ();
d1189 1
d1204 2
d1208 1
a1208 1
#define CASE(a) case a : debug_printf("/dev/dsp: ioctl %s", #a);
d1211 20
a1230 4
	audioformat_ = AFMT_S8;
	audiofreq_ = 8000;
	audiobits_ = 8;
	audiochannels_ = 1;
d1232 1
d1235 12
a1246 1
	*intptr = Audio::BLOCK_SIZE;
d1248 1
d1252 26
a1277 12
	int nBits = 0;
	if (*intptr == AFMT_S16_LE)
	  nBits = 16;
	else if (*intptr == AFMT_U8)
	  nBits = 8;
	else if (*intptr == AFMT_S8)
	  nBits = 8;
	if (nBits)
	  {
	    s_audio->setformat (*intptr);
	    s_audio->close ();
	    if (s_audio->open (audiofreq_, nBits, audiochannels_) == true)
d1280 1
a1280 1
		return 0;
d1284 1
a1284 1
		s_audio->open (audiofreq_, audiobits_, audiochannels_);
d1288 17
d1309 12
a1320 5
	s_audio->close ();
	if (s_audio->open (*intptr, audiobits_, audiochannels_) == true)
	  {
	    audiofreq_ = *intptr;
	    return 0;
d1322 1
a1322 1
	else
d1324 9
a1332 2
	    s_audio->open (audiofreq_, audiobits_, audiochannels_);
	    return -1;
d1334 3
a1336 1
	break;
d1342 11
a1352 5
	s_audio->close ();
	if (s_audio->open (audiofreq_, audiobits_, nChannels) == true)
	  {
	    audiochannels_ = nChannels;
	    return 0;
d1354 1
a1354 1
	else
d1356 9
a1364 2
	    s_audio->open (audiofreq_, audiobits_, audiochannels_);
	    return -1;
d1366 1
d1373 7
a1379 17

	int nBlocks = s_audio->blocks ();
	int leftblocks = ((Audio::MAX_BLOCKS - nBlocks) - 1);
	if (leftblocks < 0)
	  leftblocks = 0;
	if (leftblocks > 1)
	  leftblocks = 1;
	int left = leftblocks * Audio::BLOCK_SIZE;

	p->fragments = leftblocks;
	p->fragstotal = Audio::MAX_BLOCKS;
	p->fragsize = Audio::BLOCK_SIZE;
	p->bytes = left;

	debug_printf ("ptr %p nblocks %d leftblocks %d left bytes %d ",
		      ptr, nBlocks, leftblocks, left);

d1394 20
a1413 1
	*intptr = AFMT_S16_LE | AFMT_U8 | AFMT_S8; // more?
d1419 1
a1419 1
      debug_printf ("/dev/dsp: ioctl not handled yet! FIXME:");
d1424 1
d1431 12
a1442 1
  paranoid_printf ("here, fhandler_dev_dsp");
d1448 2
a1449 2
  /* FIXME:  Is there a better way to do this? */
  s_audio = new (audio_buf) Audio;
d1451 2
@


1.29
log
@* fhandler.h (*::fixup_after_exec): Eliminate unused handle argument.
* fhandler.h (dtable::fixup_after_exec): Eliminate unused handle argument.
* dcrt0.cc (dll_crt0_1): Reflect elimination of unused handle argument to
fixup_after_exec.
* dtable.cc (dtable::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_raw::fixup_after_exec): Ditto.
* fhandler_socket.cc (fhandler_socket::fixup_after_exec): Ditto.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Ditto.
* pipe.cc (fhandler_pipe::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Do not set ciresrv.parent.
* child_info.h (child_info_spawn::~child_info_spawn): Do not close parent.
Update CURR_CHILD_INFO_MAGIC.
* dcrt0.cc (dll_crt0_0): Do not close spawn_info->parent.  Pass NULL to
cygheap->fdtab.fixup_after_exec().
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003 Red Hat, Inc
@


1.28
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d649 1
a649 1
fhandler_dev_dsp::fixup_after_exec (HANDLE)
@


1.27
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d20 1
d423 1
a423 1
  fhandler_base (FH_OSS_DSP)
d432 1
a432 1
fhandler_dev_dsp::open (path_conv *, int flags, mode_t mode)
@


1.26
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@a14 1
#include <errno.h>
@


1.25
log
@	* autoload.cc: Fix copyright date.
	* fhandler_dsp.cc: Ditto.
	* mmap.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* signal.cc: Ditto.
	* syscalls.cc: Ditto.
	* uname.cc: Ditto.
	* wait.cc: Ditto.
@
text
@d490 2
a491 2
__off64_t
fhandler_dev_dsp::lseek (__off64_t offset, int whence)
@


1.25.2.1
log
@merge from trunk
@
text
@d423 1
a423 1
  fhandler_base ()
@


1.25.2.2
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@a20 1
#include "path.h"
d432 1
a432 1
fhandler_dev_dsp::open (int flags, mode_t mode)
@


1.25.2.3
log
@merge from trunk
@
text
@d491 2
a492 2
_off64_t
fhandler_dev_dsp::lseek (_off64_t offset, int whence)
@


1.25.2.4
log
@merge from trunk
@
text
@d15 1
@


1.24
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Add limited support for
SNDCTL_DSP_GETFMTS.
@
text
@d3 1
a3 1
   Copyright 2001, 2002 Red Hat, Inc
@


1.23
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d626 7
@


1.23.4.1
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d423 1
a423 1
  fhandler_base ()
@


1.22
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d484 2
a485 2
int __stdcall
fhandler_dev_dsp::read (void *ptr, size_t len)
d487 1
a487 1
  return len;
@


1.21
log
@* cygheap.cc (init_cheap): Rearrange error message.
(cygheap_fixup_in_child): Ditto.
* dtable.cc: Remove if 0'ed code.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode.
* sec_helper.cc (cygsid::get_id): Use system_printf for error message.
* tty.cc (tty::common_init): Ditto.
@
text
@d96 1
a96 1
  debug_printf ("number devices %d\n", nDevices);
d101 1
a101 1
		"channels %d, callback %d\n", rate, bits, channels,
d522 1
a522 1
#define CASE(a) case a : debug_printf("/dev/dsp: ioctl %s\n", #a);
d627 1
a627 1
      debug_printf ("/dev/dsp: ioctl not handled yet! FIXME:\n");
@


1.20
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d441 1
a441 1
  set_flags (flags & ~O_TEXT, O_BINARY);
@


1.19
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::open): Set errno to EACCES if
	requested mode isn't supported.
@
text
@a17 1
#include <sys/fcntl.h>
d441 1
a441 1
  set_flags (flags);
d453 1
d455 1
a455 1
    debug_printf ("/dev/dsp: failed to open\n");
d459 1
a459 1
      debug_printf ("/dev/dsp: successfully opened\n");
d461 3
a463 1
  return 1;
@


1.18
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@d437 4
a440 1
    return 0;
@


1.17
log
@* fhandler.cc (fhandler_base::puts_readahead): Remove default parameter
setting.  Newer gcc's complain about this.
(fhandler_base::set_readahead_valid): Ditto.
* fhandler_dsp.cc (Audio::open): Ditto.
(fhandler_dev_dsp::open): Ditto.
@
text
@d485 2
a486 2
__off32_t
fhandler_dev_dsp::lseek (__off32_t offset, int whence)
@


1.16
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d89 1
a89 1
Audio::open (int rate, int bits, int channels, bool bCallback = false)
d433 1
a433 1
fhandler_dev_dsp::open (path_conv *, int flags, mode_t mode = 0)
@


1.15
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 2001 Red Hat, Inc
@


1.14
log
@Eliminate excess whitespace.
@
text
@d485 2
a486 2
off_t
fhandler_dev_dsp::lseek (off_t offset, int whence)
@


1.13
log
@Ensure that all fhandler_*::read definitions are __stdcall throughout.
* fhandler.cc (fhandler_base::set_inheritance): Be more defensive in debugging
code.
* fhandler.h: Adjust regparms throughout to reflect passing 'this' parameter.
* fhandler_console.cc (fhandler_console::read): Remove unneeded test.  Only
honor "key down" events.
* miscfuncs.cc (strcasestr): Reorganize for efficient code use.
(check_null_empty_str_errno): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
* syscalls.cc (_read): Return 0 when length == 0, as per Single UNIX
Specification.
@
text
@d528 1
a528 2
        return 0;
	break;
@


1.12
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d479 1
a479 1
int
@


1.11
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@a425 1
  set_cb (sizeof *this);
@


1.10
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d423 2
a424 2
fhandler_dev_dsp::fhandler_dev_dsp (const char *name):
  fhandler_base (FH_OSS_DSP, name)
d529 1
@


1.9
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d434 1
a434 1
fhandler_dev_dsp::open (const char *path, int flags, mode_t mode = 0)
a445 2
  if (strcmp (path, "/dev/dsp") == 0L)
    {
d447 4
a450 5
      audioformat_ = AFMT_S8;
      audiofreq_ = 8000;
      audiobits_ = 8;
      audiochannels_ = 1;
    }
@


1.9.4.1
log
@Merged changes from HEAD
@
text
@d423 2
a424 2
fhandler_dev_dsp::fhandler_dev_dsp ():
  fhandler_base (FH_OSS_DSP)
d426 1
d434 1
a434 1
fhandler_dev_dsp::open (path_conv *, int flags, mode_t mode = 0)
d446 2
d449 5
a453 4
  audioformat_ = AFMT_S8;
  audiofreq_ = 8000;
  audiobits_ = 8;
  audiochannels_ = 1;
d483 1
a483 1
int __stdcall
d532 1
a532 1
	return 0;
@


1.9.4.2
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2001, 2002 Red Hat, Inc
d89 1
a89 1
Audio::open (int rate, int bits, int channels, bool bCallback)
d433 1
a433 1
fhandler_dev_dsp::open (path_conv *, int flags, mode_t mode)
d485 2
a486 2
__off64_t
fhandler_dev_dsp::lseek (__off64_t offset, int whence)
@


1.9.4.3
log
@Merged changes from HEAD
@
text
@d18 1
d437 1
a437 4
    {
      set_errno (EACCES);
      return 0;
    }
d439 1
a439 1
  set_flags (flags & ~O_TEXT, O_BINARY);
a450 1
  int res;
d452 1
a452 1
    res = 0;
d456 1
a456 1
      res = 1;
d458 1
a458 3

  debug_printf ("returns %d", res);
  return res;
@


1.9.4.4
log
@Merged changes from HEAD
@
text
@d441 1
a441 1
  set_flags ((flags & ~O_TEXT) | O_BINARY);
@


1.8
log
@* fhandler_dsp.cc (fhandler_dev_dsp::ioctl): Return 0 for success.
@
text
@a15 2
#include "cygerrno.h"
#include "fhandler.h"
d20 3
@


1.7
log
@* mmap.cc: Clean up *ResourceLock calls throughout.
* thread.cc (pthread_cond::TimedWait): Check for WAIT_TIMEOUT as well as
WAIT_ABANDONED.
(__pthread_cond_timedwait): Calculate a relative wait from the abstime
parameter.
@
text
@d527 1
a527 1
	return 1;
d549 1
a549 1
		return 1;
d565 1
a565 1
	    return 1;
d582 1
a582 1
	    return 1;
d612 1
a612 1
	return 1;
d620 1
a620 1
	return 1;
@


1.6
log
@forced commit
@
text
@d2 1
a2 1
 
d4 1
a4 1
 
d6 1
a6 1
 
d8 1
a8 1
 
@


1.5
log
@* exceptions.cc (handle_exceptions): Bump repeat count for debugging kick out.
* fhandler.h (fhandler_dev_dsp): Add a fixup_after_exec.
* fhandler_dsp.cc (class Audio): Add TOT_BLOCK_SIZE to enum.
(operator new): New.
(bigwavebuffer): Declare using TOT_BLOCK_SIZE to avoid buffer overruns.
(Audio::Audio): Optimize slightly.
(fhandler_dev_dsp::open): Allocate s_audio using static buffer.
(fhandler_dev_dsp::fixup_after_exec): New function.  Ditto.
@
text
@@


1.4
log
@* fhandler_dsp.cc: Reformat to GNU standards.
(s_audio): Change to a pointer throughout.
(fhandler_dev_dsp::open): Initialize s_audio, if required.
@
text
@d31 6
a36 1
  enum { MAX_BLOCKS = 12, BLOCK_SIZE = 16384 };
d51 2
d67 1
a67 1
  char bigwavebuffer_[MAX_BLOCKS * BLOCK_SIZE];
d70 2
a73 2
  int size = BLOCK_SIZE + sizeof (WAVEHDR);

d75 1
a75 1
  memset (freeblocks_, 0, sizeof (freeblocks_));
d77 1
a77 5
    {
      char *pBuffer = &bigwavebuffer_[i * size];
      memset (pBuffer, 0, size);
      freeblocks_[i] = pBuffer;
    }
d442 1
a442 1
    s_audio = new Audio;
d637 7
@


1.3
log
@        * fhandler_dsp.cc: Improved handling of 8 bit playback modes.
        Put in mock support for SNDCTL_DSP_SETFRAGMENT.
@
text
@d2 1
a2 1

d4 1
a4 1

d6 1
a6 1

d8 1
a8 1

d25 3
a27 3
// 
static void CALLBACK wave_callback(HWAVE hWave, UINT msg, DWORD instance, 
			           DWORD param1, DWORD param2);
d33 3
a35 3
  Audio ();
  ~Audio ();
  
d43 1
a43 1
  void setformat(int format) { formattype_ = format; }
d45 1
a45 1
  
d50 1
a50 1
   
d63 1
a63 1
Audio::Audio()
d65 4
a68 4
  int size = BLOCK_SIZE + sizeof(WAVEHDR);
  
  InitializeCriticalSection(&lock_);
  memset(freeblocks_, 0, sizeof(freeblocks_));
d71 2
a72 2
      char *pBuffer = &bigwavebuffer_[ i * size ];
      memset(pBuffer, 0, size);
d77 1
a77 1
Audio::~Audio()
d80 2
a81 2
    close();
  DeleteCriticalSection(&lock_);
d84 2
a85 2
bool 
Audio::open(int rate, int bits, int channels, bool bCallback = false)
d88 2
a89 2
  int nDevices = waveOutGetNumDevs();
  
d93 1
a93 1
  debug_printf("number devices %d\n", nDevices); 
d96 4
a99 4
  
  debug_printf("trying to map device freq %d, bits %d, "
	       "channels %d, callback %d\n", rate, bits, channels, 
	       bCallback); 
d102 2
a103 2
  
  memset(&format, 0, sizeof(format));
d108 3
a110 3
  format.nAvgBytesPerSec = format.nSamplesPerSec * format.nChannels * 
			   bytesperSample;
  format.nBlockAlign = format.nChannels * bytesperSample;  
d113 2
a114 2
  HRESULT res = waveOutOpen(&dev_, WAVE_MAPPER, &format, (DWORD)wave_callback,
			    (DWORD)this, bCallback ? CALLBACK_FUNCTION : 0);
d117 1
a117 1
      debug_printf("Sucessfully opened!");
d122 1
a122 1
      debug_printf("failed to open");
d127 2
a128 2
void 
Audio::close()
d131 5
a135 2
    {	
      flush();		// force out last block whatever size..	
d137 2
a138 5
      while (blocks())	// block till finished..
	waitforcallback();
      
      waveOutReset(dev_);
      waveOutClose(dev_);
d145 1
a145 1
Audio::numbytesoutput()
d150 2
a151 2
int 
Audio::getvolume()
d154 3
a156 3
  
  waveOutGetVolume(dev_, &volume);
  return ((volume >> 16) + (volume & 0xffff)) >> 1;    
d159 2
a160 2
void 
Audio::setvolume(int newVolume)
d162 1
a162 1
  waveOutSetVolume(dev_, (newVolume<<16)|newVolume);    
d166 1
a166 1
Audio::initialisebuffer()
d168 1
a168 1
  EnterCriticalSection(&lock_);
d175 1
a175 1
	  pHeader = (WAVEHDR *)pData;    
d178 2
a179 2
	      waveOutUnprepareHeader(dev_, pHeader, sizeof(WAVEHDR));   
	    }	
d184 1
a184 1
  LeaveCriticalSection(&lock_); 
d188 1
a188 1
      memset(pHeader, 0, sizeof(WAVEHDR));
d190 2
a191 2
      pHeader->lpData = (LPSTR)(&pHeader[1]);
      return (char *)pHeader->lpData;
d196 2
a197 2
bool 
Audio::write(const void *pSampleData, int nBytes)
d202 1
a202 1
      write(pSampleData, BLOCK_SIZE);
d204 1
a204 1
      pSampleData = (void *)((char *)pSampleData + BLOCK_SIZE);
d208 2
a209 2
  if (blocks() == MAX_BLOCKS)
      waitforcallback();
d214 1
a214 1
      buffer_ = initialisebuffer();
d218 1
a218 1
  
d224 1
a224 1
      memcpy(&buffer_[bufferIndex_], pSampleData, nBytes);
d229 3
a231 3
  
  // flushing when we reach our limit of BLOCK_SIZE 
  memcpy(&buffer_[bufferIndex_], pSampleData, sizeleft);
d233 3
a235 3
  nBytesWritten_ += sizeleft;	
  flush();
      
d237 2
a238 2
  pSampleData = (void *)((char *)pSampleData + sizeleft);
  nBytes -= sizeleft;	
d242 2
a243 2
    return write(pSampleData, nBytes);
  
d248 2
a249 2
int 
Audio::blocks()
d251 1
a251 1
  EnterCriticalSection(&lock_);
d253 1
a253 1
  LeaveCriticalSection(&lock_);
d257 1
a257 1
// This is called on an interupt so use locking.. Note nBlocksInQue_ is 
d259 2
a260 2
void 
Audio::callback_sampledone(void *pData)
d262 3
a264 3
  EnterCriticalSection(&lock_);
  
  nBlocksInQue_--; 
d268 1
a268 1
	freeblocks_[i] = (char *)pData;
d271 2
a272 2
  
  LeaveCriticalSection(&lock_);  
d276 1
a276 1
Audio::waitforcallback()
d278 1
a278 1
  int n = blocks();
d280 1
a280 1
      return;
d283 1
a283 1
      Sleep(250);
d285 1
a285 1
  while (n == blocks());
d289 1
a289 1
Audio::flush()
d292 2
a293 2
      return false;
  
d295 1
a295 1
  WAVEHDR *pHeader = ((WAVEHDR *)buffer_) - 1;
d301 1
a301 1
      unsigned char *p = ((unsigned char *)buffer_);
d303 1
a303 1
        {
d305 1
a305 1
        }
d307 5
a311 5
  
  if (waveOutPrepareHeader(dev_, pHeader, sizeof(WAVEHDR)) == S_OK &&
      waveOutWrite(dev_, pHeader, sizeof (WAVEHDR)) == S_OK)
    {	    
      EnterCriticalSection(&lock_);
d313 1
a313 1
      LeaveCriticalSection(&lock_);
d320 1
a320 1
      EnterCriticalSection(&lock_);
d323 5
a327 5
	{
	  freeblocks_[i] = (char *)pHeader;
	  break;
        }
      LeaveCriticalSection(&lock_);
d334 3
a336 2
static void CALLBACK 
wave_callback(HWAVE hWave, UINT msg, DWORD instance, DWORD param1, DWORD param2)
d340 2
a341 2
      Audio *ptr = (Audio *)instance;
      ptr->callback_sampledone((void *)param1);
d344 1
a344 1
  
d347 1
a347 1
static Audio s_audio;	      // static instance of the Audio handler
d353 1
a353 1
{ 
d369 1
a369 1
fhandler_dev_dsp::setupwav(const char *pData, int nBytes)
d374 1
a374 1
  if (!(pData[0] == 'R' && pData[1] == 'I' && 
d377 2
a378 2
  if (!(pData[8]  == 'W' && pData[9]  == 'A' && 
        pData[10] == 'V' && pData[11] == 'E'))
d380 2
a381 2
  
  len = *(int *)&pData[4];  
d384 4
a387 4
    { 
      wavchunk *pChunk = (wavchunk *)pData;
      int blklen = pChunk->len;	      
      if (pChunk->id[0] == 'f' && pChunk->id[1] == 'm' && 
d390 2
a391 2
	  wavformat *format = (wavformat *)(pChunk+1);
	  if ((char *)(format+1) > end)
d393 1
a393 1
      
d395 1
a395 1
	  // 
d398 3
a400 3
	  s_audio.close();
	  if (s_audio.open(format->dwSamplesPerSec, format->wBitsPerSample,
			   format->wChannels) == false)
d402 1
a402 1
	      s_audio.open(audiofreq_, audiobits_, audiochannels_);
d413 1
a413 1
      pData += blklen + sizeof(wavchunk);
d419 2
a420 2
fhandler_dev_dsp::fhandler_dev_dsp (const char *name)
  : fhandler_base (FH_OSS_DSP, name)
d422 1
a422 1
  set_cb (sizeof *this);     
d425 1
a425 1
fhandler_dev_dsp::~fhandler_dev_dsp()
d432 2
a433 2
  // currently we only support writing    
  if ((flags & (O_WRONLY|O_RDONLY|O_RDWR)) != O_WRONLY)
d435 5
a439 2
  
  set_flags(flags);
d442 1
a442 1
  if (strcmp(path, "/dev/dsp") == 0L)
d451 2
a452 2
  if (!s_audio.open(audiofreq_, audiobits_, audiochannels_))
    debug_printf("/dev/dsp: failed to open\n");   
d456 1
a456 1
      debug_printf("/dev/dsp: successfully opened\n"); 
d464 1
a464 1
  if (s_audio.numbytesoutput() == 0)
d467 2
a468 2
      setupwav((const char *)ptr, len);
 
d470 3
a472 3
      s_audio.close();
      if (!s_audio.open(audiofreq_, audiobits_, audiochannels_, true))
        return 0;
d474 2
a475 2
  
  s_audio.write(ptr, len);
d494 1
a494 1
  s_audio.close();
d501 1
a501 1
  fhandler_dev_dsp *fhc = (fhandler_dev_dsp *)child;
d503 1
a503 1
  fhc->set_flags(get_flags());
d511 2
a512 2
int 
fhandler_dev_dsp::ioctl(unsigned int cmd, void *ptr)
d514 1
a514 1
  int *intptr = (int *)ptr;
d517 8
a524 12
      #define CASE(a) case a : debug_printf("/dev/dsp: ioctl %s\n", #a); 
      
      CASE(SNDCTL_DSP_RESET)
	  audioformat_ = AFMT_S8;
	  audiofreq_ = 8000;
	  audiobits_ = 8;
	  audiochannels_ = 1;
	  return 1;
      
      CASE(SNDCTL_DSP_GETBLKSIZE)
	  *intptr = Audio::BLOCK_SIZE;
	  break;
d526 3
a528 56
      CASE(SNDCTL_DSP_SETFMT)	 
	{
	  int nBits = 0;
	  if (*intptr == AFMT_S16_LE)
	      nBits = 16;
	  else if (*intptr == AFMT_U8)
	      nBits = 8;	  
	  else if (*intptr == AFMT_S8)
	      nBits = 8;	  
	  if (nBits)
	    {
	      s_audio.setformat(*intptr);
	      s_audio.close();
	      if (s_audio.open(audiofreq_, nBits, audiochannels_) == true)
		{
		  audiobits_ = nBits;
		  return 1;
		}
	      else
		{
		  s_audio.open(audiofreq_, audiobits_, audiochannels_);
		  return -1;
		}
	    }
	}  break;
      
      CASE(SNDCTL_DSP_SPEED)
	  s_audio.close();
	  if (s_audio.open(*intptr, audiobits_, audiochannels_) == true)
	    {
	      audiofreq_ = *intptr;
	      return 1;
	    }
	  else
	    {
	      s_audio.open(audiofreq_, audiobits_, audiochannels_);
	      return -1;
	    }
	  break;
      
      CASE(SNDCTL_DSP_STEREO)
	{
	  int nChannels = *intptr + 1;
	  
	  s_audio.close();
	  if (s_audio.open(audiofreq_, audiobits_, nChannels) == true)
	    {
	      audiochannels_ = nChannels;
	      return 1;
	    }
	  else
	    {
	      s_audio.open(audiofreq_, audiobits_, audiochannels_);
	      return -1;
	    }
	} break;
d530 26
a555 3
      CASE(SNDCTL_DSP_GETOSPACE)
	{
	  audio_buf_info *p = (audio_buf_info *)ptr;
d557 12
a568 30
	  int nBlocks = s_audio.blocks();
	  int leftblocks = ((Audio::MAX_BLOCKS - nBlocks)-1);
	  if (leftblocks < 0) leftblocks = 0;
	  if (leftblocks > 1)
	    leftblocks = 1;
	  int left = leftblocks * Audio::BLOCK_SIZE;
	 
	  p->fragments = leftblocks;
	  p->fragstotal = Audio::MAX_BLOCKS;
	  p->fragsize = Audio::BLOCK_SIZE;
	  p->bytes = left;

	  debug_printf("ptr: %p "
		       "nblocks: %d "
		       "leftblocks: %d "
		       "left bytes: %d ", ptr, nBlocks, leftblocks, left);
	  
	  
	  return 1;
	} break;

      CASE(SNDCTL_DSP_SETFRAGMENT)
        {
	  // Fake!! esound & mikmod require this on non PowerPC platforms.
	  // 
	  return 1;
	} break;
        
      default:
	debug_printf("/dev/dsp: ioctl not handled yet! FIXME:\n"); 
d571 55
a625 1
      #undef CASE
d633 1
a633 1
  paranoid_printf("here, fhandler_dev_dsp");
a634 1

@


1.2
log
@Remove trailing underscore from fhandler_base and friends, throughout.
* fhandler.h (fhandler_base::set_open_status): New method.  Stores original
open status.
(fhandler_base::get_open_status): New method.  Retrieves original open status.
(fhandler_base::reset_to_open_binmode): New method.
* fhandler.cc (fhandler_base::open): Save open status.
(fhandler_base::init): Ditto.
* fhandler_clipboard.cc (fhandler_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
* fhandler_dsp.cc (fhandler_dsp::open): Ditto.
* fhandler_dev_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_dev_random.cc (fhandler_dev_random::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tty_slave.cc (fhandler_tty_slave::open): Ditto.
* fhandler_tty_master.cc (fhandler_tty_master::open): Ditto.
* fhandler_dev_zero.cc (fhandler_dev_zero::open): Ditto.
* syscalls.cc (setmode): Rework so that 0 mode value causes reversion to open
state.
* fhandler_tty_slave.cc (fhandler_tty_slave::read): Use correct multiplier when
converting from deciseconds to milliseconds.
@
text
@d31 1
a31 1
  enum { MAX_BLOCKS = 8, BLOCK_SIZE = 16384 };
d43 1
a43 1
  
d58 1
d297 11
d531 2
d537 1
d607 8
a614 1
      
@


1.1
log
@* autoload.cc: Add winmm functions needed by fhandler_dsp.cc.
* fhandler_dsp.cc: New file.  Implements OSS like /dev/dsp.
* include/sys/soundcard.h: New file.  User land includes for OSS /dev/dsp.
* fhandler.h: Add new class fhandler_dev_dsp and a FH_OSS_DSP definition.
* dtable.cc (dtable::build_fhandler): Allow creation of the /dev/dsp device.
* path.cc (windows_device_names): Add /dev/dsp into list of device names.
* Makefile.in (DLL_OFILES): Add fhandler_dsp.o.
@
text
@d435 2
a436 2
  if (s_audio.open(audiofreq_, audiobits_, audiochannels_))
    debug_printf("/dev/dsp: successfully opened\n"); 
d438 4
a441 1
    debug_printf("/dev/dsp: failed to open\n");   
@

