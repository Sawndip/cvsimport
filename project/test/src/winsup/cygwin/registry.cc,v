head	1.50;
access;
symbols
	cygwin-1_7_35-release:1.50
	cygwin-1_7_34-release:1.50
	cygwin-1_7_33-release:1.49
	cygwin-1_7_32-release:1.49
	cygwin-1_7_31-release:1.49
	cygwin-1_7_30-release:1.49
	cygwin-1_7_29-release:1.49
	cygwin-1_7_29-release-branchpoint:1.49.0.2
	cygwin-pre-user-db:1.49
	cygwin-1_7_28-release:1.49
	cygwin-1_7_27-release:1.49
	cygwin-1_7_26-release:1.49
	cygwin-1_7_25-release:1.49
	cygwin-1_7_24-release:1.49
	cygwin-1_7_23-release:1.49
	cygwin-1_7_22-release:1.49
	cygwin-1_7_21-release:1.49
	cygwin-1_7_20-release:1.49
	cygwin-1_7_19-release:1.49
	cygwin-64bit-postmerge:1.49
	cygwin-64bit-premerge-branch:1.48.0.2
	cygwin-64bit-premerge:1.48
	cygwin-1_7_18-release:1.48
	post-ptmalloc3:1.47.2.2
	pre-ptmalloc3:1.47.2.2
	cygwin-1_7_17-release:1.47
	cygwin-64bit-branch:1.47.0.2
	cygwin-1_7_16-release:1.47
	cygwin-1_7_15-release:1.46
	cygwin-1_7_14_2-release:1.46
	cygwin-1_7_14-release:1.46
	cygwin-1_7_12-release:1.46
	cygwin-1_7_11-release:1.46
	cygwin-1_7_10-release:1.45
	signal-rewrite:1.45.0.2
	pre-notty:1.45
	cygwin-1_7_9-release:1.41
	cv-post-1_7_9:1.41.0.2
	cygwin-1_7_8-release:1.41
	cygwin-1_7_7-release:1.41
	cygwin-1_7_5-release:1.40
	cygwin-1_7_4-release:1.40
	cygwin-1_7_3-release:1.40
	cygwin-1_7_2-release:1.40
	fifo_doover3:1.39.0.2
	cygwin-1_7_1-release:1.38
	prefifo:1.37
	cv-branch-2:1.37.0.2
	pre-ripout-set_console_state_for_spawn:1.36
	EOL_registry_mounts:1.34
	preoverlapped:1.29
	drop_9x_support_start:1.28
	cr-0x5f1:1.28.0.8
	cv-branch:1.28.0.6
	pre-ptymaster-archetype:1.28
	cr-0x3b58:1.28.0.4
	cr-0x5ef:1.28.0.2
	after-mmap-privanon-noreserve:1.27
	after-mmap-revamp:1.27
	before-mmap-revamp:1.27
	cgf-more-exit-sync:1.27
	post_wait_sig_exit:1.27
	pre_wait_sig_exit:1.27
	reparent-point:1.20
	noreparent:1.20.0.2
	cr-0x5e6:1.19.0.2
	cr-0x9e:1.18.0.6
	cr-0x9d:1.18.0.4
	cgf-deleteme:1.18.0.2
	pre-sigrewrite:1.18
	corinna-01:1.17
	cr-0x9c:1.17.0.4
	cr-0x9b:1.17.0.2
	cr-0x99:1.16
	Z-emcb-cygwin_daemon:1.16.0.2
	w32api-2_2:1.16
	mingw-runtime-2_4:1.16
	pre-cgf-merge:1.17
	cgf-dev-branch:1.16.0.20
	predaemon:1.14
	cygwin_daemon_merge_HEAD:1.14
	pregp02r1:1.14.0.34
	cygnus_cvs_20020108_pre:1.14
	Z-cygwin_daemon_merge-new_HEAD:1.16
	Z-cygwin_daemon_merge_HEAD:1.16
	cygwin_daemon:1.14.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.50
date	2014.12.02.10.49.46;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2012.05.25.14.49.56;	author corinna;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2012.02.10.20.56.22;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2011.06.06.05.02.12;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2011.05.07.18.56.39;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.23.13.15.46;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.19.10.02.06;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.18.14.30.51;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2010.02.12.01.04.52;	author phumblet;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.16.13.09.46;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.20.14.54.47;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.03.05.12.21;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2008.04.21.14.00.24;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2008.03.07.11.24.51;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.14.16.47.11;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.05.15.10.19;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.03.17.44.26;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.03.13.06.42;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.03.08.45.20;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.20.04.25.32;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.13.18.17.29;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.12.22.40.45;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.03.02.00.37;	author phumblet;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.20.19.09.18;	author phumblet;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.26.01.53.27;	author phumblet;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.19.19.29.10;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.10.21.01.40;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches
	1.16.20.1;
next	1.15;

1.15
date	2002.05.06.10.05.46;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.15.19.23.31;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.07.16.23.50;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.28.22.33.43;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.22.18.54.26;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.19.17.36.30;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.23.14.08.52;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.24.02.49.44;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.47.2.1
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	;

1.16.20.1
date	2003.09.11.04.47.22;	author cgf;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.13.14.34.10;	author rbcollins;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.50
log
@	* autoload.cc (CreateProfile): Import.
	(LoadUserProfileW): Import.
	* registry.cc (get_registry_hive_path): Move to sec_auth.cc.
	(load_registry_hive): Remove.
	* registry.h (get_registry_hive_path): Drop declaration.
	(load_registry_hive): Ditto.
	* sec_auth.cc (get_user_profile_directory): Moved from registry.cc and
	renamed.  Take third parameter with buffer length.
	(load_user_profile): New function taking over for load_registry_hive.
	Use official functions to load profile.  If profile is missing, create
	it on Vista and later.
	* security.h (get_user_profile_directory): Declare.
	(load_user_profile): Declare.
	* syscalls.cc (seteuid32): Replace call to load_registry_hive with call
	to load_user_profile.
	* uinfo.cc (cygheap_user::env_userprofile): Replace call to
	get_registry_hive_path with call to get_user_profile_directory.
@
text
@/* registry.cc: registry interface

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "registry.h"
#include "cygerrno.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "tls_pbuf.h"
#include "ntdll.h"
#include <wchar.h>

/* Opens a key under the appropriate Cygwin key.
   Do not use HKCU per MS KB 199190  */
static NTSTATUS
top_key (bool isHKLM, REGSAM access, PHANDLE top)
{
  WCHAR rbuf[PATH_MAX], *p;
  UNICODE_STRING rpath;
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;

  InitializeObjectAttributes (&attr, &rpath, OBJ_CASE_INSENSITIVE, NULL, NULL);
  if (isHKLM)
    {
      wcpcpy (rbuf, L"\\Registry\\Machine");
      RtlInitUnicodeString (&rpath, rbuf);
      status = NtOpenKey (top, access, &attr);
    }
  else
    {
      WCHAR name[128];
      PCWSTR names[2] = {cygheap->user.get_windows_id (name),
			 L".DEFAULT"};

      p = wcpcpy (rbuf, L"\\Registry\\User\\");
      for (int i = 0; i < 2; i++)
	{
	  wcpcpy (p, names[i]);
	  RtlInitUnicodeString (&rpath, rbuf);
	  status = NtOpenKey (top, access, &attr);
	  if (NT_SUCCESS (status))
	    break;
	}
    }
  return status;
}

reg_key::reg_key (HKEY top, REGSAM access, ...): _disposition (0)
{
  va_list av;
  va_start (av, access);
  build_reg (top, access, av);
  va_end (av);
}

reg_key::reg_key (bool isHKLM, REGSAM access, ...): _disposition (0)
{
  va_list av;
  HANDLE top;

  key_is_invalid = top_key (isHKLM, access, &top);
  if (NT_SUCCESS (key_is_invalid))
    {
      new (this) reg_key ((HKEY) top, access, L"SOFTWARE",
			  _WIDE (CYGWIN_INFO_CYGWIN_REGISTRY_NAME), NULL);
      NtClose (top);
      if (key_is_invalid)
	return;
      top = key;
      va_start (av, access);
      build_reg ((HKEY) top, access, av);
      va_end (av);
      if (top != key)
	NtClose (top);
    }
}

void
reg_key::build_reg (HKEY top, REGSAM access, va_list av)
{
  PWCHAR name;
  HANDLE r;
  UNICODE_STRING uname;
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;

  if (top != HKEY_LOCAL_MACHINE && top != HKEY_CURRENT_USER)
    r = (HANDLE) top;
  else if (!NT_SUCCESS (top_key (top == HKEY_LOCAL_MACHINE, access, &r)))
    return;
  key_is_invalid = 0;
  while ((name = va_arg (av, PWCHAR)) != NULL)
    {
      RtlInitUnicodeString (&uname, name);
      InitializeObjectAttributes (&attr, &uname,
				  OBJ_CASE_INSENSITIVE | OBJ_OPENIF, r, NULL);

      status = NtCreateKey (&key, access, &attr, 0, NULL,
			    REG_OPTION_NON_VOLATILE, &_disposition);
      if (r != (HANDLE) top)
	NtClose (r);
      r = key;
      if (!NT_SUCCESS (status))
	{
	  key_is_invalid = status;
	  debug_printf ("failed to create key %S in the registry", &uname);
	  break;
	}
    }
}

/* Given the current registry key, return the specific DWORD value
   requested.  Return def on failure. */

DWORD
reg_key::get_dword (PCWSTR name, DWORD def)
{
  if (key_is_invalid)
    return def;

  NTSTATUS status;
  UNICODE_STRING uname;
  ULONG size = sizeof (KEY_VALUE_PARTIAL_INFORMATION) + sizeof (DWORD);
  ULONG rsize;
  PKEY_VALUE_PARTIAL_INFORMATION vbuf = (PKEY_VALUE_PARTIAL_INFORMATION)
				      alloca (size);

  RtlInitUnicodeString (&uname, name);
  status = NtQueryValueKey (key, &uname, KeyValuePartialInformation, vbuf,
			    size, &rsize);
  if (status != STATUS_SUCCESS || vbuf->Type != REG_DWORD)
    return def;
  DWORD *dst = (DWORD *) vbuf->Data;
  return *dst;
}

/* Given the current registry key, set a specific DWORD value. */

NTSTATUS
reg_key::set_dword (PCWSTR name, DWORD val)
{
  if (key_is_invalid)
    return key_is_invalid;

  DWORD value = (DWORD) val;
  UNICODE_STRING uname;
  RtlInitUnicodeString (&uname, name);
  return NtSetValueKey (key, &uname, 0, REG_DWORD, &value, sizeof (value));
}

/* Given the current registry key, return the specific string value
   requested.  Return zero on success, non-zero on failure. */

NTSTATUS
reg_key::get_string (PCWSTR name, PWCHAR dst, size_t max, PCWSTR def)
{
  NTSTATUS status;

  if (key_is_invalid)
    {
      status = key_is_invalid;
      if (def != NULL)
	wcpncpy (dst, def, max);
    }
  else
    {
      UNICODE_STRING uname;
      ULONG size = sizeof (KEY_VALUE_PARTIAL_INFORMATION) + max * sizeof (WCHAR);
      ULONG rsize;
      PKEY_VALUE_PARTIAL_INFORMATION vbuf = (PKEY_VALUE_PARTIAL_INFORMATION)
					  alloca (size);

      RtlInitUnicodeString (&uname, name);
      status = NtQueryValueKey (key, &uname, KeyValuePartialInformation, vbuf,
				size, &rsize);
      if (status != STATUS_SUCCESS || vbuf->Type != REG_SZ)
	wcpncpy (dst, def, max);
      else
	wcpncpy (dst, (PWCHAR) vbuf->Data, max);
    }
  return status;
}

/* Given the current registry key, set a specific string value. */

NTSTATUS
reg_key::set_string (PCWSTR name, PCWSTR src)
{
  if (key_is_invalid)
    return key_is_invalid;

  UNICODE_STRING uname;
  RtlInitUnicodeString (&uname, name);
  return NtSetValueKey (key, &uname, 0, REG_SZ, (PVOID) src,
			(wcslen (src) + 1) * sizeof (WCHAR));
}

reg_key::~reg_key ()
{
  if (!key_is_invalid)
    NtClose (key);
  key_is_invalid = 1;
}
@


1.49
log
@	* Merge in cygwin-64bit-branch.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
a21 1
#include <alloca.h>
a214 93

/* The buffer path points to should be at least MAX_PATH bytes. */
PWCHAR
get_registry_hive_path (PCWSTR name, PWCHAR path)
{
  if (!name || !path)
    return NULL;

  WCHAR key[256];
  UNICODE_STRING buf;
  tmp_pathbuf tp;
  tp.u_get (&buf);
  NTSTATUS status;

  RTL_QUERY_REGISTRY_TABLE tab[2] = {
    { NULL, RTL_QUERY_REGISTRY_NOEXPAND | RTL_QUERY_REGISTRY_DIRECT
	    | RTL_QUERY_REGISTRY_REQUIRED,
      L"ProfileImagePath", &buf, REG_NONE, NULL, 0 },
    { NULL, 0, NULL, NULL, 0, NULL, 0 }
  };
  wcpcpy (wcpcpy (key, L"ProfileList\\"), name);
  status = RtlQueryRegistryValues (RTL_REGISTRY_WINDOWS_NT, key, tab,
				   NULL, NULL);
  if (!NT_SUCCESS (status) || buf.Length == 0)
    {
      debug_printf ("ProfileImagePath for %W not found, status %y", name,
		    status);
      return NULL;
    }
  ExpandEnvironmentStringsW (buf.Buffer, path, MAX_PATH);
  debug_printf ("ProfileImagePath for %W: %W", name, path);
  return path;
}

void
load_registry_hive (PCWSTR name)
{
  if (!name)
    return;

  /* Fetch the path. Prepend native NT path prefix. */
  tmp_pathbuf tp;
  PWCHAR path = tp.w_get ();
  if (!get_registry_hive_path (name, wcpcpy (path, L"\\??\\")))
    return;

  WCHAR key[256];
  PWCHAR path_comp;
  UNICODE_STRING ukey, upath;
  OBJECT_ATTRIBUTES key_attr, path_attr;
  NTSTATUS status;

  /* Create keyname and path strings and object attributes. */
  wcpcpy (wcpcpy (key, L"\\Registry\\User\\"), name);
  RtlInitUnicodeString (&ukey, key);
  InitializeObjectAttributes (&key_attr, &ukey, OBJ_CASE_INSENSITIVE,
			      NULL, NULL);
  /* First try to load the "normal" registry hive, which is what the user
     is supposed to see under HKEY_CURRENT_USER. */
  path_comp = wcschr (path, L'\0');
  wcpcpy (path_comp, L"\\ntuser.dat");
  RtlInitUnicodeString (&upath, path);
  InitializeObjectAttributes (&path_attr, &upath, OBJ_CASE_INSENSITIVE,
			      NULL, NULL);
  status = NtLoadKey (&key_attr, &path_attr);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("Loading user registry hive %S into %S failed: %y",
		    &upath, &ukey, status);
      return;
    }
  debug_printf ("Loading user registry hive %S into %S SUCCEEDED: %y",
		&upath, &ukey, status);
  /* If loading the normal hive worked, try to load the classes hive into
     the sibling *_Classes subkey, which is what the user is supposed to
     see under HKEY_CLASSES_ROOT, merged with the machine-wide classes. */
  wcscat (key, L"_Classes");
  RtlInitUnicodeString (&ukey, key);
  /* Path to UsrClass.dat changed in Vista to
     \\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat
     but old path is still available via symlinks. */
  wcpcpy (path_comp, L"\\Local Settings\\Application Data\\Microsoft\\"
		      "Windows\\UsrClass.dat");
  RtlInitUnicodeString (&upath, path);
  /* Load UsrClass.dat file into key. */
  status = NtLoadKey (&key_attr, &path_attr);
  if (!NT_SUCCESS (status))
    debug_printf ("Loading user classes hive %S into %S failed: %y",
		  &upath, &ukey, status);
  else
    debug_printf ("Loading user classes hive %S into %S SUCCEEDED: %y",
		  &upath, &ukey, status);
}
@


1.48
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d241 1
a241 1
      debug_printf ("ProfileImagePath for %W not found, status %p", name,
d283 1
a283 1
      debug_printf ("Loading user registry hive %S into %S failed: %p",
d287 1
a287 1
  debug_printf ("Loading user registry hive %S into %S SUCCEEDED: %p",
d303 1
a303 1
    debug_printf ("Loading user classes hive %S into %S failed: %p",
d306 1
a306 1
    debug_printf ("Loading user classes hive %S into %S SUCCEEDED: %p",
@


1.47
log
@	* registry.cc (reg_key::build_reg): Fix typo in debug output.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.47.2.1
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d241 1
a241 1
      debug_printf ("ProfileImagePath for %W not found, status %y", name,
d283 1
a283 1
      debug_printf ("Loading user registry hive %S into %S failed: %y",
d287 1
a287 1
  debug_printf ("Loading user registry hive %S into %S SUCCEEDED: %y",
d303 1
a303 1
    debug_printf ("Loading user classes hive %S into %S failed: %y",
d306 1
a306 1
    debug_printf ("Loading user classes hive %S into %S SUCCEEDED: %y",
@


1.47.2.2
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.46
log
@	* miscfuncs.cc (DEFAULT_STACKSIZE): Set to 1 Megs.  Drop comment about
	RLIMIT_STACK.

	* registry.cc (get_registry_hive_path): Expect the user hive path to
	be never longer than MAX_PATH.  Don't prepend native NT path prefix
	here.  Add comment.
	(load_registry_hive): Prepend native NT path prefix here.  Additionally
	try to load user's classes hive.
	* uinfo.cc (cygheap_user::env_userprofile): Reduce size of
	userprofile_env_buf to MAX_PATH.  Add comment.
@
text
@d118 1
a118 1
	  debug_printf ("failed to create key %S in the registry", uname);
@


1.45
log
@whitespace elimination
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d217 1
d245 1
a245 2
  wcpcpy (path, L"\\??\\");
  ExpandEnvironmentStringsW (buf.Buffer, path + 4, NT_MAX_PATH - 4);
d256 1
a256 1
  /* Fetch the path. */
d259 1
a259 1
  if (!get_registry_hive_path (name, path))
d263 1
d268 1
a268 1
  /* Create the object attributes for key and path. */
d273 4
a276 1
  wcscat (path, L"\\NTUSER.DAT");
a279 1
  /* Load file into key. */
d282 22
a303 1
    debug_printf ("Loading user registry hive %S into %S failed: %p",
d306 1
a306 1
    debug_printf ("Loading user registry hive %S into %S SUCCEEDED: %p",
@


1.44
log
@	* registry.cc (get_registry_hive_path): Change system_printf to
	debug_printf.
	(load_registry_hive): Ditto.
@
text
@a191 1
      
@


1.43
log
@	* registry.cc (reg_key::get_dword): Rename from get_int, use DWORD
	rather than int type.  Avoid compiler warning.
	(reg_key::set_dword): Rename from set_int, use DWORD rather than int
	type.  Change return type to NTSTATUS.
	(reg_key::get_string): Change return type to NTSTATUS.
	(reg_key::set_string): Ditto.
	* registry.h: Accommodate above changes.
	* environ.cc (regopt): Test return value of reg_key::get_string as
	NTSTATUS.
	* sched.cc (sched_rr_get_interval): Change local int vars to DWORD.
	Call reg_key::get_dword instead of reg_key::get_int.
	* shared.cc (init_installation_root): Test return value of
	reg_key::get_string as NTSTATUS.
	(shared_info::heap_slop_size): Call reg_key::get_dword rather than
	reg_key::get_int.
	(shared_info::heap_chunk_size): Ditto.
	* shared_info.h (CURR_SHARED_MAGIC): Update.
	(class shared_info): Change heap_chunk and heap_slop to DWORD  values.
@
text
@d241 1
a241 1
      system_printf ("ProfileImagePath for %W not found, status %p", name,
d247 1
a247 1
  system_printf ("ProfileImagePath for %W: %W", name, path);
d280 1
a280 1
    system_printf ("Loading user registry hive %S into %S failed: %p",
d283 1
a283 1
    system_printf ("Loading user registry hive %S into %S SUCCEEDED: %p",
@


1.42
log
@	* Makefile.in (DLL_IMPORTS): Drop advapi32.dll.
	* autoload.cc: Enable autoloading advapi32 functions.
	* environ.cc (regopt): Use wide char arguments in reg_key functions.
	* fhandler_console.cc (beep): Ditto.  Use WCHAR throughout.
	* registry.cc (reg_key): Rewrite reg_key class to use native NT registry
	functions.  Use WCHAR string parameters throughout.  Use PCWSTR rather
	than const WCHAR.  Drop multibyte char functionality.  Drop unused
	methods.
	(get_registry_hive_path): Use RtlQueryRegistryValues to fetch path from
	registry.
	(load_registry_hive): Drop useless check for user hive being available.
	Load hive using NtLoadKey.
	* registry.h: Accommodate above changes.
	* sched.cc (sched_rr_get_interval): Use wide char arguments in reg_key
	functions.
	* shared.cc (init_installation_root): Ditto.
	(shared_info::init_obcaseinsensitive): Use RtlQueryRegistryValues to
	fetch obcaseinsensitive value.
	(shared_info::heap_slop_size): Use wide char arguments in reg_key
	functions.
	(shared_info::heap_chunk_size): Ditto.
	* syscalls.cc (gethostid): Ditto.
	* winsup.h (__WIDE): Define.
	(_WIDE): Define.
	* libc/minires-os-if.c (get_registry_dns_items): Don't fetch values
	from registry.  Just extract them from given UNICODE_STRING parameter.
	(get_registry_dns): Fetch all registry values at once using
	RtlQueryRegistryValues.
@
text
@d124 1
a124 1
/* Given the current registry key, return the specific int value
d127 2
a128 2
int
reg_key::get_int (PCWSTR name, int def)
d145 2
a146 2
  DWORD dst = *(DWORD *) vbuf->Data;
  return (int) dst;
d149 1
a149 1
/* Given the current registry key, set a specific int value. */
d151 2
a152 2
int
reg_key::set_int (PCWSTR name, int val)
d160 1
a160 3
  NTSTATUS status = NtSetValueKey (key, &uname, 0, REG_DWORD, 
				   &value, sizeof (value));
  return (int) status;
d166 1
a166 1
int
d194 1
a194 1
  return (int) status;
d199 1
a199 1
int
d207 2
a208 3
  NTSTATUS status = NtSetValueKey (key, &uname, 0, REG_SZ, (PVOID) src,
				   (wcslen (src) + 1) * sizeof (WCHAR));
  return (int) status;
@


1.41
log
@* environ.cc (regopt): Change the first argument to wide char string.
(environ_init): Accommodate change to the first argument of regopt.
* exception.cc (open_stackdumpfile): Accommodate change to the type of progname
in _pinfo.
* external.cc (fillout_pinfo): Ditto.
* fhandler_process.cc (format_process_winexename): Ditto.
(format_process_stat): Ditto.
* fork.cc (fork::parent): Ditto.
* pinfo.cc (pinfo_basic::pinfo_basic): Call GetModuleFileNameW instead of
GetModuleFileName.
(pinfo::thisproc): Accommodate change to the type of progname in _pinfo.
(pinfo_init): Ditto.
* pinfo.h (_pinfo): Change the type of progname to a wide char array.
* registry.h (reg_key::get_int): Change the first argument from constant point
to pointer to constant.
(reg_key::get_string): Ditto.  Change the last argument likewise.
* registry.cc (reg_key::get_int): Accommodate change to the declaration.
(reg_key::get_string): Ditto.
* strace.cc (strace::hello): Accommodate change to the type of progname in
_pinfo.
(strace::vsprntf): Ditto.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d20 1
d22 1
a22 8

reg_key::reg_key (HKEY top, REGSAM access, ...): _disposition (0)
{
  va_list av;
  va_start (av, access);
  build_reg (top, access, av);
  va_end (av);
}
d26 2
a27 2

reg_key::reg_key (bool isHKLM, REGSAM access, ...): _disposition (0)
d29 4
a32 2
  va_list av;
  HKEY top;
d34 1
d36 5
a40 1
    top = HKEY_LOCAL_MACHINE;
d43 5
a47 2
      char name[128];
      const char *names[2] = {cygheap->user.get_windows_id (name), ".DEFAULT"};
d50 5
a54 4
	  key_is_invalid = RegOpenKeyEx (HKEY_USERS, names[i], 0, access, &top);
	  if (key_is_invalid == ERROR_SUCCESS)
	    goto OK;
	  debug_printf ("HKU\\%s failed, Win32 error %ld", names[i], key_is_invalid);
a55 1
      return;
d57 2
a58 7
OK:
  new (this) reg_key (top, access, "SOFTWARE",
		      CYGWIN_INFO_CYGWIN_REGISTRY_NAME, NULL);
  if (top != HKEY_LOCAL_MACHINE)
    RegCloseKey (top);
  if (key_is_invalid)
    return;
d60 3
a62 1
  top = key;
d66 22
a87 2
  if (top != key)
    RegCloseKey (top);
d93 10
a102 2
  char *name;
  HKEY r = top;
d104 1
a104 7

  /* FIXME: Most of the time a valid mount area should exist.  Perhaps
     we should just try an open of the correct key first and only resort
     to this method in the unlikely situation that it's the first time
     the current mount areas are being used. */

  while ((name = va_arg (av, char *)) != NULL)
d106 8
a113 11
      int res = RegCreateKeyExA (r,
				 name,
				 0,
				 NULL,
				 REG_OPTION_NON_VOLATILE,
				 access,
				 &sec_none_nih,
				 &key,
				 &_disposition);
      if (r != top)
	RegCloseKey (r);
d115 1
a115 1
      if (res != ERROR_SUCCESS)
d117 2
a118 2
	  key_is_invalid = res;
	  debug_printf ("failed to create key %s in the registry", name);
d128 1
a128 19
reg_key::get_int (const char *name, int def)
{
  DWORD type;
  DWORD dst;
  DWORD size = sizeof (dst);

  if (key_is_invalid)
    return def;

  LONG res = RegQueryValueExA (key, name, 0, &type, (LPBYTE) &dst, &size);

  if (type != REG_DWORD || res != ERROR_SUCCESS)
    return def;

  return dst;
}

int
reg_key::get_int (const WCHAR *name, int def)
a129 4
  DWORD type;
  DWORD dst;
  DWORD size = sizeof (dst);

d133 11
a143 3
  LONG res = RegQueryValueExW (key, name, 0, &type, (LPBYTE) &dst, &size);

  if (type != REG_DWORD || res != ERROR_SUCCESS)
d145 2
a146 2

  return dst;
d152 1
a152 12
reg_key::set_int (const char *name, int val)
{
  DWORD value = val;
  if (key_is_invalid)
    return key_is_invalid;

  return (int) RegSetValueExA (key, name, 0, REG_DWORD,
			       (const BYTE *) &value, sizeof (value));
}

int
reg_key::set_int (const PWCHAR name, int val)
a153 1
  DWORD value = val;
d157 6
a162 2
  return (int) RegSetValueExW (key, name, 0, REG_DWORD,
			       (const BYTE *) &value, sizeof (value));
d169 1
a169 1
reg_key::get_string (const char *name, char *dst, size_t max, const char *def)
d171 1
a171 3
  DWORD size = max;
  DWORD type;
  LONG res;
d174 5
a178 1
    res = key_is_invalid;
d180 17
a196 22
    res = RegQueryValueExA (key, name, 0, &type, (LPBYTE) dst, &size);

  if ((def != 0) && ((type != REG_SZ) || (res != ERROR_SUCCESS)))
    strcpy (dst, def);
  return (int) res;
}

int
reg_key::get_string (const WCHAR *name, PWCHAR dst, size_t max, const WCHAR *def)
{
  DWORD size = max;
  DWORD type;
  LONG res;

  if (key_is_invalid)
    res = key_is_invalid;
  else
    res = RegQueryValueExW (key, name, 0, &type, (LPBYTE) dst, &size);

  if ((def != 0) && ((type != REG_SZ) || (res != ERROR_SUCCESS)))
    wcscpy (dst, def);
  return (int) res;
d202 1
a202 30
reg_key::set_string (const char *name, const char *src)
{
  if (key_is_invalid)
    return key_is_invalid;
  return (int) RegSetValueExA (key, name, 0, REG_SZ, (const BYTE*) src,
			       strlen (src) + 1);
}

int
reg_key::set_string (const PWCHAR name, const PWCHAR src)
{
  if (key_is_invalid)
    return key_is_invalid;
  return (int) RegSetValueExW (key, name, 0, REG_SZ, (const BYTE*) src,
			       (wcslen (src) + 1) * sizeof (WCHAR));
}

/* Return the handle to key. */

HKEY
reg_key::get_key ()
{
  return key;
}

/* Delete subkey of current key.  Returns the error code from the
   RegDeleteKeyA invocation. */

int
reg_key::kill (const char *name)
a205 5
  return RegDeleteKeyA (key, name);
}

/* Delete the value specified by name of current key.  Returns the error code
   from the RegDeleteValueA invocation. */
d207 5
a211 6
int
reg_key::killvalue (const char *name)
{
  if (key_is_invalid)
    return key_is_invalid;
  return RegDeleteValueA (key, name);
d217 1
a217 1
    RegCloseKey (key);
d222 1
a222 1
get_registry_hive_path (const PWCHAR name, PWCHAR path)
a223 3
  WCHAR key[256], *kend;
  HKEY hkey;

d226 17
a242 3
  kend = wcpcpy (key, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\");
  wcpcpy (kend, name);
  if (!RegOpenKeyExW (HKEY_LOCAL_MACHINE, key, 0, KEY_READ, &hkey))
d244 3
a246 11
      tmp_pathbuf tp;
      PWCHAR buf = tp.w_get ();
      DWORD type, siz;

      path[0] = L'\0';
      if (!RegQueryValueExW (hkey, L"ProfileImagePath", 0, &type,
			     (BYTE *)buf, (siz = NT_MAX_PATH, &siz)))
	ExpandEnvironmentStringsW (buf, path, NT_MAX_PATH);
      RegCloseKey (hkey);
      if (path[0])
	return path;
d248 4
a251 2
  debug_printf ("HKLM\\%W not found", key);
  return NULL;
d255 1
a255 1
load_registry_hive (const PWCHAR name)
d257 4
d263 2
a264 2
  HKEY hkey;
  LONG ret;
d266 22
a287 15
  if (!name)
    return;
  /* Check if user hive is already loaded. */
  if (!RegOpenKeyExW (HKEY_USERS, name, 0, KEY_READ, &hkey))
    {
      debug_printf ("User registry hive for %W already exists", name);
      RegCloseKey (hkey);
      return;
    }
  if (get_registry_hive_path (name, path))
    {
      wcscat (path, L"\\NTUSER.DAT");
      if ((ret = RegLoadKeyW (HKEY_USERS, name, path)) != ERROR_SUCCESS)
	debug_printf ("Loading user registry hive for %W failed: %d", name, ret);
    }
a288 1

@


1.40
log
@
2010-02-11  Pierre Humblet <Pierre.Humblet@@ieee.org>

        * registry.c (get_registry_hive_path): Add space in string.
@
text
@d126 1
a126 1
reg_key::get_int (const PWCHAR name, int def)
d188 1
a188 1
reg_key::get_string (const PWCHAR name, PWCHAR dst, size_t max, const PWCHAR def)
@


1.39
log
@	* registry.cc (cygnus_class): Remove.
	(reg_key::build_reg): Don't set class when creating key.
@
text
@d269 1
a269 1
  kend = wcpcpy (key, L"SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\ProfileList\\");
@


1.38
log
@	* registry.cc (reg_key::get_int): Add alternative implementation
	taking WCHAR strings.
	(reg_key::set_int): Ditto.
	(reg_key::get_string): Ditto.
	(reg_key::set_string): Ditto.
	* registry.h (struct reg_key): Add prototypes for added methods.
@
text
@a20 1
static const char cygnus_class[] = "cygnus";
d86 1
a86 1
				 (char *) cygnus_class,
@


1.37
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d118 19
a136 2
  LONG res = RegQueryValueExA (key, name, 0, &type, (unsigned char *) &dst,
			       &size);
d154 12
a165 1
			       (unsigned char *) &value, sizeof (value));
d172 1
a172 1
reg_key::get_string (const char *name, char *dst, size_t max, const char * def)
d181 1
a181 1
    res = RegQueryValueExA (key, name, 0, &type, (unsigned char *) dst, &size);
d188 17
d212 1
a212 1
  return (int) RegSetValueExA (key, name, 0, REG_SZ, (unsigned char*) src,
d216 9
@


1.36
log
@	* mount.cc (mount_info::init): Remove call to from_registry.  Print
	message that fstab is missing.
	(mount_info::from_fstab): Use CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX
	instead of constant string.
	(mount_info::read_mounts): Remove.
	(mount_info::from_registry): Remove.
	(mount_info::read_cygdrive_info_from_registry): Remove.
	* postinstall: Enable code to create fstab entries from old registry
	entries.
	* registry.cc (reg_key::reg_key): Drop CYGWIN_INFO_CYGNUS_REGISTRY_NAME
	from registry key.
	* shared_info.h (mount_info::read_mounts): Remove declaration.
	(mount_info::from_registry): Ditto.
	(mount_info::to_registry): Ditto.
	(mount_info::read_cygdrive_info_from_registry): Ditto.
	* winver.rc (CYGWIN_REGISTRY_KEY): Remove.
	(LegalCopyright): Fix to include 2008.
	(RegistryKey): Set to CYGWIN_INFO_CYGWIN_REGISTRY_NAME.
	* include/cygwin/version.h (CYGWIN_INFO_CYGNUS_REGISTRY_NAME): Remove.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
a13 2
#include "security.h"
#include <cygwin/version.h>
@


1.35
log
@Remove unneeded header files from source files throughout.
@
text
@a57 1
		      CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
@


1.34
log
@	* Fix copyright dates.
@
text
@a12 1
#include "shared_info.h"
@


1.33
log
@	* Makefile.in (DLL_OFILES): Add tls_pbuf.o.
	* autoload.cc (CreateDesktopW): Replace CreateDesktopA.
	(CreateWindowStationW): Replace CreateWindowStationA.
	(GetUserObjectInformationW): Replace GetUserObjectInformationA.
	* cygheap.h (cwdstuff::get): Assume default buffer size NT_MAX_PATH.
	* cygtls.cc (_cygtls::remove): Free temporary TLS path buffers.
	* cygtls.h (TP_NUM_C_BUFS): Define.
	(TP_NUM_W_BUFS): Define.
	(class tls_pathbuf): New class to store pointers to thread local
	temporary path buffers.
	(_local_storage::pathbufs): New member.
	* environ.cc (win_env::add_cache): Use temporary TLS path buffer instead
	of stack based buffer.
	(posify): Get temporary outenv buffer from calling function.
	(environ_init): Create temporary TLS path buffer for posify.
	(build_env): Create Windows environment block as WCHAR buffer.
	* environ.h (build_env): Change declaration accordingly.
	* external.cc (sync_winenv): Accommodate build_env change.
	* fhandler_console.cc (fhandler_console::need_invisible): Use
	GetUserObjectInformationW and CreateWindowStationW.
	* fhandler_process.cc (format_process_maps): Use temporary TLS path
	buffer instead of stack based buffer.
	* fork.cc (frok::parent): Convert to use CreateProcessW.
	* path.cc: Throughout use temporary TLS path buffers instead of stack
	based buffer.  Replace checks for CYG_MAX_PATH by checks for
	NT_MAX_PATH.
	(getfileattr): New function to replace GetFileAttributesA.
	(normalize_win32_path): Remove Win32 and NT long path prefixes.
	(getwd): Assume PATH_MAX + 1 buffer per SUSv3.
	* path.h (class path_conv): Set path buffer to size NT_MAX_PATH.
	(iswdrive): Define.
	* pinfo.cc (commune_process): Use temporary TLS path buffer instead of
	stack based buffer.
	* registry.cc (get_registry_hive_path): Ditto.
	(load_registry_hive): Ditto.
	* spawn.cc (spawn_guts): Convert to use CreateProcessW and
	CreateProcessAsUserW.
	(av::fixup): Open/close file using NtOpenFile/NtClose.
	* syscalls.cc (mknod_worker): Allow PATH_MAX file name.
	(mknod32): Ditto.
	(getusershell): Ditto.
	* tls_pbuf.cc: New file implementing tls_pathbuf and tmp_pathbuf
	methods.
	* tls_pbuf.h: New header for files using tmp_pathbuf.
	* tlsoffsets.h: Regenerate.
	* winsup.h (NT_MAX_PATH): Define as 32767 to avoid USHORT overflow.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
@


1.32
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d22 1
d224 2
a225 1
      WCHAR buf[NT_MAX_PATH];
d230 1
a230 1
			     (BYTE *)buf, (siz = sizeof (buf), &siz)))
d243 2
a244 1
  WCHAR path[NT_MAX_PATH];
@


1.31
log
@	* cygheap.cc (cwcsdup): New function.
	(cwcsdup1): New function.
	* cygheap.h (cygheap_user::get_windows_id): New method returning PWCHAR.
	(cwcsdup): Declare.
	(cwcsdup1): Declare.
	* registry.cc (get_registry_hive_path): Use WCHAR instead of char
	throughout.
	(load_registry_hive): Ditto.
	* registry.h (get_registry_hive_path): Change declaration accordingly.
	(load_registry_hive): Ditto.
	* sec_helper.cc (cygpsid::string): New method returning PWCHAR.
	* security.h (cygpsid::string): Declare.
	* syscalls.cc (seteuid32): Convert local name var to WCHAR.
	* uinfo.cc (cygheap_user::env_userprofile): Convert local name buffers
	to WCHAR.  Call sys_wcstombs_alloc to generate puserprof buffer.

	* winsup.h: Fix comment.
	(NT_MAX_PATH): New definition for maximum internal path length.
	Use throughout where appropriate.
	* include/limits.h (PATH_MAX): Set to 4096 as on Linux.
@
text
@a223 1
      WCHAR tmp[NT_MAX_PATH];
@


1.30
log
@	* fhandler_registry.cc: Use NAME_MAX + 1 instead of CYG_MAX_PATH
	throughout for subkey name buffer size.
	* fhandler_socket.cc (search_wsa_event_slot): Use MAX_PATH instead of
	CYG_MAX_PATH for mutext name buffer size.
	(fhandler_socket::init_events): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Check path length
	against PATH_MAX instead of against CYG_MAX_PATH.
	* registry.cc (get_registry_hive_path): Use PATH_MAX instead of
	CYG_MAX_PATH for registry value path buffer size.
	* shared.cc (open_shared): Use MAX_PATH instead of CYG_MAX_PATH
	for shared memory name buffer size.
	* thread.cc (semaphore::semaphore): Use MAX_PATH instead of CYG_MAX_PATH
	for semaphore name buffer size.
	* uinfo.cc (cygheap_user::env_userprofile): Use PATH_MAX instead of
	CYG_MAX_PATH for temporary path name buffer size.
	* winf.h (LINE_BUF_CHUNK): Define as MAX_PATH * 2.
	* include/sys/dirent.h: Include sys/limits.h.  Define name buffer sizes
	using NAME_MAX.
@
text
@d22 1
d211 2
a212 2
char *
get_registry_hive_path (const char *name, char *path)
d214 1
a214 1
  char key[256];
d219 3
a221 3
  __small_sprintf (key, "SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\"
  			"ProfileList\\%s", name);
  if (!RegOpenKeyExA (HKEY_LOCAL_MACHINE, key, 0, KEY_READ, &hkey))
d223 2
a224 1
      char buf[PATH_MAX];
d227 2
a228 2
      path[0] = '\0';
      if (!RegQueryValueExA (hkey, "ProfileImagePath", 0, &type,
d230 1
a230 1
	ExpandEnvironmentStringsA (buf, path, PATH_MAX);
d235 1
a235 1
  debug_printf ("HKLM\\%s not found", key);
d240 1
a240 1
load_registry_hive (const char * name)
d242 1
a242 1
  char path[PATH_MAX];
d249 1
a249 1
  if (!RegOpenKeyExA (HKEY_USERS, name, 0, KEY_READ, &hkey))
d251 1
a251 1
      debug_printf ("User registry hive for %s already exists", name);
d257 3
a259 3
      strcat (path, "\\NTUSER.DAT");
      if ((ret = RegLoadKeyA (HKEY_USERS, name, path)) != ERROR_SUCCESS)
	debug_printf ("Loading user registry hive for %s failed: %d", name, ret);
@


1.29
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@d222 1
a222 1
      char buf[256];
d228 1
a228 1
	ExpandEnvironmentStringsA (buf, path, CYG_MAX_PATH);
d240 1
a240 1
  char path[CYG_MAX_PATH];
@


1.28
log
@* dir.cc (readdir_worker): Minor code cleanup.
* fhandler_console.cc (beep): Use a more Windows-generic wav file if the beep
is missing.  Use a more foolproof way to find out whether we should be
recreating the missing key.
* registry.h (reg_key::_disposition): New field.
(reg_key::created): New function.
* registry.cc (reg_key::reg_key): Set _disposition to zero by default.
(reg_key::build_key): Fill in _disposition field.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
d218 2
a219 3
  __small_sprintf (key, "SOFTWARE\\Microsoft\\Windows%s\\CurrentVersion\\ProfileList\\",
		   wincap.is_winnt ()?" NT":"");
  strcat (key, name);
d255 1
a255 4
      if (wincap.is_winnt ())
	strcat (path, "\\NTUSER.DAT");
      else
	strcat (path, "\\USER.DAT");
@


1.27
log
@	* cygheap.cc (cygheap_init): Accomodate set_process_privilege change.
	* cygheap.h (cygheap_user::curr_primary_token): New member.
	(cygheap_user::primary_token): New method.
	(cygheap_user::deimpersonate): Always revert to processes'
	impersonation token.
	(cygheap_user::reimpersonate): Set processes' or setuid token as
	necessary.
	(cygheap_user::has_impersonation_tokens): Look for curr_primary_token
	value.
	(cygheap_user::close_impersonation_tokens): Close curr_primary_token
	here if necessary.  Don't reset token values to NO_IMPERSONATION since
	that's done in uinfo_init anyway.
	(init_cygheap::luid): New LUID array keeping privilege LUIDs.
	* cygtls.cc (_cygtls::init_thread): Call cygheap->user.reimpersonate.
	* dcrt0.cc (hProcToken): New global variable to keep process token.
	(hProcImpToken): Ditto for process impersonation token.
	(dll_crt0_0): Open process token here once.  Duplicate to create
	hProcImpToken.
	(dll_crt0_1): Call set_cygwin_privileges.
	* environ.cc (allow_ntea): Drop duplicate declaration.
	(allow_smbntsec): Ditto.
	(set_traverse): Only set allow_traverse here.
	(environ_init): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop call to
	enable_restore_privilege.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	* fork.cc (fork_child): Move call to cygheap->user.reimpersonate after
	syn with parent. Call set_cygwin_privileges.
	* grp.cc (internal_getgroups): Use hProcImpToken instead of opening
	process token.
	* path.cc (fs_info::update): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges.
	* registry.cc (load_registry_hive): Drop setting restore privilege
	since it's already set if available.
	* sec_helper.cc: Include cygtls.h.
	(cygpriv): Privilege string array.
	(privilege_luid): New function, evaluate LUID from cygpriv_idx.
	(privilege_luid_by_name): New function, evaluate LUID from privilege
	string.
	(privilege_name): New function, evaluate privilege string from
	cygpriv_idx.
	(set_privilege): New static function called by set_process_privilege
	and set_thread_privilege.  Call privilege_luid to get privilege LUID.
	Fix bug in return value evaluation. Improve debug output.
	(set_cygwin_privileges): New function.
	(set_process_privilege): Remove.
	(enable_restore_privilege): Remove.
	* security.cc (allow_traverse): New global variable.
	(sys_privs): Change type to cygpriv_idx and store privilege indices
	instead of strings.
	(SYSTEM_PRIVILEGES_COUNT): Renamed from SYSTEM_PERMISSION_COUNT.
	(get_system_priv_list): Don't use numerical constant in malloc call.
	Use privilege_luid to get privilege LUIDs.
	(get_priv_list): Call privilege_luid_by_name to get LUIDs. Improve
	inner privilege LUID comparison loop.
	(create_token): Enable create token privilege using
	push/pop_self_privileges. Use hProcToken instead of opening process
	token. Use default DACL when duplicating token.
	(subauth): Enable tcb privilege using push/pop_self_privileges.
	Use sec_none instead of homw made security attributes when duplicating
	token.
	(check_file_access): Don't duplicate access token, use active
	impersonation token as is.
	* security.h (enum cygpriv_idx): New enumeration type enumerating
	possible privileges.
	(privilege_luid): Declare new function.
	(privilege_luid_by_name): Ditto.
	(privilege_name): Ditto.
	(allow_traverse): Declare.
	(set_privilege): Declare function.
	(set_process_privilege): Define as macro.
	(enable_restore_privilege): Remove declaration.
	(_push_thread_privilege): Define macro.
	(push_thread_privilege): Ditto.
	(pop_thread_privilege): Ditto.
	(pop_self_privilege): Ditto.
	* spawn.cc (spawn_guts): Use cygheap->user.primary_token instead of
	cygheap->user.token.
	* syscalls.cc (statvfs): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges. Rearrange code
	to simplify push/pop bracketing.
	(seteuid32): Use hProcToken instead of opening process token. Call
	cygheap->user.deimpersonate instead of RevertToSelf.  Create
	impersonation token from primary internal or external token.  Set
	cygheap->user.curr_primary_token and cygheap->user.current_token
	privileges once here.  Drop "failed" and "failed_ptok" labels.
	Drop setting DefaultDacl of process token.
	(setegid32): Use hProcToken and hProcImpToken instead of opening
	process token. Always reimpersonate afterwards.
	* uinfo.cc (cygheap_user::init): Use hProcToken instead of opening
	process token.
	(internal_getlogin): Ditto. Set hProcImpToken, too.
	(uinfo_init): Initialize cygheap->user.curr_primary_token.
	* winsup.h (hProcToken): Declare.
	(hProcImpToken): Declare.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
d24 1
a24 1
reg_key::reg_key (HKEY top, REGSAM access, ...)
d35 1
a35 1
reg_key::reg_key (bool isHKLM, REGSAM access, ...)
d94 1
a94 1
				 NULL);
@


1.26
log
@	Unify usage of CYG_MAX_PATH throughout.  Change buffers from
	size CYG_MAX_PATH + 1 to CYG_MAX_PATH.  Change length tests
	accordingly.
@
text
@a253 2
  /* This is only called while deimpersonated */
  set_process_privilege (SE_RESTORE_NAME);
@


1.25
log
@copyright
@
text
@d229 1
a229 1
	ExpandEnvironmentStringsA (buf, path, CYG_MAX_PATH + 1);
d241 1
a241 1
  char path[CYG_MAX_PATH + 1];
@


1.24
log
@white space
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.23
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d33 1
a33 1
 
d43 2
a44 2
      char name[128]; 
      const char *names[2] = {cygheap->user.get_windows_id (name), ".DEFAULT"}; 
d55 1
a55 1
  new (this) reg_key (top, access, "SOFTWARE", 
d62 1
a62 1
    
d218 1
a218 1
		   wincap.is_winnt ()?" NT":""); 
d260 1
a260 1
	strcat (path, "\\USER.DAT");	
@


1.22
log
@2004-12-03  Pierre Humblet <pierre.humblet@@ieee.org>

	* registry.h (reg_key::reg_key): Change arguments.
	* shared_info.h (class mount_info): Remove had_to_create_mount_areas.
	* registry.cc (reg_key::reg_key): Change constructors to always handle
	HKLM and to avoid relying on HKCU.
	Do not set mount_table->had_to_create_mount_areas.
	* path.cc (mount_info::conv_to_win32_path): Improve update of
	sys_mount_table_counter.
	(mount_info::read_mounts): Use new reg_key constructor.
	(mount_info::add_reg_mount): Ditto.
	(mount_info::del_reg_mount): Ditto.
	(mount_info::read_cygdrive_info_from_registry): Ditto.
	(mount_info::write_cygdrive_info_to_registry): Ditto.
	Update cygwin_shared->sys_mount_table_counter after registry update.
	(mount_info::get_cygdrive_info): Ditto.
	* shared.cc (shared_info::heap_chunk_size): Use new reg_key constructor.
	* environ.cc (regopt): Ditto.
@
text
@d16 1
a19 1
#include "cygerrno.h"
@


1.21
log
@2004-11-20  Pierre Humblet <pierre.humblet@@ieee.org>

	* cygheap.h (cygheap_user::get_windows_id): New method.
	* registry.h (get_registry_hive_path): Change argument type.
	(load_registry_hive): Ditto.
	* registry.cc (get_registry_hive_path): Change argument type and take
	Win9x keys into account.
	(load_registry_hive): Ditto.
	* uinfo.cc (cygheap_user::env_userprofile): Use get_windows_id, even
	for SYSTEM.
	* shared.cc (user_shared_initialize): Use get_windows_id.
	* syscalls.cc (seteuid32): Load the registry hive and reload the user
	shared also on Win9x.
@
text
@d16 6
a21 2

static char NO_COPY cygnus_class[] = "cygnus";
d31 4
a34 1
reg_key::reg_key (REGSAM access, ...)
d37 1
d39 25
a63 5
  new (this) reg_key (HKEY_CURRENT_USER, access, "SOFTWARE",
		 CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
		 CYGWIN_INFO_CYGWIN_REGISTRY_NAME, NULL);

  HKEY top = key;
d65 1
a65 1
  build_reg (top, KEY_READ, av);
a70 8
reg_key::reg_key (REGSAM access)
{
  new (this) reg_key (HKEY_CURRENT_USER, access, "SOFTWARE",
		 CYGWIN_INFO_CYGNUS_REGISTRY_NAME,
		 CYGWIN_INFO_CYGWIN_REGISTRY_NAME,
		 CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME, NULL);
}

a84 1
      DWORD disp;
d88 1
a88 1
				 cygnus_class,
d93 1
a93 1
				 &disp);
a102 6

      /* If we're considering the mounts key, check if it had to
	 be created and set had_to_create appropriately. */
      if (strcmp (name, CYGWIN_INFO_CYGWIN_MOUNT_REGISTRY_NAME) == 0)
	if (disp == REG_CREATED_NEW_KEY)
	  mount_table->had_to_create_mount_areas++;
@


1.20
log
@2004-10-26  Pierre Humblet <pierre.humblet@@ieee.org>

        * registry.cc (get_registry_hive_path): Simplify and add a
        debug_printf in case of failure.
        (load_registry_hive): Revert the 2004-04-19 change.
@
text
@d197 1
a197 1
get_registry_hive_path (const PSID psid, char *path)
a198 1
  char sid[256];
d202 1
a202 1
  if (!psid || !path)
d204 3
a206 4
  cygpsid csid (psid);
  csid.string (sid);
  strcpy (key,"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\");
  strcat (key, sid);
d225 1
a225 1
load_registry_hive (PSID psid)
a226 1
  char sid[256];
d231 1
a231 1
  if (!psid)
d234 1
a234 3
  cygpsid csid (psid);
  csid.string (sid);
  if (!RegOpenKeyExA (HKEY_USERS, sid, 0, KEY_READ, &hkey))
d236 1
a236 1
      debug_printf ("User registry hive for %s already exists", sid);
d242 1
a242 1
  if (get_registry_hive_path (psid, path))
d244 6
a249 3
      strcat (path, "\\NTUSER.DAT");
      if ((ret = RegLoadKeyA (HKEY_USERS, sid, path)) != ERROR_SUCCESS)
	debug_printf ("Loading user registry hive for %s failed: %d", sid, ret);
@


1.19
log
@	* errno.cc (errmap): Handle ERROR_IO_PENDING.
	* fhandler.cc (fhandler_base::open): Make tape I/O asynchronous.
	* fhandler.h (class fhandler_dev_tape): Add mt_evt member.
	* fhandler_tape.cc (mtinfo_drive::initialize): Initialize async_writes.
	(mtinfo_drive::close): Handle async writes.
	(mtinfo_drive::read): Add mt_evt parameter.  Use overlapped I/O.
	(mtinfo_drive::async_wait): New function.
	(mtinfo_drive::write): Add mt_evt parameter.  Use overlapped I/O.
	Handle async writes.
	(mtinfo_drive::_set_pos): Handle async writes.
	(mtinfo_drive::set_partition): Ditto.
	(mtinfo_drive::prepare): Ditto.
	(mtinfo_drive::get_status): Drop useless "else".  Handle async_writes
	flag.
	(mtinfo_drive::set_options): Handle async_writes flags.
	(fhandler_dev_tape::close): Close mt_evt handle.
	(fhandler_dev_tape::raw_read): Create mt_evt handle and use in call
	to mtinfo_drive::read.
	(fhandler_dev_tape::raw_write): Create mt_evt handle and use in call
	to mtinfo_drive::write.
	* mtinfo.h (MTINFO_VERSION): Bump.
	(enum dirty_state): Add async_write_pending state.
	(class mtinfo_drive): Add OVERLAPPED struct "ov".  Add async_writes
	flag.
	(mtinfo_drive::async_wait): Add declaration.
	(mtinfo_drive::read): Add mt_evt parameter.
	(mtinfo_drive::write): Ditto.

	* registry.cc (load_registry_hive): Call enable_restore_privilege
	instead of set_process_privilege.
@
text
@d214 1
a214 1
      key[0] = '\0';
d216 2
a217 2
			     (BYTE *)buf, (siz = 256, &siz)))
	ExpandEnvironmentStringsA (buf, key, 256);
d219 2
a220 2
      if (key[0])
	return strcpy (path, key);
d222 1
d245 2
a246 1
  enable_restore_privilege ();
@


1.18
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d244 1
a244 1
  set_process_privilege (SE_RESTORE_NAME);
@


1.17
log
@* shared_info.h (shared_info::initialize): Remove argument.
* cygheap.h (cygheap_user::init): New declaration.
* uinfo.cc (cygheap_user::init): New.
(internal_getlogin): Move functionality to cygheap_user::init.  Open the
process token to update the group sid.
* shared.cc (user_shared_initialize): Get the user information from
cygheap->user.
(shared_info::initialize): Remove argument.  Call cygheap->user.init instead of
cygheap->user.set_name.
(memory_init): Do not get the user name and do not pass it to
shared_info::initialize.
* registry.cc (get_registry_hive_path): Make csid a cygpsid.
(load_registry_hive): Ditto.
@
text
@d229 1
a229 1
  char path[MAX_PATH + 1];
@


1.16
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d205 1
a205 1
  cygsid csid (psid);
d236 1
a236 1
  cygsid csid (psid);
@


1.16.20.1
log
@merge from trunk
@
text
@d205 1
a205 1
  cygpsid csid (psid);
d236 1
a236 1
  cygpsid csid (psid);
@


1.15
log
@	* spawn.cc (spawn_guts): Move call to set_process_privilege()
	to load_registry_hive().
	* registry.cc (load_registry_hive): ditto.
	* fork.cc (fork_parent): Call sec_user_nih() only once.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.14
log
@Update copyrights.
@
text
@d238 1
a238 1
  if (!RegOpenKeyExA (HKEY_USERS, csid.string (sid), 0, KEY_READ, &hkey))
d244 1
@


1.14.4.1
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d238 1
a238 1
  if (!RegOpenKeyExA (HKEY_USERS, sid, 0, KEY_READ, &hkey))
a243 1
  set_process_privilege (SE_RESTORE_NAME);
@


1.13
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.12
log
@forced commit
@
text
@d17 1
a17 1
char cygnus_class[] = "cygnus";
@


1.11
log
@        * fork.cc (fork): Eliminate superfluous call to getuid().
        * security.h: New define `NO_SID'. Remove declarations of functions
        moved to methods into class cygsid.
        (class cygsid): Declare new methods `getfromstr', `get_sid',
        `getfrompw', `getfromgr', `get_rid', `get_uid', `get_gid', `string'
        and new constructors and operators =, == and !=.
        Declare new global cygsids `well_known_XXX_sid' substituting the
        corresponding `get_XXX_sid' functions. Remove declarations of
        these functions.
        * sec_helper.cc (well_known_admin_sid): New global variable.
        (well_known_system_sid): Ditto
        (well_known_creator_owner_sid): Ditto
        (well_known_world_sid): Ditto
        (cygsid::string): New method, substituting `convert_sid_to_string_sid'.
        (cygsid::get_sid): New method, substituting `get_sid'.
        (cygsid::getfromstr): New method, substituting
        `convert_string_sid_to_sid'.
        (cygsid::getfrompw): New method, substituting `get_pw_sid'.
        (cygsid::getfromgr): New method, substituting `get_gr_sid'.
        (cygsid::get_id): New method, substituting `get_id_from_sid'.
        (get_admin_sid): Eliminated.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * grp.cc: Use new cygsid methods and well known sids throughout.
        * registry.cc: Ditto.
        * sec_acl.cc: Ditto.
        * security.cc: Ditto.
        * shared.cc: Ditto.
        * syscalls.cc (seteuid): Ditto. Eliminate redundant conditional.
        * uinfo.cc (internal_getlogin): Ditto.
        * spawn.cc (spawn_guts) Revert previous patch.
@
text
@@


1.10
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@d205 2
a206 1
  convert_sid_to_string_sid (psid, sid);
d236 3
a238 2
  if (!RegOpenKeyExA (HKEY_USERS, convert_sid_to_string_sid (psid, sid),
		      0, KEY_READ, &hkey))
@


1.9
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d89 1
a89 1
	  cygwin_shared->mount.had_to_create_mount_areas++;
@


1.8
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@a11 1
#include "tty.h"
d13 3
@


1.7
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d12 2
@


1.6
log
@* dcrt0.cc (dummy_autoload): Add load statement for RegDeleteValueA.
* external.cc (get_cygdrive_prefixes): New function.
(cygwin_internal): Add CW_GET_CYGDRIVE_PREFIXES case.
* path.cc (mount_info::read_cygdrive_info_from_registry): Read system cygdrive
prefix if user one is undefined.
(mount_info::write_cygdrive_info_to_registry): Write cygdrive prefix to the
appropriate registry hive.  Overwrite in-memory copy of cygdrive, if
appropriate.
(mount_info::remove_cygdrive_info_from_registry): New method.
(mount_info::get_cygdrive_prefixes): New method.
(cygwin_umount): Remove cygdrive prefix, if appropriate.
* registry.cc (reg_key::killvalue): New method.
* shared.h (class reg_key): Add killvalue, remove_cygdrive_info_to_registry,
and get_cygdrive_prefixes declarations.
* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_CYGDRIVE_PREFIXES.
@
text
@d211 2
a212 2
                             (BYTE *)buf, (siz = 256, &siz)))
        ExpandEnvironmentStringsA (buf, key, 256);
d215 1
a215 1
        return strcpy (path, key);
d232 1
a232 1
                      0, KEY_READ, &hkey))
d242 1
a242 1
        debug_printf ("Loading user registry hive for %s failed: %d", sid, ret);
@


1.5
log
@        * registry.cc (load_registry_hive): Use HKEY_USERS when checking
        for existing user hive.
        Use MAX_PATH instead of numerical constant for array size.
        Use return code of RegLoadKeyA instead of GetLastError for error output.
@
text
@d174 11
@


1.4
log
@        * dcrt0.cc: Add load statements for `GetSidIdentifierAuthority'
        and `RegLoadKeyA'.
        * registry.cc (get_registry_hive_path): New function.
        (load_registry_hive): Ditto.
        * security.cc (convert_sid_to_string_sid): New function.
        (get_ssid): Renamed to `convert_string_sid_to_sid'.
        (get_pw_sid): Call `convert_string_sid_to_sid' instead of `get_ssid'.
        (get_gr_sid): Ditto.
        (get_admin_sid): Ditto.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * shared.h: New prototypes for `get_registry_hive_path' and
        `load_registry_hive'.
        * spawn.cc (spawn_guts): Set child->psid to NULL to force calling
        `internal_getlogin' from child process in case of changing user context.
        Call `load_registry_hive' in case of changing user context.
        (_spawnve): Copy user infos only if user context remains the same.
        * uinfo.cc: Add load statement for `NetUserGetInfo'.
        Remove load statement for `NetGetDCName'.
        (internal_getlogin): Rewrite to speed up process startup
        and to correct user environment in case user context changes.
        (uinfo_init): Call internal_getlogin only if myself->psid is NULL,
        that is user context changes.
        * winsup.h: Add prototypes for `convert_sid_to_string_sid',
        `convert_string_sid_to_sid' and `get_pw_sid'.
@
text
@d213 1
a213 1
  char path[256];
d215 1
d219 2
a220 2
  /* Check if user hive already exists */
  if (!RegOpenKeyExA (HKEY_LOCAL_MACHINE, convert_sid_to_string_sid (psid, sid),
d230 2
a231 2
      if (RegLoadKeyA (HKEY_USERS, sid, path))
        debug_printf ("Loading user registry hive for %s failed: %E", sid);
@


1.3
log
@* path.cc (mount_info::conv_to_posix_path): Avoid putting a trailing slash on a
directory name when the ms-dos path spec is a root directory of a device.
* registry.cc (reg_key::build_reg): Set 'key_is_invalid' flag rather than using
an INVALID_HANDLE_KEY.
(reg_key::get_int): Test for key validity before performing registry
operations.
(reg_key::set_int): Ditto.
(reg_key::get_string): Ditto.
(reg_key::set_string): Ditto.
(reg_key::kill): Ditto.
(reg_key::~reg_key): Ditto.
@
text
@d180 54
@


1.2
log
@* exceptions.cc (interruptible): Change method for determining if something is
interruptible.
(call_handler): Avoid suspending a thread if it owns a mutex.  Only set
signal_arrived if the thread was actually interrupted.
(events_init): Initialize module information needed by interruptible().
(sigdelayed): Don't call sig_dispatch_pending since it could screw up
* init.cc (dll_entry): Record module handle of main for use by interruptible().
(proc_subproc): Reorganize handling of terminated child so that the bulk of the
processing comes from the signal thread.
(wait_sig): Force processing of waiting threads if SIGCHLD is not processed.
* sync.cc (muto::release): Set tid == 0 after lock is released or signal
processor will be confused.
@
text
@d52 1
d76 1
a76 1
	  key = (HKEY) INVALID_HANDLE_VALUE;
d99 5
a103 5
  LONG res = RegQueryValueExA (key,
			       name,
			       0,
			       &type,
			       (unsigned char *) &dst, &size);
d117 3
d132 6
a137 2
  LONG res = RegQueryValueExA (key, name, 0, &type, (unsigned char *) dst,
								&size);
d140 1
a140 3
    {
      strcpy (dst, def);
    }
d149 2
a154 7
int
reg_key::setone_string (const char *src, const char *name)
{
  return (int) RegSetValueExA (key, name, 0, REG_SZ,
			       (const unsigned char *) src, strlen (src) + 1);
}

d169 2
d176 1
a176 1
  if (key != (HKEY) INVALID_HANDLE_VALUE)
d178 1
a178 1
  key = (HKEY) INVALID_HANDLE_VALUE;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999 Cygnus Solutions.
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
