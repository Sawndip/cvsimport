head	1.59;
access;
symbols
	cygwin-1_7_35-release:1.59
	cygwin-1_7_34-release:1.59
	cygwin-1_7_33-release:1.59
	cygwin-1_7_32-release:1.59
	cygwin-1_7_31-release:1.59
	cygwin-1_7_30-release:1.59
	cygwin-1_7_29-release:1.59
	cygwin-1_7_29-release-branchpoint:1.59.0.2
	cygwin-pre-user-db:1.59
	cygwin-1_7_28-release:1.59
	cygwin-1_7_27-release:1.59
	cygwin-1_7_26-release:1.59
	cygwin-1_7_25-release:1.59
	cygwin-1_7_24-release:1.59
	cygwin-1_7_23-release:1.59
	cygwin-1_7_22-release:1.59
	cygwin-1_7_21-release:1.59
	cygwin-1_7_20-release:1.59
	cygwin-1_7_19-release:1.59
	cygwin-64bit-postmerge:1.58
	cygwin-64bit-premerge-branch:1.57.0.2
	cygwin-64bit-premerge:1.57
	cygwin-1_7_18-release:1.57
	post-ptmalloc3:1.55.2.3
	pre-ptmalloc3:1.55.2.3
	cygwin-1_7_17-release:1.55
	cygwin-64bit-branch:1.55.0.2
	cygwin-1_7_16-release:1.55
	cygwin-1_7_15-release:1.54
	cygwin-1_7_14_2-release:1.54
	cygwin-1_7_14-release:1.54
	cygwin-1_7_12-release:1.54
	cygwin-1_7_11-release:1.54
	cygwin-1_7_10-release:1.54
	signal-rewrite:1.47.0.2
	pre-notty:1.47
	cygwin-1_7_9-release:1.44
	cv-post-1_7_9:1.44.0.2
	cygwin-1_7_8-release:1.43
	cygwin-1_7_7-release:1.43
	cygwin-1_7_5-release:1.43
	cygwin-1_7_4-release:1.43
	cygwin-1_7_3-release:1.42
	cygwin-1_7_2-release:1.40
	fifo_doover3:1.38.0.2
	cygwin-1_7_1-release:1.36
	prefifo:1.34
	cv-branch-2:1.32.0.2
	pre-ripout-set_console_state_for_spawn:1.28
	EOL_registry_mounts:1.26
	preoverlapped:1.21
	drop_9x_support_start:1.18
	cr-0x5f1:1.18.0.2
	cv-branch:1.17.0.2
	pre-ptymaster-archetype:1.16
	cr-0x3b58:1.16.0.4
	cr-0x5ef:1.16.0.2
	after-mmap-privanon-noreserve:1.16
	after-mmap-revamp:1.16
	before-mmap-revamp:1.16
	cgf-more-exit-sync:1.16
	post_wait_sig_exit:1.13
	pre_wait_sig_exit:1.13
	reparent-point:1.7
	noreparent:1.7.0.2
	cr-0x5e6:1.6.0.2
	cr-0x9e:1.3.0.6
	cr-0x9d:1.3.0.4
	cgf-deleteme:1.3.0.2
	pre-sigrewrite:1.2
	corinna-01:1.2
	pre-cgf-merge:1.2
	cgf-dev-branch:1.1.0.2;
locks; strict;
comment	@// @;


1.59
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.58;

1.58
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2012.12.07.20.59.44;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2012.06.17.20.50.24;	author cgf;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2012.01.22.21.43.25;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2011.12.09.16.02.56;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2011.12.07.03.07.25;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2011.12.04.18.32.00;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2011.11.23.18.56.57;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2011.10.30.04.50.35;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2011.05.05.17.44.42;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2011.05.02.18.48.11;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2011.04.29.08.27.11;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2011.03.09.16.47.44;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2010.04.06.15.09.44;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2010.04.02.18.55.01;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.02.16.43.27;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2010.03.12.23.13.47;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.18.20.32.03;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2009.12.09.16.52.43;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.31.13.24.06;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.17.22.51.28;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.17.18.17.11;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.27.15.04.42;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2008.11.26.17.21.03;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.20.02.25.06;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.31.18.03.25;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.04.13.29.44;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.29.05.22.05;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.07.17.00.33;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.29.16.37.36;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.27.12.58.56;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.23.14.47.45;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.17.19.30.30;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.23.00.19.39;	author cgf;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2005.09.28.22.56.42;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.28.19.22.22;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.28.19.02.49;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.07.18.41.31;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.19.01.25.19;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.22.13.58.08;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.17.00.12.14;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.16.05.20.00;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.07.04.26.32;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.21.17.41.40;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.20.00.31.13;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.16.02.01.04;	author cgf;	state dead;
branches
	1.1.2.1;
next	;

1.55.2.1
date	2012.12.10.11.45.47;	author corinna;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2012.12.10.12.19.45;	author corinna;	state Exp;
branches;
next	1.55.2.3;

1.55.2.3
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	;

1.17.2.1
date	2006.07.18.10.33.54;	author corinna;	state Exp;
branches;
next	;

1.1.2.1
date	2003.01.16.02.01.04;	author cgf;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.01.26.06.43.32;	author cgf;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@/* fhandler_fifo.cc - See fhandler.h for a description of the fhandler classes.

   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Red Hat, Inc.

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */

#include "winsup.h"
#include "miscfuncs.h"

#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "sigproc.h"
#include "cygtls.h"
#include "shared_info.h"
#include "ntdll.h"
#include "cygwait.h"

fhandler_fifo::fhandler_fifo ():
  fhandler_base_overlapped (),
  read_ready (NULL), write_ready (NULL)
{
  max_atomic_write = DEFAULT_PIPEBUFSIZE;
  need_fork_fixup (true);
}

#define fnevent(w) fifo_name (npbuf, w "-event")
#define fnpipe() fifo_name (npbuf, "fifo")
#define create_pipe(r, w) \
  fhandler_pipe::create (sa_buf, (r), (w), 0, fnpipe (), open_mode)

char *
fhandler_fifo::fifo_name (char *buf, const char *what)
{
  /* Generate a semi-unique name to associate with this fifo. */
  __small_sprintf (buf, "%s.%08x.%016X", what, get_dev (),
		   get_ino ());
  return buf;
}

inline PSECURITY_ATTRIBUTES
sec_user_cloexec (bool cloexec, PSECURITY_ATTRIBUTES sa, PSID sid)
{
  return cloexec ? sec_user_nih (sa, sid) : sec_user (sa, sid);
}

bool inline
fhandler_fifo::arm (HANDLE h)
{
#ifdef DEBUGGING
  const char *what;
  if (h == read_ready)
    what = "reader";
  else if (h == write_ready)
    what = "writer";
  else
    what = "overlapped event";
  debug_only_printf ("arming %s", what);
#endif

  bool res = SetEvent (h);
  if (!res)
#ifdef DEBUGGING
    debug_printf ("SetEvent for %s failed, %E", what);
#else
    debug_printf ("SetEvent failed, %E");
#endif
  return res;
}

int
fhandler_fifo::open (int flags, mode_t)
{
  enum
  {
    success,
    error_errno_set,
    error_set_errno
  } res;
  bool reader, writer, duplexer;
  DWORD open_mode = FILE_FLAG_OVERLAPPED;

  /* Determine what we're doing with this fhandler: reading, writing, both */
  switch (flags & O_ACCMODE)
    {
    case O_RDONLY:
      reader = true;
      writer = false;
      duplexer = false;
      break;
    case O_WRONLY:
      writer = true;
      reader = false;
      duplexer = false;
      break;
    case O_RDWR:
      open_mode |= PIPE_ACCESS_DUPLEX;
      reader = true;
      writer = false;
      duplexer = true;
      break;
    default:
      set_errno (EINVAL);
      res = error_errno_set;
      goto out;
    }

  debug_only_printf ("reader %d, writer %d, duplexer %d", reader, writer, duplexer);
  set_flags (flags);
  char char_sa_buf[1024];
  LPSECURITY_ATTRIBUTES sa_buf;
  sa_buf = sec_user_cloexec (flags & O_CLOEXEC, (PSECURITY_ATTRIBUTES) char_sa_buf,
		      cygheap->user.sid());
  char npbuf[MAX_PATH];

  /* Create control events for this named pipe */
  if (!(read_ready = CreateEvent (sa_buf, duplexer, false, fnevent ("r"))))
    {
      debug_printf ("CreatEvent for %s failed, %E", npbuf);
      res = error_set_errno;
      goto out;
    }
  if (!(write_ready = CreateEvent (sa_buf, false, false, fnevent ("w"))))
    {
      debug_printf ("CreatEvent for %s failed, %E", npbuf);
      res = error_set_errno;
      goto out;
    }

  /* If we're reading, create the pipe, signal that we're ready and wait for
     a writer.
     FIXME: Probably need to special case O_RDWR case.  */
  if (!reader)
    /* We are not a reader */;
  else if (create_pipe (&get_io_handle (), NULL))
    {
      debug_printf ("create of reader failed");
      res = error_set_errno;
      goto out;
    }
  else if (!arm (read_ready))
    {
      res = error_set_errno;
      goto out;
    }
  else if (!duplexer && !wait (write_ready))
    {
      res = error_errno_set;
      goto out;
    }

  /* If we're writing, it's a little tricky since it is possible that
     we're attempting to open the other end of a pipe which is already
     connected.  In that case, we detect ERROR_PIPE_BUSY, reset the
     read_ready event and wait for the reader to allow us to connect
     by signalling read_ready.

     Once the pipe has been set up, we signal write_ready.  */
  if (writer)
    {
      int err;
      while (1)
	if (!wait (read_ready))
	  {
	    res = error_errno_set;
	    goto out;
	  }
	else if ((err = create_pipe (NULL, &get_io_handle ())) == 0)
	  break;
	else if (err == ERROR_PIPE_BUSY)
	  {
	    debug_only_printf ("pipe busy");
	    ResetEvent (read_ready);
	  }
	else
	  {
	    debug_printf ("create of writer failed");
	    res = error_set_errno;
	    goto out;
	  }
      if (!arm (write_ready))
	{
	  res = error_set_errno;
	  goto out;
	}
    }

  /* If setup_overlapped() succeeds (and why wouldn't it?) we are all set. */
  if (setup_overlapped () == 0)
    res = success;
  else
    {
      debug_printf ("setup_overlapped failed, %E");
      res = error_set_errno;
    }

out:
  if (res == error_set_errno)
    __seterrno ();
  if (res != success)
    {
      if (read_ready)
	{
	  CloseHandle (read_ready);
	  read_ready = NULL;
	}
      if (write_ready)
	{
	  CloseHandle (write_ready);
	  write_ready = NULL;
	}
      if (get_io_handle ())
	CloseHandle (get_io_handle ());
    }
  debug_printf ("res %d", res);
  return res == success;
}

bool
fhandler_fifo::wait (HANDLE h)
{
#ifdef DEBUGGING
  const char *what;
  if (h == read_ready)
    what = "reader";
  else if (h == write_ready)
    what = "writer";
  else
    what = "overlapped event";
#endif
  /* Set the wait to zero for non-blocking I/O-related events. */
  DWORD wait = ((h == read_ready || h == write_ready)
		&& get_flags () & O_NONBLOCK) ? 0 : INFINITE;

  debug_only_printf ("waiting for %s", what);
  /* Wait for the event.  Set errno, as appropriate if something goes wrong. */
  switch (cygwait (h, wait))
    {
    case WAIT_OBJECT_0:
      debug_only_printf ("successfully waited for %s", what);
      return true;
    case WAIT_SIGNALED:
      debug_only_printf ("interrupted by signal while waiting for %s", what);
      set_errno (EINTR);
      return false;
    case WAIT_CANCELED:
      debug_only_printf ("cancellable interruption while waiting for %s", what);
      pthread::static_cancel_self ();	/* never returns */
      break;
    case WAIT_TIMEOUT:
      if (h == write_ready)
	{
	  debug_only_printf ("wait timed out waiting for write but will still open reader since non-blocking mode");
	  return true;
	}
      else
	{
	  set_errno (ENXIO);
	  return false;
	}
      break;
    default:
      debug_only_printf ("unknown error while waiting for %s", what);
      __seterrno ();
      return false;
   }
}

void __reg3
fhandler_fifo::raw_read (void *in_ptr, size_t& len)
{
  size_t orig_len = len;
  for (int i = 0; i < 2; i++)
    {
      fhandler_base_overlapped::raw_read (in_ptr, len);
      if (len || i || WaitForSingleObject (read_ready, 0) != WAIT_OBJECT_0)
	break;
      /* If we got here, then fhandler_base_overlapped::raw_read returned 0,
	 indicating "EOF" and something has set read_ready to zero.  That means
	 we should have a client waiting to connect.
	 FIXME: If the client CTRL-C's the open during this time then this
	 could hang indefinitely.  Maybe implement a timeout?  */
      if (!DisconnectNamedPipe (get_io_handle ()))
	{
	  debug_printf ("DisconnectNamedPipe failed, %E");
	  goto errno_out;
	}
      else if (!ConnectNamedPipe (get_io_handle (), get_overlapped ())
	       && GetLastError () != ERROR_IO_PENDING)
	{
	  debug_printf ("ConnectNamedPipe failed, %E");
	  goto errno_out;
	}
      else if (!arm (read_ready))
	goto errno_out;
      else if (!wait (get_overlapped_buffer ()->hEvent))
	goto errout;	/* If wait() fails, errno is set so no need to set it */
      len = orig_len;	/* Reset since raw_read above set it to zero. */
    }
  return;

errno_out:
  __seterrno ();
errout:
  len = -1;
}

int __reg2
fhandler_fifo::fstatvfs (struct statvfs *sfs)
{
  fhandler_disk_file fh (pc);
  fh.get_device () = FH_FS;
  return fh.fstatvfs (sfs);
}

int
fhandler_fifo::close ()
{
  CloseHandle (read_ready);
  CloseHandle (write_ready);
  return fhandler_base::close ();
}

int
fhandler_fifo::dup (fhandler_base *child, int flags)
{
  if (fhandler_base_overlapped::dup (child, flags))
    {
      __seterrno ();
      return -1;
    }
  fhandler_fifo *fhf = (fhandler_fifo *) child;
  if (!DuplicateHandle (GetCurrentProcess (), read_ready,
			GetCurrentProcess (), &fhf->read_ready,
			0, true, DUPLICATE_SAME_ACCESS))
    {
      fhf->close ();
      __seterrno ();
      return -1;
    }
  if (!DuplicateHandle (GetCurrentProcess (), write_ready,
			GetCurrentProcess (), &fhf->write_ready,
			0, true, DUPLICATE_SAME_ACCESS))
    {
      CloseHandle (fhf->read_ready);
      fhf->close ();
      __seterrno ();
      return -1;
    }
  return 0;
}

void
fhandler_fifo::fixup_after_fork (HANDLE parent)
{
  fhandler_base_overlapped::fixup_after_fork (parent);
  fork_fixup (parent, read_ready, "read_ready");
  fork_fixup (parent, write_ready, "write_ready");
}

void
fhandler_fifo::set_close_on_exec (bool val)
{
  fhandler_base::set_close_on_exec (val);
  set_no_inheritance (read_ready, val);
  set_no_inheritance (write_ready, val);
}
@


1.58
log
@	* Merge in cygwin-64bit-branch.
@
text
@d277 1
a277 1
void __stdcall
@


1.57
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d293 1
a293 1
	  debug_printf ("DisconnecttNamedPipe failed, %E");
@


1.56
log
@* exceptions.cc (sigpacket::process): Reorganize to avoid use of tls before
initialization.
* fhandler_fifo.cc (fhandler_fifo::arm): Avoid improper printing of integer as
a string in debug output.
@
text
@d316 1
a316 1
int __stdcall
@


1.55
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d71 5
a75 1
    debug_printf ("SetEvent for %s failed, %E", res);
@


1.55.2.1
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d289 1
a289 1
	  debug_printf ("DisconnectNamedPipe failed, %E");
@


1.55.2.2
log
@Pull in changes from HEAD
@
text
@d71 1
a71 5
#ifdef DEBUGGING
    debug_printf ("SetEvent for %s failed, %E", what);
#else
    debug_printf ("SetEvent failed, %E");
#endif
@


1.55.2.3
log
@Pull in changes from HEAD
@
text
@d316 1
a316 1
int __reg2
@


1.54
log
@* fhandler.h (fhandler_fifo::arm): Declare new function.
* fhandler_fifo.cc (fhandler_fifo::arm): Define new function.
(fhandler_fifo::open): Fix handling of RDWR pipes to avoid opening a second
handle.  Use arm() function to set events.
(fhandler_fifo::raw_read): Correctly go into "connect again logic" when we
detect another writer is available.  Use arm() function to set event.
* pipe.cc (fhandler_pipe::create): Add more detail to debugging output.
@
text
@d25 1
d246 8
a265 8
    case WAIT_OBJECT_0 + 1:
      debug_only_printf ("interrupted by signal while waiting for %s", what);
      set_errno (EINTR);
      return false;
    case WAIT_OBJECT_0 + 2:
      debug_only_printf ("cancellable interruption while waiting for %s", what);
      pthread::static_cancel_self ();	/* never returns */
      break;
@


1.53
log
@Rename cygWFMO to cygwait throughout and use the magic of polymorphism to "wait
for stuff".
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use simplified arg
form of cygwait.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_audio.cc (fhandler_dev_dsp::Audio_out::waitforspac): Ditto.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* select.cc (cygwin_select): Ditto.
* sigproc.h (cygwait): Rename from cygWFMO.  Define two argument and single
argument forms of this function.
* fhandler_tty.cc (fhandler_pty_slave::open): Use method to query if tty is
open.
(fhandler_pty_slave::read): Send SIGHUP when master is detected as closed.
(fhandler_pty_common::close): Close input_available_event in callers since
master may need to signal it first.
(fhandler_pty_master::close): Lie and set input_available_event when closing,
then close input_available_event.
(fhandler_pty_slave::close): Close input_available_event explicitly here.
* tty.h (tty::is_master_closed): Declare new method.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d54 20
d83 1
a83 1
  bool reader, writer;
d92 1
d97 1
d100 1
d102 2
a103 2
      writer = true;
      open_mode |= PIPE_ACCESS_DUPLEX;
d111 1
d120 1
a120 1
  if (!(read_ready = CreateEvent (sa_buf, true, false, fnevent ("r"))))
d126 1
a126 1
  if (!(write_ready = CreateEvent (sa_buf, true, false, fnevent ("w"))))
d144 1
a144 1
  else if (!SetEvent (read_ready))
a145 1
      debug_printf ("SetEvent for read_ready failed, %E");
d149 1
a149 1
  else if (!writer && !wait (write_ready))
a150 1
      debug_printf ("wait for write_ready failed, %E");
d184 1
a184 1
      if (!SetEvent (write_ready))
a185 1
	  debug_printf ("SetEvent for write_ready failed, %E");
d279 1
a279 1
      if (len || i || WaitForSingleObject (read_ready, 0) == WAIT_OBJECT_0)
d297 2
a298 5
      else if (!SetEvent (read_ready))
	{
	  debug_printf ("SetEvent (read_ready) failed, %E");
	  goto errno_out;
	}
@


1.52
log
@* fhandler_fifo.cc (fhandler_fifo::wait): Fix stupid typo and actually wait for
the handle.
@
text
@d219 1
a219 1
  switch (cygWFMO (1, wait, h))
@


1.51
log
@* sigproc.cc (cygWFMO): Don't assume that cancellable event is always
available.
* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::waitforspace): Use cygWFMO
instead of WaitForMultipleObjects.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto for degenerate case.
@
text
@d219 1
a219 1
  switch (cygWFMO (1, wait))
@


1.50
log
@* fhandler.h (fhandler_pipe::create): Rename from the misnamed
"create_selectable".  Change return to DWORD.
(fhandler_pty_common::pipesize): New constant.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Reflect create_selectable
name change.
* miscfuncs.cc (CreatePipeOverlapped): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create): Rename from the misnamed "create_selectable".  Return
DWORD.  Only set pipe size to default when it is passed in as zero.
* fhandler_tty.cc (fhandler_pty_master::setup): Ditto.  Use
fhandler_pty_common::pipesize rather than a raw constant.
* tty.cc (tty::not_allocated): Ditto.
* sigproc.cc (sigproc_init): Use create_selectable to create the signal pipe to
get a more appropriate message based pipe.
@
text
@a212 2
  HANDLE w4[3] = {h, signal_arrived, pthread::get_cancel_event ()};

d219 1
a219 1
  switch (WaitForMultipleObjects (3, w4, false, wait))
@


1.49
log
@* fhandler.h (fhandler_pipe::create_selectable): Remove optional argument, take
an options argument for CreateNamedPipe/CreateFile.  Change handle arguments to
expect pointers.
(fhandler_fifo::fifo_state): Delete.
(fhandler_fifo::dummy_client): Ditto.
(fhandler_fifo::open_nonserver): Ditto.
(fhandler_fifo::wait_state): Ditto.
(fhandler_fifo::raw_write): Ditto.
(fhandler_fifo::read_ready): New field.
(fhandler_fifo::write_ready): Ditto.
(fhandler_fifo::wait): Modify argument.
(fhandler_fifo::fifo_name): Add a new argument.
(fhandler_fifo::fixup_after_fork): New function.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove initialization of
expunged elements.  Initialize new handles to NULL.
(fhandler_fifo::open_nonserver): Delete.
(fnevent): New macro for creating a named event.
(fnpipe): New macro for creating a unique named pipe name.
(create_pipe): New macro for simplification of named pipe creation.
(fhandler_fifo::fifo_name): Use new argument when creating a shared name.
(fhandler_fifo::open): Rewrite.  Use events to synchronize.
(pure_debug_printf): New macro, active only when DEBUGGING.
(fhandler_fifo::wait): Rewrite to wait for new fifo events which are supplied
as a parameter.
(fhandler_fifo::raw_read): Rewrite to use handle mechanism to detect
client-side disconnect.
(fhandler_fifo::raw_write): Delete.
(fhandler_fifo::close): Remove accommodations for expunged fields.  Close event
handles.
(fhandler_fifo::dup): Remove accommodations for expunged fields.  Duplicate
event handles.
(fhandler_fifo::fixup_after_fork): New function.  Perform fixups on event
handles.
(fhandler_fifo::set_close_on_exec): Remove accommodations for expunged fields.
Set inheritance for new handle fields.
* miscfuncs.cc (CreatePipeOverlapped): Accommodate changes in
fhandler_pipe::create_selectable.
* tty.cc (tty::not_allocated): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create_selectable): Accept an extra open_mode argument.  Pass
arguments by reference and allow opening one end of the pipe at a time.
* sys/strace.h (debug_only_printf): Define new macro which calls debug_printf
only when DEBUGGING is defined.
@
text
@d37 1
a37 1
  fhandler_pipe::create_selectable (sa_buf, (r), (w), 0, fnpipe (), open_mode)
@


1.48
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d27 2
a28 1
  fhandler_base_overlapped (), wait_state (fifo_unknown), dummy_client (NULL)
d34 4
a37 24
HANDLE
fhandler_fifo::open_nonserver (const char *npname, unsigned low_flags,
			       LPSECURITY_ATTRIBUTES sa_buf)
{
  DWORD mode = 0;
  if (low_flags == O_RDONLY)
    mode = GENERIC_READ;
  else if (low_flags == O_WRONLY)
    mode = GENERIC_WRITE;
  else
    mode = GENERIC_READ | GENERIC_WRITE;
  while (1)
    {
      HANDLE h = CreateFile (npname, mode, 0, sa_buf, OPEN_EXISTING,
			     FILE_FLAG_OVERLAPPED, NULL);
      if (h != INVALID_HANDLE_VALUE || GetLastError () != ERROR_PIPE_NOT_CONNECTED)
	return h;
      if (IsEventSignalled (signal_arrived))
	{
	  set_errno (EINTR);
	  return NULL;
	}
    }
}
d40 1
a40 1
fhandler_fifo::fifo_name (char *buf)
d43 2
a44 2
  __small_sprintf (buf, "\\\\.\\pipe\\__cygfifo__%S_%08x_%016X",
		   &installation_key, get_dev (), get_ino ());
a47 6
#define FIFO_PIPE_MODE (PIPE_TYPE_BYTE | PIPE_READMODE_BYTE)
#define FIFO_BUF_SIZE  4096
#define cnp(m, s) CreateNamedPipe(npname, (m), FIFO_PIPE_MODE, \
			       PIPE_UNLIMITED_INSTANCES, (s), (s), \
			       NMPWAIT_WAIT_FOREVER, sa_buf)

d57 8
a64 2
  int res = 1;
  char npname[MAX_PATH];
d66 2
a67 8
  fifo_name (npname);
  unsigned low_flags = flags & O_ACCMODE;
  DWORD mode = 0;
  if (low_flags == O_WRONLY)
    mode = PIPE_ACCESS_OUTBOUND;
  else if (low_flags == O_RDONLY || low_flags == O_RDWR)
    mode = PIPE_ACCESS_DUPLEX;
  else
d69 14
d84 2
a85 1
      res = 0;
d88 9
a96 1
  if (res)
d98 10
a107 5
      char char_sa_buf[1024];
      LPSECURITY_ATTRIBUTES sa_buf =
	sec_user_cloexec (flags & O_CLOEXEC, (PSECURITY_ATTRIBUTES) char_sa_buf,
			  cygheap->user.sid());
      bool do_seterrno = true;
d109 54
a162 4
      HANDLE h;
      bool nonblocking_write = !!((flags & (O_WRONLY | O_NONBLOCK)) == (O_WRONLY | O_NONBLOCK));
      wait_state = fifo_unknown;
      if (mode != PIPE_ACCESS_OUTBOUND)
d164 3
a166 2
	  h = cnp (mode |  FILE_FLAG_OVERLAPPED, FIFO_BUF_SIZE);
	  wait_state = fifo_wait_for_client;
d168 17
a184 1
      else
d186 2
a187 24
	  h = open_nonserver (npname, low_flags, sa_buf);
	  if (h != INVALID_HANDLE_VALUE)
	    wait_state = fifo_ok;
	  else if (nonblocking_write)
	    {
	      set_errno (ENXIO);
	      do_seterrno = false;
	    }
	  else if ((h = cnp (PIPE_ACCESS_DUPLEX, 1)) != INVALID_HANDLE_VALUE)
	    {
	      if ((dummy_client = open_nonserver (npname, low_flags, sa_buf))
		  != INVALID_HANDLE_VALUE)
		{
		  wait_state = fifo_wait_for_server;
		  ProtectHandle (dummy_client);
		}
	      else
		{
		  DWORD saveerr = GetLastError ();
		  CloseHandle (h);
		  h = INVALID_HANDLE_VALUE;
		  SetLastError (saveerr);
		}
	    }
d189 1
a189 1
      if (h == INVALID_HANDLE_VALUE)
d191 2
a192 15
	  if (do_seterrno)
	    __seterrno ();
	  res = 0;
	}
      else if (setup_overlapped ())
	{
	  CloseHandle (h);
	  __seterrno ();
	  res = 0;
	}
      else
	{
	  set_io_handle (h);
	  set_flags (flags);
	  res = 1;
d194 2
d197 2
a198 3

  debug_printf ("returning %d, errno %d", res, get_errno ());
  return res;
d202 1
a202 1
fhandler_fifo::wait (bool iswrite)
d204 18
a221 2
  DWORD ninstances;
  switch (wait_state)
d223 5
a227 3
    case fifo_wait_for_next_client:
      DisconnectNamedPipe (get_handle ());
      if (!GetNamedPipeHandleState (get_handle (), NULL, &ninstances, NULL, NULL, NULL, 0))
d229 2
a230 3
	  __seterrno ();
	  wait_state = fifo_error;
	  return false;
d232 1
a232 1
      if (ninstances <= 1)
d234 1
a234 1
	  wait_state = fifo_eof;
a236 24
    case fifo_wait_for_client:
      {
	DWORD dummy_bytes;
	while (1)
	  {
	    int res = ConnectNamedPipe (get_handle (), get_overlapped ());
	    if (GetLastError () != ERROR_NO_DATA && GetLastError () != ERROR_PIPE_CONNECTED)
	      {
		res = wait_overlapped (res, iswrite, &dummy_bytes, false);
		if (!res)
		  {
		    if (get_errno () != EINTR)
		      wait_state = fifo_error;
		    else if (!_my_tls.call_signal_handler ())
		      wait_state = fifo_eintr;
		    else
		      continue;
		    return false;
		  }
	      }
	    wait_state = fifo_ok;
	    break;
	  }
      }
d238 8
a245 44
    case fifo_wait_for_server:
      char npname[MAX_PATH];
      fifo_name (npname);
      char char_sa_buf[1024];
      LPSECURITY_ATTRIBUTES sa_buf;
      sa_buf = sec_user_cloexec (close_on_exec (),
				 (PSECURITY_ATTRIBUTES) char_sa_buf,
				 cygheap->user.sid());
      while (1)
	{
	  if (WaitNamedPipe (npname, 10))
	    /* connected, maybe */;
	  else if (GetLastError () != ERROR_SEM_TIMEOUT)
	    {
	      __seterrno ();
	      return false;
	    }
	  else if (!IsEventSignalled (signal_arrived))
	    continue;
	  else if (_my_tls.call_signal_handler ())
	    continue;
	  else
	    {
	      set_errno (EINTR);
	      return false;
	    }
	  HANDLE h = open_nonserver (npname, get_flags () & O_ACCMODE, sa_buf);
	  if (h != INVALID_HANDLE_VALUE)
	    {
	      ForceCloseHandle (get_handle ());
	      ForceCloseHandle (dummy_client);
	      dummy_client = NULL;
	      wait_state = fifo_ok;
	      set_io_handle (h);
	      break;
	    }
	  if (GetLastError () == ERROR_PIPE_LISTENING)
	    continue;
	  else
	    {
	      __seterrno ();
	      return false;
	    }
	}
d247 4
a250 3
      break;
    }
    return true;
d256 32
a287 16
  while (wait_state != fifo_eof && wait_state != fifo_error && wait_state != fifo_eintr)
    if (!wait (false))
      len = (wait_state == fifo_error || wait_state == fifo_eintr) ? (size_t) -1 : 0;
    else
      {
	size_t prev_len = len;
	fhandler_base_overlapped::raw_read (in_ptr, len);
	if (len)
	  break;
	wait_state = fifo_wait_for_next_client;
	len = prev_len;
      }
  if (wait_state == fifo_eintr)
    wait_state = fifo_wait_for_client;
  debug_printf ("returning %d, mode %d, %E\n", len, get_errno ());
}
d289 4
a292 4
ssize_t __stdcall
fhandler_fifo::raw_write (const void *ptr, size_t len)
{
  return wait (true) ? fhandler_base_overlapped::raw_write (ptr, len) : -1;
d306 2
a307 6
  wait_state = fifo_eof;
  if (dummy_client)
    {
      ForceCloseHandle (dummy_client);
      dummy_client = NULL;
    }
d314 22
a335 15
  int res = fhandler_base_overlapped::dup (child, flags);
  fhandler_fifo *fifo_child = (fhandler_fifo *) child;
  if (res == 0 && dummy_client)
    {
      bool dres = DuplicateHandle (GetCurrentProcess (), dummy_client,
				   GetCurrentProcess (),
				   &fifo_child->dummy_client, 0,
				   TRUE, DUPLICATE_SAME_ACCESS);
      if (!dres)
	{
	  fifo_child->dummy_client = NULL;
	  child->close ();
	  __seterrno ();
	  res = -1;
	}
d337 9
a345 1
  return res;
d352 2
a353 2
  if (dummy_client)
    set_no_inheritance (dummy_client, val);
@


1.47
log
@* fhandler.cc (fhandler_base_overlapped::raw_read): Rename from
read_overlapped.
(fhandler_base_overlapped::raw_e): Rename from write_overlapped.
* fhandler.h (fhandler_*::raw_read): Add reparm decoration.
(fhandler_*::raw_write): Ditto.
(fhandler_base_overlapped::raw_read): Rename from read_overlapped.
(fhandler_base_overlapped::raw_write): Rename from write_overlapped.
(fhandler_pipe::raw_read): Delete.
(fhandler_pipe::raw_write): Ditto.
(fhandler_mailslot::raw_read): Ditto.
* fhandler_fifo.cc (fhandler_fifo::raw_read): Reflect read_overlapped ->
raw_read rename.
(fhandler_fifo::raw_write): Ditto.
* fhandler_mailslot.cc (fhandler_mailslot::raw_read): Delete.
(fhandler_mailslot::raw_write): Reflect read_overlapped -> raw_read rename.
* pipe.cc (fhandler_pipe::raw_read): Delete.
(fhandler_pipe::raw_write): Ditto.
@
text
@d306 1
a306 1
fhandler_fifo::dup (fhandler_base *child)
d308 1
a308 1
  int res = fhandler_base_overlapped::dup (child);
@


1.46
log
@	* thread.cc (cancelable_wait): Remove test for main thread.
	* fhandler_fifo.cc (fhandler_fifo::open_nonserver): Ditto.
@
text
@d268 1
a268 1
	read_overlapped (in_ptr, len);
d282 1
a282 1
  return wait (true) ? write_overlapped (ptr, len) : -1;
@


1.45
log
@	* ntdll.h (IsEventSignalled): New inline function.
	* cygthread.cc (cygthread::terminate_thread): Use IsEventSignalled in
	place of WaitForSingleObject on event with 0 timeout.
	* fhandler.cc (fhandler_base_overlapped::has_ongoing_io): Ditto.
	* fhandler_fifo.cc (fhandler_fifo::open_nonserver): Ditto.
	(fhandler_fifo::wait): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* select.cc (verify_tty_slave): Ditto.
	* thread.cc (pthread::testcancel): Ditto.
@
text
@d50 1
a50 3
      if (&_my_tls != _main_tls)
	yield ();
      else if (IsEventSignalled (signal_arrived))
@


1.44
log
@* errno.cc (errmap): Change mapping of NO_SYSTEM_RESOURCES to EFBIG.
* fhandler.cc (MAX_OVERLAPPED_WRITE_LEN): New constant.
(MIN_OVERLAPPED_WRITE_LEN): Ditto.
(fhandler_base_overlapped::close): Accommodate change in arguments to
wait_overlapped.
(fhandler_base_overlapped::setup_overlapped): Add __stdcall and regparm
modifiers.
(fhandler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Ditto.
(fhandler_base_overlapped::wait_overlapped): Modify to return an enum returning
various states.  Accept nonblocking parameter.
(fhandler_base_overlapped::read_overlapped): Add __stdcall and regparm
modifiers.  Rework to attempt to be smarter about reacting to states returned
by wait_overlapped.
(fhandler_base_overlapped::write_overlapped): Ditto.  Add fallback option for
when wait_overlapped detects that smaller chunks must be written.
(fhandler_base_overlapped::write_overlapped_fallback): Ditto.
* fhandler.h (DEFAULT_PIPEBUFSIZE): Move definition here from pipe.cc.
(fhandler_base::has_ongoing_io): Define with __stdcall and regparm modifiers.
(fhandler_base_overlapped::wait_return): New enum.
(fhandler_base_overlapped::max_atomic_write): New variable.
(fhandler_base_overlapped:: wait_overlapped): Accommodate changes mentioned
above to arguments and modifiers.
(fhandler_base_overlapped::setup_overlapped): Ditto for modifiers.
(fhandler_base_overlapped::read_overlapped): Ditto.
(fhandler_base_overlapped::write_overlapped): Ditto.
(fhandler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Ditto.
(fhandler_base_overlapped::fhandler_base_overlapped): Zero max_atomic_write.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Set max_atomic_write to the
size of the DEFAULT_PIPEBUFSIZE.
(fhandler_fifo::wait): Accommodate change in arguments to wait_overlapped.
* pipe.cc (fhandler_pipe::fhandler_pipe): Set max_atomic_write to the size of
the DEFAULT_PIPEBUFSIZE.
(fhandler_pipe::create_selectable): Allow minimum size of DEFAULT_PIPEBUFSIZE.
(DEFAULT_PIPEBUFSIZE): Delete here, move to fhandler.h.
@
text
@d24 1
d52 1
a52 1
      else if (WaitForSingleObject (signal_arrived, 0) == WAIT_OBJECT_0)
d228 1
a228 1
	  else if (WaitForSingleObject (signal_arrived, 0) != WAIT_OBJECT_0)
@


1.43
log
@* fhandler_fifo.cc (fhandler_fifo::open): Accommodate previous return value
change to setup_overlapped.
@
text
@d3 2
a4 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d28 1
d193 1
a193 1
		res = wait_overlapped (res, iswrite, &dummy_bytes);
@


1.42
log
@* fhandler.h (fhandler_base::setup_overlapped): Delete virtual declaration.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base_overlapped): Remove now-unneeded friend.
(fhandler_base_overlapped::setup_overlapped): Return int, remove parameter.
(fhandler_base_overlapped::get_overlapped): Return reference.
(fhandler_base_overlapped::fhandler_base_overlapped): Be more assertive about
zeroing everything.
(fhandler_base_overlapped::fixup_after_fork): Declare new function.
(fhandler_base_overlapped::fixup_after_exec): Ditto.
(fhandler_base_overlapped::dup): Ditto.
(fhandler_base_overlapped::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo::dup): Call fhandler_base_overlapped::dup
rather than fhandler_base::dup.
* pipe.cc (fhandler_pipe::dup): Ditto.
(fhandler_pipe::init): Accommodate change in setup_overlapped arguments for
"opened_properly" case.
@
text
@d146 1
a146 1
      else if (!setup_overlapped ())
@


1.41
log
@* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Properly initialize
overlapped part of this class.
@
text
@d307 1
a307 1
  int res = fhandler_base::dup (child);
@


1.40
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@d25 1
a25 1
  wait_state (fifo_unknown), dummy_client (NULL)
a26 1
  get_overlapped ()->hEvent = NULL;
@


1.39
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d49 1
a49 1
	low_priority_sleep (0);
@


1.38
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d73 5
d102 2
a103 1
	sec_user ((PSECURITY_ATTRIBUTES) char_sa_buf, cygheap->user.sid());
d214 3
a216 1
      sa_buf = sec_user ((PSECURITY_ATTRIBUTES) char_sa_buf, cygheap->user.sid());
@


1.37
log
@* fhandler_fifo.cc (fhandler_fifo::open): Avoid resetting errno after it has
been explicitly set.
* include/cygwin/version.h: Bump DLL minor version number to 2.
@
text
@d304 2
a305 1
      bool dres = DuplicateHandle (hMainProc, dummy_client, hMainProc,
@


1.36
log
@	* cygprops.h: New file.
	* dtable.cc (handle_to_fn): Add check for correct installation_key
	string in object name for pipes and ttys.
	* external.cc (cygwin_internal): Add CW_GET_INSTKEY to allow fetching
	the installation_key from cygserver.
	* fhandler_fifo.cc (fhandler_fifo::fifo_name): Add installation_key
	to fifo name.
	* globals.cc: Include cygprops.h.
	(_RDATA): Move slightly and add comment.
	(cygwin_props): Define.
	* mount.cc (mount_info::init): Accommodate the fact that
	installation_root is now a global variable in DLL common shared memory,
	rather than a member of cygwin_shared.
	* pipe.cc (fhandler_pipe::create_selectable): Add installation_key to
	pipe name.
	* shared.cc (installation_root): Define here for storage in DLL
	common shared memory.
	(installation_key): Ditto.
	(installation_key_buf): Ditto.
	(init_installation_root): Convert from shared_info method to ordinary
	function.  Add initializing installation_key.  Invalidate
	installation_key depending of value of disable_key property.  Add
	comment to explain.
	(get_shared_parent_dir): Add installation_key to directory name.
	(get_session_parent_dir): Ditto.
	(shared_info::initialize): Move call to init_installation_root from
	here...
	(memory_init): ...to here.  Add debug output to print installation root
	and installation key.  Add comment to explain why.
	* shared_info.h (SHARED_INFO_CB): Recalculate.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Remove definition of installation_root and
	declaration of init_installation_root.
	(init_installation_root): Declare.
	(installation_root): Declare.
	(installation_key): Declare.
	* uinfo.cc (pwdgrp::load): Accommodate the fact that installation_root
	is now a global variable in DLL common shared memory.
	* include/cygwin/version.h: Bump API minor number.
	(CYGWIN_INFO_INSTALLATIONS_NAME): Add.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_INSTKEY.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008 Red Hat, Inc.
d98 1
d114 4
a117 1
	    set_errno (ENXIO);
d137 2
a138 1
	  __seterrno ();
@


1.35
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d22 1
d62 2
a63 2
  __small_sprintf (buf, "\\\\.\\pipe\\__cygfifo__%08x_%016X",
		   get_dev (), get_ino ());
@


1.34
log
@revert erroneous checkin
@
text
@d24 1
a24 1
  wait_state (fifo_unknown)
d57 9
d67 5
d76 1
a76 1
  int res;
a77 5
  DWORD mode = 0;

  /* Generate a semi-unique name to associate with this fifo. */
  __small_sprintf (npname, "\\\\.\\pipe\\__cygfifo__%08x_%016X",
		   get_dev (), get_ino ());
d79 1
d81 2
a82 3
  if (low_flags == O_RDONLY)
    mode = PIPE_ACCESS_INBOUND;
  else if (low_flags == O_WRONLY)
d84 1
a84 1
  else if (low_flags == O_RDWR)
d86 1
a86 2

  if (!mode)
d91 2
a92 1
  else
a96 1
      mode |= FILE_FLAG_OVERLAPPED;
a98 1
      DWORD err;
d100 2
a101 1
      if (nonblocking_write)
d103 2
a104 2
	  h = INVALID_HANDLE_VALUE;
	  err = ERROR_ACCESS_DENIED;
d108 6
a113 9
	  h = CreateNamedPipe(npname, mode, FIFO_PIPE_MODE,
			      PIPE_UNLIMITED_INSTANCES, 0, 0,
			      NMPWAIT_WAIT_FOREVER, sa_buf);
	  err = GetLastError ();
	}
      if (h != INVALID_HANDLE_VALUE)
	wait_state = fifo_wait_for_client;
      else
	  switch (err)
d115 2
a116 3
	    case ERROR_ACCESS_DENIED:
	      h = open_nonserver (npname, low_flags, sa_buf);
	      if (h != INVALID_HANDLE_VALUE)
d119 1
a119 1
		  break;
d121 1
a121 1
	      if (nonblocking_write && GetLastError () == ERROR_FILE_NOT_FOUND)
d123 4
a126 2
		  set_errno (ENXIO);
		  break;
a127 4
	      /* fall through intentionally */
	    default:
	      __seterrno ();
	      break;
d129 6
a134 2
      if (!h || h == INVALID_HANDLE_VALUE)
	res = 0;
d137 1
d156 1
d159 13
a173 1
	bool res = ConnectNamedPipe (get_handle (), get_overlapped ());
d175 20
a194 3
	if (res || GetLastError () == ERROR_PIPE_CONNECTED)
	  return true;
	return wait_overlapped (res, iswrite, &dummy_bytes);
d196 1
a196 1
    case fifo_unknown:
d198 41
a238 1
      /* CGF FIXME SOON: test if these really need to be handled. */
d245 1
a245 1
void
d248 15
a262 4
  if (!wait (false))
    len = 0;
  else
    read_overlapped (in_ptr, len);
d265 1
a265 1
int
d278 41
@


1.33
log
@* cygtls.cc (_cygtls::init_exception_handler): Test for e, not e->prev or we
could still end up adding our handler twice.  Add comment explaining what we're
doing.
* dll_init.cc (dll_dllcrt0_1): Clarify comment.
@
text
@a58 9
char *
fhandler_fifo::fifo_name (char *buf)
{
  /* Generate a semi-unique name to associate with this fifo. */
  __small_sprintf (buf, "\\\\.\\pipe\\__cygfifo__%08x_%016X",
		   get_dev (), get_ino ());
  return buf;
}

d62 1
a62 1
  int res = 1;
d64 1
d66 3
a68 1
  fifo_name (npname);
d71 1
a71 4
  DWORD mode = 0;
  if (low_flags == O_WRONLY)
    /* ok */;
  else if (low_flags == O_RDONLY)
d73 2
d77 2
a78 1
  else
d83 1
a83 2

  if (res)
d93 1
a93 1
      if (flags & O_WRONLY)
d114 1
a114 1
		  wait_state = fifo_ok;
d117 1
a117 5
	      if (GetLastError () != ERROR_FILE_NOT_FOUND)
		__seterrno ();
	      else if (nonblocking_write)
		set_errno (ENXIO);
	      else
d119 2
a120 3
		  h = NULL;
		  nohandle (true);
		  wait_state = fifo_wait_for_server;
d122 1
a122 1
	      break;
d127 1
a127 1
      if (h == INVALID_HANDLE_VALUE)
a150 2
    case fifo_wait_for_next_client:
      DisconnectNamedPipe (get_handle ());
d153 5
a157 18
	int res;
	if ((res = ConnectNamedPipe (get_handle (), get_overlapped ()))
	    || GetLastError () == ERROR_PIPE_CONNECTED)
	  {
	    wait_state = fifo_ok;
	    return true;
	  }
	if (wait_state == fifo_wait_for_next_client)
	  {
	    CancelIo (get_handle ());
	    res = 0;
	  }
	else
	  {
	    DWORD dummy_bytes;
	    res = wait_overlapped (res, iswrite, &dummy_bytes);
	  }
	wait_state = res ? fifo_ok : fifo_eof;
d159 1
a159 1
      break;
d161 1
a161 41
      if (get_io_handle ())
	break;
      char npname[MAX_PATH];
      fifo_name (npname);
      char char_sa_buf[1024];
      LPSECURITY_ATTRIBUTES sa_buf;
      sa_buf = sec_user ((PSECURITY_ATTRIBUTES) char_sa_buf, cygheap->user.sid());
      while (1)
	{
	  if (WaitNamedPipe (npname, 10))
	    /* connected, maybe */;
	  else if (GetLastError () != ERROR_SEM_TIMEOUT)
	    {
	      __seterrno ();
	      return false;
	    }
	  else if (WaitForSingleObject (signal_arrived, 0) != WAIT_OBJECT_0)
	    continue;
	  else if (_my_tls.call_signal_handler ())
	    continue;
	  else
	    {
	      set_errno (EINTR);
	      return false;
	    }
	  HANDLE h = open_nonserver (npname, get_flags () & O_ACCMODE, sa_buf);
	  if (h != INVALID_HANDLE_VALUE)
	    {
	      wait_state = fifo_ok;
	      set_io_handle (h);
	      nohandle (false);
	      break;
	    }
	  if (GetLastError () == ERROR_PIPE_LISTENING)
	    continue;
	  else
	    {
	      __seterrno ();
	      return false;
	    }
	}
d171 4
a174 9
  while (wait_state != fifo_eof)
    if (!wait (false))
      len = 0;
    else
      {
	read_overlapped (in_ptr, len);
	if (!len)
	  wait_state = fifo_wait_for_next_client;
      }
@


1.32
log
@	* fhandler.h (class fhandler_fifo): Rename read/write methods to
	raw_read/raw_write.
	* fhandler_fifo.cc: Ditto.
@
text
@d59 9
d71 1
a71 1
  int res;
a72 1
  DWORD mode = 0;
d74 1
a74 3
  /* Generate a semi-unique name to associate with this fifo. */
  __small_sprintf (npname, "\\\\.\\pipe\\__cygfifo__%08x_%016X",
		   get_dev (), get_ino ());
d77 4
a80 1
  if (low_flags == O_RDONLY)
a81 2
  else if (low_flags == O_WRONLY)
    mode = PIPE_ACCESS_OUTBOUND;
d84 1
a84 2

  if (!mode)
d89 2
a90 1
  else
d100 1
a100 1
      if (nonblocking_write)
d121 1
a121 1
		  wait_state = fifo_wait_for_server;
d124 5
a128 1
	      if (nonblocking_write && GetLastError () == ERROR_FILE_NOT_FOUND)
d130 3
a132 2
		  set_errno (ENXIO);
		  break;
d134 1
a134 1
	      /* fall through intentionally */
d139 1
a139 1
      if (!h || h == INVALID_HANDLE_VALUE)
d163 2
d167 18
a184 5
	bool res = ConnectNamedPipe (get_handle (), get_overlapped ());
	DWORD dummy_bytes;
	if (res || GetLastError () == ERROR_PIPE_CONNECTED)
	  return true;
	return wait_overlapped (res, iswrite, &dummy_bytes);
d186 1
a186 1
    case fifo_unknown:
d188 41
a228 1
      /* CGF FIXME SOON: test if these really need to be handled. */
d238 9
a246 4
  if (!wait (false))
    len = 0;
  else
    read_overlapped (in_ptr, len);
@


1.31
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d169 1
a169 1
fhandler_fifo::read (void *in_ptr, size_t& len)
d178 1
a178 1
fhandler_fifo::write (const void *ptr, size_t len)
@


1.30
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d89 16
a104 3
      HANDLE h = CreateNamedPipe(npname, mode, FIFO_PIPE_MODE,
				 PIPE_UNLIMITED_INSTANCES, 0, 0,
				 NMPWAIT_WAIT_FOREVER, sa_buf);
d108 1
a108 1
	  switch (GetLastError ())
d117 5
@


1.29
log
@* fhandler.cc (fhandler_base::wait_overlapped): Always assume that bytes will
be non-NULL.  Distinguish input result from result derived from WFMO and
GetOverlappedResult or res can never be -1.  Only raise SIGPIPE when writing.
* fhandler.h (fhandler_base::wait_overlapped): Pass first argument by value.
* fhandler_fifo.cc (fhandler_fifo::wait): Pass in dummy byte count to
wait_overlapped.
* pipe.cc (DEFAULT_PIPEBUFSIZE): Define to 65536 explicitly.
@
text
@d37 1
a37 1
  else if (low_flags = O_WRONLY)
d134 10
a143 5
      bool res = ConnectNamedPipe (get_handle (), get_overlapped ());
      DWORD dummy_bytes;
      if (res || GetLastError () == ERROR_PIPE_CONNECTED)
	return true;
      return wait_overlapped (res, iswrite, &dummy_bytes);
@


1.28
log
@Remove unneeded header files from source files throughout.
@
text
@d135 1
d138 1
a138 1
      return wait_overlapped (res, iswrite, NULL);
@


1.27
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a12 4
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/statvfs.h>
a14 1
#include "perprocess.h"
a19 1
#include "pinfo.h"
@


1.26
log
@	* Fix copyright dates.
@
text
@d12 1
@


1.25
log
@	* smallprint.cc (__small_vswprintf): Fix uninitialized usage of `w'.

	Revamp advisory file locking to avoid cross reference pointers as well
	as to allow BSD flock semantics.  More agressively delete unused nodes
	and sync objects.
	* fhandler.h (fhandler_base::ino): Rename from namehash.  Fix comment.
	(fhandler_base::node): Remove.
	(fhandler_base::unique_id): Add.
	(fhandler_base::del_my_locks): New method.
	(get_ino): Rename from get_namehash.  Change usage throughout Cygwin.
	(get_unique_id): New method.
	* fhandler.cc (fhandler_base::close): Call own del_my_locks method.
	Fix comment.
	(fhandler_base::fhandler_base): Accommodate new and changed members.
	(fhandler_base::fixup_after_fork): Call del_my_locks.
	(fhandler_base::fixup_after_exec): Ditto for files with close-on-exec
	flag set.
	* fhandler_disk_file.cc (get_ino_by_handle): Rename from
	readdir_get_ino_by_handle.  Accommodate throughout.
	(fhandler_base::open_fs): Fill ino with inode number if FS has good
	inodes.  Allocate a LUID and store in unique_id to recognize file
	descriptors referencing the same file object.
	* flock.cc: Drop flock TODO comments.  Use explicit types __dev32_t
	and __ino64_t instead of dev_t and ino_t.
	(LOCK_OBJ_NAME_LEN): Change to reflect longer lf_id length.
	(get_obj_handle_count): New method.
	(lockf_t::lf_id): Change type to long long.
	(inode_t::get_lock_obj_handle_count): Drop in favor of static function
	get_obj_handle_count.
	(inode_t::del_locks): Remove.
	(inode_t::get): Add create_if_missing flag argument.
	(inode_t::del_my_locks): Reimplement to handle POSIX and BSD flock
	locks.  Return if node can be deleted or not.
	(inode_t::~inode_t): Ditto.  Close handles to i_dir and i_mtx.
	(fixup_lockf_after_fork): Remove.
	(fhandler_base::del_my_locks): New method.
	(fixup_lockf_after_exec): Check if node can be deleted.
	(inode_t::get): Only create node if create_if_missing is set.  Lock
	the returned node here before unlocking the node list.
	(inode_t::get_all_locks_list): Accommodate new lf_id length.
	(inode_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.  Change return type to bool.  De-const.
	Set lf_obj instead of returning a handle.
	(lockf_t::del_lock_obj): Call SetEvent only if new incoming parameters
	allow it.  Explain how it's supposed to work.
	(fhandler_disk_file::lock): Only fetch file length in SEEK_END case.
	Use NtQueryInformationFile(FileStandardInformation) instead of
	calling fstat_by_handle.  Always unlock node before returning.
	Use fhandler's unique id to create lf_id for BSD flock locks.
	Rely on node lock from inode_t::get.  Call del_lock_obj on removed
	locks here to allow explicit unlocking.  Delete node if no lock exists
	on the file anymore.
	(lf_setlock): Get file handle as additional parameter.  Handle the fact
	that lf_getblock now always opens the attached event object.  Reactivate
	erroneously applied patch which deactivates setting thread priority.
	Additionally handle blocking on BSD flock locks.
	(lf_clearlock): Get file handle as additional parameter.
	(lf_getlock): Close event handle opened by lf_getblock.
	(lf_getblock): Open potentially blocking event object here and check
	its signal state if it's a BSD flock lock.
	(lf_wakelock): Get file handle as additional parameter.
	* fork.cc (frok::child): Drop call to fixup_lockf_after_fork.
	* ntdll.h (struct _EVENT_BASIC_INFORMATION): Define.
	(enum _EVENT_INFORMATION_CLASS): Define.
	(NtQueryEvent): Declare.

	* fhandler.h (fhandler_base::fs_flags): Remove.
	(fhandler_base::set_fs_flags): Remove.
	(fhandler_base::get_fs_flags): Remove.
	* fhandler.cc (fhandler_base::write): Check for sparse file using
	pc.fs_flags().
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.

	The return of the volume serial number in fs_info.
	* fhandler.h (get_dev): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call to
	NtQueryVolumeInformationFile(FileFsVolumeInformation).  Just use
	get_dev() method.
	* fhandler_fifo.cc (fhandler_fifo::open) Use device ID and inode number
	to generate fifo name.
	* path.h (fs_info::sernum): New member.
	(fs_info::serial_number): New method.
	(path_conv::fs_serial_number): New method.
	* path.cc (fs_info::update): Fetch volume serial number and store in
	sernum.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007 Red Hat, Inc.
@


1.24
log
@	* fhandler_fifo.cc (fhandler_fifo::open): Use MAX_NAME for pipe name
	buffer size.
	(fhandler_fifo::fstatvfs): Use same technique as in fhandler_socket.
	* fhandler_proc.cc (format_proc_partitions): Use NAME_MAX+1 for
	device name buffer size.  Use MAX_PATH for device path buffer size.
@
text
@d71 3
a73 3
  /* Generate a semi-unique name to associate with this fifo.
     FIXME: Probably should use "inode" and "dev" from stat for this. */
  __small_sprintf (npname, "\\\\.\\pipe\\__cygfifo__%lx", get_namehash ());
@


1.23
log
@* cygtls.h (_cygtls::inside_kernel): Move function declaration into _cygtls
class.
* exceptions.cc (_cygtls::inside_kernel): Move function definition into _cygtls
class.
* fhandler.cc (fhandler_base::wait_overlapped): Make return tri-state to detect
when there is a EINTR situation.  Add a pointer to a length parameter.  Move
GetOverlappedResult into this function.
(fhandler_base::read_overlapped): Accommodate above changes and loop if we
receive a restartable signal.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::wait_overlapped): Reflect above changes.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
@
text
@d68 1
a68 1
  char npname[CYG_MAX_PATH];
d167 3
a169 10
  /* Call statvfs on parent dir. */
  char *c, dir[CYG_MAX_PATH];
  strcpy (dir, get_name ());
  if ((c = strrchr (dir, '/')))
    {
      *c = '\0';
      return statvfs (dir, sfs);
    }
  set_errno (EBADF);
  return -1;
@


1.22
log
@Preliminary change to make fifos/pipes interruptible and fifos reliable.
* dtable.cc (dtable::find_fifo): Eliminate definition.
* dtable.h (dtable::find_fifo): Ditto for declaration.
* fhandler.cc (fhandler_base::raw_read): Remove pipe-specific stuff.
(fhandler_base::fhandler_base): Ditto.
(fhandler_base::close): Handle overlapped I/O structure if appropriate.
(fhandler_base::dup): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::setup_overlapped): Define new function.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::get_overlapped): Declare new function.
(fhandler_base::setup_overlapped): Ditto.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
(fhandler_base::get_guard): Eliminate.
(fhandler_pipe::*): Rework to eliminate most Win9x related cruft, removing many
variables and defining a new overlapped capability.
(fhandler_fifo::*): Ditto.
(fifo_state): Declare new enum.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove old Win9x stuff.
Initialize overlapped handle to NULL.
(fhandler_fifo::set_use): Eliminate.
(fhandler_fifo::open_nonserver): Define.
(fhandler_fifo::open): Rework to use named pipes and overlapped I/O.
(fhandler_fifo::wait): Define new function to wait for named pipe connection.
(fhandler_fifo::read): Rework to use wait() and new overlapped I/O
functionality.
(fhandler_fifo::write): Ditto.
(fhandler_fifo::dup): Eliminate.
* pinfo.cc (commune_process): Remove fifo handling.
(_pinfo::commune_request): Ditto.
* pinfo.h (picom): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Remove Win9x stuff.  Initialize
overlapped handle to NULL.
(fhandler_pipe::open): Eliminate Win9x stuff.
(fhandler_pipe::set_close_on_exec): Eliminate.
(read_pipe): Eliminate.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::fixup_after_exec): Ditto.
(fhandler_pipe::fixup_in_child): Ditto.
(fhandler_pipe::read): Rework to use overlapped I/O.
(fhandler_pipe::write): New function using overlapped I/O.
(fhandler_pipe::dup): Rework to eliminate Win9x stuff.
(fhandler_pipe::create_selectable): Rework to eliminate Win9x and use
overlapped I/O.
* select.cc (peek_pipe): Rework to eliminate Win9x stuff and use overlapped
I/O.
(fhandler_base::ready_for_read): Ditto.
@
text
@d142 1
a142 1
      return wait_overlapped (res, iswrite);
@


1.21
log
@	* cygheap.cc (cygheap_init): Fix formatting.  Remove comment.  Set
	shared_prefix depending only on terminal service capability.
	* dcrt0.cc (dll_crt0_1): Don't call set_cygwin_privileges here.
	* fhandler_fifo.cc (fhandler_fifo::open): Create the mutex as global
	object.
	* posix_ipc.cc (ipc_mutex_init): Use cygheap->shared_prefix.
	(ipc_cond_init): Ditto.
	* sec_helper.cc (privilege_name): Make static.  Use LookupPrivilegeName
	directly to be independent of the state of cygheap.
	(set_privilege): Take a LUID as parameter instead of an index value.
	Only print debug output in case of failure.
	(set_cygwin_privileges): Add comment.  Use LookupPrivilegeValue to
	get privilege LUIDs.
	(init_global_security): Call set_cygwin_privileges here.
	* security.h (privilege_name): Drop declaration.
	(set_privilege): Declare according to above change.
	(set_process_privilege): Call privilege_luid to get LUID.
	(_push_thread_privilege): Ditto.
	* shared.cc (open_shared): Add comment.  On systems supporting the
	SeCreateGlobalPrivilege, try to create/open global shared memory first.
	Fall back to local shared memory if that fails.
	* thread.cc (semaphore::semaphore): Use cygheap->shared_prefix.
	* wincap.h (wincapc::has_create_global_privilege): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d25 2
d28 2
a29 3
fhandler_fifo::fhandler_fifo ()
  : fhandler_pipe (), output_handle (NULL),
    read_use (0), write_use (0)
d31 2
d35 3
a37 2
void
fhandler_fifo::set_use (int incr)
d39 5
a43 9
  long oread_use = read_use;

  if (get_flags () & (O_WRONLY | O_APPEND))
    write_use += incr;
  else if (get_flags () & O_RDWR)
    {
      write_use += incr;
      read_use += incr;
    }
d45 2
a46 5
    read_use += incr;

  if (incr >= 0)
    return;
  if (read_use <= 0 && oread_use != read_use)
d48 7
a54 2
      HANDLE h = get_handle ();
      if (h)
d56 2
a57 2
	  set_io_handle (NULL);
	  CloseHandle (h);
d62 1
a62 10
int
fhandler_fifo::close ()
{
  fhandler_pipe::close ();
  if (get_output_handle ())
    CloseHandle (get_output_handle ());
  if (!hExeced)
    set_use (-1);
  return 0;
}
a63 20
#define DUMMY_O_RDONLY 4

void
fhandler_fifo::close_one_end ()
{
  int testflags = (get_flags () & (O_RDWR | O_WRONLY | O_APPEND)) ?: DUMMY_O_RDONLY;
  static int flagtypes[] = {DUMMY_O_RDONLY | O_RDWR, O_WRONLY | O_APPEND | O_RDWR};
  HANDLE *handles[2] = {&(get_handle ()), &(get_output_handle ())};
  for (int i = 0; i < 2; i++)
    if (!(testflags & flagtypes[i]))
      {
	CloseHandle (*handles[i]);
	*handles[i] = NULL;
      }
    else if (i == 0 && !read_state)
      {
	create_read_state (2);
	need_fork_fixup (true);
      }
}
d65 1
a65 1
fhandler_fifo::open_not_mine (int flags)
d67 15
a81 2
  winpids pids ((DWORD) 0);
  int res = 0;
d83 1
a83 1
  for (unsigned i = 0; i < pids.npids; i++)
d85 32
a116 3
      _pinfo *p = pids[i];
      commune_result r;
      if (p->pid != myself->pid)
d118 2
a119 5
	  r = p->commune_request (PICOM_FIFO, get_win32_name ());
	  if (r.handles[0] == NULL)
	    continue;		// process doesn't own fifo
	  debug_printf ("pid %d, handles[0] %p, handles[1] %p", p->pid,
			r.handles[0], r.handles[1]);
d123 3
a125 17
	  /* FIXME: racy? */
	  fhandler_fifo *fh = cygheap->fdtab.find_fifo (get_win32_name ());
	  if (!fh)
	    continue;
	  if (!DuplicateHandle (hMainProc, fh->get_handle (), hMainProc,
				&r.handles[0], 0, false, DUPLICATE_SAME_ACCESS))
	    {
	      __seterrno ();
	      goto out;
	    }
	  if (!DuplicateHandle (hMainProc, fh->get_output_handle (), hMainProc,
				&r.handles[1], 0, false, DUPLICATE_SAME_ACCESS))
	    {
	      CloseHandle (r.handles[0]);
	      __seterrno ();
	      goto out;
	    }
a126 7

      set_io_handle (r.handles[0]);
      set_output_handle (r.handles[1]);
      set_flags (flags);
      close_one_end ();
      res = 1;
      goto out;
d129 1
a129 4
  set_errno (EAGAIN);

out:
  debug_printf ("res %d", res);
d133 2
a134 4
#define FIFO_PREFIX "_cygfifo_"

int
fhandler_fifo::open (int flags, mode_t)
d136 1
a136 19
  int res = 1;
  char mutex[CYG_MAX_PATH];
  char *emutex = mutex + CYG_MAX_PATH;
  char *p, *p1;
  DWORD resw;

  /* Generate a semi-unique name to associate with this fifo but try to ensure
     that it is no larger than CYG_MAX_PATH */
  strcpy (mutex, cygheap->shared_prefix);
  for (p = mutex + strlen (mutex), p1 = strchr (get_name (), '\0');
       --p1 >= get_name () && p < emutex ; p++)
    *p = (*p1 == '/') ? '_' : *p1;
  strncpy (p, FIFO_PREFIX, emutex - p);
  mutex[CYG_MAX_PATH - 1] = '\0';

  /* Create a mutex lock access to this fifo to prevent a race by two processes
     trying to figure out if they own the fifo or if they should create it. */
  HANDLE h = CreateMutex (&sec_none_nih, false, mutex);
  if (!h)
d138 7
a144 4
      __seterrno ();
      system_printf ("couldn't open fifo mutex '%s', %E", mutex);
      res = 0;
      goto out;
d146 2
d149 5
a153 25
  lock_process::locker.release ();	/* Since we may be a while, release the
					   process lock that is held when we
					   open an fd. */
  /* FIXME? Need to wait for signal here?
     This shouldn't block for long, but... */
  resw = WaitForSingleObject (h, INFINITE);
  lock_process::locker.acquire ();	/* Restore the lock */
  if (resw != WAIT_OBJECT_0 && resw != WAIT_ABANDONED_0)
    {
      __seterrno ();
      system_printf ("Wait for fifo mutex '%s' failed, %E", mutex);
      goto out;
    }

  set_io_handle (NULL);
  set_output_handle (NULL);
  if (open_not_mine (flags))
    goto out;

  fhandler_pipe *fhs[2];
  if (create (fhs, 1, flags, true))
    {
      __seterrno ();
      res = 0;
    }
d155 1
a155 20
    {
      set_flags (flags);
      set_io_handle (fhs[0]->get_handle ());
      set_output_handle (fhs[1]->get_handle ());
      guard = fhs[0]->guard;
      read_state = fhs[0]->read_state;
      delete (fhs[0]);
      delete (fhs[1]);
      set_use (1);
      need_fork_fixup (true);
    }

out:
  if (h)
    {
      ReleaseMutex (h);
      CloseHandle (h);
    }
  debug_printf ("returning %d, errno %d", res, get_errno ());
  return res;
d159 1
a159 1
fhandler_fifo::dup (fhandler_base *child)
d161 1
a161 15
  int res = fhandler_pipe::dup (child);
  if (!res)
    {
      fhandler_fifo *ff = (fhandler_fifo *) child;
      if (get_output_handle ()
	  && !DuplicateHandle (hMainProc, get_output_handle (), hMainProc,
			       &ff->get_output_handle (), false, true,
			       DUPLICATE_SAME_ACCESS))
	{
	  __seterrno ();
	  child->close ();
	  res = -1;
	}
    }
  return res;
@


1.20
log
@	* fhandler.cc(fhandler_base::open): Open with READ_CONTROL only in
	case of query_open flag set to query_read_control.  Add case for
	new query_read_attributes flag.
	(fhandler_base::fstatvfs): New method.
	* fhandler.h (enum query_state): Add query_read_attributes flag.
	(class fhandler_base): Declare new virtual fstatvfs method.
	(class fhandler_socket): Ditto.
	(class fhandler_pipe): Ditto.
	(class fhandler_fifo): Ditto.
	(class fhandler_disk_file): Ditto.
	(class fhandler_virtual): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Open with
	query_read_attributes instead of query_read_control.
	(fhandler_disk_file::fstatvfs): New method.
	(fhandler_disk_file::facl): Open with query_read_attributes instead of
	query_read_control.
	* fhandler_fifo.cc (fhandler_fifo::fstatvfs): New method.
	* fhandler_socket.cc (fhandler_socket::fstatvfs): New method.
	(fhandler_socket::fchmod): Return with EBADF in the default case.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::fstatvfs): Ditto.
	* ntdll.h (struct _FILE_FS_ATTRIBUTE_INFORMATION): Define.
	(struct _FILE_FS_FULL_SIZE_INFORMATION): Define.
	* pipe.cc (fhandler_pipe::fstatvfs): New method.
	* syscalls.cc (fstatvfs): Just call the fhandler's fstatvfs.
	(statvfs): Ditto.
	(fstatfs): Call fstatvfs.
	(statfs): Drop EFAULT handling.
@
text
@d158 2
a159 1
  for (p = mutex, p1 = strchr (get_name (), '\0');
@


1.19
log
@	* fhandler.h (class fhandler_pipe): Remove members writepipe_exists,
	orig_pid and id.  Make hit_eof inline.
	* fhandler_fifo.cc (fhandler_fifo::open): Drop handling of
	writepipe_exists, orig_pid and id.
	* pipe.cc: Ditto throughout.
	(pipecount): Remove.
	(pipeid_fmt): Remove.
	(fhandler_pipe::hit_eof): Simplify.  Move to fhandler.h.
	(fhandler_pipe::dup): Drop leave label.
	(fhandler_pipe::create): Drop has_unreliable_pipes case.
	* wincap.cc: Remove has_unreliable_pipes throughout.
	* wincap.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006 Red Hat, Inc.
d15 1
d242 15
@


1.18
log
@GCC 4.1 fixes.
* cygheap.h (cygheap_user): Remove unneeded class names from function
declaration.
* fhandler.h (fhandler_base): Ditto.
(fhandler_dev_floppy): Ditto.
(fhandler_console): Ditto.
* wininfo.h (wininfo): Ditto.
* exceptions.cc (sigpacket::process): Avoid compiler errors about gotos and
initialization.
* fhandler_fifo.cc (fhandler_fifo::open): Ditto.
* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Ditto.
* mmap.cc (mmap64): Ditto.
* pipe.cc (fhandler_pipe::open): Ditto.
* spawn.cc (spawn_guts): Ditto.
* sec_helper.cc: Fix some comments.
(get_null_sd): Move file-scope static to only function where it is used.
@
text
@a205 3
      writepipe_exists = fhs[1]->writepipe_exists;
      orig_pid = fhs[0]->orig_pid;
      id = fhs[0]->id;
@


1.17
log
@* fhandler_fifo.cc (fhandler_fifo::open): Release process lock and grab a
system-wide mutex to prevent a deadlock and a race.
* sync.h (lock_process): Make fhandler_fifo a friend.
* smallprint.c (__small_vsprintf): Cosmetic change.
@
text
@d153 1
d179 1
a179 1
  DWORD resw = WaitForSingleObject (h, INFINITE);
@


1.17.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@a152 1
  DWORD resw;
d178 1
a178 1
  resw = WaitForSingleObject (h, INFINITE);
@


1.16
log
@Change name from commune_recv to commune_process throughout.  Change name from
commune_send to commune_request throughout.
* pinfo.h (PICOM_EXTRASTR): New flag.
(PICOM_FIFO): Define with new flag.
(_pinfo::hello_pid): Delete.
(_pinfo::tothem): Delete.
(_pinfo::fromthem): Delete.
(_pinfo::commune_process): Rename from commune_recv.  Add a siginfo_t argument
to declaration.
(_pinfo::commune_request): Rename from commune_send.  Change DWORD to
__uint32_t in declaration.
* pinfo.cc (_pinfo::commune_process): Rename from commune_recv.  Add siginfo_t
argument.  Use information from argument rather than reading from another pipe.
Synchronize with other process's commune event.
(_pinfo::commune_request): Rename from commune_send.  Change DWORD to __uint32
in argument.  Fill out information in new siginfo_t element and rely on
extended operation of sig_send rather than trying to deal with synchronization
issues here.  Use process handle and read pipe information filled out by
sig_send to gather information from the other process.
* sigproc.cc (sig_send): Take special action if "communing" to ensure
synchronization with the other process and to return information about the
other process to the caller.
(talktome): Accept a siginfo_t and handle arguments.  Read additional
information from the signal pipe when _si_commune._si_code has the
PICOM_EXTRASTR flag set.
(wait_sig): Pass the transmitted siginfo_t struct and the pipe handle to
talktome.  Close pipe read handle as soon as possible after we detect that
we're exiting.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005 Red Hat, Inc.
d144 2
d150 36
d215 5
@


1.15
log
@	Revert erroneous checkin.
@
text
@d102 1
a102 1
	  r = p->commune_send (PICOM_FIFO, get_win32_name ());
@


1.14
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d182 1
a182 1
fhandler_fifo::dup (fhandler_base *child, HANDLE from_proc)
d184 1
a184 1
  int res = fhandler_pipe::dup (child, from_proc);
d189 1
a189 1
	  && !DuplicateHandle (from_proc, get_output_handle (), hMainProc,
@


1.13
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d182 1
a182 1
fhandler_fifo::dup (fhandler_base *child)
d184 1
a184 1
  int res = fhandler_pipe::dup (child);
d189 1
a189 1
	  && !DuplicateHandle (hMainProc, get_output_handle (), hMainProc,
@


1.12
log
@* cygthread.cc (cygthread::detach): Make error message a little more detailed.
* fhandler.cc (fhandler_base::raw_read): Ditto for debug message.
* dcrt0.cc (do_exit): Add some more synchronization tests.
* fhandler_fifo.cc (fhandler_fifo::dup): Don't duplicate a nonexistent handle.
Use derived return value rather than always retuning 0.
* fhandler_netdrive.cc (fhandler_netdrive::exists): Wnet -> WNet.
* winsup.h (exit_states): Add a couple of new exit states.
@
text
@d65 2
a66 1
  set_use (-1);
@


1.11
log
@* external.cc: Move pids declaration to file scope and use less enthusiastic
constructor.
* pinfo.h (winpids::winpids): Remove default setting.
* fhandler_fifo.cc (fhandler_fifo::open_not_mine): Accommodate removal of
default setting.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
@
text
@d187 4
a190 3
      if (!DuplicateHandle (hMainProc, get_output_handle (), hMainProc,
			    &ff->get_output_handle (), false, true,
			    DUPLICATE_SAME_ACCESS))
d197 1
a197 1
  return 0;
@


1.10
log
@* fhandler.cc (fhandler_base::read): Remove unused signal state tweaks.
* fhandler.h (fhandler_pipe::create_selectable): Declare.
(fhandler_fifo::close_one_end): Declare.
* fhandler_fifo.cc (fhandler_fifo::close_one_end): Define.
(fhandler_fifo::open_not_mine): Use close_one_end to close appropriate end of
pipe.
* pinfo.cc (_pinfo::commune_recv): Ditto.
* pipe.cc (fhandler_pipe::create_selectable): Rename from
create_selectable_pipe.  Reorganize.
(fhandler_pipe::create): Use create_selectable.
@
text
@d92 1
a92 1
  winpids pids;
@


1.9
log
@Actually check in files.
@
text
@d70 19
a92 2
  static int flagtypes[] = {DUMMY_O_RDONLY | O_RDWR, O_WRONLY | O_APPEND | O_RDWR};
  HANDLE *usehandles[2] = {&(get_handle ()), &(get_output_handle ())};
a93 1
  int testflags = (flags & (O_RDWR | O_WRONLY | O_APPEND)) ?: DUMMY_O_RDONLY;
d128 4
a131 14
      for (int i = 0; i < 2; i++)
	if (!(testflags & flagtypes[i]))
	    CloseHandle (r.handles[i]);
	else
	  {
	    *usehandles[i] = r.handles[i];

	    if (i == 0)
	      {
		read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
		need_fork_fixup (true);
	      }
	  }

a132 1
      set_flags (flags);
@


1.8
log
@* fhandler.cc (fhandler::dup): Duplicate flags, too.
* fhandler.h (fhandler_fifo::owner): Eliminate.
* fhandler_disk_file.cc (fhandler_base::fstat_fs): Handle on-disk devices
better.
(fhandler_base::fstat_helper): Ditto.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Don't initialize obsolete
"owner".
(fhandler_fifo::open_not_mine): Add some debugging.  Duplicate correct handle
when we own it.
(fhandler_fifo::open): Set flags from input, not from first pipe.  Flag that
fork fixup is needed.
(fhandler_fifo::dup): Set errno correctly when DuplicateHandle fails.
* pinfo.cc (commune_send): Add debugging for fifo.
* cygwin/version.h: Bump API minor version to 127 to reflect exporting of
sigrelese.
@
text
@d103 1
a103 1
	  if (!DuplicateHandle (hMainProc, fh->get_handle (), hMainProc,
d149 1
a149 1
  if (create (fhs, 0, flags, true))
d156 1
a156 1
      set_flags (fhs[0]->get_flags ());
@


1.7
log
@* dtable.cc (dtable::find_fifo): Release lock after fifo found (still racy).
* fhandler.h (fhandler_fifo::get_io_handle): New fifo-specific method.
* fhandler_fifo.cc (fhandler_fifo::close): Close output_handle only if it is
open.
(fhandler_fifo::open_not_mine): Reorganize slightly.  Don't call _pinfo methods
when the fifo is owned by me or suffer dtable lock_cs deadlock.
(fhandler_fifo::open): Call open_not_mine first, otherwise open myself
(racy).
* pinfo.cc (_pinfo::commune_recv): Duplicate fifo handles here in requesting
processes arena to avoid one potential race (of many).
(_pinfo::commune_send): Move all PICOM_FIFO code under one case statement.
* thread.cc (pthread::init_mainthread) Use existing hMainProc handle rather
than calling GetCurrentProcess.
@
text
@d1 1
a1 1
/* fhandler_fifo.cc.  See fhandler.h for a description of the fhandler classes.
d3 1
a3 1
   Copyright 2002, 2003, 2004 Red Hat, Inc.
d26 1
a26 1
  : fhandler_pipe (), output_handle (NULL), owner (NULL),
d88 2
d167 1
d176 1
a176 1
fhandler_fifo::dup (fhandler_base * child)
a181 1

d186 1
@


1.6
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d63 2
a64 1
  CloseHandle (get_output_handle ());
d76 2
a77 1
  int res;
d82 2
a83 2
      HANDLE hp = OpenProcess (PROCESS_DUP_HANDLE, false, p->dwProcessId);
      if (!hp)
d85 3
a87 2
	  __seterrno ();
	  goto err;
d89 1
a89 9

      HANDLE handles[2];
      commune_result r;
      r = p->commune_send (PICOM_FIFO, get_win32_name ());
      if (r.handles[0] == NULL)
	continue;		// process doesn't own fifo

      flags = (flags & (O_RDWR | O_WRONLY | O_APPEND)) ?: DUMMY_O_RDONLY;
      for (int i = 0; i < 2; i++)
d91 3
a93 1
	  if (!(flags & flagtypes[i]))
d95 2
a96 2
	   if (!DuplicateHandle (hp, r.handles[i], hMainProc, usehandles[i], 0,
				 false, DUPLICATE_SAME_ACCESS))
a97 1
	      debug_printf ("couldn't duplicate handle %d/%p, %E", i, handles[i]);
d99 1
a99 1
	      goto err;
d101 2
a102 2

	  if (i == 0)
d104 3
a106 2
	      read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
	      need_fork_fixup (true);
d109 14
a122 1
      CloseHandle (hp);
a130 4
err:
  res = 0;
  debug_printf ("failed");

d141 5
d148 18
a165 18
    goto errnout;

  set_flags (fhs[0]->get_flags ());
  set_io_handle (fhs[0]->get_handle ());
  set_output_handle (fhs[1]->get_handle ());
  guard = fhs[0]->guard;
  read_state = fhs[0]->read_state;
  writepipe_exists = fhs[1]->writepipe_exists;
  orig_pid = fhs[0]->orig_pid;
  id = fhs[0]->id;
  delete (fhs[0]);
  delete (fhs[1]);
  set_use (1);
  goto out;

errnout:
  __seterrno ();
  res = 0;
@


1.5
log
@* cygheap.cc (init_cheap): Add ability to specify minimal cygwin heap size when
debugging.
(_csbrk): Report error in allocation to stderr.
(ccalloc): Ditto.
* dtable.cc (dtable::find_fifo): Remove use of atoms.
* dtable.h (dtable::find_fifo): Ditto.
* fhandler.h (fhandler_fifo): Ditto.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Ditto.
(fhandler_fifo::set_use): Ditto.
(fhandler_fifo::open_not_mine): Ditto.
(fhandler_fifo::open): Ditto.
* pinfo.cc (_pinfo::commune_recv): Ditto.
(_pinfo::commune_send): Ditto.
@
text
@d109 1
a109 1
	      set_need_fork_fixup ();
@


1.4
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d26 1
a26 1
  : fhandler_pipe (), output_handle (NULL), owner (NULL), upand (0),
a47 5
  char buf[24];
  __small_sprintf (buf, "%x.%x", upand, myself->pid);
  ATOM ant = GlobalFindAtom (buf);
  if (!ant)
    return;
a55 1
      DeleteAtom (ant);
a71 1
  char buf[24];
a79 4
      __small_sprintf (buf, "%x.%x", upand, p->pid);
      if (!GlobalFindAtom (buf))
	continue;

d89 4
a92 1
      r = p->commune_send (PICOM_FIFO, upand);
a133 15
  char buf[24];

  upand = GlobalAddAtom (pc);
  __small_sprintf (buf, "%x.owner", upand);
  debug_printf ("mutex %s", buf);

  HANDLE h = CreateMutex (&sec_none, false, buf);
  if (!h)
    goto errnout;

  if (GetLastError () == ERROR_ALREADY_EXISTS)
    {
      CloseHandle (h);
      return open_not_mine (flags);
    }
d137 1
a137 4
    {
      CloseHandle (h);
      goto errout;
    }
a149 2
  __small_sprintf (buf, "%x.%x", upand, myself->pid);
  (void) GlobalAddAtom (buf);
a153 1
errout:
@


1.3
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d3 1
a3 1
   Copyright 2002, 2003 Red Hat, Inc.
@


1.2
log
@* syscalls.cc (system): Strip signal considerations from here so that they are
not inherited by a child process.
* spawn.cc (spawn_guts): Handle system() signal stuff here.
* winsup.h (_P_SYSTEM): Define.
@
text
@d3 1
a3 1
   Copyright 2002 Red Hat, Inc.
@


1.1
log
@file fhandler_fifo.cc was initially added on branch cgf-dev-branch.
@
text
@d1 207
@


1.1.2.1
log
@readd
@
text
@a0 185
/* fhandler_fifo.cc.  See fhandler.h for a description of the fhandler classes.

   Copyright 2002 Red Hat, Inc.

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */

#include "winsup.h"
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>

#include "cygerrno.h"
#include "perprocess.h"
#include "security.h"
#include "fhandler.h"
#include "path.h"
#include "dtable.h"
#include "cygheap.h"
#include "pinfo.h"

fhandler_fifo::fhandler_fifo ()
  : fhandler_pipe (), output_handle (NULL), owner (NULL), upand (0),
    read_use (0), write_use (0)
{
}

void
fhandler_fifo::set_use (int incr)
{
  long oread_use = read_use;

  if (get_flags () & (O_WRONLY | O_APPEND))
    write_use += incr;
  else if (get_flags () & O_RDWR)
    {
      write_use += incr;
      read_use += incr;
    }
  else
    read_use += incr;

  if (incr >= 0)
    return;
  char buf[24];
  __small_sprintf (buf, "%x.%x", upand, myself->pid);
  ATOM ant = GlobalFindAtom (buf);
  if (!ant)
    return;
  if (read_use <= 0 && oread_use != read_use)
    {
      HANDLE h = get_handle ();
      if (h)
	{
	  set_io_handle (NULL);
	  CloseHandle (h);
	}
      DeleteAtom (ant);
    }
}

int
fhandler_fifo::close ()
{
  fhandler_pipe::close ();
  CloseHandle (get_output_handle ());
  set_use (-1);
  return 0;
}

#define DUMMY_O_RDONLY 4
int
fhandler_fifo::open_not_mine (int flags)
{
  char buf[24];
  winpids pids;
  static int flagtypes[] = {DUMMY_O_RDONLY | O_RDWR, O_WRONLY | O_APPEND | O_RDWR};
  HANDLE *usehandles[2] = {&(get_handle ()), &(get_output_handle ())};
  int res;

  for (unsigned i = 0; i < pids.npids; i++)
    {
      _pinfo *p = pids[i];
      __small_sprintf (buf, "%x.%x", upand, p->pid);
      if (!GlobalFindAtom (buf))
	continue;

      HANDLE hp = OpenProcess (PROCESS_DUP_HANDLE, false, p->dwProcessId);
      if (!hp)
	{
	  __seterrno ();
	  goto err;
	}

      HANDLE handles[2];
      commune_result r;
      r = p->commune_send (PICOM_FIFO, upand);
      flags = (flags & (O_RDWR | O_WRONLY | O_APPEND)) ?: DUMMY_O_RDONLY;
      for (int i = 0; i < 2; i++)
	{
	  if (!(flags & flagtypes[i]))
	    continue;
	   if (!DuplicateHandle (hp, r.handles[i], hMainProc, usehandles[i], 0,
				 false, DUPLICATE_SAME_ACCESS))
	    {
	      debug_printf ("couldn't duplicate handle %d/%p, %E", i, handles[i]);
	      __seterrno ();
	      goto err;
	    }
        
	  if (i == 0)
	    read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
	}
      CloseHandle (hp);

      res = 1;
      set_flags (flags);
      goto out;
    }

  set_errno (EAGAIN);

err:
  res = 0;
  debug_printf ("failed");

out:
  debug_printf ("res %d", res);
  return res;
}

int
fhandler_fifo::open (path_conv *pc, int flags, mode_t)
{
  int res = 1;
  char buf[24];

  upand = GlobalAddAtom (*pc);
  __small_sprintf (buf, "%x.owner", upand);
  debug_printf ("mutex %s", buf);

  HANDLE h = CreateMutex (&sec_none, false, buf);
  if (!h)
    goto errnout;

  if (GetLastError () == ERROR_ALREADY_EXISTS)
    {
      CloseHandle (h);
      return open_not_mine (flags);
    }

  fhandler_pipe *fhs[2];
  if (create (fhs, 0, flags, true))
    {
      CloseHandle (h);
      goto errout;
    }

  set_flags (fhs[0]->get_flags ());
  set_io_handle (fhs[0]->get_handle ());
  set_output_handle (fhs[1]->get_handle ());
  guard = fhs[0]->guard;
  read_state = fhs[0]->read_state;
  writepipe_exists = fhs[1]->writepipe_exists;
  orig_pid = fhs[0]->orig_pid;
  id = fhs[0]->id;
  delete (fhs[0]);
  delete (fhs[1]);
  set_use (1);
  __small_sprintf (buf, "%x.%x", upand, myself->pid);
  (void) GlobalAddAtom (buf);
  goto out;

errnout:
  __seterrno ();
errout:
  res = 0;

out:
  debug_printf ("returning %d, errno %d", res, get_errno ());
  return res;
}
@


1.1.2.2
log
@merge from trunk
@
text
@d113 1
a113 1

@


1.1.2.3
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d19 1
a20 1
#include "fhandler.h"
d136 1
a136 1
fhandler_fifo::open (int flags, mode_t)
d141 1
a141 1
  upand = GlobalAddAtom (pc);
@


1.1.2.4
log
@merge from trunk
@
text
@d115 1
a115 4
	    {
	      read_state = CreateEvent (&sec_none_nih, FALSE, FALSE, NULL);
	      set_need_fork_fixup ();
	    }
a184 19
}

int
fhandler_fifo::dup (fhandler_base * child)
{
  int res = fhandler_pipe::dup (child);
  if (!res)
    {
      fhandler_fifo *ff = (fhandler_fifo *) child;

      if (!DuplicateHandle (hMainProc, get_output_handle (), hMainProc,
			    &ff->get_output_handle (), false, true,
			    DUPLICATE_SAME_ACCESS))
	{
	  child->close ();
	  res = -1;
	}
    }
  return 0;
@


