head	1.142;
access;
symbols
	cygwin-1_7_35-release:1.142
	cygwin-1_7_34-release:1.138
	cygwin-1_7_33-release:1.122.2.2
	cygwin-1_7_32-release:1.122.2.2
	cygwin-1_7_31-release:1.122.2.2
	cygwin-1_7_30-release:1.122.2.1
	cygwin-1_7_29-release:1.122.2.1
	cygwin-1_7_29-release-branchpoint:1.122.0.2
	cygwin-pre-user-db:1.122
	cygwin-1_7_28-release:1.122
	cygwin-1_7_27-release:1.122
	cygwin-1_7_26-release:1.122
	cygwin-1_7_25-release:1.122
	cygwin-1_7_24-release:1.122
	cygwin-1_7_23-release:1.122
	cygwin-1_7_22-release:1.122
	cygwin-1_7_21-release:1.122
	cygwin-1_7_20-release:1.122
	cygwin-1_7_19-release:1.122
	cygwin-64bit-postmerge:1.120
	cygwin-64bit-premerge-branch:1.119.0.2
	cygwin-64bit-premerge:1.119
	cygwin-1_7_18-release:1.119
	post-ptmalloc3:1.118.2.4
	pre-ptmalloc3:1.118.2.4
	cygwin-1_7_17-release:1.118
	cygwin-64bit-branch:1.118.0.2
	cygwin-1_7_16-release:1.118
	cygwin-1_7_15-release:1.118
	cygwin-1_7_14_2-release:1.118
	cygwin-1_7_14-release:1.118
	cygwin-1_7_12-release:1.118
	cygwin-1_7_11-release:1.118
	cygwin-1_7_10-release:1.118
	signal-rewrite:1.115.0.2
	pre-notty:1.115
	cygwin-1_7_9-release:1.113
	cv-post-1_7_9:1.113.0.6
	cygwin-1_7_8-release:1.113
	cygwin-1_7_7-release:1.113
	cygwin-1_7_5-release:1.113
	cygwin-1_7_4-release:1.113
	cygwin-1_7_3-release:1.113
	cygwin-1_7_2-release:1.113
	fifo_doover3:1.113.0.4
	cygwin-1_7_1-release:1.113
	prefifo:1.113
	cv-branch-2:1.113.0.2
	pre-ripout-set_console_state_for_spawn:1.108
	EOL_registry_mounts:1.104
	preoverlapped:1.103
	drop_9x_support_start:1.102
	cr-0x5f1:1.99.0.8
	cv-branch:1.99.0.6
	pre-ptymaster-archetype:1.99
	cr-0x3b58:1.99.0.4
	cr-0x5ef:1.99.0.2
	after-mmap-privanon-noreserve:1.99
	after-mmap-revamp:1.99
	before-mmap-revamp:1.99
	cgf-more-exit-sync:1.99
	post_wait_sig_exit:1.99
	pre_wait_sig_exit:1.98
	reparent-point:1.89
	noreparent:1.89.0.2
	cr-0x5e6:1.88.0.2
	cr-0x9e:1.86.0.6
	cr-0x9d:1.86.0.4
	cgf-deleteme:1.86.0.2
	pre-sigrewrite:1.84
	corinna-01:1.84
	cr-0x9c:1.83.0.6
	cr-0x9b:1.83.0.4
	cr-0x99:1.83
	Z-emcb-cygwin_daemon:1.83.0.2
	w32api-2_2:1.77
	mingw-runtime-2_4:1.77
	pre-cgf-merge:1.83
	cgf-dev-branch:1.61.0.4
	predaemon:1.42
	cygwin_daemon_merge_HEAD:1.42
	pregp02r1:1.42.0.2
	cygnus_cvs_20020108_pre:1.37
	Z-cygwin_daemon_merge-new_HEAD:1.54
	Z-cygwin_daemon_merge_HEAD:1.54
	cygwin_daemon:1.32.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.142
date	2015.02.24.20.52.57;	author corinna;	state Exp;
branches;
next	1.141;

1.141
date	2015.02.23.20.51.11;	author corinna;	state Exp;
branches;
next	1.140;

1.140
date	2015.02.23.15.46.10;	author corinna;	state Exp;
branches;
next	1.139;

1.139
date	2015.02.20.15.13.46;	author corinna;	state Exp;
branches;
next	1.138;

1.138
date	2014.06.16.09.12.29;	author corinna;	state Exp;
branches;
next	1.137;

1.137
date	2014.05.08.08.44.07;	author corinna;	state Exp;
branches;
next	1.136;

1.136
date	2014.05.07.11.00.00;	author corinna;	state Exp;
branches;
next	1.135;

1.135
date	2014.05.06.12.28.33;	author corinna;	state Exp;
branches;
next	1.134;

1.134
date	2014.05.06.12.02.47;	author corinna;	state Exp;
branches;
next	1.133;

1.133
date	2014.03.12.17.36.56;	author corinna;	state Exp;
branches;
next	1.132;

1.132
date	2014.03.07.20.38.48;	author corinna;	state Exp;
branches;
next	1.131;

1.131
date	2014.02.28.11.37.02;	author corinna;	state Exp;
branches;
next	1.130;

1.130
date	2014.02.27.12.57.26;	author corinna;	state Exp;
branches;
next	1.129;

1.129
date	2014.02.22.19.38.12;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2014.02.21.10.01.00;	author corinna;	state Exp;
branches;
next	1.127;

1.127
date	2014.02.20.15.46.48;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2014.02.20.13.55.57;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2014.02.18.19.39.48;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2014.02.17.15.36.32;	author corinna;	state Exp;
branches;
next	1.123;

1.123
date	2014.02.09.19.44.54;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2013.05.14.09.07.30;	author corinna;	state Exp;
branches
	1.122.2.1;
next	1.121;

1.121
date	2013.05.14.08.50.37;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.119;

1.119
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2012.02.03.12.26.08;	author corinna;	state Exp;
branches
	1.118.2.1;
next	1.117;

1.117
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2011.10.28.09.26.42;	author corinna;	state Exp;
branches;
next	1.115;

1.115
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2011.04.29.07.34.04;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2009.01.26.13.20.46;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2008.10.09.11.52.54;	author corinna;	state Exp;
branches;
next	1.111;

1.111
date	2008.07.24.18.25.49;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2008.07.09.11.58.38;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2008.07.09.09.14.12;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2008.05.22.21.14.30;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2008.05.22.21.03.54;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2008.04.16.10.02.05;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2007.07.16.20.01.15;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2007.02.23.15.15.49;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2006.12.12.16.27.32;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2006.11.27.12.59.58;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2006.08.31.15.57.56;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2005.09.14.14.27.55;	author cgf;	state Exp;
branches
	1.99.8.1;
next	1.98;

1.98
date	2005.04.18.16.03.08;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2005.04.16.15.21.46;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2005.04.06.12.35.51;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2005.04.05.06.04.56;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2005.04.05.04.48.02;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2005.04.05.04.30.58;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2005.04.03.13.06.42;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2005.02.20.04.25.32;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2005.01.12.22.40.45;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2004.05.17.16.14.01;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2004.05.17.16.06.00;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2003.08.17.17.50.40;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2003.08.08.19.28.34;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2003.06.30.13.07.36;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2003.04.17.20.05.15;	author tpfaff;	state Exp;
branches;
next	1.78;

1.78
date	2003.02.18.10.09.37;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2003.02.06.14.01.53;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2003.02.04.17.53.08;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2003.02.04.14.58.04;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2003.02.01.18.41.29;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2003.01.27.00.16.01;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2003.01.26.06.42.40;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2003.01.26.06.02.34;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2003.01.26.05.55.29;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2003.01.26.05.38.37;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2003.01.25.16.34.32;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2003.01.24.03.53.46;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2003.01.21.06.58.11;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2003.01.20.02.57.54;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2003.01.17.18.05.32;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2003.01.17.05.41.15;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2003.01.17.05.18.29;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2002.12.10.12.43.49;	author corinna;	state Exp;
branches
	1.61.4.1;
next	1.60;

1.60
date	2002.11.20.17.10.05;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2002.11.16.03.50.56;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2002.11.14.19.19.39;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2002.11.14.10.28.55;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2002.09.30.15.17.44;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2002.09.25.12.24.23;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2002.09.11.10.37.11;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2002.08.02.11.00.18;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2002.07.29.12.51.52;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.19.15.27.24;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.05.15.43.49;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.05.11.56.56;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.05.11.10.15;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.28.14.10.51;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.17.04.59.54;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.14.21.20.06;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2002.01.21.20.51.30;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.15.23.39.32;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.13.01.35.15;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.28.07.23.18;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2001.09.28.07.01.22;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.14.03.01.47;	author cgf;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.09.16.52.37;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.07.08.56.22;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.16.13.22.29;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.15.22.40.07;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.19.05.29.00;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.15.19.23.31;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.30.18.21.48;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.25.09.43.25;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.20.14.30.22;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.20.13.02.32;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.18.14.52.07;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.16.14.02.42;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.15.00.13.08;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.04.17.52.42;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.29.18.59.26;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.01.17.30.35;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.25.03.48.10;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.03.18.08.13;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.122.2.1
date	2014.02.23.04.42.49;	author cgf;	state Exp;
branches;
next	1.122.2.2;

1.122.2.2
date	2014.07.16.09.54.56;	author corinna;	state Exp;
branches;
next	;

1.118.2.1
date	2012.08.13.20.04.34;	author corinna;	state Exp;
branches;
next	1.118.2.2;

1.118.2.2
date	2012.12.10.11.45.49;	author corinna;	state Exp;
branches;
next	1.118.2.3;

1.118.2.3
date	2013.01.21.13.52.06;	author corinna;	state Exp;
branches;
next	1.118.2.4;

1.118.2.4
date	2013.02.09.20.38.00;	author corinna;	state Exp;
branches;
next	;

1.99.8.1
date	2006.08.31.15.58.13;	author corinna;	state Exp;
branches;
next	;

1.61.4.1
date	2003.01.24.04.04.20;	author cgf;	state Exp;
branches;
next	1.61.4.2;

1.61.4.2
date	2003.01.25.16.37.00;	author cgf;	state Exp;
branches;
next	1.61.4.3;

1.61.4.3
date	2003.01.26.05.39.17;	author cgf;	state Exp;
branches;
next	1.61.4.4;

1.61.4.4
date	2003.01.26.06.43.32;	author cgf;	state Exp;
branches;
next	1.61.4.5;

1.61.4.5
date	2003.01.27.00.16.44;	author cgf;	state Exp;
branches;
next	1.61.4.6;

1.61.4.6
date	2003.02.01.18.42.23;	author cgf;	state Exp;
branches;
next	1.61.4.7;

1.61.4.7
date	2003.02.05.14.25.09;	author cgf;	state Exp;
branches;
next	1.61.4.8;

1.61.4.8
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.61.4.9;

1.61.4.9
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.61.4.10;

1.61.4.10
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.61.4.11;

1.61.4.11
date	2003.05.10.17.20.53;	author cgf;	state Exp;
branches;
next	1.61.4.12;

1.61.4.12
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.32.2.1
date	2001.09.29.09.35.31;	author rbcollins;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2001.10.02.12.09.54;	author rbcollins;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2002.01.22.04.52.40;	author rbcollins;	state Exp;
branches;
next	1.32.2.5;

1.32.2.5
date	2002.02.28.12.53.25;	author rbcollins;	state Exp;
branches;
next	1.32.2.6;

1.32.2.6
date	2002.06.13.14.34.06;	author rbcollins;	state Exp;
branches;
next	1.32.2.7;

1.32.2.7
date	2002.06.19.20.58.58;	author scottc;	state Exp;
branches;
next	1.32.2.8;

1.32.2.8
date	2002.07.30.13.31.46;	author scottc;	state Exp;
branches;
next	1.32.2.9;

1.32.2.9
date	2002.08.06.07.14.59;	author scottc;	state Exp;
branches;
next	1.32.2.10;

1.32.2.10
date	2002.09.12.10.07.50;	author scottc;	state Exp;
branches;
next	1.32.2.11;

1.32.2.11
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	1.32.2.12;

1.32.2.12
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.142
log
@	* ldap.h: Remove index macros.
	(class cyg_ldap): Remove members srch_msg and srch_entry.
	(cyg_ldap::get_string_attribute): Remove private method taking index
	argument.
	(cyg_ldap::get_num_attribute): Ditto.  Add method taking attribute name.
	(cyg_ldap::get_primary_gid): Adjust to aforementioned change.
	(cyg_ldap::get_unix_uid): Ditto.
	(cyg_ldap::get_unix_gid): Ditto.
	* ldap.cc: Throughout, use msg and entry in place of srch_msg and
	srch_entry.
	(std_user_attr): Add sAMAccountName and objectSid.
	(group_attr): Ditto.
	(cyg_ldap::close): Drop handling of srch_msg and srch_entry.
	(cyg_ldap::get_string_attribute): Move earlier in file.
	(cyg_ldap::get_num_attribute): Ditto.
	(cyg_ldap::enumerate_ad_accounts): Add comments for clarity.
	Use group_attr or user_attr rather than sid_attr to fetch all desired
	attributes for an account right away.
	(cyg_ldap::next_account): Store found SID in last_fetched_sid to
	skip calls to fetch_ad_account from fetch_account_from_windows.
	(cyg_ldap::get_string_attribute): Remove method taking index argument.
	(cyg_ldap::get_num_attribute): Ditto.
	* pwdgrp.h (class pg_ent): Fix formatting.  Add member dom.
	* passwd.cc (pg_ent::enumerate_ad): Store current flat domain name
	in dom.  Construct fetch_acc_t argument from LDAP attributes and
	call fetch_account_from_windows with that.
	* userinfo.h (enum fetch_user_arg_type_t): Rename FULL_grp_arg to
	FULL_acc_arg.  Change throughout.
	(struct fetch_acc_t): Rename from fetch_full_grp_t.  Change throughout.
	(struct fetch_user_arg_t): Rename full_grp to full_acc.  Change
	throughout.
@
text
@/* grp.cc

   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

   Original stubs by Jason Molenda of Cygnus Support, crash@@cygnus.com
   First implementation by Gunther Ebert, gunther.ebert@@ixos-leipzig.de

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <lm.h>
#include <ntsecapi.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "cygerrno.h"
#include "pinfo.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "ntdll.h"
#include "miscfuncs.h"
#include "ldap.h"
#include "tls_pbuf.h"

static char * NO_COPY_RO null_ptr;

bool
pwdgrp::parse_group ()
{
  pg_grp &grp = group ()[curr_lines];
  grp.g.gr_name = next_str (':');
  if (!*grp.g.gr_name)
    return false;
  grp.g.gr_passwd = next_str (':');
  /* Note that lptr points to the first byte of the gr_gid field.
     We deliberately ignore the gr_gid and gr_mem entries when copying
     the buffer content since they are not referenced anymore. */
  grp.len = lptr - grp.g.gr_name;
  if (!next_num (grp.g.gr_gid))
    return false;
  /* Don't generate gr_mem entries. */
  grp.g.gr_mem = &null_ptr;
  grp.sid.getfromgr (&grp.g);
  return true;
}

muto NO_COPY pwdgrp::pglock;

void
pwdgrp::init_grp ()
{
  pwdgrp_buf_elem_size = sizeof (pg_grp);
  parse = &pwdgrp::parse_group;
}

struct group *
pwdgrp::find_group (cygpsid &sid)
{
  for (ULONG i = 0; i < curr_lines; i++)
    if (sid == group ()[i].sid)
      return &group ()[i].g;
  return NULL;
}

struct group *
pwdgrp::find_group (const char *name)
{
  for (ULONG i = 0; i < curr_lines; i++)
    if (strcasematch (group ()[i].g.gr_name, name))
      return &group ()[i].g;
  return NULL;
}

struct group *
pwdgrp::find_group (gid_t gid)
{
  for (ULONG i = 0; i < curr_lines; i++)
    if (gid == group ()[i].g.gr_gid)
      return &group ()[i].g;
  return NULL;
}

struct group *
internal_getgrsid (cygpsid &sid, cyg_ldap *pldap)
{
  struct group *ret;

  cygheap->pg.nss_init ();
  /* Check caches first. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.grp_cache.cygserver.find_group (sid)))
    return ret;
  if (cygheap->pg.nss_grp_files ()
      && (ret = cygheap->pg.grp_cache.file.find_group (sid)))
    return ret;
  if (cygheap->pg.nss_grp_db ()
      && (ret = cygheap->pg.grp_cache.win.find_group (sid)))
    return ret;
  /* Ask sources afterwards. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.grp_cache.cygserver.add_group_from_cygserver (sid)))
    return ret;
  if (cygheap->pg.nss_grp_files ())
    {
      cygheap->pg.grp_cache.file.check_file ();
      if ((ret = cygheap->pg.grp_cache.file.add_group_from_file (sid)))
	return ret;
    }
  if (cygheap->pg.nss_grp_db ())
    return cygheap->pg.grp_cache.win.add_group_from_windows (sid, pldap);
  return NULL;
}

/* Like internal_getgrsid but return only already cached data,
   NULL otherwise. */
static struct group *
internal_getgrsid_cachedonly (cygpsid &sid)
{
  struct group *ret;

  /* Check caches only. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.grp_cache.cygserver.find_group (sid)))
    return ret;
  if (cygheap->pg.nss_grp_files ()
      && (ret = cygheap->pg.grp_cache.file.find_group (sid)))
    return ret;
  if (cygheap->pg.nss_grp_db ()
      && (ret = cygheap->pg.grp_cache.win.find_group (sid)))
    return ret;
  return NULL;
}

/* Called from internal_getgroups.  The full information required to create
   a group account entry is already available from the LookupAccountSids
   call.  internal_getgrfull passes all available info into
   pwdgrp::fetch_account_from_line, thus avoiding a LookupAccountSid call
   for each group.  This is quite a bit faster, especially in slower
   environments. */
static struct group * __attribute__((used))
internal_getgrfull (fetch_acc_t &full_acc, cyg_ldap *pldap)
{
  struct group *ret;

  cygheap->pg.nss_init ();
  /* Check caches first. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.grp_cache.cygserver.find_group (full_acc.sid)))
    return ret;
  if (cygheap->pg.nss_grp_files ()
      && (ret = cygheap->pg.grp_cache.file.find_group (full_acc.sid)))
    return ret;
  if (cygheap->pg.nss_grp_db ()
      && (ret = cygheap->pg.grp_cache.win.find_group (full_acc.sid)))
    return ret;
  /* Ask sources afterwards. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.grp_cache.cygserver.add_group_from_cygserver
      							(full_acc.sid)))
    return ret;
  if (cygheap->pg.nss_grp_files ())
    {
      cygheap->pg.grp_cache.file.check_file ();
      if ((ret = cygheap->pg.grp_cache.file.add_group_from_file
      							(full_acc.sid)))
	return ret;
    }
  if (cygheap->pg.nss_grp_db ())
    return cygheap->pg.grp_cache.win.add_group_from_windows (full_acc, pldap);
  return NULL;
}

/* This function gets only called from mkgroup via cygwin_internal. */
struct group *
internal_getgrsid_from_db (cygpsid &sid)
{
  cygheap->pg.nss_init ();
  return cygheap->pg.grp_cache.win.add_group_from_windows (sid);
}

struct group *
internal_getgrnam (const char *name, cyg_ldap *pldap)
{
  struct group *ret;

  cygheap->pg.nss_init ();
  /* Check caches first. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.grp_cache.cygserver.find_group (name)))
    return ret;
  if (cygheap->pg.nss_grp_files ()
      && (ret = cygheap->pg.grp_cache.file.find_group (name)))
    return ret;
  if (cygheap->pg.nss_grp_db ()
      && (ret = cygheap->pg.grp_cache.win.find_group (name)))
    return ret;
  /* Ask sources afterwards. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.grp_cache.cygserver.add_group_from_cygserver (name)))
    return ret;
  if (cygheap->pg.nss_grp_files ())
    {
      cygheap->pg.grp_cache.file.check_file ();
      if ((ret = cygheap->pg.grp_cache.file.add_group_from_file (name)))
	return ret;
    }
  if (cygheap->pg.nss_grp_db ())
    return cygheap->pg.grp_cache.win.add_group_from_windows (name, pldap);
  return NULL;
}

struct group *
internal_getgrgid (gid_t gid, cyg_ldap *pldap)
{
  struct group *ret;

  cygheap->pg.nss_init ();
  /* Check caches first. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.grp_cache.cygserver.find_group (gid)))
    return ret;
  if (cygheap->pg.nss_grp_files ()
      && (ret = cygheap->pg.grp_cache.file.find_group (gid)))
    return ret;
  if (cygheap->pg.nss_grp_db ()
      && (ret = cygheap->pg.grp_cache.win.find_group (gid)))
    return ret;
  /* Ask sources afterwards. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.grp_cache.cygserver.add_group_from_cygserver (gid)))
    return ret;
  if (cygheap->pg.nss_grp_files ())
    {
      cygheap->pg.grp_cache.file.check_file ();
      if ((ret = cygheap->pg.grp_cache.file.add_group_from_file (gid)))
	return ret;
    }
  if (cygheap->pg.nss_grp_db () || gid == ILLEGAL_GID)
    return cygheap->pg.grp_cache.win.add_group_from_windows (gid, pldap);
  return NULL;
}

#ifndef __x86_64__
static struct __group16 *
grp32togrp16 (struct __group16 *gp16, struct group *gp32)
{
  if (!gp16 || !gp32)
    return NULL;

  /* Copying the pointers is actually unnecessary.  Just having the correct
     return type is important. */
  gp16->gr_name = gp32->gr_name;
  gp16->gr_passwd = gp32->gr_passwd;
  gp16->gr_gid = (__gid16_t) gp32->gr_gid;		/* Not loss-free */
  gp16->gr_mem = gp32->gr_mem;

  return gp16;
}
#endif

extern "C" int
getgrgid_r (gid_t gid, struct group *grp, char *buffer, size_t bufsize,
	    struct group **result)
{
  *result = NULL;

  if (!grp || !buffer)
    return ERANGE;

  struct group *tempgr = internal_getgrgid (gid);
  pthread_testcancel ();
  if (!tempgr)
    return 0;

  /* Check needed buffer size.  Deliberately ignore gr_mem. */
  size_t needsize = strlen (tempgr->gr_name) + strlen (tempgr->gr_passwd)
		    + 2 + sizeof (char *);
  if (needsize > bufsize)
    return ERANGE;

  /* Make a copy of tempgr.  Deliberately ignore gr_mem. */
  *result = grp;
  grp->gr_gid = tempgr->gr_gid;
  buffer = stpcpy (grp->gr_name = buffer, tempgr->gr_name);
  buffer = stpcpy (grp->gr_passwd = buffer + 1, tempgr->gr_passwd);
  grp->gr_mem = (char **) (buffer + 1);
  grp->gr_mem[0] = NULL;
  return 0;
}

/* getgrgid/getgrnam are not reentrant. */
static struct {
  struct group g;
  char *buf;
  size_t bufsiz;
} app_gr;

static struct group *
getgr_cp (struct group *tempgr)
{
  if (!tempgr)
    return NULL;
  pg_grp *gr = (pg_grp *) tempgr;
  if (app_gr.bufsiz < gr->len)
    {
      char *newbuf = (char *) realloc (app_gr.buf, gr->len);
      if (!newbuf)
        {
          set_errno (ENOMEM);
          return NULL;
        }
      app_gr.buf = newbuf;
      app_gr.bufsiz = gr->len;
    }
  memcpy (app_gr.buf, gr->g.gr_name, gr->len);
  memcpy (&app_gr.g, &gr->g, sizeof gr->g);
  ptrdiff_t diff = app_gr.buf - gr->g.gr_name;
  app_gr.g.gr_name += diff;
  app_gr.g.gr_passwd += diff;
  return &app_gr.g;
}

extern "C" struct group *
getgrgid32 (gid_t gid)
{
  struct group *tempgr = internal_getgrgid (gid);
  pthread_testcancel ();
  return getgr_cp (tempgr);
}

#ifdef __x86_64__
EXPORT_ALIAS (getgrgid32, getgrgid)
#else
extern "C" struct __group16 *
getgrgid (__gid16_t gid)
{
  static struct __group16 g16;	/* FIXME: thread-safe? */

  return grp32togrp16 (&g16, getgrgid32 (gid16togid32 (gid)));
}
#endif

extern "C" int
getgrnam_r (const char *nam, struct group *grp, char *buffer,
	    size_t bufsize, struct group **result)
{
  *result = NULL;

  if (!grp || !buffer)
    return ERANGE;

  struct group *tempgr = internal_getgrnam (nam);
  pthread_testcancel ();
  if (!tempgr)
    return 0;

  /* Check needed buffer size.  Deliberately ignore gr_mem. */
  size_t needsize = strlen (tempgr->gr_name) + strlen (tempgr->gr_passwd)
		    + 2 + sizeof (char *);
  if (needsize > bufsize)
    return ERANGE;

  /* Make a copy of tempgr.  Deliberately ignore gr_mem. */
  *result = grp;
  grp->gr_gid = tempgr->gr_gid;
  buffer = stpcpy (grp->gr_name = buffer, tempgr->gr_name);
  buffer = stpcpy (grp->gr_passwd = buffer + 1, tempgr->gr_passwd);
  grp->gr_mem = (char **) (buffer + 1);
  grp->gr_mem[0] = NULL;
  return 0;
}

extern "C" struct group *
getgrnam32 (const char *name)
{
  struct group *tempgr = internal_getgrnam (name);
  pthread_testcancel ();
  return getgr_cp (tempgr);
}

#ifdef __x86_64__
EXPORT_ALIAS (getgrnam32, getgrnam)
#else
extern "C" struct __group16 *
getgrnam (const char *name)
{
  static struct __group16 g16;	/* FIXME: thread-safe? */

  return grp32togrp16 (&g16, getgrnam32 (name));
}
#endif

/* getgrent functions are not reentrant. */
static gr_ent grent;

void *
gr_ent::enumerate_caches ()
{
  switch (max)
    {
    case 0:
      if (cygheap->pg.nss_cygserver_caching ())
	{
	  pwdgrp &grc = cygheap->pg.grp_cache.cygserver;
	  if (cnt < grc.cached_groups ())
	    return &grc.group ()[cnt++].g;
	}
      cnt = 0;
      max = 1;
      /*FALLTHRU*/
    case 1:
      if (from_files)
	{
	  pwdgrp &grf = cygheap->pg.grp_cache.file;
	  grf.check_file ();
	  if (cnt < grf.cached_groups ())
	    return &grf.group ()[cnt++].g;
	}
      cnt = 0;
      max = 2;
      /*FALLTHRU*/
    case 2:
      if (from_db)
	{
	  pwdgrp &grw = cygheap->pg.grp_cache.win;
	  if (cnt < grw.cached_groups ())
	    return &grw.group ()[cnt++].g;
	}
      break;
    }
  cnt = max = 0;
  return NULL;
}

void *
gr_ent::enumerate_local ()
{
  while (true)
    {
      if (!cnt)
	{
	  DWORD total;
	  NET_API_STATUS ret;

	  if (buf)
	    {
	      NetApiBufferFree (buf);
	      buf = NULL;
	    }
	  if (resume == ULONG_MAX)
	    ret = ERROR_NO_MORE_ITEMS;
	  else
	    ret = NetLocalGroupEnum (NULL, 0, (PBYTE *) &buf,
				     MAX_PREFERRED_LENGTH,
				     &max, &total, &resume);
	  if (ret == NERR_Success)
	    resume = ULONG_MAX;
	  else if (ret != ERROR_MORE_DATA)
	    {
	      cnt = max = resume = 0;
	      return NULL;
	    }
	}
      while (cnt < max)
	{
	  cygsid sid;
	  DWORD slen = SECURITY_MAX_SID_SIZE;
	  WCHAR dom[DNLEN + 1];
	  DWORD dlen = DNLEN + 1;
	  SID_NAME_USE acc_type;

	  LookupAccountNameW (NULL,
			      ((PLOCALGROUP_INFO_0) buf)[cnt++].lgrpi0_name,
			      sid, &slen, dom, &dlen, &acc_type);
	  fetch_user_arg_t arg;
	  arg.type = SID_arg;
	  arg.sid = &sid;
	  char *line = pg.fetch_account_from_windows (arg);
	  if (line)
	    return pg.add_account_post_fetch (line, false);
	}
      cnt = 0;
    }
}

struct group *
gr_ent::getgrent (void)
{
  if (state == rewound)
    setent (true);
  else
    clear_cache ();
  return (struct group *) getent ();
}

extern "C" void
setgrent ()
{
  grent.setgrent ();
}

extern "C" struct group *
getgrent32 (void)
{
  return grent.getgrent ();
}

#ifdef __x86_64__
EXPORT_ALIAS (getgrent32, getgrent)
#else
extern "C" struct __group16 *
getgrent ()
{
  static struct __group16 g16;	/* FIXME: thread-safe? */

  return grp32togrp16 (&g16, getgrent32 ());
}
#endif

extern "C" void
endgrent (void)
{
  grent.endgrent ();
}

/* *_filtered functions are called from mkgroup */
void *
setgrent_filtered (int enums, PCWSTR enum_tdoms)
{
  gr_ent *gr = new gr_ent;
  if (gr)
    gr->setgrent (enums, enum_tdoms);
  return (void *) gr;
}

void *
getgrent_filtered (void *gr)
{
  return (void *) ((gr_ent *) gr)->getgrent ();
}

void
endgrent_filtered (void *gr)
{
  ((gr_ent *) gr)->endgrent ();
}

/* timeout_ns (in 100ns units) is set to non-0 when called from
   internal_getlogin.  This restricts fetching of the user's groups at process
   tree startup to a (hopefully) bearable time.  */
int
internal_getgroups (int gidsetsize, gid_t *grouplist, cyg_ldap *pldap,
		    const DWORD timeout_ns)
{
  NTSTATUS status;
  HANDLE tok;
  ULONG size;
  PTOKEN_GROUPS groups;
  PSID *sidp_buf;
  ULONG scnt;
  PLSA_REFERENCED_DOMAIN_LIST dlst = NULL;
  PLSA_TRANSLATED_NAME nlst = NULL;

  tmp_pathbuf tp;
  struct group *grp;
  int cnt = 0;

  if (cygheap->user.groups.issetgroups ())
    {
      for (int pg = 0; pg < cygheap->user.groups.sgsids.count (); ++pg)
	if ((grp = internal_getgrsid (cygheap->user.groups.sgsids.sids[pg],
				      pldap)))
	  {
	    if (cnt < gidsetsize)
	      grouplist[cnt] = grp->gr_gid;
	    ++cnt;
	    if (gidsetsize && cnt > gidsetsize)
	      {
		cnt = -1;
		break;
	      }
	  }
      goto out;
    }

  /* If impersonated, use impersonation token. */
  tok = cygheap->user.issetuid () ? cygheap->user.primary_token ()
				  : hProcToken;

  /* Fetch groups from user token. */
  groups = (PTOKEN_GROUPS) tp.w_get ();
  status = NtQueryInformationToken (tok, TokenGroups, groups, 2 * NT_MAX_PATH,
				    &size);
  if (!NT_SUCCESS (status))
    {
      system_printf ("token group list > 64K?  status = %u", status);
      goto out;
    }
  /* Iterate over the group list and check which of them are already cached.
     Those are simply copied to grouplist.  The non-cached ones are collected
     in sidp_buf for a later call to LsaLookupSids. */
  sidp_buf = (PSID *) tp.w_get ();
  scnt = 0;
  for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
    {
      cygpsid sid = groups->Groups[pg].Sid;
      if ((groups->Groups[pg].Attributes
	  & (SE_GROUP_ENABLED | SE_GROUP_INTEGRITY_ENABLED)) == 0
	  || sid == well_known_world_sid)
	continue;
      if ((grp = internal_getgrsid_cachedonly (sid)))
	{
	  if (cnt < gidsetsize)
	    grouplist[cnt] = grp->gr_gid;
	  ++cnt;
	  if (gidsetsize && cnt > gidsetsize)
	    {
	      cnt = -1;
	      goto out;
	    }
	}
      else 
	sidp_buf[scnt++] = sid;
    }
  /* If there are non-cached groups left, call LsaLookupSids and call
     internal_getgrfull on the returned groups.  This performs a lot
     better than calling internal_getgrsid on each group. */
  if (scnt > 0)
    {
      status = STATUS_ACCESS_DENIED;
      HANDLE lsa = lsa_open_policy (NULL, POLICY_LOOKUP_NAMES);
      if (!lsa)
	{
	  system_printf ("POLICY_LOOKUP_NAMES not given?");
	  goto out;
	}
      status = LsaLookupSids (lsa, scnt, sidp_buf, &dlst, &nlst);
      lsa_close_policy (lsa);
      if (NT_SUCCESS (status))
	{
	  for (ULONG ncnt = 0; ncnt < scnt; ++ncnt)
	    {
	      fetch_acc_t full_acc =
		{
		  .sid = sidp_buf[ncnt],
		  .name = &nlst[ncnt].Name,
		  .dom = &dlst->Domains[nlst[ncnt].DomainIndex].Name,
		  .acc_type = nlst[ncnt].Use
		};
	      if ((grp = internal_getgrfull (full_acc, pldap)))
		{
		  if (cnt < gidsetsize)
		    grouplist[cnt] = grp->gr_gid;
		  ++cnt;
		  if (gidsetsize && cnt > gidsetsize)
		    {
		      cnt = -1;
		      goto out;
		    }
		}
	    }
	}
    }

out:
  if (dlst)
    LsaFreeMemory (dlst);
  if (nlst)
    LsaFreeMemory (nlst);
  if (cnt == -1)
    set_errno (EINVAL);
  return cnt;
}

extern "C" int
getgroups32 (int gidsetsize, gid_t *grouplist)
{
  cyg_ldap cldap;

  return internal_getgroups (gidsetsize, grouplist, &cldap);
}

#ifdef __x86_64__
EXPORT_ALIAS (getgroups32, getgroups)
#else
extern "C" int
getgroups (int gidsetsize, __gid16_t *grouplist)
{
  gid_t *grouplist32 = NULL;

  if (gidsetsize < 0)
    {
      set_errno (EINVAL);
      return -1;
    }
  if (gidsetsize > 0 && grouplist)
    grouplist32 = (gid_t *) alloca (gidsetsize * sizeof (gid_t));

  int ret = getgroups32 (gidsetsize, grouplist32);

  if (gidsetsize > 0 && grouplist)
    for (int i = 0; i < ret; ++ i)
      grouplist[i] = grouplist32[i];

  return ret;
}
#endif

/* Core functionality of initgroups and getgrouplist. */
static void
get_groups (const char *user, gid_t gid, cygsidlist &gsids)
{
  cyg_ldap cldap;

  cygheap->user.deimpersonate ();
  struct passwd *pw = internal_getpwnam (user, &cldap);
  struct group *grp = internal_getgrgid (gid, &cldap);
  cygsid usersid, grpsid;
  if (usersid.getfrompw (pw))
    get_server_groups (gsids, usersid, pw);
  if (gid != ILLEGAL_GID && grpsid.getfromgr (grp))
    gsids += grpsid;
  cygheap->user.reimpersonate ();
}

extern "C" int
initgroups32 (const char *user, gid_t gid)
{
  assert (user != NULL);
  cygsidlist tmp_gsids (cygsidlist_auto, 12);
  get_groups (user, gid, tmp_gsids);
  cygsidlist new_gsids (cygsidlist_alloc, tmp_gsids.count ());
  for (int i = 0; i < tmp_gsids.count (); i++)
    new_gsids.sids[i] = tmp_gsids.sids[i];
  new_gsids.count (tmp_gsids.count ());
  cygheap->user.groups.update_supp (new_gsids);
  syscall_printf ( "0 = initgroups(%s, %u)", user, gid);
  return 0;
}

#ifdef __x86_64__
EXPORT_ALIAS (initgroups32, initgroups)
#else
extern "C" int
initgroups (const char *user, __gid16_t gid)
{
  return initgroups32 (user, gid16togid32(gid));
}
#endif

extern "C" int
getgrouplist (const char *user, gid_t gid, gid_t *groups, int *ngroups)
{
  int ret = 0;
  int cnt = 0;
  struct group *grp;
  cyg_ldap cldap;

  /* Note that it's not defined if groups or ngroups may be NULL!
     GLibc does not check the pointers on entry and just uses them.
     FreeBSD calls assert for ngroups and allows a NULL groups if
     *ngroups is 0.  We follow FreeBSD's lead here, but always allow
     a NULL groups pointer. */
  assert (user != NULL);
  assert (ngroups != NULL);

  cygsidlist tmp_gsids (cygsidlist_auto, 12);
  get_groups (user, gid, tmp_gsids);
  for (int i = 0; i < tmp_gsids.count (); i++)
    if ((grp = internal_getgrsid (tmp_gsids.sids[i], &cldap)) != NULL)
      {
	if (groups && cnt < *ngroups)
	  groups[cnt] = grp->gr_gid;
	++cnt;
      }
  if (cnt > *ngroups)
    ret = -1;
  else
    ret = cnt;
  *ngroups = cnt;

  syscall_printf ( "%d = getgrouplist(%s, %u, %p, %d)",
		  ret, user, gid, groups, *ngroups);
  return ret;
}

/* setgroups32: standards? */
extern "C" int
setgroups32 (int ngroups, const gid_t *grouplist)
{
  syscall_printf ("setgroups32 (%d)", ngroups);
  if (ngroups < 0 || (ngroups > 0 && !grouplist))
    {
      set_errno (EINVAL);
      return -1;
    }

  cygsidlist gsids (cygsidlist_alloc, ngroups);
  struct group *grp;
  cyg_ldap cldap;

  if (ngroups && !gsids.sids)
    return -1;

  for (int gidx = 0; gidx < ngroups; ++gidx)
    {
      if ((grp = internal_getgrgid (grouplist[gidx], &cldap))
	  && gsids.addfromgr (grp))
	continue;
      debug_printf ("No sid found for gid %u", grouplist[gidx]);
      gsids.free_sids ();
      set_errno (EINVAL);
      return -1;
    }
  cygheap->user.groups.update_supp (gsids);
  return 0;
}

#ifdef __x86_64__
EXPORT_ALIAS (setgroups32, setgroups)
#else
extern "C" int
setgroups (int ngroups, const __gid16_t *grouplist)
{
  gid_t *grouplist32 = NULL;

  if (ngroups > 0 && grouplist)
    {
      grouplist32 = (gid_t *) alloca (ngroups * sizeof (gid_t));
      if (grouplist32 == NULL)
	return -1;
      for (int i = 0; i < ngroups; i++)
	grouplist32[i] = grouplist[i];
    }
  return setgroups32 (ngroups, grouplist32);
}
#endif
@


1.141
log
@	* autoload.cc (LsaLookupSids): Import.
	* cygserver_pwdgrp.h: Include userinfo.h.  Drop workaround defining
	fetch_user_arg_type_t locally.
	* grp.cc (internal_getgrsid_cachedonly): New function.
	(internal_getgrfull): Ditto.
	(internal_getgroups): Rearrange function.  Center around fetching all
	cached group info first, calling LsaLookupSids on all so far non-cached
	groups second.  Pass all available info to new internal_getgrfull call.
	* pwdgrp.h: Include userinfo.h.  Move definitions of
	fetch_user_arg_type_t and fetch_user_arg_t there.
	(pwdgrp::add_group_from_windows): Declare with getting full group info.
	Called from internal_getgrfull.
	* uinfo.cc (pwdgrp::add_group_from_windows): Define.
	(pwdgrp::fetch_account_from_line): Add default case.
	(pwdgrp::fetch_account_from_file): Ditto.
	(pwdgrp::fetch_account_from_windows): Handle FULL_grp_arg.
	(client_request_pwdgrp::client_request_pwdgrp): Add default case.
	* userinfo.h: New header.
	(enum fetch_user_arg_type_t): Add FULL_grp_arg.
	(struct fetch_full_grp_t): New datatype.
@
text
@d148 1
a148 1
internal_getgrfull (fetch_full_grp_t &full_grp, cyg_ldap *pldap)
d155 1
a155 1
      && (ret = cygheap->pg.grp_cache.cygserver.find_group (full_grp.sid)))
d158 1
a158 1
      && (ret = cygheap->pg.grp_cache.file.find_group (full_grp.sid)))
d161 1
a161 1
      && (ret = cygheap->pg.grp_cache.win.find_group (full_grp.sid)))
d166 1
a166 1
      							(full_grp.sid)))
d172 1
a172 1
      							(full_grp.sid)))
d176 1
a176 1
    return cygheap->pg.grp_cache.win.add_group_from_windows (full_grp, pldap);
d650 1
a650 1
	      fetch_full_grp_t full_grp =
d657 1
a657 1
	      if ((grp = internal_getgrfull (full_grp, pldap)))
@


1.140
log
@	* grp.cc (internal_getgroups): Check for group attributes and
	Everyone sid before calling internal_getgrsid.
@
text
@d17 1
d121 59
d565 8
a573 1
  struct group *grp;
d585 4
a588 1
	      goto error;
d590 1
a590 1
      return cnt;
d594 2
a595 1
  tok = cygheap->user.issetuid () ? cygheap->user.primary_token () : hProcToken;
d597 49
a645 6
  status = NtQueryInformationToken (tok, TokenGroups, NULL, 0, &size);
  if (NT_SUCCESS (status) || status == STATUS_BUFFER_TOO_SMALL)
    {
      PTOKEN_GROUPS groups = (PTOKEN_GROUPS) alloca (size);

      status = NtQueryInformationToken (tok, TokenGroups, groups, size, &size);
d648 1
a648 5
	  ULONGLONG t0;

	  if (timeout_ns)
	    t0 = GetTickCount_ns ();
	  for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
d650 8
a657 6
	      cygpsid sid = groups->Groups[pg].Sid;
	      if ((groups->Groups[pg].Attributes
		  & (SE_GROUP_ENABLED | SE_GROUP_INTEGRITY_ENABLED)) == 0
		  || sid == well_known_world_sid)
		continue;
	      if ((grp = internal_getgrsid (sid, pldap)))
d663 4
a666 1
		    goto error;
a667 2
	      if (timeout_ns && GetTickCount_ns () - t0 >= timeout_ns)
		break;
d671 8
a678 2
  else
    debug_printf ("%u = NtQueryInformationToken(NULL) %y", size, status);
a679 4

error:
  set_errno (EINVAL);
  return -1;
@


1.139
log
@	* grp.cc (internal_getgroups): Take additional timeout_ns parameter.
	Restrict fetching group account entries from user token groups by
	timeout_ns 100ns-intervals.  Add preceding comment to explain why.
	* pwdgrp.h (internal_getgroups): Align prototype.
	* times.cc (GetTickCount_ns): New function.
	* uinfo.cc (internal_getlogin): Call internal_getgroups wih 300ms
	timeout.
	* winsup.h (GetTickCount_ns): Declare.
@
text
@d541 4
d547 5
a551 10
		  if ((groups->Groups[pg].Attributes
		      & (SE_GROUP_ENABLED | SE_GROUP_INTEGRITY_ENABLED))
		      && sid != well_known_world_sid)
		    {
		      if (cnt < gidsetsize)
			grouplist[cnt] = grp->gr_gid;
		      ++cnt;
		      if (gidsetsize && cnt > gidsetsize)
			goto error;
		    }
@


1.138
log
@	* grp.cc (getgrouplist): Fix setting ngroups to make sure to return
	the right value.
@
text
@d4 1
a4 1
   2008, 2009, 2011, 2012, 2013, 2014 Red Hat, Inc.
d495 3
d499 2
a500 1
internal_getgroups (int gidsetsize, gid_t *grouplist, cyg_ldap *pldap)
d534 4
d554 2
@


1.137
log
@	* grp.cc (gr_ent::enumerate_caches): Fix copy/paste bug introducing
	an endless loop.
@
text
@a658 1
  *ngroups = cnt;
d663 1
@


1.136
log
@	* grp.cc (pwdgrp::parse_group): Set grp.len.  Drop generating any
	gr_mem entries.
	(getgrgid_r): Don't try to copy gr_mem entries.  Always set gr_mem
	to an empty list.
	(getgrnam_r): Ditto.
	(app_gr): New static struct to store group data propagated to the
	calling application via getgrgid/getgrnam.
	(getgr_cp): Fill app_gr and return pointer to app_gr.g.
	(getgrgid32): Call getgr_cp.
	(getgrnam32): Ditto.
	* passwd.cc (pwdgrp::parse_passwd): Set res.len.
	(app_pw): New static struct to store passwd data propagated to the
	calling application via getpwuid/getpwnam.
	(getpw_cp): Fill app_pw and return pointer to app_pw.p.
	(getpwuid32): Cal getpw_cp.
	(getpwnam): Ditto.
	* pwdgrp.h (struct pg_pwd): Add len member.
	(struct pg_grp): Ditto.
@
text
@d367 1
a367 1
      max = 1;
@


1.135
log
@	* security.h (MAX_SUBAUTH_CNT): Drop.  Use SID_MAX_SUB_AUTHORITIES
	instead throughout.
	(MAX_SID_LEN): Drop.  Use SECURITY_MAX_SID_SIZE instead throughout.
@
text
@d41 4
d47 1
a47 4
  int n;
  char *dp = raw_ptr ();
  for (n = 0; *next_str (','); n++)
    continue;
a48 10
  if (n)
    {
      char **namearray = (char **) ccalloc (HEAP_BUF, n + 1, sizeof (char *));
      if (namearray)
	{
	  for (int i = 0; i < n; i++, dp = strchr (dp, '\0') + 1)
	    namearray[i] = dp;
	  grp.g.gr_mem = namearray;
	}
    }
d222 1
a222 2
  /* check needed buffer size. */
  int i;
a224 2
  for (i = 0; tempgr->gr_mem[i]; ++i)
    needsize += strlen (tempgr->gr_mem[i]) + 1 + sizeof (char *);
d228 1
a228 1
  /* make a copy of tempgr */
d234 1
a234 4
  buffer = (char *) grp->gr_mem + (i + 1) * sizeof (char *);
  for (i = 0; tempgr->gr_mem[i]; ++i)
    buffer = stpcpy (grp->gr_mem[i] = buffer, tempgr->gr_mem[i]) + 1;
  grp->gr_mem[i] = NULL;
d238 32
d273 3
a275 1
  return internal_getgrgid (gid);
d304 1
a304 2
  /* check needed buffer size. */
  int i;
a306 2
  for (i = 0; tempgr->gr_mem[i]; ++i)
    needsize += strlen (tempgr->gr_mem[i]) + 1 + sizeof (char *);
d310 1
a310 1
  /* make a copy of tempgr */
d316 1
a316 4
  buffer = (char *) grp->gr_mem + (i + 1) * sizeof (char *);
  for (i = 0; tempgr->gr_mem[i]; ++i)
    buffer = stpcpy (grp->gr_mem[i] = buffer, tempgr->gr_mem[i]) + 1;
  grp->gr_mem[i] = NULL;
d323 3
a325 1
  return internal_getgrnam (name);
@


1.134
log
@	* grp.cc (internal_getgroups): Drop unused cygsid variable.
	* sec_helper.cc (cygpsid::pstring): Use sid_sub_auth_count macro.
	(cygsid::get_sid): Use MAX_SUBAUTH_CNT rather than wrong constant 8.
	Don't call memcpy to copy subauthorities into SID, use assignment.
	(cygsid::getfromstr): Use MAX_SUBAUTH_CNT rather than wrong constant 8.
	* security.h (MAX_SUBAUTH_CNT): New definition.  Set to 11 to cover
	Microsoft Accounts.
	(MAX_SID_LEN): Define in terms of SID member sizes and MAX_SUBAUTH_CNT.
	(DBGSID): Use MAX_SUBAUTH_CNT to define size of SubAuthority array.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Handle Micosoft
	Accounts.  Handle them as well known group.  Compare domain names
	case-insensitive.
	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.
@
text
@d399 1
a399 1
	  DWORD slen = MAX_SID_LEN;
@


1.133
log
@	* cygheap.h (enum cygheap_pwdgrp::cache_t): Remove.
	(cygheap_pwdgrp::caching): Convert to bool.
	(cygheap_pwdgrp::pwd_cache): Add cygserver member.
	(cygheap_pwdgrp::grp_cache): Ditto.
	(cygheap_pwdgrp::nss_db_caching): Drop.
	(cygheap_pwdgrp::nss_db_full_caching): Drop.
	(cygheap_pwdgrp::nss_cygserver_caching): New method.
	(cygheap_pwdgrp::nss_disable_cygserver_caching): New method.
	* cygserver.h (client_request::request_code_t): Add
	CYGSERVER_REQUEST_PWDGRP.
	* cygserver_pwdgrp.h: New file.
	* cygtls.h (struct _local_storage): Remove pwbuf and grbuf members.
	* grp.cc (pwdgrp::prep_tls_grbuf): Drop.
	(internal_getgrsid): Handle cygserver caching and rearrange to check
	the caches first.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(gr_ent::enumerate_caches): Handle cygserver cache.
	* passwd.cc (pwdgrp::prep_tls_pwbuf): Drop.
	(internal_getpwsid): Handle cygserver caching and rearrange to check
	the caches first.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(pw_ent::enumerate_caches): Handle cygserver cache.
	* pwdgrp.h (pwdgrp::add_account_from_cygserver): New method declaration.
	(pwdgrp::fetch_account_from_cygserver): New method declaration.
	(pwdgrp::prep_tls_pwbuf): Drop declaration.
	(pwdgrp::prep_tls_grbuf): Drop declaration.
	(pwdgrp::add_user_from_cygserver): New inline methods.
	(pwdgrp::add_group_from_cygserver): New inline methods.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
	* uinfo.cc (internal_getlogin): Call internal_getgroups if cygserver
	caching is not available.
	(cygheap_pwdgrp::init): Initialize pwd_cache.cygserver and
	grp_cache.cygserver.  Set caching to true.
	(cygheap_pwdgrp::nss_init_line): Drop db_cache handling entirely.
	(pwdgrp::add_account_from_windows): Drop no caching handling.
	(client_request_pwdgrp::client_request_pwdgrp): New method.
	(pwdgrp::fetch_account_from_cygserver): New method.
	(pwdgrp::add_account_from_cygserver): New method.

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Fix formatting.
	* include/sys/cygwin.h: Ditto.
@
text
@a514 2
	  cygsid sid;

@


1.132
log
@	* pwdgrp.h (pwdgrp::is_passwd): New inline method.
	(pwdgrp::is_group): New inline method.
	(add_account_from_windows): Drop group argument from declaration.
	(fetch_account_from_windows): Ditto.
	(check_file): Ditto.
	(add_user_from_windows): Call add_account_from_windows accordingly.
	(add_group_from_windows): Ditto.
	* uinfo.cc (pwdgrp::add_account_from_windows): Drop group argument.
	Use is_group method instead.
	(pwdgrp::check_file): Ditto.
	(pwdgrp::fetch_account_from_windows): Ditto.
	* grp.cc: Accommodate aforementioned changes.
	* passwd.cc: Ditto.
@
text
@a70 21
pwdgrp *
pwdgrp::prep_tls_grbuf ()
{
  if (!_my_tls.locals.grbuf)
    {
      _my_tls.locals.grbuf = ccalloc_abort (HEAP_BUF, 1,
					    sizeof (pwdgrp) + sizeof (pg_grp));
      pwdgrp *gr = (pwdgrp *) _my_tls.locals.grbuf;
      gr->init_grp ();
      gr->pwdgrp_buf = (void *) (gr + 1);
      gr->max_lines = 1;
    }
  pwdgrp *gr = (pwdgrp *) _my_tls.locals.grbuf;
  if (gr->curr_lines)
    {
      cfree (gr->group ()[0].g.gr_name);
      gr->curr_lines = 0;
    }
  return gr;
}         

d104 14
a120 2
      if ((ret = cygheap->pg.grp_cache.file.find_group (sid)))
	return ret;
d125 1
a125 5
    {
      if ((ret = cygheap->pg.grp_cache.win.find_group (sid)))
	return ret;
      return cygheap->pg.grp_cache.win.add_group_from_windows (sid, pldap);
    }
d143 14
a159 2
      if ((ret = cygheap->pg.grp_cache.file.find_group (name)))
	return ret;
d164 1
a164 5
    {
      if ((ret = cygheap->pg.grp_cache.win.find_group (name)))
	return ret;
      return cygheap->pg.grp_cache.win.add_group_from_windows (name, pldap);
    }
d174 14
a190 2
      if ((ret = cygheap->pg.grp_cache.file.find_group (gid)))
	return ret;
d194 1
a194 7
  if (cygheap->pg.nss_grp_db ())
    {
      if ((ret = cygheap->pg.grp_cache.win.find_group (gid)))
	return ret;
      return cygheap->pg.grp_cache.win.add_group_from_windows (gid);
    }
  else if (gid == ILLEGAL_GID)
d331 1
a331 1
  if (!max && from_files)
d333 18
a350 4
      pwdgrp &grf = cygheap->pg.grp_cache.file;
      grf.check_file ();
      if (cnt < grf.cached_groups ())
        return &grf.group ()[cnt++].g;
d353 9
a361 6
    }
  if (from_db && cygheap->pg.nss_db_caching ())
    {
      pwdgrp &grw = cygheap->pg.grp_cache.win;
      if (cnt < grw.cached_groups ())
        return &grw.group ()[cnt++].g;
@


1.131
log
@	* cygheap.h (cygheap_user::sid): Return reference to cygpsid rather
	than PSID.
	(cygheap_user::saved_sid): Ditto.
	(cygheap_pwdgrp::cache_t): New type.
	(cygheap_pwdgrp::caching): Convert to cache_t.
	(cygheap_pwdgrp::nss_db_caching): Change accordingly.
	(cygheap_pwdgrp::nss_db_full_caching): New inline method.
	* grp.cc (internal_getgroups): Reinvent.  Take cyg_ldap pointer as
	third parameter and use throughout.
	(getgroups32): Call internal_getgroups.
	* pwdgrp.h (internal_getgroups): Declare.
	* uinfo.cc (internal_getlogin): Partial rewrite to accommodate having
	no connection to the DC.  Give primary group from user token more
	weight.  Generate group entries for all groups in the user token if
	caching is set to NSS_FULL_CACHING.
	(cygheap_pwdgrp::init): Initialize caching to NSS_FULL_CACHING.
	(cygheap_pwdgrp::nss_init_line): Handle "db_cache: full".
	(pwdgrp::add_account_from_windows): Fix group handling in non-caching
	mode.
	(pwdgrp::fetch_account_from_windows): Default primary group for the
	current user to primary group from user token.  Check for primary
	domain first after LookupAccountSid failed.
@
text
@d127 1
a127 1
      cygheap->pg.grp_cache.file.check_file (true);
d158 1
a158 1
      cygheap->pg.grp_cache.file.check_file (true);
d181 1
a181 1
      cygheap->pg.grp_cache.file.check_file (true);
d333 1
a333 1
      grf.check_file (true);
d392 1
a392 1
	  char *line = pg.fetch_account_from_windows (arg, true);
@


1.130
log
@	* autoload.cc (CheckTokenMembership): Import.
	* external.cc (cygwin_internal): Call get_uid/get_gid instead of get_id.
	* grp.cc (internal_getgrsid): Take additional cyg_ldap pointer.
	Forward to pwdgrp::add_group_from_windows.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(gr_ent::enumerate_local): Drop ugid_caching bool from call to
	pwdgrp::fetch_account_from_windows.
	(getgroups32): Rename from internal_getgroups and drop getgroups32 stub.
	Drop srchsid parameter and code handling it.  Add local cyg_ldap
	instance and forward to internal_getgrXXX.
	(getgroups): Call getgroups32.
	(get_groups): Add local cyg_ldap instance and forward to
	internal_getgrXXX.
	(getgrouplist): Ditto.
	(setgroups32): Ditto.
	* ldap.cc (cyg_ldap::open): Don't call close.  Return true if connection
	is already open.
	(cyg_ldap::remap_uid): Forward this to internal_getpwsid.
	(cyg_ldap::remap_gid): Forward this to internal_getgrsid.
	* passwd.cc (internal_getpwsid): Take additional cyg_ldap pointer.
	Forward to pwdgrp::add_user_from_windows.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(pg_ent::enumerate_builtin): Drop ugid_caching bool from call to
	pwdgrp::fetch_account_from_windows.
	(pg_ent::enumerate_sam): Ditto.
	(pg_ent::enumerate_ad): Ditto.  Forward local cldap instead.
	* pwdgrp.h (internal_getpwsid): Align declaration to above change.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(internal_getgrsid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgroups): Drop declaration.
	(pwdgrp::add_account_from_windows): Align declaration to below change.
	(pwdgrp::add_user_from_windows): Ditto.
	(pwdgrp::add_group_from_windows): Ditto.
	* sec_acl.cc (setacl): Add local cyg_ldap instance and forward to
	internal_getpwuid and internal_getgrgid.
	(getacl): Add local cyg_ldap instance and forward to cygpsid::get_id.
	(aclfromtext32): Add local cyg_ldap instance and forward to
	internal_getpwnam and internal_getgrnam.
	* sec_helper.cc (cygpsid::get_id): Take additional cyg_ldap pointer.
	Forward to internal_getgrsid and internal_getpwsid.
	(get_sids_info): Drop ldap_open.  Forward local cldap to
	internal_getpwsid and internal_getgrXXX.  Call CheckTokenMembership
	rather than internal_getgroups.
	* security.h (cygpsid::get_id): Add cyg_ldap pointer, drop default
	parameter.
	(cygpsid::get_uid): Add cyg_ldap pointer.  Call get_id accordingly.
	(cygpsid::get_gid): Ditto.
	* uinfo.cc (internal_getlogin): Add local cyg_ldap instance and forward
	to internal_getpwXXX and internal_getgrXXX calls.
	(pwdgrp::add_account_from_windows): Take additional cyg_ldap pointer.
	Forward to pwdgrp::fetch_account_from_windows.
	(fetch_posix_offset): Drop ldap_open argument and handling.  Get
	cyg_ldap instance as pointer.
	(pwdgrp::fetch_account_from_windows): Take additional cyg_ldap pointer.
	Use it if it's not NULL, local instance otherwise.  Drop ldap_open.
	Drop fetching extended group arguments from AD for speed.
@
text
@d462 2
a463 2
extern "C" int
getgroups32 (int gidsetsize, gid_t *grouplist)
a469 1
  cyg_ldap cldap;
d475 1
a475 1
				      &cldap)))
d502 1
a502 1
	      if ((grp = internal_getgrsid (sid, &cldap)))
d527 8
@


1.129
log
@	* external.cc (cygwin_internal): Add cases for CW_GETNSSSEP,
	CW_GETPWSID and CW_GETGRSID.
	* grp.cc (internal_getgrsid_from_db): New function.
	* passwd.cc (internal_getpwsid_from_db): New function.
	(pg_ent::setent): Add special case for call from mkpasswd/mkgroup.
	* pwdgrp.h (internal_getpwsid_from_db): Declare.
	(internal_getgrsid_from_db): Declare.
	(enum nss_enum_t): Move to include/sys/cygwin.h.
	(class pg_ent): Add comment.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Fix typo in comment.
	Change "UNIX" to "Unix" in domain name.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GETNSSSEP,
	CW_GETPWSID and CW_GETGRSID.
	(enum nss_enum_t): Define here.
@
text
@d120 1
a120 1
internal_getgrsid (cygpsid &sid)
d137 1
a137 1
      return cygheap->pg.grp_cache.win.add_group_from_windows (sid);
d151 1
a151 1
internal_getgrnam (const char *name)
d168 1
a168 1
      return cygheap->pg.grp_cache.win.add_group_from_windows (name);
d174 1
a174 1
internal_getgrgid (gid_t gid)
d194 1
a194 1
    return cygheap->pg.grp_cache.win.add_group_from_windows (gid);
d392 1
a392 1
	  char *line = pg.fetch_account_from_windows (arg, true, false);
d462 2
a463 2
int
internal_getgroups (int gidsetsize, gid_t *grouplist, cygpsid *srchsid)
d466 1
a466 1
  HANDLE hToken = NULL;
d470 1
d472 1
a472 1
  if (!srchsid && cygheap->user.groups.issetgroups ())
d475 2
a476 1
	if ((grp = internal_getgrsid (cygheap->user.groups.sgsids.sids[pg])))
d488 1
a488 4
  if (cygheap->user.issetuid ())
    hToken = cygheap->user.primary_token ();
  else
    hToken = hProcToken;
d490 1
a490 1
  status = NtQueryInformationToken (hToken, TokenGroups, NULL, 0, &size);
d495 1
a495 2
      status = NtQueryInformationToken (hToken, TokenGroups, groups,
					size, &size);
d500 1
a500 7
	  if (srchsid)
	    {
	      for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
		if ((cnt = (*srchsid == groups->Groups[pg].Sid)))
		  break;
	    }
	  else
d502 2
a503 1
	      for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
d505 3
a507 2
		  cygpsid sid = groups->Groups[pg].Sid;
		  if ((grp = internal_getgrsid (sid)))
d509 5
a513 10
		      if ((groups->Groups[pg].Attributes
			  & (SE_GROUP_ENABLED | SE_GROUP_INTEGRITY_ENABLED))
			  && sid != well_known_world_sid)
			{
			  if (cnt < gidsetsize)
			    grouplist[cnt] = grp->gr_gid;
			  ++cnt;
			  if (gidsetsize && cnt > gidsetsize)
			    goto error;
			}
a527 6
extern "C" int
getgroups32 (int gidsetsize, gid_t *grouplist)
{
  return internal_getgroups (gidsetsize, grouplist);
}

d544 1
a544 1
  int ret = internal_getgroups (gidsetsize, grouplist32);
d558 2
d561 2
a562 2
  struct passwd *pw = internal_getpwnam (user);
  struct group *grp = internal_getgrgid (gid);
d602 1
d615 1
a615 1
    if ((grp = internal_getgrsid (tmp_gsids.sids[i])) != NULL)
d645 1
d652 1
a652 1
      if ((grp = internal_getgrgid (grouplist[gidx]))
@


1.128
log
@	* pwdgrp.h (pwdgrp::fetch_account_from_windows): Add bool parameter
	to declaration, set to true by default.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Add bool parameter
	"ugid_caching".  Only add account to ugid_cache if set to true.
	* grp.cc (gr_ent::enumerate_local): Call fetch_account_from_windows
	with ugid_caching parameter set to false.
	* passwd.cc (pg_ent::enumerate_builtin): Ditto.
	(pg_ent::enumerate_sam): Ditto.
	(pg_ent::enumerate_ad): Ditto.
@
text
@d142 8
@


1.127
log
@	* grp.cc (getgrouplist): Fix previous fix so ret is only set to ngroups
	if ngroups isn't too small.
@
text
@d384 1
a384 1
	  char *line = pg.fetch_account_from_windows (arg, true);
@


1.126
log
@	* grp.cc (get_groups): Don't add gid to list if it's ILLEGAL_GID.
	(getgrouplist): Return number of groups, just like glibc.
@
text
@d627 1
d630 2
a631 1
  ret = *ngroups = cnt;
@


1.125
log
@	* external.cc (cygwin_internal): Handle new CW_SETENT, CW_GETENT and
	CW_ENDENT info types.
	* grp.cc (setgrent_filtered): New function, called from cygwin_internal.
	(getgrent_filtered): Ditto.
	(endgrent_filtered): Ditto.
	* passwd.cc (pg_ent::setent): Set state explicitely to from_cache.
	(pg_ent::getent): Handle the fact that a DC has no SAM and enumerating
	local accounts is equivalent to enumerating domain accounts.
	(setpwent_filtered): New function, called from cygwin_internal.
	(getpwent_filtered): Ditto.
	(endpwent_filtered): Ditto.
	* pwdgrp.h (setpwent_filtered): Declare.
	(getgrent_filtered): Ditto.
	(endgrent_filtered): Ditto.
	(setpwent_filtered): Ditto.
	(getpwent_filtered): Ditto.
	(endpwent_filtered): Ditto.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_SETENT, CW_GETENT,
	and CW_ENDENT.
@
text
@d573 1
a573 1
  if (grpsid.getfromgr (grp))
d629 1
a629 1
  *ngroups = cnt;
@


1.124
log
@	* autoload.cc (ldap_abandon): Import.
	(ldap_result): Import.
	(ldap_searchW): Import.
	(NetGroupEnum): Import.
	(NetLocalGroupEnum): Import.
	(NetUserEnum): Import.
	* cygheap.h (class cygheap_pwdgrp): Add members enums and enum_tdoms.
	(cygheap_pwdgrp::nss_db_enums): New inline method.
	(cygheap_pwdgrp::nss_db_enum_tdoms): Ditto.
	* cygtls.h (struct _local_storage): Drop unused members pw_pos and
	grp_pos.
	* grp.cc (grent): New static variable of class gr_ent.
	(gr_ent::enumerate_caches): New method.
	(gr_ent::enumerate_local): New method.
	(gr_ent::getgrent): New method.
	(setgrent): Call gr_ent method.
	(getgrent32): Ditto.
	(endgrent): Ditto.
	* ldap.cc (sid_attr): Rename from nfs_attr.
	(cyg_ldap::close): Abandon still running asynchronous search.
	(cyg_ldap::fetch_ad_account): Reduce filter buffer size.
	(cyg_ldap::enumerate_ad_accounts): New method.
	(cyg_ldap::next_account): New method.
	(cyg_ldap::fetch_posix_offset_for_domain): Reduce filter buffer size.
	(cyg_ldap::fetch_unix_sid_from_ad): Ditto.  Fix return value in case
	no value has been read.
	(cyg_ldap::fetch_unix_name_from_rfc2307): Reduce filter buffer size.
	* ldap.h (class cyg_ldap): Add msg_id member.
	(cyg_ldap::enumerate_ad_accounts): Declare.
	(cyg_ldap::next_account): Declare:
	* passwd.cc (pwent): New static variable of class pw_ent.
	(pg_ent::clear_cache): New method.
	(pg_ent::setent): New method.
	(pg_ent::getent): New method.
	(pg_ent::endent): New method.
	(pg_ent::enumerate_file): New method.
	(pg_ent::enumerate_builtin): New method.
	(pg_ent::enumerate_sam): New method.
	(pg_ent::enumerate_ad): New method.
	(pw_ent::enumerate_caches): New method.
	(pw_ent::enumerate_local): New method.
	(pw_ent::getpwent): New method.
	(setpwent): Call pw_ent method.
	(getpwent): Ditto.
	(endpwent): Ditto.
	* pwdgrp.h (class pwdgrp): Define pg_ent, pw_ent and gr_ent as friend
	classes.
	(pwdgrp::add_account_post_fetch): Declare with extra bool parameter.
	(pwdgrp::file_attr): New inline method.
	(enum nss_enum_t): Define.
	(class pg_ent): Define.
	(class pw_ent): Define.
	(class gr_ent): Define.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (cygheap_pwdgrp::init): Initialize enums and enum_tdoms.
	(cygheap_pwdgrp::nss_init_line): Fix typo in preceeding comment.
	Handle new "db_enum" keyword.
	(pwdgrp::add_account_post_fetch): Take additional `bool lock' parameter
	and acquire pglock before adding element to array if lock is true.
	(pwdgrp::add_account_from_file): Call add_account_post_fetch with lock
	set to true.
	(pwdgrp::add_account_from_windows): Ditto in case of caching.
	(pwdgrp::fetch_account_from_windows): Handle builtin aliases only
	known to the domain controller.  Only call NetLocalGroupGetInfo for
	aliases.
@
text
@d432 22
@


1.123
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d16 1
d27 3
d316 2
a317 5
extern "C" void
endgrent ()
{
  _my_tls.locals.grp_pos = 0;
}
d319 2
a320 2
extern "C" struct group *
getgrent32 ()
d322 1
a322 2
  pwdgrp &grf = cygheap->pg.grp_cache.file;
  if (cygheap->pg.nss_grp_files ())
d324 6
a329 3
      cygheap->pg.grp_cache.file.check_file (true);
      if (_my_tls.locals.grp_pos < grf.cached_groups ())
	return &grf.group ()[_my_tls.locals.grp_pos++].g;
d331 1
a331 1
  if ((cygheap->pg.nss_grp_db ()) && cygheap->pg.nss_db_caching ())
d334 2
a335 2
      if (_my_tls.locals.grp_pos - grf.cached_groups () < grw.cached_groups ())
	return &grw.group ()[_my_tls.locals.grp_pos++ - grf.cached_groups ()].g;
d337 1
d341 73
d427 1
a427 1
setgrent ()
d429 1
a429 1
  _my_tls.locals.grp_pos = 0;
@


1.122
log
@	* grp.cc (get_groups): Convert to void function.
	(initgroups32): Accommodate the aforementioned change.
	(getgrouplist): Ditto.
@
text
@d4 1
a4 1
   2008, 2009, 2011, 2012, 2013 Red Hat, Inc.
a25 1
#include "pwdgrp.h"
a26 2
static group *group_buf;
static pwdgrp gr (group_buf);
d32 3
a34 3
  group &grp = (*group_buf)[curr_lines];
  grp.gr_name = next_str (':');
  if (!*grp.gr_name)
d36 2
a37 4

  grp.gr_passwd = next_str (':');

  if (!next_num (grp.gr_gid))
a38 1

d43 1
a43 2

  grp.gr_mem = &null_ptr;
d46 1
a46 1
      char **namearray = (char **) calloc (n + 1, sizeof (char *));
d51 1
a51 1
	  grp.gr_mem = namearray;
d54 1
a54 1

d58 2
a59 4
/* Cygwin internal */
/* Read in /etc/group and save contents in the group cache */
/* This sets group_in_memory_p to 1 so functions in this file can
   tell that /etc/group has been read in */
d61 1
a61 1
pwdgrp::read_group ()
d63 21
a83 24
  for (int i = 0; i < gr.curr_lines; i++)
    if ((*group_buf)[i].gr_mem != &null_ptr)
      free ((*group_buf)[i].gr_mem);

  load (L"\\etc\\group");

  /* Complete /etc/group in memory if needed */
  if (!internal_getgrgid (myself->gid))
    {
      static char linebuf [200];
      char group_name [UNLEN + 1] = "mkgroup";
      char strbuf[128] = "";
      struct group *gr;

      cygheap->user.groups.pgsid.string (strbuf);
      if ((gr = internal_getgrsid (cygheap->user.groups.pgsid)))
	snprintf (group_name, sizeof (group_name),
		  "passwd/group_GID_clash(%u/%u)", myself->gid, gr->gr_gid);
      if (myself->uid == UNKNOWN_UID)
	strcpy (group_name, "mkpasswd"); /* Feedback... */
      snprintf (linebuf, sizeof (linebuf), "%s:%s:%u:%s",
		group_name, strbuf, myself->gid, cygheap->user.name ());
      debug_printf ("Completing /etc/group: %s", linebuf);
      add_line (linebuf);
d85 10
a94 2
  static char NO_COPY pretty_ls[] = "????????::-1:";
  add_line (pretty_ls);
d97 2
a98 4
muto NO_COPY pwdgrp::pglock;

pwdgrp::pwdgrp (passwd *&pbuf) :
  pwdgrp_buf_elem_size (sizeof (*pbuf)), passwd_buf (&pbuf)
d100 4
a103 3
  read = &pwdgrp::read_passwd;
  parse = &pwdgrp::parse_passwd;
  pglock.init ("pglock");
d106 2
a107 2
pwdgrp::pwdgrp (group *&gbuf) :
  pwdgrp_buf_elem_size (sizeof (*gbuf)), group_buf (&gbuf)
d109 4
a112 3
  read = &pwdgrp::read_group;
  parse = &pwdgrp::parse_group;
  pglock.init ("pglock");
d118 1
a118 1
  char sid_string[128];
d120 15
a134 6
  gr.refresh (false);

  if (sid.string (sid_string))
    for (int i = 0; i < gr.curr_lines; i++)
      if (!strcmp (sid_string, group_buf[i].gr_passwd))
	return group_buf + i;
d139 1
a139 1
internal_getgrgid (gid_t gid, bool check)
d141 1
a141 1
  gr.refresh (check);
d143 15
a157 3
  for (int i = 0; i < gr.curr_lines; i++)
    if (group_buf[i].gr_gid == gid)
      return group_buf + i;
d162 1
a162 1
internal_getgrnam (const char *name, bool check)
d164 1
a164 1
  gr.refresh (check);
d166 17
a182 5
  for (int i = 0; i < gr.curr_lines; i++)
    if (strcasematch (group_buf[i].gr_name, name))
      return group_buf + i;

  /* Didn't find requested group */
d213 1
a213 1
  struct group *tempgr = internal_getgrgid (gid, true);
d243 1
a243 1
  return internal_getgrgid (gid, true);
d267 1
a267 1
  struct group *tempgr = internal_getgrnam (nam, true);
d297 1
a297 1
  return internal_getgrnam (name, true);
d321 13
a333 5
  if (_my_tls.locals.grp_pos == 0)
    gr.refresh (true);
  if (_my_tls.locals.grp_pos < gr.curr_lines)
    return group_buf + _my_tls.locals.grp_pos++;

a354 11
/* Internal function. ONLY USE THIS INTERNALLY, NEVER `getgrent'!!! */
struct group *
internal_getgrent (int pos)
{
  gr.refresh (false);

  if (pos < gr.curr_lines)
    return group_buf + pos;
  return NULL;
}

d356 1
a356 1
internal_getgroups (int gidsetsize, gid_t *grouplist, cygpsid * srchsid)
d362 1
a362 1
  struct group *gr;
d366 9
a374 14
      cygsid sid;
      for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
	if (sid.getfromgr (gr))
	  for (int pg = 0; pg < cygheap->user.groups.sgsids.count (); ++pg)
	    if (sid == cygheap->user.groups.sgsids.sids[pg]
		&& sid != well_known_world_sid)
	      {
		if (cnt < gidsetsize)
		  grouplist[cnt] = gr->gr_gid;
		++cnt;
		if (gidsetsize && cnt > gidsetsize)
		  goto error;
		break;
	      }
a377 1

d402 7
a408 5
	    for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
	      if (sid.getfromgr (gr))
		for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
		  if (sid == groups->Groups[pg].Sid
		      && (groups->Groups[pg].Attributes
d410 8
a417 8
		      && sid != well_known_world_sid)
		    {
		      if (cnt < gidsetsize)
			grouplist[cnt] = gr->gr_gid;
		      ++cnt;
		      if (gidsetsize && cnt > gidsetsize)
			goto error;
		      break;
d419 2
d470 1
a470 1
  struct group *gr = internal_getgrgid (gid);
d474 1
a474 1
  if (grpsid.getfromgr (gr))
d509 1
a509 1
  struct group *gr;
d522 1
a522 1
    if ((gr = internal_getgrsid (tmp_gsids.sids[i])) != NULL)
d525 1
a525 1
	  groups[cnt] = gr->gr_gid;
d549 1
a549 1
  struct group *gr;
d556 2
a557 2
      if ((gr = internal_getgrgid (grouplist[gidx]))
	  && gsids.addfromgr (gr))
@


1.122.2.1
log
@* grp.cc (getgrouplist): Fix previous fix so ret is only set to ngroups if
ngroups isn't too small.
* grp.cc (get_groups): Don't add gid to list if it's ILLEGAL_GID.
(getgrouplist): Return number of groups, just like glibc.
@
text
@d450 1
a450 1
  if (gid != ILLEGAL_GID && grpsid.getfromgr (gr))
a503 1
  *ngroups = cnt;
d506 1
a506 2
  else
    ret = cnt;
@


1.122.2.2
log
@Add more missing patches
@
text
@d504 1
a508 1
  *ngroups = cnt;
@


1.121
log
@	* grp.cc (get_groups): Never return error.  Always create a group list,
	even if it's empty.
@
text
@d441 1
a441 1
static int
a452 1
  return 0;
a457 2
  int ret;

d460 8
a467 10
  if (!(ret = get_groups (user, gid, tmp_gsids)))
    {
      cygsidlist new_gsids (cygsidlist_alloc, tmp_gsids.count ());
      for (int i = 0; i < tmp_gsids.count (); i++)
	new_gsids.sids[i] = tmp_gsids.sids[i];
      new_gsids.count (tmp_gsids.count ());
      cygheap->user.groups.update_supp (new_gsids);
    }
  syscall_printf ( "%d = initgroups(%s, %u)", ret, user, gid);
  return ret;
d483 3
a485 1
  int ret;
d496 12
a507 17
  if (!(ret = get_groups (user, gid, tmp_gsids)))
    {
      int cnt = 0;
      for (int i = 0; i < tmp_gsids.count (); i++)
	{
	  struct group *gr = internal_getgrsid (tmp_gsids.sids[i]);
	  if (gr)
	    {
	      if (groups && cnt < *ngroups)
		groups[cnt] = gr->gr_gid;
	      ++cnt;
	    }
	}
      if (cnt > *ngroups)
	ret = -1;
      *ngroups = cnt;
    }
@


1.120
log
@	* Merge in cygwin-64bit-branch.
@
text
@a443 2
  int ret = -1;

d448 4
a451 7
  if (!usersid.getfrompw (pw) || !grpsid.getfromgr (gr))
    set_errno (EINVAL);
  else if (get_server_groups (gsids, usersid, pw))
    {
      gsids += grpsid;
      ret = 0;
    }
d453 1
a453 1
  return ret;
@


1.119
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d4 1
a4 1
   2008, 2009, 2011, 2012 Red Hat, Inc.
d28 1
a28 1
static __group32 *group_buf;
d30 1
a30 1
static char * NO_COPY null_ptr;
d35 1
a35 1
  __group32 &grp = (*group_buf)[curr_lines];
d84 1
a84 1
      struct __group32 *gr;
d89 1
a89 1
		  "passwd/group_GID_clash(%lu/%lu)", myself->gid, gr->gr_gid);
d92 1
a92 1
      snprintf (linebuf, sizeof (linebuf), "%s:%s:%lu:%s",
d111 1
a111 1
pwdgrp::pwdgrp (__group32 *&gbuf) :
d119 1
a119 1
struct __group32 *
d133 2
a134 2
struct __group32 *
internal_getgrgid (__gid32_t gid, bool check)
d144 1
a144 1
struct __group32 *
d157 1
d159 1
a159 1
grp32togrp16 (struct __group16 *gp16, struct __group32 *gp32)
d173 1
d176 2
a177 2
getgrgid_r (__gid32_t gid, struct __group32 *grp, char *buffer, size_t bufsize,
	    struct __group32 **result)
d184 1
a184 1
  struct __group32 *tempgr = internal_getgrgid (gid, true);
d211 2
a212 2
extern "C" struct __group32 *
getgrgid32 (__gid32_t gid)
d217 3
d227 1
d230 2
a231 2
getgrnam_r (const char *nam, struct __group32 *grp, char *buffer,
	    size_t bufsize, struct __group32 **result)
d238 1
a238 1
  struct __group32 *tempgr = internal_getgrnam (nam, true);
d265 1
a265 1
extern "C" struct __group32 *
d271 3
d281 1
d289 1
a289 1
extern "C" struct __group32 *
d300 3
d310 1
d319 1
a319 1
struct __group32 *
d330 1
a330 1
internal_getgroups (int gidsetsize, __gid32_t *grouplist, cygpsid * srchsid)
d336 1
a336 1
  struct __group32 *gr;
d400 1
a400 1
    debug_printf ("%lu = NtQueryInformationToken(NULL) %p", size, status);
d409 1
a409 1
getgroups32 (int gidsetsize, __gid32_t *grouplist)
d414 3
d420 1
a420 1
  __gid32_t *grouplist32 = NULL;
d428 1
a428 1
    grouplist32 = (__gid32_t *) alloca (gidsetsize * sizeof (__gid32_t));
d438 1
d448 1
a448 1
  struct __group32 *gr = internal_getgrgid (gid);
d462 1
a462 1
initgroups32 (const char *user, __gid32_t gid)
d480 3
d488 1
d509 1
a509 1
	  struct __group32 *gr = internal_getgrsid (tmp_gsids.sids[i]);
d528 1
a528 1
setgroups32 (int ngroups, const __gid32_t *grouplist)
d538 1
a538 1
  struct __group32 *gr;
d548 1
a548 1
      debug_printf ("No sid found for gid %d", grouplist[gidx]);
d557 3
d563 1
a563 1
  __gid32_t *grouplist32 = NULL;
d567 1
a567 1
      grouplist32 = (__gid32_t *) alloca (ngroups * sizeof (__gid32_t));
d575 1
@


1.118
log
@	* grp.cc (pwdgrp::parse_group): Convert grp from macro to reference.
	* passwd.cc (pwdgrp::parse_passwd): Ditto for res.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2011, 2012 Red Hat, Inc.
@


1.118.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d28 1
a28 1
static group *group_buf;
d35 1
a35 1
  group &grp = (*group_buf)[curr_lines];
d84 1
a84 1
      struct group *gr;
d89 1
a89 1
		  "passwd/group_GID_clash(%u/%u)", myself->gid, gr->gr_gid);
d92 1
a92 1
      snprintf (linebuf, sizeof (linebuf), "%s:%s:%u:%s",
d111 1
a111 1
pwdgrp::pwdgrp (group *&gbuf) :
d119 1
a119 1
struct group *
d133 2
a134 2
struct group *
internal_getgrgid (gid_t gid, bool check)
d144 1
a144 1
struct group *
a156 1
#ifndef __x86_64__
d158 1
a158 1
grp32togrp16 (struct __group16 *gp16, struct group *gp32)
a171 1
#endif
d174 2
a175 2
getgrgid_r (gid_t gid, struct group *grp, char *buffer, size_t bufsize,
	    struct group **result)
d182 1
a182 1
  struct group *tempgr = internal_getgrgid (gid, true);
d209 2
a210 2
extern "C" struct group *
getgrgid32 (gid_t gid)
a214 3
#ifdef __x86_64__
EXPORT_ALIAS (getgrgid32, getgrgid)
#else
a221 1
#endif
d224 2
a225 2
getgrnam_r (const char *nam, struct group *grp, char *buffer,
	    size_t bufsize, struct group **result)
d232 1
a232 1
  struct group *tempgr = internal_getgrnam (nam, true);
d259 1
a259 1
extern "C" struct group *
a264 3
#ifdef __x86_64__
EXPORT_ALIAS (getgrnam32, getgrnam)
#else
a271 1
#endif
d279 1
a279 1
extern "C" struct group *
a289 3
#ifdef __x86_64__
EXPORT_ALIAS (getgrent32, getgrent)
#else
a296 1
#endif
d305 1
a305 1
struct group *
d316 1
a316 1
internal_getgroups (int gidsetsize, gid_t *grouplist, cygpsid * srchsid)
d322 1
a322 1
  struct group *gr;
d395 1
a395 1
getgroups32 (int gidsetsize, gid_t *grouplist)
a399 3
#ifdef __x86_64__
EXPORT_ALIAS (getgroups32, getgroups)
#else
d403 1
a403 1
  gid_t *grouplist32 = NULL;
d411 1
a411 1
    grouplist32 = (gid_t *) alloca (gidsetsize * sizeof (gid_t));
a420 1
#endif
d430 1
a430 1
  struct group *gr = internal_getgrgid (gid);
d444 1
a444 1
initgroups32 (const char *user, gid_t gid)
a461 3
#ifdef __x86_64__
EXPORT_ALIAS (initgroups32, initgroups)
#else
a466 1
#endif
d487 1
a487 1
	  struct group *gr = internal_getgrsid (tmp_gsids.sids[i]);
d506 1
a506 1
setgroups32 (int ngroups, const gid_t *grouplist)
d516 1
a516 1
  struct group *gr;
a534 3
#ifdef __x86_64__
EXPORT_ALIAS (setgroups32, setgroups)
#else
d538 1
a538 1
  gid_t *grouplist32 = NULL;
d542 1
a542 1
      grouplist32 = (gid_t *) alloca (ngroups * sizeof (gid_t));
a549 1
#endif
@


1.118.2.2
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d400 1
a400 1
    debug_printf ("%u = NtQueryInformationToken(NULL) %y", size, status);
d548 1
a548 1
      debug_printf ("No sid found for gid %u", grouplist[gidx]);
@


1.118.2.3
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2011, 2012 Red Hat, Inc.
@


1.118.2.4
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d4 1
a4 1
   2008, 2009, 2011, 2012, 2013 Red Hat, Inc.
d30 1
a30 1
static char * NO_COPY_RO null_ptr;
@


1.117
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2011 Red Hat, Inc.
d35 1
a35 1
# define grp (*group_buf)[curr_lines]
a62 1
# undef grp
@


1.116
log
@	* cygwin.din (getgrouplist): Export.
	* grp.cc (get_groups): New static function to run the core functionality
	of initgroups and getgrouplist.
	(initgroups32): Call get_groups and just create supplementary group
	list in cygheap.  Rename name of first argument to "user".  Add an
	assertion to test for a NULL user name.
	(initgroups): Rename name of first argument to "user".
	(getgrouplist): New function.
	* posix.sgml (std-bsd): Add getgrouplist.
	* include/cygwin/grp.h (getgrouplist): Declare.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d459 1
a459 1
  syscall_printf ( "%d = initgroups (%s, %u)", ret, user, gid);
d500 1
a500 1
  syscall_printf ( "%d = getgrouplist (%s, %u, %p, %d)",
@


1.115
log
@whitespace elimination
@
text
@d16 1
d423 3
a425 2
extern "C" int
initgroups32 (const char *name, __gid32_t gid)
d430 1
a430 1
  struct passwd *pw = internal_getpwnam (name);
d435 1
a435 1
  else
d437 2
a438 11
      cygsidlist tmp_gsids (cygsidlist_auto, 12);
      if (get_server_groups (tmp_gsids, usersid, pw))
	{
	  tmp_gsids += grpsid;
	  cygsidlist new_gsids (cygsidlist_alloc, tmp_gsids.count ());
	  for (int i = 0; i < tmp_gsids.count (); i++)
	    new_gsids.sids[i] = tmp_gsids.sids[i];
	  new_gsids.count (tmp_gsids.count ());
	  cygheap->user.groups.update_supp (new_gsids);
	  ret = 0;
	}
a440 1
  syscall_printf ( "%d = initgroups (%s, %u)", ret, name, gid);
d445 1
a445 1
initgroups (const char *name, __gid16_t gid)
d447 56
a502 1
  return initgroups32 (name, gid16togid32(gid));
@


1.114
log
@	* advapi32.cc (GetTokenInformation): Remove.
	(SetTokenInformation): Remove.
	* grp.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_auth.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d349 1
a349 1
  
@


1.113
log
@	* grp.cc (getgrgid_r): Simplify code by using stpcpy.
	(getgrnam_r): Ditto.
	* passwd.cc (getpwuid_r32): Simplify code by using stpcpy.
	(getpwnam_r): Ditto.
@
text
@d4 1
a4 1
   2007, 2008, 2009 Red Hat, Inc.
d24 1
d318 1
d320 1
a320 1
  DWORD size;
d349 3
a351 3

  if (GetTokenInformation (hToken, TokenGroups, NULL, 0, &size)
      || GetLastError () == ERROR_INSUFFICIENT_BUFFER)
d355 3
a357 1
      if (GetTokenInformation (hToken, TokenGroups, groups, size, &size))
d386 1
a386 1
    debug_printf ("%d = GetTokenInformation(NULL) %E", size);
@


1.112
log
@	* grp.cc (pwdgrp::read_group): Generate more speaking group name
	if passwd gid exists under different gid in /etc/group.
@
text
@d4 1
a4 1
   2007 Red Hat, Inc.
d198 4
a201 4
  grp->gr_name = buffer;
  grp->gr_passwd = grp->gr_name + strlen (tempgr->gr_name) + 1;
  grp->gr_mem = (char **) (grp->gr_passwd + strlen (tempgr->gr_passwd) + 1);
  char *mem = (char *) grp->gr_mem + (i + 1) * sizeof (char *);
d203 1
a203 4
    {
      grp->gr_mem[i] = mem;
      mem += strlen (tempgr->gr_mem[i]) + 1;
    }
a204 4
  strcpy (grp->gr_name, tempgr->gr_name);
  strcpy (grp->gr_passwd, tempgr->gr_passwd);
  for (i = 0; tempgr->gr_mem[i]; ++i)
    strcpy (grp->gr_mem[i], tempgr->gr_mem[i]);
d248 4
a251 4
  grp->gr_name = buffer;
  grp->gr_passwd = grp->gr_name + strlen (tempgr->gr_name) + 1;
  grp->gr_mem = (char **) (grp->gr_passwd + strlen (tempgr->gr_passwd) + 1);
  char *mem = (char *) grp->gr_mem + (i + 1) * sizeof (char *);
d253 1
a253 4
    {
      grp->gr_mem[i] = mem;
      mem += strlen (tempgr->gr_mem[i]) + 1;
    }
a254 4
  strcpy (grp->gr_name, tempgr->gr_name);
  strcpy (grp->gr_passwd, tempgr->gr_passwd);
  for (i = 0; tempgr->gr_mem[i]; ++i)
    strcpy (grp->gr_mem[i], tempgr->gr_mem[i]);
@


1.111
log
@	* shared.cc (user_shared_initialize): Fetch potentially changed Cygwin
	username from /etc/passwd before loading mount table.
	(shared_info::init_installation_root): New function fetching Cygwin's
	installation root dir and storing as native NT path in global shared
	memory.
	(shared_info::initialize): Call init_installation_root exactly once at
	first startup.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add installation_root member.
	(shared_info::init_installation_root): Declare.

	* grp.cc (pwdgrp::read_group): Call pwdgrp::load with native WCHAR path.
	* passwd.cc (pwdgrp::read_passwd): Ditto.  Avoid recursion.
	(etc::init): Take POBJECT_ATTRIBUTES instead of path_conv.
	* path.h (etc::init): Change prototype accordingly.
	* pwdgrp.h (class pwdgrp): Store path as UNICODE_STRING/PWCHAR instead
	of as path_conv.
	(pwdgrp::load): Accommodate prototype.
	* uinfo.cc (pwdgrp::load): Change argument type from char to wchar_t.
	Create native NT path here instead of calling path_conv.

	* mount.cc (find_root_from_cygwin_dll): Drop in favor of global
	initializaion in shared_info.
	(mount_info::init): Fetch native NT root dir from cygwin_shared.
	(mount_info::from_fstab): Expect native NT path and use native NT
	functions to access file.  Convert username part in user fstab path
	according to special char transformation rules.
	* path.cc (tfx_chars): Convert slash to backslash.
	(transform_chars): Implement for path given as PWCHAR.
	(transform_chars): PUNICODE_STRING version calls PWCHAR version.
	Remove useless commented code.
@
text
@d87 2
a88 1
	strlcpy (group_name, gr->gr_name, sizeof (group_name));
@


1.110
log
@	* autoload.cc (DsGetDcNameW): Replace DsGetDcNameA.
	* dcrt0.cc (child_info_spawn::handle_spawn): Drop artificial
	supplementary group list from calling setgroups in parent.
	* grp.cc (internal_getgroups): Drop 9x-only code.  Reformat.
	* sec_auth.cc (get_logon_server): Do everything in WCHAR only.
	(get_user_groups): Ditto.  Use wlogonserver in LookupAccountNameW
	calls, too.
	(is_group_member): Get logon server as first argument and use in call
	to NetLocalGroupGetMembers.
	(get_user_local_groups): Get logon server as first argument and use in
	calls to NetLocalGroupEnum and LookupAccountNameW.  Revamp to work
	more correctly in domain environments.
	(get_server_groups): Accommodate aforementioned changed function calls.
	* security.h (get_logon_server): Change prototype accordingly.
	* uinfo.cc (cygheap_user::env_logsrv): Accommodate changed
	get_logon_server call.
@
text
@d75 1
a75 1
  load ("/etc/group");
@


1.109
log
@	* grp.cc (internal_getgroups): Also add integrity-enabled groups.
@
text
@a333 2
  __gid32_t gid;
  const char *username;
d341 2
a342 2
	    if (sid == cygheap->user.groups.sgsids.sids[pg] &&
		sid != well_known_world_sid)
d361 2
a362 1
  if (hToken)
d364 3
a366 2
      if (GetTokenInformation (hToken, TokenGroups, NULL, 0, &size)
	  || GetLastError () == ERROR_INSUFFICIENT_BUFFER)
d368 1
a368 1
	  PTOKEN_GROUPS groups = (PTOKEN_GROUPS) alloca (size);
d370 1
a370 1
	  if (GetTokenInformation (hToken, TokenGroups, groups, size, &size))
d372 18
a389 6
	      cygsid sid;

	      if (srchsid)
		{
		  for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
		    if ((cnt = (*srchsid == groups->Groups[pg].Sid)))
d391 1
a391 18
		}
	      else
		for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
		  if (sid.getfromgr (gr))
		    for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
		      if (sid == groups->Groups[pg].Sid
			  && (groups->Groups[pg].Attributes
			      & (SE_GROUP_ENABLED | SE_GROUP_INTEGRITY_ENABLED))
			  && sid != well_known_world_sid)
			{
			  if (cnt < gidsetsize)
			    grouplist[cnt] = gr->gr_gid;
			  ++cnt;
			  if (gidsetsize && cnt > gidsetsize)
			    goto error;
			  break;
			}
	    }
a392 3
      else
	debug_printf ("%d = GetTokenInformation(NULL) %E", size);
      return cnt;
d394 2
a395 22

  gid = myself->gid;
  username = cygheap->user.name ();
  for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
    if (gid == gr->gr_gid)
      {
	if (cnt < gidsetsize)
	  grouplist[cnt] = gr->gr_gid;
	++cnt;
	if (gidsetsize && cnt > gidsetsize)
	  goto error;
      }
    else if (gr->gr_mem)
      for (int gi = 0; gr->gr_mem[gi]; ++gi)
	if (strcasematch (username, gr->gr_mem[gi]))
	  {
	    if (cnt < gidsetsize)
	      grouplist[cnt] = gr->gr_gid;
	    ++cnt;
	    if (gidsetsize && cnt > gidsetsize)
	      goto error;
	  }
@


1.108
log
@	* grp.cc (internal_getgroups): Fix thinko.  Only add enabled groups to
	the group list.
@
text
@d385 2
a386 1
			  && (groups->Groups[pg].Attributes & SE_GROUP_ENABLED)
@


1.107
log
@	* grp.cc (internal_getgroups): Don't add deny-only groups to the group
	list.
@
text
@d385 1
a385 2
			  && !(groups->Groups[pg].Attributes
			       & SE_GROUP_USE_FOR_DENY_ONLY)
@


1.106
log
@	* grp.cc (internal_getgroups): Drop local buf.  Allocate groups
	directly using alloca.
@
text
@d384 4
a387 2
		      if (sid == groups->Groups[pg].Sid &&
			  sid != well_known_world_sid)
@


1.105
log
@Remove unneeded header files from source files throughout.
@
text
@d368 1
a368 2
	  char buf[size];
	  TOKEN_GROUPS *groups = (TOKEN_GROUPS *) buf;
d370 1
a370 1
	  if (GetTokenInformation (hToken, TokenGroups, buf, size, &size))
@


1.104
log
@	* cygheap.h (cygheap_user::curr_imp_token): Rename from current_token.
	Accommodate changge throughout Cygwin.
	(cygheap_user::imp_token): Rename from token.  Accommodate changge
	throughout Cygwin.
	(rcygheap_user::eimpersonate): Use primary token for impersonation.
	* grp.cc (internal_getgroups): Use primary impersonation token when
	impersonated.
	* security.h (_push_thread_privilege): Use primary impersonation token
	when impersonated.
@
text
@a15 2
#include <grp.h>
#include <wininet.h>
a19 1
#include "security.h"
a24 1
#include "cygtls.h"
@


1.103
log
@	Throughout remove all usage of wincap.has_security.
	* environ.cc (environ_init): Drop setting allow_ntsec here.
	* grp.cc (initgroups32): Drop usage of label "out".
	* security.cc (allow_ntsec): Set to true by default.
	* syscalls.cc (seteuid32): Remove label success_9x.
	* wincap.cc: Remove has_security throughout.
	* wincap.h: Ditto.
@
text
@d363 1
a363 1
    hToken = cygheap->user.token ();
@


1.102
log
@	Partially revert change from 2005-04-03, always running under an
	impersonation token, which collides with Vista UAC.
	* cygheap.h (deimpersonate): revert to self instead of impersonating
	hProcImpToken.
	(reimpersonate): Only impersonate if setuid.
	* dcrt0.cc (dll_crt0_0): Don't initialize hProcImpToken here.
	(dll_crt0_1): Set privileges on hProcToken.
	* fork.cc (frok::child): Set privileges on hProcToken.  Close handle to
	hProcImpToken.
	* grp.cc (internal_getgroups): Use hProcToken instead of hProcImpToken.
	* security.cc (check_access): Create hProcImpToken on demand here.
	* security.h (set_process_privilege): Set privileges on hProcToken.
	(_push_thread_privilege): Use hProcToken instead of hProcImpToken.
	(pop_thread_privilege): If not setuid'ed, revert to self.
	* syscalls.cc (setegid32): Drop setting primary group on hProcImpToken.
	Close handle to hProcImpToken.
	* uinfo.cc (internal_getlogin): Ditto.
	* winsup.h (clear_procimptoken): New inline function.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005
   Red Hat, Inc.
d87 1
d89 3
a91 8
      if (wincap.has_security ())
	{
	  struct __group32 *gr;

	  cygheap->user.groups.pgsid.string (strbuf);
	  if ((gr = internal_getgrsid (cygheap->user.groups.pgsid)))
	    strlcpy (group_name, gr->gr_name, sizeof (group_name));
	}
d100 1
a100 2
  if (wincap.has_security ())
    add_line (pretty_ls);
d465 9
a473 2
  int ret;
  if (wincap.has_security ())
d475 2
a476 6
      ret = -1;
      cygheap->user.deimpersonate ();
      struct passwd *pw = internal_getpwnam (name);
      struct __group32 *gr = internal_getgrgid (gid);
      cygsid usersid, grpsid;
      if (!usersid.getfrompw (pw) || !grpsid.getfromgr (gr))
d478 7
a484 2
	  set_errno (EINVAL);
	  goto out;
d486 2
a487 15
      cygsidlist tmp_gsids (cygsidlist_auto, 12);
      if (!get_server_groups (tmp_gsids, usersid, pw))
	goto out;
      tmp_gsids += grpsid;
      cygsidlist new_gsids (cygsidlist_alloc, tmp_gsids.count ());
      for (int i = 0; i < tmp_gsids.count (); i++)
	new_gsids.sids[i] = tmp_gsids.sids[i];
      new_gsids.count (tmp_gsids.count ());
      cygheap->user.groups.update_supp (new_gsids);
    }
  ret = 0;

 out:
  if (wincap.has_security ())
    cygheap->user.reimpersonate ();
a508 3
  if (!wincap.has_security ())
    return 0;

@


1.101
log
@	* cyglsa.h: New header file.
	* environ.cc: Disable subauth settings.
	* grp.cc: Accomodate cygsidlist's count now being a method.
	* sec_helper.cc (SECURITY_MANDATORY_INTEGRITY_AUTHORITY): Remove.
	(mandatory_medium_integrity_sid): Remove.
	(mandatory_high_integrity_sid): Remove.
	(mandatory_system_integrity_sid): Remove.
	(fake_logon_sid): Add.
	(cygsid::get_sid): Add well_known parameter.  Set well_known_sid
	accordingly.
	(cygsid::getfromstr): Ditto.
	(cygsidlist::alloc_sids): Move here from security.cc.
	(cygsidlist::free_sids): Ditto.
	(cygsidlist::add): Move here from security.h.  Add well_known parameter.
	Set well_known_sid accordingly.  Don't allow duplicate SIDs.
	* security.cc: Include cyglsa.h and cygwin/version.h.  Throughout
	accomodate cygsidlist's count now being a method.  Throughout drop
	redundant "contains" tests.
	(get_user_local_groups): Add local groups as well known SIDs.
	(get_token_group_sidlist): Add well known groups as well known SIDs.
	(get_server_groups): Ditto.  Only call get_unix_group_sidlist after
	get_user_local_groups to maintain "well_known_sid" attribute.
	(get_initgroups_sidlist): Add well known groups as well known SIDs.
	(get_setgroups_sidlist): Add usersid and struct passwd parameter to
	allow calling get_server_groups from here.
	(get_system_priv_list): Make static.  Return size of TOKEN_PRIVILEGES
	structure.
	(get_priv_list): Ditto.
	(create_token): Accomodate above changes.  Drop misguided attempt to
	add MIC SIDs to created user token.  Print returned token as hex value.
	(subauth): Disable.
	(lsaauth): New function implementing client side of LSA authentication.
	* security.h (class cygsid): Add well_known_sid attribute.  Accomodate
	throughout.  Add *= operator to create a well known SID.
	(class cygsidlist): Rename count to cnt.  Make count a method.
	(cygsidlist::add): Move to sec_helper.cc.
	(cygsidlist::operator *=): New method to add well known SID.
	(cygsidlist::non_well_known_count): New method returning number of
	non well known SIDs in list.
	(cygsidlist::next_non_well_known_sid): New method returning next non
	well known SID by index.
	(mandatory_medium_integrity_sid): Drop declaration.
	(mandatory_high_integrity_sid): Drop declaration.
	(mandatory_system_integrity_sid): Drop declaration.
	(fake_logon_sid): Add declaration.
	(subauth): Disable declaration.
	(lsaauth): Add declaration.
	* syscalls.cc (seteuid32): Disable subauthentication.  Add LSA
	authentication.
	* wincap.h: Define needs_logon_sid_in_sid_list throughout.
	* wincap.cc: Ditto.
@
text
@d370 1
a370 1
    hToken = hProcImpToken;
@


1.100
log
@	* grp.cc (initgroups32): Run get_server_groups under original token.
	* syscalls.cc (seteuid32): Slightly reorganize code creating a token.
@
text
@d351 1
a351 1
	  for (int pg = 0; pg < cygheap->user.groups.sgsids.count; ++pg)
d487 2
a488 2
      cygsidlist new_gsids (cygsidlist_alloc, tmp_gsids.count);
      for (int i = 0; i < tmp_gsids.count; i++)
d490 1
a490 1
      new_gsids.count = tmp_gsids.count;
@


1.99
log
@Remove some more unneeded 'return;'s throughout.
@
text
@d474 1
d496 2
@


1.99.8.1
log
@	* grp.cc (initgroups32): Run get_server_groups under original token.
@
text
@a473 1
      cygheap->user.deimpersonate ();
a494 2
  if (wincap.has_security ())
    cygheap->user.reimpersonate ();
@


1.98
log
@	* grp.cc (initgroups32): Return the correct value.
@
text
@a105 1
  return;
@


1.97
log
@	* security.h (cygsidlist::addfromgr): Allow duplicate entries.
	(get_server_groups): Declare new function.
	* security.cc (is_group_member): Simplify.
	(get_server_groups): New function.
	(get_initgroups_sidlist): Call get_server_groups.
	(verify_token): Allow token when supplementary sids are not in
	/etc/group but are in the token.
	Streamline the code.
	* grp.cc (initgroups32): New implementation.
	(getgroups32): Handle case where the supplementary groups are set.
@
text
@d497 1
a497 1
  return 0;
@


1.96
log
@	* security.h (cygsidlist::addfromgr): Avoid duplicate entries.
	* grp.cc (initgrousp): Add syscall_printf.
	(setgroups): Add syscall_printf and make sure sids are added only once.
@
text
@d347 1
a347 1
  if (allow_ntsec)
d349 15
a363 5
      /* If impersonated, use impersonation token. */
      if (cygheap->user.issetuid ())
	hToken = cygheap->user.token ();
      else
        hToken = hProcImpToken;
d365 8
d471 1
d473 24
a496 2
    cygheap->user.groups.clear_supp ();
  syscall_printf ( "0 = initgroups (%s, %u)", name, gid);
@


1.95
log
@* sync.h (muto::initforce): Delete flawed implementation.
* pwdgrp.h (pwdgrp::pglock): Make static.
* grp.cc (pwdgrp::pwdgrp): Eliminate use of initforce.
@
text
@d451 1
a451 1
initgroups32 (const char *, __gid32_t)
d455 1
d460 1
a460 1
initgroups (const char * name, __gid16_t gid)
d469 1
d487 3
a489 6
      for (int gidy = 0; gidy < gidx; gidy++)
	if (grouplist[gidy] == grouplist[gidx])
	  goto found; /* Duplicate */
      if ((gr = internal_getgrgid (grouplist[gidx])) &&
	  gsids.addfromgr (gr))
	goto found;
a493 2
    found:
      continue;
@


1.94
log
@* sync.h (muto::initforce): Force initialization even when name != NULL.
* grp.cc (pwdgrp::pwdgrp): Use initforce since the enclosing structure is
!NO_COPY.
@
text
@d109 2
d116 1
a116 1
  pglock.initforce ("pwd_lock");
d124 1
a124 1
  pglock.initforce ("grp_lock");
@


1.93
log
@* sync.h (muto::operator int): New operator.
(locker): Remove unused class.
(new_muto): Delete.
(new_muto1): Ditto.
(new_muto_name): Ditto.
* cygheap.cc (cygheap_setup_for_child): Reflect use of static storage for muto
rather than pointer.
(_csbrk): Ditto.
(_cmalloc): Ditto.
(_cmalloc): Ditto.
(_cfree): Ditto.
* cygheap.h (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_drive): Ditto.
* cygmalloc.h (__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* cygtls.cc (sentry::lock): Ditto.
(sentry::sentry): Ditto.
(~sentry): Ditto.
(_cygtls::init): Ditto.
* dcrt0.cc: Ditto.
(cygwin_atexit): Ditto.
(cygwin_exit): Ditto.
* debug.cc (lock_debug::locker): Ditto.
(lock_debug::lock_debug): Ditto.
(lock_debug::unlock): Ditto.
(debug_init): Ditto.
* dtable.cc (dtable::init_lock): Ditto.
* dtable.h (dtable::lock_cs): Ditto.
(dtable::lock): Ditto.
(dtable::unlock): Ditto.
* exceptions.cc (mask_sync): Ditto.
(sighold): Ditto.
(set_process_mask_delta): Ditto.
(set_signal_mask): Ditto.
(events_init): Ditto.
* grp.cc (pwdgrp::pwdgrp): Ditto.
* malloc_wrapper.cc (mallock): Ditto.
(malloc_init): Ditto.
* path.cc (cwdstuff::cwd_lock): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::get_hash): Ditto.
(cwdstuff::init): Ditto.
(cwdstuff::set): Ditto.
(cwdstuff::get): Ditto.
* pwdgrp.h (pwdgrp::pglock): Ditto.
(pwdgrp::refresh): Ditto.
* sigproc.cc (sync_proc_subproc): Ditto.
(get_proc_lock): Ditto.
(proc_subproc): Ditto.
(_cygtls::remove_wq): Ditto.
(proc_terminate): Ditto.
(sigproc_init): Ditto.
* timer.cc (lock_timer_tracker::protect): Ditto.
(lock_timer_tracker::lock_timer_tracker): Ditto.
(lock_timer_tracker::~lock_timer_tracker): Ditto.
* wininfo.cc (wininfo::_lock;): Ditto.
(wininfo::winthread): Ditto.
(operator HWND): Ditto.
(wininfo::lock): Ditto.
(wininfo::release): Ditto.
* wininfo.h (wininfo::_lock;): Ditto.
@
text
@d114 1
a114 1
  pglock.init ("pwd_lock");
d122 1
a122 1
  pglock.init ("grp_lock");
@


1.92
log
@	* cygheap.cc (cygheap_init): Accomodate set_process_privilege change.
	* cygheap.h (cygheap_user::curr_primary_token): New member.
	(cygheap_user::primary_token): New method.
	(cygheap_user::deimpersonate): Always revert to processes'
	impersonation token.
	(cygheap_user::reimpersonate): Set processes' or setuid token as
	necessary.
	(cygheap_user::has_impersonation_tokens): Look for curr_primary_token
	value.
	(cygheap_user::close_impersonation_tokens): Close curr_primary_token
	here if necessary.  Don't reset token values to NO_IMPERSONATION since
	that's done in uinfo_init anyway.
	(init_cygheap::luid): New LUID array keeping privilege LUIDs.
	* cygtls.cc (_cygtls::init_thread): Call cygheap->user.reimpersonate.
	* dcrt0.cc (hProcToken): New global variable to keep process token.
	(hProcImpToken): Ditto for process impersonation token.
	(dll_crt0_0): Open process token here once.  Duplicate to create
	hProcImpToken.
	(dll_crt0_1): Call set_cygwin_privileges.
	* environ.cc (allow_ntea): Drop duplicate declaration.
	(allow_smbntsec): Ditto.
	(set_traverse): Only set allow_traverse here.
	(environ_init): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop call to
	enable_restore_privilege.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	* fork.cc (fork_child): Move call to cygheap->user.reimpersonate after
	syn with parent. Call set_cygwin_privileges.
	* grp.cc (internal_getgroups): Use hProcImpToken instead of opening
	process token.
	* path.cc (fs_info::update): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges.
	* registry.cc (load_registry_hive): Drop setting restore privilege
	since it's already set if available.
	* sec_helper.cc: Include cygtls.h.
	(cygpriv): Privilege string array.
	(privilege_luid): New function, evaluate LUID from cygpriv_idx.
	(privilege_luid_by_name): New function, evaluate LUID from privilege
	string.
	(privilege_name): New function, evaluate privilege string from
	cygpriv_idx.
	(set_privilege): New static function called by set_process_privilege
	and set_thread_privilege.  Call privilege_luid to get privilege LUID.
	Fix bug in return value evaluation. Improve debug output.
	(set_cygwin_privileges): New function.
	(set_process_privilege): Remove.
	(enable_restore_privilege): Remove.
	* security.cc (allow_traverse): New global variable.
	(sys_privs): Change type to cygpriv_idx and store privilege indices
	instead of strings.
	(SYSTEM_PRIVILEGES_COUNT): Renamed from SYSTEM_PERMISSION_COUNT.
	(get_system_priv_list): Don't use numerical constant in malloc call.
	Use privilege_luid to get privilege LUIDs.
	(get_priv_list): Call privilege_luid_by_name to get LUIDs. Improve
	inner privilege LUID comparison loop.
	(create_token): Enable create token privilege using
	push/pop_self_privileges. Use hProcToken instead of opening process
	token. Use default DACL when duplicating token.
	(subauth): Enable tcb privilege using push/pop_self_privileges.
	Use sec_none instead of homw made security attributes when duplicating
	token.
	(check_file_access): Don't duplicate access token, use active
	impersonation token as is.
	* security.h (enum cygpriv_idx): New enumeration type enumerating
	possible privileges.
	(privilege_luid): Declare new function.
	(privilege_luid_by_name): Ditto.
	(privilege_name): Ditto.
	(allow_traverse): Declare.
	(set_privilege): Declare function.
	(set_process_privilege): Define as macro.
	(enable_restore_privilege): Remove declaration.
	(_push_thread_privilege): Define macro.
	(push_thread_privilege): Ditto.
	(pop_thread_privilege): Ditto.
	(pop_self_privilege): Ditto.
	* spawn.cc (spawn_guts): Use cygheap->user.primary_token instead of
	cygheap->user.token.
	* syscalls.cc (statvfs): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges. Rearrange code
	to simplify push/pop bracketing.
	(seteuid32): Use hProcToken instead of opening process token. Call
	cygheap->user.deimpersonate instead of RevertToSelf.  Create
	impersonation token from primary internal or external token.  Set
	cygheap->user.curr_primary_token and cygheap->user.current_token
	privileges once here.  Drop "failed" and "failed_ptok" labels.
	Drop setting DefaultDacl of process token.
	(setegid32): Use hProcToken and hProcImpToken instead of opening
	process token. Always reimpersonate afterwards.
	* uinfo.cc (cygheap_user::init): Use hProcToken instead of opening
	process token.
	(internal_getlogin): Ditto. Set hProcImpToken, too.
	(uinfo_init): Initialize cygheap->user.curr_primary_token.
	* winsup.h (hProcToken): Declare.
	(hProcImpToken): Declare.
@
text
@d114 1
a114 1
  new_muto (pglock);
d122 1
a122 1
  new_muto (pglock);
@


1.91
log
@copyright
@
text
@d350 2
a351 2
      else if (!OpenProcessToken (hMainProc, TOKEN_QUERY, &hToken))
	hToken = NULL;
d382 1
a382 5
			    {
			      if (!cygheap->user.issetuid ())
				CloseHandle (hToken);
			      goto error;
			    }
a388 2
      if (!cygheap->user.issetuid ())
	CloseHandle (hToken);
@


1.90
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.89
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d19 1
a24 1
#include "cygerrno.h"
@


1.88
log
@	* grp.cc (getgrgid_r): Replace struct group by struct __group32 in
	argument definition.
	(getgrnam_r): Ditto.
@
text
@d188 1
a188 1
  pthread_testcancel (); 
d245 1
a245 1
  pthread_testcancel (); 
d376 1
a376 1
		        {
@


1.87
log
@	* cygwin.din: Add symbols flockfile, ftrylockfile, funlockfile,
	getgrgid_r, getgrnam_r and getlogin_r.
	* grp.cc (getgrgid_r): New function.
	(getgrnam_r): Ditto.
	* syscalls.cc (flockfile): Ditto.
	(ftrylockfile): Ditto.
	(funlockfile): Ditto.
	* sysconf.cc (sysconf): Return LOGIN_NAME_MAX in case of
	_SC_LOGIN_NAME_MAX.
	* thread.cc (__cygwin_lock_trylock): Define int.  Return value from
	call to pthread_mutex_trylock.
	* uinfo.cc (getlogin_r): New function.
	* include/limits.h: Define LOGIN_NAME_MAX.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/lock.h: Add declarations for __cygwin_lock_xxx functions.
	* include/sys/stdio.h: Add define for _ftrylockfile.
@
text
@d179 2
a180 2
getgrgid_r (__gid32_t gid, struct group *grp, char *buffer, size_t bufsize,
	    struct group **result)
d236 2
a237 2
getgrnam_r (const char *nam, struct group *grp, char *buffer, size_t bufsize,
	    struct group **result)
@


1.86
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d178 43
d233 43
@


1.85
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d27 1
a27 3

/* Position in the group cache */
#define grp_pos _reent_winsup ()->_grp_pos
d209 1
a209 1
  grp_pos = 0;
d215 1
a215 1
  if (grp_pos == 0)
d217 2
a218 2
  if (grp_pos < gr.curr_lines)
    return group_buf + grp_pos++;
d234 1
a234 1
  grp_pos = 0;
@


1.84
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d183 1
a183 1
  return internal_getgrgid (gid, TRUE);
d197 1
a197 1
  return internal_getgrnam (name, TRUE);
@


1.83
log
@	* grp.cc (read_group): Revert previous change.
	* uinfo.cc (pwdgrp::load): Always reset curr_lines.
@
text
@d21 1
a22 1
#include "path.h"
@


1.82
log
@* grp.cc (read_group): Set __group32.gr_mem pointer back to &null_ptr after
free() is called.
@
text
@d78 1
a78 4
      {
        free ((*group_buf)[i].gr_mem);
        (*group_buf)[i].gr_mem = &null_ptr;
      }
@


1.81
log
@	* cygheap.h (enum impersonation): New enum.
	(cygheap_user::token): Delete.
	(cygheap_user::impersonated): Delete.
	(cygheap_user::external_token): New member.
	(cygheap_user::internal_token): New member.
	(cygheap_user::impersonation_state): New member.
	(cygheap_user::issetuid): Modify.
	(cygheap_user::token): New method.
	(cygheap_user::deimpersonate): New method.
	(cygheap_user::reimpersonate): New method.
	(cygheap_user::has_impersonation_tokens): New method.
	(cygheap_user::close_impersonation_tokens): New method.
	* dtable.cc (dtable::vfork_child_dup): Use new cygheap_user methods.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fork.cc (fork_child): Ditto.
	(fork_parent): Ditto.
	* grp.cc (internal_getgroups): Ditto.
	* security.cc (verify_token): Ditto.
	(check_file_access): Ditto.
	(cygwin_set_impersonation_token): Detect conflicts. Set
	user.external_token.
	* spawn.cc (spawn_guts): Use new cygheap_user methods.
	* syscalls.cc (seteuid32): Rearrange to use the two tokens
	in cygheap_user.
	(setegid32): Use new cygheap_user methods.
	* uinfo.cc: (internal_getlogin): Ditto.
@
text
@d78 4
a81 1
      free ((*group_buf)[i].gr_mem);
@


1.80
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d264 1
a264 1
	hToken = cygheap->user.token;
d298 1
a298 1
			      if (hToken != cygheap->user.token)
d308 1
a308 1
      if (hToken != cygheap->user.token)
@


1.79
log
@
* Makefile.in: Add finline-functions optimization to CXXFLAGS.
* autoload.cc (LoadDLLprime): Rename std_dll_init to
_std_dll_init.
(std_dll_init): Remove name mangling prototype. Add attributes
used and noinline.
(wsock_init): Ditto.
Change wsock_init to _wsock_init in wsock32 and ws2_32
LoadDLLprime.
* exceptions.cc (unused_sig_wrapper): Remove prototype. Add
attributes used and noinline.
* pwdgrp.h ((pwdgrp (passwd *&)): Remove inline code.
(pwdgrp (__group32 *&)): Ditto.
* grp.cc (pwdgrp (passwd *&)): Outline constructor.
(pwdgrp (__group32 *&)): Ditto.
@
text
@a18 1
#include <errno.h>
@


1.78
log
@	* grp.cc (internal_getgroups): Handle properly tokens with
	no groups. Fix bug introduced on 2003-02-04.
@
text
@d111 16
@


1.77
log
@	* security.h: Introduce names UNKNOWN_UID and UNKNOWN_GID and delete
	declaration of is_grp_member.
	* uinfo.cc (internal_getlogin): Use UNKNOWN_GID.
	* passwd.cc (pwdgrp::read_passwd): Use UNKNOWN_UID.
	* grp.cc (pwdgrp::read_group): Change group name to provide better
	feedback.
	(getgrgid): Use gid16togid32.
	* sec_helper.cc (is_grp_member): Delete.
@
text
@a269 1
		  cnt = -1;
d295 1
a295 2
      if (cnt)
	return cnt;
@


1.76
log
@	* grp.cc (internal_getgroups): Do not return without closing
	the process handle.
@
text
@d98 2
d176 1
a176 1
  return grp32togrp16 (&g16, getgrgid32 ((__gid32_t) gid));
@


1.75
log
@	* security.h (class cygpsid): New class.
	(class cygsid): Use cygpsid as base. Remove members psid, get_id,
	get_uid, get_gid, string, debug_printf and the == and != operators.
	(cygsidlist::clear_supp): Only do work if setgroups has been called.
	* sec_helper.cc: Define sid_auth NO_COPY.
	(cygpsid::operator==): New operator.
	(cygpsid::get_id): New function.
	(cygpsid::string): New function.
	(cygsid::string): Delete.
	(cygsid::get_id): Delete.
	* pwdgrp.h: Change arguments of internal_getpwsid,
	internal_getgrsid and internal_getgroups to cygpsid.
	* passwd.cc (internal_getpwsid): Change argument from cygsid to cygpsid.
	* grp.cc (internal_getgrsid): Ditto.
	(internal_getgroups): Ditto.
@
text
@d266 3
a268 3
		    if (*srchsid == groups->Groups[pg].Sid)
		      return 1;
		  return 0;
d270 18
a287 17
	      for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
		if (sid.getfromgr (gr))
		  for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
		    if (sid == groups->Groups[pg].Sid &&
			sid != well_known_world_sid)
		      {
			if (cnt < gidsetsize)
			  grouplist[cnt] = gr->gr_gid;
			++cnt;
			if (gidsetsize && cnt > gidsetsize)
			  {
			    if (hToken != cygheap->user.token)
			      CloseHandle (hToken);
			    goto error;
			  }
			break;
		      }
@


1.74
log
@* grp.cc (getgrent32): Only refresh group entries when at beginning.
(internal_getgrsid): Only refresh if uninitialized.
(internal_getgrent): Ditto.
* passwd.cc (getpwent): Only refresh passwd entries when at beginning.
(pwdgrp::read_passwd): linebuf *cannot* be NO_COPY.
(internal_getpwsid): Only refresh if uninitialized.
(getpass): No need to refresh passwd data here.
* pwdgrp.h (refresh): Eliminate default.
@
text
@d110 1
a110 1
internal_getgrsid (cygsid &sid)
d234 1
a234 1
internal_getgroups (int gidsetsize, __gid32_t *grouplist, cygsid * srchsid)
@


1.73
log
@* strings.h (strechr): New function.
* uinfo.cc (pwdgrp::next_str): Search only for input char in string.  Return
EOS on failure.  Don't check for NULL since it shouldn't be possible.
(pwdgrp::add_line): Revert to replacing '\n' in input line with '\0'.
(pwdgrp::next_num): Pass explicit separator character to next_str.
* grp.cc (pwdgrp::parse_group): Ditto.
* passwd.cc (pwdgrp::parse_passwd): Ditto.  Revamp test for garbage input.
* pwdgrp.h (pwdgrp::next_str): Don't use default parameter.
@
text
@d114 1
a114 1
  gr.refresh ();
d200 2
a201 2
  gr.refresh ();

d226 1
a226 1
  gr.refresh ();
@


1.72
log
@* uinfo.cc (pwdgrp::load): Regularize strace output.  Add warning for
CreateFile failure.
@
text
@d40 1
a40 1
  grp.gr_name = next_str ();
d44 1
a44 1
  grp.gr_passwd = next_str ();
@


1.71
log
@* passwd.cc (pwdgrp::parse_passwd): Eliminate use of memset.  The structure
should always be completely filled out.
* grp.cc (pwdgrp::parse_group): Ditto.
* grp.cc (pwdgrp::parse_group): Fix off-by-one problem in allocating
@
text
@d119 1
a119 1
        return group_buf + i;
d247 1
a247 1
        hToken = cygheap->user.token;
d249 1
a249 1
        hToken = NULL;
d264 1
a264 1
	        {
d292 1
a292 1
        CloseHandle (hToken);
@


1.70
log
@* pwdgrp.cc (pwdgrp::parse_group): Fix off-by-one problem in allocating gr_mem.
@
text
@a38 2
  char *dp;

a39 3

  memset (&grp, 0, sizeof (grp));

d50 1
a50 1
  dp = raw_ptr ();
@


1.69
log
@* include/sys/strace.h (paranoid_printf): Define as not being part of "all"
output.
* pwdgrp.h (pwdgrp::next_num): Rename from next_int.  Returns true/false if
parse operation succeeded.
(pwdgrp::reparse): Remove.
(pwdgrp::raw_ptr): New function.  Returns pointer in line.
(pwdgrp::next_num): New functions for parsing other than unsigned long.
* grp.cc (pwdgrp::parse_group): Reinstate previous parsing behavior.  Don't
fill in fields with NULL and assign empty gr_mem to known pointer rather than
doing a pointless calloc.  Streamline gr_mem parsing.  Don't increment
curr_lines here.
* passwd.cc (pwdgrp::parse_passwd): Use new behavior of next_num.  Don't
increment curr_lines here.
* uinfo.cc (pwdgrp::next_str): Keep returning EOL if out of data.
(pwdgrp::reparse): Remove.
(pwdgrp::next_num): Rename from next_int.  Return bool indicating success of
parse, argument returns value parsed.
(pwdgrp::add_line): Increment curr_lines here on successful parse.
(pwdgrp::load): (from Pierre Humblet) Don't return status.  Just report it
here.
@
text
@d62 1
a62 1
      char **namearray = (char **) calloc (n + 2, sizeof (char *));
@


1.68
log
@* pwdgrp.cc (pwdgrp::reparse): Declare.
* uinfo.cc (pwdgrp::reparse): Define.
* grp.cc (pwdgrp::parse_group): Use.
@
text
@d42 1
d44 1
d46 1
a46 1
  if (!grp.gr_name)
d50 11
a60 2
  int n = next_int ();
  if (n >= 0)
d62 1
a62 11
      grp.gr_gid = n;
      dp = next_str ();
      if (!dp)
	{
	  static char empty[] = "";
	  dp = empty;
	}
      int i = 0;
      for (char *cp = dp; (cp = strchr (cp, ',')) != NULL; cp++)
	i++;
      char **namearray = (char **) calloc (i + 2, sizeof (char *));
d65 1
a65 2
	  reparse (dp);
	  for (i = 0; (dp = next_str (',')); i++)
a66 1
	  namearray[i] = NULL;
a68 2
      curr_lines++;
      return true;
d70 2
a71 1
  return false;
d86 1
a86 2
  if (!gr.load ("/etc/group"))
    debug_printf ("gr.load failed");
d106 1
a106 1
      gr.add_line (linebuf);
d110 1
a110 1
    gr.add_line (pretty_ls);
@


1.67
log
@* pwdrp.h (pwdgrp::refresh): Lock entire test prior to reading.
* grp.cc (pwdgrp::parse_group): Eliminate arg and use class member instead.
Use next_str and next_int to parse arguments.
* passwd.cc (pwdgrp::parse_passwd): Ditto.
(grab_string): Eliminate.
(grab_int): Ditto.
* pwdgrp.h (pwdgrp::parse): Eliminate input arg.
(pwdgrp::parse_passwd): Reflect above change.
(pwdgrp::parse_group): Reflect above change.
(pwdgrp::next_str): New function.
(pwdgrp::next_int): Ditto.
(pwdgrp::gets): Eliminate.
* uinfo.cc (pwdgrp::next_str): New function.
(pwdgrp::next_int): Ditto.
(pwdgrp::add_line): Subsume gets.
(pwdgrp::gets): Eliminate.
(pwdgrp::load): Just call add_line to parse input buffer.
@
text
@d64 1
@


1.66
log
@* grp.cc: Call gr.refresh() rather than doing isunitialized tests throughout.
(gr): Use constructor (sigh).
(pwdgrp::parse_group): Rename from parse_grp.
(pwdgrp::read_group): Rename from read_etc_group.  Just call gr.load with a
single argument.
* passwd.cc: Call pr.refresh() rather than doing isunitialized tests
throughout.
(pr): Use constructor (sigh).
(pwdgrp::parse_passwd): Rename from "parse_pwd".
(pwdgrp::read_passwd): Rename from read_etc_passwd.  Just call pr.load with a
single argument.
* pwdgrp.h (pwdgrp_state): Eliminate.
(pwdgrp): Reflect above renamings.
(pwdgrp::etc_ix): Rename from pwd_ix.
(pwdgrp::read): New element.
(pwdgrp::lock): New element.
(pwdgrp::refresh): New function.
(pwdgrp::load): Eliminate variations which take buffer arguments.
(pwdgrp::pwdgrp): New constructors.  Initialize mutex here.
* uinfo.cc (pwdgrp::load): Accommodate pwd_ix -> etc_ix renaming.
(pwdgrp::load): Set initialized state to true rather than setting state to
loaded.
@
text
@d37 1
a37 1
pwdgrp::parse_group (char *line)
d39 1
a39 1
  char *dp = strchr (line, ':');
d41 4
a44 1
  if (!dp)
d47 3
a49 7
# define grp (*group_buf)[curr_lines]
  *dp++ = '\0';
  grp.gr_name = line;

  grp.gr_passwd = dp;
  dp = strchr (grp.gr_passwd, ':');
  if (dp)
d51 3
a53 3
      *dp++ = '\0';
      grp.gr_gid = strtoul (line = dp, &dp, 10);
      if (dp != line && *dp == ':')
d55 13
a67 24
	  grp.gr_mem = &null_ptr;
	  if (*++dp)
	    {
	      int i = 0;
	      char *cp;

	      for (cp = dp; (cp = strchr (cp, ',')) != NULL; ++cp)
		++i;
	      char **namearray = (char **) calloc (i + 2, sizeof (char *));
	      if (namearray)
		{
		  i = 0;
		  for (cp = dp; (cp = strchr (dp, ',')) != NULL; dp = cp + 1)
		    {
		      *cp = '\0';
		      namearray[i++] = dp;
		    }
		  namearray[i++] = dp;
		  namearray[i] = NULL;
		  grp.gr_mem = namearray;
		}
	    }
	  curr_lines++;
	  return true;
d69 2
@


1.65
log
@* pwdgrp.h (etc): Move to path.h.
(pwdgrp::max_lines): New field.
(pwdgrp::curr_lines): New field.
(pwdgrp::pwdgrp_buf): Ditto.
(pwdgrp_buf_elem_size): Ditto.
(pwdgrp_parse): Ditto.
(pwdgrp::gets): Just declare here.
(pwdgrp::load): Ditto.  Just take one argument.
(pwdgrp::load): Define overloaded function accepting passwd buf.
(pwdgrp::load): Define overloaded function accepting group buf.
* grp.cc: Use pwdgrp elements rather than standalone static variables
throughout.
(curr_lines): Eliminate.
(max_lines): Ditto.
(add_grp_line): Ditto.
(parse_grp): Define as returning boolean.  Accept void * arg and line count.
Coerce first argument into __group32 buf reference.  Increment curr_line as
appropriate.
(read_etc_group): Pass pwdgrp buffer to gr.load.
* passwd.cc: Use pwdgrp elements rather than standalone static variables
throughout.
(curr_lines): Eliminate.
(max_lines): Ditto.
(add_grp_line): Ditto.
(parse_passwd): Define as returning boolean.  Accept void * arg and line count.
Coerce first argument into passwd buf reference.  Increment curr_line as
appropriate.
(read_etc_group): Pass pwdgrp buffer to pr.load.
* path.cc (etc::fn): Extend buffer size to allow index by 1 rather than zero.
(etc::last_modified): Ditto.
(etc::change_possible): Ditto.  Renamed from sawchange.  Change to signed char
since elements are now tri-state.
(etc::init): Assume "handle" is 1 based rather than 0.
(etc::test_file_change): New function.  Sets change_possible based on file date
comparison.
(etc::dir_changed): Check file states immediately after changed_h is
initialized to avoid a race.
(etc::file_changed): Use test_file_change to detect if file needs to be
updated.
* path.h (etc): Move class here from pwdgrp.h.
* uinfo.cc: Move etc:: functions to path.cc.  Move pwdgrp functions here.
(pwdgrp::gets): Eliminate buf checks.  Just check eptr and set lptr.
(pwdgrp::add_line): New function.
(pwdgrp::load): Call generic add_line function which will call correct parser.
@
text
@a31 1
static pwdgrp gr;
d33 1
d37 1
a37 1
pwdgrp::parse_grp (char *line)
d44 1
a44 1
# define grp (* group_buf)[curr_lines]
a85 19
class group_lock
{
  bool armed;
  static NO_COPY pthread_mutex_t mutex;
public:
  group_lock (bool doit)
    {
      if (armed = doit)
        pthread_mutex_lock (&mutex);
    }
  ~group_lock ()
    {
      if (armed)
        pthread_mutex_unlock (&mutex);
    }
};

pthread_mutex_t NO_COPY group_lock::mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;

d90 2
a91 2
static void
read_etc_group ()
d93 3
a95 1
  group_lock here (cygwin_finished_initializing);
d97 5
a101 2
  /* if we got blocked by the mutex, then etc_group may have been processed */
  if (gr.isinitializing ())
d103 11
a113 26
      for (int i = 0; i < gr.curr_lines; i++)
	if ((group_buf + i)->gr_mem != &null_ptr)
	  free ((group_buf + i)->gr_mem);

      if (!gr.load ("/etc/group", group_buf))
	debug_printf ("gr.load failed");

      /* Complete /etc/group in memory if needed */
      if (!internal_getgrgid (myself->gid))
        {
	  static char linebuf [200];
	  char group_name [UNLEN + 1] = "mkgroup";
	  char strbuf[128] = "";

	  if (wincap.has_security ())
            {
	      struct __group32 *gr;

	      cygheap->user.groups.pgsid.string (strbuf);
	      if ((gr = internal_getgrsid (cygheap->user.groups.pgsid)))
		strlcpy (group_name, gr->gr_name, sizeof (group_name));
	    }
	  snprintf (linebuf, sizeof (linebuf), "%s:%s:%lu:%s",
		    group_name, strbuf, myself->gid, cygheap->user.name ());
	  debug_printf ("Completing /etc/group: %s", linebuf);
	  gr.add_line (linebuf);
d115 4
a118 3
      static char NO_COPY pretty_ls[] = "????????::-1:";
      if (wincap.has_security ())
	gr.add_line (pretty_ls);
d120 3
d131 1
a131 2
  if (gr.isuninitialized ())
    read_etc_group ();
d143 1
a143 2
  if (gr.isuninitialized () || (check && gr.isinitializing ()))
    read_etc_group ();
d154 1
a154 2
  if (gr.isuninitialized () || (check && gr.isinitializing ()))
    read_etc_group ();
d217 1
a217 2
  if (gr.isinitializing ())
    read_etc_group ();
d243 1
a243 2
  if (gr.isuninitialized ())
    read_etc_group ();
@


1.64
log
@* dcrt0.cc (initialize_env): Use colon for CYGWIN_DEBUG separator.
* grp.cc: Change most statics to NO_COPY throughout.
* passwd.cc: Ditto.
* pwdgrp.h: Change some BOOLs to bools.
(pwdgrp::pwdgrp): Remove unneeded constructor.
* passwd.cc: Change BOOL to bool throughout.
@
text
@a28 7
/* Read /etc/group only once for better performance.  This is done
   on the first call that needs information from it. */

static struct __group32 NO_COPY *group_buf;		/* group contents in memory */
static int NO_COPY curr_lines;
static int NO_COPY max_lines;

d32 2
a33 1
static pwdgrp NO_COPY gr;
d36 2
a37 2
static int
parse_grp (struct __group32 &grp, char *line)
d42 1
a42 1
    return 0;
d44 1
d78 2
a79 1
	  return 1;
d82 2
a83 14
  return 0;
}

/* Read one line from /etc/group into the group cache */
static void
add_grp_line (char *line)
{
    if (curr_lines == max_lines)
      {
	max_lines += 10;
	group_buf = (struct __group32 *) realloc (group_buf, max_lines * sizeof (struct __group32));
      }
    if (parse_grp (group_buf[curr_lines], line))
      curr_lines++;
d117 1
a117 1
      for (int i = 0; i < curr_lines; i++)
d121 1
a121 2
      curr_lines = 0;
      if (!gr.load ("/etc/group", add_grp_line))
d142 1
a142 1
	  add_grp_line (linebuf);
d146 1
a146 1
	add_grp_line (pretty_ls);
d160 1
a160 1
    for (int i = 0; i < curr_lines; i++)
d172 1
a172 1
  for (int i = 0; i < curr_lines; i++)
d184 1
a184 1
  for (int i = 0; i < curr_lines; i++)
d192 1
a192 2
static
struct __group16 *
d248 1
a248 1
  if (grp_pos < curr_lines)
d275 1
a275 1
  if (pos < curr_lines)
@


1.63
log
@update copyright
@
text
@d32 3
a34 3
static struct __group32 *group_buf;		/* group contents in memory */
static int curr_lines;
static int max_lines;
a36 1
#ifdef _MT_SAFE
a37 3
#else
static int grp_pos = 0;
#endif
d39 1
a39 1
static pwdgrp gr;
d106 1
a106 1
 public:
d161 1
a161 1
      static char pretty_ls[] = "????????::-1:";
d184 1
a184 1
internal_getgrgid (__gid32_t gid, BOOL check)
d196 1
a196 1
internal_getgrnam (const char *name, BOOL check)
d235 1
a235 1
  static struct __group16 g16;
d249 1
a249 1
  static struct __group16 g16;
d275 1
a275 1
  static struct __group16 g16;
@


1.62
log
@* grp.cc (read_etc_group): On NT, add a line for gid = -1.  Change name
"unknown" to "mkgroup".
(internal_getgrgid): Do not return default in nontsec case.
(internal_getgroups): Add argument srchsid and look for it in groups if not
NULL.
* passwd.cc (read_etc_passwd): On NT, add a line for uid = -1.  Use same
default uid for Win95 and NT.  Call cygheap_user::ontherange to initialize
HOME.
* cygheap.cc (init_cygheap::etc_changed): Move to uinfo.cc.
* cygheap.h (init_cygheap::etc_changed_h): Remove.
(init_cygheap::etc_changed): Ditto.
* grp.cc (group_state): Remove.  Use gr instead throughout.
(gr): Define as class pwdgrp.
(read_etc_group): Remove gr definition.  Remove calls to set_last_modified and
close.  Pass add_grp to gr.load to load file.
* passwd.cc (passwd_state): Remove.  Use pr instead, throughout.
(pr): Define as class pwdgrp.
(read_etc_passwd): Remove pr definition.  Remove calls to set_last_modified and
close.  Pass add_pwd_line to pr.load to load file.
* pwdgrp.h (etc): New helper class for pwdgrp.
(pwdgrp): Combine pwdgrp_check and pwdgrp_read into one class.  Remove file_w32
and last_modified fields.
(pwdgrp::set_last_modified): Remove.
(pwdgrp::isinitializing): Remove FindFirstFile stuff.  Move to
etc::file_changed.
(pwdgrp::load): Rename from 'open'.  Call etc::init to initialize etc scanning.
Close file handle after reading buffer into memory.  Parse buffer by calling
second argument.
(pwdgrp::gets): Reorganize slightly to rely on eptr starting at beginning of
buffer.  Free buffer when memory exhausted.
(pwdgrp::close): Remove.
* uinfo.cc (etc::dir_changed): New function.
(etc::init): Ditto.
(etc::file_changed): Ditto.
(etc::set_last_modified): Ditto.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002 Red Hat, Inc.
@


1.61
log
@2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* pwdgrp.h (pwdgrp_check::pwdgrp_state): Replace by
	pwdgrp_check::isinitializing ().
	(pwdgrp_check::isinitializing): Create.
	* passwd.cc (grab_int): Change type to unsigned, use strtoul and
	set the pointer content to 0 if the field is invalid.
	(parse_pwd): Move validity test after getting pw_gid.
	(read_etc_passwd): Replace "passwd_state <= " by
	passwd_state::isinitializing ().
	(internal_getpwuid): Ditto.
	(internal_getpwnam): Ditto.
	(getpwent): Ditto.
	(getpass): Ditto.
	* grp.cc (parse_grp): Use strtoul for gr_gid and verify the validity.
	(read_etc_group): Replace "group_state <= " by
	group_state::isinitializing ().
	(internal_getgrgid): Ditto.
	(getgrent32): Ditto.
	(internal_getgrent): Ditto.

2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h: Move declarations of internal_getgrent,
	internal_getpwsid and internal_getgrsid to pwdgrp.h.
	* pwdgrp.h: Declare internal_getpwsid, internal_getpwnam,
	internal_getpwuid, internal_getgrsid, internal_getgrgid,
	internal_getgrnam, internal_getgrent and internal_getgroups.
	Delete "emulated" from enum pwdgrp_state.
	(pwdgrp_check::isuninitialized): Create.
	(pwdgrp_check::pwdgrp_state): Change state to initializing
	rather than to uninitialized.
	(pwdgrp_read::gets): Remove trailing CRs.
	* passwd.cc (grab_string): Don't look for NLs.
	(grab_int): Ditto.
	(parse_pwd): Don't look for CRs. Return 0 if entry is too short.
	(search_for): Delete.
	(read_etc_passwd): Simplify tests to actually read the file.
	Set state to loaded before making internal_getpwXX calls.
	Replace search_for calls by equivalent internal_pwgetXX calls.
	(internal_getpwsid): Use passwd_state.isuninitialized to decide
	to call read_etc_passwd.
	(internal_getpwuid): Create.
	(internal_getpwnam): Create.
	(getpwuid32): Simply call internal_getpwuid.
	(getpwuid_r32): Call internal_getpwuid.
	(getpwnam): Simply call internal_getpwnam.
	(getpwnam_r): Call internal_getpwnam.
	* grp.cc (parse_grp): Don't look for CRs. Adjust blank space.
	(add_grp_line): Adjust blank space.
	(class group_lock): Ditto.
	(read_etc_group): Simplify tests to actually read the file.
	Set state to loaded before making internal_getgrXX calls.
	Replace getgrXX calls by equivalent internal calls.
	(internal_getgrsid): Use group_state.isuninitialized to decide
	to call read_etc_group.
	(internal_getgrgid): Create.
	(internal_getgrnam): Create.
	(getgroups32): Simply call internal_getgrgid.
	(getgrnam32): Simply call internal_getgrnam.
	(internal_getgrent): Call group_state.isuninitialized.
	(internal_getgroups): Create from the former getgroups32, using
	two of the four arguments. Set gid to myself->gid and username
	to cygheap->user.name ().
	(getgroups32): Simply call internal_getgroup.
	(getgroups): Call internal_getgroup instead of getgroups32.
	(setgroups32): Call internal versions of get{pw,gr}XX.
	* sec_helper.cc: Include pwdgrp.h.
	(is_grp_member): Call internal versions of get{pw,gr}XX.
	* security.cc: Include pwdgrp.h.
	(alloc_sd): Call internal versions of get{pw,gr}XX.
	* syscalls.cc: Include pwdgrp.h.
	(seteuid32): Call internal versions of get{pw,gr}XX.
	(setegid32): Ditto.
	* uinfo.cc: Include pwdgrp.h.
	(internal_getlogin): Call internal versions of get{pw,gr}XX.
	(cygheap_user::ontherange): Ditto.
	* sec_acl.cc: Include pwdgrp.h.
	(setacl): Call internal versions of get{pw,gr}XX.
	(acl_access): Ditto and simplify logic.
	(aclfromtext): Ditto.
@
text
@d43 2
a44 2
static pwdgrp_check group_state;
static char * NO_COPY null_ptr = NULL;
a131 2
  static pwdgrp_read gr;

d135 1
a135 1
  if (group_state.isinitializing ())
d142 2
a143 11
      if (gr.open ("/etc/group"))
	{
	  char *line;
	  while ((line = gr.gets ()) != NULL)
            add_grp_line (line);

	  group_state.set_last_modified (gr.get_fhandle (), gr.get_fname ());
	  gr.close ();
	  debug_printf ("Read /etc/group, %d lines", curr_lines);
	}
      group_state = loaded;
d149 1
a149 1
	  char group_name [UNLEN + 1] = "unknown";
d165 3
d177 1
a177 1
  if (group_state.isuninitialized ())
d190 1
a190 4
  struct __group32 * default_grp = NULL;

  if (group_state.isuninitialized ()
      || (check && group_state.isinitializing ()))
d194 3
a196 7
    {
      if (group_buf[i].gr_gid == myself->gid)
	default_grp = group_buf + i;
      if (group_buf[i].gr_gid == gid)
	return group_buf + i;
    }
  return allow_ntsec || gid != ILLEGAL_GID ? NULL : default_grp;
d202 1
a202 2
  if (group_state.isuninitialized ()
      || (check && group_state.isinitializing ()))
d267 1
a267 1
  if (group_state.isinitializing ())
d294 1
a294 1
  if (group_state.isuninitialized ())
d303 1
a303 1
internal_getgroups (int gidsetsize, __gid32_t *grouplist)
d332 7
@


1.61.4.1
log
@trunk merge
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003 Red Hat, Inc.
d29 7
d37 1
d39 14
d54 6
a59 18
static __group32 *group_buf;
static pwdgrp gr (group_buf);
static char * NO_COPY null_ptr;

bool
pwdgrp::parse_group ()
{
  char *dp;

# define grp (*group_buf)[curr_lines]
  memset (&grp, 0, sizeof (grp));
  grp.gr_name = next_str ();
  if (!grp.gr_name)
    return false;

  grp.gr_passwd = next_str ();
  int n = next_int ();
  if (n >= 0)
d61 3
a63 3
      grp.gr_gid = n;
      dp = next_str ();
      if (!dp)
d65 23
a87 13
	  static char empty[] = "";
	  dp = empty;
	}
      int i = 0;
      for (char *cp = dp; (cp = strchr (cp, ',')) != NULL; cp++)
	i++;
      char **namearray = (char **) calloc (i + 2, sizeof (char *));
      if (namearray)
	{
	  for (i = 0; (dp = next_str (',')); i++)
	    namearray[i] = dp;
	  namearray[i] = NULL;
	  grp.gr_mem = namearray;
d89 14
d104 11
a114 1
      return true;
d116 8
a123 3
  return false;
# undef grp
}
d129 2
a130 2
void
pwdgrp::read_group ()
d132 1
a132 3
  for (int i = 0; i < gr.curr_lines; i++)
    if ((*group_buf)[i].gr_mem != &null_ptr)
      free ((*group_buf)[i].gr_mem);
d134 1
a134 2
  if (!gr.load ("/etc/group"))
    debug_printf ("gr.load failed");
d136 2
a137 2
  /* Complete /etc/group in memory if needed */
  if (!internal_getgrgid (myself->gid))
d139 3
a141 3
      static char linebuf [200];
      char group_name [UNLEN + 1] = "mkgroup";
      char strbuf[128] = "";
d143 2
a144 1
      if (wincap.has_security ())
d146 9
a154 1
	  struct __group32 *gr;
d156 19
a174 3
	  cygheap->user.groups.pgsid.string (strbuf);
	  if ((gr = internal_getgrsid (cygheap->user.groups.pgsid)))
	    strlcpy (group_name, gr->gr_name, sizeof (group_name));
a175 4
      snprintf (linebuf, sizeof (linebuf), "%s:%s:%lu:%s",
		group_name, strbuf, myself->gid, cygheap->user.name ());
      debug_printf ("Completing /etc/group: %s", linebuf);
      gr.add_line (linebuf);
a176 3
  static char NO_COPY pretty_ls[] = "????????::-1:";
  if (wincap.has_security ())
    gr.add_line (pretty_ls);
d185 2
a186 1
  gr.refresh ();
d189 1
a189 1
    for (int i = 0; i < gr.curr_lines; i++)
d196 1
a196 1
internal_getgrgid (__gid32_t gid, bool check)
d198 5
a202 1
  gr.refresh (check);
d204 8
a211 4
  for (int i = 0; i < gr.curr_lines; i++)
    if (group_buf[i].gr_gid == gid)
      return group_buf + i;
  return NULL;
d215 1
a215 1
internal_getgrnam (const char *name, bool check)
d217 3
a219 1
  gr.refresh (check);
d221 1
a221 1
  for (int i = 0; i < gr.curr_lines; i++)
d229 2
a230 1
static struct __group16 *
d255 1
a255 1
  static struct __group16 g16;	/* FIXME: thread-safe? */
d269 1
a269 1
  static struct __group16 g16;	/* FIXME: thread-safe? */
d283 2
a284 1
  gr.refresh ();
d286 1
a286 1
  if (grp_pos < gr.curr_lines)
d295 1
a295 1
  static struct __group16 g16;	/* FIXME: thread-safe? */
d310 2
a311 1
  gr.refresh ();
d313 1
a313 1
  if (pos < gr.curr_lines)
d319 1
a319 1
internal_getgroups (int gidsetsize, __gid32_t *grouplist, cygsid * srchsid)
a347 7
	      if (srchsid)
	        {
		  for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
		    if (*srchsid == groups->Groups[pg].Sid)
		      return 1;
		  return 0;
		}
@


1.61.4.2
log
@merge from trunk
@
text
@a63 1
	  reparse (dp);
@


1.61.4.3
log
@merge from trunk
@
text
@a41 1

a42 1

d44 1
a44 1
  if (!*grp.gr_name)
d48 2
a49 11

  if (!next_num (grp.gr_gid))
    return false;

  int n;
  dp = raw_ptr ();
  for (n = 0; *next_str (','); n++)
    continue;

  grp.gr_mem = &null_ptr;
  if (n)
d51 11
a61 1
      char **namearray = (char **) calloc (n + 2, sizeof (char *));
d64 2
a65 1
	  for (int i = 0; i < n; i++, dp = strchr (dp, '\0') + 1)
d67 1
d70 2
d73 1
a73 2

  return true;
d88 2
a89 1
  load ("/etc/group");
d109 1
a109 1
      add_line (linebuf);
d113 1
a113 1
    add_line (pretty_ls);
@


1.61.4.4
log
@merge from trunk
@
text
@d39 2
d42 3
d55 1
a55 1
  char *dp = raw_ptr ();
d62 1
a62 1
      char **namearray = (char **) calloc (n + 1, sizeof (char *));
d124 1
a124 1
	return group_buf + i;
d252 1
a252 1
	hToken = cygheap->user.token;
d254 1
a254 1
	hToken = NULL;
d269 1
a269 1
		{
d297 1
a297 1
	CloseHandle (hToken);
@


1.61.4.5
log
@merge from trunk
@
text
@d40 1
a40 1
  grp.gr_name = next_str (':');
d44 1
a44 1
  grp.gr_passwd = next_str (':');
@


1.61.4.6
log
@merge from trunk
@
text
@d114 1
a114 1
  gr.refresh (false);
d200 2
a201 2
  if (grp_pos == 0)
    gr.refresh (true);
d226 1
a226 1
  gr.refresh (false);
@


1.61.4.7
log
@merge from trunk
@
text
@d110 1
a110 1
internal_getgrsid (cygpsid &sid)
d234 1
a234 1
internal_getgroups (int gidsetsize, __gid32_t *grouplist, cygpsid * srchsid)
d266 3
a268 3
		    if ((cnt = (*srchsid == groups->Groups[pg].Sid)))
		      break;
		  cnt = -1;
d270 17
a286 18
	      else
		for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
		  if (sid.getfromgr (gr))
		    for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
		      if (sid == groups->Groups[pg].Sid &&
			  sid != well_known_world_sid)
		        {
			  if (cnt < gidsetsize)
			    grouplist[cnt] = gr->gr_gid;
			  ++cnt;
			  if (gidsetsize && cnt > gidsetsize)
			    {
			      if (hToken != cygheap->user.token)
				CloseHandle (hToken);
			      goto error;
			    }
			  break;
			}
@


1.61.4.8
log
@merge from trunk
@
text
@a97 2
      if (myself->uid == UNKNOWN_UID)
	strcpy (group_name, "mkpasswd"); /* Feedback... */
d174 1
a174 1
  return grp32togrp16 (&g16, getgrgid32 (gid16togid32 (gid)));
@


1.61.4.9
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d22 1
a23 1
#include "fhandler.h"
@


1.61.4.10
log
@merge from trunk
@
text
@d270 1
d296 2
a297 1
      return cnt;
@


1.61.4.11
log
@merge from trunk
@
text
@a110 16
pwdgrp::pwdgrp (passwd *&pbuf) :
  pwdgrp_buf_elem_size (sizeof (*pbuf)), passwd_buf (&pbuf)
{
  read = &pwdgrp::read_passwd;
  parse = &pwdgrp::parse_passwd;
  new_muto (pglock);
}

pwdgrp::pwdgrp (__group32 *&gbuf) :
  pwdgrp_buf_elem_size (sizeof (*gbuf)), group_buf (&gbuf)
{
  read = &pwdgrp::read_group;
  parse = &pwdgrp::parse_group;
  new_muto (pglock);
}

@


1.61.4.12
log
@merge from trunk
@
text
@d19 1
d265 1
a265 1
	hToken = cygheap->user.token ();
d299 1
a299 1
			      if (!cygheap->user.issetuid ())
d309 1
a309 1
      if (!cygheap->user.issetuid ())
@


1.60
log
@	* security.h: Declare internal_getpwsid and internal_getgrsid.
	Undeclare internal_getpwent.  Define DEFAULT_UID_NT.  Change
	DEFAULT_GID.
	* passwd.cc (internal_getpwsid): New function.
	(internal_getpwent): Suppress.
	(read_etc_passwd): Make static.  Rewrite the code for the completion
	line.  Set curr_lines to 0.
	(parse_pwd): Change type to static int.  Return 0 for short lines.
	(add_pwd_line): Pay attention to the value of parse_pwd.
	(search_for): Do not look for nor return the DEFAULT_UID.
	* grp.cc (read_etc_group): Make static.  Free gr_mem and set
	curr_lines to 0.  Always call add_pwd_line.  Rewrite the code for the
	completion line.
	(internal_getgrsid): New function.
	(parse_grp): If grp.gr_mem is empty, set it to &null_ptr.
	Never NULL gr_passwd.
	(getgrgid32): Only return the default if ntsec is off and the gid is
	ILLEGAL_GID.
	* sec_helper.cc (cygsid::get_id): Use getpwsid and getgrsid.
	(cygsid_getfrompw): Clean up last line.
	(cygsid_getfromgr): Ditto.
	(is_grp_member): Use getpwuid32 and getgrgid32.
	* uinfo.cc (internal_getlogin): Set DEFAULT_GID at start.
	Use getpwsid. Move the read of /etc/group after the second access
	to /etc/passwd.  Change some debug_printf.
@
text
@d33 1
a33 1
static int curr_lines = -1;
a48 4
  int len = strlen (line);
  if (line[--len] == '\r')
    line[len] = '\0';

d62 2
a63 3
      grp.gr_gid = strtol (dp, NULL, 10);
      dp = strchr (dp, ':');
      if (dp)
d98 1
a98 1
    {
d101 1
a101 1
    }
d112 4
a115 4
  {
    if (armed = doit)
      pthread_mutex_lock (&mutex);
  }
d117 4
a120 4
  {
    if (armed)
      pthread_mutex_unlock (&mutex);
  }
d137 1
a137 4
  if (group_state != uninitialized)
    return;

  if (group_state != initializing)
a138 1
      group_state = initializing;
d154 1
d157 1
a157 1
      if (!getgrgid32 (myself->gid))
a175 1
      group_state = loaded;
d185 1
a185 1
  if (curr_lines < 0 && group_state  <= initializing)
d190 1
a190 1
      if (!strcmp (sid_string, (group_buf + i)->gr_passwd))
d195 34
d249 1
a249 12
  struct __group32 * default_grp = NULL;
  if (group_state  <= initializing)
    read_etc_group ();

  for (int i = 0; i < curr_lines; i++)
    {
      if (group_buf[i].gr_gid == myself->gid)
	default_grp = group_buf + i;
      if (group_buf[i].gr_gid == gid)
	return group_buf + i;
    }
  return allow_ntsec || gid != ILLEGAL_GID ? NULL : default_grp;
d263 1
a263 9
  if (group_state  <= initializing)
    read_etc_group ();

  for (int i = 0; i < curr_lines; i++)
    if (strcasematch (group_buf[i].gr_name, name))
      return group_buf + i;

  /* Didn't find requested group */
  return NULL;
d283 1
a283 1
  if (group_state  <= initializing)
d310 1
a310 1
  if (group_state  <= initializing)
d319 1
a319 2
getgroups32 (int gidsetsize, __gid32_t *grouplist, __gid32_t gid,
	     const char *username)
d325 2
a326 3

  if (group_state  <= initializing)
    read_etc_group ();
d375 2
d406 1
a406 2
  return getgroups32 (gidsetsize, grouplist, myself->gid,
		      cygheap->user.name ());
d422 1
a422 2
  int ret = getgroups32 (gidsetsize, grouplist32, myself->gid,
			 cygheap->user.name ());
d469 1
a469 1
      if ((gr = getgrgid32 (grouplist[gidx])) &&
@


1.59
log
@* grp.cc (getgroups32): Protect against closing cygheap->user.token.
@
text
@d33 1
a33 1
static int curr_lines;
d44 1
a65 3
      if (!strlen (grp.gr_passwd))
	grp.gr_passwd = NULL;

d70 1
d89 1
a90 1
	      grp.gr_mem = namearray;
a91 2
	  else
	    grp.gr_mem = (char **) calloc (1, sizeof (char *));
d134 1
a134 3
/* FIXME: should be static but this is called in uinfo_init outside this
   file */
void
d148 5
d157 1
a157 2
	    if (strlen (line))
	      add_grp_line (line);
a159 1
	  group_state = loaded;
d163 4
a166 7
      else /* /etc/group doesn't exist -- create default one in memory */
	{
	  char group_name [UNLEN + 1];
	  DWORD group_name_len = UNLEN + 1;
	  char domain_name [INTERNET_MAX_HOST_NAME_LENGTH + 1];
	  DWORD domain_name_len = INTERNET_MAX_HOST_NAME_LENGTH + 1;
	  SID_NAME_USE acType;
d168 2
d172 2
a173 4
	    {
	      HANDLE ptok;
	      cygsid tg;
	      DWORD siz;
d175 3
a177 36
	      if (OpenProcessToken (hMainProc, TOKEN_QUERY, &ptok))
		{
		  if (GetTokenInformation (ptok, TokenPrimaryGroup, &tg,
					   sizeof tg, &siz)
		      && LookupAccountSidA (NULL, tg, group_name,
					    &group_name_len, domain_name,
					    &domain_name_len, &acType))
		    {
		      char strbuf[100];
		      snprintf (linebuf, sizeof (linebuf), "%s:%s:%lu:",
				group_name,
				tg.string (strbuf),
				*GetSidSubAuthority (tg,
					     *GetSidSubAuthorityCount (tg) - 1));
		      debug_printf ("Emulating /etc/group: %s", linebuf);
		      add_grp_line (linebuf);
		      group_state = emulated;
		    }
		  CloseHandle (ptok);
		}
	    }
	  if (group_state != emulated)
	    {
	      strncpy (group_name, "Administrators", sizeof (group_name));
	      if (!LookupAccountSidA (NULL, well_known_admins_sid, group_name,
				      &group_name_len, domain_name,
				      &domain_name_len, &acType))
		{
		  strcpy (group_name, "unknown");
		  debug_printf ("Failed to get local admins group name. %E");
		}
	      snprintf (linebuf, sizeof (linebuf), "%s::%u:", group_name,
			(unsigned) DEFAULT_GID);
	      debug_printf ("Emulating /etc/group: %s", linebuf);
	      add_grp_line (linebuf);
	      group_state = emulated;
d179 4
d184 1
d186 2
d189 13
a201 1
  return;
d230 1
a230 1
      if (group_buf[i].gr_gid == DEFAULT_GID)
d235 1
a235 2

  return allow_ntsec ? NULL : default_grp;
d465 3
a467 7
      for (int gidy = 0; (gr = internal_getgrent (gidy)); ++gidy)
	if (gr->gr_gid == (__gid32_t) grouplist[gidx])
	  {
	    if (gsids.addfromgr (gr))
	      goto found;
	    break;
	  }
@


1.58
log
@	* grp.cc (getgroups32): Revert previous patch.  Use impersonation
	token if process is in impersonated state.
	* sec_helper.cc (is_grp_member): Rewrite.  Call getgroups32 only
	for current user.  Scan passwd and group info otherwise.
@
text
@d375 2
a376 1
			    CloseHandle (hToken);
@


1.57
log
@	* grp.cc (getgroups32): Don't use access token of current user when
	retrieving group info for another user.
@
text
@d344 9
a352 3
  if (allow_ntsec &&
      strcasematch (username, cygheap->user.name ()) &&
      OpenProcessToken (hMainProc, TOKEN_QUERY, &hToken))
d384 2
a385 1
      CloseHandle (hToken);
@


1.56
log
@whitespace
@
text
@d345 1
@


1.55
log
@* fhandler_proc.cc (format_process_stat): make ctty a real device number.
(format_process_status): use effective uid/gid as real and saved uid/gid.
@
text
@d181 1
a181 1
	        {
d186 1
a186 1
				            &domain_name_len, &acType))
@


1.54
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d240 1
a240 2
extern "C"
struct __group32 *
d258 1
a258 2
extern "C"
struct __group16 *
d266 1
a266 2
extern "C"
struct __group32 *
d280 1
a280 2
extern "C"
struct __group16 *
d288 1
a288 2
extern "C"
void
d294 1
a294 2
extern "C"
struct __group32 *
d306 1
a306 2
extern "C"
struct __group16 *
d314 1
a314 2
extern "C"
void
d408 1
a408 2
extern "C"
int
d415 1
a415 2
extern "C"
int
d438 1
a438 2
extern "C"
int
d446 1
a446 2
extern "C"
int
d453 1
a453 2
extern "C"
int
d494 1
a494 2
extern "C"
int
@


1.53
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d38 1
a38 1
#define grp_pos _reent_winsup()->_grp_pos
d48 1
a48 1
  int len = strlen(line);
d160 1
a160 1
	  group_state.set_last_modified (gr.get_fhandle(), gr.get_fname ());
d192 2
a193 2
				*GetSidSubAuthority(tg,
					     *GetSidSubAuthorityCount(tg) - 1));
d246 1
a246 1
    read_etc_group();
d273 1
a273 1
    read_etc_group();
d294 1
a294 1
endgrent()
d301 1
a301 1
getgrent32()
d304 1
a304 1
    read_etc_group();
d314 1
a314 1
getgrent()
d333 1
a333 1
    read_etc_group();
d350 1
a350 1
    read_etc_group();
@


1.52
log
@	* grp.cc (initgroups): Call groups::clear_supp to free the
	supplementary group sids that may have been set by setgroups.
	* security.cc (cygsidlist::free_sids): Also zero the class members.
	* security.h (groups::clear_supp): New.
	Rename cygsidlist_unknown to cygsidlist_empty.
@
text
@d190 1
a190 1
		      		group_name, 
d193 1
a193 1
				             *GetSidSubAuthorityCount(tg) - 1));
d368 1
a368 1
		    if (sid == groups->Groups[pg].Sid && 
d519 1
a519 1
        grouplist32[i] = grouplist[i];
@


1.51
log
@	* security.cc (verify_token): Do not reject a token just because
	the supplementary group list is missing Everyone or a groupsid
	equal to usersid, or because the primary group is not in the token,
	as long as it is equal to the usersid.
	* syscalls.cc (seteuid32): Use common code for all successful returns.
	* grp.cc (getgroups32): Never includes Everyone in the output.
@
text
@d452 2
d459 1
a459 1
initgroups (const char *, __gid16_t)
d461 1
a461 1
  return 0;
@


1.50
log
@	* security.cc: Change some formatting.
	* include/cygwin/version.h: Bump API minor version.

        * cygheap.h (class cygheap_user): Add member groups.
        * security.h (class cygsidlist): Add members type and maxcount,
        methods position, addfromgr, alloc_sids and free_sids and
        operator+= (const PSID psid). Modify contains () to call
        position () and optimize add () to use maxcount.
        (class user_groups): Create.
        Update declarations of verify_token and create_token.
        * security.cc (cygsidlist::alloc_sids): New.
        (cygsidlist::free_sids): New.
        (get_token_group_sidlist): Create from get_group_sidlist.
        (get_initgroups_sidlist): Create from get_group_sidlist.
        (get_group_sidlist): Suppress.
        (get_setgroups_sidlist): Create.
        (verify_token): Modify arguments. Add setgroups case.
        (create_token): Modify arguments. Call get_initgroups_sidlist and
        get_setgroups_sidlist as needed. Set SE_GROUP_LOGON_ID from auth_pos
        outside of the loop. Rename the various group sid lists consistently.
        * syscalls.cc (seteuid32): Modify to use cygheap->user.groups.
        (setegid32): Call cygheap->user.groups.update_pgrp.
        * grp.cc (setgroups): Create.
        (setgroups32): Create.
        * uinfo.cc (internal_getlogin): Initialize and update user.groups.pgsid.
        * cygwin.din: Add setgroups and setgroups32.
@
text
@d368 2
a369 1
		    if (sid == groups->Groups[pg].Sid)
a519 1

@


1.49
log
@Use hMainProc where appropriate, throughout.
* environ.cc (spenv::retrieve): Add debugging statements.
* pinfo.cc (set_myself): Don't call strace.hello if already stracing.
* strace.cc (strace): Move NO_COPY keyword so that it will actually take
effect.
@
text
@d460 61
@


1.48
log
@* dtable.cc (handle_to_fn): Check error return value from NtQueryObject first
before seeing if name buffer is NULL.
* grp.cc (read_etc_group): Fix gcc warning regarding snprintf format.
* passwd.cc (read_etc_passwd): Ditto.
@
text
@d180 1
a180 1
	      if (OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok))
@


1.47
log
@	* grp.cc (read_etc_group): When emulating nonexisting group file on
	NT systems, read primary group SID from process token.  Use that info
	to create correct group entry.  On error or on 9x systems fallback
	to emulating Administrators group as before.
	(read_etc_passwd): When emulating nonexisting passwd file on NT systems,
	read user and primary group SID from process token.  Use that info to
	create correct passwd entry.  On error or on 9x systems fallback to
	emulating user with Administrator user id and Administrators group
	as before.
@
text
@d189 1
a189 1
		      snprintf (linebuf, sizeof (linebuf), "%s:%s:%u:",
@


1.46
log
@	* grp.cc (etc_group): Removed.
	(parse_grp): Make line parameter nonconst.  Don't copy data into new
	allocated memory.  Check for CR instead of LF to accomodate new
	read method.
	(add_grp_line): Make line parameter nonconst.
	(read_etc_group): Rearrange using new pwdgrp_read class.
	* passwd.cc (parse_pwd): Don't copy data into new allocated memory.
	Check for CR instead of LF to accomodate new read method.
	(read_etc_passwd): Rearrange using new pwdgrp_read class.
	* pwdgrp.h (pwdgrp_check::set_last_modified):  Use different
	parameters.
	(class pwdgrp_read): New class for opening and reading passwd and
	group files.
@
text
@d174 1
a174 5
	  debug_printf ("Emulating /etc/group");
	  strncpy (group_name, "Administrators", sizeof (group_name));
	  if (! LookupAccountSidA (NULL, well_known_admins_sid, group_name,
				   &group_name_len, domain_name,
				   &domain_name_len, &acType))
d176 40
a215 2
	      strcpy (group_name, "unknown");
	      debug_printf ("Failed to get local admins group name. %E");
a216 4
	  snprintf (linebuf, sizeof (linebuf), "%s::%u:\n", group_name,
		    (unsigned) DEFAULT_GID);
	  add_grp_line (linebuf);
	  group_state = emulated;
@


1.45
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@a31 1
static const char *etc_group NO_COPY = "/etc/group";
d46 1
a46 1
parse_grp (struct __group32 &grp, const char *line)
d49 2
a50 2
  char *newline = (char *) malloc (len + 1);
  (void) memcpy (newline, line, len + 1);
d52 1
a52 4
  if (newline[--len] == '\n')
    newline[len] = '\0';

  char *dp = strchr (newline, ':');
d58 1
a58 1
  grp.gr_name = newline;
d103 1
a103 1
add_grp_line (const char *line)
d142 1
a142 5
  char linebuf [200];
  char group_name [UNLEN + 1];
  DWORD group_name_len = UNLEN + 1;

  strncpy (group_name, "Administrators", sizeof (group_name));
d153 1
a153 13
      if (max_lines) /* When rereading, free allocated memory first. */
	{
	  for (int i = 0; i < curr_lines; ++i)
	    {
	      free (group_buf[i].gr_name);
	      free (group_buf[i].gr_mem);
	    }
	  curr_lines = 0;
	}

      FILE *f = fopen (etc_group, "rt");

      if (f)
d155 4
a158 5
	  while (fgets (linebuf, sizeof (linebuf), f) != NULL)
	    {
	      if (strlen (linebuf))
		add_grp_line (linebuf);
	    }
d160 1
a160 2
	  group_state.set_last_modified (f);
	  fclose (f);
d162 2
d167 2
d172 2
d175 4
a178 7
	  if (! LookupAccountSidA (NULL ,
				    well_known_admins_sid,
				    group_name,
				    &group_name_len,
				    domain_name,
				    &domain_name_len,
				    &acType))
d183 2
a184 2

	  snprintf (linebuf, sizeof (linebuf), "%s::%u:\n", group_name, (unsigned) DEFAULT_GID);
@


1.44
log
@	Change internal gid datatype from __gid16_t to __gid32_t
	throughout.
	* cygwin.din: Export new symbols chown32, fchown32, getegid32,
	getgid32, getgrgid32, getgrnam32, getgroups32, initgroups32, lchown32,
	setgid32, setegid32, getgrent32.
	* grp.cc (grp32togrp16): New static function.
	(getgrgid32): New function.
	(getgrnam32): Ditto.
	(getgrent32): Ditto.
	(getgroups32): Change name of internal function from getgroups.
	(getgroups32): New function.
	(initgroups32): Ditto.
	* syscalls.cc (chown32): Ditto.
	(lchown32): Ditto.
	(fchown32): Ditto.
	(setegid32): Ditto.
	(setgid32): Ditto.
	* uinfo.cc (getgid32): Ditto.
	(getegid32): Ditto.
	* include/cygwin/grp.h: Remove declaration of getgrgid() and getgrnam().
	Declare getgrgid32() and getgrnam32() instead.  Declare getgid32().
@
text
@a19 1
#include "sigproc.h"
@


1.43
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d34 1
a34 1
static struct __group16 *group_buf;		/* group contents in memory */
d48 1
a48 1
parse_grp (struct __group16 &grp, const char *line)
d113 1
a113 1
	group_buf = (struct __group16 *) realloc (group_buf, max_lines * sizeof (struct __group16));
d213 17
d231 2
a232 2
struct __group16 *
getgrgid (__gid16_t gid)
d234 1
a234 1
  struct __group16 * default_grp = NULL;
d251 10
a260 1
getgrnam (const char *name)
d274 9
d290 2
a291 2
struct __group16 *
getgrent()
d303 9
d319 1
a319 1
struct __group16 *
d331 2
a332 1
getgroups (int gidsetsize, __gid16_t *grouplist, __gid16_t gid, const char *username)
d337 1
a337 1
  struct __group16 *gr;
d407 8
d417 25
a441 1
  return getgroups (gidsetsize, grouplist, myself->gid, cygheap->user.name ());
@


1.42
log
@* times.cc (hires::prime): Restore thread priority on failure condition.
* uinfo.cc (uinfo_init): Use more robust method for determining if process was
invoked from a non-cygwin process.
* sync.h (muto::init): Eliminate "inheritance" parameter.
(new_muto): Reflect removal of parameter.
* sync.cc (muto::init): Ditto.
* cygheap.cc (cygheap_init): Ditto.
* debug.cc (threadname_init): Ditto.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* grp.cc (group_lock): Use different method for locking with static member.
(read_etc_group): REALLY ensure that read lock mutex is released.
* passwd.cc (passwd_lock): Use different method for locking with static member.
(read_etc_passwd): REALLY ensure that read lock mutex is released.
* shared.cc (sec_user): Correct reversed inheritance test.
@
text
@a19 1
#include "sync.h"
@


1.41
log
@* exceptions.cc (unused_sig_wrapper): Eliminate unused parameter to asm.
* external.cc (cygwin_internal): Change CW_STRACE_ON to CW_STRACE_TOGGLE.
* strace.cc (strace::hello): Toggle strace on and off.
* sync.cc (muto::init): Renamed from constructor.
* sync.h (muto::new): Delete.
(muto::delete): Ditto.
(new_muto): Simplify.  Use muto.init for nearly everything.
* uinfo.cc (uinfo_init): Avoid closing a NULL handle.
* include/sys/cygwin.h (cygwin_getinfo_types): Rename CW_STRACE_OFF to
CW_STRACE_TOGGLE.  Delete CW_STRACE_OFF.
* include/sys/strace.h (strace): Add "inited" field.
@
text
@d34 1
a34 1
static NO_COPY const char *etc_group = "/etc/group";
d122 2
a123 1
  pthread_mutex_t mutex;
d125 5
a129 2
  group_lock (): mutex ((pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER) {}
  void arm () {pthread_mutex_lock (&mutex); }
d132 1
a132 1
    if (mutex != (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER)
d137 2
d154 1
a154 3
  static NO_COPY group_lock here = group_lock();
  if (cygwin_finished_initializing)
    here.arm ();
@


1.40
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d148 1
a148 1
  static NO_COPY group_lock here;
@


1.39
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001 Red Hat, Inc.
@


1.38
log
@	* grp.cc (getgrent): Don't return default gid entry when ntsec is on.
	* syscalls.cc (setegid): Don't set primary group in process token.
@
text
@d35 1
a35 1
static struct group *group_buf;		/* group contents in memory */
d49 1
a49 1
parse_grp (struct group &grp, const char *line)
d114 1
a114 1
	group_buf = (struct group *) realloc (group_buf, max_lines * sizeof (struct group));
d211 2
a212 2
struct group *
getgrgid (gid_t gid)
d214 1
a214 1
  struct group * default_grp = NULL;
d230 1
a230 1
struct group *
d252 1
a252 1
struct group *
d272 1
a272 1
struct group *
d284 1
a284 1
getgroups (int gidsetsize, gid_t *grouplist, gid_t gid, const char *username)
d289 1
a289 1
  struct group *gr;
d359 1
a359 1
getgroups (int gidsetsize, gid_t *grouplist)
d366 1
a366 1
initgroups (const char *, gid_t)
@


1.37
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d226 1
a226 1
  return default_grp;
@


1.36
log
@* autoload.cc (wsock_init): Reorganize slightly to accomodate a new compiler.
@
text
@d27 1
a28 1
#include "cygerrno.h"
@


1.35
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d201 1
a201 1
	  snprintf (linebuf, sizeof (linebuf), "%s::%u:\n", group_name, DEFAULT_GID);
@


1.34
log
@* passwd.cc (read_etc_passwd): Bother with unlocking when not in cygwin
initialization.
* grp.cc (read_etc_group): Ditto.
@
text
@d25 1
a26 1
#include "path.h"
@


1.33
log
@* passwd.cc (read_etc_passwd): Don't bother with locking when
in cygwin initialization since there is only one thread.
* grp.cc (read_etc_group): Ditto.
@
text
@d126 5
@


1.32
log
@* grp.cc (read_etc_group): Just reuse group_buf storage for subsequent reread
of /etc/group.
* passwd.cc (read_etc_passwd): Just reuse passwd_buf storage for subsequent
reread of /etc/passwd.
@
text
@d120 8
d143 3
a145 2
  static NO_COPY pthread_mutex_t etc_group_mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;
  pthread_mutex_lock (&etc_group_mutex);
d149 1
a149 4
    {
      pthread_mutex_unlock(&etc_group_mutex);
      return;
    }
d202 1
a202 1
  pthread_mutex_unlock(&etc_group_mutex);
@


1.32.2.1
log
@Merged changes from HEAD
@
text
@a119 13
class group_lock
{
  pthread_mutex_t mutex;
 public:
  group_lock (): mutex ((pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER) {}
  void arm () {pthread_mutex_lock (&mutex); }
  ~group_lock ()
  {
    if (mutex != (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER)
      pthread_mutex_unlock (&mutex);
  }
};

d135 2
a136 3
  static NO_COPY group_lock here;
  if (cygwin_finished_initializing)
    here.arm ();
d140 4
a143 1
    return;
d196 1
a196 1
  return;
@


1.32.2.2
log
@Merged changes from HEAD
@
text
@d25 1
a26 1
#include "dtable.h"
@


1.32.2.3
log
@Merged changes from HEAD
@
text
@d27 1
a28 1
#include "cygheap.h"
d201 1
a201 1
	  snprintf (linebuf, sizeof (linebuf), "%s::%u:\n", group_name, (unsigned) DEFAULT_GID);
@


1.32.2.4
log
@Merged changes from HEAD
@
text
@d226 1
a226 1
  return allow_ntsec ? NULL : default_grp;
@


1.32.2.5
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002 Red Hat, Inc.
d34 2
a35 2
static const char *etc_group NO_COPY = "/etc/group";
static struct __group16 *group_buf;		/* group contents in memory */
d49 1
a49 1
parse_grp (struct __group16 &grp, const char *line)
d114 1
a114 1
	group_buf = (struct __group16 *) realloc (group_buf, max_lines * sizeof (struct __group16));
d122 1
a122 2
  bool armed;
  static NO_COPY pthread_mutex_t mutex;
d124 2
a125 5
  group_lock (bool doit)
  {
    if (armed = doit)
      pthread_mutex_lock (&mutex);
  }
d128 1
a128 1
    if (armed)
a132 2
pthread_mutex_t NO_COPY group_lock::mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;

d148 3
a150 1
  group_lock here (cygwin_finished_initializing);
d211 2
a212 2
struct __group16 *
getgrgid (__gid16_t gid)
d214 1
a214 1
  struct __group16 * default_grp = NULL;
d230 1
a230 1
struct __group16 *
d252 1
a252 1
struct __group16 *
d272 1
a272 1
struct __group16 *
d284 1
a284 1
getgroups (int gidsetsize, __gid16_t *grouplist, __gid16_t gid, const char *username)
d289 1
a289 1
  struct __group16 *gr;
d359 1
a359 1
getgroups (int gidsetsize, __gid16_t *grouplist)
d366 1
a366 1
initgroups (const char *, __gid16_t)
@


1.32.2.6
log
@Merged changes from HEAD
@
text
@d20 2
d34 2
a35 1
static struct __group32 *group_buf;		/* group contents in memory */
d49 1
a49 1
parse_grp (struct __group32 &grp, char *line)
d52 2
a53 2
  if (line[--len] == '\r')
    line[len] = '\0';
d55 4
a58 1
  char *dp = strchr (line, ':');
d64 1
a64 1
  grp.gr_name = line;
d109 1
a109 1
add_grp_line (char *line)
d114 1
a114 1
	group_buf = (struct __group32 *) realloc (group_buf, max_lines * sizeof (struct __group32));
d148 5
a152 1
  static pwdgrp_read gr;
d163 1
a163 1
      if (gr.open ("/etc/group"))
d165 7
a171 4
	  char *line;
	  while ((line = gr.gets ()) != NULL)
	    if (strlen (line))
	      add_grp_line (line);
d173 12
a184 1
	  group_state.set_last_modified (gr.get_fhandle(), gr.get_fname ());
a185 2
	  gr.close ();
	  debug_printf ("Read /etc/group, %d lines", curr_lines);
a188 2
	  char group_name [UNLEN + 1];
	  DWORD group_name_len = UNLEN + 1;
d192 8
a199 3
	  static char linebuf [200];

	  if (wincap.has_security ())
d201 2
a202 40
	      HANDLE ptok;
	      cygsid tg;
	      DWORD siz;

	      if (OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok))
	        {
		  if (GetTokenInformation (ptok, TokenPrimaryGroup, &tg,
					   sizeof tg, &siz)
		      && LookupAccountSidA (NULL, tg, group_name,
					    &group_name_len, domain_name,
				            &domain_name_len, &acType))
		    {
		      char strbuf[100];
		      snprintf (linebuf, sizeof (linebuf), "%s:%s:%lu:",
		      		group_name, 
				tg.string (strbuf),
				*GetSidSubAuthority(tg,
				             *GetSidSubAuthorityCount(tg) - 1));
		      debug_printf ("Emulating /etc/group: %s", linebuf);
		      add_grp_line (linebuf);
		      group_state = emulated;
		    }
		  CloseHandle (ptok);
		}
	    }
	  if (group_state != emulated)
	    {
	      strncpy (group_name, "Administrators", sizeof (group_name));
	      if (!LookupAccountSidA (NULL, well_known_admins_sid, group_name,
				      &group_name_len, domain_name,
				      &domain_name_len, &acType))
		{
		  strcpy (group_name, "unknown");
		  debug_printf ("Failed to get local admins group name. %E");
		}
	      snprintf (linebuf, sizeof (linebuf), "%s::%u:", group_name,
			(unsigned) DEFAULT_GID);
	      debug_printf ("Emulating /etc/group: %s", linebuf);
	      add_grp_line (linebuf);
	      group_state = emulated;
d204 4
d214 1
a214 1
static
d216 1
a216 1
grp32togrp16 (struct __group16 *gp16, struct __group32 *gp32)
d218 1
a218 18
  if (!gp16 || !gp32)
    return NULL;

  /* Copying the pointers is actually unnecessary.  Just having the correct
     return type is important. */
  gp16->gr_name = gp32->gr_name;
  gp16->gr_passwd = gp32->gr_passwd;
  gp16->gr_gid = (__gid16_t) gp32->gr_gid;		/* Not loss-free */
  gp16->gr_mem = gp32->gr_mem;

  return gp16;
}

extern "C"
struct __group32 *
getgrgid32 (__gid32_t gid)
{
  struct __group32 * default_grp = NULL;
d235 1
a235 10
getgrgid (__gid16_t gid)
{
  static struct __group16 g16;

  return grp32togrp16 (&g16, getgrgid32 ((__gid32_t) gid));
}

extern "C"
struct __group32 *
getgrnam32 (const char *name)
a248 9
struct __group16 *
getgrnam (const char *name)
{
  static struct __group16 g16;

  return grp32togrp16 (&g16, getgrnam32 (name));
}

extern "C"
d256 2
a257 2
struct __group32 *
getgrent32()
a268 9
struct __group16 *
getgrent()
{
  static struct __group16 g16;

  return grp32togrp16 (&g16, getgrent32 ());
}

extern "C"
d276 1
a276 1
struct __group32 *
d288 1
a288 2
getgroups32 (int gidsetsize, __gid32_t *grouplist, __gid32_t gid,
	     const char *username)
d293 1
a293 1
  struct __group32 *gr;
a362 8
getgroups32 (int gidsetsize, __gid32_t *grouplist)
{
  return getgroups32 (gidsetsize, grouplist, myself->gid,
		      cygheap->user.name ());
}

extern "C"
int
d365 1
a365 25
  __gid32_t *grouplist32 = NULL;

  if (gidsetsize < 0)
    {
      set_errno (EINVAL);
      return -1;
    }
  if (gidsetsize > 0 && grouplist)
    grouplist32 = (__gid32_t *) alloca (gidsetsize * sizeof (__gid32_t));

  int ret = getgroups32 (gidsetsize, grouplist32, myself->gid,
			 cygheap->user.name ());

  if (gidsetsize > 0 && grouplist)
    for (int i = 0; i < ret; ++ i)
      grouplist[i] = grouplist32[i];

  return ret;
}

extern "C"
int
initgroups32 (const char *, __gid32_t)
{
  return 0;
@


1.32.2.7
log
@Merged changes from HEAD
@
text
@d180 1
a180 1
	      if (OpenProcessToken (hMainProc, TOKEN_QUERY, &ptok))
@


1.32.2.8
log
@Merged changes from HEAD
@
text
@a459 61

/* setgroups32: standards? */
extern "C"
int
setgroups32 (int ngroups, const __gid32_t *grouplist)
{
  if (ngroups < 0 || (ngroups > 0 && !grouplist))
    {
      set_errno (EINVAL);
      return -1;
    }

  if (!wincap.has_security ())
    return 0;

  cygsidlist gsids (cygsidlist_alloc, ngroups);
  struct __group32 *gr;

  if (ngroups && !gsids.sids)
    return -1;

  for (int gidx = 0; gidx < ngroups; ++gidx)
    {
      for (int gidy = 0; gidy < gidx; gidy++)
	if (grouplist[gidy] == grouplist[gidx])
	  goto found; /* Duplicate */
      for (int gidy = 0; (gr = internal_getgrent (gidy)); ++gidy)
	if (gr->gr_gid == (__gid32_t) grouplist[gidx])
	  {
	    if (gsids.addfromgr (gr))
	      goto found;
	    break;
	  }
      debug_printf ("No sid found for gid %d", grouplist[gidx]);
      gsids.free_sids ();
      set_errno (EINVAL);
      return -1;
    found:
      continue;
    }
  cygheap->user.groups.update_supp (gsids);
  return 0;
}

extern "C"
int
setgroups (int ngroups, const __gid16_t *grouplist)
{
  __gid32_t *grouplist32 = NULL;

  if (ngroups > 0 && grouplist)
    {
      grouplist32 = (__gid32_t *) alloca (ngroups * sizeof (__gid32_t));
      if (grouplist32 == NULL)
	return -1;
      for (int i = 0; i < ngroups; i++)
        grouplist32[i] = grouplist[i];
    }
  return setgroups32 (ngroups, grouplist32);

}
@


1.32.2.9
log
@Merged changes from HEAD
@
text
@d368 1
a368 2
		    if (sid == groups->Groups[pg].Sid && 
			sid != well_known_world_sid)
d519 1
@


1.32.2.10
log
@Merged changes from HEAD
@
text
@a451 2
  if (wincap.has_security ())
    cygheap->user.groups.clear_supp ();
d457 1
a457 1
initgroups (const char * name, __gid16_t gid)
d459 1
a459 1
  return initgroups32 (name, gid16togid32(gid));
@


1.32.2.11
log
@Merged changes from HEAD
@
text
@d190 1
a190 1
				group_name,
d193 1
a193 1
					     *GetSidSubAuthorityCount(tg) - 1));
d368 1
a368 1
		    if (sid == groups->Groups[pg].Sid &&
d519 1
a519 1
	grouplist32[i] = grouplist[i];
@


1.32.2.12
log
@Merged changes from HEAD
@
text
@d38 1
a38 1
#define grp_pos _reent_winsup ()->_grp_pos
d48 1
a48 1
  int len = strlen (line);
d160 1
a160 1
	  group_state.set_last_modified (gr.get_fhandle (), gr.get_fname ());
d192 2
a193 2
				*GetSidSubAuthority (tg,
					     *GetSidSubAuthorityCount (tg) - 1));
d246 1
a246 1
    read_etc_group ();
d273 1
a273 1
    read_etc_group ();
d294 1
a294 1
endgrent ()
d301 1
a301 1
getgrent32 ()
d304 1
a304 1
    read_etc_group ();
d314 1
a314 1
getgrent ()
d333 1
a333 1
    read_etc_group ();
d350 1
a350 1
    read_etc_group ();
@


1.31
log
@Update copyrights.
@
text
@d155 1
a155 2
	  free (group_buf);
	  curr_lines = max_lines = 0;
@


1.30
log
@	* cygheap.cc (init_cygheap::etc_changed): New method to signal
	a change in /etc.
	* cygheap.h (struct init_cygheap): Add member `etc_changed_h'
	and method `etc_changed'.
	* grp.cc (enum grp_state): Eliminate.
	(class grp_check): Ditto.
	(group_state): Define as `class pwdgrp_check'.
	(parse_grp): Remeber path and modification time of /etc/group file.
	* passwd.cc (enum_pwd_state): Eliminate.
	(class pwd_check): Ditto.
	(passwd_state): Define as `class pwdgrp_check'.
	(read_etc_passwd): Remember path and modification time of /etc/passwd
	file.
	* pwdgrp.h: New file.
	(enum pwdgrp_state): Substitutes `pwd_state' and `grp_state'.
	(class pwdgrp_check): Substitutes `pwd_check' and `grp_check'.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001 Cygnus Solutions.
@


1.29
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d29 1
d46 1
a46 51
/* Set to loaded when /etc/passwd has been read in by read_etc_passwd ().
   Set to emulated if passwd is emulated. */
/* Functions in this file need to check the value of passwd_state
   and read in the password file if it isn't set. */
enum grp_state {
  uninitialized = 0,
  initializing,
  emulated,
  loaded
};
class grp_check {
  grp_state state;
  FILETIME  last_modified;
  char	    grp_w32[MAX_PATH];

public:
  grp_check () : state (uninitialized)
    {
      last_modified.dwLowDateTime = last_modified.dwHighDateTime = 0;
      grp_w32[0] = '\0';
    }
  operator grp_state ()
    {
      HANDLE h;
      WIN32_FIND_DATA data;

      if (!grp_w32[0])	/* First call. */
	{
	  path_conv g ("/etc/group", PC_SYM_FOLLOW | PC_FULL);
	  if (!g.error)
	    strcpy (grp_w32, g.get_win32 ());
	}

      if ((h = FindFirstFile (grp_w32, &data)) != INVALID_HANDLE_VALUE)
	{
	  if (CompareFileTime (&data.ftLastWriteTime, &last_modified) > 0)
	    {
	      state = uninitialized;
	      last_modified = data.ftLastWriteTime;
	    }
	  FindClose (h);
	}
      return state;
    }
  void operator = (grp_state nstate)
    {
      state = nstate;
    }
};

static grp_check group_state;
d169 1
@


1.28
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d86 1
a86 1
        }
d121 1
a121 1
        grp.gr_passwd = NULL;
d126 20
a145 20
        {
          if (*++dp)
            {
              int i = 0;
              char *cp;

              for (cp = dp; (cp = strchr (cp, ',')) != NULL; ++cp)
                ++i;
              char **namearray = (char **) calloc (i + 2, sizeof (char *));
              if (namearray)
                {
                  i = 0;
                  for (cp = dp; (cp = strchr (dp, ',')) != NULL; dp = cp + 1)
                    {
                      *cp = '\0';
                      namearray[i++] = dp;
                    }
                  namearray[i++] = dp;
                  namearray[i] = NULL;
                }
d147 5
a151 5
            }
          else
            grp.gr_mem = (char **) calloc (1, sizeof (char *));
          return 1;
        }
d198 1
a198 1
        {
d259 1
a259 1
        default_grp = group_buf + i;
d261 1
a261 1
        return group_buf + i;
d336 2
a337 2
          || GetLastError () == ERROR_INSUFFICIENT_BUFFER)
        {
d361 1
a361 1
        }
d363 1
a363 1
        debug_printf ("%d = GetTokenInformation(NULL) %E", size);
d366 1
a366 1
        return cnt;
@


1.27
log
@        * grp.cc (class grp_check): New class. Make `group_state'
        a member of class grp_check.
        (read_etc_group): Free former allocated memory on reread.
        * passwd.cc (class pwd_check): New class Make `passwd_state'
        a member of class pwd_check.
        (read_etc_passwd): Free former allocated memory on reread.
@
text
@d34 3
a36 3
static struct group *group_buf = NULL;		/* group contents in memory */
static int curr_lines = 0;
static int max_lines = 0;
@


1.26
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d26 1
d55 41
a95 1
static grp_state group_state = uninitialized;
d197 10
@


1.25
log
@        * grp.cc: Add missing Copyright date 2001.
@
text
@d23 1
a27 1
#include "security.h"
@


1.24
log
@        Change well_known_admin_sid to well_known_admins_sid throughout.
        * sec_acl.cc (setacl): Never set DELETE permission. Set
        FILE_DELETE_CHILD only on readable and executable directories.
        * sec_helper.cc: Add constructor for `well_known_null_sid'.
        * security.cc (get_nt_attribute): Set S_ISVTX for directories if
        FILE_WRITE_DATA and FILE_EXECUTE but not FILE_DELETE_CHILD is set.
        Add evaluation of S_ISVTX, S_ISGID and S_ISUID from NULL ACE.
        (alloc_sd): Never set DELETE permission. Set FILE_DELETE_CHILD
        only on readable and executable directories.
        Add creation of NULL ACE for S_ISVTX, S_ISGID and S_ISUID permissions.
        * security.h: Add extern declaration for `well_known_null_sid'.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2000 Cygnus Solutions.
@


1.23
log
@forced commit
@
text
@d177 1
a177 1
				    well_known_admin_sid,
@


1.22
log
@* grp.cc (read_etc_group): Don't copy mutex on fork.
* pwd.cc (read_etc_passwd): Ditto.
* autoload.cc (LoadDLLfuncEx): Use LoadDLLprime to initialize DLL specific
area.
@
text
@@


1.21
log
@        * fork.cc (fork): Eliminate superfluous call to getuid().
        * security.h: New define `NO_SID'. Remove declarations of functions
        moved to methods into class cygsid.
        (class cygsid): Declare new methods `getfromstr', `get_sid',
        `getfrompw', `getfromgr', `get_rid', `get_uid', `get_gid', `string'
        and new constructors and operators =, == and !=.
        Declare new global cygsids `well_known_XXX_sid' substituting the
        corresponding `get_XXX_sid' functions. Remove declarations of
        these functions.
        * sec_helper.cc (well_known_admin_sid): New global variable.
        (well_known_system_sid): Ditto
        (well_known_creator_owner_sid): Ditto
        (well_known_world_sid): Ditto
        (cygsid::string): New method, substituting `convert_sid_to_string_sid'.
        (cygsid::get_sid): New method, substituting `get_sid'.
        (cygsid::getfromstr): New method, substituting
        `convert_string_sid_to_sid'.
        (cygsid::getfrompw): New method, substituting `get_pw_sid'.
        (cygsid::getfromgr): New method, substituting `get_gr_sid'.
        (cygsid::get_id): New method, substituting `get_id_from_sid'.
        (get_admin_sid): Eliminated.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * grp.cc: Use new cygsid methods and well known sids throughout.
        * registry.cc: Ditto.
        * sec_acl.cc: Ditto.
        * security.cc: Ditto.
        * shared.cc: Ditto.
        * syscalls.cc (seteuid): Ditto. Eliminate redundant conditional.
        * uinfo.cc (internal_getlogin): Ditto.
        * spawn.cc (spawn_guts) Revert previous patch.
@
text
@d143 1
a143 1
  static pthread_mutex_t etc_group_mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;
@


1.20
log
@        * grp.cc: Eliminate MAX_DOMAIN_NAME define.
        (read_etc_group): Substitute MAX_DOMAIN_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * passwd.cc (parse_pwd): Don't force pw_name to be lower case.
        * sec_helper.cc: Substitute MAX_USER_NAME by UNLEN,
        MAX_COMPUTERNAME_LENGTH by INTERNET_MAX_HOST_NAME_LENGTH throughout.
        (lookup_name): Slight cleanup.
        * security.cc (alloc_sd): Substitute MAX_USER_NAME by UNLEN.
        * security.h: Define DEFAULT_UID as DOMAIN_USER_RID_ADMIN and
        DEFAULT_GID as DOMAIN_ALIAS_RID_ADMINS.
        * shared.cc (memory_init): Substitute MAX_USER_NAME by UNLEN.
        * thread.h: Ditto.
        * uinfo.cc (internal_getlogin): Substitute MAX_USER_NAME by UNLEN.
        Substitute MAX_COMPUTERNAME_LENGTH and MAX_HOST_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * winsup.h: Include lmcons.h. Eliminate MAX_USER_NAME and
        MAX_HOST_NAME. Move DEFAULT_UID and DEFAULT_GID to security.h.
@
text
@a127 2
extern PSID get_admin_sid ();

d177 1
a177 1
				    get_admin_sid () ,
d295 1
a295 1
		if (get_gr_sid (sid, gr))
@


1.19
log
@        * autoload.cc: Add LoadDLLfunc statements for SetTokenInformation@@16.
        * cygheap.cc: Include security.h.
        * grp.cc (internal_getgrent): New function.
        (getgroups): Rearranged using `internal_getgrent' and the new
        `cygsid' class.
        * passwd.cc (internal_getpwent): New function.
        * sec_acl.cc: Use new `cygsid' class throughout.
        (acl_access): Use `internal_getgrent' instead of `getgrent'.
        * sec_helper.cc: Use new `cygsid' class throughout.
        (get_id_from_sid): Use `internal_getgrent' instead of `getgrent'.
        Use `internal_getpwent' instead of `getpwent'.
        * security.cc: Use new `cygsid' class throughout.
        * security.h: Move `MAX_SID_LEN' from winsup.h to here.
        Add extern declarations for `internal_getgrent' and `internal_getpwent'.
        (class cygsid): New class.
        * shared.cc (sec_user): Use new `cygsid' class.
        * syscalls.cc (seteuid): Try to set owner to user and primary group to
        current group in impersonation token before performing impersonation.
        (setegid): Try to set primary group in process token to the new group
        if ntsec is on.
        * uinfo.cc (internal_getlogin): Use new `cygsid' class.
        Try to set owner to user and primary group to current group in process
        token if the process has been started from a non cygwin process.
        (uinfo_init): Set primary group only if the process has been started
        from a non cygwin process.
        * winsup.h: Move define for `MAX_SID_LEN' to security.h.
@
text
@d16 1
a31 2
#define MAX_DOMAIN_NAME	100

d140 2
a141 2
  char group_name [MAX_USER_NAME];
  DWORD group_name_len = MAX_USER_NAME;
d174 2
a175 2
	  char domain_name [MAX_DOMAIN_NAME];
	  DWORD domain_name_len = MAX_DOMAIN_NAME;
@


1.18
log
@        * grp.cc (getgroups): Change so that SIDs get compared instead
        of strings to SIDs.
@
text
@d261 12
a276 1
  char buf[4096];
d279 1
d285 1
a285 2
      OpenProcessToken (hMainProc, TOKEN_QUERY, &hToken) &&
      GetTokenInformation (hToken, TokenGroups, buf, 4096, &size))
d287 5
a291 3
      TOKEN_GROUPS *groups = (TOKEN_GROUPS *) buf;
      char ssid[MAX_SID_LEN];
      PSID sid = (PSID) ssid;
d293 1
a293 4
      for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
        {
	  struct group *gr;
	  while ((gr = getgrent ()) != NULL)
d295 17
a311 10
	      if (get_gr_sid (sid, gr) &&
	          EqualSid (sid, groups->Groups[pg].Sid))
	        {
		  if (cnt < gidsetsize)
		    grouplist[cnt] = gr->gr_gid;
		  ++cnt;
		  if (gidsetsize && cnt > gidsetsize)
		    goto error;
		  break;
		}
a312 1
	  endgrent ();
d314 2
d317 2
a318 1
      return cnt;
d320 13
a332 4
  else
    {
      for (int i = 0; i < curr_lines; ++i)
	if (gid == group_buf[i].gr_gid)
d335 1
a335 1
	      grouplist[cnt] = group_buf[i].gr_gid;
d340 1
a340 12
	else if (group_buf[i].gr_mem)
	  for (int gi = 0; group_buf[i].gr_mem[gi]; ++gi)
	    if (strcasematch (username, group_buf[i].gr_mem[gi]))
	      {
		if (cnt < gidsetsize)
		  grouplist[cnt] = group_buf[i].gr_gid;
		++cnt;
		if (gidsetsize && cnt > gidsetsize)
		  goto error;
	      }
      return cnt;
    }
@


1.17
log
@        * Makefile.in: Add object files `sec_helper.cc' and `sec_acl.cc'.
        * security.cc: Swap out several functions.
        * sec_acl.cc: New file. Move Sun compatibel ACL functions from
        `security.cc' to here.
        * sec_helper.cc: New file. Move security helper functions from
        `security.cc' to here.
        * security.h: Changed to accomodate the above changes.

        * grp.cc: Replace `group_in_memory_p' by `group_state'.
        Eliminate group_sem throughout.
        (enum grp_state): New enumeration type.
        (read_etc_group): Make race safe.
        * security.cc: Eliminate group_sem throughout.
@
text
@d277 2
a278 1
      char ssid[256];
d282 2
a283 2
	  convert_sid_to_string_sid (groups->Groups[pg].Sid, ssid);
          for (int gg = 0; gg < curr_lines; ++gg)
d285 2
a286 2
	      if (group_buf[gg].gr_passwd &&
	          !strcmp (group_buf[gg].gr_passwd, ssid))
d289 1
a289 1
		    grouplist[cnt] = group_buf[gg].gr_gid;
d296 1
@


1.16
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d45 11
a55 6
/* Set to 1 when /etc/group has been read in by read_etc_group (). */
/* Functions in this file need to check the value of group_in_memory_p
   and read in the group file if it isn't set. */
/* FIXME: This should be static but this is called in uinfo_init outside
   this file */
int group_in_memory_p = 0;
a139 1
  extern int group_sem;
d146 2
a147 3
  ++group_sem;
  FILE *f = fopen (etc_group, "rt");
  --group_sem;
d149 2
a150 1
  if (f)
d152 3
a154 5
      while (fgets (linebuf, sizeof (linebuf), f) != NULL)
	{
	  if (strlen (linebuf))
	    add_grp_line (linebuf);
	}
d156 1
a156 3
      fclose (f);
    }
  else /* /etc/group doesn't exist -- create default one in memory */
d158 5
a162 11
      char domain_name [MAX_DOMAIN_NAME];
      DWORD domain_name_len = MAX_DOMAIN_NAME;
      SID_NAME_USE acType;
      debug_printf ("Emulating /etc/group");
      if (! LookupAccountSidA (NULL ,
				get_admin_sid () ,
				group_name,
				&group_name_len,
				domain_name,
				&domain_name_len,
				&acType))
d164 5
a168 3
	  strcpy (group_name, "unknown");
	  debug_printf ("Failed to get local admins group name. %E");
        }
d170 25
a194 2
      snprintf (linebuf, sizeof (linebuf), "%s::%u:\n", group_name, DEFAULT_GID);
      add_grp_line (linebuf);
d197 1
a197 1
  group_in_memory_p = 1;
d205 1
a205 1
  if (!group_in_memory_p)
d223 1
a223 1
  if (!group_in_memory_p)
d245 1
a245 1
  if (!group_in_memory_p)
d269 1
a269 1
  if (!group_in_memory_p)
@


1.15
log
@        * grp.cc (getgroups): Avoid crash if passwd field if /etc/group is
        empty.
@
text
@d22 2
@


1.14
log
@        * grp.cc (getgroups): If `allow_ntsec' is set, use the process token
        information to evaluate the groups list.
@
text
@d263 2
a264 1
	      if (!strcmp (group_buf[gg].gr_passwd, ssid))
@


1.13
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@d24 1
d243 5
d251 6
a256 1
  int cnt = 0;
d258 42
a299 20
  for (int i = 0; i < curr_lines; ++i)
    if (gid == group_buf[i].gr_gid)
      {
        if (cnt < gidsetsize)
          grouplist[cnt] = group_buf[i].gr_gid;
        ++cnt;
        if (gidsetsize && cnt > gidsetsize)
          goto error;
      }
    else if (group_buf[i].gr_mem)
      for (int gi = 0; group_buf[i].gr_mem[gi]; ++gi)
        if (strcasematch (username, group_buf[i].gr_mem[gi]))
          {
            if (cnt < gidsetsize)
              grouplist[cnt] = group_buf[i].gr_gid;
            ++cnt;
            if (gidsetsize && cnt > gidsetsize)
              goto error;
          }
  return cnt;
@


1.12
log
@        * cygheap.cc (cygheap_root::cygheap_root): New function.
        (cygheap_root::~cygheap_root): Ditto.
        (cygheap_root::operator=): Ditto.
        (cygheap_user::~cygheap_user): Ditto.
        (cygheap_user::set_name): Ditto.
        (cygheap_user::set_logsrv): Ditto.
        (cygheap_user::set_domain): Ditto.
        (cygheap_user::set_sid): Ditto.
        * cygheap.h (cygheap_root): New class.
        (cygheap_user): Ditto.
        (init_cygheap): Change type of `root' member to cygheap_root.
        Add `user' member.
        * dir.cc (opendir): Use new `cygheap_root' class.
        * dcrt0.cc (dll_crt0_1): Use new `cygheap_user' class.
        * fork.cc (fork_parent): Ditto.
        * grp.cc (getgroups): Ditto.
        * passwd.cc (search_for): Ditto.
        * path.cc: Use new `cygheap_root' class throughout.
        * pinfo.h (_pinfo): Remove `use_psid'. Move `username', `psid',
        `logsrv', `domain', `orig_{uid,gid}' and `real_{uid,gid}' to
        cygheap_user class.
        * security.cc: Use new `cygheap_user' class throughout.
        * shared.cc (sec_user): Ditto.
        * sigproc.cc (proc_subproc): Remove copy statements for user
        related information moved to `cygheap_user' class.
        * spawn.cc (spawn_guts): Invalidate current chroot settings
        when creating Windows environment. Use new `cygheap_user' class.
        * syscalls.cc: Use new `cygheap_user' class throughout.
        * uinfo.cc: Ditto.
        * uinfo.cc (internal_getlogin): Change parameters to reflect the
        move of user information to cygheap.
@
text
@d133 2
a134 2
  char linebuf [ 200 ];
  char group_name [ MAX_USER_NAME ];
d155 1
a155 1
      char domain_name [ MAX_DOMAIN_NAME ];
@


1.11
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d22 1
d277 1
a277 8
#if 0
  if (gidsetsize <= 0)
      return 0;
  grouplist[0] = myself->gid;
  return 1;
#else
  return getgroups (gidsetsize, grouplist, myself->gid, myself->username);
#endif
@


1.10
log
@* path.cc (readlink): Check if buffer length is positive.  Truncate output to
buffer length.  Don't terminate buffer with '\0'.
@
text
@a18 1
#include "thread.h"
@


1.9
log
@* grp.cc (getgroups): fail with EINVAL if array is not large
enough to hold all supplementary group IDs.
@
text
@d269 1
a269 1
  set_errno ( EINVAL );
@


1.8
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d18 1
d23 1
d253 2
a254 2
        if (gidsetsize && cnt >= gidsetsize)
          goto out;
d263 2
a264 2
            if (gidsetsize && cnt >= gidsetsize)
              goto out;
a265 1
out:
d267 4
@


1.7
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d18 3
@


1.6
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d18 1
@


1.5
log
@Changes by  Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>
        * assert.cc (__assert): Reduce dependency on newlib.
        * exec.cc: Eliminate unnecessary inclusion of ctype.h.
        * glob.c: Ditto.
        * hinfo.cc: Ditto.
        * init.cc: Ditto.
        * strace.cc: Ditto.
        * tty.cc: Ditto.
        * grp.cc (parse_grp): Eliminate atoi.
        * passwd.cc (grab_int): Ditto.
        * grp.cc (getgroups): Eliminate str{n,}casecmp.
        * path.cc (get_raw_device_number): Ditto.
        * path.cc (sort_by_native_name): Ditto.
        * spawn.cc (iscmd): Ditto.
        * uinfo.cc (internal_getlogin): Ditto.
@
text
@d14 1
a17 1
#include "winsup.h"
@


1.4
log
@* grp.cc (read_etc_group): Open file in text mode.
* pwd.cc (read_etc_passwd): Ditto.
* shared.h: Bump PROC_MAGIC.
@
text
@d69 1
a69 1
      grp.gr_gid = atoi (dp);
d252 1
a252 1
        if (! strcasecmp (username, group_buf[i].gr_mem[gi]))
@


1.3
log
@        * grp.cc (parse_grp): Save empty array instead of
        NULL in gr_mem if no supplementary group is given.
@
text
@d134 1
a134 1
  FILE *f = fopen (etc_group, "r");
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d95 1
a95 1
            grp.gr_mem = NULL;
@


1.1
log
@Initial revision
@
text
@d280 1
a280 1
initgroups (const char *user, gid_t grp)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
