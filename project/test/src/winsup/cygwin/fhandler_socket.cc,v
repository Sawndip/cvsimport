head	1.317;
access;
symbols
	cygwin-1_7_35-release:1.317
	cygwin-1_7_34-release:1.317
	cygwin-1_7_33-release:1.302.2.5
	cygwin-1_7_32-release:1.302.2.4
	cygwin-1_7_31-release:1.302.2.4
	cygwin-1_7_30-release:1.302.2.1
	cygwin-1_7_29-release:1.302
	cygwin-1_7_29-release-branchpoint:1.302.0.2
	cygwin-pre-user-db:1.302
	cygwin-1_7_28-release:1.302
	cygwin-1_7_27-release:1.302
	cygwin-1_7_26-release:1.302
	cygwin-1_7_25-release:1.301
	cygwin-1_7_24-release:1.301
	cygwin-1_7_23-release:1.301
	cygwin-1_7_22-release:1.301
	cygwin-1_7_21-release:1.301
	cygwin-1_7_20-release:1.301
	cygwin-1_7_19-release:1.301
	cygwin-64bit-postmerge:1.300
	cygwin-64bit-premerge-branch:1.299.0.2
	cygwin-64bit-premerge:1.299
	cygwin-1_7_18-release:1.299
	post-ptmalloc3:1.291.2.13
	pre-ptmalloc3:1.291.2.13
	cygwin-1_7_17-release:1.292
	cygwin-64bit-branch:1.291.0.2
	cygwin-1_7_16-release:1.288
	cygwin-1_7_15-release:1.285
	cygwin-1_7_14_2-release:1.285
	cygwin-1_7_14-release:1.285
	cygwin-1_7_12-release:1.285
	cygwin-1_7_11-release:1.284
	cygwin-1_7_10-release:1.284
	signal-rewrite:1.281.0.2
	pre-notty:1.276
	cygwin-1_7_9-release:1.269
	cv-post-1_7_9:1.269.0.2
	cygwin-1_7_8-release:1.268
	cygwin-1_7_7-release:1.262
	cygwin-1_7_5-release:1.261
	cygwin-1_7_4-release:1.261
	cygwin-1_7_3-release:1.261
	cygwin-1_7_2-release:1.260
	fifo_doover3:1.256.0.2
	cygwin-1_7_1-release:1.254
	prefifo:1.241
	cv-branch-2:1.236.0.2
	pre-ripout-set_console_state_for_spawn:1.227
	EOL_registry_mounts:1.222
	preoverlapped:1.210
	drop_9x_support_start:1.205
	cr-0x5f1:1.191.0.2
	cv-branch:1.189.0.2
	pre-ptymaster-archetype:1.186
	cr-0x3b58:1.178.0.4
	cr-0x5ef:1.178.0.2
	after-mmap-privanon-noreserve:1.176
	after-mmap-revamp:1.176
	before-mmap-revamp:1.176
	cgf-more-exit-sync:1.172
	post_wait_sig_exit:1.169
	pre_wait_sig_exit:1.169
	reparent-point:1.142
	noreparent:1.142.0.2
	cr-0x5e6:1.137.0.2
	cr-0x9e:1.115.0.6
	cr-0x9d:1.115.0.4
	cgf-deleteme:1.115.0.2
	pre-sigrewrite:1.114
	corinna-01:1.111
	cr-0x9c:1.109.0.4
	cr-0x9b:1.109.0.2
	cr-0x99:1.108
	Z-emcb-cygwin_daemon:1.108.0.2
	w32api-2_2:1.78
	mingw-runtime-2_4:1.78
	pre-cgf-merge:1.109
	cgf-dev-branch:1.75.0.6
	predaemon:1.40
	cygwin_daemon_merge_HEAD:1.40
	pregp02r1:1.39.0.2
	cygnus_cvs_20020108_pre:1.37
	Z-cygwin_daemon_merge-new_HEAD:1.65
	Z-cygwin_daemon_merge_HEAD:1.65
	cygwin_daemon:1.24.0.2;
locks; strict;
comment	@// @;


1.317
date	2014.10.26.18.47.23;	author corinna;	state Exp;
branches;
next	1.316;

1.316
date	2014.10.14.19.43.09;	author corinna;	state Exp;
branches;
next	1.315;

1.315
date	2014.10.14.19.08.27;	author corinna;	state Exp;
branches;
next	1.314;

1.314
date	2014.10.11.18.28.04;	author corinna;	state Exp;
branches;
next	1.313;

1.313
date	2014.10.11.16.37.29;	author corinna;	state Exp;
branches;
next	1.312;

1.312
date	2014.10.11.12.14.29;	author corinna;	state Exp;
branches;
next	1.311;

1.311
date	2014.10.11.10.50.36;	author corinna;	state Exp;
branches;
next	1.310;

1.310
date	2014.08.22.09.21.30;	author corinna;	state Exp;
branches;
next	1.309;

1.309
date	2014.08.19.09.47.12;	author corinna;	state Exp;
branches;
next	1.308;

1.308
date	2014.08.18.11.09.56;	author corinna;	state Exp;
branches;
next	1.307;

1.307
date	2014.07.24.13.21.02;	author corinna;	state Exp;
branches;
next	1.306;

1.306
date	2014.07.07.12.57.03;	author corinna;	state Exp;
branches;
next	1.305;

1.305
date	2014.06.16.13.01.40;	author corinna;	state Exp;
branches;
next	1.304;

1.304
date	2014.05.13.16.07.50;	author corinna;	state Exp;
branches;
next	1.303;

1.303
date	2014.04.24.13.44.22;	author corinna;	state Exp;
branches;
next	1.302;

1.302
date	2013.10.25.12.21.59;	author corinna;	state Exp;
branches
	1.302.2.1;
next	1.301;

1.301
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.300;

1.300
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.299;

1.299
date	2013.04.08.17.34.34;	author corinna;	state Exp;
branches;
next	1.298;

1.298
date	2013.03.07.15.39.35;	author corinna;	state Exp;
branches;
next	1.297;

1.297
date	2013.03.07.11.04.28;	author corinna;	state Exp;
branches;
next	1.296;

1.296
date	2013.02.04.12.21.56;	author corinna;	state Exp;
branches;
next	1.295;

1.295
date	2013.02.04.12.04.20;	author corinna;	state Exp;
branches;
next	1.294;

1.294
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.293;

1.293
date	2012.11.26.13.28.52;	author corinna;	state Exp;
branches;
next	1.292;

1.292
date	2012.08.15.19.07.41;	author cgf;	state Exp;
branches;
next	1.291;

1.291
date	2012.08.01.09.00.53;	author corinna;	state Exp;
branches
	1.291.2.1;
next	1.290;

1.290
date	2012.07.23.04.36.48;	author cgf;	state Exp;
branches;
next	1.289;

1.289
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches;
next	1.288;

1.288
date	2012.07.06.13.52.17;	author corinna;	state Exp;
branches;
next	1.287;

1.287
date	2012.06.19.00.38.01;	author cgf;	state Exp;
branches;
next	1.286;

1.286
date	2012.06.19.00.31.14;	author cgf;	state Exp;
branches;
next	1.285;

1.285
date	2012.03.08.09.36.11;	author corinna;	state Exp;
branches;
next	1.284;

1.284
date	2011.12.04.17.58.24;	author cgf;	state Exp;
branches;
next	1.283;

1.283
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.282;

1.282
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.281;

1.281
date	2011.08.23.13.07.24;	author corinna;	state Exp;
branches;
next	1.280;

1.280
date	2011.08.01.17.01.37;	author corinna;	state Exp;
branches;
next	1.279;

1.279
date	2011.07.31.12.37.52;	author corinna;	state Exp;
branches;
next	1.278;

1.278
date	2011.07.29.12.47.54;	author corinna;	state Exp;
branches;
next	1.277;

1.277
date	2011.07.05.09.59.34;	author corinna;	state Exp;
branches;
next	1.276;

1.276
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2011.05.11.08.20.17;	author corinna;	state Exp;
branches;
next	1.274;

1.274
date	2011.05.06.10.56.37;	author corinna;	state Exp;
branches;
next	1.273;

1.273
date	2011.04.30.16.34.47;	author corinna;	state Exp;
branches;
next	1.272;

1.272
date	2011.04.18.11.44.16;	author corinna;	state Exp;
branches;
next	1.271;

1.271
date	2011.04.02.11.30.27;	author corinna;	state Exp;
branches;
next	1.270;

1.270
date	2011.03.29.11.07.23;	author corinna;	state Exp;
branches;
next	1.269;

1.269
date	2011.03.08.14.26.14;	author corinna;	state Exp;
branches
	1.269.2.1;
next	1.268;

1.268
date	2011.02.21.17.01.05;	author corinna;	state Exp;
branches;
next	1.267;

1.267
date	2011.02.15.15.56.01;	author corinna;	state Exp;
branches;
next	1.266;

1.266
date	2011.01.31.08.53.57;	author corinna;	state Exp;
branches;
next	1.265;

1.265
date	2011.01.30.21.52.11;	author corinna;	state Exp;
branches;
next	1.264;

1.264
date	2011.01.28.11.17.29;	author corinna;	state Exp;
branches;
next	1.263;

1.263
date	2010.09.25.20.06.21;	author corinna;	state Exp;
branches;
next	1.262;

1.262
date	2010.04.13.19.56.30;	author corinna;	state Exp;
branches;
next	1.261;

1.261
date	2010.03.30.16.20.15;	author corinna;	state Exp;
branches;
next	1.260;

1.260
date	2010.03.22.10.47.53;	author corinna;	state Exp;
branches;
next	1.259;

1.259
date	2010.01.16.10.22.58;	author corinna;	state Exp;
branches;
next	1.258;

1.258
date	2010.01.15.21.34.27;	author corinna;	state Exp;
branches;
next	1.257;

1.257
date	2010.01.15.15.40.05;	author corinna;	state Exp;
branches;
next	1.256;

1.256
date	2009.12.28.17.24.03;	author corinna;	state Exp;
branches;
next	1.255;

1.255
date	2009.12.18.20.32.03;	author corinna;	state Exp;
branches;
next	1.254;

1.254
date	2009.12.02.15.23.03;	author corinna;	state Exp;
branches;
next	1.253;

1.253
date	2009.11.23.14.50.14;	author corinna;	state Exp;
branches;
next	1.252;

1.252
date	2009.11.23.12.21.39;	author corinna;	state Exp;
branches;
next	1.251;

1.251
date	2009.11.17.10.43.00;	author corinna;	state Exp;
branches;
next	1.250;

1.250
date	2009.10.30.19.58.52;	author corinna;	state Exp;
branches;
next	1.249;

1.249
date	2009.10.12.11.57.29;	author corinna;	state Exp;
branches;
next	1.248;

1.248
date	2009.09.29.08.46.29;	author corinna;	state Exp;
branches;
next	1.247;

1.247
date	2009.09.22.14.27.57;	author corinna;	state Exp;
branches;
next	1.246;

1.246
date	2009.08.14.06.58.44;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2009.08.13.15.44.29;	author corinna;	state Exp;
branches;
next	1.244;

1.244
date	2009.08.13.10.26.42;	author corinna;	state Exp;
branches;
next	1.243;

1.243
date	2009.08.12.14.48.16;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2009.08.04.22.35.35;	author cgf;	state Exp;
branches;
next	1.241;

1.241
date	2009.07.06.20.30.34;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2009.07.01.09.16.17;	author corinna;	state Exp;
branches;
next	1.239;

1.239
date	2009.06.30.10.36.40;	author corinna;	state Exp;
branches;
next	1.238;

1.238
date	2009.06.17.08.23.17;	author corinna;	state Exp;
branches;
next	1.237;

1.237
date	2009.06.13.16.13.01;	author corinna;	state Exp;
branches;
next	1.236;

1.236
date	2009.03.09.14.40.44;	author corinna;	state Exp;
branches;
next	1.235;

1.235
date	2009.01.20.11.16.59;	author corinna;	state Exp;
branches;
next	1.234;

1.234
date	2008.11.26.17.21.03;	author cgf;	state Exp;
branches;
next	1.233;

1.233
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.232;

1.232
date	2008.08.14.14.05.04;	author corinna;	state Exp;
branches;
next	1.231;

1.231
date	2008.07.27.10.20.49;	author corinna;	state Exp;
branches;
next	1.230;

1.230
date	2008.07.14.20.22.02;	author corinna;	state Exp;
branches;
next	1.229;

1.229
date	2008.07.14.15.56.11;	author corinna;	state Exp;
branches;
next	1.228;

1.228
date	2008.07.08.20.12.46;	author corinna;	state Exp;
branches;
next	1.227;

1.227
date	2008.04.21.12.46.57;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2008.04.18.20.30.04;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2008.04.18.20.13.37;	author corinna;	state Exp;
branches;
next	1.224;

1.224
date	2008.04.16.17.22.14;	author corinna;	state Exp;
branches;
next	1.223;

1.223
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.222;

1.222
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.221;

1.221
date	2008.03.27.10.43.14;	author corinna;	state Exp;
branches;
next	1.220;

1.220
date	2008.03.07.14.47.48;	author corinna;	state Exp;
branches;
next	1.219;

1.219
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2007.12.05.15.10.19;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2007.11.28.15.54.17;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2007.10.10.16.07.46;	author corinna;	state Exp;
branches;
next	1.215;

1.215
date	2007.08.16.16.59.25;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2007.08.16.15.07.41;	author corinna;	state Exp;
branches;
next	1.213;

1.213
date	2007.08.15.15.17.05;	author corinna;	state Exp;
branches;
next	1.212;

1.212
date	2007.08.13.19.15.47;	author corinna;	state Exp;
branches;
next	1.211;

1.211
date	2007.08.13.17.16.04;	author corinna;	state Exp;
branches;
next	1.210;

1.210
date	2007.06.21.15.57.54;	author corinna;	state Exp;
branches;
next	1.209;

1.209
date	2007.06.14.16.02.31;	author corinna;	state Exp;
branches;
next	1.208;

1.208
date	2007.05.15.16.33.20;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2007.02.27.12.58.56;	author corinna;	state Exp;
branches;
next	1.206;

1.206
date	2007.02.22.11.17.01;	author corinna;	state Exp;
branches;
next	1.205;

1.205
date	2007.02.20.09.48.31;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2007.01.21.22.54.04;	author corinna;	state Exp;
branches;
next	1.202;

1.202
date	2007.01.16.12.01.36;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2007.01.04.10.11.27;	author corinna;	state Exp;
branches;
next	1.200;

1.200
date	2006.08.10.14.16.24;	author cgf;	state Exp;
branches;
next	1.199;

1.199
date	2006.08.10.14.15.00;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2006.07.31.14.27.56;	author corinna;	state Exp;
branches;
next	1.197;

1.197
date	2006.07.31.12.55.20;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2006.07.28.08.50.46;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2006.07.27.13.58.54;	author corinna;	state Exp;
branches;
next	1.194;

1.194
date	2006.07.27.09.18.28;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2006.07.27.09.11.38;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2006.07.25.19.23.23;	author corinna;	state Exp;
branches;
next	1.191;

1.191
date	2006.07.13.12.59.53;	author corinna;	state Exp;
branches
	1.191.2.1;
next	1.190;

1.190
date	2006.07.07.15.44.19;	author corinna;	state Exp;
branches;
next	1.189;

1.189
date	2006.07.04.20.10.43;	author corinna;	state Exp;
branches
	1.189.2.1;
next	1.188;

1.188
date	2006.06.26.12.12.11;	author corinna;	state Exp;
branches;
next	1.187;

1.187
date	2006.06.14.20.19.10;	author corinna;	state Exp;
branches;
next	1.186;

1.186
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2006.04.21.11.35.44;	author corinna;	state Exp;
branches;
next	1.184;

1.184
date	2006.04.05.16.53.12;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2006.02.06.17.50.23;	author corinna;	state Exp;
branches;
next	1.182;

1.182
date	2006.02.01.11.10.53;	author corinna;	state Exp;
branches;
next	1.181;

1.181
date	2006.01.29.12.23.44;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2006.01.23.15.10.57;	author corinna;	state Exp;
branches;
next	1.179;

1.179
date	2006.01.20.10.22.38;	author corinna;	state Exp;
branches;
next	1.178;

1.178
date	2005.12.22.05.57.54;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2005.12.08.10.13.57;	author corinna;	state Exp;
branches;
next	1.176;

1.176
date	2005.11.14.04.28.44;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2005.11.13.16.24.40;	author corinna;	state Exp;
branches;
next	1.174;

1.174
date	2005.10.22.16.02.15;	author corinna;	state Exp;
branches;
next	1.173;

1.173
date	2005.10.22.15.11.49;	author corinna;	state Exp;
branches;
next	1.172;

1.172
date	2005.10.17.21.22.18;	author corinna;	state Exp;
branches;
next	1.171;

1.171
date	2005.09.28.19.22.22;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2005.09.28.19.02.50;	author corinna;	state Exp;
branches;
next	1.169;

1.169
date	2005.08.18.13.14.15;	author corinna;	state Exp;
branches;
next	1.168;

1.168
date	2005.08.12.02.39.12;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2005.07.03.02.40.28;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2005.06.12.12.01.09;	author corinna;	state Exp;
branches;
next	1.164;

1.164
date	2005.06.10.21.47.24;	author corinna;	state Exp;
branches;
next	1.163;

1.163
date	2005.05.03.14.07.19;	author corinna;	state Exp;
branches;
next	1.162;

1.162
date	2005.05.02.03.50.07;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2005.04.18.18.56.51;	author corinna;	state Exp;
branches;
next	1.160;

1.160
date	2005.04.13.17.13.41;	author corinna;	state Exp;
branches;
next	1.159;

1.159
date	2005.04.06.18.50.13;	author corinna;	state Exp;
branches;
next	1.158;

1.158
date	2005.03.24.14.04.05;	author corinna;	state Exp;
branches;
next	1.157;

1.157
date	2005.03.23.17.27.17;	author corinna;	state Exp;
branches;
next	1.156;

1.156
date	2005.03.22.19.00.29;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2005.03.21.18.56.50;	author corinna;	state Exp;
branches;
next	1.154;

1.154
date	2005.03.17.11.56.30;	author corinna;	state Exp;
branches;
next	1.153;

1.153
date	2005.03.09.23.00.20;	author corinna;	state Exp;
branches;
next	1.152;

1.152
date	2005.03.08.16.33.17;	author corinna;	state Exp;
branches;
next	1.151;

1.151
date	2005.03.04.08.36.43;	author corinna;	state Exp;
branches;
next	1.150;

1.150
date	2005.02.28.13.11.49;	author corinna;	state Exp;
branches;
next	1.149;

1.149
date	2005.02.23.17.39.45;	author corinna;	state Exp;
branches;
next	1.148;

1.148
date	2005.02.20.11.44.32;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2005.02.20.04.25.31;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2005.02.19.21.53.36;	author corinna;	state Exp;
branches;
next	1.145;

1.145
date	2005.02.19.20.03.18;	author corinna;	state Exp;
branches;
next	1.144;

1.144
date	2005.02.01.15.11.43;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2005.01.31.10.28.53;	author corinna;	state Exp;
branches;
next	1.142;

1.142
date	2004.10.26.21.13.50;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2004.09.03.01.53.11;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2004.08.19.10.58.34;	author corinna;	state Exp;
branches;
next	1.139;

1.139
date	2004.06.23.07.36.21;	author corinna;	state Exp;
branches;
next	1.138;

1.138
date	2004.05.28.19.50.05;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2004.05.16.15.38.03;	author corinna;	state Exp;
branches;
next	1.136;

1.136
date	2004.05.16.04.18.50;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2004.05.15.16.10.41;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2004.05.15.16.09.04;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2004.05.10.15.21.01;	author corinna;	state Exp;
branches;
next	1.132;

1.132
date	2004.05.07.07.51.31;	author corinna;	state Exp;
branches;
next	1.131;

1.131
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.130;

1.130
date	2004.04.09.12.09.45;	author corinna;	state Exp;
branches;
next	1.129;

1.129
date	2004.04.09.08.43.28;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2004.04.03.19.07.59;	author corinna;	state Exp;
branches;
next	1.127;

1.127
date	2004.04.01.17.00.21;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2004.04.01.09.48.14;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2004.03.31.15.33.33;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2004.03.31.10.10.59;	author corinna;	state Exp;
branches;
next	1.123;

1.123
date	2004.03.31.09.13.54;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2004.03.29.19.41.17;	author corinna;	state Exp;
branches;
next	1.121;

1.121
date	2004.02.09.11.30.57;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2004.02.02.21.00.07;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2004.02.02.20.33.09;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2004.01.24.00.14.27;	author phumblet;	state Exp;
branches;
next	1.116;

1.116
date	2004.01.23.23.05.32;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches
	1.115.6.1;
next	1.114;

1.114
date	2003.11.26.13.23.27;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2003.11.19.18.50.20;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.111;

1.111
date	2003.09.25.03.51.50;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2003.09.10.10.01.32;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2003.07.05.18.20.13;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2003.06.30.13.07.36;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2003.06.07.11.05.35;	author tpfaff;	state Exp;
branches;
next	1.103;

1.103
date	2003.06.03.14.05.17;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2003.06.02.21.20.22;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2003.06.02.21.14.39;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2003.06.02.17.52.16;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2003.05.29.16.16.59;	author corinna;	state Exp;
branches;
next	1.98;

1.98
date	2003.05.28.22.05.56;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2003.05.27.18.30.29;	author tpfaff;	state Exp;
branches;
next	1.96;

1.96
date	2003.05.27.07.50.00;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2003.05.26.11.11.22;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2003.05.20.17.39.46;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2003.05.20.15.22.09;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2003.05.11.21.52.09;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2003.05.11.00.10.10;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2003.04.01.17.17.46;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2003.03.20.08.53.28;	author corinna;	state Exp;
branches;
next	1.88;

1.88
date	2003.03.11.16.49.58;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2003.03.11.13.05.36;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2003.03.09.20.31.07;	author cgf;	state Exp;
branches
	1.86.2.1;
next	1.85;

1.85
date	2003.03.04.16.35.00;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2003.03.01.16.17.55;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2003.03.01.15.28.24;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2003.02.27.21.41.28;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2003.02.21.14.59.35;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2003.02.21.14.29.18;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2003.02.20.14.14.37;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2003.02.03.15.34.52;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2003.01.28.15.33.50;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2003.01.26.06.42.40;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2002.12.14.04.01.32;	author cgf;	state Exp;
branches
	1.75.4.1
	1.75.6.1;
next	1.74;

1.74
date	2002.11.28.00.41.02;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2002.11.28.00.40.20;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2002.11.27.23.44.14;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2002.11.07.10.22.26;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2002.11.05.16.49.58;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2002.10.21.01.00.56;	author cgf;	state Exp;
branches
	1.69.4.1;
next	1.68;

1.68
date	2002.10.20.04.46.31;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2002.09.30.15.17.44;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2002.09.30.04.35.17;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2002.09.04.09.39.34;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2002.08.30.15.47.09;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2002.08.28.10.18.20;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2002.08.27.09.24.50;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2002.08.26.09.57.26;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2002.08.12.13.54.12;	author scottc;	state Exp;
branches;
next	1.57;

1.57
date	2002.08.08.17.03.20;	author scottc;	state Exp;
branches;
next	1.56;

1.56
date	2002.08.07.10.08.17;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2002.07.13.20.00.25;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2002.07.06.11.16.07;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2002.07.05.18.26.22;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.04.17.18.14;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.04.15.32.34;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2002.07.03.09.20.24;	author corinna;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2002.06.26.19.25.09;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.24.02.23.14;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.10.11.07.44;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.08.01.35.54;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.08.01.24.58;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.04.16.38.13;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.24.05.44.10;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.05.18.02.53;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.25.17.47.46;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2002.02.09.10.40.48;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.08.11.54.10;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.01.16.25.31;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.05.06.09.07;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.30.11.48.36;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.30.10.07.39;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2001.10.30.07.43.46;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2001.10.29.05.28.24;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.24.04.16.45;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.22.18.39.22;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.14.04.14.23;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2001.10.13.01.35.15;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.20.11.35.49;	author corinna;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.09.20.11.29.48;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.19.15.50.54;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.07.00.07.49;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.05.09.35.08;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.16.14.34.27;	author duda;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.15.07.49.15;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.14.07.41.45;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.07.00.01.42;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.22.20.53.45;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.20.06.50.13;	author duda;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.15.08.42.15;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.04.16.30.18;	author duda;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.09.07.21.32;	author duda;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.20.19.50.28;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.18.03.34.05;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.07.22.50.49;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.28.05.41.43;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.27.09.50.33;	author corinna;	state Exp;
branches;
next	;

1.302.2.1
date	2014.05.19.11.47.54;	author corinna;	state Exp;
branches;
next	1.302.2.2;

1.302.2.2
date	2014.06.16.13.01.11;	author corinna;	state Exp;
branches;
next	1.302.2.3;

1.302.2.3
date	2014.07.15.14.34.37;	author corinna;	state Exp;
branches;
next	1.302.2.4;

1.302.2.4
date	2014.07.24.14.24.20;	author corinna;	state Exp;
branches;
next	1.302.2.5;

1.302.2.5
date	2014.11.13.12.53.01;	author corinna;	state Exp;
branches;
next	;

1.291.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.291.2.2;

1.291.2.2
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.291.2.3;

1.291.2.3
date	2012.10.18.17.16.00;	author corinna;	state Exp;
branches;
next	1.291.2.4;

1.291.2.4
date	2012.10.30.17.52.12;	author corinna;	state Exp;
branches;
next	1.291.2.5;

1.291.2.5
date	2012.11.07.20.56.05;	author corinna;	state Exp;
branches;
next	1.291.2.6;

1.291.2.6
date	2012.11.08.11.32.01;	author corinna;	state Exp;
branches;
next	1.291.2.7;

1.291.2.7
date	2012.11.16.09.41.12;	author corinna;	state Exp;
branches;
next	1.291.2.8;

1.291.2.8
date	2012.11.16.13.48.24;	author corinna;	state Exp;
branches;
next	1.291.2.9;

1.291.2.9
date	2012.11.26.13.29.09;	author corinna;	state Exp;
branches;
next	1.291.2.10;

1.291.2.10
date	2012.12.10.11.45.48;	author corinna;	state Exp;
branches;
next	1.291.2.11;

1.291.2.11
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.291.2.12;

1.291.2.12
date	2013.02.05.15.30.12;	author corinna;	state Exp;
branches;
next	1.291.2.13;

1.291.2.13
date	2013.02.20.20.15.56;	author yselkowitz;	state Exp;
branches;
next	1.291.2.14;

1.291.2.14
date	2013.03.01.16.32.33;	author corinna;	state Exp;
branches;
next	1.291.2.15;

1.291.2.15
date	2013.03.07.11.08.24;	author corinna;	state Exp;
branches;
next	1.291.2.16;

1.291.2.16
date	2013.03.07.15.41.01;	author corinna;	state Exp;
branches;
next	1.291.2.17;

1.291.2.17
date	2013.03.14.12.09.51;	author corinna;	state Exp;
branches;
next	1.291.2.18;

1.291.2.18
date	2013.04.08.10.03.11;	author corinna;	state Exp;
branches;
next	1.291.2.19;

1.291.2.19
date	2013.04.08.10.33.55;	author corinna;	state Exp;
branches;
next	1.291.2.20;

1.291.2.20
date	2013.04.08.17.34.40;	author corinna;	state Exp;
branches;
next	;

1.269.2.1
date	2011.03.17.16.14.50;	author corinna;	state Exp;
branches;
next	;

1.191.2.1
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	;

1.189.2.1
date	2006.07.06.14.04.32;	author corinna;	state Exp;
branches;
next	1.189.2.2;

1.189.2.2
date	2006.07.10.20.39.06;	author corinna;	state Exp;
branches;
next	1.189.2.3;

1.189.2.3
date	2006.07.11.08.59.02;	author corinna;	state Exp;
branches;
next	1.189.2.4;

1.189.2.4
date	2006.07.12.09.21.57;	author corinna;	state Exp;
branches;
next	1.189.2.5;

1.189.2.5
date	2006.07.13.10.37.58;	author corinna;	state Exp;
branches;
next	1.189.2.6;

1.189.2.6
date	2006.07.13.13.00.03;	author corinna;	state Exp;
branches;
next	1.189.2.7;

1.189.2.7
date	2006.07.21.08.33.38;	author corinna;	state Exp;
branches;
next	1.189.2.8;

1.189.2.8
date	2006.07.21.09.47.46;	author corinna;	state Exp;
branches;
next	1.189.2.9;

1.189.2.9
date	2006.07.25.17.02.36;	author corinna;	state Exp;
branches;
next	1.189.2.10;

1.189.2.10
date	2006.07.25.17.37.28;	author corinna;	state Exp;
branches;
next	;

1.115.6.1
date	2004.01.24.01.53.57;	author cgf;	state Exp;
branches;
next	;

1.86.2.1
date	2003.03.11.23.30.35;	author cgf;	state Exp;
branches;
next	;

1.75.4.1
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.75.4.2;

1.75.4.2
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	;

1.75.6.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.75.6.2;

1.75.6.2
date	2003.01.26.06.43.32;	author cgf;	state Exp;
branches;
next	1.75.6.3;

1.75.6.3
date	2003.01.30.02.46.41;	author cgf;	state Exp;
branches;
next	1.75.6.4;

1.75.6.4
date	2003.02.05.14.25.08;	author cgf;	state Exp;
branches;
next	1.75.6.5;

1.75.6.5
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.75.6.6;

1.75.6.6
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.75.6.7;

1.75.6.7
date	2003.03.01.02.05.42;	author cgf;	state Exp;
branches;
next	1.75.6.8;

1.75.6.8
date	2003.03.01.16.26.53;	author cgf;	state Exp;
branches;
next	1.75.6.9;

1.75.6.9
date	2003.03.02.23.39.10;	author cgf;	state Exp;
branches;
next	1.75.6.10;

1.75.6.10
date	2003.03.04.17.26.32;	author cgf;	state Exp;
branches;
next	1.75.6.11;

1.75.6.11
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.75.6.12;

1.75.6.12
date	2003.03.19.19.59.54;	author cgf;	state Exp;
branches;
next	1.75.6.13;

1.75.6.13
date	2003.03.21.15.15.18;	author cgf;	state Exp;
branches;
next	1.75.6.14;

1.75.6.14
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.75.6.15;

1.75.6.15
date	2003.05.26.19.39.06;	author cgf;	state Exp;
branches;
next	1.75.6.16;

1.75.6.16
date	2003.06.06.00.27.50;	author cgf;	state Exp;
branches;
next	1.75.6.17;

1.75.6.17
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.75.6.18;

1.75.6.18
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.75.6.19;

1.75.6.19
date	2003.09.14.01.35.37;	author cgf;	state Exp;
branches;
next	;

1.69.4.1
date	2002.11.07.03.47.46;	author cgf;	state Exp;
branches;
next	;

1.50.2.1
date	2002.07.06.06.11.52;	author cgf;	state Exp;
branches;
next	;

1.24.2.1
date	2001.10.02.12.09.54;	author rbcollins;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2002.02.28.12.53.24;	author rbcollins;	state Exp;
branches;
next	1.24.2.4;

1.24.2.4
date	2002.06.13.14.34.05;	author rbcollins;	state Exp;
branches;
next	1.24.2.5;

1.24.2.5
date	2002.06.24.10.55.35;	author scottc;	state Exp;
branches;
next	1.24.2.6;

1.24.2.6
date	2002.06.27.11.30.14;	author scottc;	state Exp;
branches;
next	1.24.2.7;

1.24.2.7
date	2002.07.03.16.01.46;	author scottc;	state Exp;
branches;
next	1.24.2.8;

1.24.2.8
date	2002.07.04.20.09.47;	author scottc;	state Exp;
branches;
next	1.24.2.9;

1.24.2.9
date	2002.07.06.22.28.18;	author scottc;	state Exp;
branches;
next	1.24.2.10;

1.24.2.10
date	2002.07.13.20.39.24;	author scottc;	state Exp;
branches;
next	1.24.2.11;

1.24.2.11
date	2002.08.07.10.44.59;	author scottc;	state Exp;
branches;
next	1.24.2.12;

1.24.2.12
date	2002.08.12.14.06.34;	author scottc;	state Exp;
branches;
next	1.24.2.13;

1.24.2.13
date	2002.08.26.11.38.14;	author scottc;	state Exp;
branches;
next	1.24.2.14;

1.24.2.14
date	2002.08.27.12.28.37;	author scottc;	state Exp;
branches;
next	1.24.2.15;

1.24.2.15
date	2002.08.28.16.09.14;	author scottc;	state Exp;
branches;
next	1.24.2.16;

1.24.2.16
date	2002.08.30.22.08.50;	author scottc;	state Exp;
branches;
next	1.24.2.17;

1.24.2.17
date	2002.09.04.09.55.01;	author scottc;	state Exp;
branches;
next	1.24.2.18;

1.24.2.18
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	1.24.2.19;

1.24.2.19
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.317
log
@	* fhandler_socket.cc (fhandler_socket::af_local_connect): Drop
	setting connect_state to connect_credxchg.
	(fhandler_socket::af_local_accept): Ditto.
	(fhandler_socket::recv_internal): Drop ill-advised connect_state check.
	Add comment so as not to repeat the exercise.
	* fhandler.h (enum conn_state): Drop now unneeded connect_credxchg
	state.
@
text
@/* fhandler_socket.cc. See fhandler.h for a description of the fhandler classes.

   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011, 2012, 2013, 2014 Red Hat, Inc.

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */

/* #define DEBUG_NEST_ON 1 */

#define  __INSIDE_CYGWIN_NET__
#define USE_SYS_TYPES_FD_SET

#define _BSDTYPES_DEFINED
#include "winsup.h"
#undef _BSDTYPES_DEFINED
#ifdef __x86_64__
/* 2014-04-24: Current Mingw headers define sockaddr_in6 using u_long (8 byte)
   because a redefinition for LP64 systems is missing.  This leads to a wrong
   definition and size of sockaddr_in6 when building with winsock headers.
   This definition is also required to use the right u_long type in subsequent
   function calls. */
#undef u_long
#define u_long __ms_u_long
#endif
#include <ws2tcpip.h>
#include <mswsock.h>
#include <iphlpapi.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include <asm/byteorder.h>
#include "cygwin/version.h"
#include "perprocess.h"
#include "shared_info.h"
#include "sigproc.h"
#include "wininfo.h"
#include <unistd.h>
#include <sys/param.h>
#include <sys/acl.h>
#include "cygtls.h"
#include <sys/un.h>
#include "ntdll.h"
#include "miscfuncs.h"

#define ASYNC_MASK (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT)
#define EVENT_MASK (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT|FD_CLOSE)

extern bool fdsock (cygheap_fdmanip& fd, const device *, SOCKET soc);
extern "C" {
int sscanf (const char *, const char *, ...);
} /* End of "C" section */

static inline mode_t
adjust_socket_file_mode (mode_t mode)
{
  /* Kludge: Don't allow to remove read bit on socket files for
     user/group/other, if the accompanying write bit is set.  It would
     be nice to have exact permissions on a socket file, but it's
     necessary that somebody able to access the socket can always read
     the contents of the socket file to avoid spurious "permission
     denied" messages. */
  return mode | ((mode & (S_IWUSR | S_IWGRP | S_IWOTH)) << 1);
}

/* cygwin internal: map sockaddr into internet domain address */
int
get_inet_addr (const struct sockaddr *in, int inlen,
	       struct sockaddr_storage *out, int *outlen,
	       int *type = NULL, int *secret = NULL)
{
  int secret_buf [4];
  int* secret_ptr = (secret ? : secret_buf);

  switch (in->sa_family)
    {
    case AF_LOCAL:
      /* Check for abstract socket. These are generated for AF_LOCAL datagram
	 sockets in recv_internal, to allow a datagram server to use sendto
	 after recvfrom. */
      if (inlen >= (int) sizeof (in->sa_family) + 7
	  && in->sa_data[0] == '\0' && in->sa_data[1] == 'd'
	  && in->sa_data[6] == '\0')
	{
	  struct sockaddr_in addr;
	  addr.sin_family = AF_INET;
	  sscanf (in->sa_data + 2, "%04hx", &addr.sin_port);
	  addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	  *outlen = sizeof addr;
	  memcpy (out, &addr, *outlen);
	  return 0;
	}
      break;
    case AF_INET:
      memcpy (out, in, inlen);
      *outlen = inlen;
      /* If the peer address given in connect or sendto is the ANY address,
	 Winsock fails with WSAEADDRNOTAVAIL, while Linux converts that into
	 a connection/send attempt to LOOPBACK.  We're doing the same here. */
      if (((struct sockaddr_in *) out)->sin_addr.s_addr == htonl (INADDR_ANY))
	((struct sockaddr_in *) out)->sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      return 0;
    case AF_INET6:
      memcpy (out, in, inlen);
      *outlen = inlen;
      /* See comment in AF_INET case. */
      if (IN6_IS_ADDR_UNSPECIFIED (&((struct sockaddr_in6 *) out)->sin6_addr))
	((struct sockaddr_in6 *) out)->sin6_addr = in6addr_loopback;
      return 0;
    default:
      set_errno (EAFNOSUPPORT);
      return SOCKET_ERROR;
    }
  /* AF_LOCAL/AF_UNIX only */
  path_conv pc (in->sa_data, PC_SYM_FOLLOW);
  if (pc.error)
    {
      set_errno (pc.error);
      return SOCKET_ERROR;
    }
  if (!pc.exists ())
    {
      set_errno (ENOENT);
      return SOCKET_ERROR;
    }
  /* Do NOT test for the file being a socket file here.  The socket file
     creation is not an atomic operation, so there is a chance that socket
     files which are just in the process of being created are recognized
     as non-socket files.  To work around this problem we now create the
     file with all sharing disabled.  If the below NtOpenFile fails
     with STATUS_SHARING_VIOLATION we know that the file already exists,
     but the creating process isn't finished yet.  So we yield and try
     again, until we can either open the file successfully, or some error
     other than STATUS_SHARING_VIOLATION occurs.
     Since we now don't know if the file is actually a socket file, we
     perform this check here explicitely. */
  NTSTATUS status;
  HANDLE fh;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;

  pc.get_object_attr (attr, sec_none_nih);
  do
    {
      status = NtOpenFile (&fh, GENERIC_READ | SYNCHRONIZE, &attr, &io,
			   FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT
			   | FILE_NON_DIRECTORY_FILE);
      if (status == STATUS_SHARING_VIOLATION)
	{
	  /* While we hope that the sharing violation is only temporary, we
	     also could easily get stuck here, waiting for a file in use by
	     some greedy Win32 application.  Therefore we should never wait
	     endlessly without checking for signals and thread cancel event. */
	  pthread_testcancel ();
	  if (cygwait (NULL, cw_nowait, cw_sig_eintr) == WAIT_SIGNALED
	      && !_my_tls.call_signal_handler ())
	    {
	      set_errno (EINTR);
	      return SOCKET_ERROR;
	    }
	  yield ();
	}
      else if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  return SOCKET_ERROR;
	}
    }
  while (status == STATUS_SHARING_VIOLATION);
  /* Now test for the SYSTEM bit. */
  FILE_BASIC_INFORMATION fbi;
  status = NtQueryInformationFile (fh, &io, &fbi, sizeof fbi,
				   FileBasicInformation);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return SOCKET_ERROR;
    }
  if (!(fbi.FileAttributes & FILE_ATTRIBUTE_SYSTEM))
    {
      NtClose (fh);
      set_errno (EBADF);
      return SOCKET_ERROR;
    }
  /* Eventually check the content and fetch the required information. */
  char buf[128];
  memset (buf, 0, sizeof buf);
  status = NtReadFile (fh, NULL, NULL, NULL, &io, buf, 128, NULL, NULL);
  NtClose (fh);
  if (NT_SUCCESS (status))
    {
      struct sockaddr_in sin;
      char ctype;
      sin.sin_family = AF_INET;
      if (strncmp (buf, SOCKET_COOKIE, strlen (SOCKET_COOKIE)))
	{
	  set_errno (EBADF);
	  return SOCKET_ERROR;
	}
      sscanf (buf + strlen (SOCKET_COOKIE), "%hu %c %08x-%08x-%08x-%08x",
	      &sin.sin_port,
	      &ctype,
	      secret_ptr, secret_ptr + 1, secret_ptr + 2, secret_ptr + 3);
      sin.sin_port = htons (sin.sin_port);
      sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      memcpy (out, &sin, sizeof sin);
      *outlen = sizeof sin;
      if (type)
	*type = (ctype == 's' ? SOCK_STREAM :
		 ctype == 'd' ? SOCK_DGRAM
			      : 0);
      return 0;
    }
  __seterrno_from_nt_status (status);
  return SOCKET_ERROR;
}

/**********************************************************************/
/* fhandler_socket */

fhandler_socket::fhandler_socket () :
  fhandler_base (),
  wsock_events (NULL),
  wsock_mtx (NULL),
  wsock_evt (NULL),
  prot_info_ptr (NULL),
  sun_path (NULL),
  peer_sun_path (NULL),
  status ()
{
  need_fork_fixup (true);
}

fhandler_socket::~fhandler_socket ()
{
  if (prot_info_ptr)
    cfree (prot_info_ptr);
  if (sun_path)
    cfree (sun_path);
  if (peer_sun_path)
    cfree (peer_sun_path);
}

char *
fhandler_socket::get_proc_fd_name (char *buf)
{
  __small_sprintf (buf, "socket:[%lu]", get_socket ());
  return buf;
}

int
fhandler_socket::open (int flags, mode_t mode)
{
  set_errno (ENXIO);
  return 0;
}

void
fhandler_socket::af_local_set_sockpair_cred ()
{
  sec_pid = sec_peer_pid = getpid ();
  sec_uid = sec_peer_uid = geteuid32 ();
  sec_gid = sec_peer_gid = getegid32 ();
}

void
fhandler_socket::af_local_setblocking (bool &async, bool &nonblocking)
{
  async = async_io ();
  nonblocking = is_nonblocking ();
  if (async)
    {
      WSAAsyncSelect (get_socket (), winmsg, 0, 0);
      WSAEventSelect (get_socket (), wsock_evt, EVENT_MASK);
    }
  set_nonblocking (false);
  async_io (false);
}

void
fhandler_socket::af_local_unsetblocking (bool async, bool nonblocking)
{
  if (nonblocking)
    set_nonblocking (true);
  if (async)
    {
      WSAAsyncSelect (get_socket (), winmsg, WM_ASYNCIO, ASYNC_MASK);
      async_io (true);
    }
}

bool
fhandler_socket::af_local_recv_secret ()
{
  int out[4] = { 0, 0, 0, 0 };
  int rest = sizeof out;
  char *ptr = (char *) out;
  while (rest > 0)
    {
      int ret = recvfrom (ptr, rest, 0, NULL, NULL);
      if (ret <= 0)
	break;
      rest -= ret;
      ptr += ret;
    }
  if (rest == 0)
    {
      debug_printf ("Received af_local secret: %08x-%08x-%08x-%08x",
		    out[0], out[1], out[2], out[3]);
      if (out[0] != connect_secret[0] || out[1] != connect_secret[1]
	  || out[2] != connect_secret[2] || out[3] != connect_secret[3])
	{
	  debug_printf ("Receiving af_local secret mismatch");
	  return false;
	}
    }
  else
    debug_printf ("Receiving af_local secret failed");
  return rest == 0;
}

bool
fhandler_socket::af_local_send_secret ()
{
  int rest = sizeof connect_secret;
  char *ptr = (char *) connect_secret;
  while (rest > 0)
    {
      int ret = sendto (ptr, rest, 0, NULL, 0);
      if (ret <= 0)
	break;
      rest -= ret;
      ptr += ret;
    }
  debug_printf ("Sending af_local secret %s", rest == 0 ? "succeeded"
							: "failed");
  return rest == 0;
}

bool
fhandler_socket::af_local_recv_cred ()
{
  struct ucred out = { (pid_t) 0, (uid_t) -1, (gid_t) -1 };
  int rest = sizeof out;
  char *ptr = (char *) &out;
  while (rest > 0)
    {
      int ret = recvfrom (ptr, rest, 0, NULL, NULL);
      if (ret <= 0)
	break;
      rest -= ret;
      ptr += ret;
    }
  if (rest == 0)
    {
      debug_printf ("Received eid credentials: pid: %d, uid: %d, gid: %d",
		    out.pid, out.uid, out.gid);
      sec_peer_pid = out.pid;
      sec_peer_uid = out.uid;
      sec_peer_gid = out.gid;
    }
  else
    debug_printf ("Receiving eid credentials failed");
  return rest == 0;
}

bool
fhandler_socket::af_local_send_cred ()
{
  struct ucred in = { sec_pid, sec_uid, sec_gid };
  int rest = sizeof in;
  char *ptr = (char *) &in;
  while (rest > 0)
    {
      int ret = sendto (ptr, rest, 0, NULL, 0);
      if (ret <= 0)
	break;
      rest -= ret;
      ptr += ret;
    }
  if (rest == 0)
    debug_printf ("Sending eid credentials succeeded");
  else
    debug_printf ("Sending eid credentials failed");
  return rest == 0;
}

int
fhandler_socket::af_local_connect ()
{
  bool orig_async_io, orig_is_nonblocking;

  if (get_addr_family () != AF_LOCAL || get_socket_type () != SOCK_STREAM)
    return 0;

  debug_printf ("af_local_connect called, no_getpeereid=%d", no_getpeereid ());
  if (no_getpeereid ())
    return 0;

  af_local_setblocking (orig_async_io, orig_is_nonblocking);
  if (!af_local_send_secret () || !af_local_recv_secret ()
      || !af_local_send_cred () || !af_local_recv_cred ())
    {
      debug_printf ("accept from unauthorized server");
      ::shutdown (get_socket (), SD_BOTH);
      WSASetLastError (WSAECONNREFUSED);
      return -1;
    }
  af_local_unsetblocking (orig_async_io, orig_is_nonblocking);
  return 0;
}

int
fhandler_socket::af_local_accept ()
{
  bool orig_async_io, orig_is_nonblocking;

  debug_printf ("af_local_accept called, no_getpeereid=%d", no_getpeereid ());
  if (no_getpeereid ())
    return 0;

  af_local_setblocking (orig_async_io, orig_is_nonblocking);
  if (!af_local_recv_secret () || !af_local_send_secret ()
      || !af_local_recv_cred () || !af_local_send_cred ())
    {
      debug_printf ("connect from unauthorized client");
      ::shutdown (get_socket (), SD_BOTH);
      ::closesocket (get_socket ());
      WSASetLastError (WSAECONNABORTED);
      return -1;
    }
  af_local_unsetblocking (orig_async_io, orig_is_nonblocking);
  return 0;
}

int
fhandler_socket::af_local_set_no_getpeereid ()
{
  if (get_addr_family () != AF_LOCAL || get_socket_type () != SOCK_STREAM)
    {
      set_errno (EINVAL);
      return -1;
    }
  if (connect_state () != unconnected)
    {
      set_errno (EALREADY);
      return -1;
    }

  debug_printf ("no_getpeereid set");
  no_getpeereid (true);
  return 0;
}

void
fhandler_socket::af_local_set_cred ()
{
  sec_pid = getpid ();
  sec_uid = geteuid32 ();
  sec_gid = getegid32 ();
  sec_peer_pid = (pid_t) 0;
  sec_peer_uid = (uid_t) -1;
  sec_peer_gid = (gid_t) -1;
}

void
fhandler_socket::af_local_copy (fhandler_socket *sock)
{
  sock->connect_secret[0] = connect_secret[0];
  sock->connect_secret[1] = connect_secret[1];
  sock->connect_secret[2] = connect_secret[2];
  sock->connect_secret[3] = connect_secret[3];
  sock->sec_pid = sec_pid;
  sock->sec_uid = sec_uid;
  sock->sec_gid = sec_gid;
  sock->sec_peer_pid = sec_peer_pid;
  sock->sec_peer_uid = sec_peer_uid;
  sock->sec_peer_gid = sec_peer_gid;
  sock->no_getpeereid (no_getpeereid ());
}

void
fhandler_socket::af_local_set_secret (char *buf)
{
  if (!fhandler_dev_random::crypt_gen_random (connect_secret,
					      sizeof (connect_secret)))
    bzero ((char*) connect_secret, sizeof (connect_secret));
  __small_sprintf (buf, "%08x-%08x-%08x-%08x",
		   connect_secret [0], connect_secret [1],
		   connect_secret [2], connect_secret [3]);
}

/* Maximum number of concurrently opened sockets from all Cygwin processes
   per session.  Note that shared sockets (through dup/fork/exec) are
   counted as one socket. */
#define NUM_SOCKS       (32768 / sizeof (wsa_event))

#define LOCK_EVENTS	WaitForSingleObject (wsock_mtx, INFINITE)
#define UNLOCK_EVENTS	ReleaseMutex (wsock_mtx)

static wsa_event wsa_events[NUM_SOCKS] __attribute__((section (".cygwin_dll_common"), shared));

static LONG socket_serial_number __attribute__((section (".cygwin_dll_common"), shared));

static HANDLE wsa_slot_mtx;

static PWCHAR
sock_shared_name (PWCHAR buf, LONG num)
{
  __small_swprintf (buf, L"socket.%d", num);
  return buf;
}

static wsa_event *
search_wsa_event_slot (LONG new_serial_number)
{
  WCHAR name[32], searchname[32];
  UNICODE_STRING uname;
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;

  if (!wsa_slot_mtx)
    {
      RtlInitUnicodeString (&uname, sock_shared_name (name, 0));
      InitializeObjectAttributes (&attr, &uname, OBJ_INHERIT | OBJ_OPENIF,
				  get_session_parent_dir (),
				  everyone_sd (CYG_MUTANT_ACCESS));
      status = NtCreateMutant (&wsa_slot_mtx, CYG_MUTANT_ACCESS, &attr, FALSE);
      if (!NT_SUCCESS (status))
	api_fatal ("Couldn't create/open shared socket mutex %S, %y",
		   &uname, status);
    }
  switch (WaitForSingleObject (wsa_slot_mtx, INFINITE))
    {
    case WAIT_OBJECT_0:
    case WAIT_ABANDONED:
      break;
    default:
      api_fatal ("WFSO failed for shared socket mutex, %E");
      break;
    }
  unsigned int slot = new_serial_number % NUM_SOCKS;
  while (wsa_events[slot].serial_number)
    {
      HANDLE searchmtx;
      RtlInitUnicodeString (&uname, sock_shared_name (searchname,
					wsa_events[slot].serial_number));
      InitializeObjectAttributes (&attr, &uname, 0, get_session_parent_dir (),
				  NULL);
      status = NtOpenMutant (&searchmtx, READ_CONTROL, &attr);
      if (!NT_SUCCESS (status))
	break;
      /* Mutex still exists, attached socket is active, try next slot. */
      NtClose (searchmtx);
      slot = (slot + 1) % NUM_SOCKS;
      if (slot == (new_serial_number % NUM_SOCKS))
	{
	  /* Did the whole array once.   Too bad. */
	  debug_printf ("No free socket slot");
	  ReleaseMutex (wsa_slot_mtx);
	  return NULL;
	}
    }
  memset (&wsa_events[slot], 0, sizeof (wsa_event));
  wsa_events[slot].serial_number = new_serial_number;
  ReleaseMutex (wsa_slot_mtx);
  return wsa_events + slot;
}

bool
fhandler_socket::init_events ()
{
  LONG new_serial_number;
  WCHAR name[32];
  UNICODE_STRING uname;
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;

  do
    {
      new_serial_number =
	InterlockedIncrement (&socket_serial_number);
      if (!new_serial_number)	/* 0 is reserved for global mutex */
	InterlockedIncrement (&socket_serial_number);
      RtlInitUnicodeString (&uname, sock_shared_name (name, new_serial_number));
      InitializeObjectAttributes (&attr, &uname, OBJ_INHERIT | OBJ_OPENIF,
				  get_session_parent_dir (),
				  everyone_sd (CYG_MUTANT_ACCESS));
      status = NtCreateMutant (&wsock_mtx, CYG_MUTANT_ACCESS, &attr, FALSE);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("NtCreateMutant(%S), %y", &uname, status);
	  set_errno (ENOBUFS);
	  return false;
	}
      if (status == STATUS_OBJECT_NAME_EXISTS)
	NtClose (wsock_mtx);
    }
  while (status == STATUS_OBJECT_NAME_EXISTS);
  if ((wsock_evt = CreateEvent (&sec_all, TRUE, FALSE, NULL))
      == WSA_INVALID_EVENT)
    {
      debug_printf ("CreateEvent, %E");
      set_errno (ENOBUFS);
      NtClose (wsock_mtx);
      return false;
    }
  if (WSAEventSelect (get_socket (), wsock_evt, EVENT_MASK) == SOCKET_ERROR)
    {
      debug_printf ("WSAEventSelect, %E");
      set_winsock_errno ();
      NtClose (wsock_evt);
      NtClose (wsock_mtx);
      return false;
    }
  wsock_events = search_wsa_event_slot (new_serial_number);
  /* sock type not yet set here. */
  if (pc.dev == FH_UDP || pc.dev == FH_DGRAM)
    wsock_events->events = FD_WRITE;
  return true;
}

int
fhandler_socket::evaluate_events (const long event_mask, long &events,
				  const bool erase)
{
  int ret = 0;
  long events_now = 0;

  WSANETWORKEVENTS evts = { 0 };
  if (!(WSAEnumNetworkEvents (get_socket (), wsock_evt, &evts)))
    {
      if (evts.lNetworkEvents)
	{
	  LOCK_EVENTS;
	  wsock_events->events |= evts.lNetworkEvents;
	  events_now = (wsock_events->events & event_mask);
	  if (evts.lNetworkEvents & FD_CONNECT)
	    {
	      wsock_events->connect_errorcode = evts.iErrorCode[FD_CONNECT_BIT];

	      /* Setting the connect_state and calling the AF_LOCAL handshake 
		 here allows to handle this stuff from a single point.  This
		 is independent of FD_CONNECT being requested.  Consider a
		 server calling connect(2) and then immediately poll(2) with
		 only polling for POLLIN (example: postfix), or select(2) just
		 asking for descriptors ready to read.

		 Something weird occurs in Winsock: If you fork off and call
		 recv/send on the duplicated, already connected socket, another
		 FD_CONNECT event is generated in the child process.  This
		 would trigger a call to af_local_connect which obviously fail. 
		 Avoid this by calling set_connect_state only if connect_state
		 is connect_pending. */
	      if (connect_state () == connect_pending)
		{
		  if (wsock_events->connect_errorcode)
		    connect_state (connect_failed);
		  else if (af_local_connect ())
		    {
		      wsock_events->connect_errorcode = WSAGetLastError ();
		      connect_state (connect_failed);
		    }
		  else
		    connect_state (connected);
		}
	    }
	  UNLOCK_EVENTS;
	  if ((evts.lNetworkEvents & FD_OOB) && wsock_events->owner)
	    kill (wsock_events->owner, SIGURG);
	}
    }

  LOCK_EVENTS;
  if ((events = events_now) != 0
      || (events = (wsock_events->events & event_mask)) != 0)
    {
      if (events & FD_CONNECT)
	{
	  int wsa_err = wsock_events->connect_errorcode;
	  if (wsa_err)
	    {
	      /* CV 2014-04-23: This is really weird.  If you call connect
		 asynchronously on a socket and then select, an error like
		 "Connection refused" is set in the event and in the SO_ERROR
		 socket option.  If you call connect, then dup, then select,
		 the error is set in the event, but not in the SO_ERROR socket
		 option, despite the dup'ed socket handle referring to the same
		 socket.  We're trying to workaround this problem here by
		 taking the connect errorcode from the event and write it back
		 into the SO_ERROR socket option.
	         
		 CV 2014-06-16: Call WSASetLastError *after* setsockopt since,
		 apparently, setsockopt sets the last WSA error code to 0 on
		 success. */
	      setsockopt (get_socket (), SOL_SOCKET, SO_ERROR,
			  (const char *) &wsa_err, sizeof wsa_err);
	      WSASetLastError (wsa_err);
	      ret = SOCKET_ERROR;
	    }
	  else
	    wsock_events->events |= FD_WRITE;
	  wsock_events->events &= ~FD_CONNECT;
	  wsock_events->connect_errorcode = 0;
	}
      /* This test makes the accept function behave as on Linux when
	 accept is called on a socket for which shutdown for the read side
	 has been called.  The second half of this code is in the shutdown
	 method.  See there for more info. */
      if ((event_mask & FD_ACCEPT) && (events & FD_CLOSE))
	{
	  WSASetLastError (WSAEINVAL);
	  ret = SOCKET_ERROR;
	}
      if (erase)
	wsock_events->events &= ~(events & ~(FD_WRITE | FD_CLOSE));
    }
  UNLOCK_EVENTS;

  return ret;
}

int
fhandler_socket::wait_for_events (const long event_mask, const DWORD flags)
{
  if (async_io ())
    return 0;

  int ret;
  long events;

  while (!(ret = evaluate_events (event_mask, events, !(flags & MSG_PEEK)))
	 && !events)
    {
      if (is_nonblocking () || (flags & MSG_DONTWAIT))
	{
	  WSASetLastError (WSAEWOULDBLOCK);
	  return SOCKET_ERROR;
	}

      WSAEVENT ev[2] = { wsock_evt };
      set_signal_arrived here (ev[1]);
      switch (WSAWaitForMultipleEvents (2, ev, FALSE, 50, FALSE))
	{
	  case WSA_WAIT_TIMEOUT:
	    pthread_testcancel ();
	    /*FALLTHRU*/
	  case WSA_WAIT_EVENT_0:
	    break;

	  case WSA_WAIT_EVENT_0 + 1:
	    if (_my_tls.call_signal_handler ())
	      break;
	    WSASetLastError (WSAEINTR);
	    return SOCKET_ERROR;

	  default:
	    WSASetLastError (WSAEFAULT);
	    return SOCKET_ERROR;
	}
    }

  return ret;
}

void
fhandler_socket::release_events ()
{
  NtClose (wsock_evt);
  NtClose (wsock_mtx);
}

/* Called from net.cc:fdsock() if a freshly created socket is not
   inheritable.  In that case we use fixup_before_fork_exec.  See
   the comment in fdsock() for a description of the problem. */
void
fhandler_socket::init_fixup_before ()
{
  prot_info_ptr = (LPWSAPROTOCOL_INFOW)
		  cmalloc_abort (HEAP_BUF, sizeof (WSAPROTOCOL_INFOW));
  cygheap->fdtab.inc_need_fixup_before ();
}

int
fhandler_socket::fixup_before_fork_exec (DWORD win_pid)
{
  SOCKET ret = WSADuplicateSocketW (get_socket (), win_pid, prot_info_ptr);
  if (ret)
    set_winsock_errno ();
  else
    debug_printf ("WSADuplicateSocket succeeded (%x)", prot_info_ptr->dwProviderReserved);
  return (int) ret;
}

void
fhandler_socket::fixup_after_fork (HANDLE parent)
{
  fork_fixup (parent, wsock_mtx, "wsock_mtx");
  fork_fixup (parent, wsock_evt, "wsock_evt");

  if (!need_fixup_before ())
    {
      fhandler_base::fixup_after_fork (parent);
      return;
    }

  SOCKET new_sock = WSASocketW (FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO,
				FROM_PROTOCOL_INFO, prot_info_ptr, 0,
				WSA_FLAG_OVERLAPPED);
  if (new_sock == INVALID_SOCKET)
    {
      set_winsock_errno ();
      set_io_handle ((HANDLE) INVALID_SOCKET);
    }
  else
    {
      /* Even though the original socket was not inheritable, the duplicated
	 socket is potentially inheritable again. */
      SetHandleInformation ((HANDLE) new_sock, HANDLE_FLAG_INHERIT, 0);
      set_io_handle ((HANDLE) new_sock);
      debug_printf ("WSASocket succeeded (%p)", new_sock);
    }
}

void
fhandler_socket::fixup_after_exec ()
{
  if (need_fixup_before () && !close_on_exec ())
    fixup_after_fork (NULL);
}

int
fhandler_socket::dup (fhandler_base *child, int flags)
{
  debug_printf ("here");
  fhandler_socket *fhs = (fhandler_socket *) child;

  if (!DuplicateHandle (GetCurrentProcess (), wsock_mtx,
			GetCurrentProcess (), &fhs->wsock_mtx,
			0, TRUE, DUPLICATE_SAME_ACCESS))
    {
      __seterrno ();
      return -1;
    }
  if (!DuplicateHandle (GetCurrentProcess (), wsock_evt,
			GetCurrentProcess (), &fhs->wsock_evt,
			0, TRUE, DUPLICATE_SAME_ACCESS))
    {
      __seterrno ();
      NtClose (fhs->wsock_mtx);
      return -1;
    }
  if (get_addr_family () == AF_LOCAL)
    {
      fhs->set_sun_path (get_sun_path ());
      fhs->set_peer_sun_path (get_peer_sun_path ());
    }
  if (!need_fixup_before ())
    {
      int ret = fhandler_base::dup (child, flags);
      if (ret)
	{
	  NtClose (fhs->wsock_evt);
	  NtClose (fhs->wsock_mtx);
	}
      return ret;
    }

  cygheap->user.deimpersonate ();
  fhs->init_fixup_before ();
  fhs->set_io_handle (get_io_handle ());
  int ret = fhs->fixup_before_fork_exec (GetCurrentProcessId ());
  cygheap->user.reimpersonate ();
  if (!ret)
    {
      fhs->fixup_after_fork (GetCurrentProcess ());
      if (fhs->get_io_handle() != (HANDLE) INVALID_SOCKET)
	return 0;
    }
  cygheap->fdtab.dec_need_fixup_before ();
  NtClose (fhs->wsock_evt);
  NtClose (fhs->wsock_mtx);
  return -1;
}

int __reg2
fhandler_socket::fstat (struct stat *buf)
{
  int res;
  if (get_device () == FH_UNIX)
    {
      res = fhandler_base::fstat_fs (buf);
      if (!res)
	{
	  buf->st_mode = (buf->st_mode & ~S_IFMT) | S_IFSOCK;
	  buf->st_size = 0;
	}
    }
  else
    {
      res = fhandler_base::fstat (buf);
      if (!res)
	{
	  buf->st_dev = 0;
	  buf->st_ino = (ino_t) ((uintptr_t) get_handle ());
	  buf->st_mode = S_IFSOCK | S_IRWXU | S_IRWXG | S_IRWXO;
	  buf->st_size = 0;
	}
    }
  return res;
}

int __reg2
fhandler_socket::fstatvfs (struct statvfs *sfs)
{
  if (get_device () == FH_UNIX)
    {
      fhandler_disk_file fh (pc);
      fh.get_device () = FH_FS;
      return fh.fstatvfs (sfs);
    }
  set_errno (EBADF);
  return -1;
}

int
fhandler_socket::fchmod (mode_t mode)
{
  if (get_device () == FH_UNIX)
    {
      fhandler_disk_file fh (pc);
      fh.get_device () = FH_FS;
      int ret = fh.fchmod (S_IFSOCK | adjust_socket_file_mode (mode));
      return ret;
    }
  set_errno (EBADF);
  return -1;
}

int
fhandler_socket::fchown (uid_t uid, gid_t gid)
{
  if (get_device () == FH_UNIX)
    {
      fhandler_disk_file fh (pc);
      return fh.fchown (uid, gid);
    }
  set_errno (EBADF);
  return -1;
}

int
fhandler_socket::facl (int cmd, int nentries, aclent_t *aclbufp)
{
  if (get_device () == FH_UNIX)
    {
      fhandler_disk_file fh (pc);
      return fh.facl (cmd, nentries, aclbufp);
    }
  set_errno (EBADF);
  return -1;
}

int
fhandler_socket::link (const char *newpath)
{
  if (get_device () == FH_UNIX)
    {
      fhandler_disk_file fh (pc);
      return fh.link (newpath);
    }
  return fhandler_base::link (newpath);
}

int
fhandler_socket::bind (const struct sockaddr *name, int namelen)
{
  int res = -1;

  if (name->sa_family == AF_LOCAL)
    {
#define un_addr ((struct sockaddr_un *) name)
      struct sockaddr_in sin;
      int len = namelen - offsetof (struct sockaddr_un, sun_path);

      /* Check that name is within bounds.  Don't check if the string is
         NUL-terminated, because there are projects out there which set
	 namelen to a value which doesn't cover the trailing NUL. */
      if (len <= 1 || (len = strnlen (un_addr->sun_path, len)) > UNIX_PATH_MAX)
	{
	  set_errno (len <= 1 ? (len == 1 ? ENOENT : EINVAL) : ENAMETOOLONG);
	  goto out;
	}
      /* Copy over the sun_path string into a buffer big enough to add a
	 trailing NUL. */
      char sun_path[len + 1];
      strncpy (sun_path, un_addr->sun_path, len);
      sun_path[len] = '\0';

      /* This isn't entirely foolproof, but we check first if the file exists
	 so we can return with EADDRINUSE before having bound the socket.
	 This allows an application to call bind again on the same socket using
	 another filename.  If we bind first, the application will not be able
	 to call bind successfully ever again. */
      path_conv pc (sun_path, PC_SYM_FOLLOW);
      if (pc.error)
	{
	  set_errno (pc.error);
	  goto out;
	}
      if (pc.exists ())
	{
	  set_errno (EADDRINUSE);
	  goto out;
	}

      sin.sin_family = AF_INET;
      sin.sin_port = 0;
      sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      if (::bind (get_socket (), (sockaddr *) &sin, len = sizeof sin))
	{
	  syscall_printf ("AF_LOCAL: bind failed");
	  set_winsock_errno ();
	  goto out;
	}
      if (::getsockname (get_socket (), (sockaddr *) &sin, &len))
	{
	  syscall_printf ("AF_LOCAL: getsockname failed");
	  set_winsock_errno ();
	  goto out;
	}

      sin.sin_port = ntohs (sin.sin_port);
      debug_printf ("AF_LOCAL: socket bound to port %u", sin.sin_port);

      mode_t mode = adjust_socket_file_mode ((S_IRWXU | S_IRWXG | S_IRWXO)
					     & ~cygheap->umask);
      DWORD fattr = FILE_ATTRIBUTE_SYSTEM;
      if (!(mode & (S_IWUSR | S_IWGRP | S_IWOTH)) && !pc.has_acls ())
	fattr |= FILE_ATTRIBUTE_READONLY;
      SECURITY_ATTRIBUTES sa = sec_none_nih;
      NTSTATUS status;
      HANDLE fh;
      OBJECT_ATTRIBUTES attr;
      IO_STATUS_BLOCK io;
      ULONG access = DELETE | FILE_GENERIC_WRITE;

      /* If the filesystem supports ACLs, we will overwrite the DACL after the
	 call to NtCreateFile.  This requires a handle with READ_CONTROL and
	 WRITE_DAC access, otherwise get_file_sd and set_file_sd both have to
	 open the file again.
	 FIXME: On remote NTFS shares open sometimes fails because even the
	 creator of the file doesn't have the right to change the DACL.
	 I don't know what setting that is or how to recognize such a share,
	 so for now we don't request WRITE_DAC on remote drives. */
      if (pc.has_acls () && !pc.isremote ())
	access |= READ_CONTROL | WRITE_DAC;

      status = NtCreateFile (&fh, access, pc.get_object_attr (attr, sa), &io,
			     NULL, fattr, 0, FILE_CREATE,
			     FILE_NON_DIRECTORY_FILE
			     | FILE_SYNCHRONOUS_IO_NONALERT
			     | FILE_OPEN_FOR_BACKUP_INTENT,
			     NULL, 0);
      if (!NT_SUCCESS (status))
	{
	  if (io.Information == FILE_EXISTS)
	    set_errno (EADDRINUSE);
	  else
	    __seterrno_from_nt_status (status);
	}
      else
	{
	  if (pc.has_acls ())
	    set_file_attribute (fh, pc, ILLEGAL_UID, ILLEGAL_GID,
				S_JUSTCREATED | mode);
	  char buf[sizeof (SOCKET_COOKIE) + 80];
	  __small_sprintf (buf, "%s%u %c ", SOCKET_COOKIE, sin.sin_port,
			   get_socket_type () == SOCK_STREAM ? 's'
			   : get_socket_type () == SOCK_DGRAM ? 'd' : '-');
	  af_local_set_secret (strchr (buf, '\0'));
	  DWORD blen = strlen (buf) + 1;
	  status = NtWriteFile (fh, NULL, NULL, NULL, &io, buf, blen, NULL, 0);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      FILE_DISPOSITION_INFORMATION fdi = { TRUE };
	      status = NtSetInformationFile (fh, &io, &fdi, sizeof fdi,
					     FileDispositionInformation);
	      if (!NT_SUCCESS (status))
		debug_printf ("Setting delete dispostion failed, status = %y",
			      status);
	    }
	  else
	    {
	      set_sun_path (sun_path);
	      res = 0;
	    }
	  NtClose (fh);
	}
#undef un_addr
    }
  else
    {
      if (!saw_reuseaddr ())
	{
	  /* If the application didn't explicitely request SO_REUSEADDR,
	     enforce POSIX standard socket binding behaviour by setting the
	     SO_EXCLUSIVEADDRUSE socket option.  See cygwin_setsockopt()
	     for a more detailed description. */
	  int on = 1;
	  int ret = ::setsockopt (get_socket (), SOL_SOCKET,
				  ~(SO_REUSEADDR),
				  (const char *) &on, sizeof on);
	  debug_printf ("%d = setsockopt(SO_EXCLUSIVEADDRUSE), %E", ret);
	}
      if (::bind (get_socket (), name, namelen))
	set_winsock_errno ();
      else
	res = 0;
    }

out:
  return res;
}

int
fhandler_socket::connect (const struct sockaddr *name, int namelen)
{
  struct sockaddr_storage sst;
  int type;

  if (get_inet_addr (name, namelen, &sst, &namelen, &type, connect_secret)
      == SOCKET_ERROR)
    return SOCKET_ERROR;

  if (get_addr_family () == AF_LOCAL)
    {
      if (get_socket_type () != type)
	{
	  WSASetLastError (WSAEPROTOTYPE);
	  set_winsock_errno ();
	  return SOCKET_ERROR;
	}

      set_peer_sun_path (name->sa_data);

      /* Don't move af_local_set_cred into af_local_connect which may be called
	 via select, possibly running under another identity.  Call early here,
	 because af_local_connect is called in wait_for_events. */
      if (get_socket_type () == SOCK_STREAM)
	af_local_set_cred ();
    }
  
  /* Initialize connect state to "connect_pending".  State is ultimately set
     to "connected" or "connect_failed" in wait_for_events when the FD_CONNECT
     event occurs.  Note that the underlying OS sockets are always non-blocking
     and a successfully initiated non-blocking Winsock connect always returns
     WSAEWOULDBLOCK.  Thus it's safe to rely on event handling.

     Check for either unconnected or connect_failed since in both cases it's
     allowed to retry connecting the socket.  It's also ok (albeit ugly) to
     call connect to check if a previous non-blocking connect finished.

     Set connect_state before calling connect, otherwise a race condition with
     an already running select or poll might occur. */
  if (connect_state () == unconnected || connect_state () == connect_failed)
    connect_state (connect_pending);

  int res = ::connect (get_socket (), (struct sockaddr *) &sst, namelen);
  if (!is_nonblocking ()
      && res == SOCKET_ERROR
      && WSAGetLastError () == WSAEWOULDBLOCK)
    res = wait_for_events (FD_CONNECT | FD_CLOSE, 0);

  if (res)
    {
      DWORD err = WSAGetLastError ();
      
      /* Some applications use the ugly technique to check if a non-blocking
         connect succeeded by calling connect again, until it returns EISCONN.
	 This circumvents the event handling and connect_state is never set.
	 Thus we check for this situation here. */
      if (err == WSAEISCONN)
	connect_state (connected);
      /* Winsock returns WSAEWOULDBLOCK if the non-blocking socket cannot be
         conected immediately.  Convert to POSIX/Linux compliant EINPROGRESS. */
      else if (is_nonblocking () && err == WSAEWOULDBLOCK)
	WSASetLastError (WSAEINPROGRESS);
      /* Winsock returns WSAEINVAL if the socket is already a listener.
      	 Convert to POSIX/Linux compliant EISCONN. */
      else if (err == WSAEINVAL && connect_state () == listener)
	WSASetLastError (WSAEISCONN);
      /* Any other error except WSAEALREADY during connect_pending means the
         connect failed. */
      else if (connect_state () == connect_pending && err != WSAEALREADY)
      	connect_state (connect_failed);
      set_winsock_errno ();
    }

  return res;
}

int
fhandler_socket::listen (int backlog)
{
  int res = ::listen (get_socket (), backlog);
  if (res && WSAGetLastError () == WSAEINVAL)
    {
      /* It's perfectly valid to call listen on an unbound INET socket.
	 In this case the socket is automatically bound to an unused
	 port number, listening on all interfaces.  On WinSock, listen
	 fails with WSAEINVAL when it's called on an unbound socket.
	 So we have to bind manually here to have POSIX semantics. */
      if (get_addr_family () == AF_INET)
	{
	  struct sockaddr_in sin;
	  sin.sin_family = AF_INET;
	  sin.sin_port = 0;
	  sin.sin_addr.s_addr = INADDR_ANY;
	  if (!::bind (get_socket (), (struct sockaddr *) &sin, sizeof sin))
	    res = ::listen (get_socket (), backlog);
	}
      else if (get_addr_family () == AF_INET6)
	{
	  struct sockaddr_in6 sin6;
	  memset (&sin6, 0, sizeof sin6);
	  sin6.sin6_family = AF_INET6;
	  if (!::bind (get_socket (), (struct sockaddr *) &sin6, sizeof sin6))
	    res = ::listen (get_socket (), backlog);
	}
    }
  if (!res)
    {
      if (get_addr_family () == AF_LOCAL && get_socket_type () == SOCK_STREAM)
	af_local_set_cred ();
      connect_state (listener);	/* gets set to connected on accepted socket. */
    }
  else
    set_winsock_errno ();
  return res;
}

int
fhandler_socket::accept4 (struct sockaddr *peer, int *len, int flags)
{
  /* Allows NULL peer and len parameters. */
  struct sockaddr_storage lpeer;
  int llen = sizeof (struct sockaddr_storage);

  int res = (int) INVALID_SOCKET;

  /* Windows event handling does not check for the validity of the desired
     flags so we have to do it here. */
  if (connect_state () != listener)
    {
      WSASetLastError (WSAEINVAL);
      set_winsock_errno ();
      goto out;
    }

  while (!(res = wait_for_events (FD_ACCEPT | FD_CLOSE, 0))
	 && (res = ::accept (get_socket (), (struct sockaddr *) &lpeer, &llen))
	    == SOCKET_ERROR
	 && WSAGetLastError () == WSAEWOULDBLOCK)
    ;
  if (res == (int) INVALID_SOCKET)
    set_winsock_errno ();
  else
    {
      cygheap_fdnew res_fd;
      if (res_fd >= 0 && fdsock (res_fd, &dev (), res))
	{
	  fhandler_socket *sock = (fhandler_socket *) res_fd;
	  sock->set_addr_family (get_addr_family ());
	  sock->set_socket_type (get_socket_type ());
	  sock->async_io (false); /* fdsock switches async mode off. */
	  if (get_addr_family () == AF_LOCAL)
	    {
	      sock->set_sun_path (get_sun_path ());
	      sock->set_peer_sun_path (get_peer_sun_path ());
	      if (get_socket_type () == SOCK_STREAM)
		{
		  /* Don't forget to copy credentials from accepting
		     socket to accepted socket and start transaction
		     on accepted socket! */
		  af_local_copy (sock);
		  res = sock->af_local_accept ();
		  if (res == -1)
		    {
		      res_fd.release ();
		      set_winsock_errno ();
		      goto out;
		    }
		}
	    }
	  sock->set_nonblocking (flags & SOCK_NONBLOCK);
	  if (flags & SOCK_CLOEXEC)
	    sock->set_close_on_exec (true);
	  /* No locking necessary at this point. */
	  sock->wsock_events->events = wsock_events->events | FD_WRITE;
	  sock->wsock_events->owner = wsock_events->owner;
	  sock->connect_state (connected);
	  res = res_fd;
	  if (peer)
	    {
	      if (get_addr_family () == AF_LOCAL)
		{
		  /* FIXME: Right now we have no way to determine the
		     bound socket name of the peer's socket.  For now
		     we just fake an unbound socket on the other side. */
		  static struct sockaddr_un un = { AF_LOCAL, "" };
		  memcpy (peer, &un, MIN (*len, (int) sizeof (un.sun_family)));
		  *len = (int) sizeof (un.sun_family);
		}
	      else
		{
		  memcpy (peer, &lpeer, MIN (*len, llen));
		  *len = llen;
		}
	    }
	}
      else
	{
	  closesocket (res);
	  res = -1;
	}
    }

out:
  debug_printf ("res %d", res);
  return res;
}

int
fhandler_socket::getsockname (struct sockaddr *name, int *namelen)
{
  int res = -1;

  if (get_addr_family () == AF_LOCAL)
    {
      struct sockaddr_un sun;
      sun.sun_family = AF_LOCAL;
      sun.sun_path[0] = '\0';
      if (get_sun_path ())
	strncat (sun.sun_path, get_sun_path (), UNIX_PATH_MAX - 1);
      memcpy (name, &sun, MIN (*namelen, (int) SUN_LEN (&sun) + 1));
      *namelen = (int) SUN_LEN (&sun) + (get_sun_path () ? 1 : 0);
      res = 0;
    }
  else
    {
      /* Always use a local big enough buffer and truncate later as necessary
	 per POSIX.  WinSock unfortunaltey only returns WSAEFAULT if the buffer
	 is too small. */
      struct sockaddr_storage sock;
      int len = sizeof sock;
      res = ::getsockname (get_socket (), (struct sockaddr *) &sock, &len);
      if (!res)
	{
	  memcpy (name, &sock, MIN (*namelen, len));
	  *namelen = len;
	}
      else
	{
	  if (WSAGetLastError () == WSAEINVAL)
	    {
	      /* WinSock returns WSAEINVAL if the socket is locally
		 unbound.  Per SUSv3 this is not an error condition.
		 We're faking a valid return value here by creating the
		 same content in the sockaddr structure as on Linux. */
	      memset (&sock, 0, sizeof sock);
	      sock.ss_family = get_addr_family ();
	      switch (get_addr_family ())
		{
		case AF_INET:
		  res = 0;
		  len = (int) sizeof (struct sockaddr_in);
		  break;
		case AF_INET6:
		  res = 0;
		  len = (int) sizeof (struct sockaddr_in6);
		  break;
		default:
		  WSASetLastError (WSAEOPNOTSUPP);
		  break;
		}
	      if (!res)
		{
		  memcpy (name, &sock, MIN (*namelen, len));
		  *namelen = len;
		}
	    }
	  if (res)
	    set_winsock_errno ();
	}
    }

  return res;
}

int
fhandler_socket::getpeername (struct sockaddr *name, int *namelen)
{
  /* Always use a local big enough buffer and truncate later as necessary
     per POSIX.  WinSock unfortunately only returns WSAEFAULT if the buffer
     is too small. */
  struct sockaddr_storage sock;
  int len = sizeof sock;
  int res = ::getpeername (get_socket (), (struct sockaddr *) &sock, &len);
  if (res)
    set_winsock_errno ();
  else if (get_addr_family () == AF_LOCAL)
    {
      struct sockaddr_un sun;
      memset (&sun, 0, sizeof sun);
      sun.sun_family = AF_LOCAL;
      sun.sun_path[0] = '\0';
      if (get_peer_sun_path ())
	strncat (sun.sun_path, get_peer_sun_path (), UNIX_PATH_MAX - 1);
      memcpy (name, &sun, MIN (*namelen, (int) SUN_LEN (&sun) + 1));
      *namelen = (int) SUN_LEN (&sun) + (get_peer_sun_path () ? 1 : 0);
    }
  else
    {
      memcpy (name, &sock, MIN (*namelen, len));
      *namelen = len;
    }

  return res;
}

/* There's no DLL which exports the symbol WSARecvMsg.  One has to call
   WSAIoctl as below to fetch the function pointer.  Why on earth did the
   MS developers decide not to export a normal symbol for these extension
   functions? */
inline int
get_ext_funcptr (SOCKET sock, void *funcptr)
{
  DWORD bret;
  const GUID guid = WSAID_WSARECVMSG;
  return WSAIoctl (sock, SIO_GET_EXTENSION_FUNCTION_POINTER,
		   (void *) &guid, sizeof (GUID), funcptr, sizeof (void *),
		   &bret, NULL, NULL);
}

inline ssize_t
fhandler_socket::recv_internal (LPWSAMSG wsamsg, bool use_recvmsg)
{
  ssize_t res = 0;
  DWORD ret = 0, wret;
  int evt_mask = FD_READ | ((wsamsg->dwFlags & MSG_OOB) ? FD_OOB : 0);
  LPWSABUF &wsabuf = wsamsg->lpBuffers;
  ULONG &wsacnt = wsamsg->dwBufferCount;
  static NO_COPY LPFN_WSARECVMSG WSARecvMsg;
  int orig_namelen = wsamsg->namelen;

  /* CV 2014-10-26: Do not check for the connect_state at this point.  In
     certain scenarios there's no way to check the connect state reliably.
     Example (hexchat): Parent process creates socket, forks, child process
     calls connect, parent process calls read.  Even if the event handling
     allows to check for FD_CONNECT in the parent, there is always yet another
     scenario we can easily break. */

  DWORD wait_flags = wsamsg->dwFlags;
  bool waitall = !!(wait_flags & MSG_WAITALL);
  wsamsg->dwFlags &= (MSG_OOB | MSG_PEEK | MSG_DONTROUTE);
  if (use_recvmsg)
    {
      if (!WSARecvMsg
	  && get_ext_funcptr (get_socket (), &WSARecvMsg) == SOCKET_ERROR)
	{
	  if (wsamsg->Control.len > 0)
	    {
	      set_winsock_errno ();
	      return SOCKET_ERROR;
	    }
	  use_recvmsg = false;
	}
      else /* Only MSG_PEEK is supported by WSARecvMsg. */
	wsamsg->dwFlags &= MSG_PEEK;
    }
  if (waitall)
    {
      if (get_socket_type () != SOCK_STREAM)
	{
	  WSASetLastError (WSAEOPNOTSUPP);
	  set_winsock_errno ();
	  return SOCKET_ERROR;
	}
      if (is_nonblocking () || (wsamsg->dwFlags & (MSG_OOB | MSG_PEEK)))
	waitall = false;
    }

  /* Note: Don't call WSARecvFrom(MSG_PEEK) without actually having data
     waiting in the buffers, otherwise the event handling gets messed up
     for some reason. */
  while (!(res = wait_for_events (evt_mask | FD_CLOSE, wait_flags))
	 || saw_shutdown_read ())
    {
      if (use_recvmsg)
	res = WSARecvMsg (get_socket (), wsamsg, &wret, NULL, NULL);
      /* This is working around a really weird problem in WinSock.

	 Assume you create a socket, fork the process (thus duplicating
	 the socket), connect the socket in the child, then call recv
	 on the original socket handle in the parent process.
	 In this scenario, calls to WinSock's recvfrom and WSARecvFrom
	 in the parent will fail with WSAEINVAL, regardless whether both
	 address parameters, name and namelen, are NULL or point to valid
	 storage.  However, calls to recv and WSARecv succeed as expected.
	 Per MSDN, WSAEINVAL in the context of recv means  "The socket has not
	 been bound".  It is as if the recvfrom functions test if the socket
	 is bound locally, but in the parent process, WinSock doesn't know
	 about that and fails, while the same test is omitted in the recv
	 functions.

	 This also covers another weird case: WinSock returns WSAEFAULT if
	 namelen is a valid pointer while name is NULL.  Both parameters are
	 ignored for TCP sockets, so this only occurs when using UDP socket. */
      else if (!wsamsg->name || get_socket_type () == SOCK_STREAM)
	res = WSARecv (get_socket (), wsabuf, wsacnt, &wret, &wsamsg->dwFlags,
		       NULL, NULL);
      else
	res = WSARecvFrom (get_socket (), wsabuf, wsacnt, &wret,
			   &wsamsg->dwFlags, wsamsg->name, &wsamsg->namelen,
			   NULL, NULL);
      if (!res)
	{
	  ret += wret;
	  if (!waitall)
	    break;
	  while (wret && wsacnt)
	    {
	      if (wsabuf->len > wret)
		{
		  wsabuf->len -= wret;
		  wsabuf->buf += wret;
		  wret = 0;
		}
	      else
		{
		  wret -= wsabuf->len;
		  ++wsabuf;
		  --wsacnt;
		}
	    }
	  if (!wret)
	    break;
	}
      else if (WSAGetLastError () != WSAEWOULDBLOCK)
	break;
    }

  if (res)
    {
      /* According to SUSv3, errno isn't set in that case and no error
	 condition is returned. */
      if (WSAGetLastError () == WSAEMSGSIZE)
	ret += wret;
      else if (!ret)
	{
	  /* ESHUTDOWN isn't defined for recv in SUSv3.  Simply EOF is returned
	     in this case. */
	  if (WSAGetLastError () == WSAESHUTDOWN)
	    ret = 0;
	  else
	    {
	      set_winsock_errno ();
	      return SOCKET_ERROR;
	    }
	}
    }

  if (get_addr_family () == AF_LOCAL && wsamsg->name != NULL
      && orig_namelen >= (int) sizeof (sa_family_t))
    {
      /* WSARecvFrom copied the sockaddr_in block to wsamsg->name.  We have to
	 overwrite it with a sockaddr_un block.  For datagram sockets we
	 generate a sockaddr_un with a filename analogue to abstract socket
	 names under Linux.  See `man 7 unix' under Linux for a description. */
      sockaddr_un *un = (sockaddr_un *) wsamsg->name;
      un->sun_family = AF_LOCAL;
      int len = orig_namelen - offsetof (struct sockaddr_un, sun_path);
      if (len > 0)
	{
	  if (get_socket_type () == SOCK_DGRAM)
	    {
	      if (len >= 7)
		{
		  __small_sprintf (un->sun_path + 1, "d%04x",
			       ((struct sockaddr_in *) wsamsg->name)->sin_port);
		  wsamsg->namelen = offsetof (struct sockaddr_un, sun_path) + 7;
		}
	      else
		wsamsg->namelen = offsetof (struct sockaddr_un, sun_path) + 1;
	      un->sun_path[0] = '\0';
	    }
	  else if (!get_peer_sun_path ())
	    wsamsg->namelen = sizeof (sa_family_t);
	  else
	    {
	      memset (un->sun_path, 0, len);
	      strncpy (un->sun_path, get_peer_sun_path (), len);
	      if (un->sun_path[len - 1] == '\0')
		len = strlen (un->sun_path) + 1;
	      if (len > UNIX_PATH_MAX)
		len = UNIX_PATH_MAX;
	      wsamsg->namelen = offsetof (struct sockaddr_un, sun_path) + len;
	    }
	}
    }

  return ret;
}

void __reg3
fhandler_socket::read (void *in_ptr, size_t& len)
{
  char *ptr = (char *) in_ptr;

#ifdef __x86_64__
  /* size_t is 64 bit, but the len member in WSABUF is 32 bit.
     Split buffer if necessary. */
  DWORD bufcnt = len / UINT32_MAX + ((!len || (len % UINT32_MAX)) ? 1 : 0);
  WSABUF wsabuf[bufcnt];
  WSAMSG wsamsg = { NULL, 0, wsabuf, bufcnt, { 0,  NULL }, 0 };
  /* Don't use len as loop condition, it could be 0. */
  for (WSABUF *wsaptr = wsabuf; bufcnt--; ++wsaptr)
    {
      wsaptr->len = MIN (len, UINT32_MAX);
      wsaptr->buf = ptr;
      len -= wsaptr->len;
      ptr += wsaptr->len;
    }
#else
  WSABUF wsabuf = { len, ptr };
  WSAMSG wsamsg = { NULL, 0, &wsabuf, 1, { 0,  NULL }, 0 };
#endif
  
  len = recv_internal (&wsamsg, false);
}

ssize_t
fhandler_socket::readv (const struct iovec *const iov, const int iovcnt,
			ssize_t tot)
{
  WSABUF wsabuf[iovcnt];
  WSABUF *wsaptr = wsabuf + iovcnt;
  const struct iovec *iovptr = iov + iovcnt;
  while (--wsaptr >= wsabuf)
    {
      wsaptr->len = (--iovptr)->iov_len;
      wsaptr->buf = (char *) iovptr->iov_base;
    }
  WSAMSG wsamsg = { NULL, 0, wsabuf, (DWORD) iovcnt, { 0,  NULL}, 0 };
  return recv_internal (&wsamsg, false);
}

ssize_t
fhandler_socket::recvfrom (void *in_ptr, size_t len, int flags,
			   struct sockaddr *from, int *fromlen)
{
  char *ptr = (char *) in_ptr;

#ifdef __x86_64__
  /* size_t is 64 bit, but the len member in WSABUF is 32 bit.
     Split buffer if necessary. */
  DWORD bufcnt = len / UINT32_MAX + ((!len || (len % UINT32_MAX)) ? 1 : 0);
  WSABUF wsabuf[bufcnt];
  WSAMSG wsamsg = { from, from && fromlen ? *fromlen : 0,
		    wsabuf, bufcnt,
		    { 0,  NULL },
		    (DWORD) flags };
  /* Don't use len as loop condition, it could be 0. */
  for (WSABUF *wsaptr = wsabuf; bufcnt--; ++wsaptr)
    {
      wsaptr->len = MIN (len, UINT32_MAX);
      wsaptr->buf = ptr;
      len -= wsaptr->len;
      ptr += wsaptr->len;
    }
#else
  WSABUF wsabuf = { len, ptr };
  WSAMSG wsamsg = { from, from && fromlen ? *fromlen : 0,
		    &wsabuf, 1,
		    { 0, NULL},
		    (DWORD) flags };
#endif
  ssize_t ret = recv_internal (&wsamsg, false);
  if (fromlen)
    *fromlen = wsamsg.namelen;
  return ret;
}

ssize_t
fhandler_socket::recvmsg (struct msghdr *msg, int flags)
{
  /* TODO: Descriptor passing on AF_LOCAL sockets. */

  /* Disappointing but true:  Even if WSARecvMsg is supported, it's only
     supported for datagram and raw sockets. */
  bool use_recvmsg = true;
  if (get_socket_type () == SOCK_STREAM || get_addr_family () == AF_LOCAL)
    {
      use_recvmsg = false;
      msg->msg_controllen = 0;
    }

  WSABUF wsabuf[msg->msg_iovlen];
  WSABUF *wsaptr = wsabuf + msg->msg_iovlen;
  const struct iovec *iovptr = msg->msg_iov + msg->msg_iovlen;
  while (--wsaptr >= wsabuf)
    {
      wsaptr->len = (--iovptr)->iov_len;
      wsaptr->buf = (char *) iovptr->iov_base;
    }
  WSAMSG wsamsg = { (struct sockaddr *) msg->msg_name, msg->msg_namelen,
		    wsabuf, (DWORD) msg->msg_iovlen,
		    { (DWORD) msg->msg_controllen, (char *) msg->msg_control },
		    (DWORD) flags };
  ssize_t ret = recv_internal (&wsamsg, use_recvmsg);
  if (ret >= 0)
    {
      msg->msg_namelen = wsamsg.namelen;
      msg->msg_controllen = wsamsg.Control.len;
      if (!CYGWIN_VERSION_CHECK_FOR_USING_ANCIENT_MSGHDR)
	msg->msg_flags = wsamsg.dwFlags;
    }
  return ret;
}

inline ssize_t
fhandler_socket::send_internal (struct _WSAMSG *wsamsg, int flags)
{
  ssize_t res = 0;
  DWORD ret = 0, err = 0, sum = 0;
  WSABUF out_buf[wsamsg->dwBufferCount];
  bool use_sendmsg = false;
  DWORD wait_flags = flags & MSG_DONTWAIT;
  bool nosignal = !!(flags & MSG_NOSIGNAL);

  flags &= (MSG_OOB | MSG_DONTROUTE);
  if (wsamsg->Control.len > 0)
    use_sendmsg = true;
  /* Workaround for MSDN KB 823764: Split a message into chunks <= SO_SNDBUF.
     in_idx is the index of the current lpBuffers from the input wsamsg buffer.
     in_off is used to keep track of the next byte to write from a wsamsg
     buffer which only gets partially written. */
  for (DWORD in_idx = 0, in_off = 0;
       in_idx < wsamsg->dwBufferCount;
       in_off >= wsamsg->lpBuffers[in_idx].len && (++in_idx, in_off = 0))
    {
      /* Split a message into the least number of pieces to minimize the
	 number of WsaSendTo calls.  Don't split datagram messages (bad idea).
	 out_idx is the index of the next buffer in the out_buf WSABUF,
	 also the number of buffers given to WSASendTo.
	 out_len is the number of bytes in the buffers given to WSASendTo.
	 Don't split datagram messages (very bad idea). */
      DWORD out_idx = 0;
      DWORD out_len = 0;
      if (get_socket_type () == SOCK_STREAM)
	{
	  do
	    {
	      out_buf[out_idx].buf = wsamsg->lpBuffers[in_idx].buf + in_off;
	      out_buf[out_idx].len = wsamsg->lpBuffers[in_idx].len - in_off;
	      out_len += out_buf[out_idx].len;
	      out_idx++;
	    }
	  while (out_len < (unsigned) wmem ()
		 && (in_off = 0, ++in_idx < wsamsg->dwBufferCount));
	  /* Tweak len of the last out_buf buffer so the entire number of bytes
	     is (less than or) equal to wmem ().  Fix out_len as well since it's
	     used in a subsequent test expression. */
	  if (out_len > (unsigned) wmem ())
	    {
	      out_buf[out_idx - 1].len -= out_len - (unsigned) wmem ();
	      out_len = (unsigned) wmem ();
	    }
	  /* Add the bytes written from the current last buffer to in_off,
	     so in_off points to the next byte to be written from that buffer,
	     or beyond which lets the outper loop skip to the next buffer. */
	  in_off += out_buf[out_idx - 1].len;
	}

      do
	{
	  if (use_sendmsg)
	    res = WSASendMsg (get_socket (), wsamsg, flags, &ret, NULL, NULL);
	  else if (get_socket_type () == SOCK_STREAM)
	    res = WSASendTo (get_socket (), out_buf, out_idx, &ret, flags,
			     wsamsg->name, wsamsg->namelen, NULL, NULL);
	  else
	    res = WSASendTo (get_socket (), wsamsg->lpBuffers,
			     wsamsg->dwBufferCount, &ret, flags,
			     wsamsg->name, wsamsg->namelen, NULL, NULL);
	  if (res && (err = WSAGetLastError ()) == WSAEWOULDBLOCK)
	    {
	      LOCK_EVENTS;
	      wsock_events->events &= ~FD_WRITE;
	      UNLOCK_EVENTS;
	    }
	}
      while (res && err == WSAEWOULDBLOCK
	     && !(res = wait_for_events (FD_WRITE | FD_CLOSE, wait_flags)));

      if (!res)
	{
	  sum += ret;
	  /* For streams, return to application if the number of bytes written
	     is less than the number of bytes we intended to write in a single
	     call to WSASendTo.  Otherwise we would have to add code to
	     backtrack in the input buffers, which is questionable.  There was
	     probably a good reason we couldn't write more. */
	  if (get_socket_type () != SOCK_STREAM || ret < out_len)
	    break;
	}
      else if (is_nonblocking () || err != WSAEWOULDBLOCK)
	break;
    }

  if (sum)
    res = sum;
  else if (res == SOCKET_ERROR)
    {
      set_winsock_errno ();

      /* Special handling for EPIPE and SIGPIPE.

	 EPIPE is generated if the local end has been shut down on a connection
	 oriented socket.  In this case the process will also receive a SIGPIPE
	 unless MSG_NOSIGNAL is set.  */
      if ((get_errno () == ECONNABORTED || get_errno () == ESHUTDOWN)
	  && get_socket_type () == SOCK_STREAM)
	{
	  set_errno (EPIPE);
	  if (!nosignal)
	    raise (SIGPIPE);
	}
    }

  return res;
}

ssize_t
fhandler_socket::write (const void *in_ptr, size_t len)
{
  char *ptr = (char *) in_ptr;

#ifdef __x86_64__
  /* size_t is 64 bit, but the len member in WSABUF is 32 bit.
     Split buffer if necessary. */
  DWORD bufcnt = len / UINT32_MAX + ((!len || (len % UINT32_MAX)) ? 1 : 0);
  WSABUF wsabuf[bufcnt];
  WSAMSG wsamsg = { NULL, 0, wsabuf, bufcnt, { 0,  NULL }, 0 };
  /* Don't use len as loop condition, it could be 0. */
  for (WSABUF *wsaptr = wsabuf; bufcnt--; ++wsaptr)
    {
      wsaptr->len = MIN (len, UINT32_MAX);
      wsaptr->buf = ptr;
      len -= wsaptr->len;
      ptr += wsaptr->len;
    }
#else
  WSABUF wsabuf = { len, ptr };
  WSAMSG wsamsg = { NULL, 0, &wsabuf, 1, { 0, NULL }, 0 };
#endif
  return send_internal (&wsamsg, 0);
}

ssize_t
fhandler_socket::writev (const struct iovec *const iov, const int iovcnt,
			 ssize_t tot)
{
  WSABUF wsabuf[iovcnt];
  WSABUF *wsaptr = wsabuf;
  const struct iovec *iovptr = iov;
  for (int i = 0; i < iovcnt; ++i)
    {
      wsaptr->len = iovptr->iov_len;
      (wsaptr++)->buf = (char *) (iovptr++)->iov_base;
    }
  WSAMSG wsamsg = { NULL, 0, wsabuf, (DWORD) iovcnt, { 0, NULL}, 0 };
  return send_internal (&wsamsg, 0);
}

ssize_t
fhandler_socket::sendto (const void *in_ptr, size_t len, int flags,
			 const struct sockaddr *to, int tolen)
{
  char *ptr = (char *) in_ptr;
  struct sockaddr_storage sst;

  if (to && get_inet_addr (to, tolen, &sst, &tolen) == SOCKET_ERROR)
    return SOCKET_ERROR;

#ifdef __x86_64__
  /* size_t is 64 bit, but the len member in WSABUF is 32 bit.
     Split buffer if necessary. */
  DWORD bufcnt = len / UINT32_MAX + ((!len || (len % UINT32_MAX)) ? 1 : 0);
  WSABUF wsabuf[bufcnt];
  WSAMSG wsamsg = { to ? (struct sockaddr *) &sst : NULL, tolen,
		    wsabuf, bufcnt,
		    { 0,  NULL },
		    0 };
  /* Don't use len as loop condition, it could be 0. */
  for (WSABUF *wsaptr = wsabuf; bufcnt--; ++wsaptr)
    {
      wsaptr->len = MIN (len, UINT32_MAX);
      wsaptr->buf = ptr;
      len -= wsaptr->len;
      ptr += wsaptr->len;
    }
#else
  WSABUF wsabuf = { len, ptr };
  WSAMSG wsamsg = { to ? (struct sockaddr *) &sst : NULL, tolen,
		    &wsabuf, 1,
		    { 0, NULL},
		    0 };
#endif
  return send_internal (&wsamsg, flags);
}

ssize_t
fhandler_socket::sendmsg (const struct msghdr *msg, int flags)
{
  /* TODO: Descriptor passing on AF_LOCAL sockets. */

  struct sockaddr_storage sst;
  int len = 0;

  if (msg->msg_name
      && get_inet_addr ((struct sockaddr *) msg->msg_name, msg->msg_namelen,
			&sst, &len) == SOCKET_ERROR)
    return SOCKET_ERROR;

  WSABUF wsabuf[msg->msg_iovlen];
  WSABUF *wsaptr = wsabuf;
  const struct iovec *iovptr = msg->msg_iov;
  for (int i = 0; i < msg->msg_iovlen; ++i)
    {
      wsaptr->len = iovptr->iov_len;
      (wsaptr++)->buf = (char *) (iovptr++)->iov_base;
    }
  /* Disappointing but true:  Even if WSASendMsg is supported, it's only
     supported for datagram and raw sockets. */
  DWORD controllen = (DWORD) (!wincap.has_sendmsg ()
			      || get_socket_type () == SOCK_STREAM
			      || get_addr_family () == AF_LOCAL
			      ? 0 : msg->msg_controllen);
  WSAMSG wsamsg = { msg->msg_name ? (struct sockaddr *) &sst : NULL, len,
		    wsabuf, (DWORD) msg->msg_iovlen,
		    { controllen, (char *) msg->msg_control },
		    0 };
  return send_internal (&wsamsg, flags);
}

int
fhandler_socket::shutdown (int how)
{
  int res = ::shutdown (get_socket (), how);

  /* Linux allows to call shutdown for any socket, even if it's not connected.
     This also disables to call accept on this socket, if shutdown has been
     called with the SHUT_RD or SHUT_RDWR parameter.  In contrast, WinSock
     only allows to call shutdown on a connected socket.  The accept function
     is in no way affected.  So, what we do here is to fake success, and to
     change the event settings so that an FD_CLOSE event is triggered for the
     calling Cygwin function.  The evaluate_events method handles the call
     from accept specially to generate a Linux-compatible behaviour. */
  if (res && WSAGetLastError () != WSAENOTCONN)
    set_winsock_errno ();
  else
    {
      res = 0;
      switch (how)
	{
	case SHUT_RD:
	  saw_shutdown_read (true);
	  wsock_events->events |= FD_CLOSE;
	  SetEvent (wsock_evt);
	  break;
	case SHUT_WR:
	  saw_shutdown_write (true);
	  break;
	case SHUT_RDWR:
	  saw_shutdown_read (true);
	  saw_shutdown_write (true);
	  wsock_events->events |= FD_CLOSE;
	  SetEvent (wsock_evt);
	  break;
	}
    }
  return res;
}

int
fhandler_socket::close ()
{
  int res = 0;

  release_events ();
  while ((res = closesocket (get_socket ())) != 0)
    {
      if (WSAGetLastError () != WSAEWOULDBLOCK)
	{
	  set_winsock_errno ();
	  res = -1;
	  break;
	}
      if (cygwait (10) == WAIT_SIGNALED)
	{
	  set_errno (EINTR);
	  res = -1;
	  break;
	}
      WSASetLastError (0);
    }

  debug_printf ("%d = fhandler_socket::close()", res);
  return res;
}

/* Definitions of old ifreq stuff used prior to Cygwin 1.7.0. */
#define OLD_SIOCGIFFLAGS    _IOW('s', 101, struct __old_ifreq)
#define OLD_SIOCGIFADDR     _IOW('s', 102, struct __old_ifreq)
#define OLD_SIOCGIFBRDADDR  _IOW('s', 103, struct __old_ifreq)
#define OLD_SIOCGIFNETMASK  _IOW('s', 104, struct __old_ifreq)
#define OLD_SIOCGIFHWADDR   _IOW('s', 105, struct __old_ifreq)
#define OLD_SIOCGIFMETRIC   _IOW('s', 106, struct __old_ifreq)
#define OLD_SIOCGIFMTU      _IOW('s', 107, struct __old_ifreq)
#define OLD_SIOCGIFINDEX    _IOW('s', 108, struct __old_ifreq)

#define CONV_OLD_TO_NEW_SIO(old) (((old)&0xff00ffff)|(((long)sizeof(struct ifreq)&IOCPARM_MASK)<<16))

struct __old_ifreq {
#define __OLD_IFNAMSIZ	16
  union {
    char    ifrn_name[__OLD_IFNAMSIZ];   /* if name, e.g. "en0" */
  } ifr_ifrn;

  union {
    struct  sockaddr ifru_addr;
    struct  sockaddr ifru_broadaddr;
    struct  sockaddr ifru_netmask;
    struct  sockaddr ifru_hwaddr;
    short   ifru_flags;
    int     ifru_metric;
    int     ifru_mtu;
    int     ifru_ifindex;
  } ifr_ifru;
};

int
fhandler_socket::ioctl (unsigned int cmd, void *p)
{
  extern int get_ifconf (struct ifconf *ifc, int what); /* net.cc */
  int res;
  struct ifconf ifc, *ifcp;
  struct ifreq *ifrp;

  switch (cmd)
    {
    case SIOCGIFCONF:
      ifcp = (struct ifconf *) p;
      if (!ifcp)
	{
	  set_errno (EINVAL);
	  return -1;
	}
      if (CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ)
	{
	  ifc.ifc_len = ifcp->ifc_len / sizeof (struct __old_ifreq)
			* sizeof (struct ifreq);
	  ifc.ifc_buf = (caddr_t) alloca (ifc.ifc_len);
	}
      else
	{
	  ifc.ifc_len = ifcp->ifc_len;
	  ifc.ifc_buf = ifcp->ifc_buf;
	}
      res = get_ifconf (&ifc, cmd);
      if (res)
	debug_printf ("error in get_ifconf");
      if (CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ)
	{
	  struct __old_ifreq *ifr = (struct __old_ifreq *) ifcp->ifc_buf;
	  for (ifrp = ifc.ifc_req;
	       (caddr_t) ifrp < ifc.ifc_buf + ifc.ifc_len;
	       ++ifrp, ++ifr)
	    {
	      memcpy (&ifr->ifr_ifrn, &ifrp->ifr_ifrn, sizeof ifr->ifr_ifrn);
	      ifr->ifr_name[__OLD_IFNAMSIZ - 1] = '\0';
	      memcpy (&ifr->ifr_ifru, &ifrp->ifr_ifru, sizeof ifr->ifr_ifru);
	    }
	  ifcp->ifc_len = ifc.ifc_len / sizeof (struct ifreq)
			  * sizeof (struct __old_ifreq);
	}
      else
	ifcp->ifc_len = ifc.ifc_len;
      break;
    case OLD_SIOCGIFFLAGS:
    case OLD_SIOCGIFADDR:
    case OLD_SIOCGIFBRDADDR:
    case OLD_SIOCGIFNETMASK:
    case OLD_SIOCGIFHWADDR:
    case OLD_SIOCGIFMETRIC:
    case OLD_SIOCGIFMTU:
    case OLD_SIOCGIFINDEX:
      cmd = CONV_OLD_TO_NEW_SIO (cmd);
      /*FALLTHRU*/
    case SIOCGIFFLAGS:
    case SIOCGIFBRDADDR:
    case SIOCGIFNETMASK:
    case SIOCGIFADDR:
    case SIOCGIFHWADDR:
    case SIOCGIFMETRIC:
    case SIOCGIFMTU:
    case SIOCGIFINDEX:
    case SIOCGIFFRNDLYNAM:
    case SIOCGIFDSTADDR:
      {
	if (!p)
	  {
	    debug_printf ("ifr == NULL");
	    set_errno (EINVAL);
	    return -1;
	  }

	if (cmd > SIOCGIFINDEX && CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ)
	  {
	    debug_printf ("cmd not supported on this platform");
	    set_errno (EINVAL);
	    return -1;
	  }
	ifc.ifc_len = 64 * sizeof (struct ifreq);
	ifc.ifc_buf = (caddr_t) alloca (ifc.ifc_len);
	if (cmd == SIOCGIFFRNDLYNAM)
	  {
	    struct ifreq_frndlyname *iff = (struct ifreq_frndlyname *)
				alloca (64 * sizeof (struct ifreq_frndlyname));
	    for (int i = 0; i < 64; ++i)
	      ifc.ifc_req[i].ifr_frndlyname = &iff[i];
	  }

	res = get_ifconf (&ifc, cmd);
	if (res)
	  {
	    debug_printf ("error in get_ifconf");
	    break;
	  }

	if (CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ)
	  {
	    struct __old_ifreq *ifr = (struct __old_ifreq *) p;
	    debug_printf ("    name: %s", ifr->ifr_name);
	    for (ifrp = ifc.ifc_req;
		 (caddr_t) ifrp < ifc.ifc_buf + ifc.ifc_len;
		 ++ifrp)
	      {
		debug_printf ("testname: %s", ifrp->ifr_name);
		if (! strcmp (ifrp->ifr_name, ifr->ifr_name))
		  {
		    memcpy (&ifr->ifr_ifru, &ifrp->ifr_ifru,
			    sizeof ifr->ifr_ifru);
		    break;
		  }
	      }
	  }
	else
	  {
	    struct ifreq *ifr = (struct ifreq *) p;
	    debug_printf ("    name: %s", ifr->ifr_name);
	    for (ifrp = ifc.ifc_req;
		 (caddr_t) ifrp < ifc.ifc_buf + ifc.ifc_len;
		 ++ifrp)
	      {
		debug_printf ("testname: %s", ifrp->ifr_name);
		if (! strcmp (ifrp->ifr_name, ifr->ifr_name))
		  {
		    if (cmd == SIOCGIFFRNDLYNAM)
		      /* The application has to care for the space. */
		      memcpy (ifr->ifr_frndlyname, ifrp->ifr_frndlyname,
			      sizeof (struct ifreq_frndlyname));
		    else
		      memcpy (&ifr->ifr_ifru, &ifrp->ifr_ifru,
			      sizeof ifr->ifr_ifru);
		    break;
		  }
	      }
	  }
	if ((caddr_t) ifrp >= ifc.ifc_buf + ifc.ifc_len)
	  {
	    set_errno (EINVAL);
	    return -1;
	  }
	break;
      }
    /* From this point on we handle only ioctl commands which are understood by
       Winsock.  However, we have a problem, which is, the different size of
       u_long in Windows and 64 bit Cygwin.  This affects the definitions of
       FIOASYNC, etc, because they are defined in terms of sizeof(u_long).
       So we have to use case labels which are independent of the sizeof
       u_long.  Since we're redefining u_long at the start of this file to
       matching Winsock's idea of u_long, we can use the real definitions in
       calls to Windows.  In theory we also have to make sure to convert the
       different ideas of u_long between the application and Winsock, but
       fortunately, the parameters defined as u_long pointers are on Linux
       and BSD systems defined as int pointer, so the applications will
       use a type of the expected size.  Hopefully. */
    case FIOASYNC:
#ifdef __x86_64__
    case _IOW('f', 125, unsigned long):
#endif
      res = WSAAsyncSelect (get_socket (), winmsg, WM_ASYNCIO,
	      *(int *) p ? ASYNC_MASK : 0);
      syscall_printf ("Async I/O on socket %s",
	      *(int *) p ? "started" : "cancelled");
      async_io (*(int *) p != 0);
      /* If async_io is switched off, revert the event handling. */
      if (*(int *) p == 0)
	WSAEventSelect (get_socket (), wsock_evt, EVENT_MASK);
      break;
    case FIONREAD:
#ifdef __x86_64__
    case _IOR('f', 127, unsigned long):
#endif
      res = ioctlsocket (get_socket (), FIONREAD, (u_long *) p);
      if (res == SOCKET_ERROR)
	set_winsock_errno ();
      break;
    default:
      /* Sockets are always non-blocking internally.  So we just note the
	 state here. */
#ifdef __x86_64__
      /* Convert the different idea of u_long in the definition of cmd. */
      if (((cmd >> 16) & IOCPARM_MASK) == sizeof (unsigned long))
      	cmd = (cmd & ~(IOCPARM_MASK << 16)) | (sizeof (u_long) << 16);
#endif
      if (cmd == FIONBIO)
	{
	  syscall_printf ("socket is now %sblocking",
			    *(int *) p ? "non" : "");
	  set_nonblocking (*(int *) p);
	  res = 0;
	}
      else
	res = ioctlsocket (get_socket (), cmd, (u_long *) p);
      break;
    }
  syscall_printf ("%d = ioctl_socket(%x, %p)", res, cmd, p);
  return res;
}

int
fhandler_socket::fcntl (int cmd, intptr_t arg)
{
  int res = 0;
  int request, current;

  switch (cmd)
    {
    case F_SETOWN:
      {
	pid_t pid = (pid_t) arg;
	LOCK_EVENTS;
	wsock_events->owner = pid;
	UNLOCK_EVENTS;
	debug_printf ("owner set to %d", pid);
      }
      break;
    case F_GETOWN:
      res = wsock_events->owner;
      break;
    case F_SETFL:
      {
	/* Carefully test for the O_NONBLOCK or deprecated OLD_O_NDELAY flag.
	   Set only the flag that has been passed in.  If both are set, just
	   record O_NONBLOCK.   */
	int new_flags = arg & O_NONBLOCK_MASK;
	if ((new_flags & OLD_O_NDELAY) && (new_flags & O_NONBLOCK))
	  new_flags = O_NONBLOCK;
	current = get_flags () & O_NONBLOCK_MASK;
	request = new_flags ? 1 : 0;
	if (!!current != !!new_flags && (res = ioctl (FIONBIO, &request)))
	  break;
	set_flags ((get_flags () & ~O_NONBLOCK_MASK) | new_flags);
	break;
      }
    default:
      res = fhandler_base::fcntl (cmd, arg);
      break;
    }
  return res;
}

void
fhandler_socket::set_close_on_exec (bool val)
{
  set_no_inheritance (wsock_mtx, val);
  set_no_inheritance (wsock_evt, val);
  if (need_fixup_before ())
    {
      close_on_exec (val);
      debug_printf ("set close_on_exec for %s to %d", get_name (), val);
    }
  else
    fhandler_base::set_close_on_exec (val);
}

void
fhandler_socket::set_sun_path (const char *path)
{
  sun_path = path ? cstrdup (path) : NULL;
}

void
fhandler_socket::set_peer_sun_path (const char *path)
{
  peer_sun_path = path ? cstrdup (path) : NULL;
}

int
fhandler_socket::getpeereid (pid_t *pid, uid_t *euid, gid_t *egid)
{
  if (get_addr_family () != AF_LOCAL || get_socket_type () != SOCK_STREAM)
    {
      set_errno (EINVAL);
      return -1;
    }
  if (no_getpeereid ())
    {
      set_errno (ENOTSUP);
      return -1;
    }
  if (connect_state () != connected)
    {
      set_errno (ENOTCONN);
      return -1;
    }

  __try
    {
      if (pid)
	*pid = sec_peer_pid;
      if (euid)
	*euid = sec_peer_uid;
      if (egid)
	*egid = sec_peer_gid;
      return 0;
    }
  __except (EFAULT) {}
  __endtry
  return -1;
}
@


1.316
log
@	* fhandler_socket.cc (fhandler_socket::connect): Don't change state
	on WSAEALREADY error.  Change comment accordingly.
@
text
@a407 1
  connect_state (connect_credxchg);
a429 1
  connect_state (connect_credxchg);
d1466 6
a1471 14
  /* Windows event handling does not check for the validity of the desired
     flags so we have to do it here.
     The check goes like this:
       STREAM sockets must be either connected, or they are AF_LOCAL
       sockets in the pre-connected credential exchange phase.
     All other states are disallowed.  */
  if (get_socket_type () == SOCK_STREAM && connect_state () != connected
      && (get_addr_family () != AF_LOCAL
	  || connect_state () != connect_credxchg))
    {
      WSASetLastError (WSAENOTCONN);
      set_winsock_errno ();
      return SOCKET_ERROR;
    }
@


1.315
log
@	* fhandler_socket.cc (fhandler_socket::connect): Init connect_state to
	connect_pending only on unconnected socket.  Set connect_state to
	connected on WSAEISCONN error.  Set connect_state to connect_failed
	on any other error except WSAEWOULDBLOCK if connect is still pending.
	Add lots of comment to explain why all of the above.
@
text
@d1204 3
a1206 2
      /* Any other error means the connmect failed. */
      else if (connect_state () == connect_pending)
@


1.314
log
@	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d1169 10
a1178 2
     WSAEWOULDBLOCK.  Thus it's safe to rely on event handling. */
  connect_state (connect_pending);
d1190 6
d1198 1
a1198 1
      if (is_nonblocking () && err == WSAEWOULDBLOCK)
d1202 1
a1202 1
      else if (err == WSAEINVAL)
d1204 3
@


1.313
log
@	* fhandler_socket.cc (fhandler_socket::af_local_connect): Drop outdated
	comment.
	(fhandler_socket::evaluate_events): Only set connect_state and call
	af_local_connect if connect_state is connect_pending.  Explain why.
	Drop redundant test for socket family and type.
	(fhandler_socket::connect): Extend comment.
@
text
@d404 4
a407 1
  debug_printf ("af_local_connect called");
d427 4
a430 1
  debug_printf ("af_local_accept called");
d446 19
d489 1
d2332 5
@


1.312
log
@	* fhandler_socket.cc (fhandler_socket::evaluate_events): Handle
	connect_state and af_local_connect connect call here, once, independent
	of FD_CONNECT being requested.  Add comment to explain why.
	(fhandler_socket::connect): Drop connect_state handling and calling
	af_local_connect.  Move remaining AF_LOCAL stuff prior  to calling
	::connect and explain why.  Simplify error case.
	* poll.cc (poll): Handle connect state independently of POLLOUT being
	requested for the descriptor to allow setting POLLIN if connect failed.
	Add comment.
	* select.cc (set_bits): Drop connect_state and AF_LOCAL handling here.
@
text
@a400 1
  /* This keeps the test out of select. */
d625 1
d631 9
a639 6
		 asking for descriptors ready to read). */
	      if (wsock_events->connect_errorcode)
		connect_state (connect_failed);
	      else if (get_addr_family () == AF_LOCAL
		       && get_socket_type () == SOCK_STREAM
		       && af_local_connect ())
d641 9
a649 2
		  wsock_events->connect_errorcode = WSAGetLastError ();
		  connect_state (connect_failed);
a650 2
	      else
		connect_state (connected);
d1141 3
a1143 1
     event occurs. */
@


1.311
log
@	* fhandler_socket.cc (fhandler_socket::evaluate_events): Slightly
	rearrange code.  Rephrase a comment.
@
text
@d624 20
a643 1
	    wsock_events->connect_errorcode = evts.iErrorCode[FD_CONNECT_BIT];
a1105 1
  bool in_progress = false;
a1106 1
  DWORD err;
d1113 1
a1113 1
  if (get_addr_family () == AF_LOCAL && get_socket_type () != type)
d1115 14
a1128 3
      WSASetLastError (WSAEPROTOTYPE);
      set_winsock_errno ();
      return SOCKET_ERROR;
d1130 5
d1142 1
a1142 3
  if (!res)
    err = 0;
  else
d1144 10
a1153 13
      err = WSAGetLastError ();
      /* Special handling for connect to return the correct error code
	 when called on a non-blocking socket. */
      if (is_nonblocking ())
	{
	  if (err == WSAEWOULDBLOCK || err == WSAEALREADY)
	    in_progress = true;

	  if (err == WSAEWOULDBLOCK)
	    WSASetLastError (err = WSAEINPROGRESS);
	}
      if (err == WSAEINVAL)
	WSASetLastError (err = WSAEISCONN);
a1156 22
  if (get_addr_family () == AF_LOCAL && (!res || in_progress))
    set_peer_sun_path (name->sa_data);

  if (get_addr_family () == AF_LOCAL && get_socket_type () == SOCK_STREAM)
    {
      af_local_set_cred (); /* Don't move into af_local_connect since
			       af_local_connect is called from select,
			       possibly running under another identity. */
      if (!res && af_local_connect ())
	{
	  set_winsock_errno ();
	  return SOCKET_ERROR;
	}
    }

  if (err == WSAEINPROGRESS || err == WSAEALREADY)
    connect_state (connect_pending);
  else if (err)
    connect_state (connect_failed);
  else
    connect_state (connected);

@


1.310
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d637 2
a638 2
	  int wsa_err = 0;
	  if ((wsa_err = wsock_events->connect_errorcode) != 0)
d645 1
a645 1
		 option, even if the dup'ed socket handle refers to the same
@


1.309
log
@	* fhandler.h (enum conn_state): Add "connect_credxchg" state.
	(class fhandler_socket): Grant another bit to connect_state flag.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Rearrange
	variable definition.  Set connect_state to connect_credxchg.
	(fhandler_socket::af_local_accept): Ditto.
	(fhandler_socket::recv_internal): Accept connect_credxchg on connection
	oriented AF_LOCAL sockets as well to allow the credential exchange.
	Extend comment to explain.
@
text
@d2296 13
a2308 10
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;
  if (pid)
    *pid = sec_peer_pid;
  if (euid)
    *euid = sec_peer_uid;
  if (egid)
    *egid = sec_peer_gid;
  return 0;
@


1.308
log
@	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::recv_internal): Explicitely check if the socket is
	connected if it's a stream socket.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.
@
text
@d399 2
d406 1
a406 1
  bool orig_async_io, orig_is_nonblocking;
d423 2
d426 1
a426 1
  bool orig_async_io, orig_is_nonblocking;
d1409 8
a1416 2
     flags so we have to do it here. */
  if (get_socket_type () == SOCK_STREAM && connect_state () != connected)
@


1.307
log
@	* fhandler_socket.cc (fhandler_socket::send_internal): Fix value of
	out_len when tweaking the last buffer so out_len is correct in a
	subsequent if expression.
@
text
@d1183 1
a1183 2
      connect_state (connected);
      listener (true);
d1197 11
a1207 1
  int res = 0;
d1404 9
a2284 6
  if (sec_peer_pid == (pid_t) 0)
    {
      set_errno (ENOTCONN);	/* Usually when calling getpeereid on
				   accepting (instead of accepted) socket. */
      return -1;
    }
@


1.306
log
@	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.
@
text
@d1704 2
a1705 1
	     is less than wmem (). */
d1707 4
a1710 1
	    out_buf[out_idx - 1].len -= out_len - (unsigned) wmem ();
@


1.305
log
@	* fhandler_socket.cc (fhandler_socket::evaluate_events): Call
	WSASetLastError after setsockopt.  Explain why.
@
text
@d1667 2
a1668 2
  DWORD ret = 0, err = 0, sum = 0, off = 0;
  WSABUF buf;
d1676 16
a1691 6
  for (DWORD i = 0; i < wsamsg->dwBufferCount;
       off >= wsamsg->lpBuffers[i].len && (++i, off = 0))
    {
      /* CV 2009-12-02: Don't split datagram messages. */
      /* FIXME: Look for a way to split a message into the least number of
		pieces to minimize the number of WsaSendTo calls. */
d1694 17
a1710 5
	  buf.buf = wsamsg->lpBuffers[i].buf + off;
	  buf.len = wsamsg->lpBuffers[i].len - off;
	  /* See net.cc:fdsock() and MSDN KB 823764 */
	  if (buf.len >= (unsigned) wmem ())
	    buf.len = (unsigned) wmem ();
d1718 1
a1718 1
	    res = WSASendTo (get_socket (), &buf, 1, &ret, flags,
a1735 1
	  off += ret;
d1737 6
a1742 1
	  if (get_socket_type () != SOCK_STREAM)
@


1.304
log
@	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.
@
text
@a635 1
	      WSASetLastError (wsa_err);
d644 5
a648 1
		 into the SO_ERROR socket option. */
d651 1
@


1.303
log
@	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.
@
text
@d2096 12
d2109 3
d2122 3
d2132 5
@


1.302
log
@	* devices.in (dev_storage): Map /dev/random and /dev/urandom to
	\Device\Null.
	* devices.cc: Regenerate.
	* fhandler.h (fhandler_dev_random::open): Drop declaration.
	(fhandler_dev_random::close): Ditto.
	(fhandler_dev_random::crypt_gen_random): Convert to static method.
	* fhandler_random.cc (fhandler_dev_random::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	(fhandler_dev_random::close): Ditto.
	* fhandler_socket.cc (entropy_source): Delete.
	(fhandler_socket::af_local_set_secret): Remove entropy_source code and
	call fhandler_dev_random::crypt_gen_random directly instead.
@
text
@d4 1
a4 1
   2011, 2012, 2013 Red Hat, Inc.
d20 9
d101 8
d112 3
d637 11
a2106 10
#ifdef __x86_64__
/* FIXME: This looks broken in the Mingw64 headers.  If I make sure
to use the Windows u_long definition, I'd expect that it's defined
as a 4 byte type on LP64 as well.  But that's not the case right now.
The *additional* type __ms_u_long is available on LP64, and that's
used in subsequent function declarations, but that's not available
on 32 bit or LLP64.  The LP64-ness shouldn't require to use another
type name in the application code. */
#define u_long __ms_u_long
#endif
@


1.302.2.1
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@d4 1
a4 1
   2011, 2012, 2013, 2014 Red Hat, Inc.
a19 9
#ifdef __x86_64__
/* 2014-04-24: Current Mingw headers define sockaddr_in6 using u_long (8 byte)
   because a redefinition for LP64 systems is missing.  This leads to a wrong
   definition and size of sockaddr_in6 when building with winsock headers.
   This definition is also required to use the right u_long type in subsequent
   function calls. */
#undef u_long
#define u_long __ms_u_long
#endif
a91 8
      memcpy (out, in, inlen);
      *outlen = inlen;
      /* If the peer address given in connect or sendto is the ANY address,
	 Winsock fails with WSAEADDRNOTAVAIL, while Linux converts that into
	 a connection/send attempt to LOOPBACK.  We're doing the same here. */
      if (((struct sockaddr_in *) out)->sin_addr.s_addr == htonl (INADDR_ANY))
	((struct sockaddr_in *) out)->sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      return 0;
a94 3
      /* See comment in AF_INET case. */
      if (IN6_IS_ADDR_UNSPECIFIED (&((struct sockaddr_in6 *) out)->sin6_addr))
	((struct sockaddr_in6 *) out)->sin6_addr = in6addr_loopback;
a616 11
	      /* CV 2014-04-23: This is really weird.  If you call connect
		 asynchronously on a socket and then select, an error like
		 "Connection refused" is set in the event and in the SO_ERROR
		 socket option.  If you call connect, then dup, then select,
		 the error is set in the event, but not in the SO_ERROR socket
		 option, even if the dup'ed socket handle refers to the same
		 socket.  We're trying to workaround this problem here by
		 taking the connect errorcode from the event and write it back
		 into the SO_ERROR socket option. */
	      setsockopt (get_socket (), SOL_SOCKET, SO_ERROR,
			  (const char *) &wsa_err, sizeof wsa_err);
a2064 12
    /* From this point on we handle only ioctl commands which are understood by
       Winsock.  However, we have a problem, which is, the different size of
       u_long in Windows and 64 bit Cygwin.  This affects the definitions of
       FIOASYNC, etc, because they are defined in terms of sizeof(u_long).
       So we have to use case labels which are independent of the sizeof
       u_long.  Since we're redefining u_long at the start of this file to
       matching Winsock's idea of u_long, we can use the real definitions in
       calls to Windows.  In theory we also have to make sure to convert the
       different ideas of u_long between the application and Winsock, but
       fortunately, the parameters defined as u_long pointers are on Linux
       and BSD systems defined as int pointer, so the applications will
       use a type of the expected size.  Hopefully. */
a2065 3
#ifdef __x86_64__
    case _IOW('f', 125, unsigned long):
#endif
d2077 8
a2084 1
    case _IOR('f', 127, unsigned long):
a2092 5
#ifdef __x86_64__
      /* Convert the different idea of u_long in the definition of cmd. */
      if (((cmd >> 16) & IOCPARM_MASK) == sizeof (unsigned long))
      	cmd = (cmd & ~(IOCPARM_MASK << 16)) | (sizeof (u_long) << 16);
#endif
@


1.302.2.2
log
@	* fhandler_socket.cc (fhandler_socket::evaluate_events): Call
	WSASetLastError after setsockopt.  Explain why.
@
text
@d636 1
d645 1
a645 5
		 into the SO_ERROR socket option.
	         
		 CV 2014-06-16: Call WSASetLastError *after* setsockopt since,
		 apparently, setsockopt sets the last WSA error code to 0 on
		 success. */
a647 1
	      WSASetLastError (wsa_err);
@


1.302.2.3
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@d1667 2
a1668 2
  DWORD ret = 0, err = 0, sum = 0;
  WSABUF out_buf[wsamsg->dwBufferCount];
d1676 6
a1681 16
  /* Workaround for MSDN KB 823764: Split a message into chunks <= SO_SNDBUF.
     in_idx is the index of the current lpBuffers from the input wsamsg buffer.
     in_off is used to keep track of the next byte to write from a wsamsg
     buffer which only gets partially written. */
  for (DWORD in_idx = 0, in_off = 0;
       in_idx < wsamsg->dwBufferCount;
       in_off >= wsamsg->lpBuffers[in_idx].len && (++in_idx, in_off = 0))
    {
      /* Split a message into the least number of pieces to minimize the
	 number of WsaSendTo calls.  Don't split datagram messages (bad idea).
	 out_idx is the index of the next buffer in the out_buf WSABUF,
	 also the number of buffers given to WSASendTo.
	 out_len is the number of bytes in the buffers given to WSASendTo.
	 Don't split datagram messages (very bad idea). */
      DWORD out_idx = 0;
      DWORD out_len = 0;
d1684 5
a1688 17
	  do
	    {
	      out_buf[out_idx].buf = wsamsg->lpBuffers[in_idx].buf + in_off;
	      out_buf[out_idx].len = wsamsg->lpBuffers[in_idx].len - in_off;
	      out_len += out_buf[out_idx].len;
	      out_idx++;
	    }
	  while (out_len < (unsigned) wmem ()
		 && (in_off = 0, ++in_idx < wsamsg->dwBufferCount));
	  /* Tweak len of the last out_buf buffer so the entire number of bytes
	     is less than wmem (). */
	  if (out_len > (unsigned) wmem ())
	    out_buf[out_idx - 1].len -= out_len - (unsigned) wmem ();
	  /* Add the bytes written from the current last buffer to in_off,
	     so in_off points to the next byte to be written from that buffer,
	     or beyond which lets the outper loop skip to the next buffer. */
	  in_off += out_buf[out_idx - 1].len;
d1696 1
a1696 1
	    res = WSASendTo (get_socket (), out_buf, out_idx, &ret, flags,
d1714 1
d1716 1
a1716 6
	  /* For streams, return to application if the number of bytes written
	     is less than the number of bytes we intended to write in a single
	     call to WSASendTo.  Otherwise we would have to add code to
	     backtrack in the input buffers, which is questionable.  There was
	     probably a good reason we couldn't write more. */
	  if (get_socket_type () != SOCK_STREAM || ret < out_len)
@


1.302.2.4
log
@	* fhandler_socket.cc (fhandler_socket::send_internal): Fix value of
	out_len when tweaking the last buffer so out_len is correct in a
	subsequent if expression.
@
text
@d1704 1
a1704 2
	     is (less than or) equal to wmem ().  Fix out_len as well since it's
	     used in a subsequent test expression. */
d1706 1
a1706 4
	    {
	      out_buf[out_idx - 1].len -= out_len - (unsigned) wmem ();
	      out_len = (unsigned) wmem ();
	    }
@


1.302.2.5
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d403 1
a403 4
  debug_printf ("af_local_connect called, no_getpeereid=%d", no_getpeereid ());
  if (no_getpeereid ())
    return 0;

d421 1
a421 4
  debug_printf ("af_local_accept called, no_getpeereid=%d", no_getpeereid ());
  if (no_getpeereid ())
    return 0;

a436 19
int
fhandler_socket::af_local_set_no_getpeereid ()
{
  if (get_addr_family () != AF_LOCAL || get_socket_type () != SOCK_STREAM)
    {
      set_errno (EINVAL);
      return -1;
    }
  if (connect_state () != unconnected)
    {
      set_errno (EALREADY);
      return -1;
    }

  debug_printf ("no_getpeereid set");
  no_getpeereid (true);
  return 0;
}

a460 1
  sock->no_getpeereid (no_getpeereid ());
d1183 2
a1184 1
      connect_state (listener);	/* gets set to connected on accepted socket. */
d1198 1
a1198 11
  int res = (int) INVALID_SOCKET;

  /* Windows event handling does not check for the validity of the desired
     flags so we have to do it here. */
  if (connect_state () != listener)
    {
      WSASetLastError (WSAEINVAL);
      set_winsock_errno ();
      goto out;
    }

d2262 1
a2262 1
  if (no_getpeereid ())
d2264 1
a2264 1
      set_errno (ENOTSUP);
d2267 1
a2267 1
  if (connect_state () != connected)
d2269 2
a2270 1
      set_errno (ENOTCONN);
d2274 10
a2283 13
  __try
    {
      if (pid)
	*pid = sec_peer_pid;
      if (euid)
	*euid = sec_peer_uid;
      if (egid)
	*egid = sec_peer_gid;
      return 0;
    }
  __except (EFAULT) {}
  __endtry
  return -1;
@


1.301
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@a50 2
fhandler_dev_random* entropy_source;

d446 3
a448 19
  if (!entropy_source)
    {
      void *buf = malloc (sizeof (fhandler_dev_random));
      entropy_source = new (buf) fhandler_dev_random ();
      entropy_source->dev () = *urandom_dev;
    }
  if (entropy_source &&
      !entropy_source->open (O_RDONLY))
    {
      delete entropy_source;
      entropy_source = NULL;
    }
  if (entropy_source)
    {
      size_t len = sizeof (connect_secret);
      entropy_source->read (connect_secret, len);
      if (len != sizeof (connect_secret))
	bzero ((char*) connect_secret, sizeof (connect_secret));
    }
@


1.300
log
@	* Merge in cygwin-64bit-branch.
@
text
@d849 1
a849 1
int __stdcall
d1530 1
a1530 1
void __stdcall
@


1.299
log
@	* fhandler_socket.cc (get_inet_addr): Handle abstract AF_LOCAL socket.
	(fhandler_socket::recv_internal): Create abstract socket name for
	AF_LOCAL datagram sockets.  Explain why we do that.
@
text
@d17 1
d19 4
a28 3
#include <ws2tcpip.h>
#include <mswsock.h>
#include <iphlpapi.h>
d237 1
a237 1
  __small_sprintf (buf, "socket:[%d]", get_socket ());
d333 1
a333 1
  struct ucred out = { (pid_t) 0, (__uid32_t) -1, (__gid32_t) -1 };
d426 2
a427 2
  sec_peer_uid = (__uid32_t) -1;
  sec_peer_gid = (__gid32_t) -1;
d509 1
a509 1
	api_fatal ("Couldn't create/open shared socket mutex %S, %p",
d571 1
a571 1
	  debug_printf ("NtCreateMutant(%S), %p", &uname, status);
d727 1
a727 1
    debug_printf ("WSADuplicateSocket succeeded (%lx)", prot_info_ptr->dwProviderReserved);
d757 1
a757 1
      debug_printf ("WSASocket succeeded (%lx)", new_sock);
d823 1
a823 1
fhandler_socket::fstat (struct __stat64 *buf)
d841 1
a841 1
	  buf->st_ino = (__ino64_t) ((DWORD) get_handle ());
d877 1
a877 1
fhandler_socket::fchown (__uid32_t uid, __gid32_t gid)
d889 1
a889 1
fhandler_socket::facl (int cmd, int nentries, __aclent32_t *aclbufp)
d1027 1
a1027 1
		debug_printf ("Setting delete dispostion failed, status = %p",
d1046 1
a1046 4
	     for a more detailed description.

	     KB 870562: Note that a bug in Win2K SP1-3 and XP up to SP1 only
	     enables this option for users in the local administrators group. */
a1070 2
  pthread_testcancel ();

a1180 2
  pthread_testcancel ();

a1352 24
void __stdcall
fhandler_socket::read (void *in_ptr, size_t& len)
{
  WSABUF wsabuf = { len, (char *) in_ptr };
  WSAMSG wsamsg = { NULL, 0, &wsabuf, 1, { 0,  NULL }, 0 };
  len = recv_internal (&wsamsg, false);
}

int
fhandler_socket::readv (const struct iovec *const iov, const int iovcnt,
			ssize_t tot)
{
  WSABUF wsabuf[iovcnt];
  WSABUF *wsaptr = wsabuf + iovcnt;
  const struct iovec *iovptr = iov + iovcnt;
  while (--wsaptr >= wsabuf)
    {
      wsaptr->len = (--iovptr)->iov_len;
      wsaptr->buf = (char *) iovptr->iov_base;
    }
  WSAMSG wsamsg = { NULL, 0, wsabuf, iovcnt, { 0,  NULL}, 0 };
  return recv_internal (&wsamsg, false);
}

d1530 43
d1574 1
a1574 1
fhandler_socket::recvfrom (void *ptr, size_t len, int flags,
d1577 1
a1577 1
  pthread_testcancel ();
d1579 19
a1597 1
  WSABUF wsabuf = { len, (char *) ptr };
d1601 2
a1602 1
		    flags };
a1611 2
  pthread_testcancel ();

d1617 1
a1617 2
  if (get_socket_type () == SOCK_STREAM || get_addr_family () == AF_LOCAL
      || !wincap.has_recvmsg ())
d1632 3
a1634 3
		    wsabuf, msg->msg_iovlen,
		    { msg->msg_controllen, (char *) msg->msg_control },
		    flags };
a1645 24
int
fhandler_socket::write (const void *ptr, size_t len)
{
  WSABUF wsabuf = { len, (char *) ptr };
  WSAMSG wsamsg = { NULL, 0, &wsabuf, 1, { 0, NULL }, 0 };
  return send_internal (&wsamsg, 0);
}

int
fhandler_socket::writev (const struct iovec *const iov, const int iovcnt,
			 ssize_t tot)
{
  WSABUF wsabuf[iovcnt];
  WSABUF *wsaptr = wsabuf;
  const struct iovec *iovptr = iov;
  for (int i = 0; i < iovcnt; ++i)
    {
      wsaptr->len = iovptr->iov_len;
      (wsaptr++)->buf = (char *) (iovptr++)->iov_base;
    }
  WSAMSG wsamsg = { NULL, 0, wsabuf, iovcnt, { 0, NULL}, 0 };
  return send_internal (&wsamsg, 0);
}

d1649 1
a1649 1
  int res = 0;
d1730 43
a1772 1
fhandler_socket::sendto (const void *ptr, size_t len, int flags,
d1775 1
a1777 2
  pthread_testcancel ();

d1781 19
a1799 1
  WSABUF wsabuf = { len, (char *) ptr };
d1804 1
d1808 1
a1808 1
int
a1815 2
  pthread_testcancel ();

d1829 6
d1836 2
a1837 8
		    wsabuf, msg->msg_iovlen,
		    /* Disappointing but true:  Even if WSASendMsg is
		       supported, it's only supported for datagram and
		       raw sockets. */
		    { !wincap.has_sendmsg ()
		      || get_socket_type () == SOCK_STREAM
		      || get_addr_family () == AF_LOCAL
		      ? 0 : msg->msg_controllen, (char *) msg->msg_control },
d1885 1
a1885 14
  /* TODO: CV - 2008-04-16.  Lingering disabled.  The original problem
     could be no longer reproduced on NT4, XP, 2K8.  Any return of a
     spurious "Connection reset by peer" *could* be caused by disabling
     the linger code here... */
#if 0
  /* HACK to allow a graceful shutdown even if shutdown() hasn't been
     called by the application. Note that this isn't the ultimate
     solution but it helps in many cases. */
  struct linger linger;
  linger.l_onoff = 1;
  linger.l_linger = 240; /* secs. default 2MSL value according to MSDN. */
  setsockopt (get_socket (), SOL_SOCKET, SO_LINGER,
	      (const char *)&linger, sizeof linger);
#endif
d2094 11
a2104 1
      res = ioctlsocket (get_socket (), FIONREAD, (unsigned long *) p);
d2119 1
a2119 1
	res = ioctlsocket (get_socket (), cmd, (unsigned long *) p);
d2122 1
a2122 1
  syscall_printf ("%d = ioctl_socket(%x, %x)", res, cmd, p);
d2127 1
a2127 1
fhandler_socket::fcntl (int cmd, void *arg)
d2151 1
a2151 1
	int new_flags = (int) arg & O_NONBLOCK_MASK;
d2195 1
a2195 1
fhandler_socket::getpeereid (pid_t *pid, __uid32_t *euid, __gid32_t *egid)
@


1.298
log
@	* include/sys/un.h (UNIX_PATH_MAX): Rename from UNIX_PATH_LEN to
	follow Linux.
	* fhandler_socket.cc: Change UNIX_PATH_LEN to UNIX_PATH_MAX throughout.
	(fhandler_socket::recv_internal): Don't return prematurely in case of
	successful return.  For AF_LOCAL sockets, overwrite returned AF_INET
	name with AF_LOCAL name.
@
text
@d75 15
d1520 4
a1523 2
      /* WSARecvFrom copied the sockaddr_in block to wsamsg->name.
	 We have to overwrite it with a sockaddr_un block. */
d1528 14
a1541 2
      	{
	  if (!get_peer_sun_path ())
@


1.297
log
@	* fhandler_socket.cc (fhandler_socket::bind): Fix check for AF_LOCAL
	filename length to allow non-NUL terminated strings within namelen
	bytes.  Copy over sun_path to local array sun_path to have a
	NUL-terminated string for subsequent function calls.  Move path_conv
	check before OS bind call to not bind the socket before being sure
	the file doesn't exist.  Add and fix comments.
@
text
@d908 1
a908 1
      if (len <= 1 || (len = strnlen (un_addr->sun_path, len)) > UNIX_PATH_LEN)
d1256 1
a1256 1
	strncat (sun.sun_path, get_sun_path (), UNIX_PATH_LEN - 1);
d1330 1
a1330 1
	strncat (sun.sun_path, get_peer_sun_path (), UNIX_PATH_LEN - 1);
d1390 1
d1487 2
a1488 3
	return ret + wret;

      if (!ret)
d1493 8
a1500 1
	    return 0;
d1502 22
a1523 2
	  set_winsock_errno ();
	  return SOCKET_ERROR;
@


1.296
log
@	* fhandler_socket.cc (fhandler_socket::bind): Fix error code for
	empty filename.
@
text
@d905 4
a908 3
      /* Check that name is within bounds and NUL-terminated. */
      if (len <= 1 || len > UNIX_PATH_LEN
	  || !memchr (un_addr->sun_path, '\0', len))
d913 23
a954 11
      path_conv pc (un_addr->sun_path, PC_SYM_FOLLOW);
      if (pc.error)
	{
	  set_errno (pc.error);
	  goto out;
	}
      if (pc.exists ())
	{
	  set_errno (EADDRINUSE);
	  goto out;
	}
d1015 1
a1015 1
	      set_sun_path (un_addr->sun_path);
@


1.295
log
@	* fhandler_socket.cc (fhandler_socket::bind): Fix length check of
	AF_LOCAL filename so it never accesses memory beyond namelen.  Also
	make sure filename is NUL-terminated.
@
text
@d909 1
a909 1
	  set_errno (len < 1 ? EINVAL : ENAMETOOLONG);
@


1.294
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d903 1
a903 1
      int len = sizeof sin;
d905 3
a907 1
      if (strlen (un_addr->sun_path) >= UNIX_PATH_LEN)
d909 1
a909 1
	  set_errno (ENAMETOOLONG);
d915 1
a915 1
      if (::bind (get_socket (), (sockaddr *) &sin, len))
@


1.293
log
@	* fhandler_registry.cc: Drop Mingw.org considerations.
	* fhandler_serial.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* sched.cc: Ditto.
	* sec_helper.cc: Ditto.
@
text
@d3 2
a4 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012 Red Hat, Inc.
d805 1
a805 1
int __stdcall
@


1.292
log
@Rename cancelable_wait -> cygwait throughout.
* DevNotes: Add entry cgf-000015.
* cygwait.h (cygwait): Don't allow an optional PLARGE_INTERGER argument.
@
text
@a1351 11
extern "C" {
#ifndef __MINGW64_VERSION_MAJOR
#define WSAID_WSARECVMSG \
	  {0xf689d7c8,0x6f1f,0x436b,{0x8a,0x53,0xe5,0x4f,0xe3,0x51,0xc3,0x22}};
typedef int (WSAAPI *LPFN_WSARECVMSG)(SOCKET,LPWSAMSG,LPDWORD,LPWSAOVERLAPPED,
				      LPWSAOVERLAPPED_COMPLETION_ROUTINE);
#endif
int WSAAPI WSASendMsg(SOCKET,LPWSAMSG,DWORD,LPDWORD, LPWSAOVERLAPPED,
		      LPWSAOVERLAPPED_COMPLETION_ROUTINE);
};

@


1.291
log
@	* fhandler.h (fhandler_socket::recv_internal): Add bool parameter.
	Add regparm attribute.
	* fhandler_socket.cc (fhandler_socket::read): Call recv_internal with
	second parameter set to false.
	(fhandler_socket::readv): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recv_internal): Convert use_recvmsg from local
	variable to parameter.  Use as request for using WSARecvMsg.  Only
	fail if WSARecvMsg can't be loaded and wsamsg->Control.len > 0,
	otherwise use WSARecv{From}.  Restrict dwFlags to MSG_PEEK when using
	WSARecvMsg.
	(fhandler_socket::recvmsg): Prefer using WSARecvMsg.  Change priority
	of tests for not using WSARecvMsg.  Call recv_internal with second
	parameter set accordingly.
@
text
@d128 1
a128 1
	  if (cancelable_wait (NULL, cw_nowait, cw_sig_eintr) == WAIT_SIGNALED
@


1.291.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d316 1
a316 1
  struct ucred out = { (pid_t) 0, (uid_t) -1, (gid_t) -1 };
d409 2
a410 2
  sec_peer_uid = (uid_t) -1;
  sec_peer_gid = (gid_t) -1;
d806 1
a806 1
fhandler_socket::fstat (struct stat *buf)
d824 1
a824 1
	  buf->st_ino = (ino_t) ((DWORD) get_handle ());
d860 1
a860 1
fhandler_socket::fchown (uid_t uid, gid_t gid)
d2074 1
a2074 1
fhandler_socket::getpeereid (pid_t *pid, uid_t *euid, gid_t *egid)
@


1.291.2.2
log
@Pull in changes from HEAD
@
text
@d128 1
a128 1
	  if (cygwait (NULL, cw_nowait, cw_sig_eintr) == WAIT_SIGNALED
@


1.291.2.3
log
@	Avoid various type ambiguity problems showing up in the 64 bit case:
	* cygheap.h (cygheap_user::set_sid): Convert to void.
	(cygheap_user::set_saved_sid): Ditto.
	* devices.h (struct device): Drop operator int& and DWORD& entirely.
	Throughout, use dev_t or fh_devices instead.
	* devices.cc: Regenerate.
	* fhandler.h (class fhandler_base): Convert _refcnt member to LONG.
	(fhandler_base::inc_refcnt): Return LONG.
	(fhandler_base::dec_refcnt): Ditto.
	(fhandler_base::get_major): Return _major_t.
	(fhandler_base::get_minor): Return _minor_t.
	(fhandler_base::get_unit): Delete.  Throughout, use get_minor instead
	of get_unit.
	(fhandler_socket::get_socket): Use SOCKET rather than int.  Only define
	if __INSIDE_CYGWIN_NET__ is defined.
	(fhandler_pty_slave::get_unit): Drop declaration.
	* fhandler_procnet.cc: Include Windows headers early.
	* fhandler_socket.cc: Ditto.
	* fhandler_tty.cc (fhandler_pty_slave::get_unit): Remove.
	* path.h (path_conv::get_device): Rename from get_devn and change return
	type to dev_t.  Accommodate throughout.
	(path_conv::get_unitn): Remove unused method.
	* pinfo.h (class pinfo): Drop operator== for int case.
	(pinfo::operator!): Define.
	* poll.cc: Don't define __INSIDE_CYGWIN_NET__.
	* syscalls.cc (getpgid): Replace use of pinfo::operator== with
	pinfo::operator!.
	* tty.h (tty_min::setntty): Convert 2nd parameter to _minor_t.
	* tty.h (tty_min::getntty): Change return type to dev_t.
	(tty_min::get_minor): Rename from get_unit.  Change return type to
	_minor_t.
@
text
@a17 3
#include <ws2tcpip.h>
#include <mswsock.h>
#include <iphlpapi.h>
d24 3
@


1.291.2.4
log
@	* fcntl.cc (fcntl64): Make arg an intptr_t.  Add comment to explain a
	potential type problem.  Fix syscall_printf.
	(_fcntl): Make arg an intptr_t.
	* fhandler.cc (fhandler_base::fcntl): Ditto.
	* fhandler_socket.cc (fhandler_socket::fcntl): Ditto.
	* fhandler.h: Align declarations.
@
text
@d2006 1
a2006 1
fhandler_socket::fcntl (int cmd, intptr_t arg)
d2030 1
a2030 1
	int new_flags = arg & O_NONBLOCK_MASK;
@


1.291.2.5
log
@	* fhandler_socket.cc: Throughout, fix casts to work on 64 bit.  Move
	calls to pthread_testcancel to upper syscall level for consistency.
	Move read, readv, write, and writev methods to keep together with
	equivalent recv and send methods.
	(fhandler_socket::read): Compute WSAMSG buffer on 64 bit to overcome
	type restriction of WSABUF len member.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::write): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Restructure for readability.
	* net.cc (cygwin_sendto): Call pthread_testcancel here.
	(cygwin_recvfrom): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
@
text
@d824 1
a824 1
	  buf->st_ino = (ino_t) ((uintptr_t) get_handle ());
d1042 2
d1154 2
d1328 24
a1498 43
void __stdcall
fhandler_socket::read (void *in_ptr, size_t& len)
{
  char *ptr = (char *) in_ptr;

#ifdef __x86_64__
  /* size_t is 64 bit, but the len member in WSABUF is 32 bit.
     Split buffer if necessary. */
  DWORD bufcnt = len / UINT_MAX + ((!len || (len % UINT_MAX)) ? 1 : 0);
  WSABUF wsabuf[bufcnt];
  WSAMSG wsamsg = { NULL, 0, wsabuf, bufcnt, { 0,  NULL }, 0 };
  /* Don't use len as loop condition, it could be 0. */
  for (WSABUF *wsaptr = wsabuf; bufcnt--; ++wsaptr)
    {
      wsaptr->len = MIN (len, UINT_MAX);
      wsaptr->buf = ptr;
      len -= wsaptr->len;
      ptr += wsaptr->len;
    }
#else
  WSABUF wsabuf = { len, ptr };
  WSAMSG wsamsg = { NULL, 0, &wsabuf, 1, { 0,  NULL }, 0 };
#endif
  
  len = recv_internal (&wsamsg, false);
}

int
fhandler_socket::readv (const struct iovec *const iov, const int iovcnt,
			ssize_t tot)
{
  WSABUF wsabuf[iovcnt];
  WSABUF *wsaptr = wsabuf + iovcnt;
  const struct iovec *iovptr = iov + iovcnt;
  while (--wsaptr >= wsabuf)
    {
      wsaptr->len = (--iovptr)->iov_len;
      wsaptr->buf = (char *) iovptr->iov_base;
    }
  WSAMSG wsamsg = { NULL, 0, wsabuf, (DWORD) iovcnt, { 0,  NULL}, 0 };
  return recv_internal (&wsamsg, false);
}

d1500 1
a1500 1
fhandler_socket::recvfrom (void *in_ptr, size_t len, int flags,
d1503 1
a1503 1
  char *ptr = (char *) in_ptr;
d1505 1
a1505 19
#ifdef __x86_64__
  /* size_t is 64 bit, but the len member in WSABUF is 32 bit.
     Split buffer if necessary. */
  DWORD bufcnt = len / UINT_MAX + ((!len || (len % UINT_MAX)) ? 1 : 0);
  WSABUF wsabuf[bufcnt];
  WSAMSG wsamsg = { from, from && fromlen ? *fromlen : 0,
		    wsabuf, bufcnt,
		    { 0,  NULL },
		    (DWORD) flags };
  /* Don't use len as loop condition, it could be 0. */
  for (WSABUF *wsaptr = wsabuf; bufcnt--; ++wsaptr)
    {
      wsaptr->len = MIN (len, UINT_MAX);
      wsaptr->buf = ptr;
      len -= wsaptr->len;
      ptr += wsaptr->len;
    }
#else
  WSABUF wsabuf = { len, ptr };
d1509 1
a1509 2
		    (DWORD) flags };
#endif
d1519 2
d1542 3
a1544 3
		    wsabuf, (DWORD) msg->msg_iovlen,
		    { (DWORD) msg->msg_controllen, (char *) msg->msg_control },
		    (DWORD) flags };
d1556 24
a1662 42
int
fhandler_socket::write (const void *in_ptr, size_t len)
{
  char *ptr = (char *) in_ptr;

#ifdef __x86_64__
  /* size_t is 64 bit, but the len member in WSABUF is 32 bit.
     Split buffer if necessary. */
  DWORD bufcnt = len / UINT_MAX + ((!len || (len % UINT_MAX)) ? 1 : 0);
  WSABUF wsabuf[bufcnt];
  WSAMSG wsamsg = { NULL, 0, wsabuf, bufcnt, { 0,  NULL }, 0 };
  /* Don't use len as loop condition, it could be 0. */
  for (WSABUF *wsaptr = wsabuf; bufcnt--; ++wsaptr)
    {
      wsaptr->len = MIN (len, UINT_MAX);
      wsaptr->buf = ptr;
      len -= wsaptr->len;
      ptr += wsaptr->len;
    }
#else
  WSABUF wsabuf = { len, ptr };
  WSAMSG wsamsg = { NULL, 0, &wsabuf, 1, { 0, NULL }, 0 };
#endif
  return send_internal (&wsamsg, 0);
}

int
fhandler_socket::writev (const struct iovec *const iov, const int iovcnt,
			 ssize_t tot)
{
  WSABUF wsabuf[iovcnt];
  WSABUF *wsaptr = wsabuf;
  const struct iovec *iovptr = iov;
  for (int i = 0; i < iovcnt; ++i)
    {
      wsaptr->len = iovptr->iov_len;
      (wsaptr++)->buf = (char *) (iovptr++)->iov_base;
    }
  WSAMSG wsamsg = { NULL, 0, wsabuf, (DWORD) iovcnt, { 0, NULL}, 0 };
  return send_internal (&wsamsg, 0);
}

d1664 1
a1664 1
fhandler_socket::sendto (const void *in_ptr, size_t len, int flags,
a1666 1
  char *ptr = (char *) in_ptr;
d1669 2
d1674 1
a1674 19
#ifdef __x86_64__
  /* size_t is 64 bit, but the len member in WSABUF is 32 bit.
     Split buffer if necessary. */
  DWORD bufcnt = len / UINT_MAX + ((!len || (len % UINT_MAX)) ? 1 : 0);
  WSABUF wsabuf[bufcnt];
  WSAMSG wsamsg = { to ? (struct sockaddr *) &sst : NULL, tolen,
		    wsabuf, bufcnt,
		    { 0,  NULL },
		    0 };
  /* Don't use len as loop condition, it could be 0. */
  for (WSABUF *wsaptr = wsabuf; bufcnt--; ++wsaptr)
    {
      wsaptr->len = MIN (len, UINT_MAX);
      wsaptr->buf = ptr;
      len -= wsaptr->len;
      ptr += wsaptr->len;
    }
#else
  WSABUF wsabuf = { len, ptr };
a1678 1
#endif
d1690 2
a1704 6
  /* Disappointing but true:  Even if WSASendMsg is supported, it's only
     supported for datagram and raw sockets. */
  DWORD controllen = (DWORD) (!wincap.has_sendmsg ()
			      || get_socket_type () == SOCK_STREAM
			      || get_addr_family () == AF_LOCAL
			      ? 0 : msg->msg_controllen);
d1706 8
a1713 2
		    wsabuf, (DWORD) msg->msg_iovlen,
		    { controllen, (char *) msg->msg_control },
d1983 1
a1983 1
      res = ioctlsocket (get_socket (), FIONREAD, (__ms_u_long *) p);
d1998 1
a1998 1
	res = ioctlsocket (get_socket (), cmd, (__ms_u_long *) p);
@


1.291.2.6
log
@	* fhandler_socket.cc (fhandler_socket::ioctl): Don't use __ms_u_long
	directly.  Rather only use it on 64 bit.  Add comment to explain the
	problem.
@
text
@a16 1
#define _BSDTYPES_DEFINED
a17 1
#undef _BSDTYPES_DEFINED
d2049 1
a2049 11
#ifdef __x86_64__
/* FIXME: This looks broken in the Mingw64 headers.  If I make sure
to use the Windows u_long definition, I'd expect that it's defined
as a 4 byte type on LP64 as well.  But that's not the case right now.
The *additional* type __ms_u_long is available on LP64, and that's
used in subsequent function declarations, but that's not available
on 32 bit or LLP64.  The LP64-ness shouldn't require to use another
type name in the application code. */
#define u_long __ms_u_long
#endif
      res = ioctlsocket (get_socket (), FIONREAD, (u_long *) p);
d2064 1
a2064 1
	res = ioctlsocket (get_socket (), cmd, (u_long *) p);
@


1.291.2.7
log
@	* include/cygwin/acl.h (struct __acl32): Drop.  Use struct acl or
	aclent_t throughout instead.
	* sec_acl.cc (aclcheck32): Mark currently unused variables as unused.
	(lacl32): Disable on x86_64.
	(acl): Alias to acl32 on x86_64.
	(facl): Alias to facl32 on x86_64.
	(aclcheck): Alias to aclcheck32 on x86_64.
	(aclsort): Alias to aclsort32 on x86_64.
	(acltomode): Alias to acltomode32 on x86_64.
	(aclfrommode): Alias to aclfrommode32 on x86_64.
	(acltopbits): Alias to acltopbits32 on x86_64.
	(aclfrompbits): Alias to aclfrompbits32 on x86_64.
	(acltotext): Alias to acltotext32 on x86_64.
	(aclfromtext): Alias to aclfromtext32 on x86_64.
	* resource.cc (getrlimit): Use correct cast to rlim_t rather than DWORD.
	* sched.cc (sched_setparam): Drop ThreadPriority and all code setting
	it.
@
text
@d874 1
a874 1
fhandler_socket::facl (int cmd, int nentries, aclent_t *aclbufp)
@


1.291.2.8
log
@	* fhandler_netdrive.cc: Use UINT32_MAX rather than UINT_MAX to make
	absolutely clear that we mean the 32 bit maximum.
	* fhandler_socket.cc: Ditto.
	* pinfo.cc: Ditto with INT32_MAX.
	* select.cc (fd_mask): Drop gratuitious definition.
	(sizeof_fd_set): Cast to size_t.
	* shared.cc (pround): Cast to ptrdiff_t.
	* strace.cc (strace::activate): Fix format string.
	(strace::write_childpid): Take pid_t as parameter.
	* include/sys/strace.h (strace::write_childpid): Change declaration
	accordingly.
	* sync.cc (muto::init): Cast in call to InterlockedExchangePointer to
	make compiler happy.
	* sync.h (class muto): De-const name.
	* syslog.cc (try_connect_syslogd): Take size_t as third argument.
	(vsyslog): Convert len to size_t.
	* thread.cc: Use {U}INT32_MAX rather than {U}LONG_MAX.  Througout change
	types used in Windows calls to matching Windows types.
	(pthread::cancel): Fix access to instruction pointer for x86_64.
	(pthread_attr_getstack): Cast to ptrdiff_t for pointer arithmetic.
	* thread.h: Throughout convert 'long' types to uint32_t or LONG.
@
text
@d1481 1
a1481 1
  DWORD bufcnt = len / UINT32_MAX + ((!len || (len % UINT32_MAX)) ? 1 : 0);
d1487 1
a1487 1
      wsaptr->len = MIN (len, UINT32_MAX);
d1525 1
a1525 1
  DWORD bufcnt = len / UINT32_MAX + ((!len || (len % UINT32_MAX)) ? 1 : 0);
d1534 1
a1534 1
      wsaptr->len = MIN (len, UINT32_MAX);
d1681 1
a1681 1
  DWORD bufcnt = len / UINT32_MAX + ((!len || (len % UINT32_MAX)) ? 1 : 0);
d1687 1
a1687 1
      wsaptr->len = MIN (len, UINT32_MAX);
d1728 1
a1728 1
  DWORD bufcnt = len / UINT32_MAX + ((!len || (len % UINT32_MAX)) ? 1 : 0);
d1737 1
a1737 1
      wsaptr->len = MIN (len, UINT32_MAX);
@


1.291.2.9
log
@Pull in changes from HEAD
@
text
@d1326 11
@


1.291.2.10
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d494 1
a494 1
	api_fatal ("Couldn't create/open shared socket mutex %S, %y",
d556 1
a556 1
	  debug_printf ("NtCreateMutant(%S), %y", &uname, status);
d712 1
a712 1
    debug_printf ("WSADuplicateSocket succeeded (%x)", prot_info_ptr->dwProviderReserved);
d742 1
a742 1
      debug_printf ("WSASocket succeeded (%p)", new_sock);
d997 1
a997 1
		debug_printf ("Setting delete dispostion failed, status = %y",
d2068 1
a2068 1
  syscall_printf ("%d = ioctl_socket(%x, %p)", res, cmd, p);
@


1.291.2.11
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011, 2012, 2013 Red Hat, Inc.
d807 1
a807 1
int __reg2
@


1.291.2.12
log
@Pull in changes from HEAD
@
text
@d905 1
a905 1
      int len = namelen - offsetof (struct sockaddr_un, sun_path);
d907 1
a907 3
      /* Check that name is within bounds and NUL-terminated. */
      if (len <= 1 || len > UNIX_PATH_LEN
	  || !memchr (un_addr->sun_path, '\0', len))
d909 1
a909 1
	  set_errno (len <= 1 ? (len == 1 ? ENOENT : EINVAL) : ENAMETOOLONG);
d915 1
a915 1
      if (::bind (get_socket (), (sockaddr *) &sin, len = sizeof sin))
@


1.291.2.13
log
@* cygserver_ipc (class ipc_retval): Add ssize_t member to anonymous union.
(ipc_retval::operator =): Add ssize_t variant for x86_64.
* fhandler_floppy.cc (fhandler_dev_floppy::raw_write): Change return
type to ssize_t to match fhandler.h.
* fhandler_socket.cc (fhandler_socket::readv): Ditto.
(fhandler_socket::write): Ditto.
(fhandler_socket::writev): Ditto.
(fhandler_socket::sendmsg): Ditto.
@
text
@d1491 1
a1491 1
ssize_t
d1664 1
a1664 1
ssize_t
d1690 1
a1690 1
ssize_t
d1743 1
a1743 1
ssize_t
@


1.291.2.14
log
@	* autoload.cc (AttachConsole): Remove.
	(GetModuleHandleExW): Remove.
	(GetSystemWow64DirectoryW): Remove.
	(GetVolumePathNamesForVolumeNameW): Remove.
	* exceptions.cc (cygwin_stackdump): Always call RtlCaptureContext.
	(exception::handle): Drop accidentally left in debugging statement.
	Always call RtlCaptureContext.
	(sigpacket::process): Always call RtlCaptureContext for current thread.
	* fhandler_disk_file.cc (fstatvfs): Drop code using
	FileFsSizeInformation.
	(struct __DIR_cache): Remove comment.
	(fhandler_disk_file::rewinddir): Drop W2K-only code.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Don't
	check for old OS.  Extend a comment.
	* fhandler_mem.cc (fhandler_dev_mem::open): Drop NT4 and W2K from
	debug output.
	* fhandler_proc.cc (format_proc_partitions): Drop Pre-XP considerations.
	* fhandler_procnet.cc (fhandler_procnet::exists): Ditto.
	(fhandler_procnet::readdir): Ditto.
	(format_procnet_ifinet6): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvmsg): Ditto.
	* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
	* init.cc (dll_entry): Drop W2K-only code.
	* net.cc (get_ifs): Rename from get_xp_ifs.
	(get_2k_ifs): Remove.
	(getifaddrs): Always call get_ifs.
	(get_ifconf): Ditto.
	(if_nametoindex): Drop Pre-XP considerations.
	(load_ipv6_funcs): Ditto.  Fix preceeding comment.
	* sec_auth.cc (lsaauth): Drop code handling fake_login_sid.
	* sec_helper.cc (fake_logon_sid): Remove.
	(set_cygwin_privileges): Fix uncommented statement to drop pre-XP
	considerations.
	* security.h (fake_logon_sid): Drop declaration.
	* shared.cc (shared_info::init_obcaseinsensitive): Drop W2K-only code.
	* wincap.cc: Throughout, remove setting all deprecated wincapc members.
	(wincap_minimal): Set to wincap_xpsp2.
	(wincap_2000): Remove.
	(wincap_2000sp4): Remove.
	(wincap_xp): Remove.
	(wincap_xpsp1): Remove.
	(wincapc::init): Drop OS 5.0 and pre-SP2 XP.
	* wincap.h (struct wincaps): Remove the following members:
	has_create_global_privilege, has_ioctl_storage_get_media_types_ex,
	has_disk_ex_ioctls, has_buggy_restart_scan, needs_logon_sid_in_sid_list,
	has_gaa_prefixes, has_recvmsg, has_stack_size_param_is_a_reservation,
	kernel_is_always_casesensitive, has_rtl_capture_context.
@
text
@d1551 2
a1552 1
  if (get_socket_type () == SOCK_STREAM || get_addr_family () == AF_LOCAL)
@


1.291.2.15
log
@Pull in changes from HEAD
@
text
@d907 3
a909 4
      /* Check that name is within bounds.  Don't check if the string is
         NUL-terminated, because there are projects out there which set
	 namelen to a value which doesn't cover the trailing NUL. */
      if (len <= 1 || (len = strnlen (un_addr->sun_path, len)) > UNIX_PATH_LEN)
a913 23
      /* Copy over the sun_path string into a buffer big enough to add a
	 trailing NUL. */
      char sun_path[len + 1];
      strncpy (sun_path, un_addr->sun_path, len);
      sun_path[len] = '\0';

      /* This isn't entirely foolproof, but we check first if the file exists
	 so we can return with EADDRINUSE before having bound the socket.
	 This allows an application to call bind again on the same socket using
	 another filename.  If we bind first, the application will not be able
	 to call bind successfully ever again. */
      path_conv pc (sun_path, PC_SYM_FOLLOW);
      if (pc.error)
	{
	  set_errno (pc.error);
	  goto out;
	}
      if (pc.exists ())
	{
	  set_errno (EADDRINUSE);
	  goto out;
	}

d933 11
d1004 1
a1004 1
	      set_sun_path (sun_path);
@


1.291.2.16
log
@Pull in changes from HEAD
@
text
@d910 1
a910 1
      if (len <= 1 || (len = strnlen (un_addr->sun_path, len)) > UNIX_PATH_MAX)
d1254 1
a1254 1
	strncat (sun.sun_path, get_sun_path (), UNIX_PATH_MAX - 1);
d1328 1
a1328 1
	strncat (sun.sun_path, get_peer_sun_path (), UNIX_PATH_MAX - 1);
a1363 1
  int orig_namelen = wsamsg->namelen;
d1460 3
a1462 2
	ret += wret;
      else if (!ret)
d1467 1
a1467 8
	    ret = 0;
	  else
	    {
	      set_winsock_errno ();
	      return SOCKET_ERROR;
	    }
	}
    }
d1469 2
a1470 22
  if (get_addr_family () == AF_LOCAL && wsamsg->name != NULL
      && orig_namelen >= (int) sizeof (sa_family_t))
    {
      /* WSARecvFrom copied the sockaddr_in block to wsamsg->name.
	 We have to overwrite it with a sockaddr_un block. */
      sockaddr_un *un = (sockaddr_un *) wsamsg->name;
      un->sun_family = AF_LOCAL;
      int len = orig_namelen - offsetof (struct sockaddr_un, sun_path);
      if (len > 0)
      	{
	  if (!get_peer_sun_path ())
	    wsamsg->namelen = sizeof (sa_family_t);
	  else
	    {
	      memset (un->sun_path, 0, len);
	      strncpy (un->sun_path, get_peer_sun_path (), len);
	      if (un->sun_path[len - 1] == '\0')
		len = strlen (un->sun_path) + 1;
	      if (len > UNIX_PATH_MAX)
		len = UNIX_PATH_MAX;
	      wsamsg->namelen = offsetof (struct sockaddr_un, sun_path) + len;
	    }
@


1.291.2.17
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@d1031 4
a1034 1
	     for a more detailed description. */
d1859 14
a1872 1

@


1.291.2.18
log
@	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Use %lu as
	format specifier to match HANDLE size.
	* net.cc (cygwin_sendto): Fix return type to be ssize_t.  Change
	syscall_printf return type format specifier to %lR.
	(cygwin_recvfrom): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
	* smallprint.cc (__small_vsprintf): Handle `l' for %R, too.
	(__small_vswprintf): Ditto.
	* syscalls.cc (read): Change syscall_printf return type format specifier
	to %lR.
	(readv): Ditto.
	(pread): Ditto.
	(write): Ditto.
	(writev): Ditto.
	(pwrite): Ditto.
	(lseek64): Enhance comment.
@
text
@d222 1
a222 1
  __small_sprintf (buf, "socket:[%lu]", get_socket ());
@


1.291.2.19
log
@	* fhandler_socket.cc (fhandler_socket::send_internal): Change type of
	local variable res to ssize_t.
	* net.cc (cygwin_sendto): Fix local variable res, containing return
	value, to be ssize_t as well.
	(cygwin_recvfrom): Ditto.
	(cygwin_recv): Ditto.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
	* syscalls.cc (write): Ditto.
	(writev): Ditto.
	* pipe.cc (fhandler_pipe::open): Fix type when reading handle value to
	accommodate 32 bit compiler.
@
text
@d1620 1
a1620 1
  ssize_t res = 0;
@


1.291.2.20
log
@Pull in change from HEAD
@
text
@a76 15
      /* Check for abstract socket. These are generated for AF_LOCAL datagram
	 sockets in recv_internal, to allow a datagram server to use sendto
	 after recvfrom. */
      if (inlen >= (int) sizeof (in->sa_family) + 7
	  && in->sa_data[0] == '\0' && in->sa_data[1] == 'd'
	  && in->sa_data[6] == '\0')
	{
	  struct sockaddr_in addr;
	  addr.sin_family = AF_INET;
	  sscanf (in->sa_data + 2, "%04hx", &addr.sin_port);
	  addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	  *outlen = sizeof addr;
	  memcpy (out, &addr, *outlen);
	  return 0;
	}
d1476 2
a1477 4
      /* WSARecvFrom copied the sockaddr_in block to wsamsg->name.  We have to
	 overwrite it with a sockaddr_un block.  For datagram sockets we
	 generate a sockaddr_un with a filename analogue to abstract socket
	 names under Linux.  See `man 7 unix' under Linux for a description. */
d1482 2
a1483 14
	{
	  if (get_socket_type () == SOCK_DGRAM)
	    {
	      if (len >= 7)
		{
		  __small_sprintf (un->sun_path + 1, "d%04x",
			       ((struct sockaddr_in *) wsamsg->name)->sin_port);
		  wsamsg->namelen = offsetof (struct sockaddr_un, sun_path) + 7;
		}
	      else
		wsamsg->namelen = offsetof (struct sockaddr_un, sun_path) + 1;
	      un->sun_path[0] = '\0';
	    }
	  else if (!get_peer_sun_path ())
@


1.290
log
@Change "set_thread_waiting" to "set_signal_arrived" throughout.
@
text
@d1333 1
a1333 1
  len = recv_internal (&wsamsg);
d1349 1
a1349 1
  return recv_internal (&wsamsg);
d1378 1
a1378 1
fhandler_socket::recv_internal (LPWSAMSG wsamsg)
a1384 1
  bool use_recvmsg = false;
d1390 1
a1390 1
  if (wsamsg->Control.len > 0)
d1395 6
a1400 2
	  set_winsock_errno ();
	  return SOCKET_ERROR;
d1402 2
a1403 1
      use_recvmsg = true;
d1510 1
a1510 1
  ssize_t ret = recv_internal (&wsamsg);
d1525 3
a1527 2
  if (!wincap.has_recvmsg () || get_socket_type () == SOCK_STREAM
      || get_addr_family () == AF_LOCAL)
d1529 1
a1530 2
      if (!CYGWIN_VERSION_CHECK_FOR_USING_ANCIENT_MSGHDR)
	msg->msg_flags = 0;
d1545 1
a1545 1
  ssize_t ret = recv_internal (&wsamsg);
@


1.289
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d661 1
a661 1
      set_thread_waiting here (ev[1]);
@


1.288
log
@	In terms of network related functionality, rely on Winsock definitions
	as much as possible:
	* dtable.cc: Drop including sys/socket.h.
	* fhandler_procnet.cc: Change includes accordingly.
	* fhandler_socket.cc: Ditto.
	(fhandler_socket::listen): Avoid gcc error message initializing sin6.
	(LPFN_WSARECVMSG): Only define when building against w32api headers.
	* net.cc: Change includes accordingly.  Define USE_SYS_TYPES_FD_SET
	and __WSA_ERR_MACROS_DEFINED.  Define _INC_NETIOAPI temporarily and
	explain why.
	(struct _IP_ADAPTER_UNICAST_ADDRESS_LH): Only define when building
	against w32api headers.
	(struct _IP_ADAPTER_ADDRESSES_LH): Ditto.
	(SIO_GET_INTERFACE_LIST): Ditto.
	(ws_freeaddrinfo): Rename from freeaddrinfo so as not to collide with
	Winsock declaration.  Change througout.
	(ws_getaddrinfo): Ditto.
	(ws_getnameinfo): Ditto.
	* select.cc: Include netdb.h after defining USE_SYS_TYPES_FD_SET.
	* syslog.cc: Drop including netinet/in.h.  Define USE_SYS_TYPES_FD_SET
	and include ws2tcpip.h.
	* include/netdb.h (struct addrinfo): Don't define when building Cygwin.
	* include/cygwin/if.h: Don't declare if_xxx functions when building
	Cygwin.
	* include/cygwin/in.h: Disable most definitions when building Cygwin.
	* include/cygwin/socket.h: Disable sockaddr and sockaddr_storage
	definitions when building Cygwin.  Same for MCAST_INCLUDE/MCAST_EXCLUDE.
	* libc/inet_addr.c: Don't define __INSIDE_CYGWIN__ nor
	__INSIDE_CYGWIN_NET__.
	* libc/inet_network.c: Ditto.
	* libc/minires.h: Drop redundant inclusion of netdb.h.  Define
	__INSIDE_CYGWIN_NET__ only before including netdb.h and resolver
	headers.
@
text
@d128 1
a128 3
	  /* Using IsEventSignalled like this is racy since another thread could
	     be waiting for signal_arrived. */
	  if (IsEventSignalled (signal_arrived)
d660 2
a661 1
      WSAEVENT ev[2] = { wsock_evt, signal_arrived };
d1780 1
a1780 1
      if (WaitForSingleObject (signal_arrived, 10) == WAIT_OBJECT_0)
@


1.287
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@d15 1
a17 8
#include <sys/un.h>
#include <asm/byteorder.h>

#include <stdlib.h>
#define USE_SYS_TYPES_FD_SET
#include <winsock2.h>
#include <mswsock.h>
#include <iphlpapi.h>
a19 2
#include "cygwin/version.h"
#include "perprocess.h"
d24 6
d37 1
a37 1
#include "cygwin/in6.h"
d1129 3
a1131 8
	  struct sockaddr_in6 sin6 =
	    {
	      sin6_family: AF_INET6,
	      sin6_port: 0,
	      sin6_flowinfo: 0,
	      sin6_addr: {{IN6ADDR_ANY_INIT}},
	      sin6_scope_id: 0
	    };
d1354 1
d1359 1
@


1.286
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d133 1
a133 1
	  if (cancelable_wait (NULL, cw_nowait, cw_sig_eintr) == WAIT_SIGNALED
d665 1
a665 2
      WSAEVENT ev[2] = { wsock_evt };
      set_thread_waiting (ev[1]);
d1787 1
a1787 1
      if (cygwait (10) == WAIT_SIGNALED)
@


1.285
log
@	* Throughout, replace usage of w32api's min with MIN from sys/param.h.
@
text
@d133 1
a133 1
	  if (IsEventSignalled (signal_arrived)
d665 2
a666 1
      WSAEVENT ev[2] = { wsock_evt, signal_arrived };
d1788 1
a1788 1
      if (WaitForSingleObject (signal_arrived, 10) == WAIT_OBJECT_0)
@


1.284
log
@* exceptions.cc (exception::handle): Drop abbreviation for "exception" since I
never remember what it stands for.
(sig_handle_tty_stop): Remove obsolete call to sig_handle_tty_stop.
(_cygtls::call_signal_handler): Rework to grab signal information from
_main_tls if none is set for _my_tls.  Try harder to keep thread locked.
(reset_signal_arrived): Delete.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use new cygWFMO call
to wait for an event + standard cygwin stuff.  Modify debug output to
acccomodate new function.
* fhandler_console.cc (fhandler_console::read): Replace WaitForMultipleObjects
with cygWFMO.
* fhandler_socket.cc (get_inet_addr): Add comment.
* gendef (_sigdelayed): Remove call to reset_signal_arrived.
* sigproc.cc (_cygtls::signal_exit): Don't close my_readsig here unless we're
in the signal thread.
(create_signal_arrived): Create signal_arrived as auto-reset so that only one
thread is woken when a signal arrives.
* sigproc.h (cygWFMO): New function.
(reset_signal_arrived): Delete declaration.
@
text
@d4 1
a4 1
   2009, 2010, 2011 Red Hat, Inc.
d37 1
d1217 1
a1217 1
		  memcpy (peer, &un, min (*len, (int) sizeof (un.sun_family)));
d1222 1
a1222 1
		  memcpy (peer, &lpeer, min (*len, llen));
d1251 1
a1251 1
      memcpy (name, &sun, min (*namelen, (int) SUN_LEN (&sun) + 1));
d1265 1
a1265 1
	  memcpy (name, &sock, min (*namelen, len));
d1294 1
a1294 1
		  memcpy (name, &sock, min (*namelen, len));
d1325 1
a1325 1
      memcpy (name, &sun, min (*namelen, (int) SUN_LEN (&sun) + 1));
d1330 1
a1330 1
      memcpy (name, &sock, min (*namelen, len));
@


1.283
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d130 2
@


1.282
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d1023 1
a1023 1
	  debug_printf ("%d = setsockopt (SO_EXCLUSIVEADDRUSE), %E", ret);
d2001 1
a2001 1
  syscall_printf ("%d = ioctl_socket (%x, %x)", res, cmd, p);
@


1.281
log
@	* fhandler_socket.cc (fhandler_socket::send_internal): Fix setting
	nosignal flag.  Convert ECONNABORTED on connection-oriented socket
	to EPIPE, too.
@
text
@d753 1
a753 1
fhandler_socket::dup (fhandler_base *child)
d780 1
a780 1
      int ret = fhandler_base::dup (child);
@


1.280
log
@	* syscalls.cc (faccessat): Fix parens in flag expression when calling
	build_fh_name.

	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Fix typo in
	comment.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
@
text
@d1588 1
a1588 1
  bool nosignal = !(flags & MSG_NOSIGNAL);
d1651 2
a1652 1
      if (get_errno () == ESHUTDOWN && get_socket_type () == SOCK_STREAM)
@


1.279
log
@	* fhandler.h (class fhandler_dev_mem): Remove dup method declaration.
	* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Accommodate the
	fact that the entire fhandler gets copied over to the child in
	operator =.
	* fhandler_floppy.cc (fhandler_dev_floppy::dup): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::dup): Ditto.
	* fhandler_serial.cc (fhandler_serial::dup): Ditto.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::dup): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::dup): Ditto.  Remove entirely.
@
text
@d959 1
a959 1
	 I don't know what setting that is or howq to recognize such a share,
@


1.278
log
@	Throughout change "WinSock" to "Winsock" in comments.
	* fhandler_socket.cc (fhandler_socket::sendmsg): Add missing call to
	get_inet_addr to convert AF_LOCAL to AF_INET sockets.
	* net.cc (cygwin_socket): Workaround UDP Winsock problem.  Add comment
	to explain why.
	* select.cc: Include winsock2.h rather than winsock.h.
@
text
@a772 6
  fhs->wsock_events = wsock_events;

  fhs->rmem (rmem ());
  fhs->wmem (wmem ());
  fhs->addr_family = addr_family;
  fhs->set_socket_type (get_socket_type ());
a776 9
      if (get_socket_type () == SOCK_STREAM)
	{
	  fhs->sec_pid = sec_pid;
	  fhs->sec_uid = sec_uid;
	  fhs->sec_gid = sec_gid;
	  fhs->sec_peer_pid = sec_peer_pid;
	  fhs->sec_peer_uid = sec_peer_uid;
	  fhs->sec_peer_gid = sec_peer_gid;
	}
a777 2
  fhs->connect_state (connect_state ());

d792 3
a794 1
  if (!fhs->fixup_before_fork_exec (GetCurrentProcessId ()))
a795 1
      cygheap->user.reimpersonate ();
a799 1
  cygheap->user.reimpersonate ();
@


1.277
log
@	* fhandler.cc (fhandler_base::open): Don't open file with WRITE_DAC
	access on remote filesystem.  Explain why.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto for
	directories.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for sockets.
	* path.cc (symlink_worker): Ditto for symlinks.
@
text
@d1132 1
a1132 1
	 port number, listening on all interfaces.  On Winsock, listen
d1286 1
a1286 1
	      /* Winsock returns WSAEINVAL if the socket is locally
d1457 1
a1457 1
	 This also covers another weird case: Winsock returns WSAEFAULT if
d1701 5
d1708 4
a1711 1
  /* TODO: Descriptor passing on AF_LOCAL sockets. */
d1721 1
a1721 1
  WSAMSG wsamsg = { (struct sockaddr *) msg->msg_name, msg->msg_namelen,
d1741 1
a1741 1
     called with the SHUT_RD or SHUT_RDWR parameter.  In contrast, Winsock
@


1.276
log
@whitespace elimination
@
text
@d973 6
a978 2
	 open the file again. */
      if (pc.has_acls ())
@


1.275
log
@	* fhandler_socket.cc (get_inet_addr): Rearrange for better readability.
	Make waiting loop interruptible and cancelable.  Check for SYSTEM DOS
	flag before reading the file.  Change return value to return 0 on
	success, SOCKET_ERROR on failure.
	(fhandler_socket::bind): Only set R/O DOS flag on filesystems not
	supporting ACLs.
	(fhandler_socket::connect): Accommodate changed return values from
	get_inet_addr.  Use SOCKET_ERROR instead of -1.
	(fhandler_socket::sendto): Accommodate changed return values from
	get_inet_addr.
	* syslog.cc (connect_syslogd): Ditto.
@
text
@d511 1
a511 1
      					wsa_events[slot].serial_number));
d726 1
a726 1
    
d738 1
a738 1
         socket is potentially inheritable again. */
d1222 1
a1222 1
	      	{
d1260 1
a1260 1
      	strncat (sun.sun_path, get_sun_path (), UNIX_PATH_LEN - 1);
d1334 1
a1334 1
      	strncat (sun.sun_path, get_peer_sun_path (), UNIX_PATH_LEN - 1);
d1440 1
a1440 1
         Assume you create a socket, fork the process (thus duplicating
d1452 1
a1452 1
	 
d1613 1
a1613 1
      	{
d1814 1
a1814 1
#define __OLD_IFNAMSIZ        16
@


1.274
log
@	* fhandler.h (fhandler_socket::read): Declare.
	(fhandler_socket::write): Declare.
	* fhandler_procsys.cc (fhandler_procsys::read): Add FIXME comment.
	(fhandler_procsys::write): Ditto.
	* fhandler_socket.cc (fhandler_socket::read): New method.
	(fhandler_socket::write): New method.
	* syscalls.cc: Rearrange order of read/write functions.
	(read): Call fhandler read method directly instead of just readv.
	(readv): Remove EINTR loop.  This is done in all affected fhandler's
	now.
	(write): Call fhandler write method directly instead of just writev.
	Fix debug output.
@
text
@d74 1
a74 1
  if (in->sa_family == AF_INET || in->sa_family == AF_INET6)
d76 4
d82 4
a85 1
      return 1;
d87 30
a116 1
  else if (in->sa_family == AF_LOCAL)
d118 14
a131 37
      NTSTATUS status;
      HANDLE fh;
      OBJECT_ATTRIBUTES attr;
      IO_STATUS_BLOCK io;

      path_conv pc (in->sa_data, PC_SYM_FOLLOW);
      if (pc.error)
	{
	  set_errno (pc.error);
	  return 0;
	}
      if (!pc.exists ())
	{
	  set_errno (ENOENT);
	  return 0;
	}
      /* Do NOT test for the file being a socket file here.  The socket file
	 creation is not an atomic operation, so there is a chance that socket
	 files which are just in the process of being created are recognized
	 as non-socket files.  To work around this problem we now create the
	 file with all sharing disabled.  If the below NtOpenFile fails
	 with STATUS_SHARING_VIOLATION we know that the file already exists,
	 but the creating process isn't finished yet.  So we yield and try
	 again, until we can either open the file successfully, or some error
	 other than STATUS_SHARING_VIOLATION occurs.
	 Since we now don't know if the file is actually a socket file, we
	 perform this check here explicitely. */
      pc.get_object_attr (attr, sec_none_nih);
      do
	{
	  status = NtOpenFile (&fh, GENERIC_READ | SYNCHRONIZE, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_SYNCHRONOUS_IO_NONALERT
			       | FILE_OPEN_FOR_BACKUP_INTENT);
	  if (status == STATUS_SHARING_VIOLATION)
	    yield ();
	  else if (!NT_SUCCESS (status))
d133 2
a134 2
	      __seterrno_from_nt_status (status);
	      return 0;
d136 1
d138 1
a138 7
      while (status == STATUS_SHARING_VIOLATION);
      int ret = 0;
      char buf[128];
      memset (buf, 0, sizeof buf);
      status = NtReadFile (fh, NULL, NULL, NULL, &io, buf, 128, NULL, NULL);
      NtClose (fh);
      if (NT_SUCCESS (status))
d140 2
a141 21
	  struct sockaddr_in sin;
	  char ctype;
	  sin.sin_family = AF_INET;
	  if (strncmp (buf, SOCKET_COOKIE, strlen (SOCKET_COOKIE)))
	    {
	      set_errno (EBADF);
	      return 0;
	    }
	  sscanf (buf + strlen (SOCKET_COOKIE), "%hu %c %08x-%08x-%08x-%08x",
		  &sin.sin_port,
		  &ctype,
		  secret_ptr, secret_ptr + 1, secret_ptr + 2, secret_ptr + 3);
	  sin.sin_port = htons (sin.sin_port);
	  sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	  memcpy (out, &sin, sizeof sin);
	  *outlen = sizeof sin;
	  if (type)
	    *type = (ctype == 's' ? SOCK_STREAM :
		     ctype == 'd' ? SOCK_DGRAM
				  : 0);
	  ret = 1;
a142 3
      else
	__seterrno_from_nt_status (status);
      return ret;
d144 22
a165 1
  else
d167 20
a186 1
      set_errno (EAFNOSUPPORT);
d189 2
d961 1
a961 1
      if (!(mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
a1050 1
  int res = -1;
d1058 3
a1060 2
  if (!get_inet_addr (name, namelen, &sst, &namelen, &type, connect_secret))
    return -1;
d1066 1
a1066 1
      return -1;
d1069 1
a1069 1
  res = ::connect (get_socket (), (struct sockaddr *) &sst, namelen);
d1106 1
a1106 1
	  return -1;
d1683 1
a1683 1
  if (to && !get_inet_addr (to, tolen, &sst, &tolen))
@


1.273
log
@	* fcntl.cc (fcntl64): Call pthread_testcancel.
	* fhandler_socket.cc (fhandler_socket::connect): Ditto.
	(fhandler_socket::accept4): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* flock.cc (lf_setlock): Allow to cancel thread running blocking
	file lock.  Try to make code more readable.
	(lockf): Call pthread_testcancel.
	* mmap.cc (msync): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Call pthread::static_cancel_self
	rather than pthread_testcancel.
	* select.cc (cygwin_select): Call pthread_testcancel.
	* syscalls.cc (pread): Ditto.
	(pwrite): Ditto.
	(readv): Ditto.
	(writev): Ditto.
	(open): Ditto.
	(close): Ditto.
	(fsync): Ditto.
	* termios.cc (tcdrain): Ditto.
	* thread.cc: Align list of cancellation points with above changes.
	Mark not-implemented functions, too.
	(cancelable_wait): Don't set unused object indices to WAIT_FAILED
	since that could result in wrong behaviour.  Set them to the invalid
	value WAIT_TIMEOUT + 1 instead.
@
text
@d1319 8
d1542 8
@


1.272
log
@	* fhandler_socket.cc (fhandler_socket::evaluate_events): Handle the
	FD_CLOSE event specially when called from accept.  Explain why.
	(fhandler_socket::shutdown): Fake success on not-connected socket and
	trigger socket event if the read side of a socket is affected.  Explain
	why.
	* poll.cc (poll): Check for saw_shutdown_read on sockets to generate
	POLLHUP as well.
@
text
@d1029 2
d1145 2
d1480 2
d1496 2
d1637 2
d1653 2
@


1.271
log
@	* autoload.cc (GetExtendedTcpTable): Remove.
	(GetTcpTable): Remove.
	(CharNextExA): Remove.
	(FindWindowA): Remove.
	(ShowWindowAsync): Remove.
	* dcrt0.cc (disable_dep): Remove unused function.
	(dll_crt0_0): Drop comment babbling about TS & DEP.
	* fhandler_socket.cc (address_in_use): Remove unused function.
	* wincap.cc: Throughout, drop ts_has_dep_problem from wincaps.
	(wincapc::init): Drop code setting ts_has_dep_problem flag.
	* wincap.h (struct wincaps): Drop ts_has_dep_problem flags and method.
@
text
@d599 9
d1671 9
a1679 1
  if (res)
d1682 20
a1701 13
    switch (how)
      {
      case SHUT_RD:
	saw_shutdown_read (true);
	break;
      case SHUT_WR:
	saw_shutdown_write (true);
	break;
      case SHUT_RDWR:
	saw_shutdown_read (true);
	saw_shutdown_write (true);
	break;
      }
@


1.270
log
@	* fhandler_socket.cc (get_inet_addr): Make externally available.
	* autoload.cc (GetUdpTable): Define.
	* syslog.cc (connect_syslogd): Use get_inet_addr rather than _stat64
	to check for local socket file.  Create socket with type returned by
	get_inet_addr.  If connect on UDP socket works, test if there's
	really a listening peer, otherwise fall back to Windows event log.
	(try_connect_syslogd): Use syslogd_inited flag to check if syslogd
	is available.
@
text
@a874 68
#if 0
/* This function doesn't work correctly.  It has been called in bind to check
   if a local address is still in use, but it disables to bind in the
   SO_REUSEADDR case even if only an accepted socket is still using the
   local address, and even if said accepted socket is already in CLOSE_WAIT.
   I keep this function in the code for later reference only. */
static inline bool
address_in_use (const struct sockaddr *addr)
{
  switch (addr->sa_family)
    {
    case AF_INET:
      {
	PMIB_TCPTABLE tab;
	PMIB_TCPROW entry;
	DWORD size = 0, i;
	struct sockaddr_in *in = (struct sockaddr_in *) addr;

	if (GetTcpTable (NULL, &size, FALSE) == ERROR_INSUFFICIENT_BUFFER)
	  {
	    tab = (PMIB_TCPTABLE) alloca (size += 16 * sizeof (PMIB_TCPROW));
	    if (!GetTcpTable (tab, &size, FALSE))
	      for (i = tab->dwNumEntries, entry = tab->table; i > 0;
		   --i, ++entry)
		if (entry->dwLocalAddr == in->sin_addr.s_addr
		    && entry->dwLocalPort == in->sin_port
		    && entry->dwState >= MIB_TCP_STATE_LISTEN
		    && entry->dwState <= MIB_TCP_STATE_LAST_ACK)
		  return true;
	  }
      }
      break;
    case AF_INET6:
      {
	/* This test works on XP SP2 and above which should cover almost
	   all IPv6 users... */
	PMIB_TCP6TABLE_OWNER_PID tab;
	PMIB_TCP6ROW_OWNER_PID entry;
	DWORD size = 0, i;
	struct sockaddr_in6 *in6 = (struct sockaddr_in6 *) addr;

	if (GetExtendedTcpTable (NULL, &size, FALSE, AF_INET6,
				 TCP_TABLE_OWNER_PID_ALL, 0)
	    == ERROR_INSUFFICIENT_BUFFER)
	  {
	    tab = (PMIB_TCP6TABLE_OWNER_PID)
		  alloca (size += 16 * sizeof (PMIB_TCP6ROW_OWNER_PID));
	    if (!GetExtendedTcpTable (tab, &size, FALSE, AF_INET6,
				      TCP_TABLE_OWNER_PID_ALL, 0))
	      for (i = tab->dwNumEntries, entry = tab->table; i > 0;
		   --i, ++entry)
		if (IN6_ARE_ADDR_EQUAL (entry->ucLocalAddr,
					in6->sin6_addr.s6_addr)
		    /* FIXME: Is testing for the scope required. too?!? */
		    && entry->dwLocalPort == in6->sin6_port
		    && entry->dwState >= MIB_TCP_STATE_LISTEN
		    && entry->dwState <= MIB_TCP_STATE_LAST_ACK)
		  return true;
	  }
      }
      break;
    default:
      break;
    }
  return false;
}
#endif

@


1.269
log
@	* fhandler.cc (fhandler_base::open): When creating a file on a
	filesystem supporting ACLs, create the file with WRITE_DAC access.
	Explain why.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto for
	directories.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for sockets.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Always call GetSecurityInfo for directories
	on XP and Server 2003.  Improve comment to explain why.
	(set_file_attribute): Explicitely cast mode_t value to bool in call to
	get_file_sd.
	* wincap.h (wincaps::use_get_sec_info_on_dirs): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d66 1
a66 1
static int
@


1.269.2.1
log
@	* fhandler_socket.cc (get_inet_addr): Make externally available.
	* autoload.cc (GetUdpTable): Define.
	* syslog.cc (connect_syslogd): Use get_inet_addr rather than _stat64
	to check for local socket file.  Create socket with type returned by
	get_inet_addr.  If connect on UDP socket works, test if there's
	really a listening peer, otherwise fall back to Windows event log.
	(try_connect_syslogd): Use syslogd_inited flag to check if syslogd
	is available.
@
text
@d66 1
a66 1
int
@


1.268
log
@	* fhandler_socket (fhandler_socket::readv): Call recv_internal directly,
	rather than recvmsg.
	(fhandler_socket::writev): Call send_internal directly, rather than
	sendmsg.
	* net.cc (cygwin_recv): Call fhandler_socket::recvfrom directly, rather
	than cygwin_recvfrom.
	(cygwin_send): Call fhandler_socket::sendto directly, rather than
	cygwin_sendto.
@
text
@d999 1
d1001 9
a1009 3
      status = NtCreateFile (&fh, DELETE | FILE_GENERIC_WRITE,
			     pc.get_object_attr (attr, sa), &io, NULL, fattr,
			     0, FILE_CREATE,
@


1.267
log
@	* Throughout fix copyright dates.
@
text
@d1371 4
a1374 1
  struct msghdr msg =
d1376 5
a1380 10
      msg_name:		NULL,
      msg_namelen:	0,
      msg_iov:		(struct iovec *) iov, // const_cast
      msg_iovlen:	iovcnt,
      msg_control:	NULL,
      msg_controllen:	0,
      msg_flags:	0
    };

  return recvmsg (&msg, 0);
d1581 4
a1584 1
  struct msghdr msg =
d1586 5
a1590 10
      msg_name:		NULL,
      msg_namelen:	0,
      msg_iov:		(struct iovec *) iov, // const_cast
      msg_iovlen:	iovcnt,
      msg_control:	NULL,
      msg_controllen:	0,
      msg_flags:	0
    };

  return sendmsg (&msg, 0);
@


1.266
log
@	* fhandler_socket.cc (address_in_use): Improve comment readability.
@
text
@d4 1
a4 1
   2009, 2010 Red Hat, Inc.
@


1.265
log
@	* fhandler_socket.cc (address_in_use): Disable.  Add comment.
	(fhandler_socket::bind): Change comment to explain setting the
	SO_EXCLUSIVEADDRUSE socket option.  Remove code which checks for
	address in use.
	* net.cc (cygwin_setsockopt): Never set SO_REUSEADDR option.  Improve
	comment to compensate for the deleted comment in fhandler_socket::bind.
	* wincap.cc: Throughout, drop has_enhanced_socket_security from wincaps.
	* wincap.h (struct wincaps): Drop has_enhanced_socket_security flags
	and method.
@
text
@d876 4
a879 3
/* This doesn't work correctly.  It has been called in bind to check if a
   loca address is still in use, but it disables bind in the SO_REUSEADDR
   case even if only an accepted socket is still using the local address.
@


1.264
log
@	* fhandler_socket.cc (fhandler_socket::wait_for_events): Call
	pthread_testcancel in case of timeout to enable pthread_cancel
	on waiting thread.
@
text
@d875 5
d940 1
d1048 4
a1051 4
	  /* If the application didn't explicitely call setsockopt
	     (SO_REUSEADDR), enforce exclusive local address use using the
	     SO_EXCLUSIVEADDRUSE socket option, to emulate POSIX socket
	     behaviour more closely.
a1060 28
      else if (!wincap.has_enhanced_socket_security ())
	{
	  debug_printf ("SO_REUSEADDR set");
	  /* There's a bug in SO_REUSEADDR handling in WinSock.
	     Per standards, we must not be able to reuse a complete
	     duplicate of a local TCP address (same IP, same port),
	     even if SO_REUSEADDR has been set.  That's unfortunately
	     possible in WinSock.

	     So we're testing here if the local address is already in
	     use and don't bind, if so.  This only works for OSes with
	     IP Helper support and is, of course, still prone to races.

	     However, we don't have to do this on systems supporting
	     "enhanced socket security" (2K3 and later).  On these
	     systems the default binding behaviour is exactly as you'd
	     expect for SO_REUSEADDR, while setting SO_REUSEADDR re-enables
	     the wrong behaviour.  So all we have to do on these newer
	     systems is never to set SO_REUSEADDR but only to note that
	     it has been set for the above SO_EXCLUSIVEADDRUSE setting.
	     See setsockopt() in net.cc. */
	  if (get_socket_type () == SOCK_STREAM && address_in_use (name))
	    {
	      debug_printf ("Local address in use, don't bind");
	      set_errno (EADDRINUSE);
	      goto out;
	    }
	}
@


1.263
log
@	* fhandler_socket.cc (fhandler_socket::bind): Drop has_exclusiveaddruse
	condition.  Fix comment about availability.  Move remaining comment to
	the right spot.  Drop has_ip_helper_lib condition.
	* net.cc (cygwin_setsockopt): Drop has_disabled_user_tos_setting
	condition.  Fix comment.
	(get_2k_ifs): Fix comment.
	(get_nt_ifs): Remove.
	(getifaddrs): Drop call to get_nt_ifs.
	(get_ifconf): Ditto.
	* wincap.cc: Throughout, drop has_ip_helper_lib,
	has_disabled_user_tos_setting, and has_exclusiveaddruse settings from
	wincaps.
	(wincap_unknown): Remove.
	(wincap_nt4): Remove.
	(wincap_minimal): New macro, set to wincap_nt4sp4 for now.
	(wincapc::init): Drop test for pre-SP4 NT4.  Just imply at least NT SP4.
	Replace references to wincap_unknown with references to wincap_minimal.
	* wincap.h (struct wincaps): Drop has_ip_helper_lib,
	has_disabled_user_tos_setting, and has_exclusiveaddruse flags and
	methods.
@
text
@d629 2
@


1.262
log
@	* fhandler_socket.cc (get_inet_addr): Only test the file for being a
	socket after opening it.  Retry if opening failed with sharing
	violation.  Explain why we do this.
	(fhandler_socket::bind): Create file with no sharing allowed.
@
text
@d1038 1
a1038 8
      /* If the application didn't explicitely call setsockopt (SO_REUSEADDR),
	 enforce exclusive local address use using the SO_EXCLUSIVEADDRUSE
	 socket option, to emulate POSIX socket behaviour more closely.

	 KB 870562: Note that this option is only available since NT4 SP4.
	 Also note that a bug in Win2K SP1-3 and XP up to SP1 only enables
	 this option for users in the local administrators group. */
      if (wincap.has_exclusiveaddruse ())
d1040 35
a1074 1
	  if (!saw_reuseaddr ())
d1076 3
a1078 35
	      int on = 1;
	      int ret = ::setsockopt (get_socket (), SOL_SOCKET,
				      ~(SO_REUSEADDR),
				      (const char *) &on, sizeof on);
	      debug_printf ("%d = setsockopt (SO_EXCLUSIVEADDRUSE), %E", ret);
	    }
	  else if (!wincap.has_enhanced_socket_security ())
	    {
	      debug_printf ("SO_REUSEADDR set");
	      /* There's a bug in SO_REUSEADDR handling in WinSock.
		 Per standards, we must not be able to reuse a complete
		 duplicate of a local TCP address (same IP, same port),
		 even if SO_REUSEADDR has been set.  That's unfortunately
		 possible in WinSock.

		 So we're testing here if the local address is already in
		 use and don't bind, if so.  This only works for OSes with
		 IP Helper support and is, of course, still prone to races.

		 However, we don't have to do this on systems supporting
		 "enhanced socket security" (2K3 and later).  On these
		 systems the default binding behaviour is exactly as you'd
		 expect for SO_REUSEADDR, while setting SO_REUSEADDR re-enables
		 the wrong behaviour.  So all we have to do on these newer
		 systems is never to set SO_REUSEADDR but only to note that
		 it has been set for the above SO_EXCLUSIVEADDRUSE setting.
		 See setsockopt() in net.cc. */
	      if (get_socket_type () == SOCK_STREAM
		  && wincap.has_ip_helper_lib ()
		  && address_in_use (name))
		{
		  debug_printf ("Local address in use, don't bind");
		  set_errno (EADDRINUSE);
		  goto out;
		}
@


1.261
log
@	* fhandler_socket.cc (fhandler_socket::wait_for_events): Remove call to
	sig_dispatch_pending.
@
text
@d41 1
d98 13
a110 1
      if (!pc.issocket ())
d112 11
a122 12
	  set_errno (EBADF);
	  return 0;
	}
      status = NtOpenFile (&fh, GENERIC_READ | SYNCHRONIZE,
			   pc.get_object_attr (attr, sec_none_nih), &io,
			   FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  return 0;
d124 1
d135 5
d993 1
a993 1
			     FILE_SHARE_VALID_FLAGS, FILE_CREATE,
@


1.260
log
@	* fhandler_socket.cc (fhandler_socket::evaluate_events): Make erase
	const in parameter list.
	(fhandler_socket::wait_for_events): Take a DWORD flags value instead of
	just a bool.  Call evaluate_events with erase flag according to
	MSG_PEEK value in flags.  Replace check for dontwait with check for
	MSG_DONTWAIT in flags.
	(fhandler_socket::connect): Call wait_for_events with 0 flags value.
	(fhandler_socket::accept4): Ditto.
	(fhandler_socket::recv_internal): Save flags in wait_flags.  Drop
	dontwait variable.  Call wait_for_events with wait_flags.
	(fhandler_socket::send_internal): Save MSG_DONTWAIT flag in wait_flags
	and call wait_for_events with wait_flags as argument.  Drop dontwait
	variable.
	* fhandler.h (class fhandler_socket): Change second parameter in
	declaration of wait_for_events to const DWORD.
@
text
@d616 1
a616 4
	      {
		sig_dispatch_pending ();
		break;
	      }
@


1.259
log
@	* fhandler_socket.cc (fhandler_socket::accept4): Reset async flag
	on accepted socket.
@
text
@d543 1
a543 1
				  bool erase)
d590 1
a590 1
fhandler_socket::wait_for_events (const long event_mask, bool dontwait)
d598 2
a599 1
  while (!(ret = evaluate_events (event_mask, events, true)) && !events)
d601 1
a601 1
      if (is_nonblocking () || dontwait)
d1104 1
a1104 1
    res = wait_for_events (FD_CONNECT | FD_CLOSE, false);
d1205 1
a1205 1
  while (!(res = wait_for_events (FD_ACCEPT | FD_CLOSE, false))
d1428 2
a1429 2
  bool waitall = !!(wsamsg->dwFlags & MSG_WAITALL);
  bool dontwait = !!(wsamsg->dwFlags & MSG_DONTWAIT);
d1456 1
a1456 1
  while (!(res = wait_for_events (evt_mask | FD_CLOSE, dontwait))
d1613 1
a1613 1
  bool dontwait = !!(flags & MSG_DONTWAIT);
d1653 1
a1653 1
	     && !(res = wait_for_events (FD_WRITE | FD_CLOSE, dontwait)));
@


1.258
log
@	* fhandler_socket.cc (fhandler_socket::accept4): Set nonblocking
	flag exactly according to flags, as on Linux.
	* net.cc (cygwin_accept): Maintain BSD semantics here.
@
text
@d1219 1
a1219 1
	  sock->async_io (async_io ());
@


1.257
log
@	* cygwin.din (accept4): Export.
	* fhandler.h (fhandler_socket::accept4): Rename from accept.  Take
	additional flag parameter.
	* fhandler_socket.cc (fhandler_socket::accept4): Ditto.  Handle
	SOCK_NONBLOCK and SOCK_CLOEXEC flags.
	* net.cc (cygwin_socket): Handle SOCK_NONBLOCK and SOCK_CLOEXEC flags
	in type.  Check for invalid flag values.
	(socketpair): Ditto.
	(cygwin_accept): Accommodate renaming of fhandler_socket::accept
	function to accept4.
	(accept4): New function.
	* posix.sgml: Mention accept4 as GNU extensions.
	* include/cygwin/socket.h (SOCK_NONBLOCK): Define.
	(SOCK_CLOEXEC): Define.
	(_SOCK_FLAG_MASK): Define when building Cygwin.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/socket.h (accept4): Declare.
@
text
@d1239 1
a1239 2
	  sock->set_nonblocking (flags & SOCK_NONBLOCK
				 ? true : is_nonblocking ());
@


1.256
log
@	* fhandler.h (fhandler_socket::wait_for_events): Drop parameter default
	value.
	* fhandler_socket.cc (fhandler_socket::connect): Add false as second
	parameter to wait_for_events call.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::send_internal): Fix typo in call to wait_for_events.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Red Hat, Inc.
d1197 1
a1197 1
fhandler_socket::accept (struct sockaddr *peer, int *len)
a1219 1
	  sock->set_nonblocking (is_nonblocking ());
d1239 4
@


1.255
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d1102 1
a1102 1
    res = wait_for_events (FD_CONNECT | FD_CLOSE);
d1203 1
a1203 1
  while (!(res = wait_for_events (FD_ACCEPT | FD_CLOSE))
d1649 1
a1649 1
	     && !(res = wait_for_events (FD_WRITE | FD_CLOSE), dontwait));
@


1.254
log
@	* fhandler_socket.cc (send_internal): Don't split datagram messages
	into pieces.

	* syslog.cc (vsyslog): Set default facility to LOG_USER if it hasn't
	been set yet.
@
text
@d702 3
a704 2
  if (!DuplicateHandle (hMainProc, wsock_mtx, hMainProc, &fhs->wsock_mtx, 0,
			TRUE, DUPLICATE_SAME_ACCESS))
d709 3
a711 2
  if (!DuplicateHandle (hMainProc, wsock_evt, hMainProc, &fhs->wsock_evt, 0,
			TRUE, DUPLICATE_SAME_ACCESS))
d756 1
a756 1
      fhs->fixup_after_fork (hMainProc);
@


1.253
log
@	* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Add
	socket handle value to debug output.
	(fhandler_socket::fixup_after_fork): Ditto.  Make new socket handle
	OVERLAPPED, just as if it has been created with socket().
	* net.cc (fdsock): Close duplicated socket and explain why.  Disable
	the entire WSADuplicateSocket test for now and explain why.
@
text
@d1616 4
a1619 2
      /* FIXME?  Use the same technique in call to WSASendMsg? */
      if (!use_sendmsg)
d1632 3
d1636 2
a1637 1
	    res = WSASendTo (get_socket (), &buf, 1, &ret, flags,
d1653 1
a1653 1
	  if (use_sendmsg)
@


1.252
log
@	* fhandler_socket.cc (fhandler_socket::set_close_on_exec): Only call
	fhandler_base::set_close_on_exec for inheritable sockets.
@
text
@d655 1
a655 1
    debug_printf ("WSADuplicateSocket succeeded");
d672 2
a673 1
				FROM_PROTOCOL_INFO, prot_info_ptr, 0, 0);
d685 1
a685 1
      debug_printf ("WSASocket succeeded");
@


1.251
log
@	Reintegrate socket duplication via WSADuplicateSocket/WSASocket.
	* autoload.cc (WSADuplicateSocketW): Define.
	(WSASocketW): Define.
	* dtable.cc (dtable::release): Call dec_need_fixup_before if necessary.
	(dtable::fixup_before_fork): New function.
	(dtable::fixup_before_exec): New function.
	* dtable.h (class dtable): Add member cnt_need_fixup_before.  Add
	declarations for above new functions.
	(dtable::dec_need_fixup_before): New inline method.
	(dtable::inc_need_fixup_before): New inline method.
	(dtable::need_fixup_before): New inline method.
	* fhandler.h (fhandler_base::fixup_before_fork_exec): New virtual
	method.
	(fhandler_base::need_fixup_before): New virtual method.
	(class fhandler_socket): Add member prot_info_ptr.
	(fhandler_socket::init_fixup_before): Declare.
	(fhandler_socket::need_fixup_before): New inline method.
	(fhandler_socket::fixup_before_fork_exec): Declare.
	(fhandler_socket::fixup_after_exec): Declare.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	prot_info_ptr to NULL.
	(fhandler_socket::~fhandler_socket): Free prot_info_ptr conditionally.
	(fhandler_socket::init_fixup_before): New method.
	(fhandler_socket::fixup_before_fork_exec): Ditto.
	(fhandler_socket::fixup_after_fork): Use WSASocketW to duplicate
	socket if necessary.
	(fhandler_socket::fixup_after_exec): New method.
	(fhandler_socket::dup): Use fixup_before_fork_exec/fixup_after_fork
	to duplicate socket if necessary.
	* fork.cc (frok::parent): Start child suspended if some fhandler
	needs fixup before fork.  If so, call dtable::fixup_before_fork after
	CreateProcess and resume child.
	* net.cc (fdsock): Try to find out if socket needs fixup before and
	initialize socket accordingly.  Add HUGE comment to explain what happens
	and why.
	* spawn.cc (spawn_guts): Start child suspended if some fhandler needs
	fixup before exec.  If so, call dtable::fixup_before_exec after
	CreateProcess.
@
text
@d2037 7
a2043 2
  fhandler_base::set_close_on_exec (val);
  debug_printf ("set close_on_exec for %s to %d", get_name (), val);
@


1.250
log
@	* sec_helper.cc (security_descriptor::free): If sd_size is 0, call
	LocalFree instead of ::free.

	* sec_acl.cc: Throughout replace old ACE flag definitions with current
	definitions as used in MSDN man pages.
	* security.cc: Ditto.

	* fhandler.cc (fhandler_base::open): Make sure file has really been
	just created before fixing file permissions.  Add S_JUSTCREATED
	attribute to set_file_attribute call.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Always create dir
	with default security descriptor and fix descriptor afterwards.
	Add S_JUSTCREATED flag to set_file_attribute call.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Call GetSecurityInfo rather than
	NtQuerySecurityObject.  Explain why.  Change error handling accordingly.
	(alloc_sd): Skip non-inherited, non-standard entries in ACL if
	S_JUSTCREATED attribute is set.  Explain why.  Minor format fixes.
	* security.h (S_JUSTCREATED): New define.
	(security_descriptor::operator=): New operator.
@
text
@d154 1
d164 2
d637 22
d664 29
a692 1
  fhandler_base::fixup_after_fork (parent);
d735 2
a736 2
  int ret = fhandler_base::dup (child);
  if (ret)
d738 7
a744 2
      NtClose (fhs->wsock_evt);
      NtClose (fhs->wsock_mtx);
d746 16
a761 1
  return ret;
@


1.249
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Only append .lnk
	if the original device had one, too.  Add comment.

	* fhandler_socket.cc (fhandler_socket::fstat): Always return a size of
	0 on sockets.
@
text
@a892 5
      security_descriptor sd;
      /* See comments in fhander_base::open () for an explanation why we defer
	 setting security attributes on remote files. */
      if (pc.has_acls () && !pc.isremote ())
	set_security_attribute (pc, mode, &sa, sd);
d897 1
d914 3
a916 2
	  if (pc.has_acls () && pc.isremote ())
	    set_file_attribute (fh, pc, ILLEGAL_UID, ILLEGAL_GID, mode);
@


1.248
log
@	* fhandler_socket.cc (fhandler_socket::recv_internal): Always call
	WSARecv on SOCK_STREAM sockets.
@
text
@d701 1
d712 1
@


1.247
log
@	* autoload.cc (WSARecv): Define.
	* fhandler_socket.cc (fhandler_socket::recv_internal): Call WSARecv
	instead of WSARecvFrom if no name parameter is given.  Explain why.
@
text
@d1400 1
a1400 1
      else if (!wsamsg->name)
@


1.246
log
@	* (fhandler_socket::getsockname): Fix length returned for unbound
	AF_LOCAL sockets.
	(fhandler_socket::getpeername): Ditto.
	* net.cc (socketpair): Don't set sun_path and peer_sun_path to
	make sure getsockname and getpeername return the correct values
	for AF_LOCAL sockets.
@
text
@d1382 21
d1405 1
a1405 6
			   &wsamsg->dwFlags, wsamsg->name,
			   /* Winsock returns WSAEFAULT if namelen is a valid
			      pointer while name is NULL.  Both parameters are
			      ignored for TCP sockets, so this only occurs when
			      using UDP socket. */
			   wsamsg->name ? &wsamsg->namelen : NULL,
@


1.245
log
@	* fhandler_socket.cc (fhandler_socket::accept): Use sizeof rather
	then constant size.  Truncate returned data, but return full address
	length as per POSIX.
	(fhandler_socket::getsockname): Truncate returned data, but return full
	address length as per POSIX.
	(fhandler_socket::getpeername): Ditto.
@
text
@d1212 1
a1212 1
      *namelen = (int) SUN_LEN (&sun) + 1;
d1286 1
a1286 1
      *namelen = (int) SUN_LEN (&sun) + 1;
@


1.244
log
@	* fhandler.h (class fhandler_socket): Add peer_sun_path member.
	(fhandler_socket::set_peer_sun_path): New method.
	(fhandler_socket::get_peer_sun_path): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	peer_sun_path to NULL.
	(fhandler_socket::~fhandler_socket): Free peer_sun_path if necessary.
	(fhandler_socket::dup): Duplicate peer_sun_path.
	(fhandler_socket::accept): Ditto.  Return fake unbound peer content
	and len in case of AF_LOCAL sockets.
	(fhandler_socket::getsockname): Always use local sockaddr_storage to
	store socket address and copy over to incoming address.  Handle every
	namelen correctly per POSIX.
	(fhandler_socket::getpeername): Ditto.  Add code path to return
	correct value for AF_LOCAL sockets.
	(fhandler_socket::set_peer_sun_path): New method.
	* net.cc (socketpair): Set peer_sun_path to empty string, just like
	sun_path.
@
text
@d1177 2
a1178 2
		  *len = min (*len, 2);
		  memcpy (peer, &un, *len);
d1182 2
a1183 2
		  *len = min (*len, llen);
		  memcpy (peer, &lpeer, *len);
d1211 2
a1212 2
      *namelen = min (*namelen, (int) SUN_LEN (&sun) + 1);
      memcpy (name, &sun, *namelen);
d1225 2
a1226 2
	  *namelen = min (*namelen, len);
	  memcpy (name, &sock, *namelen);
d1236 2
d1242 1
a1242 1
		  *namelen = min (*namelen, (int) sizeof (struct sockaddr_in));
d1246 1
a1246 1
		  *namelen = min (*namelen, (int) sizeof (struct sockaddr_in6));
d1254 2
a1255 2
		  memset (name, 0, *namelen);
		  name->sa_family = get_addr_family ();
d1285 2
a1286 2
      *namelen = min (*namelen, (int) SUN_LEN (&sun) + 1);
      memcpy (name, &sun, *namelen);
d1290 2
a1291 2
      *namelen = min (*namelen, len);
      memcpy (name, &sock, *namelen);
@


1.243
log
@	* fhandler_socket.cc (fhandler_socket::accept): Always use local
	sockaddr_storage to store peer address and copy over to incoming
	peer address if available.  Truncate data as necessary according
	to POSIX.
@
text
@d155 1
d165 2
d670 1
d1050 1
a1050 1
    set_sun_path (name->sa_data);
d1148 1
d1171 14
a1184 2
	      *len = min (*len, llen);
	      memcpy (peer, &lpeer, *len);
d1206 7
a1212 16
      struct sockaddr_un *sun = (struct sockaddr_un *) name;
      memset (sun, 0, *namelen);
      sun->sun_family = AF_LOCAL;

      if (!get_sun_path ())
	sun->sun_path[0] = '\0';
      else
	/* According to SUSv2 "If the actual length of the address is
	   greater than the length of the supplied sockaddr structure, the
	   stored address will be truncated."  We play it save here so
	   that the path always has a trailing 0 even if it's truncated. */
	strncpy (sun->sun_path, get_sun_path (),
		 *namelen - sizeof *sun + sizeof sun->sun_path - 1);

      *namelen = sizeof *sun - sizeof sun->sun_path
		 + strlen (sun->sun_path) + 1;
d1217 12
a1228 2
      res = ::getsockname (get_socket (), name, namelen);
      if (res)
d1240 1
a1240 1
		  *namelen = sizeof (struct sockaddr_in);
d1244 1
a1244 1
		  *namelen = sizeof (struct sockaddr_in6);
d1267 6
a1272 1
  int res = ::getpeername (get_socket (), name, namelen);
d1275 16
d1957 6
@


1.242
log
@* fhandler_socket.cc (fhandler_socket::send_internal): Just use wmem size if
the length exceeds it.
* net.cc (fdsock): Use 65535 as window size, just like the comment says or we
run into problems with DuplicateHandle.
* path.cc (patch_conv::check): Use set_path to set invalid filename.
* path.h (path_conv::path_conv): Ditto.
@
text
@d1120 2
a1121 17
  struct sockaddr_in peer_dummy;
  int len_dummy;
  if (!peer)
    peer = (struct sockaddr *) &peer_dummy;
  if (!len)
    {
      len_dummy = sizeof (struct sockaddr_in);
      len = &len_dummy;
    }

  /* accept on NT fails if len < sizeof (sockaddr_in)
   * some programs set len to
   * sizeof (name.sun_family) + strlen (name.sun_path) for UNIX domain
   */
  if (len && ((unsigned) *len < sizeof (struct sockaddr_in)))
    *len = sizeof (struct sockaddr_in);

d1125 2
a1126 1
	 && (res = ::accept (get_socket (), peer, len)) == SOCKET_ERROR
d1164 5
@


1.241
log
@	* fhandler_socket.cc (fhandler_socket::recv_internal): Convert wsabuf
	and wsacnt to references.  Fix handling of WSAEMSGSIZE.
@
text
@d1502 1
a1502 1
	    buf.len = (unsigned) wmem () - 1;
@


1.240
log
@	* fhandler.h (class fhandler_socket): Add class members and methods
	to store and retrieve the SO_RCVBUF and SO_SNDBUF sizes.
	* fhandler_socket.cc (fhandler_socket::dup): Duplicate new members.
	(fhandler_socket::send_internal): Check for SO_SNDBUF size and
	restrict send to 1 byte less per KB 823764.  Leave loop immediately
	if WSASendMsg has been used.
	* net.cc (fdsock): Change comment again.  Set buffer sizes to 65536.
	Store values in fhandler_socket.
	(cygwin_setsockopt): Store SO_RCVBUF and SO_SNDBUF sizes in
	fhandler_socket.
	(cygwin_sendto): Drop call to sig_dispatch_pending.
	(cygwin_recvfrom): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
@
text
@d1312 2
a1313 2
  LPWSABUF wsabuf = wsamsg->lpBuffers;
  ULONG wsacnt = wsamsg->dwBufferCount;
d1386 1
a1386 1
  if (!ret && res == SOCKET_ERROR)
d1391 1
a1391 1
	return ret;
d1393 6
a1398 4
      /* ESHUTDOWN isn't defined for recv in SUSv3.  Simply EOF is returned
	 in this case. */
      if (WSAGetLastError () == WSAESHUTDOWN)
	return 0;
d1400 3
a1402 2
      set_winsock_errno ();
      return SOCKET_ERROR;
@


1.239
log
@	* net.cc (fdsock): Set default socket buffer sizes to 65520.  Change
	comment accordingly.
	* fhandler_socket.cc (fhandler_socket::send_internal): Set maximum
	send size to 65520 as well.
@
text
@d660 2
d1492 9
a1500 4
      buf.buf = wsamsg->lpBuffers[i].buf + off;
      buf.len = wsamsg->lpBuffers[i].len - off;
      if (buf.len > 65520)	/* See net.cc:fdsock() and MSDN KB 823764 */
	buf.len = 65520;
d1523 2
@


1.238
log
@	* fhandler_socket.cc (fhandler_socket::recv_internal): Mark WSARecvMsg
	as NO_COPY.
@
text
@d1492 2
a1493 2
      if (buf.len > 65536)	/* See KB 823764 */
	buf.len = 65536;
@


1.237
log
@	* fhandler_socket.cc (fhandler_socket::recv_internal): Set namelen
	pointer to NULL if name pointer is NULL.  Explain why.
@
text
@d1313 1
a1313 1
  static LPFN_WSARECVMSG WSARecvMsg;
@


1.236
log
@	* fhandler.h (fhandler_socket::wait_for_events): Take additional
	parameter "dontwait".
	* fhandler_socket.cc (fhandler_socket::wait_for_events): Act as if the
	socket is non-blocking if dontwait is true.
	(fhandler_socket::recv_internal): Use incoming MSG_DONTWAIT flag to
	set the wait_for_events dontwait parameter.
	(fhandler_socket::send_internal): Ditto.  Optimize code slightly.
	* include/cygwin/socket.h (MSG_DONTWAIT): Define.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d1350 6
a1355 1
			   &wsamsg->dwFlags, wsamsg->name, &wsamsg->namelen,
@


1.235
log
@	* autoload.cc (WSAIoctl): Reintroduce.
	(WSASendMsg): Define.
	* fhandler.h (class fhandler_socket): Change definition of recv_internal
	and send_internal to take WSAMSG pointer as parameter.
	* fhandler_socket.cc (WSAID_WSARECVMSG): Define.
	(LPFN_WSARECVMSG): Define.
	(WSASendMsg): Declare.
	(get_ext_funcptr): New function to fetch address of WSARecvMsg.
	(fhandler_socket::recv_internal): Take just a LPWSAMSG parameter.
	Change code accordingly.  If control information is requested,
	fetch address of WSARecvMsg and use that instead of WSARecvFrom.
	(fhandler_socket::recvfrom): Change return type to ssize_t as
	declared in fhandler.h.  Accommodate changes to recv_internal.
	(fhandler_socket::recvmsg): Ditto.  Make sure that control information
	is only requested if system, address family, and socket type support it.
	(fhandler_socket::send_internal): Take just a LPWSAMSG parameter
	and the flags.  Change code accordingly.  If control information is
	provided, use WSASendMsg instead of WSASendTo.
	(fhandler_socket::sendto): Drop useless comment.  Accommodate changes
	to send_internal.
	(fhandler_socket::sendmsg): Ditto.  Make sure that control information
	is only provided if system, address family, and socket type support it.
	* wincap.h (wincaps::has_recvmsg): New element.
	(wincaps::has_sendmsg): New element
	* wincap.cc: Implement above elements throughout.
	* include/cygwin/socket.h (CMSG_ALIGN): Phrase in terms of alignment
	of type struct cmsghdr.
@
text
@d583 1
a583 1
fhandler_socket::wait_for_events (const long event_mask)
d593 1
a593 1
      if (is_nonblocking ())
d1315 2
a1316 1
  bool waitall = (wsamsg->dwFlags & MSG_WAITALL);
d1343 1
a1343 1
  while (!(res = wait_for_events (evt_mask | FD_CLOSE))
d1476 2
d1479 1
d1493 1
a1493 3
	    res = WSASendMsg (get_socket (), wsamsg,
			      flags & (MSG_OOB | MSG_DONTROUTE), &ret,
			      NULL, NULL);
d1495 2
a1496 4
	    res = WSASendTo (get_socket (), &buf, 1, &ret,
			     flags & (MSG_OOB | MSG_DONTROUTE),
			     wsamsg->name, wsamsg->namelen,
			     NULL, NULL);
d1505 1
a1505 1
	     && !(res = wait_for_events (FD_WRITE | FD_CLOSE)));
d1530 1
a1530 1
	  if (!(flags & MSG_NOSIGNAL))
@


1.234
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d22 1
d1281 23
d1305 1
a1305 2
fhandler_socket::recv_internal (WSABUF *wsabuf, DWORD wsacnt, DWORD flags,
				struct sockaddr *from, int *fromlen)
d1309 18
a1326 4
  int evt_mask = FD_READ | ((flags & MSG_OOB) ? FD_OOB : 0);

  bool waitall = (flags & MSG_WAITALL);
  flags &= (MSG_OOB | MSG_PEEK | MSG_DONTROUTE);
d1335 1
a1335 1
      if (is_nonblocking () || (flags & (MSG_OOB | MSG_PEEK)))
d1345 6
a1350 2
      res = WSARecvFrom (get_socket (), wsabuf, wsacnt, &wret,
			 &flags, from, fromlen, NULL, NULL);
d1397 1
a1397 1
int
d1402 8
a1409 1
  return recv_internal (&wsabuf, 1, flags, from, fromlen);
d1412 1
a1412 1
int
d1415 6
a1420 3
  if (CYGWIN_VERSION_CHECK_FOR_USING_ANCIENT_MSGHDR)
    ((struct OLD_msghdr *) msg)->msg_accrightslen = 0;
  else
d1423 2
a1424 10
      msg->msg_flags = 0;
    }
  if (get_addr_family () == AF_LOCAL)
    {
      /* On AF_LOCAL sockets the (fixed-size) name of the shared memory
	 area used for descriptor passing is transmitted first.
	 If this string is empty, no descriptors are passed and we can
	 go ahead recv'ing the normal data blocks.  Otherwise start
	 special handling for descriptor passing. */
      /*TODO*/
d1435 13
a1447 5

  struct sockaddr *from = (struct sockaddr *) msg->msg_name;
  int *fromlen = from ? &msg->msg_namelen : NULL;

  return recv_internal (wsabuf, msg->msg_iovlen, flags, from, fromlen);
d1469 1
a1469 2
fhandler_socket::send_internal (struct _WSABUF *wsabuf, DWORD wsacnt, int flags,
				const struct sockaddr *to, int tolen)
d1474 1
d1476 4
a1479 1
  for (DWORD i = 0; i < wsacnt; off >= wsabuf[i].len && (++i, off = 0))
d1481 2
a1482 2
      buf.buf = wsabuf[i].buf + off;
      buf.len = wsabuf[i].len - off;
d1488 10
a1497 4
	  if ((res = WSASendTo (get_socket (), &buf, 1, &ret,
				flags & (MSG_OOB | MSG_DONTROUTE), to, tolen,
				NULL, NULL))
	      && (err = WSAGetLastError ()) == WSAEWOULDBLOCK)
d1530 1
a1530 1
	  if (! (flags & MSG_NOSIGNAL))
a1546 6
  /* Never write more than 64K at once to workaround a problem with
     Winsock, which creates a temporary buffer with the total incoming
     buffer size and copies the whole content over, regardless of
     the size of the internal send buffer.  A buffer full condition
     is only recognized in subsequent calls and, if len is big enough,
     the call even might fail with an out-of-memory condition. */
d1548 5
a1552 2
  return send_internal (&wsabuf, 1, flags,
			(to ? (const struct sockaddr *) &sst : NULL), tolen);
d1558 1
a1558 8
  if (get_addr_family () == AF_LOCAL)
    {
      /* For AF_LOCAL/AF_UNIX sockets, if descriptors are given, start
	 the special handling for descriptor passing.  Otherwise just
	 transmit an empty string to tell the receiver that no
	 descriptor passing is done. */
      /*TODO*/
    }
d1568 11
a1578 3

  return send_internal (wsabuf, msg->msg_iovlen, flags,
			(struct sockaddr *) msg->msg_name, msg->msg_namelen);
@


1.233
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d1455 1
a1455 1
  
@


1.232
log
@	* external.cc (cygwin_internal): Call set_security_attribute with
	additional path_conv argument.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Never set DOS
	R/O attribute when using ACLs.
	(fhandler_disk_file::mkdir): Ditto.  Set
	security descriptor on remote dirs after creating the dir, same as in
	fhandler_base::open.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for remote AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto. for remote symlinks.
	* security.cc (alloc_sd): Take additional path_conv argument.
	Accommodate throughout.  Drop setting FILE_WRITE_EA/FILE_READ_EA
	flags unconditionally (was only necessary for "ntea"). Don't set
	FILE_READ_ATTRIBUTES and FILE_WRITE_ATTRIBUTES unconditionally on
	Samba.  Add comment to explain.  Drop useless setting of
	STANDARD_RIGHTS_WRITE, it's in FILE_GENERIC_WRITE anyway.
	Remove FILE_READ_ATTRIBUTES bit from FILE_GENERIC_EXECUTE so as not
	to enforce read permissions on Samba.
	(set_security_attribute): Take additional path_conv argument.
	* security.h (set_security_attribute): Change prototype accordingly.
@
text
@d411 1
a411 1
static wsa_event wsa_events[NUM_SOCKS] __attribute__((section (".cygwin_dll_common"), shared)) = { 0 };
d413 1
a413 1
static LONG socket_serial_number __attribute__((section (".cygwin_dll_common"), shared)) = 0;
d1094 1
a1094 1
	      sin6_addr: IN6ADDR_ANY_INIT,
@


1.231
log
@	* fhandler_socket.cc (fhandler_socket::send_internal): Send never more
	then 64K bytes at once.  For blocking sockets, loop until entire data
	has been sent or an error occurs.
	(fhandler_socket::sendto): Drop code which sends on 64K bytes.
	(fhandler_socket::sendmsg): Ditto.
@
text
@d885 4
a888 2
      if (pc.has_acls ())
	set_security_attribute (mode, &sa, sd);
d909 2
@


1.230
log
@	Throughout drop allow_ntsec and allow_smbntsec handling.
	* environ.cc (set_ntsec): Remove.
	(set_smbntsec): Remove.
	(known): Remove ntsec and smbntsec options.
	* external.cc (check_ntsec): Return true if no filename is given.
	* mount.cc (oopts): Add "acl" and "noacl" options.  Set MOUNT_NOACL
	flag accordingly.
	(fillout_mntent): Handle MOUNT_NOACL flag.
	* path.h (enum path_types): Add PATH_NOACL.
	* security.cc (allow_ntsec): Remove.
	(allow_smbntsec): Remove.
	* security.h (allow_ntsec): Drop declaration.
	(allow_smbntsec): Drop declaration.
	* include/sys/mount.h (MOUNT_NOACL): Define.
@
text
@d1418 2
a1419 1
  DWORD ret = 0, err = 0;
d1421 1
a1421 1
  do
d1423 21
a1443 3
      if ((res = WSASendTo (get_socket (), wsabuf, wsacnt, &ret,
			    flags & (MSG_OOB | MSG_DONTROUTE), to, tolen, NULL, NULL))
	  && (err = WSAGetLastError ()) == WSAEWOULDBLOCK)
d1445 2
a1446 3
	  LOCK_EVENTS;
	  wsock_events->events &= ~FD_WRITE;
	  UNLOCK_EVENTS;
d1448 2
d1451 6
a1456 2
  while (res && err == WSAEWOULDBLOCK
	 && !(res = wait_for_events (FD_WRITE | FD_CLOSE)));
d1458 1
a1458 4
  if (res == SOCKET_ERROR)
    set_winsock_errno ();
  else
    res = ret;
d1460 9
a1468 11
  /* Special handling for EPIPE and SIGPIPE.

     EPIPE is generated if the local end has been shut down on a connection
     oriented socket.  In this case the process will also receive a SIGPIPE
     unless MSG_NOSIGNAL is set.  */
  if (res == SOCKET_ERROR && get_errno () == ESHUTDOWN
      && get_socket_type () == SOCK_STREAM)
    {
      set_errno (EPIPE);
      if (! (flags & MSG_NOSIGNAL))
	raise (SIGPIPE);
d1489 1
a1489 1
  WSABUF wsabuf = { len > 65536 ? 65536 : len, (char *) ptr };
d1509 1
a1509 2
  size_t total = 0;
  for (int i = 0; i < msg->msg_iovlen && total < 65536; ++i)
d1511 1
a1511 5
      if (total + iovptr->iov_len > 65536) /* See above. */
	wsaptr->len = 65536 - total;
      else
	wsaptr->len = iovptr->iov_len;
      total += wsaptr->len;
@


1.229
log
@	* autoload.cc (GetExtendedTcpTable): Define.
	* fhandler_socket.cc (address_in_use): Take const struct sockaddr
	pointer as argument.  Implement additional AF_INET6 table check.
	(fhandler_socket::bind): Drop AF_INET test before calling
	address_in_use.
	* net.cc (ipv4_getnameinfo): Return EAI_FAMILY instead of 1 if
	called with unsupported af_family.
@
text
@d885 1
a885 1
      if (allow_ntsec && pc.has_acls ())
@


1.228
log
@	* fhandler_socket.cc (fhandler_socket::bind): Don't run explicit
	local socket test in SO_REUSEADDR case on systems supporting
	enhanced socket security.  Explain why.  Only call address_in_use
	for AF_INET sockets.
	* net.cc (cygwin_setsockopt): Don't call setsockopt to set SO_REUSEADDR
	on systems supporting enhanced socket security.  Add comment.
	* wincap.h (wincaps::has_enhanced_socket_security): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d772 1
a772 1
address_in_use (struct sockaddr_in *addr)
d774 54
a827 16
  PMIB_TCPTABLE tab;
  PMIB_TCPROW entry;
  DWORD size = 0, i;

  if (GetTcpTable (NULL, &size, FALSE) == ERROR_INSUFFICIENT_BUFFER)
    {
      tab = (PMIB_TCPTABLE) alloca (size);
      if (!GetTcpTable (tab, &size, FALSE))
	{
	  for (i = tab->dwNumEntries, entry = tab->table; i > 0; --i, ++entry)
	    if (entry->dwLocalAddr == addr->sin_addr.s_addr
		&& entry->dwLocalPort == addr->sin_port
		&& entry->dwState >= MIB_TCP_STATE_LISTEN
		&& entry->dwState <= MIB_TCP_STATE_LAST_ACK)
	      return true;
	}
d973 1
a973 2
	      if (name->sa_family == AF_INET
		  && get_socket_type () == SOCK_STREAM
d975 1
a975 1
		  && address_in_use ((struct sockaddr_in *) name))
@


1.227
log
@	* Makefile.in (DLL_OFILES): Add kernel32.o.
	* autoload.cc (WSACloseEvent): Remove.
	(WSACreateEvent): Remove.
	* cygheap.cc (cygheap_init): Drop initializing shared_prefix.
	* cygheap.h (struct init_cygheap): Drop shared_prefix and
	shared_prefix_buf members.
	* fhandler_socket.cc (sock_shared_name): New static function.
	(search_wsa_event_slot): Convert name buffers to WCHAR.  Call
	NtCreateMutant/NtOpenMutant to create mutexes in session local
	namespace.
	(fhandler_socket::init_events): Ditto.  Fix debug output.
	(fhandler_socket::release_events): Close mutexes using NtClose.
	(fhandler_socket::dup): Ditto.
	* kernel32.cc: New file, implementing Win32 calls in a Cygwin-specific
	way.
	* mmap.cc (MapView): Make static.
	* ntdll.h: Fix status code sorting.
	(STATUS_OBJECT_NAME_EXISTS): Define.
	(SEMAPHORE_QUERY_STATE): Define.
	(CYG_SHARED_DIR_ACCESS): Define.
	(CYG_MUTANT_ACCESS): Define.
	(CYG_EVENT_ACCESS): Define.
	(CYG_SEMAPHORE_ACCESS): Define.
	(enum _PROCESSINFOCLASS): Define ProcessSessionInformation.
	(struct _PROCESS_SESSION_INFORMATION): Define.
	(NtCreateSemaphore): Declare.
	(NtOpenSemaphore): Declare.
	* flock.cc: Use CYG_xxx_ACCESS access masks where appropriate.
	* posix_ipc.cc (ipc_mutex_init): Use native functions to create mutex.
	Create in cygwin-shared subdir.
	(ipc_cond_init): Ditto for event.
	(ipc_mutex_close): Use NtClose.
	(ipc_cond_close): Ditto.
	(mq_open): Drop "cyg" prefix from mqh_uname.
	* shared.cc (CYG_SHARED_DIR_ACCESS): Drop definition here.
	(_cygwin_testing): Declare extern on file level.
	(get_shared_parent_dir): Change name of shared directory.  Add name
	to api_fatal output.
	(get_session_parent_dir): New function.
	(shared_name): Simplify.
	(shared_info::initialize): Call get_session_parent_dir.
	* shared_info.h (get_session_parent_dir): Declare.
	* smallprint.cc (__small_vswprintf): Fix bug in multibyte string
	conversion.
	* thread.cc (semaphore::semaphore): Align semaphore name to object
	names in posix IPC functions.
	* include/cygwin/version.h (CYGWIN_VERSION_SHARED_DATA): Bump.
@
text
@d914 1
a914 1
	  else
d921 16
a936 4
		 possible in WinSock.  So we're testing here if the local
		 address is already in use and don't bind, if so.  This
		 only works for OSes with IP Helper support. */
	      if (get_socket_type () == SOCK_STREAM
@


1.226
log
@	Revert thinko in previous patch.
	* fhandler.h (struct wsa_event): Move back from wsa_event.h to here.
	* fhandler_socket.cc (NUM_SOCKS): Ditto.
	(wsa_events): Move back from cygwin_shared to here.  Accommodate
	throughout.
	(socket_serial_number): Ditto.
	* shared_info.h: Accommodate above changes.
	* wsa_event.h: Remove.
@
text
@d417 7
d427 4
a430 1
  char name[MAX_PATH], searchname[MAX_PATH];
d434 8
a441 4
      wsa_slot_mtx = CreateMutex (&sec_all, FALSE,
				  shared_name (name, "sock", 0));
      if (!wsa_slot_mtx)
	api_fatal ("Couldn't create/open shared socket mutex, %E");
d455 7
a461 3
      HANDLE searchmtx = OpenMutex (STANDARD_RIGHTS_READ, FALSE,
	    shared_name (searchname, "sock", wsa_events[slot].serial_number));
      if (!searchmtx)
d464 1
a464 1
      CloseHandle (searchmtx);
d484 4
a487 2
  char name[MAX_PATH];
  DWORD err = 0;
d495 6
a500 3
      wsock_mtx = CreateMutex (&sec_all, FALSE,
			       shared_name (name, "sock", new_serial_number));
      if (!wsock_mtx)
d502 1
a502 1
	  debug_printf ("CreateMutex, %E");
d506 2
a507 3
      err = GetLastError ();
      if (err == ERROR_ALREADY_EXISTS)
	CloseHandle (wsock_mtx);
d509 1
a509 1
  while (err == ERROR_ALREADY_EXISTS);
d513 1
a513 1
      debug_printf ("WSACreateEvent, %E");
d515 1
a515 1
      CloseHandle (wsock_mtx);
d522 2
a523 2
      CloseHandle (wsock_evt);
      CloseHandle (wsock_mtx);
d626 2
a627 2
  CloseHandle (wsock_evt);
  CloseHandle (wsock_mtx);
d654 1
a654 1
      CloseHandle (fhs->wsock_mtx);
d678 2
a679 2
      CloseHandle (fhs->wsock_evt);
      CloseHandle (fhs->wsock_mtx);
@


1.225
log
@	* fhandler.h (-struct wsa_event): Move to wsa_event.h.  Include
	wsa_event.h instead.
	* fhandler_socket.cc (NUM_SOCKS): Move to wsa_event.h.
	(wsa_events): Move from DLL shared area to cygwin_shared shared
	memory.  Accommodate throughout.
	(socket_serial_number): Ditto.
	* fhandler_tape.cc (mt): Ditto.
	(mtinfo_init): Remove.
	(mt): Define as cygwin_shared->mt.
	* flock.cc (FLOCK_PARENT_DIR_ACCESS): Remove.
	(FLOCK_INODE_DIR_ACCESS): Move up in file.
	(FLOCK_MUTANT_ACCESS): Ditto.
	(FLOCK_EVENT_ACCESS): Ditto.
	(get_lock_parent_dir): Remove.
	(inode_t::inode_t): Call get_shared_parent_dir to get parent dir handle.
	Add a "flock-" prefix to file's lock directory name for clarity.
	* mtinfo.h (mtinfo_init): Drop declaration.
	* net.cc (last_used_bindresvport): Move from DLL shared area to
	cygwin_shared shared memory.
	(cygwin_bindresvport_sa): Accommodate above change.
	* sec_helper.cc (_everyone_sd): Move here from flock.cc.
	* security.h (SD_MIN_SIZE): Ditto.
	(everyone_sd): Ditto.
	* shared.cc (cygwin_shared_area): Remove.
	(cygwin_shared_h): New handle.
	(get_shared_parent_dir): New static function.
	(shared_name): Drop session_local argument.  Call get_shared_parent_dir
	here.  Add cygwin-shared subdir to object name.
	(offsets): Reinstantiate SH_CYGWIN_SHARED member.
	(open_shared): Revert change from 2007-03-29 for systems supporting
	SeCreateGlobalPrivilege.
	(shared_info::initialize): Call mtinfo's initialize here.
	(memory_init): Drop call to mtinfo_init.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add members for global socket and tape info
	sharing.
	(enum shared_locations): Reinstantiate SH_CYGWIN_SHARED.
	(get_shared_parent_dir): Declare.
	(shared_name): Drop session_local argument from declaration.
	* wsa_event.h: New file.  Move definitions of NUM_SOCKS and
	struct wsa_event here.
@
text
@d406 2
d411 4
d439 1
a439 1
  while (cygwin_shared->wsa_events[slot].serial_number)
d442 1
a442 2
	    shared_name (searchname, "sock",
			 cygwin_shared->wsa_events[slot].serial_number));
d456 2
a457 2
  memset (&cygwin_shared->wsa_events[slot], 0, sizeof (wsa_event));
  cygwin_shared->wsa_events[slot].serial_number = new_serial_number;
d459 1
a459 1
  return cygwin_shared->wsa_events + slot;
d472 1
a472 1
	InterlockedIncrement (&cygwin_shared->socket_serial_number);
d474 1
a474 1
	InterlockedIncrement (&cygwin_shared->socket_serial_number);
@


1.224
log
@	* fhandler_socket.cc (fhandler_socket::close): Disable enforced
	lingering since the original problem can no longer be reproduced.
@
text
@a405 2
#define NUM_SOCKS	(65536 / sizeof (wsa_event))

a408 4
static wsa_event wsa_events[NUM_SOCKS] __attribute__((section (".cygwin_dll_common"), shared)) = { 0 };

static LONG socket_serial_number __attribute__((section (".cygwin_dll_common"), shared)) = 0;

d419 1
a419 1
				  shared_name (name, "sock", 0, true));
d433 1
a433 1
  while (wsa_events[slot].serial_number)
d436 2
a437 2
	    shared_name (searchname, "sock", wsa_events[slot].serial_number,
			 true));
d451 2
a452 2
  memset (&wsa_events[slot], 0, sizeof (wsa_event));
  wsa_events[slot].serial_number = new_serial_number;
d454 1
a454 1
  return wsa_events + slot;
d466 2
a467 1
      new_serial_number = InterlockedIncrement (&socket_serial_number);
d469 1
a469 1
	InterlockedIncrement (&socket_serial_number);
d471 1
a471 2
			       shared_name (name, "sock", new_serial_number,
					    true));
@


1.223
log
@Remove unneeded header files from source files throughout.
@
text
@d1463 5
a1467 1

d1476 1
a1476 1

@


1.222
log
@	* Fix copyright dates.
@
text
@a15 1
#include <sys/socket.h>
a16 1
#include <sys/uio.h>
a32 1
#include "cygthread.h"
a35 1
#include <sys/statvfs.h>
@


1.221
log
@	* fhandler_socket.cc: Create shared objects session local throughout.
	* shared.cc (shared_name): Add argument to allow opening session
	local shared memory.
	* shared_info.h (shared_name): Change declaration accordingly.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Red Hat, Inc.
@


1.220
log
@	* fhandler_socket.cc (fhandler_socket::sendto): Never send more than
	64K.  Add comment to explain why.
	(fhandler_socket::sendmsg): Ditto.
@
text
@d408 1
a408 1
   on a machine.  Note that shared sockets (through dup/fork/exec) are
d429 1
a429 1
				  shared_name (name, "sock", 0));
d446 2
a447 1
	    shared_name (searchname, "sock", wsa_events[slot].serial_number));
d480 2
a481 1
			       shared_name (name, "sock", new_serial_number));
@


1.219
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d1396 7
a1402 1
  WSABUF wsabuf = { len, (char *) ptr };
d1420 4
a1423 3
  WSABUF *wsaptr = wsabuf + msg->msg_iovlen;
  const struct iovec *iovptr = msg->msg_iov + msg->msg_iovlen;
  while (--wsaptr >= wsabuf)
d1425 6
a1430 2
      wsaptr->len = (--iovptr)->iov_len;
      wsaptr->buf = (char *) iovptr->iov_base;
@


1.218
log
@	* fhandler_registry.cc: Use NAME_MAX + 1 instead of CYG_MAX_PATH
	throughout for subkey name buffer size.
	* fhandler_socket.cc (search_wsa_event_slot): Use MAX_PATH instead of
	CYG_MAX_PATH for mutext name buffer size.
	(fhandler_socket::init_events): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Check path length
	against PATH_MAX instead of against CYG_MAX_PATH.
	* registry.cc (get_registry_hive_path): Use PATH_MAX instead of
	CYG_MAX_PATH for registry value path buffer size.
	* shared.cc (open_shared): Use MAX_PATH instead of CYG_MAX_PATH
	for shared memory name buffer size.
	* thread.cc (semaphore::semaphore): Use MAX_PATH instead of CYG_MAX_PATH
	for semaphore name buffer size.
	* uinfo.cc (cygheap_user::env_userprofile): Use PATH_MAX instead of
	CYG_MAX_PATH for temporary path name buffer size.
	* winf.h (LINE_BUF_CHUNK): Define as MAX_PATH * 2.
	* include/sys/dirent.h: Include sys/limits.h.  Define name buffer sizes
	using NAME_MAX.
@
text
@d429 1
a429 1
      				  shared_name (name, "sock", 0));
d1221 1
a1221 1
        {
d1227 1
a1227 1
        waitall = false;
d1252 1
a1252 1
	        {
@


1.217
log
@	* fhandler_socket.cc (fhandler_socket::recv_internal): Add MSG_WAITALL
	handling.  Use explicit flag values instead of MSG_WINMASK.
	(fhandler_socket::send_internal): Use explicit flag values instead of
	MSG_WINMASK.
	* include/cygwin/socket.h (MSG_WINMASK): Remove definition.
	(MSG_WAITALL): Define.
@
text
@d424 1
a424 1
  char name[CYG_MAX_PATH], searchname[CYG_MAX_PATH];
d470 1
a470 1
  char name[CYG_MAX_PATH];
@


1.216
log
@	* fhandler_socket.cc (fhandler_socket::bind): Open file for deletion,
	too.  Don't write to file and especially don't close handle if file
	couldn't be created.  Set delete disposition if writing failed,
	instead of calling unlink_nt.
@
text
@d1213 1
a1213 1
  DWORD ret = 0;
d1216 14
a1229 1
  flags &= MSG_WINMASK;
d1236 1
a1236 1
      res = WSARecvFrom (get_socket (), wsabuf, wsacnt, &ret,
d1238 24
a1261 1
      if (!res || WSAGetLastError () != WSAEWOULDBLOCK)
d1265 1
a1265 1
  if (res == SOCKET_ERROR)
d1278 1
a1279 2
  else
    res = ret;
d1281 1
a1281 1
  return res;
d1355 1
a1355 1
			    flags & MSG_WINMASK, to, tolen, NULL, NULL))
@


1.215
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Handle S_IFSOCK
	mode bit by setting the SYSTEM attribute.
	* fhandler_socket.cc (fhandler_socket::fchmod): Add S_IFSOCK mode bit
	when calling fhandler_disk_file::fchmod.  Don't set attributes here.
@
text
@d834 1
a834 1
      status = NtCreateFile (&fh, GENERIC_WRITE | SYNCHRONIZE,
a847 14

      char buf[sizeof (SOCKET_COOKIE) + 80];
      __small_sprintf (buf, "%s%u %c ", SOCKET_COOKIE, sin.sin_port, get_socket_type () == SOCK_STREAM ? 's' : get_socket_type () == SOCK_DGRAM ? 'd' : '-');
      af_local_set_secret (strchr (buf, '\0'));
      DWORD blen = strlen (buf) + 1;
      status = NtWriteFile (fh, NULL, NULL, NULL, &io, buf, blen, NULL, 0);
      NtClose (fh);
      if (!NT_SUCCESS (status))
	{
	  extern NTSTATUS unlink_nt (path_conv &pc);

	  __seterrno_from_nt_status (status);
	  unlink_nt (pc);
	}
d850 23
a872 2
	  set_sun_path (un_addr->sun_path);
	  res = 0;
@


1.214
log
@	* path.h (path_conv::operator char *): Delete.
	(path_conv::operator const char *): Delete.
	* dlfcn.cc: Throughout, replace path_conv::operator char * and
	path_conv::operator const char * by call to path_conv::get_win32
	for easier transition to UNICODE_PATHs.
	* fhandler_socket.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d710 1
a710 4
      int ret = fh.fchmod (adjust_socket_file_mode (mode));
      SetFileAttributesA (pc.get_win32 (),
			  GetFileAttributesA (pc.get_win32 ())
			  | FILE_ATTRIBUTE_SYSTEM);
@


1.213
log
@	* fhandler_socket.cc (get_inet_addr): Use NT native functions for
	accessing the file representing the local socket.
	(fhandler_socket::bind): Ditto.
	* ntdll.h: Declare NtReadFile.
@
text
@d711 3
a713 1
      SetFileAttributes	(pc, GetFileAttributes (pc) | FILE_ATTRIBUTE_SYSTEM);
@


1.212
log
@	* fhandler.h (fhandler_base::close_fs): Reintroduce (as inline function)
	for clearness.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Revert previous
	change.
	(fhandler_base::open_fs): Ditto.
	* fhandler_socket.cc (fhandler_socket::close): Ditto.
@
text
@d42 1
d83 5
d104 6
a109 4
      HANDLE fh = CreateFile (pc, GENERIC_READ, FILE_SHARE_VALID_FLAGS,
			      &sec_none, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
			      0);
      if (fh == INVALID_HANDLE_VALUE)
d111 1
a111 1
	  __seterrno ();
a114 1
      DWORD len = 0;
d117 3
a119 1
      if (ReadFile (fh, buf, 128, &len, 0))
d139 1
a139 2
	__seterrno ();
      CloseHandle (fh);
d824 1
a824 1
      DWORD attr = FILE_ATTRIBUTE_SYSTEM;
d826 2
a827 2
	attr |= FILE_ATTRIBUTE_READONLY;
      SECURITY_ATTRIBUTES sa = sec_none;
d831 12
a842 2
      HANDLE fh = CreateFile (pc, GENERIC_WRITE, 0, &sa, CREATE_NEW, attr, 0);
      if (fh == INVALID_HANDLE_VALUE)
d844 1
a844 1
	  if (GetLastError () == ERROR_ALREADY_EXISTS)
d847 1
a847 1
	    __seterrno ();
d854 3
a856 1
      if (!WriteFile (fh, buf, blen, &blen, 0))
d858 4
a861 3
	  __seterrno ();
	  CloseHandle (fh);
	  DeleteFile (pc);
a864 1
	  CloseHandle (fh);
@


1.211
log
@	* Makefile.in (DLL_OFILES): Remove delqueue.o.
	* delqueue.cc: Delete.
	* fhandler.h (fhandler_base::close_fs): Drop declaration.
	(fhandler_disk_file::close): Drop declaration.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Call close instead of
	close_fs.
	(fhandler_base::fstat_helper): Use open FH_UNIX handle in call to
	get_file_attribute.
	(fhandler_base::open_fs): Call close instead of get_file_attribute.
	(fhandler_disk_file::close): Remove.
	(fhandler_base::close_fs): Remove.
	* fhandler_socket.cc (fhandler_socket::close): Just call
	fhandler_base::close for FH_UNIX sockets.
	* shared.cc (user_shared_initialize): Drop call to
	user_shared->delqueue.init.
	* shared_info.h (CURR_USER_MAGIC): Change according to below change.
	(MAX_DELQUEUES_PENDING): Remove.
	(class delqueue_list): Remove.
	(class user_info): Remove delqueue.
	* syscalls.cc (close_all_files): Drop call to
	user_shared->delqueue.process_queue.
	(unlink): Drop delqueue handling.
@
text
@a1393 3
  if (get_device () == FH_UNIX)
    return fhandler_base::close ();

@


1.210
log
@	* autoload.cc (WSAIoctl): Remove.
	* cygwin.din: Export freeifaddrs, getifaddrs.
	* fhandler_socket.cc (fhandler_socket::ioctl): Drop SOCKET parameter
	from get_ifconf.
	* net.cc: Include ifaddrs.h.
	(in_are_prefix_equal): Match addresses in network byte order.
	(ip_addr_prefix): Convert address into host byte order before
	testing with IN_LOOPBACK.
	(struct ifall): Define.
	(get_xp_ifs): Replace get_xp_ifconf.  Return struct ifall array.
	(get_2k_ifs): Ditto, replace get_2k_ifconf.
	(get_nt_ifs): Ditto, replace get_nt_ifconf.
	(getifaddrs): New function.
	(freeifaddrs): New function.
	(get_ifconf): Call matching get_XX_ifs function and create
	ifc content from here.  Drop lo fake since it's now in get_nt_ifs.
	* posix.sgml: Add freeifaddrs and getifaddrs to list of implemented
	BSD functions.
	* wincap.h (wincapc::has_broken_if_oper_status): New element.
	* wincap.cc: Implement above element throughout.
	* include/ifaddrs.h: New file.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d1394 3
@


1.209
log
@	* autoload.cc (GetIpForwardTable): Define.
	* fhandler_socket.cc (fhandler_socket::ioctl): Handle SIOCGIFDSTADDR.
	* net.cc (get_routedst): New static function to get destination
	address of point-to-point interfaces.
	(get_xp_ifconf): Handle SIOCGIFDSTADDR.
	(get_2k_ifconf): Ditto.
	(get_nt_ifconf): Ditto.
	(get_ifconf): Ditto.
	* include/asm/socket.h (SIOCGIFDSTADDR): Define.
	* include/cygwin/if.h (struct ifreq): Add ifru_dstaddr member.
	(ifr_dstaddr): Define.
	* include/cygwin/in.h: Cast ipv4 addresses correctly to in_addr_t in
	definitions.
@
text
@d1458 1
a1458 1
  extern int get_ifconf (SOCKET s, struct ifconf *ifc, int what); /* net.cc */
d1483 1
a1483 1
      res = get_ifconf (get_socket (), &ifc, cmd);
d1547 1
a1547 1
	res = get_ifconf (get_socket (), &ifc, cmd);
@


1.208
log
@	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.
@
text
@d1522 1
@


1.207
log
@	* fhandler.cc(fhandler_base::open): Open with READ_CONTROL only in
	case of query_open flag set to query_read_control.  Add case for
	new query_read_attributes flag.
	(fhandler_base::fstatvfs): New method.
	* fhandler.h (enum query_state): Add query_read_attributes flag.
	(class fhandler_base): Declare new virtual fstatvfs method.
	(class fhandler_socket): Ditto.
	(class fhandler_pipe): Ditto.
	(class fhandler_fifo): Ditto.
	(class fhandler_disk_file): Ditto.
	(class fhandler_virtual): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Open with
	query_read_attributes instead of query_read_control.
	(fhandler_disk_file::fstatvfs): New method.
	(fhandler_disk_file::facl): Open with query_read_attributes instead of
	query_read_control.
	* fhandler_fifo.cc (fhandler_fifo::fstatvfs): New method.
	* fhandler_socket.cc (fhandler_socket::fstatvfs): New method.
	(fhandler_socket::fchmod): Return with EBADF in the default case.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::fstatvfs): Ditto.
	* ntdll.h (struct _FILE_FS_ATTRIBUTE_INFORMATION): Define.
	(struct _FILE_FS_FULL_SIZE_INFORMATION): Define.
	* pipe.cc (fhandler_pipe::fstatvfs): New method.
	* syscalls.cc (fstatvfs): Just call the fhandler's fstatvfs.
	(statvfs): Ditto.
	(fstatfs): Call fstatvfs.
	(statfs): Drop EFAULT handling.
@
text
@d53 12
d702 1
a702 1
      int ret = fh.fchmod (mode);
d814 2
a815 1
      mode_t mode = (S_IRWXU | S_IRWXG | S_IRWXO) & ~cygheap->umask;
@


1.206
log
@	Throughout replace all usage of wincap.shared with the constant
	FILE_SHARE_VALID_FLAGS.
	* fhandler.cc (fhandler_base::open_9x): Drop local variable shared.
	* wincap.cc: Remove shared member throughout.
	* wincap.h: Ditto.
@
text
@d39 1
d670 13
d694 2
a695 1
  return 0;
d706 2
a707 1
  return 0;
d718 2
a719 1
  return fhandler_base::facl (cmd, nentries, aclbufp);
@


1.205
log
@	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.
@
text
@d85 3
a87 2
      HANDLE fh = CreateFile (pc, GENERIC_READ, wincap.shared (), &sec_none,
			      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
@


1.204
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d759 1
a759 1
	  syscall_printf ("AF_LOCAL: bind failed %d", get_errno ());
d765 1
a765 1
	  syscall_printf ("AF_LOCAL: getsockname failed %d", get_errno ());
@


1.203
log
@	* autoload.cc (WSAIoctl): Define.
	(SendARP): Define.
	* cygwin.din: Export if_freenameindex, if_indextoname, if_nameindex and
	if_nametoindex.
	* fhandler_procnet.cc: Drop including wchar.h.  Drop definitions of
	GAA_FLAG_INCLUDE_ALL_INTERFACES, IP_ADAPTER_UNICAST_ADDRESS_VISTA.
	(fhandler_procnet::exists): Check for has_gaa_prefixes.  Call
	get_adapters_addresses here.
	(fhandler_procnet::readdir): Ditto.
	(prefix): Move to net.cc.
	(fhandler_procnet::fill_filebuf): Call get_adapters_addresses here.
	Simplify allocation.  Use AdapterName rather than FriendlyName as
	interface name.  Use IfIndex if available, Ipv6IfIndex otherwise.
	(in6_are_prefix_equal): Move to net.cc.
	* fhandler_socket.cc: Define old SIOCGxxx values.
	(CONV_OLD_TO_NEW_SIO): Convert old SIOCGxxx value to new one.
	(struct __old_ifreq): Define old struct ifreq.
	(fhandler_socket::ioctl): Handle old SIOCGxxx values.  Handle new
	SIOCGIFFRNDLYNAM command.  Simplify copying ifreq data to user space.
	Call get_ifconf with additional SOCKET parameter.
	* net.cc (IP_ADAPTER_UNICAST_ADDRESS_LH): Define.
	(IP_ADAPTER_ADDRESSES_LH): Define.
	(SIO_GET_INTERFACE_LIST): Define.
	(sockaddr_in6_old): Define.
	(sockaddr_gen): Define.
	(INTERFACE_INFO): Define.
	(IN_LOOPBACK): Define.
	(in_are_prefix_equal): New static function.
	(ip_addr_prefix): New function, replaces prefix function, add AF_INET
	handling.
	(GAA_FLAG_INCLUDE_ALL_INTERFACES): Define.
	(get_adapters_addresses): New function.
	(WS_IFF_xxx): Define Winsock interface flag values.
	(convert_ifr_flags): New function to convert Winsock interface flag
	values to Cygwin interface flag values.
	(get_xp_ifconf): New get_ifconf implementation for XP SP1 and above.
	(get_2k_ifconf): Fix interface index.  Fix formatting.
	(get_nt_ifconf): Fix formatting.
	(get_95_ifconf): Ditto.
	(get_ifconf): Take additional SOCKET parameter.  Call get_xp_ifconf
	on XP SP1 and above.
	(if_nametoindex): New function.
	(if_indextoname): New function.
	(if_nameindex): New function.
	(if_freenameindex): New function.
	(in6_are_prefix_equal): Moved here from fhandler_procnet.cc.
	* wincap.cc (wincap_xp): Define has_gaa_prefixes as true by default.
	(wincapc::init): Assume has_osversioninfoex by default.  Call
	GetVersionEx with OSVERSIONINFOEX first.  Call with OSVERSIONINFO only
	if that fails.  Simplify NT4 case and try to avoid strcmp.  Check XP
	Service Pack using version.wServicePackMajor to avoid strcmp.
	* include/asm/socket.h (SIOCGIFFRNDLYNAM): Define.
	* include/cygwin/if.h: Fix formatting.
	(IFF_POINTTOPOINT): Define.
	(IFF_NOARP): Define.
	(IFF_LOWER_UP): Define.
	(IFF_DORMANT): Define.
	(struct if_nameindex): Define.
	(IFRF_FRIENDLYNAMESIZ): Define.
	(struct ifreq_frndlyname): Define.
	(IFNAMSIZ): Redefine as 44.
	(IF_NAMESIZE): Define.
	(struct ifreq): Redefine ifru_flags as int.  Define ifru_data.  Pad size
	to sizeof sockaddr_in6 for further extensions.
	(ifr_data): Define.
	(ifr_frndlyname): Define.
	(if_nametoindex): Declare.
	(if_indextoname): Declare.
	(if_nameindex): Declare.
	(if_freenameindex): Declare.
	* include/cygwin/version.h: Bump API minor number.
	(CYGWIN_VERSION_CHECK_FOR_OLD_IFREQ): Define check for old vs. new
	ifreq structure.
@
text
@d426 1
a426 1
        break;
d431 1
a431 1
        {
d466 1
a466 1
        CloseHandle (wsock_mtx);
d503 1
a503 1
        {
d950 1
a950 1
        {
d959 2
a960 2
        {
	  struct sockaddr_in6 sin6 = 
d1088 1
a1088 1
        {
d1096 1
a1096 1
	        {
d1110 1
a1110 1
	        {
d1265 1
a1265 1
        {
d1306 1
a1306 1
  			(to ? (const struct sockaddr *) &sst : NULL), tolen);
d1331 1
a1331 1
  			(struct sockaddr *) msg->msg_name, msg->msg_namelen);
d1444 1
a1444 1
	  		* sizeof (struct ifreq);
d1448 1
a1448 1
        {
d1456 1
a1456 1
        {
d1470 1
a1470 1
        ifcp->ifc_len = ifc.ifc_len;
d1510 1
a1510 1
	    			alloca (64 * sizeof (struct ifreq_frndlyname));
d1576 1
a1576 1
        WSAEventSelect (get_socket (), wsock_evt, EVENT_MASK);
d1585 1
a1585 1
         state here. */
d1592 1
a1592 1
        }
@


1.202
log
@	* fhandler_socket.cc (fhandler_socket::ioctl): Handle SIOCGIFINDEX.
	* net.cc (get_2k_ifconf): Ditto.
	(get_nt_ifconf): Fake SIOCGIFINDEX.
	(get_95_ifconf): Ditto.
	(get_ifconf): Handle SIOCGIFINDEX.  Fake it for loopback on systems
	not supporting IP Helper Lib.
	* include/asm/socket.h (SIOCGIFINDEX): Define.
	* include/cygwin/if.h (struct ifreq): Add member for interface index.
	(ifr_ifindex): Define.
@
text
@d1394 30
d1427 1
a1427 1
  extern int get_ifconf (struct ifconf *ifc, int what); /* net.cc */
d1430 1
a1430 1
  struct ifreq *ifr, *ifrp;
d1441 12
a1452 1
      res = get_ifconf (ifcp, cmd);
d1455 16
d1472 10
d1490 1
d1492 6
a1497 2
	ifc.ifc_len = 2048;
	ifc.ifc_buf = (char *) alloca (2048);
d1499 1
a1499 2
	ifr = (struct ifreq *) p;
	if (ifr == 0)
d1501 1
a1501 1
	    debug_printf ("ifr == NULL");
d1505 9
d1515 1
a1515 1
	res = get_ifconf (&ifc, cmd);
d1522 1
a1522 4
	debug_printf ("    name: %s", ifr->ifr_name);
	for (ifrp = ifc.ifc_req;
	     (caddr_t) ifrp < ifc.ifc_buf + ifc.ifc_len;
	     ++ifrp)
d1524 5
a1528 2
	    debug_printf ("testname: %s", ifrp->ifr_name);
	    if (! strcmp (ifrp->ifr_name, ifr->ifr_name))
d1530 2
a1531 1
		switch (cmd)
d1533 2
a1534 2
		  case SIOCGIFFLAGS:
		    ifr->ifr_flags = ifrp->ifr_flags;
d1536 21
a1556 20
		  case SIOCGIFADDR:
		    ifr->ifr_addr = ifrp->ifr_addr;
		    break;
		  case SIOCGIFBRDADDR:
		    ifr->ifr_broadaddr = ifrp->ifr_broadaddr;
		    break;
		  case SIOCGIFNETMASK:
		    ifr->ifr_netmask = ifrp->ifr_netmask;
		    break;
		  case SIOCGIFHWADDR:
		    ifr->ifr_hwaddr = ifrp->ifr_hwaddr;
		    break;
		  case SIOCGIFMETRIC:
		    ifr->ifr_metric = ifrp->ifr_metric;
		    break;
		  case SIOCGIFMTU:
		    ifr->ifr_mtu = ifrp->ifr_mtu;
		    break;
		  case SIOCGIFINDEX:
		    ifr->ifr_ifindex = ifrp->ifr_ifindex;
a1558 1
		break;
@


1.201
log
@	* fhandler_socket.cc (fhandler_socket::ioctl): Don't fake results
	for SIOCGIFFLAGS here.  Call get_ifconf instead.
	* net.cc (get_2k_ifconf): Clean up code to generate interface name.
	Handle SIOCGIFFLAGS here.
	(get_nt_ifconf): Fake SIOCGIFFLAGS here.
	(get_95_ifconf): Ditto.
	(get_ifconf): Don't fake loopback on systems with IP Helper Lib.
	Set MTU for loopback to a more "modern" value.
@
text
@d1422 1
d1473 3
@


1.200
log
@revert erroneous checkin
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006 Red Hat, Inc.
a1415 15
      ifr = (struct ifreq *) p;
      if (ifr == 0)
	{
	  set_errno (EINVAL);
	  return -1;
	}
      ifr->ifr_flags = IFF_NOTRAILERS | IFF_UP | IFF_RUNNING;
      if (!strncmp(ifr->ifr_name, "lo", 2)
	  || ntohl (((struct sockaddr_in *) &ifr->ifr_addr)->sin_addr.s_addr)
	  == INADDR_LOOPBACK)
	ifr->ifr_flags |= IFF_LOOPBACK;
      else
	ifr->ifr_flags |= IFF_BROADCAST;
      res = 0;
      break;
d1451 3
@


1.199
log
@* winsup.h: Turn on DEBUGGING by default for now.
@
text
@a40 1
#include "mmap_helper.h"
d1166 2
a1167 2
      res = mmWSARecvFrom (get_socket (), wsabuf, wsacnt, &ret,
			   &flags, from, fromlen, NULL, NULL);
@


1.198
log
@	* fhandler_socket.cc (fhandler_socket::recv_internal): Fix a problem
	with poll(2) after shutdown(SHUT_RD) has been called on the local side.
	* poll.cc (poll): Use POSIX type nfds_t for second parameter.  Drop
	special socket handling for POLLIN.  Add comment to explain why.
	* include/sys/poll.h: Declare nfds_t.  Use as type for second parameter
	in poll(2) declaration.
@
text
@d41 1
d1167 2
a1168 2
      res = WSARecvFrom (get_socket (), wsabuf, wsacnt, &ret,
			 &flags, from, fromlen, NULL, NULL);
@


1.197
log
@	* fhandler_socket.cc (fhandler_socket::evaluate_events): Circumvent
	potential race condition.
	(fhandler_socket::recv_internal): Fix MSG_PEEK bug on blocking sockets
	and simplify recv loop.
	(fhandler_socket::send_internal): Only lock when changing wsock_events.
@
text
@d1163 2
a1164 1
  while (!(res = wait_for_events (evt_mask | FD_CLOSE)))
@


1.196
log
@	* fhandler.h (struct wsa_event): Define here.
	(class fhandler_socket): Make wsock_evt private again.
	(fhandler_socket::wsock_event): New read accessor for wsock_evt.
	(fhandler_socket::serial_number): New read accessor to get the
	socket's serial number.
	(fhandler_socket::ready_for_read): Just return true.
	* fhandler_socket.cc (struct wsa_event): Move definition to fhandler.h.
	* select.cc (struct socketinf): Add serial number vector.
	(start_thread_socket): Identify duplicate sockets by their serial
	number, not (wrongly) by their wsock_evt.
@
text
@d497 1
d506 1
d516 2
a517 1
  if ((events = (wsock_events->events & event_mask)) != 0)
d1160 4
a1163 1
  if (flags & MSG_PEEK)
a1164 1
      LOCK_EVENTS;
d1167 2
a1168 16
      wsock_events->events &= ~evt_mask;
      UNLOCK_EVENTS;
    }
  else
    {
      do
        {
	  LOCK_EVENTS;
	  res = WSARecvFrom (get_socket (), wsabuf, wsacnt, &ret,
			     &flags, from, fromlen, NULL, NULL);
	  wsock_events->events &= ~evt_mask;
	  UNLOCK_EVENTS;
	}
      while (res && WSAGetLastError () == WSAEWOULDBLOCK
	     && !(res = wait_for_events (evt_mask | FD_CLOSE)))
	;
a1260 1
      LOCK_EVENTS;
d1264 5
a1268 2
        wsock_events->events &= ~FD_WRITE;
      UNLOCK_EVENTS;
@


1.195
log
@	* fhandler_socket.cc: Revert misguided attempt to handle FD_CLOSE error
	conditions in evaluate_events.
	(search_wsa_event_slot): Move wrongly placed memset in
	fhandler_socket::init_events here.
	(fhandler_socket::init_events): Initially set FD_WRITE event for
	connectionless sockets.
	* poll.cc (poll): Don't add sockets always to except_fds since select
	is now supposed to do it right.
	* select.cc (set_bits): Set connection state correctly for failed
	af_local_connect on local sockets.  Remove socket special handling
	for except_selected descriptors.
	(peek_socket): Try to set the read/write/exception bits actually
	correctly.
@
text
@a384 8
struct wsa_event
{
  LONG serial_number;
  long events;
  int  connect_errorcode;
  pid_t owner;
};

@


1.194
log
@	* fhandler_socket.cc (fhandler_socket::recvmsg): Remove unused tot
	argument.  All callers changed.
	(fhandler_socket::sendmsg): Likewise.
	* net.cc (cygwin_recvmsg): Likewise.
	(cygwin_sendmsg): Likewise, and prevent calling sendmsg whith an
	invalid iovec.
	* fhandler.h (fhandler_socket::recvmsg): Adjust prototype.
	(fhandler_socket::sendmsg): Likewise.
@
text
@d389 1
a389 1
  int  errorcode;
d446 1
d494 3
a496 1
  memset (wsock_events, 0, sizeof *wsock_events);
d514 1
a514 3
	    wsock_events->errorcode = evts.iErrorCode[FD_CONNECT_BIT];
	  else if (evts.lNetworkEvents & FD_CLOSE)
	    wsock_events->errorcode = evts.iErrorCode[FD_CLOSE_BIT];
d524 1
a524 1
      if (events & (FD_CONNECT | FD_CLOSE))
d527 1
a527 1
	  if ((wsa_err = wsock_events->errorcode) != 0)
d532 4
a535 8
	  if (events & FD_CONNECT)
	    {
	      if (!wsock_events->errorcode)
	        wsock_events->events |= FD_WRITE;
	      wsock_events->events &= ~FD_CONNECT;
	    }
	  if (!(events & FD_CLOSE))
	    wsock_events->errorcode = 0;
@


1.193
log
@	* fhandler.h (class fhandler_socket): Remove prot_info_ptr.
	(fhandler_socket::fixup_before_fork_exec): Remove.
	(fhandler_socket::fixup_after_exec): Remove.
	(fhandler_socket::need_fixup_before): Remove.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Drop
	initializing prot_info_ptr.  Remove unused code.
	(fhandler_socket::~fhandler_socket): Drop free'ing prot_info_ptr.
	(struct wsa_event): Rename connect_errorcode to errorcode.
	(fhandler_socket::evaluate_events): Handle FD_CLOSE error condition
	as FD_CONNECT error condition, except, never reset an FD_CLOSE error
	condition.  Always set FD_WRITE after successfully recorded FD_CONNECT.
	(fhandler_socket::fixup_before_fork_exec): Remove.
	(fhandler_socket::fixup_after_fork): Revert to using handle duplication.
	(fhandler_socket::fixup_after_exec): Remove.
	(fhandler_socket::dup): Revert to using handle duplication.
	(fhandler_socket::send_internal): Only call wait_for_events in case
	of WSAEWOULDBLOCK condition.
	(fhandler_socket::set_close_on_exec): Call
	fhandler_base::set_close_on_exec.
	* net.cc (fdsock): Just set socket to inheritable on non-NT.  Don't
	call inc_need_fixup_before.
	* select.cc (peek_socket): Don't set except_ready on every FD_CLOSE,
	just on error.
@
text
@d1156 1
a1156 1
  return recvmsg (&msg, 0, tot);
d1220 1
a1220 1
fhandler_socket::recvmsg (struct msghdr *msg, int flags, ssize_t tot)
d1269 1
a1269 1
  return sendmsg (&msg, 0, tot);
d1327 1
a1327 1
fhandler_socket::sendmsg (const struct msghdr *msg, int flags, ssize_t tot)
@


1.192
log
@2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h: Bump DLL version to 1.7.0.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.

2006-07-18  Brian Ford  <Brian.Ford@@FlightSafety.com>
	    Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.

2006-07-18  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din (posix_openpt): Export.
	* tty.cc (posix_openpt): New function.
	* include/cygwin/stdlib.h (posix_openpt): Declare.
	* include/cygwin/version.h: Bump API minor number.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netinet/in.h: Update copyright.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netdb.h: Declare rcmd, rcmd_af, rexec, rresvport,
	rresvport_af, iruserok, iruserok_sa, ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.

2006-07-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.

2006-07-10  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.

2006-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/in6.h (struct in6_addr): Fix typo.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@a138 10
  prot_info_ptr = (LPWSAPROTOCOL_INFOA) cmalloc (HEAP_BUF,
						 sizeof (WSAPROTOCOL_INFOA));
#if 0
  if (pc.is_fs_special ())
    {
      fhandler_socket * fhs = (fhandler_socket *) fh;
      fhs->set_addr_family (AF_LOCAL);
      fhs->set_sun_path (posix_path);
    }
#endif
a142 2
  if (prot_info_ptr)
    cfree (prot_info_ptr);
d389 1
a389 1
  int  connect_errorcode;
d511 3
a513 1
	    wsock_events->connect_errorcode = evts.iErrorCode[FD_CONNECT_BIT];
d523 1
a523 1
      if (events & FD_CONNECT)
d526 1
a526 1
	  if ((wsa_err = wsock_events->connect_errorcode) != 0)
d531 8
a538 2
	  wsock_events->connect_errorcode = 0;
	  wsock_events->events &= ~FD_CONNECT;
a597 14
fhandler_socket::fixup_before_fork_exec (DWORD win_proc_id)
{
  if (!WSADuplicateSocketA (get_socket (), win_proc_id, prot_info_ptr))
    debug_printf ("WSADuplicateSocket went fine, sock %p, win_proc_id %d, prot_info_ptr %p",
		  get_socket (), win_proc_id, prot_info_ptr);
  else
    {
      debug_printf ("WSADuplicateSocket error, sock %p, win_proc_id %d, prot_info_ptr %p",
		    get_socket (), win_proc_id, prot_info_ptr);
      set_winsock_errno ();
    }
}

void
d600 3
a602 40
  SOCKET new_sock;

  debug_printf ("WSASocket begin, dwServiceFlags1=%d",
		prot_info_ptr->dwServiceFlags1);

  if ((new_sock = WSASocketA (FROM_PROTOCOL_INFO,
				   FROM_PROTOCOL_INFO,
				   FROM_PROTOCOL_INFO,
				   prot_info_ptr, 0, 0)) == INVALID_SOCKET)
    {
      debug_printf ("WSASocket error");
      set_io_handle ((HANDLE)INVALID_SOCKET);
      set_winsock_errno ();
    }
  else
    {
      debug_printf ("WSASocket went fine new_sock %p, old_sock %p", new_sock, get_socket ());

      /* Go figure!  Even though the original socket was not inheritable,
	 the duplicated socket is inheritable again.  This can lead to all
	 sorts of trouble, apparently.  Note that there's no way to prevent
	 this on 9x, not even by trying to reset socket inheritance using
	 DuplicateHandle and closing the original socket. */
      if (wincap.has_set_handle_information ())
	SetHandleInformation ((HANDLE) new_sock, HANDLE_FLAG_INHERIT, 0);

      set_io_handle ((HANDLE) new_sock);
    }
  if (parent)	/* fork, not exec or dup */
    {
      fork_fixup (parent, wsock_mtx, "wsock_mtx");
      fork_fixup (parent, wsock_evt, "wsock_evt");
    }
}

void
fhandler_socket::fixup_after_exec ()
{
  if (!close_on_exec ())
    fixup_after_fork (NULL);
a607 2
  HANDLE nh;

a613 1
      system_printf ("DuplicateHandle(%x) failed, %E", wsock_mtx);
a619 1
      system_printf ("DuplicateHandle(%x) failed, %E", wsock_evt);
d642 2
a643 31

  /* Since WSADuplicateSocket() fails on NT systems when the process
     is currently impersonating a non-privileged account, we revert
     to the original account before calling WSADuplicateSocket() and
     switch back afterwards as it's also in fork().
     If WSADuplicateSocket() still fails for some reason, we fall back
     to DuplicateHandle(). */
  WSASetLastError (0);
  cygheap->user.deimpersonate ();
  fhs->set_io_handle (get_io_handle ());
  fhs->fixup_before_fork_exec (GetCurrentProcessId ());
  cygheap->user.reimpersonate ();
  if (!WSAGetLastError ())
    {
      /* Call with NULL parent, otherwise wsock_mtx and wsock_evt are
         duplicated again with wrong close_on_exec settings. */
      fhs->fixup_after_fork (NULL);
      if (fhs->get_io_handle() != (HANDLE) INVALID_SOCKET)
	{
	  cygheap->fdtab.inc_need_fixup_before ();
	  return 0;
	}
    }
  debug_printf ("WSADuplicateSocket failed, trying DuplicateHandle");

  /* We don't call fhandler_base::dup here since that requires
     having winsock called from fhandler_base and it creates only
     inheritable sockets which is wrong for winsock2. */

  if (!DuplicateHandle (hMainProc, get_io_handle (), hMainProc, &nh, 0,
			FALSE, DUPLICATE_SAME_ACCESS))
a644 2
      system_printf ("DuplicateHandle(%x) failed, %E", get_io_handle ());
      __seterrno ();
a646 1
      return -1;
d648 1
a648 4
  VerifyHandle (nh);
  fhs->set_io_handle (nh);
  cygheap->fdtab.inc_need_fixup_before ();
  return 0;
d1288 2
a1289 1
  while (res && err && !(res = wait_for_events (FD_WRITE | FD_CLOSE)));
d1592 1
a1592 1
  close_on_exec (val);
@


1.191
log
@	* fhandler_socket.cc: Update copyright.
	* include/pthread.h: Ditto.
@
text
@d33 1
a35 1
#include "select.h"
d40 1
d43 1
d55 1
a55 1
	       struct sockaddr_in *out, int *outlen,
d61 1
a61 1
  if (in->sa_family == AF_INET)
d63 1
a63 1
      *out = * (struct sockaddr_in *)in;
d107 1
a107 1
	  *out = sin;
d132 3
d186 5
a190 4
  if (async || nonblocking)
  WSAAsyncSelect (get_socket (), winmsg, 0, 0);
  unsigned long p = 0;
  ioctlsocket (get_socket (), FIONBIO, &p);
d199 1
a199 5
    {
      unsigned long p = 1;
      ioctlsocket (get_socket (), FIONBIO, &p);
      set_nonblocking (true);
    }
d397 204
d646 5
d667 18
d715 3
a717 1
      fhs->fixup_after_fork (hMainProc);
d733 1
a733 1
      system_printf ("!DuplicateHandle(%x) failed, %E", get_io_handle ());
d735 2
d975 1
a975 1
  struct sockaddr_in sin;
d979 1
a979 1
  if (!get_inet_addr (name, namelen, &sin, &namelen, &type, connect_secret))
d989 5
a993 1
  res = ::connect (get_socket (), (struct sockaddr *) &sin, namelen);
d1044 1
a1044 1
  if (res && WSAGetLastError () == WSAEINVAL && get_addr_family () == AF_INET)
d1051 22
a1072 6
      struct sockaddr_in sa;
      sa.sin_family = AF_INET;
      sa.sin_port = 0;
      sa.sin_addr.s_addr = INADDR_ANY;
      if (!::bind (get_socket (), (struct sockaddr *) &sa, sizeof sa))
	res = ::listen (get_socket (), backlog);
d1079 1
a1088 2
  int res = -1;

a1106 1
  res = ::accept (get_socket (), peer, len);
d1108 5
d1143 3
d1190 30
a1219 1
	set_winsock_errno ();
a1234 133
bool
fhandler_socket::prepare (HANDLE &event, long event_mask)
{
  WSASetLastError (0);
  closed (false);
  if ((event = WSACreateEvent ()) == WSA_INVALID_EVENT)
    {
      debug_printf ("WSACreateEvent, %E");
      return false;
    }
  if (WSAEventSelect (get_socket (), event, event_mask) == SOCKET_ERROR)
    {
      debug_printf ("WSAEventSelect(evt), %d", WSAGetLastError ());
      return false;
    }
  return true;
}

int
fhandler_socket::wait (HANDLE event, int flags, DWORD timeout)
{
  int ret = SOCKET_ERROR;
  int wsa_err = 0;
  WSAEVENT ev[2] = { event, signal_arrived };
  WSANETWORKEVENTS evts;

#if 0	/* Not yet.  Not this way. */
/* If WSAWaitForMultipleEvents is interrupted by a signal, and the signal
   has the SA_RESTART flag set, return to this label and... restart. */
sa_restart:
#endif

  switch (WSAWaitForMultipleEvents (2, ev, FALSE, timeout, FALSE))
    {
      case WSA_WAIT_TIMEOUT:
	ret = 0;
	break;
      case WSA_WAIT_EVENT_0:
	if (!WSAEnumNetworkEvents (get_socket (), event, &evts))
	  {
	    if (!evts.lNetworkEvents)
	      {
		ret = 0;
		break;
	      }
	    if (evts.lNetworkEvents & FD_OOB)
	      {
		if (evts.iErrorCode[FD_OOB_BIT])
		  wsa_err = evts.iErrorCode[FD_OOB_BIT];
		else if (flags & MSG_OOB)
		  ret = 0;
		else
		  {
		    raise (SIGURG);
		    WSASetLastError (WSAEINTR);
		    break;
		  }
	      }
	    if (evts.lNetworkEvents & FD_ACCEPT)
	      {
		if (evts.iErrorCode[FD_ACCEPT_BIT])
		  wsa_err = evts.iErrorCode[FD_ACCEPT_BIT];
		else
		  ret = 0;
	      }
	    if (evts.lNetworkEvents & FD_CONNECT)
	      {
		if (evts.iErrorCode[FD_CONNECT_BIT])
		  wsa_err = evts.iErrorCode[FD_CONNECT_BIT];
		else
		  ret = 0;
	      }
	    else if (evts.lNetworkEvents & FD_READ)
	      {
		if (evts.iErrorCode[FD_READ_BIT])
		  wsa_err = evts.iErrorCode[FD_READ_BIT];
		else
		  ret = 0;
	      }
	    else if (evts.lNetworkEvents & FD_WRITE)
	      {
		if (evts.iErrorCode[FD_WRITE_BIT])
		  wsa_err = evts.iErrorCode[FD_WRITE_BIT];
		else
		  ret = 0;
	      }
	    if (evts.lNetworkEvents & FD_CLOSE)
	      {
		closed (true);
		if (!wsa_err)
		  {
		    if (evts.iErrorCode[FD_CLOSE_BIT])
		      wsa_err = evts.iErrorCode[FD_CLOSE_BIT];
		    else
		      ret = 0;
		  }
	      }
	    if (wsa_err)
	      WSASetLastError (wsa_err);
	  }
	break;
      case WSA_WAIT_EVENT_0 + 1:
#if 0	/* Not yet.  Not this way. */
	if (_my_tls.call_signal_handler ())
	  {
	    sig_dispatch_pending ();
	    goto sa_restart;
	  }
#endif
	WSASetLastError (WSAEINTR);
	break;
      default:
	WSASetLastError (WSAEFAULT);
	break;
    }
  return ret;
}

void
fhandler_socket::release (HANDLE event)
{
  int last_err = WSAGetLastError ();
  /* KB 168349: NT4 fails if the event parameter is not NULL. */
  if (WSAEventSelect (get_socket (), NULL, 0) == SOCKET_ERROR)
    debug_printf ("WSAEventSelect(NULL), %d", WSAGetLastError ());
  WSACloseEvent (event);
  unsigned long non_block = 0;
  if (ioctlsocket (get_socket (), FIONBIO, &non_block))
    debug_printf ("return to blocking failed: %d", WSAGetLastError ());
  else
    WSASetLastError (last_err);
}

d1253 3
a1255 3
int
fhandler_socket::recvfrom (void *ptr, size_t len, int flags,
			   struct sockaddr *from, int *fromlen)
d1257 1
a1257 1
  int res = SOCKET_ERROR;
d1259 1
d1261 2
a1262 3
  WSABUF wsabuf = { len, (char *) ptr };

  if (is_nonblocking () || closed () || async_io ())
d1264 5
a1268 3
      DWORD lflags = (DWORD) (flags & MSG_WINMASK);
      res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret,
			 &lflags, from, fromlen, NULL, NULL);
d1272 11
a1282 15
      HANDLE evt;
      if (prepare (evt, FD_CLOSE | FD_READ | (owner () ? FD_OOB : 0)))
	{
	  do
	    {
	      DWORD lflags = (DWORD) (flags & MSG_WINMASK);
	      res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret, &lflags,
				 from, fromlen, NULL, NULL);
	    }
	  while (res == SOCKET_ERROR
		 && WSAGetLastError () == WSAEWOULDBLOCK
		 && !closed ()
		 && !(res = wait (evt, flags)));
	  release (evt);
	}
d1290 1
a1290 1
	return len;
d1306 8
d1333 4
a1336 14
  struct iovec *const iov = msg->msg_iov;
  const int iovcnt = msg->msg_iovlen;

  struct sockaddr *from = (struct sockaddr *) msg->msg_name;
  int *fromlen = from ? &msg->msg_namelen : NULL;

  int res = SOCKET_ERROR;

  WSABUF wsabuf[iovcnt];
  unsigned long len = 0L;

  const struct iovec *iovptr = iov + iovcnt;
  WSABUF *wsaptr = wsabuf + iovcnt;
  do
d1338 1
a1338 3
      iovptr -= 1;
      wsaptr -= 1;
      len += wsaptr->len = iovptr->iov_len;
a1340 1
  while (wsaptr != wsabuf);
d1342 2
a1343 33
  DWORD ret = 0;

  if (is_nonblocking () || closed () || async_io ())
    {
      DWORD lflags = (DWORD) (flags & MSG_WINMASK);
      res = WSARecvFrom (get_socket (), wsabuf, iovcnt, &ret,
			 &lflags, from, fromlen, NULL, NULL);
    }
  else
    {
      HANDLE evt;
      if (prepare (evt, FD_CLOSE | FD_READ | (owner () ? FD_OOB : 0)))
	{
	  do
	    {
	      DWORD lflags = (DWORD) (flags & MSG_WINMASK);
	      res = WSARecvFrom (get_socket (), wsabuf, iovcnt, &ret,
				 &lflags, from, fromlen, NULL, NULL);
	    }
	  while (res == SOCKET_ERROR
		 && WSAGetLastError () == WSAEWOULDBLOCK
		 && !closed ()
		 && !(res = wait (evt, flags)));
	  release (evt);
	}
    }

  if (res == SOCKET_ERROR)
    {
      /* According to SUSv3, errno isn't set in that case and no error
	 condition is returned. */
      if (WSAGetLastError () == WSAEMSGSIZE)
	return len;
d1345 1
a1345 11
      /* ESHUTDOWN isn't defined for recv in SUSv3.  Simply EOF is returned
	 in this case. */
      if (WSAGetLastError () == WSAESHUTDOWN)
	return 0;

      set_winsock_errno ();
    }
  else
    res = ret;

  return res;
d1366 3
a1368 3
int
fhandler_socket::sendto (const void *ptr, size_t len, int flags,
			 const struct sockaddr *to, int tolen)
d1370 2
a1371 1
  struct sockaddr_in sin;
d1373 1
a1373 14
  if (to && !get_inet_addr (to, tolen, &sin, &tolen))
    return SOCKET_ERROR;

  int res = SOCKET_ERROR;
  DWORD ret = 0;

  WSABUF wsabuf = { len, (char *) ptr };

  if (is_nonblocking () || closed () || async_io ())
    res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
		     flags & MSG_WINMASK,
		     (to ? (const struct sockaddr *) &sin : NULL), tolen,
		     NULL, NULL);
  else
d1375 6
a1380 16
      HANDLE evt;
      if (prepare (evt, FD_CLOSE | FD_WRITE | (owner () ? FD_OOB : 0)))
	{
	  do
	    {
	      res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
			       flags & MSG_WINMASK,
			       (to ? (const struct sockaddr *) &sin : NULL),
			       tolen, NULL, NULL);
	    }
	  while (res == SOCKET_ERROR
		 && WSAGetLastError () == WSAEWOULDBLOCK
		 && !(res = wait (evt, 0))
		 && !closed ());
	  release (evt);
	}
d1382 1
d1405 14
d1431 4
a1434 10
  struct iovec *const iov = msg->msg_iov;
  const int iovcnt = msg->msg_iovlen;

  int res = SOCKET_ERROR;

  WSABUF wsabuf[iovcnt];

  const struct iovec *iovptr = iov + iovcnt;
  WSABUF *wsaptr = wsabuf + iovcnt;
  do
d1436 1
a1436 3
      iovptr -= 1;
      wsaptr -= 1;
      wsaptr->len = iovptr->iov_len;
a1438 45
  while (wsaptr != wsabuf);

  DWORD ret = 0;

  if (is_nonblocking () || closed () || async_io ())
    res = WSASendTo (get_socket (), wsabuf, iovcnt, &ret,
		     flags & MSG_WINMASK, (struct sockaddr *) msg->msg_name,
		     msg->msg_namelen, NULL, NULL);
  else
    {
      HANDLE evt;
      if (prepare (evt, FD_CLOSE | FD_WRITE | (owner () ? FD_OOB : 0)))
	{
	  do
	    {
	      res = WSASendTo (get_socket (), wsabuf, iovcnt,
			       &ret, flags & MSG_WINMASK,
			       (struct sockaddr *) msg->msg_name,
			       msg->msg_namelen, NULL, NULL);
	    }
	  while (res == SOCKET_ERROR
		 && WSAGetLastError () == WSAEWOULDBLOCK
		 && !(res = wait (evt, 0))
		 && !closed ());
	  release (evt);
	}
    }

  if (res == SOCKET_ERROR)
    set_winsock_errno ();
  else
    res = ret;

  /* Special handling for EPIPE and SIGPIPE.

     EPIPE is generated if the local end has been shut down on a connection
     oriented socket.  In this case the process will also receive a SIGPIPE
     unless MSG_NOSIGNAL is set.  */
  if (res == SOCKET_ERROR && get_errno () == ESHUTDOWN
      && get_socket_type () == SOCK_STREAM)
    {
      set_errno (EPIPE);
      if (! (flags & MSG_NOSIGNAL))
	raise (SIGPIPE);
    }
d1440 2
a1441 1
  return res;
d1482 1
d1611 3
d1621 2
a1622 13
      /* We must cancel WSAAsyncSelect (if any) before setting socket to
       * blocking mode
       */
      if (cmd == FIONBIO && *(int *) p == 0)
	{
	  if (async_io ())
	    WSAAsyncSelect (get_socket (), winmsg, 0, 0);
	  if (WSAEventSelect (get_socket (), NULL, 0) == SOCKET_ERROR)
	    debug_printf ("WSAEventSelect(NULL), %d", WSAGetLastError ());
	}
      res = ioctlsocket (get_socket (), cmd, (unsigned long *) p);
      if (res == SOCKET_ERROR)
	  set_winsock_errno ();
d1625 7
a1631 10
	  if (!res)
	    {
	      syscall_printf ("socket is now %sblocking",
				*(int *) p ? "non" : "");
	      set_nonblocking (*(int *) p);
	    }
	  /* Start AsyncSelect if async socket unblocked */
	  if (*(int *) p && async_io ())
	    WSAAsyncSelect (get_socket (), winmsg, WM_ASYNCIO, ASYNC_MASK);
	}
a1647 1
	/* Urgh!  Bad hack! */
d1649 4
a1652 2
	owner (pid == getpid ());
	debug_printf ("owner set to %d", owner ());
d1655 3
d1683 2
@


1.191.2.1
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@a49 12
static inline mode_t
adjust_socket_file_mode (mode_t mode)
{
  /* Kludge: Don't allow to remove read bit on socket files for
     user/group/other, if the accompanying write bit is set.  It would
     be nice to have exact permissions on a socket file, but it's
     necessary that somebody able to access the socket can always read
     the contents of the socket file to avoid spurious "permission
     denied" messages. */
  return mode | ((mode & (S_IWUSR | S_IWGRP | S_IWOTH)) << 1);
}

d544 1
a544 1
      int ret = fh.fchmod (adjust_socket_file_mode (mode));
d628 1
a628 1
	  syscall_printf ("AF_LOCAL: bind failed");
d634 1
a634 1
	  syscall_printf ("AF_LOCAL: getsockname failed");
d653 1
a653 2
      mode_t mode = adjust_socket_file_mode ((S_IRWXU | S_IRWXG | S_IRWXO)
					     & ~cygheap->umask);
@


1.190
log
@	* fhandler_socket.cc (fhandler_socket::wait): Disable SA_RESTART
	handling for now.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
@


1.189
log
@	* fhandler_socket.cc (fhandler_socket::listen): Allow listening on
	unbound INET socket.
@
text
@d973 1
d977 1
d1049 1
d1055 1
@


1.189.2.1
log
@	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.
@
text
@a39 1
#include "cygwin/in6.h"
d53 1
a53 1
	       struct sockaddr_storage *out, int *outlen,
d59 1
a59 1
  if (in->sa_family == AF_INET || in->sa_family == AF_INET6)
d61 1
a61 1
      memcpy (out, in, inlen);
d105 1
a105 1
	  memcpy (out, &sin, sizeof sin);
d742 1
a742 1
  struct sockaddr_storage sst;
d746 1
a746 1
  if (!get_inet_addr (name, namelen, &sst, &namelen, &type, connect_secret))
d756 1
a756 1
  res = ::connect (get_socket (), (struct sockaddr *) &sst, namelen);
d807 1
a807 1
  if (res && WSAGetLastError () == WSAEINVAL)
d814 6
a819 22
      if (get_addr_family () == AF_INET)
        {
	  struct sockaddr_in sin;
	  sin.sin_family = AF_INET;
	  sin.sin_port = 0;
	  sin.sin_addr.s_addr = INADDR_ANY;
	  if (!::bind (get_socket (), (struct sockaddr *) &sin, sizeof sin))
	    res = ::listen (get_socket (), backlog);
	}
      else if (get_addr_family () == AF_INET6)
        {
	  struct sockaddr_in6 sin6 = 
	    {
	      sin6_family: AF_INET6,
	      sin6_port: 0,
	      sin6_flowinfo: 0,
	      sin6_addr: IN6ADDR_ANY_INIT,
	      sin6_scope_id: 0
	    };
	  if (!::bind (get_socket (), (struct sockaddr *) &sin6, sizeof sin6))
	    res = ::listen (get_socket (), backlog);
	}
d1259 1
a1259 1
  struct sockaddr_storage sst;
d1261 1
a1261 1
  if (to && !get_inet_addr (to, tolen, &sst, &tolen))
d1272 1
a1272 1
		     (to ? (const struct sockaddr *) &sst : NULL), tolen,
d1283 1
a1283 1
			       (to ? (const struct sockaddr *) &sst : NULL),
@


1.189.2.2
log
@	* Merge HEAD into cv-branch.

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.
@
text
@a32 1
#include "shared_info.h"
a42 1
#define EVENT_MASK (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT|FD_CLOSE)
a130 3
  wsock_mtx (NULL),
  wsock_evt (NULL),
  wsock_events (NULL),
d182 4
a185 5
  if (async)
    {
      WSAAsyncSelect (get_socket (), winmsg, 0, 0);
      WSAEventSelect (get_socket (), wsock_evt, EVENT_MASK);
    }
d194 5
a198 1
    set_nonblocking (true);
a395 214
struct wsa_event
{
  LONG serial_number;
  long events;
  int  connect_errorcode;
};

/* Maximum number of concurrently opened sockets from all Cygwin processes
   on a machine.  Note that shared sockets (through dup/fork/exec) are
   counted as one socket. */
#define NUM_SOCKS	(65536 / sizeof (wsa_event))

static wsa_event wsa_events[NUM_SOCKS] __attribute__((section (".cygwin_dll_common"), shared)) = { 0 };

static LONG socket_serial_number __attribute__((section (".cygwin_dll_common"), shared)) = 0;

static HANDLE wsa_slot_mtx;

static wsa_event *
search_wsa_event_slot (LONG new_serial_number)
{
  char name[CYG_MAX_PATH], searchname[CYG_MAX_PATH];

  if (!wsa_slot_mtx)
    {
      wsa_slot_mtx = CreateMutex (&sec_all, FALSE,
      				  shared_name (name, "sock", 0));
      if (!wsa_slot_mtx)
	api_fatal ("Couldn't create/open shared socket mutex, %E");
    }
  switch (WaitForSingleObject (wsa_slot_mtx, INFINITE))
    {
    case WAIT_OBJECT_0:
    case WAIT_ABANDONED:
      break;
    default:
      api_fatal ("WFSO failed for shared socket mutex, %E");
      break;
    }
  unsigned int slot = new_serial_number % NUM_SOCKS;
  while (wsa_events[slot].serial_number)
    {
      HANDLE searchmtx = OpenMutex (STANDARD_RIGHTS_READ, FALSE,
	    shared_name (searchname, "sock", wsa_events[slot].serial_number));
      if (!searchmtx)
        break;
      /* Mutex still exists, attached socket is active, try next slot. */
      CloseHandle (searchmtx);
      slot = (slot + 1) % NUM_SOCKS;
      if (slot == (new_serial_number % NUM_SOCKS))
        {
	  /* Did the whole array once.   Too bad. */
	  debug_printf ("No free socket slot");
	  ReleaseMutex (wsa_slot_mtx);
	  return NULL;
	}
    }
  wsa_events[slot].serial_number = new_serial_number;
  ReleaseMutex (wsa_slot_mtx);
  return wsa_events + slot;
}

bool
fhandler_socket::prepare ()
{
  LONG new_serial_number;
  char name[CYG_MAX_PATH];
  DWORD err = 0;

  do
    {
      new_serial_number = InterlockedIncrement (&socket_serial_number);
      if (!new_serial_number)	/* 0 is reserved for global mutex */
	InterlockedIncrement (&socket_serial_number);
      wsock_mtx = CreateMutex (&sec_all, FALSE,
			       shared_name (name, "sock", new_serial_number));
      if (!wsock_mtx)
	{
	  debug_printf ("CreateMutex, %E");
	  set_errno (ENOBUFS);
	  return false;
	}
      err = GetLastError ();
      if (err == ERROR_ALREADY_EXISTS)
        CloseHandle (wsock_mtx);
    }
  while (err == ERROR_ALREADY_EXISTS);
  if ((wsock_evt = CreateEvent (&sec_all, TRUE, FALSE, NULL))
      == WSA_INVALID_EVENT)
    {
      debug_printf ("WSACreateEvent, %E");
      set_errno (ENOBUFS);
      CloseHandle (wsock_mtx);
      return false;
    }
  if (WSAEventSelect (get_socket (), wsock_evt, EVENT_MASK) == SOCKET_ERROR)
    {
      debug_printf ("WSAEventSelect, %E");
      set_winsock_errno ();
      CloseHandle (wsock_evt);
      CloseHandle (wsock_mtx);
      return false;
    }
  wsock_events = search_wsa_event_slot (new_serial_number);
  memset (wsock_events, 0, sizeof *wsock_events);
  return true;
}

int
fhandler_socket::wait (long event_mask)
{
  int ret = SOCKET_ERROR;
  int wsa_err = 0;
  DWORD timeout = (is_nonblocking () ? 0 : INFINITE); 
  long events;

  if (async_io ())
    return 0;

  WaitForSingleObject (wsock_mtx, INFINITE);
  WSAEVENT ev[2] = { wsock_evt, signal_arrived };

sa_rerun:

  if ((events = (wsock_events->events & event_mask)) != 0)
    {
      if (events & FD_CONNECT)
	{
	  wsa_err = wsock_events->connect_errorcode;
	  wsock_events->connect_errorcode = 0;
	}
      wsock_events->events &= ~(events & ~FD_CLOSE);
      if (!wsa_err)
	ret = 0;
      else
	WSASetLastError (wsa_err);
      ReleaseMutex (wsock_mtx);
      return ret;
    }
  ReleaseMutex (wsock_mtx);

/* If WSAWaitForMultipleEvents is interrupted by a signal, and the signal
   has the SA_RESTART flag set, return to this label and... restart. */
sa_restart:

  WSANETWORKEVENTS evts = { 0 };
  switch (WSAWaitForMultipleEvents (2, ev, FALSE, timeout, FALSE))
    {
      case WSA_WAIT_TIMEOUT:
	WSASetLastError (WSAEINPROGRESS);
	break;
      case WSA_WAIT_EVENT_0:
	WaitForSingleObject (wsock_mtx, INFINITE);
	if (!WSAEnumNetworkEvents (get_socket (), wsock_evt, &evts))
	  {
	    if (!evts.lNetworkEvents)
	      {
		if (timeout == INFINITE)
		  goto sa_rerun;
		ReleaseMutex (wsock_mtx);
		WSASetLastError (WSAEINPROGRESS);
		break;
	      }
	    wsock_events->events |= evts.lNetworkEvents;
	    if (evts.lNetworkEvents & FD_CONNECT)
	      wsock_events->connect_errorcode = evts.iErrorCode[FD_CONNECT_BIT];
	    if ((evts.lNetworkEvents & FD_OOB)
	    	&& !evts.iErrorCode[FD_OOB_BIT]
	    	&& owner ())
	      {
		siginfo_t si = {0};
		si.si_signo = SIGURG;
		si.si_code = SI_KERNEL;
		sig_send (myself_nowait, si);
		if (_my_tls.call_signal_handler ())
		  {
		    sig_dispatch_pending ();
		    goto sa_rerun;
		  }
		if (evts.lNetworkEvents & event_mask)
		  goto sa_rerun;
		WSASetLastError (WSAEINTR);
	      }
	    else
	      {
		if (timeout == INFINITE || (evts.lNetworkEvents & event_mask))
		  goto sa_rerun;
		WSASetLastError (WSAEINPROGRESS);
	      }
	  }
	ReleaseMutex (wsock_mtx);
	break;
      case WSA_WAIT_EVENT_0 + 1:
	if (_my_tls.call_signal_handler ())
	  {
	    sig_dispatch_pending ();
	    goto sa_restart;
	  }
	WSASetLastError (WSAEINTR);
	break;
      default:
	WSASetLastError (WSAEFAULT);
	break;
    }
  return ret;
}

void
fhandler_socket::release ()
{
  CloseHandle (wsock_evt);
  CloseHandle (wsock_mtx);
}

a447 5
  else
    {
      CloseHandle (wsock_evt);
      CloseHandle (wsock_mtx);
    }
a456 18

  if (!DuplicateHandle (hMainProc, wsock_mtx, hMainProc, &fhs->wsock_mtx, 0,
			TRUE, DUPLICATE_SAME_ACCESS))
    {
      system_printf ("DuplicateHandle(%x) failed, %E", wsock_mtx);
      __seterrno ();
      return -1;
    }
  if (!DuplicateHandle (hMainProc, wsock_evt, hMainProc, &fhs->wsock_evt, 0,
			TRUE, DUPLICATE_SAME_ACCESS))
    {
      system_printf ("DuplicateHandle(%x) failed, %E", wsock_evt);
      __seterrno ();
      CloseHandle (fhs->wsock_mtx);
      return -1;
    }
  fhs->wsock_events = wsock_events;

d503 1
a503 1
      system_printf ("DuplicateHandle(%x) failed, %E", get_io_handle ());
a504 2
      CloseHandle (fhs->wsock_evt);
      CloseHandle (fhs->wsock_mtx);
a757 4
  if (!is_nonblocking ()
      && res == SOCKET_ERROR
      && WSAGetLastError () == WSAEWOULDBLOCK)
    res = wait (FD_CONNECT | FD_CLOSE);
a842 1
      listener (true);
d852 2
d872 1
a872 5

  int res = 0;
  while (!(res = wait (FD_ACCEPT | FD_CLOSE))
	 && (res = ::accept (get_socket (), peer, len)) == WSAEWOULDBLOCK)
    ;
d964 129
d1111 3
a1113 3
inline ssize_t
fhandler_socket::recv_internal (WSABUF *wsabuf, DWORD wsacnt, DWORD flags,
				struct sockaddr *from, int *fromlen)
d1115 1
a1115 1
  ssize_t res = 0;
d1118 8
a1125 4
  flags &= MSG_WINMASK;
  if (flags & MSG_PEEK)
    res = WSARecvFrom (get_socket (), wsabuf, wsacnt, &ret,
		       &flags, from, fromlen, NULL, NULL);
d1128 15
a1142 7
      int evt_mask = FD_READ | FD_CLOSE
		     | ((flags & MSG_OOB) ? FD_OOB : 0);
      while ((res = WSARecvFrom (get_socket (), wsabuf, wsacnt, &ret,
				    &flags, from, fromlen, NULL, NULL)) == -1
	     && WSAGetLastError () == WSAEWOULDBLOCK
	     && !(res = wait (evt_mask)))
	;
d1150 1
a1150 1
	return ret;
a1165 8
fhandler_socket::recvfrom (void *ptr, size_t len, int flags,
			   struct sockaddr *from, int *fromlen)
{
  WSABUF wsabuf = { len, (char *) ptr };
  return recv_internal (&wsabuf, 1, flags, from, fromlen);
}

int
d1185 14
a1198 4
  WSABUF wsabuf[msg->msg_iovlen];
  WSABUF *wsaptr = wsabuf + msg->msg_iovlen;
  const struct iovec *iovptr = msg->msg_iov + msg->msg_iovlen;
  while (--wsaptr >= wsabuf)
d1200 3
a1202 1
      wsaptr->len = (--iovptr)->iov_len;
d1205 40
d1246 4
a1249 2
  struct sockaddr *from = (struct sockaddr *) msg->msg_name;
  int *fromlen = from ? &msg->msg_namelen : NULL;
d1251 1
a1251 1
  return recv_internal (wsabuf, msg->msg_iovlen, flags, from, fromlen);
d1272 3
a1274 3
inline ssize_t
fhandler_socket::send_internal (struct _WSABUF *wsabuf, DWORD wsacnt, int flags,
				const struct sockaddr *to, int tolen)
d1276 6
a1281 1
  int res = 0;
d1283 27
a1309 5
  while ((res = WSASendTo (get_socket (), wsabuf, wsacnt, &ret,
			   flags & MSG_WINMASK, to, tolen, NULL, NULL)) == -1
	 && WSAGetLastError () == WSAEWOULDBLOCK
	 && !(res = wait (FD_WRITE | FD_CLOSE)))
    ;
d1313 2
a1327 2
  else
    res = ret;
a1331 14
ssize_t
fhandler_socket::sendto (const void *ptr, size_t len, int flags,
			 const struct sockaddr *to, int tolen)
{
  struct sockaddr_storage sst;

  if (to && !get_inet_addr (to, tolen, &sst, &tolen))
    return SOCKET_ERROR;

  WSABUF wsabuf = { len, (char *) ptr };
  return send_internal (&wsabuf, 1, flags,
  			(to ? (const struct sockaddr *) &sst : NULL), tolen);
}

d1344 10
a1353 4
  WSABUF wsabuf[msg->msg_iovlen];
  WSABUF *wsaptr = wsabuf + msg->msg_iovlen;
  const struct iovec *iovptr = msg->msg_iov + msg->msg_iovlen;
  while (--wsaptr >= wsabuf)
d1355 3
a1357 1
      wsaptr->len = (--iovptr)->iov_len;
d1360 45
d1406 1
a1406 2
  return send_internal (wsabuf, msg->msg_iovlen, flags,
  			(struct sockaddr *) msg->msg_name, msg->msg_namelen);
a1446 1
  release ();
a1574 3
      /* If async_io is switched off, revert the event handling. */
      if (*(int *) p == 0)
        WSAEventSelect (get_socket (), wsock_evt, EVENT_MASK);
d1582 13
a1594 2
      /* Sockets are always non-blocking internally.  So we just note the
         state here. */
d1597 10
a1606 7
	  syscall_printf ("socket is now %sblocking",
			    *(int *) p ? "non" : "");
	  set_nonblocking (*(int *) p);
	  res = 0;
        }
      else
	res = ioctlsocket (get_socket (), cmd, (unsigned long *) p);
@


1.189.2.3
log
@	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.
@
text
@a656 5
  if (parent)	/* fork, not exec or dup */
    {
      fork_fixup (parent, wsock_mtx, "wsock_mtx");
      fork_fixup (parent, wsock_evt, "wsock_evt");
    }
d664 5
d726 1
a726 3
      /* Call with NULL parent, otherwise wsock_mtx and wsock_evt are
         duplicated again with wrong close_on_exec settings. */
      fhs->fixup_after_fork (NULL);
a1639 2
  set_no_inheritance (wsock_mtx, val);
  set_no_inheritance (wsock_evt, val);
@


1.189.2.4
log
@	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.
@
text
@d1198 1
a1198 30
        {
	  if (WSAGetLastError () == WSAEINVAL)
	    {
	      /* Winsock returns WSAEINVAL if the socket is locally
		 unbound.  Per SUSv3 this is not an error condition.
		 We're faking a valid return value here by creating the
		 same content in the sockaddr structure as on Linux. */
	      switch (get_addr_family ())
	        {
		case AF_INET:
		  res = 0;
		  *namelen = sizeof (struct sockaddr_in);
		  break;
		case AF_INET6:
		  res = 0;
		  *namelen = sizeof (struct sockaddr_in6);
		  break;
		default:
		  WSASetLastError (WSAEOPNOTSUPP);
		  break;
		}
	      if (!res)
	        {
		  memset (name, 0, *namelen);
		  name->sa_family = get_addr_family ();
		}
	    }
	  if (res)
	    set_winsock_errno ();
	}
@


1.189.2.5
log
@	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.
@
text
@d509 5
d517 2
a518 2
  int ret = SOCKET_ERROR;
  long events;
d520 1
a520 3
/* If WSAWaitForMultipleEvents is interrupted by a signal, and the signal
   has the SA_RESTART flag set, return to this label and... restart. */
sa_restart:
a521 31
  WSANETWORKEVENTS evts = { 0 };
  if (!(WSAEnumNetworkEvents (get_socket (), wsock_evt, &evts)))
    {
      if (evts.lNetworkEvents)
        {
	  WaitForSingleObject (wsock_mtx, INFINITE);
	  wsock_events->events |= evts.lNetworkEvents;
	  if (evts.lNetworkEvents & FD_CONNECT)
	    wsock_events->connect_errorcode = evts.iErrorCode[FD_CONNECT_BIT];
	  events = (wsock_events->events & event_mask);
	  ReleaseMutex (wsock_mtx);
	  if ((evts.lNetworkEvents & FD_OOB)
	      && !evts.iErrorCode[FD_OOB_BIT]
	      && owner ())
	    {
	      siginfo_t si = {0};
	      si.si_signo = SIGURG;
	      si.si_code = SI_KERNEL;
	      sig_send (myself_nowait, si);
	      if (!_my_tls.call_signal_handler () && !events)
	        {
		  WSASetLastError (WSAEINTR);
		  return SOCKET_ERROR;
		}
	      sig_dispatch_pending ();
	      WaitForSingleObject (wsock_mtx, INFINITE);
	    }
	}
    }

  WaitForSingleObject (wsock_mtx, INFINITE);
a523 1
      ret = 0;
d526 1
a526 6
	  int wsa_err = 0;
	  if ((wsa_err = wsock_events->connect_errorcode) != 0)
	    {
	      WSASetLastError (wsa_err);
	      ret = SOCKET_ERROR;
	    }
d530 6
d539 6
a544 1
  if (!events)
d546 1
a546 1
      if (is_nonblocking ())
d548 10
a557 6
      else
	{
	  WSAEVENT ev[2] = { wsock_evt, signal_arrived };
	  switch (WSAWaitForMultipleEvents (2, ev, FALSE, INFINITE, FALSE))
	    {
	      case WSA_WAIT_TIMEOUT:
d560 12
a571 4
	      case WSA_WAIT_EVENT_0:
		goto sa_restart;
		break;
	      case WSA_WAIT_EVENT_0 + 1:
d575 1
a575 1
		    goto sa_restart;
d577 2
d580 21
a600 6
		break;
	      default:
		WSASetLastError (WSAEFAULT);
		break;
	    }
	}
a601 1

@


1.189.2.6
log
@	* include/netinet/in.h: Update copyright.
	* fhandler_socket.cc: Update copyright.
	* include/pthread.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006 Red Hat, Inc.
@


1.189.2.7
log
@	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.
@
text
@d570 1
a570 1
	WSASetLastError (WSAEWOULDBLOCK);
d577 1
a577 1
		WSASetLastError (WSAEWOULDBLOCK);
@


1.189.2.8
log
@	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.
@
text
@a402 1
  pid_t owner;
a409 3
#define LOCK_EVENTS	WaitForSingleObject (wsock_mtx, INFINITE)
#define UNLOCK_EVENTS	ReleaseMutex (wsock_mtx)

d461 1
a461 1
fhandler_socket::init_events ()
d507 1
a507 2
fhandler_socket::evaluate_events (const long event_mask, long &events,
				  bool erase)
d509 9
a517 1
  int ret = 0;
d524 1
a524 1
	  LOCK_EVENTS;
d528 18
a545 3
	  UNLOCK_EVENTS;
	  if ((evts.lNetworkEvents & FD_OOB) && wsock_events->owner)
	    kill (wsock_events->owner, SIGURG);
d549 1
a549 1
  LOCK_EVENTS;
d552 1
d563 1
a563 2
      if (erase)
	wsock_events->events &= ~(events & ~FD_CLOSE);
d565 1
a565 1
  UNLOCK_EVENTS;
d567 1
a567 13
  return ret;
}

int
fhandler_socket::wait_for_events (const long event_mask)
{
  if (async_io ())
    return 0;

  int ret;
  long events;

  while (!(ret = evaluate_events (event_mask, events, true)) && !events)
d570 2
d573 19
a591 15
	  WSASetLastError (WSAEWOULDBLOCK);
	  return SOCKET_ERROR;
	}

      WSAEVENT ev[2] = { wsock_evt, signal_arrived };
      switch (WSAWaitForMultipleEvents (2, ev, FALSE, INFINITE, FALSE))
	{
	  case WSA_WAIT_TIMEOUT:
	  case WSA_WAIT_EVENT_0:
	    break;

	  case WSA_WAIT_EVENT_0 + 1:
	    if (_my_tls.call_signal_handler ())
	      {
		sig_dispatch_pending ();
d593 1
a593 7
	      }
	    WSASetLastError (WSAEINTR);
	    return SOCKET_ERROR;

	  default:
	    WSASetLastError (WSAEFAULT);
	    return SOCKET_ERROR;
d601 1
a601 1
fhandler_socket::release_events ()
d999 1
a999 1
    res = wait_for_events (FD_CONNECT | FD_CLOSE);
d1115 1
a1115 1
  while (!(res = wait_for_events (FD_ACCEPT | FD_CLOSE))
d1274 1
a1274 1
	     && !(res = wait_for_events (evt_mask)))
d1368 1
a1368 1
	 && !(res = wait_for_events (FD_WRITE | FD_CLOSE)))
d1469 1
a1469 1
  release_events ();
d1635 1
d1637 2
a1638 4
	LOCK_EVENTS;
	wsock_events->owner = pid;
	UNLOCK_EVENTS;
	debug_printf ("owner set to %d", pid);
a1640 3
    case F_GETOWN:
      res = wsock_events->owner;
      break;
@


1.189.2.9
log
@	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.
@
text
@a132 1
  wsock_events (NULL),
d135 1
a542 1
	  wsock_events->events &= ~FD_CONNECT;
d545 1
a545 1
	wsock_events->events &= ~(events & ~(FD_WRITE | FD_CLOSE));
d570 1
a570 1
      switch (WSAWaitForMultipleEvents (2, ev, FALSE, 50, FALSE))
d1110 1
a1110 2
	 && (res = ::accept (get_socket (), peer, len)) == SOCKET_ERROR
	 && WSAGetLastError () == WSAEWOULDBLOCK)
d1112 1
a1142 3
	  /* No locking necessary at this point. */
	  sock->wsock_events->events = wsock_events->events | FD_WRITE;
	  sock->wsock_events->owner = wsock_events->owner;
a1255 1
  int evt_mask = FD_READ | ((flags & MSG_OOB) ? FD_OOB : 0);
d1259 2
a1260 7
    {
      LOCK_EVENTS;
      res = WSARecvFrom (get_socket (), wsabuf, wsacnt, &ret,
			 &flags, from, fromlen, NULL, NULL);
      wsock_events->events &= ~evt_mask;
      UNLOCK_EVENTS;
    }
d1263 6
a1268 10
      do
        {
	  LOCK_EVENTS;
	  res = WSARecvFrom (get_socket (), wsabuf, wsacnt, &ret,
			     &flags, from, fromlen, NULL, NULL);
	  wsock_events->events &= ~evt_mask;
	  UNLOCK_EVENTS;
	}
      while (res && WSAGetLastError () == WSAEWOULDBLOCK
	     && !(res = wait_for_events (evt_mask | FD_CLOSE)))
d1358 6
a1363 12
  DWORD ret = 0, err = 0;

  do
    {
      LOCK_EVENTS;
      if ((res = WSASendTo (get_socket (), wsabuf, wsacnt, &ret,
			    flags & MSG_WINMASK, to, tolen, NULL, NULL))
	  && (err = WSAGetLastError ()) == WSAEWOULDBLOCK)
        wsock_events->events &= ~FD_WRITE;
      UNLOCK_EVENTS;
    }
  while (res && err && !(res = wait_for_events (FD_WRITE | FD_CLOSE)));
a1366 2
  else
    res = ret;
d1380 2
@


1.189.2.10
log
@	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.
@
text
@d36 1
@


1.188
log
@	Revert patches from 2005-10-22 and 2006-06-14 to use event driven
	accept and connect back to using select:
	* fhandler.h (class fhandler_socket): Remove accept_mtx.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Drop
	initializing accept_mtx.
	(fhandler_socket::accept): Drop event handling.
	(fhandler_socket.cc (fhandler_socket::connect): Ditto.
	(fhandler_socket::dup): Drop accept_mtx handling.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::prepare): Ditto.
	(fhandler_socket::release): Ditto.
	(fhandler_socket::close): Ditto.
	* net.cc (cygwin_accept): Revert to calling cygwin_select to
	implement interuptible accept.
	(cygwin_connect): Ditto for connect.
@
text
@d807 15
a821 3
  if (res)
    set_winsock_errno ();
  else
d827 2
@


1.187
log
@	* fhandler.h (class fhandler_socket): Add private mutex handle
	accept_mtx.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	accept_mtx to NULL.
	(fhandler_socket::dup): Duplicate accept_mtx, if available.
	(fhandler_socket::listen): Create accept_mtx before trying to listen.
	(fhandler_socket::prepare): Wait for accept_mtx if available to
	serialize accepts on the same socket.
	(fhandler_socket::release): Release accept_mtx.
	(fhandler_socket::close): Close accept_mtx on successful closesocket.
@
text
@a129 1
  accept_mtx (NULL),
a455 1
  fhs->accept_mtx = NULL;
a471 11
  if (accept_mtx)
    {
      if (!DuplicateHandle (hMainProc, accept_mtx, hMainProc, &nh, 0,
			    TRUE, DUPLICATE_SAME_ACCESS))
	{
	  system_printf ("DuplicateHandle(%x) failed, %E", accept_mtx);
	  __seterrno ();
	  return -1;
	}
      fhs->accept_mtx = nh;
    }
d502 1
a502 1
      system_printf ("DuplicateHandle(%x) failed, %E", get_io_handle ());
a503 2
      if (fhs->accept_mtx)
        CloseHandle (fhs->accept_mtx);
d756 1
a756 14
  if (is_nonblocking ())
    res = ::connect (get_socket (), (struct sockaddr *) &sin, namelen);
  else
    {
      HANDLE evt;
      if (prepare (evt, FD_CONNECT))
	{
	  res = ::connect (get_socket (), (struct sockaddr *) &sin, namelen);
	  if (res == SOCKET_ERROR
	      && WSAGetLastError () == WSAEWOULDBLOCK)
	    res = wait (evt, 0, INFINITE);
	  release (evt);
	}
    }
a805 5
  if (!accept_mtx && !(accept_mtx = CreateMutex (&sec_all, FALSE, NULL)))
    {
      set_errno (ENOBUFS);
      return -1;
    }
d841 1
a841 15
  if (is_nonblocking ())
    res = ::accept (get_socket (), peer, len);
  else
    {
      HANDLE evt;
      if (prepare (evt, FD_ACCEPT))
	{
	  res = wait (evt, 0, INFINITE);
	  if (res != -1
	      || (WSAGetLastError () != WSAEINTR
		  && WSAGetLastError () != WSAEFAULT))
	    res = ::accept (get_socket (), peer, len);
	  release (evt);
	}
    }
a935 10
  if (event_mask == FD_ACCEPT && accept_mtx)
    {
      HANDLE obj[2] = { accept_mtx, signal_arrived };
      if (WaitForMultipleObjects (2, obj, FALSE, INFINITE) != WAIT_OBJECT_0)
	{
	  debug_printf ("signal_arrived");
	  WSASetLastError (WSAEINTR);
	  return false;
	}
    }
a1059 2
  if (accept_mtx)
    ReleaseMutex (accept_mtx);
a1431 2
  if (!res && accept_mtx)
    CloseHandle (accept_mtx);
@


1.186
log
@white space
@
text
@d130 1
d457 1
d474 11
d515 1
a515 1
      system_printf ("!DuplicateHandle(%x) failed, %E", get_io_handle ());
d517 2
d834 5
d983 10
d1117 2
d1491 2
@


1.185
log
@	* fhandler_socket.cc (fhandler_socket::wait): Reorder setting
	WSAError to avoid spurious errors with WSAError set to 0.
@
text
@d595 1
a595 1
        {
d598 1
a598 1
	    	&& entry->dwLocalPort == addr->sin_port
d691 1
a691 1
         enforce exclusive local address use using the SO_EXCLUSIVEADDRUSE
d693 1
a693 1
	 
d698 1
a698 1
        {
d711 1
a711 1
	         Per standards, we must not be able to reuse a complete
d719 2
a720 2
	      	  && address_in_use ((struct sockaddr_in *) name))
	        {
d1018 1
a1018 1
	        if (evts.iErrorCode[FD_ACCEPT_BIT])
d1025 1
a1025 1
	        if (evts.iErrorCode[FD_CONNECT_BIT])
@


1.184
log
@* fhandler_socket.cc: Move iptypes.h include after winsock2 since it now relies
on it.
* net.cc: Ditto.
@
text
@a1059 1
	WSASetLastError (WSAEINTR);
d1065 1
@


1.183
log
@	* fhandler_socket.cc (fhandler_socket::connect): Fix formatting.
	(fhandler_socket::wait): Handle SA_RESTART when signal arrives.
@
text
@a19 1
#include <iphlpapi.h>
d24 1
@


1.182
log
@	* autoload.cc  (GetTcpTable): Define.
	* fhandler_socket.cc (address_in_use): New function to check if
	sockaddr_in address is already in use.
	(fhandler_socket::bind): Check if address is alreay in use in case of
	SO_REUSEADDR, to circumvent WinSock non-standard behaviour.
@
text
@d766 1
a766 1
	     res = wait (evt, 0, INFINITE);
d986 4
d1061 5
@


1.181
log
@	* fhandler.h (class fhandler_socket): Add saw_reuseaddr status flag.
	* fhandler_socket.cc (fhandler_socket::bind): Set socket to
	SO_EXCLUSIVEADDRUSE if application didn't explicitely set SO_REUSEADDR
	socket option, on systems supporting SO_EXCLUSIVEADDRUSE.
	* net.cc (cygwin_setsockopt): Set fhandler's saw_reuseaddr status flag
	if SO_REUSEADDR socket option has been successsfully set.
	* wincap.h (wincaps::has_exclusiveaddruse): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d20 1
d584 23
d708 18
a725 1
	    debug_printf ("SO_REUSEADDR set");
@


1.180
log
@	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Reset
	inheritance for duplicated socket.
@
text
@a663 2
  else if (::bind (get_socket (), name, namelen))
    set_winsock_errno ();
d665 26
a690 1
    res = 0;
@


1.179
log
@	* fhandler_socket.cc (fhandler_socket::prepare): Fix debug output.
	(fhandler_socket::release): Add debug output for WSAEventSelect failure.
	(fhandler_socket::ioctl): Always cancel WSAEventSelect before switching
	to blocking mode.  Only set nonblocking flag if ioctlsocket call
	succeeded.  Only print new socket state if ioctlsocket call succeeded.
@
text
@d427 10
a436 1
      debug_printf ("WSASocket went fine new_sock %p, old_sock %p", new_sock, get_io_handle ());
@


1.178
log
@whitespace cleanup to force snapshot.
@
text
@d899 1
a899 1
      debug_printf ("WSAEventSelect, %E");
d997 2
a998 1
  WSAEventSelect (get_socket (), NULL, 0);
d1499 7
a1505 2
      if (cmd == FIONBIO && async_io () && *(int *) p == 0)
	WSAAsyncSelect (get_socket (), winmsg, 0, 0);
d1511 6
a1516 2
	  syscall_printf ("socket is now %sblocking",
			    *(int *) p ? "non" : "");
a1519 2

	  set_nonblocking (*(int *) p);
@


1.177
log
@	* fhandler_socket.cc (fhandler_socket::recvfrom): Mask flags with
	MSG_WINMASK for Windows socket calls.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendmsg): Ditto.
@
text
@d1066 1
a1066 1
         in this case. */
d1068 1
a1068 1
        return 0;
d1155 1
a1155 1
         in this case. */
d1157 1
a1157 1
        return 0;
@


1.176
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@a1030 1
  flags &= MSG_WINMASK;
d1034 5
a1038 2
    res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret,
		       (DWORD *) &flags, from, fromlen, NULL, NULL);
d1046 1
a1046 1
	      DWORD lflags = (DWORD) flags;
d1123 5
a1127 2
    res = WSARecvFrom (get_socket (), wsabuf, iovcnt, &ret,
		       (DWORD *) &flags, from, fromlen, NULL, NULL);
d1135 1
a1135 1
	      DWORD lflags = (DWORD) flags;
d1279 1
a1279 1
		     flags, (struct sockaddr *) msg->msg_name,
d1289 1
a1289 1
			       &ret, flags,
@


1.175
log
@	* fhandler_socket.cc (fhandler_socket::recvfrom): Just return 0 (EOF)
	in case of WSAESHUTDOWN.
	(fhandler_socket::recvmsg): Ditto.
	* poll.cc (poll): Set revents to POLLIN instead of POLLHUP. Add comment.
@
text
@a434 1
  debug_printf ("here");
@


1.174
log
@	* fhandler_socket.cc (fhandler_socket::connect): Don't restrict
	WSAEINVAL -> WSAEISCONN conversion to nonblocking sockets.
	(fhandler_socket::accept): Use event driven technique to implement
	interuptible accept.
	(fhandler_socket::wait): Allow FD_ACCEPT handling.
	* net.cc (cygwin_accept): Remove workaround for allowing blocking
	accept.  That's entirely in fhandler_socket::accept now.
@
text
@d1064 5
d1150 5
@


1.173
log
@	* fhandler.h (class fhandler_socket): Add timeout parameter to wait()
	method.
	* fhandler_socket.cc (fhandler_socket::connect): Use event driven
	technique (prepare/wait/release) to implement interuptible connect.
	(fhandler_socket::wait): Add timeout parameter.  Allow FD_CONNECT
	handling.
	* net.cc (cygwin_connect): Remove braindead workaround for allowing
	blocking connect.  That's entirely in fhandler_socket::connect now.
@
text
@a712 2
	  else if (err == WSAEINVAL)
	    WSASetLastError (err = WSAEISCONN);
d714 2
d782 15
a796 1
  res = ::accept (get_socket (), peer, len);
d940 7
@


1.172
log
@	* autoload.cc: Never load wsock32.dll. Load all wsock32 function
	from ws2_32.  Rearrange symbol order accordingly.  None of the ws2_32
	functions is optional right now.
	(wsadata): Move from net.cc here.  Define NO_COPY.
	(wsock_init): Drop unused symbols ws2_32_handle and wsock32_handle.
	(load_wsock32): Remove.
	(WSACleanup): Remove.
	* fhandler_socket.cc: Drop Winsock 1 accommodations throughout.
	(fhandler_socket::readv): Accomodate new POSIX style struct msghdr.
	(fhandler_socket::writev): Ditto.
	(fhandler_socket::recvmsg): Ditto. Handle "old" applications using
	former struct msghdr correctly.
	* net.cc: Drop Winsock 1 accommodations throughout.
	(wsadata): Move definition to autoload.cc.
	(set_socket_inheritance): Remove.
	(convert_ws1_ip_optname): New static function to convert Winsock1
	IPPROTO_IP option values into Winsock2 IPPROTO_IP option values.
	(cygwin_setsockopt): Remove wrong and incomplete cleartext printing
	of optname.  For "old" applications, convert optname from Winsock1
	to Winsock2 values before using them.  Add comment to describe the
	IP_TOS weirdness on W2K and above.
	(cygwin_getsockopt): Remove wrong and incomplete cleartext printing
	of optname.  For "old" applications, convert optname from Winsock1
	to Winsock2 values before using them.
	* select.cc (start_thread_socket): Forget about winsock2_active.
	* winsup.h (wsock32_handle): Remove declaration.
	(ws2_32_handle): Ditto.
	(netapi32_handle): Ditto.
	(wsadata): Ditto.
	(winsock2_active): Remove definition.
	* include/cygwin/socket.h: Change formatting slightly.
	(socklen_t): Move definition up in file.
	(struct msghdr): Convert to POSIX style.
	(struct cmsghdr): New type.
	(CMSG_ALIGN): New macro.
	(CMSG_LEN): Ditto.
	(CMSG_SPACE): Ditto.
	(CMSG_FIRSTHDR): Ditto.
	(CMSG_NXTHDR): Ditto.
	(CMSG_DATA): Ditto.
	(SCM_RIGHTS): Ditto.
	(struct OLD_msghdr): Define old msghdr structure for Cygwin internal
	purposes.
	(MSG_TRUNC): New macro.
	(MSG_CTRUNC): Ditto.
	(IP_OPTIONS): Redefine IPPROTO_IP option values to Winsock2 values.
	Keep Winsock1 values for Cygwin internal purposes.
	* include/cygwin/version.h: Bump API minor version.
	(CYGWIN_VERSION_CHECK_FOR_USING_ANCIENT_MSGHDR): Define to check for
	applications using old struct msghdr.
	(CYGWIN_VERSION_CHECK_FOR_USING_WINSOCK1_VALUES): Define to check for
	applications using old Winsock1 IPPROTO_IP values.
@
text
@d684 14
a697 1
  res = ::connect (get_socket (), (struct sockaddr *) &sin, namelen);
d893 1
a893 1
fhandler_socket::wait (HANDLE event, int flags)
d900 1
a900 1
  switch (WSAWaitForMultipleEvents (2, ev, FALSE, 10, FALSE))
d926 8
a933 1
	    if (evts.lNetworkEvents & FD_READ)
@


1.171
log
@	Revert erroneous checkin.
@
text
@d397 1
a397 6
  if (!winsock2_active)
    {
      fhandler_base::fixup_before_fork_exec (win_proc_id);
      debug_printf ("Without Winsock 2.0");
    }
  else if (!WSADuplicateSocketA (get_socket (), win_proc_id, prot_info_ptr))
a407 1
extern "C" void __stdcall load_wsock32 ();
a424 6
  else if (!new_sock && !winsock2_active)
    {
      load_wsock32 ();
      fhandler_base::fixup_after_fork (parent);
      debug_printf ("Without Winsock 2.0");
    }
a437 4
#if 0
  else if (!winsock2_active)
    closesocket (get_socket ());
#endif
d464 12
a475 1
  if (winsock2_active)
d477 2
a478 12
      /* Since WSADuplicateSocket() fails on NT systems when the process
	 is currently impersonating a non-privileged account, we revert
	 to the original account before calling WSADuplicateSocket() and
	 switch back afterwards as it's also in fork().
	 If WSADuplicateSocket() still fails for some reason, we fall back
	 to DuplicateHandle(). */
      WSASetLastError (0);
      cygheap->user.deimpersonate ();
      fhs->set_io_handle (get_io_handle ());
      fhs->fixup_before_fork_exec (GetCurrentProcessId ());
      cygheap->user.reimpersonate ();
      if (!WSAGetLastError ())
d480 2
a481 6
	  fhs->fixup_after_fork (hMainProc);
	  if (fhs->get_io_handle() != (HANDLE) INVALID_SOCKET)
	    {
	      cygheap->fdtab.inc_need_fixup_before ();
	      return 0;
	    }
a482 1
      debug_printf ("WSADuplicateSocket failed, trying DuplicateHandle");
d484 1
d491 1
a491 1
			!winsock2_active, DUPLICATE_SAME_ACCESS))
d976 3
a978 2
      msg_accrights:	NULL,
      msg_accrightslen:	0
d992 5
a996 4
  if (!winsock2_active)
    ret = res = ::recvfrom (get_socket (),
			    (char *) ptr, len, flags,
			    from, fromlen);
d999 2
a1000 6
      WSABUF wsabuf = { len, (char *) ptr };

      if (is_nonblocking () || closed () || async_io ())
	res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret,
			   (DWORD *) &flags, from, fromlen, NULL, NULL);
      else
d1002 1
a1002 2
	  HANDLE evt;
	  if (prepare (evt, FD_CLOSE | FD_READ | (owner () ? FD_OOB : 0)))
d1004 3
a1006 11
	      do
		{
		  DWORD lflags = (DWORD) flags;
		  res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret, &lflags,
				     from, fromlen, NULL, NULL);
		}
	      while (res == SOCKET_ERROR
		     && WSAGetLastError () == WSAEWOULDBLOCK
		     && !closed ()
		     && !(res = wait (evt, flags)));
	      release (evt);
d1008 5
d1034 7
a1048 1
      msg->msg_accrightslen = 0;
d1059 2
a1060 17
  if (!winsock2_active)
    {
      if (iovcnt == 1)
	res = recvfrom (iov->iov_base, iov->iov_len, flags, from, fromlen);
      else
	{
	  if (tot == -1)	// i.e. if not pre-calculated by the caller.
	    {
	      tot = 0;
	      const struct iovec *iovptr = iov + iovcnt;
	      do
		{
		  iovptr -= 1;
		  tot += iovptr->iov_len;
		}
	      while (iovptr != iov);
	    }
d1062 10
a1071 1
	  char *buf = (char *) alloca (tot);
d1073 1
a1073 11
	  if (!buf)
	    {
	      set_errno (ENOMEM);
	      res = SOCKET_ERROR;
	    }
	  else
	    {
	      res = recvfrom (buf, tot, flags, from, fromlen);

	      const struct iovec *iovptr = iov;
	      int nbytes = res;
d1075 3
a1077 11
	      while (nbytes > 0)
		{
		  const int frag = min (nbytes, (ssize_t) iovptr->iov_len);
		  memcpy (iovptr->iov_base, buf, frag);
		  buf += frag;
		  iovptr += 1;
		  nbytes -= frag;
		}
	    }
	}
    }
d1080 2
a1081 22
      WSABUF wsabuf[iovcnt];
      unsigned long len = 0L;

      {
	const struct iovec *iovptr = iov + iovcnt;
	WSABUF *wsaptr = wsabuf + iovcnt;
	do
	  {
	    iovptr -= 1;
	    wsaptr -= 1;
	    len += wsaptr->len = iovptr->iov_len;
	    wsaptr->buf = (char *) iovptr->iov_base;
	  }
	while (wsaptr != wsabuf);
      }

      DWORD ret = 0;

      if (is_nonblocking () || closed () || async_io ())
	res = WSARecvFrom (get_socket (), wsabuf, iovcnt, &ret,
			   (DWORD *) &flags, from, fromlen, NULL, NULL);
      else
d1083 1
a1083 2
	  HANDLE evt;
	  if (prepare (evt, FD_CLOSE | FD_READ | (owner () ? FD_OOB : 0)))
d1085 3
a1087 11
	      do
		{
		  DWORD lflags = (DWORD) flags;
		  res = WSARecvFrom (get_socket (), wsabuf, iovcnt, &ret,
				     &lflags, from, fromlen, NULL, NULL);
		}
	      while (res == SOCKET_ERROR
		     && WSAGetLastError () == WSAEWOULDBLOCK
		     && !closed ()
		     && !(res = wait (evt, flags)));
	      release (evt);
d1089 5
d1095 1
d1097 6
a1102 6
      if (res == SOCKET_ERROR)
	{
	  /* According to SUSv3, errno isn't set in that case and no error
	     condition is returned. */
	  if (WSAGetLastError () == WSAEMSGSIZE)
	    return len;
d1104 1
a1104 4
	  set_winsock_errno ();
	}
      else
	res = ret;
d1106 2
d1122 3
a1124 2
      msg_accrights:	NULL,
      msg_accrightslen:	0
d1142 7
a1148 4
  if (!winsock2_active)
    ret = res = ::sendto (get_socket (), (const char *) ptr, len,
			  flags & MSG_WINMASK,
			  (to ? (const struct sockaddr *) &sin : NULL), tolen);
d1151 2
a1152 8
      WSABUF wsabuf = { len, (char *) ptr };

      if (is_nonblocking () || closed () || async_io ())
	res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
			 flags & MSG_WINMASK,
			 (to ? (const struct sockaddr *) &sin : NULL), tolen,
			 NULL, NULL);
      else
d1154 1
a1154 2
	  HANDLE evt;
	  if (prepare (evt, FD_CLOSE | FD_WRITE | (owner () ? FD_OOB : 0)))
d1156 4
a1159 12
	      do
		{
		  res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
				   flags & MSG_WINMASK,
				   (to ? (const struct sockaddr *) &sin : NULL),
				   tolen, NULL, NULL);
		}
	      while (res == SOCKET_ERROR
		     && WSAGetLastError () == WSAEWOULDBLOCK
		     && !(res = wait (evt, 0))
		     && !closed ());
	      release (evt);
d1161 5
d1207 1
a1207 19
  if (!winsock2_active)
    {
      if (iovcnt == 1)
	res = sendto (iov->iov_base, iov->iov_len, flags,
		      (struct sockaddr *) msg->msg_name,
		      msg->msg_namelen);
      else
	{
	  if (tot == -1)	// i.e. if not pre-calculated by the caller.
	    {
	      tot = 0;
	      const struct iovec *iovptr = iov + iovcnt;
	      do
		{
		  iovptr -= 1;
		  tot += iovptr->iov_len;
		}
	      while (iovptr != iov);
	    }
d1209 10
a1218 1
	  char *const buf = (char *) alloca (tot);
d1220 1
a1220 10
	  if (!buf)
	    {
	      set_errno (ENOMEM);
	      res = SOCKET_ERROR;
	    }
	  else
	    {
	      char *bufptr = buf;
	      const struct iovec *iovptr = iov;
	      int nbytes = tot;
d1222 4
a1225 15
	      while (nbytes != 0)
		{
		  const int frag = min (nbytes, (ssize_t) iovptr->iov_len);
		  memcpy (bufptr, iovptr->iov_base, frag);
		  bufptr += frag;
		  iovptr += 1;
		  nbytes -= frag;
		}

	      res = sendto (buf, tot, flags,
			    (struct sockaddr *) msg->msg_name,
			    msg->msg_namelen);
	    }
	}
    }
d1228 2
a1229 22
      WSABUF wsabuf[iovcnt];

      {
	const struct iovec *iovptr = iov + iovcnt;
	WSABUF *wsaptr = wsabuf + iovcnt;
	do
	  {
	    iovptr -= 1;
	    wsaptr -= 1;
	    wsaptr->len = iovptr->iov_len;
	    wsaptr->buf = (char *) iovptr->iov_base;
	  }
	while (wsaptr != wsabuf);
      }

      DWORD ret = 0;

      if (is_nonblocking () || closed () || async_io ())
	res = WSASendTo (get_socket (), wsabuf, iovcnt, &ret,
			 flags, (struct sockaddr *) msg->msg_name,
			 msg->msg_namelen, NULL, NULL);
      else
d1231 1
a1231 2
	  HANDLE evt;
	  if (prepare (evt, FD_CLOSE | FD_WRITE | (owner () ? FD_OOB : 0)))
d1233 4
a1236 12
	      do
		{
		  res = WSASendTo (get_socket (), wsabuf, iovcnt,
				   &ret, flags,
				   (struct sockaddr *) msg->msg_name,
				   msg->msg_namelen, NULL, NULL);
		}
	      while (res == SOCKET_ERROR
		     && WSAGetLastError () == WSAEWOULDBLOCK
		     && !(res = wait (evt, 0))
		     && !closed ());
	      release (evt);
d1238 5
d1244 1
d1246 4
a1249 5
      if (res == SOCKET_ERROR)
	set_winsock_errno ();
      else
	res = ret;
    }
a1504 2
  if (!winsock2_active) /* < Winsock 2.0 */
    set_no_inheritance (get_handle (), val);
@


1.170
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@a29 1
#include "pinfo.h"
d457 1
a457 1
fhandler_socket::dup (fhandler_base *child, HANDLE from_proc)
d480 1
a480 1
  if (winsock2_active && from_proc == hMainProc)
d509 1
a509 1
  if (!DuplicateHandle (from_proc, get_io_handle (), hMainProc, &nh, 0,
d995 2
a996 3
      msg_control:	NULL,
      msg_controllen:	0,
      msg_flags:	0
d1067 1
a1067 4
      if (CYGWIN_VERSION_CHECK_FOR_USING_ANCIENT_MSGHDR)
        ((struct OLD_msghdr *) msg)->msg_accrightslen = 0;
      else
	msg->msg_controllen = 0;
d1189 2
a1190 3
      msg_control:	NULL,
      msg_controllen:	0,
      msg_flags:	0
d1266 1
a1266 6
  struct cmsghdr *cmsg;
  bool descriptors_inflight = false;

  if (get_addr_family () == AF_LOCAL
      && get_socket_type () == SOCK_STREAM
      && msg->msg_controllen > 0)	/* Works for ancient msghdr, too. */
d1268 1
a1268 1
      /* For AF_LOCAL/SOCK_STREAM sockets, if descriptors are given, start
d1272 1
a1272 47

      /* NOTE: SOCK_DGRAMs are usually allowed, but we can't support them
         unless credential passing works for SOCK_DGRAM sockets as well.
	 OTOH, since DGRAMs can be easily discarded, they are not reliable
	 and seldomly used anyway. */

      struct msghdr lmsg;

      union {
        struct cmsghdr cm;
	char control[CMSG_SPACE (sizeof (int))];
      } control_un;
      if (CYGWIN_VERSION_CHECK_FOR_USING_ANCIENT_MSGHDR)
        {
	  memcpy (&lmsg, msg, sizeof *msg);
	  lmsg.msg_control = (void *) control_un.control;
	  lmsg.msg_controllen = sizeof control_un.control;
	  lmsg.msg_flags = 0;
	  cmsg = CMSG_FIRSTHDR (&lmsg);
	  cmsg->cmsg_len = CMSG_LEN (sizeof (int));
	  cmsg->cmsg_level = SOL_SOCKET;
	  cmsg->cmsg_type = SCM_RIGHTS;
	  *((int *) CMSG_DATA (cmsg)) =
			    *(int *) ((OLD_msghdr *) msg)->msg_accrights;
	  msg = &lmsg;
	}

      pinfo p (sec_peer_pid);
      if (!p)
        {
	  set_errno (ENOTCONN);
	  return SOCKET_ERROR;
	}
      for (cmsg = CMSG_FIRSTHDR (msg); cmsg; cmsg = CMSG_NXTHDR (msg, cmsg))
        {
	  if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS)
	    {
	      set_errno (ENOTSUP);
	      return SOCKET_ERROR;
	    }
	  int *fds = (int *) CMSG_DATA (cmsg);
	  int cnt = (cmsg->cmsg_len - CMSG_ALIGN (sizeof (struct cmsghdr)))
		    / sizeof (int);
	  if (!p->send_descriptors (cnt, fds))
	    return SOCKET_ERROR;
	  descriptors_inflight = true;
	}
d1372 1
a1372 3
	{
	  set_winsock_errno ();
	}
d1377 7
a1383 1
  if (res == SOCKET_ERROR)
d1385 3
a1387 19
      /* If sendmsg fails, destroy all inflight descriptors. */
      if (descriptors_inflight && WSAGetLastError () != WSAEWOULDBLOCK)
	{
	  pinfo p (sec_peer_pid);
	  if (p)
	    p->destroy_inflight_descriptors ();
	}

      /* Special handling for EPIPE and SIGPIPE.

	 EPIPE is generated if the local end has been shut down on a connection
	 oriented socket.  In this case the process will also receive a SIGPIPE
	 unless MSG_NOSIGNAL is set.  */
      if (get_errno () == ESHUTDOWN && get_socket_type () == SOCK_STREAM)
	{
	  set_errno (EPIPE);
	  if (! (flags & MSG_NOSIGNAL))
	    raise (SIGPIPE);
	}
@


1.169
log
@	* fhandler_socket.cc (fhandler_socket::recvfrom): Always initialize
	ret to 0.
	(fhandler_socket::recvmsg): Ditto.
@
text
@d30 1
d458 1
a458 1
fhandler_socket::dup (fhandler_base *child)
d481 1
a481 1
  if (winsock2_active)
d510 1
a510 1
  if (!DuplicateHandle (hMainProc, get_io_handle (), hMainProc, &nh, 0,
d996 3
a998 2
      msg_accrights:	NULL,
      msg_accrightslen:	0
d1069 4
a1072 1
      msg->msg_accrightslen = 0;
d1194 3
a1196 2
      msg_accrights:	NULL,
      msg_accrightslen:	0
d1272 6
a1277 1
  if (get_addr_family () == AF_LOCAL)
d1279 1
a1279 1
      /* For AF_LOCAL/AF_UNIX sockets, if descriptors are given, start
d1283 47
a1329 1
      /*TODO*/
d1429 3
a1431 1
	set_winsock_errno ();
d1436 11
a1446 1
  /* Special handling for EPIPE and SIGPIPE.
d1448 9
a1456 9
     EPIPE is generated if the local end has been shut down on a connection
     oriented socket.  In this case the process will also receive a SIGPIPE
     unless MSG_NOSIGNAL is set.  */
  if (res == SOCKET_ERROR && get_errno () == ESHUTDOWN
      && get_socket_type () == SOCK_STREAM)
    {
      set_errno (EPIPE);
      if (! (flags & MSG_NOSIGNAL))
	raise (SIGPIPE);
@


1.168
log
@white space
@
text
@d1007 1
a1007 1
  DWORD ret;
d1019 1
a1019 1
	res = WSARecvFrom (get_socket (), &wsabuf, 1, (ret = 0, &ret),
d1139 1
a1139 1
      DWORD ret;
d1142 1
a1142 1
	res = WSARecvFrom (get_socket (), wsabuf, iovcnt, (ret = 0, &ret),
@


1.167
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d113 1
a113 1
        __seterrno ();
@


1.166
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d168 1
a168 1
fhandler_socket::af_local_set_sockpair_cred (void)
d205 1
a205 1
fhandler_socket::af_local_recv_secret (void)
d235 1
a235 1
fhandler_socket::af_local_send_secret (void)
d253 1
a253 1
fhandler_socket::af_local_recv_cred (void)
d280 1
a280 1
fhandler_socket::af_local_send_cred (void)
d301 1
a301 1
fhandler_socket::af_local_connect (void)
d323 1
a323 1
fhandler_socket::af_local_accept (void)
d342 1
a342 1
fhandler_socket::af_local_set_cred (void)
@


1.165
log
@	* fhandler_socket.cc (fhandler_socket::recvmsg): Avoid SEGV in OpenSSH
	when trying to pass file descriptor by setting msg->msg_accrightslen
	to 0.
@
text
@d38 1
d1663 4
a1666 1
  if (!check_null_invalid_struct (pid))
d1668 1
a1668 1
  if (!check_null_invalid_struct (euid))
d1670 1
a1670 1
  if (!check_null_invalid_struct (egid))
@


1.164
log
@	* fhandler_socket.cc (fhandler_socket::sendto): Always initialize
	ret to 0.
	(fhandler_socket::sendmsg): Ditto.
@
text
@d1066 1
@


1.163
log
@	* fhandler_socket.cc (get_inet_addr): Add missing __seterrno call.
@
text
@d1204 1
a1204 1
  DWORD ret;
d1215 1
a1215 1
	res = WSASendTo (get_socket (), &wsabuf, 1, (ret = 0, &ret),
d1343 1
a1343 1
      DWORD ret;
d1346 1
a1346 1
	res = WSASendTo (get_socket (), wsabuf, iovcnt, (ret = 0, &ret),
@


1.162
log
@white space and minor comment cleanup.
@
text
@d111 2
@


1.161
log
@	* fhandler.h (enum conn_state): Add connect_failed state.
	* fhandler_socket.cc (fhandler_socket::connect): Set connect_state to
	connect_failed when connect failed.
	* poll.cc (poll): Change errno to EINVAL if allocating memory fails,
	according to SUSv3. Add socket descriptors always to except_fds. Test
	for failed connect and set revents flags appropriately.
	* select.cc (set_bits): Set connect_state to connect_failed when
	select indicates failed nonblocking connect.
	(fhandler_dev_null::select_except): Set except_ready to false so that
	/dev/null is not always in except state.
	(peek_socket): Fix bogus conditional.
	(fhandler_socket::select_write): Treat all connect_states except
	unconnected equivalent to return consistent results.
	(fhandler_windows::select_except): Set except_ready to false so that
	/dev/windows is not always in except state.
@
text
@d107 2
a108 2
	             ctype == 'd' ? SOCK_DGRAM
		                  : 0);
d220 1
a220 1
          || out[2] != connect_secret[2] || out[3] != connect_secret[3])
d466 1
a466 1
        {
d527 1
a527 1
        {
d803 1
a803 1
	        {
d815 1
a815 1
	        }
d1655 1
a1655 1
      				   accepting (instead of accepted) socket. */
@


1.160
log
@	* fhandler.h (class fhandler_socket): Remove utimes.
	* fhandler_socket.cc (fhandler_socket::utimes): Remove.
@
text
@d709 1
a709 1
      if (is_nonblocking () || connect_state () == connect_pending)
d739 2
@


1.159
log
@	* fhandler_socket.cc (get_inet_addr): Add type parameter to return
	unix socket type.  Read socket type from unix socket file.
	(fhandler_socket::bind): Write socket type to unix socket file.
	(fhandler_socket::connect): Return with errno EPROTOTYPE if
	socket type of socket doesn't match socket type of unix socket
	trying to connect to.
@
text
@a591 11
fhandler_socket::utimes (const struct timeval *tvp)
{
  if (get_device () == FH_UNIX)
    {
      fhandler_disk_file fh (pc);
      return fh.utimes (tvp);
    }
  return fhandler_base::utimes (tvp);
}

int
@


1.158
log
@	* fhandler.h (fhandler_socket::secret_event): Remove.
	(fhandler_socket::af_local_set_secret): New function combining former
	set_connect_secret and get_connect_secret into one function.
	(fhandler_socket::af_local_setblocking): Rename from eid_setblocking.
	(fhandler_socket::af_local_unsetblocking): Rename from
	eid_unsetblocking.
	(fhandler_socket::af_local_set_cred): New method.
	(fhandler_socket::af_local_copy): New method.
	(fhandler_socket::af_local_recv_secret): New method.
	(fhandler_socket::af_local_send_secret): New method.
	(fhandler_socket::af_local_recv_cred): Rename from eid_recv.
	(fhandler_socket::af_local_send_cred): Rename from eid_send.
	(fhandler_socket::af_local_accept): New method.
	(fhandler_socket::af_local_set_sockpair_cred): Rename from
	set_socketpair_eids.
	(fhandler_socket::eid_accept): Remove.
	(fhandler_socket::eid_connect): Remove.
	(fhandler_socket::set_connect_secret): Remove.
	(fhandler_socket::get_connect_secret): Remove.
	(fhandler_socket::create_secret_event): Remove.
	(fhandler_socket::check_peer_secret_event): Remove.
	(fhandler_socket::signal_secret_event): Remove.
	(fhandler_socket::close_secret_event): Remove.
	(fhandler_socket::sec_event_accept): Remove.
	(fhandler_socket::sec_event_connect): Remove.
	* fhandler_socket.cc (secret_event_name): Remove.
	(fhandler_socket::af_local_set_sockpair_cred): Rename from
	set_socketpair_eids.
	(fhandler_socket::af_local_setblocking): Rename from eid_setblocking.
	(fhandler_socket::af_local_unsetblocking): Rename from
	eid_unsetblocking.
	(fhandler_socket::af_local_recv_secret): New function to receive
	AF_LOCAL connect secret over socket itself.
	(fhandler_socket::af_local_send_secret): New function to send AF_LOCAL
	connect secret over socket itself.
	(fhandler_socket::af_local_recv_cred): Rename from eid_recv.
	(fhandler_socket::af_local_send_cred): Rename from eid_send.
	(fhandler_socket::eid_connect): Remove.
	(fhandler_socket::af_local_connect): Take over connect side handling
	of AF_LOCAL secret and credential handshake.
	(fhandler_socket::eid_accept): Remove.
	(fhandler_socket::af_local_accept): New method, take over accept side
	handling of AF_LOCAL secret and credential handshake.
	(fhandler_socket::af_local_set_cred): New method, set eid credentials
	to start values.
	(fhandler_socket::af_local_copy): New method, copy secret and
	credentials to another socket.
	(fhandler_socket::af_local_set_secret): New function combining former
	set_connect_secret and get_connect_secret into one function.
	(fhandler_socket::create_secret_event): Remove.
	(fhandler_socket::signal_secret_event): Remove.
	(fhandler_socket::close_secret_event): Remove.
	(fhandler_socket::check_peer_secret_event): Remove.
	(fhandler_socket::sec_event_connect): Remove.
	(fhandler_socket::sec_event_accept): Remove.
	(fhandler_socket::fixup_after_fork): Drop secret_event handling.
	(fhandler_socket::bind): Call af_local_set_secret.
	(fhandler_socket::connect): Call af_local_set_cred and af_local_connect.
	(fhandler_socket::listen): Call af_local_set_cred.
	(fhandler_socket::accept): Call af_local_copy and af_local_accept on
	accepted socket.
	(fhandler_socket::close): Don't call close_secret_event.
	(fhandler_socket::set_close_on_exec): Don't set secret_event
	inheritance.
	* net.cc (cygwin_getsockopt): Add debug output.
	(socketpair): Call af_local_set_sockpair_cred instead of
	set_socketpair_eids.
	* select.cc (set_bits): Drop AF_LOCAL special handling in case
	of except bit set.
@
text
@d51 2
a52 1
	       struct sockaddr_in *out, int *outlen, int* secret = 0)
d95 1
d97 1
a97 1
	  sscanf (buf + strlen (SOCKET_COOKIE), "%hu %08x-%08x-%08x-%08x",
d99 1
d105 4
d666 1
a666 1
      __small_sprintf (buf, "%s%u ", SOCKET_COOKIE, sin.sin_port);
d699 1
d701 1
a701 1
  if (!get_inet_addr (name, namelen, &sin, &namelen, connect_secret))
d704 7
@


1.157
log
@	* fhandler.h (fhandler_socket::eid_connect): Make private.
	(fhandler_socket::set_connect_secret): Ditto.
	(fhandler_socket::get_connect_secret): Ditto.
	(fhandler_socket::create_secret_event): Ditto. Remove secret argument.
	(fhandler_socket::check_peer_secret_event): Ditto.
	(fhandler_socket::signal_secret_event): Make private.
	(fhandler_socket::close_secret_event): Ditto.
	(fhandler_socket::sec_event_accept): New private method.
	(fhandler_socket::sec_event_connect): Ditto.
	(fhandler_socket::af_local_connect): New public method.
	* fhandler_socket.cc: Use 'struct sockaddr' and 'struct sockaddr_in'
	rather than just 'sockaddr' and 'sockaddr_in' throughout.
	(fhandler_socket::eid_connect): Drop AF_LOCAL/SOCK_STREAM test.
	(fhandler_socket::create_secret_event): Remove secret argument.
	Always use connect_secret instead.
	(fhandler_socket::check_peer_secret_event): Ditto.
	(fhandler_socket::sec_event_connect): New method, combining entire
	secret event handshake on connect side.
	(fhandler_socket::af_local_connect): New method, combining secret
	event handshake and eid credential transaction on connect side, to
	be called from select.
	(fhandler_socket::sec_event_accept): New method, combining entire
	secret event handshake on accept side.
	(fhandler_socket::connect): Drop secret, use connect_secret instead.
	Move entire secret event handshake to sec_event_connect.
	(fhandler_socket::accept): Move entire secret event handshake to
	sec_event_accept.
	* select.cc (set_bits): Just call af_local_connect here.
@
text
@a47 10
static void
secret_event_name (char *buf, short port, int *secret_ptr)
{
  __small_sprintf (buf, "%scygwin.local_socket.secret.%d.%08x-%08x-%08x-%08x",
		   wincap.has_terminal_services () ? "Global\\" : "",
		   port,
		   secret_ptr [0], secret_ptr [1],
		   secret_ptr [2], secret_ptr [3]);
}

d143 14
d158 1
a158 1
fhandler_socket::set_socketpair_eids (void)
d166 1
a166 1
fhandler_socket::eid_setblocking (bool &async, bool &nonblocking)
d179 1
a179 1
fhandler_socket::eid_unsetblocking (bool async, bool nonblocking)
d195 49
a243 1
fhandler_socket::eid_recv (void)
d270 1
a270 1
fhandler_socket::eid_send (void)
d290 2
a291 2
void
fhandler_socket::eid_connect (void)
d293 5
a297 1
  debug_printf ("eid_connect called");
d299 11
a309 3
  eid_setblocking (orig_async_io, orig_is_nonblocking);
  eid_send () && eid_recv ();
  eid_unsetblocking (orig_async_io, orig_is_nonblocking);
d312 2
a313 2
void
fhandler_socket::eid_accept (void)
d315 1
a315 1
  debug_printf ("eid_accept called");
d317 12
a328 3
  eid_setblocking (orig_async_io, orig_is_nonblocking);
  eid_recv () && eid_send ();
  eid_unsetblocking (orig_async_io, orig_is_nonblocking);
d331 2
a332 2
char *
fhandler_socket::get_proc_fd_name (char *buf)
d334 6
a339 2
  __small_sprintf (buf, "socket:[%d]", get_socket ());
  return buf;
d342 2
a343 2
int
fhandler_socket::open (int flags, mode_t mode)
d345 10
a354 2
  set_errno (ENXIO);
  return 0;
d358 1
a358 1
fhandler_socket::set_connect_secret ()
a378 5
}

void
fhandler_socket::get_connect_secret (char* buf)
{
a383 144
HANDLE
fhandler_socket::create_secret_event ()
{
  struct sockaddr_in sin;
  int sin_len = sizeof (sin);

  if (secret_event)
    return secret_event;

  if (::getsockname (get_socket (), (struct sockaddr*) &sin, &sin_len))
    {
      debug_printf ("error getting local socket name (%d)", WSAGetLastError ());
      return NULL;
    }

  char event_name[CYG_MAX_PATH];
  secret_event_name (event_name, sin.sin_port, connect_secret);
  secret_event = CreateEvent (&sec_all, FALSE, FALSE, event_name);

  if (!secret_event)
    debug_printf("create event %E");
  else if (close_on_exec ())
    /* Event allows inheritance, but handle will not be inherited */
    set_no_inheritance (secret_event, 1);

  return secret_event;
}

void
fhandler_socket::signal_secret_event ()
{
  if (!secret_event)
    debug_printf ("no secret event?");
  else
    {
      SetEvent (secret_event);
      debug_printf ("signaled secret_event");
    }
}

void
fhandler_socket::close_secret_event ()
{
  if (secret_event)
    CloseHandle (secret_event);
  secret_event = NULL;
}

int
fhandler_socket::check_peer_secret_event (struct sockaddr_in *peer)
{

  char event_name[CYG_MAX_PATH];

  secret_event_name (event_name, peer->sin_port, connect_secret);
  HANDLE ev = CreateEvent (&sec_all_nih, FALSE, FALSE, event_name);
  if (!ev)
    debug_printf("create event %E");

  signal_secret_event ();

  if (ev)
    {
      DWORD rc = WaitForSingleObject (ev, 10000);
      debug_printf ("WFSO rc=%d", rc);
      CloseHandle (ev);
      return (rc == WAIT_OBJECT_0 ? 1 : 0);
    }
  else
    return 0;
}

int
fhandler_socket::sec_event_connect (struct sockaddr_in *peer)
{
  bool secret_check_failed = false;
  struct sockaddr_in sin;
  int siz = sizeof sin;

  debug_printf ("sec_event_connect called");
  if (!peer)
    {
      if (::getpeername (get_socket (), (struct sockaddr *) &sin, &siz))
        goto err;
      peer = &sin;
    }
  if (!create_secret_event ())
    secret_check_failed = true;
  if (!secret_check_failed && !check_peer_secret_event (peer))
    {
      debug_printf ("accept from unauthorized server");
      secret_check_failed = true;
    }
  if (!secret_check_failed)
    return 0;

err:
  close_secret_event ();
  closesocket (get_socket ());
  WSASetLastError (WSAECONNREFUSED);
  set_winsock_errno ();
  return -1;
}

/* Called from select().  It combines the secret event handshake and
   the eid credential transaction into one call.  This keeps implementation
   details from select. */
int
fhandler_socket::af_local_connect (void)
{
  if (get_addr_family () != AF_LOCAL || get_socket_type () != SOCK_STREAM)
    return 0;
  int ret = sec_event_connect (NULL);
  if (!ret)
    eid_connect ();
  return ret;
}

int
fhandler_socket::sec_event_accept (int sock, struct sockaddr_in *peer)
{
  bool secret_check_failed = false;

  debug_printf ("sec_event_accept called");

  if (!create_secret_event ())
    secret_check_failed = true;

  if (!secret_check_failed
      && !check_peer_secret_event (peer))
    {
      debug_printf ("connect from unauthorized client");
      secret_check_failed = true;
    }
  if (secret_check_failed)
    {
      close_secret_event ();
      closesocket (sock);
      set_errno (ECONNABORTED);
      return -1;
    }
  return sock;
}

a431 3

  if (secret_event)
    fork_fixup (parent, secret_event, "secret_event");
a657 2
      set_connect_secret ();

d660 1
a660 1
      get_connect_secret (strchr (buf, '\0'));
d723 7
a729 17
      /* Prepare eid credential transaction. */
      sec_pid = getpid ();
      sec_uid = geteuid32 ();
      sec_gid = getegid32 ();
      sec_peer_pid = (pid_t) 0;
      sec_peer_uid = (__uid32_t) -1;
      sec_peer_gid = (__gid32_t) -1;

      if (!res)
	res = sec_event_connect (&sin);

      if (!res)
        {
	  /* eid credential transaction.  If connect is in progress,
	    we're deferring the eid transaction to the successful select,
	    see select.cc, function set_bits(). */
	  eid_connect ();
d750 1
a750 9
        {
	  /* Prepare eid credential transaction. */
	  sec_pid = getpid ();
	  sec_uid = geteuid32 ();
	  sec_gid = getegid32 ();
	  sec_peer_pid = (pid_t) 0;
	  sec_peer_uid = (__uid32_t) -1;
	  sec_peer_gid = (__gid32_t) -1;
	}
d781 1
a781 5
  if ((SOCKET) res != INVALID_SOCKET && get_addr_family () == AF_LOCAL
      && get_socket_type () == SOCK_STREAM)
    res = sec_event_accept (res, (struct sockaddr_in *) peer);

  if ((SOCKET) res == INVALID_SOCKET)
d801 8
a808 7
		  sock->sec_pid = sec_pid;
		  sock->sec_uid = sec_uid;
		  sock->sec_gid = sec_gid;
		  sock->sec_peer_pid = sec_peer_pid;
		  sock->sec_peer_uid = sec_peer_uid;
		  sock->sec_peer_gid = sec_peer_gid;
		  sock->eid_accept ();
d821 1
a1437 2
  close_secret_event ();

a1620 2
  if (secret_event)
    set_no_inheritance (secret_event, val);
@


1.156
log
@* Makefile.in (DLL_OFILES): Add hookapi.o.  Eliminate some cruft.
* cygheap.h (cygheap_types): Add new enum: HEAP_1_HOOK.
(hook_chain): New struct.
(init_cygheap::hooks): Define new element.
* cygheap.cc (cygheap_fixup_in_child): Zero hook chain on exec.
* dcrt0.cc (dll_crt0_1): Call ld_preload just before calling main function.
* external.cc (cygwin_internal): Implement CW_HOOK.
* fork.cc (fork_child): Call fixup_hooks_after_fork.
* init.cc (cygwin_hmodule): Reinstate after a long absence.
* include/sys/cygwin.h: Define CW_HOOK.
* hookapi.cc: New file.
* select.cc (start_thread_socket): Add debugging output.
* fhandler_disk_file.cc (fhandler_disk_file::fchmod): gcc 4.x accommodation.
* fhandler_socket.cc (fhandler_socket::connect): Make sure that err is
initialized.
@
text
@d68 1
a68 1
      *out = * (sockaddr_in *)in;
d103 1
a103 1
	  sockaddr_in sin;
a240 4
  /* This test allows to keep select.cc clean from boring implementation
     details. */
  if (get_addr_family () != AF_LOCAL || get_socket_type () != SOCK_STREAM)
    return;
d305 1
a305 1
fhandler_socket::create_secret_event (int* secret)
d320 1
a320 1
  secret_event_name (event_name, sin.sin_port, secret ?: connect_secret);
d353 1
a353 1
fhandler_socket::check_peer_secret_event (struct sockaddr_in* peer, int* secret)
d358 1
a358 1
  secret_event_name (event_name, peer->sin_port, secret ?: connect_secret);
d376 72
a757 1
  bool secret_check_failed = false;
d759 1
a759 2
  sockaddr_in sin;
  int secret [4];
d762 1
a762 1
  if (!get_inet_addr (name, namelen, &sin, &namelen, secret))
d765 1
a765 1
  res = ::connect (get_socket (), (sockaddr *) &sin, namelen);
a791 28
      if (!res || in_progress)
	{
	  if (!create_secret_event (secret))
	    {
	      secret_check_failed = true;
	    }
	  else if (in_progress)
	    signal_secret_event ();
	}

      if (!secret_check_failed && !res)
	{
	  if (!check_peer_secret_event (&sin, secret))
	    {
	      debug_printf ("accept from unauthorized server");
	      secret_check_failed = true;
	    }
       }

      if (secret_check_failed)
	{
	  close_secret_event ();
	  if (res)
	    closesocket (res);
	  set_errno (ECONNREFUSED);
	  res = -1;
	}

d801 3
a846 1
  bool secret_check_failed = false;
d870 1
a870 21
    {
	if (!create_secret_event ())
	  secret_check_failed = true;

      if (!secret_check_failed)
	{
	  if (!check_peer_secret_event ((struct sockaddr_in*) peer))
	    {
	      debug_printf ("connect from unauthorized client");
	      secret_check_failed = true;
	    }
	}

      if (secret_check_failed)
	{
	  close_secret_event ();
	  closesocket (res);
	  set_errno (ECONNABORTED);
	  return -1;
	}
    }
d1279 1
a1279 1
  sockaddr_in sin;
@


1.155
log
@	* fhandler.h (class cygthread): Forward declare.
	(fhandler_socket::sec_pipe): Remove.
	(fhandler_socket::eid_pipe_name): Remove.
	(fhandler_socket::eid_setblocking): New private method.
	(fhandler_socket::eid_unsetblocking): Ditto
	(fhandler_socket::eid_recv): Ditto
	(fhandler_socket::eid_send): Ditto
	(fhandler_socket::eid_accept): Ditto
	(fhandler_socket::eid_connect): New public method.
	* fhandler_socket.cc (ASYNC_MASK): Move to beginning of file.
	(fhandler_socket::eid_pipe_name): Remove.
	(fhandler_socket::set_socketpair_eids): Move down to fhandler_socket
	methods.
	(fhandler_socket::fhandler_socket): Drop initializing sec_pipe.
	(fhandler_socket::~fhandler_socket): Drop closing sec_pipe.
	(fhandler_socket::eid_setblocking): New method.
	(fhandler_socket::eid_unsetblocking): New method.
	(fhandler_socket::eid_recv): New method.
	(fhandler_socket::eid_send): New method.
	(fhandler_socket::eid_connect): New method.
	(fhandler_socket::eid_accept): New method.
	(fhandler_socket::dup): Drop sec_pipe handling.
	(fhandler_socket::connect): Fix WinSock error handling. Prepare
	eid credential transaction. Call eid_connect on successful connect.
	(fhandler_socket::listen): Drop creating sec_pipe.
	(fhandler_socket::accept): Slightly simplify code. Call eid_accept
	on accepted socket.
	(fhandler_socket::getpeereid): Reshuffle code for readability. Fix
	test for invalid pid.
	* select.cc (set_bits): Call eid_connect on successfully connected
	socket.
@
text
@d701 3
a703 1
  if (res)
@


1.154
log
@	* fhandler_socket.cc (fhandler_socket::connect): Always set sun_path
	in case of a successful or pending connect.
	(fhandler_socket::accept): Don't run secret event and eid credential
	transactions if OS accept returned WSAEWOULDBLOCK.
@
text
@d39 2
a57 16
char *
fhandler_socket::eid_pipe_name (char *buf)
{
  __small_sprintf (buf, "\\\\.\\pipe\\cygwin-unix-%s", get_sun_path ());
  debug_printf ("%s", buf);
  return buf;
}

void
fhandler_socket::set_socketpair_eids (void)
{
  sec_pid = sec_peer_pid = getpid ();
  sec_uid = sec_peer_uid = geteuid32 ();
  sec_gid = sec_peer_gid = getegid32 ();
}

a128 1
  sec_pipe (INVALID_HANDLE_VALUE),
a150 3
  /* Close eid credentials pipe handle. */
  if (sec_pipe != INVALID_HANDLE_VALUE)
    CloseHandle (sec_pipe);
d153 111
a263 1
char *fhandler_socket::get_proc_fd_name (char *buf)
a464 12
	  if (sec_pipe != INVALID_HANDLE_VALUE)
	    {
	      if (!DuplicateHandle (hMainProc, sec_pipe, hMainProc, &nh, 0,
				    TRUE, DUPLICATE_SAME_ACCESS))
		{
		  system_printf ("!DuplicateHandle(%x) failed, %E", sec_pipe);
		  __seterrno ();
		  return -1;
		}
	      else
	        fhs->sec_pipe = nh;
	    }
a502 2
      if (fhs->sec_pipe != INVALID_HANDLE_VALUE)
        CloseHandle (fhs->sec_pipe);
d703 1
a707 1
	  err = WSAGetLastError ();
d712 1
a712 1
	    WSASetLastError (WSAEINPROGRESS);
d714 1
a714 1
	    WSASetLastError (WSAEISCONN);
d752 9
a760 1
      if (!res || in_progress)
d762 4
a765 26
	  /* eid credential transaction. */
	  if (wincap.has_named_pipes ())
	    {
	      struct ucred in = { getpid (), geteuid32 (), getegid32 () };
	      struct ucred out = { (pid_t) 0, (__uid32_t) -1, (__gid32_t) -1 };
	      DWORD bytes = 0;
	      debug_printf ("Calling CallNamedPipe");
	      if (CallNamedPipe(eid_pipe_name ((char *) alloca (CYG_MAX_PATH + 1)),
				&in, sizeof in, &out, sizeof out, &bytes, 1000))
		{
		  debug_printf ("Received eid credentials: pid: %d, uid: %d"
		  		", gid: %d", out.pid, out.uid, out.gid);
		  sec_peer_pid = out.pid;
		  sec_peer_uid = out.uid;
		  sec_peer_gid = out.gid;
		}
	      else
		debug_printf ("Receiving eid credentials failed: %E");
	    }
	  else /* 9x */
	    {
	      /* Incorrect but wrong pid at least doesn't break getpeereid. */
	      sec_peer_pid = getpid ();
	      sec_peer_uid = geteuid32 ();
	      sec_peer_gid = getegid32 ();
	    }
a768 1
  err = WSAGetLastError ();
a793 10
	  /* A listening socket can call listen again, but that shouldn't
	     result in trying to create another pipe. */
	  if (wincap.has_named_pipes () && sec_pipe == INVALID_HANDLE_VALUE)
	    sec_pipe =
	    CreateNamedPipe (eid_pipe_name ((char *) alloca (CYG_MAX_PATH + 1)),
			     PIPE_ACCESS_DUPLEX,
			     PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,
			     PIPE_UNLIMITED_INSTANCES, sizeof (struct ucred),
			     sizeof (struct ucred), 1000, &sec_all);
	  debug_printf ("sec_pipe: %x", sec_pipe);
a804 2
  struct ucred in = { sec_pid, sec_uid, sec_gid };
  struct ucred out = { (pid_t) 0, (__uid32_t) -1, (__gid32_t) -1 };
a847 28

      /* eid credential transaction. */
      if (wincap.has_named_pipes ())
	{
	  DWORD bytes = 0;
	  debug_printf ("Calling ConnectNamedPipe");
	  bool ret = ConnectNamedPipe (sec_pipe, NULL);
	  if (ret || GetLastError () == ERROR_PIPE_CONNECTED)
	    {
	      if (!ReadFile (sec_pipe, &out, sizeof out, &bytes, NULL))
		debug_printf ("Receiving eid credentials failed: %E");
	      else
		debug_printf ("Received eid credentials: pid: %d, uid: %d"
			      ", gid: %d", out.pid, out.uid, out.gid);
	      if (!WriteFile (sec_pipe, &in, sizeof in, &bytes, NULL))
		debug_printf ("Sending eid credentials failed: %E");
	      DisconnectNamedPipe (sec_pipe);
	    }
	  else
	    debug_printf ("Connecting the eid credential pipe failed: %E");
	}
      else /* 9x */
	{
	  /* Incorrect but wrong pid at least doesn't break getpeereid. */
	  out.pid = sec_pid;
	  out.uid = sec_uid;
	  out.gid = sec_gid;
	}
d857 5
a861 2
	  ((fhandler_socket *) res_fd)->set_addr_family (get_addr_family ());
	  ((fhandler_socket *) res_fd)->set_socket_type (get_socket_type ());
d864 1
a864 1
	      ((fhandler_socket *) res_fd)->set_sun_path (get_sun_path ());
d866 12
a877 5
		{
		  ((fhandler_socket *) res_fd)->sec_peer_pid = out.pid;
		  ((fhandler_socket *) res_fd)->sec_peer_uid = out.uid;
		  ((fhandler_socket *) res_fd)->sec_peer_gid = out.gid;
		}
d879 1
a879 1
	  ((fhandler_socket *) res_fd)->connect_state (connected);
a1510 2
#define ASYNC_MASK (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT)

d1707 6
a1712 1
  if (get_addr_family () == AF_LOCAL && get_socket_type () == SOCK_STREAM)
a1713 10
      if (connect_state () == connected && sec_peer_pid != (pid_t) -1)
        {
	  if (!check_null_invalid_struct (pid))
	    *pid = sec_peer_pid;
	  if (!check_null_invalid_struct (euid))
	    *euid = sec_peer_uid;
	  if (!check_null_invalid_struct (egid))
	    *egid = sec_peer_gid;
	  return 0;
	}
d1715 1
d1717 14
a1730 3
  else
    set_errno (EINVAL);
  return -1;
@


1.153
log
@	* fhandler_socket.cc (fhandler_socket::eid_pipe_name): Fix format
	string.
	(fhandler_socket::connect): Set sun_path before running eid credential
	transaction.  Run transaction only if OS connect was successful.
	(fhandler_socket::accept): Run transaction only if OS accept was
	successful.
@
text
@d640 4
a676 1
	  set_sun_path (name->sa_data);
d682 1
a751 1
  bool in_progress = false;
d775 2
a776 4
  if ((SOCKET) res == INVALID_SOCKET && WSAGetLastError () == WSAEWOULDBLOCK)
    in_progress = true;

  if (get_addr_family () == AF_LOCAL && get_socket_type () == SOCK_STREAM)
d778 2
a779 7
      if ((SOCKET) res != INVALID_SOCKET || in_progress)
	{
	  if (!create_secret_event ())
	    secret_check_failed = true;
	  else if (in_progress)
	    signal_secret_event ();
	}
d781 1
a781 2
      if (!secret_check_failed &&
	  (SOCKET) res != INVALID_SOCKET)
d793 1
a793 2
	  if ((SOCKET) res != INVALID_SOCKET)
	    closesocket (res);
d798 7
a804 4
      if ((SOCKET) res != INVALID_SOCKET || in_progress)
        {
	  /* eid credential transaction. */
	  if (wincap.has_named_pipes ())
d806 2
a807 13
	      DWORD bytes = 0;
	      bool ret = ConnectNamedPipe (sec_pipe, NULL);
	      if (ret || GetLastError () == ERROR_PIPE_CONNECTED)
		{
		  if (!ReadFile (sec_pipe, &out, sizeof out, &bytes, NULL))
		    debug_printf ("Receiving eid credentials failed: %E");
		  else
		    debug_printf ("Received eid credentials: pid: %d, uid: %d"
		    		  ", gid: %d", out.pid, out.uid, out.gid);
		  if (!WriteFile (sec_pipe, &in, sizeof in, &bytes, NULL))
		    debug_printf ("Sending eid credentials failed: %E");
		  DisconnectNamedPipe (sec_pipe);
		}
d809 5
a813 8
		debug_printf ("Connecting the eid credential pipe failed: %E");
	    }
	  else /* 9x */
	    {
	      /* Incorrect but wrong pid at least doesn't break getpeereid. */
	      out.pid = sec_pid;
	      out.uid = sec_uid;
	      out.gid = sec_gid;
d815 9
@


1.152
log
@	* fhandler_socket.cc (fhandler_socket::listen): Don't limit the number
	of pipe instances.
@
text
@d59 2
a60 1
  __small_sprintf (buf, "\\\\.\\pipe\\cygwin-unix-$s", get_sun_path ());
d670 1
a670 2
      /* eid credential transaction. */
      if (wincap.has_named_pipes ())
d672 20
a691 5
	  struct ucred in = { getpid (), geteuid32 (), getegid32 () };
	  struct ucred out = { (pid_t) 0, (__uid32_t) -1, (__gid32_t) -1 };
	  DWORD bytes = 0;
	  if (CallNamedPipe(eid_pipe_name ((char *) alloca (CYG_MAX_PATH + 1)),
			    &in, sizeof in, &out, sizeof out, &bytes, 1000))
d693 4
a696 5
	      debug_printf ("Received eid credentials: pid: %d, uid: %d, gid: %d",
			    out.pid, out.uid, out.gid);
	      sec_peer_pid = out.pid;
	      sec_peer_uid = out.uid;
	      sec_peer_gid = out.gid;
a697 9
	  else
	    debug_printf ("Receiving eid credentials failed: %E");
	}
      else /* 9x */
        {
	  /* Incorrect but wrong pid at least doesn't break getpeereid. */
	  sec_peer_pid = getpid ();
	  sec_peer_uid = geteuid32 ();
	  sec_peer_gid = getegid32 ();
d804 1
a804 2
      /* eid credential transaction. */
      if (wincap.has_named_pipes ())
d806 2
a807 3
	  DWORD bytes = 0;
	  bool ret = ConnectNamedPipe (sec_pipe, NULL);
	  if (ret || GetLastError () == ERROR_PIPE_CONNECTED)
d809 13
a821 2
	      if (!ReadFile (sec_pipe, &out, sizeof out, &bytes, NULL))
		debug_printf ("Receiving eid credentials failed: %E");
d823 8
a830 5
		 debug_printf ("Received eid credentials: pid: %d, uid: %d, gid: %d",
			       out.pid, out.uid, out.gid);
	      if (!WriteFile (sec_pipe, &in, sizeof in, &bytes, NULL))
		debug_printf ("Sending eid credentials failed: %E");
	      DisconnectNamedPipe (sec_pipe);
a831 9
	  else
	    debug_printf ("Connecting the eid credential pipe failed: %E");
	}
      else /* 9x */
	{
	  /* Incorrect but wrong pid at least doesn't break getpeereid. */
	  out.pid = sec_pid;
	  out.uid = sec_uid;
	  out.gid = sec_gid;
@


1.151
log
@	* fhandler_socket.cc (fhandler_socket::ioctl): Only cancel
	WSAAsyncSelect when async mode is on.
@
text
@d729 2
a730 2
			     1, sizeof (struct ucred), sizeof (struct ucred),
			     1000, &sec_all);
@


1.150
log
@	* fhandler.h (class fhandler_socket): Declare new method
	set_socketpair_eids.
	* fhandler_socket.cc (fhandler_socket::set_socketpair_eids): New method.
	(fhandler_socket::dup): Duplicate sec_pipe if necessary.
	(fhandler_socket::listen): Only create sec_pipe if named pipes are
	available. Initialized sec_peer_pid to 0 as on Linux.
	(fhandler_socket::connect): Only run eid credential transaction if
	named pipes are available.  Fake otherwise. Initialized sec_peer_pid
	to 0 as on Linux.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::close): Move closing sec_pipe handle from here...
	(fhandler_socket::~fhandler_socket): ... to here.
	* net.cc (socketpair): Set eid credentials by calling
	fhandler_socket::set_socketpair_eids() on both socket ends.
	* wincap.h (wincaps::has_named_pipes): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d1597 1
a1597 1
      if (cmd == FIONBIO && *(int *) p == 0)
@


1.149
log
@	* cygwin.din (getpeereid): Export.
	* fhandler.h (class fhandler_socket): Add pipe and id members to
	exchange eid credentials for AF_LOCAL sockets.
	(eid_pipe_name): Declare new method.
	(getpeereid): Ditto.
	* fhandler_socket.cc (fhandler_socket::eid_pipe_name): New method.
	(fhandler_socket::fhandler_socket): Initialize sec_pipe.
	(fhandler_socket::connect): Exchange eid credentials with accepting
	socket process.
	(fhandler_socket::listen): Prepare eid credential transaction.
	(fhandler_socket::accept): Exchange eid credentials with connecting
	socket process.
	(fhandler_socket::close): Close eid credentials pipe if open.
	(fhandler_socket::getpeereid): New method.
	* net.cc (cygwin_getsockopt): Add SO_PEERCRED handling.
	(getpeereid): New function.
	* include/asm/socket.h (SO_PEERCRED): Define.
	* include/cygwin/socket.h (struct ucred): Define new type.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d63 8
d165 3
d355 2
d360 1
d362 24
a385 2
    fhs->set_sun_path (get_sun_path ());
  fhs->set_socket_type (get_socket_type ());
a416 1
  HANDLE nh;
d422 2
d670 24
a693 14
      struct ucred in = { getpid (), geteuid32 (), getegid32 () };
      struct ucred out = { (pid_t) -1, (__uid32_t) -1, (__gid32_t) -1 };
      DWORD bytes = 0;
      if (CallNamedPipe(eid_pipe_name ((char *) alloca (CYG_MAX_PATH + 1)),
      			&in, sizeof in, &out, sizeof out, &bytes, 1000))
	{
	  debug_printf ("Received eid credentials: pid: %d, uid: %d, gid: %d",
			out.pid, out.uid, out.gid);
	  sec_peer_pid = out.pid;
	  sec_peer_uid = out.uid;
	  sec_peer_gid = out.gid;
        }
      else
        debug_printf ("Receiving eid credentials failed: %E");
d719 1
a719 1
	  sec_peer_pid = (pid_t) -1;
d722 4
a725 1
	  sec_pipe =
d745 1
a745 1
  struct ucred out = { (pid_t) -1, (__uid32_t) -1, (__gid32_t) -1 };
d800 1
a800 3
      DWORD bytes = 0;
      bool ret = ConnectNamedPipe (sec_pipe, NULL);
      if (ret || GetLastError () == ERROR_PIPE_CONNECTED)
d802 13
a814 2
	  if (!ReadFile (sec_pipe, &out, sizeof out, &bytes, NULL))
	    debug_printf ("Receiving eid credentials failed: %E");
d816 8
a823 5
	     debug_printf ("Received eid credentials: pid: %d, uid: %d, gid: %d",
			   out.pid, out.uid, out.gid);
	  if (!WriteFile (sec_pipe, &in, sizeof in, &bytes, NULL))
	    debug_printf ("Sending eid credentials failed: %E");
	  DisconnectNamedPipe (sec_pipe);
a824 2
      else
        debug_printf ("Connecting the eid credential pipe failed: %E");
a1454 4
  /* Close eid credentials pipe handle. */
  if (sec_pipe != INVALID_HANDLE_VALUE)
    CloseHandle (sec_pipe);

@


1.148
log
@	* fhandler.h (enum query_state): Add query_write_attributes state.
	(fhandler_base::status.query_open): Add a bit to make room for more
	states.
	(class fhandler_base): Declare new method utimes.
	(class fhandler_socket): Ditto.
	(class fhandler_disk_file): Ditto.
	(fhandler_disk_file::fhandler_disk_file): Add constructor with
	path_conv parameter.
	* fhandler.cc (fhandler_base::open): Add query_write_attributes
	handling.
	(fhandler_base::utimes): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Simplify.
	Open file with query_write_attributes instead of query_write_control.
	(fhandler_disk_file::utimes): New method.
	(fhandler_disk_file::fhandler_disk_file): Add constructor with
	path_conv parameter setting pc member immediately.
	* fhandler_socket.cc (fhandler_socket::fchmod): Use new
	fhandler_disk_file constructor.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	(fhandler_socket::link): Ditto.
	(fhandler_socket::utimes): New method.
	* times.cc: Include dtable.h.
	(timeval_to_filetime): Make non-static.
	(utimes): Move functionality into fhandler method utimes. Just call
	this method from here.
	* winsup.h: Simplify declarations of time helper functions.
	(timeval_to_filetime): Add extern declaration.
@
text
@d56 7
d134 1
d631 16
d665 20
a684 1
    connect_state (connected);
d694 2
d748 17
a773 2
	  if (get_addr_family () == AF_LOCAL)
	    ((fhandler_socket *) res_fd)->set_sun_path (get_sun_path ());
d776 10
d1395 4
d1616 22
@


1.147
log
@copyright
@
text
@d417 1
a417 2
      fhandler_disk_file fh;
      fh.set_name (pc);
d431 1
a431 2
      fhandler_disk_file fh;
      fh.set_name (pc);
d442 1
a442 2
      fhandler_disk_file fh;
      fh.set_name (pc);
d453 1
a453 2
      fhandler_disk_file fh;
      fh.set_name (pc);
d460 11
@


1.146
log
@	* fhandler.h (class fhandler_base): Declare new method link.
	(class fhandler_socket): Ditto.
	(class fhandler_disk_file): Ditto.
	* fhandler.cc (fhandler_base::open): Add FILE_WRITE_ATTRIBUTES
	to query_write_control access flags.
	(fhandler_base::link): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Don't try to
	open with O_WRONLY since query_write_control includes
	FILE_WRITE_ATTRIBUTES.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::link): New method.  Touch st_ctime on successful
	link.
	* fhandler_socket.cc (fhandler_socket::link): New method.
	* syscalls.cc (link): Move functionality into fhandler method link.
	Just call this method from here.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.145
log
@	* fhandler.h (class fhandler_socket): Declare new methods fchown,
	fchmod and facl.
	* fhandler_socket.cc (fhandler_socket::fstat): Handle AF_LOCAL
	sockets.
	(fhandler_socket::fchmod): New method.
	(fhandler_socket::fchown): New method.
	(fhandler_socket::facl): New method.
@
text
@d452 12
@


1.144
log
@	* fhandler.cc (fhandler_base::get_proc_fd_name): Don't generate
	"device:" entry.
	* fhandler.h (fhandler_socket::open): New method.
	(fhandler_pipe::open): New method.
	* fhandler_proc.cc (fhandler_proc::exists): Return -2 in case of
	/proc/self.
	* fhandler_process.cc (fhandler_process::exists): Return -2 in
	case of symlinks, -3 for pipes and -4 for sockets.
	(fhandler_process::fstat): Handle pipes and sockets.
	(fhandler_process::open): Handle opening /proc/<pid>/fd.
	(fhandler_process::fill_filebuf): Generate empty names for
	non exisiting file descriptors.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Always
	generate "socket:[number]" strings as on Linux.
	(fhandler_socket::open): New method.
	(fhandler_socket::fstat): Always return socket type.
	* path.cc (symlink_info::set): Remove unused second parameter.
	(path_conv::check): Handle pipes and sockets in /proc.
	Set correct device type for AF_LOCAL sockets.
	* pinfo.cc (_pinfo::commune_recv): Generate empty names for
	non exisiting file descriptors.
	(_pinfo::fd): Ditto.
	* pipe.cc (fhandler_pipe::open): New method.
@
text
@d37 1
d390 2
a391 2
  int res = fhandler_base::fstat (buf);
  if (!res)
d393 15
a407 3
      buf->st_dev = 0;
      buf->st_ino = (__ino64_t) ((DWORD) get_handle ());
      buf->st_mode = S_IFSOCK | S_IRWXU | S_IRWXG | S_IRWXO;
d413 39
@


1.143
log
@	* cygheap.h (class cygheap_fdenum): New class to enumerate used
	fhandlers.
	* dtable.h (class dtable): Add cygheap_fdenum as friend class.
	* fhandler.h (fhandler_base::get_proc_fd_name): New virtual method
	to return a name for /proc/<pid>/fd.
	(fhandler_socket::get_proc_fd_name): Ditto.
	(fhandler_pipe::get_proc_fd_name): Ditto.
	(fhandler_virtual::opendir): Make virtual method.
	(fhandler_process::opendir): New method.
	* fhandler.cc (fhandler_base::get_proc_fd_name): New method.
	* fhandler_process.cc: Include ctype.h.
	(PROCESS_FD): Define.
	(process_listing): Add "fd".
	(fhandler_process::exists): Fix comment.  Return 1 in case of "fd"
	directory. Handle files below "fd".
	(fhandler_process::fstat): Drop "self" handling.  Set correct link
	count for directories.
	(fhandler_process::opendir): New method to handle "fd" directory.
	(fhandler_process::readdir): Add "fd" handling.
	(fhandler_process::open): Drop "self" handling.
	(fhandler_process::fill_filebuf): Ditto.  Add "fd" handling.  Fix
	"maps" output string.
	* fhandler_registry.cc (fhandler_registry::fstat): Set correct link
	count for directories.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): New method.
	* path.cc (symlink_info::set): Fix thinko.
	* pinfo.cc (_pinfo::commune_recv): Rename pathbuf to path throughout.
	Drop local path variable in PICOM_FIFO case.  Fix debug output.
	Close handles as early as possible. Add PICOM_FDS and PICOM_FD
	handling.
	(_pinfo::commune_send): Add PICOM_FDS and PICOM_FD handling.
	(_pinfo::fd): New method.
	(_pinfo::fds): New method.
	* pinfo.h (enum picom): Add PICOM_FDS and PICOM_FD.
	(_pinfo::fd): Declare.
	(_pinfo::fds): Declare.
	* pipe.cc (fhandler_pipe::get_proc_fd_name): New method.
@
text
@d152 1
a152 4
  if (get_sun_path ())
    __small_sprintf (buf, "%s", get_sun_path ());
  else
    __small_sprintf (buf, "socket:[%d]", get_socket ());
d156 7
d392 3
a394 14
      if (get_socket_type ()) /* fstat */
	{
	  buf->st_dev = 0;
	  buf->st_ino = (__ino64_t) ((DWORD) get_handle ());
	  buf->st_mode = S_IFSOCK | S_IRWXU | S_IRWXG | S_IRWXO;
	}
      else
	{
	  path_conv spc ("/dev", PC_SYM_NOFOLLOW | PC_NULLEMPTY, NULL);
	  buf->st_dev = spc.volser ();
	  buf->st_ino = get_namehash ();
	  buf->st_mode &= ~S_IRWXO;
	  buf->st_rdev = (get_device () << 16) | get_unit ();
	}
@


1.142
log
@* cygtls.cc (_cygtls::fixup_after_fork): Wipe out exitsock local since it
should not be used by the child.
* select.cc (start_thread_socket): Turn off inheritance for exitsock.  Don't
add exitsock to exception mask since it should never get an exception.
(socket_cleanup): Change some debug messages for consistency.
* fhandler_socket.cc (fhandler_socket::dup): Change comment wording slightly.
@
text
@d150 9
@


1.141
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d355 2
a356 2
  /* We don't call fhandler_base::dup here since that requires to
     have winsock called from fhandler_base and it creates only
@


1.140
log
@	* fhandler_socket.cc (fhandler_socket::dup): Decrement dtable's
	need_fixup_before counter on successful dup.
	* net.cc (cygwin_getpeername): Add file descriptor to debug output.
@
text
@d709 1
a709 1
      debug_printf ("WSACreateEvent: %E");
d714 1
a714 1
      debug_printf ("WSAEventSelect: %E");
@


1.139
log
@	* fhandler_socket.cc (fhandler_socket::release): Call
	WSASetLastError last.
@
text
@d347 4
a350 1
	    return 0;
d369 1
@


1.138
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d795 1
a800 1
  WSACloseEvent (event);
@


1.137
log
@	* fhandler_socket.cc (fhandler_socket::recvfrom): Use original flags
	value in each WSARecvFrom call.
	(fhandler_socket::recvmsg): Ditto.  Reformat slightly.
@
text
@d634 1
a634 1
        {
d727 1
a727 1
        ret = 0;
d734 1
a734 1
	        ret = 0;
d780 1
a780 1
        WSASetLastError (WSAEINTR);
d844 2
a845 2
              do
                {
d849 3
a851 3
                }
              while (res == SOCKET_ERROR
                     && WSAGetLastError () == WSAEWOULDBLOCK
d966 2
a967 2
              do
                {
d971 2
a972 2
                }
              while (res == SOCKET_ERROR
d1043 1
a1043 1
	      do 
d1051 1
a1051 1
	             && WSAGetLastError () == WSAEWOULDBLOCK
d1173 2
a1174 2
              do
                {
d1176 1
a1176 1
		  		   &ret, flags,
d1179 3
a1181 3
                }
              while (res == SOCKET_ERROR
	             && WSAGetLastError () == WSAEWOULDBLOCK
d1183 1
a1183 1
	             && !closed ());
d1384 1
a1384 1
        set_winsock_errno ();
@


1.136
log
@* cygthread.cc (cygthread::is): Eliminate.
* cygthread.h (cygthread::is): Eliminate declaratin.
* fhandler_console.cc (fhandler_console::read): Only wait for signal_arrived in
the main thread.
* fhandler_socket.cc: Include new "wininfo.h".
(fhandler_socket::ioctl): Use 'winmsg' rather than 'gethwnd()'.
* sync.cc (muto::grab): Define new function.
(muto::acquire): Use tls pointer rather than tid.
(muto::acquired): Ditto.
(muto::reset): Delete.
(muto::release): Ditto.  Also implement "close on last release".
* sync.h (muto::tid): Delete.
(muto::tls): New field.
(muto::ismine): Delete.
(muto::owner): Delete.
(muto::unstable): Delete.
(muto::reset): Delete.
(muto::upforgrabs): New method.
(muto::grab): Ditto.
(new_muto_name): New define.
* wininfo.h: New file.
(wininfo): New class.
* window.cc: Rework throughout to use winfo class for controlling invisible
window operation.
(gethwnd): Delete definition.
* winsup.h (gethwnd): Delete declaration.
@
text
@d846 2
a847 2
		  res = WSARecvFrom (get_socket (), &wsabuf, 1,
				     &ret, (DWORD *) &flags,
d898 1
a898 2
	res = recvfrom (iov->iov_base, iov->iov_len, flags,
			from, fromlen);
d922 1
a922 2
	      res = recvfrom (buf, tot, flags,
			      from, fromlen);
d959 2
a960 3
	res = WSARecvFrom (get_socket (),
			   wsabuf, iovcnt, (ret = 0, &ret), (DWORD *) &flags,
			   from, fromlen, NULL, NULL);
d968 3
a970 3
		  res = WSARecvFrom (get_socket (), wsabuf, iovcnt,
				     &ret, (DWORD *) &flags,
				     from, fromlen, NULL, NULL);
@


1.135
log
@revert previous not-ready-for-primetime checkin.
@
text
@d35 1
d1378 1
a1378 1
      res = WSAAsyncSelect (get_socket (), gethwnd (), WM_ASYNCIO,
d1394 1
a1394 1
	WSAAsyncSelect (get_socket (), gethwnd (), 0, 0);
d1404 1
a1404 1
	    WSAAsyncSelect (get_socket (), gethwnd (), WM_ASYNCIO, ASYNC_MASK);
@


1.134
log
@* cygheap.h: Remove some parameter names from declarations throughout.
(cygheap::set): Reflect changes in declaration for arguments and return value
from previous checkin.
@
text
@a34 1
#include "wininfo.h"
d1377 1
a1377 1
      res = WSAAsyncSelect (get_socket (), winmsg, WM_ASYNCIO,
d1393 1
a1393 1
	WSAAsyncSelect (get_socket (), winmsg, 0, 0);
d1403 1
a1403 1
	    WSAAsyncSelect (get_socket (), winmsg, WM_ASYNCIO, ASYNC_MASK);
@


1.133
log
@	* fhandler.h (class fhandler_socket): Add "owner" status flag.
	* fhandler_socket.cc (wait): Take flag parameter to take FD_OOB into
	account.  Don't wait infinitely.
	(fhandler_socket::recvfrom): Also wait for FD_OOB if socket owner.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	(fhandler_socket::fcntl): Set owner status flag if F_SETOWN with own
	pid is called.
@
text
@d35 1
d1378 1
a1378 1
      res = WSAAsyncSelect (get_socket (), gethwnd (), WM_ASYNCIO,
d1394 1
a1394 1
	WSAAsyncSelect (get_socket (), gethwnd (), 0, 0);
d1404 1
a1404 1
	    WSAAsyncSelect (get_socket (), gethwnd (), WM_ASYNCIO, ASYNC_MASK);
@


1.132
log
@	Revert code reversion from 2004-04-03.  So, revert to async I/O again.
	* fhandler.h (status): Add "closed" flag.
	(prepare): New method declaration.
	(wait): Ditto.
	(release): Ditto.
	* fhandler_socket.cc: Don't include wsock_event.h.
	(fhandler_socket::prepare): New method, moved from wsock_event.
	(fhandler_socket::wait): Ditto.
	(fhandler_socket::release): New method.
	(fhandler_socket::recvfrom): Simplify loop.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc: Don't include wsock_event.h.
	(wsock_event::prepare): Remove.
	(wsock_event::wait): Ditto.
	* wsock_event.h: Remove.
@
text
@d716 1
a716 1
fhandler_socket::wait (HANDLE event)
d723 1
a723 1
  switch (WSAWaitForMultipleEvents (2, ev, FALSE, WSA_INFINITE, FALSE))
d725 3
d736 13
d841 1
a841 1
	  if (prepare (evt, FD_CLOSE | ((flags & MSG_OOB) ? FD_OOB : FD_READ)))
d852 1
a852 1
		     && !(res = wait (evt)));
d966 1
a966 1
	  if (prepare (evt, FD_CLOSE | ((flags & MSG_OOB) ? FD_OOB : FD_READ)))
d977 1
a977 1
		     && !(res = wait (evt)));
d1043 1
a1043 1
	  if (prepare (evt, FD_CLOSE | FD_WRITE))
d1054 1
a1054 1
		     && !(res = wait (evt))
d1173 1
a1173 1
	  if (prepare (evt, FD_CLOSE | FD_WRITE))
d1184 1
a1184 1
		     && !(res = wait (evt))
d1421 8
@


1.131
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@a32 1
#include "wsock_event.h"
d697 89
d807 1
a807 1
  int res;
d819 3
a821 4
      if (is_nonblocking ())
	res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret, (DWORD *) &flags,
			   from, fromlen,
			   NULL, NULL);
d824 15
a838 7
	  wsock_event wsock_evt;
	  res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret, (DWORD *) &flags,
			     from, fromlen,
			     wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
d876 1
a876 1
  int res;
d943 1
a943 1
      if (is_nonblocking ())
d945 2
a946 3
			   wsabuf, iovcnt, &ret, (DWORD *) &flags,
			   from, fromlen,
			   NULL, NULL);
d949 15
a963 8
	  wsock_event wsock_evt;
	  res = WSARecvFrom (get_socket (),
			     wsabuf, iovcnt, &ret, (DWORD *) &flags,
			     from, fromlen,
			     wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
d1008 1
a1008 1
  int res;
d1019 2
a1020 2
      if (is_nonblocking ())
	res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
d1026 16
a1041 8
	  wsock_event wsock_evt;
	  res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
			   flags & MSG_WINMASK,
			   (to ? (const struct sockaddr *) &sin : NULL), tolen,
			   wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
d1081 1
a1081 1
  int res;
d1150 4
a1153 5
      if (is_nonblocking ())
	res = WSASendTo (get_socket (), wsabuf, iovcnt, &ret, flags,
			 (struct sockaddr *) msg->msg_name,
			 msg->msg_namelen,
			 NULL, NULL);
d1156 16
a1171 8
	  wsock_event wsock_evt;
	  res = WSASendTo (get_socket (), wsabuf, iovcnt, &ret, flags,
			   (struct sockaddr *) msg->msg_name,
			   msg->msg_namelen,
			   wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
@


1.130
log
@	* fhandler.h (fhandler_base::status): Declare private.
	(fhandler_base::open_status): Ditto.
	(class fhandler_socket): Move status bits into private bitfield struct
	type status_flags.  Change accessor methods appropriately.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	above status bit changes.
	* tty.h: Remove status bit enumerator.
	(TTYISSETF): Remove.
	(TTYSETF): Remove.
	(TTYCLEARF): Remove.
	(TTYCONDSETF): Remove.
	(tty_min::status): Define as private bitfield struct type status_flags.
	Add appropriate accessor methods.
	* fhandler_console.cc: Use tty_min::status accessor methods throughout.
	* fhandler_termios.cc: Ditto.
	* winsup.h (__ISSETF): Remove.
	(__SETF): Remove.
	(__CLEARF): Remove.
	(__CONDSETF): Remove.
@
text
@d129 1
a129 1
  set_need_fork_fixup ();
d203 1
a203 1
  else if (get_close_on_exec ())
d311 1
a311 1
  if (!get_close_on_exec ())
d328 1
a328 1
  fhs->set_connect_state (get_connect_state ());
d504 1
a504 1
      if (is_nonblocking () || is_connect_pending ())
d550 1
a550 1
    set_connect_state (connect_pending);
d552 1
a552 1
    set_connect_state (connected);
d564 1
a564 1
    set_connect_state (connected);
d639 1
a639 1
	  ((fhandler_socket *) res_fd)->set_connect_state (connected);
d1091 1
a1091 1
	set_shutdown_read ();
d1094 1
a1094 1
	set_shutdown_write ();
d1097 2
a1098 2
	set_shutdown_read ();
	set_shutdown_write ();
d1249 1
a1249 1
      set_async (*(int *) p);
d1270 1
a1270 1
	  if (*(int *) p && get_async ())
d1312 1
a1312 1
fhandler_socket::set_close_on_exec (int val)
d1318 1
a1318 1
  set_close_on_exec_flag (val);
@


1.129
log
@	* fhandler.cc (fhandler_base::write): Use bool parameter in calls to
	set_did_lseek.
	(fhandler_base::fhandler_base): Accomodate new status and open_status
	constructor.
	* fhandler.h: Remove status bit enumerator.
	(FHDEVN): Remove.
	(FHISSETF): Remove.
	(FHSETF): Remove.
	(FHCLEARF): Remove.
	(FHCONDSETF): Remove.
	(FHSTATOFF): Remove.
	(UNCONNECTED, CONNECT_PENDING, CONNECTED): Substitute by enum
	connect_state.
	(fhandler_base::status): Define as bitfield struct type status_flags.
	Remove unused flags entirely.  Accomodate all status access methods.
	(open_status): Define as bitfield struct type status_flags.
	(fhandler_socket): Move socket related status bits to here.  Redefine
	had_connect_or_listen to be part of these status bits.  Accomodate
	related access methods.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Use pc.issymlink
	instead of dropped method get_symlink_p.
	(fhandler_base::open_fs): Remove setting dropped status flags.
	* fhandler_socket.cc: Use values from enum connect_state throughout.
	(fhandler_socket::fhandler_socket): Initialize status bits.
	* fhandler_virtual.cc (fhandler_virtual::open): Remove setting dropped
	status flags.
	* net.cc: Use values from enum connect_state throughout.
	* select.cc: Ditto.
	* shared_info.h: Protect struct console_state using _FHANDLER_H_
	instead of FHDEVN.
@
text
@d127 1
a127 3
  sock_saw_shut_rd (0),
  sock_saw_shut_wr (0),
  had_connect_or_listen (unconnected)
@


1.128
log
@	* fhandler.h (class fhandler_socket): Remove has_been_closed member.
	* fhandler_socket.cc (fhandler_socket::recvfrom): Revert to
	overlapped I/O.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (wsock_event::prepare): Ditto.
	(wsock_event::wait): Ditto.  Evaluate overlapped result also after
	calling CancelIo (thanks to Patrick Samson <p_samson@@yahoo.com>).
	(wsock_event::release): Remove.
	* wsock_event.h: Revert to overlapped I/O.
@
text
@d124 6
a129 2
fhandler_socket::fhandler_socket ()
  : fhandler_base (), sun_path (NULL)
d552 1
a552 1
    set_connect_state (CONNECT_PENDING);
d554 1
a554 1
    set_connect_state (CONNECTED);
d566 1
a566 1
    set_connect_state (CONNECTED);
d641 1
a641 1
	  ((fhandler_socket *) res_fd)->set_connect_state (CONNECTED);
@


1.127
log
@	* fhandler_socket.cc (fhandler_socket::recvfrom): Rearrange loop
	so that WSARecvFrom is always called before waiting.
	(fhandler_socket::recvmsg): Ditto.
@
text
@d125 1
a125 1
  : fhandler_base (), sun_path (NULL), has_been_closed (0)
d717 1
a717 1
  int res = SOCKET_ERROR;
d729 4
a732 3
      if (is_nonblocking () || has_been_closed)
	res = WSARecvFrom (get_socket (), &wsabuf, 1, (ret = 0, &ret),
			   (DWORD *) &flags, from, fromlen, NULL, NULL);
d736 6
a741 16
	  long evt = (FD_CLOSE | ((flags & MSG_OOB) ? FD_OOB : FD_READ));
	  if (wsock_evt.prepare (get_socket (), evt))
	    {
              do
                {
		  res = WSARecvFrom (get_socket (), &wsabuf, 1,
				     (ret = 0, &ret), (DWORD *) &flags,
				     from, fromlen, NULL, NULL);
                }
              while (res == SOCKET_ERROR
                     && WSAGetLastError () == WSAEWOULDBLOCK
		     && !has_been_closed
		     && !(res = wsock_evt.wait (get_socket (),
		     				has_been_closed)));
	      wsock_evt.release (get_socket ());
	    }
d779 1
a779 1
  int res = SOCKET_ERROR;
d846 1
a846 1
      if (is_nonblocking () || has_been_closed)
d848 3
a850 2
			   wsabuf, iovcnt, (ret = 0, &ret), (DWORD *) &flags,
			   from, fromlen, NULL, NULL);
d854 7
a860 16
	  long evt = (FD_CLOSE | ((flags & MSG_OOB) ? FD_OOB : FD_READ));
	  if (wsock_evt.prepare (get_socket (), evt))
	    {
              do
                {
		  res = WSARecvFrom (get_socket (), wsabuf, iovcnt,
				     (ret = 0, &ret), (DWORD *) &flags,
				     from, fromlen, NULL, NULL);
                }
              while (res == SOCKET_ERROR
		     && WSAGetLastError () == WSAEWOULDBLOCK
		     && !has_been_closed
		     && !(res = wsock_evt.wait (get_socket (),
		     				has_been_closed)));
	      wsock_evt.release (get_socket ());
	    }
d903 1
a903 1
    return -1;
d905 1
a905 1
  int res = SOCKET_ERROR;
d916 2
a917 2
      if (is_nonblocking () || has_been_closed)
	res = WSASendTo (get_socket (), &wsabuf, 1, (ret = 0, &ret),
d924 7
a930 21
	  if (wsock_evt.prepare (get_socket (), FD_CLOSE | FD_WRITE))
	    {
	      do 
		{
		  res = WSASendTo (get_socket (), &wsabuf, 1, (ret = 0, &ret),
				   flags & MSG_WINMASK,
				   (to ? (const struct sockaddr *) &sin : NULL),
				   tolen, NULL, NULL);
		  if (res != SOCKET_ERROR
		      || WSAGetLastError () != WSAEWOULDBLOCK)
		    break;
		  if (ret > 0)
		    {
		      res = 0;
		      break;
		    }
		}
	      while (!(res = wsock_evt.wait (get_socket (), has_been_closed))
		     && !has_been_closed);
	      wsock_evt.release (get_socket ());
	    }
d970 1
a970 1
  int res = SOCKET_ERROR;
d1039 5
a1043 4
      if (is_nonblocking () || has_been_closed)
	res = WSASendTo (get_socket (), wsabuf, iovcnt, (ret = 0, &ret),
			 flags, (struct sockaddr *) msg->msg_name,
			 msg->msg_namelen, NULL, NULL);
d1047 7
a1053 21
	  if (wsock_evt.prepare (get_socket (), FD_CLOSE | FD_WRITE))
	    {
              do
                {
		  res = WSASendTo (get_socket (), wsabuf, iovcnt,
		  		   (ret = 0, &ret), flags,
				   (struct sockaddr *) msg->msg_name,
				   msg->msg_namelen, NULL, NULL);
                  if (res != SOCKET_ERROR
                      || WSAGetLastError () != WSAEWOULDBLOCK)
                    break;
                  if (ret > 0)
                    {
                      res = 0;
                      break;
                    }
                }
              while (!(res = wsock_evt.wait (get_socket (), has_been_closed))
	             && !has_been_closed);
	      wsock_evt.release (get_socket ());
	    }
@


1.126
log
@	* fhandler_socket.cc (fhandler_socket::sendto): Drop out of loop if
	has_been_closed gets set.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (wsock_event::wait): Don't initialize evts.  Don't try to
	evaluate network events if WSAEnumNetworkEvents fails.
	(wsock_event::release): Save last WSA error and set it again unless
	resetting to blocking socket fails.
	* wsock_event.h (class wsock_event): Remove destructor.
@
text
@d740 3
a742 4
                  if (!(res = wsock_evt.wait (get_socket (), has_been_closed)))
		    res = WSARecvFrom (get_socket (), &wsabuf, 1,
				       (ret = 0, &ret), (DWORD *) &flags,
				       from, fromlen, NULL, NULL);
d746 3
a748 1
                     && !has_been_closed);
d867 3
a869 4
                  if (!(res = wsock_evt.wait (get_socket (), has_been_closed)))
		    res = WSARecvFrom (get_socket (), wsabuf, iovcnt,
				       (ret = 0, &ret), (DWORD *) &flags,
				       from, fromlen, NULL, NULL);
d872 4
a875 2
                     && WSAGetLastError () == WSAEWOULDBLOCK
                     && !has_been_closed);
@


1.125
log
@	* fhandler_socket.cc (fhandler_socket::recvfrom): Always initialize
	ret to 0 when using in Winsock call.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
@
text
@d956 2
a957 1
	      while (!(res = wsock_evt.wait (get_socket (), has_been_closed)));
d1092 2
a1093 1
              while (!(res = wsock_evt.wait (get_socket (), has_been_closed)));
@


1.124
log
@	* fhandler_socket.cc (fhandler_socket::sendmsg): Add SIGPIPE handling.
@
text
@d730 2
a731 2
	res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret, (DWORD *) &flags,
			   from, fromlen, NULL, NULL);
d741 3
a743 3
		    res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret,
				       (DWORD *) &flags, from, fromlen,
				       NULL, NULL);
d856 2
a857 3
			   wsabuf, iovcnt, &ret, (DWORD *) &flags,
			   from, fromlen,
			   NULL, NULL);
d867 3
a869 3
		    res = WSARecvFrom (get_socket (), wsabuf, iovcnt, &ret,
				       (DWORD *) &flags, from, fromlen,
				       NULL, NULL);
d932 1
a932 1
	res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
d943 1
a943 1
		  res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
d1068 3
a1070 4
	res = WSASendTo (get_socket (), wsabuf, iovcnt, &ret, flags,
			 (struct sockaddr *) msg->msg_name,
			 msg->msg_namelen,
			 NULL, NULL);
d1078 3
a1080 2
		  res = WSASendTo (get_socket (), wsabuf, iovcnt, &ret,
				   flags, (struct sockaddr *) msg->msg_name,
@


1.123
log
@	* fhandler_socket.cc (fhandler_socket::recvfrom): Initialize res to
	SOCKET_ERROR.  Use SOCKET_ERROR instead of -1 throughout.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (wsock_event::prepare): Call WSASetLastError instead of
	SetLastError.
	(wsock_event::wait): Use SOCKET_ERROR instead of -1.
@
text
@d1103 13
@


1.122
log
@	* fhandler.h (class fhandler_socket): Add has_been_closed member.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	has_been_closed to 0.
	(fhandler_socket::recvfrom): Use new asynchronous I/O driven
	wsock_event methods.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (wsock_event::prepare): Reimplement using asynchronous I/O.
	(wsock_event::wait): Ditto.
	(wsock_event::release): New method.
	* wsock_event.h (class wsock_event): Remove ovr member.  Accomodate
	new implementation of prepare and wait methods.  Add release method.
@
text
@d717 1
a717 1
  int res;
d731 1
a731 2
			   from, fromlen,
			   NULL, NULL);
a759 1
      res = -1;
d787 1
a787 1
  int res;
d813 1
a813 1
	      res = -1;
a885 1
	  res = -1;
d921 1
a921 1
  int res;
d964 1
a964 4
    {
      res = -1;
      set_winsock_errno ();
    }
d973 1
a973 1
  if (res == -1 && get_errno () == ESHUTDOWN
d999 1
a999 1
  int res;
d1026 1
a1026 1
	      res = -1;
d1098 1
a1098 4
	{
	  res = -1;
	  set_winsock_errno ();
	}
@


1.121
log
@	* fhandler_socket.cc (fhandler_socket::ioctl): Add FIONREAD handling.
@
text
@d125 1
a125 1
  : fhandler_base (), sun_path (NULL)
d729 1
a729 1
      if (is_nonblocking ())
d736 15
a750 6
	  res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret, (DWORD *) &flags,
			     from, fromlen,
			     wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
d856 1
a856 1
      if (is_nonblocking ())
d864 15
a878 7
	  res = WSARecvFrom (get_socket (),
			     wsabuf, iovcnt, &ret, (DWORD *) &flags,
			     from, fromlen,
			     wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
d935 1
a935 1
      if (is_nonblocking ())
d943 20
a962 7
	  res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
			   flags & MSG_WINMASK,
			   (to ? (const struct sockaddr *) &sin : NULL), tolen,
			   wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
d1074 1
a1074 1
      if (is_nonblocking ())
d1082 19
a1100 7
	  res = WSASendTo (get_socket (), wsabuf, iovcnt, &ret, flags,
			   (struct sockaddr *) msg->msg_name,
			   msg->msg_namelen,
			   wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
@


1.120
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d1244 5
@


1.119
log
@* fhandler.h (*::fixup_after_exec): Eliminate unused handle argument.
* fhandler.h (dtable::fixup_after_exec): Eliminate unused handle argument.
* dcrt0.cc (dll_crt0_1): Reflect elimination of unused handle argument to
fixup_after_exec.
* dtable.cc (dtable::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_raw::fixup_after_exec): Ditto.
* fhandler_socket.cc (fhandler_socket::fixup_after_exec): Ditto.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Ditto.
* pipe.cc (fhandler_pipe::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Do not set ciresrv.parent.
* child_info.h (child_info_spawn::~child_info_spawn): Do not close parent.
Update CURR_CHILD_INFO_MAGIC.
* dcrt0.cc (dll_crt0_0): Do not close spawn_info->parent.  Pass NULL to
cygheap->fdtab.fixup_after_exec().
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Red Hat, Inc.
@


1.118
log
@Throughout, change name from set_inheritance to set_no_inheritance to better
reflect input arguments of this function.
* cygheap.h (CYGHEAPSIZE): Increase size of cygheap to something closer to the
21st century.
@
text
@d306 1
a306 1
fhandler_socket::fixup_after_exec (HANDLE parent)
d310 1
a310 1
    fixup_after_fork (parent);
@


1.117
log
@2004-01-23  Pierre Humblet <pierre.humblet@@ieee.org>

        * fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid
        creating multiple handles. Always allow event inheritance but set the
        handle inheritance appropriately. Improve error handling.
        (fhandler_socket::check_peer_secret_event): Improve error handling.
        (fhandler_socket::close_secret_event): Simply call CloseHandle.
        (fhandler_socket::set_close_on_exec): Set secret event inheritance.
@
text
@d203 1
a203 1
    set_inheritance (secret_event, 1);
d1303 1
a1303 1
    set_inheritance (secret_event, val);
d1305 1
a1305 1
    set_inheritance (get_handle (), val);
@


1.116
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d186 3
d197 1
a197 4
  LPSECURITY_ATTRIBUTES sec = get_inheritance (true);
  secret_event = CreateEvent (sec, FALSE, FALSE, event_name);
  if (!secret_event && GetLastError () == ERROR_ALREADY_EXISTS)
    secret_event = OpenEvent (EVENT_ALL_ACCESS, FALSE, event_name);
d200 4
a203 5
    /* nothing to do */;
  else if (sec == &sec_all_nih || sec == &sec_none_nih)
    ProtectHandle (secret_event);
  else
    ProtectHandleINH (secret_event);
d224 1
a224 1
    ForceCloseHandle (secret_event);
d236 2
a237 5
  if (!ev && GetLastError () == ERROR_ALREADY_EXISTS)
    {
      debug_printf ("event \"%s\" already exists", event_name);
      ev = OpenEvent (EVENT_ALL_ACCESS, FALSE, event_name);
    }
d1302 2
@


1.115
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d366 1
@


1.115.6.1
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a185 3
  if (secret_event)
    return secret_event;

d194 4
a197 1
  secret_event = CreateEvent (&sec_all, FALSE, FALSE, event_name);
d200 5
a204 4
    debug_printf("create event %E");
  else if (get_close_on_exec ())
    /* Event allows inheritance, but handle will not be inherited */
    set_inheritance (secret_event, 1);
d225 1
a225 1
    CloseHandle (secret_event);
d237 5
a241 2
  if (!ev)
    debug_printf("create event %E");
a365 1
  VerifyHandle (nh);
a1304 2
  if (secret_event)
    set_inheritance (secret_event, val);
@


1.114
log
@	* dir.cc (mkdir): Use local security_descriptor. Call
	set_security_attribute appropriately.
	* external.cc (cygwin_internal): Ditto.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
	* sec_acl.cc (setacl): Ditto. Call read_sd appropriately.
	(getace): Ditto.
	* sec_helper.cc (security_descriptor::malloc): New method.
	(security_descriptor::realloc): New method.
	(security_descriptor::free): New method.
	* security.cc (read_sd): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	Allocate the security_descriptor buffer according to size returned by
	a call to GetFileSecurity. Return buffer size on success.
	(write_sd): Get security_descriptor as parameter instead of
	PSECURITY_DESCRIPTOR and a size.
	(get_nt_attribute): Use local security_descriptor.
	(get_nt_object_attribute): Ditto in case of type == SE_REGISTRY_KEY.
	Allocate security_descriptor buffer according to size returned by
	a call to RegGetKeySecurity.
	(alloc_sd): Make static. Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	(set_security_attribute): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size.
	(set_nt_attribute): Use local security_descriptor.
	(check_file_access): Ditto.
	* security.h: Add class security_descriptor.
	(read_sd): Change declaration to get security_descriptor as parameter
	instead of PSECURITY_DESCRIPTOR and a size.
	(write_sd): Ditto.
	(set_security_attribute): Ditto.
	(alloc_sd): Remove declaration.
	* thread.cc (semaphore::semaphore): Use local security_descriptor. Call
	set_security_attribute appropriately.
@
text
@d490 2
a491 2
  BOOL secret_check_failed = FALSE;
  BOOL in_progress = FALSE;
d509 1
a509 1
	    in_progress = TRUE;
d524 1
a524 1
	      secret_check_failed = TRUE;
d535 1
a535 1
	      secret_check_failed = TRUE;
d573 2
a574 2
  BOOL secret_check_failed = FALSE;
  BOOL in_progress = FALSE;
d597 1
a597 1
    in_progress = TRUE;
d604 1
a604 1
	    secret_check_failed = TRUE;
d615 1
a615 1
	      secret_check_failed = TRUE;
@


1.113
log
@	* cygserver.h (client_request::request_code_t): Add
	CYGSERVER_REQUEST_MSG and CYGSERVER_REQUEST_SEM.
	(admininstrator_group_sid): Add extern declaration.
	* cygserver_ipc.h: Rewrite.
	* cygserver_msg.h: New file.
	* cygserver_sem.h: New file.
	* cygserver_shm.h: More or less rewrite.
	* cygwin.din: Add msgctl, msgget, msgrcv, msgsnd, semctl, semget and
	semop.
	* msg.cc: Rewrite.
	* safe_memory.h: Remove.
	* sem.cc: Rewrite.
	* shm.cc: Rewrite.
	* include/cygwin/ipc.h: Use appropriate guard.
	(struct ipc_perm): Add seq.
	(IPCID_TO_IX): New define from BSD.
	(IPCID_TO_SEQ): Ditto.
	(IXSEQ_TO_IPCID): Ditto.
	(IPC_R): Ditto.
	(IPC_W): Ditto.
	(IPC_M): Ditto.
	* include/cygwin/msg.h: Use appropriate guard. #ifdef _KERNEL all stuff
	not explicitely defined by SUSv3. Use signed types in structs to match
	types used in BSD.
	(msgqnum_t): Define unsigned.
	(msglen_t): Ditto.
	(struct msqid_ds): Add msg_first and msg_last.
	(struct msginfo): Remove msgpool. Add msgssz and msgseg.
	* include/cygwin/sem.h: Use appropriate guard. #ifdef _KERNEL all stuff
	not explicitely defined by SUSv3. Use signed types in structs to match
	types used in BSD.
	(SEM_UNDO): Define appropriately.
	(struct semid_ds): Add sem_base.
	(struct seminfo): Add semmap and semusz.
	(SEM_A): New define from BSD.
	(SEM_R): Ditto.
	(SEM_ALLOC): Ditto.
	(union semun): Define.
	* include/cygwin/shm.h: Use appropriate guard. #ifdef _KERNEL all stuff
	not explicitely defined by SUSv3. Use signed types in structs to match
	types used in BSD.
	(SHMLBA): Define using cygwin_internal(CW_GET_SHMLBA) call.
	(struct shmid_ds): Add shm_internal.
	(struct shm_info): Rename shm_ids to used_ids as in BSD.  Add define
	for shm_ids.
	* include/cygwin/sysproto.h: New file.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/ipc.h: New file.
	* include/sys/msg.h: New file.
	* include/sys/queue.h: New file from BSD.
	* include/sys/sem.h: New file.
	* include/sys/shm.h: New file.
	* include/sys/sysproto.h: New file.
@
text
@d445 1
d447 1
a447 1
	set_security_attribute (mode, &sa, alloca (4096), 4096);
@


1.112
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d1109 1
a1109 1
  linger.l_linger = 240; /* seconds. default 2MSL value according to MSDN. */
@


1.111
log
@* include/tzfile.h: Add some missing entries.
@
text
@d192 1
a192 1
  char event_name[MAX_PATH];
d233 1
a233 1
  char event_name[MAX_PATH];
@


1.110
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d250 1
a250 1
      return (rc == WAIT_OBJECT_0 ? 1 : 0 );
d533 1
a533 1
	      debug_printf ( "accept from unauthorized server" );
@


1.109
log
@	* fhandler_socket.cc (fhandler_socket::fstat): Don't use PC_POSIX.
@
text
@d28 1
a29 1
#include "path.h"
d38 1
a38 3
#define ENTROPY_SOURCE_DEV_UNIT 9

extern fhandler_socket *fdsock (int& fd, const char *name, SOCKET soc);
d124 2
a125 2
fhandler_socket::fhandler_socket (int nunit)
  : fhandler_base (FH_SOCKET), sun_path (NULL), unit (nunit)
d130 8
d154 2
a155 1
      entropy_source = new (buf) fhandler_dev_random (ENTROPY_SOURCE_DEV_UNIT);
d158 1
a158 1
      !entropy_source->open (NULL, O_RDONLY))
d371 1
a371 1
fhandler_socket::fstat (struct __stat64 *buf, path_conv *pc)
d373 1
a373 17
  int res;
  if (get_addr_family () == AF_LOCAL && get_sun_path () && !get_socket_type ())
    {
      path_conv spc (get_sun_path (), PC_SYM_NOFOLLOW | PC_NULLEMPTY | PC_FULL,
		     NULL);
      fhandler_base *fh = cygheap->fdtab.build_fhandler (-1, FH_DISK,
							 get_sun_path (),
							 spc, 0);
      if (fh)
	{
	  res = fh->fstat (buf, &spc);
	  buf->st_rdev = buf->st_size = buf->st_blocks = 0;
	  return res;
	}
    }

  res = fhandler_base::fstat (buf, pc);
d633 2
a634 5
      fhandler_socket* res_fh = NULL;
      if (res_fd >= 0)
	  res_fh = fdsock (res_fd, get_name (), res);
      if (res_fh)
	{
d636 4
a639 4
	    res_fh->set_sun_path (get_sun_path ());
	  res_fh->set_addr_family (get_addr_family ());
	  res_fh->set_socket_type (get_socket_type ());
	  res_fh->set_connect_state (CONNECTED);
d649 1
@


1.108
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@d369 1
a369 2
      path_conv spc (get_sun_path (),
		     PC_SYM_NOFOLLOW | PC_NULLEMPTY | PC_FULL | PC_POSIX,
@


1.107
log
@	* fhandler.h (fhandler_socket::get_connect_state): New method to
	return socket connection state.
	* fhandler_socket.cc (dup): Copy socket connect state to new file
	handle.
	* net.cc (cygwin_rcmd): Mark file handles of sockets returned by
	rcmd() as CONNECTED state.
	(cygwin_rexec): Similarly for rexec().
	(socketpair): Mark both ends of a new socket pair as CONNECTED.
@
text
@d52 1
a52 1
  		   port,
d227 1
a227 1
  
d959 1
a959 1
     
@


1.106
log
@	* cygheap.h (enum impersonation): New enum.
	(cygheap_user::token): Delete.
	(cygheap_user::impersonated): Delete.
	(cygheap_user::external_token): New member.
	(cygheap_user::internal_token): New member.
	(cygheap_user::impersonation_state): New member.
	(cygheap_user::issetuid): Modify.
	(cygheap_user::token): New method.
	(cygheap_user::deimpersonate): New method.
	(cygheap_user::reimpersonate): New method.
	(cygheap_user::has_impersonation_tokens): New method.
	(cygheap_user::close_impersonation_tokens): New method.
	* dtable.cc (dtable::vfork_child_dup): Use new cygheap_user methods.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fork.cc (fork_child): Ditto.
	(fork_parent): Ditto.
	* grp.cc (internal_getgroups): Ditto.
	* security.cc (verify_token): Ditto.
	(check_file_access): Ditto.
	(cygwin_set_impersonation_token): Detect conflicts. Set
	user.external_token.
	* spawn.cc (spawn_guts): Use new cygheap_user methods.
	* syscalls.cc (seteuid32): Rearrange to use the two tokens
	in cygheap_user.
	(setegid32): Use new cygheap_user methods.
	* uinfo.cc: (internal_getlogin): Ditto.
@
text
@d323 1
@


1.105
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d333 1
a333 2
      if (cygheap->user.issetuid ())
	RevertToSelf ();
d336 1
a336 2
      if (cygheap->user.issetuid ())
	ImpersonateLoggedOnUser (cygheap->user.token);
@


1.104
log
@
* fhandler_socket.cc (fhandler_socket::connect): Change error
handling for nonblocking connects to return EALREADY when
connect is called more than once for the same socket.
@
text
@a15 1
#include <errno.h>
@


1.103
log
@	* fhandler_socket.cc (connect_thread): Remove.
	(accept_thread): Remove.
	(fhandler_socket::connect): Remove all special blocking handling.
	(fhandler_socket::accept): Ditto.
	* net.cc (cygwin_connect): Make blocking sockets temporarily
	non-blocking and call cygwin_select on them to be interruptible.
	(cygwin_accept):  Ditto.
@
text
@d505 1
d518 1
a518 1
	  DWORD err = WSAGetLastError ();
d520 4
a523 4
	    {
	      WSASetLastError (WSAEINPROGRESS);
	      in_progress = TRUE;
	    }
d560 2
a561 1
  if (WSAGetLastError () == WSAEINPROGRESS)
@


1.102
log
@	* fhandler_socket.cc (fhandler_socket::accept): Rename `signalled'
	to `interrupted' as used in fhandler_socket::connect.
@
text
@d36 1
a123 24
struct sock_thread_data
{
  int socket;
  sockaddr *peer;
  int *len;
  int ret;
};

static DWORD WINAPI
connect_thread (void *arg)
{
  sock_thread_data *std = (sock_thread_data *) arg;
  std->ret = ::connect (std->socket, std->peer, *std->len);
  return 0;
}

static DWORD WINAPI
accept_thread (void *arg)
{
  sock_thread_data *std = (sock_thread_data *) arg;
  std->ret = ::accept (std->socket, std->peer, std->len);
  return 0;
}

a499 1
  BOOL interrupted = FALSE;
d509 1
a509 12
  if (!is_nonblocking ())
    {
      sock_thread_data cd = { get_socket (), (sockaddr *) &sin, &namelen, -1 };
      cygthread *thread = new cygthread (connect_thread, &cd, "connect");
      HANDLE waitevt = CreateEvent(&sec_none_nih, FALSE, TRUE, NULL);
      interrupted = thread->detach (waitevt);
      CloseHandle (waitevt);
      if (!interrupted)
        res = cd.ret;
    }
  else
    res = ::connect (get_socket (), (sockaddr *) &sin, namelen);
a563 3
  if (interrupted)
    set_errno (EINTR);

d603 1
a603 13
  if (!is_nonblocking ())
    {
      sock_thread_data ad = { get_socket (), peer, len, -1 };
      cygthread *thread = new cygthread (accept_thread, &ad, "accept");
      HANDLE waitevt = CreateEvent(&sec_none_nih, FALSE, TRUE, NULL);
      BOOL interrupted = thread->detach (waitevt);
      CloseHandle (waitevt);
      if (interrupted)
	return -1;
      res = ad.ret;
    }
  else
    res = ::accept (get_socket (), peer, len);
@


1.101
log
@	* fhandler_socket.cc (fhandler_socket::connect): Simplify previous
	patch.
	(fhandler_socket::accept): Ditto.
@
text
@d646 1
a646 1
      bool signalled = thread->detach (waitevt);
d648 1
a648 1
      if (signalled)
@


1.100
log
@	* fhandler_socket.cc: Include cygthread.h.
	(class sock_event): Remove.
	(thread_connect): New function.
	(thread_accept): Ditto.
	(fhandler_socket::connect): Use cygthread instead of socket event
	handling for blocking sockets.
	(fhandler_socket::accept): Ditto.
@
text
@d537 5
a541 15
      HANDLE wait_events[2] = { *thread, signal_arrived };
      if (WaitForMultipleObjects(2, wait_events, FALSE, INFINITE)
      	  != WAIT_OBJECT_0)
	{
	  /* Signal arrived */
	  thread->terminate_thread ();
	  interrupted = TRUE;
	}
      else
	{
	  /* connect returned normally */
	  res = cd.ret;
	  thread->detach ();
	}
      delete thread;
d645 5
a649 11
      HANDLE wait_events[2] = { *thread, signal_arrived };
      if (WaitForMultipleObjects(2, wait_events, FALSE, INFINITE)
          != WAIT_OBJECT_0)
        {
	  /* Signal arrived */
	  thread->terminate_thread ();
	  delete thread;
	  set_errno (EINTR);
	  return -1;
	}
      /* accept returned normally */
a650 2
      thread->detach ();
      delete thread;
@


1.99
log
@	* fhandler_socket.cc (fhandler_socket::dup): Rearrange.  Fix
	conditional.
@
text
@d35 1
d123 1
a123 1
class sock_event
d125 5
a129 3
  WSAEVENT ev[2];
  SOCKET evt_sock;
  int evt_type_bit;
d131 7
a137 16
public:
  sock_event ()
    {
      ev[0] = WSA_INVALID_EVENT;
      ev[1] = signal_arrived;
    }
  ~sock_event ()
    {
      if (ev[0] != WSA_INVALID_EVENT)
        WSACloseEvent (ev[0]);
    }
  void load (SOCKET sock, int type_bit)
    {
      if (!winsock2_active)
        /* Can not wait for signal if winsock2 is not active */
        return;
d139 7
a145 56
      if (ev[0] == WSA_INVALID_EVENT)
        if ((ev[0] = WSACreateEvent ()) == WSA_INVALID_EVENT)
          return;

      evt_sock = sock;
      evt_type_bit = type_bit;
      if (WSAEventSelect (evt_sock, ev[0], 1 << evt_type_bit))
	{
	  WSACloseEvent (ev[0]);
	  ev[0] = WSA_INVALID_EVENT;
	}
    }
  int wait ()
    {
      WSANETWORKEVENTS sock_event;
      int wait_result;

      if (ev[0] == WSA_INVALID_EVENT)
        return 0;

      wait_result = WSAWaitForMultipleEvents (2, ev, FALSE, WSA_INFINITE,
						  FALSE);
      if (wait_result == WSA_WAIT_EVENT_0)
	WSAEnumNetworkEvents (evt_sock, ev[0], &sock_event);

      /* Cleanup,  Revert to blocking. */
      WSAEventSelect (evt_sock, ev[0], 0);
      unsigned long nonblocking = 0;
      ioctlsocket (evt_sock, FIONBIO, &nonblocking);

      switch (wait_result)
	{
	  case WSA_WAIT_EVENT_0:
	    if ((sock_event.lNetworkEvents & (1 << evt_type_bit))
		&& sock_event.iErrorCode[evt_type_bit])
	      {
		WSASetLastError (sock_event.iErrorCode[evt_type_bit]);
		set_winsock_errno ();
		return -1;
	      }
	    break;

	  case WSA_WAIT_EVENT_0 + 1:
	    debug_printf ("signal received");
	    set_errno (EINTR);
	    return 1;

	  case WSA_WAIT_FAILED:
	  default:
	    WSASetLastError (WSAEFAULT);
	    set_winsock_errno ();
	    return -1;
	}
      return 0;
    }
};
a522 1
  sock_event evt;
d533 10
a542 11
  if (!is_nonblocking () && !is_connect_pending ())
    evt.load (get_socket (), FD_CONNECT_BIT);

  res = ::connect (get_socket (), (sockaddr *) &sin, namelen);

  if (res && !is_nonblocking () && !is_connect_pending ()
      && WSAGetLastError () == WSAEWOULDBLOCK)
    switch (evt.wait ())
      {
	case 1: /* Signal */
	  WSASetLastError (WSAEINPROGRESS);
d544 11
a554 8
	  break;
	case 0:
	  res = 0;
	  break;
	default:
	  res = -1;
	  break;
      }
d653 16
a668 11
      sock_event evt;
      evt.load (get_socket (), FD_ACCEPT_BIT);
      switch (evt.wait ())
	{
	  case 1: /* Signal */
	    return -1;
	  case 0:
	    break;
	  case -1:
	    return -1;
	}
d670 2
a671 2

  res = ::accept (get_socket (), peer, len);
@


1.98
log
@	* fhandler_socket.cc (fhandler_socket::dup): If running impersonated,
	revert to original account before calling fixup_before_fork_exec
	and impersonate again afterwards.  Change comment accordingly.
	Clean up error handling and debug output.
@
text
@a398 1
  fhs->set_io_handle (get_io_handle ());
d403 1
a403 14
  /* Since WSADuplicateSocket() fails on NT systems when the process
     is currently impersonating a non-privileged account, we revert
     to the original account before calling WSADuplicateSocket() and
     switch back afterwards as it's also in fork().
     If WSADuplicateSocket() still fails for some reason, we fall back
     to DuplicateHandle(). */

  WSASetLastError (0);
  if (cygheap->user.issetuid ())
    RevertToSelf ();
  fhs->fixup_before_fork_exec (GetCurrentProcessId ());
  if (cygheap->user.issetuid ())
    ImpersonateLoggedOnUser (cygheap->user.token);
  if (winsock2_active && !WSAGetLastError ())
d405 20
a424 3
      fhs->fixup_after_fork (hMainProc);
      if (get_io_handle() != (HANDLE) INVALID_SOCKET)
	return 0;
a426 2
  debug_printf ("WSADuplicateSocket failed, trying DuplicateHandle");

d439 1
a439 1
  child->set_io_handle (nh);
@


1.97
log
@
* fhandler_socket.cc (sock_event::~sock_event): New method.
(sock_event::load): Change to void. Check if winsock2 is available.
(socke_event::wait): Return 0 if interruptible mode is not available.
(fhandler_socket::connect): Remove checks for winsock2 availability.
(fhandler_socket::accept): Ditto.
@
text
@d404 7
a410 5
  /* Using WinSock2 methods for dup'ing sockets seem to collide
     with user context switches under... some... conditions.  So we
     drop this for NT systems at all and return to the good ol'
     DuplicateHandle way of life.  This worked fine all the time on
     NT anyway and it's even a bit faster. */
d412 2
d415 3
a417 1
  if (WSAGetLastError () != WSAEINVAL && winsock2_active)
d420 2
a421 2
      if (WSAGetLastError () != WSAEINVAL)
	return get_io_handle () == (HANDLE) INVALID_SOCKET;
d425 1
d429 1
d434 1
a434 2
      system_printf ("dup(%s) failed, handle %x, %E",
		     get_name (), get_io_handle ());
@


1.96
log
@	* fhandler_socket.cc (fhandler_socket::dup): First try duplicating
	using WSADuplicateSocket/WSASocket, if that fails, try DuplicateHandle.
@
text
@d134 1
a134 1
  bool load (SOCKET sock, int type_bit)
d136 13
a148 2
      if ((ev[0] = WSACreateEvent ()) == WSA_INVALID_EVENT)
	return false;
a154 1
	  return false;
a155 1
      return true;
d160 6
a165 1
      int wait_result = WSAWaitForMultipleEvents (2, ev, FALSE, WSA_INFINITE,
a171 1
      WSACloseEvent (ev[0]);
d581 2
a582 6
  if (winsock2_active && !is_nonblocking () && !is_connect_pending ())
    if (!evt.load (get_socket (), FD_CONNECT_BIT))
      {
	set_winsock_errno ();
	return -1;
      }
d586 2
a587 2
  if (winsock2_active && res && !is_nonblocking () && !is_connect_pending () &&
      WSAGetLastError () == WSAEWOULDBLOCK)
d697 1
a697 1
  if (winsock2_active && !is_nonblocking ())
d700 1
a700 5
      if (!evt.load (get_socket (), FD_ACCEPT_BIT))
	{
	  set_winsock_errno ();
	  return -1;
	}
@


1.95
log
@	* fhandler_socket.cc (fhandler_socket::connect): Guard calls to
	sock_event methods by a check for WinSock2 availability.
	(fhandler_socket::accept): Ditto.
@
text
@d396 3
a398 1
  if (!wincap.has_security ())
d400 3
a402 6
      fhs->fixup_before_fork_exec (GetCurrentProcessId ());
      if (winsock2_active)
	{
	  fhs->fixup_after_fork (hMainProc);
	  return get_io_handle () == (HANDLE) INVALID_SOCKET;
	}
d404 2
@


1.94
log
@	* fhandler_socket.cc (secret_event_name): Return void.  Use incoming
	char *parameter instead of local static buffer.
	(fhandler_socket::create_secret_event): Accomodate new calling
	convention for secret_event_name.
	(fhandler_socket::close_secret_event): Ditto.
@
text
@d567 1
a567 1
  if (!is_nonblocking () && !is_connect_pending ())
d576 1
a576 1
  if (res && !is_nonblocking () && !is_connect_pending () &&
d687 1
a687 1
  if (!is_nonblocking ())
@


1.93
log
@	* fhandler_socket.cc (SECRET_EVENT_NAME): Remove.
	(ENTROPY_SOURCE_NAME): Ditto.
	(secret_event_name): New static function.  Create shared event name
	with "Global\" prefix on systems supporting terminal services.
	(fhandler_socket::set_connect_secret): Fix conditional.
	(fhandler_socket::create_secret_event): Create secret event using
	secret_event_name().
	(fhandler_socket::close_secret_event): Ditto.
	* shared.cc (shared_name): Create shared object name with "Global\"
	prefix on systems supporting terminal services.
	* wincap.cc: Set has_terminal_services capability throughout.
	(wincap_2003): New global object representing Windows 2003 Server
	capabilities.
	(wincapc::init): Accomodate Windows 2003 Server.
	* wincap.h (struct wincaps): Add has_terminal_services capability.
@
text
@d46 2
a47 2
static char *
secret_event_name (short port, int *secret_ptr)
a48 2
  static NO_COPY char buf[MAX_PATH] = {0};

a53 1
  return buf;
d251 2
a252 2
  char *event_name = secret_event_name (sin.sin_port,
  					secret ?: connect_secret);
d291 4
a294 2
  char *event_name = secret_event_name (peer->sin_port,
  					secret ?: connect_secret);
@


1.92
log
@	Replace ino_t by __ino64_t throughout.
@
text
@a36 2
#define SECRET_EVENT_NAME "cygwin.local_socket.secret.%d.%08x-%08x-%08x-%08x"
#define ENTROPY_SOURCE_NAME "/dev/urandom"
d46 13
d225 1
a225 1
  if (!entropy_source)
a244 2
  char buf [128];
  int* secret_ptr = (secret ? : connect_secret);
d254 2
a255 3
  __small_sprintf (buf, SECRET_EVENT_NAME, sin.sin_port,
		   secret_ptr [0], secret_ptr [1],
		   secret_ptr [2], secret_ptr [3]);
d257 1
a257 1
  secret_event = CreateEvent (sec, FALSE, FALSE, buf);
d259 1
a259 1
    secret_event = OpenEvent (EVENT_ALL_ACCESS, FALSE, buf);
d294 3
a296 8
  char buf [128];
  HANDLE ev;
  int* secret_ptr = (secret ? : connect_secret);

  __small_sprintf (buf, SECRET_EVENT_NAME, peer->sin_port,
		  secret_ptr [0], secret_ptr [1],
		  secret_ptr [2], secret_ptr [3]);
  ev = CreateEvent (&sec_all_nih, FALSE, FALSE, buf);
d299 2
a300 2
      debug_printf ("event \"%s\" already exists", buf);
      ev = OpenEvent (EVENT_ALL_ACCESS, FALSE, buf);
@


1.91
log
@* dir.cc (readdir): Fill out new old_d_ino field.
* fhandler.h (fhandler_base::namehash): Define as ino_t.
(fhandler_base::get_namehash): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Accommodate new 64
bit st_ino.
* fhandler_socket.cc (fhandler_socket::fstat): Ditto.
* path.cc (hash_path_name): Return ino_t.
* syscalls.cc (stat64_to_stat32): Convert 64 bit inode to 32 bit.
* winsup.h (hash_path_name): Declare as returning ino_t.
* include/cygwin/stat.h (__stat32): Use 32 bit st_ino.
(__stat64): Use 64 bit st_ino.
* include/cygwin/types.h (__ino64_t): Define.
(__ino32_t): Ditto.
(ino_t): Define appropriately.
@
text
@d445 1
a445 1
	  buf->st_ino = (ino_t) ((DWORD) get_handle ());
@


1.90
log
@	* fhandler.cc (fhandler_base::fstat): Set the uid and gid fields
	from the current effective ids.
	* fhandler_socket.cc (fhandler_socket::fstat): Keep the uid and gid set
	by fhandler_base::fstat.
	* security.cc (get_nt_attribute): Do not test wincap.has_security ().
	(get_nt_object_attribute): Ditto.
	(get_file_attribute): Add test for wincap.has_security ().
	(get_object_attribute): Ditto.
@
text
@d445 1
a445 1
	  buf->st_ino = (ino_t) get_handle ();
d452 1
a452 1
	  buf->st_ino = (ino_t) get_namehash ();
@


1.89
log
@	* fhandler_socket.cc (fhandler_socket::sendto): Restrict EPIPE and
	SIGPIPE handling to connection oriented sockets.  Add comment.
@
text
@a446 2
	  buf->st_uid = geteuid32 ();
	  buf->st_gid = getegid32 ();
@


1.88
log
@	* fhandler_socket.cc (fhandler_socket::dup): Don't call
	fhandler_base::dup() but call DuplicateHandle directly instead to have
	control over socket inheritence.
@
text
@d1061 7
a1067 2
  /* Special handling for SIGPIPE */
  if (res == -1 && get_errno () == ESHUTDOWN)
@


1.87
log
@2003-03-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::dup): On NT systems avoid
	using WinSock2 socket duplication methods.  Add comment.

2003-03-11  Pierre Humblet  <pierre.humblet@@ieee.org>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork):
	Set io_handle to INVALID_SOCKET in case of failure.
	(fhandler_socket::dup): Return 0 if the io_handle is valid.
@
text
@d403 14
a416 1
  return fhandler_base::dup (child);
@


1.86
log
@whitespace cleanup
@
text
@d347 1
d389 6
a394 2
  fhs->fixup_before_fork_exec (GetCurrentProcessId ());
  if (winsock2_active)
d396 6
a401 2
      fhs->fixup_after_fork (hMainProc);
      return 0;
@


1.86.2.1
log
@* fhandler_socket.cc (fhandler_socket::dup): Don't call fhandler_base::dup()
but call DuplicateHandle directly instead to have control over socket
inheritence.
* fhandler_socket.cc (fhandler_socket::dup): On NT systems avoid using WinSock2
socket duplication methods.  Add comment.
* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Set io_handle to
INVALID_SOCKET in case of failure.
(fhandler_socket::dup): Return 0 if the io_handle is valid.
* sec_acl.cc (setacl): Don't handle DELETE flag specially.
* security.cc (alloc_sd): Ditto.
* winver.rc: Change Copyright hint to include 2003.
@
text
@a346 1
      set_io_handle ((HANDLE)INVALID_SOCKET);
d388 2
a389 6
  /* Using WinSock2 methods for dup'ing sockets seem to collide
     with user context switches under... some... conditions.  So we
     drop this for NT systems at all and return to the good ol'
     DuplicateHandle way of life.  This worked fine all the time on
     NT anyway and it's even a bit faster. */
  if (!wincap.has_security ())
d391 2
a392 6
      fhs->fixup_before_fork_exec (GetCurrentProcessId ());
      if (winsock2_active)
	{
	  fhs->fixup_after_fork (hMainProc);
	  return get_io_handle () == (HANDLE) INVALID_SOCKET;
	}
d394 1
a394 14
  /* We don't call fhandler_base::dup here since that requires to
     have winsock called from fhandler_base and it creates only
     inheritable sockets which is wrong for winsock2. */
  HANDLE nh;
  if (!DuplicateHandle (hMainProc, get_io_handle (), hMainProc, &nh, 0,
			!winsock2_active, DUPLICATE_SAME_ACCESS))
    {
      system_printf ("dup(%s) failed, handle %x, %E",
		     get_name (), get_io_handle ());
      __seterrno ();
      return -1;
    }
  child->set_io_handle (nh);
  return 0;
@


1.85
log
@	* fhandler_socket.cc (fhandler_socket::dup): Initialize type.
@
text
@d66 1
a66 1
        {
d71 1
a71 1
        {
d76 1
a76 1
        {
d83 1
a83 1
        {
d92 1
a92 1
        {
d129 1
a129 1
        return false;
d133 1
a133 1
        {
d146 1
a146 1
        WSAEnumNetworkEvents (evt_sock, ev[0], &sock_event);
d155 1
a155 1
        {
d158 1
a158 1
	        && sock_event.iErrorCode[evt_type_bit])
d160 1
a160 1
	        WSASetLastError (sock_event.iErrorCode[evt_type_bit]);
d404 1
a404 1
                     PC_SYM_NOFOLLOW | PC_NULLEMPTY | PC_FULL | PC_POSIX,
d407 1
a407 1
      							 get_sun_path (),
d410 1
a410 1
        {
d421 1
a421 1
        {
d429 1
a429 1
        {
d477 2
a478 2
        {
          set_errno (pc.error);
d482 1
a482 1
        {
d489 1
a489 1
        attr |= FILE_ATTRIBUTE_READONLY;
d492 1
a492 1
        set_security_attribute (mode, &sa, alloca (4096), 4096);
d495 1
a495 1
        {
d509 1
a509 1
        {
d515 1
a515 1
        {
d669 1
a669 1
        {
d674 1
a674 1
        {
d728 1
a728 1
        {
d737 1
a737 1
        {
d843 1
a843 1
         condition is returned. */
d845 1
a845 1
        return len;
@


1.84
log
@	* fhandler_socket.cc (fhandler_socket::bind): Open and write socket
	file using Win32 calls.
@
text
@d386 1
@


1.83
log
@	* fhandler_socket.cc (get_inet_addr): Open and read socket file using
	Win32 calls.
@
text
@a448 1
      int fd;
d474 22
a495 6
      /* bind must fail if file system socket object already exists
	 so _open () is called with O_EXCL flag. */
      fd = ::open (un_addr->sun_path, O_WRONLY | O_CREAT | O_EXCL | O_BINARY, 0);
      if (fd < 0)
	{
	  if (get_errno () == EEXIST)
d497 2
a498 1
	  goto out;
d506 6
a511 8
      len = strlen (buf) + 1;

      /* Note that the terminating nul is written.  */
      if (::write (fd, buf, len) != len)
	{
	  save_errno here;
	  ::close (fd);
	  unlink (un_addr->sun_path);
d514 2
a515 4
	{
	  ::close (fd);
	  chmod (un_addr->sun_path,
		 (S_IFSOCK | S_IRWXU | S_IRWXG | S_IRWXO) & ~cygheap->umask);
@


1.82
log
@2003-03-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (class sock_event): New class managing Winsock
	events for interruptible socket calls.
	(fhandler_socket::connect): Move support for interruptible call to
	class sock_event.  Use class object instead.
	(fhandler_socket::accept): Ditto.  Remove useless casts.

2003-03-27  Thomas Pfaff  <tpfaff@@gmx.net>

	* fhandler_socket.cc (fhandler_socket::connect): Add support for
	an interruptable connect.
@
text
@d64 23
a86 4
      int fd = open (in->sa_data, O_RDONLY);
      if (fd == -1)
	return 0;

d88 1
d91 2
a92 2
      if (read (fd, buf, sizeof buf) != -1)
	{
d104 1
a104 1
      close (fd);
@


1.81
log
@	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Fix compiler
	warning.
	(fhandler_socket::fstat): Simplify.  Set st_uid/st_gid to effective
	uid/gid of current process in case of open sockets.
@
text
@d94 67
d501 2
d512 7
d520 17
d541 1
a541 1
      if (is_nonblocking ())
d589 4
a610 1
  WSAEVENT ev[2] = { WSA_INVALID_EVENT, signal_arrived };
d634 14
a647 47
      ev[0] = WSACreateEvent ();

      if (ev[0] != WSA_INVALID_EVENT &&
	  !WSAEventSelect (get_socket (), ev[0], FD_ACCEPT))
	{
	  WSANETWORKEVENTS sock_event;
	  int wait_result;

	  wait_result = WSAWaitForMultipleEvents (2, ev, FALSE, WSA_INFINITE,
						  FALSE);
	  if (wait_result == WSA_WAIT_EVENT_0)
	    WSAEnumNetworkEvents (get_socket (), ev[0], &sock_event);

	  /* Unset events for listening socket and
	     switch back to blocking mode */
	  WSAEventSelect (get_socket (), ev[0], 0);
	  unsigned long nonblocking = 0;
	  ioctlsocket (get_socket (), FIONBIO, &nonblocking);

	  switch (wait_result)
	    {
	    case WSA_WAIT_EVENT_0:
	      if (sock_event.lNetworkEvents & FD_ACCEPT)
		{
		  if (sock_event.iErrorCode[FD_ACCEPT_BIT])
		    {
		      WSASetLastError (sock_event.iErrorCode[FD_ACCEPT_BIT]);
		      set_winsock_errno ();
		      res = -1;
		      goto done;
		    }
		}
	      /* else; : Should never happen since FD_ACCEPT is the only event
		 that has been selected */
	      break;
	    case WSA_WAIT_EVENT_0 + 1:
	      debug_printf ("signal received during accept");
	      set_errno (EINTR);
	      res = -1;
	      goto done;
	    case WSA_WAIT_FAILED:
	    default: /* Should never happen */
	      WSASetLastError (WSAEFAULT);
	      set_winsock_errno ();
	      res = -1;
	      goto done;
	    }
d653 1
a653 2
  if ((SOCKET) res == (SOCKET) INVALID_SOCKET &&
      WSAGetLastError () == WSAEWOULDBLOCK)
d658 1
a658 1
      if ((SOCKET) res != (SOCKET) INVALID_SOCKET || in_progress)
d667 1
a667 1
	  (SOCKET) res != (SOCKET) INVALID_SOCKET)
d679 1
a679 1
	  if ((SOCKET) res != (SOCKET) INVALID_SOCKET)
d682 1
a682 2
	  res = -1;
	  goto done;
d686 1
a686 1
  if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
a708 4

done:
  if (ev[0] != WSA_INVALID_EVENT)
    WSACloseEvent (ev[0]);
@


1.80
log
@	* dtable.cc (dtable::build_fhandler_from_name): Set some fhandler
	data on sockets to evaluate AF_LOCAL sockets correctly.
	(dtable::build_fhandler): Set unit number on sockets.
	* fhandler.h (fhandler_socket): Add unit number.
	(fhandler_socket::get_unit): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Set unit
	number.
	(fhandler_socket::fstat): Reorganize to return more Linux-like
	values.
	* net.cc: include ctype.h.
	(fdsock): Set unit number when building fhandler.
	* path.cc (path_conv::check): Set device type to FH_SOCKET if file
	is a AF_UNIX socket.
	(get_devn): Evaluate unit for virtual socket devices.
	(win32_device_name): Set windows path for sockets to unix_path with
	just backslashes to keep the different names.
	* syscalls.cc (fstat64): Don't override st_ino, st_dev and st_rdev
	for sockets.
	(stat_worker): Ditto.

From Pierre Humblet:

	* autoload.cc (AccessCheck): Add.
	(DuplicateToken): Add.
	* security.h (check_file_access): Declare.
	* syscalls.cc (access): Convert path to Windows, check existence
	and readonly attribute. Call check_file_access instead of acl_access.
	* security.cc (check_file_access): Create.
	* sec_acl (acl_access): Delete.
@
text
@d98 1
a98 1
  : fhandler_base (FH_SOCKET), unit (nunit), sun_path (NULL)
d313 1
a313 1
  if (get_addr_family () == AF_LOCAL && get_sun_path ())
a323 7
	  /* Faking Linux like values on top of the file specific values. */
	  if (get_socket_type ()) /* fstat() */
	    {
	      buf->st_dev = 0;
	      buf->st_mode |= S_IRWXU | S_IRWXG | S_IRWXO;
	      buf->st_ino = (ino_t) get_handle ();
	    }
d334 1
d336 3
a338 2
	  buf->st_mode &= ~S_IFMT;
	  buf->st_mode |= S_IFSOCK;
@


1.79
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Check descriptor
	created by cygheap_fdnew constructor.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
	* fhandler_socket.cc (fhandler_socket::accept): Ditto and move
	creation of file descriptor behind blocking OS call.
	* net.cc (cygwin_socket): Ditto.
	(cygwin_rcmd): Ditto.
	(cygwin_rresvport): Ditto.
	(cygwin_rexec): Ditto.
	(socketpair): Ditto.
@
text
@d97 2
a98 2
fhandler_socket::fhandler_socket ()
  : fhandler_base (FH_SOCKET), sun_path (NULL)
d312 25
a336 1
  int res = fhandler_base::fstat (buf, pc);
d339 14
a352 3
      buf->st_mode &= ~_IFMT;
      buf->st_mode |= _IFSOCK;
      buf->st_ino = (ino_t) get_handle ();
@


1.78
log
@	* fhandler_socket.cc (fhandler_socket::recvfrom): Return buffer
	length and don't set errno in case of WSAEMSGSIZE error.
	(fhandler_socket::recvmsg): Ditto.
@
text
@a486 1
  cygheap_fdnew res_fd;
d595 1
a595 3
  if (res_fd < 0)
    /* FIXME: what is correct errno? */;
  else if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
d599 18
a616 7
      fhandler_socket* res_fh = fdsock (res_fd, get_name (), res);
      if (get_addr_family () == AF_LOCAL)
	res_fh->set_sun_path (get_sun_path ());
      res_fh->set_addr_family (get_addr_family ());
      res_fh->set_socket_type (get_socket_type ());
      res_fh->set_connect_state (CONNECTED);
      res = res_fd;
@


1.77
log
@	* fhandler_socket.cc (fhandler_socket::accept): On successful execution
	set connection state of returned socket to CONNECTED.
@
text
@d714 5
d797 1
d806 1
a806 1
	    wsaptr->len = iovptr->iov_len;
d833 5
@


1.76
log
@* uinfo.cc (pwdgrp::load): Regularize strace output.  Add warning for
CreateFile failure.
@
text
@d487 1
d596 14
a609 16
  {
    cygheap_fdnew res_fd;
    if (res_fd < 0)
      /* FIXME: what is correct errno? */;
    else if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
      set_winsock_errno ();
    else
      {
	fhandler_socket* res_fh = fdsock (res_fd, get_name (), res);
	if (get_addr_family () == AF_LOCAL)
	  res_fh->set_sun_path (get_sun_path ());
	res_fh->set_addr_family (get_addr_family ());
	res_fh->set_socket_type (get_socket_type ());
	res = res_fd;
      }
  }
@


1.75
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d1118 1
a1118 1
          || ntohl (((struct sockaddr_in *) &ifr->ifr_addr)->sin_addr.s_addr)
@


1.75.6.1
log
@merge from trunk
@
text
@d39 1
d98 1
a98 1
  : fhandler_base (), sun_path (NULL)
d119 1
a119 2
      entropy_source = new (buf) fhandler_dev_random ();
      entropy_source->dev = *urandom_dev;
@


1.75.6.2
log
@merge from trunk
@
text
@d1118 1
a1118 1
	  || ntohl (((struct sockaddr_in *) &ifr->ifr_addr)->sin_addr.s_addr)
@


1.75.6.3
log
@merge from trunk
@
text
@a486 1
  cygheap_fdnew res_fd;
d595 16
a610 14
  if (res_fd < 0)
    /* FIXME: what is correct errno? */;
  else if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
    set_winsock_errno ();
  else
    {
      fhandler_socket* res_fh = fdsock (res_fd, get_name (), res);
      if (get_addr_family () == AF_LOCAL)
	res_fh->set_sun_path (get_sun_path ());
      res_fh->set_addr_family (get_addr_family ());
      res_fh->set_socket_type (get_socket_type ());
      res_fh->set_connect_state (CONNECTED);
      res = res_fd;
    }
@


1.75.6.4
log
@merge from trunk
@
text
@a713 5
      /* According to SUSv3, errno isn't set in that case and no error
         condition is returned. */
      if (WSAGetLastError () == WSAEMSGSIZE)
        return len;

a791 1
      unsigned long len = 0L;
d800 1
a800 1
	    len += wsaptr->len = iovptr->iov_len;
a826 5
	  /* According to SUSv3, errno isn't set in that case and no error
	     condition is returned. */
	  if (WSAGetLastError () == WSAEMSGSIZE)
	    return len;

@


1.75.6.5
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d29 1
a30 1
#include "fhandler.h"
d119 1
a119 1
      entropy_source->dev () = *urandom_dev;
d122 1
a122 1
      !entropy_source->open (O_RDONLY))
d310 1
a310 1
fhandler_socket::fstat (struct __stat64 *buf)
d312 1
a312 1
  int res = fhandler_base::fstat (buf);
@


1.75.6.6
log
@merge from trunk
@
text
@a101 8
#if 0
  if (pc.is_fs_special ())
    {
      fhandler_socket * fhs = (fhandler_socket *) fh;
      fhs->set_addr_family (AF_LOCAL);
      fhs->set_sun_path (posix_path);
    }
#endif
d487 1
d596 3
a598 1
  if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
d602 7
a608 18
      cygheap_fdnew res_fd;
      fhandler_socket* res_fh = NULL;
      if (res_fd >= 0)
	  res_fh = fdsock (res_fd, get_name (), res);
      if (res_fh)
        {
	  if (get_addr_family () == AF_LOCAL)
	    res_fh->set_sun_path (get_sun_path ());
	  res_fh->set_addr_family (get_addr_family ());
	  res_fh->set_socket_type (get_socket_type ());
	  res_fh->set_connect_state (CONNECTED);
	  res = res_fd;
	}
      else
        {
	  closesocket (res);
	  res = -1;
	}
@


1.75.6.7
log
@merge from trunk
@
text
@a92 67
class sock_event
{
  WSAEVENT ev[2];
  SOCKET evt_sock;
  int evt_type_bit;

public:
  sock_event ()
    {
      ev[0] = WSA_INVALID_EVENT;
      ev[1] = signal_arrived;
    }
  bool load (SOCKET sock, int type_bit)
    {
      if ((ev[0] = WSACreateEvent ()) == WSA_INVALID_EVENT)
        return false;
      evt_sock = sock;
      evt_type_bit = type_bit;
      if (WSAEventSelect (evt_sock, ev[0], 1 << evt_type_bit))
        {
	  WSACloseEvent (ev[0]);
	  ev[0] = WSA_INVALID_EVENT;
	  return false;
	}
      return true;
    }
  int wait ()
    {
      WSANETWORKEVENTS sock_event;
      int wait_result = WSAWaitForMultipleEvents (2, ev, FALSE, WSA_INFINITE,
						  FALSE);
      if (wait_result == WSA_WAIT_EVENT_0)
        WSAEnumNetworkEvents (evt_sock, ev[0], &sock_event);

      /* Cleanup,  Revert to blocking. */
      WSAEventSelect (evt_sock, ev[0], 0);
      WSACloseEvent (ev[0]);
      unsigned long nonblocking = 0;
      ioctlsocket (evt_sock, FIONBIO, &nonblocking);

      switch (wait_result)
        {
	  case WSA_WAIT_EVENT_0:
	    if ((sock_event.lNetworkEvents & (1 << evt_type_bit))
	        && sock_event.iErrorCode[evt_type_bit])
	      {
	        WSASetLastError (sock_event.iErrorCode[evt_type_bit]);
		set_winsock_errno ();
		return -1;
	      }
	    break;

	  case WSA_WAIT_EVENT_0 + 1:
	    debug_printf ("signal received");
	    set_errno (EINTR);
	    return 1;

	  case WSA_WAIT_FAILED:
	  default:
	    WSASetLastError (WSAEFAULT);
	    set_winsock_errno ();
	    return -1;
	}
      return 0;
    }
};

a411 2
  sock_event evt;
  BOOL interrupted = FALSE;
a420 7
  if (!is_nonblocking () && !is_connect_pending ())
    if (!evt.load (get_socket (), FD_CONNECT_BIT))
      {
	set_winsock_errno ();
	return -1;
      }

a421 17

  if (res && !is_nonblocking () && !is_connect_pending () &&
      WSAGetLastError () == WSAEWOULDBLOCK)
    switch (evt.wait ())
      {
	case 1: /* Signal */
	  WSASetLastError (WSAEINPROGRESS);
	  interrupted = TRUE;
	  break;
	case 0:
	  res = 0;
	  break;
	default:
	  res = -1;
	  break;
      }

d426 1
a426 1
      if (is_nonblocking () || is_connect_pending ())
a473 4

  if (interrupted)
    set_errno (EINTR);

d492 1
d516 47
a562 14
      sock_event evt;
      if (!evt.load (get_socket (), FD_ACCEPT_BIT))
        {
	  set_winsock_errno ();
	  return -1;
	}
      switch (evt.wait ())
        {
	  case 1: /* Signal */
	    return -1;
	  case 0:
	    break;
	  case -1:
	    return -1;
d568 2
a569 1
  if ((SOCKET) res == INVALID_SOCKET && WSAGetLastError () == WSAEWOULDBLOCK)
d574 1
a574 1
      if ((SOCKET) res != INVALID_SOCKET || in_progress)
d583 1
a583 1
	  (SOCKET) res != INVALID_SOCKET)
d595 1
a595 1
	  if ((SOCKET) res != INVALID_SOCKET)
d598 2
a599 1
	  return -1;
d603 1
a603 1
  if ((SOCKET) res == INVALID_SOCKET)
d626 4
@


1.75.6.8
log
@merge from trunk
@
text
@d63 4
a66 23
      path_conv pc (in->sa_data, PC_SYM_FOLLOW);
      if (pc.error)
        {
	  set_errno (pc.error);
	  return 0;
	}
      if (!pc.exists ())
        {
	  set_errno (ENOENT);
	  return 0;
	}
      if (!pc.issocket ())
        {
	  set_errno (EBADF);
	  return 0;
	}
      HANDLE fh = CreateFile (pc, GENERIC_READ, wincap.shared (), &sec_none,
			      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
      if (fh == INVALID_HANDLE_VALUE)
        {
	  __seterrno ();
	  return 0;
	}
a67 1
      DWORD len = 0;
d70 2
a71 2
      if (ReadFile (fh, buf, 128, &len, 0))
        {
d83 1
a83 1
      CloseHandle (fh);
d407 1
d433 7
a439 9
      path_conv pc (un_addr->sun_path, PC_SYM_FOLLOW);
      if (pc.error)
        {
          set_errno (pc.error);
	  goto out;
	}
      if (pc.exists ())
        {
	  set_errno (EADDRINUSE);
a441 15
      mode_t mode = (S_IRWXU | S_IRWXG | S_IRWXO) & ~cygheap->umask;
      DWORD attr = FILE_ATTRIBUTE_SYSTEM;
      if (!(mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
        attr |= FILE_ATTRIBUTE_READONLY;
      SECURITY_ATTRIBUTES sa = sec_none;
      if (allow_ntsec && pc.has_acls ())
        set_security_attribute (mode, &sa, alloca (4096), 4096);
      HANDLE fh = CreateFile (pc, GENERIC_WRITE, 0, &sa, CREATE_NEW, attr, 0);
      if (fh == INVALID_HANDLE_VALUE)
        {
	  if (GetLastError () == ERROR_ALREADY_EXISTS)
	    set_errno (EADDRINUSE);
	  else
	    __seterrno ();
	}
d448 8
a455 6
      DWORD blen = strlen (buf) + 1;
      if (!WriteFile (fh, buf, blen, &blen, 0))
        {
	  __seterrno ();
	  CloseHandle (fh);
	  DeleteFile (pc);
d458 4
a461 2
        {
	  CloseHandle (fh);
@


1.75.6.9
log
@Merge from trunk.
* Makefile.in (devicess.cc): Make generation dependent on cygwin-gperf.
* cygheap.h (cygheap_fdmanip): Add fhandler_socket cast.
* cygwin-gperf: Autogenerate references to network devices.
* devices.h: Create separate device types for all network types.  Export
references to global network device storage.
* dtable.cc (dtable::release): Use generic determination to control when
need_fixup_before needs to be decremented.
(dtable::init_std_file_from_handle): Replace use of 'socket_dev' with
'tcp_dev'.
(build_fh_pc): Adapt to new socket types.  Don't increment fixup_before here.
* fhandler.h (fhandler_base::need_fixup_before): Declare/define.
(fhandler_socket::need_fixup_before): Ditto.
* fhandler_socket.cc (fhandler_socket::accept): Accommodate new fdsock
definition.
* net.cc: Throughout, change use of fdsock to return true/false for
success/failure and take cygheap_fdmanip type and device
* select.cc (set_bits): Use 'is_socket ()' test rather than specificially
testing device type.
@
text
@d40 1
a40 1
extern bool fdsock (cygheap_fdmanip& fd, const device *, SOCKET soc);
d701 4
a704 1
      if (res_fd >= 0 && fdsock (res_fd, &dev (), res))
d707 4
a710 4
	    ((fhandler_socket *) res_fd)->set_sun_path (get_sun_path ());
	  ((fhandler_socket *) res_fd)->set_addr_family (get_addr_family ());
	  ((fhandler_socket *) res_fd)->set_socket_type (get_socket_type ());
	  ((fhandler_socket *) res_fd)->set_connect_state (CONNECTED);
@


1.75.6.10
log
@merge from trunk
@
text
@a393 1
  fhs->set_socket_type (get_socket_type ());
@


1.75.6.11
log
@merge from trunk
@
text
@d65 1
a65 1
	{
d70 1
a70 1
	{
d75 1
a75 1
	{
d82 1
a82 1
	{
d91 1
a91 1
	{
d128 1
a128 1
	return false;
d132 1
a132 1
	{
d145 1
a145 1
	WSAEnumNetworkEvents (evt_sock, ev[0], &sock_event);
d154 1
a154 1
	{
d157 1
a157 1
		&& sock_event.iErrorCode[evt_type_bit])
d159 1
a159 1
		WSASetLastError (sock_event.iErrorCode[evt_type_bit]);
d455 2
a456 2
	{
	  set_errno (pc.error);
d460 1
a460 1
	{
d467 1
a467 1
	attr |= FILE_ATTRIBUTE_READONLY;
d470 1
a470 1
	set_security_attribute (mode, &sa, alloca (4096), 4096);
d473 1
a473 1
	{
d487 1
a487 1
	{
d493 1
a493 1
	{
d647 1
a647 1
	{
d652 1
a652 1
	{
d712 1
a712 1
	{
d818 1
a818 1
	 condition is returned. */
d820 1
a820 1
	return len;
@


1.75.6.12
log
@merge from trunk
@
text
@a354 1
      set_io_handle ((HANDLE)INVALID_SOCKET);
d396 2
a397 6
  /* Using WinSock2 methods for dup'ing sockets seem to collide
     with user context switches under... some... conditions.  So we
     drop this for NT systems at all and return to the good ol'
     DuplicateHandle way of life.  This worked fine all the time on
     NT anyway and it's even a bit faster. */
  if (!wincap.has_security ())
d399 2
a400 6
      fhs->fixup_before_fork_exec (GetCurrentProcessId ());
      if (winsock2_active)
	{
	  fhs->fixup_after_fork (hMainProc);
	  return get_io_handle () == (HANDLE) INVALID_SOCKET;
	}
d402 1
a402 14
  /* We don't call fhandler_base::dup here since that requires to
     have winsock called from fhandler_base and it creates only
     inheritable sockets which is wrong for winsock2. */
  HANDLE nh;
  if (!DuplicateHandle (hMainProc, get_io_handle (), hMainProc, &nh, 0,
			!winsock2_active, DUPLICATE_SAME_ACCESS))
    {
      system_printf ("dup(%s) failed, handle %x, %E",
		     get_name (), get_io_handle ());
      __seterrno ();
      return -1;
    }
  child->set_io_handle (nh);
  return 0;
@


1.75.6.13
log
@merge from trunk
@
text
@d1036 2
a1037 7
  /* Special handling for EPIPE and SIGPIPE.
     
     EPIPE is generated if the local end has been shut down on a connection
     oriented socket.  In this case the process will also receive a SIGPIPE
     unless MSG_NOSIGNAL is set.  */
  if (res == -1 && get_errno () == ESHUTDOWN
      && get_socket_type () == SOCK_STREAM)
@


1.75.6.14
log
@merge from trunk
@
text
@d433 3
a435 14
      if (get_socket_type ()) /* fstat */
	{
	  buf->st_dev = 0;
	  buf->st_ino = (ino_t) get_handle ();
	  buf->st_mode = S_IFSOCK | S_IRWXU | S_IRWXG | S_IRWXO;
	}
      else
	{
	  path_conv spc ("/dev", PC_SYM_NOFOLLOW | PC_NULLEMPTY, NULL);
	  buf->st_dev = spc.volser ();
	  buf->st_ino = (ino_t) get_namehash ();
	  buf->st_mode &= ~S_IRWXO;
	  buf->st_rdev = (get_device () << 16) | get_unit ();
	}
@


1.75.6.15
log
@merge from trunk
@
text
@d37 3
a46 10
static void
secret_event_name (char *buf, short port, int *secret_ptr)
{
  __small_sprintf (buf, "%scygwin.local_socket.secret.%d.%08x-%08x-%08x-%08x",
		   wincap.has_terminal_services () ? "Global\\" : "",
  		   port,
		   secret_ptr [0], secret_ptr [1],
		   secret_ptr [2], secret_ptr [3]);
}

d222 1
a222 1
  if (entropy_source)
d242 2
d253 3
a255 2
  char event_name[MAX_PATH];
  secret_event_name (event_name, sin.sin_port, secret ?: connect_secret);
d257 1
a257 1
  secret_event = CreateEvent (sec, FALSE, FALSE, event_name);
d259 1
a259 1
    secret_event = OpenEvent (EVENT_ALL_ACCESS, FALSE, event_name);
d294 8
a301 5

  char event_name[MAX_PATH];
  
  secret_event_name (event_name, peer->sin_port, secret ?: connect_secret);
  HANDLE ev = CreateEvent (&sec_all_nih, FALSE, FALSE, event_name);
d304 2
a305 2
      debug_printf ("event \"%s\" already exists", event_name);
      ev = OpenEvent (EVENT_ALL_ACCESS, FALSE, event_name);
d436 1
a436 1
	  buf->st_ino = (__ino64_t) ((DWORD) get_handle ());
d443 1
a443 1
	  buf->st_ino = get_namehash ();
d556 1
a556 1
  if (winsock2_active && !is_nonblocking () && !is_connect_pending ())
d565 1
a565 1
  if (winsock2_active && res && !is_nonblocking () && !is_connect_pending () &&
d676 1
a676 1
  if (winsock2_active && !is_nonblocking ())
@


1.75.6.16
log
@merge from trunk
@
text
@a34 2
#include "cygthread.h"
#include "select.h"
d120 67
d393 1
d398 6
a403 1
  if (winsock2_active)
a404 10
      /* Since WSADuplicateSocket() fails on NT systems when the process
	 is currently impersonating a non-privileged account, we revert
	 to the original account before calling WSADuplicateSocket() and
	 switch back afterwards as it's also in fork().
	 If WSADuplicateSocket() still fails for some reason, we fall back
	 to DuplicateHandle(). */
      WSASetLastError (0);
      if (cygheap->user.issetuid ())
	RevertToSelf ();
      fhs->set_io_handle (get_io_handle ());
d406 1
a406 3
      if (cygheap->user.issetuid ())
	ImpersonateLoggedOnUser (cygheap->user.token);
      if (!WSAGetLastError ())
d409 1
a409 2
	  if (fhs->get_io_handle() != (HANDLE) INVALID_SOCKET)
	    return 0;
a410 1
      debug_printf ("WSADuplicateSocket failed, trying DuplicateHandle");
a411 1

a414 1

d419 2
a420 1
      system_printf ("!DuplicateHandle(%x) failed, %E", get_io_handle ());
d424 1
a424 1
  fhs->set_io_handle (nh);
d546 2
d557 7
d566 16
d635 3
d676 19
@


1.75.6.17
log
@merge from trunk
@
text
@d16 1
a330 1
  fhs->set_connect_state (get_connect_state ());
d341 2
a342 1
      cygheap->user.deimpersonate ();
d345 2
a346 1
      cygheap->user.reimpersonate ();
a494 1
  DWORD err;
d507 1
a507 1
	  err = WSAGetLastError ();
d509 4
a512 4
	    in_progress = TRUE;

	  if (err == WSAEWOULDBLOCK)
	    WSASetLastError (WSAEINPROGRESS);
d549 1
a549 2
  err = WSAGetLastError ();
  if (err == WSAEINPROGRESS || err == WSAEALREADY)
@


1.75.6.18
log
@merge from trunk
@
text
@d50 1
a50 1
		   port,
d234 1
a234 1

d946 1
a946 1

@


1.75.6.19
log
@merge from trunk
@
text
@a648 1
  debug_printf ("res %d", res);
@


1.75.4.1
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d39 1
d119 1
a119 2
      entropy_source = new (buf) fhandler_dev_random ();
      entropy_source->dev = *urandom_dev;
@


1.75.4.2
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d97 1
a97 1
  : fhandler_base (), sun_path (NULL)
@


1.74
log
@revert botched checkin
@
text
@d127 7
a133 4
  if (!entropy_source ||
      (entropy_source->read (connect_secret, sizeof (connect_secret)) !=
					     sizeof (connect_secret)))
    bzero ((char*) connect_secret, sizeof (connect_secret));
@


1.73
log
@* include/cygwin/version.h: Bump DLL minor number.
@
text
@d667 6
a672 6
      .msg_name:		NULL,
      .msg_namelen:	0,
      .msg_iov:		(struct iovec *) iov, // const_cast
      .msg_iovlen:	iovcnt,
      .msg_accrights:	NULL,
      .msg_accrightslen:	0
@


1.72
log
@* fhandler_socket.cc (fhandler_socket::sendto): Fix potential unitialized value
return.
@
text
@d667 6
a672 6
      msg_name:		NULL,
      msg_namelen:	0,
      msg_iov:		(struct iovec *) iov, // const_cast
      msg_iovlen:	iovcnt,
      msg_accrights:	NULL,
      msg_accrightslen:	0
@


1.71
log
@	* fhandler_socket.cc (fhandler_socket::ioctl): Return correct flags
	for loopback interface when name is given on input instead of address.
@
text
@d865 3
a867 3
    res = ::sendto (get_socket (), (const char *) ptr, len,
		    flags & MSG_WINMASK,
		    (to ? (const struct sockaddr *) &sin : NULL), tolen);
@


1.70
log
@* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@d1114 2
a1115 1
      if (ntohl (((struct sockaddr_in *) &ifr->ifr_addr)->sin_addr.s_addr)
@


1.69
log
@Change _function() to function() throughout.
* cygwin.din: Remove last vestiges (?) of newlib wrappers.
* cygthread.cc (cygthread::detach): Always wait for event or suffer an
apparently inavoidable race.
* dcrt0.cc (dll_crt0_1): Allocate threads after stack has been relocated.
* debub.cc (lock_debug): Don't acquire lock on exit.
* fork.cc (fork_child): Recreate mmaps before doing anything else since Windows
has a habit of using blocks of memory in the child that could previously have
been occupied by shared memory in the parent.
* mmap.cc (fhandler_disk_file::fixup_mmap_after_fork): Issue error here and
provide some details about what went wrong.
(fixup_mmaps_after_fork): Remove error message.
* shared.cc (open_shared): Move warning message so that more detail is
possible.
* sigproc.cc (sigproc_init): Initialize sync_proc_subproc to avoid a race.
(sigproc_terminate): Specifically wait for process thread to terminate.
@
text
@d737 3
d746 1
a746 2
			(struct sockaddr *) msg->msg_name,
			&msg->msg_namelen);
d771 1
a771 2
			      (struct sockaddr *) msg->msg_name,
			      &msg->msg_namelen);
d809 1
a809 2
			   (struct sockaddr *) msg->msg_name,
			   &msg->msg_namelen,
d816 1
a816 2
			     (struct sockaddr *) msg->msg_name,
			     &msg->msg_namelen,
@


1.69.4.1
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
* fhandler.h (fhandler_serial::vmin_): Declare as size_t.
* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@a736 3
  struct sockaddr *from = (struct sockaddr *) msg->msg_name;
  int *fromlen = from ? &msg->msg_namelen : NULL;

d743 2
a744 1
			from, fromlen);
d769 2
a770 1
			      from, fromlen);
d808 2
a809 1
			   from, fromlen,
d816 2
a817 1
			     from, fromlen,
@


1.68
log
@missed checkin
@
text
@a22 1
#include <unistd.h>
d35 1
d64 1
a64 1
      int fd = _open (in->sa_data, O_RDONLY);
d84 1
a84 1
      _close (fd);
d357 1
a357 3
      fd = _open (un_addr->sun_path,
		  O_WRONLY | O_CREAT | O_EXCL | O_BINARY,
		  0);
d373 1
a373 1
      if (_write (fd, buf, len) != len)
d376 2
a377 2
	  _close (fd);
	  _unlink (un_addr->sun_path);
d381 1
a381 1
	  _close (fd);
d383 1
a383 1
	    (S_IFSOCK | S_IRWXU | S_IRWXG | S_IRWXO) & ~cygheap->umask);
@


1.67
log
@whitespace
@
text
@d906 1
a906 1
	_raise (SIGPIPE);
@


1.66
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d51 1
a51 1
               struct sockaddr_in *out, int *outlen, int* secret = 0)
d66 1
a66 1
        return 0;
d72 12
a83 12
        {
          sockaddr_in sin;
          sin.sin_family = AF_INET;
          sscanf (buf + strlen (SOCKET_COOKIE), "%hu %08x-%08x-%08x-%08x",
                  &sin.sin_port,
                  secret_ptr, secret_ptr + 1, secret_ptr + 2, secret_ptr + 3);
          sin.sin_port = htons (sin.sin_port);
          sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
          *out = sin;
          *outlen = sizeof sin;
          ret = 1;
        }
d510 4
a513 4
          !WSAEventSelect (get_socket (), ev[0], FD_ACCEPT))
        {
          WSANETWORKEVENTS sock_event;
          int wait_result;
d515 1
a515 1
          wait_result = WSAWaitForMultipleEvents (2, ev, FALSE, WSA_INFINITE,
@


1.65
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d1107 1
a1107 1
	debug_printf ("error in get_ifconf\n");
d1137 1
a1137 1
	    debug_printf ("ifr == NULL\n");
d1145 1
a1145 1
	    debug_printf ("error in get_ifconf\n");
d1149 1
a1149 1
	debug_printf ("    name: %s\n", ifr->ifr_name);
d1154 1
a1154 1
	    debug_printf ("testname: %s\n", ifrp->ifr_name);
@


1.64
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d505 1
a505 1
  if (!is_nonblocking())
@


1.63
log
@	* fhandler.h (fhandler_socket::read): Remove method.
	(fhandler_socket::write): Ditto.
	(fhandler_socket::readv): New method.
	(fhandler_socket::writev): Ditto.
	(fhandler_socket::recvmsg): Add new optional argument.
	(fhandler_socket::sendmsg): Ditto.
	* fhandler.cc (fhandler_socket::read): Remove method.
	(fhandler_socket::write): Ditto.
	(fhandler_socket::readv): New method.
	(fhandler_socket::writev): Ditto.
	(fhandler_socket::recvmsg): Use win32's scatter/gather IO where
	possible.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (cygwin_recvmsg): Check the msghdr's iovec fields.
	(cygwin_sendmsg): Ditto.  Add omitted sigframe.
@
text
@d328 1
a328 1
      int len = sizeof sin; 
d516 7
a522 7
	  					  FALSE);
          if (wait_result == WSA_WAIT_EVENT_0)
            WSAEnumNetworkEvents (get_socket (), ev[0], &sock_event);

          /* Unset events for listening socket and
             switch back to blocking mode */
          WSAEventSelect (get_socket (), ev[0], 0);
d524 1
a524 1
          ioctlsocket (get_socket (), FIONBIO, &nonblocking);
d526 29
a554 29
          switch (wait_result)
            {
            case WSA_WAIT_EVENT_0:
              if (sock_event.lNetworkEvents & FD_ACCEPT)
                {
                  if (sock_event.iErrorCode[FD_ACCEPT_BIT])
                    {
                      WSASetLastError (sock_event.iErrorCode[FD_ACCEPT_BIT]);
                      set_winsock_errno ();
                      res = -1;
                      goto done;
                    }
                }
              /* else; : Should never happen since FD_ACCEPT is the only event
                 that has been selected */
              break;
            case WSA_WAIT_EVENT_0 + 1:
              debug_printf ("signal received during accept");
              set_errno (EINTR);
              res = -1;
              goto done;
            case WSA_WAIT_FAILED:
            default: /* Should never happen */
              WSASetLastError (WSAEFAULT);
              set_winsock_errno ();
              res = -1;
              goto done;
            }
        }
d569 1
a569 1
	  else if (in_progress) 
d602 6
a607 6
        fhandler_socket* res_fh = fdsock (res_fd, get_name (), res);
        if (get_addr_family () == AF_LOCAL)
          res_fh->set_sun_path (get_sun_path ());
        res_fh->set_addr_family (get_addr_family ());
        res_fh->set_socket_type (get_socket_type ());
        res = res_fd;
d753 1
a753 1
	      do 
d906 1
a906 1
        _raise (SIGPIPE);
d941 1
a941 1
	      do 
@


1.62
log
@* miscfuncs.cc (check_iovec_for_read): Don't check buffer when zero length
iov_len.
(check_iovec_for_write): Ditto.
* fhandler.h (fhandler_base::readv): New method.
(fhandler_base::writev): Ditto.
* fhandler.cc (fhandler_base::readv): New method.
(fhandler_base::writev): Ditto.
* syscalls.cc (_read): Delegate to readv(2).
(_write): Ditto, mutatis mutandi.
(readv): Rewrite, based on the old _read code, to use the new
fhandler_base::readv method.  Improve access mode handling and ensure all calls
reach the final strace statement.
(writev): Ditto, mutatis mutandi.
* include/sys/uio.h (struct iovec): Change field types to match SUSv3.
* winsup.h (check_iovec_for_read): New function.
(check_iovec_for_write): Ditto.
* miscfuncs.cc (check_iovec_for_read): Ditto.
(check_iovec_for_write): Ditto.
@
text
@d663 3
a665 2
int __stdcall
fhandler_socket::read (void *ptr, size_t len)
d667 11
a677 1
  return recvfrom (ptr, len, 0, NULL, NULL);
d684 2
a685 3
  int res = -1;
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;
d688 5
a692 1
  if (is_nonblocking () || !(ovr = wsock_evt.prepare ()))
d694 7
a700 4
      debug_printf ("Fallback to winsock 1 recvfrom call");
      if ((res = ::recvfrom (get_socket (), (char *) ptr, len, flags, from,
			     fromlen))
	  == SOCKET_ERROR)
d702 7
a708 2
	  set_winsock_errno ();
	  res = -1;
d711 2
a712 1
  else
d714 2
a715 12
      WSABUF wsabuf = { len, (char *) ptr };
      DWORD ret = 0;
      if (WSARecvFrom (get_socket (), &wsabuf, 1, &ret, (DWORD *)&flags,
		       from, fromlen, ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	{
	  set_winsock_errno ();
	  res = -1;
	}
      else if ((res = wsock_evt.wait (get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
d717 2
d724 1
a724 1
fhandler_socket::recvmsg (struct msghdr *msg, int flags)
a725 6
  int res = -1;
  int nb;
  size_t tot = 0;
  char *buf, *p;
  struct iovec *iov = msg->msg_iov;

d735 98
a832 20
  for (int i = 0; i < msg->msg_iovlen; ++i)
    tot += iov[i].iov_len;
  buf = (char *) alloca (tot);
  if (tot != 0 && buf == NULL)
    {
      set_errno (ENOMEM);
      return -1;
    }
  nb = res = recvfrom (buf, tot, flags, (struct sockaddr *) msg->msg_name,
		       (int *) &msg->msg_namelen);
  p = buf;
  while (nb > 0)
    {
      ssize_t cnt = iov->iov_len;
      if (nb < cnt)
	cnt = nb;
      memcpy (iov->iov_base, p, cnt);
      p += cnt;
      nb -= cnt;
      ++iov;
d834 1
d839 2
a840 1
fhandler_socket::write (const void *ptr, size_t len)
d842 11
a852 1
  return sendto (ptr, len, 0, NULL, 0);
a858 3
  int res = -1;
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;
d864 8
a871 1
  if (is_nonblocking () || !(ovr = wsock_evt.prepare ()))
d873 11
a883 2
      debug_printf ("Fallback to winsock 1 sendto call");
      if ((res = ::sendto (get_socket (), (const char *) ptr, len,
d885 5
a889 5
			   (to ? (sockaddr *) &sin : NULL),
			   tolen)) == SOCKET_ERROR)
	{
	  set_winsock_errno ();
	  res = -1;
d892 2
a893 1
  else
d895 2
a896 15
      WSABUF wsabuf = { len, (char *) ptr };
      DWORD ret = 0;
      if (WSASendTo (get_socket (), &wsabuf, 1, &ret,
		     (DWORD)(flags & MSG_WINMASK),
		     (to ? (sockaddr *) &sin : NULL),
		     tolen,
		     ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	{
	  set_winsock_errno ();
	  res = -1;
	}
      else if ((res = wsock_evt.wait (get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
d898 2
d902 1
a902 1
  if (get_errno () == ESHUTDOWN)
d908 1
d913 1
a913 1
fhandler_socket::sendmsg (const struct msghdr *msg, int flags)
d915 65
a979 3
    size_t tot = 0;
    char *buf, *p;
    struct iovec *iov = msg->msg_iov;
a980 1
    if (get_addr_family () == AF_LOCAL)
d982 10
a991 5
        /* For AF_LOCAL/AF_UNIX sockets, if descriptors are given, start
           the special handling for descriptor passing.  Otherwise just
           transmit an empty string to tell the receiver that no
           descriptor passing is done. */
      /*TODO*/
d993 30
a1022 16
    for(int i = 0; i < msg->msg_iovlen; ++i)
        tot += iov[i].iov_len;
    buf = (char *) alloca (tot);
    if (tot != 0 && buf == NULL)
      {
        set_errno (ENOMEM);
        return -1;
      }
    p = buf;
    for (int i = 0; i < msg->msg_iovlen; ++i)
      {
        memcpy (p, iov[i].iov_base, iov[i].iov_len);
        p += iov[i].iov_len;
      }
    return sendto (buf, tot, flags, (struct sockaddr *) msg->msg_name,
		   msg->msg_namelen);
@


1.61
log
@	* fhandler_socket.cc (fhandler_socket::recvfrom): Eliminate flags
	not understood by WinSock.
	(fhandler_socket::sendto): Ditto.  If WinSock sendto() returns
	WSAESHUTDOWN, change errno to EPIPE and raise SIGPIPE if MSG_NOSIGNAL
	isn't set in flags.
	* include/cygwin/socket.h: Define MSG_WINMASK and MSG_NOSIGNAL.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d739 3
a741 1
      ssize_t cnt = min(nb, iov->iov_len);
@


1.60
log
@	* fhandler_socket.cc (fhandler_socket::check_peer_secret_event):
	Fix strace message.
	(fhandler_socket::connect): Remove sigframe.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::getsockname): Ditto.
	(fhandler_socket::getpeername): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::ioctl): Ditto.
	* ioctl.cc (ioctl): Add sigframe.
	*net.cc (cygwin_sendto): Ditto.
	(cygwin_recvfrom): Ditto.
	(cygwin_recvfrom): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_shutdown): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_accept): Ditto.  Improve strace message.
	(cygwin_getsockname): Ditto.  Ditto.
	(cygwin_recvmsg): Ditto.  Ditto.
	(cygwin_sendmsg): Fix strace message.
@
text
@d677 1
d769 2
a770 1
      if ((res = ::sendto (get_socket (), (const char *) ptr, len, flags,
d782 2
a783 1
      if (WSASendTo (get_socket (), &wsabuf, 1, &ret, (DWORD)flags,
d797 7
@


1.59
log
@	* fhandler.h (fhandler_socket::recvfrom): Fix prototype.
	(fhandler_socket::sendto): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::sendto): Ditto.
	* include/sys/socket.h (recv): Fix prototype.
	(recvfrom): Ditto.
	(send): Ditto.
	(sendto): Ditto.
	* net.cc (cygwin_sendto): Ditto. Improve strace message
	(cygwin_recvfrom): Ditto.  Ditto.
	(cygwin_setsockopt): Improve strace message.
	(cygwin_getsockopt): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_bind): Ditto.
	(cygwin_getsockname): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_recv): Fix prototype.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Improve strace message.
	(cygwin_sendmsg): Ditto.
@
text
@d206 1
a206 1
      debug_printf ("%s event already exist");
a408 2
  sigframe thisframe (mainthread);

a486 2
  sigframe thisframe (mainthread);

a622 2
  sigframe thisframe (mainthread);

a655 2
  sigframe thisframe (mainthread);

a676 2
  sigframe thisframe (mainthread);

a715 2
  sigframe thisframe (mainthread);

a761 2
  sigframe thisframe (mainthread);

a832 2
  sigframe thisframe (mainthread);

a858 2
  sigframe thisframe (mainthread);

a899 2

  sigframe thisframe (mainthread);
@


1.58
log
@	* fhandler.h (fhandler_socket::recv): Remove method.
	(fhandler_socket::send): Ditto.
	* fhandler_socket.cc (fhandler_socket::recv): Ditto.
	(fhandler_socket::send): Ditto.
	(fhandler_socket::read): Delegate to fhandler_socket::recvfrom.
	(fhandler_socket::write): Delegate to fhandler_socket::sendto.
	(fhandler_socket::sendto): Check for null `to' address.
	* net.cc (cygwin_sendto): Check for zero request length.
	(cygwin_recvfrom): Ditto.  Fix signature, use void *buf.
	(cygwin_recv): Delegate to cygwin_recvfrom.
	(cygwin_send): Delegate to cygwin_sendto.
@
text
@d678 1
a678 1
fhandler_socket::recvfrom (void *ptr, size_t len, unsigned int flags,
d766 1
a766 1
fhandler_socket::sendto (const void *ptr, size_t len, unsigned int flags,
@


1.57
log
@	* winsup.h (__check_null_invalid_struct): Make ptr argument non-const.
	(__check_null_invalid_struct_errno): Ditto.
	* miscfuncs.cc (__check_null_invalid_struct): Ditto.
	(__check_null_invalid_struct_errno): Ditto.
	(__check_invalid_read_ptr_errno): Remove superfluous cast.
	* net.cc (get): Set appropriate errno if fd is not a socket.
	(cygwin_sendto): Fix parameter checking.
	(cygwin_recvfrom): Ditto.
	(cygwin_setsockopt): Ditto.
	(cygwin_getsockopt): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_gethostbyaddr): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_bind): Ditto.
	(cygwin_getsockname): Ditto.
	(cygwin_listen): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_send): Ditto.
	(cygwin_shutdown): Ditto.  Move sigframe to fhandler_socket.
	(cygwin_recvmsg): Fix parameter checking.  Add tracing.
	(cygwin_sendmsg): Ditto.
	* fhandler_socket.cc (fhandler_socket::shutdown): Add sigframe.
	* resource.cc (setrlimit): Fix parameter checking.
@
text
@a670 37
int
fhandler_socket::recv (void *ptr, size_t len, unsigned int flags)
{
  int res = -1;
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;

  sigframe thisframe (mainthread);

  if (is_nonblocking () || !(ovr = wsock_evt.prepare ()))
    {
      debug_printf ("Fallback to winsock 1 recv call");
      if ((res = ::recv (get_socket (), (char *) ptr, len, flags))
	  == SOCKET_ERROR)
	{
	  set_winsock_errno ();
	  res = -1;
	}
    }
  else
    {
      WSABUF wsabuf = { len, (char *) ptr };
      DWORD ret = 0;
      if (WSARecv (get_socket (), &wsabuf, 1, &ret, (DWORD *)&flags,
		   ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	{
	  set_winsock_errno ();
	  res = -1;
	}
      else if ((res = wsock_evt.wait (get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
    }
  return res;
}

d674 1
a674 1
  return recv (ptr, len, 0);
a759 37
fhandler_socket::send (const void *ptr, size_t len, unsigned int flags)
{
  int res = -1;
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;

  sigframe thisframe (mainthread);

  if (is_nonblocking () || !(ovr = wsock_evt.prepare ()))
    {
      debug_printf ("Fallback to winsock 1 send call");
      if ((res = ::send (get_socket (), (const char *) ptr, len, flags))
	  == SOCKET_ERROR)
	{
	  set_winsock_errno ();
	  res = -1;
	}
    }
  else
    {
      WSABUF wsabuf = { len, (char *) ptr };
      DWORD ret = 0;
      if (WSASend (get_socket (), &wsabuf, 1, &ret, (DWORD)flags,
		   ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	{
	  set_winsock_errno ();
	  res = -1;
	}
      else if ((res = wsock_evt.wait (get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
    }
  return res;
}

int
d762 1
a762 1
  return send (ptr, len, 0);
d776 1
a776 1
  if (!get_inet_addr (to, tolen, &sin, &tolen))
d783 2
a784 1
			   (sockaddr *) &sin, tolen)) == SOCKET_ERROR)
d795 3
a797 1
		     (sockaddr *) &sin, tolen, ovr, NULL) != SOCKET_ERROR)
@


1.56
log
@	Fix by Conrad Scott  <conrad.scott@@dsl.pipex.com>:
	* fhandler_socket.cc (fhandler_socket::accept): Fix FIONBIO call.
@
text
@d918 2
@


1.55
log
@* debug.h (handle_list): Move here from debug.cc.  Add "inherit" flag
functionality.
* cygheap.cc (init_cheap): Move cygheap_max calculation to _csbrk.
(_csbrk): Reorganize to not assume first allocation is <= 1 page.
(cygheap_setup_for_child): Mark protected handle as inheritable.
* cygheap.h (cygheap_debug): New struct.
(init_cygheap): Add new structure when debugging.
* dcrt0.cc (dll_crt0_1): Remove call to debug_init.  Close ppid_handle here, if
appropriate.  Don't protect subproc_ready, since it is already protected in the
parent.  Call memory_init prior to ProtectHandle to ensure that cygheap is set
up.  Call debug_fixup_after_fork_exec when appropriate.
(_dll_crt0): Don't close ppid_handle here.
* debug.cc: Use cygheap debug structure rather than static elements throughout.
(add_handle): Don't issue a warning if attempt to protect handle in exactly the
same way from exactly the same place.  Add pid info to warning output.  Accept
additional argument controlling whether handle is to be inherited.  Add pid to
stored information.
(debug_fixup_after_fork_exec): Renamed from debug_fixup_after_fork.  Reorganize
to avoid erroneously skipping handles.
(mark_closed): Add pid info to warning output.
(setclexec): Rename from setclexec_pid.
* fhandler.cc (fhandler_base::get_default_fmode): Minor reorg.
(fhandler_base::fstat): Add debugging output.
(fhandler_base::set_inheritance): Call setclexec rather than setclexec_pid.
(fhandler_base::fork_fixup): Ditto.
* fhandler_console.cc (get_tty_stuff): Mark protected handle as inheritable.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* tty.cc (tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* fork.cc (fork_parent): Ditto.
(fork_child): Close protected handles with correct name.  Remove
debug_fixup_after_fork call.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Mark protected
handle as inheritable/non-inheritable, as appropriate.
* shared.cc (memory_init): Mark protected handle as inheritable.  Call
debug_init here.
* sigproc.cc (wait_sig): Close protected handle with correct name.
* spawn.cc (spawn_guts): Rename spr to subproc_ready and mark it as
inheritable.
* exceptions.cc (debugger_command): Try to run dumper.exe, if found.
* syscalls.cc (fstat64): Don't follow symlinks for path_conv lookup since path
is already resolved.
@
text
@d526 3
a528 2
          WSAEventSelect (get_socket (), ev[0], 0 );
          ioctlsocket (get_socket (), FIONBIO, 0);
@


1.54
log
@	* fhandler.h (fhandler_socket::is_unconnected): Constify.
	(fhandler_socket::is_connect_pending): Ditto.
	(fhandler_socket::is_connected): Ditto.
	(fhandler_socket::set_connect_state): New method.
	(struct select_record): Add member `except_on_write'.
	(select_record::select_record): Initialize all bool values to `false'.
	* fhandler_socket.cc: Use set_connect_state() method throughout.
	(fhandler_socket::connect): Set state always to connected if connection
	isn't pending.
	* net.cc (cygwin_getsockopt): Revert erroneous previous patch.
	* select.cc (set_bits): Check for `except_on_write'.  Set fd in
	write_fds if set.  Set connect state to connected if fd has been
	returned by WINSOCK_SELECT.
	(peek_socket): Check for `except_on_write'.
	(start_thread_socket): Ditto.
	(fhandler_socket::select_write): Don't set `write_ready' if connect
	is pending.  Set `except_on_write' if connect is pending.
@
text
@d158 2
a159 1
  secret_event = CreateEvent (get_inheritance(true), FALSE, FALSE, buf);
d163 3
a165 1
  if (secret_event)
d167 2
@


1.53
log
@	* fhandler.h (UNCONNECTED): New define.
	(CONNECT_PENDING): Ditto.
	(CONNECTED): Ditto.
	(class fhandler_socket): Add member `had_connect_or_listen'.
	Add member functions `is_unconnected', `is_connect_pending' and
	`is_connected'.
	* fhandler_socket.cc (fhandler_socket::connect): Set member
	`had_connect_or_listen' according to return code of WinSock
	call.
	(fhandler_socket::listen): Ditto.
	* net.cc (cygwin_getsockopt): Modify SO_ERROR return value in
	case of socket with pending connect().
	* select.cc (peek_socket): Only add socket to matching fd_set
	if it's not "ready".  Call WINSOCK_SELECT only if at least one
	socket is in one of the fd_sets.
	(start_thread_socket): Only add socket to matching fd_set
	if it's not "ready".
	(fhandler_socket::select_write): Set write_ready to true also
	if socket isn't connected or listening.
@
text
@d458 4
a461 4
  if (!res)
    had_connect_or_listen = CONNECTED;
  else if (WSAGetLastError () == WSAEINPROGRESS)
    had_connect_or_listen = CONNECT_PENDING;
d472 1
a472 1
    had_connect_or_listen = CONNECTED;
@


1.52
log
@	* fhandler_socket.cc (fhandler_socket::set_sun_path): Don't free
	memory here.  Allow NULL parameter.
@
text
@d458 4
d471 2
@


1.51
log
@	* fhandler_socket.cc (fhandler_socket::dup): Add missing copy operation
	on sun_path.
@
text
@d1144 1
a1144 3
  if (sun_path)
    cfree (sun_path);
  sun_path = cstrdup (path);
@


1.50
log
@	* autoload.cc (WSAEventSelect): Define new autoload function.
	(WSAEnumNetworkEvents): Ditto.
	* fhandler_socket.cc (fhandler_socket::accept): If socket is
	in blocking mode wait for incoming connection and signal.
@
text
@d289 2
@


1.50.2.1
log
@* path.cc (suffix_scan::has): Reorganize to eliminate double scanning for for
.exe (in the typical case).
* fhandler_socket.cc (fhandler_socket::set_sun_path): Don't free memory here.
Allow NULL parameter.
* fhandler_socket.cc (fhandler_socket::dup): Add missing copy operation on
sun_path.
@
text
@a288 2
  if (get_addr_family () == AF_LOCAL)
    fhs->set_sun_path (get_sun_path ());
d1142 3
a1144 1
  sun_path = path ? cstrdup (path) : NULL;
@


1.49
log
@	* fhandler.h (fhandler_socket::bind): Add method definition.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::getsockname): Ditto.
	(fhandler_socket::getpeername): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	(fhandler_socket::shutdown): Ditto.
	* fhandler_socket.cc (get_inet_addr): Move here from net.cc.
	(fhandler_socket::bind): New method.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::getsockname): Ditto.
	(fhandler_socket::getpeername): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	(fhandler_socket::shutdown): Ditto.
	* net.cc: Various formatting cleanups throughout.
	(get_inet_addr): Move to fhandler_socket.cc.
	(cygwin_bind): Move base functionality to appropriate fhandler_socket
	method.
	(cygwin_connect): Ditto.
	(cygwin_listen): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_getsockname): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_recvfrom): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendto): Ditto.
	(cygwin_sendmsg): Ditto.
	(cygwin_shutdown): Ditto.
@
text
@d472 1
d496 52
a547 1
  res = ::accept (get_socket (), peer, len);  // can't use a blocking call inside a lock
d580 1
a580 1
	  return res;
d584 20
a603 14
  cygheap_fdnew res_fd;
  if (res_fd < 0)
    /* FIXME: what is correct errno? */;
  else if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
    set_winsock_errno ();
  else
    {
      fhandler_socket* res_fh = fdsock (res_fd, get_name (), res);
      if (get_addr_family () == AF_LOCAL)
	res_fh->set_sun_path (get_sun_path ());
      res_fh->set_addr_family (get_addr_family ());
      res_fh->set_socket_type (get_socket_type ());
      res = res_fd;
    }
@


1.48
log
@* fhandler.cc (fhandler_base::fstat): Set S_IFIFO for pipes.
* fhandler_socket.cc (fhandler_socket.cc::fstat): Set S_IFSOCK.
@
text
@d18 2
d41 5
d48 46
d149 1
a149 1
  if (getsockname (get_socket (), (struct sockaddr*) &sin, &sin_len))
d313 287
d607 1
d643 82
d732 1
d767 100
a866 1
/* Cygwin internal */
d871 1
a907 1
/* Cygwin internal */
d915 1
@


1.47
log
@	* fhandler.h (fhandler_socket::fixup_after_fork): Revert patch from
	2002-06-04.
	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Ditto.
	(fhandler_socket::dup): Ditto.
	* net.cc (fdsock): Make sockets explicitely noninheritable on NT.
@
text
@d251 5
a255 1
    buf->st_ino = (ino_t) get_handle ();
@


1.46
log
@coerce
@
text
@d186 1
a186 1
fhandler_socket::fixup_after_fork (bool dup, HANDLE parent)
a209 4
#if 1
      if (!dup && new_sock != (SOCKET) get_socket ())
        closesocket (get_socket ());
#endif
a217 6
fhandler_socket::fixup_after_fork (HANDLE parent)
{
  fixup_after_fork (false, parent);
}

void
d222 1
a222 1
    fixup_after_fork (false, parent);
d240 1
a240 1
      fhs->fixup_after_fork (true, hMainProc);
@


1.45
log
@* fhandler_socket.cc (fhandler_socket::fstat): Don't assume that socket is
unix-domain socket.
* times.cc (hires_ms::prime): Set init flag.
* times.cc (hires_ms::prime): Adjust epoch of initime_us from 1601 to 1970.
@
text
@d261 1
a261 1
    buf->st_ino = get_handle ();
@


1.44
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d259 4
a262 3
  fhandler_disk_file fh;
  fh.set_name (cstrdup (get_name ()), get_win32_name ());
  return fh.fstat (buf, pc);
@


1.43
log
@	* fhandler.h (class fhandler_socket): Add private method
	fixup_after_fork (bool, HANDLE).
	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Move
	functionality to new private method.  Add closing parent socket
	if not called from dup().  Create method new calling private method
	with appropriate parameter.
	(fhandler_socket::fixup_after_exec): Call private method
	fixup_after_fork with appropriate parameter.
	(fhandler_socket::dup): Ditto.
@
text
@a21 1
#include <fcntl.h>
@


1.42
log
@* dtable.cc (dtable::build_fhandler_from_name): Just pass posix path along to
set_name via return_and_clear_normalized_path.
(dtable::build_fhandler): New method with const char * argument.
(dtable::reset_unix_path_name): Eliminate.
(dtable::dup_worker): Use correct build_fhandler method.
* mmap.cc (mmap_record::alloc_fh): Ditto.
* dtable.h (dtable::build_fhandler): New method.
(dtable::reset_unix_path_name): Eliminate.
* fhandler.cc (fhandler_base::set_name): Assume that unix_name has already been
cmalloced.
(fhandler_base::reset_unix_path_name): Eliminate.
(fhandler_base::~fhandler_base): Coercion for cfree.
* fhandler.h (fhandler_base::unix_path_name): Make const char *.
(fhandler_base::win32_path_name): Ditto.
(fhandler_base::reset_unix_path_name): Eliminate.
* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Accommodate const char
*ness of win32_path_name.
* fhandler_socket.cc (fhandler_socket::fstat): Accommodate new set_name
requirements.
* path.cc (path_conv::return_and_clear_normalized_path): New method.
(path_conv::clear_normalized_path): Eliminate.
(path_conv::~path_conv): Ditto.
(path_conv::check): Accommodate new build_fhandler method.
* path.h (path_conv::~path_conv): Eliminate.
(path_conv::clear_normalized_path): Ditto.
(path_conv::return_and_clear_normalized_path): Declare new method.
@
text
@d187 1
a187 1
fhandler_socket::fixup_after_fork (HANDLE parent)
d211 4
d223 6
d233 1
a233 1
    fixup_after_fork (parent);
d251 1
a251 1
      fhs->fixup_after_fork (hMainProc);
@


1.41
log
@* fhandler_socket.cc (fhandler_socket::close): Respond to signals while
looping, waiting for socket to close.  Superstitiously clear last error when
WSAEWOULDBLOCK.
@
text
@d251 1
a251 1
  fh.set_name (get_name (), get_win32_name ());
@


1.40
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@d355 1
a355 4
  while ((res = closesocket (get_socket ()))
	 && WSAGetLastError () == WSAEWOULDBLOCK)
    continue;
  if (res)
d357 13
a369 2
      set_winsock_errno ();
      res = -1;
@


1.39
log
@	* dtable.cc (dtable::dup2): Revert previous patch.
	* fhandler.h: Ditto.
	(fhandler_socket::recv): Define new method.
	(fhandler_socket::send): Ditto.
	* fhandler_socket.cc (fhandler_socket::recv): New method.
	(fhandler_socket::send): Ditto.
	(fhandler_socket::read): Call fhandler_socket::recv() now.
	(fhandler_socket::write): Call fhandler_socket::send() now.
	* net.cc (class wsock_event): Move definition to wsock_event.h.
	(fdsock): Revert previous patch.
	(cygwin_recv): Move implementation to fhandler_socket::recv().
	(cygwin_send): Move implementation to fhandler_socket::send().
	* wsock_event.h: New file.
@
text
@d248 1
a248 1
fhandler_socket::fstat (struct stat *buf, path_conv *pc)
@


1.38
log
@	* dtable.cc (dtable::dup2): Store fd for fhandler_socket.
	* fhandler.h (fhandler_base::set_fd): New virtual method.
	(fhandler_base::get_fd): Ditto.
	(fhandler_socket::set_fd): Ditto.
	(fhandler_socket::get_fd): Ditto.
	* fhandler_socket.cc (fhandler_socket::read): Call cygwin_recv instead
	of native Winsock recv.
	(fhandler_socket::write): Call cygwin_send instead of native Winsock
	send.
	* net.cc (fdsock): Store fd in fhandler_socket.
@
text
@d34 1
d255 35
a289 1
extern "C" int cygwin_recv (int, void *, int, unsigned int);
d294 1
a294 7
  sigframe thisframe (mainthread);
  int res = cygwin_recv (get_fd (), (char *) ptr, len, 0);
#if 0
  if (res == SOCKET_ERROR)
    set_winsock_errno ();
#endif
  return res;
a296 2
extern "C" int cygwin_send (int, const void *, int, unsigned int);

d298 1
a298 1
fhandler_socket::write (const void *ptr, size_t len)
d300 4
d305 11
a315 3
  int res = cygwin_send (get_fd (), (const char *) ptr, len, 0);
#if 0
  if (res == SOCKET_ERROR)
d317 12
a328 3
      set_winsock_errno ();
      if (get_errno () == ECONNABORTED || get_errno () == ECONNRESET)
	_raise (SIGPIPE);
a329 1
#endif
d331 6
@


1.37
log
@	* fhandler.h (fhandler_socket::sun_path): New private member.
	(fhandler_socket::set_sun_path): New method.
	(fhandler_socket::get_sun_path): Ditto.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	sun_path to NULL.
	(fhandler_socket::~fhandler_socket): Free sun_path if needed.
	(fhandler_socket::set_sun_path): New method.
	* net.cc (cygwin_bind): Set sun_path to path of local socket file.
	(cygwin_getsockname): Add code to return correct sockaddr for unix
	domain sockets.
@
text
@d254 2
d260 2
a261 1
  int res = recv (get_socket (), (char *) ptr, len, 0);
d264 1
d268 2
d274 2
a275 1
  int res = send (get_socket (), (const char *) ptr, len, 0);
d282 1
@


1.36
log
@Eliminate excess whitespace.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Red Hat, Inc.
d45 1
a45 1
  : fhandler_base (FH_SOCKET)
d56 2
d482 8
@


1.35
log
@	* fhandler_socket.cc (fhandler_socket::close): Add error handling.

	Fixed ChangeLog entries.
@
text
@d48 1
a48 1
  prot_info_ptr = (LPWSAPROTOCOL_INFOA) cmalloc (HEAP_BUF, 
d177 1
a177 1
	  	    get_socket (), win_proc_id, prot_info_ptr);
d293 1
a293 1
         && WSAGetLastError () == WSAEWOULDBLOCK)
@


1.34
log
@        * (fhandler_socket::dup): Revert previous change.
@
text
@d292 1
a292 1
  while (closesocket (get_socket ())
d295 5
@


1.33
log
@* dtable.cc (dtable::dup2): Add some debugging.  Use methods from passed in
class rather than cygheap->fdtab.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Add more
debugging output.
(fhandler_socket::dup): Allocate new space for prot_info_ptr for duplicated
entry.
* syscalls.cc (stat_worker): Always delete fh if it has been created.
@
text
@a234 2
  fhs->prot_info_ptr = (LPWSAPROTOCOL_INFOA)
    cmalloc (HEAP_BUF, sizeof (WSAPROTOCOL_INFOA));
@


1.32
log
@* fhandler.h (fhandler_serial::fhandler_serial): Change to only accept unit
argument.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
(fhandler_serial::open): Avoid else when previous clause is a return().
* path.cc (get_devn): Alias /dev/ttyS0 -> /dev/com1, etc.
(get_device_number): Reallow standalone "com1" as a valid name for /dev/com1.
@
text
@d172 2
a173 2
    debug_printf ("WSADuplicateSocket went fine, dwServiceFlags1=%d",
		  prot_info_ptr->dwServiceFlags1);
d176 2
a177 1
      debug_printf ("WSADuplicateSocket error");
d207 1
a207 1
      debug_printf ("WSASocket went fine %p", new_sock);
d234 3
d294 3
a296 5
  if (closesocket (get_socket ()))
    {
      set_winsock_errno ();
      res = -1;
    }
@


1.31
log
@Ensure that all fhandler_*::read definitions are __stdcall throughout.
* fhandler.cc (fhandler_base::set_inheritance): Be more defensive in debugging
code.
* fhandler.h: Adjust regparms throughout to reflect passing 'this' parameter.
* fhandler_console.cc (fhandler_console::read): Remove unneeded test.  Only
honor "key down" events.
* miscfuncs.cc (strcasestr): Reorganize for efficient code use.
(check_null_empty_str_errno): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
* syscalls.cc (_read): Return 0 when length == 0, as per Single UNIX
Specification.
@
text
@d44 2
a45 2
fhandler_socket::fhandler_socket () :
	fhandler_base (FH_SOCKET)
@


1.30
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d250 1
a250 1
int
@


1.29
log
@* autoload.cc (load_wsock32): Declare dummy function to force loading of
winsock.
* fhandler.cc (fhandler_base::set_inheritance): Make debugging output more
verbose.
* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Force loading of
winsock32 if winsock2 not available.
* net.cc (set_socket_inheritance): Use DuplicateHandle in all cases to set
inheritance correctly.
(fdsock): Use winsock2_active macro to determine when to set socket
inheritance.  Remove fdtab resource locking since this function should already
be protected.
(cygwin_accept): Simplify logic.  Ensure that fdtab unlock is not called
inappropriately.
(cygwin_rcmd): Use fdtab locking.
(cygwin_rresvport): Ditto.
(cygwin_rexec): Ditto.
* select.cc (peek_socket): Set errno appropriately if winsock select fails.
* winsup.h: Declare check_pty_fds.
* syscalls.cc (check_pty_fds): Rename from check_ttys_fds.  Also check pty
master.
(setsid): Use check_pty_fds.
* dtable.cc (dtable::dec_console_fds): Add check on pty fds.
@
text
@a46 1
  set_cb (sizeof *this);
@


1.28
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d182 1
d201 1
@


1.27
log
@* autoload.cc (wsock_init): Reorganize slightly to accomodate a new compiler.
@
text
@d44 2
a45 2
fhandler_socket::fhandler_socket (const char *name) :
	fhandler_base (FH_SOCKET, name)
d65 1
a65 2
      entropy_source = new (buf) fhandler_dev_random (ENTROPY_SOURCE_NAME,
						      ENTROPY_SOURCE_DEV_UNIT);
d117 7
a123 2
  if (secret_event)
    SetEvent (secret_event);
d167 1
a167 4
  int ret = 1;

  if (prot_info_ptr &&
      (ret = WSADuplicateSocketA (get_socket (), win_proc_id, prot_info_ptr)))
d169 2
a170 7
      debug_printf ("WSADuplicateSocket error");
      set_winsock_errno ();
    }
  if (!ret && ws2_32_handle)
    {
      debug_printf ("WSADuplicateSocket went fine, dwServiceFlags1=%d",
		    prot_info_ptr->dwServiceFlags1);
d172 3
d177 2
a178 2
      fhandler_base::fixup_before_fork_exec (win_proc_id);
      debug_printf ("Without Winsock 2.0");
d185 1
a185 1
  SOCKET new_sock = INVALID_SOCKET;
d189 5
a193 5
  if (prot_info_ptr &&
      (new_sock = WSASocketA (FROM_PROTOCOL_INFO,
			      FROM_PROTOCOL_INFO,
			      FROM_PROTOCOL_INFO,
			      prot_info_ptr, 0, 0)) == INVALID_SOCKET)
d198 1
a198 1
  if (new_sock != INVALID_SOCKET && ws2_32_handle)
d200 2
a201 2
      debug_printf ("WSASocket went fine %p", new_sock);
      set_io_handle ((HANDLE) new_sock);
d205 2
a206 4
#if 0
      fhandler_base::fixup_after_fork (parent);
#endif
      debug_printf ("Without Winsock 2.0");
d208 1
d216 1
a216 1
  extern WSADATA wsadata;
d219 2
a220 1
  else if (wsadata.wVersion < 512) /* < Winsock 2.0 */
d222 1
d228 1
d233 1
a233 1
  if (ws2_32_handle)
d241 8
d255 1
a255 3
    {
      set_winsock_errno ();
    }
d424 1
a424 1
			    *(int *) p ? "un" : "");
d470 1
a470 3
#if 0
  extern WSADATA wsadata;
  if (wsadata.wVersion < 512) /* < Winsock 2.0 */
a471 1
#endif
@


1.26
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d201 1
a201 1
      debug_printf ("WSASocket went fine");
@


1.25
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d69 1
a69 1
      !entropy_source->open (ENTROPY_SOURCE_NAME, O_RDONLY))
@


1.24
log
@        * fhandler_socket.cc (fhandler_socket::fixup_after_exec): Close
        socket only when not using Winsock2.
@
text
@d30 1
@


1.24.2.1
log
@Merged changes from HEAD
@
text
@a29 1
#include "path.h"
@


1.24.2.2
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Red Hat, Inc.
d44 2
a45 2
fhandler_socket::fhandler_socket ()
  : fhandler_base (FH_SOCKET), sun_path (NULL)
d47 1
d49 1
a49 1
  prot_info_ptr = (LPWSAPROTOCOL_INFOA) cmalloc (HEAP_BUF,
a56 2
  if (sun_path)
    cfree (sun_path);
d65 2
a66 1
      entropy_source = new (buf) fhandler_dev_random (ENTROPY_SOURCE_DEV_UNIT);
d69 1
a69 1
      !entropy_source->open (NULL, O_RDONLY))
d118 2
a119 7
  if (!secret_event)
    debug_printf ("no secret event?");
  else
    {
      SetEvent (secret_event);
      debug_printf ("signaled secret_event");
    }
d163 4
a166 1
  if (!winsock2_active)
d168 7
a174 2
      fhandler_base::fixup_before_fork_exec (win_proc_id);
      debug_printf ("Without Winsock 2.0");
a175 3
  else if (!WSADuplicateSocketA (get_socket (), win_proc_id, prot_info_ptr))
    debug_printf ("WSADuplicateSocket went fine, sock %p, win_proc_id %d, prot_info_ptr %p",
		  get_socket (), win_proc_id, prot_info_ptr);
d178 2
a179 3
      debug_printf ("WSADuplicateSocket error, sock %p, win_proc_id %d, prot_info_ptr %p",
		    get_socket (), win_proc_id, prot_info_ptr);
      set_winsock_errno ();
a182 1
extern "C" void __stdcall load_wsock32 ();
d186 1
a186 1
  SOCKET new_sock;
d190 5
a194 5

  if ((new_sock = WSASocketA (FROM_PROTOCOL_INFO,
				   FROM_PROTOCOL_INFO,
				   FROM_PROTOCOL_INFO,
				   prot_info_ptr, 0, 0)) == INVALID_SOCKET)
d199 1
a199 1
  else if (!new_sock && !winsock2_active)
d201 2
a202 3
      load_wsock32 ();
      fhandler_base::fixup_after_fork (parent);
      debug_printf ("Without Winsock 2.0");
d206 4
a209 2
      debug_printf ("WSASocket went fine new_sock %p, old_sock %p", new_sock, get_io_handle ());
      set_io_handle ((HANDLE) new_sock);
a210 1

d218 1
a218 1
  debug_printf ("here");
d221 1
a221 2
#if 0
  else if (!winsock2_active)
a222 1
#endif
a227 1
  debug_printf ("here");
a230 1

d232 1
a232 1
  if (winsock2_active)
d240 1
a240 9
int __stdcall
fhandler_socket::fstat (struct stat *buf, path_conv *pc)
{
  fhandler_disk_file fh;
  fh.set_name (get_name (), get_win32_name ());
  return fh.fstat (buf, pc);
}

int __stdcall
d246 3
a248 1
    set_winsock_errno ();
d282 1
a282 4
  while ((res = closesocket (get_socket ()))
	 && WSAGetLastError () == WSAEWOULDBLOCK)
    continue;
  if (res)
d417 1
a417 1
			    *(int *) p ? "non" : "");
d463 3
a465 1
  if (!winsock2_active) /* < Winsock 2.0 */
d467 1
a469 8
}

void
fhandler_socket::set_sun_path (const char *path)
{
  if (sun_path)
    cfree (sun_path);
  sun_path = cstrdup (path);
@


1.24.2.3
log
@Merged changes from HEAD
@
text
@a33 1
#include "wsock_event.h"
d247 1
a247 1
fhandler_socket::fstat (struct __stat64 *buf, path_conv *pc)
d254 2
a255 2
int
fhandler_socket::recv (void *ptr, size_t len, unsigned int flags)
a256 4
  int res = -1;
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;

d258 3
a260 25
  if (is_nonblocking () || !(ovr = wsock_evt.prepare ()))
    {
      debug_printf ("Fallback to winsock 1 recv call");
      if ((res = ::recv (get_socket (), (char *) ptr, len, flags))
	  == SOCKET_ERROR)
	{
	  set_winsock_errno ();
	  res = -1;
	}
    }
  else
    {
      WSABUF wsabuf = { len, (char *) ptr };
      DWORD ret = 0;
      if (WSARecv (get_socket (), &wsabuf, 1, &ret, (DWORD *)&flags,
		   ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	{
	  set_winsock_errno ();
	  res = -1;
	}
      else if ((res = wsock_evt.wait (get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
    }
a263 6
int __stdcall
fhandler_socket::read (void *ptr, size_t len)
{
  return recv (ptr, len, 0);
}

d265 1
a265 1
fhandler_socket::send (const void *ptr, size_t len, unsigned int flags)
a266 4
  int res = -1;
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;

d268 2
a269 1
  if (is_nonblocking () || !(ovr = wsock_evt.prepare ()))
d271 3
a273 22
      debug_printf ("Fallback to winsock 1 send call");
      if ((res = ::send (get_socket (), (const char *) ptr, len, flags))
	  == SOCKET_ERROR)
	{
	  set_winsock_errno ();
	  res = -1;
	}
    }
  else
    {
      WSABUF wsabuf = { len, (char *) ptr };
      DWORD ret = 0;
      if (WSASend (get_socket (), &wsabuf, 1, &ret, (DWORD)flags,
		   ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	{
	  set_winsock_errno ();
	  res = -1;
	}
      else if ((res = wsock_evt.wait (get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
a275 6
}

int
fhandler_socket::write (const void *ptr, size_t len)
{
  return send (ptr, len, 0);
@


1.24.2.4
log
@Merged changes from HEAD
@
text
@d22 1
d250 3
a252 4
  int res = fhandler_base::fstat (buf, pc);
  if (!res)
    buf->st_ino = (ino_t) get_handle ();
  return res;
d355 4
a358 1
  while ((res = closesocket (get_socket ())) != 0)
d360 2
a361 13
      if (WSAGetLastError () != WSAEWOULDBLOCK)
	{
	  set_winsock_errno ();
	  res = -1;
	  break;
	}
      if (WaitForSingleObject (signal_arrived, 10) == WAIT_OBJECT_0)
	{
	  set_errno (EINTR);
	  res = -1;
	  break;
	}
      WSASetLastError (0);
@


1.24.2.5
log
@Merged changes from HEAD
@
text
@d251 1
a251 5
    {
      buf->st_mode &= ~_IFMT;
      buf->st_mode |= _IFSOCK;
      buf->st_ino = (ino_t) get_handle ();
    }
@


1.24.2.6
log
@Merged changes from HEAD
@
text
@a17 2
#include <sys/un.h>
#include <sys/uio.h>
a38 5
extern fhandler_socket *fdsock (int& fd, const char *name, SOCKET soc);
extern "C" {
int sscanf (const char *, const char *, ...);
} /* End of "C" section */

a40 46
/* cygwin internal: map sockaddr into internet domain address */
static int
get_inet_addr (const struct sockaddr *in, int inlen,
               struct sockaddr_in *out, int *outlen, int* secret = 0)
{
  int secret_buf [4];
  int* secret_ptr = (secret ? : secret_buf);

  if (in->sa_family == AF_INET)
    {
      *out = * (sockaddr_in *)in;
      *outlen = inlen;
      return 1;
    }
  else if (in->sa_family == AF_LOCAL)
    {
      int fd = _open (in->sa_data, O_RDONLY);
      if (fd == -1)
        return 0;

      int ret = 0;
      char buf[128];
      memset (buf, 0, sizeof buf);
      if (read (fd, buf, sizeof buf) != -1)
        {
          sockaddr_in sin;
          sin.sin_family = AF_INET;
          sscanf (buf + strlen (SOCKET_COOKIE), "%hu %08x-%08x-%08x-%08x",
                  &sin.sin_port,
                  secret_ptr, secret_ptr + 1, secret_ptr + 2, secret_ptr + 3);
          sin.sin_port = htons (sin.sin_port);
          sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
          *out = sin;
          *outlen = sizeof sin;
          ret = 1;
        }
      _close (fd);
      return ret;
    }
  else
    {
      set_errno (EAFNOSUPPORT);
      return 0;
    }
}

d96 1
a96 1
  if (::getsockname (get_socket (), (struct sockaddr*) &sin, &sin_len))
a259 287
fhandler_socket::bind (const struct sockaddr *name, int namelen)
{
  int res = -1;

  if (name->sa_family == AF_LOCAL)
    {
#define un_addr ((struct sockaddr_un *) name)
      struct sockaddr_in sin;
      int len = sizeof sin; 
      int fd;

      if (strlen (un_addr->sun_path) >= UNIX_PATH_LEN)
	{
	  set_errno (ENAMETOOLONG);
	  goto out;
	}
      sin.sin_family = AF_INET;
      sin.sin_port = 0;
      sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      if (::bind (get_socket (), (sockaddr *) &sin, len))
	{
	  syscall_printf ("AF_LOCAL: bind failed %d", get_errno ());
	  set_winsock_errno ();
	  goto out;
	}
      if (::getsockname (get_socket (), (sockaddr *) &sin, &len))
	{
	  syscall_printf ("AF_LOCAL: getsockname failed %d", get_errno ());
	  set_winsock_errno ();
	  goto out;
	}

      sin.sin_port = ntohs (sin.sin_port);
      debug_printf ("AF_LOCAL: socket bound to port %u", sin.sin_port);

      /* bind must fail if file system socket object already exists
	 so _open () is called with O_EXCL flag. */
      fd = _open (un_addr->sun_path,
		  O_WRONLY | O_CREAT | O_EXCL | O_BINARY,
		  0);
      if (fd < 0)
	{
	  if (get_errno () == EEXIST)
	    set_errno (EADDRINUSE);
	  goto out;
	}

      set_connect_secret ();

      char buf[sizeof (SOCKET_COOKIE) + 80];
      __small_sprintf (buf, "%s%u ", SOCKET_COOKIE, sin.sin_port);
      get_connect_secret (strchr (buf, '\0'));
      len = strlen (buf) + 1;

      /* Note that the terminating nul is written.  */
      if (_write (fd, buf, len) != len)
	{
	  save_errno here;
	  _close (fd);
	  _unlink (un_addr->sun_path);
	}
      else
	{
	  _close (fd);
	  chmod (un_addr->sun_path,
	    (S_IFSOCK | S_IRWXU | S_IRWXG | S_IRWXO) & ~cygheap->umask);
	  set_sun_path (un_addr->sun_path);
	  res = 0;
	}
#undef un_addr
    }
  else if (::bind (get_socket (), name, namelen))
    set_winsock_errno ();
  else
    res = 0;

out:
  return res;
}

int
fhandler_socket::connect (const struct sockaddr *name, int namelen)
{
  int res = -1;
  BOOL secret_check_failed = FALSE;
  BOOL in_progress = FALSE;
  sockaddr_in sin;
  int secret [4];

  sigframe thisframe (mainthread);

  if (!get_inet_addr (name, namelen, &sin, &namelen, secret))
    return -1;

  res = ::connect (get_socket (), (sockaddr *) &sin, namelen);
  if (res)
    {
      /* Special handling for connect to return the correct error code
	 when called on a non-blocking socket. */
      if (is_nonblocking ())
	{
	  DWORD err = WSAGetLastError ();
	  if (err == WSAEWOULDBLOCK || err == WSAEALREADY)
	    {
	      WSASetLastError (WSAEINPROGRESS);
	      in_progress = TRUE;
	    }
	  else if (err == WSAEINVAL)
	    WSASetLastError (WSAEISCONN);
	}
      set_winsock_errno ();
    }
  if (get_addr_family () == AF_LOCAL && get_socket_type () == SOCK_STREAM)
    {
      if (!res || in_progress)
	{
	  if (!create_secret_event (secret))
	    {
	      secret_check_failed = TRUE;
	    }
	  else if (in_progress)
	    signal_secret_event ();
	}

      if (!secret_check_failed && !res)
	{
	  if (!check_peer_secret_event (&sin, secret))
	    {
	      debug_printf ( "accept from unauthorized server" );
	      secret_check_failed = TRUE;
	    }
       }

      if (secret_check_failed)
	{
	  close_secret_event ();
	  if (res)
	    closesocket (res);
	  set_errno (ECONNREFUSED);
	  res = -1;
	}
    }

  return res;
}

int
fhandler_socket::listen (int backlog)
{
  int res = ::listen (get_socket (), backlog);
  if (res)
    set_winsock_errno ();
  return res;
}

int
fhandler_socket::accept (struct sockaddr *peer, int *len)
{
  int res = -1;
  BOOL secret_check_failed = FALSE;
  BOOL in_progress = FALSE;

  sigframe thisframe (mainthread);

  /* Allows NULL peer and len parameters. */
  struct sockaddr_in peer_dummy;
  int len_dummy;
  if (!peer)
    peer = (struct sockaddr *) &peer_dummy;
  if (!len)
    {
      len_dummy = sizeof (struct sockaddr_in);
      len = &len_dummy;
    }

  /* accept on NT fails if len < sizeof (sockaddr_in)
   * some programs set len to
   * sizeof (name.sun_family) + strlen (name.sun_path) for UNIX domain
   */
  if (len && ((unsigned) *len < sizeof (struct sockaddr_in)))
    *len = sizeof (struct sockaddr_in);

  res = ::accept (get_socket (), peer, len);  // can't use a blocking call inside a lock

  if ((SOCKET) res == (SOCKET) INVALID_SOCKET &&
      WSAGetLastError () == WSAEWOULDBLOCK)
    in_progress = TRUE;

  if (get_addr_family () == AF_LOCAL && get_socket_type () == SOCK_STREAM)
    {
      if ((SOCKET) res != (SOCKET) INVALID_SOCKET || in_progress)
	{
	  if (!create_secret_event ())
	    secret_check_failed = TRUE;
	  else if (in_progress) 
	    signal_secret_event ();
	}

      if (!secret_check_failed &&
	  (SOCKET) res != (SOCKET) INVALID_SOCKET)
	{
	  if (!check_peer_secret_event ((struct sockaddr_in*) peer))
	    {
	      debug_printf ("connect from unauthorized client");
	      secret_check_failed = TRUE;
	    }
	}

      if (secret_check_failed)
	{
	  close_secret_event ();
	  if ((SOCKET) res != (SOCKET) INVALID_SOCKET)
	    closesocket (res);
	  set_errno (ECONNABORTED);
	  res = -1;
	  return res;
	}
    }

  cygheap_fdnew res_fd;
  if (res_fd < 0)
    /* FIXME: what is correct errno? */;
  else if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
    set_winsock_errno ();
  else
    {
      fhandler_socket* res_fh = fdsock (res_fd, get_name (), res);
      if (get_addr_family () == AF_LOCAL)
	res_fh->set_sun_path (get_sun_path ());
      res_fh->set_addr_family (get_addr_family ());
      res_fh->set_socket_type (get_socket_type ());
      res = res_fd;
    }

  return res;
}

int
fhandler_socket::getsockname (struct sockaddr *name, int *namelen)
{
  int res = -1;

  sigframe thisframe (mainthread);

  if (get_addr_family () == AF_LOCAL)
    {
      struct sockaddr_un *sun = (struct sockaddr_un *) name;
      memset (sun, 0, *namelen);
      sun->sun_family = AF_LOCAL;

      if (!get_sun_path ())
	sun->sun_path[0] = '\0';
      else
	/* According to SUSv2 "If the actual length of the address is
	   greater than the length of the supplied sockaddr structure, the
	   stored address will be truncated."  We play it save here so
	   that the path always has a trailing 0 even if it's truncated. */
	strncpy (sun->sun_path, get_sun_path (),
		 *namelen - sizeof *sun + sizeof sun->sun_path - 1);

      *namelen = sizeof *sun - sizeof sun->sun_path
		 + strlen (sun->sun_path) + 1;
      res = 0;
    }
  else
    {
      res = ::getsockname (get_socket (), name, namelen);
      if (res)
	set_winsock_errno ();
    }

  return res;
}

int
fhandler_socket::getpeername (struct sockaddr *name, int *namelen)
{
  sigframe thisframe (mainthread);

  int res = ::getpeername (get_socket (), name, namelen);
  if (res)
    set_winsock_errno ();

  return res;
}

int
a266 1

a301 82
fhandler_socket::recvfrom (void *ptr, size_t len, unsigned int flags,
			   struct sockaddr *from, int *fromlen)
{
  int res = -1;
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;

  sigframe thisframe (mainthread);

  if (is_nonblocking () || !(ovr = wsock_evt.prepare ()))
    {
      debug_printf ("Fallback to winsock 1 recvfrom call");
      if ((res = ::recvfrom (get_socket (), (char *) ptr, len, flags, from,
			     fromlen))
	  == SOCKET_ERROR)
	{
	  set_winsock_errno ();
	  res = -1;
	}
    }
  else
    {
      WSABUF wsabuf = { len, (char *) ptr };
      DWORD ret = 0;
      if (WSARecvFrom (get_socket (), &wsabuf, 1, &ret, (DWORD *)&flags,
		       from, fromlen, ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	{
	  set_winsock_errno ();
	  res = -1;
	}
      else if ((res = wsock_evt.wait (get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
    }

  return res;
}

int
fhandler_socket::recvmsg (struct msghdr *msg, int flags)
{
  int res = -1;
  int nb;
  size_t tot = 0;
  char *buf, *p;
  struct iovec *iov = msg->msg_iov;

  sigframe thisframe (mainthread);

  if (get_addr_family () == AF_LOCAL)
    {
      /* On AF_LOCAL sockets the (fixed-size) name of the shared memory
	 area used for descriptor passing is transmitted first.
	 If this string is empty, no descriptors are passed and we can
	 go ahead recv'ing the normal data blocks.  Otherwise start
	 special handling for descriptor passing. */
      /*TODO*/
    }
  for (int i = 0; i < msg->msg_iovlen; ++i)
    tot += iov[i].iov_len;
  buf = (char *) alloca (tot);
  if (tot != 0 && buf == NULL)
    {
      set_errno (ENOMEM);
      return -1;
    }
  nb = res = recvfrom (buf, tot, flags, (struct sockaddr *) msg->msg_name,
		       (int *) &msg->msg_namelen);
  p = buf;
  while (nb > 0)
    {
      ssize_t cnt = min(nb, iov->iov_len);
      memcpy (iov->iov_base, p, cnt);
      p += cnt;
      nb -= cnt;
      ++iov;
    }
  return res;
}

int
a308 1

d343 1
a343 100
int
fhandler_socket::sendto (const void *ptr, size_t len, unsigned int flags,
			 const struct sockaddr *to, int tolen)
{
  int res = -1;
  wsock_event wsock_evt;
  LPWSAOVERLAPPED ovr;
  sockaddr_in sin;

  sigframe thisframe (mainthread);

  if (!get_inet_addr (to, tolen, &sin, &tolen))
    return -1;

  if (is_nonblocking () || !(ovr = wsock_evt.prepare ()))
    {
      debug_printf ("Fallback to winsock 1 sendto call");
      if ((res = ::sendto (get_socket (), (const char *) ptr, len, flags,
			   (sockaddr *) &sin, tolen)) == SOCKET_ERROR)
	{
	  set_winsock_errno ();
	  res = -1;
	}
    }
  else
    {
      WSABUF wsabuf = { len, (char *) ptr };
      DWORD ret = 0;
      if (WSASendTo (get_socket (), &wsabuf, 1, &ret, (DWORD)flags,
		     (sockaddr *) &sin, tolen, ovr, NULL) != SOCKET_ERROR)
	res = ret;
      else if ((res = WSAGetLastError ()) != WSA_IO_PENDING)
	{
	  set_winsock_errno ();
	  res = -1;
	}
      else if ((res = wsock_evt.wait (get_socket (), (DWORD *)&flags)) == -1)
	set_winsock_errno ();
    }

  return res;
}

int
fhandler_socket::sendmsg (const struct msghdr *msg, int flags)
{
    size_t tot = 0;
    char *buf, *p;
    struct iovec *iov = msg->msg_iov;

    if (get_addr_family () == AF_LOCAL)
      {
        /* For AF_LOCAL/AF_UNIX sockets, if descriptors are given, start
           the special handling for descriptor passing.  Otherwise just
           transmit an empty string to tell the receiver that no
           descriptor passing is done. */
      /*TODO*/
      }
    for(int i = 0; i < msg->msg_iovlen; ++i)
        tot += iov[i].iov_len;
    buf = (char *) alloca (tot);
    if (tot != 0 && buf == NULL)
      {
        set_errno (ENOMEM);
        return -1;
      }
    p = buf;
    for (int i = 0; i < msg->msg_iovlen; ++i)
      {
        memcpy (p, iov[i].iov_base, iov[i].iov_len);
        p += iov[i].iov_len;
      }
    return sendto (buf, tot, flags, (struct sockaddr *) msg->msg_name,
		   msg->msg_namelen);
}

int
fhandler_socket::shutdown (int how)
{
  int res = ::shutdown (get_socket (), how);

  if (res)
    set_winsock_errno ();
  else
    switch (how)
      {
      case SHUT_RD:
	set_shutdown_read ();
	break;
      case SHUT_WR:
	set_shutdown_write ();
	break;
      case SHUT_RDWR:
	set_shutdown_read ();
	set_shutdown_write ();
	break;
      }
  return res;
}

a347 1

d384 1
a391 1

@


1.24.2.7
log
@Merged changes from HEAD
@
text
@a471 1
  WSAEVENT ev[2] = { WSA_INVALID_EVENT, signal_arrived };
d495 1
a495 52
  if (!is_nonblocking())
    {
      ev[0] = WSACreateEvent ();

      if (ev[0] != WSA_INVALID_EVENT &&
          !WSAEventSelect (get_socket (), ev[0], FD_ACCEPT))
        {
          WSANETWORKEVENTS sock_event;
          int wait_result;

          wait_result = WSAWaitForMultipleEvents (2, ev, FALSE, WSA_INFINITE,
	  					  FALSE);
          if (wait_result == WSA_WAIT_EVENT_0)
            WSAEnumNetworkEvents (get_socket (), ev[0], &sock_event);

          /* Unset events for listening socket and
             switch back to blocking mode */
          WSAEventSelect (get_socket (), ev[0], 0 );
          ioctlsocket (get_socket (), FIONBIO, 0);

          switch (wait_result)
            {
            case WSA_WAIT_EVENT_0:
              if (sock_event.lNetworkEvents & FD_ACCEPT)
                {
                  if (sock_event.iErrorCode[FD_ACCEPT_BIT])
                    {
                      WSASetLastError (sock_event.iErrorCode[FD_ACCEPT_BIT]);
                      set_winsock_errno ();
                      res = -1;
                      goto done;
                    }
                }
              /* else; : Should never happen since FD_ACCEPT is the only event
                 that has been selected */
              break;
            case WSA_WAIT_EVENT_0 + 1:
              debug_printf ("signal received during accept");
              set_errno (EINTR);
              res = -1;
              goto done;
            case WSA_WAIT_FAILED:
            default: /* Should never happen */
              WSASetLastError (WSAEFAULT);
              set_winsock_errno ();
              res = -1;
              goto done;
            }
        }
    }

  res = ::accept (get_socket (), peer, len);
d528 1
a528 1
	  goto done;
d532 14
a545 20
  {
    cygheap_fdnew res_fd;
    if (res_fd < 0)
      /* FIXME: what is correct errno? */;
    else if ((SOCKET) res == (SOCKET) INVALID_SOCKET)
      set_winsock_errno ();
    else
      {
        fhandler_socket* res_fh = fdsock (res_fd, get_name (), res);
        if (get_addr_family () == AF_LOCAL)
          res_fh->set_sun_path (get_sun_path ());
        res_fh->set_addr_family (get_addr_family ());
        res_fh->set_socket_type (get_socket_type ());
        res = res_fd;
      }
  }

done:
  if (ev[0] != WSA_INVALID_EVENT)
    WSACloseEvent (ev[0]);
@


1.24.2.8
log
@Merged changes from HEAD
@
text
@a288 2
  if (get_addr_family () == AF_LOCAL)
    fhs->set_sun_path (get_sun_path ());
d1142 3
a1144 1
  sun_path = path ? cstrdup (path) : NULL;
@


1.24.2.9
log
@Merged changes from HEAD
@
text
@a457 4
  if (WSAGetLastError () == WSAEINPROGRESS)
    set_connect_state (CONNECT_PENDING);
  else
    set_connect_state (CONNECTED);
a466 2
  else
    set_connect_state (CONNECTED);
@


1.24.2.10
log
@Merged changes from HEAD
@
text
@d158 1
a158 2
  LPSECURITY_ATTRIBUTES sec = get_inheritance (true);
  secret_event = CreateEvent (sec, FALSE, FALSE, buf);
d162 1
a162 3
  if (!secret_event)
    /* nothing to do */;
  else if (sec == &sec_all_nih || sec == &sec_none_nih)
a163 2
  else
    ProtectHandleINH (secret_event);
@


1.24.2.11
log
@Merged changes from HEAD
@
text
@d526 2
a527 3
          WSAEventSelect (get_socket (), ev[0], 0);
	  unsigned long nonblocking = 0;
          ioctlsocket (get_socket (), FIONBIO, &nonblocking);
@


1.24.2.12
log
@Merged changes from HEAD
@
text
@d671 37
d711 1
a711 1
  return recvfrom (ptr, len, 0, NULL, NULL);
d797 37
d836 1
a836 1
  return sendto (ptr, len, 0, NULL, 0);
d850 1
a850 1
  if (to && !get_inet_addr (to, tolen, &sin, &tolen))
d857 1
a857 2
			   (to ? (sockaddr *) &sin : NULL),
			   tolen)) == SOCKET_ERROR)
d868 1
a868 3
		     (to ? (sockaddr *) &sin : NULL),
		     tolen,
		     ovr, NULL) != SOCKET_ERROR)
a917 2
  sigframe thisframe (mainthread);

@


1.24.2.13
log
@Merged changes from HEAD
@
text
@d678 1
a678 1
fhandler_socket::recvfrom (void *ptr, size_t len, int flags,
d766 1
a766 1
fhandler_socket::sendto (const void *ptr, size_t len, int flags,
@


1.24.2.14
log
@Merged changes from HEAD
@
text
@d206 1
a206 1
      debug_printf ("event \"%s\" already exists", buf);
d409 2
d489 2
d627 2
d662 2
d685 2
d726 2
d774 2
d847 2
d875 2
d918 2
@


1.24.2.15
log
@Merged changes from HEAD
@
text
@a676 1
  flags &= MSG_WINMASK;
d768 1
a768 2
      if ((res = ::sendto (get_socket (), (const char *) ptr, len,
			   flags & MSG_WINMASK,
d780 1
a780 2
      if (WSASendTo (get_socket (), &wsabuf, 1, &ret,
		     (DWORD)(flags & MSG_WINMASK),
a793 7
  /* Special handling for SIGPIPE */
  if (get_errno () == ESHUTDOWN)
    {
      set_errno (EPIPE);
      if (! (flags & MSG_NOSIGNAL))
        _raise (SIGPIPE);
    }
@


1.24.2.16
log
@Merged changes from HEAD
@
text
@d739 1
a739 3
      ssize_t cnt = iov->iov_len;
      if (nb < cnt)
	cnt = nb;
@


1.24.2.17
log
@Merged changes from HEAD
@
text
@d663 2
a664 3
int
fhandler_socket::readv (const struct iovec *const iov, const int iovcnt,
			ssize_t tot)
d666 1
a666 11
  struct msghdr msg =
    {
      msg_name:		NULL,
      msg_namelen:	0,
      msg_iov:		(struct iovec *) iov, // const_cast
      msg_iovlen:	iovcnt,
      msg_accrights:	NULL,
      msg_accrightslen:	0
    };

  return recvmsg (&msg, 0, tot);
d673 3
a675 2
  int res;
  DWORD ret;
d678 11
a688 4
  if (!winsock2_active)
    ret = res = ::recvfrom (get_socket (),
			    (char *) ptr, len, flags,
			    from, fromlen);
d692 5
a696 6

      if (is_nonblocking ())
	res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret, (DWORD *) &flags,
			   from, fromlen,
			   NULL, NULL);
      else
d698 2
a699 7
	  wsock_event wsock_evt;
	  res = WSARecvFrom (get_socket (), &wsabuf, 1, &ret, (DWORD *) &flags,
			     from, fromlen,
			     wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
d701 2
a704 8
  if (res == SOCKET_ERROR)
    {
      res = -1;
      set_winsock_errno ();
    }
  else
    res = ret;

d709 1
a709 1
fhandler_socket::recvmsg (struct msghdr *msg, int flags, ssize_t tot)
d711 6
d726 20
a745 98

  struct iovec *const iov = msg->msg_iov;
  const int iovcnt = msg->msg_iovlen;

  int res;

  if (!winsock2_active)
    {
      if (iovcnt == 1)
	res = recvfrom (iov->iov_base, iov->iov_len, flags,
			(struct sockaddr *) msg->msg_name,
			&msg->msg_namelen);
      else
	{
	  if (tot == -1)	// i.e. if not pre-calculated by the caller.
	    {
	      tot = 0;
	      const struct iovec *iovptr = iov + iovcnt;
	      do 
		{
		  iovptr -= 1;
		  tot += iovptr->iov_len;
		}
	      while (iovptr != iov);
	    }

	  char *buf = (char *) alloca (tot);

	  if (!buf)
	    {
	      set_errno (ENOMEM);
	      res = -1;
	    }
	  else
	    {
	      res = recvfrom (buf, tot, flags,
			      (struct sockaddr *) msg->msg_name,
			      &msg->msg_namelen);

	      const struct iovec *iovptr = iov;
	      int nbytes = res;

	      while (nbytes > 0)
		{
		  const int frag = min (nbytes, (ssize_t) iovptr->iov_len);
		  memcpy (iovptr->iov_base, buf, frag);
		  buf += frag;
		  iovptr += 1;
		  nbytes -= frag;
		}
	    }
	}
    }
  else
    {
      WSABUF wsabuf[iovcnt];

      {
	const struct iovec *iovptr = iov + iovcnt;
	WSABUF *wsaptr = wsabuf + iovcnt;
	do
	  {
	    iovptr -= 1;
	    wsaptr -= 1;
	    wsaptr->len = iovptr->iov_len;
	    wsaptr->buf = (char *) iovptr->iov_base;
	  }
	while (wsaptr != wsabuf);
      }

      DWORD ret;

      if (is_nonblocking ())
	res = WSARecvFrom (get_socket (),
			   wsabuf, iovcnt, &ret, (DWORD *) &flags,
			   (struct sockaddr *) msg->msg_name,
			   &msg->msg_namelen,
			   NULL, NULL);
      else
	{
	  wsock_event wsock_evt;
	  res = WSARecvFrom (get_socket (),
			     wsabuf, iovcnt, &ret, (DWORD *) &flags,
			     (struct sockaddr *) msg->msg_name,
			     &msg->msg_namelen,
			     wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
	}

      if (res == SOCKET_ERROR)
	{
	  res = -1;
	  set_winsock_errno ();
	}
      else
	res = ret;
a746 1

d751 1
a751 2
fhandler_socket::writev (const struct iovec *const iov, const int iovcnt,
			 ssize_t tot)
d753 1
a753 11
  struct msghdr msg =
    {
      msg_name:		NULL,
      msg_namelen:	0,
      msg_iov:		(struct iovec *) iov, // const_cast
      msg_iovlen:	iovcnt,
      msg_accrights:	NULL,
      msg_accrightslen:	0
    };

  return sendmsg (&msg, 0, tot);
d760 3
d768 12
a779 7
  int res;
  DWORD ret;

  if (!winsock2_active)
    res = ::sendto (get_socket (), (const char *) ptr, len,
		    flags & MSG_WINMASK,
		    (to ? (const struct sockaddr *) &sin : NULL), tolen);
d783 8
a790 7

      if (is_nonblocking ())
	res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
			 flags & MSG_WINMASK,
			 (to ? (const struct sockaddr *) &sin : NULL), tolen,
			 NULL, NULL);
      else
d792 2
a793 8
	  wsock_event wsock_evt;
	  res = WSASendTo (get_socket (), &wsabuf, 1, &ret,
			   flags & MSG_WINMASK,
			   (to ? (const struct sockaddr *) &sin : NULL), tolen,
			   wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
d795 2
a798 8
  if (res == SOCKET_ERROR)
    {
      res = -1;
      set_winsock_errno ();
    }
  else
    res = ret;

d800 1
a800 1
  if (res == -1 && get_errno () == ESHUTDOWN)
a805 1

d810 1
a810 1
fhandler_socket::sendmsg (const struct msghdr *msg, int flags, ssize_t tot)
d812 10
a821 6
  if (get_addr_family () == AF_LOCAL)
    {
      /* For AF_LOCAL/AF_UNIX sockets, if descriptors are given, start
	 the special handling for descriptor passing.  Otherwise just
	 transmit an empty string to tell the receiver that no
	 descriptor passing is done. */
d823 11
a833 59
    }

  struct iovec *const iov = msg->msg_iov;
  const int iovcnt = msg->msg_iovlen;

  int res;

  if (!winsock2_active)
    {
      if (iovcnt == 1)
	res = sendto (iov->iov_base, iov->iov_len, flags,
		      (struct sockaddr *) msg->msg_name,
		      msg->msg_namelen);
      else
	{
	  if (tot == -1)	// i.e. if not pre-calculated by the caller.
	    {
	      tot = 0;
	      const struct iovec *iovptr = iov + iovcnt;
	      do 
		{
		  iovptr -= 1;
		  tot += iovptr->iov_len;
		}
	      while (iovptr != iov);
	    }

	  char *const buf = (char *) alloca (tot);

	  if (!buf)
	    {
	      set_errno (ENOMEM);
	      res = -1;
	    }
	  else
	    {
	      char *bufptr = buf;
	      const struct iovec *iovptr = iov;
	      int nbytes = tot;

	      while (nbytes != 0)
		{
		  const int frag = min (nbytes, (ssize_t) iovptr->iov_len);
		  memcpy (bufptr, iovptr->iov_base, frag);
		  bufptr += frag;
		  iovptr += 1;
		  nbytes -= frag;
		}

	      res = sendto (buf, tot, flags,
			    (struct sockaddr *) msg->msg_name,
			    msg->msg_namelen);
	    }
	}
    }
  else
    {
      WSABUF wsabuf[iovcnt];

d835 2
a836 10
	const struct iovec *iovptr = iov + iovcnt;
	WSABUF *wsaptr = wsabuf + iovcnt;
	do
	  {
	    iovptr -= 1;
	    wsaptr -= 1;
	    wsaptr->len = iovptr->iov_len;
	    wsaptr->buf = (char *) iovptr->iov_base;
	  }
	while (wsaptr != wsabuf);
d838 2
a839 30

      DWORD ret;

      if (is_nonblocking ())
	res = WSASendTo (get_socket (), wsabuf, iovcnt, &ret, flags,
			 (struct sockaddr *) msg->msg_name,
			 msg->msg_namelen,
			 NULL, NULL);
      else
	{
	  wsock_event wsock_evt;
	  res = WSASendTo (get_socket (), wsabuf, iovcnt, &ret, flags,
			   (struct sockaddr *) msg->msg_name,
			   msg->msg_namelen,
			   wsock_evt.prepare (), NULL);

	  if (res == SOCKET_ERROR && WSAGetLastError () == WSA_IO_PENDING)
	    ret = res = wsock_evt.wait (get_socket (), (DWORD *) &flags);
	}

      if (res == SOCKET_ERROR)
	{
	  res = -1;
	  set_winsock_errno ();
	}
      else
	res = ret;
    }

  return res;
@


1.24.2.18
log
@Merged changes from HEAD
@
text
@d328 1
a328 1
      int len = sizeof sin;
d516 7
a522 7
						  FALSE);
	  if (wait_result == WSA_WAIT_EVENT_0)
	    WSAEnumNetworkEvents (get_socket (), ev[0], &sock_event);

	  /* Unset events for listening socket and
	     switch back to blocking mode */
	  WSAEventSelect (get_socket (), ev[0], 0);
d524 1
a524 1
	  ioctlsocket (get_socket (), FIONBIO, &nonblocking);
d526 29
a554 29
	  switch (wait_result)
	    {
	    case WSA_WAIT_EVENT_0:
	      if (sock_event.lNetworkEvents & FD_ACCEPT)
		{
		  if (sock_event.iErrorCode[FD_ACCEPT_BIT])
		    {
		      WSASetLastError (sock_event.iErrorCode[FD_ACCEPT_BIT]);
		      set_winsock_errno ();
		      res = -1;
		      goto done;
		    }
		}
	      /* else; : Should never happen since FD_ACCEPT is the only event
		 that has been selected */
	      break;
	    case WSA_WAIT_EVENT_0 + 1:
	      debug_printf ("signal received during accept");
	      set_errno (EINTR);
	      res = -1;
	      goto done;
	    case WSA_WAIT_FAILED:
	    default: /* Should never happen */
	      WSASetLastError (WSAEFAULT);
	      set_winsock_errno ();
	      res = -1;
	      goto done;
	    }
	}
d569 1
a569 1
	  else if (in_progress)
d602 6
a607 6
	fhandler_socket* res_fh = fdsock (res_fd, get_name (), res);
	if (get_addr_family () == AF_LOCAL)
	  res_fh->set_sun_path (get_sun_path ());
	res_fh->set_addr_family (get_addr_family ());
	res_fh->set_socket_type (get_socket_type ());
	res = res_fd;
d753 1
a753 1
	      do
d906 1
a906 1
	_raise (SIGPIPE);
d941 1
a941 1
	      do
@


1.24.2.19
log
@Merged changes from HEAD
@
text
@d505 1
a505 1
  if (!is_nonblocking ())
@


1.23
log
@        * fhandler.h (fhandler_socket::fixup_after_exec): Remove inline
        implementation.
        (fhandler_dev_raw::fixup_after_exec): Ditto.
        * fhandler_raw.cc (fhandler_dev_raw::fixup_after_fork): Don't
        duplicate buffer on fork to avoid memory leak.
        (fhandler_dev_raw::fixup_after_exec): New implementation equal to
        former fixup_after_fork() implementation.
        * fhandler_socket.cc (fhandler_socket::fixup_after_fork): Do
        nothing when not using Winsock2.
        (fhandler_socket::fixup_after_exec): New implementation.
        (fhandler_socket::set_close_on_exec): Never call set_inheritance().
@
text
@d217 1
d220 1
a220 1
  else
@


1.22
log
@        * fhandler_socket.cc (fhandler_socket::fhandler_socket): Revert
        memory allocation to use cmalloc again.
@
text
@d205 1
d207 1
d214 9
d461 1
d465 1
@


1.21
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d48 1
a48 1
  prot_info_ptr = (LPWSAPROTOCOL_INFOA) ccalloc (HEAP_BUF, 1,
@


1.20
log
@* fhandler_socket.cc (fhandler_socket::fhandler_socket): Ensure that
prot_info_ptr is zeroed for later use.
@
text
@d49 1
a49 1
					         sizeof (WSAPROTOCOL_INFOA));
d137 2
a138 2
                  secret_ptr [0], secret_ptr [1],
                  secret_ptr [2], secret_ptr [3]);
d191 3
a193 3
                              FROM_PROTOCOL_INFO,
                              FROM_PROTOCOL_INFO,
                              prot_info_ptr, 0, 0)) == INVALID_SOCKET)
d315 2
a316 2
          == INADDR_LOOPBACK)
        ifr->ifr_flags |= IFF_LOOPBACK;
d318 1
a318 1
        ifr->ifr_flags |= IFF_BROADCAST;
d427 1
a427 1
        /* Carefully test for the O_NONBLOCK or deprecated OLD_O_NDELAY flag.
d433 1
a433 1
        current = get_flags () & O_NONBLOCK_MASK;
d435 2
a436 2
        if (!!current != !!new_flags && (res = ioctl (FIONBIO, &request)))
          break;
d438 1
a438 1
        break;
@


1.19
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d48 1
a48 1
  prot_info_ptr = (LPWSAPROTOCOL_INFOA) cmalloc (HEAP_BUF,
@


1.18
log
@        * fhandler_socket.cc (fhandler_socket::close): Change 2MSL value
        according to MSDN.
@
text
@d38 1
a38 1
fhandler_dev_random* entropy_source = NULL;
@


1.17
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Relax
security of secret_event so AF_UNIX socket clients can connect to
servers even if running under a different user account.
(fhandler_socket::check_peer_secret_event): Ditto.
@
text
@d265 1
a265 1
  linger.l_linger = 60; /* seconds. 2MSL according to BSD implementation. */
@


1.16
log
@        * fhandler.cc (fhandler_base::is_nonblocking): New method.
        (fhandler_base::set_nonblocking): Ditto.
        * fhandler.h (fhandler_base): Declare new methods `is_nonblocking' and
        `set_nonblocking'.
        * fhandler_socket.cc (fhandler_socket::ioctl): Use `set_nonblocking'.
        * fhandler_tty.cc (fhandler_pty_master::process_slave_output):
        Use `is_nonblocking'.
        (fhandler_tty_slave::read): Ditto.
        (fhandler_tty_slave::ioctl): Use `set_nonblocking'.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (cygwin_sendto): Fallback to winsock 1 functionality
        in case of nonblocking IO.
        (cygwin_recvfrom): Ditto.
        (cygwin_recv): Ditto.
        (cygwin_send): Ditto.
        * syscalls.cc (_read): Use `is_nonblocking'.
@
text
@d104 1
a104 1
  secret_event = CreateEvent (get_inheritance (), FALSE, FALSE, buf);
d139 1
a139 1
  ev = CreateEvent (&sec_none_nih, FALSE, FALSE, buf);
@


1.15
log
@        * fhandler.cc (fhandler_base::fcntl): Use new O_NONBLOCK_MASK define.
        * fhandler.h: Move definitions of O_NOSYMLINK, O_DIROPEN and
        OLD_O_NDELAY from winsup.h to here. Add O_NONBLOCK_MASK define.
        * fhandler_socket.cc (fhandler_socket::close): Add hack to allow
        a graceful shutdown even if shutdown() hasn't been called by the
        application. Add debug output.
        (fhandler_socket::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_socket::fcntl): Use new O_NONBLOCK_MASK define. Actually
        set `request' before using it.
        * fhandler_tty.cc: Use new O_NONBLOCK_MASK define throughout.
        (fhandler_tty_slave::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (wsock_event::prepare): Compare WSACreateEvent return code
        with `WSA_INVALID_EVENT' according to MSDN.
        * syscalls.cc (_read): Use new O_NONBLOCK_MASK define.
@
text
@d409 1
a409 3
	  int current = get_flags () & O_NONBLOCK_MASK;
	  int new_flags = *(int *) p ? (!current ? O_NONBLOCK : current) : 0;
	  set_flags ((get_flags () & ~O_NONBLOCK_MASK) | new_flags);
@


1.14
log
@* cygheap.cc (cygheap_root::set): Avoid treating '/' specially.
* fhandler.cc (fhandler_base::fcntl): Only set specific O_NDELAY style flag
passed in from application.
* fhandler_socket.cc (fhandler_socket::fcntl): Ditto.
* fhandler.h: Set constant for future use.
* winsup.h: Define OLD_O_NDELAY only for old programs.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_OLD_O_NONBLOCK.
@
text
@d260 9
d277 1
d408 4
a428 4
        /* Care for the old O_NDELAY flag. If one of the flags is set,
           both flags are set. */
        const int allowed_flags = O_NONBLOCK | OLD_O_NDELAY;

d432 1
a432 1
	int new_flags = (int) arg & allowed_flags;
d435 2
a436 1
        current = get_flags () & allowed_flags;
d439 1
a439 1
	set_flags ((get_flags () & ~allowed_flags) | new_flags);
@


1.13
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d27 2
d417 10
a426 6
        int new_flags = (int) arg;
        if (new_flags & (O_NONBLOCK | OLD_O_NDELAY))
          new_flags |= O_NONBLOCK | OLD_O_NDELAY;
        request = (new_flags & O_NONBLOCK) ? 1 : 0;
        current = (get_flags () & O_NONBLOCK) ? 1 : 0;
        if (request != current && (res = ioctl (FIONBIO, &request)))
d428 1
a428 4
        if (request)
          set_flags (get_flags () | O_NONBLOCK | OLD_O_NDELAY);
        else
          set_flags (get_flags () & ~(O_NONBLOCK | OLD_O_NDELAY));
@


1.12
log
@forced commit
@
text
@d26 1
d102 1
a102 1
  secret_event = CreateEvent ( NULL, FALSE, FALSE, buf);
d137 1
a137 1
  ev = CreateEvent (NULL, FALSE, FALSE, buf);
@


1.11
log
@        * fhandler.h class fhandler_socket): Declare new method
        `set_close_on_exec'.
        * fhandler_socket.cc (fhandler_socket::set_close_on_exec):
        New method.
@
text
@@


1.10
log
@* fhandler_socket.cc (fhandler_socket::signal_secret_event): New
function.
* fhandler.h: Declare it.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Don't
signal secret event immediately.
(fhandler_socket::check_peer_secret_event): Do it after peer event
was opened.
* net.cc (cygwin_connect): Or if socket is non-blocking.
(cygwin_accept): Ditto.
@
text
@d434 9
@


1.9
log
@        * fhandler_socket.cc (fhandler_socket::ioctl): Convert s_addr
        field to host byte order before comparing with INADDR_LOOPBACK.
@
text
@d106 1
a106 4
    {
      ProtectHandle (secret_event);
      SetEvent (secret_event);
    }
d112 7
d142 2
@


1.8
log
@* fhandler_socket.cc (set_connect_secret): Use /dev/urandom to
generate secret cookie.
@
text
@d18 1
d295 1
a295 1
      if (((struct sockaddr_in *) &ifr->ifr_addr)->sin_addr.s_addr
@


1.7
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d31 4
d57 16
a72 2
  for (int i = 0; i < 4; i++)
    connect_secret [i] = random ();
@


1.6
log
@* fhandler.h (class fhandler_socket): Add members and methods to
support secure connections on AF_UNIX sockets.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): New method.
(fhandler_socket::get_connect_secret): Ditto.
(fhandler_socket::create_secret_event): Ditto.
(fhandler_socket::close_secret_event): Ditto.
(fhandler_socket::check_peer_secret_event): Ditto.
(fhandler_socket::fixup_after_fork): Duplicate secret event to child.
(fhandler_socket::dup): Copy address family.
(fhandler_socket::close): Close secret event.
* net.cc (get_inet_addr): Read secret cookie.
(cygwin_connect): Check if peer knows secret cookie value.
(cygwin_accept): Ditto. Copy address family to newly created socket.
(cygwin_bind): Generate and write secret cookie.
(wsock_init): Initialize random number generator.
@
text
@a23 1
#include "cygheap.h"
d27 1
@


1.5
log
@* dtable.cc: Guard against new winsock.h/winsock2.h warnings when mixing
winsock*.h and sys/types.h.
* fhandler_socket.cc: Ditto.
* net.cc: Ditto.
* select.cc: Ditto.
* exceptions.cc: Remove unneeded define.
@
text
@d19 1
d30 2
d51 81
d180 2
d188 1
d237 2
@


1.4
log
@Update copyrights.
@
text
@a14 1
#define Win32_Winsock
d21 1
@


1.3
log
@        * autoload.cc: Add LoadDLLinitfunc for iphlpapi.dll.
        Add LoadDLLfuncEx statements for GetIfTable@@12 and GetIpAddrTable@@12.
        * fhandler_socket.cc (fhandler_socket::ioctl): Move variable
        definitions to the beginning of the function to allow better debugging.
        Add handling for SIOCGIFHWADDR, SIOCGIFMETRIC and SIOCGIFMTU.
        * net.cc: Include iphlpapi.h.
        (get_2k_ifconf): Rewritten. Uses IP Helper API now.
        (get_nt_ifconf): Add handling for SIOCGIFHWADDR, SIOCGIFMETRIC
        and SIOCGIFMTU.
        (get_95_ifconf): Ditto. Renamed from `get_9x_ifconf'.
        (get_ifconf): Name loopback `lo' instead of `lo0' as in Linux.
        Add handling for SIOCGIFHWADDR, SIOCGIFMETRIC and SIOCGIFMTU.
        Call `get_95_ifconf' only on Windows 95, `get_nt_ifconf' only
        on Windows NT < Service Pack 3, `get_2k_ifconf otherwise.
        * include/asm/socket.h: Add defines for SIOCGIFHWADDR, SIOCGIFMETRIC
        and SIOCGIFMTU.
        * include/cygwin/if.h: Add `ifr_hwaddr', `ifr_metric' and `ifr_mtu'.
        (struct ifreq): Add `ifru_hwaddr'.
@
text
@d3 1
a3 1
   Copyright 2000 Cygnus Solutions.
@


1.2
log
@Whitespace cleanup.

* configure.in: Eliminate subdir stuff.
* configure: Regenerate.
* include/getopt.h (option): Make name field 'const'.
@
text
@d162 2
a163 2
  struct ifconf *ifc;
  struct ifreq *ifr;
d169 2
a170 2
      ifc = (struct ifconf *) p;
      if (ifc == 0)
d175 1
a175 1
      res = get_ifconf (ifc, cmd);
d197 3
d201 2
a202 5
	char buf[2048];
	struct ifconf ifc;
	ifc.ifc_len = sizeof (buf);
	ifc.ifc_buf = buf;
	struct ifreq *ifrp;
d204 1
a204 1
	struct ifreq *ifr = (struct ifreq *) p;
d237 9
@


1.1
log
@        * fhandler_socket.cc: New file.
        * Makefile.in: Add fhandler_socket.o to dependencies.
        * fhandler.h: Change comment.
        * net.cc Move all fhandler_socket methods to fhandler_socket.cc.
        * winsup.h: Add declaration for `ws2_32_handle'.
@
text
@d38 1
a38 1
  					         sizeof (WSAPROTOCOL_INFOA));
@

