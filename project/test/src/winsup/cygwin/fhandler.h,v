head	1.514;
access;
symbols
	cygwin-1_7_35-release:1.513
	cygwin-1_7_34-release:1.511
	cygwin-1_7_33-release:1.495.2.9
	cygwin-1_7_32-release:1.495.2.8
	cygwin-1_7_31-release:1.495.2.8
	cygwin-1_7_30-release:1.495.2.8
	cygwin-1_7_29-release:1.495.2.7
	cygwin-1_7_29-release-branchpoint:1.495.0.2
	cygwin-pre-user-db:1.495
	cygwin-1_7_28-release:1.495
	cygwin-1_7_27-release:1.491
	cygwin-1_7_26-release:1.491
	cygwin-1_7_25-release:1.482
	cygwin-1_7_24-release:1.482
	cygwin-1_7_23-release:1.482
	cygwin-1_7_22-release:1.482
	cygwin-1_7_21-release:1.481
	cygwin-1_7_20-release:1.481
	cygwin-1_7_19-release:1.481
	cygwin-64bit-postmerge:1.478
	cygwin-64bit-premerge-branch:1.477.0.2
	cygwin-64bit-premerge:1.477
	cygwin-1_7_18-release:1.477
	post-ptmalloc3:1.473.2.11
	pre-ptmalloc3:1.473.2.11
	cygwin-1_7_17-release:1.475
	cygwin-64bit-branch:1.473.0.2
	cygwin-1_7_16-release:1.472
	cygwin-1_7_15-release:1.468
	cygwin-1_7_14_2-release:1.467
	cygwin-1_7_14-release:1.466
	cygwin-1_7_12-release:1.461
	cygwin-1_7_11-release:1.453
	cygwin-1_7_10-release:1.452
	signal-rewrite:1.435.0.2
	pre-notty:1.428
	cygwin-1_7_9-release:1.413
	cv-post-1_7_9:1.411.0.2
	cygwin-1_7_8-release:1.410
	cygwin-1_7_7-release:1.403
	cygwin-1_7_5-release:1.399
	cygwin-1_7_4-release:1.398
	cygwin-1_7_3-release:1.398
	cygwin-1_7_2-release:1.393
	fifo_doover3:1.388.0.2
	cygwin-1_7_1-release:1.384
	prefifo:1.374
	cv-branch-2:1.364.0.2
	pre-ripout-set_console_state_for_spawn:1.346
	EOL_registry_mounts:1.339
	preoverlapped:1.315
	drop_9x_support_start:1.308
	cr-0x5f1:1.298.0.2
	cv-branch:1.297.0.2
	pre-ptymaster-archetype:1.290
	cr-0x3b58:1.282.0.4
	cr-0x5ef:1.282.0.2
	after-mmap-privanon-noreserve:1.275
	after-mmap-revamp:1.274
	before-mmap-revamp:1.273
	cgf-more-exit-sync:1.269
	post_wait_sig_exit:1.265
	pre_wait_sig_exit:1.264
	reparent-point:1.211
	noreparent:1.211.0.2
	cr-0x5e6:1.208.0.2
	cr-0x9e:1.182.0.6
	cr-0x9d:1.182.0.4
	cgf-deleteme:1.182.0.2
	pre-sigrewrite:1.172
	corinna-01:1.171
	cr-0x9c:1.166.0.6
	cr-0x9b:1.166.0.4
	cr-0x99:1.166
	Z-emcb-cygwin_daemon:1.166.0.2
	w32api-2_2:1.154
	mingw-runtime-2_4:1.154
	pre-cgf-merge:1.166
	cgf-dev-branch:1.154.0.2
	predaemon:1.109
	cygwin_daemon_merge_HEAD:1.109
	pregp02r1:1.108.0.2
	cygnus_cvs_20020108_pre:1.105
	Z-cygwin_daemon_merge-new_HEAD:1.140
	Z-cygwin_daemon_merge_HEAD:1.140
	cygwin_daemon:1.83.0.2;
locks; strict;
comment	@ * @;
expand	@o@;


1.514
date	2015.03.05.12.57.33;	author corinna;	state Exp;
branches;
next	1.513;

1.513
date	2015.02.24.11.05.02;	author corinna;	state Exp;
branches;
next	1.512;

1.512
date	2015.02.15.08.59.54;	author corinna;	state Exp;
branches;
next	1.511;

1.511
date	2015.01.22.13.46.11;	author corinna;	state Exp;
branches;
next	1.510;

1.510
date	2014.11.13.18.37.15;	author corinna;	state Exp;
branches;
next	1.509;

1.509
date	2014.10.26.18.47.23;	author corinna;	state Exp;
branches;
next	1.508;

1.508
date	2014.10.11.18.28.04;	author corinna;	state Exp;
branches;
next	1.507;

1.507
date	2014.08.27.11.42.17;	author corinna;	state Exp;
branches;
next	1.506;

1.506
date	2014.08.19.09.47.12;	author corinna;	state Exp;
branches;
next	1.505;

1.505
date	2014.08.19.08.31.10;	author corinna;	state Exp;
branches;
next	1.504;

1.504
date	2014.08.18.11.09.56;	author corinna;	state Exp;
branches;
next	1.503;

1.503
date	2014.04.26.17.38.22;	author cgf;	state Exp;
branches;
next	1.502;

1.502
date	2014.03.19.20.43.15;	author cgf;	state Exp;
branches;
next	1.501;

1.501
date	2014.03.17.04.41.35;	author cgf;	state Exp;
branches;
next	1.500;

1.500
date	2014.03.10.18.18.56;	author cgf;	state Exp;
branches;
next	1.499;

1.499
date	2014.03.09.22.49.56;	author cgf;	state Exp;
branches;
next	1.498;

1.498
date	2014.02.26.03.58.37;	author cgf;	state Exp;
branches;
next	1.497;

1.497
date	2014.02.23.03.38.52;	author cgf;	state Exp;
branches;
next	1.496;

1.496
date	2014.02.16.01.48.24;	author cgf;	state Exp;
branches;
next	1.495;

1.495
date	2014.01.31.04.23.22;	author cgf;	state Exp;
branches
	1.495.2.1;
next	1.494;

1.494
date	2014.01.04.23.58.32;	author cgf;	state Exp;
branches;
next	1.493;

1.493
date	2013.12.17.19.05.26;	author cgf;	state Exp;
branches;
next	1.492;

1.492
date	2013.12.10.21.05.23;	author corinna;	state Exp;
branches;
next	1.491;

1.491
date	2013.10.31.14.26.42;	author corinna;	state Exp;
branches;
next	1.490;

1.490
date	2013.10.30.09.44.47;	author corinna;	state Exp;
branches;
next	1.489;

1.489
date	2013.10.25.16.16.50;	author corinna;	state Exp;
branches;
next	1.488;

1.488
date	2013.10.25.12.21.59;	author corinna;	state Exp;
branches;
next	1.487;

1.487
date	2013.10.24.17.51.41;	author corinna;	state Exp;
branches;
next	1.486;

1.486
date	2013.10.24.15.26.21;	author cgf;	state Exp;
branches;
next	1.485;

1.485
date	2013.10.24.09.41.16;	author corinna;	state Exp;
branches;
next	1.484;

1.484
date	2013.10.22.20.41.09;	author cgf;	state Exp;
branches;
next	1.483;

1.483
date	2013.10.15.14.00.37;	author corinna;	state Exp;
branches;
next	1.482;

1.482
date	2013.07.15.13.54.27;	author corinna;	state Exp;
branches;
next	1.481;

1.481
date	2013.06.04.10.24.42;	author corinna;	state Exp;
branches;
next	1.480;

1.480
date	2013.06.02.10.22.14;	author corinna;	state Exp;
branches;
next	1.479;

1.479
date	2013.05.21.18.51.36;	author corinna;	state Exp;
branches;
next	1.478;

1.478
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.477;

1.477
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.476;

1.476
date	2013.01.11.11.04.50;	author corinna;	state Exp;
branches;
next	1.475;

1.475
date	2012.10.13.12.34.17;	author corinna;	state Exp;
branches;
next	1.474;

1.474
date	2012.08.16.23.34.43;	author cgf;	state Exp;
branches;
next	1.473;

1.473
date	2012.08.01.09.00.52;	author corinna;	state Exp;
branches
	1.473.2.1;
next	1.472;

1.472
date	2012.07.02.20.17.27;	author corinna;	state Exp;
branches;
next	1.471;

1.471
date	2012.06.03.18.02.45;	author cgf;	state Exp;
branches;
next	1.470;

1.470
date	2012.05.23.13.13.56;	author corinna;	state Exp;
branches;
next	1.469;

1.469
date	2012.05.12.19.17.16;	author cgf;	state Exp;
branches;
next	1.468;

1.468
date	2012.04.30.15.38.45;	author cgf;	state Exp;
branches;
next	1.467;

1.467
date	2012.04.25.07.25.00;	author corinna;	state Exp;
branches;
next	1.466;

1.466
date	2012.04.24.14.29.37;	author corinna;	state Exp;
branches;
next	1.465;

1.465
date	2012.04.18.05.57.37;	author cgf;	state Exp;
branches;
next	1.464;

1.464
date	2012.04.15.17.51.22;	author cgf;	state Exp;
branches;
next	1.463;

1.463
date	2012.04.06.19.40.58;	author cgf;	state Exp;
branches;
next	1.462;

1.462
date	2012.04.05.02.54.51;	author cgf;	state Exp;
branches;
next	1.461;

1.461
date	2012.04.02.16.19.29;	author corinna;	state Exp;
branches;
next	1.460;

1.460
date	2012.04.02.11.18.45;	author corinna;	state Exp;
branches;
next	1.459;

1.459
date	2012.04.02.11.08.07;	author corinna;	state Exp;
branches;
next	1.458;

1.458
date	2012.03.31.17.38.00;	author cgf;	state Exp;
branches;
next	1.457;

1.457
date	2012.03.29.18.02.54;	author corinna;	state Exp;
branches;
next	1.456;

1.456
date	2012.03.26.11.24.51;	author corinna;	state Exp;
branches;
next	1.455;

1.455
date	2012.03.12.21.29.36;	author cgf;	state Exp;
branches;
next	1.454;

1.454
date	2012.02.28.14.03.02;	author ericb;	state Exp;
branches;
next	1.453;

1.453
date	2012.02.07.16.54.13;	author cgf;	state Exp;
branches;
next	1.452;

1.452
date	2012.01.22.21.43.25;	author cgf;	state Exp;
branches;
next	1.451;

1.451
date	2012.01.22.06.45.07;	author cgf;	state Exp;
branches;
next	1.450;

1.450
date	2012.01.20.12.53.26;	author corinna;	state Exp;
branches;
next	1.449;

1.449
date	2012.01.11.19.07.09;	author cgf;	state Exp;
branches;
next	1.448;

1.448
date	2011.12.17.00.03.31;	author cgf;	state Exp;
branches;
next	1.447;

1.447
date	2011.12.13.04.11.45;	author cgf;	state Exp;
branches;
next	1.446;

1.446
date	2011.11.29.15.34.48;	author cgf;	state Exp;
branches;
next	1.445;

1.445
date	2011.11.23.18.56.57;	author cgf;	state Exp;
branches;
next	1.444;

1.444
date	2011.11.08.06.26.15;	author cgf;	state Exp;
branches;
next	1.443;

1.443
date	2011.11.07.20.05.48;	author cgf;	state Exp;
branches;
next	1.442;

1.442
date	2011.10.30.04.50.35;	author cgf;	state Exp;
branches;
next	1.441;

1.441
date	2011.10.22.16.26.28;	author cgf;	state Exp;
branches;
next	1.440;

1.440
date	2011.10.20.21.35.59;	author cgf;	state Exp;
branches;
next	1.439;

1.439
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.438;

1.438
date	2011.10.11.23.20.38;	author cgf;	state Exp;
branches;
next	1.437;

1.437
date	2011.10.10.18.59.56;	author corinna;	state Exp;
branches;
next	1.436;

1.436
date	2011.10.07.13.52.20;	author cgf;	state Exp;
branches;
next	1.435;

1.435
date	2011.08.12.12.31.07;	author corinna;	state Exp;
branches;
next	1.434;

1.434
date	2011.07.31.12.37.52;	author corinna;	state Exp;
branches;
next	1.433;

1.433
date	2011.07.30.20.01.27;	author cgf;	state Exp;
branches;
next	1.432;

1.432
date	2011.06.17.11.04.44;	author corinna;	state Exp;
branches;
next	1.431;

1.431
date	2011.06.16.23.00.00;	author cgf;	state Exp;
branches;
next	1.430;

1.430
date	2011.06.14.21.48.43;	author cgf;	state Exp;
branches;
next	1.429;

1.429
date	2011.06.12.20.15.26;	author cgf;	state Exp;
branches;
next	1.428;

1.428
date	2011.06.04.00.12.29;	author cgf;	state Exp;
branches;
next	1.427;

1.427
date	2011.05.31.00.26.37;	author cgf;	state Exp;
branches;
next	1.426;

1.426
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.425;

1.425
date	2011.05.06.20.22.45;	author cgf;	state Exp;
branches;
next	1.424;

1.424
date	2011.05.06.19.13.22;	author cgf;	state Exp;
branches;
next	1.423;

1.423
date	2011.05.06.10.56.37;	author corinna;	state Exp;
branches;
next	1.422;

1.422
date	2011.05.05.22.30.53;	author cgf;	state Exp;
branches;
next	1.421;

1.421
date	2011.05.05.17.44.42;	author cgf;	state Exp;
branches;
next	1.420;

1.420
date	2011.05.04.13.06.10;	author corinna;	state Exp;
branches;
next	1.419;

1.419
date	2011.05.04.12.56.12;	author corinna;	state Exp;
branches;
next	1.418;

1.418
date	2011.05.04.12.23.00;	author corinna;	state Exp;
branches;
next	1.417;

1.417
date	2011.05.01.14.35.11;	author corinna;	state Exp;
branches;
next	1.416;

1.416
date	2011.05.01.08.01.55;	author corinna;	state Exp;
branches;
next	1.415;

1.415
date	2011.04.17.19.56.25;	author cgf;	state Exp;
branches;
next	1.414;

1.414
date	2011.04.01.19.48.19;	author yselkowitz;	state Exp;
branches;
next	1.413;

1.413
date	2011.03.18.14.25.33;	author cgf;	state Exp;
branches;
next	1.412;

1.412
date	2011.03.13.20.20.58;	author cgf;	state Exp;
branches;
next	1.411;

1.411
date	2011.03.09.16.47.44;	author cgf;	state Exp;
branches
	1.411.2.1;
next	1.410;

1.410
date	2011.01.12.09.16.50;	author corinna;	state Exp;
branches;
next	1.409;

1.409
date	2011.01.11.14.50.44;	author corinna;	state Exp;
branches;
next	1.408;

1.408
date	2010.10.23.18.07.07;	author cgf;	state Exp;
branches;
next	1.407;

1.407
date	2010.10.07.14.03.26;	author corinna;	state Exp;
branches;
next	1.406;

1.406
date	2010.09.24.16.22.53;	author corinna;	state Exp;
branches;
next	1.405;

1.405
date	2010.09.13.11.17.35;	author corinna;	state Exp;
branches;
next	1.404;

1.404
date	2010.09.06.09.47.01;	author corinna;	state Exp;
branches;
next	1.403;

1.403
date	2010.07.05.16.59.55;	author corinna;	state Exp;
branches;
next	1.402;

1.402
date	2010.06.15.12.05.14;	author corinna;	state Exp;
branches;
next	1.401;

1.401
date	2010.05.26.13.10.55;	author corinna;	state Exp;
branches;
next	1.400;

1.400
date	2010.04.19.19.52.43;	author corinna;	state Exp;
branches;
next	1.399;

1.399
date	2010.04.11.19.11.17;	author corinna;	state Exp;
branches;
next	1.398;

1.398
date	2010.04.02.22.36.43;	author cgf;	state Exp;
branches;
next	1.397;

1.397
date	2010.04.02.18.54.58;	author cgf;	state Exp;
branches;
next	1.396;

1.396
date	2010.03.31.15.00.48;	author cgf;	state Exp;
branches;
next	1.395;

1.395
date	2010.03.31.04.39.13;	author cgf;	state Exp;
branches;
next	1.394;

1.394
date	2010.03.31.04.26.11;	author cgf;	state Exp;
branches;
next	1.393;

1.393
date	2010.03.22.10.47.53;	author corinna;	state Exp;
branches;
next	1.392;

1.392
date	2010.02.15.01.45.05;	author cgf;	state Exp;
branches;
next	1.391;

1.391
date	2010.01.15.15.40.05;	author corinna;	state Exp;
branches;
next	1.390;

1.390
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.389;

1.389
date	2010.01.10.11.12.52;	author corinna;	state Exp;
branches;
next	1.388;

1.388
date	2009.12.28.17.24.03;	author corinna;	state Exp;
branches;
next	1.387;

1.387
date	2009.12.19.15.37.10;	author corinna;	state Exp;
branches;
next	1.386;

1.386
date	2009.12.18.17.14.21;	author corinna;	state Exp;
branches;
next	1.385;

1.385
date	2009.12.16.14.56.10;	author corinna;	state Exp;
branches;
next	1.384;

1.384
date	2009.11.17.10.43.00;	author corinna;	state Exp;
branches;
next	1.383;

1.383
date	2009.11.11.18.16.57;	author corinna;	state Exp;
branches;
next	1.382;

1.382
date	2009.10.07.07.52.30;	author corinna;	state Exp;
branches;
next	1.381;

1.381
date	2009.09.28.12.10.32;	author corinna;	state Exp;
branches;
next	1.380;

1.380
date	2009.09.25.13.44.45;	author ericb;	state Exp;
branches;
next	1.379;

1.379
date	2009.08.18.15.21.47;	author cgf;	state Exp;
branches;
next	1.378;

1.378
date	2009.08.13.10.26.42;	author corinna;	state Exp;
branches;
next	1.377;

1.377
date	2009.08.04.04.31.08;	author cgf;	state Exp;
branches;
next	1.376;

1.376
date	2009.08.04.04.20.36;	author cgf;	state Exp;
branches;
next	1.375;

1.375
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.374;

1.374
date	2009.07.22.15.46.36;	author corinna;	state Exp;
branches;
next	1.373;

1.373
date	2009.07.17.22.51.28;	author cgf;	state Exp;
branches;
next	1.372;

1.372
date	2009.07.17.18.17.11;	author cgf;	state Exp;
branches;
next	1.371;

1.371
date	2009.07.04.23.51.09;	author cgf;	state Exp;
branches;
next	1.370;

1.370
date	2009.07.03.18.05.50;	author cgf;	state Exp;
branches;
next	1.369;

1.369
date	2009.07.01.09.16.17;	author corinna;	state Exp;
branches;
next	1.368;

1.368
date	2009.06.30.21.18.43;	author cgf;	state Exp;
branches;
next	1.367;

1.367
date	2009.06.30.14.36.11;	author cgf;	state Exp;
branches;
next	1.366;

1.366
date	2009.06.28.19.23.13;	author cgf;	state Exp;
branches;
next	1.365;

1.365
date	2009.06.14.23.42.09;	author cgf;	state Exp;
branches;
next	1.364;

1.364
date	2009.05.14.19.49.37;	author corinna;	state Exp;
branches;
next	1.363;

1.363
date	2009.05.04.03.51.16;	author cgf;	state Exp;
branches;
next	1.362;

1.362
date	2009.04.07.12.13.37;	author corinna;	state Exp;
branches;
next	1.361;

1.361
date	2009.04.05.16.49.15;	author cgf;	state Exp;
branches;
next	1.360;

1.360
date	2009.03.27.15.04.42;	author corinna;	state Exp;
branches;
next	1.359;

1.359
date	2009.03.24.12.18.34;	author corinna;	state Exp;
branches;
next	1.358;

1.358
date	2009.03.09.14.40.44;	author corinna;	state Exp;
branches;
next	1.357;

1.357
date	2009.02.27.00.34.40;	author cgf;	state Exp;
branches;
next	1.356;

1.356
date	2009.01.20.18.04.32;	author corinna;	state Exp;
branches;
next	1.355;

1.355
date	2009.01.20.17.22.11;	author corinna;	state Exp;
branches;
next	1.354;

1.354
date	2009.01.20.11.16.59;	author corinna;	state Exp;
branches;
next	1.353;

1.353
date	2008.12.23.18.22.33;	author cgf;	state Exp;
branches;
next	1.352;

1.352
date	2008.12.15.12.33.27;	author corinna;	state Exp;
branches;
next	1.351;

1.351
date	2008.11.26.17.21.03;	author cgf;	state Exp;
branches;
next	1.350;

1.350
date	2008.09.11.04.41.24;	author cgf;	state Exp;
branches;
next	1.349;

1.349
date	2008.08.26.15.39.17;	author corinna;	state Exp;
branches;
next	1.348;

1.348
date	2008.08.20.02.25.06;	author cgf;	state Exp;
branches;
next	1.347;

1.347
date	2008.06.12.15.57.23;	author corinna;	state Exp;
branches;
next	1.346;

1.346
date	2008.05.21.09.02.42;	author corinna;	state Exp;
branches;
next	1.345;

1.345
date	2008.05.20.15.11.20;	author corinna;	state Exp;
branches;
next	1.344;

1.344
date	2008.05.13.13.44.04;	author corinna;	state Exp;
branches;
next	1.343;

1.343
date	2008.04.30.09.51.38;	author corinna;	state Exp;
branches;
next	1.342;

1.342
date	2008.04.24.09.59.54;	author corinna;	state Exp;
branches;
next	1.341;

1.341
date	2008.04.18.20.30.04;	author corinna;	state Exp;
branches;
next	1.340;

1.340
date	2008.04.18.20.13.37;	author corinna;	state Exp;
branches;
next	1.339;

1.339
date	2008.03.31.18.03.25;	author corinna;	state Exp;
branches;
next	1.338;

1.338
date	2008.03.24.14.48.58;	author corinna;	state Exp;
branches;
next	1.337;

1.337
date	2008.03.22.21.04.16;	author cgf;	state Exp;
branches;
next	1.336;

1.336
date	2008.03.10.17.23.50;	author corinna;	state Exp;
branches;
next	1.335;

1.335
date	2008.02.10.15.43.04;	author corinna;	state Exp;
branches;
next	1.334;

1.334
date	2008.02.06.18.24.50;	author corinna;	state Exp;
branches;
next	1.333;

1.333
date	2008.02.05.17.37.10;	author corinna;	state Exp;
branches;
next	1.332;

1.332
date	2008.01.07.16.51.54;	author corinna;	state Exp;
branches;
next	1.331;

1.331
date	2008.01.06.18.37.20;	author cgf;	state Exp;
branches;
next	1.330;

1.330
date	2007.12.22.13.26.47;	author corinna;	state Exp;
branches;
next	1.329;

1.329
date	2007.12.16.21.21.23;	author cgf;	state Exp;
branches;
next	1.328;

1.328
date	2007.11.08.14.37.59;	author cgf;	state Exp;
branches;
next	1.327;

1.327
date	2007.11.08.14.36.49;	author cgf;	state Exp;
branches;
next	1.326;

1.326
date	2007.08.16.14.10.06;	author corinna;	state Exp;
branches;
next	1.325;

1.325
date	2007.08.14.14.48.52;	author corinna;	state Exp;
branches;
next	1.324;

1.324
date	2007.08.13.19.15.46;	author corinna;	state Exp;
branches;
next	1.323;

1.323
date	2007.08.13.17.16.04;	author corinna;	state Exp;
branches;
next	1.322;

1.322
date	2007.07.29.05.22.05;	author cgf;	state Exp;
branches;
next	1.321;

1.321
date	2007.07.27.08.38.00;	author corinna;	state Exp;
branches;
next	1.320;

1.320
date	2007.07.26.17.30.54;	author corinna;	state Exp;
branches;
next	1.319;

1.319
date	2007.07.10.01.21.03;	author cgf;	state Exp;
branches;
next	1.318;

1.318
date	2007.07.09.17.02.37;	author corinna;	state Exp;
branches;
next	1.317;

1.317
date	2007.07.07.17.28.22;	author cgf;	state Exp;
branches;
next	1.316;

1.316
date	2007.07.07.17.00.33;	author cgf;	state Exp;
branches;
next	1.315;

1.315
date	2007.06.29.15.13.00;	author corinna;	state Exp;
branches;
next	1.314;

1.314
date	2007.05.29.17.25.36;	author corinna;	state Exp;
branches;
next	1.313;

1.313
date	2007.03.06.16.29.40;	author corinna;	state Exp;
branches;
next	1.312;

1.312
date	2007.02.27.12.58.55;	author corinna;	state Exp;
branches;
next	1.311;

1.311
date	2007.02.23.14.47.45;	author corinna;	state Exp;
branches;
next	1.310;

1.310
date	2007.02.23.14.20.28;	author corinna;	state Exp;
branches;
next	1.309;

1.309
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.308;

1.308
date	2007.01.17.19.26.57;	author corinna;	state Exp;
branches;
next	1.307;

1.307
date	2007.01.04.09.17.55;	author corinna;	state Exp;
branches;
next	1.306;

1.306
date	2006.12.11.18.55.28;	author cgf;	state Exp;
branches;
next	1.305;

1.305
date	2006.11.07.17.59.54;	author corinna;	state Exp;
branches;
next	1.304;

1.304
date	2006.10.19.10.01.03;	author corinna;	state Exp;
branches;
next	1.303;

1.303
date	2006.08.07.19.29.14;	author corinna;	state Exp;
branches;
next	1.302;

1.302
date	2006.07.28.08.50.46;	author corinna;	state Exp;
branches;
next	1.301;

1.301
date	2006.07.27.09.18.28;	author corinna;	state Exp;
branches;
next	1.300;

1.300
date	2006.07.27.09.11.38;	author corinna;	state Exp;
branches;
next	1.299;

1.299
date	2006.07.25.19.23.23;	author corinna;	state Exp;
branches;
next	1.298;

1.298
date	2006.07.17.19.30.30;	author cgf;	state Exp;
branches
	1.298.2.1;
next	1.297;

1.297
date	2006.07.05.15.39.08;	author corinna;	state Exp;
branches
	1.297.2.1;
next	1.296;

1.296
date	2006.07.04.09.26.49;	author corinna;	state Exp;
branches;
next	1.295;

1.295
date	2006.07.03.15.29.10;	author corinna;	state Exp;
branches;
next	1.294;

1.294
date	2006.06.26.12.12.11;	author corinna;	state Exp;
branches;
next	1.293;

1.293
date	2006.06.14.20.19.10;	author corinna;	state Exp;
branches;
next	1.292;

1.292
date	2006.06.03.21.44.01;	author cgf;	state Exp;
branches;
next	1.291;

1.291
date	2006.06.02.15.41.34;	author cgf;	state Exp;
branches;
next	1.290;

1.290
date	2006.05.25.05.40.51;	author cgf;	state Exp;
branches;
next	1.289;

1.289
date	2006.05.21.21.02.52;	author cgf;	state Exp;
branches;
next	1.288;

1.288
date	2006.05.21.05.25.49;	author cgf;	state Exp;
branches;
next	1.287;

1.287
date	2006.04.26.16.51.09;	author corinna;	state Exp;
branches;
next	1.286;

1.286
date	2006.03.01.22.37.25;	author corinna;	state Exp;
branches;
next	1.285;

1.285
date	2006.01.29.12.23.44;	author corinna;	state Exp;
branches;
next	1.284;

1.284
date	2006.01.27.21.50.40;	author corinna;	state Exp;
branches;
next	1.283;

1.283
date	2006.01.21.02.24.16;	author cgf;	state Exp;
branches;
next	1.282;

1.282
date	2006.01.12.15.53.50;	author corinna;	state Exp;
branches;
next	1.281;

1.281
date	2006.01.12.05.03.14;	author cgf;	state Exp;
branches;
next	1.280;

1.280
date	2006.01.07.17.57.26;	author cgf;	state Exp;
branches;
next	1.279;

1.279
date	2005.12.22.16.45.15;	author corinna;	state Exp;
branches;
next	1.278;

1.278
date	2005.12.20.18.14.42;	author cgf;	state Exp;
branches;
next	1.277;

1.277
date	2005.12.19.19.04.14;	author cgf;	state Exp;
branches;
next	1.276;

1.276
date	2005.12.19.04.34.13;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2005.11.29.16.28.05;	author corinna;	state Exp;
branches;
next	1.274;

1.274
date	2005.11.28.22.32.29;	author corinna;	state Exp;
branches;
next	1.273;

1.273
date	2005.11.14.14.15.51;	author cgf;	state Exp;
branches;
next	1.272;

1.272
date	2005.11.14.05.36.16;	author cgf;	state Exp;
branches;
next	1.271;

1.271
date	2005.11.14.04.28.44;	author cgf;	state Exp;
branches;
next	1.270;

1.270
date	2005.10.22.15.11.49;	author corinna;	state Exp;
branches;
next	1.269;

1.269
date	2005.09.28.19.33.18;	author corinna;	state Exp;
branches;
next	1.268;

1.268
date	2005.09.28.19.22.21;	author corinna;	state Exp;
branches;
next	1.267;

1.267
date	2005.09.28.19.02.49;	author corinna;	state Exp;
branches;
next	1.266;

1.266
date	2005.09.26.14.55.39;	author corinna;	state Exp;
branches;
next	1.265;

1.265
date	2005.09.22.15.52.02;	author corinna;	state Exp;
branches;
next	1.264;

1.264
date	2005.08.20.06.19.54;	author cgf;	state Exp;
branches;
next	1.263;

1.263
date	2005.08.19.16.29.43;	author cgf;	state Exp;
branches;
next	1.262;

1.262
date	2005.08.19.16.18.42;	author cgf;	state Exp;
branches;
next	1.261;

1.261
date	2005.08.18.20.17.10;	author cgf;	state Exp;
branches;
next	1.260;

1.260
date	2005.08.08.04.06.07;	author cgf;	state Exp;
branches;
next	1.259;

1.259
date	2005.08.02.09.17.09;	author corinna;	state Exp;
branches;
next	1.258;

1.258
date	2005.07.29.17.04.46;	author cgf;	state Exp;
branches;
next	1.257;

1.257
date	2005.07.06.20.05.00;	author cgf;	state Exp;
branches;
next	1.256;

1.256
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.255;

1.255
date	2005.07.05.02.05.07;	author cgf;	state Exp;
branches;
next	1.254;

1.254
date	2005.06.22.19.59.19;	author corinna;	state Exp;
branches;
next	1.253;

1.253
date	2005.06.17.11.44.45;	author corinna;	state Exp;
branches;
next	1.252;

1.252
date	2005.06.02.02.36.50;	author cgf;	state Exp;
branches;
next	1.251;

1.251
date	2005.06.01.03.46.56;	author cgf;	state Exp;
branches;
next	1.250;

1.250
date	2005.05.25.04.32.58;	author cgf;	state Exp;
branches;
next	1.249;

1.249
date	2005.05.19.05.43.55;	author cgf;	state Exp;
branches;
next	1.248;

1.248
date	2005.05.18.10.32.37;	author corinna;	state Exp;
branches;
next	1.247;

1.247
date	2005.05.17.20.34.15;	author corinna;	state Exp;
branches;
next	1.246;

1.246
date	2005.05.13.20.20.02;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2005.05.10.20.56.07;	author corinna;	state Exp;
branches;
next	1.244;

1.244
date	2005.05.09.02.39.34;	author phumblet;	state Exp;
branches;
next	1.243;

1.243
date	2005.04.22.17.03.37;	author cgf;	state Exp;
branches;
next	1.242;

1.242
date	2005.04.22.13.58.08;	author cgf;	state Exp;
branches;
next	1.241;

1.241
date	2005.04.18.18.56.51;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2005.04.17.00.12.13;	author cgf;	state Exp;
branches;
next	1.239;

1.239
date	2005.04.13.17.13.41;	author corinna;	state Exp;
branches;
next	1.238;

1.238
date	2005.04.13.16.17.36;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2005.04.12.14.26.30;	author corinna;	state Exp;
branches;
next	1.236;

1.236
date	2005.04.04.10.26.34;	author corinna;	state Exp;
branches;
next	1.235;

1.235
date	2005.03.24.14.04.04;	author corinna;	state Exp;
branches;
next	1.234;

1.234
date	2005.03.23.17.27.17;	author corinna;	state Exp;
branches;
next	1.233;

1.233
date	2005.03.21.19.10.45;	author corinna;	state Exp;
branches;
next	1.232;

1.232
date	2005.03.21.18.56.50;	author corinna;	state Exp;
branches;
next	1.231;

1.231
date	2005.03.19.21.45.15;	author cgf;	state Exp;
branches;
next	1.230;

1.230
date	2005.03.16.21.20.56;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2005.02.28.13.11.49;	author corinna;	state Exp;
branches;
next	1.228;

1.228
date	2005.02.25.21.23.15;	author corinna;	state Exp;
branches;
next	1.227;

1.227
date	2005.02.23.17.39.45;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2005.02.20.16.14.53;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2005.02.20.13.28.23;	author corinna;	state Exp;
branches;
next	1.224;

1.224
date	2005.02.20.11.44.32;	author corinna;	state Exp;
branches;
next	1.223;

1.223
date	2005.02.19.21.53.36;	author corinna;	state Exp;
branches;
next	1.222;

1.222
date	2005.02.19.20.03.17;	author corinna;	state Exp;
branches;
next	1.221;

1.221
date	2005.02.13.18.17.28;	author cgf;	state Exp;
branches;
next	1.220;

1.220
date	2005.02.11.15.37.26;	author corinna;	state Exp;
branches;
next	1.219;

1.219
date	2005.02.06.05.04.34;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2005.02.02.22.42.04;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2005.02.01.15.11.42;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2005.01.31.21.29.59;	author cgf;	state Exp;
branches;
next	1.215;

1.215
date	2005.01.31.10.28.52;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2005.01.29.11.23.05;	author corinna;	state Exp;
branches;
next	1.213;

1.213
date	2005.01.13.22.56.20;	author corinna;	state Exp;
branches;
next	1.212;

1.212
date	2005.01.12.22.40.45;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2004.08.17.09.52.50;	author corinna;	state Exp;
branches;
next	1.210;

1.210
date	2004.07.15.14.56.05;	author corinna;	state Exp;
branches;
next	1.209;

1.209
date	2004.06.07.04.26.32;	author cgf;	state Exp;
branches;
next	1.208;

1.208
date	2004.05.10.15.21.01;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2004.05.07.07.51.31;	author corinna;	state Exp;
branches;
next	1.206;

1.206
date	2004.04.20.15.51.24;	author corinna;	state Exp;
branches;
next	1.205;

1.205
date	2004.04.19.19.29.10;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2004.04.16.21.22.13;	author corinna;	state Exp;
branches;
next	1.203;

1.203
date	2004.04.14.16.36.26;	author corinna;	state Exp;
branches;
next	1.202;

1.202
date	2004.04.14.13.40.07;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2004.04.13.20.36.58;	author corinna;	state Exp;
branches;
next	1.200;

1.200
date	2004.04.13.09.04.21;	author corinna;	state Exp;
branches;
next	1.199;

1.199
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.198;

1.198
date	2004.04.09.20.39.18;	author corinna;	state Exp;
branches;
next	1.197;

1.197
date	2004.04.09.12.09.45;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2004.04.09.08.43.28;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2004.04.08.07.57.28;	author corinna;	state Exp;
branches;
next	1.194;

1.194
date	2004.04.03.19.07.59;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2004.03.29.19.41.17;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2004.03.26.21.43.48;	author corinna;	state Exp;
branches;
next	1.191;

1.191
date	2004.03.23.11.05.56;	author corinna;	state Exp;
branches;
next	1.190;

1.190
date	2004.03.21.17.41.40;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2004.03.15.11.37.36;	author corinna;	state Exp;
branches;
next	1.188;

1.188
date	2004.03.13.18.15.06;	author corinna;	state Exp;
branches;
next	1.187;

1.187
date	2004.02.09.04.04.22;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2004.02.02.21.00.07;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2004.02.02.20.33.09;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2004.01.24.20.34.27;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2004.01.24.03.40.33;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2003.12.30.01.57.16;	author cgf;	state Exp;
branches
	1.182.6.1;
next	1.181;

1.181
date	2003.12.27.17.41.17;	author cgf;	state Exp;
branches;
next	1.180;

1.180
date	2003.12.27.01.59.29;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2003.12.16.23.28.03;	author cgf;	state Exp;
branches;
next	1.178;

1.178
date	2003.12.11.06.12.41;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2003.12.10.03.19.19;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2003.12.08.06.27.05;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.174;

1.174
date	2003.12.03.16.35.52;	author corinna;	state Exp;
branches;
next	1.173;

1.173
date	2003.12.01.17.26.28;	author corinna;	state Exp;
branches;
next	1.172;

1.172
date	2003.11.25.02.03.17;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2003.10.16.14.08.27;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2003.10.01.12.36.39;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2003.09.30.21.43.40;	author corinna;	state Exp;
branches;
next	1.168;

1.168
date	2003.09.27.05.35.02;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2003.07.09.01.33.06;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2003.07.05.18.20.13;	author corinna;	state Exp;
branches;
next	1.164;

1.164
date	2003.07.04.03.07.01;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2003.05.26.09.54.01;	author corinna;	state Exp;
branches;
next	1.162;

1.162
date	2003.05.12.11.06.25;	author corinna;	state Exp;
branches;
next	1.161;

1.161
date	2003.05.11.21.52.09;	author corinna;	state Exp;
branches;
next	1.160;

1.160
date	2003.05.11.00.10.10;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.158;

1.158
date	2003.03.08.16.44.24;	author corinna;	state Exp;
branches;
next	1.157;

1.157
date	2003.03.04.04.07.34;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2003.03.02.18.37.17;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2003.02.21.14.29.18;	author corinna;	state Exp;
branches;
next	1.154;

1.154
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.154.2.1;
next	1.153;

1.153
date	2002.12.27.05.31.30;	author cgf;	state Exp;
branches
	1.153.2.1;
next	1.152;

1.152
date	2002.12.27.03.50.29;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2002.12.21.04.38.12;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2002.12.20.01.38.55;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2002.12.14.04.01.32;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2002.12.11.04.00.03;	author cgf;	state Exp;
branches;
next	1.147;

1.147
date	2002.12.05.16.24.52;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2002.11.09.03.17.40;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2002.11.05.23.15.04;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2002.10.30.21.05.17;	author cgf;	state Exp;
branches
	1.144.2.1;
next	1.143;

1.143
date	2002.10.09.05.55.40;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2002.10.09.04.08.05;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2002.10.08.06.16.16;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2002.09.04.09.39.34;	author corinna;	state Exp;
branches;
next	1.138;

1.138
date	2002.08.31.03.35.50;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2002.08.30.15.47.09;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2002.08.26.09.57.26;	author corinna;	state Exp;
branches;
next	1.135;

1.135
date	2002.08.19.04.43.58;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2002.08.12.13.54.12;	author scottc;	state Exp;
branches;
next	1.133;

1.133
date	2002.08.02.02.10.24;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2002.07.31.13.18.51;	author corinna;	state Exp;
branches;
next	1.131;

1.131
date	2002.07.31.00.26.36;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2002.07.22.09.11.44;	author corinna;	state Exp;
branches;
next	1.129;

1.129
date	2002.07.06.11.16.07;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2002.07.05.18.26.22;	author corinna;	state Exp;
branches;
next	1.127;

1.127
date	2002.07.02.01.36.15;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2002.06.30.23.02.58;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2002.06.30.17.05.48;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2002.06.26.19.25.09;	author corinna;	state Exp;
branches;
next	1.123;

1.123
date	2002.06.10.11.07.44;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2002.06.04.16.38.13;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2002.05.31.22.53.25;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2002.05.24.05.44.10;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2002.05.22.22.09.57;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2002.05.12.03.08.59;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2002.05.12.01.37.48;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2002.05.02.04.13.45;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2002.04.12.14.52.36;	author corinna;	state Exp;
branches;
next	1.111;

1.111
date	2002.03.19.04.39.01;	author rbcollins;	state Exp;
branches;
next	1.110;

1.110
date	2002.02.28.14.25.53;	author rbcollins;	state Exp;
branches;
next	1.109;

1.109
date	2002.02.25.17.47.46;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2002.02.10.13.38.48;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2002.02.09.10.40.48;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2002.02.08.11.54.10;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2002.01.01.16.25.31;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2001.12.11.00.24.46;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2001.11.24.03.11.39;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2001.11.22.05.59.07;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2001.11.21.06.47.57;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2001.11.05.01.52.20;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2001.11.04.02.31.58;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2001.11.03.05.42.21;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2001.11.03.03.32.27;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2001.11.02.04.44.06;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2001.11.01.21.15.53;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2001.10.29.05.28.24;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2001.10.28.23.05.49;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2001.10.24.04.16.45;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2001.10.22.18.39.22;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2001.10.16.14.53.26;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2001.10.08.05.50.33;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2001.10.05.04.21.41;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2001.09.29.01.23.06;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2001.09.24.21.50.44;	author cgf;	state Exp;
branches
	1.83.2.1;
next	1.82;

1.82
date	2001.09.22.21.44.07;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2001.09.22.16.55.02;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2001.09.20.20.58.29;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2001.09.20.11.29.48;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2001.09.14.04.22.05;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2001.09.01.05.17.34;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2001.08.31.05.23.04;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2001.08.31.05.06.13;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2001.08.15.07.49.15;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2001.08.14.07.41.45;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2001.08.07.00.01.42;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.26.14.47.48;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.24.22.26.50;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.22.20.53.45;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.20.06.50.13;	author duda;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.14.18.21.17;	author duda;	state Exp;
branches;
next	1.62;

1.62
date	2001.05.31.05.25.46;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2001.05.24.05.20.17;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2001.05.09.18.53.55;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2001.05.08.15.16.49;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2001.04.28.23.48.27;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2001.04.24.02.07.58;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2001.04.23.17.29.33;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2001.04.17.03.52.08;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2001.04.16.03.27.16;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2001.04.09.07.21.32;	author duda;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.31.09.19.32;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2001.03.30.11.10.13;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2001.03.22.22.11.34;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2001.03.18.18.05.01;	author duda;	state Exp;
branches;
next	1.48;

1.48
date	2001.03.12.21.27.42;	author duda;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.12.20.39.40;	author duda;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.11.01.58.23;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.06.12.05.45;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.04.15.34.25;	author duda;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.02.01.55.21;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.27.09.14.35;	author duda;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.17.14.57.09;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.11.12.33.12;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2000.12.15.04.42.20;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.13.04.06.40;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.31.22.38.00;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.31.22.20.59;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.28.05.41.43;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2000.10.27.09.50.33;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.26.10.13.41;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2000.10.23.20.16.52;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.21.04.53.49;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.17.01.46.26;	author dj;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.12.04.38.29;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.09.13.19.41;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.07.18.12.11;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.07.17.35.36;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.05.13.07.02;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.04.17.08.46;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.01.01.02.40;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.26.00.52.21;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.07.16.23.50;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.07.01.18.37;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.29.04.19.24;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.24.11.33.02;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.23.21.13.05;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.23.19.33.44;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.09.05.29.51;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.18.17.43.45;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.12.05.06.43;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.03.15.39.10;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.20.04.38.10;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.03.18.15.01;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.30.04.23.11;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.30.03.51.30;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.15.04.49.36;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.12.06.29.54;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.495.2.1
date	2014.02.21.02.43.26;	author cgf;	state Exp;
branches;
next	1.495.2.2;

1.495.2.2
date	2014.02.23.03.39.38;	author cgf;	state Exp;
branches;
next	1.495.2.3;

1.495.2.3
date	2014.02.26.01.40.49;	author cgf;	state Exp;
branches;
next	1.495.2.4;

1.495.2.4
date	2014.03.09.22.49.06;	author cgf;	state Exp;
branches;
next	1.495.2.5;

1.495.2.5
date	2014.03.10.18.18.49;	author cgf;	state Exp;
branches;
next	1.495.2.6;

1.495.2.6
date	2014.03.17.01.54.12;	author cgf;	state Exp;
branches;
next	1.495.2.7;

1.495.2.7
date	2014.03.19.20.42.52;	author cgf;	state Exp;
branches;
next	1.495.2.8;

1.495.2.8
date	2014.05.19.11.47.53;	author corinna;	state Exp;
branches;
next	1.495.2.9;

1.495.2.9
date	2014.11.13.12.53.00;	author corinna;	state Exp;
branches;
next	;

1.473.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.473.2.2;

1.473.2.2
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.473.2.3;

1.473.2.3
date	2012.10.18.17.16.00;	author corinna;	state Exp;
branches;
next	1.473.2.4;

1.473.2.4
date	2012.10.30.17.52.12;	author corinna;	state Exp;
branches;
next	1.473.2.5;

1.473.2.5
date	2012.11.05.17.20.20;	author corinna;	state Exp;
branches;
next	1.473.2.6;

1.473.2.6
date	2012.11.08.17.25.47;	author corinna;	state Exp;
branches;
next	1.473.2.7;

1.473.2.7
date	2012.11.16.09.41.12;	author corinna;	state Exp;
branches;
next	1.473.2.8;

1.473.2.8
date	2012.12.10.11.45.46;	author corinna;	state Exp;
branches;
next	1.473.2.9;

1.473.2.9
date	2013.01.11.12.36.55;	author corinna;	state Exp;
branches;
next	1.473.2.10;

1.473.2.10
date	2013.01.14.17.16.30;	author corinna;	state Exp;
branches;
next	1.473.2.11;

1.473.2.11
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	;

1.411.2.1
date	2011.03.14.09.32.05;	author corinna;	state Exp;
branches;
next	1.411.2.2;

1.411.2.2
date	2011.03.18.17.50.58;	author corinna;	state Exp;
branches;
next	;

1.298.2.1
date	2007.01.15.11.56.07;	author corinna;	state Exp;
branches;
next	1.298.2.2;

1.298.2.2
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	1.298.2.3;

1.298.2.3
date	2008.02.21.17.37.32;	author cgf;	state Exp;
branches;
next	;

1.297.2.1
date	2006.07.10.20.39.06;	author corinna;	state Exp;
branches;
next	1.297.2.2;

1.297.2.2
date	2006.07.18.10.33.54;	author corinna;	state Exp;
branches;
next	1.297.2.3;

1.297.2.3
date	2006.07.21.09.47.46;	author corinna;	state Exp;
branches;
next	1.297.2.4;

1.297.2.4
date	2006.07.25.17.02.36;	author corinna;	state Exp;
branches;
next	;

1.182.6.1
date	2004.01.24.03.41.29;	author cgf;	state Exp;
branches;
next	1.182.6.2;

1.182.6.2
date	2004.01.24.20.36.51;	author cgf;	state Exp;
branches;
next	;

1.154.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.154.2.2;

1.154.2.2
date	2003.01.25.18.59.43;	author cgf;	state Exp;
branches;
next	1.154.2.3;

1.154.2.3
date	2003.02.14.03.03.27;	author cgf;	state Exp;
branches;
next	1.154.2.4;

1.154.2.4
date	2003.03.02.18.57.51;	author cgf;	state Exp;
branches;
next	1.154.2.5;

1.154.2.5
date	2003.03.02.23.39.10;	author cgf;	state Exp;
branches;
next	1.154.2.6;

1.154.2.6
date	2003.03.04.17.26.32;	author cgf;	state Exp;
branches;
next	1.154.2.7;

1.154.2.7
date	2003.03.09.16.22.58;	author cgf;	state Exp;
branches;
next	1.154.2.8;

1.154.2.8
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.154.2.9;

1.154.2.9
date	2003.05.26.19.39.06;	author cgf;	state Exp;
branches;
next	1.154.2.10;

1.154.2.10
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.153.2.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	1.153.2.2;

1.153.2.2
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.153.2.3;

1.153.2.3
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	1.153.2.4;

1.153.2.4
date	2002.12.29.06.14.14;	author cgf;	state Exp;
branches;
next	1.153.2.5;

1.153.2.5
date	2003.01.01.18.16.37;	author cgf;	state Exp;
branches;
next	1.153.2.6;

1.153.2.6
date	2003.01.02.06.16.17;	author cgf;	state Exp;
branches;
next	1.153.2.7;

1.153.2.7
date	2003.01.05.03.01.16;	author cgf;	state Exp;
branches;
next	;

1.144.2.1
date	2002.11.07.03.47.46;	author cgf;	state Exp;
branches;
next	;

1.83.2.1
date	2001.09.25.06.31.04;	author rbcollins;	state Exp;
branches;
next	1.83.2.2;

1.83.2.2
date	2001.09.29.09.35.30;	author rbcollins;	state Exp;
branches;
next	1.83.2.3;

1.83.2.3
date	2001.10.02.12.09.54;	author rbcollins;	state Exp;
branches;
next	1.83.2.4;

1.83.2.4
date	2002.01.04.03.56.07;	author rbcollins;	state Exp;
branches;
next	1.83.2.5;

1.83.2.5
date	2002.02.28.12.53.23;	author rbcollins;	state Exp;
branches;
next	1.83.2.6;

1.83.2.6
date	2002.06.13.14.34.03;	author rbcollins;	state Exp;
branches;
next	1.83.2.7;

1.83.2.7
date	2002.06.27.11.30.14;	author scottc;	state Exp;
branches;
next	1.83.2.8;

1.83.2.8
date	2002.07.01.13.53.39;	author scottc;	state Exp;
branches;
next	1.83.2.9;

1.83.2.9
date	2002.07.02.10.58.17;	author scottc;	state Exp;
branches;
next	1.83.2.10;

1.83.2.10
date	2002.07.06.22.28.18;	author scottc;	state Exp;
branches;
next	1.83.2.11;

1.83.2.11
date	2002.07.23.03.19.13;	author scottc;	state Exp;
branches;
next	1.83.2.12;

1.83.2.12
date	2002.08.02.02.23.44;	author scottc;	state Exp;
branches;
next	1.83.2.13;

1.83.2.13
date	2002.08.12.14.06.34;	author scottc;	state Exp;
branches;
next	1.83.2.14;

1.83.2.14
date	2002.08.24.12.25.31;	author scottc;	state Exp;
branches;
next	1.83.2.15;

1.83.2.15
date	2002.08.26.11.38.14;	author scottc;	state Exp;
branches;
next	1.83.2.16;

1.83.2.16
date	2002.08.30.22.08.50;	author scottc;	state Exp;
branches;
next	1.83.2.17;

1.83.2.17
date	2002.09.03.13.52.06;	author scottc;	state Exp;
branches;
next	1.83.2.18;

1.83.2.18
date	2002.09.04.09.55.01;	author scottc;	state Exp;
branches;
next	1.83.2.19;

1.83.2.19
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.514
log
@	* fhandler.h (fhandler_base::get_echo_handle): New virtual method.
	(class fhandler_pty_master): Add echo_r and echo_w handles constituting
	read and write side of new echo pipe.
	* select.cc (peek_pipe): On pty masters, check additionally if input
	from the echo pipe is available.
	* fhandler_tty.cc (fhandler_pty_master::doecho): Drop output_mutex
	locking.  Write output to echo pipe.
	(fhandler_pty_master::process_slave_output): Check if input is available
	in echo pipe and prefer to read from it, if so.
	(fhandler_pty_slave::write): Drop output_mutex locking.
	(fhandler_pty_master::fhandler_pty_master): Initialize echo pipe
	handles to NULL.
	(fhandler_pty_master::close): Close and NULL echo pipe handles.
	(fhandler_pty_master::setup): Create echo pipe, close in case of error.
@
text
@/* fhandler.h

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#pragma once
#include "pinfo.h"

#include "tty.h"
/* fcntl flags used only internaly. */
#define O_NOSYMLINK	0x080000
#define O_DIROPEN	0x100000

/* newlib used to define O_NDELAY differently from O_NONBLOCK.  Now it
   properly defines both to be the same.  Unfortunately, we have to
   behave properly the old version, too, to accommodate older executables. */
#define OLD_O_NDELAY	(CYGWIN_VERSION_CHECK_FOR_OLD_O_NONBLOCK ? 4 : 0)

/* Care for the old O_NDELAY flag. If one of the flags is set,
   both flags are set. */
#define O_NONBLOCK_MASK (O_NONBLOCK | OLD_O_NDELAY)

/* It appears that 64K is the block size used for buffered I/O on NT.
   Using this blocksize in read/write calls in the application results
   in a much better performance than using smaller values. */
#define PREFERRED_IO_BLKSIZE ((blksize_t) 65536)

/* It also appears that this may be the only acceptable block size for
   atomic writes to a pipe.  It is a shame that we have to make this
   so small.  http://cygwin.com/ml/cygwin/2011-03/msg00541.html  */
#define DEFAULT_PIPEBUFSIZE PREFERRED_IO_BLKSIZE

/* Used for fhandler_pipe::create.  Use an available flag which will
   never be used in Cygwin for this function. */
#define PIPE_ADD_PID	FILE_FLAG_FIRST_PIPE_INSTANCE

extern const char *windows_device_names[];
extern struct __cygwin_perfile *perfile_table;
#define __fmode (*(user_data->fmode_ptr))
extern const char proc[];
extern const size_t proc_len;
extern const char procsys[];
extern const size_t procsys_len;

class select_record;
class select_stuff;
class fhandler_disk_file;
class inode_t;
typedef struct __DIR DIR;
struct dirent;
struct iovec;
struct acl;

enum dirent_states
{
  dirent_ok		= 0x0000,
  dirent_saw_dot	= 0x0001,
  dirent_saw_dot_dot	= 0x0002,
  dirent_saw_eof	= 0x0004,
  dirent_isroot		= 0x0008,
  dirent_set_d_ino	= 0x0010,
  dirent_get_d_ino	= 0x0020,
  dirent_nfs_d_ino	= 0x0040,

  /* Global flags which must not be deleted on rewinddir or seekdir. */
  dirent_info_mask	= 0x0078
};

enum conn_state
{
  unconnected = 0,
  connect_pending = 1,
  connected = 2,
  listener = 3,
  connect_failed = 4
};

enum line_edit_status
{
  line_edit_ok = 0,
  line_edit_input_done = 1,
  line_edit_signalled = 2,
  line_edit_error = 3,
  line_edit_pipe_full = 4
};

enum bg_check_types
{
  bg_error = -1,
  bg_eof = 0,
  bg_ok = 1,
  bg_signalled = 2
};

enum query_state {
  no_query = 0,
  query_read_control = 1,
  query_read_attributes = 2,
  query_write_control = 3,
  query_write_dac = 4,
  query_write_attributes = 5
};

enum del_lock_called_from {
  on_close,
  after_fork,
  after_exec
};

enum virtual_ftype_t {
  virt_blk = -7,	/* Block special */
  virt_chr = -6,	/* Character special */
  virt_fsfile = -5,	/* FS-based file via /proc/sys */
  virt_socket = -4,	/* Socket */
  virt_pipe = -3,	/* Pipe */
  virt_symlink = -2,	/* Symlink */
  virt_file = -1,	/* Regular file */
  virt_none = 0,	/* Invalid, Error */
  virt_directory = 1,	/* Directory */
  virt_rootdir = 2,	/* Root directory of virtual FS */
  virt_fsdir = 3,	/* FS-based directory via /proc/sys */
};

class fhandler_base
{
  friend class dtable;
  friend void close_all_files (bool);

  struct status_flags
  {
    unsigned rbinary		: 1; /* binary read mode */
    unsigned rbinset	    	: 1; /* binary read mode explicitly set */
    unsigned wbinary		: 1; /* binary write mode */
    unsigned wbinset		: 1; /* binary write mode explicitly set */
    unsigned nohandle		: 1; /* No handle associated with fhandler. */
    unsigned did_lseek		: 1; /* set when lseek is called as a flag that
					_write should check if we've moved
					beyond EOF, zero filling or making
					file sparse if so. */
    unsigned query_open		: 3; /* open file without requesting either
					read or write access */
    unsigned close_on_exec      : 1; /* close-on-exec */
    unsigned need_fork_fixup    : 1; /* Set if need to fixup after fork. */
    unsigned isclosed		: 1; /* Set when fhandler is closed. */
    unsigned mandatory_locking	: 1; /* Windows mandatory locking */
    unsigned was_nonblocking	: 1; /* Set when setting O_NONBLOCK.  Never
					reset.  This is for the sake of
					fhandler_base_overlapped::close. */

   public:
    status_flags () :
      rbinary (0), rbinset (0), wbinary (0), wbinset (0), nohandle (0),
      did_lseek (0), query_open (no_query), close_on_exec (0),
      need_fork_fixup (0), isclosed (0), mandatory_locking (0),
      was_nonblocking (0)
      {}
  } status, open_status;

 private:
  ACCESS_MASK access;
  ULONG options;

  HANDLE io_handle;

  ino_t ino;	/* file ID or hashed filename, depends on FS. */
  LONG _refcnt;

 protected:
  /* File open flags from open () and fcntl () calls */
  int openflags;

  char *rabuf;		/* used for crlf conversion in text files */
  size_t ralen;
  size_t raixget;
  size_t raixput;
  size_t rabuflen;

  /* Used for advisory file locking.  See flock.cc.  */
  long long unique_id;
  void del_my_locks (del_lock_called_from);

  HANDLE read_state;

 public:
  LONG inc_refcnt () {return InterlockedIncrement (&_refcnt);}
  LONG dec_refcnt () {return InterlockedDecrement (&_refcnt);}
  class fhandler_base *archetype;
  int usecount;

  path_conv pc;

  void reset (const fhandler_base *);
  virtual bool use_archetype () const {return false;}
  virtual void set_name (path_conv &pc);
  virtual void set_name (const char *s)
  {
    pc.set_posix (s);
    pc.set_path (s);
  }
  int error () const {return pc.error;}
  void set_error (int error) {pc.error = error;}
  bool exists () const {return pc.exists ();}
  int pc_binmode () const {return pc.binmode ();}
  device& dev () {return pc.dev;}
  operator DWORD& () {return (DWORD&) pc;}
  fhandler_base ();
  virtual ~fhandler_base ();

  /* Non-virtual simple accessor functions. */
  void set_io_handle (HANDLE x) { io_handle = x; }

  dev_t& get_device () { return dev (); }
  _major_t get_major () { return dev ().get_major (); }
  _minor_t get_minor () { return dev ().get_minor (); }

  ACCESS_MASK get_access () const { return access; }
  void set_access (ACCESS_MASK x) { access = x; }

  ULONG get_options () const { return options; }
  void set_options (ULONG x) { options = x; }

  int get_flags () { return openflags; }
  void set_flags (int x, int supplied_bin = 0);

  bool is_nonblocking ();
  void set_nonblocking (int);

  bool wbinary () const { return status.wbinset ? status.wbinary : 1; }
  bool rbinary () const { return status.rbinset ? status.rbinary : 1; }

  void wbinary (bool b) {status.wbinary = b; status.wbinset = 1;}
  void rbinary (bool b) {status.rbinary = b; status.rbinset = 1;}

  void set_open_status () {open_status = status;}
  void reset_to_open_binmode ()
  {
    set_flags ((get_flags () & ~(O_TEXT | O_BINARY))
	       | ((open_status.wbinary || open_status.rbinary)
		   ? O_BINARY : O_TEXT));
  }

  IMPLEMENT_STATUS_FLAG (bool, wbinset)
  IMPLEMENT_STATUS_FLAG (bool, rbinset)
  IMPLEMENT_STATUS_FLAG (bool, nohandle)
  IMPLEMENT_STATUS_FLAG (bool, did_lseek)
  IMPLEMENT_STATUS_FLAG (query_state, query_open)
  IMPLEMENT_STATUS_FLAG (bool, close_on_exec)
  IMPLEMENT_STATUS_FLAG (bool, need_fork_fixup)
  IMPLEMENT_STATUS_FLAG (bool, isclosed)
  IMPLEMENT_STATUS_FLAG (bool, mandatory_locking)
  IMPLEMENT_STATUS_FLAG (bool, was_nonblocking)

  int get_default_fmode (int flags);

  virtual void set_close_on_exec (bool val);

  LPSECURITY_ATTRIBUTES get_inheritance (bool all = 0)
  {
    if (all)
      return close_on_exec () ? &sec_all_nih : &sec_all;
    else
      return close_on_exec () ? &sec_none_nih : &sec_none;
  }

  virtual int fixup_before_fork_exec (DWORD) { return 0; }
  virtual void fixup_after_fork (HANDLE);
  virtual void fixup_after_exec ();
  void create_read_state (LONG n)
  {
    read_state = CreateSemaphore (&sec_none_nih, 0, n, NULL);
    ProtectHandle (read_state);
  }

  void signal_read_state (LONG n)
  {
    ReleaseSemaphore (read_state, n, NULL);
  }

  bool get_readahead_valid () { return raixget < ralen; }
  int puts_readahead (const char *s, size_t len = (size_t) -1);
  int put_readahead (char value);

  int get_readahead ();
  int peek_readahead (int queryput = 0);

  int eat_readahead (int n);

  void set_readahead_valid (int val, int ch = -1);

  int get_readahead_into_buffer (char *buf, size_t buflen);

  bool has_acls () const { return pc.has_acls (); }

  bool isremote () { return pc.isremote (); }

  bool has_attribute (DWORD x) const {return pc.has_attribute (x);}
  const char *get_name () const { return pc.get_posix (); }
  const char *get_win32_name () { return pc.get_win32 (); }
  virtual dev_t get_dev () { return get_device (); }
  ino_t get_ino () { return ino ?: ino = hash_path_name (0, pc.get_nt_native_path ()); }
  long long get_unique_id () const { return unique_id; }
  /* Returns name used for /proc/<pid>/fd in buf. */
  virtual char *get_proc_fd_name (char *buf);

  virtual void hclose (HANDLE h) {CloseHandle (h);}
  virtual void set_no_inheritance (HANDLE &, bool);

  /* fixup fd possibly non-inherited handles after fork */
  bool fork_fixup (HANDLE, HANDLE &, const char *);
  virtual bool need_fixup_before () const {return false;}

  int open_with_arch (int, mode_t = 0);
  int open_null (int flags);
  virtual int open (int, mode_t);
  virtual void open_setup (int flags);
  void set_unique_id () { NtAllocateLocallyUniqueId ((PLUID) &unique_id); }

  int close_with_arch ();
  virtual int close ();
  virtual void cleanup ();
  int _archetype_usecount (const char *fn, int ln, int n)
  {
    if (!archetype)
      return 0;
    archetype->usecount += n;
    if (strace.active ())
      strace.prntf (_STRACE_ALL, fn, "line %d:  %s<%p> usecount + %d = %d", ln, get_name (), archetype, n, archetype->usecount);
    return archetype->usecount;
  }

  int open_fs (int, mode_t = 0);
# define archetype_usecount(n) _archetype_usecount (__PRETTY_FUNCTION__, __LINE__, (n))
  int close_fs () { return fhandler_base::close (); }
  virtual int __reg2 fstat (struct stat *buf);
  void __reg2 stat_fixup (struct stat *buf);
  int __reg2 fstat_fs (struct stat *buf);
private:
  int __reg3 fstat_helper (struct stat *buf,
			      DWORD nNumberOfLinks);
  int __reg2 fstat_by_nfs_ea (struct stat *buf);
  int __reg2 fstat_by_handle (struct stat *buf);
  int __reg2 fstat_by_name (struct stat *buf);
public:
  virtual int __reg2 fstatvfs (struct statvfs *buf);
  int __reg2 utimens_fs (const struct timespec *);
  virtual int __reg1 fchmod (mode_t mode);
  virtual int __reg2 fchown (uid_t uid, gid_t gid);
  virtual int __reg3 facl (int, int, struct acl *);
  virtual ssize_t __reg3 fgetxattr (const char *, void *, size_t);
  virtual int __reg3 fsetxattr (const char *, const void *, size_t, int);
  virtual int __reg3 fadvise (off_t, off_t, int);
  virtual int __reg3 ftruncate (off_t, bool);
  virtual int __reg2 link (const char *);
  virtual int __reg2 utimens (const struct timespec *);
  virtual int __reg1 fsync ();
  virtual int ioctl (unsigned int cmd, void *);
  virtual int fcntl (int cmd, intptr_t);
  virtual char const *ttyname () { return get_name (); }
  virtual void __reg3 read (void *ptr, size_t& len);
  virtual ssize_t __stdcall write (const void *ptr, size_t len);
  virtual ssize_t __stdcall readv (const struct iovec *, int iovcnt, ssize_t tot = -1);
  virtual ssize_t __stdcall writev (const struct iovec *, int iovcnt, ssize_t tot = -1);
  virtual ssize_t __reg3 pread (void *, size_t, off_t);
  virtual ssize_t __reg3 pwrite (void *, size_t, off_t);
  virtual off_t lseek (off_t offset, int whence);
  virtual int lock (int, struct flock *);
  virtual int mand_lock (int, struct flock *);
  virtual int dup (fhandler_base *child, int flags);
  virtual int fpathconf (int);

  virtual HANDLE mmap (caddr_t *addr, size_t len, int prot,
		       int flags, off_t off);
  virtual int munmap (HANDLE h, caddr_t addr, size_t len);
  virtual int msync (HANDLE h, caddr_t addr, size_t len, int flags);
  virtual bool fixup_mmap_after_fork (HANDLE h, int prot, int flags,
				      off_t offset, DWORD size,
				      void *address);

  void *operator new (size_t, void *p) __attribute__ ((nothrow)) {return p;}

  virtual int init (HANDLE, DWORD, mode_t);

  virtual int tcflush (int);
  virtual int tcsendbreak (int);
  virtual int tcdrain ();
  virtual int tcflow (int);
  virtual int tcsetattr (int a, const struct termios *t);
  virtual int tcgetattr (struct termios *t);
  virtual int tcsetpgrp (const pid_t pid);
  virtual int tcgetpgrp ();
  virtual pid_t tcgetsid ();
  virtual bool is_tty () const { return false; }
  virtual bool ispipe () const { return false; }
  virtual pid_t get_popen_pid () const {return 0;}
  virtual bool isdevice () const { return true; }
  virtual bool isfifo () const { return false; }
  virtual int ptsname_r (char *, size_t);
  virtual class fhandler_socket *is_socket () { return NULL; }
  virtual class fhandler_console *is_console () { return 0; }
  virtual int is_windows () {return 0; }

  virtual void __reg3 raw_read (void *ptr, size_t& ulen);
  virtual ssize_t __reg3 raw_write (const void *ptr, size_t ulen);

  /* Virtual accessor functions to hide the fact
     that some fd's have two handles. */
  virtual HANDLE& get_handle () { return io_handle; }
  virtual HANDLE& get_io_handle () { return io_handle; }
  virtual HANDLE& get_output_handle () { return io_handle; }
  virtual HANDLE get_stat_handle () { return pc.handle () ?: io_handle; }
  virtual HANDLE get_echo_handle () const { return NULL; }
  virtual bool hit_eof () {return false;}
  virtual select_record *select_read (select_stuff *);
  virtual select_record *select_write (select_stuff *);
  virtual select_record *select_except (select_stuff *);
  virtual const char *get_native_name ()
  {
    return dev ().native;
  }
  virtual bg_check_types bg_check (int) {return bg_ok;}
  void clear_readahead ()
  {
    raixput = raixget = ralen = rabuflen = 0;
    rabuf = NULL;
  }
  void operator delete (void *p) {cfree (p);}
  virtual void set_eof () {}
  virtual int mkdir (mode_t mode);
  virtual int rmdir ();
  virtual __reg2 DIR *opendir (int fd);
  virtual __reg3 int readdir (DIR *, dirent *);
  virtual long telldir (DIR *);
  virtual void seekdir (DIR *, long);
  virtual void rewinddir (DIR *);
  virtual int closedir (DIR *);
  bool is_auto_device () {return isdevice () && !dev ().isfs ();}
  bool is_fs_special () {return pc.is_fs_special ();}
  bool issymlink () {return pc.issymlink ();}
  bool __reg2 device_access_denied (int);
  int __reg3 fhaccess (int flags, bool);
  virtual bool __reg1 has_ongoing_io ()  {return false;}

  fhandler_base (void *) {}

  virtual void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_base *> (x) = *this;
    x->reset (this);
  }

  virtual fhandler_base *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_base));
    fhandler_base *fh = new (ptr) fhandler_base (ptr);
    copyto (fh);
    return fh;
  }
};

struct wsa_event
{
  LONG serial_number;
  long events;
  int  connect_errorcode;
  pid_t owner;
};

class fhandler_socket: public fhandler_base
{
 private:
  int addr_family;
  int type;
  int connect_secret[4];

  wsa_event *wsock_events;
  HANDLE wsock_mtx;
  HANDLE wsock_evt;
 public:
  bool init_events ();
  int evaluate_events (const long event_mask, long &events, const bool erase);
  const HANDLE wsock_event () const { return wsock_evt; }
  const LONG serial_number () const { return wsock_events->serial_number; }
 private:
  int wait_for_events (const long event_mask, const DWORD flags);
  void release_events ();

  pid_t sec_pid;
  uid_t sec_uid;
  gid_t sec_gid;
  pid_t sec_peer_pid;
  uid_t sec_peer_uid;
  gid_t sec_peer_gid;
  void af_local_set_secret (char *);
  void af_local_setblocking (bool &, bool &);
  void af_local_unsetblocking (bool, bool);
  void af_local_set_cred ();
  void af_local_copy (fhandler_socket *);
  bool af_local_recv_secret ();
  bool af_local_send_secret ();
  bool af_local_recv_cred ();
  bool af_local_send_cred ();
  int af_local_accept ();
 public:
  int af_local_connect ();
  int af_local_set_no_getpeereid ();
  void af_local_set_sockpair_cred ();

 private:
  int	    _rmem;
  int	    _wmem;
 public:
  int &rmem () { return _rmem; }
  int &wmem () { return _wmem; }
  void rmem (int nrmem) { _rmem = nrmem; }
  void wmem (int nwmem) { _wmem = nwmem; }

 private:
  struct _WSAPROTOCOL_INFOW *prot_info_ptr;
 public:
  void init_fixup_before ();
  bool need_fixup_before () const {return prot_info_ptr != NULL;}

 private:
  char *sun_path;
  char *peer_sun_path;
  struct status_flags
  {
    unsigned async_io		   : 1; /* async I/O */
    unsigned saw_shutdown_read     : 1; /* Socket saw a SHUT_RD */
    unsigned saw_shutdown_write    : 1; /* Socket saw a SHUT_WR */
    unsigned saw_reuseaddr	   : 1; /* Socket saw SO_REUSEADDR call */
    unsigned connect_state	   : 3;
    unsigned no_getpeereid	   : 1;
   public:
    status_flags () :
      async_io (0), saw_shutdown_read (0), saw_shutdown_write (0),
      connect_state (unconnected), no_getpeereid (0)
      {}
  } status;

 public:
  fhandler_socket ();
  ~fhandler_socket ();
/* Originally get_socket returned an int, which is not a good idea
   to cast a handle to on 64 bit.  The right type here is very certainly
   SOCKET instead.  On the other hand, we don't want to have to include
   winsock.h just to build fhandler.h.  Therefore we define get_socket
   now only when building network related code. */
#ifdef __INSIDE_CYGWIN_NET__
  SOCKET get_socket () { return (SOCKET) get_handle(); }
#endif
  fhandler_socket *is_socket () { return this; }

  IMPLEMENT_STATUS_FLAG (bool, async_io)
  IMPLEMENT_STATUS_FLAG (bool, saw_shutdown_read)
  IMPLEMENT_STATUS_FLAG (bool, saw_shutdown_write)
  IMPLEMENT_STATUS_FLAG (bool, saw_reuseaddr)
  IMPLEMENT_STATUS_FLAG (conn_state, connect_state)
  IMPLEMENT_STATUS_FLAG (bool, no_getpeereid)

  int bind (const struct sockaddr *name, int namelen);
  int connect (const struct sockaddr *name, int namelen);
  int listen (int backlog);
  int accept4 (struct sockaddr *peer, int *len, int flags);
  int getsockname (struct sockaddr *name, int *namelen);
  int getpeername (struct sockaddr *name, int *namelen);
  int getpeereid (pid_t *pid, uid_t *euid, gid_t *egid);

  int open (int flags, mode_t mode = 0);
  void __reg3 read (void *ptr, size_t& len);
  ssize_t __stdcall readv (const struct iovec *, int iovcnt, ssize_t tot = -1);
  inline ssize_t __reg3 recv_internal (struct _WSAMSG *wsamsg, bool use_recvmsg);
  ssize_t recvfrom (void *ptr, size_t len, int flags,
		    struct sockaddr *from, int *fromlen);
  ssize_t recvmsg (struct msghdr *msg, int flags);

  ssize_t __stdcall write (const void *ptr, size_t len);
  ssize_t __stdcall writev (const struct iovec *, int iovcnt, ssize_t tot = -1);
  inline ssize_t send_internal (struct _WSAMSG *wsamsg, int flags);
  ssize_t sendto (const void *ptr, size_t len, int flags,
	      const struct sockaddr *to, int tolen);
  ssize_t sendmsg (const struct msghdr *msg, int flags);

  int ioctl (unsigned int cmd, void *);
  int fcntl (int cmd, intptr_t);
  off_t lseek (off_t, int)
  { 
    set_errno (ESPIPE);
    return -1;
  }
  int shutdown (int how);
  int close ();
  void hclose (HANDLE) {close ();}
  int dup (fhandler_base *child, int);

  void set_close_on_exec (bool val);
  int fixup_before_fork_exec (DWORD);
  void fixup_after_fork (HANDLE);
  void fixup_after_exec ();
  char *get_proc_fd_name (char *buf);

  select_record *select_read (select_stuff *);
  select_record *select_write (select_stuff *);
  select_record *select_except (select_stuff *);
  void set_addr_family (int af) {addr_family = af;}
  int get_addr_family () {return addr_family;}
  void set_socket_type (int st) { type = st;}
  int get_socket_type () {return type;}
  void set_sun_path (const char *path);
  char *get_sun_path () {return sun_path;}
  void set_peer_sun_path (const char *path);
  char *get_peer_sun_path () {return peer_sun_path;}

  int __reg2 fstat (struct stat *buf);
  int __reg2 fstatvfs (struct statvfs *buf);
  int __reg1 fchmod (mode_t mode);
  int __reg2 fchown (uid_t uid, gid_t gid);
  int __reg3 facl (int, int, struct acl *);
  int __reg2 link (const char *);

  fhandler_socket (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_socket *> (x) = *this;
    x->reset (this);
  }

  fhandler_socket *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_socket));
    fhandler_socket *fh = new (ptr) fhandler_socket (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_base_overlapped: public fhandler_base
{
  static HANDLE asio_done;
  static LONG asio_close_counter;
protected:
  enum wait_return
  {
    overlapped_unknown = 0,
    overlapped_success,
    overlapped_nonblocking_no_data,
    overlapped_nullread,
    overlapped_error
  };
  bool io_pending;
  OVERLAPPED io_status;
  OVERLAPPED *overlapped;
  size_t max_atomic_write;
public:
  wait_return __reg3 wait_overlapped (bool, bool, DWORD *, bool, DWORD = 0);
  int __reg1 setup_overlapped ();
  void __reg1 destroy_overlapped ();
  virtual void __reg3 raw_read (void *ptr, size_t& len);
  virtual ssize_t __reg3 raw_write (const void *ptr, size_t len);
  OVERLAPPED *&get_overlapped () {return overlapped;}
  OVERLAPPED *get_overlapped_buffer () {return &io_status;}
  void set_overlapped (OVERLAPPED *ov) {overlapped = ov;}
  fhandler_base_overlapped (): io_pending (false), overlapped (NULL), max_atomic_write (0)
  {
    memset (&io_status, 0, sizeof io_status);
  }
  bool __reg1 has_ongoing_io ();

  void fixup_after_fork (HANDLE);
  void fixup_after_exec ();

  int close ();
  int dup (fhandler_base *child, int);

  void check_later ();
  static void __reg1 flush_all_async_io ();;

  fhandler_base_overlapped (void *) {}

  virtual void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_base_overlapped *> (x) = *this;
    x->reset (this);
  }

  virtual fhandler_base_overlapped *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_base_overlapped));
    fhandler_base_overlapped *fh = new (ptr) fhandler_base_overlapped (ptr);
    copyto (fh);
    return fh;
  }

  friend DWORD WINAPI flush_async_io (void *);
};

class fhandler_pipe: public fhandler_base_overlapped
{
private:
  pid_t popen_pid;
public:
  fhandler_pipe ();


  bool ispipe() const { return true; }

  void set_popen_pid (pid_t pid) {popen_pid = pid;}
  pid_t get_popen_pid () const {return popen_pid;}
  off_t lseek (off_t offset, int whence);
  select_record *select_read (select_stuff *);
  select_record *select_write (select_stuff *);
  select_record *select_except (select_stuff *);
  char *get_proc_fd_name (char *buf);
  int open (int flags, mode_t mode = 0);
  int dup (fhandler_base *child, int);
  int ioctl (unsigned int cmd, void *);
  int __reg2 fstatvfs (struct statvfs *buf);
  int __reg3 fadvise (off_t, off_t, int);
  int __reg3 ftruncate (off_t, bool);
  int init (HANDLE, DWORD, mode_t);
  static int create (fhandler_pipe *[2], unsigned, int);
  static DWORD create (LPSECURITY_ATTRIBUTES, HANDLE *, HANDLE *, DWORD,
		       const char *, DWORD);
  fhandler_pipe (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_pipe *> (x) = *this;
    x->reset (this);
  }

  fhandler_pipe *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_pipe));
    fhandler_pipe *fh = new (ptr) fhandler_pipe (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_fifo: public fhandler_base_overlapped
{
  HANDLE read_ready;
  HANDLE write_ready;
  bool __reg2 wait (HANDLE);
  char __reg2 *fifo_name (char *, const char *);
public:
  fhandler_fifo ();
  int open (int, mode_t);
  int close ();
  int dup (fhandler_base *child, int);
  bool isfifo () const { return true; }
  void set_close_on_exec (bool val);
  void __reg3 raw_read (void *ptr, size_t& ulen);
  bool arm (HANDLE h);
  void fixup_after_fork (HANDLE);
  int __reg2 fstatvfs (struct statvfs *buf);
  select_record *select_read (select_stuff *);
  select_record *select_write (select_stuff *);
  select_record *select_except (select_stuff *);

  fhandler_fifo (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_fifo *> (x) = *this;
    x->reset (this);
  }

  fhandler_fifo *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_fifo));
    fhandler_fifo *fh = new (ptr) fhandler_fifo (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_mailslot : public fhandler_base_overlapped
{
  POBJECT_ATTRIBUTES get_object_attr (OBJECT_ATTRIBUTES &, PUNICODE_STRING, int);
 public:
  fhandler_mailslot ();
  int __reg2 fstat (struct stat *buf);
  int open (int flags, mode_t mode = 0);
  ssize_t __reg3 raw_write (const void *, size_t);
  int ioctl (unsigned int cmd, void *);
  select_record *select_read (select_stuff *);

  fhandler_mailslot (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_mailslot *> (x) = *this;
    x->reset (this);
  }

  fhandler_mailslot *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_mailslot));
    fhandler_mailslot *fh = new (ptr) fhandler_mailslot (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_dev_raw: public fhandler_base
{
 protected:
  char *devbufalloc;
  char *devbuf;
  DWORD devbufalign;
  DWORD devbufsiz;
  DWORD devbufstart;
  DWORD devbufend;
  struct status_flags
  {
    unsigned lastblk_to_read : 1;
   public:
    status_flags () : lastblk_to_read (0) {}
  } status;

  IMPLEMENT_STATUS_FLAG (bool, lastblk_to_read)

  fhandler_dev_raw ();

 public:
  ~fhandler_dev_raw ();

  int open (int flags, mode_t mode = 0);

  int __reg2 fstat (struct stat *buf);

  int dup (fhandler_base *child, int);
  int ioctl (unsigned int cmd, void *buf);

  void fixup_after_fork (HANDLE);
  void fixup_after_exec ();

  fhandler_dev_raw (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_dev_raw *> (x) = *this;
    x->reset (this);
  }

  fhandler_dev_raw *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_dev_raw));
    fhandler_dev_raw *fh = new (ptr) fhandler_dev_raw (ptr);
    copyto (fh);
    return fh;
  }
};

#define MAX_PARTITIONS 15

struct part_t
{
  LONG refcnt;
  HANDLE hdl[MAX_PARTITIONS];
};

class fhandler_dev_floppy: public fhandler_dev_raw
{
 private:
  off_t drive_size;
  part_t *partitions;
  struct status_flags
  {
    unsigned eom_detected    : 1;
   public:
    status_flags () : eom_detected (0) {}
  } status;

  IMPLEMENT_STATUS_FLAG (bool, eom_detected)

  inline off_t get_current_position ();
  int get_drive_info (struct hd_geometry *geo);

  int lock_partition (DWORD to_write);

  BOOL write_file (const void *buf, DWORD to_write, DWORD *written, int *err);
  BOOL read_file (void *buf, DWORD to_read, DWORD *read, int *err);

 public:
  fhandler_dev_floppy ();

  int open (int flags, mode_t mode = 0);
  int close ();
  int dup (fhandler_base *child, int);
  void __reg3 raw_read (void *ptr, size_t& ulen);
  ssize_t __reg3 raw_write (const void *ptr, size_t ulen);
  off_t lseek (off_t offset, int whence);
  int ioctl (unsigned int cmd, void *buf);

  fhandler_dev_floppy (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_dev_floppy *> (x) = *this;
    x->reset (this);
  }

  fhandler_dev_floppy *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_dev_floppy));
    fhandler_dev_floppy *fh = new (ptr) fhandler_dev_floppy (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_dev_tape: public fhandler_dev_raw
{
  HANDLE mt_mtx;
  OVERLAPPED ov;

  bool is_rewind_device () { return get_minor () < 128; }
  unsigned int driveno () { return (unsigned int) get_minor () & 0x7f; }
  void drive_init ();

  inline bool _lock (bool);
  inline int unlock (int ret = 0);

 public:
  fhandler_dev_tape ();

  int open (int flags, mode_t mode = 0);
  virtual int close ();

  void __reg3 raw_read (void *ptr, size_t& ulen);
  ssize_t __reg3 raw_write (const void *ptr, size_t ulen);

  virtual off_t lseek (off_t offset, int whence);

  virtual int __reg2 fstat (struct stat *buf);

  virtual int dup (fhandler_base *child, int);
  virtual void fixup_after_fork (HANDLE parent);
  virtual void set_close_on_exec (bool val);
  virtual int ioctl (unsigned int cmd, void *buf);

  fhandler_dev_tape (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_dev_tape *> (x) = *this;
    x->reset (this);
  }

  fhandler_dev_tape *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_dev_tape));
    fhandler_dev_tape *fh = new (ptr) fhandler_dev_tape (ptr);
    copyto (fh);
    return fh;
  }
};

/* Standard disk file */

class fhandler_disk_file: public fhandler_base
{
  HANDLE prw_handle;
  int __reg3 readdir_helper (DIR *, dirent *, DWORD, DWORD, PUNICODE_STRING fname);

  int prw_open (bool);

 public:
  fhandler_disk_file ();
  fhandler_disk_file (path_conv &pc);

  int open (int flags, mode_t mode);
  int close ();
  int fcntl (int cmd, intptr_t);
  int dup (fhandler_base *child, int);
  void fixup_after_fork (HANDLE parent);
  int mand_lock (int, struct flock *);
  bool isdevice () const { return false; }
  int __reg2 fstat (struct stat *buf);
  int __reg1 fchmod (mode_t mode);
  int __reg2 fchown (uid_t uid, gid_t gid);
  int __reg3 facl (int, int, struct acl *);
  ssize_t __reg3 fgetxattr (const char *, void *, size_t);
  int __reg3 fsetxattr (const char *, const void *, size_t, int);
  int __reg3 fadvise (off_t, off_t, int);
  int __reg3 ftruncate (off_t, bool);
  int __reg2 link (const char *);
  int __reg2 utimens (const struct timespec *);
  int __reg2 fstatvfs (struct statvfs *buf);

  HANDLE mmap (caddr_t *addr, size_t len, int prot, int flags, off_t off);
  int munmap (HANDLE h, caddr_t addr, size_t len);
  int msync (HANDLE h, caddr_t addr, size_t len, int flags);
  bool fixup_mmap_after_fork (HANDLE h, int prot, int flags,
			      off_t offset, DWORD size, void *address);
  int mkdir (mode_t mode);
  int rmdir ();
  DIR __reg2 *opendir (int fd);
  int __reg3 readdir (DIR *, dirent *);
  long telldir (DIR *);
  void seekdir (DIR *, long);
  void rewinddir (DIR *);
  int closedir (DIR *);

  ssize_t __reg3 pread (void *, size_t, off_t);
  ssize_t __reg3 pwrite (void *, size_t, off_t);

  fhandler_disk_file (void *) {}
  dev_t get_dev () { return pc.fs_serial_number (); }

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_disk_file *> (x) = *this;
    x->reset (this);
  }

  fhandler_disk_file *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_disk_file));
    fhandler_disk_file *fh = new (ptr) fhandler_disk_file (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_dev: public fhandler_disk_file
{
  const struct device *devidx;
  bool dir_exists;
public:
  fhandler_dev ();
  int open (int flags, mode_t mode);
  int close ();
  int __reg2 fstat (struct stat *buf);
  int __reg2 fstatvfs (struct statvfs *buf);
  DIR __reg2 *opendir (int fd);
  int __reg3 readdir (DIR *, dirent *);
  void rewinddir (DIR *);

  fhandler_dev (void *) {}
  dev_t get_dev () { return dir_exists ? pc.fs_serial_number ()
				       : get_device (); }

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_dev *> (x) = *this;
    x->reset (this);
  }

  fhandler_dev *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_dev));
    fhandler_dev *fh = new (ptr) fhandler_dev (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_cygdrive: public fhandler_disk_file
{
  enum
  {
    DRVSZ = sizeof ("x:\\")
  };
  int ndrives;
  const char *pdrive;
  char pdrive_buf[1 + (2 * 26 * DRVSZ)];
  void set_drives ();
 public:
  fhandler_cygdrive ();
  int open (int flags, mode_t mode);
  DIR __reg2 *opendir (int fd);
  int __reg3 readdir (DIR *, dirent *);
  void rewinddir (DIR *);
  int closedir (DIR *);
  int __reg2 fstat (struct stat *buf);
  int __reg2 fstatvfs (struct statvfs *buf);

  fhandler_cygdrive (void *) {}
  dev_t get_dev () { return get_device (); }

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_cygdrive *> (x) = *this;
    x->reset (this);
  }

  fhandler_cygdrive *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_cygdrive));
    fhandler_cygdrive *fh = new (ptr) fhandler_cygdrive (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_serial: public fhandler_base
{
 private:
  size_t vmin_;				/* from termios */
  unsigned int vtime_;			/* from termios */
  pid_t pgrp_;
  int rts;				/* for Windows 9x purposes only */
  int dtr;				/* for Windows 9x purposes only */

 public:
  int overlapped_armed;
  OVERLAPPED io_status;
  DWORD ev;

  /* Constructor */
  fhandler_serial ();

  int open (int flags, mode_t mode);
  int close ();
  int init (HANDLE h, DWORD a, mode_t flags);
  void overlapped_setup ();
  int dup (fhandler_base *child, int);
  void __reg3 raw_read (void *ptr, size_t& ulen);
  ssize_t __reg3 raw_write (const void *ptr, size_t ulen);
  int tcsendbreak (int);
  int tcdrain ();
  int tcflow (int);
  int ioctl (unsigned int cmd, void *);
  int switch_modem_lines (int set, int clr);
  int tcsetattr (int a, const struct termios *t);
  int tcgetattr (struct termios *t);
  off_t lseek (off_t, int)
  { 
    set_errno (ESPIPE);
    return -1;
  }
  int tcflush (int);
  bool is_tty () const { return true; }
  void fixup_after_fork (HANDLE parent);
  void fixup_after_exec ();

  /* We maintain a pgrp so that tcsetpgrp and tcgetpgrp work, but we
     don't use it for permissions checking.  fhandler_pty_slave does
     permission checking on pgrps.  */
  virtual int tcgetpgrp () { return pgrp_; }
  virtual int tcsetpgrp (const pid_t pid) { pgrp_ = pid; return 0; }
  select_record *select_read (select_stuff *);
  select_record *select_write (select_stuff *);
  select_record *select_except (select_stuff *);

  fhandler_serial (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_serial *> (x) = *this;
    x->reset (this);
  }

  fhandler_serial *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_serial));
    fhandler_serial *fh = new (ptr) fhandler_serial (ptr);
    copyto (fh);
    return fh;
  }
};

#define acquire_output_mutex(ms) \
  __acquire_output_mutex (__PRETTY_FUNCTION__, __LINE__, ms)

#define release_output_mutex() \
  __release_output_mutex (__PRETTY_FUNCTION__, __LINE__)

class tty;
class tty_min;
class fhandler_termios: public fhandler_base
{
 private:
  HANDLE output_handle;
 protected:
  virtual void doecho (const void *, DWORD) {};
  virtual int accept_input () {return 1;};
  int ioctl (int, void *);
  tty_min *_tc;
  tty *get_ttyp () {return (tty *) tc ();}
 public:
  tty_min*& tc () {return _tc;}
  fhandler_termios () :
  fhandler_base ()
  {
    need_fork_fixup (true);
  }
  HANDLE& get_output_handle () { return output_handle; }
  line_edit_status line_edit (const char *rptr, size_t nread, termios&,
			      ssize_t *bytes_read = NULL);
  void set_output_handle (HANDLE h) { output_handle = h; }
  void tcinit (bool force);
  bool is_tty () const { return true; }
  void sigflush ();
  int tcgetpgrp ();
  int tcsetpgrp (int pid);
  bg_check_types bg_check (int sig);
  virtual DWORD __acquire_output_mutex (const char *fn, int ln, DWORD ms) {return 1;}
  virtual void __release_output_mutex (const char *fn, int ln) {}
  void echo_erase (int force = 0);
  virtual off_t lseek (off_t, int);
  pid_t tcgetsid ();

  fhandler_termios (void *) {}

  virtual void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_termios *> (x) = *this;
    x->reset (this);
  }

  virtual fhandler_termios *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_termios));
    fhandler_termios *fh = new (ptr) fhandler_termios (ptr);
    copyto (fh);
    return fh;
  }
};

enum ansi_intensity
{
  INTENSITY_INVISIBLE,
  INTENSITY_DIM,
  INTENSITY_NORMAL,
  INTENSITY_BOLD
};

#define normal 0
#define gotesc 1
#define gotsquare 2
#define gotarg1 3
#define gotrsquare 4
#define gotcommand 5
#define gettitle 6
#define eattitle 7
#define gotparen 8
#define gotrparen 9
#define MAXARGS 10

enum cltype
{
  cl_curr_pos = 1,
  cl_disp_beg,
  cl_disp_end,
  cl_buf_beg,
  cl_buf_end
};

class dev_console
{
  WORD default_color, underline_color, dim_color;

  /* Used to determine if an input keystroke should be modified with META. */
  int meta_mask;

/* Output state */
  int state;
  int args[MAXARGS];
  int nargs;
  unsigned rarg;
  bool saw_question_mark;
  bool saw_greater_than_sign;
  bool saw_space;
  bool vt100_graphics_mode_G0;
  bool vt100_graphics_mode_G1;
  bool iso_2022_G1;
  bool alternate_charset_active;
  bool metabit;
  char backspace_keycode;

  char my_title_buf [TITLESIZE + 1];

  WORD current_win32_attr;
  ansi_intensity intensity;
  bool underline, blink, reverse;
  WORD fg, bg;

  /* saved cursor coordinates */
  int savex, savey;


  struct
    {
      short Top;
      short Bottom;
    } scroll_region;

  CONSOLE_SCREEN_BUFFER_INFO b;
  COORD dwWinSize;
  COORD dwEnd;

  /* saved screen */
  COORD save_bufsize;
  PCHAR_INFO save_buf;
  COORD save_cursor;
  SHORT save_top;

  COORD dwLastCursorPosition;
  COORD dwMousePosition;	/* scroll-adjusted coord of mouse event */
  COORD dwLastMousePosition;	/* scroll-adjusted coord of previous mouse event */
  DWORD dwLastButtonState;	/* (not noting mouse wheel events) */
  int last_button_code;		/* transformed mouse report button code */
  int nModifiers;

  bool insert_mode;
  int use_mouse;
  bool ext_mouse_mode5;
  bool ext_mouse_mode6;
  bool ext_mouse_mode15;
  bool use_focus;
  bool raw_win32_keyboard_mode;

  inline UINT get_console_cp ();
  DWORD con_to_str (char *d, int dlen, WCHAR w);
  DWORD str_to_con (mbtowc_p, const char *, PWCHAR d, const char *s, DWORD sz);
  void set_color (HANDLE);
  void set_default_attr ();
  int set_cl_x (cltype);
  int set_cl_y (cltype);
  bool fillin (HANDLE);
  bool __reg3 scroll_window (HANDLE, int, int, int, int);
  void __reg3 scroll_buffer (HANDLE, int, int, int, int, int, int);
  void __reg3 clear_screen (HANDLE, int, int, int, int);
  void __reg3 save_restore (HANDLE, char);

  friend class fhandler_console;
};

/* This is a input and output console handle */
class fhandler_console: public fhandler_termios
{
public:
  struct console_state
  {
    tty_min tty_min_state;
    dev_console con;
  };
private:
  static const unsigned MAX_WRITE_CHARS;
  static console_state *shared_console_info;
  static bool invisible_console;

  /* Used when we encounter a truncated multi-byte sequence.  The
     lead bytes are stored here and revisited in the next write call. */
  struct {
    int len;
    unsigned char buf[4]; /* Max len of valid UTF-8 sequence. */
  } trunc_buf;
  PWCHAR write_buf;

/* Output calls */
  void set_default_attr ();

  void scroll_buffer (int, int, int, int, int, int);
  void scroll_buffer_screen (int, int, int, int, int, int);
  void __reg3 clear_screen (cltype, cltype, cltype, cltype);
  void __reg3 cursor_set (bool, int, int);
  void __reg3 cursor_get (int *, int *);
  void __reg3 cursor_rel (int, int);
  inline void write_replacement_char ();
  inline bool write_console (PWCHAR, DWORD, DWORD&);
  const unsigned char *write_normal (unsigned const char*, unsigned const char *);
  void char_command (char);
  bool set_raw_win32_keyboard_mode (bool);
  int output_tcsetattr (int a, const struct termios *t);

/* Input calls */
  int igncr_enabled ();
  int input_tcsetattr (int a, const struct termios *t);
  void set_cursor_maybe ();
  static bool create_invisible_console (HWINSTA);
  static bool create_invisible_console_workaround ();
  static console_state *open_shared_console (HWND, HANDLE&, bool&);

 public:
  static pid_t tc_getpgid ()
  {
    return shared_console_info ? shared_console_info->tty_min_state.getpgid () : myself->pgid;
  }
  fhandler_console (fh_devices);
  static console_state *open_shared_console (HWND hw, HANDLE& h)
  {
    bool createit = false;
    return open_shared_console (hw, h, createit);
  }

  fhandler_console* is_console () { return this; }

  bool use_archetype () const {return true;}

  int open (int flags, mode_t mode);
  void open_setup (int flags);
  int dup (fhandler_base *, int);

  void __reg3 read (void *ptr, size_t& len);
  ssize_t __stdcall write (const void *ptr, size_t len);
  void doecho (const void *str, DWORD len) { (void) write (str, len); }
  int close ();
  static bool exists () {return !!GetConsoleCP ();}

  int tcflush (int);
  int tcsetattr (int a, const struct termios *t);
  int tcgetattr (struct termios *t);

  int ioctl (unsigned int cmd, void *);
  int init (HANDLE, DWORD, mode_t);
  bool mouse_aware (MOUSE_EVENT_RECORD& mouse_event);
  bool focus_aware () {return shared_console_info->con.use_focus;}

  select_record *select_read (select_stuff *);
  select_record *select_write (select_stuff *);
  select_record *select_except (select_stuff *);
  void fixup_after_fork_exec (bool);
  void fixup_after_exec () {fixup_after_fork_exec (true);}
  void fixup_after_fork (HANDLE) {fixup_after_fork_exec (false);}
  void set_close_on_exec (bool val);
  void set_input_state ();
  void send_winch_maybe ();
  void setup ();
  bool set_unit ();
  static bool need_invisible ();
  static void free_console ();

  fhandler_console (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_console *> (x) = *this;
    x->reset (this);
  }

  fhandler_console *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_console));
    fhandler_console *fh = new (ptr) fhandler_console (ptr);
    copyto (fh);
    return fh;
  }
  friend tty_min * tty_list::get_cttyp ();
};

class fhandler_pty_common: public fhandler_termios
{
 public:
  fhandler_pty_common ()
    : fhandler_termios (),
      output_mutex (NULL),
    input_mutex (NULL), input_available_event (NULL)
  {
    pc.file_attributes (FILE_ATTRIBUTE_NORMAL);
  }
  static const unsigned pipesize = 128 * 1024;
  HANDLE output_mutex, input_mutex;
  HANDLE input_available_event;

  bool use_archetype () const {return true;}
  DWORD __acquire_output_mutex (const char *fn, int ln, DWORD ms);
  void __release_output_mutex (const char *fn, int ln);

  int close ();
  off_t lseek (off_t, int);
  bool bytes_available (DWORD& n);
  void set_close_on_exec (bool val);
  select_record *select_read (select_stuff *);
  select_record *select_write (select_stuff *);
  select_record *select_except (select_stuff *);

  fhandler_pty_common (void *) {}

  virtual void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_pty_common *> (x) = *this;
    x->reset (this);
  }

  virtual fhandler_pty_common *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_pty_common));
    fhandler_pty_common *fh = new (ptr) fhandler_pty_common (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_pty_slave: public fhandler_pty_common
{
  HANDLE inuse;			// used to indicate that a tty is in use

  /* Helper functions for fchmod and fchown. */
  bool fch_open_handles (bool chown);
  int fch_set_sd (security_descriptor &sd, bool chown);
  void fch_close_handles ();

 public:
  /* Constructor */
  fhandler_pty_slave (int);

  int open (int flags, mode_t mode = 0);
  void open_setup (int flags);
  ssize_t __stdcall write (const void *ptr, size_t len);
  void __reg3 read (void *ptr, size_t& len);
  int init (HANDLE, DWORD, mode_t);

  int tcsetattr (int a, const struct termios *t);
  int tcgetattr (struct termios *t);
  int tcflush (int);
  int ioctl (unsigned int cmd, void *);
  int close ();
  void cleanup ();
  int dup (fhandler_base *child, int);
  void fixup_after_fork (HANDLE parent);
  void fixup_after_exec ();

  select_record *select_read (select_stuff *);
  virtual char const *ttyname () { return pc.dev.name; }
  int __reg2 fstat (struct stat *buf);
  int __reg1 fchmod (mode_t mode);
  int __reg2 fchown (uid_t uid, gid_t gid);

  fhandler_pty_slave (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_pty_slave *> (x) = *this;
    x->reset (this);
  }

  fhandler_pty_slave *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_pty_slave));
    fhandler_pty_slave *fh = new (ptr) fhandler_pty_slave (ptr);
    copyto (fh);
    return fh;
  }
};

#define __ptsname(buf, unit) __small_sprintf ((buf), "/dev/pty%d", (unit))
class fhandler_pty_master: public fhandler_pty_common
{
  int pktmode;			// non-zero if pty in a packet mode.
  HANDLE master_ctl;		// Control socket for handle duplication
  cygthread *master_thread;	// Master control thread
  HANDLE from_master, to_master;
  HANDLE echo_r, echo_w;
  DWORD dwProcessId;		// Owner of master handles

public:
  int need_nl;			// Next read should start with \n

  HANDLE get_echo_handle () const { return echo_r; }
  /* Constructor */
  fhandler_pty_master (int);

  DWORD pty_master_thread ();
  int process_slave_output (char *buf, size_t len, int pktmode_on);
  void doecho (const void *str, DWORD len);
  int accept_input ();
  int open (int flags, mode_t mode = 0);
  void open_setup (int flags);
  ssize_t __stdcall write (const void *ptr, size_t len);
  void __reg3 read (void *ptr, size_t& len);
  int close ();
  void cleanup ();

  int tcsetattr (int a, const struct termios *t);
  int tcgetattr (struct termios *t);
  int tcflush (int);
  int ioctl (unsigned int cmd, void *);

  int ptsname_r (char *, size_t);

  bool hit_eof ();
  bool setup ();
  int dup (fhandler_base *, int);
  void fixup_after_fork (HANDLE parent);
  void fixup_after_exec ();
  int tcgetpgrp ();
  void flush_to_slave ();

  fhandler_pty_master (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_pty_master *> (x) = *this;
    x->reset (this);
  }

  fhandler_pty_master *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_pty_master));
    fhandler_pty_master *fh = new (ptr) fhandler_pty_master (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_dev_null: public fhandler_base
{
 public:
  fhandler_dev_null ();

  select_record *select_read (select_stuff *);
  select_record *select_write (select_stuff *);
  select_record *select_except (select_stuff *);

  fhandler_dev_null (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_dev_null *> (x) = *this;
    x->reset (this);
  }

  fhandler_dev_null *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_dev_null));
    fhandler_dev_null *fh = new (ptr) fhandler_dev_null (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_dev_zero: public fhandler_base
{
 public:
  fhandler_dev_zero ();
  ssize_t __stdcall write (const void *ptr, size_t len);
  void __reg3 read (void *ptr, size_t& len);
  off_t lseek (off_t, int) { return 0; }

  virtual HANDLE mmap (caddr_t *addr, size_t len, int prot,
		       int flags, off_t off);
  virtual int munmap (HANDLE h, caddr_t addr, size_t len);
  virtual int msync (HANDLE h, caddr_t addr, size_t len, int flags);
  virtual bool fixup_mmap_after_fork (HANDLE h, int prot, int flags,
				      off_t offset, DWORD size,
				      void *address);

  fhandler_dev_zero (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_dev_zero *> (x) = *this;
    x->reset (this);
  }

  fhandler_dev_zero *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_dev_zero));
    fhandler_dev_zero *fh = new (ptr) fhandler_dev_zero (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_dev_random: public fhandler_base
{
 protected:
  uint32_t pseudo;

  int pseudo_write (const void *ptr, size_t len);
  int pseudo_read (void *ptr, size_t len);

 public:
  ssize_t __stdcall write (const void *ptr, size_t len);
  void __reg3 read (void *ptr, size_t& len);
  off_t lseek (off_t, int) { return 0; }

  static bool crypt_gen_random (void *ptr, size_t len);

  fhandler_dev_random () : fhandler_base () {}
  fhandler_dev_random (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_dev_random *> (x) = *this;
    x->reset (this);
  }

  fhandler_dev_random *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_dev_random));
    fhandler_dev_random *fh = new (ptr) fhandler_dev_random (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_dev_clipboard: public fhandler_base
{
  UINT cygnativeformat;
  off_t pos;
  void *membuffer;
  size_t msize;
  int set_clipboard (const void *buf, size_t len);

 public:
  fhandler_dev_clipboard ();
  int is_windows () { return 1; }
  int __reg2 fstat (struct stat *buf);
  ssize_t __stdcall write (const void *ptr, size_t len);
  void __reg3 read (void *ptr, size_t& len);
  off_t lseek (off_t offset, int whence);
  int close ();

  int dup (fhandler_base *child, int);
  void fixup_after_exec ();

  fhandler_dev_clipboard (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_dev_clipboard *> (x) = *this;
    x->reset (this);
  }

  fhandler_dev_clipboard *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_dev_clipboard));
    fhandler_dev_clipboard *fh = new (ptr) fhandler_dev_clipboard (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_windows: public fhandler_base
{
 private:
  HWND hWnd_;	// the window whose messages are to be retrieved by read() call
  int method_;  // write method (Post or Send)
 public:
  fhandler_windows ();
  int is_windows () { return 1; }
  HWND get_hwnd () { return hWnd_; }
  int open (int flags, mode_t mode = 0);
  ssize_t __stdcall write (const void *ptr, size_t len);
  void __reg3 read (void *ptr, size_t& len);
  int ioctl (unsigned int cmd, void *);
  off_t lseek (off_t, int) { return 0; }
  int close () { return 0; }

  select_record *select_read (select_stuff *);
  select_record *select_write (select_stuff *);
  select_record *select_except (select_stuff *);

  fhandler_windows (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_windows *> (x) = *this;
    x->reset (this);
  }

  fhandler_windows *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_windows));
    fhandler_windows *fh = new (ptr) fhandler_windows (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_dev_dsp: public fhandler_base
{
 public:
  class Audio;
  class Audio_out;
  class Audio_in;
 private:
  int audioformat_;
  int audiofreq_;
  int audiobits_;
  int audiochannels_;
  Audio_out *audio_out_;
  Audio_in  *audio_in_;
 public:
  fhandler_dev_dsp ();
  fhandler_dev_dsp *base () const {return (fhandler_dev_dsp *)archetype;}

  int open (int, mode_t mode = 0);
  ssize_t __stdcall write (const void *, size_t);
  void __reg3 read (void *, size_t&);
  int ioctl (unsigned int, void *);
  int close ();
  void fixup_after_fork (HANDLE);
  void fixup_after_exec ();

 private:
  ssize_t __stdcall _write (const void *, size_t);
  void __reg3 _read (void *, size_t&);
  int _ioctl (unsigned int, void *);
  void _fixup_after_fork (HANDLE);
  void _fixup_after_exec ();

  void __reg1 close_audio_in ();
  void __reg2 close_audio_out (bool = false);
  bool use_archetype () const {return true;}

  fhandler_dev_dsp (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_dev_dsp *> (x) = *this;
    x->reset (this);
  }

  fhandler_dev_dsp *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_dev_dsp));
    fhandler_dev_dsp *fh = new (ptr) fhandler_dev_dsp (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_virtual : public fhandler_base
{
 protected:
  char *filebuf;
  off_t filesize;
  off_t position;
  int fileid; // unique within each class
 public:

  fhandler_virtual ();
  virtual ~fhandler_virtual();

  virtual virtual_ftype_t exists();
  DIR __reg2 *opendir (int fd);
  long telldir (DIR *);
  void seekdir (DIR *, long);
  void rewinddir (DIR *);
  int closedir (DIR *);
  ssize_t __stdcall write (const void *ptr, size_t len);
  void __reg3 read (void *ptr, size_t& len);
  off_t lseek (off_t, int);
  int dup (fhandler_base *child, int);
  int open (int flags, mode_t mode = 0);
  int close ();
  int __reg2 fstatvfs (struct statvfs *buf);
  int __reg1 fchmod (mode_t mode);
  int __reg2 fchown (uid_t uid, gid_t gid);
  int __reg3 facl (int, int, struct acl *);
  virtual bool fill_filebuf ();
  char *get_filebuf () { return filebuf; }
  void fixup_after_exec ();

  fhandler_virtual (void *) {}

  virtual void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_virtual *> (x) = *this;
    x->reset (this);
  }

  virtual fhandler_virtual *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_virtual));
    fhandler_virtual *fh = new (ptr) fhandler_virtual (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_proc: public fhandler_virtual
{
 public:
  fhandler_proc ();
  virtual_ftype_t exists();
  DIR __reg2 *opendir (int fd);
  int closedir (DIR *);
  int __reg3 readdir (DIR *, dirent *);
  static fh_devices get_proc_fhandler (const char *path);

  int open (int flags, mode_t mode = 0);
  int __reg2 fstat (struct stat *buf);
  bool fill_filebuf ();

  fhandler_proc (void *) {}

  virtual void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_proc *> (x) = *this;
    x->reset (this);
  }

  virtual fhandler_proc *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_proc));
    fhandler_proc *fh = new (ptr) fhandler_proc (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_procsys: public fhandler_virtual
{
 public:
  fhandler_procsys ();
  virtual_ftype_t __reg2 exists(struct stat *buf);
  virtual_ftype_t exists();
  DIR __reg2 *opendir (int fd);
  int __reg3 readdir (DIR *, dirent *);
  long telldir (DIR *);
  void seekdir (DIR *, long);
  int closedir (DIR *);
  int open (int flags, mode_t mode = 0);
  int close ();
  void __reg3 read (void *ptr, size_t& len);
  ssize_t __stdcall write (const void *ptr, size_t len);
  int __reg2 fstat (struct stat *buf);
  bool fill_filebuf ();

  fhandler_procsys (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_procsys *> (x) = *this;
    x->reset (this);
  }

  fhandler_procsys *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_procsys));
    fhandler_procsys *fh = new (ptr) fhandler_procsys (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_procsysvipc: public fhandler_proc
{
  pid_t pid;
 public:
  fhandler_procsysvipc ();
  virtual_ftype_t exists();
  int __reg3 readdir (DIR *, dirent *);
  int open (int flags, mode_t mode = 0);
  int __reg2 fstat (struct stat *buf);
  bool fill_filebuf ();

  fhandler_procsysvipc (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_procsysvipc *> (x) = *this;
    x->reset (this);
  }

  fhandler_procsysvipc *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_procsysvipc));
    fhandler_procsysvipc *fh = new (ptr) fhandler_procsysvipc (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_netdrive: public fhandler_virtual
{
 public:
  fhandler_netdrive ();
  virtual_ftype_t exists();
  int __reg3 readdir (DIR *, dirent *);
  void seekdir (DIR *, long);
  void rewinddir (DIR *);
  int closedir (DIR *);
  int open (int flags, mode_t mode = 0);
  int close ();
  int __reg2 fstat (struct stat *buf);

  fhandler_netdrive (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_netdrive *> (x) = *this;
    x->reset (this);
  }

  fhandler_netdrive *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_netdrive));
    fhandler_netdrive *fh = new (ptr) fhandler_netdrive (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_registry: public fhandler_proc
{
 private:
  wchar_t *value_name;
  DWORD wow64;
  int prefix_len;
 public:
  fhandler_registry ();
  void set_name (path_conv &pc);
  virtual_ftype_t exists();
  DIR __reg2 *opendir (int fd);
  int __reg3 readdir (DIR *, dirent *);
  long telldir (DIR *);
  void seekdir (DIR *, long);
  void rewinddir (DIR *);
  int closedir (DIR *);

  int open (int flags, mode_t mode = 0);
  int __reg2 fstat (struct stat *buf);
  bool fill_filebuf ();
  int close ();
  int dup (fhandler_base *child, int);

  fhandler_registry (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_registry *> (x) = *this;
    x->reset (this);
  }

  fhandler_registry *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_registry));
    fhandler_registry *fh = new (ptr) fhandler_registry (ptr);
    copyto (fh);
    return fh;
  }
};

class pinfo;
class fhandler_process: public fhandler_proc
{
  pid_t pid;
  virtual_ftype_t fd_type;
 public:
  fhandler_process ();
  virtual_ftype_t exists();
  DIR __reg2 *opendir (int fd);
  int closedir (DIR *);
  int __reg3 readdir (DIR *, dirent *);
  int open (int flags, mode_t mode = 0);
  int __reg2 fstat (struct stat *buf);
  bool fill_filebuf ();

  fhandler_process (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_process *> (x) = *this;
    x->reset (this);
  }

  fhandler_process *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_process));
    fhandler_process *fh = new (ptr) fhandler_process (ptr);
    copyto (fh);
    return fh;
  }
};

class fhandler_procnet: public fhandler_proc
{
  pid_t pid;
 public:
  fhandler_procnet ();
  virtual_ftype_t exists();
  int __reg3 readdir (DIR *, dirent *);
  int open (int flags, mode_t mode = 0);
  int __reg2 fstat (struct stat *buf);
  bool fill_filebuf ();

  fhandler_procnet (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_procnet *> (x) = *this;
    x->reset (this);
  }

  fhandler_procnet *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_procnet));
    fhandler_procnet *fh = new (ptr) fhandler_procnet (ptr);
    copyto (fh);
    return fh;
  }
};

struct fhandler_nodevice: public fhandler_base
{
  fhandler_nodevice ();
  int open (int flags, mode_t mode = 0);
};

#define report_tty_counts(fh, call, use_op) \
  termios_printf ("%s %s, %susecount %d",\
		  fh->ttyname (), call,\
		  use_op, ((fhandler_pty_slave *) (fh->archetype ?: fh))->usecount);

typedef union
{
  char __base[sizeof (fhandler_base)];
  char __console[sizeof (fhandler_console)];
  char __dev[sizeof (fhandler_dev)];
  char __cygdrive[sizeof (fhandler_cygdrive)];
  char __dev_clipboard[sizeof (fhandler_dev_clipboard)];
  char __dev_dsp[sizeof (fhandler_dev_dsp)];
  char __dev_floppy[sizeof (fhandler_dev_floppy)];
  char __dev_null[sizeof (fhandler_dev_null)];
  char __dev_random[sizeof (fhandler_dev_random)];
  char __dev_raw[sizeof (fhandler_dev_raw)];
  char __dev_tape[sizeof (fhandler_dev_tape)];
  char __dev_zero[sizeof (fhandler_dev_zero)];
  char __disk_file[sizeof (fhandler_disk_file)];
  char __fifo[sizeof (fhandler_fifo)];
  char __mailslot[sizeof (fhandler_mailslot)];
  char __netdrive[sizeof (fhandler_netdrive)];
  char __nodevice[sizeof (fhandler_nodevice)];
  char __pipe[sizeof (fhandler_pipe)];
  char __proc[sizeof (fhandler_proc)];
  char __process[sizeof (fhandler_process)];
  char __procnet[sizeof (fhandler_procnet)];
  char __procsys[sizeof (fhandler_procsys)];
  char __procsysvipc[sizeof (fhandler_procsysvipc)];
  char __pty_master[sizeof (fhandler_pty_master)];
  char __registry[sizeof (fhandler_registry)];
  char __serial[sizeof (fhandler_serial)];
  char __socket[sizeof (fhandler_socket)];
  char __termios[sizeof (fhandler_termios)];
  char __pty_common[sizeof (fhandler_pty_common)];
  char __pty_slave[sizeof (fhandler_pty_slave)];
  char __virtual[sizeof (fhandler_virtual)];
  char __windows[sizeof (fhandler_windows)];
} fhandler_union;
@


1.513
log
@	* fhandler.h (class fhandler_base): Add was_nonblocking status flag.
	* fhandler.cc (fhandler_base::set_flags): Set was_nonblocking if the
	O_NONBLOCK flag has been specified.
	(fhandler_base_overlapped::close): Check for was_nonblocking instead
	of for is_nonblocking.  Explain why.
	(fhandler_base::set_nonblocking): Set was_nonblocking if noblocking
	mode gets enabled.
@
text
@d417 1
d1573 1
d1579 1
@


1.512
log
@	* path.h (path_conv): Make path_flags private.  Rename known_suffix to
	suffix and make private.  Rename normalized_path to posix_path and
	make privtae.  Accommodate name changes throughout in path_conv
	methods.
	(path_conv::known_suffix): New method.  Use throughout instead of
	accessing suffix directly.
	(path_conv::get_win32): Constify.
	(path_conv::get_posix): New method to read posix_path.  Use throughout
	instead of accessing normalized_path directly.
	(path_conv::set_posix): Rename from set_normalized_path.  Accommodate
	name change throughout.
	* spawn.cc (find_exec): Return POSIX path, not Win32 path.
@
text
@d152 3
d160 2
a161 1
      need_fork_fixup (0), isclosed (0), mandatory_locking (0)
d257 1
@


1.511
log
@	* fhandler.h (class fhandler_process): Add fd_type member.
	* fhandler_process.cc (process_tab): Fix indentation.
	(fhandler_process::exists): Rely on format_process_fd returning file
	type in fd_type.
	(struct process_fd_t): Add fd_type member.
	(fhandler_process::fill_filebuf): Allow format_process_fd to set
	this->fd_type member.
	(format_process_fd): Fix path evaluation to allow recognizing trailing
	path components.  Fix check for file descriptor path component.  Return
	virt_symlink in fd_type if no trailing path compenents exist, return
	virt_fsdir otherwise and copy full resulting path into destbuf.
	* path.cc (path_conv::check): If /proc/$PID/fd symlink has trailing
	path components, reparse resulting path as if it's the incoming path.
	Add comment to wail over the outdated and hackish check method, and to
	explain what we do here.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015  Red Hat, Inc.
d199 1
a199 1
    pc.set_normalized_path (s);
d298 1
a298 1
  const char *get_name () const { return pc.normalized_path; }
@


1.510
log
@	* fhandler.h (fhandler_termios::line_edit): Add parameter to return
	written bytes.
	* fhandler_termios.cc (fhandler_termios::tcinit): Fix formatting.
	(fhandler_termios::line_edit): Return bytes actually written.  Write
	in 32 byte chunks in non-canonical mode to reduce number of WriteFile
	calls.  Don't just eat unwritten bytes in case of an error condition.
	Especially, don't report them back to the caller as written.
	* fhandler_tty.cc (fhandler_pty_slave::read): Disable code reducing
	the number of bytes read from the pipe to vmin.  Add comment.
	(fhandler_pty_master::write): Convert ret to ssize_t type.  Just call
	line_edit once, not in a loop once for each byte.  Return bytes written
	as returned by line_edit.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d2067 1
@


1.509
log
@	* fhandler_socket.cc (fhandler_socket::af_local_connect): Drop
	setting connect_state to connect_credxchg.
	(fhandler_socket::af_local_accept): Ditto.
	(fhandler_socket::recv_internal): Drop ill-advised connect_state check.
	Add comment so as not to repeat the exercise.
	* fhandler.h (enum conn_state): Drop now unneeded connect_credxchg
	state.
@
text
@d1207 2
a1208 1
  line_edit_status line_edit (const char *rptr, int nread, termios&);
@


1.508
log
@	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d78 4
a81 5
  connect_credxchg = 1,
  connect_pending = 2,
  connected = 3,
  listener = 4,
  connect_failed = 5
@


1.507
log
@	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.
@
text
@d507 1
d535 1
d539 1
a539 1
      connect_state (unconnected)
d561 1
@


1.506
log
@	* fhandler.h (enum conn_state): Add "connect_credxchg" state.
	(class fhandler_socket): Grant another bit to connect_state flag.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Rearrange
	variable definition.  Set connect_state to connect_credxchg.
	(fhandler_socket::af_local_accept): Ditto.
	(fhandler_socket::recv_internal): Accept connect_credxchg on connection
	oriented AF_LOCAL sockets as well to allow the credential exchange.
	Extend comment to explain.
@
text
@d1509 1
a1509 1
  bool fch_open_handles ();
@


1.505
log
@	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.
@
text
@d78 5
a82 4
  connect_pending = 1,
  connected = 2,
  listener = 3,
  connect_failed = 4
d533 1
a533 1
    unsigned connect_state	   : 2;
@


1.504
log
@	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::recv_internal): Explicitely check if the socket is
	connected if it's a stream socket.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.
@
text
@d1147 1
@


1.503
log
@* DevNotes: Add entry cgf-000026.
* fhandler.h (fhandler_console::save_top): Save top of screen coordinates.
* fhandler_console.cc (dev::save_restore): Record top of screen coordinates.
Clear entire buffer when restoring saved buffer and try to position the cursor
on the save relative place on the screen.
@
text
@d80 2
a81 1
  connect_failed = 3
a531 1
    unsigned listener		   : 1; /* listen called */
d536 1
a536 1
      listener (0), connect_state (unconnected)
a556 1
  IMPLEMENT_STATUS_FLAG (bool, listener)
d584 5
a588 1
  off_t lseek (off_t, int) { return 0; }
d1141 5
a1145 1
  off_t lseek (off_t, int) { return 0; }
a1146 1
  bool is_tty () const { return true; }
@


1.502
log
@* fhandler.h (fhandler_dev_dsp): Remove variable names from declarations.
(fhandler_dev_dsp::close_audio_in): Make __reg1.
(fhandler_dev_dsp::close_audio_out): Make __reg2.
* fhandler_dev_dsp.cc (fhandler_dev_dsp::close_audio_in): Make __reg1.
(fhandler_dev_dsp::close_audio_out): Make __reg2.
(fhandler_dev_dsp::close): Don't abruptly terminate sound just because we are
exiting.
@
text
@d1305 1
@


1.501
log
@* sigproc.h (no_thread_exit_protect): New class.
* sigproc.cc (thread_exit): Use no_thread_exit_protect to determine if we need
to coordinate ThreadExit/ExitProcess.
* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::stop): Use
no_thread_exit_protect to kludge around waiting for waveOutClose as it waits
for a thread that never exits.
(fhandler_dev_dsp::Audio_in::stop): Ditto for waveInClose.
* fhandler.h (fhandler_dev_dsp::base): New method.
(fhandler_dev_dsp::_read): Ditto.
(fhandler_dev_dsp::_write): Ditto.
(fhandler_dev_dsp::_ioctl): Ditto.
(fhandler_dev_dsp::_fixup_after_fork): Ditto.
(fhandler_dev_dsp::_fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::read): Call real function via base()
pointer.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
(fhandler_dev_dsp::_read): Rename by adding an leading underscore.
(fhandler_dev_dsp::_write): Ditto.
(fhandler_dev_dsp::_ioctl): Ditto.
(fhandler_dev_dsp::_fixup_after_fork): Ditto.
(fhandler_dev_dsp::_fixup_after_exec): Ditto.
@
text
@d1795 4
a1798 4
  int open (int flags, mode_t mode = 0);
  ssize_t __stdcall write (const void *ptr, size_t len);
  void __reg3 read (void *ptr, size_t& len);
  int ioctl (unsigned int cmd, void *);
d1800 1
a1800 1
  void fixup_after_fork (HANDLE parent);
d1804 4
a1807 4
  ssize_t __stdcall _write (const void *ptr, size_t len);
  void __reg3 _read (void *ptr, size_t& len);
  int _ioctl (unsigned int cmd, void *);
  void _fixup_after_fork (HANDLE parent);
d1810 2
a1811 2
  void close_audio_in ();
  void close_audio_out (bool immediately = false);
@


1.500
log
@* fhandler.h (dev_console::b): Redefine as CONSOLE_SCREEN_BUFFER_INFO for use
with older OS.
* fhandler_console.cc (dev_console::fillin): Ditto for
GetConsoleScreenBufferInfo.
@
text
@d1793 1
a1798 1
  off_t lseek (off_t, int) { return 0; }
d1802 1
d1804 6
@


1.499
log
@* fhandler.h (fhandler_console::dwBufferSize): Delete.
(fhandler_console::dwCursorPosition): Ditto.
(fhandler_console::wAttributes): Ditto.
(fhandler_console::b): New field encompassing previously disparate screen
buffer info.
(fhandler_console::save_bufsize): Rename from savebufsiz
(fhandler_console::save_buf): Rename sfrom savebuf.
(fhandler_console::save_cursor): New field.
(fhandler_console::save_restore): New function.
(fhandler_console::con): Rename from dev_state.
(fhandler_console::focus_aware): Accommodate name change.
* fhandler_console.cc: Use 'b' field of dev_console throughout instead of
disparate names.  Accommodate dev_state -> con rename.
(dev_state:save_restore): New function.  Attempt to save the entire screen
buffer rather than just the visible part.  Clear the buffer when saving, like
Linux.
(fhandler_console::char_command): Use con.save_restore() for Save/restore
screen sequence.
@
text
@d1297 1
a1297 1
  CONSOLE_SCREEN_BUFFER_INFOEX b;
@


1.498
log
@* fhandler.h (fhandler_console::scroll_buffer_screen): New function.
* fhandler_console.cc (fhandler_console::scroll_buffer_screen): New function.
(fhandler_console::char_command): Use scroll_buffer_screen as appropriate.
(dev_console::scroll_buffer): Remove if 0'ed block.
@
text
@a1289 3
  /* saved screen */
  COORD savebufsiz;
  PCHAR_INFO savebuf;
d1293 2
a1294 1
      short Top, Bottom;
d1297 1
a1297 2
  SHORT winTop;
  SHORT winBottom;
a1298 3
  COORD dwBufferSize;
  COORD dwCursorPosition;
  WORD wAttributes;
d1301 5
d1332 1
d1344 1
a1344 1
    dev_console dev_state;
d1416 1
a1416 1
  bool focus_aware () {return shared_console_info->dev_state.use_focus;}
@


1.497
log
@* fhandler.h (dev_console::is_fullscreen): Delete.
(dev_console::scroll_window): Return bool indicating success.
(dev_console::scroll_screen): New function.
(dev_console::clear_screen): New function.
(fhandler_console::clear_screen): Make __reg3.
(fhandler_console::cursor_set): Ditto.
(fhandler_console::cursor_get): Ditto.
(fhandler_console::cursor_rel): Ditto.
* fhandler_console.cc (dev_console::scroll_buffer): Adapt from
fhandler_console.
(fhandler_console::scroll_buffer): Use dev_console function.
(dev_console::is_fullscreen): Delete.
(dev_console::scroll_window): Return true if we cleared the screen.
Shrink/grow buffer first before scrolling to ensure that there is sufficient
space after scrolling.
(fhandler_console::clear_screen): Make reg3, use dev_console function.
(dev_console::clear_screen): New function adapted from fhandler_console.
(fhandler_console::cursor_set): Make __reg3.
(fhandler_console::cursor_rel): Ditto.
(fhandler_console::cursor_get): Ditto.
(fhandler_console::write): Fix "reverse index".
@
text
@d1363 1
@


1.496
log
@* DevNotes: Add entry cgf-000024.
* fhandler.h (dev_console::state): Remove trailing underscore.
(dev_console::args): Ditto.
(dev_console::nargs): Ditto.
(dev_console::info): Eliminate subclass.
(dev_console::dwEnd): New field.
(dev_console::scroll_window): New function.
(dev_console::is_fullscreen): Ditto.
(dev_console::fillin): Rename from fillin_info.
(fhandler_console::scroll_buffer): Rename from scroll_screen.
* fhandler_console.cc: Throughout s/dev_state\.info/dev_state/g.  Accommodate
other name changes.
(dev_console::fillin): Accommodate rename.  Notice max x/y written to.  Forgo
memset if GetConsoleScreenBufferInfo fails.
(fhandler_console::scroll_buffer): Accommodate rename.  Don't treat y
coordinate of zero as top of screen.
(dev_console::is_fullscreen): New function.
(dev_console::scroll_window): Ditto.
(fhandler_console::clear_screen): Just scroll the screen when clearing the
screen in a state where the screen buffer is bigger than the screen.
(fhandler_console::char_command): Try harder to get 'S' and 'T' working in the
presence of a screen buffer.  Use temporary 'n' variable rather than
dev_state.args[0].  Use GNU ?: shortcut method.
@
text
@d1330 3
a1332 2
  bool is_fullscreen (int, int, int, int);
  void scroll_window (HANDLE);
a1361 1
  void clear_screen (cltype, cltype, cltype, cltype);
d1363 4
a1366 3
  void cursor_set (bool, int, int);
  void cursor_get (int *, int *);
  void cursor_rel (int, int);
@


1.495
log
@* fhandler.h (cltype): Add cl_buf_beg, cl_buf_end.
* fhandler_console.cc (dev_console::console_attrs::set_cl_x): Honor buffer
locations.
(dev_console::console_attrs::set_cl_y): Ditto.
(fhandler_console::write): On reset, use absolute positioning to go to
beginning of buffer.  Clear entire buffer.
@
text
@d1266 3
a1268 3
  int state_;
  int args_[MAXARGS];
  int nargs_;
d1298 8
a1305 11
  struct console_attrs
    {
      SHORT winTop;
      SHORT winBottom;
      COORD dwWinSize;
      COORD dwBufferSize;
      COORD dwCursorPosition;
      WORD wAttributes;
      int set_cl_x (cltype);
      int set_cl_y (cltype);
    } info;
a1325 1
  bool fillin_info (HANDLE);
d1327 5
d1362 1
a1362 1
  void scroll_screen (int, int, int, int, int, int);
@


1.495.2.1
log
@* DevNotes: Add entry cgf-000024.
* fhandler.h (dev_console::state): Remove trailing underscore.
(dev_console::args): Ditto.
(dev_console::nargs): Ditto.
(dev_console::info): Eliminate subclass.
(dev_console::dwEnd): New field.
(dev_console::scroll_window): New function.
(dev_console::is_fullscreen): Ditto.
(dev_console::fillin): Rename from fillin_info.
(fhandler_console::scroll_buffer): Rename from scroll_screen.
* fhandler_console.cc: Throughout s/dev_state\.info/dev_state/g.  Accommodate
other name changes.
(dev_console::fillin): Accommodate rename.  Notice max x/y written to.  Forgo
memset if GetConsoleScreenBufferInfo fails.
(fhandler_console::scroll_buffer): Accommodate rename.  Don't treat y
coordinate of zero as top of screen.
(dev_console::is_fullscreen): New function.
(dev_console::scroll_window): Ditto.
(fhandler_console::clear_screen): Just scroll the screen when clearing the
screen in a state where the screen buffer is bigger than the screen.
(fhandler_console::char_command): Try harder to get 'S' and 'T' working in the
presence of a screen buffer.  Use temporary 'n' variable rather than
dev_state.args[0].  Use GNU ?: shortcut method.
@
text
@d1266 3
a1268 3
  int state;
  int args[MAXARGS];
  int nargs;
d1298 11
a1308 8

  SHORT winTop;
  SHORT winBottom;
  COORD dwWinSize;
  COORD dwBufferSize;
  COORD dwCursorPosition;
  WORD wAttributes;
  COORD dwEnd;
d1329 1
a1330 5
  int set_cl_x (cltype);
  int set_cl_y (cltype);
  bool fillin (HANDLE);
  bool is_fullscreen (int, int, int, int);
  void scroll_window (HANDLE);
d1361 1
a1361 1
  void scroll_buffer (int, int, int, int, int, int);
@


1.495.2.2
log
@* fhandler.h (dev_console::is_fullscreen): Delete.
(dev_console::scroll_window): Return bool indicating success.
(dev_console::scroll_screen): New function.
(dev_console::clear_screen): New function.
(fhandler_console::clear_screen): Make __reg3.
(fhandler_console::cursor_set): Ditto.
(fhandler_console::cursor_get): Ditto.
(fhandler_console::cursor_rel): Ditto.
* fhandler_console.cc (dev_console::scroll_buffer): Adapt from
fhandler_console.
(fhandler_console::scroll_buffer): Use dev_console function.
(dev_console::is_fullscreen): Delete.
(dev_console::scroll_window): Return true if we cleared the screen.
Shrink/grow buffer first before scrolling to ensure that there is sufficient
space after scrolling.
(fhandler_console::clear_screen): Make reg3, use dev_console function.
(dev_console::clear_screen): New function adapted from fhandler_console.
(fhandler_console::cursor_set): Make __reg3.
(fhandler_console::cursor_rel): Ditto.
(fhandler_console::cursor_get): Ditto.
(fhandler_console::write): Fix "reverse index".
@
text
@d1330 2
a1331 3
  bool __reg3 scroll_window (HANDLE, int, int, int, int);
  void __reg3 scroll_buffer (HANDLE, int, int, int, int, int, int);
  void __reg3 clear_screen (HANDLE, int, int, int, int);
d1361 1
d1363 3
a1365 4
  void __reg3 clear_screen (cltype, cltype, cltype, cltype);
  void __reg3 cursor_set (bool, int, int);
  void __reg3 cursor_get (int *, int *);
  void __reg3 cursor_rel (int, int);
@


1.495.2.3
log
@* fhandler.h (fhandler_console::scroll_buffer_screen): New function.
* fhandler_console.cc (fhandler_console::scroll_buffer_screen): New function.
(fhandler_console::char_command): Use scroll_buffer_screen as appropriate.
(dev_console::scroll_buffer): Remove if 0'ed block.
@
text
@a1362 1
  void scroll_buffer_screen (int, int, int, int, int, int);
@


1.495.2.4
log
@* fhandler.h (fhandler_console::dwBufferSize): Delete.
(fhandler_console::dwCursorPosition): Ditto.
(fhandler_console::wAttributes): Ditto.
(fhandler_console::b): New field encompassing previously disparate screen
buffer info.
(fhandler_console::save_bufsize): Rename from savebufsiz
(fhandler_console::save_buf): Rename sfrom savebuf.
(fhandler_console::save_cursor): New field.
(fhandler_console::save_restore): New function.
(fhandler_console::con): Rename from dev_state.
(fhandler_console::focus_aware): Accommodate name change.
* fhandler_console.cc: Use 'b' field of dev_console throughout instead of
disparate names.  Accommodate dev_state -> con rename.
(dev_state:save_restore): New function.  Now attempts to save the entire screen
buffer rather than just the visible part.  Clear the buffer when saving, like
Linux.
(fhandler_console::char_command): Use con.save_restore() for Save/restore
screen sequence.
@
text
@d1290 3
d1296 1
a1296 2
      short Top;
      short Bottom;
d1299 2
a1300 1
  CONSOLE_SCREEN_BUFFER_INFOEX b;
d1302 3
a1306 5
  /* saved screen */
  COORD save_bufsize;
  PCHAR_INFO save_buf;
  COORD save_cursor;

a1332 1
  void __reg3 save_restore (HANDLE, char);
d1344 1
a1344 1
    dev_console con;
d1416 1
a1416 1
  bool focus_aware () {return shared_console_info->con.use_focus;}
@


1.495.2.5
log
@* fhandler.h (dev_console::b): Redefine as CONSOLE_SCREEN_BUFFER_INFO for use
with older OS.
* fhandler_console.cc (dev_console::fillin): Ditto for
GetConsoleScreenBufferInfo.
@
text
@d1297 1
a1297 1
  CONSOLE_SCREEN_BUFFER_INFO b;
@


1.495.2.6
log
@* fhandler.h (fhandler_dev_dsp::base): New method.
(fhandler_dev_dsp::_read): Ditto.
(fhandler_dev_dsp::_write): Ditto.
(fhandler_dev_dsp::_ioctl): Ditto.
(fhandler_dev_dsp::_fixup_after_fork): Ditto.
(fhandler_dev_dsp::_fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::read): Call real function via base()
pointer.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
(fhandler_dev_dsp::_read): Rename by adding an leading underscore.
(fhandler_dev_dsp::_write): Ditto.
(fhandler_dev_dsp::_ioctl): Ditto.
(fhandler_dev_dsp::_fixup_after_fork): Ditto.
(fhandler_dev_dsp::_fixup_after_exec): Ditto.
@
text
@a1792 1
  fhandler_dev_dsp *base () const {return (fhandler_dev_dsp *)archetype;}
d1798 1
a1801 1

a1802 6
  ssize_t __stdcall _write (const void *ptr, size_t len);
  void __reg3 _read (void *ptr, size_t& len);
  int _ioctl (unsigned int cmd, void *);
  void _fixup_after_fork (HANDLE parent);
  void _fixup_after_exec ();

@


1.495.2.7
log
@* fhandler.h (fhandler_dev_dsp): Remove variable names from declarations.
(fhandler_dev_dsp::close_audio_in): Make __reg1.
(fhandler_dev_dsp::close_audio_out): Make __reg2.
* fhandler_dev_dsp.cc (fhandler_dev_dsp::close_audio_in): Make __reg1.
(fhandler_dev_dsp::close_audio_out): Make __reg2.
(fhandler_dev_dsp::close): Don't abruptly terminate sound just because we are
exiting.
@
text
@d1795 4
a1798 4
  int open (int, mode_t mode = 0);
  ssize_t __stdcall write (const void *, size_t);
  void __reg3 read (void *, size_t&);
  int ioctl (unsigned int, void *);
d1800 1
a1800 1
  void fixup_after_fork (HANDLE);
d1804 4
a1807 4
  ssize_t __stdcall _write (const void *, size_t);
  void __reg3 _read (void *, size_t&);
  int _ioctl (unsigned int, void *);
  void _fixup_after_fork (HANDLE);
d1810 2
a1811 2
  void __reg1 close_audio_in ();
  void __reg2 close_audio_out (bool = false);
@


1.495.2.8
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@a1304 1
  SHORT save_top;
@


1.495.2.9
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d80 1
a80 2
  listener = 3,
  connect_failed = 4
a504 1
  int af_local_set_no_getpeereid ();
d531 2
a532 2
    unsigned connect_state	   : 3;
    unsigned no_getpeereid	   : 1;
d536 1
a536 1
      connect_state (unconnected), no_getpeereid (0)
d557 1
a558 1
  IMPLEMENT_STATUS_FLAG (bool, no_getpeereid)
d585 1
a585 5
  off_t lseek (off_t, int)
  { 
    set_errno (ESPIPE);
    return -1;
  }
d1138 1
a1138 5
  off_t lseek (off_t, int)
  { 
    set_errno (ESPIPE);
    return -1;
  }
d1501 1
a1501 1
  bool fch_open_handles (bool chown);
@


1.494
log
@* fhandler.h: Update copyright.
(cltype): New enum.
(dev_console::console_attrs): Define struct name.
(dev_console::console_attrs::set_cl_x): New function.
(dev_console::console_attrs::set_cl_y): New function.
(fhandler_console::clear_screen): Redefine input params.
* fhandler_console.cc: Update copyright.  Throughout, reflect change in
arguments to fhandler_console::clear_screeen.
(fhandler_console::mouse_aware): Simplify logic slightly.
(fhandler_console::scroll_screen): Remove hopefully obsolete win95 code.
(dev_console::console_attrs::set_cl_x): New function.
(dev_console::console_attrs::set_cl_y): New function.
(fhandler_console::clear_screen): Redefine input params.  Calculate position
based on enum value.
(region_split): Change arguments.  Simplify.
(ReadConsoleOutputWrapper): Remove coord argument since we now always use 0, 0.
Send extra arguments to region_split.
@
text
@d1253 3
a1255 1
  cl_disp_end
@


1.493
log
@* fhandler.h (fhandler_pty_master::~fhandler_pty_master): Delete.
* fhandler_tty.cc (fhandler_pty_master::~fhandler_pty_master): Ditto.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d1249 7
d1296 1
a1296 1
  struct
d1304 2
d1358 1
a1358 1
  void clear_screen (int, int, int, int);
@


1.492
log
@	* fhandler.h (fhandler_dev_clipboard): Add private member
	cygnativeformat.  Declare private method set_clipboard.
	* fhandler_clipboard.cc (cygnativeformat): Convert static variable to
	fhandler_dev_clipboard member.
	(fhandler_dev_clipboard::set_clipboard): Convert from static function
	to fhandler_dev_clipboard method.
@
text
@a1575 1
  ~fhandler_pty_master ();
@


1.491
log
@	* devices.in (dev_cygdrive_storage): Revert mapping to \Device\Null.
	(dev_storage): Ditto for /dev.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::open_null): New method to open a fake
	\Device\Null handler.
	(fhandler_base::open): Fix formatting.  Change O_ACCMODE test to a
	switch statement.  Simplify a test which still tested for a now unused
	create_disposition.
	* fhandler.h (fhandler_base::open_null): Declare.
	(fhandler_netdrive::close): Declare.
	* fhandler_dev.cc (fhandler_dev::open): Open fake \Device\Null handle
	by just calling new open_null method.
	* fhandler_disk_file.cc (fhandler_cygdrive::open): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::open): Call open_null
	rather than setting nohandle.
	(fhandler_netdrive::close): New method.
	* fhandler_registry.cc (fetch_hkey): Fix token in RegOpenUserClassesRoot
	call.  Create valid key for HKEY_CURRENT_CONFIG by mapping to real key
	HKEY_LOCAL_MACHINE\System\CurrentControlSet\Hardware Profiles\Current.
	(fhandler_registry::open): Set nohandle only when using pseudo registry
	handle.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Call open rather
	than just setting nohandle here.
	* fhandler_virtual::fstatvfs): Set ST_RDONLY fs flag.
	* globals.cc (ro_u_null): New readonly UNICODE_STRING for \Device\Null.
	* path.h (path_conv::set_path): Revert previous change caring for
	wide_path.
@
text
@d1691 1
d1695 2
@


1.490
log
@	* devices.in (dev_cygdrive_storage): Map to \Device\Null.
	(dev_storage): Map /dev and /dev/windows to \Device\Null.
	* devices.cc: Regenerate.
	* dir.cc (opendir): Create unique id.  Explain why.
	* fhandler.h (fhandler_dev::get_dev): Implement inline.
	(fhandler_cygdrive::close): Drop declaration.
	(fhandler_cygdrive::get_dev): Implement inline.
	(fhandler_windows::get_hwnd): Ditto.
	(fhandler_windows::set_close_on_exec): Drop declaration.
	(fhandler_windows::fixup_after_fork): Ditto.
	* fhandler_dev.cc (fhandler_dev::open): Call fhandler_disk_file::open
	without O_CREAT flag.  Explain why.  Create \Device\Null handle if
	/dev/ doesn't actually exist.
	(fhandler_dev::close): Drop nohandle case.
	(fhandler_dev::fstatvfs): Drop nohandle check.  Test for fs_got_fs
	instead.  Set ST_RDONLY fs flag for simulated /dev.
	(fhandler_dev::opendir): If /dev doesn't exist, call open() to create
	fake \Device\Null handle.  Don't set nohandle.  Set dir_exists
	correctly.
	(fhandler_dev::rewinddir): Call fhandler_disk_file::rewinddir only if
	/dev is a real directory.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): If called for
	the cygdrive dir, call open() to create fake \Device\Null handle.
	Only attach __DIR_mounts buffer to dir if not called for cygdrive dir.
	Don't set nohandle.
	(fhandler_cygdrive::open): Create \Device\Null handle.
	(fhandler_cygdrive::close): Remove.
	(fhandler_cygdrive::fstatvfs): Set ST_RDONLY fs flag.
	* fhandler_windows.cc (fhandler_windows::open): Create \Device\Null
	handle.
	(fhandler_windows::read): Don't add io_handle to WFMO handle array.
	Change subsequent test for return value accordingly.  Fix test for
	"message arrived".
	(fhandler_windows::set_close_on_exec): Remove.
	(fhandler_windows::fixup_after_fork): Remove.
	* path.h (path_conv::set_path): Make sure wide_path is NULL when
	setting a new path.
	* select.cc (peek_windows): Use correct hWnd value, not io_handle.
	(fhandler_windows::select_read): Don't use io_handle as wait object.
	(fhandler_windows::select_write): Ditto.
	(fhandler_windows::select_except): Ditto.
@
text
@d313 1
d1966 1
@


1.489
log
@	* devices.in (dev_storage): Map /dev/clipboard to \Device\Null.
	* devices.cc: Regenerate.
	* fhandler.h (fhandler_dev_clipboard::open): Drop declaration.
	* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Drop call to
	open.  Set private members to 0 and call fhandler_base::dup.
	(fhandler_dev_clipboard::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	(set_clipboard): Drop gratuitios call to RegisterClipboardFormatW.
	(fhandler_dev_clipboard::close): Call fhandler_base::close from here.
@
text
@d1048 2
a1079 1
  int close ();
d1088 1
d1731 1
a1738 2
  void set_close_on_exec (bool val);
  void fixup_after_fork (HANDLE parent);
@


1.488
log
@	* devices.in (dev_storage): Map /dev/random and /dev/urandom to
	\Device\Null.
	* devices.cc: Regenerate.
	* fhandler.h (fhandler_dev_random::open): Drop declaration.
	(fhandler_dev_random::close): Ditto.
	(fhandler_dev_random::crypt_gen_random): Convert to static method.
	* fhandler_random.cc (fhandler_dev_random::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	(fhandler_dev_random::close): Ditto.
	* fhandler_socket.cc (entropy_source): Delete.
	(fhandler_socket::af_local_set_secret): Remove entropy_source code and
	call fhandler_dev_random::crypt_gen_random directly instead.
@
text
@a1693 1
  int open (int flags, mode_t mode = 0);
@


1.487
log
@	* fhandler.h (fhandler_dev_zero::lseek): Convert to inline method.
	(class fhandler_dev_random): Drop dummy_offset.
	(fhandler_dev_random::lseek): Convert to inline method.
	(fhandler_dev_dsp::lseek): Ditto.
	* fhandler_dsp.cc (fhandler_dev_dsp::lseek): Drop here.
	* fhandler_random.cc (fhandler_dev_random::open): Drop setting
	dummy_offset.
	(fhandler_dev_random::lseek): Drop here.
	* fhandler_tape.cc (fhandler_dev_tape::lseek): Make no-op, but keep
	old code for reference.
	* fhandler_zero.cc (fhandler_dev_zero::lseek): Drop here.
@
text
@a1656 1
  bool crypt_gen_random (void *ptr, size_t len);
a1660 1
  int open (int flags, mode_t mode = 0);
d1664 2
a1665 1
  int close ();
@


1.486
log
@* external.cc (fillout_pinfo): If start_time is 0, wait a while before
returning the pinfo structure.
* fhandler.cc (fhandler_base::open_setup): Convert from inline.
* fhandler.h (fhandler_base::open_setup): Declare.
* fhandler_console.cc (fhandler_console::open_setup): Always call
fhandler_base::open_setup.
* fhandler_tty.cc (fhandler_pty_slave::open_setup): Ditto.
(fhandler_pty_master::open_setup): Ditto.
@
text
@d1624 1
a1624 1
  off_t lseek (off_t offset, int whence);
a1655 1
  off_t dummy_offset;
d1665 1
a1665 1
  off_t lseek (off_t offset, int whence);
d1782 1
a1782 1
  off_t lseek (off_t, int);
@


1.485
log
@	* devices.in (dev_storage): Map /dev/zero and /dev/full to \Device\Null.
	* devices.cc: Regenerate.
	* dtable.h (struct dtable): Make fhandler_base friend, rather
	than fhandler_disk_file.
	* fhandler.cc (fhandler_base::open_with_arch): Create unique id.
	(fhandler_base::cleanup): Call del_my_locks.
	(fhandler_base::fcntl): Handle F_GETLK, F_SETLK and F_SETLKW.
	* fhandler.h (fhandler_base::get_dev): Return real device number.
	(fhandler_base::set_unique_id): New inline method.
	(fhandler_disk_file::lock): Drop declaration.
	(fhandler_disk_file::get_dev): New method, return pc.fs_serial_number.
	(fhandler_dev_zero::open): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::close): Move
	del_my_locks call to fhandler_base::open_with_arch.
	(fhandler_disk_file::fcntl): Move handling of locking commands to
	fhandler_base::fcntl.
	(fhandler_base::open_fs): Drop call to NtAllocateLocallyUniqueId.
	* fhandler_zero.cc (fhandler_dev_zero::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	* flock.cc (fixup_lockf_after_exec): Finding a single fhandler is
	enough here.
	(fhandler_base::lock): Replace fhandler_disk_file::lock.  Refuse to lock
	nohandle devices.  Handle read/write test using POSIX flags.  Explain
	why.  Never fail on SEEK_CUR or SEEK_END, rather assume position 0,
	just as Linux.
	* net.cc (fdsock): Create unique id.
@
text
@d314 1
a314 1
  virtual void open_setup (int flags) { return; }
@


1.484
log
@* fhandler.h (fhandler_base::cleanup): Mark as extern rather than inline.
* fhandler_base.cc (fhandler_base::cleanup): Define.
* fhandler_tty.cc (fhandler_pty_slave::cleanup): Call fhandler_base::cleanup.
(fhandler_pty_master::cleanup): Ditto.
@
text
@d299 1
a299 1
  dev_t get_dev () { return pc.fs_serial_number (); }
d315 1
a982 1
  int lock (int, struct flock *);
d1015 1
a1621 1
  int open (int flags, mode_t mode = 0);
@


1.483
log
@	* autoload.cc (CryptAcquireContextW): Remove.
	(CryptGenRandom): Remove.
	(CryptReleaseContext): Remove.
	(SystemFunction036): Define.  Add comment to explain that this is
	actually the RtlGenRandom function.
	* fhandler.h (class fhandler_dev_random): Drop crypt_prov member.
	(fhandler_dev_random::fhandler_dev_random): Define inline.
	(fhandler_dev_random::dup): Drop declaration.
	* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Remove
	here.
	(fhandler_dev_random::crypt_gen_random): Use RtlGenRandom to drop
	dependency to old Crypto API.
	(fhandler_dev_random::read): Implement an enhanced version of reading
	random bytes from RtlGenRandom for the sake of a better /dev/random
	emulation.
	(fhandler_dev_random::close): Just return 0 since crypt_prov doesn't
	exisyt anymore.
	(fhandler_dev_random::dup): Drop entirely for the same reason.
@
text
@d318 1
a318 1
  virtual void cleanup () { return; }
@


1.482
log
@	Remove /dev/mem, /dev/kmem, /dev/port support.
	* Makefile.in (DLL_OFILES): Drop fhandler_mem.o.
	(fhandler_mem_CFLAGS): Remove rule.
	* devices.in (enum fh_devices): Remove FH_MEM, FH_KMEM and FH_PORT.
	* devices.cc: Regenerate.
	* dtable.cc (fh_alloc): Drop handling for FH_MEM, FH_KMEM and FH_PORT.
	* fhandler.h (class fhandler_dev_mem): Remove.
	* fhandler_mem.cc: Remove file.
	* globals.cc (ro_u_pmem): Remove.
	* mmap.cc (fhandler_dev_mem::mmap): Remove.
	(fhandler_dev_mem::munmap): Remove.
	(fhandler_dev_mem::fixup_mmap_after_fork): Remove.
@
text
@a1654 1
  HCRYPTPROV crypt_prov;
a1662 1
  fhandler_dev_random ();
a1667 1
  int dup (fhandler_base *child, int);
d1669 1
@


1.481
log
@	* fhandler.cc (fhandler_base::lock): Move to flock.cc.
	(fhandler_base::fixup_after_exec): Reset mandatory_locking.
	* fhandler.h (class fhandler_base): Add mandatory_locking status flag.
	Add mandatory_locking accessor methods.  Accommodate change throughout.
	(fhandler_base::mand_lock): Declare.
	(class fhandler_disk_file): Drop in favor of new status flag.
	* (fhandler_disk_file::fcntl): Call need_fork_fixup if mandatory_locking
	flag gets set.
	* flock.cc (fhandler_base::lock): Define here.
	(flock): Handle mandatory_locking.
	(lockf): Ditto.
	(fhandler_base::mand_lock): Define.
@
text
@a1689 40
class fhandler_dev_mem: public fhandler_base
{
 protected:
  SIZE_T mem_size;
  off_t pos;

 public:
  fhandler_dev_mem ();
  ~fhandler_dev_mem ();

  int open (int flags, mode_t mode = 0);
  ssize_t __stdcall write (const void *ptr, size_t ulen);
  void __reg3 read (void *ptr, size_t& len);
  off_t lseek (off_t offset, int whence);
  int __reg2 fstat (struct stat *buf);

  HANDLE mmap (caddr_t *addr, size_t len, int prot, int flags, off_t off);
  int munmap (HANDLE h, caddr_t addr, size_t len);
  int msync (HANDLE h, caddr_t addr, size_t len, int flags);
  bool fixup_mmap_after_fork (HANDLE h, int prot, int flags,
			      off_t offset, DWORD size, void *address);

  fhandler_dev_mem (void *) {}

  void copyto (fhandler_base *x)
  {
    x->pc.free_strings ();
    *reinterpret_cast<fhandler_dev_mem *> (x) = *this;
    x->reset (this);
  }

  fhandler_dev_mem *clone (cygheap_types malloc_type = HEAP_FHANDLER)
  {
    void *ptr = (void *) ccalloc (malloc_type, 1, sizeof (fhandler_dev_mem));
    fhandler_dev_mem *fh = new (ptr) fhandler_dev_mem (ptr);
    copyto (fh);
    return fh;
  }
};

a2110 1
  char __dev_mem[sizeof (fhandler_dev_mem)];
@


1.480
log
@	* autoload.cc (CancelSynchronousIo): Define.
	* fcntl.cc (fcntl64): Drop handling of locking commands.
	* fhandler.h (class fhandler_disk_file): Add mandatory_locking.
	(fhandler_disk_file::fcntl): Declare.
	(fhandler_disk_file::mand_lock): Declare.
	* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file):
	Initialize mandatory_locking.
	(fhandler_disk_file::fcntl): New method.  Handle F_LCK_MANDATORY and
	locking commands.
	(fhandler_disk_file::dup): Duplicate mandatory_locking.  Fix a bug
	when duplicating prw_handle failed.
	(fhandler_disk_file::fixup_after_fork): Reset mandatory_locking.
	* flock.cc (fhandler_disk_file::lock): Add comment.
	(struct lock_parms): New struct to pass parameters to blocking_lock_thr
	thread function.
	(blocking_lock_thr): New thread function.
	(fhandler_disk_file::mand_lock): New methof implementing mandatory
	locking with Windows semantics.
	* ntdll.h (NtLockFile): Declare.
	(NtUnlockFile): Declare.
	* include/fcntl.h: Fix a comment.
	(F_LCK_MANDATORY): Define.  Add lengthy comment to explain.
@
text
@d150 1
d156 1
a156 1
      need_fork_fixup (0), isclosed (0)
d251 1
d365 1
a968 1
  bool mandatory_locking;
@


1.479
log
@	* fhandler.h (class fhandler_dev_random): Change type of pseudo to
	uint32_t to make sure it's 32 bit on all supported platforms.
@
text
@d966 1
d977 1
d981 1
@


1.478
log
@	* Merge in cygwin-64bit-branch.
@
text
@d1651 1
a1651 1
  long pseudo;
@


1.477
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d58 1
a58 1
struct __acl32;
d165 2
a166 2
  __ino64_t ino;	/* file ID or hashed filename, depends on FS. */
  long _refcnt;
d185 2
a186 2
  long inc_refcnt () {return InterlockedIncrement (&_refcnt);}
  long dec_refcnt () {return InterlockedDecrement (&_refcnt);}
d212 3
a214 4
  DWORD& get_device () { return dev (); }
  DWORD get_major () { return dev ().get_major (); }
  DWORD get_minor () { return dev ().get_minor (); }
  virtual int get_unit () { return dev ().get_minor (); }
d297 2
a298 2
  __dev32_t get_dev () { return pc.fs_serial_number (); }
  __ino64_t get_ino () { return ino ?: ino = hash_path_name (0, pc.get_nt_native_path ()); }
d330 3
a332 3
  virtual int __reg2 fstat (struct __stat64 *buf);
  void __reg2 stat_fixup (struct __stat64 *buf);
  int __reg2 fstat_fs (struct __stat64 *buf);
d334 1
a334 1
  int __reg3 fstat_helper (struct __stat64 *buf,
d336 3
a338 3
  int __reg2 fstat_by_nfs_ea (struct __stat64 *buf);
  int __reg2 fstat_by_handle (struct __stat64 *buf);
  int __reg2 fstat_by_name (struct __stat64 *buf);
d343 2
a344 2
  virtual int __reg2 fchown (__uid32_t uid, __gid32_t gid);
  virtual int __reg3 facl (int, int, __acl32 *);
d347 2
a348 2
  virtual int __reg3 fadvise (_off64_t, _off64_t, int);
  virtual int __reg3 ftruncate (_off64_t, bool);
d353 1
a353 1
  virtual int fcntl (int cmd, void *);
d359 4
a362 4
  virtual ssize_t __reg3 pread (void *, size_t, _off64_t);
  virtual ssize_t __reg3 pwrite (void *, size_t, _off64_t);
  virtual _off64_t lseek (_off64_t offset, int whence);
  virtual int lock (int, struct __flock64 *);
d367 1
a367 1
		       int flags, _off64_t off);
d371 1
a371 1
				      _off64_t offset, DWORD size,
d482 6
a487 6
  pid_t     sec_pid;
  __uid32_t sec_uid;
  __gid32_t sec_gid;
  pid_t     sec_peer_pid;
  __uid32_t sec_peer_uid;
  __gid32_t sec_peer_gid;
d538 8
a545 1
  int get_socket () { return (int) get_handle(); }
d561 1
a561 1
  int getpeereid (pid_t *pid, __uid32_t *euid, __gid32_t *egid);
d579 2
a580 2
  int fcntl (int cmd, void *);
  _off64_t lseek (_off64_t, int) { return 0; }
d604 1
a604 1
  int __reg2 fstat (struct __stat64 *buf);
d607 2
a608 2
  int __reg2 fchown (__uid32_t uid, __gid32_t gid);
  int __reg3 facl (int, int, __acl32 *);
d702 1
a702 1
  _off64_t lseek (_off64_t offset, int whence);
d711 2
a712 2
  int __reg3 fadvise (_off64_t, _off64_t, int);
  int __reg3 ftruncate (_off64_t, bool);
d779 1
a779 1
  int __reg2 fstat (struct __stat64 *buf);
d808 4
a811 4
  size_t devbufalign;
  size_t devbufsiz;
  size_t devbufstart;
  size_t devbufend;
d828 1
a828 1
  int __reg2 fstat (struct __stat64 *buf);
d865 1
a865 1
  _off64_t drive_size;
d876 1
a876 1
  inline _off64_t get_current_position ();
d892 1
a892 1
  _off64_t lseek (_off64_t offset, int whence);
d916 1
a916 1
  HANDLE mt_evt;
d934 1
a934 1
  virtual _off64_t lseek (_off64_t offset, int whence);
d936 1
a936 1
  virtual int __reg2 fstat (struct __stat64 *buf);
d978 1
a978 1
  int lock (int, struct __flock64 *);
d980 1
a980 1
  int __reg2 fstat (struct __stat64 *buf);
d982 2
a983 2
  int __reg2 fchown (__uid32_t uid, __gid32_t gid);
  int __reg3 facl (int, int, __acl32 *);
d986 2
a987 2
  int __reg3 fadvise (_off64_t, _off64_t, int);
  int __reg3 ftruncate (_off64_t, bool);
d992 1
a992 1
  HANDLE mmap (caddr_t *addr, size_t len, int prot, int flags, _off64_t off);
d996 1
a996 1
			      _off64_t offset, DWORD size, void *address);
d1006 2
a1007 2
  ssize_t __reg3 pread (void *, size_t, _off64_t);
  ssize_t __reg3 pwrite (void *, size_t, _off64_t);
d1035 1
a1035 1
  int __reg2 fstat (struct __stat64 *buf);
d1077 1
a1077 1
  int __reg2 fstat (struct __stat64 *buf);
d1129 1
a1129 1
  _off64_t lseek (_off64_t, int) { return 0; }
d1199 1
a1199 1
  virtual _off64_t lseek (_off64_t, int);
d1447 1
a1447 1
  _off64_t lseek (_off64_t, int);
a1501 1
  int get_unit ();
d1503 1
a1503 1
  int __reg2 fstat (struct __stat64 *buf);
d1505 1
a1505 1
  int __reg2 fchown (__uid32_t uid, __gid32_t gid);
d1619 1
a1619 1
  _off64_t lseek (_off64_t offset, int whence);
d1622 1
a1622 1
		       int flags, _off64_t off);
d1626 1
a1626 1
				      _off64_t offset, DWORD size,
d1652 1
a1652 1
  _off64_t dummy_offset;
d1663 1
a1663 1
  _off64_t lseek (_off64_t offset, int whence);
d1688 2
a1689 2
  DWORD mem_size;
  _off64_t pos;
d1698 2
a1699 2
  _off64_t lseek (_off64_t offset, int whence);
  int __reg2 fstat (struct __stat64 *buf);
d1701 1
a1701 1
  HANDLE mmap (caddr_t *addr, size_t len, int prot, int flags, _off64_t off);
d1705 1
a1705 1
			      _off64_t offset, DWORD size, void *address);
d1727 1
a1727 1
  _off64_t pos;
d1734 1
a1734 1
  int __reg2 fstat (struct __stat64 *buf);
d1737 1
a1737 1
  _off64_t lseek (_off64_t offset, int whence);
d1773 1
a1773 1
  _off64_t lseek (_off64_t, int) { return 0; }
d1820 1
a1820 1
  _off64_t lseek (_off64_t, int);
d1851 2
a1852 2
  _off64_t filesize;
  _off64_t position;
d1867 1
a1867 1
  _off64_t lseek (_off64_t, int);
a1870 1
  int __reg2 fstat (struct stat *buf);
d1873 2
a1874 2
  int __reg2 fchown (__uid32_t uid, __gid32_t gid);
  int __reg3 facl (int, int, __acl32 *);
d1908 1
a1908 1
  int __reg2 fstat (struct __stat64 *buf);
d1933 1
a1933 1
  virtual_ftype_t __reg2 exists(struct __stat64 *buf);
d1944 1
a1944 1
  int __reg2 fstat (struct __stat64 *buf);
d1973 1
a1973 1
  int __reg2 fstat (struct __stat64 *buf);
d2004 1
a2004 1
  int __reg2 fstat (struct __stat64 *buf);
d2042 1
a2042 1
  int __reg2 fstat (struct __stat64 *buf);
d2076 1
a2076 1
  int __reg2 fstat (struct __stat64 *buf);
d2105 1
a2105 1
  int __reg2 fstat (struct __stat64 *buf);
@


1.476
log
@	* fhandler.h (class dev_console): Flag for expanded control sequence.
	* fhandler_console.cc (char_command): Supporting cursor style modes.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d331 3
a333 3
  virtual int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
  void stat_fixup (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fstat_fs (struct __stat64 *buf) __attribute__ ((regparm (2)));
d335 5
a339 6
  int __stdcall fstat_helper (struct __stat64 *buf,
			      DWORD nNumberOfLinks)
		__attribute__ ((regparm (3)));
  int __stdcall fstat_by_nfs_ea (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fstat_by_handle (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fstat_by_name (struct __stat64 *buf) __attribute__ ((regparm (2)));
d341 12
a352 12
  virtual int __stdcall fstatvfs (struct statvfs *buf) __attribute__ ((regparm (2)));
  int utimens_fs (const struct timespec *) __attribute__ ((regparm (2)));
  virtual int __stdcall fchmod (mode_t mode) __attribute__ ((regparm (1)));
  virtual int __stdcall fchown (__uid32_t uid, __gid32_t gid) __attribute__ ((regparm (2)));
  virtual int __stdcall facl (int, int, __acl32 *) __attribute__ ((regparm (3)));
  virtual ssize_t __stdcall fgetxattr (const char *, void *, size_t) __attribute__ ((regparm (3)));
  virtual int __stdcall fsetxattr (const char *, const void *, size_t, int) __attribute__ ((regparm (3)));
  virtual int __stdcall fadvise (_off64_t, _off64_t, int) __attribute__ ((regparm (3)));
  virtual int __stdcall ftruncate (_off64_t, bool) __attribute__ ((regparm (3)));
  virtual int __stdcall link (const char *) __attribute__ ((regparm (2)));
  virtual int __stdcall utimens (const struct timespec *) __attribute__ ((regparm (2)));
  virtual int __stdcall fsync () __attribute__ ((regparm (1)));
d356 1
a356 1
  virtual void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d360 2
a361 2
  virtual ssize_t __stdcall pread (void *, size_t, _off64_t) __attribute__ ((regparm (3)));
  virtual ssize_t __stdcall pwrite (void *, size_t, _off64_t) __attribute__ ((regparm (3)));
d398 2
a399 2
  virtual void __stdcall raw_read (void *ptr, size_t& ulen) __attribute__ ((regparm (3)));
  virtual ssize_t __stdcall raw_write (const void *ptr, size_t ulen) __attribute__ ((regparm (3)));
d425 2
a426 2
  virtual DIR *opendir (int fd) __attribute__ ((regparm (2)));
  virtual int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d434 3
a436 3
  bool device_access_denied (int) __attribute__ ((regparm (2)));
  int fhaccess (int flags, bool) __attribute__ ((regparm (3)));
  virtual bool __stdcall has_ongoing_io () __attribute__ ((regparm (1))) {return false;}
d558 1
a558 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d560 1
a560 1
  inline ssize_t recv_internal (struct _WSAMSG *wsamsg, bool use_recvmsg) __attribute__ ((regparm (3)));
d598 6
a603 6
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fstatvfs (struct statvfs *buf) __attribute__ ((regparm (2)));
  int __stdcall fchmod (mode_t mode) __attribute__ ((regparm (1)));
  int __stdcall fchown (__uid32_t uid, __gid32_t gid) __attribute__ ((regparm (2)));
  int __stdcall facl (int, int, __acl32 *) __attribute__ ((regparm (3)));
  int __stdcall link (const char *) __attribute__ ((regparm (2)));
d641 5
a645 5
  wait_return __stdcall wait_overlapped (bool, bool, DWORD *, bool, DWORD = 0) __attribute__ ((regparm (3)));
  int __stdcall setup_overlapped () __attribute__ ((regparm (1)));
  void __stdcall destroy_overlapped () __attribute__ ((regparm (1)));
  virtual void __stdcall raw_read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
  virtual ssize_t __stdcall raw_write (const void *ptr, size_t len) __attribute__ ((regparm (3)));
d653 1
a653 1
  bool __stdcall has_ongoing_io () __attribute__ ((regparm (1)));
d662 1
a662 1
  static void flush_all_async_io () __attribute__ ((regparm (1)));;
d704 3
a706 3
  int __stdcall fstatvfs (struct statvfs *buf) __attribute__ ((regparm (2)));
  int __stdcall fadvise (_off64_t, _off64_t, int) __attribute__ ((regparm (3)));
  int __stdcall ftruncate (_off64_t, bool) __attribute__ ((regparm (3)));
d733 2
a734 2
  bool wait (HANDLE) __attribute__ ((regparm (2)));
  char *fifo_name (char *, const char *) __attribute__ ((regparm (2)));
d742 1
a742 1
  void __stdcall raw_read (void *ptr, size_t& ulen) __attribute__ ((regparm (3)));
d745 1
a745 1
  int __stdcall fstatvfs (struct statvfs *buf) __attribute__ ((regparm (2)));
d773 1
a773 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d775 1
a775 1
  ssize_t __stdcall raw_write (const void *, size_t) __attribute__ ((regparm (3)));
d822 1
a822 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d884 2
a885 2
  void __stdcall raw_read (void *ptr, size_t& ulen) __attribute__ ((regparm (3)));
  ssize_t __stdcall raw_write (const void *ptr, size_t ulen) __attribute__ ((regparm (3)));
d925 2
a926 2
  void __stdcall raw_read (void *ptr, size_t& ulen) __attribute__ ((regparm (3)));
  ssize_t __stdcall raw_write (const void *ptr, size_t ulen) __attribute__ ((regparm (3)));
d930 1
a930 1
  virtual int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d960 1
a960 1
  int readdir_helper (DIR *, dirent *, DWORD, DWORD, PUNICODE_STRING fname) __attribute__ ((regparm (3)));
d974 11
a984 11
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fchmod (mode_t mode) __attribute__ ((regparm (1)));
  int __stdcall fchown (__uid32_t uid, __gid32_t gid) __attribute__ ((regparm (2)));
  int __stdcall facl (int, int, __acl32 *) __attribute__ ((regparm (3)));
  ssize_t __stdcall fgetxattr (const char *, void *, size_t) __attribute__ ((regparm (3)));
  int __stdcall fsetxattr (const char *, const void *, size_t, int) __attribute__ ((regparm (3)));
  int __stdcall fadvise (_off64_t, _off64_t, int) __attribute__ ((regparm (3)));
  int __stdcall ftruncate (_off64_t, bool) __attribute__ ((regparm (3)));
  int __stdcall link (const char *) __attribute__ ((regparm (2)));
  int __stdcall utimens (const struct timespec *) __attribute__ ((regparm (2)));
  int __stdcall fstatvfs (struct statvfs *buf) __attribute__ ((regparm (2)));
d993 2
a994 2
  DIR *opendir (int fd) __attribute__ ((regparm (2)));
  int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d1000 2
a1001 2
  ssize_t __stdcall pread (void *, size_t, _off64_t) __attribute__ ((regparm (3)));
  ssize_t __stdcall pwrite (void *, size_t, _off64_t) __attribute__ ((regparm (3)));
d1029 4
a1032 4
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fstatvfs (struct statvfs *buf) __attribute__ ((regparm (2)));
  DIR *opendir (int fd) __attribute__ ((regparm (2)));
  int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d1067 2
a1068 2
  DIR *opendir (int fd) __attribute__ ((regparm (2)));
  int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d1071 2
a1072 2
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fstatvfs (struct statvfs *buf) __attribute__ ((regparm (2)));
d1114 2
a1115 2
  void __stdcall raw_read (void *ptr, size_t& ulen) __attribute__ ((regparm (3)));
  ssize_t __stdcall raw_write (const void *ptr, size_t ulen) __attribute__ ((regparm (3)));
d1374 1
a1374 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1482 1
a1482 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1498 3
a1500 3
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fchmod (mode_t mode) __attribute__ ((regparm (1)));
  int __stdcall fchown (__uid32_t uid, __gid32_t gid) __attribute__ ((regparm (2)));
d1542 1
a1542 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1613 1
a1613 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1657 1
a1657 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1692 1
a1692 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1694 1
a1694 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d1729 1
a1729 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d1731 1
a1731 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1766 1
a1766 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1813 1
a1813 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1855 1
a1855 1
  DIR *opendir (int fd) __attribute__ ((regparm (2)));
d1861 1
a1861 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1866 5
a1870 5
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
  int __stdcall fstatvfs (struct statvfs *buf) __attribute__ ((regparm (2)));
  int __stdcall fchmod (mode_t mode) __attribute__ ((regparm (1)));
  int __stdcall fchown (__uid32_t uid, __gid32_t gid) __attribute__ ((regparm (2)));
  int __stdcall facl (int, int, __acl32 *) __attribute__ ((regparm (3)));
d1898 1
a1898 1
  DIR *opendir (int fd) __attribute__ ((regparm (2)));
d1900 1
a1900 1
  int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d1904 1
a1904 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d1929 1
a1929 1
  virtual_ftype_t exists(struct __stat64 *buf) __attribute__ ((regparm (2)));
d1931 2
a1932 2
  DIR *opendir (int fd) __attribute__ ((regparm (2)));
  int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d1938 1
a1938 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1940 1
a1940 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d1967 1
a1967 1
  int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d1969 1
a1969 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d1995 1
a1995 1
  int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d2000 1
a2000 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d2030 2
a2031 2
  DIR *opendir (int fd) __attribute__ ((regparm (2)));
  int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d2038 1
a2038 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d2068 1
a2068 1
  DIR *opendir (int fd) __attribute__ ((regparm (2)));
d2070 1
a2070 1
  int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d2072 1
a2072 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d2099 1
a2099 1
  int readdir (DIR *, dirent *) __attribute__ ((regparm (3)));
d2101 1
a2101 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
@


1.475
log
@	* fhandler.h (class fhandler_dev_raw): Add members devbufalloc and
	devbufalign.
	(class fhandler_dev_floppy): Remove member bytes_per_sector;
	* fhandler_floppy.cc (bytes_per_sector): Define as devbufalign.
	(fhandler_dev_floppy::open): Set devbufalign to a multiple of the
	sector size and handle devbuf allocation and alignment in !O_DIRECT
	case here.  Change comment accordingly.
	Call FSCTL_ALLOW_EXTENDED_DASD_IO for partitions as well.
	(fhandler_dev_floppy::raw_write): Fix comment.  Rewrite and fix
	writing behaviour when application uses read and lseek.
	(fhandler_dev_floppy::lseek): Use rounddown macro.  Call
	SetFilePointerEx rather than the old SetFilePointer.
	(fhandler_dev_floppy::ioctl): Reformat switch.  Call
	IOCTL_DISK_UPDATE_PROPERTIES rather than IOCTL_DISK_UPDATE_DRIVE_SIZE
	in BLKRRPART case.  Support BLKIOMIN, BLKIOOPT, BLKPBSZGET and
	BLKALIGNOFF.
	* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Initialize
	all devbuf-related members.
	(fhandler_dev_raw::~fhandler_dev_raw): Delete devbufalloc rather than
	devbuf.
	(fhandler_dev_raw::open): Drop allocating devbuf.
	(fhandler_dev_raw::dup): Allocate devbufalloc and set devbuf to support
	new sector-aligned devbuf handling.
	(fhandler_dev_raw::fixup_after_exec): Ditto.
	* fhandler_tape.cc (fhandler_dev_tape::open): Ditto, set devbufalign
	to 1.
	* include/cygwin/fs.h (BLKIOMIN): Define.
	(BLKIOOPT): Define.
	(BLKALIGNOFF): Define.
	(BLKPBSZGET): Define.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d1249 1
@


1.474
log
@whitespace cleanup
@
text
@d801 1
d803 1
a860 1
  unsigned long bytes_per_sector;
@


1.473
log
@	* fhandler.h (fhandler_socket::recv_internal): Add bool parameter.
	Add regparm attribute.
	* fhandler_socket.cc (fhandler_socket::read): Call recv_internal with
	second parameter set to false.
	(fhandler_socket::readv): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recv_internal): Convert use_recvmsg from local
	variable to parameter.  Use as request for using WSARecvMsg.  Only
	fail if WSARecvMsg can't be loaded and wsamsg->Control.len > 0,
	otherwise use WSARecv{From}.  Restrict dwFlags to MSG_PEEK when using
	WSARecvMsg.
	(fhandler_socket::recvmsg): Prefer using WSARecvMsg.  Change priority
	of tests for not using WSARecvMsg.  Call recv_internal with second
	parameter set accordingly.
@
text
@d186 1
a186 1
  long dec_refcnt () {return InterlockedDecrement (&_refcnt);} 
@


1.473.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d165 1
a165 1
  ino_t ino;	/* file ID or hashed filename, depends on FS. */
d298 2
a299 2
  dev_t get_dev () { return pc.fs_serial_number (); }
  ino_t get_ino () { return ino ?: ino = hash_path_name (0, pc.get_nt_native_path ()); }
d331 3
a333 3
  virtual int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
  void stat_fixup (struct stat *buf) __attribute__ ((regparm (2)));
  int __stdcall fstat_fs (struct stat *buf) __attribute__ ((regparm (2)));
d335 1
a335 1
  int __stdcall fstat_helper (struct stat *buf,
d338 3
a340 3
  int __stdcall fstat_by_nfs_ea (struct stat *buf) __attribute__ ((regparm (2)));
  int __stdcall fstat_by_handle (struct stat *buf) __attribute__ ((regparm (2)));
  int __stdcall fstat_by_name (struct stat *buf) __attribute__ ((regparm (2)));
d345 1
a345 1
  virtual int __stdcall fchown (uid_t uid, gid_t gid) __attribute__ ((regparm (2)));
d349 2
a350 2
  virtual int __stdcall fadvise (off_t, off_t, int) __attribute__ ((regparm (3)));
  virtual int __stdcall ftruncate (off_t, bool) __attribute__ ((regparm (3)));
d361 4
a364 4
  virtual ssize_t __stdcall pread (void *, size_t, off_t) __attribute__ ((regparm (3)));
  virtual ssize_t __stdcall pwrite (void *, size_t, off_t) __attribute__ ((regparm (3)));
  virtual off_t lseek (off_t offset, int whence);
  virtual int lock (int, struct flock *);
d369 1
a369 1
		       int flags, off_t off);
d373 1
a373 1
				      off_t offset, DWORD size,
d484 6
a489 6
  pid_t sec_pid;
  uid_t sec_uid;
  gid_t sec_gid;
  pid_t sec_peer_pid;
  uid_t sec_peer_uid;
  gid_t sec_peer_gid;
d556 1
a556 1
  int getpeereid (pid_t *pid, uid_t *euid, gid_t *egid);
d575 1
a575 1
  off_t lseek (off_t, int) { return 0; }
d599 1
a599 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d602 1
a602 1
  int __stdcall fchown (uid_t uid, gid_t gid) __attribute__ ((regparm (2)));
d697 1
a697 1
  off_t lseek (off_t offset, int whence);
d706 2
a707 2
  int __stdcall fadvise (off_t, off_t, int) __attribute__ ((regparm (3)));
  int __stdcall ftruncate (off_t, bool) __attribute__ ((regparm (3)));
d774 1
a774 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d821 1
a821 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d858 1
a858 1
  off_t drive_size;
d870 1
a870 1
  inline off_t get_current_position ();
d886 1
a886 1
  off_t lseek (off_t offset, int whence);
d928 1
a928 1
  virtual off_t lseek (off_t offset, int whence);
d930 1
a930 1
  virtual int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d972 1
a972 1
  int lock (int, struct flock *);
d974 1
a974 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d976 1
a976 1
  int __stdcall fchown (uid_t uid, gid_t gid) __attribute__ ((regparm (2)));
d980 2
a981 2
  int __stdcall fadvise (off_t, off_t, int) __attribute__ ((regparm (3)));
  int __stdcall ftruncate (off_t, bool) __attribute__ ((regparm (3)));
d986 1
a986 1
  HANDLE mmap (caddr_t *addr, size_t len, int prot, int flags, off_t off);
d990 1
a990 1
			      off_t offset, DWORD size, void *address);
d1000 2
a1001 2
  ssize_t __stdcall pread (void *, size_t, off_t) __attribute__ ((regparm (3)));
  ssize_t __stdcall pwrite (void *, size_t, off_t) __attribute__ ((regparm (3)));
d1029 1
a1029 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d1071 1
a1071 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d1123 1
a1123 1
  off_t lseek (off_t, int) { return 0; }
d1193 1
a1193 1
  virtual off_t lseek (off_t, int);
d1440 1
a1440 1
  off_t lseek (off_t, int);
d1497 1
a1497 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d1499 1
a1499 1
  int __stdcall fchown (uid_t uid, gid_t gid) __attribute__ ((regparm (2)));
d1613 1
a1613 1
  off_t lseek (off_t offset, int whence);
d1616 1
a1616 1
		       int flags, off_t off);
d1620 1
a1620 1
				      off_t offset, DWORD size,
d1646 1
a1646 1
  off_t dummy_offset;
d1657 1
a1657 1
  off_t lseek (off_t offset, int whence);
d1683 1
a1683 1
  off_t pos;
d1692 2
a1693 2
  off_t lseek (off_t offset, int whence);
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d1695 1
a1695 1
  HANDLE mmap (caddr_t *addr, size_t len, int prot, int flags, off_t off);
d1699 1
a1699 1
			      off_t offset, DWORD size, void *address);
d1721 1
a1721 1
  off_t pos;
d1728 1
a1728 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d1731 1
a1731 1
  off_t lseek (off_t offset, int whence);
d1767 1
a1767 1
  off_t lseek (off_t, int) { return 0; }
d1814 1
a1814 1
  off_t lseek (off_t, int);
d1845 2
a1846 2
  off_t filesize;
  off_t position;
d1861 1
a1861 1
  off_t lseek (off_t, int);
d1865 1
d1868 1
a1868 1
  int __stdcall fchown (uid_t uid, gid_t gid) __attribute__ ((regparm (2)));
d1903 1
a1903 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d1928 1
a1928 1
  virtual_ftype_t exists(struct stat *buf) __attribute__ ((regparm (2)));
d1939 1
a1939 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d1968 1
a1968 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d1999 1
a1999 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d2037 1
a2037 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d2071 1
a2071 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d2100 1
a2100 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
@


1.473.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d186 1
a186 1
  long dec_refcnt () {return InterlockedDecrement (&_refcnt);}
a800 1
  char *devbufalloc;
a801 1
  size_t devbufalign;
d859 1
@


1.473.2.3
log
@	Avoid various type ambiguity problems showing up in the 64 bit case:
	* cygheap.h (cygheap_user::set_sid): Convert to void.
	(cygheap_user::set_saved_sid): Ditto.
	* devices.h (struct device): Drop operator int& and DWORD& entirely.
	Throughout, use dev_t or fh_devices instead.
	* devices.cc: Regenerate.
	* fhandler.h (class fhandler_base): Convert _refcnt member to LONG.
	(fhandler_base::inc_refcnt): Return LONG.
	(fhandler_base::dec_refcnt): Ditto.
	(fhandler_base::get_major): Return _major_t.
	(fhandler_base::get_minor): Return _minor_t.
	(fhandler_base::get_unit): Delete.  Throughout, use get_minor instead
	of get_unit.
	(fhandler_socket::get_socket): Use SOCKET rather than int.  Only define
	if __INSIDE_CYGWIN_NET__ is defined.
	(fhandler_pty_slave::get_unit): Drop declaration.
	* fhandler_procnet.cc: Include Windows headers early.
	* fhandler_socket.cc: Ditto.
	* fhandler_tty.cc (fhandler_pty_slave::get_unit): Remove.
	* path.h (path_conv::get_device): Rename from get_devn and change return
	type to dev_t.  Accommodate throughout.
	(path_conv::get_unitn): Remove unused method.
	* pinfo.h (class pinfo): Drop operator== for int case.
	(pinfo::operator!): Define.
	* poll.cc: Don't define __INSIDE_CYGWIN_NET__.
	* syscalls.cc (getpgid): Replace use of pinfo::operator== with
	pinfo::operator!.
	* tty.h (tty_min::setntty): Convert 2nd parameter to _minor_t.
	* tty.h (tty_min::getntty): Change return type to dev_t.
	(tty_min::get_minor): Rename from get_unit.  Change return type to
	_minor_t.
@
text
@d166 1
a166 1
  LONG _refcnt;
d185 2
a186 2
  LONG inc_refcnt () {return InterlockedIncrement (&_refcnt);}
  LONG dec_refcnt () {return InterlockedDecrement (&_refcnt);}
d212 4
a215 3
  dev_t& get_device () { return dev (); }
  _major_t get_major () { return dev ().get_major (); }
  _minor_t get_minor () { return dev ().get_minor (); }
d540 1
a540 8
/* Originally get_socket returned an int, which is not a good idea
   to cast a handle to on 64 bit.  The right type here is very certainly
   SOCKET instead.  On the other hand, we don't want to have to include
   winsock.h just to build fhandler.h.  Therefore we define get_socket
   now only when building network related code. */
#ifdef __INSIDE_CYGWIN_NET__
  SOCKET get_socket () { return (SOCKET) get_handle(); }
#endif
d1496 1
@


1.473.2.4
log
@	* fcntl.cc (fcntl64): Make arg an intptr_t.  Add comment to explain a
	potential type problem.  Fix syscall_printf.
	(_fcntl): Make arg an intptr_t.
	* fhandler.cc (fhandler_base::fcntl): Ditto.
	* fhandler_socket.cc (fhandler_socket::fcntl): Ditto.
	* fhandler.h: Align declarations.
@
text
@d354 1
a354 1
  virtual int fcntl (int cmd, intptr_t);
d580 1
a580 1
  int fcntl (int cmd, intptr_t);
@


1.473.2.5
log
@	* cpuid.h (can_set_flag): Implement for x86_64.
	* fhandler.h (class fhandler_dev_raw): Define devbuf members taking
	numerical values as DWORD, rather than size_t.
	* fhandler_dsp.cc: Fix debug printf calls to be type safe.
	(waveOut_callback): Align parameter types to latest MSDN description.
	(waveIn_callback): Ditto.
	(fhandler_dev_dsp::Audio_out::start): Change casts in call to
	waveOutOpen according to MSDN.
	(fhandler_dev_dsp::Audio_out::parsewav): Fix a cast.
	(fhandler_dev_dsp::Audio_in::start): Change casts in call to
	waveInOpen according to MSDN.
	* fhandler_floppy.cc: Fix debug printf calls to be type safe.
	(fhandler_dev_floppy::ioctl): Add casts to be on the safe side.
	* fhandler_proc.cc: Fix debug printf calls to be type safe.
@
text
@d809 4
a812 4
  DWORD devbufalign;
  DWORD devbufsiz;
  DWORD devbufstart;
  DWORD devbufend;
@


1.473.2.6
log
@	* cygheap.h (struct user_heap_info): Change type of chunk to SIZE_T.
	Remove unused slop member.
	* fork.cc (fork): Rename esp to stackp.  Add 64 bit asm expression to
	fetch stack pointer.
	(child_copy): Use platform independent types.
	* heap.cc (eval_start_address): Add comment. Disable 3GB code on 64 bit.
	(eval_initial_heap_size): Use platform independent types.  Fix debug
	printf format strings.
	(sbrk): Add comment.  Change argument type according to newlib
	definition.  Use platform independent types.  Drop unneeded else and
	move comment to the right spot.
	* hookapi.cc (PEHeaderFromHModule): Return PVOID.  Add comment to
	explain why.  Add bool parameter to return if target executable is
	64 bit or not.
	(rvadelta_get): New inline function to fetch section address platform
	independent.
	(rvadelta32, rvadelta64): Platform dependent wrappers.
	(rvadelta): Change to macro calling the platform dependent rvadelta
	wrappers.
	(putmem): Define platform dependent THUNK_FUNC_TYPE and use throughout.
	(RedirectIAT): Add comment.
	(get_export): Add comment.
	(find_first_notloaded_dll): Allow to fetch information in a platform
	and target independent way.
	(hook_or_detect_cygwin): Ditto.  Recognize the cyg64win1.dll file name
	as well.
	* kernel32.cc (CreateFileMappingW): Cast to avoid compiler warning.

	* fhandler.h (class fhandler_dev_tape): Replace mt_evt with an
	OVERLAPPED structure ov.
	* mtinfo.h (class mtinfo_part): Define members as int32_t rather than
	long.  Change member function declarations accordingly.
	(class mtinfo_drive): Ditto.  Store OVERLAPPED pointer rather than
	holding the full structure.  Add comment to explain why.
	* fhandler_tape.cc: Accommodate above changes throughout.
@
text
@d917 1
a917 1
  OVERLAPPED ov;
@


1.473.2.7
log
@	* include/cygwin/acl.h (struct __acl32): Drop.  Use struct acl or
	aclent_t throughout instead.
	* sec_acl.cc (aclcheck32): Mark currently unused variables as unused.
	(lacl32): Disable on x86_64.
	(acl): Alias to acl32 on x86_64.
	(facl): Alias to facl32 on x86_64.
	(aclcheck): Alias to aclcheck32 on x86_64.
	(aclsort): Alias to aclsort32 on x86_64.
	(acltomode): Alias to acltomode32 on x86_64.
	(aclfrommode): Alias to aclfrommode32 on x86_64.
	(acltopbits): Alias to acltopbits32 on x86_64.
	(aclfrompbits): Alias to aclfrompbits32 on x86_64.
	(acltotext): Alias to acltotext32 on x86_64.
	(aclfromtext): Alias to aclfromtext32 on x86_64.
	* resource.cc (getrlimit): Use correct cast to rlim_t rather than DWORD.
	* sched.cc (sched_setparam): Drop ThreadPriority and all code setting
	it.
@
text
@d58 1
a58 1
struct acl;
d345 1
a345 1
  virtual int __stdcall facl (int, int, struct acl *) __attribute__ ((regparm (3)));
d609 1
a609 1
  int __stdcall facl (int, int, struct acl *) __attribute__ ((regparm (3)));
d984 1
a984 1
  int __stdcall facl (int, int, struct acl *) __attribute__ ((regparm (3)));
d1874 1
a1874 1
  int __stdcall facl (int, int, struct acl *) __attribute__ ((regparm (3)));
@


1.473.2.8
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d1688 1
a1688 1
  SIZE_T mem_size;
@


1.473.2.9
log
@Pull in changes from HEAD
@
text
@a1254 1
  bool saw_space;
@


1.473.2.10
log
@Fix copyrights
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.473.2.11
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d330 3
a332 3
  virtual int __reg2 fstat (struct stat *buf);
  void __reg2 stat_fixup (struct stat *buf);
  int __reg2 fstat_fs (struct stat *buf);
d334 6
a339 5
  int __reg3 fstat_helper (struct stat *buf,
			      DWORD nNumberOfLinks);
  int __reg2 fstat_by_nfs_ea (struct stat *buf);
  int __reg2 fstat_by_handle (struct stat *buf);
  int __reg2 fstat_by_name (struct stat *buf);
d341 12
a352 12
  virtual int __reg2 fstatvfs (struct statvfs *buf);
  int __reg2 utimens_fs (const struct timespec *);
  virtual int __reg1 fchmod (mode_t mode);
  virtual int __reg2 fchown (uid_t uid, gid_t gid);
  virtual int __reg3 facl (int, int, struct acl *);
  virtual ssize_t __reg3 fgetxattr (const char *, void *, size_t);
  virtual int __reg3 fsetxattr (const char *, const void *, size_t, int);
  virtual int __reg3 fadvise (off_t, off_t, int);
  virtual int __reg3 ftruncate (off_t, bool);
  virtual int __reg2 link (const char *);
  virtual int __reg2 utimens (const struct timespec *);
  virtual int __reg1 fsync ();
d356 1
a356 1
  virtual void __reg3 read (void *ptr, size_t& len);
d360 2
a361 2
  virtual ssize_t __reg3 pread (void *, size_t, off_t);
  virtual ssize_t __reg3 pwrite (void *, size_t, off_t);
d398 2
a399 2
  virtual void __reg3 raw_read (void *ptr, size_t& ulen);
  virtual ssize_t __reg3 raw_write (const void *ptr, size_t ulen);
d425 2
a426 2
  virtual __reg2 DIR *opendir (int fd);
  virtual __reg3 int readdir (DIR *, dirent *);
d434 3
a436 3
  bool __reg2 device_access_denied (int);
  int __reg3 fhaccess (int flags, bool);
  virtual bool __reg1 has_ongoing_io ()  {return false;}
d565 1
a565 1
  void __reg3 read (void *ptr, size_t& len);
d567 1
a567 1
  inline ssize_t __reg3 recv_internal (struct _WSAMSG *wsamsg, bool use_recvmsg);
d605 6
a610 6
  int __reg2 fstat (struct stat *buf);
  int __reg2 fstatvfs (struct statvfs *buf);
  int __reg1 fchmod (mode_t mode);
  int __reg2 fchown (uid_t uid, gid_t gid);
  int __reg3 facl (int, int, struct acl *);
  int __reg2 link (const char *);
d648 5
a652 5
  wait_return __reg3 wait_overlapped (bool, bool, DWORD *, bool, DWORD = 0);
  int __reg1 setup_overlapped ();
  void __reg1 destroy_overlapped ();
  virtual void __reg3 raw_read (void *ptr, size_t& len);
  virtual ssize_t __reg3 raw_write (const void *ptr, size_t len);
d660 1
a660 1
  bool __reg1 has_ongoing_io ();
d669 1
a669 1
  static void __reg1 flush_all_async_io ();;
d711 3
a713 3
  int __reg2 fstatvfs (struct statvfs *buf);
  int __reg3 fadvise (off_t, off_t, int);
  int __reg3 ftruncate (off_t, bool);
d740 2
a741 2
  bool __reg2 wait (HANDLE);
  char __reg2 *fifo_name (char *, const char *);
d749 1
a749 1
  void __reg3 raw_read (void *ptr, size_t& ulen);
d752 1
a752 1
  int __reg2 fstatvfs (struct statvfs *buf);
d780 1
a780 1
  int __reg2 fstat (struct stat *buf);
d782 1
a782 1
  ssize_t __reg3 raw_write (const void *, size_t);
d829 1
a829 1
  int __reg2 fstat (struct stat *buf);
d891 2
a892 2
  void __reg3 raw_read (void *ptr, size_t& ulen);
  ssize_t __reg3 raw_write (const void *ptr, size_t ulen);
d932 2
a933 2
  void __reg3 raw_read (void *ptr, size_t& ulen);
  ssize_t __reg3 raw_write (const void *ptr, size_t ulen);
d937 1
a937 1
  virtual int __reg2 fstat (struct stat *buf);
d967 1
a967 1
  int __reg3 readdir_helper (DIR *, dirent *, DWORD, DWORD, PUNICODE_STRING fname);
d981 11
a991 11
  int __reg2 fstat (struct stat *buf);
  int __reg1 fchmod (mode_t mode);
  int __reg2 fchown (uid_t uid, gid_t gid);
  int __reg3 facl (int, int, struct acl *);
  ssize_t __reg3 fgetxattr (const char *, void *, size_t);
  int __reg3 fsetxattr (const char *, const void *, size_t, int);
  int __reg3 fadvise (off_t, off_t, int);
  int __reg3 ftruncate (off_t, bool);
  int __reg2 link (const char *);
  int __reg2 utimens (const struct timespec *);
  int __reg2 fstatvfs (struct statvfs *buf);
d1000 2
a1001 2
  DIR __reg2 *opendir (int fd);
  int __reg3 readdir (DIR *, dirent *);
d1007 2
a1008 2
  ssize_t __reg3 pread (void *, size_t, off_t);
  ssize_t __reg3 pwrite (void *, size_t, off_t);
d1036 4
a1039 4
  int __reg2 fstat (struct stat *buf);
  int __reg2 fstatvfs (struct statvfs *buf);
  DIR __reg2 *opendir (int fd);
  int __reg3 readdir (DIR *, dirent *);
d1074 2
a1075 2
  DIR __reg2 *opendir (int fd);
  int __reg3 readdir (DIR *, dirent *);
d1078 2
a1079 2
  int __reg2 fstat (struct stat *buf);
  int __reg2 fstatvfs (struct statvfs *buf);
d1121 2
a1122 2
  void __reg3 raw_read (void *ptr, size_t& ulen);
  ssize_t __reg3 raw_write (const void *ptr, size_t ulen);
d1381 1
a1381 1
  void __reg3 read (void *ptr, size_t& len);
d1489 1
a1489 1
  void __reg3 read (void *ptr, size_t& len);
d1504 3
a1506 3
  int __reg2 fstat (struct stat *buf);
  int __reg1 fchmod (mode_t mode);
  int __reg2 fchown (uid_t uid, gid_t gid);
d1548 1
a1548 1
  void __reg3 read (void *ptr, size_t& len);
d1619 1
a1619 1
  void __reg3 read (void *ptr, size_t& len);
d1663 1
a1663 1
  void __reg3 read (void *ptr, size_t& len);
d1698 1
a1698 1
  void __reg3 read (void *ptr, size_t& len);
d1700 1
a1700 1
  int __reg2 fstat (struct stat *buf);
d1735 1
a1735 1
  int __reg2 fstat (struct stat *buf);
d1737 1
a1737 1
  void __reg3 read (void *ptr, size_t& len);
d1772 1
a1772 1
  void __reg3 read (void *ptr, size_t& len);
d1819 1
a1819 1
  void __reg3 read (void *ptr, size_t& len);
d1861 1
a1861 1
  DIR __reg2 *opendir (int fd);
d1867 1
a1867 1
  void __reg3 read (void *ptr, size_t& len);
d1872 4
a1875 4
  int __reg2 fstatvfs (struct statvfs *buf);
  int __reg1 fchmod (mode_t mode);
  int __reg2 fchown (uid_t uid, gid_t gid);
  int __reg3 facl (int, int, struct acl *);
d1903 1
a1903 1
  DIR __reg2 *opendir (int fd);
d1905 1
a1905 1
  int __reg3 readdir (DIR *, dirent *);
d1909 1
a1909 1
  int __reg2 fstat (struct stat *buf);
d1934 1
a1934 1
  virtual_ftype_t __reg2 exists(struct stat *buf);
d1936 2
a1937 2
  DIR __reg2 *opendir (int fd);
  int __reg3 readdir (DIR *, dirent *);
d1943 1
a1943 1
  void __reg3 read (void *ptr, size_t& len);
d1945 1
a1945 1
  int __reg2 fstat (struct stat *buf);
d1972 1
a1972 1
  int __reg3 readdir (DIR *, dirent *);
d1974 1
a1974 1
  int __reg2 fstat (struct stat *buf);
d2000 1
a2000 1
  int __reg3 readdir (DIR *, dirent *);
d2005 1
a2005 1
  int __reg2 fstat (struct stat *buf);
d2035 2
a2036 2
  DIR __reg2 *opendir (int fd);
  int __reg3 readdir (DIR *, dirent *);
d2043 1
a2043 1
  int __reg2 fstat (struct stat *buf);
d2073 1
a2073 1
  DIR __reg2 *opendir (int fd);
d2075 1
a2075 1
  int __reg3 readdir (DIR *, dirent *);
d2077 1
a2077 1
  int __reg2 fstat (struct stat *buf);
d2104 1
a2104 1
  int __reg3 readdir (DIR *, dirent *);
d2106 1
a2106 1
  int __reg2 fstat (struct stat *buf);
@


1.472
log
@	* fhandler.h (class fhandler_dev_clipboard): Remove member eof.
	* fhandler_clipboard.cc: Throughout remove handling of eof member.
	(fhandler_dev_clipboard::write): Handle EOF condition immediately,
	rather than pushing it erroneously to the next read call.  Rearrange
	code.  Fix bug in CF_UNICODETEXT case which potentially dropped single
	bytes at the end of the buffer.  Add comment.
	* strfuncs.cc (sys_cp_wcstombs): Allow returning non-NUL-terminated
	buffer if dst != NULL and len == (size_t) -1.  Extend leading comment
	to explain what's returned in more detail.
@
text
@d561 1
a561 1
  inline ssize_t recv_internal (struct _WSAMSG *wsamsg);
@


1.471
log
@* DevNotes: Add entry cgf-000011.
* fhandler.h (fhandler_base::refcnt): Delete.
(fhandler_base::inc_refcnt): New function.
(fhandler_base::dec_refcnt): New function.
* cygheap.h (cygheap_fdnew::~cygheap_fdnew): Accommodate split of refcnt to
inc_refcnt/dec_refcnt.
(cygheap_fdget::cygheap_fdget): Ditto.
(cygheap_fdget::~cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable::release): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::init_std_file_from_handle): Ditto.
(dtable::dup3): On success, return with fdtab locked.
* dtable.h (dtable): Add dup_finish as a friend.
* syscalls.cc (dup_finish): Define new function.  Increment refcnt while fdtab
is locked.
(dup2): Use common dup_finish() to perform dup operation.
(dup3): Ditto.
@
text
@a1723 1
  bool eof;
@


1.470
log
@	* fhandler.h (refcnt): Add i interlocked.  Explain why.
	* winbase.h (ilockadd): New function.
	(InterlockedAdd): Define as ilockadd.
@
text
@d185 2
a186 9
  long refcnt(long i = 0)
  {
    debug_only_printf ("%p, %s, i %d, refcnt %ld", this, get_name (), i, _refcnt + i);
    /* This MUST be an interlocked operation.  If multiple threads access the
       same descriptor in quick succession, a context switch can interrupt
       the += operation and we wrongly end up with a refcnt of 0 in the
       cygheap_fdget destructor. */
    return i ? InterlockedAdd (&_refcnt, i) : _refcnt;
  }
@


1.469
log
@* DevNotes: Add entry cgf-000005.
* fhandler.h (PIPE_ADD_PID): Redefine to something we actually DON'T use.
* pipe.cc (fhandler_pipe::create): Avoid clearing all open_mode bits when
checking for PIPE_ADD_PID.  Properly keep track of len so that passed in name
is not overwritten.
@
text
@d188 5
a192 1
    return _refcnt += i;
@


1.468
log
@* fhandler.h (PIPE_ADD_PID): Define new flag.
* pipe.cc (fhandler_pipe::create): Don't indiscriminately add process id to
every pipe since some pipe names (fifo, tty) don't need it.
* sigproc.cc (sigproc_init): Pass PIPE_ADD_PID to fhandler_pipe::create to
ensure that pid is always part of sigwait pipe name.
@
text
@d41 1
a41 1
#define PIPE_ADD_PID	PIPE_ACCESS_OUTBOUND
@


1.467
log
@	* fhandler.h (class dev_console): Add member ext_mouse_mode5.
	* fhandler_console.cc (fhandler_console::read): Implement extended
	mouse mode 1005 (xterm, mintty).
	Fix actual mouse reporting for large coordinates.
@
text
@d17 2
a18 2
#define O_NOSYMLINK 0x080000
#define O_DIROPEN   0x100000
d39 4
@


1.466
log
@	* fhandler.h (class dev_console): Add members ext_mouse_mode6 and
	ext_mouse_mode15.
	* fhandler_console.cc (fhandler_console::read): Implement extended
	mouse modes 1015 (urxvt, mintty, xterm) and 1006 (xterm).  Recognize,
	but don't implement extended mouse mode 1005 (xterm, mintty).
	Support mouse coordinates greater than 222 (each axis).  Fix formatting.
	(fhandler_console::char_command): Initialize enhanced mouse reporting
	modes.
@
text
@d1291 1
@


1.465
log
@* fhandler.h (fhandler_base::nohandle): Revert to standard implementation.
* dtable.cc (dtable::fixup_after_exec): Specifically reject releasing
nohandle() type fhandlers rather than relying on contents of io_handle.
(dtable::fixup_after_fork): Ditto.
* fhandler_termios.cc: Add includes necessary for definitions of have_execed
and have_execed_cygwin.
(fhandler_termios::sigflush): Don't flush console input when we've started a
non-Cygwin process.
@
text
@d1291 2
@


1.464
log
@wincap.h: Rename assitant to assistant throughout.  wincap.cc: Ditto.
* devices.in (exists_console): Use fhandler_console::exists () rather than raw
test.
* devices.cc: Regenerate.
* fhandler.h (fhandler_console::exists): Define new function.
* fhandler_console.cc (fhandler_console::need_invisible): Use
fhandler_console::exists () rather than raw test.
* spawn.cc: Rename assitant to assistant throughout.
(child_info_spawn::worker): Simplify test for when to start a non-Cygwin
process in its own process group.  Just do it whenever we start a non-Cygwin
process.
@
text
@d244 1
a250 8
  bool nohandle () const {return !!status.nohandle;}
  bool nohandle (bool val)
  {
    if ((status.nohandle = val))
      io_handle = INVALID_HANDLE_VALUE;
    return val;
  }

@


1.463
log
@* fhandler.h (fhandler_base::nohandle): Implement "by hand" rather than through
macro.  Set io_handle to INVALID_HANDLE_VALUE when setting flag to true.
@
text
@d1380 1
@


1.462
log
@* fhandler.h (fhandler_pty_common::bytes_available): Declare new function.
(fhandler_pty_master::flush_to_slave): Ditto.
* fhandler_tty.cc (bytes_available): Define new function.
(fhandler_pty_common::bytes_available): Ditto.
(handler_pty_master::flush_to_slave): Ditto.
(fhandler_pty_master::process_slave_output): Call flush_to_slave () here.  Use
bytes_available () rather than PeekNamedPipe.  Cleanup sloppy logic.
(fhandler_pty_slave::read): Use bytes_available () rather than PeekNamedPipe.
(fhandler_pty_slave::ioctl): Ditto.
(fhandler_pty_master::ioctl): Ditto.
(fhandler_pty_master::cleanup): Remove ancient #if 0.
* select.cc (peek_pipe): Call flush_to_slave whenever we're checking for a pty
master.
@
text
@a243 1
  IMPLEMENT_STATUS_FLAG (bool, nohandle)
d250 8
@


1.461
log
@	* fhandler.h (fhandler_base::stat_fixup): Rename from
	fhandler_base::set_ino_and_dev.
	* syscalls.cc (fhandler_base::stat_fixup): Ditto. Accommodate name
	change throughout.  Fixup link count of console devices.
@
text
@d1436 1
d1553 1
@


1.460
log
@	* fhandler.h (fhandler_base::set_ino_and_dev): Declare.
	* syscalls.cc (fhandler_base::set_ino_and_dev): New method to set
	st_ino, st_dev, and st_rdev for devices in a single spot.
	(fstat64): Call fhandler_base::set_ino_and_dev instead of setting
	st_ino, st_dev, and st_rdev here.
	(stat_worker): Ditto.
@
text
@d331 1
a331 1
  void set_ino_and_dev (struct __stat64 *buf) __attribute__ ((regparm (2)));
@


1.459
log
@	* fhandler.h (fhandler_dev::open): Declare.
	(fhandler_dev::close): Declare.
	(fhandler_dev::fstat): Declare.
	(fhandler_dev::fstatvfs): Declare.
	(fhandler_cygdrive::fstatvfs): Declare.
	* fhandler_dev.cc (fhandler_dev::open): New method.
	(fhandler_dev::close): Ditto.
	(fhandler_dev::fstat): Ditto.
	(fhandler_dev::fstatvfs): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't fill
	st_rdev.
	(fhandler_cygdrive::fstatvfs): New method.
	* path.h (path_conv::fs_got_fs): New method.
	* mount.h (fs_info::got_fs): Change type to bool, make public.
@
text
@d331 1
@


1.458
log
@(Interim checkin while we work on this)
* devices.cc: Regenerate.
* devices.h (device::noexpose): New field.
(device::dev_on_fs): Make a bit field.
(get_major): Use proper type for declaration.
(expose): New field.
(ext_dev_storage): Delete declaration.
(dev_storage_size): Ditto.
(dev_storage): New declaration.
(dev_storage_end): Ditto.
* devices.in: Mark /dev/ptym*, /dev/com*, /dev/pipe, /dev/fifo, and "/dev" as
"no expose".
* fhandler.h (fhandler_dev::lastrealpos): Delete declaration.
(fhandler_dev::devidx): Declare new field.
* fhandler_disk_file.cc: Move fhandler_dev functions into fhandler_dev.cc.
* fhandler_dev.cc: Add includes needed for functions moved from
fhandler_disk_file.cc.
(dev_storage_scan_start): Define place to start listing devices.
(dev_storage_size): Define size of array to scan.
(fhandler_dev::fhandler_dev): Move here from fhandler_disk_file.cc.
(fhandler_dev::opendir): Ditto.
(fhandler_dev::readdir): Just check devidx for non-NULL to determine when to go
to disk for /dev content.  Use dev_storage rather than ext_dev_storage.
Iterate over dev_storage using devidx pointer.  Use accessor functions rather
than raw references to the device struct.  Only increment dir->__d_position
when we are actually going to be returning something.  Add debug_printf for
exit.
(fhandler_dev::rewinddir): Set devidx as appropriate depending on whether
there's a /dev on disk or not.
* gendevices: Don't mark dev_storage static but do put it in the _RDATA
section.
* path.cc (path_conv::check): Use new "device::expose()" function to decide to
forbid programs from referencing internal device types.
@
text
@d1025 4
d1070 1
@


1.457
log
@	* Makefile.in (DLL_OFILES): Add fhandler_dev.o.
	* devices.h (DEV_DEV_MAJOR): Define.
	(FH_DEV): Redefine in terms of DEV_DEV_MAJOR.
	(ext_dev_storage): Declare.
	(dev_storage_size): Declare.
	(dev_dev_storage): Declare.
	(dev_dev): Define.
	(isdev_dev): Define.
	* devices.in (dev_dev_storage): Activate.
	(ext_dev_storage): Define as externally available pointer to
	dev_storage.
	(dev_storage_size): Define to contain number of dev_storage elements.
	* dir.cc (rmdir): Handle /dev as always not empty.
	* dtable.cc (fh_alloc): Handle DEV_DEV_MAJOR.
	* fhandler.h (fhandler_dev): New class, derived from fhandler_disk_file.
	(fhandler_union): Add fhandler_dev member.
	* fhandler_disk_file.cc (class __DIR_mounts): Handle /dev directory
	to make sure it always exists.
	* fhandler_dev.cc: New file implementing /dev.
	* globals.cc (ro_u_dev): New R/O unicode string.
	* path.cc (path_conv::check): Handle FH_DEV device.
@
text
@d1021 1
a1021 1
  int lastrealpos;
@


1.456
log
@	* fhandler.h (class fhandler_dev_clipboard): Add fstat method.
	* fhandler_clipboard.cc (cygcb_t): New type for Cygwin-specific
	clipboard format.
	(set_clipboard): Use new clipboard format to allow setting a timestamp.
	(fhandler_dev_clipboard::fstat): New method.  Read modification and
	access timestamp as well as length from clipboard data.
	(fhandler_dev_clipboard::read): Use new clipboard format.
@
text
@d1019 28
d2124 1
@


1.455
log
@Christopher Faylor <me.cygwin2012@@cgf.cx>
* fhandler.h (wait_return): Add overlapped_nullread.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Detect zero-byte
read as a special case.
(fhandler_base_overlapped::raw_read): Keep looping when zero-byte read detected
without EOF.
(fhandler_base_overlapped::raw_write): Quiet gcc warning by adding
overlapped_nullread to switch statement even though it will never actually be
hit.
@
text
@d1688 1
@


1.454
log
@tcgetsid: fix return type

* include/sys/termios.h (tcgetsid): Fix return type.
* termios.cc (tcgetsid): Likewise.
* fhandler_termios.cc (fhandler_termios::tcgetsid): Likewise.
* fhandler.h (fhandler_base): Likewise.
* fhandler.cc (fhandler_base::tcgetsid): Likewise.
@
text
@d632 1
@


1.453
log
@* cygheap.cc (init_cygheap::manage_console_count): Delete.
* cygheap.h (init_cygheap::manage_console_count): Ditto.
(init_cygheap::console_count): Ditto.
* fhandler.h (fhandler_console::has_a): Ditto.
(fhandler_console::free_console): Declare new function.
* fhandler_console.cc (fhandler_console::free_console): Define new function.
(fhandler_console::open_setup): Delete call to manage_console_count.
(fhandler_console::close): Ditto.  Replace with call to free_console().
* fhandler_tty.cc (fhandler_pty_slave::open): Delete call to
manage_console_count.
(fhandler_pty_slave::cleanup): Ditto.
(fhandler_pty_slave::close): Call fhandler_console::free_console() if this is
our controlling tty.
* pinfo.cc (_pinfo::set_ctty): Skip function if tty in question == our ctty.
Delete call to manage_console_count.
* syscalls.cc (close_all_files): Avoid locking and avoid setting errno when
iterating over fds.
@
text
@d386 1
a386 1
  virtual int tcgetsid ();
d1158 1
a1158 1
  int tcgetsid ();
@


1.452
log
@* fhandler.h (fhandler_fifo::arm): Declare new function.
* fhandler_fifo.cc (fhandler_fifo::arm): Define new function.
(fhandler_fifo::open): Fix handling of RDWR pipes to avoid opening a second
handle.  Use arm() function to set events.
(fhandler_fifo::raw_read): Correctly go into "connect again logic" when we
detect another writer is available.  Use arm() function to set event.
* pipe.cc (fhandler_pipe::create): Add more detail to debugging output.
@
text
@d1360 1
a1360 1
  static bool has_a () {return !invisible_console;}
@


1.451
log
@* cygheap.h (cygheap_fdget::~cygheap_fdget): Simplify now that refcnt reports
reference count changes itself.
* fhandler.cc (fhandler_base::reset): Set _refcnt to 0.
* fhandler.h (fhandler_base::refcnt): Report refcnt when debugging.
* select.cc (cygwin_select): Set return_on_signal to indicate when select
should be interrupted.
(select_stuff::wait): Keep looping unless return_on_signal is set.
* select.h (select_stuff::return_on_signal): New variable.
(select_stuff::select_stuff): Zero return_on_signal.
@
text
@d741 1
@


1.450
log
@	* fhandler.h (fhandler_registry::opendir): Declare.
	* fhandler_registry.cc (fhandler_registry::opendir): New function.
@
text
@d181 5
a185 1
  long refcnt(long i = 0) {return _refcnt += i;}
@


1.449
log
@Update copyright on all files checked in so far this year.
* fhandler.h: Use #pragma once rather than ifdef guards.
(fhandler_console::tc_getpgid): Return our pgid if we have never opened a
console.
* fork.cc: Rearrange includes to accommodate fhandler.h use of pinfo.h.
* sigproc.cc: Ditto.
* spawn.cc: Ditto.
(child_info_spawn::worker): Query myself->pgid rather than calling expensive
function.
* thread.h: Use #pragma once rather than ifdef guards.
* pinfo.h: Use #pragma once rather than ifdef guards.
(pinfo::remember): Don't define if sigproc.h has not been included.
(pinfo::reattach): Ditto.
* sigproc.h: Use #pragma once rather than ifdef guards.  Use different test to
see if pinfo.h has been included.
@
text
@d1982 1
@


1.448
log
@Implement fhandler reference counting.
* cygheap.h
(cygheap_fdmanip::release): Make virtual.
(cygheap_fdnew::~cygheap_fdnew): New destructor increments reference count when
fd has been allocated.
(cygheap_fdget::fh): New (old?) field.
(cygheap_fdget::cygheap_fdget): Increment reference count when we've found an
active fd.  Set fh appropriately.
(cygheap_fdget::~cygheap_fdget): Decrement reference count when appropriate.
Delete fh if reference count goes to zero.
(cygheap_fdget::release): New function.  Do more bookkeping on release.
* dtable.cc (dtable::release): Change from void to boolean return.  Only delete
the fhandler when its reference count is <= 0 (this should be a fairly unusual
case).  Return true if fhandler has been deleted.
(cygwin_attach_handle_to_fd): Increment reference count when fh is assigned.
(dtable::init_std_file_from_handle): Ditto.
* dtable.h (dtable::release): Change return to boolean.
* fhandler.cc (fhandler_base::fhandler_base): Set new isclosed flag to false.
Set _refcnt to zero.
(fhandler_base::close): Simplify paranoid debugging output.  Set new isclosed()
flag.
(fhandler_base_overlapped::wait_overlapped): Use isclosed() flag to avoid
querying the exception handle.
* fhandler.h (fhandler_base::_refcnt): New field.
(fhandler_base::refcnt): New function.
(fhandler_base::isclosed): Implement.
(fhandler_base::fhandler_base): Set isclosed to false.
* syscalls.cc: Remove space after function before parentheses for several
strace printfs.
(dup): Add standard strace "leaver" code.
(dup2): Ditto.
(dup3): Ditto.
(remove): Ditto.
(getpid): Ditto.
(getppid): Ditto.
(lseek64): Fix strace debugging to correctly use %R.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Avoid sending signals to
other processes if we're debugging since it can cause a deadlock with the
calling debugger.
* exceptions.cc (_cygtls::call_signal_handler): Add debugging-only strace
output.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
d12 2
a13 2
#ifndef _FHANDLER_H_
#define _FHANDLER_H_
d1310 4
a1313 1
  static pid_t tc_getpgid () {return shared_console_info->tty_min_state.getpgid ();}
a2118 1
#endif /* _FHANDLER_H_ */
@


1.447
log
@* cygthread.h (cygthread::name): Very minor formatting tweak.
* exceptions.cc (_cygtls::call_signal_handler): Add paranoid debugging output.
* sigproc.h (cygwait): Call signal handler when signal is detected and loop as
appropriate.
* fhandler.h (fhandler_base_overlapped::wait_return): Remove overlapped_signal.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Remove restartable
signal accommodations in light of cygwait improvements.
(fhandler_base_overlapped::raw_read): Remove now-obsolete signal loop behavior.
(fhandler_base_overlapped::raw_write): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* ioctl.cc (ioctl): Add standard syscall introducer and leaver debug output.
@
text
@d145 1
d151 1
a151 1
      need_fork_fixup (0)
d162 1
d181 1
d245 1
@


1.446
log
@* sigproc.cc (remove_proc): Don't terminate the currently executing thread.
@
text
@a622 1
    overlapped_signal,
@


1.445
log
@* fhandler.h (fhandler_pipe::create): Rename from the misnamed
"create_selectable".  Change return to DWORD.
(fhandler_pty_common::pipesize): New constant.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Reflect create_selectable
name change.
* miscfuncs.cc (CreatePipeOverlapped): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create): Rename from the misnamed "create_selectable".  Return
DWORD.  Only set pipe size to default when it is passed in as zero.
* fhandler_tty.cc (fhandler_pty_master::setup): Ditto.  Use
fhandler_pty_common::pipesize rather than a raw constant.
* tty.cc (tty::not_allocated): Ditto.
* sigproc.cc (sigproc_init): Use create_selectable to create the signal pipe to
get a more appropriate message based pipe.
@
text
@d412 1
a412 1
  void operator delete (void *);
d438 1
a438 1
  virtual fhandler_base *clone ()
d440 1
a440 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_base));
d605 1
a605 1
  fhandler_socket *clone ()
d607 1
a607 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_socket));
d616 2
d652 3
d664 1
a664 1
  virtual fhandler_base_overlapped *clone ()
d666 1
a666 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_base_overlapped));
d671 2
d711 1
a711 1
  fhandler_pipe *clone ()
d713 1
a713 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_pipe));
d749 1
a749 1
  fhandler_fifo *clone ()
d751 1
a751 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_fifo));
d778 1
a778 1
  fhandler_mailslot *clone ()
d780 1
a780 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_mailslot));
d827 1
a827 1
  fhandler_dev_raw *clone ()
d829 1
a829 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_raw));
d887 1
a887 1
  fhandler_dev_floppy *clone ()
d889 1
a889 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_floppy));
d935 1
a935 1
  fhandler_dev_tape *clone ()
d937 1
a937 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_tape));
d1001 1
a1001 1
  fhandler_disk_file *clone ()
d1003 1
a1003 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_disk_file));
d1039 1
a1039 1
  fhandler_cygdrive *clone ()
d1041 1
a1041 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_cygdrive));
d1103 1
a1103 1
  fhandler_serial *clone ()
d1105 1
a1105 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_serial));
d1161 1
a1161 1
  virtual fhandler_termios *clone ()
d1163 1
a1163 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_termios));
d1360 1
a1360 1
  fhandler_console *clone ()
d1362 1
a1362 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_console));
d1404 1
a1404 1
  virtual fhandler_pty_common *clone ()
d1406 1
a1406 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_pty_common));
d1458 1
a1458 1
  fhandler_pty_slave *clone ()
d1460 1
a1460 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_pty_slave));
d1517 1
a1517 1
  fhandler_pty_master *clone ()
d1519 1
a1519 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_pty_master));
d1544 1
a1544 1
  fhandler_dev_null *clone ()
d1546 1
a1546 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_null));
d1579 1
a1579 1
  fhandler_dev_zero *clone ()
d1581 1
a1581 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_zero));
d1617 1
a1617 1
  fhandler_dev_random *clone ()
d1619 1
a1619 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_random));
d1657 1
a1657 1
  fhandler_dev_mem *clone ()
d1659 1
a1659 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_mem));
d1693 1
a1693 1
  fhandler_dev_clipboard *clone ()
d1695 1
a1695 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_clipboard));
d1732 1
a1732 1
  fhandler_windows *clone ()
d1734 1
a1734 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_windows));
d1779 1
a1779 1
  fhandler_dev_dsp *clone ()
d1781 1
a1781 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_dsp));
d1830 1
a1830 1
  virtual fhandler_virtual *clone ()
d1832 1
a1832 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_virtual));
d1862 1
a1862 1
  virtual fhandler_proc *clone ()
d1864 1
a1864 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_proc));
d1898 1
a1898 1
  fhandler_procsys *clone ()
d1900 1
a1900 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_procsys));
d1927 1
a1927 1
  fhandler_procsysvipc *clone ()
d1929 1
a1929 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_procsysvipc));
d1957 1
a1957 1
  fhandler_netdrive *clone ()
d1959 1
a1959 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_netdrive));
d1997 1
a1997 1
  fhandler_registry *clone ()
d1999 1
a1999 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_registry));
d2029 1
a2029 1
  fhandler_process *clone ()
d2031 1
a2031 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_process));
d2058 1
a2058 1
  fhandler_procnet *clone ()
d2060 1
a2060 1
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_procnet));
@


1.444
log
@* fhandler.h (__ptsname): New macro.
* dtable.cc (decode_tty): Use __ptsname to generate the slave pty name.
* fhandler_tty.cc (fhandler_pty_master::ptsname_r): Ditto.
* bsdlib.cc: Add needed includes for openpty() changes.
(openpty): Use __ptsname to generate the slave pty name.  Close slave fd when
aslave == NULL.
@
text
@d693 2
a694 2
  static int create_selectable (LPSECURITY_ATTRIBUTES, HANDLE *, HANDLE *, DWORD,
				const char *, DWORD);
d1373 1
@


1.443
log
@* cygwin.din (ptsname_r): Export.
* fhandler.cc (fhandler_base::ptsname_r): Define.
* fhandler.h (fhandler_base::ptsname): Delete.
(fhandler_base::ptsname_r): Declare.
(fhandler_pty_master::ptsname_r): Declare.
* fhandler_tty.cc (fhandler_pty_master::ptsname): Delete.
(fhandler_pty_master::ptsname_r): New reentrant function derived from previous
ptsname.
* syscalls.cc (ptsname_r): Implement new function with functionality similar to
Linux.
(ptsname): Use ptsname_r () to fill out buf.
* include/cygwin/stdlib.h (ptsname_r): Declare.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 255 to reflect
export of ptsname_r.
* pinfo.cc (pinfo::wait): Return bool rather than int.
* pinfo.h (info::wait): Ditto.
(pinfo::reattach): Define !defined(_SIGPROC_H) case for consistency.
* sigproc.cc (child_info_spawn::reattach_children): Use correct dwProcessId
rather than pid when duplicating handle.
@
text
@d1459 1
@


1.442
log
@* fhandler.h (fhandler_pipe::create_selectable): Remove optional argument, take
an options argument for CreateNamedPipe/CreateFile.  Change handle arguments to
expect pointers.
(fhandler_fifo::fifo_state): Delete.
(fhandler_fifo::dummy_client): Ditto.
(fhandler_fifo::open_nonserver): Ditto.
(fhandler_fifo::wait_state): Ditto.
(fhandler_fifo::raw_write): Ditto.
(fhandler_fifo::read_ready): New field.
(fhandler_fifo::write_ready): Ditto.
(fhandler_fifo::wait): Modify argument.
(fhandler_fifo::fifo_name): Add a new argument.
(fhandler_fifo::fixup_after_fork): New function.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove initialization of
expunged elements.  Initialize new handles to NULL.
(fhandler_fifo::open_nonserver): Delete.
(fnevent): New macro for creating a named event.
(fnpipe): New macro for creating a unique named pipe name.
(create_pipe): New macro for simplification of named pipe creation.
(fhandler_fifo::fifo_name): Use new argument when creating a shared name.
(fhandler_fifo::open): Rewrite.  Use events to synchronize.
(pure_debug_printf): New macro, active only when DEBUGGING.
(fhandler_fifo::wait): Rewrite to wait for new fifo events which are supplied
as a parameter.
(fhandler_fifo::raw_read): Rewrite to use handle mechanism to detect
client-side disconnect.
(fhandler_fifo::raw_write): Delete.
(fhandler_fifo::close): Remove accommodations for expunged fields.  Close event
handles.
(fhandler_fifo::dup): Remove accommodations for expunged fields.  Duplicate
event handles.
(fhandler_fifo::fixup_after_fork): New function.  Perform fixups on event
handles.
(fhandler_fifo::set_close_on_exec): Remove accommodations for expunged fields.
Set inheritance for new handle fields.
* miscfuncs.cc (CreatePipeOverlapped): Accommodate changes in
fhandler_pipe::create_selectable.
* tty.cc (tty::not_allocated): Ditto.
* pipe.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create_selectable): Accept an extra open_mode argument.  Pass
arguments by reference and allow opening one end of the pipe at a time.
* sys/strace.h (debug_only_printf): Define new macro which calls debug_printf
only when DEBUGGING is defined.
@
text
@d384 1
a384 1
  virtual char *ptsname () { return NULL;}
d1489 1
a1489 1
  char *ptsname ();
@


1.441
log
@* dtable.cc (dtable::delete_archetype): Improve debugging output.
(dtable::init_std_file_from_handle): Close console handle early, before
initialization.  Build up openflags for passing to open_setup, just to be safe.
(last_tty_dev): New variable.
(fh_last_tty_dev): New macro.
(fh_alloc): Try again to keep track of previously opened tty, this time by just
saving the device and using that to potentially open an archetype.  Avoid
setting the "/dev/tty" name if the creation of the fhandler failed.
(build_fh_pc): Remove unused second argument.  Reorganize how and where the
name is set.  Set last_tty_dev as appropriate.  Avoid a NULL dereference in a
debug printf.
* dtable.h (build_fh_pc): Reflect removal of second parameter.
* fhandler.cc (fhandler_base::reset): Use new '<<' operator to copy pc since it
preserves any potentially previously set name.
(fhandler_base::set_name): Ditto.
* fhandler.h (fhandler_*::clone): Throughout use ccalloc to allocate new
fhandler, primarily to make sure that pc field is properly zeroed.
(fhandler_termios::last): Eliminate.
(fhandler_termios): Remove setting of last.
(fhandler_base::~fhandler_termios): Ditto.
* fhandler_console.cc (fhandler_console::open): Don't make decisions about
opening close-on-exec handles here since it makes no sense for archetypes.
(fhandler_console::init): Assume that input handle has already been opened.
* fhandler_termios.cc (fhandler_termios::last): Delete.
* path.h (path_conv::eq_worker): New function.  Move bulk of operator = here.
(operator <<): New function.
(operator =): Use eq_worker to perform old functionality.
@
text
@d132 6
a137 6
    unsigned rbinary            : 1; /* binary read mode */
    unsigned rbinset            : 1; /* binary read mode explicitly set */
    unsigned wbinary            : 1; /* binary write mode */
    unsigned wbinset            : 1; /* binary write mode explicitly set */
    unsigned nohandle           : 1; /* No handle associated with fhandler. */
    unsigned did_lseek          : 1; /* set when lseek is called as a flag that
d141 1
a141 1
    unsigned query_open         : 3; /* open file without requesting either
d440 2
a441 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_base)); 
    fhandler_base *fh = new (ptr) fhandler_base (ptr); 
d514 1
a514 1
    unsigned async_io              : 1; /* async I/O */
d517 3
a519 3
    unsigned saw_reuseaddr         : 1; /* Socket saw SO_REUSEADDR call */
    unsigned listener              : 1; /* listen called */
    unsigned connect_state         : 2;
d607 2
a608 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_socket)); 
    fhandler_socket *fh = new (ptr) fhandler_socket (ptr); 
d661 2
a662 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_base_overlapped)); 
    fhandler_base_overlapped *fh = new (ptr) fhandler_base_overlapped (ptr); 
d693 2
a694 3
  static int create_selectable (LPSECURITY_ATTRIBUTES, HANDLE&, HANDLE&, DWORD, const char * = NULL);
  friend class fhandler_fifo;

d706 2
a707 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_pipe)); 
    fhandler_pipe *fh = new (ptr) fhandler_pipe (ptr); 
d715 4
a718 16
  enum fifo_state
  {
    fifo_unknown,
    fifo_wait_for_client,
    fifo_wait_for_server,
    fifo_wait_for_next_client,
    fifo_eof,
    fifo_error,
    fifo_eintr,
    fifo_ok
  };
  fifo_state wait_state;
  HANDLE dummy_client;
  HANDLE open_nonserver (const char *, unsigned, LPSECURITY_ATTRIBUTES);
  bool wait (bool) __attribute__ ((regparm (1)));
  char *fifo_name (char *) __attribute__ ((regparm (2)));
a720 2
  void __stdcall raw_read (void *, size_t&) __attribute__ ((regparm (3)));
  ssize_t __stdcall raw_write (const void *, size_t) __attribute__ ((regparm (3)));
d726 2
d744 2
a745 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_fifo)); 
    fhandler_fifo *fh = new (ptr) fhandler_fifo (ptr); 
d773 2
a774 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_mailslot)); 
    fhandler_mailslot *fh = new (ptr) fhandler_mailslot (ptr); 
d822 2
a823 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_raw)); 
    fhandler_dev_raw *fh = new (ptr) fhandler_dev_raw (ptr); 
d882 2
a883 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_floppy)); 
    fhandler_dev_floppy *fh = new (ptr) fhandler_dev_floppy (ptr); 
d930 2
a931 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_tape)); 
    fhandler_dev_tape *fh = new (ptr) fhandler_dev_tape (ptr); 
d996 2
a997 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_disk_file)); 
    fhandler_disk_file *fh = new (ptr) fhandler_disk_file (ptr); 
d1034 2
a1035 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_cygdrive)); 
    fhandler_cygdrive *fh = new (ptr) fhandler_cygdrive (ptr); 
d1098 2
a1099 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_serial)); 
    fhandler_serial *fh = new (ptr) fhandler_serial (ptr); 
d1156 2
a1157 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_termios)); 
    fhandler_termios *fh = new (ptr) fhandler_termios (ptr); 
d1355 2
a1356 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_console)); 
    fhandler_console *fh = new (ptr) fhandler_console (ptr); 
d1398 2
a1399 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_pty_common)); 
    fhandler_pty_common *fh = new (ptr) fhandler_pty_common (ptr); 
d1452 2
a1453 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_pty_slave)); 
    fhandler_pty_slave *fh = new (ptr) fhandler_pty_slave (ptr); 
d1510 2
a1511 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_pty_master)); 
    fhandler_pty_master *fh = new (ptr) fhandler_pty_master (ptr); 
d1537 2
a1538 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_null)); 
    fhandler_dev_null *fh = new (ptr) fhandler_dev_null (ptr); 
d1572 2
a1573 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_zero)); 
    fhandler_dev_zero *fh = new (ptr) fhandler_dev_zero (ptr); 
d1610 2
a1611 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_random)); 
    fhandler_dev_random *fh = new (ptr) fhandler_dev_random (ptr); 
d1650 2
a1651 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_mem)); 
    fhandler_dev_mem *fh = new (ptr) fhandler_dev_mem (ptr); 
d1686 2
a1687 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_clipboard)); 
    fhandler_dev_clipboard *fh = new (ptr) fhandler_dev_clipboard (ptr); 
d1725 2
a1726 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_windows)); 
    fhandler_windows *fh = new (ptr) fhandler_windows (ptr); 
d1772 2
a1773 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_dev_dsp)); 
    fhandler_dev_dsp *fh = new (ptr) fhandler_dev_dsp (ptr); 
d1823 2
a1824 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_virtual)); 
    fhandler_virtual *fh = new (ptr) fhandler_virtual (ptr); 
d1855 2
a1856 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_proc)); 
    fhandler_proc *fh = new (ptr) fhandler_proc (ptr); 
d1891 2
a1892 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_procsys)); 
    fhandler_procsys *fh = new (ptr) fhandler_procsys (ptr); 
d1920 2
a1921 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_procsysvipc)); 
    fhandler_procsysvipc *fh = new (ptr) fhandler_procsysvipc (ptr); 
d1950 2
a1951 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_netdrive)); 
    fhandler_netdrive *fh = new (ptr) fhandler_netdrive (ptr); 
d1990 2
a1991 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_registry)); 
    fhandler_registry *fh = new (ptr) fhandler_registry (ptr); 
d2022 2
a2023 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_process)); 
    fhandler_process *fh = new (ptr) fhandler_process (ptr); 
d2051 2
a2052 2
    void *ptr = (void *) ccalloc (HEAP_FHANDLER, 1, sizeof (fhandler_procnet)); 
    fhandler_procnet *fh = new (ptr) fhandler_procnet (ptr); 
@


1.440
log
@* fhandler.h (fhandler*::copyto): Free path_conv strings first.
* path.h (cfree_and_null): Rename and expand from cfree_maybe.
(path_conv &operator =): Call free_strings rather than freeing strings
directly.
@
text
@d440 1
a440 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_base)); 
d607 1
a607 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_socket)); 
d661 1
a661 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_base_overlapped)); 
d707 1
a707 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_pipe)); 
d757 1
a757 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_fifo)); 
d786 1
a786 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_mailslot)); 
d835 1
a835 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_dev_raw)); 
d895 1
a895 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_dev_floppy)); 
d943 1
a943 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_dev_tape)); 
d1009 1
a1009 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_disk_file)); 
d1047 1
a1047 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_cygdrive)); 
d1111 1
a1111 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_serial)); 
a1136 1
  static fhandler_termios *last;
a1141 6
    last = this;
  }
  ~fhandler_termios ()
  {
    if (this == last)
      last = NULL;
d1169 1
a1169 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_termios)); 
d1368 1
a1368 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_console)); 
d1411 1
a1411 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_pty_common)); 
d1465 1
a1465 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_pty_slave)); 
d1523 1
a1523 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_pty_master)); 
d1550 1
a1550 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_dev_null)); 
d1585 1
a1585 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_dev_zero)); 
d1623 1
a1623 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_dev_random)); 
d1663 1
a1663 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_dev_mem)); 
d1699 1
a1699 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_dev_clipboard)); 
d1738 1
a1738 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_windows)); 
d1785 1
a1785 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_dev_dsp)); 
d1836 1
a1836 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_virtual)); 
d1868 1
a1868 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_proc)); 
d1904 1
a1904 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_procsys)); 
d1933 1
a1933 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_procsysvipc)); 
d1963 1
a1963 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_netdrive)); 
d2003 1
a2003 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_registry)); 
d2035 1
a2035 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_process)); 
d2064 1
a2064 1
    void *ptr = (void *) cmalloc (HEAP_FHANDLER, sizeof (fhandler_procnet)); 
@


1.439
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d433 1
d600 1
d654 1
d700 1
d750 1
d779 1
d828 1
d888 1
d936 1
d1002 1
d1040 1
d1104 1
d1169 1
d1368 1
d1411 1
d1465 1
d1523 1
d1550 1
d1585 1
d1623 1
d1663 1
d1699 1
d1738 1
d1785 1
d1836 1
d1868 1
d1904 1
d1933 1
d1963 1
d2003 1
d2035 1
d2064 1
@


1.438
log
@* cygwin.din: Remove some _tc* exports.  Add tcgetsid().
* dtable.cc (fh_alloc): Revert ill-advised setting of major/minor.  Use new
is_dev_tty to remember that this device was opened as /dev/tty.
* fhandler.cc (fhandler_base::fstat): Remove leftover debugging statement.
(fhandler_base::tcgetsid): New function.
* fhandler.h ((fhandler_base::tcgetsid): Declare new function.
(fhandler_base::is_dev_tty): Ditto.
(fhandler_termios::opened_as_dev_tty): Declare new field.
(fhandler_termios::is_dev_tty): Declare new function.
(fhandler_termios::tcgetsid): Ditto.
(fhandler_pty_common::use_archetype): Move here from subclass.
(fhandler_pty_slave::use_archetype): Move up.
(fhandler_pty_master::use_archetype): Ditto.
* fhandler_console.cc (fhandler_console::ioctl): Rename second argument from
`buf' to `arg' for consistency.  Call ioctl_termios for common fhandler_termios
ioctl handling.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Call ioctl_termios for common
fhandler_termios ioctl handling.
(fhandler_pty_master::ioctl): Ditto.
* fhandler_termios.cc (fhandler_termios::tcgetsid): Implement new function.
(fhandler_termios::ioctl_termios): Ditto.  Implements TIOCSCTTY handling.
* syscalls.cc (stat_worker): Set /dev/tty device info when appropriate.
* termios.cc (tcgetpgrp): Avoid extraneous "isatty" check.
(tcgetsid): Implement new function.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 253.
* include/sys/termios.h (TIOCSCTTY): Define.
@
text
@d184 1
a197 3
  virtual size_t size () const {return sizeof (*this);}

  virtual fhandler_base& operator =(fhandler_base &x);
d355 1
a355 1
  virtual int dup (fhandler_base *child);
d428 16
a443 1
  virtual bool is_dev_tty () const { return false; }
d568 1
a568 1
  int dup (fhandler_base *child);
d594 16
a609 1
  size_t size () const { return sizeof (*this);}
d646 17
a662 2
  int dup (fhandler_base *child);
  virtual size_t size () const { return sizeof (*this);}	/* probably not needed */
d683 1
a683 1
  int dup (fhandler_base *child);
d692 16
a707 1
  size_t size () const { return sizeof (*this);}
d734 1
a734 1
  int dup (fhandler_base *child);
d741 16
a756 1
  size_t size () const { return sizeof (*this);}
d769 16
a784 1
  size_t size () const { return sizeof (*this);}
d812 1
a812 1
  int dup (fhandler_base *child);
d817 16
a832 1
  size_t size () const { return sizeof (*this);}
d871 1
a871 1
  int dup (fhandler_base *child);
d876 16
a891 1
  size_t size () const { return sizeof (*this);}
d919 1
a919 1
  virtual int dup (fhandler_base *child);
d923 16
a938 1
  size_t size () const { return sizeof (*this);}
d956 1
a956 1
  int dup (fhandler_base *child);
d988 16
a1003 1
  size_t size () const { return sizeof (*this);}
d1025 16
a1040 1
  size_t size () const { return sizeof (*this);}
d1064 1
a1064 1
  int dup (fhandler_base *child);
d1088 16
a1103 1
  size_t size () const { return sizeof (*this);}
d1116 2
a1118 2
  bool opened_as_dev_tty;
  HANDLE output_handle;
d1121 3
a1123 1
  int ioctl_termios (int, int);
d1125 2
a1126 4
  bool is_dev_tty () const { return opened_as_dev_tty; }
  bool is_dev_tty (bool val) { return opened_as_dev_tty = val; }
  tty_min *_tc;
  virtual tty_min *tc () const {return _tc; }
a1129 1
    opened_as_dev_tty = false;
d1131 6
a1142 1
  tty *get_ttyp () { return (tty *) tc (); }
d1152 16
a1167 1
  virtual size_t size () const { return sizeof (*this);}	/* probably not needed */
a1304 1
  tty_min *tc () const {return &(shared_console_info->tty_min_state);}
d1321 1
d1346 1
a1346 1
  void get_tty_stuff ();
d1350 16
a1365 1
  size_t size () const { return sizeof (*this);}
d1392 16
a1407 1
  virtual size_t size () const { return sizeof (*this);}	/* probably not needed */
d1435 1
a1435 1
  int dup (fhandler_base *child);
d1445 16
a1460 1
  size_t size () const { return sizeof (*this);}
d1468 2
a1472 2
  DWORD dwProcessId;		// Owner of master handles
  HANDLE from_master, to_master;
d1475 1
a1475 1
  fhandler_pty_master ();
d1482 1
d1497 1
a1497 1
  int dup (fhandler_base *);
d1501 17
a1517 1
  size_t size () const { return sizeof (*this);}
d1528 16
a1543 1
  size_t size () const { return sizeof (*this);}
d1562 16
a1577 1
  size_t size () const { return sizeof (*this);}
d1598 17
a1614 2
  int dup (fhandler_base *child);
  size_t size () const { return sizeof (*this);}
d1638 16
a1653 1
  size_t size () const { return sizeof (*this);}
d1671 1
a1671 1
  int dup (fhandler_base *child);
d1673 16
a1688 1
  size_t size () const { return sizeof (*this);}
d1711 16
a1726 1
  size_t size () const { return sizeof (*this);}
d1757 16
a1772 1
  size_t size () const { return sizeof (*this);}
d1796 1
a1796 1
  int dup (fhandler_base *child);
d1807 16
a1822 1
  virtual size_t size () const { return sizeof (*this);}
d1838 16
a1853 1
  virtual size_t size () const { return sizeof (*this);}
d1873 16
a1888 1
  size_t size () const { return sizeof (*this);}
d1901 16
a1916 1
  size_t size () const { return sizeof (*this);}
d1930 16
a1945 1
  size_t size () const { return sizeof (*this);}
d1968 17
a1984 2
  int dup (fhandler_base *child);
  size_t size () const { return sizeof (*this);}
d2000 16
a2015 1
  size_t size () const { return sizeof (*this);}
d2028 16
a2043 1
  size_t size () const { return sizeof (*this);}
a2049 1
  // int __stdcall fstat (struct __stat64 *buf, path_conv *);
@


1.437
log
@	* fhandler.h (fhandler_process::closedir): Declare.
	* fhandler_process.cc (fhandler_process::closedir): New function to
	avoid a SEGV in fhandler_proc::closedir.
@
text
@d380 1
d430 1
d939 1
d943 1
d945 2
d952 1
d969 1
d1170 1
a1195 1
  bool use_archetype () const {return true;}
a1234 1
  virtual bool use_archetype () const {return true;}
@


1.436
log
@* fhandler.h (fhandler_console::tc_getpgid): New function.
* spawn.cc (spawn_guts): Add logic to put pure-windows processes "in the
background" when they are started that way.
@
text
@d1534 1
@


1.435
log
@	* fhandler.h (fhandler_proc::opendir): Declare.
	(fhandler_proc::closedir): Declare.
	* fhandler_proc.cc (fhandler_proc::opendir): New method.  Fetch list
	of active processes here once to avoid potential duplicates.
	(fhandler_proc::closedir): New method.
@
text
@d1103 1
@


1.434
log
@	* fhandler.h (class fhandler_dev_mem): Remove dup method declaration.
	* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Accommodate the
	fact that the entire fhandler gets copied over to the child in
	operator =.
	* fhandler_floppy.cc (fhandler_dev_floppy::dup): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::dup): Ditto.
	* fhandler_serial.cc (fhandler_serial::dup): Ditto.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::dup): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::dup): Ditto.  Remove entirely.
@
text
@d1443 2
@


1.433
log
@* fhandler.h (fhandler_base_overlapped::size): Declare/define size() function
for consistency.
(fhandler_termios::size): Ditto.
(fhandler_pty_common::size): Ditto.
@
text
@a1319 1
  int dup (fhandler_base *child);
@


1.432
log
@	* fhandler.cc (fhandler_base::open): Drop local create_options variable.
	Use options member instead.
	* fhandler.h (class fhandler_base): Change type of access member to
	ACCESS_MASK.  Change get_access and set_access methods accordingly.
	Add options member.  Add get_options and set_options methods.
	(class fhandler_disk_file): Add prw_handle.
	(fhandler_disk_file::prw_open): Declare.
	(fhandler_disk_file::close): Declare.
	(fhandler_disk_file::dup): Declare.
	(fhandler_disk_file::fixup_after_fork): Declare.
	* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file):
	Initialize prw_handle to NULL.
	(fhandler_disk_file::close): Close prw_handle.
	(fhandler_disk_file::dup): New method.
	(fhandler_disk_file::fixup_after_fork): Set prw_handle to NULL since
	prw_handle is not inherited.
	(fhandler_disk_file::prw_open): New method.  Add long comment to
	explain current behaviour.
	(fhandler_disk_file::pread): Revert previous change.  Change to use
	prw_handle if possible.
	(fhandler_disk_file::pwrite): Change to use prw_handle if possible.
@
text
@d617 1
d962 1
d1170 1
@


1.431
log
@* fhandler_console.cc (fhandler_console::set_unit): Set pc.file_attributes() to
reflect existence.
* fhandler.h (fhandler_pty_common::fhandler_pty_common): Ditto.
* pinfo.cc (_pinfo::set_ctty): Output device numbers in hex.
@
text
@d155 3
a157 1
  int access;
d211 5
a215 2
  int get_access () const { return access; }
  void set_access (int x) { access = x; }
d809 1
d812 2
d819 3
@


1.430
log
@* cygheap.h (init_cygheap::ctty_on_hold): Remove conditionalized variable.
* dcrt0.cc (do_exit): Remove code which handled CYGWIN=tty style ttys.
* devices.in: Remove "/dev/ttym".
* dtable.cc: Rename tty to pty where appropriate throughout.
(dtable::stdio_init): Use new t->is_console rather than using now-deleted hwnd
element in tty structure.
(dtable::init_std_file_from_handle): Remove code which handled CYGWIN=tty style
ttys.
(fh_alloc): Ditto.
* fhandler.h: Rename tty to pty where appropriate.
(fhandler_pty_common): Delete output_done_event, ioctl_request_event,
ioctl_done_event.
(fhandler_pty_master::setup): Delete argument.
(fhandler_tty_master): Delete.
(fhandler_union): Delete __tty_master.
* fhandler_console.cc (use_tty): Delete.
(fhandler_console::get_tty_stuff): Set is_console to true rather than calling
sethwnd.
(fhandler_console::send_winch_maybe): Remove CYGWIN=tty considerations.
(fhandler_console::input_tcsetattr): Ditto.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Use new t->is_console
rather than using now-deleted hwnd element in tty structure.
* fhandler_tty.cc: Rename tty to pty where appropriate throughout.
(tty_master): Delete.
(process_input): Ditto.
(process_output): Ditto.
(process_ioctl): Ditto.
(fhandler_tty_master::*): Ditto.
(fhandler_pty_master::process_slave_output): Remove CYGWIN=tty considerations.
(fhandler_pty_slave::open): Ditto for *_done_event.
(fhandler_pty_slave::write): Ditto.
(fhandler_pty_slave::ioctl): Ditto.
(fhandler_pty_slave::fch_open_handles): Ditto.
(fhandler_pty_slave::fch_set_sd): Ditto.
(fhandler_pty_slave::fch_close_handles): Ditto.
(fhandler_pty_common::close): Ditto.
(fhandler_pty_master::setup): Ditto.  Remove now-unneeded ispty parameter.
(fhandler_pty_master::open): Reflect argument removal for tty::allocate.
* select.cc: Rename tty to pty where appropriate throughout.
* sigproc.cc (proc_subproc): Remove CYGWIN=tty considerations.
* tty.cc (ttyslot): Accommodate CYGWIN=tty removal.
(tty_list::init_session): Ditto.
(tty_list::attach): Ditto.
(tty::create_master): Delete.
(tty_list::terminate): Ditto.
(tty_list::allocate): Delete "with_console" parameter.  Remove CYGWIN=tty
considerations.
(tty::init): Set is_console = false.  Use 'false' for was_opened since it is a
boolean.
* tty.h (*_{DONE,REQUEST}_EVENT): Delete.
(tty_min::is_console): Declare new field which replaces hwnd.
(tty_min::gethwnd): Delete.
(tty_min::sethwnd): Ditto.
(tty_list::allocate): Delete parameter.
(tty_list::terminate): Delete declaration.
* include/sys/cygwin.h (PID_USETTY): Redefine to PID_UNUSED1 and change comment
to reflect its availability.
@
text
@d1143 1
a1143 1
    // nothing to do
@


1.429
log
@Rename FH_BAD to FH_NADA throughout.
* devices.h (FH_ERROR): New value.
(iscons_dev): Extend to detect all the console device types.
* devices.in: Set aside storage for FH_ERROR.
* dtable.cc (dtable::init_std_file_from_handle): Use iscons_dev to detect when
device is a console.
(fh_alloc): Pass device to console constructor.
(build_fh_pc): Short circuit when we detect that the constructor saw an error.
* fhandler.h (fhandler_console::fhandler_console): Accept fh_devices parameter.
(get_tty_stuff): Change to void.
* fhandler_console (fhandler_console::set_unit): Set device to FH_ERROR on
attempt to access anything other than the current console.
(fhandler_console::get_tty_stuff): Change to void return.
(fhandler_console::open): Return EPERM on FH_ERROR device type.
(fhandler_console::fhandler_console): Set the device type appropriately before
calling get_tty_stuff and rely on that function to reset it if necessary.
@
text
@d904 1
a904 1
     don't use it for permissions checking.  fhandler_tty_slave does
d1135 1
a1135 1
class fhandler_tty_common: public fhandler_termios
d1138 3
a1140 3
  fhandler_tty_common ()
    : fhandler_termios (), output_done_event (NULL),
    ioctl_request_event (NULL), ioctl_done_event (NULL), output_mutex (NULL),
a1144 6
  HANDLE output_done_event;	// Raised by master when tty's output buffer
				// written. Write status in tty::write_retval.
  HANDLE ioctl_request_event;	// Raised by slave to perform ioctl() request.
				// Ioctl() request in tty::cmd/arg.
  HANDLE ioctl_done_event;	// Raised by master on ioctl() completion.
				// Ioctl() status in tty::ioctl_retval.
d1159 1
a1159 1
class fhandler_tty_slave: public fhandler_tty_common
d1170 1
a1170 1
  fhandler_tty_slave (int);
d1198 1
a1198 1
class fhandler_pty_master: public fhandler_tty_common
d1207 1
a1229 1
  HANDLE from_master, to_master;
d1231 1
a1231 1
  bool setup (bool);
a1235 16
  virtual bool is_tty_master () const {return false;}
  size_t size () const { return sizeof (*this);}
};

class fhandler_tty_master: public fhandler_pty_master
{
 public:
  /* Constructor */
  fhandler_console *console;	// device handler to perform real i/o.
  bool use_archetype () const {return false;}

  fhandler_tty_master ();
  int init ();
  int init_console ();
  void set_winsize (bool);
  bool is_tty_master () const {return true;}
d1548 1
a1548 1
		  use_op, ((fhandler_tty_slave *) (fh->archetype ?: fh))->usecount);
d1580 2
a1581 3
  char __tty_common[sizeof (fhandler_tty_common)];
  char __tty_master[sizeof (fhandler_tty_master)];
  char __tty_slave[sizeof (fhandler_tty_slave)];
@


1.428
log
@* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Only raise SIGPIPE
when writing.
* fhandler.h: Include "tty.h".
(fhandler_termios::_tc): Rename from tc.
(fhandler_termios::tc): New method.
(fhandler_termios::tcinit): Remove an argument.
(fhandler_termios::get_ttyp): Use method to retrieve value.
(fhandler_console::console_state): Move here.
(fhandler_console::dev_state): Delete.
(fhandler_console::shared_console_info): Define.
(fhandler_console::open_shared_console): Move this function under
fhandler_console umbrella.
(fhandler_console::tc): Define.  Return static value.
(fhandler_console::focus_aware): Accommodate deletion of dev_state.
(fhandler_console): Add tty_list::get_cttyp as a friend.
* fhandler_console.cc (dev_state): Redefine as a pointer within
shared_console_info and change dev-> to dev.  throughout.
(fhandler_console::shared_console_info): Move into fhandler_console.
(fhandler_console::open_shared_console): Move into fhandler_console change
argument to simple bool.
(enum_windows): Accommodate changes to console_state and open_shared_console.
(console_unit::console_unit): Ditto.
(fhandler_console::get_tty_stuff): Accommodate change to dev_state.
(tty_list::get_cttyp): Accommodate change to
handler_console::shared_console_info.
(fhandler_console::read): Accommodate change from tc to tc ().
(fhandler_console::set_input_state): Ditto.
(fhandler_console::open): Accommodate tcinit argument change and change from tc
to tc().
(fhandler_console::input_tcsetattr): Accomodate change from tc to tc().
(fhandler_console::input_tcsetattr): Ditto.
(fhandler_console::write_normal): Ditto.
(fhandler_console::init): Ditto.
(fhandler_console::igncr_enabled): Ditto.
* fhandler_termios.cc (fhandler_termios::tcinit): Remove first argument.
Expect tc() to have been set up first.  Use tc() rather than tc.
(fhandler_termios::tcsetpgrp): Accomodate change from tc to tc().
(fhandler_termios::tcgetpgrp): Ditto.
(fhandler_termios::bg_check): Ditto.
(fhandler_termios::line_edit: Ditto.
(fhandler_tty_master::set_winsize): Ditto.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::init): Ditto.
(fhandler_pty_master::write): Ditto.
(fhandler_pty_master::setup): Ditto.  Accommodate change in arguments to
tcinit.
(fhandler_tty_slave::fch_open_handles): Set _tc directly.
(tty_min::is_orphaned_process_group): Don't assume that parent pid exists.
* pinfo.cc (_pinfo::set_ctty): Reset myself->{pgid,sid} here if we were started
by a non-Cygwin process but the tty exists.
* shared_info.h (console_state): Delete from here.
* tty.h: Make multiple inclusion safe.
@
text
@d1090 1
a1090 1
  fhandler_console ();
d1127 1
a1127 1
  tty_min *get_tty_stuff ();
@


1.427
log
@* dtable.cc (dtable::select_write): Add missing argument to debug_printf.
* fhandler.cc (fhandler_base_overlapped::setup_overlapped): Explicitly set
io_pending to false.
(fhandler_base_overlapped::has_ongoing_io): Call GetOverlappedResult to force
completion of I/O.
(fhandler_base_overlapped::wait_overlapped): Rewrite to correctly deal with
nonblocking reads and to make more race proof.
(fhandler_base_overlapped::raw_write): Deal with new enum values.
(fhandler_base_overlapped::raw_read): Ditto.  Don't deal with ongoing I/O here
since it makes no sense in the read context.
* fhandler.h (enum wait_return): Add overlapped_unknown,
overlapped_nonblocking_no_data.
* pipe.cc (pipe): Add debugging output.
@
text
@d15 1
d929 2
a930 1
  tty_min *tc;
d939 1
a939 1
  void tcinit (tty_min *this_tc, bool force);
d941 1
a941 1
  tty *get_ttyp () { return (tty *) tc; }
d1046 7
a1052 1
 private:
d1054 1
a1054 1
  static dev_console *dev_state;
d1086 2
d1091 5
d1116 1
a1116 1
  bool focus_aware () {return dev_state->use_focus;}
d1132 1
@


1.426
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d581 2
a582 1
    overlapped_success = 0,
d584 1
@


1.425
log
@* fhandler.h (fhandler_base::close_with_arch): Make non-virtual.
(fhandler_base::open_fs): Move closer to it's close counterpart.
@
text
@d203 4
a206 4
  DWORD& get_device () { return dev ().devn; }
  DWORD get_major () { return dev ().major; }
  DWORD get_minor () { return dev ().minor; }
  virtual int get_unit () { return dev ().minor; }
a416 1
  virtual bool is_slow () {return false;}
a907 1
  bool is_slow () {return true;}
d1110 2
a1111 2
  tty_min *get_tty_stuff (int);
  bool is_slow () {return true;}
a1144 1
  bool is_slow () {return true;}
d1435 1
a1435 1
  static DWORD get_proc_fhandler(const char *path);
@


1.424
log
@* fhandler.h (fhandler_dev_dsp): Cosmetic change.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Put back
Sleep(10) for tty_master case.
* sigproc.cc (stopped_or_terminated): Don't consider a pid which has been
reaped to be terminated.
@
text
@d302 1
a302 2
  int open_fs (int, mode_t = 0);
  virtual int close_with_arch ();
d314 2
@


1.423
log
@	* fhandler.h (fhandler_socket::read): Declare.
	(fhandler_socket::write): Declare.
	* fhandler_procsys.cc (fhandler_procsys::read): Add FIXME comment.
	(fhandler_procsys::write): Ditto.
	* fhandler_socket.cc (fhandler_socket::read): New method.
	(fhandler_socket::write): New method.
	* syscalls.cc: Rearrange order of read/write functions.
	(read): Call fhandler read method directly instead of just readv.
	(readv): Remove EINTR loop.  This is done in all affected fhandler's
	now.
	(write): Call fhandler write method directly instead of just writev.
	Fix debug output.
@
text
@d1392 1
a1393 1
  bool use_archetype () const {return true;}
@


1.422
log
@* cygheap.cc (cygheap::close_ctty): Close ctty via close_with_arch().
* debug.cc (close_handle): Call debugger on failure.
* devices.in (device::tty_to_real_device): Delete.
* devices.h (device::tty_to_real_device): Ditto.
* devices.cc: Regenerate.
* dtable.cc: Delete old ifdef'ed vfork code.
(dtable::release): Don't handle archetype here.
(dtable::init_std_file_from_handle): Consolidate console tests.  Generate
major/minor for tty ASAP.  Fix incorrect setting of DEV_TTYS* for serial.
(fh_alloc): New function derived from build_fh_pc.  Pass current tty when
building tty.
(build_pc_pc): Use fh_alloc to create.  Set name from fh->dev if appropriate.
Generate an archetype or point to one here.
(dtable::dup_worker): Deal with archetypes.  Rely on = operator copying whole
class rather than just fhandler_base.
(dtable::fixup_after_exec): Call close_with_arch to handle closing of fhandlers
with archetypes.
* fhandler.cc (fhandler_base::operator =): Call memcpy with fhandler's size()
rather than sizeof fhandler_base.
(fhandler_base::open_with_arch): New function.  Handles opening of fhandler's
with archetypes, dealing with usecounts, etc.
(fhandler_base::close_with_arch): Ditto for close.
* fhandler.h: Many changes for archetypes.
(fhandler_base::set_name): Set both normalized path and regular path.
(fhandler_base::open_with_arch): New function.
(fhandler_base::open_setup): Ditto.
(fhandler_base::use_archetype): Ditto.
(fhandler_base::_archetype_usecount): Ditto.
(fhandler_*::size): Ditto.
(fhandler_dev_tape::open): Remove virtual decoration.
(fhandler_console::use_archetype): New function.  Return true.
(fhandler_console::open_setup): New function.
(fhandler_console::dup): Delete.
(fhandler_tty_slave::fhandler_tty_slave): Redeclare to take an argument.
(fhandler_tty_slave::use_archetype): New function.  Return true.
(fhandler_tty_slave::cleanup): New function.
(fhandler_pty_master::use_archetype): New function.  Return true.
(fhandler_pty_master::cleanup): New function.
(fhandler_pty_master::is_tty_master): New function.  Return false.
(fhandler_tty_master::is_tty_master): New function.  Return true.
(fhandler_dev_dsp::fhandler_dev_dsp): New function.  Return true.
(report_tty_counts): Only report on archetype's usecount if there is one.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove handling of
setsid, set_ctty, set_flags, and manage_console_count.
(fhandler_console::open_setup): New function.  Implement functionality removed
from get_tty_stuff.
(fhandler_console::dup): Delete.
(fhandler_console::output_tcsetattr): Set errno on error.
(fhandler_console::fhandler_console): Set device early.
(fhandler_console::init): Use open_with_arch to open console handles.
(fhandler_console::fixup_after_fork_exec): Nuke most of the stuff for dealing
with console handles.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Remove archetype handling.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
(fhandler_dev_dsp::close): Ditto.
(fhandler_dev_dsp::dup): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Add a little
more debugging.
(fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_pty_master::process_slave_output): Ditto.  Don't do signal handling
or pthread_cancel handling in the tty master thread.
(process_output): Minor reorg.
(fhandler_tty_slave::fhandler_tty_slave): Set device based on new ntty
argument.
(fhandler_tty_slave::open): Remove archetype handling.  Move some processing
into open_setup().
(fhandler_tty_slave::open_setup): New function.
(fhandler_tty_slave::cleanup): New function.
(fhandler_tty_slave::close): Remove archetype handling.  Move some processing
into cleanup().
(fhandler_tty_slave::init): Rename argument from f to h.  Open device using
open_with_arch().  Remove archetype handling.
(fhandler_pty_master::dup): Ditto.
(fhandler_pty_master::open): Ditto.
(fhandler_pty_master::close): Ditto.  Move some handling to cleanup().
(fhandler_pty_master::cleanup): New function.
(fhandler_tty_master::init_console): Give unique name to captive console
fhandler.
* pinfo.cc (_pinfo::set_ctty): Rename argument from arch to fh.  Eliminate
archetype assumption.
* syscalls.cc (close_all_files): Use close_with_arch for closing.
(open): Use open_with_arch() rather than open().
(close): Use close_with_arch() rather than close().
@
text
@d527 1
d534 1
@


1.421
log
@* fhandler.cc (fhandler_base_overlapped::raw_read): Rename from
read_overlapped.
(fhandler_base_overlapped::raw_e): Rename from write_overlapped.
* fhandler.h (fhandler_*::raw_read): Add reparm decoration.
(fhandler_*::raw_write): Ditto.
(fhandler_base_overlapped::raw_read): Rename from read_overlapped.
(fhandler_base_overlapped::raw_write): Rename from write_overlapped.
(fhandler_pipe::raw_read): Delete.
(fhandler_pipe::raw_write): Ditto.
(fhandler_mailslot::raw_read): Ditto.
* fhandler_fifo.cc (fhandler_fifo::raw_read): Reflect read_overlapped ->
raw_read rename.
(fhandler_fifo::raw_write): Ditto.
* fhandler_mailslot.cc (fhandler_mailslot::raw_read): Delete.
(fhandler_mailslot::raw_write): Reflect read_overlapped -> raw_read rename.
* pipe.cc (fhandler_pipe::raw_read): Delete.
(fhandler_pipe::raw_write): Ditto.
@
text
@d181 1
d183 5
a187 1
  virtual void set_name (const char *s) {pc.set_normalized_path (s);}
d298 4
a301 1
  virtual int open (int, mode_t = 0);
d303 1
d305 11
d571 1
d636 1
d670 1
d683 1
d716 1
d760 1
d778 1
a778 1
  virtual int open (int flags, mode_t mode = 0);
d792 1
d836 1
d858 1
d907 1
d1081 4
a1084 1
  int open (int flags, mode_t mode = 0);
a1094 3
  /* Special dup as we must dup two handles */
  int dup (fhandler_base *child);

d1113 1
d1158 1
a1158 1
  fhandler_tty_slave ();
d1160 1
d1162 1
d1172 1
d1183 1
d1199 1
d1208 1
d1224 2
d1233 1
d1239 2
d1251 1
d1270 1
d1292 1
d1317 2
a1318 1
} ;
d1337 1
d1360 1
a1384 1
  int dup (fhandler_base *child);
d1390 2
d1426 1
d1440 1
d1460 1
d1473 1
d1487 1
d1511 1
d1526 1
d1539 1
d1552 1
a1552 1
		  use_op, ((fhandler_tty_slave *) fh)->archetype->usecount);
@


1.420
log
@	* fhandler.h (class fhandler_base): Remove uninterruptible_io status
	flag.
	(fhandler_base::ready_for_read): Remove declaration.
	(fhandler_socket::ready_for_read): Ditto.
	(fhandler_pipe::ready_for_read): Ditto.
	(fhandler_tty_master::is_slow): Remove.
	* fhandler_console.cc (fhandler_console::open): Drop setting
	uninterruptible_io.
	* fhandler_serial.cc (fhandler_serial::open): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Ditto.
	(fhandler_tty_master::init_console): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Ditto.
	(fhandler_pipe::open): Ditto.
	(_pipe): Ditto.
	* select.cc (fhandler_pipe::ready_for_read): Remove.
	(fhandler_base::ready_for_read): Remove.
	* syscalls.cc (readv): Drop unneeded wait variable.  Remove entire test
	which might lead to calling ready_for_read.  Remove now unused label
	out.
@
text
@d363 2
a364 2
  virtual void __stdcall raw_read (void *ptr, size_t& ulen);
  virtual ssize_t __stdcall raw_write (const void *ptr, size_t ulen);
d570 2
a571 3
  void __stdcall read_overlapped (void *ptr, size_t& len) __attribute__ ((regparm (3)));
  ssize_t __stdcall write_overlapped (const void *ptr, size_t len) __attribute__ ((regparm (3)));
    __attribute__ ((regparm (3)));
a604 2
  void __stdcall raw_read (void *ptr, size_t& len);
  ssize_t __stdcall raw_write (const void *, size_t);
d637 2
a638 2
  void __stdcall raw_read (void *, size_t&);
  ssize_t __stdcall raw_write (const void *, size_t);
d657 1
a657 2
  void __stdcall raw_read (void *ptr, size_t& len);
  ssize_t __stdcall raw_write (const void *, size_t);
d731 2
a732 2
  void __stdcall raw_read (void *ptr, size_t& ulen);
  ssize_t __stdcall raw_write (const void *ptr, size_t ulen);
d755 2
a756 2
  void __stdcall raw_read (void *ptr, size_t& ulen);
  ssize_t __stdcall raw_write (const void *ptr, size_t ulen);
d854 2
a855 2
  void __stdcall raw_read (void *ptr, size_t& ulen);
  ssize_t __stdcall raw_write (const void *ptr, size_t ulen);
@


1.419
log
@	* fhandler.h (class fhandler_mailslot): Move down in file and change
	parent class to fhandler_base_overlapped.  Remove declaration of
	method write.  Add declaraiotns for raw_read and raw_write.
	* fhandler_mailslot.cc (fhandler_mailslot::fhandler_mailslot): Call
	fhandler_base_overlapped constructor.
	(fhandler_mailslot::fstat): Call fhandler_base_overlapped::fstat.
	(fhandler_mailslot::open): Drop FILE_SYNCHRONOUS_IO_NONALERT flag from
	call to NtOpenFile.
	(fhandler_mailslot::raw_read): New method.
	(fhandler_mailslot::raw_write): Ditto.  Take over length algorithm from
	former write method.
	(fhandler_mailslot::write): Remove.
	(fhandler_mailslot::ioctl): Call fhandler_base_overlapped::ioctl.
@
text
@a135 1
    unsigned uninterruptible_io : 1; /* Set if I/O should be uninterruptible. */
d148 2
a149 2
      uninterruptible_io (0), did_lseek (0),
      query_open (no_query), close_on_exec (0), need_fork_fixup (0)
a228 1
  IMPLEMENT_STATUS_FLAG (bool, uninterruptible_io)
a375 1
  virtual int ready_for_read (int fd, DWORD howlong);
a535 1
  int ready_for_read (int, DWORD) { return true; }
a613 1
  int ready_for_read (int fd, DWORD howlong);
a1202 1
  bool is_slow () {return true;}
@


1.418
log
@	* fhandler.h (fhandler_dev_tape::_lock): Add bool parameter.
	* fhandler_tape.cc (lock): Call _lock with false argument.
	(_lock): Take bool cancelable parameter.  Handle O_NONBLOCK.
	Make cancelable if cancelabe parameter is true.
	(fhandler_dev_tape::raw_read): Call _lock with true argument.
	(fhandler_dev_tape::raw_write): Ditto.
@
text
@a407 12
class fhandler_mailslot : public fhandler_base
{
  POBJECT_ATTRIBUTES get_object_attr (OBJECT_ATTRIBUTES &, PUNICODE_STRING, int);
 public:
  fhandler_mailslot ();
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int open (int flags, mode_t mode = 0);
  ssize_t __stdcall write (const void *ptr, size_t len);
  int ioctl (unsigned int cmd, void *);
  select_record *select_read (select_stuff *);
};

d658 13
@


1.417
log
@	Throughout, use user32 UNICODE functions rather than ANSI functions.
	* autoload.cc: Convert all definitions for ANSI user32 functions to
	definitions for the corresponding UNICODE function.
	(SendMessageA): Remove.
	(SendNotifyMessageW): Define.
	* fhandler_windows.cc (fhandler_windows::write): Use SendNotifyMessageW
	call rather than SendMessage to make function always return immediately.
	(fhandler_windows::read): Make function interruptible and a cancellation
	point.  Handle O_NONBLOCK.
	* select.cc (peek_serial): Don't wait for signal_arrived here.
	* window.cc (wininfo::winthread): Call CreateWindowExW directly rather
	than CreateWindow wrapper.
@
text
@d754 1
a754 1
  inline bool _lock ();
@


1.416
log
@	* fhandler.h (fhandler_socket::is_slow): Remove.
@
text
@a1321 1
  bool is_slow () {return true;}
@


1.415
log
@* cygheap.h (init_cygheap::ctty): Use base class so that console can join in
the fun.
* dtable.cc (dtable::stdio_init): Remove special-case call to set_console_ctty
().
* exceptions.cc (sigpacket::process): Conditionally flush terminal input on
certain signals.
* fhandler.h (fhandler_console::get_tty_stuff): Make non-static.
(fhandler_termios::get_ttyp): Move here.
(fhandler_termios::sigflush): Declare.
(fhandler_tty_common::get_ttyp): Delete.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass this as "arch"
argument.
(set_console_ctty): Delete.
(tty_list::get_tty): Just return pointer to shared console region, delaying
get_tty_stuff until open().
(fhandler_console::init): Treat NULL handle as signifying that console should
be opened with O_NOCTTY flag.  Rename handle argument to the more common 'h'.
* fhandler_termios.cc (fhandler_termios::sigflush): Define.
* fhandler_tty.cc (handler_tty_master::init_console): Pass NULL as first
argument to fhandler_console::init.
* pinfo.cc (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
Add extra debugging.
* pinfo.h (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
* sigproc.cc (handle_sigsuspend): Don't special-case non-main threads.
@
text
@a566 1
  bool is_slow () {return true;}
@


1.414
log
@Implement /proc/sysvipc/*
* devices.in (dev_procsysvipc_storage): Add.
* devices.cc: Regenerate.
* devices.h (fh_devices): Add FH_PROCSYSVIPC.
* dtable.cc (build_fh_pc): Add case FH_PROCSYSVIPC.
* fhandler.h (class fhandler_procsysvipc): Declare.
(fhandler_union): Add __procsysvipc.
* fhandler_proc.cc (proc_tab): Add sysvipc virt_directory.
* fhandler_procsysvipc.cc: New file.
* Makefile.in (DLL_OFILES): Add fhandler_procsysvipc.o.
* path.h (isproc_dev): Add FH_PROCSYSVIPC to conditional.
@
text
@d915 2
d1088 1
a1088 1
  static tty_min *get_tty_stuff (int);
a1115 2
  tty *get_ttyp () { return (tty *) tc; }

@


1.413
log
@* fhandler.h (DEFAULT_PIPEBUFSIZE): Reset to 64K.
@
text
@d1422 12
d1532 1
@


1.412
log
@* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Remove special
treatment for ERROR_NO_SYSTEM_RESOURCES.  Cancel I/O and reset the overlapped
handle on error.
(fhandler_base_overlapped::write_overlapped): Limit writes to max_atomic_write
bytes in blocking case.  Incorporate code from now-defunct
write_overlapped_fallback.  Fix serious oversight where ptr was not advanced as
buffer was written.
(fhandler_base_overlapped::write_overlapped_fallback): Eliminate.
* fhandler.h (fhandler_base_overlapped::write_overlapped_fallback): Ditto for
declaration.
(DEFAULT_PIPEBUFSIZE): Lower size to slightly less than documented worst-case
atomic write size.
(fhandler_overlapped::wait_return): Remove unused element.
@
text
@d32 5
a36 1
#define DEFAULT_PIPEBUFSIZE (31 * 1024 * 1024)
@


1.411
log
@* errno.cc (errmap): Change mapping of NO_SYSTEM_RESOURCES to EFBIG.
* fhandler.cc (MAX_OVERLAPPED_WRITE_LEN): New constant.
(MIN_OVERLAPPED_WRITE_LEN): Ditto.
(fhandler_base_overlapped::close): Accommodate change in arguments to
wait_overlapped.
(fhandler_base_overlapped::setup_overlapped): Add __stdcall and regparm
modifiers.
(fhandler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Ditto.
(fhandler_base_overlapped::wait_overlapped): Modify to return an enum returning
various states.  Accept nonblocking parameter.
(fhandler_base_overlapped::read_overlapped): Add __stdcall and regparm
modifiers.  Rework to attempt to be smarter about reacting to states returned
by wait_overlapped.
(fhandler_base_overlapped::write_overlapped): Ditto.  Add fallback option for
when wait_overlapped detects that smaller chunks must be written.
(fhandler_base_overlapped::write_overlapped_fallback): Ditto.
* fhandler.h (DEFAULT_PIPEBUFSIZE): Move definition here from pipe.cc.
(fhandler_base::has_ongoing_io): Define with __stdcall and regparm modifiers.
(fhandler_base_overlapped::wait_return): New enum.
(fhandler_base_overlapped::max_atomic_write): New variable.
(fhandler_base_overlapped:: wait_overlapped): Accommodate changes mentioned
above to arguments and modifiers.
(fhandler_base_overlapped::setup_overlapped): Ditto for modifiers.
(fhandler_base_overlapped::read_overlapped): Ditto.
(fhandler_base_overlapped::write_overlapped): Ditto.
(fhandler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Ditto.
(fhandler_base_overlapped::fhandler_base_overlapped): Zero max_atomic_write.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Set max_atomic_write to the
size of the DEFAULT_PIPEBUFSIZE.
(fhandler_fifo::wait): Accommodate change in arguments to wait_overlapped.
* pipe.cc (fhandler_pipe::fhandler_pipe): Set max_atomic_write to the size of
the DEFAULT_PIPEBUFSIZE.
(fhandler_pipe::create_selectable): Allow minimum size of DEFAULT_PIPEBUFSIZE.
(DEFAULT_PIPEBUFSIZE): Delete here, move to fhandler.h.
@
text
@d32 1
a32 1
#define DEFAULT_PIPEBUFSIZE PREFERRED_IO_BLKSIZE
d573 1
a573 2
    overlapped_error,
    overlapped_fallback
a584 1
  ssize_t __stdcall write_overlapped_fallback (const void *ptr, size_t orig_len)
@


1.411.2.1
log
@	* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Remove
	special treatment for ERROR_NO_SYSTEM_RESOURCES.  Cancel I/O and reset
	the overlapped handle on error.
	(fhandler_base_overlapped::write_overlapped): Limit writes to
	max_atomic_write bytes in blocking case.  Incorporate code from
	now-defunct write_overlapped_fallback.  Fix serious oversight where ptr
	was not advanced as buffer was written.
	(fhandler_base_overlapped::write_overlapped_fallback): Eliminate.
	* fhandler.h (fhandler_base_overlapped::write_overlapped_fallback):
	Ditto for declaration.
	(DEFAULT_PIPEBUFSIZE): Lower size to slightly less than documented
	worst-case atomic write size.
	(fhandler_overlapped::wait_return): Remove unused element.
@
text
@d32 1
a32 1
#define DEFAULT_PIPEBUFSIZE (31 * 1024 * 1024)
d573 2
a574 1
    overlapped_error
d586 1
@


1.411.2.2
log
@2011-03-18  Christopher Faylor  <me.cygwin2011@@cgf.cx>

	* fhandler.h (DEFAULT_PIPEBUFSIZE): Reset to 64K.

2011-03-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap_record::alloc_fh): Initialize name strings in fdev to
	empty strings or suffer a SEGV.  Drop second parameter in call to
	build_fh_dev.

2011-03-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (class mmap_record): Pack 4 byte-aligned.  Convert member dev
	to plain int.
	(mmap_record::alloc_fh): Create temporary device from dev and use in
	call to build_fh_dev.
@
text
@d32 1
a32 5

/* It also appears that this may be the only acceptable block size for
   atomic writes to a pipe.  It is a shame that we have to make this
   so small.  http://cygwin.com/ml/cygwin/2011-03/msg00541.html  */
#define DEFAULT_PIPEBUFSIZE PREFERRED_IO_BLKSIZE
@


1.410
log
@	* fhandler.h (struct part_t): New type.
	(class fhandler_dev_floppy): Convert partitions to part_t pointer.
	Add lock_partition method.
	* fhandler_floppy.cc (fhandler_dev_floppy::lock_partition): New method
	to implement ondemand partition locking.
	(fhandler_dev_floppy::write_file): Call lock_partition from here if
	writing failed due to a potential write restriction on a disk
	partition.
	(fhandler_dev_floppy::open): Don't lock partitions here.
	(fhandler_dev_floppy::close): Keep track of partition handle reference
	count.  Close handles and remove partitions pointer ony if count is 0.
	(fhandler_dev_floppy::dup): Just copy partitions pointer and increment
	reference count.
@
text
@d32 1
d401 1
a401 1
  virtual bool has_ongoing_io () {return false;}
d569 7
d579 1
d581 3
a583 3
  int wait_overlapped (bool, bool, DWORD *, DWORD = 0) __attribute__ ((regparm (3)));
  int setup_overlapped () __attribute__ ((regparm (1)));
  void destroy_overlapped () __attribute__ ((regparm (1)));
d585 3
a587 1
  ssize_t __stdcall write_overlapped (const void *ptr, size_t len);
d591 1
a591 1
  fhandler_base_overlapped (): io_pending (false), overlapped (NULL)
d595 1
a595 1
  bool has_ongoing_io ();
@


1.409
log
@	* fhandler.h (MAX_PARTITIONS): New definition.
	(class fhandler_dev_floppy): Add partitions array member.  Add close
	method.
	* fhandler_floppy.cc (fhandler_dev_floppy::fhandler_dev_floppy): Zero
	out partitions array.
	(fhandler_dev_floppy::open): Fix "entire disk" condition for call to
	DeviceIoControl (FSCTL_ALLOW_EXTENDED_DASD_IO).
	When opening disks for writing, call DeviceIoControl (FSCTL_LOCK_VOLUME)
	on all affected disk partitions starting with Vista.
	(fhandler_dev_floppy::close): New method.
	(fhandler_dev_floppy::dup): Duplicate handles in partitions, if any.
	* wincap.h (wincaps::has_restricted_raw_disk_access): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d692 6
d703 1
a703 1
  HANDLE partitions[MAX_PARTITIONS];
d716 2
@


1.408
log
@* fhandler.h (fhandler_termios::tcinit): Make second argument non-optional.
* fhandler_console.cc (fhandler_console::open): Specify second argument to
tcinit.
* fhandler_termios.cc (fhandler_termios::tcinit): Rename second argument.  Set
pgid to 0 if this is a pty master.
(fhandler_termios::tcgetpgrp): Just return value of pgid.  It will be zero if
not initialized.
* fhandler_tty.cc (fhandler_tty_slave::open): Specify second argument to
tcinit.
(fhandler_tty_slave::ioctl): Implement TIOCGPRP/TIOCSPGRP.  Fix switch
indentation.
(fhandler_tty_master::ioctl): Implement TIOCGPRP/TIOCSPGRP.
* include/sys/termios.h (TIOCGPGRP): Define similarly to Linux.
* include/sys/termios.h (TIOCSPGRP): Ditto.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d690 2
d697 1
d717 1
@


1.407
log
@	* fhandler.h (fhandler_base::get_stat_access): Delete.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Always check
	executable suffix to get x-bits for .exe files also in notexec case.
	Always reopen file when checking for file header.
	* ntdll.h (wait_pending): Delete.
	* path.cc (symlink_info::check_shortcut): Drop call to wait_pending
	since file is always opened for sync IO.
	(symlink_info::check_sysfile): Ditto.
	(MIN_STAT_ACCESS): Remove.
	(FULL_STAT_ACCESS): Remove.
	(symlink_info::check): Drop access flag.  Revert to open file with
	just read attributes access.  Reorder symlink check to check for
	reparse points first.  Don't check reparse points for anything else,
	even on remote drives.  Open file for GENERIC_READ when trying to
	read shortcuts or system-bit symlinks. Accommodate dropped access
	flag in call to path_conv_handle::set.
	* path.h (class path_conv_handle): Drop access flag and accommodate
	all related methods.
@
text
@d888 1
a888 1
  void tcinit (tty_min *this_tc, bool force = false);
@


1.406
log
@	* fhandler.cc (fhandler_base::open): Handle query_write_dac flag.
	* fhandler.h (enum query_state): Add query_write_dac flag.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Open file
	with query_write_dac instead of query_write_control.
@
text
@a200 1
  int get_stat_access () const { return pc.handle () ? pc.access () : access; }
@


1.405
log
@	* fhandler.h (class fhandler_base): Change inheritance of fstat_helper
	and fstat_by_...  methods to private.
	(fhandler_base::fstat_helper): Drop all redundant arguments.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call
	to fstat_by_nfs_ea here.  Drop fetching basic file information.
	Drop setting file attributes.  Accommodate change in fstat_helper call.
	(fhandler_base::fstat_by_name): Simplify.  Only fetch directory
	information to get the inode number.  Drop setting file attributes.
	Accommodate change in fstat_helper call.
	(fhandler_base::fstat_fs): Call fstat_by_nfs_ea if on NFS.
	(fhandler_base::fstat_helper): Drop all redundant arguments.  Use
	information already collected in the fhandler.  Move heading comment
	into code and drop dwFileAttributes comment.
	* mmap.cc (mmap64): Call fstat_fs rather than fstat_by_handle.
	* mount.cc (fs_info::update): Note that has_buggy_basic_info is unused.
	* path.cc (symlink_info::check_reparse_point): Add comment.
	(symlink_info::check): Fetch FileNetworkOpenInformation rather than
	FileBasicInformation throughout, except on NFS.  Explain why.  Store
	FILE_NETWORK_OPEN_INFORMATION in conv_hdl.  Remove
	FILE_ATTRIBUTE_DIRECTORY attribute in conv_hdl for reparse point
	symlinks.
	* path.h (class path_conv_handle): Add FILE_NETWORK_OPEN_INFORMATION
	member _fnoi.
	(path_conv_handle::fnoi): New accessor method for _fnoi.
	(path_conv::fnoi): New accessor method for cubv_hdl._fnoi.

	* fhandler_tty.cc (fhandler_tty_slave::init): Use tty::setpgid method.
@
text
@d95 2
a96 1
  query_write_attributes = 4
@


1.404
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procsys.o.
	* devices.h (enum fh_devices): Add FH_PROCSYS.
	* devices.in (dev_procsys_storage): New device.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add code to allocate fhandler_procsys.
	* fhandler.h (proc_len): Convert to size_t.
	(procsys): Declare.
	(procsys_len): Declare.
	(enum virtual_ftype_t): Move here from fhandler_virtual.h.
	Add members supported by fhandler_procsys.
	(fhandler_virtual::exists): Return virtual_ftype_t.  Change
	in all derived classes.
	(class fhandler_procsys): New class.
	(fhandler_union): Add fhandler_procnet and fhandler_procsys members.
	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Use
	ro_u_proc.
	(fhandler_base::fstat_by_handle): Don't copy attributes if file is an
	NT device.
	(fhandler_base::fstat_by_name): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::exists): Return
	virtual_ftype_t.
	* fhandler_proc.cc (proc_tab): Sort alphabetically.  Use _VN macro
	to store length.
	(proc_len): Change to size_t.
	(proc_tab_cmp): New static function.
	(virt_tab_search): New function to search entry in virt_tab_t
	arrays.  Use throughout in /proc and sibling classes instead of
	loop.
	(fhandler_proc::exists): Return virtual_ftype_t.
	* fhandler_process.cc (process_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_process::exists): Return virtual_ftype_t.
	(fhandler_process::open): Simplify code.
	* fhandler_procnet.cc (procnet_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_procnet::exists): Return virtual_ftype_t.
	(fhandler_procnet::open): Simplify.
	* fhandler_procsys.cc: New file.
	* fhandler_registry.cc (fhandler_registry::exists): Return
	virtual_ftype_t.
	* fhandler_virtual.cc (fhandler_virtual::exists): Ditto.
	* fhandler_virtual.h (enum virtual_ftype_t): Move to fhandler.h.
	(virt_tab_t): Add name_len member.
	(_VN): New macro.
	(virt_tab_search): Declare.
	* mount.cc (mount_info::conv_to_win32_path): Fix comment.  Backslashify
	isprocsys_dev paths.
	* ntdll.h (STATUS_OBJECT_TYPE_MISMATCH): Define
	(STATUS_INSTANCE_NOT_AVAILABLE): Define.
	(STATUS_PIPE_NOT_AVAILABLE): Define.
	(STATUS_INVALID_PIPE_STATE): Define.
	(STATUS_PIPE_BUSY): Define.
	(SYMBOLIC_LINK_QUERY): Define.
	(NtOpenSymbolicLinkObject): Declare.
	(NtQuerySymbolicLinkObject): Declare.
	* path.cc (path_conv::check): Accommodate fact that exists method
	returns virtual_ftype_t now.  Add cases for new virtual_ftype_t
	types.
	(cygwin_conv_path): Add GLOBALROOT prefix to native device paths.
	Make sure to strip \\?\ prefix only for actual filesystem-based
	paths, not for all paths.
	* path.h (isproc_dev): Add FH_PROCSYS.
	(isprocsys_dev): Define.
@
text
@d296 1
d298 2
a299 11
			      PLARGE_INTEGER ChangeTime,
			      PLARGE_INTEGER LastAccessTime,
			      PLARGE_INTEGER LastWriteTime,
			      PLARGE_INTEGER CreationTime,
			      DWORD dwVolumeSerialNumber,
			      ULONGLONG nFileSize,
			      LONGLONG nAllocSize,
			      ULONGLONG nFileIndex,
			      DWORD nNumberOfLinks,
			      DWORD dwFileAttributes)
    __attribute__ ((regparm (3)));
d303 1
@


1.403
log
@	Align seekdir and telldir API to POSIX definition.
	* Makefile.in (NEW_FUNCTIONS): Remove seekdir and telldir mappings.
	* dir.cc (telldir): Move functionality from telldir64 here.  Use
	long, rather than _off_t.
	(telldir64): Just call telldir.  Only keep for backward compatibility.
	(seekdir): Move functionality from seekdir64 here.  Use long, rather
	than _off_t.
	(seekdir64): Just call seekdir.  Only keep for backward compatibility.
	* fhandler.h: Throughout, change prototypes of seekdir and telldir
	methods to use long, rather than _off64_t.
	* fhandler_disk_file.cc: Change aforementioned methods accordingly.
	* fhandler_netdrive.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* include/sys/dirent.h (struct __DIR): Change __d_position from
	_off_t to long to reflect API change.
	(telldir): Change prototype to use long, rather than off_t.
	(seekdir): Ditto.
@
text
@d37 3
a39 1
extern const int proc_len;
d104 14
d1350 1
a1350 1
  virtual int exists();
d1376 1
a1376 1
  int exists();
d1385 19
d1408 1
a1408 1
  int exists();
d1426 1
a1426 1
  int exists();
d1446 1
a1446 1
  int exists();
d1459 1
a1459 1
  int exists();
d1500 2
@


1.402
log
@	* dtable.cc (dtable::dup_worker): Reset path_conv handle in duplicated
	fhandler.
	* fhandler.cc (fhandler_base::fstatvfs): Keep handle in created
	path_conv.
	* fhandler.h (fhandler_base::get_stat_access): New method.
	(fhandler_base::get_stat_handle): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Use handle
	returned by get_stat_handle.  Only request inode from system if it
	isn't already set in the fhandler, and only for filesystems supporting
	them.
	(fhandler_base::fstat_fs): Use handle returned by get_stat_handle.
	Change the way open_fs is called.  Explain why.
	(fhandler_base::fstat_helper): Use handle returned by get_stat_handle.
	Never use 0 inode number.  Simplify executable recognition by re-using
	get_stat_handle if file could be opened with sufficient rights.
	(fhandler_disk_file::fstatvfs): Use handle returned by get_stat_handle.
	(fhandler_disk_file::facl): Use handle returned by get_stat_handle in
	GETACL and GETACLCNT cases.
	(fhandler_disk_file::link): Use handle returned by get_stat_handle
	instead of opening file here again.  Add comment.
	(readdir_get_ino): Keep handle in created path_conv and drop
	opening file.
	* ntdll.h (wait_pending): New helper function.
	* path.cc (symlink_info::check): Drop unused 'opt' parameter from
	declaration.  Add path_conv_handle argument.
	(path_conv::check): Make sure conv_handle is closed.  Keep
	PC_KEEP_HANDLE flag in pflags_or.  Accommodate call to sym.check to
	new args.
	(path_conv::~path_conv): Close conv_handle.
	(symlink_info::check_shortcut): Don't re-open file here, just use
	incoming handle.  Drop goto's and label out.
	(symlink_info::check_sysfile): Don't re-open file here, just use
	incoming handle.  Keep track of file position to accommodate the fact
	that file has been opened asynchronously in calling function.
	(symlink_info::check_nfs_symlink): Don't re-open file here, just use
	incoming handle.
	(symlink_info::check): Drop unused 'opt' parameter.  Add
	path_conv_handle argument.  Always try to open file with GENERIC_READ
	rights first to allow reading file content w/o having to re-open the
	file.  Drop back to READ_CONTROL | FILE_READ_ATTRIBUTES otherwise.
	Call symlink test functions (except for check_reparse_point) only if
	file could be opened with GENERIC_READ.  Keep file handle open if
	PC_KEEP_HANDLE is set in pflags.
	* path.h (enum pathconv_arg): Add PC_KEEP_HANDLE flag.
	(class path_conv_handle): New class.
	(class path_conv): Add conv_handle member.
	(path_conv::operator =): Duplicate conv_handle.
	(path_conv::handle): New method.
	(path_conv::access): New method.
	(path_conv::reset_conv_handle): New method.
	(path_conv::close_conv_handle): New method.
@
text
@d381 2
a382 2
  virtual _off64_t telldir (DIR *);
  virtual void seekdir (DIR *, _off64_t);
d777 2
a778 2
  _off64_t telldir (DIR *);
  void seekdir (DIR *, _off64_t);
d1336 2
a1337 2
  _off64_t telldir (DIR *);
  void seekdir (DIR *, _off64_t);
d1375 1
a1375 1
  void seekdir (DIR *, _off64_t);
d1393 2
a1394 2
  _off64_t telldir (DIR *);
  void seekdir (DIR *, _off64_t);
@


1.401
log
@	* fhandler.h (class fhandler_pty_master): Add master_thread member.
	* fhandler_tty.cc (fhandler_pty_master::close): Properly detach from
	master thread.
	(fhandler_pty_master::setup): Store cygthread pointer of pty master
	control thread in master_thread.  Don't zap thread handle.
@
text
@d184 1
d359 1
@


1.400
log
@	* autoload.cc (GetNamedPipeClientProcessId): Define.
	* fhandler.h (fhandler_tty_slave::fch_open_handles): Declare private.
	(fhandler_tty_slave::fch_close_handles): Ditto.
	(fhandler_tty_slave::cygserver_attach_tty): Drop declaration.
	(fhandler_tty_slave::fstat): Declare public.
	(fhandler_tty_slave::fchmod): Declare public.
	(fhandler_tty_slave::fchown): Declare public.
	(class fhandler_pty_master): Add master_ctl handle.
	(fhandler_pty_master::pty_master_thread): Declare public.
	* fhandler_termios.cc (fhandler_termios::tcinit): If the process
	is started from a non-Cygwin process, make it tty process group
	leader.
	* fhandler_tty.cc: Throughout accommodate additional security related
	arguments in calls to functions creating or opening objects.
	(close_maybe): Move to start of file to reuse it
	in other methods.
	(struct pipe_request): Define.
	(struct pipe_reply): Define.
	(fhandler_tty_slave::open): Throughout, try to open synchronization
	objects with MAXIMUM_ALLOWED permissions.  Drop call to cygserver.
	Try to duplicate pipe handles via master_ctl pipe if duplicating
	directly doesn't work.
	(fhandler_tty_slave::cygserver_attach_tty): Remove.
	(fhandler_tty_slave::init): Close unused incoming pipe handle.
	(fhandler_pty_master::close): Send exit message to master control
	thread and close master_ctl handle.
	(fhandler_pty_master::pty_master_thread): New method, implementing the
	master control thread.
	(pty_master_thread): Static helper to start master control thread.
	(fhandler_pty_master::setup): Simplify creating pipe inheritance.
	Make sure we're the one creating the input_available_event.  Add
	comment to explain why.  Create master_ctl pipe and start master
	control thread.  Close master_ctl handle in case of error.
	* security.cc (alloc_sd): Add code to handle tty objects.  Add comments
	to explain what exactly is required.
	(get_object_sd): New function.
	(get_object_attribute): New function.
	(create_object_sd_from_attribute): New function.
	(set_object_sd): New function.
	(set_object_attribute): New function.
	(set_file_attribute): Change attribute type to mode_t.
	* security.h (set_file_attribute): Change attribute type to mode_t.
	(get_object_sd): Declare.
	(get_object_attribute): Declare.
	(create_object_sd_from_attribute): Declare.
	(set_object_sd): Declare.
	(set_object_attribute): Declare.
	* tty.cc (tty::slave_alive): Implement directly instead of via alive.
	(tty::exists): Open mutex handle with READ_CONTROL access.
	(tty::alive): Remove.
	(tty::open_output_mutex): Convert to inline method.
	(tty::open_input_mutex): Ditto.
	(tty::open_mutex): Take additional ACCESS_MASK parameter for the
	mutex open access mask.
	(tty::open_inuse): New method.
	(tty::create_inuse): Take PSECURITY_ATTRIBUTES parameter.  Drop fmt
	name parameter.  Always create TTY_SLAVE_ALIVE event.
	(tty::get_event): Take additional PSECURITY_ATTRIBUTES parameter for
	CreateEvent.
	* tty.h (class tty): Change declarations according to aforementioned
	changes.
	(tty::open_output_mutex): Implement as inline method.
	(tty::open_input_mutex): Ditto.
@
text
@d1128 1
@


1.399
log
@	* fhandler.h (class dev_console): Add backspace_keycode member.
	* fhandler_console.cc (fhandler_console::get_tty_stuff): Initialize
	backspace_keycode with CERASE.
	(fhandler_console::read): Return dev_state->backspace_keycode if the
	backspace key is pressed.
	(fhandler_console::char_command): Implement DECBKM escape sequence.
@
text
@d1092 6
a1116 1
  int cygserver_attach_tty (HANDLE*, HANDLE*);
d1119 3
d1127 2
d1136 1
@


1.398
log
@* fhandler.h (fhandler_base::has_ongoing_io): Declare virtual method.
* select.cc (peek_pipe): Reorganize slightly.  Don't attempt to check a handle
if it has ongoing I/O.
(select_pipe_info::select_pipe_info): Delete definition.
(select_pipe_info::~select_pipe_info): Delete definition.
(thread_pipe): Get rid of WFMO call.  Reorganize loop.
(pipe_cleanup): Remove dependence on destructor.
(thread_serial): Reorganize loop.
* select.h (select_pipe_info): Empty this class since it no longer has any
special requirements (for now).
* syscalls.cc (readv): Remove an unneeded debug printf.
@
text
@d927 1
@


1.397
log
@* fhandler.h (fhandler_base::setup_overlapped): Delete virtual declaration.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base_overlapped): Remove now-unneeded friend.
(fhandler_base_overlapped::setup_overlapped): Return int, remove parameter.
(fhandler_base_overlapped::get_overlapped): Return reference.
(fhandler_base_overlapped::fhandler_base_overlapped): Be more assertive about
zeroing everything.
(fhandler_base_overlapped::fixup_after_fork): Declare new function.
(fhandler_base_overlapped::fixup_after_exec): Ditto.
(fhandler_base_overlapped::dup): Ditto.
(fhandler_base_overlapped::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo::dup): Call fhandler_base_overlapped::dup
rather than fhandler_base::dup.
* pipe.cc (fhandler_pipe::dup): Ditto.
(fhandler_pipe::init): Accommodate change in setup_overlapped arguments for
"opened_properly" case.
@
text
@d389 1
@


1.396
log
@* fhandler.h (fhandler_base_overlapped): Temporarily (?) make select_pipe_info
a friend until the fhandler_tty intertangling can be worked out.
* select.cc (select_pipe_info::add_watch_handle): Don't inspect the overlapped
event if we're not waiting for I/O.
(fhandler_tty_common::select_*): Change to standard function.  Don't do kludgy
fhandler_pipe coercion.
@
text
@a388 2
  virtual void destroy_overlapped () __attribute__ ((regparm (1))) {}
  virtual bool setup_overlapped () {return false;}
d561 1
a561 1
  bool setup_overlapped (bool doit = true) __attribute__ ((regparm (2)));
d565 1
a565 1
  OVERLAPPED *get_overlapped () {return overlapped;}
d568 4
a571 1
  fhandler_base_overlapped (): io_pending (false), overlapped (NULL) {}
d573 6
a578 2
  friend class select_pipe_info;	/* FIXME: At least correct the naming
					   here */
@


1.395
log
@Add missing fhandler.h patch and ChangeLog comment.
@
text
@d572 2
@


1.394
log
@* fhandler.cc (fhandler_base::dup): Call setup_overlapped unconditionally.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::fixup_after_fork): Ditto.
(fhandler_base::fixup_after_exec): Ditto.
(fhandler_base_overlapped::setup_overlapped): Move to this class from
fhandler_base.
(handler_base_overlapped::destroy_overlapped): Ditto.
(fhandler_base_overlapped::wait_overlapped): Ditto.  Track when we expect
pending I/O.
(fhandler_base_overlapped::read_overlapped): Move to this class from
fhandler_base.  Return error if ongoing I/O.
(fhandler_base_overlapped::write_overlapped): Ditto.
(fhandler_base_overlapped::has_ongoing_io): Semi-reinstate previous function.
* fhandler.h (fhandler_base::wait_overlapped): Move to fhandler_base_overlapped
class.
(fhandler_base::write_overlapped): Ditto.
(fhandler_base::get_overlapped): Ditto.
(fhandler_base::get_overlapped_buffer): Ditto.
(fhandler_base_overlapped): New class.
(fhandler_pipe): Inherit from fhandler_base_overlapped.  Remove overlapped
stuff as a result.
(fhandler_fifo): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Initialize fhandler_base_overlapped.
(pipe): Put a descriptive name in the fhandler.
@
text
@d914 3
a916 1
  bool vt100_graphics_mode_active;
@


1.393
log
@	* fhandler_socket.cc (fhandler_socket::evaluate_events): Make erase
	const in parameter list.
	(fhandler_socket::wait_for_events): Take a DWORD flags value instead of
	just a bool.  Call evaluate_events with erase flag according to
	MSG_PEEK value in flags.  Replace check for dontwait with check for
	MSG_DONTWAIT in flags.
	(fhandler_socket::connect): Call wait_for_events with 0 flags value.
	(fhandler_socket::accept4): Ditto.
	(fhandler_socket::recv_internal): Save flags in wait_flags.  Drop
	dontwait variable.  Call wait_for_events with wait_flags.
	(fhandler_socket::send_internal): Save MSG_DONTWAIT flag in wait_flags
	and call wait_for_events with wait_flags as argument.  Drop dontwait
	variable.
	* fhandler.h (class fhandler_socket): Change second parameter in
	declaration of wait_for_events to const DWORD.
@
text
@a152 3
  int wait_overlapped (bool, bool, DWORD *, DWORD = 0) __attribute__ ((regparm (3)));
  bool setup_overlapped (bool doit = true) __attribute__ ((regparm (2)));
  void destroy_overlapped () __attribute__ ((regparm (1)));
a309 1
  virtual void __stdcall read_overlapped (void *ptr, size_t& len) __attribute__ ((regparm (3)));
a310 1
  virtual ssize_t __stdcall write_overlapped (const void *ptr, size_t len);
a351 3
  virtual OVERLAPPED *get_overlapped () {return NULL;}
  virtual OVERLAPPED *get_overlapped_buffer () {return NULL;}
  virtual void set_overlapped (OVERLAPPED *) {}
d389 2
d555 1
a555 1
class fhandler_pipe: public fhandler_base
d557 2
a558 2
private:
  pid_t popen_pid;
d562 5
a566 2
  fhandler_pipe ();

d570 11
d606 1
a606 1
class fhandler_fifo: public fhandler_base
a621 1
  OVERLAPPED io_status;
a633 2
  OVERLAPPED *get_overlapped () {return &io_status;}
  OVERLAPPED *get_overlapped_buffer () {return &io_status;}
@


1.392
log
@* fhandler.cc (fhandler_base::setup_overlapped): Don't set signalled state to
true initially.
(fhandler_base::has_ongoing_io): Delete ill-advised function.
(fhandler_base::read_overlapped): Rely on caller having checked nonblocking
state.  Don't attempt to (incorrectly) check it here.
(fhandler_base::write_overlapped): Remove call to has_ongoing_io.
* select.cc (peek_pipe): Ditto.
* fhandler.h (fhandler_base::has_ongoing_io): Delete declaration.
@
text
@d435 1
a435 1
  int wait_for_events (const long event_mask, bool dontwait);
@


1.391
log
@	* cygwin.din (accept4): Export.
	* fhandler.h (fhandler_socket::accept4): Rename from accept.  Take
	additional flag parameter.
	* fhandler_socket.cc (fhandler_socket::accept4): Ditto.  Handle
	SOCK_NONBLOCK and SOCK_CLOEXEC flags.
	* net.cc (cygwin_socket): Handle SOCK_NONBLOCK and SOCK_CLOEXEC flags
	in type.  Check for invalid flag values.
	(socketpair): Ditto.
	(cygwin_accept): Accommodate renaming of fhandler_socket::accept
	function to accept4.
	(accept4): New function.
	* posix.sgml: Mention accept4 as GNU extensions.
	* include/cygwin/socket.h (SOCK_NONBLOCK): Define.
	(SOCK_CLOEXEC): Define.
	(_SOCK_FLAG_MASK): Define when building Cygwin.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/socket.h (accept4): Declare.
@
text
@a313 1
  virtual bool __stdcall has_ongoing_io (bool) __attribute__ ((regparm (2)));
@


1.390
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d508 1
a508 1
  int accept (struct sockaddr *peer, int *len);
@


1.389
log
@	* fhandler.h (fhandler_base::fstat_helper): Declare timestamps as
	PLARGE_INTEGER.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle):
	Accommodate fstat_helper change of timestamp arguments.
	(fhandler_base::fstat_by_name): Ditto.
	(fhandler_base::fstat_helper): Define with timestamps as PLARGE_INTEGER.
	Accommodate in call to to_timestruc_t.
@
text
@d402 1
a402 1
  POBJECT_ATTRIBUTES get_object_attr (OBJECT_ATTRIBUTES &, PUNICODE_STRING);
@


1.388
log
@	* fhandler.h (fhandler_socket::wait_for_events): Drop parameter default
	value.
	* fhandler_socket.cc (fhandler_socket::connect): Add false as second
	parameter to wait_for_events call.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::send_internal): Fix typo in call to wait_for_events.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d283 4
a286 4
			      FILETIME ftChangeTime,
			      FILETIME ftLastAccessTime,
			      FILETIME ftLastWriteTime,
			      FILETIME ftCreationTime,
@


1.387
log
@	* fhandler_console.cc (write_console): Check for VT100
	graphics mode and transform wide characters in ASCII small
	letter range to corresponding graphics.
	(__vt100_conv): Table to transform small ASCII letters to line
	drawing graphics for use in VT100 graphics mode.
	(write_normal): Check for SO/SI control characters to
	enable/disable VT100 graphics mode.
	(base_chars): Enable SO/SI control characters for detection.
	(write): Check for ESC ( 0 / ESC ( B escape sequences to
	enable/disable VT100 graphics mode. Also detect ">" while
	parsing ESC [ sequences to distinguish specific requests.
	(char_command): Distinguish Secondary from Primary Device Attribute
	request to report more details about cygwin console terminal version.
	* fhandler.h (vt100_graphics_mode_active): New flag to indicate mode.
	(saw_greater_than_sign): New parse flag for ESC [ > sequences.
	(gotparen, gotrparen): New state values to parse ESC ( / ) sequences.

	* fhandler_console.cc (read): Allow combined Alt-AltGr modifiers
	to also produce an ESC prefix like a plain Alt modifier, e.g. to make
	Alt-@@ work on a keyboard where @@ is AltGr-q.
@
text
@d436 1
a436 1
  int wait_for_events (const long event_mask, bool dontwait = false);
@


1.386
log
@	* fhandler.h (fhandler_registry::value_name): Convert to wchar_t*.
	* fhandler_registry.cc: Call UNICODE registry functions throughout
	and convert to multibyte using current locale's charset.  Accommodate
	throughout.
	(must_encode): Take wchar_t.
	(encode_regname): Convert from wchar_t *.
	(decode_regname): Convert to wchar_t *.
@
text
@d892 2
d909 2
@


1.385
log
@	* fhandler_console.cc (read): Detect and handle mouse wheel scrolling
	events (for completion of mouse reporting mode 1000) and mouse
	movement events (for additional mouse reporting modes 1002 and 1003).
	Use mouse_aware() as a guard and only condition for mouse
	reporting in order to enforce consistence of read() and select().
	Add focus reports (for additional focus reporting mode 1004).
	(mouse_aware): Enable detection of additional mouse events for select().
	Tune function to precisely match actual reporting criteria.
	Move adjustment of mouse position (by window scroll offset)
	here to avoid duplicate code.
	(char_command): Initialization of enhanced mouse reporting modes.
	Initialization of focus reporting mode.
	* fhandler.h (use_mouse): Change flag (bool->int) to indicate
	additional mouse modes. Add flag to indicate focus reporting.
	(mouse_aware): Move enhanced function into fhandler_console.cc.
	* select.cc (peek_console): Use modified mouse_aware() for more
	general detection of mouse events. Also check for focus reports.
@
text
@d1352 1
a1352 1
  char *value_name;
@


1.384
log
@	Reintegrate socket duplication via WSADuplicateSocket/WSASocket.
	* autoload.cc (WSADuplicateSocketW): Define.
	(WSASocketW): Define.
	* dtable.cc (dtable::release): Call dec_need_fixup_before if necessary.
	(dtable::fixup_before_fork): New function.
	(dtable::fixup_before_exec): New function.
	* dtable.h (class dtable): Add member cnt_need_fixup_before.  Add
	declarations for above new functions.
	(dtable::dec_need_fixup_before): New inline method.
	(dtable::inc_need_fixup_before): New inline method.
	(dtable::need_fixup_before): New inline method.
	* fhandler.h (fhandler_base::fixup_before_fork_exec): New virtual
	method.
	(fhandler_base::need_fixup_before): New virtual method.
	(class fhandler_socket): Add member prot_info_ptr.
	(fhandler_socket::init_fixup_before): Declare.
	(fhandler_socket::need_fixup_before): New inline method.
	(fhandler_socket::fixup_before_fork_exec): Declare.
	(fhandler_socket::fixup_after_exec): Declare.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	prot_info_ptr to NULL.
	(fhandler_socket::~fhandler_socket): Free prot_info_ptr conditionally.
	(fhandler_socket::init_fixup_before): New method.
	(fhandler_socket::fixup_before_fork_exec): Ditto.
	(fhandler_socket::fixup_after_fork): Use WSASocketW to duplicate
	socket if necessary.
	(fhandler_socket::fixup_after_exec): New method.
	(fhandler_socket::dup): Use fixup_before_fork_exec/fixup_after_fork
	to duplicate socket if necessary.
	* fork.cc (frok::parent): Start child suspended if some fhandler
	needs fixup before fork.  If so, call dtable::fixup_before_fork after
	CreateProcess and resume child.
	* net.cc (fdsock): Try to find out if socket needs fixup before and
	initialize socket accordingly.  Add HUGE comment to explain what happens
	and why.
	* spawn.cc (spawn_guts): Start child suspended if some fhandler needs
	fixup before exec.  If so, call dtable::fixup_before_exec after
	CreateProcess.
@
text
@d939 4
a942 1
  DWORD dwLastButtonState;
d946 2
a947 1
  bool use_mouse;
d1019 2
a1020 1
  bool mouse_aware () {return dev_state->use_mouse;}
@


1.383
log
@	* fhandler.h (class fhandler_mailslot): Declare new private method
	get_object_attr.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Implement.
	(fhandler_mailslot::open): Replace calls to path_conv::get_object_attr
	with calls to fhandler_mailslot::get_object_attr.
@
text
@d229 1
d274 1
d469 6
d535 1
d537 1
@


1.382
log
@	* fhandler.h (fhandler_pty_master::tcgetpgrp): Declare.
	* fhandler_termios.cc (fhandler_termios::tcgetpgrp): Only return
	valid pgid if tty is controlling tty.  Set errno to ENOTTY and
	return -1 otherwise.
	(fhandler_pty_master::tcgetpgrp): New function.  Return 0 for
	master side of pty if it's not the controlling tty of the process.
@
text
@d400 1
@


1.381
log
@	* fhandler.h (class dev_console): Constify charset parameter of
	str_to_con.
	* fhandler_console.cc (dev_console::con_to_str): Simplify.  Always
	default to the current internal locale.
	(dev_console::get_console_cp): Always use codepage 437 for alternate
	charset.
	(dev_console::str_to_con): Constify charset parameter.
	(fhandler_console::write_normal): Always use codepage 437 for alternate
	charset.  Otherwise always default to the current internal locale.
	Replace ASCII SO with ASCII CAN.
	* strfuncs.cc: Tweka comments according to below changes.
	(sys_cp_wcstombs): Constify charset parameter.  Convert all wchar_t
	values in the Unicode private use area U+F0xx to the singlebyte
	counterpart.  Drop special handling creating ASCII SO sequence from
	U+DCxx value.  Rearrange for performance.  Replace ASCII SO with
	ASCII CAN.
	(sys_cp_mbstowcs): Constify charset parameter.  Replace ASCII SO with
	ASCII CAN.  Drop special case for U+DCxx ASCII SO sequences.  Always
	create a replacement from the Unicode private use area U+F0xx for
	invalid byte values in a multibyte sequence.  Do the same for wchar_t
	values from the U+F0xx range to make them roundtrip safe.
	* wchar.h (sys_cp_wcstombs): Constify charset parameter.
	(sys_cp_mbstowcs): Ditto.
@
text
@d1112 1
@


1.380
log
@Fix faccessat(,0) and access() semantics.

* fhandler.h (fhandler_base::fhaccess): Add parameter.
* security.h (check_file_access, check_registry_access): Likewise.
* security.cc (check_file_access, check_registry_access)
(check_access): Implement new parameter.
* fhandler.cc (fhandler_base::fhaccess): Likewise.
(device_access_denied): Update caller.
* syscalls.cc (access, faccessat): Update callers.
* spawn.cc (find_exec, fixup): Likewise.
@
text
@d937 1
a937 1
  DWORD str_to_con (mbtowc_p, char *, PWCHAR d, const char *s, DWORD sz);
@


1.379
log
@* dtable.cc (dtable::fixup_after_exec): Close any popen'ed file handles here.
* fhandler.h (fhandler_*::ispipe): New function.
(fhandler_base::get_popen_pid): Define virtual function.
(fhandler_*::isdevice): Make const.
(fhandler_*::isfifo): Ditto.
@
text
@d395 1
a395 1
  int fhaccess (int flags) __attribute__ ((regparm (2)));
@


1.378
log
@	* fhandler.h (class fhandler_socket): Add peer_sun_path member.
	(fhandler_socket::set_peer_sun_path): New method.
	(fhandler_socket::get_peer_sun_path): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	peer_sun_path to NULL.
	(fhandler_socket::~fhandler_socket): Free peer_sun_path if necessary.
	(fhandler_socket::dup): Duplicate peer_sun_path.
	(fhandler_socket::accept): Ditto.  Return fake unbound peer content
	and len in case of AF_LOCAL sockets.
	(fhandler_socket::getsockname): Always use local sockaddr_storage to
	store socket address and copy over to incoming address.  Handle every
	namelen correctly per POSIX.
	(fhandler_socket::getpeername): Ditto.  Add code path to return
	correct value for AF_LOCAL sockets.
	(fhandler_socket::set_peer_sun_path): New method.
	* net.cc (socketpair): Set peer_sun_path to empty string, just like
	sun_path.
@
text
@d345 4
a348 2
  virtual bool isdevice () { return true; }
  virtual bool isfifo () { return false; }
d564 2
d614 1
a614 1
  bool isfifo () { return true; }
d730 1
a730 1
  bool isdevice () { return false; }
@


1.377
log
@* fhandler.h (pdrive_buf): Defensively allocate one extra byte.
@
text
@d465 1
d537 2
@


1.376
log
@* fhandler.h (fhandler_cygdrive:DRVSZ): New enum.
(pdrive_buf): New place to hold information about cygdrive.
* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Store drive info in
pdrive_buf since get_win32_name() could now be too small to hold everything.
(fhandler_cygdrive::rewinddir): Reset pdrive to pdrive_buf.
(fhandler_cygdrive::closedir): Ditto.
* pipe.cc (fhandler_pipe::init): Be more defensive when referencing
get_win32_name().  Rework logic which made a copy of the POSIX path and then
never used it.
@
text
@d762 1
a762 1
  char pdrive_buf[2 * 26 * DRVSZ];
@


1.375
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d756 4
d762 1
@


1.374
log
@	* fhandler.h (enum del_lock_called_from): New enumeration.
	(fhandler_base::del_my_locks): Declare taking a del_lock_called_from
	as argument.
	* fhandler.cc (fhandler_base::close): Call del_my_locks with "on_close".
	(fhandler_base::fixup_after_fork): Call del_my_locks with "after_fork".
	(fhandler_base::fixup_after_exec): Call del_my_locks with "after_exec".
	* flock.cc (fhandler_base::del_my_locks): Take del_lock_called_from
	as argument.  Call node->del_my_locks with NULL handle in after_exec
	case.  Explain why.
@
text
@d313 4
a316 4
  virtual int write (const void *ptr, size_t len);
  virtual int __stdcall write_overlapped (const void *ptr, size_t len);
  virtual ssize_t readv (const struct iovec *, int iovcnt, ssize_t tot = -1);
  virtual ssize_t writev (const struct iovec *, int iovcnt, ssize_t tot = -1);
d352 2
a353 2
  virtual void raw_read (void *ptr, size_t& ulen);
  virtual int raw_write (const void *ptr, size_t ulen);
d402 1
a402 1
  int write (const void *ptr, size_t len);
d502 1
a502 1
  ssize_t readv (const struct iovec *, int iovcnt, ssize_t tot = -1);
d508 1
a508 1
  ssize_t writev (const struct iovec *, int iovcnt, ssize_t tot = -1);
d566 2
a567 2
  void raw_read (void *ptr, size_t& len);
  int raw_write (const void *, size_t);
a580 7
enum fifo_state
{
  fifo_unknown,
  fifo_wait_for_client,
  fifo_wait_for_server,
  fifo_ok
};
d583 11
d595 1
d599 1
d602 2
a603 2
  void raw_read (void *, size_t&);
  int raw_write (const void *, size_t);
d605 2
d608 1
d674 2
a675 2
  void raw_read (void *ptr, size_t& ulen);
  int raw_write (const void *ptr, size_t ulen);
d698 2
a699 2
  void raw_read (void *ptr, size_t& ulen);
  int raw_write (const void *ptr, size_t ulen);
d792 2
a793 2
  void raw_read (void *ptr, size_t& ulen);
  int raw_write (const void *ptr, size_t ulen);
d978 2
a979 1
  int write (const void *ptr, size_t len);
a980 1
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
d1050 1
a1050 1
  int write (const void *ptr, size_t len);
d1083 1
a1083 1
  int write (const void *ptr, size_t len);
d1130 1
a1130 1
  int write (const void *ptr, size_t len);
d1157 1
a1157 1
  int write (const void *ptr, size_t len);
d1175 1
a1175 1
  int write (const void *ptr, size_t ulen);
d1198 1
a1198 1
  int write (const void *ptr, size_t len);
d1216 1
a1216 1
  int write (const void *ptr, size_t len);
d1247 1
a1247 1
  int write (const void *ptr, size_t len);
d1278 1
a1278 1
  int write (const void *ptr, size_t len);
@


1.373
log
@revert erroneous checkin
@
text
@d96 6
d150 1
a150 1
  void del_my_locks (bool);
@


1.372
log
@* cygtls.cc (_cygtls::init_exception_handler): Test for e, not e->prev or we
could still end up adding our handler twice.  Add comment explaining what we're
doing.
* dll_init.cc (dll_dllcrt0_1): Clarify comment.
@
text
@d575 7
a583 9
  enum fifo_state
  {
    fifo_unknown,
    fifo_wait_for_client,
    fifo_wait_for_server,
    fifo_wait_for_next_client,
    fifo_eof,
    fifo_ok
  };
a587 1
  char *fifo_name (char *) __attribute__ ((regparm (2)));
@


1.371
log
@* autoload.cc (SetParent): Add new import.
* fhandler.h (fhandler_console::create_invisible_console): Declare new
function.
(create_invisible_console_workaround): Ditto.
* fhandler_console.cc (fhandler_console::create_invisible_console): Define new
function.
(create_invisible_console_workaround): Ditto.  Add too much code to deal with
broken Windows 7.  Use a helper app to start an invisible console window.
(fhandler_console::need_invisible): Reorganize to use helper functions to
create invisible console.
* spawn.cc (spawn_guts): Avoid zeroing already zeroed fields in si.
@
text
@a574 7
enum fifo_state
{
  fifo_unknown,
  fifo_wait_for_client,
  fifo_wait_for_server,
  fifo_ok
};
d577 9
d590 1
@


1.370
log
@* dcrt0.cc (jit_debug): New global.
(initial_env): Set jit_debug when we are automatically starting a gdb process.
* dtable.cc (dtable::get_debugger_info): Don't tty tricks when we are being
debugged by our own captive gdb, as determined by jit_debug == true.
(dtable::init_std_file_from_handle): Detect errors when initializing a tty
early rather than at random points later.
* fhandler.h (fhandler_*::init): Return int to indicate success/failure.
* fhandler.cc (fhandler_base::init): Reflect change in return value.
* pipe.cc (fhandler_pipe::init): Ditto.
(fhandler_pipe::create_selectable): Don't say we're retrying when we aren't.
* fhandler_console.cc (fhandler_console::init): Ditto.  Return success/failure.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
(fhandler_tty_slave::open): Make debugging output more detailed.
* tty.cc (tty_list::terminate): Don't close I/O handles before all slaves have
checked in.
(tty::slave_alive): Make a non-inlined function.  Check if tty pipe handles can
be created as an additional exists check.
* tty.h (tty::slave_alive): Just define here.
@
text
@d953 2
@


1.369
log
@	* fhandler.h (class fhandler_socket): Add class members and methods
	to store and retrieve the SO_RCVBUF and SO_SNDBUF sizes.
	* fhandler_socket.cc (fhandler_socket::dup): Duplicate new members.
	(fhandler_socket::send_internal): Check for SO_SNDBUF size and
	restrict send to 1 byte less per KB 823764.  Leave loop immediately
	if WSASendMsg has been used.
	* net.cc (fdsock): Change comment again.  Set buffer sizes to 65536.
	Store values in fhandler_socket.
	(cygwin_setsockopt): Store SO_RCVBUF and SO_SNDBUF sizes in
	fhandler_socket.
	(cygwin_sendto): Drop call to sig_dispatch_pending.
	(cygwin_recvfrom): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendmsg): Ditto.
@
text
@d328 1
a328 1
  virtual void init (HANDLE, DWORD, mode_t);
d569 1
a569 1
  void init (HANDLE, DWORD, mode_t);
d774 1
a774 1
  void init (HANDLE h, DWORD a, mode_t flags);
d974 1
a974 1
  void init (HANDLE, DWORD, mode_t);
d1035 1
a1035 1
  void init (HANDLE, DWORD, mode_t);
@


1.368
log
@* select.h: New file split from fhandler.h.
(select_record::select_record): Define do-nothing constructor for "new" to
avoid gratuitous zeroing.
(select_info): New base class.
(select_pipe_info): New class with methods for dealing with pipes.
(select_socket_info): New class with methods for dealing with sockets.
(select_serial_info): Dummy class for serial.
(select_mailslot_info): Dummy class for mailslots.
(select_stuff): Define device_specific_* as actual classes rather than void *.
* dtable.h (dtable::select_read): Accommodate return value change to 'bool' and
argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* dtable.cc (dtable::select_read): Accommodate return value change to 'bool'
and argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* fhandler.h: Excise select-related classes.
(fhandler_*::select_read): Change argument to select_stuff.
(fhandler_*::select_write): Ditto.
(fhandler_*::select_except): Ditto.
* select.cc (UNIX_FD_ZERO): Use memset rather than bzero.
(select_stuff::test_and_set): Change return type to bool.  Allocate
select_record on entry and let fhandler_*::select_* operate on the start.next
field of select_stuff.
(pipeinf): Delete.
(select_pipe_info::select_pipe_info): New constructor.  Allocates event for
controlling pipe waits.
(select_pipe_info::~select_pipe_info): New destructor.  Destroy event.  Stop
thread.
(select_pipe_info::add_watch_handle): New function.
(thread_pipe): Wait for the hEvent part of any overlapped pipes before peeking.
(start_thread_pipe): Don't allocate device_specific_pipe stuff here.  Assume
that it has been allocated earlier.
(pipe_cleanup): Rely on select_pipe_info destructor to clean up pipe
paraphenalia.
(fhandler_*::select_*): Derive select_record from new select_stuff argument.
(fhandler_pipe::select_*): Ditto.  Allocate pipe-specific field if not already
allocated.
(serialinf): Delete.
(thread_serial): serialinf -> select_serial_info.
(fhandler_base::ready_for_read): Rewrite to accommodate change in argument to
fhandler_*::select_*.
(socketinf): Delete.
(thread_socket): socketinf -> select_socket_info.
(mailslotinf): Delete.
(thread_mailslot): mailslotinf -> select_mailslot_info.
@
text
@d449 9
@


1.367
log
@* fhandler.cc (fhandler_base::has_ongoing_io): Accept an argument indicating
whether the overlapped event should be tested.
(fhandler_base::read_overlapped): Pass is_overlapped state to has_ongoing_io.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::has_ongoing_io): Accommodate argument change.
* select.cc (peek_pipe): Ditto.
@
text
@d40 1
d358 3
a360 3
  virtual select_record *select_read (select_record *s);
  virtual select_record *select_write (select_record *s);
  virtual select_record *select_except (select_record *s);
d398 1
a398 1
  select_record *select_read (select_record *s);
d511 3
a513 3
  select_record *select_read (select_record *s);
  select_record *select_write (select_record *s);
  select_record *select_except (select_record *s);
d547 3
a549 3
  select_record *select_read (select_record *s);
  select_record *select_write (select_record *s);
  select_record *select_except (select_record *s);
d588 3
a590 3
  select_record *select_read (select_record *s);
  select_record *select_write (select_record *s);
  select_record *select_except (select_record *s);
d788 3
a790 3
  select_record *select_read (select_record *s);
  select_record *select_write (select_record *s);
  select_record *select_except (select_record *s);
d968 3
a970 3
  select_record *select_read (select_record *s);
  select_record *select_write (select_record *s);
  select_record *select_except (select_record *s);
d1010 3
a1012 3
  select_record *select_read (select_record *s);
  select_record *select_write (select_record *s);
  select_record *select_except (select_record *s);
d1037 1
a1037 1
  select_record *select_read (select_record *s);
d1094 3
a1096 3
  select_record *select_read (select_record *s);
  select_record *select_write (select_record *s);
  select_record *select_except (select_record *s);
d1198 3
a1200 3
  select_record *select_read (select_record *s);
  select_record *select_write (select_record *s);
  select_record *select_except (select_record *s);
a1387 51

struct select_record
{
  int fd;
  HANDLE h;
  fhandler_base *fh;
  int thread_errno;
  bool windows_handle;
  bool read_ready, write_ready, except_ready;
  bool read_selected, write_selected, except_selected;
  bool except_on_write;
  int (*startup) (select_record *me, class select_stuff *stuff);
  int (*peek) (select_record *, bool);
  int (*verify) (select_record *me, fd_set *readfds, fd_set *writefds,
		 fd_set *exceptfds);
  void (*cleanup) (select_record *me, class select_stuff *stuff);
  struct select_record *next;
  void set_select_errno () {__seterrno (); thread_errno = errno;}
  int saw_error () {return thread_errno;}

  select_record (fhandler_base *in_fh = NULL) : fd (0), h (NULL),
		 fh (in_fh), thread_errno (0), windows_handle (false),
		 read_ready (false), write_ready (false), except_ready (false),
		 read_selected (false), write_selected (false),
		 except_selected (false), except_on_write (false),
		 startup (NULL), peek (NULL), verify (NULL), cleanup (NULL),
		 next (NULL) {}
};

class select_stuff
{
 public:
  ~select_stuff ();
  bool always_ready, windows_used;
  select_record start;
  void *device_specific_pipe;
  void *device_specific_socket;
  void *device_specific_serial;
  void *device_specific_mailslot;

  int test_and_set (int i, fd_set *readfds, fd_set *writefds,
		     fd_set *exceptfds);
  int poll (fd_set *readfds, fd_set *writefds, fd_set *exceptfds);
  int wait (fd_set *readfds, fd_set *writefds, fd_set *exceptfds, DWORD ms);
  void cleanup ();
  select_stuff (): always_ready (0), windows_used (0), start (0),
		   device_specific_pipe (0),
		   device_specific_socket (0),
		   device_specific_serial (0),
		   device_specific_mailslot (0) {}
};
@


1.366
log
@* fhandler.h (fhandler_base::has_ongoing_io): Declare new function.
* fhandler.cc (fhandler_base::has_ongoing_io): Define new function.
(fhandler_base::read_overlapped): Use has_ongoing_io to avoid writing when
handle has not completed last I/O.
(fhandler_base::write_overlapped): Ditto.
* select.cc (peek_pipe): Be more careful about accessing hEvent field from
get_overlapped().
@
text
@d305 1
a305 1
  virtual bool __stdcall has_ongoing_io () __attribute__ ((regparm (1)));
@


1.365
log
@* errno.cc (errmap): Add mapping for ERROR_IO_INCOMPLETE.
* fhandler.cc (fhandler_base::fcntl): Fix comment.
(fhandler_base::wait_overlapped): Accept an optional len parameter.  Use the
len parameter when WriteFile fails with ERROR_IO_PENDING.  Make debug output
less alarming.
(fhandler_base::write_overlapped): Pass len to wait_overlapped.
* fhandler.h (fhandler_base::wait_overlapped): Add an optional argument
denoting the number of characters intended to be written.
* fhandler_tty.cc (fhandler_pty_master::close): Don't close archetype handles
when cygwin is still initializing since the handles aren't actually opened at
that point.
@
text
@d305 1
@


1.364
log
@	* cygheap.cc (cygheap_init): Set Cygwin default locale values.
	* cygheap.h (struct cygheap_locale): New structure.
	(struct user_heap_info): Add cygheap_locale member locale.
	* dcrt0.cc (dll_crt0_1): Revert to calling _setlocale_r so that only
	the applications locale is reverted to "C".
	* environ.cc (environ_init): Remove unused got_lc variable.
	* fhandler.h (class dev_console): Remove now unsed locale variables.
	* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove
	setting dev_console's locale members.
	(dev_console::con_to_str): Use internal locale settings.  Default to
	__ascii_wctomb if charset is "ASCII".
	(fhandler_console::write_normal): Ditto.
	* strfuncs.cc (__ascii_wctomb): Drop declaration.
	(__db_wctomb): Use fixed value 2 instead of not
	necessarily matching MB_CUR_MAX.
	(__eucjp_wctomb): Use 3 instead of MB_CUR_MAX.
	(sys_cp_wcstombs): Remove special case for "C" locale.
	(sys_wcstombs): Implement here.  Use internal locale data stored on
	cygheap.
	(sys_cp_mbstowcs): Remove special case for "C" locale.
	(sys_mbstowcs): Implement here.  Use internal locale data stored on
	cygheap.
	* syscalls.cc (internal_setlocale): New function to set cygheap locale
	data and to reset CWD posix path.
	(setlocale): Just call internal_setlocale from here if necessary.
	* wchar.h (__ascii_wctomb): Declare.
	(sys_wcstombs): Don't define inline, just declare.
	(sys_mbstowcs): Ditto.
@
text
@d146 1
a146 1
  int wait_overlapped (bool, bool, DWORD *) __attribute__ ((regparm (3)));
@


1.363
log
@* fhandler.h (fhandler_console::MAX_WRITE_CHARS): Declare.
(fhandler_console::write_replacement_char): Declare as inline.
(fhandler_console::write_console): Declare new function.
* fhandler_console.cc (fhandler_console::MAX_WRITE_CHARS): Define.
(handler_console::write_console): Define.
(fhandler_console::write_replacement_char): Define as inline.
(fhandler_console::write_normal): Use write_console when writing buffers of
unknown length.
@
text
@a896 4
  mbtowc_p con_mbtowc;
  wctomb_p con_wctomb;
  char con_charset[ENCODING_LEN + 1];

@


1.362
log
@	* fhandler.h (class dev_console): Add members con_mbtowc, con_wctomb,
	and con_charset.
	(dev_console::str_to_con): Take mbtowc function pointer and charset
	as additional parameters.
	* fhandler_console.cc (fhandler_console::get_tty_stuff): Initialize
	aforementioned new members.  Explain why.
	(dev_console::con_to_str): Remove useless comment.  Call new
	sys_cp_wcstombs function rather than sys_wcstombs.
	(dev_console::str_to_con): Take mbtowc function pointer and charset
	as additional parameters.  Call sys_cp_mbstowcs accordingly.
	(fhandler_console::write_normal): Only initialize f_mbtowc and charset
	once.  Accommodate changed str_to_con.
	* strfuncs.cc (sys_cp_wcstombs): Renamed from sys_wcstombs.  Take
	wctomb function pointer and charset as parameters.  Use throughout.
	(sys_cp_mbstowcs): Take wctomb function pointer and charset as
	parameters instead of codepage.  Remove matching local variables and
	their initialization.
	* wchar.h (ENCODING_LEN): Define as in newlib.
	(__mbtowc): Use mbtowc_p typedef for declaration.
	(wctomb_f): New type.
	(wctomb_p): New type.
	(__wctomb): Declare.
	(__utf8_wctomb): Use wctomb_f typedef for declaration.
	(sys_cp_wcstombs): Move declaration from winsup.h here.
	(sys_wcstombs): Ditto.
	(sys_wcstombs_alloc): Ditto.
	(sys_cp_mbstowcs): Ditto.
	(sys_mbstowcs): Ditto.
	(sys_mbstowcs_alloc): Ditto.
	* winsup.h: Move declaration of sys_FOO functions to wchar.h.  Include
	wchar.h instead.
@
text
@d915 1
d935 2
a936 1
  void write_replacement_char ();
@


1.361
log
@* Makefile.in: Use all compile options when calculating magic values.
* shared_info.h (CURR_SHARED_MAGIC): Revert erroneous value.
* child_info.h (CURR_CHILD_INFO_MAGIC): Update.
* fhandler.h (acquire_output_mutex): Remove unneeded ';'.
(release_output_mutex): Ditto.
@
text
@d897 4
d903 1
a903 1
  DWORD str_to_con (PWCHAR d, const char *s, DWORD sz);
@


1.360
log
@	* fhandler.h (class fhandler_fifo): Rename read/write methods to
	raw_read/raw_write.
	* fhandler_fifo.cc: Ditto.
@
text
@d793 1
a793 1
  __acquire_output_mutex (__PRETTY_FUNCTION__, __LINE__, ms);
d796 1
a796 1
  __release_output_mutex (__PRETTY_FUNCTION__, __LINE__);
@


1.359
log
@	* ctype.cc (_CTYPE_DATA_0_127): Add _B class to TAB character.
	(__ctype_default): New character class array for default ASCII
	character set.
	(__ctype_iso): New array of character class array for ISO charsets.
	(__ctype_cp): Ditto for singlebyte Windows codepages.
	(tolower): Implement as distinct function to support any singlebyte
	charset.
	(toupper): Ditto.
	(__set_ctype): New function to copy singlebyte character classes
	corresponding to current charset to ctype_b array.
	Align copyright text to upstream.
	* dcrt0.cc (dll_crt0_1): Reset current locale to "C" per POSIX.
	* environ.cc (set_file_api_mode): Remove.
	(codepage_init): Remove.
	(parse_thing): Remove "codepage" setting.
	(environ_init): Set locale according to environment settings, or
	to current codepage, before converting environment to multibyte.
	* fhandler.h (fhandler_console::write_replacement_char): Drop argument.
	* fhandler_console.cc (dev_console::str_to_con): Call sys_cp_mbstowcs
	rather than MultiByteToWideChar.
	(fhandler_console::write_replacement_char): Always print a funny
	half filled square if a character isn't in the current charset.
	(fhandler_console::write_normal): Convert to using __mbtowc
	rather than next_char.
	* fork.cc (frok::child): Drop call to set_file_api_mode.
	* globals.cc (enum codepage_type) Remove.
	(current_codepage): Remove.
	* miscfuncs.cc (cygwin_wcslwr): Unused, dangerous.  Remove.
	(cygwin_wcsupr): Ditto.
	(is_cp_multibyte): Remove.
	(next_char): Remove.
	* miscfuncs.h (is_cp_multibyte): Drop declaration.
	(next_char): Ditto.
	* strfuncs.cc (get_cp): Remove.
	(__db_wctomb): New function to implement _wctomb_r functionality for
	doublebyte charsets using WideCharToMultiByte.
	(__sjis_wctomb): New function to replace unusable newlib function.
	(__jis_wctomb): Ditto.
	(__eucjp_wctomb): Ditto.
	(__gbk_wctomb): New function.
	(__kr_wctomb): Ditto.
	(__big5_wctomb): Ditto.
	(__db_mbtowc): New function to implement _mbtowc_r functionality for
	doublebyte charsets using MultiByteToWideChar.
	(__sjis_mbtowc): New function to replace unusable newlib function.
	(__jis_mbtowc): Ditto.
	(__eucjp_mbtowc): Ditto.
	(__gbk_mbtowc): New function.
	(__kr_mbtowc): New function
	(__big5_mbtowc): New function
	(__set_charset_from_codepage): New function.
	(sys_wcstombs): Reimplement, basically using same wide char to multibyte
	conversion as newlib's application level functions.  Plus extras.
	Add lengthy comment to explain.  Change return type to size_t.
	(sys_wcstombs_alloc): Just use sys_wcstombs.  Change return type to
	size_t.
	(sys_cp_mbstowcs): Replace sys_mbstowcs, take additional codepage
	argument.  Explain why.  Change return type to size_t.
	(sys_mbstowcs_alloc): Just use sys_mbstowcs.  Change return type to
	size_t.
	* wchar.h: Declare internal functions implemented in strfuncs.cc.
	(wcscasecmp): Remove.
	(wcsncasecmp): Remove.
	(wcslwr): Remove.
	(wcsupr): Remove.
	* winsup.h (codepage_init): Remove declaration.
	(get_cp): Ditto.
	(sys_wcstombs): Align declaration to new implementation.
	(sys_wcstombs_alloc): Ditto.
	(sys_cp_mbstowcs): Add declaration.
	(sys_mbstowcs): Define as inline function.
	(sys_mbstowcs_alloc): Align declaration to new implementation.
	(set_file_api_mode): Remove declaration.
	* include/ctype.h (isblank): Redefine to use _B character class.
	(toupper): Remove ASCII-only definition.
	(tolower): Ditto.
@
text
@d579 2
a580 2
  void __stdcall read (void *, size_t&) __attribute__ ((regparm (3)));
  int write (const void *, size_t);
@


1.358
log
@	* fhandler.h (fhandler_socket::wait_for_events): Take additional
	parameter "dontwait".
	* fhandler_socket.cc (fhandler_socket::wait_for_events): Act as if the
	socket is non-blocking if dontwait is true.
	(fhandler_socket::recv_internal): Use incoming MSG_DONTWAIT flag to
	set the wait_for_events dontwait parameter.
	(fhandler_socket::send_internal): Ditto.  Optimize code slightly.
	* include/cygwin/socket.h (MSG_DONTWAIT): Define.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d930 1
a930 1
  void write_replacement_char (const unsigned char *);
@


1.357
log
@* dtable.cc (dtable::select_read): Add ability to override fh.
* fhandler.h (fhandler_fifo::select_read): Declare new function.
(fhandler_fifo::select_write): Ditto.
(fhandler_fifo::select_except): Ditto.
* select.cc (peek_pipe): Treat certain classes of pipe errors as "no data".
(fhandler_fifo::select_read): Define new function.
(fhandler_fifo::select_write): Ditto.
(fhandler_fifo::select_except): Ditto.
* shared_info.h (CURR_SHARED_MAGIC): Update.
@
text
@d423 1
a423 1
  int wait_for_events (const long event_mask);
@


1.356
log
@	* fhandler_procnet.cc: Reorganize global procnet content data into a
	new struct virt_tab_t.  Accommodate throughout.

	* fhandler.h: Fix copyright dates.
	* fhandler_process.cc: Ditto.
	* fhandler_registry.cc: Ditto.
@
text
@d561 1
d586 3
@


1.355
log
@	* devices.h (FH_PROCESSFD): New device type.
	* dtable.cc (build_fh_pc): Add case for FH_PROCESSFD.
	* fhandler.h (class fhandler_virtual): Drop bufalloc member.
	* fhandler_virtual.h: New header.
	* fhandler_proc.cc: Remove types proc_type_t and proc_tab_t in favor
	of types virt_type_t and virt_tab_t from fhandler_virtual.h.
	Change prototypes of format_XXX functions accordingly.
	(proc_tab): Drop size member info.
	(fhandler_proc::fill_filebuf): Don't allocate filebuf here.  Allocate
	it in the format_XXX functions.
	* fhandler_process.cc: Reorganize global process content data into a
	new struct virt_tab_t.  Accommodate throughout.
	(format_process_winexename): New function.
	(format_process_winpid): New function.
	(format_process_exename): New function.
	(format_process_root): New function.
	(format_process_cwd): New function.
	(format_process_cmdline): New function.
	(format_process_ppid): New function.
	(format_process_uid): New function.
	(format_process_pgid): New function.
	(format_process_sid): New function.
	(format_process_gid): New function.
	(format_process_ctty): New function.
	(format_process_fd): New function.
	* fhandler_procnet.cc (fhandler_procnet::fill_filebuf): Don't use
	bufalloc.
	* fhandler_registry.cc (fhandler_registry::fill_filebuf): Define
	bufalloc locally.
	* fhandler_virtual.cc (fhandler_virtual::fhandler_virtual): Drop
	initialization of bufalloc.
	(fhandler_virtual::dup): Drop copying bufalloc.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
@


1.354
log
@	* autoload.cc (WSAIoctl): Reintroduce.
	(WSASendMsg): Define.
	* fhandler.h (class fhandler_socket): Change definition of recv_internal
	and send_internal to take WSAMSG pointer as parameter.
	* fhandler_socket.cc (WSAID_WSARECVMSG): Define.
	(LPFN_WSARECVMSG): Define.
	(WSASendMsg): Declare.
	(get_ext_funcptr): New function to fetch address of WSARecvMsg.
	(fhandler_socket::recv_internal): Take just a LPWSAMSG parameter.
	Change code accordingly.  If control information is requested,
	fetch address of WSARecvMsg and use that instead of WSARecvFrom.
	(fhandler_socket::recvfrom): Change return type to ssize_t as
	declared in fhandler.h.  Accommodate changes to recv_internal.
	(fhandler_socket::recvmsg): Ditto.  Make sure that control information
	is only requested if system, address family, and socket type support it.
	(fhandler_socket::send_internal): Take just a LPWSAMSG parameter
	and the flags.  Change code accordingly.  If control information is
	provided, use WSASendMsg instead of WSASendTo.
	(fhandler_socket::sendto): Drop useless comment.  Accommodate changes
	to send_internal.
	(fhandler_socket::sendmsg): Ditto.  Make sure that control information
	is only provided if system, address family, and socket type support it.
	* wincap.h (wincaps::has_recvmsg): New element.
	(wincaps::has_sendmsg): New element
	* wincap.cc: Implement above elements throughout.
	* include/cygwin/socket.h (CMSG_ALIGN): Phrase in terms of alignment
	of type struct cmsghdr.
@
text
@a1229 1
  size_t bufalloc;
@


1.353
log
@* fhandler.h (fhandler_base_setup_overlapped): Add new argument.
(fhandler_base::get_overlapped_buffer): Declare new function.
(fhandler_base::set_overlapped): Ditto.
(fhandler_pipe::overlapped): New variable.
(fhandler_pipe::get_overlapped): Rework to return contents of overlapped
variable.
(fhandler_pipe::set_overlapped): Set overlapped variable based on argument.
(fhandler_fifo::get_overlapped_buffer): Return pointer to io_status.
* fhandler.cc (handler_base::setup_overlapped): Set to overlapped pointer to
NULL if new doit parameter is false.  Otherwise set up overlapped event as
usual.
(fhandler_base::wait_overlapped): Return inres if this isn't an overlapped
operation.
(fhandler_base::read_overlapped): Remove inappropriate asserts.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero overlapped element.
(struct pipesync): Delete.
(getov_result): Ditto.
(pipe_handler): Ditto.
(pipesync::pipesync): Ditto.
(fhandler_pipe::init): Don't set up pipesync thread.  Just pass opened_properly
flag along to overlapped setup.
@
text
@d486 1
a486 3
  inline ssize_t recv_internal (struct _WSABUF *wsabuf, DWORD wsacnt,
  				DWORD flags,
				struct sockaddr *from, int *fromlen);
d492 1
a492 2
  inline ssize_t send_internal (struct _WSABUF *wsabuf, DWORD wsacnt, int flags,
				const struct sockaddr *to, int tolen);
@


1.352
log
@	* fhandler.h (class fhandler_registry): Declare dup method.
	* fhandler_registry.cc (fhandler_registry::exists): Fix missing
	parenthesis.
	(fhandler_registry::dup): New method.
@
text
@d147 1
a147 1
  bool setup_overlapped () __attribute__ ((regparm (1)));
d347 2
d537 1
d540 5
a544 1
  OVERLAPPED *get_overlapped () {return &io_status;}
d587 1
@


1.351
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d1302 1
@


1.350
log
@* fhandler.h (fhandler_pipe::raw_read): Remove __stdcall decoration.
* pipe.cc (fhandler_pipe::raw_read): Ditto.
@
text
@d397 1
a397 1
struct wsa_event 
d403 1
a403 1
};  
@


1.349
log
@	* fhandler.h (class fhandler_pipe): Rename read and write
	declarations to raw_read and raw_write.
	* pipe.cc (fhandler_pipe::raw_read): Rename from read.
	(fhandler_pipe::raw_write): Rename from write.
@
text
@d545 1
a545 1
  void __stdcall raw_read (void *ptr, size_t& len);
@


1.348
log
@* fhandler.cc (fhandler_base::wait_overlapped): Always assume that bytes will
be non-NULL.  Distinguish input result from result derived from WFMO and
GetOverlappedResult or res can never be -1.  Only raise SIGPIPE when writing.
* fhandler.h (fhandler_base::wait_overlapped): Pass first argument by value.
* fhandler_fifo.cc (fhandler_fifo::wait): Pass in dummy byte count to
wait_overlapped.
* pipe.cc (DEFAULT_PIPEBUFSIZE): Define to 65536 explicitly.
@
text
@d545 2
a546 2
  void __stdcall read (void *ptr, size_t& len) __attribute__ ((regparm (3)));
  int write (const void *, size_t);
@


1.347
log
@	* fhandler.h (set_console_state_for_spawn): Drop declaration.
	* fhandler_console.cc (set_console_state_for_spawn): Remove.
	(fhandler_console::open): Set console state last.  Don't set
	ENABLE_PROCESSED_INPUT flag.
	* spawn.cc (spawn_guts): Drop call to set_console_state_for_spawn.
@
text
@d146 1
a146 1
  int wait_overlapped (bool&, bool, DWORD *) __attribute__ ((regparm (3)));
@


1.346
log
@	* fhandler.h (dirent_states): Add dirent_nfs_d_ino state and add it to
	dirent_info_mask.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set
	dirent_nfs_d_ino flag for NFS shares.  Explain why.
	(fhandler_disk_file::readdir): Use FileNamesInformation instead of
	FileBothDirectoryInformation info class on NFS clients not supporting
	the FileIdBothDirectoryInformation info class.  Use local pointers to
	accommodate different offsets.
	* path.cc (symlink_info::check): Don't test directories for symlinks
	on NFS shares.  Enhance comment.
@
text
@a1425 2

void __stdcall set_console_state_for_spawn (bool);
@


1.345
log
@	* Makefile.in (DLL_OFILES): Add nfs.o.
	* fhandler.cc (fhandler_base::open): Open files on NFS shares with
	correct access flags and EAs.
	* fhandler.h (fhandler_base::fstat_by_nfs_ea): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): New method.
	(fhandler_base::fstat_by_handle): Call fstat_by_nfs_ea for files on
	NFS shares.
	(fhandler_disk_file::fchmod): Use NFS specific method to set mode for
	files on NFS shares.  Don't overrule errno from call to
	set_file_attribute with errno from NtSetInformationFile call.
	(fhandler_disk_file::fchown): Add comment.
	* mount.cc (fillout_mntent): Accommodate change in second parameter
	to fs_info::update.
	* nfs.cc: New file.
	* nfs.h: New file.
	* path.cc (fs_info::update): Take handle instead of bool as second
	parameter.  Use that handle if it's not NULL.  Only close handle if
	it has been opened here.  Use static defined buffers instead of
	alloca'd buffers.
	(path_conv::check): Call symlink_info::check with reference to fs.
	Don't call fs.update here if file exists.
	(conv_path_list): Prefer tmp_pathbuf buffer over using alloca.
	(symlink_worker): Use NFS specific method to create symlinks on NFS
	shares.  Prefer tmp_pathbuf buffer over using alloca.
	(symlink_info::check_shortcut): Reopen file from incoming handle
	with necessary FILE_GENERIC_READ flag.  Prefer tmp_pathbuf buffer over
	using alloca.
	(symlink_info::check_sysfile): Ditto.
	(symlink_info::check_reparse_point): Use tmp_pathbuf buffer to
	allocate REPARSE_DATA_BUFFER.
	(symlink_info::check_nfs_symlink): New method.
	(enum symlink_t): Remove.
	(symlink_info::check): Don't use NtQueryAttributesFile.  Rather, open
	file with necessary access flags and call NtQueryInformationFile.  Fix
	error handling in case file can't be opened.  For existing files, call
	fs_info::update here.  Restructure symlink checking to accommodate the
	fact that the file is already open.  Add case for NFS symlinks.
	* path.h (fs_info::update): Take handle instead of bool as second
	parameter.
@
text
@d56 1
d59 1
a59 1
  dirent_info_mask	= 0x0038
@


1.344
log
@	* path.cc (path_conv::set_normalized_path): Drop strip_tail argument.
	Never strip trailing dots and spaces.
	* (path_conv::check): Accomodate above change.
	* path.h (path_conv::operator=): Ditto
	* dtable.cc (build_fh_dev): Ditto.
	* fhandler.h (fhandler_base::set_name): Ditto.

	* path.cc (transform_chars): Disable converting trailing dots and
	spaces.

	* path.cc (path_conv::check): Remove two disabled code snippets.
@
text
@d284 1
@


1.343
log
@	* dtable.cc (dtable::release): Drop fixup_before handling.
	(dtable::fixup_before_fork): Remove.
	(dtable::fixup_before_exec): Remove.
	* dtable.h (class dtable): Remove cnt_need_fixup_before member.
	(dtable::dtable): Accommodate above change.
	(dtable::dec_need_fixup_before): Remove.
	(dtable::inc_need_fixup_before): Remove.
	(dtable::need_fixup_before): Remove.
	(dtable::fixup_before_exec): Remove declaration.
	(dtable::fixup_before_fork): Ditto.
	* fhandler.h (fhandler_base::fixup_before_fork_exec): Remove.
	(fhandler_base::need_fixup_before): Remove.
	* fork.cc (frok::parent): Drop fixup_before handling.
	* spawn.cc (spawn_guts): Ditto.
@
text
@d156 1
a156 1
  virtual void set_name (const char *s) {pc.set_normalized_path (s, false);}
@


1.342
log
@	* cygwin.din (futimens): Export.
	(utimensat): Export.
	* fhandler.cc (fhandler_base::utimens): Replace fhandler_base::utimes.
	Call utimens_fs.
	* fhandler.h (class fhandler_base): Declare utimens_fs instead of
	utimes_fs, utimens instead of utimes.
	(class fhandler_disk_file): Declare utimens instead of utimes.
	* fhandler_disk_file.cc (fhandler_disk_file::utimens): Replace
	fhandler_disk_file::utimes.
	(fhandler_base::utimens_fs): Replace fhandler_base::utimes_fs.
	Implement tv_nsec handling according to SUSv4.
	* syscalls.cc (utimensat): New function.
	* times.cc (timespec_to_filetime): New function.
	(timeval_to_timespec): New function.
	(utimens_worker): Replace utimes_worker.
	(utimes): Convert timeval to timespec and call utimens_worker.
	(lutimes): Ditto.
	(futimens): Take over implementation from futimes.
	(futimes): Convert timeval to timespec and call futimens.
	* winsup.h (timespec_to_filetime): Declare.
	* include/cygwin/version.h: Bump API minor number.
	* posix.sgml: Add SUSv4 section.  Add futimens and utimensat to it.
@
text
@a220 1
  virtual void fixup_before_fork_exec (DWORD) {}
a264 1
  virtual bool need_fixup_before () const {return false;}
@


1.341
log
@	Revert thinko in previous patch.
	* fhandler.h (struct wsa_event): Move back from wsa_event.h to here.
	* fhandler_socket.cc (NUM_SOCKS): Ditto.
	(wsa_events): Move back from cygwin_shared to here.  Accommodate
	throughout.
	(socket_serial_number): Ditto.
	* shared_info.h: Accommodate above changes.
	* wsa_event.h: Remove.
@
text
@d289 1
a289 1
  int utimes_fs (const struct timeval *) __attribute__ ((regparm (2)));
d298 1
a298 1
  virtual int __stdcall utimes (const struct timeval *) __attribute__ ((regparm (2)));
d698 1
a698 1
  int __stdcall utimes (const struct timeval *) __attribute__ ((regparm (2)));
@


1.340
log
@	* fhandler.h (-struct wsa_event): Move to wsa_event.h.  Include
	wsa_event.h instead.
	* fhandler_socket.cc (NUM_SOCKS): Move to wsa_event.h.
	(wsa_events): Move from DLL shared area to cygwin_shared shared
	memory.  Accommodate throughout.
	(socket_serial_number): Ditto.
	* fhandler_tape.cc (mt): Ditto.
	(mtinfo_init): Remove.
	(mt): Define as cygwin_shared->mt.
	* flock.cc (FLOCK_PARENT_DIR_ACCESS): Remove.
	(FLOCK_INODE_DIR_ACCESS): Move up in file.
	(FLOCK_MUTANT_ACCESS): Ditto.
	(FLOCK_EVENT_ACCESS): Ditto.
	(get_lock_parent_dir): Remove.
	(inode_t::inode_t): Call get_shared_parent_dir to get parent dir handle.
	Add a "flock-" prefix to file's lock directory name for clarity.
	* mtinfo.h (mtinfo_init): Drop declaration.
	* net.cc (last_used_bindresvport): Move from DLL shared area to
	cygwin_shared shared memory.
	(cygwin_bindresvport_sa): Accommodate above change.
	* sec_helper.cc (_everyone_sd): Move here from flock.cc.
	* security.h (SD_MIN_SIZE): Ditto.
	(everyone_sd): Ditto.
	* shared.cc (cygwin_shared_area): Remove.
	(cygwin_shared_h): New handle.
	(get_shared_parent_dir): New static function.
	(shared_name): Drop session_local argument.  Call get_shared_parent_dir
	here.  Add cygwin-shared subdir to object name.
	(offsets): Reinstantiate SH_CYGWIN_SHARED member.
	(open_shared): Revert change from 2007-03-29 for systems supporting
	SeCreateGlobalPrivilege.
	(shared_info::initialize): Call mtinfo's initialize here.
	(memory_init): Drop call to mtinfo_init.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add members for global socket and tape info
	sharing.
	(enum shared_locations): Reinstantiate SH_CYGWIN_SHARED.
	(get_shared_parent_dir): Declare.
	(shared_name): Drop session_local argument from declaration.
	* wsa_event.h: New file.  Move definitions of NUM_SOCKS and
	struct wsa_event here.
@
text
@d397 7
a403 1
#include "wsa_event.h"
@


1.339
log
@	* smallprint.cc (__small_vswprintf): Fix uninitialized usage of `w'.

	Revamp advisory file locking to avoid cross reference pointers as well
	as to allow BSD flock semantics.  More agressively delete unused nodes
	and sync objects.
	* fhandler.h (fhandler_base::ino): Rename from namehash.  Fix comment.
	(fhandler_base::node): Remove.
	(fhandler_base::unique_id): Add.
	(fhandler_base::del_my_locks): New method.
	(get_ino): Rename from get_namehash.  Change usage throughout Cygwin.
	(get_unique_id): New method.
	* fhandler.cc (fhandler_base::close): Call own del_my_locks method.
	Fix comment.
	(fhandler_base::fhandler_base): Accommodate new and changed members.
	(fhandler_base::fixup_after_fork): Call del_my_locks.
	(fhandler_base::fixup_after_exec): Ditto for files with close-on-exec
	flag set.
	* fhandler_disk_file.cc (get_ino_by_handle): Rename from
	readdir_get_ino_by_handle.  Accommodate throughout.
	(fhandler_base::open_fs): Fill ino with inode number if FS has good
	inodes.  Allocate a LUID and store in unique_id to recognize file
	descriptors referencing the same file object.
	* flock.cc: Drop flock TODO comments.  Use explicit types __dev32_t
	and __ino64_t instead of dev_t and ino_t.
	(LOCK_OBJ_NAME_LEN): Change to reflect longer lf_id length.
	(get_obj_handle_count): New method.
	(lockf_t::lf_id): Change type to long long.
	(inode_t::get_lock_obj_handle_count): Drop in favor of static function
	get_obj_handle_count.
	(inode_t::del_locks): Remove.
	(inode_t::get): Add create_if_missing flag argument.
	(inode_t::del_my_locks): Reimplement to handle POSIX and BSD flock
	locks.  Return if node can be deleted or not.
	(inode_t::~inode_t): Ditto.  Close handles to i_dir and i_mtx.
	(fixup_lockf_after_fork): Remove.
	(fhandler_base::del_my_locks): New method.
	(fixup_lockf_after_exec): Check if node can be deleted.
	(inode_t::get): Only create node if create_if_missing is set.  Lock
	the returned node here before unlocking the node list.
	(inode_t::get_all_locks_list): Accommodate new lf_id length.
	(inode_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.  Change return type to bool.  De-const.
	Set lf_obj instead of returning a handle.
	(lockf_t::del_lock_obj): Call SetEvent only if new incoming parameters
	allow it.  Explain how it's supposed to work.
	(fhandler_disk_file::lock): Only fetch file length in SEEK_END case.
	Use NtQueryInformationFile(FileStandardInformation) instead of
	calling fstat_by_handle.  Always unlock node before returning.
	Use fhandler's unique id to create lf_id for BSD flock locks.
	Rely on node lock from inode_t::get.  Call del_lock_obj on removed
	locks here to allow explicit unlocking.  Delete node if no lock exists
	on the file anymore.
	(lf_setlock): Get file handle as additional parameter.  Handle the fact
	that lf_getblock now always opens the attached event object.  Reactivate
	erroneously applied patch which deactivates setting thread priority.
	Additionally handle blocking on BSD flock locks.
	(lf_clearlock): Get file handle as additional parameter.
	(lf_getlock): Close event handle opened by lf_getblock.
	(lf_getblock): Open potentially blocking event object here and check
	its signal state if it's a BSD flock lock.
	(lf_wakelock): Get file handle as additional parameter.
	* fork.cc (frok::child): Drop call to fixup_lockf_after_fork.
	* ntdll.h (struct _EVENT_BASIC_INFORMATION): Define.
	(enum _EVENT_INFORMATION_CLASS): Define.
	(NtQueryEvent): Declare.

	* fhandler.h (fhandler_base::fs_flags): Remove.
	(fhandler_base::set_fs_flags): Remove.
	(fhandler_base::get_fs_flags): Remove.
	* fhandler.cc (fhandler_base::write): Check for sparse file using
	pc.fs_flags().
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.

	The return of the volume serial number in fs_info.
	* fhandler.h (get_dev): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call to
	NtQueryVolumeInformationFile(FileFsVolumeInformation).  Just use
	get_dev() method.
	* fhandler_fifo.cc (fhandler_fifo::open) Use device ID and inode number
	to generate fifo name.
	* path.h (fs_info::sernum): New member.
	(fs_info::serial_number): New method.
	(path_conv::fs_serial_number): New method.
	* path.cc (fs_info::update): Fetch volume serial number and store in
	sernum.
@
text
@d397 1
a397 7
struct wsa_event
{
  LONG serial_number;
  long events;
  int  connect_errorcode;
  pid_t owner;
};
@


1.338
log
@	* fhandler.cc (fhandler_base::dup): Drop setting flags in the parent.

	Implement advisory file locking.
	* cygheap.h (struct init_cygheap): Add inode_list member.
	* cygwin.din (lockf): Export.
	* dcrt0.cc (child_info_spawn::handle_spawn): Call
	fixup_lockf_after_exec.
	* dtable.h (class dtable): Add fhandler_disk_file as friend class.
	* fhandler.cc (fhandler_base::close): Call del_my_locks if node is set.
	(fhandler_base::fhandler_base): Initialize node to NULL.
	(fhandler_base::fixup_after_fork): Ditto.
	* fhandler.h (class fhandler_base): Add member node.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Delete.
	* flock.cc: Implement all advisory file locking here.
	(fhandler_disk_file::lock): Implement here.
	(flock): Call fcntl with F_FLOCK bit set.  Remove test main function.
	(lockf): New function.
	* fork.cc (frok::child): Call fixup_lockf_after_fork.
	* ntdll.h (DIRECTORY_ALL_ACCESS): Define.
	(struct _OBJECT_BASIC_INFORMATION): Define.
	(enum _EVENT_TYPE): Define.
	(NtCreateDirectoryObject): Declare.
	(NtCreateEvent): Declare.
	(NtCreateMutant): Declare.
	(NtOpenEvent): Declare.
	(NtOpenMutant): Declare.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d128 1
a128 1
  __ino64_t namehash;	/* hashed filename, used as inode num */
d140 3
a142 1
  inode_t *node;	/* Used for advisory file locking.  See flock.cc.  */
a143 1
  DWORD fs_flags;
a234 4
  void set_fs_flags (DWORD flags) { fs_flags = flags; }
  bool get_fs_flags (DWORD flagval = UINT32_MAX)
    { return (fs_flags & (flagval)); }

d255 3
a257 1
  __ino64_t get_namehash () { return namehash ?: namehash = hash_path_name (0, pc.get_nt_native_path ()); }
@


1.337
log
@* dtable.cc: Define various device-related string constants as wide character
constants.
(dtable::init_std_file_from_handle): Reorganize pipe handling to try to catch
special tty case.
(build_fh_name_worker): Declare for common use.
(build_fh_name): Define char version.
(build_fh_name): Define (currently unused) UNICODE_STRING version.
(decode_tty): Detect if pipe is actually a cygwin tty, returning the tty name
in the buffer.
(handle_to_fn): Reorganize to use wide characters.
* dtable.h (build_fh_name): Declare (currently unused) UNICODE_STRING version.
* fhandler_tty.cc (fhandler_pty_master::setup): Use
fhandler_pipe::create_selectable to create a pipe with a given name.
* pipe.cc (pipe_handler): Make returned handle inheritable.
(fhandler_pipe::create_selectable): Take an optional name.  Use a standard
cygwin introducer for the name.
* path.cc (path_conv::check): Make first argument const.
* path.h (path_conv::check): Ditto for declaration.
(path_conv::path_conv): Ditto for UNICODE_STRING version.
@
text
@d41 1
d140 2
@


1.336
log
@	* fhandler.h (class fhandler_console): Add write_buf as pointer to
	temporary buffer space.
	* fhandler_console.cc (CONVERT_LIMIT): Define as NT_MAX_PATH.  Add
	comment.
	(fhandler_console::write_normal): Use write_buf throughout.
	(fhandler_console::write): Use tmp_pathbuf to allocate write_buf.
@
text
@d554 1
a554 1
  static int create_selectable (LPSECURITY_ATTRIBUTES, HANDLE&, HANDLE&, DWORD);
@


1.335
log
@	* Makefile.in (DLL_OFILES): Add ntea.o.
	* cygwin.din (getxattr, listxattr, removexattr, setxattr, lgetxattr,
	llistxattr, lremovexattr, lsetxattr, fgetxattr, flistxattr,
	fremovexattr, fsetxattr): Export Linux extended attribute functions.
	Sort.
	* errno.cc (errmap): Add mappings for ERROR_EAS_DIDNT_FIT,
	ERROR_EAS_NOT_SUPPORTED, ERROR_EA_LIST_INCONSISTENT,
	ERROR_EA_TABLE_FULL, ERROR_FILE_CORRUPT, ERROR_INVALID_EA_NAME.
	* fhandler.h (class fhandler_base): Declare new fgetxattr and
	fsetxattr methods.
	(class fhandler_disk_file): Ditto.
	* fhandler.cc (fhandler_base::fgetxattr): New method.
	(fhandler_base::fsetxattr): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::fgetxattr): New method.
	(fhandler_disk_file::fsetxattr): New method.
	* ntdll.h (STATUS_EA_TOO_LARGE): Define.
	(STATUS_NONEXISTENT_EA_ENTRY): Define.
	(STATUS_NO_EAS_ON_FILE): Define.
	* ntea.cc (read_ea): Rewrite for long pathnames and for using with
	Linux extended attribute functions.
	(write_ea): Ditto.
	(getxattr_worker): New static function.
	(getxattr): New function.
	(lgetxattr): New function.
	(fgetxattr): New function.
	(listxattr): New function.
	(llistxattr): New function.
	(flistxattr): New function.
	(setxattr_worker): New static function.
	(setxattr): New function.
	(lsetxattr): New function.
	(fsetxattr): New function.
	(removexattr): New function.
	(lsetxattr): New function.
	(fsetxattr): New function.
	* security.h (read_ea): Change declaration according to above changes.
	(write_ea): Ditto.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d887 1
a887 1
  bool con_to_str (char *d, int dlen, WCHAR w);
d909 1
@


1.334
log
@	* fhandler.h (fhandler_console::trunc_buf): Add to use as cache for
	truncated multibyte characters on input.
	(fhandler_console::write_replacement_char): Declare new method.
	* fhandler_console.cc (CONVERT_LIMIT): Raise to 64K.
	(fhandler_console::fhandler_console): Initialize trunc_buf.
	(ERR): Define as independent value again.
	(fhandler_console::write_replacement_char): New method to print
	replacement chars.
	(fhandler_console::write_normal): Add handling for truncated multibyte
	sequences.  Call next_char instead of pathetic CharNextExA function.
	Don't change src, rather just work with found later on.
	* miscfuncs.cc (is_cp_multibyte): Move here from strfuncs.cc.
	Don't call Windows function, restrict to well-known ANSI/OEM codepages
	and UTF-8.
	(next_char): Call CharNextExA only for doublebyte codepages.
	Implement for UTF-8 here.
	* strfuncs.cc (is_cp_multibyte): Move to miscfuncs.cc.
	* winsup.h (next_char): Declare.
	* include/limits.h (MB_LEN_MAX): Set to maximum value of MB_CUR_MAX
	as defined by newlib for now.
@
text
@d291 2
d691 2
@


1.333
log
@	* autoload.cc (CharToOemA): Remove.
	(CharNextExA): Define.
	* environ.cc (codepage_init): Un-static.  Set active_codepage to
	active codepage.  Default to ansi regardless of buf pointer.
	* fhandler.h (dev_console::get_console_cp): New method.
	(dev_console::con_to_str): Change declaration according to new
	implementation.
	(dev_console::str_to_con): Ditto.
	* fhandler_console.cc (cp_convert): Remove.
	(dev_console::con_to_str): Redefine to take WCHAR as incoming console
	char.
	(dev_console::get_console_cp): Return correct codepage according to
	alternate_charset_active setting.
	(dev_console::str_to_con): Redefine to create WCHAR buffer for console
	output.
	(fhandler_console::read): Read console input as WCHARs.
	(base_chars): Fix typo in comment.
	(fhandler_console::char_command): Save and restore console output
	buffer using UNICODE functions.
	(fhandler_console::write_normal): Convert to write output in UNICODE.
	Use CharNextExA to recognize multibyte characters in input.  Workaround
	problem with UTF-8 and MultiByteToWideChar.  Simplify the loop for
	printing "normal" characters.
	* strfuncs.cc (active_codepage): New variable to store active codepage.
	(get_cp): Call codepage_init() if active_codepage is uninitialized.
	Just return active_codepage.
	(is_cp_multibyte): New function.
	* winsup.h (active_codepage): Declare.
	(codepage_init): Declare.
	(is_cp_multibyte): Declare.
@
text
@d899 7
d914 1
@


1.332
log
@	* fhandler.h: Update copyright.
	* include/limits.h: Ditto.
@
text
@d882 3
a884 2
  bool con_to_str (char *d, const char *s, DWORD sz);
  bool str_to_con (char *d, const char *s, DWORD sz);
@


1.331
log
@* fhandler.h (fhandler_base::is_tty): Make bool.
(fhandler_serial::is_tty): Ditto.
(fhandler_termios::is_tty): Ditto.
(fhandler_base::is_slow): Return bool value.
(fhandler_socket::is_slow): Ditto.
(fhandler_serial::is_slow): Ditto.
(fhandler_console::is_slow): Ditto.
(fhandler_tty_common::is_slow): Ditto.
(fhandler_tty_master::is_slow): Ditto.
(fhandler_dev_null::is_slow): Ditto.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
@


1.330
log
@	* fhandler.h (class fhandler_dev_random): Add dummy_offset member.
	* fhandler_random.cc (fhandler_dev_random::lseek): Fake seeking
	capability as on Linux.
@
text
@d332 1
a332 1
  virtual int is_tty () { return 0; }
d374 1
a374 1
  virtual bool is_slow () {return 0;}
d523 1
a523 1
  bool is_slow () {return 1;}
d762 1
a762 1
  int is_tty () { return 1; }
d774 1
a774 1
  bool is_slow () {return 1;}
d802 1
a802 1
  virtual int is_tty () { return 1; }
d949 1
a949 1
  bool is_slow () {return 1;}
d984 1
a984 1
  bool is_slow () {return 1;}
d1057 1
a1057 1
  bool is_slow () {return 1;}
d1172 1
a1172 1
  bool is_slow () {return 1;}
@


1.329
log
@* dtable.cc (POSIX_NAMED_PIPE): New define.
(POSIX_NAMED_PIPE_LEN): Ditto.
(dtable::add_archetype): Use crealloc_abort.
(dtable::init_std_file_from_handle): Specifically detect pipe stdin/stdout.
Pass name to build_fh_dev so that proper name is recorded.  Use binmode of fh
if it is set before using get_default_mode.  Set proper read/write access when
calling init().
(handle_to_fn): Handle pipes.
* fhandler.cc (fhandler_base::wait_overlapped): Add some debugging.
* fhandler.h (fhandler_base::set_name): Default to just setting the path_conv
name.
(fhandler_pipe::init): Declare.
* pipe.cc (struct pipesync): New struct.
(getov_result): New function.  Blocks and retrieves the result of an overlay
I/O operation.
(pipe_handler): New function.
(pipesync::pipesync): New function.  Initializer for pipesync struct.
(handler_pipe::init): Define.  Detects attempts to set up a "native" pipe
fhandler and creates a thread which accepts input from or output to the
non-cygwin pipe, creating a cygwin pipe wrapper around the non-cygwin pipe.
(fhandler_pipe::create): Add pipe-specific flags to call to init().
* exceptions.cc (ctrl_c_handler): Lock process while we determine what to do.
@
text
@d1093 1
@


1.328
log
@revert premature checkin
@
text
@d152 1
d550 1
@


1.327
log
@* dllfixdbg: Eliminate extra objcopy step.
@
text
@a151 1
  virtual void set_name (const char *s) {pc.set_normalized_path (s, false);}
a548 1
  void init (HANDLE, DWORD, mode_t);
@


1.326
log
@	* fhandler.h (fhandler_base::get_namehash): Use NT native path.
	* fhandler_disk_file.cc (readdir_get_ino): Ditto in call to
	hash_path_name.
@
text
@d152 1
d550 1
@


1.325
log
@	* fhandler.h (fhandler_base::pc): Make public.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Drop extern
	declaration of stat_suffixes.  Use NT native path in debug output.
	(fhandler_base::utimes_fs): Simplify closeit case.  Use close_fs
	to close newly opened file handle.
	(fhandler_base::open_fs): Use NT native path in debug output.
	* path.cc: Throughout drop extern declaration of stat_suffixes.
	* path.h (stat_suffixes): Declare.
	* sec_acl.cc (acl_worker): Drop extern declaration of stat_suffixes.
	* times.cc (utimes_worker): Take path_conv as parameter instead of
	single-byte pathnam, drop nofollow argument, accommodate throughout.
	Compare UNICODE paths when enumerating file descriptors.  Fix
	formatting.  Use NT native path in debug output.
@
text
@d254 1
a254 1
  __ino64_t get_namehash () { return namehash ?: namehash = hash_path_name (0, get_win32_name ()); }
@


1.324
log
@	* fhandler.h (fhandler_base::close_fs): Reintroduce (as inline function)
	for clearness.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Revert previous
	change.
	(fhandler_base::open_fs): Ditto.
	* fhandler_socket.cc (fhandler_socket::close): Ditto.
@
text
@a140 1
  path_conv pc;
d149 2
d254 1
a254 1
    __ino64_t get_namehash () { return namehash ?: namehash = hash_path_name (0, get_win32_name ()); }
@


1.323
log
@	* Makefile.in (DLL_OFILES): Remove delqueue.o.
	* delqueue.cc: Delete.
	* fhandler.h (fhandler_base::close_fs): Drop declaration.
	(fhandler_disk_file::close): Drop declaration.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Call close instead of
	close_fs.
	(fhandler_base::fstat_helper): Use open FH_UNIX handle in call to
	get_file_attribute.
	(fhandler_base::open_fs): Call close instead of get_file_attribute.
	(fhandler_disk_file::close): Remove.
	(fhandler_base::close_fs): Remove.
	* fhandler_socket.cc (fhandler_socket::close): Just call
	fhandler_base::close for FH_UNIX sockets.
	* shared.cc (user_shared_initialize): Drop call to
	user_shared->delqueue.init.
	* shared_info.h (CURR_USER_MAGIC): Change according to below change.
	(MAX_DELQUEUES_PENDING): Remove.
	(class delqueue_list): Remove.
	(class user_info): Remove delqueue.
	* syscalls.cc (close_all_files): Drop call to
	user_shared->delqueue.process_queue.
	(unlink): Drop delqueue handling.
@
text
@d267 1
@


1.322
log
@* cygtls.h (_cygtls::inside_kernel): Move function declaration into _cygtls
class.
* exceptions.cc (_cygtls::inside_kernel): Move function definition into _cygtls
class.
* fhandler.cc (fhandler_base::wait_overlapped): Make return tri-state to detect
when there is a EINTR situation.  Add a pointer to a length parameter.  Move
GetOverlappedResult into this function.
(fhandler_base::read_overlapped): Accommodate above changes and loop if we
receive a restartable signal.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::wait_overlapped): Reflect above changes.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
@
text
@a266 1
  int close_fs ();
a678 1
  int close ();
@


1.321
log
@	* fhandler.h (enum query_state): Drop redundant query_stat_control.
	* fhandler.cc (fhandler_base::open): Ditto.  Add READ_CONTROL to
	access and FILE_OPEN_FOR_BACKUP_INTENT to create_options when opening
	for writing.  Always set security attributes to avoid calling
	has_acls.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Don't try to
	open file twice.
@
text
@d142 1
a142 1
  bool wait_overlapped (bool&, bool) __attribute__ ((regparm (2)));
@


1.320
log
@	* dir.cc (readdir_worker): Drop dir parameter from call to
	readdir_get_ino.
	* fhandler.h (fhandler_disk_file::readdir_helper): Switch file name
	parameter to PUNICODE_STRING.
	* fhandler_disk_file.cc: Drop including ntdef.h.
	(class __DIR_mounts): Store mount points in UNICODE.  Additionally
	store cygdrive prefix in unicode here.  Change methods accordingly.
	(__DIR_mounts::eval_ino): Call new stat_worker instead of lstat64.
	(__DIR_mounts::~__DIR_mounts): New destructor to free UNICODE buffers.
	(path_conv::ndisk_links): Rewrite using native NT functions.
	(fhandler_base::fstat_by_handle): Use NAME_MAX instead of CYG_MAX_PATH.
	Always set pfvi->VolumeSerialNumber to non-0.  Remove last resort
	code.
	(fhandler_base::fstat_by_name): Rewrite using native NT functions.
	(fhandler_base::fstat_fs): Always call fstat_by_name if fstat_by_handle
	fails.
	(fhandler_base::fstat_helper): Rely on dwVolumeSerialNumber.
	(fhandler_disk_file::facl): Call fstat_by_name if fstat_by_handle fails.
	(DIR_BUF_SIZE): Define using NAME_MAX instead of CYG_MAX_PATH.
	(__DIR_cache): Remove __name.
	(d_dirname): Remove.
	(fhandler_disk_file::opendir): Drop pathname length check.
	Remove outdated comment.  Use get_name method instead of accessing
	pc.normalized_path directly.
	(readdir_get_ino): Drop unused dir parameter.  Accomodate throughout.
	Allocate fname dynamically.  Call new stat_worker instead of lstat64.
	Call NtOpenFile instead of CreateFile.  Call NtClose instead of
	CloseHandle.
	(fhandler_disk_file::readdir_helper): Use native NT functions.
	Check for volume mount points and use correct inode number.
	(fhandler_disk_file::readdir): Simplify slightly.
	Use get_name instead of pc.normalized_path.
	(fhandler_disk_file::rewinddir): Use RtlInitUnicodeString.
	(fhandler_cygdrive::fstat): Ignore floppy drives.  Set st_nlink
	correctly.
	(fhandler_cygdrive::readdir): Ignore floppy drives.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Accommodate
	change to readdir_get_ino.
	* fhandler_proc.cc (PROC_DIR_COUNT): Define.
	(fhandler_proc::fstat): Evaluate correct link count for /proc.
	* ntdll.h (struct _FILE_DIRECTORY_INFORMATION): Define.
	(NtFsControlFile): Declare.
	(RtlAppendUnicodeToString): Declare.
	(RtlAppendUnicodeStringToString): Declare.
	(RtlCompareUnicodeString): Declare.
	(RtlCopyUnicodeString): Declare.
	(RtlCreateUnicodeStringFromAsciiz): Declare.
	(RtlEqualUnicodeString): Declare.
	(RtlFreeUnicodeString): Declare.
	(RtlInitEmptyUnicodeString): Declare.
	(RtlSecondsSince1970ToTime): Declare.
	(RtlInitEmptyUnicodeString): Define as inline function.
	(RtlInitCountedUnicodeString): Define as inline function.
	* path.cc (path_conv::check): New method with PUNICODE_STRING as path,
	preliminary implementation.
	(mount_info::get_mounts_here): Change to create UNICODE_STRINGs.
	Also copy cygpath prefix into UNICODE_STRING.
	(is_floppy): Drop 9x consideration.
	* path.h: Drop including ntdef.h.
	(path_conv::check): Add declaration.
	(path_conv::path_conv): Add constructor for UNICODE_STRING paths.
	* shared_info.h (mount_info::get_mounts_here): Change declaration.
	* syscalls.cc: Drop forward declaration of stat_worker.
	(stat_worke): Take path_conv as parameter.  Drop nofollow flag.
	(stat64): Create matching path_conv and call stat_worker with it.
	(lstat64): Ditto.
	* winsup.h: Include ntdef.h.
	(stat_worker): Declare.
	(readdir_get_ino): Change declaration.
@
text
@d89 2
a90 3
  query_stat_control = 3,
  query_write_control = 4,
  query_write_attributes = 5
@


1.319
log
@* debug.cc (close_handle): Change debug output format slightly.
* dlfcn.cc (dlclose): Don't close handle returned from GetModuleHandle(NULL).
* fhandler.h (fhandler_pipe::create): Remove obsolete argument.
(fhandler_pipe::create): Ditto.
* fhandler.cc (fhandler_pipe::create): Ditto.
(fhandler_pipe::create): Ditto.
@
text
@d674 1
a674 1
  int readdir_helper (DIR *, dirent *, DWORD, DWORD, char *) __attribute__ ((regparm (3)));
@


1.318
log
@	* dir.cc (closedir): Revert change from 2007-06-29.
	* fhandler.h (dirent_valid_fd): Drop.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): If opening a
	real dir, use the underlying fhandler to keep track of the directory
	handle.  In fdopendir case use original io_handle from fhandler.  Use
	fhandler's io_handle in subsequent directory functions throughout.
	Create handle non-inheritable and set close-on-exec flag.
	(readdir_get_ino): Drop dirent_isroot case.
	(fhandler_disk_file::readdir): Handle dirent_isroot case here.
	(fhandler_disk_file::rewinddir): Revert change from 2007-07-05.  Use
	NtClose instead of CloseHandle.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Drop adding
	dirent_valid_fd flag.  Set close-on-exec flag.
@
text
@d549 2
a550 2
  static int create (fhandler_pipe *[2], unsigned, int, bool = false);
  static int create_selectable (LPSECURITY_ATTRIBUTES, HANDLE&, HANDLE&, DWORD, bool);
@


1.317
log
@* fhandler.h (fhandler_base::write): Remove __stdcall decoration.
(fhandler_pipe::write): Ditto.
(fhandler_fifo::write): Ditto.
@
text
@a54 1
  dirent_valid_fd	= 0x0040,
d57 1
a57 1
  dirent_info_mask	= 0x0078
@


1.316
log
@Preliminary change to make fifos/pipes interruptible and fifos reliable.
* dtable.cc (dtable::find_fifo): Eliminate definition.
* dtable.h (dtable::find_fifo): Ditto for declaration.
* fhandler.cc (fhandler_base::raw_read): Remove pipe-specific stuff.
(fhandler_base::fhandler_base): Ditto.
(fhandler_base::close): Handle overlapped I/O structure if appropriate.
(fhandler_base::dup): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::setup_overlapped): Define new function.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
* fhandler.h (fhandler_base::get_overlapped): Declare new function.
(fhandler_base::setup_overlapped): Ditto.
(fhandler_base::destroy_overlapped): Ditto.
(fhandler_base::wait_overlapped): Ditto.
(fhandler_base::read_overlapped): Ditto.
(fhandler_base::write_overlapped): Ditto.
(fhandler_base::get_guard): Eliminate.
(fhandler_pipe::*): Rework to eliminate most Win9x related cruft, removing many
variables and defining a new overlapped capability.
(fhandler_fifo::*): Ditto.
(fifo_state): Declare new enum.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Remove old Win9x stuff.
Initialize overlapped handle to NULL.
(fhandler_fifo::set_use): Eliminate.
(fhandler_fifo::open_nonserver): Define.
(fhandler_fifo::open): Rework to use named pipes and overlapped I/O.
(fhandler_fifo::wait): Define new function to wait for named pipe connection.
(fhandler_fifo::read): Rework to use wait() and new overlapped I/O
functionality.
(fhandler_fifo::write): Ditto.
(fhandler_fifo::dup): Eliminate.
* pinfo.cc (commune_process): Remove fifo handling.
(_pinfo::commune_request): Ditto.
* pinfo.h (picom): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Remove Win9x stuff.  Initialize
overlapped handle to NULL.
(fhandler_pipe::open): Eliminate Win9x stuff.
(fhandler_pipe::set_close_on_exec): Eliminate.
(read_pipe): Eliminate.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::fixup_after_exec): Ditto.
(fhandler_pipe::fixup_in_child): Ditto.
(fhandler_pipe::read): Rework to use overlapped I/O.
(fhandler_pipe::write): New function using overlapped I/O.
(fhandler_pipe::dup): Rework to eliminate Win9x stuff.
(fhandler_pipe::create_selectable): Rework to eliminate Win9x and use
overlapped I/O.
* select.cc (peek_pipe): Rework to eliminate Win9x stuff and use overlapped
I/O.
(fhandler_base::ready_for_read): Ditto.
@
text
@d301 1
a301 1
  virtual int __stdcall write (const void *ptr, size_t len);
d542 1
a542 1
  int __stdcall write (const void *, size_t);
d570 1
a570 1
  int __stdcall write (const void *, size_t);
@


1.315
log
@	* cygwin.din: Export fdopendir.
	* dir.cc (opendir): Call fhandler's opendir with fd set to -1.
	(fdopendir): New function.
	(seekdir64): Use dirent_info_mask.
	(rewinddir): Ditto.
	(closedir): Only release underlying file descriptor if it has been
	reserved by opendir itself.
	* fhandler.cc (fhandler_base::opendir): Accommodate new parameter.
	* fhandler.h (dirent_states): Add dirent_valid_fd and dirent_info_mask.
	(fhander_XXX::opendir): Add file descriptor parameter.  Use regparms.
	(fhandler_procnet::opendir): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
	If called from fdopendir, use existing handle to re-open directory
	with valid flags.  Rename fd to cfd.  Use only if no valid incoming fd.
	(fhandler_cygdrive::opendir): Accommodate new parameter.
	* fhandler_process.cc (fhandler_process::opendir): Ditto.
	* fhandler_procnet.cc (fhandler_procnet::opendir): Drop definition.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Accommodate new
	parameter.  Only create new file descriptor entry if called from
	opendir.  Remove duplicated setting of dir->__flags.
	* posix.sgml: Add fdopendir to list of implemented Solaris functions.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/dirent.h: Declare fdopendir.
@
text
@d144 3
d300 3
a302 1
  virtual int write (const void *ptr, size_t len);
d342 1
a364 1
  virtual HANDLE get_guard () const {return NULL;}
a379 1
  friend class fhandler_fifo;
a527 3
protected:
  HANDLE guard;
  bool broken_pipe;
d530 1
d533 1
a540 1
  void set_close_on_exec (bool val);
d542 1
a543 6
  int close ();
  void create_guard (SECURITY_ATTRIBUTES *sa)
  {
    guard = CreateMutex (sa, FALSE, NULL);
    ProtectHandleINH (guard);
  }
a548 6
  void fixup_in_child ();
  virtual void fixup_after_fork (HANDLE);
  void fixup_after_exec ();
  bool hit_eof () {return broken_pipe;}
  void set_eof () {broken_pipe = true;}
  HANDLE get_guard () const {return guard;}
a550 1
  bool is_slow () {return true;}
a551 1
  friend class fhandler_fifo;
d554 8
a561 1
class fhandler_fifo: public fhandler_pipe
d563 4
a566 4
  HANDLE output_handle;
  long read_use;
  long write_use;
  virtual HANDLE& get_io_handle () { return io_handle ?: output_handle; }
d569 3
a571 4
  int open (int flags, mode_t mode = 0);
  int open_not_mine (int flags) __attribute__ ((regparm (2)));
  int close ();
  void set_use (int flags) __attribute__ ((regparm (2)));
a572 4
  HANDLE& get_output_handle () { return output_handle; }
  void set_output_handle (HANDLE h) { output_handle = h; }
  void set_use ();
  int dup (fhandler_base *child);
d574 1
a574 2
  bool is_slow () {return true;}
  void close_one_end ();
@


1.314
log
@	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.
@
text
@d54 5
a58 1
  dirent_get_d_ino	= 0x0020
d363 1
a363 1
  virtual DIR *opendir ();
d712 1
a712 1
  DIR *opendir ();
d732 1
a732 1
  DIR *opendir ();
d1228 1
a1228 1
  virtual DIR *opendir ();
d1304 1
a1304 1
  DIR *opendir ();
a1316 1
  DIR *opendir ();
@


1.313
log
@	Add accidentally missing checkins.

	* fhandler.h (fhandler_base::fstat_helper): Add creation time parameter.
	* glob.cc (stat32_to_stat64): Set st_birthtim to st_mtim.
@
text
@a103 1
    unsigned append_mode        : 1; /* always append */
d116 1
a116 1
      uninterruptible_io (0), append_mode (0), did_lseek (0),
a192 1
  IMPLEMENT_STATUS_FLAG (bool, append_mode)
@


1.312
log
@	* fhandler.cc(fhandler_base::open): Open with READ_CONTROL only in
	case of query_open flag set to query_read_control.  Add case for
	new query_read_attributes flag.
	(fhandler_base::fstatvfs): New method.
	* fhandler.h (enum query_state): Add query_read_attributes flag.
	(class fhandler_base): Declare new virtual fstatvfs method.
	(class fhandler_socket): Ditto.
	(class fhandler_pipe): Ditto.
	(class fhandler_fifo): Ditto.
	(class fhandler_disk_file): Ditto.
	(class fhandler_virtual): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Open with
	query_read_attributes instead of query_read_control.
	(fhandler_disk_file::fstatvfs): New method.
	(fhandler_disk_file::facl): Open with query_read_attributes instead of
	query_read_control.
	* fhandler_fifo.cc (fhandler_fifo::fstatvfs): New method.
	* fhandler_socket.cc (fhandler_socket::fstatvfs): New method.
	(fhandler_socket::fchmod): Return with EBADF in the default case.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::fstatvfs): Ditto.
	* ntdll.h (struct _FILE_FS_ATTRIBUTE_INFORMATION): Define.
	(struct _FILE_FS_FULL_SIZE_INFORMATION): Define.
	* pipe.cc (fhandler_pipe::fstatvfs): New method.
	* syscalls.cc (fstatvfs): Just call the fhandler's fstatvfs.
	(statvfs): Ditto.
	(fstatfs): Call fstatvfs.
	(statfs): Drop EFAULT handling.
@
text
@d271 1
@


1.311
log
@	* fhandler.h (class fhandler_pipe): Remove members writepipe_exists,
	orig_pid and id.  Make hit_eof inline.
	* fhandler_fifo.cc (fhandler_fifo::open): Drop handling of
	writepipe_exists, orig_pid and id.
	* pipe.cc: Ditto throughout.
	(pipecount): Remove.
	(pipeid_fmt): Remove.
	(fhandler_pipe::hit_eof): Simplify.  Move to fhandler.h.
	(fhandler_pipe::dup): Drop leave label.
	(fhandler_pipe::create): Drop has_unreliable_pipes case.
	* wincap.cc: Remove has_unreliable_pipes throughout.
	* wincap.h: Ditto.
@
text
@d85 4
a88 3
  query_stat_control = 2,
  query_write_control = 3,
  query_write_attributes = 4
d280 1
d511 1
d546 1
d579 1
d700 1
d1237 1
@


1.310
log
@	* devices.in: Change native device name to native NT device name for
	/dev/null, /dev/comX and /dev/ttySx.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::open_9x): Remove.
	(fhandler_base::open): Don't test for DOS device name, don't call
	open_9x.
	(fhandler_dev_null::open): Remove.
	* fhandler.h (class fhandler_base): Drop open_9x declaration.
	(class fhandler_dev_null): Drop open declaration.
@
text
@a520 3
  HANDLE writepipe_exists;
  DWORD orig_pid;
  unsigned id;
d548 1
a548 1
  bool hit_eof ();
@


1.309
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@a259 1
  int open_9x (int, mode_t = 0);
a1067 1
  int open (int, mode_t);
@


1.308
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procnet.o.
	* autoload.cc (GetAdaptersAddresses): Define.
	* devices.h (FH_PROCNET): Define new device.
	* devices.in (dev_procnet_storage): Add "/proc/net" entry.
	* devices.cc: Regenerate.
	* dir.cc (readdir_worker): Use isproc_dev macro.
	* dtable.cc (build_fh_pc): Add FH_PROCNET.
	* fhandler.h (class fhandler_procnet): New class.
	* fhandler_proc.cc: Add "net" subdirectory handling.
	* fhandler_procnet.cc: New file handling "/proc/net" directory.
	* path.cc (isvirtual_dev): Move to path.h.
	* path.h (isproc_dev): New macro to identify /proc files by device.
	(isvirtual_dev): Moved here.  Define using isproc_dev.
	* syscalls.cc (unlink): Use isproc_dev macro.
	* wincap.h (wincapc::has_gaa_prefixes): New element.
	(wincapc::has_gaa_on_link_prefix): New element.
	* wincap.cc: Implement above elements throughout.
	(wincapc::init): Check XP for service pack and set has_gaa_prefixes
	appropriately.
	* include/cygwin/in6.h: Include asm/byteorder.h.
@
text
@a111 1
    unsigned has_changed	: 1; /* Flag used to set ctime on close. */
d117 1
a117 2
      query_open (no_query), close_on_exec (0), need_fork_fixup (0),
      has_changed (0)
a197 1
  IMPLEMENT_STATUS_FLAG (bool, has_changed)
a680 1
  void touch_ctime ();
a681 1
  int readdir_9x (DIR *, dirent *) __attribute__ ((regparm (3)));
@


1.307
log
@	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.
@
text
@d1311 13
@


1.306
log
@* child_info.h (child_info_spawn::__stdin): New element.
(child_info_spawn::__stdin): Ditto.
(CURR_CHILD_INFO_MAGIC): Regenerate.
* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
(child_info_spawn::handle_spawn): Handle new __std* elements by calling
move_fd.
* dtable.cc (dtable::move_fd): Define new function.
* dtable.h (dtable::move_fd): Declare new function.
* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
(fhandler_pipe::dup): Ditto.
* spawn.cc (handle): Change second argument to bool.
(spawn_guts): Accept __stdin/__stdout arguments and set them appropriately in
child_info structure and in STARTUPINFO structure.
* syscalls.cc (popen): New cygwin-specific implementation using spawn.
(pclose): Ditto.
* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.
* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.
* child_info.h (child_info::msv_count): Rename from the now-inappropriate
"zero".
(child_info_spawn::filler): Add filler to work around Vista bug.
(child_info_fork::filler): Ditto.
* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is now
always filled out.
* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
* sigproc.cc (child_info::child_info): Initialize starter[].
* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
d28 5
@


1.305
log
@	* fhandler.cc (check_posix_perm): Moved here from syscalls.cc.
	(fhandler_base::fpathconf): New method implementing (f)pathconf.
	* fhandler.h (class fhandler_base): Declare fpathconf method.
	* path.cc (path_conv::check): Replace MAX_LINK_DEPTH with SYMLOOP_MAX.
	* path.h (MAX_LINK_DEPTH): Delete.
	* syscalls.cc (check_posix_perm): Move to fhandler.cc.
	(fpathconf): Call fhandler's fpathconf method.
	(pathconf): Build fhandler and call fhandler's fpathconf method.
	* sysconf.cc (sysconf): Reorder switch according to order of flags
	in sys/unistd.h.  Add handling for some missing flags.
	* include/limits.h: Reorder according to SUSv3 description.  Add some
	missing definitions.  Add comments.
	* include/sys/syslimits.h: New file overriding newlib's syslimits.h
	file.
@
text
@d170 1
a170 1
  void set_nonblocking (int yes);
d252 1
a252 1
  virtual void set_no_inheritance (HANDLE &h, int not_inheriting);
d255 1
a255 1
  bool fork_fixup (HANDLE parent, HANDLE &h, const char *name);
d258 3
a260 3
  int open_9x (int flags, mode_t mode = 0);
  virtual int open (int flags, mode_t mode = 0);
  int open_fs (int flags, mode_t mode = 0);
d523 2
d527 2
@


1.304
log
@	* fhandler.h (fhandler_base::set_name): Make virtual.
	(class fhandler_registry): Add wow64 and prefix_len members.
	Declare set_name method.
	* fhandler_proc.cc (PROC_REGISTRY32): Define.
	(PROC_REGISTRY64): Define.
	(proc_listing): Add "registry32" and "registry64" elements.
	(proc_fhandlers): Add corresponding FH_REGISTRY values.
	* fhandler_registry.cc (registry_len): Drop static value in favor of
	class member prefix_len.  Use preifx_len instead of registry_len
	throughout.
	(fhandler_registry::set_name): Define.  Set wow64 and prefix_len
	according to directory prefix.
	(fhandler_registry::fhandler_registry): Set wow64 and prefix_len to
	default values.
	(open_key): Add wow64 argument.  Handle wow64 in call to RegOpenKeyEx.
	Use fhandler_registry member wow64 in this place throughout.
@
text
@d299 1
@


1.303
log
@	* autoload.cc (NtSetInformationFile): Define.
	* cygwin.din: Export posix_fadvise and posix_fallocate.
	* fhandler.cc (fhandler_base::fadvise): New method.
	(fhandler_base::ftruncate): Add allow_truncate parameter.
	* fhandler.h (class fhandler_base): Add fadvise method.  Accomodate
	new parameter to ftruncate.
	(class fhandler_pipe): Add fadvise and ftruncate methods.
	(class fhandler_disk_file): Add fadvise method.  Accomodate new
	parameter to ftruncate.
	* fhandler_disk_file.cc (fhandler_disk_file::fadvise): New method.
	(fhandler_disk_file::ftruncate): Accomodate new allow_truncate
	parameter.  Set EOF using NtSetInformationFile on NT.
	* ntdll.h (struct _FILE_END_OF_FILE_INFORMATION): Define.
	(NtSetInformationFile): Declare.
	* pipe.cc (fhandler_pipe::fadvise): New method.
	(fhandler_pipe::ftruncate): Ditto.
	* syscalls.cc (posix_fadvise): New function.
	(posix_fallocate): Ditto.
	(ftruncate64): Accomodate second parameter to fhandler's ftruncate
	method.
	* include/fcntl.h: Add POSIX_FADV_* flags.  Add declarations of
	posix_fadvise and posix_fallocate.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d142 1
a142 1
  void set_name (path_conv &pc);
d1269 2
d1273 1
@


1.302
log
@	* fhandler.h (struct wsa_event): Define here.
	(class fhandler_socket): Make wsock_evt private again.
	(fhandler_socket::wsock_event): New read accessor for wsock_evt.
	(fhandler_socket::serial_number): New read accessor to get the
	socket's serial number.
	(fhandler_socket::ready_for_read): Just return true.
	* fhandler_socket.cc (struct wsa_event): Move definition to fhandler.h.
	* select.cc (struct socketinf): Add serial number vector.
	(start_thread_socket): Identify duplicate sockets by their serial
	number, not (wrongly) by their wsock_evt.
@
text
@d282 2
a283 1
  virtual int __stdcall ftruncate (_off64_t) __attribute__ ((regparm (2)));
d540 2
d690 2
a691 1
  int __stdcall ftruncate (_off64_t) __attribute__ ((regparm (2)));
@


1.301
log
@	* fhandler_socket.cc (fhandler_socket::recvmsg): Remove unused tot
	argument.  All callers changed.
	(fhandler_socket::sendmsg): Likewise.
	* net.cc (cygwin_recvmsg): Likewise.
	(cygwin_sendmsg): Likewise, and prevent calling sendmsg whith an
	invalid iovec.
	* fhandler.h (fhandler_socket::recvmsg): Adjust prototype.
	(fhandler_socket::sendmsg): Likewise.
@
text
@d381 7
a387 1
struct wsa_event;
d398 1
a399 1
  HANDLE wsock_evt;
d401 3
a403 1
  int evaluate_events (const long event_mask, long &events, bool erase);
d497 1
@


1.300
log
@	* fhandler.h (class fhandler_socket): Remove prot_info_ptr.
	(fhandler_socket::fixup_before_fork_exec): Remove.
	(fhandler_socket::fixup_after_exec): Remove.
	(fhandler_socket::need_fixup_before): Remove.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Drop
	initializing prot_info_ptr.  Remove unused code.
	(fhandler_socket::~fhandler_socket): Drop free'ing prot_info_ptr.
	(struct wsa_event): Rename connect_errorcode to errorcode.
	(fhandler_socket::evaluate_events): Handle FD_CLOSE error condition
	as FD_CONNECT error condition, except, never reset an FD_CLOSE error
	condition.  Always set FD_WRITE after successfully recorded FD_CONNECT.
	(fhandler_socket::fixup_before_fork_exec): Remove.
	(fhandler_socket::fixup_after_fork): Revert to using handle duplication.
	(fhandler_socket::fixup_after_exec): Remove.
	(fhandler_socket::dup): Revert to using handle duplication.
	(fhandler_socket::send_internal): Only call wait_for_events in case
	of WSAEWOULDBLOCK condition.
	(fhandler_socket::set_close_on_exec): Call
	fhandler_base::set_close_on_exec.
	* net.cc (fdsock): Just set socket to inheritable on non-NT.  Don't
	call inc_need_fixup_before.
	* select.cc (peek_socket): Don't set except_ready on every FD_CLOSE,
	just on error.
@
text
@d465 1
a465 1
  ssize_t recvmsg (struct msghdr *msg, int flags, ssize_t tot = -1);
d472 1
a472 1
  ssize_t sendmsg (const struct msghdr *msg, int flags, ssize_t tot = -1);
@


1.299
log
@2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h: Bump DLL version to 1.7.0.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.

2006-07-18  Brian Ford  <Brian.Ford@@FlightSafety.com>
	    Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.

2006-07-18  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din (posix_openpt): Export.
	* tty.cc (posix_openpt): New function.
	* include/cygwin/stdlib.h (posix_openpt): Declare.
	* include/cygwin/version.h: Bump API minor number.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netinet/in.h: Update copyright.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netdb.h: Declare rcmd, rcmd_af, rexec, rresvport,
	rresvport_af, iruserok, iruserok_sa, ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.

2006-07-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.

2006-07-10  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.

2006-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/in6.h (struct in6_addr): Fix typo.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@a420 1
  struct _WSAPROTOCOL_INFOA *prot_info_ptr;
a482 1
  virtual void fixup_before_fork_exec (DWORD);
a483 2
  void fixup_after_exec ();
  bool need_fixup_before () const {return true;}
@


1.298
log
@GCC 4.1 fixes.
* cygheap.h (cygheap_user): Remove unneeded class names from function
declaration.
* fhandler.h (fhandler_base): Ditto.
(fhandler_dev_floppy): Ditto.
(fhandler_console): Ditto.
* wininfo.h (wininfo): Ditto.
* exceptions.cc (sigpacket::process): Avoid compiler errors about gotos and
initialization.
* fhandler_fifo.cc (fhandler_fifo::open): Ditto.
* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Ditto.
* mmap.cc (mmap64): Ditto.
* pipe.cc (fhandler_pipe::open): Ditto.
* spawn.cc (spawn_guts): Ditto.
* sec_helper.cc: Fix some comments.
(get_null_sd): Move file-scope static to only function where it is used.
@
text
@d381 2
d390 10
d429 1
a429 2
    unsigned closed		   : 1;
    unsigned owner		   : 1;
d434 1
a434 1
      closed (0), owner (0), connect_state (unconnected)
a437 4
  bool prepare (HANDLE &event, long event_mask);
  int wait (HANDLE event, int flags, DWORD timeout = 10);
  void release (HANDLE event);

d448 1
a448 2
  IMPLEMENT_STATUS_FLAG (bool, closed)
  IMPLEMENT_STATUS_FLAG (bool, owner)
d461 6
a466 3
  int recvfrom (void *ptr, size_t len, int flags,
		struct sockaddr *from, int *fromlen);
  int recvmsg (struct msghdr *msg, int flags, ssize_t tot = -1);
d469 3
a471 1
  int sendto (const void *ptr, size_t len, int flags,
d473 1
a473 1
  int sendmsg (const struct msghdr *msg, int flags, ssize_t tot = -1);
@


1.298.2.1
log
@2007-01-13  Christopher Faylor  <me@@cgf.cx>

	* glob.cc: Update copyright notice with latest from FreeBSD.
	(glob0): Use correct type for c variable to propagate previously
	detected protection.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.

2006-12-12  Christopher Faylor  <me@@cgf.cx>

	* syscalls.cc (popen): Allow '[rw][bt]'.

2006-12-11  Christopher Faylor  <me@@cgf.cx>

	* sigproc.cc (child_info::child_info): Move old comment about msv_count
	here.  Edit it slightly to reflect new sensibilities.

2006-12-11  Christopher Faylor  <me+cygwin@@cgf.cx>

	* child_info.h (child_info_spawn::__stdin): New element.
	(child_info_spawn::__stdin): Ditto.
	(CURR_CHILD_INFO_MAGIC): Regenerate.
	* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
	(child_info_spawn::handle_spawn): Handle new __std* elements by calling
	move_fd.
	* dtable.cc (dtable::move_fd): Define new function.
	* dtable.h (dtable::move_fd): Declare new function.
	* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
	* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
	* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
	(fhandler_pipe::dup): Ditto.
	* spawn.cc (handle): Change second argument to bool.
	(spawn_guts): Accept __stdin/__stdout arguments and set them
	appropriately in child_info structure and in STARTUPINFO structure.
	* syscalls.cc (popen): New cygwin-specific implementation using spawn.
	(pclose): Ditto.
	* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.

	* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
	* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.

	* child_info.h (child_info::msv_count): Rename from the now-inappropriate
	"zero".
	(child_info_spawn::filler): Add filler to work around Vista bug.
	(child_info_fork::filler): Ditto.
	* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is
	now always filled out.
	* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
	* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
	* sigproc.cc (child_info::child_info): Initialize starter[].

	* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
	* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d170 1
a170 1
  void set_nonblocking (int);
d252 1
a252 1
  virtual void set_no_inheritance (HANDLE &, bool);
d255 1
a255 1
  bool fork_fixup (HANDLE, HANDLE &, const char *);
d258 3
a260 3
  int open_9x (int, mode_t = 0);
  virtual int open (int, mode_t = 0);
  int open_fs (int, mode_t = 0);
a504 2
private:
  pid_t popen_pid;
a506 2
  void set_popen_pid (pid_t pid) {popen_pid = pid;}
  pid_t get_popen_pid () const {return popen_pid;}
@


1.298.2.2
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
a27 5
/* It appears that 64K is the block size used for buffered I/O on NT.
   Using this blocksize in read/write calls in the application results
   in a much better performance than using smaller values. */
#define PREFERRED_IO_BLKSIZE ((blksize_t) 65536)

d98 1
d112 1
a112 1
      uninterruptible_io (0), did_lseek (0),
d190 1
@


1.298.2.3
log
@* dtable.cc (dtable::init_std_file_from_handle): Try harder to make a pipe into
a full-cygwin device.
(handle_to_fn): Change \ to / when necessary.
* fhandler.cc (fhandler_base::init): Change bin to mode.
* fhandler.h (fhandler_pipe::init): Declare.
* pipe.cc (fhandler_pipe::init): Define.
(handler_pipe::open): Move initialization code into init.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
a520 1
  void init (HANDLE, DWORD, mode_t);
@


1.297
log
@	* fhandler.h (fhandler_socket::wait): Reset default timeout to 10ms.
@
text
@d278 1
a278 1
  int fhandler_base::utimes_fs (const struct timeval *) __attribute__ ((regparm (2)));
d604 1
a604 1
  int fhandler_dev_floppy::get_drive_info (struct hd_geometry *geo);
d931 1
a931 1
  static bool fhandler_console::has_a () {return !invisible_console;}
@


1.297.2.1
log
@	* Merge HEAD into cv-branch.

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.
@
text
@a380 2
struct wsa_event;

a387 4
  HANDLE wsock_mtx;
  HANDLE wsock_evt;
  wsa_event *wsock_events;

d417 2
a418 2
    unsigned owner                 : 1; /* fcntl(F_SETOWN) called */
    unsigned listener              : 1; /* listen called */
d423 1
a423 1
      owner (0), listener (0), connect_state (unconnected)
d427 3
a429 5
 public:
  bool prepare ();
 private:
  int wait (long event_mask);
  void release ();
d441 1
a442 1
  IMPLEMENT_STATUS_FLAG (bool, listener)
d455 3
a457 6
  inline ssize_t recv_internal (struct _WSABUF *wsabuf, DWORD wsacnt,
  				DWORD flags,
				struct sockaddr *from, int *fromlen);
  ssize_t recvfrom (void *ptr, size_t len, int flags,
		    struct sockaddr *from, int *fromlen);
  ssize_t recvmsg (struct msghdr *msg, int flags, ssize_t tot = -1);
d460 1
a460 3
  inline ssize_t send_internal (struct _WSABUF *wsabuf, DWORD wsacnt, int flags,
				const struct sockaddr *to, int tolen);
  ssize_t sendto (const void *ptr, size_t len, int flags,
d462 1
a462 1
  ssize_t sendmsg (const struct msghdr *msg, int flags, ssize_t tot = -1);
@


1.297.2.2
log
@	* Merge HEAD into cv-branch.
@
text
@d278 1
a278 1
  int utimes_fs (const struct timeval *) __attribute__ ((regparm (2)));
d617 1
a617 1
  int get_drive_info (struct hd_geometry *geo);
d944 1
a944 1
  static bool has_a () {return !invisible_console;}
@


1.297.2.3
log
@	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.
@
text
@a392 6
 public:
  bool init_events ();
 private:
  int evaluate_events (const long event_mask, long &events, bool erase);
  int wait_for_events (const long event_mask);
  void release_events ();
d423 1
d429 1
a429 1
      listener (0), connect_state (unconnected)
d434 6
d449 1
@


1.297.2.4
log
@	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.
@
text
@d390 2
a392 1
  HANDLE wsock_mtx;
a393 1
  HANDLE wsock_evt;
d395 1
a396 1
 private:
@


1.296
log
@	* fhandler.h (fhandler_socket::wait): Set default timeout to INFINITE.
@
text
@d428 1
a428 1
  int wait (HANDLE event, int flags, DWORD timeout = INFINITE);
@


1.295
log
@	* fhandler.h (class dev_console): Add `metabit' indicating the
	current meta key mode.
	* fhandler_console.cc (fhandler_console::read): Set the top bit of
	the character if metabit is true.
	* fhandler_console.cc (fhandler_console::ioctl): Implement
	KDGKBMETA and KDSKBMETA commands.
	* fhandler_tty.cc (process_ioctl): Support KDSKBMETA.
	(fhandler_tty_slave::ioctl): Send KDGKBMETA and KDSKBMETA to the
	master.
	* include/cygwin/kd.h: New file for the meta key mode.
	* include/sys/kd.h: New file.
@
text
@d428 1
a428 1
  int wait (HANDLE event, int flags, DWORD timeout = 10);
@


1.294
log
@	Revert patches from 2005-10-22 and 2006-06-14 to use event driven
	accept and connect back to using select:
	* fhandler.h (class fhandler_socket): Remove accept_mtx.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Drop
	initializing accept_mtx.
	(fhandler_socket::accept): Drop event handling.
	(fhandler_socket.cc (fhandler_socket::connect): Ditto.
	(fhandler_socket::dup): Drop accept_mtx handling.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::prepare): Ditto.
	(fhandler_socket::release): Ditto.
	(fhandler_socket::close): Ditto.
	* net.cc (cygwin_accept): Revert to calling cygwin_select to
	implement interuptible accept.
	(cygwin_connect): Ditto for connect.
@
text
@d824 1
@


1.293
log
@	* fhandler.h (class fhandler_socket): Add private mutex handle
	accept_mtx.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	accept_mtx to NULL.
	(fhandler_socket::dup): Duplicate accept_mtx, if available.
	(fhandler_socket::listen): Create accept_mtx before trying to listen.
	(fhandler_socket::prepare): Wait for accept_mtx if available to
	serialize accepts on the same socket.
	(fhandler_socket::release): Release accept_mtx.
	(fhandler_socket::close): Close accept_mtx on successful closesocket.
@
text
@a383 1
  HANDLE accept_mtx;
@


1.292
log
@* cygthread.cc (cygthread::terminate_thread): In debugging output, use name of
thread being terminated rather than thread doing terminating.
* fhandler.h (fhandler_pty_master::slave): Delete.
(fhandler_pty_master::get_unit): Ditto.
(fhandler_pty_master::setup): Change argument declaration to accommodate new
usage.
* fhandler_tty.cc (fhandler_tty_master::init): Remove obsolete slave
assignment.  Pass argument to setup indicating that this is a tty.
(fhandler_tty_slave::open): Use dev() method rather than referencing pc.dev
directly.
(fhandler_pty_master::open): Don't create archetype based on ptym device
number.  Set device number to use DEV_TTYM_MAJOR and tty number.  Pass argument
to setup indicating that this is a pty.
(fhandler_pty_master::setup): Change single argument to a flag indicating
whether we're creating a pty and use appropriately.  Calculate 't' variable
here rather than in caller.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Use dev() method rather than
referencing pc.dev directly.
@
text
@d384 1
@


1.291
log
@* fhandler.cc (fhandler_base::fixup_after_exec): Declare here.
* fhandler.h (fhandler_base::fixup_after_exec): Make non-inline.
(fhandler_termios::fixup_after_fork): Delete declaration.
(fhandler_termios::fixup_after_exec): Ditto.
(fhandler_tty_common::inuse): Remove.
(fhandler_tty_common::dup): Delete declaration.
(fhandler_tty_common::fixup_after_fork): Ditto.
(fhandler_tty_slave::fixup_after_exec): Declare new function.
(fhandler_pty_master::dwProcessId): New variable.
(fhandler_pty_master::from_master): Ditto.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::setup): New function.
(fhandler_pty_master::fixup_after_fork): Ditto.
(fhandler_pty_master::fixup_after_exec): Ditto.
* fhandler_termios.cc (fhandler_termios::fixup_after_exec): Delete definition.
(fhandler_termios::fixup_after_fork): Ditto.
* fhandler_tty.cc (fhandler_tty_master::init): Use fhandler_pty_master setup
function rather than obsolete tty::common_init.  Delete obsolete inuse setting.
(fhandler_tty_slave::fhandler_tty_slave): Set inuse to NULL here.
(fhandler_tty_slave::open): Change debugging output for clarity.  Check for
different things when doing a sanity check on the tty.  Reflect the fact that
master_pid now is the cygwin pid rather than the windows pid.  Use "arch"
rather than "archetype" for consistency.
(fhandler_tty_slave::close): Close inuse here.
(fhandler_tty_slave::dup): Remove old if 0'ed code.
(fhandler_pty_master::dup): New function.  Handles pty master archetype.
(fhandler_pty_master::fhandler_pty_master): Zero pty_master specific fields.
(fhandler_pty_master::open): Implement using archetypes, similar to slave.  Use
fhandler_pty_master setup function rather than obsolete tty::common_init.
Don't set inuse.
(fhandler_tty_common::close): Don't deal with inuse.  Delete old if 0'ed code.
(fhandler_pty_master::close): Implement using archetypes.  Close from_master
and to_master.
(fhandler_tty_common::set_close_on_exec): Just set close_on_exec flag here
since everything uses archetypes now.
(fhandler_tty_common::fixup_after_fork): Delete definition.
(fhandler_tty_slave::fixup_after_exec): Define new function.
(fhandler_pty_master::setup): New function, derived from tty::common_init.
(fhandler_pty_master::fixup_after_fork): New function.
(shared_info.h): Reset SHARED_INFO_CB to reflect new tty size.
* tty.cc (tty_list::terminate): Close individual handles from tty_master.
(tty::master_alive): Delete.
(tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* tty.h (tty::from_slave): Delete.
(tty::to_slave): Ditto.
(tty::common_init): Delete declaration.
(tty::make_pipes): Ditto.
(tty::master_pid): Define as pid_t since it is now a cygwin pid.
@
text
@a995 2
protected:
  device slave;			// device type of slave
d1020 1
a1020 2
  int get_unit () const { return slave.minor; }
  bool setup (tty&);
@


1.290
log
@* debug.h (ModifyHandle): Define new macro.
(modify_handle): Declare new function.
* debug.cc (modify_handle): Define new function.
* fhandler.h (fhandler_base::fork_fixup): Change return value from void to
bool.
* fhandler.cc (fhandler_base::fork_fixup): Return true if fork fixup has been
done.
* pipe.cc (fhandler_pipe::set_close_on_exec): Set inheritance of protected
handle via ModifyHandle if DEBUGGING.
(fhandler_pipe::fixup_after_fork): Protect guard handle if fork fixup has been
done.
@
text
@d211 1
a211 1
  virtual void fixup_after_exec () {}
a787 2
  void fixup_after_fork (HANDLE);
  void fixup_after_exec ();
d939 1
a939 1
    input_mutex (NULL), input_available_event (NULL), inuse (NULL)
a950 1
  HANDLE inuse;			// used to indicate that a tty is in use
a954 2
  virtual int dup (fhandler_base *child);

a959 1
  void fixup_after_fork (HANDLE parent);
d968 1
d985 1
d1000 1
d1020 1
a1020 1
  void set_close_on_exec (bool val);
d1023 4
@


1.289
log
@* fhandle.h (fhandler_pipe::create_guard): Revert change which eliminated
SECURITY_ATTRIBUTES argument.
* pipe.cc (fhandler_pipe::open): Duplicate guard from other process and protect
it appropriately.  Eliminate unneeded writepipe_exists temporary variable.  Set
inheritance appropriately.
(fhandler_pipe::set_close_on_exec): Revert change which eliminated handling
guard inheritance.
(fhandler_pipe::fixup_after_fork): Ditto.  Use correct name of entity being
checked by fork_fixup.
(fhandler_pipe::fixup_after_exec): Don't bother with guard here.
(fhandler_pipe::dup): Cosmetic changes and revert creation of writepipe_exists
as noninheritable.
(fhandler_pipe::create): Revert change which eliminated SECURITY_ATTRIBUTES
argument.  Revert change which always made writepipe_exists noninheritable.
@
text
@d255 1
a255 1
  void fork_fixup (HANDLE parent, HANDLE &h, const char *name);
@


1.288
log
@* debug.cc (add_handle): Print handle value when collision detected.
* dtable.cc (dtable::stdio_init): Cosmetic change.
* fhandler.h (fhandler_base::create_read_state): Protect handle.
(fhandler_pipe::create_guard): Ditto.  Always mark the handle as inheritable.
(fhandler_pipe::is_slow): Return boolean value rather than numeric 1.
* pipe.cc (fhandler_pipe::fhandler_pipe): Always flag that we need fork fixup.
(fhandler_pipe::open): Don't pass security attributes to create_guard.
(fhandler_pipe::set_close_on_exec): Don't handle guard here.
(fhandler_pipe::close): Accommodate now-protected guard handle.
(fhandler_pipe::fixup_in_child): Don't proected read_state here.
(fhandler_pipe::fixup_after_exec): Close guard handle if close_on_exec.
(fhandler_pipe::fixup_after_fork): Don't bother with guard here.
(fhandler_pipe::dup): Don't set res to non-error prematurely.  Use boolean
values where appropriate.  Protect guard and read_state.
(fhandler_pipe::create): Don't call need_fork_fixup since it is now the
default.  Don't protect read_state or guard.
* pipe.cc (fhandler_base::ready_for_read): Use bool values for "avail".
* spawn.cc (spawn_guts): Set cygheap->pid_handle as inheritable when
protecting.
* select.cc (fhandler_pipe::ready_for_read): Actually get the guard mutex for
blocking reads.
@
text
@d516 5
a520 5
  void create_guard ()
    {
      guard = CreateMutex (&sec_none, FALSE, NULL);
      ProtectHandleINH (guard);
    }
@


1.287
log
@	* fhandler.h (fhandler_base): Change fstat_helper prototype
	to take file size and inode number as 64 bit values.
	* fhandler_disk_file.cc (FS_IS_SAMBA): Move to path.cc
	(FS_IS_SAMBA_WITH_QUOTA): Ditto.
	(path_conv::hasgood_inode): Delete.
	(path_conv::is_samba): Delete.
	(path_conv::isgood_inode): Centralized function to recognize
	a good inode number.
	(fhandler_base::fstat_by_handle): Constify fvi_size and fai_size.
	Accomodate argument change in fstat_helper.
	(fhandler_base::fstat_by_name): Ditto.
	(fhandler_base::fstat_helper): Accomodate argument change.  Call
	path_conv::isgood_inode to recognize good inodes.
	(fhandler_disk_file::opendir): Explain Samba weirdness here.
	Call path_conv::fs_is_samba instead of path_conv::is_samba.
	(fhandler_disk_file::readdir): Add STATUS_INVALID_INFO_CLASS
	as valid return code from NtQueryDirectoryFile to indicate that
	FileIdBothDirectoryInformation is not supported.
	Call path_conv::isgood_inode to recognize good inodes.
	* ntdll.h (STATUS_INVALID_INFO_CLASS): Define.
	* path.cc (fs_info::update): Rework file system recognition
	and set appropriate flags.
	* path.h (struct fs_info): Add is_ntfs, is_samba and is_nfs flags.
	Constify pure read accessors.
@
text
@d215 1
d516 5
a520 1
  void create_guard (SECURITY_ATTRIBUTES *sa) {guard = CreateMutex (sa, FALSE, NULL);}
d553 1
a553 1
  bool is_slow () {return 1;}
@


1.286
log
@	* fhandler.h (enum dirent_states): Remove dirent_saw_cygdrive,
	dirent_saw_dev and dirent_saw_proc.
	(fhandler_cygdrive::open): Declare.
	(fhandler_cygdrive::close): Declare.
	* fhandler_disk_file.cc (class __DIR_mounts): Move to beginning of file.
	(__DIR_mounts::check_mount): New parameter to indicate if inode number
	is needed in calling function or not. Add /proc and /cygdrive handling.
	(__DIR_mounts::check_missing_mount): Ditto.
	(path_conv::ndisk_links): Use __DIR_mounts class to create correct
	hardlink count for directories with mount points in them.
	(fhandler_disk_file::readdir_helper): Remove /dev, /proc and /cygdrive
	handling.
	(fhandler_cygdrive::open): New method.
	(fhandler_cygdrive::close): New method.
	(fhandler_cygdrive::fstat): Always return fixed inode number 2 and
	fixed link count of 1. Drop call to set_drives.
	(fhandler_cygdrive::opendir): Drop call to get_namehash.
	(fhandler_cygdrive::readdir): Handle "." entry to return fixed inode
	number 2.
@
text
@d269 1
a269 2
			      DWORD nFileSizeHigh,
			      DWORD nFileSizeLow,
d271 1
a271 2
			      DWORD nFileIndexHigh,
			      DWORD nFileIndexLow,
@


1.285
log
@	* fhandler.h (class fhandler_socket): Add saw_reuseaddr status flag.
	* fhandler_socket.cc (fhandler_socket::bind): Set socket to
	SO_EXCLUSIVEADDRUSE if application didn't explicitely set SO_REUSEADDR
	socket option, on systems supporting SO_EXCLUSIVEADDRUSE.
	* net.cc (cygwin_setsockopt): Set fhandler's saw_reuseaddr status flag
	if SO_REUSEADDR socket option has been successsfully set.
	* wincap.h (wincaps::has_exclusiveaddruse): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d48 2
a49 5
  dirent_saw_cygdrive	= 0x0010,
  dirent_saw_dev	= 0x0020,
  dirent_saw_proc	= 0x0040,
  dirent_set_d_ino	= 0x0080,
  dirent_get_d_ino	= 0x0100
d697 2
@


1.284
log
@	* autoload.cc (NtQueryDirectoryFile): Define.
	* dir.cc (__opendir_with_d_ino): Just call opendir.
	(opendir): Remove CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO handling.
	(readdir_worker): Only try generating d_ino if it's 0.
	Utilize namehash of directories fhandler.  Call readdir_get_ino to
	generate d_ino for "..".
	(seekdir64): Keep dirent_set_d_ino flag.
	* fhandler.h (enum dirent_states): Add dirent_get_d_ino.
	(class fhandler_disk_file): Declare new private methods readdir_helper
	and readdir_9x.
	* fhandler_disk_file.cc (path_conv::hasgood_inode): New method to
	evaluate if a filesystem has reliable inode numbers.
	(fhandler_base::fstat_by_handle): Accomodate structure member name
	change from IndexNumber to FileId.
	(fhandler_base::fstat_helper): Call hasgood_inode here.
	(fhandler_disk_file::opendir): Call fhaccess only for real files.
	Don't append '*' to __d_dirname here, move to readdir_9x.  On NT,
	open directory handle here.  Set dirent_get_d_ino and dirent_set_d_ino
	flags according to wincap and filesystem.
	(fhandler_disk_file::readdir_helper): New method to implement readdir
	postprocessing only once.
	(readdir_get_ino_by_handle): New static function.
	(readdir_get_ino): New function to centralize inode number evaluation
	in case inode number hasn't been returned by NtQueryDirectoryFile.
	(fhandler_disk_file::readdir): Move old functionality to readdir_9x.
	Call readdir_9x when on 9x/Me.  Implement NT specific readdir here.
	(fhandler_disk_file::readdir_9x): Move 9x specific readdir here.
	(fhandler_disk_file::seekdir): Accomodate new NT readdir method.
	(fhandler_disk_file::closedir): Ditto.
	(fhandler_cygdrive::fstat): Set d_ino to namehash. Add comment.
	(fhandler_cygdrive::opendir): Call get_namehash to prepare later
	correct evaluation of d_ino.
	(fhandler_cygdrive::readdir): Replace recursion with loop. Evaluate
	drive's d_ino by calling readdir_get_ino.
	* fhandler_proc.cc (fhandler_proc::readdir): Set dirent_saw_dot and
	dirent_saw_dot_dot to avoid seeing . and .. entries twice.
	* fhandler_process.cc (fhandler_process::readdir): Ditto.
	* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
	* ntdll.h (STATUS_INVALID_PARAMETER): New define.
	(STATUS_INVALID_LEVEL): New define.
	(struct _FILE_INTERNAL_INFORMATION): Rename member IndexNumber to
	FileId (as in Nebbitt).
	* path.h (path_conv::hasgood_inode): Now implemented in
	fhandler_disk_file.cc.
	* wincap.h (wincaps::has_fileid_dirinfo): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (readdir_get_ino): Add declaration.
	* include/sys/dirent.h (struct dirent): Slightly rename structure
	members to accomodate changes.
	Remove __USE_EXPENSIVE_CYGWIN_D_INO handling and declaration of
	__opendir_with_d_ino.
@
text
@d420 1
d444 1
@


1.283
log
@* include/cygwin/version.h: Bump API minor number to 151.
* dir.cc (__opendir_with_d_ino): New function.
(opendir): Set flag if we should be calculating inodes.
(readdir_worker): Calculate d_ino by calling stat if the user has asked for it.
(seekdir64): Maintain all persistent flag settings.
* fhandler.h (dirent_states): Add dirent_set_d_ino.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Reflect changes to
dirent structure.
* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
* include/sys/dirent.h (struct dirent): Coalesce two similar structures.
Remove all threads of the apparently highly confusing references to inodes.
Add support for calculating a real inode if __USE_EXPENSIVE_CYGWIN_D_INO is
defined.
@
text
@d51 2
a52 1
  dirent_set_d_ino	= 0x0080
d654 2
@


1.282
log
@	* Update copyrights.
@
text
@d50 2
a51 1
  dirent_saw_proc	= 0x0040
@


1.281
log
@* fhandler.h (set_console_state_for_spawn): Whackamole the argument back to a
bool.
* spawn.cc (spawn_guts): Ditto, i.e., once again call
set_console_state_for_spawn with an indication of whether we're about to start
a cygwin process.
* fhandler_console.cc (set_console_state_for_spawn): Don't set the console
state if we know we're starting a cygwin process or if we're using a "real"
tty.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
@


1.280
log
@* fhandler.h (set_console_state_for_spawn): Eliminate argument from
declaration.
* fhandler.cc (set_console_state_for_spawn): Eliminate argument from
definition.  Always check for invisible console.
(fhandler_console::need_invisible): Don't do anything if the windows station is
already not visible.
* spawn.cc (spawn_guts): Accommodate change of argument to
set_console_state_for_spawn.
@
text
@d1368 1
a1368 2
void __stdcall set_console_state_for_spawn ();

@


1.279
log
@	* fhandler.h (fhandler_base::issymlink): New method.
	* syscalls.cc (open): Handle O_NOFOLLOW flag.
	* include/fcntl.h (_FNOFOLLOW): New define.
	(O_NOFOLLOW): Ditto.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d1368 1
a1368 1
void __stdcall set_console_state_for_spawn (bool) __attribute__ ((regparm (1)));
@


1.278
log
@* fhandler.h (fhandler_termios::fixup_after_exec): Make non-inlined.
* fhandler_termios.cc (fhandler_termios::fixup_after_exec): Don't call
fixup_after_fork if close_on_exec'ed.
@
text
@d366 1
@


1.277
log
@* fhandler.h (set_console_state_for_spawn): Add an argument to the declaration.
* fhandler_console.cc (set_console_state_for_spawn): Ditto for the definition.
Only set invisible console for non-cygwin process.  Remove debugging leftover.
* spawn.cc (spawn_guts): Pass argument denoting whether this is a cygwin
process to set_console_state_for_spawn and only call this function when
exec'ing.
@
text
@d780 1
a780 1
  void fixup_after_exec () { fixup_after_fork (NULL); }
@


1.276
log
@* fhandler.h (fhandler_pipe::fixup_in_child): Declare new function.
(fhandler_console::invisible_console): Declare new variable.
(fhandler_console::need_invisible): Ditto.
(fhandler_console::has_a): Ditto.
* fhandler_console.cc (set_console_state_for_spawn): Eliminate return value.
Set up an invisible console if necessary prior to spawning.
(fhandler_console::invisible_console): Define.
* fhandler_tty.cc (fhandler_tty_slave::open): Use
fhandler_console::invisible_console to setup an invisible console.
* pipe.cc (fhandler_pipe::fixup_in_child): Define new function from
fixup_after_exec.
(fhandler_pipe::fixup_after_exec): Use fixup_in_child when appropriate.
(fhandler_pipe::fixup_after_fork): Ditto.
* spawn.cc (handle): Reorganize and modernize a little.
(spawn_guts): Rely on set_console_state_for_spawn to set the console into the
right state but don't create the process with "detached" flag if we have no
controlling tty since that confuses 'cmd'.
* dtable.cc (dtable::stdio_init): Don't set console as controlling terminal if
we have an invisible console.
* sigproc.cc (child_info::sync): Use correct name in ForceCloseHandle1.
@
text
@d1367 1
a1367 1
void __stdcall set_console_state_for_spawn ();
@


1.275
log
@	* fhandler.h (fhandler_dev_zero::mmap): Add method.
	(fhandler_dev_zero::munmap): Ditto.
	(fhandler_dev_zero::msync): Ditto.
	(fhandler_dev_zero::fixup_mmap_after_fork): Ditto.
	* mmap.cc: Implement anonymous mapping using fhandler_dev_zero class.
	Implement private anonymous maps using VirtualAlloc/VirtualFree.  Fix
	or add some more comments.
	(fh_paging_file): Change to type fhandler_dev_zero.
	(priv): New static inline function to avoid having lots of flag bit
	tests in the code.  Use throughout were appropriate.
	(fixed): Ditto.
	(anonymous): Ditto.
	(noreserve): Ditto.
	(autogrow): Ditto.
	(gen_protect): Never generate PAGE_WRITECOPY protection for
	private anonymous maps.
	(gen_access): Drop FILE_MAP_EXECUTE handling since it's not supported
	correctly on 9x.
	(VirtualProt9x): Move comment from mmap64 here.
	(mmap_record::mmap_record): Gegerate correct device entry for
	anonymous maps, though unused right now.
	(mmap_record::priv): Call global priv function.
	(mmap_record::fixed): Call global fixed function.
	(mmap_record::anonymous): Call global anonymous function.
	(mmap_record::noreserve): Call global noreserve function.
	(mmap_record::autogrow): Call global autogrow function.
	(list::anonymous): New method.  Use throughout were appropriate.
	(mmap_record::compatible_flags): Drop now useless ifdef.
	(mmap_record::alloc_page_map): Accomodate private anonymous maps.
	(mmap_record::map_pages): Accomodate MAP_NORESERVE mappings.
	(mmap_record::unmap_pages): Accomodate private anonymous maps.
	(mmap64): Simplify argument check.  Don't remove the MAP_PRIVATE flag
	for anonymous mappings on 9x anymore since that's now handled
	gracefully.
	(mprotect): Accomodate MAP_NORESERVE mappings.  Fix case when
	non-mmap areas are just MEM_RESERVEd.
	(fhandler_dev_zero::mmap): Implement anonymous mapping here.
	(fhandler_dev_zero::munmap): Ditto.
	(fhandler_dev_zero::msyn): Ditto.
	(fhandler_dev_zero::fixup_mmap_after_fork): Ditto.
	(fixup_mmaps_after_fork): Accomodate private anonymous maps.  Enhance
	debug output in case VirtualProtect fails.
	* include/sys/mman.h: Really define MAP_NORESERVE now.
@
text
@d518 1
d868 1
d922 2
d1367 1
a1367 1
int __stdcall set_console_state_for_spawn ();
@


1.274
log
@	* autoload.cc (NtCreateSection): Define.
	* cygheap.cc (_csbrk): Call getpagesize instead of getshmlba.
	* dcrt0.cc (dll_crt0_0): Call mmap_init.
	* external.cc (cygwin_internal): Call getpagesize instead of getshmlba.
	* fhandler.h (fhandler_base::mmap): Change access to prot parameter.
	(fhandler_base::fixup_mmap_after_fork): Ditto.
	(fhandler_disk_file::mmap): Ditto.
	(fhandler_disk_file::fixup_mmap_after_fork): Ditto.
	(fhandler_dev_mem::mmap): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::write): Call getsystempagesize
	instead of getpagesize.
	(fhandler_dev_mem::read): Ditto.
	(fhandler_dev_mem::fstat): Ditto.
	(fhandler_dev_mem::mmap): Move to mmap.cc.
	(fhandler_dev_mem::munmap): Ditto.
	(fhandler_dev_mem::msync): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.
	* fhandler_proc.cc (format_proc_meminfo): Call getsystempagesize
	instead of getpagesize.
	* fhandler_process.cc (format_process_stat): Ditto.
	(format_process_status): Ditto.
	(get_mem_values): Ditto.
	* mmap.cc: Fix formatting.  Try to make more readable and modular.
	Take advantage of pagesize==granularity.
	(gen_protect): New static function to evaluate Windows
	protection bits from POSIX protection and flags.
	(gen_access): Ditto for Windows access mode.
	(VirtualProt9x): Wrapper function to call VirtualProtect on 9x.
	(VirtualProtNT): Ditto for NT.
	(VirtualProtEx9x): Ditto for VirtualProtectEx on 9x.
	(VirtualProtExNT): Ditto for NT.
	(CreateMapping9x): Wrapper function for creating a mapping handle on 9x.
	(CreateMappingNT): Ditto for NT.
	(MapView9x): Wrapper function to map a view on 9x.
	(MapViewNT): Ditto for NT.
	(mmap_funcs_9x): Structure containing function pointers to wrapper
	functions for 9x.
	(mmap_funcs_nt): Ditto for NT.
	(mmap_func): Pointer to wrapper functions used in subsequent code.
	(mmap_init): Initialize mmap_func depending on OS.
	(class mmap_record): Use sensible member names.  Add POSIX protection
	member. Drop Windows access flags member.  Constify more methods.
	Use accessors instead of direct member access inside of own methods.
	(mmap_record::gen_protect): Class wrapper to evaluate matching
	Windows protection bits.
	(mmap_record::gen_access): Ditto for Windows access flags.
	(mmap_record::compatible_flags): New function to check if flags are
	compatible with flags of existing map.
	(list::add_record): Drop offset and length arguments.
	(class map): Change counters to unsigned.  Match usage throughout.
	(mmapped_areas): Convert from pointer to global struct.
	(mmap_record::alloc_page_map): Simplify.
	(mmap_record::map_pages): Ditto.
	(mmap_record::fixup_page_map): Delete.
	(mmap64): Simplify.  Add workaround for Windows 98 bug.  Fix bug on
	NT that existing anonymous mappings weren't searched for a match.
	(munmap): Add workaround for Windows 98 bug.
	(msync): Simplify.
	(mprotect): Handle existing maps correctly.
	(mlock): Add local pagesize variable and enlightening comment.
	(fhandler_disk_file::mmap): Main functionality now in CreateMapping/
	MapView wrapper functions.
	(fhandler_disk_file::fixup_mmap_after_fork): Call MapView wrapper.
	(fhandler_dev_mem::mmap): Moved from fhandler_mem.cc.  Simplify by
	calling MapViewNT.
	(fhandler_dev_mem::munmap): Moved from fhandler_mem.cc.
	(fhandler_dev_mem::msync): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.  Call MapViewNT.
	(fixup_mmaps_after_fork): Restructure and hopefully speed up loop for
	setting protection and memory content on MAP_PRIVATE maps.
	* ntdll.h (AT_ROUND_TO_PAGE): Remove define.
	(AT_EXTENDABLE_FILE): Add define.
	(NtCreateSection): Add prototype.
	* syscalls.cc (getpagesize): Return granularity as pagesize now.
	(getsystempagesize): New function to retrieve "real" pagesize.
	(getshmlba): Delete since it's replaced by getpagesize now.
	* wincap.h (wincaps::has_mmap_alignment_bug): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (getshmlba): Drop prototype.
	(getsystempagesize): Add prototype.
	(mmap_init): Ditto.
	* include/sys/mman.h: (Not yet) define MAP_NORESERVE.
@
text
@d1047 8
@


1.273
log
@* fhandler.h (fhandler_console::fixup_after_fork_exec): Define with additional
bool parameter.
(fhandler_console::fixup_after_exec): Accommodate fixup_after_fork_exec's
parameter.
(fhandler_console::fixup_after_fork): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_fork_exec): Avoid opening
new console only when close_on_exec AND execing.
@
text
@d301 1
a301 1
  virtual HANDLE mmap (caddr_t *addr, size_t len, DWORD access,
d305 1
a305 1
  virtual bool fixup_mmap_after_fork (HANDLE h, DWORD access, int flags,
d667 1
a667 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, _off64_t off);
d670 1
a670 1
  bool fixup_mmap_after_fork (HANDLE h, DWORD access, int flags,
d1086 1
a1086 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, _off64_t off);
d1089 1
a1089 1
  bool fixup_mmap_after_fork (HANDLE h, DWORD access, int flags,
@


1.272
log
@* fhandler.h (fhandler_console::fixup_after_fork_exec): Declare new function.
(fhandler_console::fixup_after_fork): Use fixup_after_fork_exec.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_fork): Delete definition.
(fhandler_console::fixup_after_fork_exec): Rename from fixup_after_exec.
* pinfo.cc (_pinfo::set_ctty): Don't play with console count here.
* syscalls.cc (close_all_files): Don't close cygheap ctty if hExeced since the
child will be copying information from us.
(setsid): Use myctty() rather than raw ctty #.
@
text
@d912 3
a914 3
  void fixup_after_fork_exec ();
  void fixup_after_exec () {fixup_after_fork_exec ();}
  void fixup_after_fork (HANDLE) {fixup_after_fork_exec ();}
@


1.271
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@d912 3
a914 1
  void fixup_after_exec ();
a915 1
  void fixup_after_fork (HANDLE parent);
@


1.270
log
@	* fhandler.h (class fhandler_socket): Add timeout parameter to wait()
	method.
	* fhandler_socket.cc (fhandler_socket::connect): Use event driven
	technique (prepare/wait/release) to implement interuptible connect.
	(fhandler_socket::wait): Add timeout parameter.  Allow FD_CONNECT
	handling.
	* net.cc (cygwin_connect): Remove braindead workaround for allowing
	blocking connect.  That's entirely in fhandler_socket::connect now.
@
text
@d1264 2
a1265 2
#define report_tty_counts(fh, call, fhs_op, use_op) \
  termios_printf ("%s %s, %sopen_fhs %d, %susecount %d",\
a1266 1
		  fhs_op, cygheap->open_fhs,\
@


1.269
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d428 1
a428 1
  int wait (HANDLE event, int flags);
@


1.268
log
@	Revert erroneous checkin.
@
text
@a553 3
  _off64_t drive_size;
  _off64_t current_position;
  unsigned long bytes_per_sector;
a559 2
    unsigned eom_detected    : 1;
    unsigned eof_detected    : 1;
d562 1
a562 3
    status_flags () :
      eom_detected (0), eof_detected (0), lastblk_to_read (0)
      {}
a564 2
  IMPLEMENT_STATUS_FLAG (bool, eom_detected)
  IMPLEMENT_STATUS_FLAG (bool, eof_detected)
a566 9
  virtual BOOL write_file (const void *buf, DWORD to_write,
			   DWORD *written, int *err);
  virtual BOOL read_file (void *buf, DWORD to_read, DWORD *read, int *err);

  /* returns not null, if `win_error' determines an end of media condition */
  virtual int is_eom(int win_error);
  /* returns not null, if `win_error' determines an end of file condition */
  virtual int is_eof(int win_error);

a572 2
  void raw_read (void *ptr, size_t& ulen);
  int raw_write (const void *ptr, size_t ulen);
a576 1

d586 12
d600 2
a601 3
 protected:
  virtual int is_eom (int win_error);
  virtual int is_eof (int win_error);
d606 6
a611 5
  virtual int open (int flags, mode_t mode = 0);

  virtual _off64_t lseek (_off64_t offset, int whence);

  virtual int ioctl (unsigned int cmd, void *buf);
@


1.267
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d299 1
a299 1
  virtual int dup (fhandler_base *child, HANDLE from_proc);
d469 1
a469 1
  int dup (fhandler_base *child, HANDLE from_proc);
d516 1
a516 1
  int dup (fhandler_base *child, HANDLE from_proc);
d546 1
a546 1
  int dup (fhandler_base *child, HANDLE from_proc);
d596 1
a596 1
  int dup (fhandler_base *child, HANDLE from_proc);
d648 1
a648 1
  virtual int dup (fhandler_base *child, HANDLE from_proc);
d729 1
a729 1
  int dup (fhandler_base *child, HANDLE from_proc);
d912 1
a912 1
  int dup (fhandler_base *child, HANDLE from_proc);
d953 1
a953 1
  virtual int dup (fhandler_base *child, HANDLE from_proc);
d983 1
a983 1
  int dup (fhandler_base *child, HANDLE from_proc);
d1074 1
a1074 1
  int dup (fhandler_base *child, HANDLE from_proc);
d1092 1
a1092 1
  int dup (fhandler_base *child, HANDLE from_proc);
d1116 1
a1116 1
  int dup (fhandler_base *child, HANDLE from_proc);
d1165 1
a1165 1
  int dup (fhandler_base *child, HANDLE from_proc);
d1195 1
a1195 1
  int dup (fhandler_base *child, HANDLE from_proc);
@


1.266
log
@	* fhandler.h (class fhandler_dev_raw): Add drive information members
	drive_size, current_position and bytes_per_sector.
	(fhandler_dev_floppy::get_drive_info): Declare.
	* fhandler_floppy.cc (fhandler_dev_floppy::is_eom): Define ERROR_SEEK
	and ERROR_SECTOR_NOT_FOUND as end-of-medium conditions.
	(fhandler_dev_floppy::get_drive_info): New method to have one function
	retrieving drive info.
	(fhandler_dev_floppy::open): Call get_drive_info to get drive
	information right from the start.
	(fhandler_dev_floppy::lseek): Use and set drive information members.
	Especially keep track of current_position.
	(fhandler_dev_floppy::ioctl): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::write_file): Keep track of
	current_position.
	(fhandler_dev_raw::read_file): Ditto.
	(fhandler_dev_raw::raw_read): Never try to read beyond end-of-medium.
	(fhandler_dev_raw::dup): Handle new drive information members.
@
text
@d299 1
a299 1
  virtual int dup (fhandler_base *child);
d469 1
a469 1
  int dup (fhandler_base *child);
d516 1
a516 1
  int dup (fhandler_base *child);
d546 1
a546 1
  int dup (fhandler_base *child);
d596 1
a596 1
  int dup (fhandler_base *child);
d648 1
a648 1
  virtual int dup (fhandler_base *child);
d729 1
a729 1
  int dup (fhandler_base *child);
d912 1
a912 1
  int dup (fhandler_base *child);
d953 1
a953 1
  virtual int dup (fhandler_base *child);
d983 1
a983 1
  int dup (fhandler_base *child);
d1074 1
a1074 1
  int dup (fhandler_base *child);
d1092 1
a1092 1
  int dup (fhandler_base *child);
d1116 1
a1116 1
  int dup (fhandler_base *child);
d1165 1
a1165 1
  int dup (fhandler_base *child);
d1195 1
a1195 1
  int dup (fhandler_base *child);
@


1.265
log
@	* fhandler.h (fhandler_base::fstat_helper): Declare with additional
	file attributes argument.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Use
	file attributes evaluated from NtQueryFileInformation or
	FileInformationByHandle in call to fstat_helper.
	Set pc.fileattr from just evaluated file attributes here.
	(fhandler_base::fstat_by_name): Use file attributes evaluated from
	FindFileFirst or default attribute in call to fstat_helper.
	Set pc.fileattr from just evaluated file attributes here.
	(fhandler_base::fstat_helper): Use file attributes given as argument,
	not file attributes stored in this fhandler, since this information
	is potentially wrong.  Add comment to explain this.
	* path.h (has_attribute): New global inline function.
	(path_conv::set_attributes): New method to change fileattr.
@
text
@d554 3
d606 3
@


1.264
log
@* cygerrno.h (geterrno_from_win_error): Change declaration to default to using
GetLastError and EACCESS.
* cygwin.din: Export readdir_r.
* include/cygwin/version.h: Bump API version number to 138.
* syscalls.cc (readdir_worker): New function, renamed from old readdir()
function.
(readdir): Use readdir_worker.
(readdir_r): New function.
* fhandler.h (fhandler_base::readdir): Accommodate second argument indicating
dirent buffer.
(fhandler_disk_file::readdir): Ditto.
(fhandler_cygdrive::readdir): Ditto.
(fhandler_proc::readdir): Ditto.
(fhandler_netdrive::readdir): Ditto.
(fhandler_registry::readdir): Ditto.
(fhandler_process::readdir): Ditto.
* fhandler.cc (fhandler_base::readdir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Ditto.
* fhandler_cygdrive.cc (fhandler_cygdrive::readdir): Ditto.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_netdrive.cc (fhandler_netdrive::readdir): Ditto.
* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
* fhandler_process.cc (fhandler_process::readdir): Ditto.
@
text
@d275 2
a276 1
			      DWORD nNumberOfLinks)
@


1.263
log
@* fhandler.h (dirent_states): Add dirent_saw_proc.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Fill in "proc" if it is
the root dir and it is missing.
@
text
@d357 1
a357 1
  virtual dirent *readdir (DIR *);
d677 1
a677 1
  struct dirent *readdir (DIR *);
d695 1
a695 1
  struct dirent *readdir (DIR *);
d1205 1
a1205 1
  struct dirent *readdir (DIR *);
d1218 1
a1218 1
  struct dirent *readdir (DIR *);
d1233 1
a1233 1
  struct dirent *readdir (DIR *);
d1253 1
a1253 1
  struct dirent *readdir (DIR *);
@


1.262
log
@* fhandler.h (dirent_states): Add dirent_isroot, dirent_saw_cygdrive,
dirent_saw_dev.
* dir.cc (opendir): Don't zero __flags here.  Push that responsibility to
opendir methods.
(seekdir): Preserve dirent_isrrot in __flags.
(rewinddir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set dirent_isroot
appropriately.
(fhandler_disk_file::readdir): Fill in "cygdrive" and "dev" if it is the root
dir and they are missing.
* fhandler_process.cc (fhandler_process::opendir): Set __flags here.
* fhandler_virtual.cc (fhandler_virtual::opendir): Set __flags here.
@
text
@d49 2
a50 1
  dirent_saw_dev	= 0x0020
@


1.261
log
@* fhandler.h (fhandler_tty_common::lseek): Declare new method.
(fhandler_tty_slave::lseek): Delete old method.
(fhandler_tty_master::lseek): Delete old method.
* fhandler_tty.cc (fhandler_tty_common::lseek): Define new method.
@
text
@d43 7
a49 4
  dirent_ok = 0,
  dirent_saw_dot = 1,
  dirent_saw_dot_dot = 2,
  dirent_saw_eof = 4
@


1.260
log
@* Makefile.in (dtable_CFLAGS): Use -fomit-frame-pointer and -fcheck-new.
* cygheap.cc (cmalloc): Only emit system_printf warnings on failure if
DEBUGGING.
(crealloc): Ditto.
(ccalloc): Ditto.
* dtable.cc (build_fh_name): Treat NULL return from cnew as indicative of
EMFILE condition.
(build_fh_dev): Ditto.
(dtable::dup_worker): Handle NULL return from build_fh_pc.
(dtable::vfork_child_dup): Trust dup_worker to set errno.
* fhandler.h (fhandler_base::new): Mark as nothrow.
@
text
@d947 1
a974 1
  _off64_t lseek (_off64_t, int) { return 0; }
a1004 1
  _off64_t lseek (_off64_t, int) { return 0; }
@


1.259
log
@	* include/sys/termios.h: Define TIOCMBIS and TIOCMBIC.
	* fhandler.h (class fhandler_serial): Declare switch_modem_lines.
	* fhandler_serial.cc (fhandler_serial::switch_modem_lines): New
	static function to set or clear DTR and/or RTS.
	(fhandler_serial::ioctl): Use switch_modem_lines for TIOCMSET
	and new TIOCMBIS and TIOCMBIC.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d304 1
a304 1
  void *operator new (size_t, void *p) {return p;}
@


1.258
log
@* fhandler.h (fhandler_base::pread): Declare new function.
(fhandler_base::pwrite): Ditto.
(fhandler_disk_file::pread): Ditto.
(fhandler_disk_file::pwrite): Ditto.
* fhandler.cc (fhandler_base::pread): Define new function.
(fhandler_base::pwrite): Ditto.
* fhandler_disk_file.cc (fhandler_base::pread): Ditto.
(fhandler_base::pwrite): Ditto.
* syscalls.cc (pread): Define new function.
(pwrite): Ditto.
* cygwin.din: Export pread, pwrite.
* include/sys/ioctl.h: Guard some _IO* declarations to avoid conflict with
socket.h.
@
text
@d725 1
@


1.257
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d290 2
d678 3
@


1.256
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d216 1
a216 1
    (void) ReleaseSemaphore (read_state, n, NULL);
@


1.255
log
@* cygtls.h (_cygtls): Perform minor reformatting.
* winsup.h (close_all_files): Reflect argument change.
* dtable.cc (close_all_files): Ditto.
* dtable.h: Ditto.
* fhandler.h: Ditto.
* spawn.cc (spawn_guts): Move close_all_files back to its original location in
first P_OVERLAY test but use argument denoting that handles are only supposed
to be closed, not released (more work to be done here).
* syscalls.cc (close_all_files): Take an argument denoting whether to release
closed files or not.
* path.cc (symlink): Change argument names to reflect linux man page.
(symlink_worker): Ditto.  Also appropriately set ENOENT for empty strings.
@
text
@d282 1
a282 1
  virtual int __stdcall fsync (void) __attribute__ ((regparm (1)));
a291 1
  virtual void dump ();
d391 1
a391 1
  void af_local_set_cred (void);
d393 5
a397 5
  bool af_local_recv_secret (void);
  bool af_local_send_secret (void);
  bool af_local_recv_cred (void);
  bool af_local_send_cred (void);
  int af_local_accept (void);
d399 2
a400 2
  int af_local_connect (void);
  void af_local_set_sockpair_cred (void);
d578 1
a578 1
  ~fhandler_dev_raw (void);
a580 2
  int close (void);

d617 1
a617 1
  void drive_init (void);
d626 1
a626 1
  virtual int close (void);
d645 1
a645 1
  void touch_ctime (void);
a723 1
  void dump ();
a1025 1
  void dump ();
a1038 2

  void dump ();
d1057 1
a1057 1
  int close (void);
a1058 2

  void dump ();
d1069 1
a1069 1
  ~fhandler_dev_mem (void);
a1074 1
  int close (void);
a1082 2

  void dump ();
d1087 4
d1093 1
a1093 1
  int is_windows (void) { return 1; }
d1098 1
a1098 1
  int close (void);
d1101 1
a1101 8

  void dump ();

 private:
  _off64_t pos;
  void *membuffer;
  size_t msize;
  bool eof;
d1111 1
a1111 1
  int is_windows (void) { return 1; }
d1117 1
a1117 1
  int close (void) { return 0; }
d1148 1
a1148 1
  int close (void);
a1149 1
  void dump (void);
d1181 1
a1181 1
  int close (void);
d1233 1
a1233 1
  int close (void);
@


1.254
log
@	* fhandler.h (class fhandler_dev_tape): Add declaration for
	fixup_after_fork and set_close_on_exec.
	* fhandler_tape.cc (fhandler_dev_tape::open): Create mt_mtx mutex
	inheritable.
	(fhandler_dev_tape::close): Close mt_mtx.
	(fhandler_dev_tape::dup): Duplicate mt_mtx and mt_evt as necessary.
	(fhandler_dev_tape::fixup_after_fork): New method.
	(fhandler_dev_tape::set_close_on_exec): New method.
@
text
@d85 1
a85 1
  friend void close_all_files ();
@


1.253
log
@	* fhandler.h (fhandler_union): Add missing members corresponding to
	fhandler_fifo and fhandler_netdrive.
@
text
@d639 2
@


1.252
log
@Revert 2005-05-30 close_all_files changes.
* spawn.cc (spawn_guts): When execing, close all files after the child has
synced with us.
@
text
@d1292 1
d1294 2
a1308 1
  char __nodevice[sizeof (fhandler_nodevice)];
@


1.251
log
@* child_info.h (child_info::cygheap_h): Delete.
(child_info::dwProcessId): New field.
* cygheap.cc (init_cheap): Delete.
(dup_now): Ditto.
(cygheap_setup_for_child): Ditto.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_fixup_in_child): Simplify.  Use new "child_copy" function to copy heap
from parent.
(_csbrk): Don't attempt allocation if within cygheap section.  Fix so that more
than one allocation will succeed.
(cygheap_init): Reset possibly-nonzero region to zero.
* cygheap.h (cygheap_setup_for_child): Delete declaration.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_start): Define as an array.
* cygwin.sc: Modernize.  Remove unneeded sections.  Define cygheap here.
* dcrt0.cc (do_exit): Reflect argument change to close_all_files.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
* dtable.h: Ditto.
* fhandler.h: Ditto.
* fork.cc (fork_copy): Call ReadProcessMemory if there is no thread
(indicating that we're execing).
(fork_child): Don't mess with hParent.
(fork_parent): Remove hParent stuff.  It happens earlier now.  Remove call to
cygheap_setup_for_child* stuff.
(fork): Put child_info_stuff in grouped structure.  Issue error if parent
handle is not set.
(child_copy): New function.
* sigproc.cc (child_info::child_info): Put cygheap settings here.  Set parent
handle.
(child_info::~child_info): Close parent handle if it exists.
* spawn.cc (spawn_guts): Reorganize so that ciresrv is allocated at only the
last minute so that cygheap changes are reflected.  Delete cygheap_setup*
calls.
* syscalls.cc (close_all_files): Add an argument to flag when the fd entry
should be released.
* winsup.h (close_all_files): Add an argument to close_all_files declaration.
Declare child_copy.
@
text
@d85 1
a85 1
  friend void close_all_files (bool);
@


1.250
log
@* fhandler.h (fhandler_base::mkdir): New virtual method.
(fhandler_base::rmdir): Ditto.
(fhandler_disk_file:mkdir): New method.
(fhandler_disk_file:rmdir): Ditto.
* dir.cc (mkdir): Implement with fhandlers.
(rmdir): Ditto.
* fhandler.cc (fhandler_base::mkdir): New virtual method.
(fhandler_base::rmdir): Ditto.
(fhandler_disk_file::mkdir): New method.
(fhandler_disk_file::rmdir): Ditto.

fhandler_random.cc: white space.
@
text
@d85 1
a85 1
  friend void close_all_files ();
@


1.249
log
@* fhandler.h (fhandler_cygdrive::seekdir): Delete declaration.
(fhandler_cygdrive::seekdir): Delete.
* fhandler.h (fhandler_cygdrive::iscygdrive_root): Delete method.
(fhandler_cygdrive::telldir): Delete declaration.
* fhandler_disk_file.cc: Remove all uses of fhandler_cygdrive::iscygdrive_root.
(fhandler_disk_file::mkdir): New method.
(fhandler_disk_file::rmdir): Ditto.
(fhandler_cygdrive::telldir): Delete.
@
text
@d349 2
d669 2
@


1.248
log
@	* fhandler_netdrive.cc (fhandler_netdrive::telldir): Remove since it's
	equivalent to fhandler_virtual::telldir now anyway.
	* fhandler.h (class fhandler_netdrive): Remove telldir.
@
text
@a680 1
  bool iscygdrive_root () { return !dev ().minor; }
a683 2
  _off64_t telldir (DIR *);
  void seekdir (DIR *, _off64_t);
@


1.247
log
@	* fhandler.h (class fhandler_netdrive): Add method rewinddir.
	* fhandler_netdrive.cc (struct netdriveinf): New structure to
	store thread arguments.
	(thread_netdrive): Thread handling all potentially blocking
	WNet... calls.
	(create_thread_and_wait): Start and wait for above thread.
	(fhandler_netdrive::exists): Change to call create_thread_and_wait
	instead of calling WNet... function.
	(fhandler_netdrive::readdir): Ditto.  Fix error handling.
	(fhandler_netdrive::rewinddir): New method.
@
text
@a1222 1
  _off64_t telldir (DIR *);
@


1.246
log
@	* autoload.cc (WNetGetResourceParentA): Import.
	(WNetOpenEnumA): Import.
	(WNetEnumResourceA): Import.
	(WNetCloseEnum): Import.
	* fhandler.h (fhandler_netdrive::telldir): Add declaration.
	(fhandler_netdrive::seekdir): Ditto.
	(fhandler_netdrive::closedir): Ditto.
	* fhandler_netdrive.cc: Drop explicit including windows.h.  Include
	winnetwk.h instead of shlwapi.h.  Include dirent.h.
	(fhandler_netdrive::readdir): Implement.
	(fhandler_netdrive::telldir): New method.
	(fhandler_netdrive::seekdir): New method.
	(fhandler_netdrive::closedir): Ditto.
@
text
@d1225 1
@


1.245
log
@	* Makefile.in (DLL_OFILES): Add fhandler_mailslot.o.
	* devices.h (FH_KMSG): Define new device.
	* devices.in: Add "/dev/kmsg" entry.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Handle case FH_KMSG.
	* fhandler.h (class fhandler_mailslot): New class.
	(class select_stuff): Add device_specific_mailslot pointer.
	* fhandler_mailslot.cc: New file.
	* select.cc (peek_mailslot): New function.
	(verify_mailslot): Ditto.
	(struct mailslotinf): New stuct to handle select on mailslots.
	(thread_mailslot): New function.
	(start_thread_mailslot): Ditto.
	(mailslot_cleanup): Ditto.
	(fhandler_mailslot::select_read): New method.
	* syslog.cc (klog_guard): New muto.
	(dev_kmsg): Local mailslot for kernel message device.
	(vklog): New function.
	(klog): Ditto.
	* winsup.h (vklog): Declare.
	(klog): Ditto.
	* include/sys/syslog.h: Define _PATH_KLOG.
@
text
@d1223 3
@


1.244
log
@2005-05-09  Pierre Humblet <pierre.humblet@@ieee.org>

        * fhandler.h (class fhandler_netdrive): New class.
        * fhandler_netdrive.cc (fhandler_netdrive::fhandler_netdrive): New constructor.
        (fhandler_netdrive::exists): New method.
        (fhandler_netdrive::fstat): Ditto.
        (fhandler_netdrive::readdir): Ditto.
        (fhandler_netdrive::open): Ditto.
        * dtable.cc (build_fh_pc): Handle case FH_NETDRIVE.
        * path.cc (isvirtual_dev): Add FH_NETDRIVE.
        (mount_info::conv_to_win32_path): Detect netdrive device and bypass mount
        search for network paths.
@
text
@d363 11
d1288 1
d1342 1
d1352 2
a1353 1
		   device_specific_serial (0) {}
@


1.243
log
@* fhandler.h (dev_console::set_color): Define new function.
(dev_console::set_default_attr): Ditto, moved from fhandler_console.
(dev_console::fillin_info): Ditto.  Accommodate this change throughout this
file.
(fhandler_console::get_win32_attr): Eliminate.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Properly set default
attributes on initialization.
(fhandler_console::open): Set current attributes rather than default color on
open.
(fhandler_console::get_win32_attr): Eliminate.
(dev_console::set_color): New function.  Move get_win32_attr stuff here.
(dev_console::set_default_attr): New function, moved from fhandler_console.
(dev_console::fillin_info): Ditto.
(fhandler_console::char_command): Call set_color to set screen characteristics.
@
text
@d1206 10
@


1.242
log
@* fhandler.cc (fhandler_base::read): Remove unused signal state tweaks.
* fhandler.h (fhandler_pipe::create_selectable): Declare.
(fhandler_fifo::close_one_end): Declare.
* fhandler_fifo.cc (fhandler_fifo::close_one_end): Define.
(fhandler_fifo::open_not_mine): Use close_one_end to close appropriate end of
pipe.
* pinfo.cc (_pinfo::commune_recv): Ditto.
* pipe.cc (fhandler_pipe::create_selectable): Rename from
create_selectable_pipe.  Reorganize.
(fhandler_pipe::create): Use create_selectable.
@
text
@d837 3
a851 1
  WORD get_win32_attr ();
a852 1
  bool fillin_info ();
@


1.241
log
@	* fhandler.h (enum conn_state): Add connect_failed state.
	* fhandler_socket.cc (fhandler_socket::connect): Set connect_state to
	connect_failed when connect failed.
	* poll.cc (poll): Change errno to EINVAL if allocating memory fails,
	according to SUSv3. Add socket descriptors always to except_fds. Test
	for failed connect and set revents flags appropriately.
	* select.cc (set_bits): Set connect_state to connect_failed when
	select indicates failed nonblocking connect.
	(fhandler_dev_null::select_except): Set except_ready to false so that
	/dev/null is not always in except state.
	(peek_socket): Fix bogus conditional.
	(fhandler_socket::select_write): Treat all connect_states except
	unconnected equivalent to return consistent results.
	(fhandler_windows::select_except): Set except_ready to false so that
	/dev/windows is not always in except state.
@
text
@d506 2
a507 1
  bool is_slow () {return 1;}
d529 1
@


1.240
log
@Actually check in files.
@
text
@d53 2
a54 1
  connected = 2
@


1.239
log
@	* fhandler.h (class fhandler_socket): Remove utimes.
	* fhandler_socket.cc (fhandler_socket::utimes): Remove.
@
text
@d498 1
a498 1
  void fixup_after_fork (HANDLE);
a511 1
  HANDLE owner;		// You can't have too many mutexes, now, can you?
@


1.238
log
@* fhandler.h (fhandler_base::utimes_fs): New method.
* fhandler.cc (fhandler_base::utimes): Call utimes_fs if on-disk special file.
* fhandler_disk_file.cc (fhandler_disk_file::utimes): Use utimes_fs.
(fhandler_base::utimes_fs): Handle on-disk device files.
@
text
@a472 1
  int __stdcall utimes (const struct timeval *) __attribute__ ((regparm (2)));
@


1.237
log
@	* autoload.cc (NtQueryVolumeInformationFile): Add.
	* fhandler.cc (fhandler_base::raw_write): Don't touch has_changed flag.
	* fhandler.h (enum change_state): Remove.
	(fhandler_base::status): Revert has_changed to a simple bit.
	(fhandler_base::fstat_helper): Add nAllocSize parameter.  Rename
	ftCreationTime to ftChangeTime.
	* fhandler_disk_file.cc:
	Call fstat_helper with additional
	allocation size throughout.
	(fhandler_base::fstat_by_handle): Use NT native functions to get
	full file information on NT.  Call fstat_helper with LastWriteTime
	as ctime, if ChangeTime is not available.
	(fhandler_base::fstat_by_name): Call fstat_helper with LastWriteTime
	as ctime.
	(fhandler_base::fstat_helper): Add comment. Drop special FAT
	handling since it's useless. Use nAllocSize for st_blocks if available.
	(fhandler_disk_file::touch_ctime): Only touch LastWriteTime.
	(fhandler_disk_file::fchmod): Set has_changed on 9x only.
	(fhandler_disk_file::fchown): Don't set has_changed.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::ftruncate): Ditto.
	(fhandler_disk_file::link): Set has_changed on 9x only and on original
	file only.
	(fhandler_base::open_fs): Don't set has_changed in O_TRUNC case.
	* ntdll.h (FILE_BASIC_INFORMATION): Define.
	(FILE_STANDARD_INFORMATION): Define.
	(FILE_INTERNAL_INFORMATION): Define.
	(FILE_EA_INFORMATION): Define.
	(FILE_ACCESS_INFORMATION): Define.
	(FILE_POSITION_INFORMATION): Define.
	(FILE_MODE_INFORMATION): Define.
	(FILE_ALIGNMENT_INFORMATION): Define.
	(FILE_NAME_INFORMATION): Don't define with arbitrary FileName size.
	(FILE_ALL_INFORMATION): Define.
	(FILE_INFORMATION_CLASS): Add FileAllInformation.
	(FILE_FS_VOLUME_INFORMATION): Define.
	(FS_INFORMATION_CLASS): Define.
	(NtQueryVolumeInformationFile): Define.
@
text
@d274 1
@


1.236
log
@	* dcrt0.cc (dll_crt0_1): Don't call set_cygwin_privileges on 9x.

	* fhandler.h (enum change_state): Add.
	(fhandler_base::status): Add a bit to has_changed flag.
	(fhandler_base::has_changed): Implement with type change_state.
	* fhandler.cc (fhandler_base::raw_write): Accomodate type change
	of has_changed.
	* fhandler_disk_file.cc )fhandler_disk_file::touch_ctime): Also
	touch modification time if has_changed == data_changed.
	(fhandler_disk_file::fchmod): Also open on 9x, otherwise we can't
	touch ctime.  Accomodate type change of has_changed.
	(fhandler_disk_file::fchown): Accomodate type change of has_changed.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::ftruncate): Ditto.
	(fhandler_disk_file::link): Ditto.
	(fhandler_base::open_fs): Ditto.
@
text
@a80 6
enum change_state {
  no_change = 0,
  inode_changed = 1,
  data_changed = 2
};

d103 1
a103 1
    unsigned has_changed	: 2; /* Flag used to set ctime on close. */
d110 1
a110 1
      has_changed (no_change)
d191 1
a191 1
  IMPLEMENT_STATUS_FLAG (change_state, has_changed)
d261 1
a261 1
			      FILETIME ftCreationTime,
d267 1
@


1.235
log
@	* fhandler.h (fhandler_socket::secret_event): Remove.
	(fhandler_socket::af_local_set_secret): New function combining former
	set_connect_secret and get_connect_secret into one function.
	(fhandler_socket::af_local_setblocking): Rename from eid_setblocking.
	(fhandler_socket::af_local_unsetblocking): Rename from
	eid_unsetblocking.
	(fhandler_socket::af_local_set_cred): New method.
	(fhandler_socket::af_local_copy): New method.
	(fhandler_socket::af_local_recv_secret): New method.
	(fhandler_socket::af_local_send_secret): New method.
	(fhandler_socket::af_local_recv_cred): Rename from eid_recv.
	(fhandler_socket::af_local_send_cred): Rename from eid_send.
	(fhandler_socket::af_local_accept): New method.
	(fhandler_socket::af_local_set_sockpair_cred): Rename from
	set_socketpair_eids.
	(fhandler_socket::eid_accept): Remove.
	(fhandler_socket::eid_connect): Remove.
	(fhandler_socket::set_connect_secret): Remove.
	(fhandler_socket::get_connect_secret): Remove.
	(fhandler_socket::create_secret_event): Remove.
	(fhandler_socket::check_peer_secret_event): Remove.
	(fhandler_socket::signal_secret_event): Remove.
	(fhandler_socket::close_secret_event): Remove.
	(fhandler_socket::sec_event_accept): Remove.
	(fhandler_socket::sec_event_connect): Remove.
	* fhandler_socket.cc (secret_event_name): Remove.
	(fhandler_socket::af_local_set_sockpair_cred): Rename from
	set_socketpair_eids.
	(fhandler_socket::af_local_setblocking): Rename from eid_setblocking.
	(fhandler_socket::af_local_unsetblocking): Rename from
	eid_unsetblocking.
	(fhandler_socket::af_local_recv_secret): New function to receive
	AF_LOCAL connect secret over socket itself.
	(fhandler_socket::af_local_send_secret): New function to send AF_LOCAL
	connect secret over socket itself.
	(fhandler_socket::af_local_recv_cred): Rename from eid_recv.
	(fhandler_socket::af_local_send_cred): Rename from eid_send.
	(fhandler_socket::eid_connect): Remove.
	(fhandler_socket::af_local_connect): Take over connect side handling
	of AF_LOCAL secret and credential handshake.
	(fhandler_socket::eid_accept): Remove.
	(fhandler_socket::af_local_accept): New method, take over accept side
	handling of AF_LOCAL secret and credential handshake.
	(fhandler_socket::af_local_set_cred): New method, set eid credentials
	to start values.
	(fhandler_socket::af_local_copy): New method, copy secret and
	credentials to another socket.
	(fhandler_socket::af_local_set_secret): New function combining former
	set_connect_secret and get_connect_secret into one function.
	(fhandler_socket::create_secret_event): Remove.
	(fhandler_socket::signal_secret_event): Remove.
	(fhandler_socket::close_secret_event): Remove.
	(fhandler_socket::check_peer_secret_event): Remove.
	(fhandler_socket::sec_event_connect): Remove.
	(fhandler_socket::sec_event_accept): Remove.
	(fhandler_socket::fixup_after_fork): Drop secret_event handling.
	(fhandler_socket::bind): Call af_local_set_secret.
	(fhandler_socket::connect): Call af_local_set_cred and af_local_connect.
	(fhandler_socket::listen): Call af_local_set_cred.
	(fhandler_socket::accept): Call af_local_copy and af_local_accept on
	accepted socket.
	(fhandler_socket::close): Don't call close_secret_event.
	(fhandler_socket::set_close_on_exec): Don't set secret_event
	inheritance.
	* net.cc (cygwin_getsockopt): Add debug output.
	(socketpair): Call af_local_set_sockpair_cred instead of
	set_socketpair_eids.
	* select.cc (set_bits): Drop AF_LOCAL special handling in case
	of except bit set.
@
text
@d81 6
d109 1
a109 1
    unsigned has_changed	: 1; /* Flag used to set ctime on close. */
d116 1
a116 1
      has_changed (0)
d197 1
a197 1
  IMPLEMENT_STATUS_FLAG (bool, has_changed)
@


1.234
log
@	* fhandler.h (fhandler_socket::eid_connect): Make private.
	(fhandler_socket::set_connect_secret): Ditto.
	(fhandler_socket::get_connect_secret): Ditto.
	(fhandler_socket::create_secret_event): Ditto. Remove secret argument.
	(fhandler_socket::check_peer_secret_event): Ditto.
	(fhandler_socket::signal_secret_event): Make private.
	(fhandler_socket::close_secret_event): Ditto.
	(fhandler_socket::sec_event_accept): New private method.
	(fhandler_socket::sec_event_connect): Ditto.
	(fhandler_socket::af_local_connect): New public method.
	* fhandler_socket.cc: Use 'struct sockaddr' and 'struct sockaddr_in'
	rather than just 'sockaddr' and 'sockaddr_in' throughout.
	(fhandler_socket::eid_connect): Drop AF_LOCAL/SOCK_STREAM test.
	(fhandler_socket::create_secret_event): Remove secret argument.
	Always use connect_secret instead.
	(fhandler_socket::check_peer_secret_event): Ditto.
	(fhandler_socket::sec_event_connect): New method, combining entire
	secret event handshake on connect side.
	(fhandler_socket::af_local_connect): New method, combining secret
	event handshake and eid credential transaction on connect side, to
	be called from select.
	(fhandler_socket::sec_event_accept): New method, combining entire
	secret event handshake on accept side.
	(fhandler_socket::connect): Drop secret, use connect_secret instead.
	Move entire secret event handshake to sec_event_connect.
	(fhandler_socket::accept): Move entire secret event handshake to
	sec_event_accept.
	* select.cc (set_bits): Just call af_local_connect here.
@
text
@d365 1
a365 2
  int connect_secret [4];
  HANDLE secret_event;
d373 10
a382 6
  void eid_setblocking (bool &, bool &);
  void eid_unsetblocking (bool, bool);
  bool eid_recv (void);
  bool eid_send (void);
  void eid_accept (void);
  void eid_connect (void);
d384 2
a385 1
  void set_socketpair_eids (void);
a465 12
 private:
  void set_connect_secret ();
  void get_connect_secret (char*);
  HANDLE create_secret_event ();
  int check_peer_secret_event (struct sockaddr_in *peer);
  void signal_secret_event ();
  void close_secret_event ();
  int sec_event_accept (int, struct sockaddr_in *);
  int sec_event_connect (struct sockaddr_in *peer);
 public:
  int af_local_connect (void);

@


1.233
log
@	* fhandler.h (class cygthread): Remove forward declaration.
@
text
@d379 1
a380 1
  void eid_connect (void);
d461 2
d465 2
a466 2
  HANDLE create_secret_event (int *secret = NULL);
  int check_peer_secret_event (struct sockaddr_in *peer, int *secret = NULL);
d469 5
@


1.232
log
@	* fhandler.h (class cygthread): Forward declare.
	(fhandler_socket::sec_pipe): Remove.
	(fhandler_socket::eid_pipe_name): Remove.
	(fhandler_socket::eid_setblocking): New private method.
	(fhandler_socket::eid_unsetblocking): Ditto
	(fhandler_socket::eid_recv): Ditto
	(fhandler_socket::eid_send): Ditto
	(fhandler_socket::eid_accept): Ditto
	(fhandler_socket::eid_connect): New public method.
	* fhandler_socket.cc (ASYNC_MASK): Move to beginning of file.
	(fhandler_socket::eid_pipe_name): Remove.
	(fhandler_socket::set_socketpair_eids): Move down to fhandler_socket
	methods.
	(fhandler_socket::fhandler_socket): Drop initializing sec_pipe.
	(fhandler_socket::~fhandler_socket): Drop closing sec_pipe.
	(fhandler_socket::eid_setblocking): New method.
	(fhandler_socket::eid_unsetblocking): New method.
	(fhandler_socket::eid_recv): New method.
	(fhandler_socket::eid_send): New method.
	(fhandler_socket::eid_connect): New method.
	(fhandler_socket::eid_accept): New method.
	(fhandler_socket::dup): Drop sec_pipe handling.
	(fhandler_socket::connect): Fix WinSock error handling. Prepare
	eid credential transaction. Call eid_connect on successful connect.
	(fhandler_socket::listen): Drop creating sec_pipe.
	(fhandler_socket::accept): Slightly simplify code. Call eid_accept
	on accepted socket.
	(fhandler_socket::getpeereid): Reshuffle code for readability. Fix
	test for invalid pid.
	* select.cc (set_bits): Call eid_connect on successfully connected
	socket.
@
text
@a39 1
class cygthread;
@


1.231
log
@* child_info.h (fork_info): Use different method to alias variable.
(spawn_info): Ditto.
* cxx.cc (__cxa_guard_acquire): New function (needed for gcc 4.x).
(__cxa_guard_release): Ditto.
* devices.in: Make sure stuff is correctly bracketed (for gcc 4.x).
* devices.cc: Regenerate.
* fhandler.h (fhandler_disk_file::fchmod): Avoid left coercion (for gcc 4.x).
* smallprint.c (__rn): Declare as __fastcall since gcc 4.x complains about use
of regparm, for some reason.
* sync.h (sync::init_lock): Remove.
* sync.cc (sync::init_lock): Ditto.
@
text
@d40 1
a368 1
  HANDLE sec_pipe;
d375 5
a379 1
  char *eid_pipe_name (char *buf);
d381 1
@


1.230
log
@* dir.cc: Rename opendir_* to dirent_* throughout.
(opendir_states): Move and rename.
* fhandler.h (dirent_states): to here.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Use raw readdir when
skipping through entries since it is keeping track of "." and "..".
(fhandler_cygdrive::seekdir): Use fhandler_disk_file::readdir to do everything.
* fhandler_virtual.cc (fhandler_virtual::opendir): Set flag indicating that we
provide .  and ..
(fhandler_virtual::seekdir): Ditto.
(fhandler_virtual::rewinddir): Ditto.
* fhandler_registry.cc (fhandler_registry::rewinddir): Ditto.
@
text
@d144 1
a144 1
  operator DWORD& () {return (DWORD) pc;}
@


1.229
log
@	* fhandler.h (class fhandler_socket): Declare new method
	set_socketpair_eids.
	* fhandler_socket.cc (fhandler_socket::set_socketpair_eids): New method.
	(fhandler_socket::dup): Duplicate sec_pipe if necessary.
	(fhandler_socket::listen): Only create sec_pipe if named pipes are
	available. Initialized sec_peer_pid to 0 as on Linux.
	(fhandler_socket::connect): Only run eid credential transaction if
	named pipes are available.  Fake otherwise. Initialized sec_peer_pid
	to 0 as on Linux.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::close): Move closing sec_pipe handle from here...
	(fhandler_socket::~fhandler_socket): ... to here.
	* net.cc (socketpair): Set eid credentials by calling
	fhandler_socket::set_socketpair_eids() on both socket ends.
	* wincap.h (wincaps::has_named_pipes): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d41 8
@


1.228
log
@	* fhandler.h (class fhandler_base): Declare fixup_mmap_after_fork
	with additional flags parameter.  Change offset parameter to _off64_t.
	(class fhandler_disk_file): Ditto.
	(class fhandler_dev_mem): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::fixup_mmap_after_fork):
	Accomodate new parameters.
	* mmap.cc: Include ntdll.h.
	(class mmap_record): Add flags member.
	(mmap_record::mmap_record): Add flags parameter.
	(mmap_record::get_flags): New method.
	(class map): Add next_anon_addr member to store next anonymous mapping
	address suggestion.
	(map::get_next_anon_addr): New method.
	(map::set_next_anon_addr): New method.
	(mmap64): Don't align offset and length to granularity in case of
	MAP_ANONYMOUS on NT.  Check for already existing mapping only on 9x.
	Call mmap_record::mmap_record with additional flags argument.
	(fhandler_base::fixup_mmap_after_fork): Accomodate new parameters.
	(fhandler_disk_file::mmap): Use NtMapViewOfSection with
	AT_ROUND_TO_PAGE flag for anonymous mappings on NT.  If addr is NULL,
	try to map adjacent to previous mapping.
	(fhandler_disk_file::fixup_mmap_after_fork): Add flags argument.
	Change offset parameter to _off64_t.  Use NtMapViewOfSection to
	re-create anonymous mappings on NT.
	(fixup_mmaps_after_fork): Accomodate new parameters when calling
	fhandler's fixup_mmaps_after_fork function.
	* ntdll.h (AT_ROUND_TO_PAGE): New define.
@
text
@d368 2
d371 1
@


1.227
log
@	* cygwin.din (getpeereid): Export.
	* fhandler.h (class fhandler_socket): Add pipe and id members to
	exchange eid credentials for AF_LOCAL sockets.
	(eid_pipe_name): Declare new method.
	(getpeereid): Ditto.
	* fhandler_socket.cc (fhandler_socket::eid_pipe_name): New method.
	(fhandler_socket::fhandler_socket): Initialize sec_pipe.
	(fhandler_socket::connect): Exchange eid credentials with accepting
	socket process.
	(fhandler_socket::listen): Prepare eid credential transaction.
	(fhandler_socket::accept): Exchange eid credentials with connecting
	socket process.
	(fhandler_socket::close): Close eid credentials pipe if open.
	(fhandler_socket::getpeereid): New method.
	* net.cc (cygwin_getsockopt): Add SO_PEERCRED handling.
	(getpeereid): New function.
	* include/asm/socket.h (SO_PEERCRED): Define.
	* include/cygwin/socket.h (struct ucred): Define new type.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d288 3
a290 2
  virtual bool fixup_mmap_after_fork (HANDLE h, DWORD access, DWORD offset,
				      DWORD size, void *address);
d637 2
a638 2
  bool fixup_mmap_after_fork (HANDLE h, DWORD access, DWORD offset,
			      DWORD size, void *address);
d1059 2
a1060 2
  bool fixup_mmap_after_fork (HANDLE h, DWORD access, DWORD offset,
			      DWORD size, void *address);
@


1.226
log
@	* fhandler.h (fhandler_base::fstat_helper): Declare with additional
	dwVolumeSerialNumber argument.  Drop default values for last three
	arguments.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Pass
	dwVolumeSerialNumber from GetFileInformationByHandle to fstat_helper.
	(fhandler_base::fstat_by_name): Pass pc.volser () to fstat_helper.
	Accomodate dropping default values for last three arguments of
	fstat_helper.
	(fhandler_base::fstat_helper): Add dwVolumeSerialNumber argument.
	Use for st_dev member unless 0 in which case pc.volser () is used.
@
text
@d358 10
d408 1
@


1.225
log
@	* autoload.cc (FindFirstVolumeA): Add.
	(FindNextVolumeA): Add.
	(FindVolumeClose): Add.
	(GetVolumePathNamesForVolumeNameA): Add.
	* fhandler.h (class fhandler_base): Declare new method fsync.
	* fhandler.cc (fhandler_base::fsync): New method.
	* syscalls.cc (fsync): Move functionality into fhandler method fsync.
	Just call this method from here.
	(sync_worker): New static function.
	(sync): Fill with life for NT systems.
	* wincap.h (wincaps::has_guid_volumes): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d253 1
a253 1
			      FILETIME ftCreateionTime,
d256 1
d259 3
a261 3
			      DWORD nFileIndexHigh = 0,
			      DWORD nFileIndexLow = 0,
			      DWORD nNumberOfLinks = 1)
@


1.224
log
@	* fhandler.h (enum query_state): Add query_write_attributes state.
	(fhandler_base::status.query_open): Add a bit to make room for more
	states.
	(class fhandler_base): Declare new method utimes.
	(class fhandler_socket): Ditto.
	(class fhandler_disk_file): Ditto.
	(fhandler_disk_file::fhandler_disk_file): Add constructor with
	path_conv parameter.
	* fhandler.cc (fhandler_base::open): Add query_write_attributes
	handling.
	(fhandler_base::utimes): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Simplify.
	Open file with query_write_attributes instead of query_write_control.
	(fhandler_disk_file::utimes): New method.
	(fhandler_disk_file::fhandler_disk_file): Add constructor with
	path_conv parameter setting pc member immediately.
	* fhandler_socket.cc (fhandler_socket::fchmod): Use new
	fhandler_disk_file constructor.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	(fhandler_socket::link): Ditto.
	(fhandler_socket::utimes): New method.
	* times.cc: Include dtable.h.
	(timeval_to_filetime): Make non-static.
	(utimes): Move functionality into fhandler method utimes. Just call
	this method from here.
	* winsup.h: Simplify declarations of time helper functions.
	(timeval_to_filetime): Add extern declaration.
@
text
@d270 1
@


1.223
log
@	* fhandler.h (class fhandler_base): Declare new method link.
	(class fhandler_socket): Ditto.
	(class fhandler_disk_file): Ditto.
	* fhandler.cc (fhandler_base::open): Add FILE_WRITE_ATTRIBUTES
	to query_write_control access flags.
	(fhandler_base::link): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Don't try to
	open with O_WRONLY since query_write_control includes
	FILE_WRITE_ATTRIBUTES.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::link): New method.  Touch st_ctime on successful
	link.
	* fhandler_socket.cc (fhandler_socket::link): New method.
	* syscalls.cc (link): Move functionality into fhandler method link.
	Just call this method from here.
@
text
@d69 2
a70 1
  query_write_control = 3
d91 1
a91 1
    unsigned query_open         : 2; /* open file without requesting either
d269 1
d443 1
d606 1
d618 1
@


1.222
log
@	* fhandler.h (class fhandler_socket): Declare new methods fchown,
	fchmod and facl.
	* fhandler_socket.cc (fhandler_socket::fstat): Handle AF_LOCAL
	sockets.
	(fhandler_socket::fchmod): New method.
	(fhandler_socket::fchown): New method.
	(fhandler_socket::facl): New method.
@
text
@d267 1
d440 1
d613 1
@


1.221
log
@white space
@
text
@d436 3
@


1.220
log
@	* fhandler.cc (fhandler_base::raw_write): Mark as changed on
	successful write.
	* fhandler.h (fhandler_base::status_flags): Add 'has_changed' flag.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Call
	fhandler_disk_file's own open and close instead of open_fs and
	close_fs.  Mark as changed on success.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::ftruncate): Ditto.
	(fhandler_base::open_fs): Mark as changed when O_TRUNC flag on existing
	file is set.
	(fhandler_disk_file::close): Set st_ctime if has_changed flag is set.
@
text
@d91 1
a91 1
    					read or write access */
d510 1
a510 1
 
@


1.219
log
@* cygthread.h (cygthread::terminate_thread): Reflect return value.
* cygthread.cc (cygthread::detach): Be more careful about ensuring that sigwait
is properly waited for to avoid later missynchronization.
(cygthread::terminate_thread): Return true if thread was actually terminated
and all handles were closed.
* fhandler_base.cc (fhandler_base::raw_read): Use signal_read_state rather than
raw calls to win32 api.
(fhandler_base::read): Ditto.
* fhandler.h (fhandler_pipe::fixup_after_exec): Use method to create read_state
signalling.
(fhandler_pipe::create): Ditto.
* Makefile.in: Make some more files -fomit-frame-pointer.
@
text
@d94 1
d100 2
a101 1
      query_open (no_query), close_on_exec (0), need_fork_fixup (0)
d182 1
@


1.218
log
@	* fhandler.h (fhandler_base::ftruncate): Define new virtual method.
	(fhandler_disk_file::ftruncate): Ditto.
	* fhandler.cc (fhandler_base::ftruncate): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.
	* syscalls.cc (ftruncate64): Move functionality into fhandlers.
	Call fhandler method from here.
@
text
@d196 9
@


1.217
log
@	* fhandler.cc (fhandler_base::get_proc_fd_name): Don't generate
	"device:" entry.
	* fhandler.h (fhandler_socket::open): New method.
	(fhandler_pipe::open): New method.
	* fhandler_proc.cc (fhandler_proc::exists): Return -2 in case of
	/proc/self.
	* fhandler_process.cc (fhandler_process::exists): Return -2 in
	case of symlinks, -3 for pipes and -4 for sockets.
	(fhandler_process::fstat): Handle pipes and sockets.
	(fhandler_process::open): Handle opening /proc/<pid>/fd.
	(fhandler_process::fill_filebuf): Generate empty names for
	non exisiting file descriptors.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Always
	generate "socket:[number]" strings as on Linux.
	(fhandler_socket::open): New method.
	(fhandler_socket::fstat): Always return socket type.
	* path.cc (symlink_info::set): Remove unused second parameter.
	(path_conv::check): Handle pipes and sockets in /proc.
	Set correct device type for AF_LOCAL sockets.
	* pinfo.cc (_pinfo::commune_recv): Generate empty names for
	non exisiting file descriptors.
	(_pinfo::fd): Ditto.
	* pipe.cc (fhandler_pipe::open): New method.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d254 1
d595 1
@


1.216
log
@* path.h (path_conv::set_name): Declare new function.
* path.cc (path_conv::set_name): Define new function.
* fhandler.h (fhandler_dev_null::open): Declare new function.
* fhandler.cc (fhandler_dev_null::open): Define new function.
@
text
@d380 1
d442 1
@


1.215
log
@	* cygheap.h (class cygheap_fdenum): New class to enumerate used
	fhandlers.
	* dtable.h (class dtable): Add cygheap_fdenum as friend class.
	* fhandler.h (fhandler_base::get_proc_fd_name): New virtual method
	to return a name for /proc/<pid>/fd.
	(fhandler_socket::get_proc_fd_name): Ditto.
	(fhandler_pipe::get_proc_fd_name): Ditto.
	(fhandler_virtual::opendir): Make virtual method.
	(fhandler_process::opendir): New method.
	* fhandler.cc (fhandler_base::get_proc_fd_name): New method.
	* fhandler_process.cc: Include ctype.h.
	(PROCESS_FD): Define.
	(process_listing): Add "fd".
	(fhandler_process::exists): Fix comment.  Return 1 in case of "fd"
	directory. Handle files below "fd".
	(fhandler_process::fstat): Drop "self" handling.  Set correct link
	count for directories.
	(fhandler_process::opendir): New method to handle "fd" directory.
	(fhandler_process::readdir): Add "fd" handling.
	(fhandler_process::open): Drop "self" handling.
	(fhandler_process::fill_filebuf): Ditto.  Add "fd" handling.  Fix
	"maps" output string.
	* fhandler_registry.cc (fhandler_registry::fstat): Set correct link
	count for directories.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): New method.
	* path.cc (symlink_info::set): Fix thinko.
	* pinfo.cc (_pinfo::commune_recv): Rename pathbuf to path throughout.
	Drop local path variable in PICOM_FIFO case.  Fix debug output.
	Close handles as early as possible. Add PICOM_FDS and PICOM_FD
	handling.
	(_pinfo::commune_send): Add PICOM_FDS and PICOM_FD handling.
	(_pinfo::fd): New method.
	(_pinfo::fds): New method.
	* pinfo.h (enum picom): Add PICOM_FDS and PICOM_FD.
	(_pinfo::fd): Declare.
	(_pinfo::fds): Declare.
	* pipe.cc (fhandler_pipe::get_proc_fd_name): New method.
@
text
@d954 1
@


1.214
log
@	* autoload.cc (GetModuleFileNameExA): Add.
	(GetModuleInformation): Add.
	(QueryWorkingSet): Add.
	* fhandler.h (fhandler_virtual::get_filebuf): New method.
	* fhandler_proc.cc (PROC_SELF): Define.
	(proc_fhandlers): Change type of self to FH_PROC.
	(fhandler_proc::exists): Return -3 if self.
	(fhandler_proc::fstat): Handle self as symlink.
	(fhandler_proc::fill_filebuf): Handle self.
	* fhandler_process.cc: Include psapi.h.
	(PROCESS_EXENAME): Remove.
	(PROCESS_MAPS): Define.
	(PROCESS_ROOT): Define.
	(PROCESS_EXE): Define.
	(PROCESS_CWD): Define.
	(process_listing): Remove "exename", add "maps, "root", "exe" and
	"cwd" elements.
	(fhandler_process::exists): Return -2 for symlinks.
	(fhandler_process::fstat): Handle symlinks.
	(fill_filebuf): Evaluate pid if pid is 0.  Use exename handling for
	exe.  Handle maps, root and cwd.
	(format_process_maps): New function evaluating "maps".
	* path.cc (symlink_info::set): New method to fill symlink_info
	with data matching virtual symlinks.
	(path_conv::check): Handle virtual symlinks.
	* pinfo.cc (_pinfo::commune_recv): Add PICOM_CWD and PICOM_ROOT
	handling.
	(_pinfo::commune_send): Ditto.
	(_pinfo::root): New function.
	(_pinfo::cwd): New function.
	* pinfo.h (enum picom): Add PICOM_CWD and PICOM_ROOT.
	(_pinfo::root): Declare.
	(_pinfo::cwd): Declare.
@
text
@d221 2
d403 1
d438 1
d1112 1
a1112 1
  DIR *opendir ();
d1171 1
@


1.213
log
@	* fhandler.h (fhandler_disk_file::touch_ctime): Declare.
	* fhandler_disk_file.cc (fhandler_disk_file::touch_ctime): New method
	to set file's ctime.
	(fhandler_disk_file::fchmod): Try opening file for writing first.
	Set file's ctime on success.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
@
text
@d1124 1
@


1.212
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d574 2
@


1.211
log
@	* fhandler.h (fhandler_dev_dsp:~fhandler_dev_dsp): Delete.
	(fhandler_dev_dsp::open_count): Delete.
	(fhandler_dev_dsp::close_audio_in): New method declaration.
	(fhandler_dev_dsp::close_audio_in): Ditto.
	* fhandler_dsp.cc: Add and edit debug_printf throughout.
	(fhandler_dev_dsp::Audio::denyAccess): Delete.
	(fhandler_dev_dsp::Audio::fork_fixup): Ditto.
	(fhandler_dev_dsp::Audio::getOwner): Ditto.
	(fhandler_dev_dsp::Audio::clearOwner): Ditto.
	(fhandler_dev_dsp::Audio::owner_): Ditto.
	(fhandler_dev_dsp::Audio::setformat): Ditto, rename to setconvert.
	(fhandler_dev_dsp::Audio::lock): Ditto, move to queue.
	(fhandler_dev_dsp::Audio::unlock): Ditto.
	(fhandler_dev_dsp::Audio::lock_): Ditto.
	(fhandler_dev_dsp::Audio::bufferIndex_): New member, from Audio_out
	and Audio_in.
	(fhandler_dev_dsp::Audio::pHdr_): Ditto.
	(fhandler_dev_dsp::Audio::wavehdr_): Ditto.
	(fhandler_dev_dsp::Audio::bigwavebuffer_): ditto.
	(fhandler_dev_dsp::Audio::Qisr2app_): Ditto.
	(fhandler_dev_dsp::Audio::setconvert): New method, from old setformat.
	(fhandler_dev_dsp::Audio::queue::lock): New method.
	(fhandler_dev_dsp::Audio::queue::unlock): Ditto.
	(fhandler_dev_dsp::Audio::queue::dellock): Ditto.
	(fhandler_dev_dsp::Audio::queue::isvalid): Ditto.
	(fhandler_dev_dsp::Audio::queue::lock_): New member.
	(fhandler_dev_dsp::Audio::queue::depth1_): Delete.
	(fhandler_dev_dsp::Audio_out::fork_fixup): New method.
	(fhandler_dev_dsp::Audio_out::isvalid): New method.
	(fhandler_dev_dsp::Audio_out::start): Remove arguments.
	(fhandler_dev_dsp::Audio_out::parsewav): Change arguments and set
	internal state.
	(fhandler_dev_dsp::Audio_out::emptyblocks): Delete.
	(fhandler_dev_dsp::Audio_out::Qapp2app_): Ditto.
	(fhandler_dev_dsp::Audio_out::Qisr2app_): Ditto, move to Audio.
	(fhandler_dev_dsp::Audio_out::bufferIndex_): Ditto.
	(fhandler_dev_dsp::Audio_out::pHdr_): Ditto.
	(fhandler_dev_dsp::Audio_out::wavehdr_): Ditto.
	(fhandler_dev_dsp::Audio_out::bigwavefuffer_): Ditto.
	(fhandler_dev_dsp::Audio_out::freq_): New member.
	(fhandler_dev_dsp::Audio_out::bits_): New member.
	(fhandler_dev_dsp::Audio_out::channels_): New member.
	(fhandler_dev_dsp::Audio_in::fork_fixup): New method.
	(fhandler_dev_dsp::Audio_in::isvalid): New method.
	(fhandler_dev_dsp::Audio_in::Qapp2app_): Delete.
	(fhandler_dev_dsp::Audio_in::Qisr2app_): Ditto, move to Audio.
	(fhandler_dev_dsp::Audio_in::bufferIndex_): Ditto.
	(fhandler_dev_dsp::Audio_in::pHdr_): Ditto.
	(fhandler_dev_dsp::Audio_in::wavehdr_): Ditto.
	(fhandler_dev_dsp::Audio_in::bigwavefuffer_): Ditto.
	(fhandler_dev_dsp::Audio::queue::queue): Simplify.
	(fhandler_dev_dsp::Audio::queue::send): Use lock.
	(fhandler_dev_dsp::Audio::queue::query): Do not use depth1_.
	(fhandler_dev_dsp::Audio::queue::recv): Ditto.
	(fhandler_dev_dsp::Audio::Audio): Adapt to new class members.
	(fhandler_dev_dsp::Audio::~Audio): Ditto
	(fhandler_dev_dsp::Audio_out::start): Reorganize.
	(fhandler_dev_dsp::Audio_out::stop): Simplify.
	(fhandler_dev_dsp::Audio_out::init): Reset the queue and clear flag.
	(fhandler_dev_dsp::Audio_out::write): Reorganize to allocate audio_out.
	(fhandler_dev_dsp::Audio_out::buf_info): Use appropriate block size.
	(fhandler_dev_dsp::Audio_out::callback_sampledone): Do not use lock.
	(fhandler_dev_dsp::Audio_out::waitforspace): Simplify.
	(fhandler_dev_dsp::Audio_out::waitforallsent):Ditto.
	(fhandler_dev_dsp::Audio_out::sendcurrent): Reorganize.
	Clear flag before requeuing.
	(fhandler_dev_dsp::Audio_out::parsewav):
	(fhandler_dev_dsp::Audio_in::start): Reorganize.
	(fhandler_dev_dsp::Audio_in::stop): Simplify.
	(fhandler_dev_dsp::Audio_in::queueblock): Ditto.
	Requeue header in case of error.
	(fhandler_dev_dsp::Audio_in::init): Reset the queue and clear flag.
	(fhandler_dev_dsp::Audio_in::waitfordata): Simplify.
	Do not UnprepareHeader if the flag is zero.
	(fhandler_dev_dsp::Audio_in::buf_info): Ditto.
	(fhandler_dev_dsp::Audio_in::callback_blockfull): Do not use lock.
	(fhandler_dev_dsp::open_count): Delete.
	(fhandler_dev_dsp::open): Only check existence, do not allocate
	anything. Set flags appropriately. Create archetype.
	(fhandler_dev_dsp::write): Call archetype as needed. Create audio_out.
	(fhandler_dev_dsp::read): Call archetype as needed. Create audio_in.
	(fhandler_dev_dsp::close): Call archetype as needed.
	Call close_audio_in and close_audio_out.
	(fhandler_dev_dsp::close_audio_in): New function.
	(fhandler_dev_dsp::close_audio_out): New function.
	(fhandler_dev_dsp::dup): Use archetypes.
	(fhandler_dev_dsp::ioctl): Call archetype as needed. Reorganize for
	new structures.
	(fhandler_dev_dsp::fixup_after_fork): Call archetype as needed.
	(fhandler_dev_dsp::fixup_after_exec): Call archetype as needed.
	Clear audio_in and audio_out.
@
text
@d1219 1
a1219 1
  bool saw_error;
d1230 2
d1234 1
a1234 1
		 fh (in_fh), saw_error (false), windows_handle (false),
@


1.210
log
@	* fhandler.h (class fhandler_dev_raw): Remove is_writing flag.
	Remove declaration of writebuf.
	(class fhandler_dev_floppy): Remove declaration of close.
	* fhandler_floppy.cc (fhandler_dev_floppy::close): Delete.
	(fhandler_dev_floppy::lseek): Remove calls to writebuf.  Set
	eom_detected to false after successful seek.
	* fhandler_raw.cc (fhandler_dev_raw::writebuf): Delete.
	(fhandler_dev_raw::raw_read): Remove calls to writebuf.
	(fhandler_dev_raw::raw_write): Always invalidate buffer.
@
text
@a1071 1
  static int open_count; // per process
a1075 1
  ~fhandler_dev_dsp();
d1087 3
@


1.209
log
@* dtable.cc (dtable::find_fifo): Release lock after fifo found (still racy).
* fhandler.h (fhandler_fifo::get_io_handle): New fifo-specific method.
* fhandler_fifo.cc (fhandler_fifo::close): Close output_handle only if it is
open.
(fhandler_fifo::open_not_mine): Reorganize slightly.  Don't call _pinfo methods
when the fifo is owned by me or suffer dtable lock_cs deadlock.
(fhandler_fifo::open): Call open_not_mine first, otherwise open myself
(racy).
* pinfo.cc (_pinfo::commune_recv): Duplicate fifo handles here in requesting
processes arena to avoid one potential race (of many).
(_pinfo::commune_send): Move all PICOM_FIFO code under one case statement.
* thread.cc (pthread::init_mainthread) Use existing hMainProc handle rather
than calling GetCurrentProcess.
@
text
@a484 1
    unsigned is_writing      : 1;
d487 1
a487 1
      eom_detected (0), eof_detected (0), lastblk_to_read (0), is_writing (0)
a493 1
  IMPLEMENT_STATUS_FLAG (bool, is_writing)
a497 1
  virtual int writebuf (void);
a534 1
  virtual int close (void);
@


1.208
log
@	* fhandler.h (class fhandler_socket): Add "owner" status flag.
	* fhandler_socket.cc (wait): Take flag parameter to take FD_OOB into
	account.  Don't wait infinitely.
	(fhandler_socket::recvfrom): Also wait for FD_OOB if socket owner.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	(fhandler_socket::fcntl): Set owner status flag if F_SETOWN with own
	pid is called.
@
text
@d327 1
d458 1
@


1.207
log
@	Revert code reversion from 2004-04-03.  So, revert to async I/O again.
	* fhandler.h (status): Add "closed" flag.
	(prepare): New method declaration.
	(wait): Ditto.
	(release): Ditto.
	* fhandler_socket.cc: Don't include wsock_event.h.
	(fhandler_socket::prepare): New method, moved from wsock_event.
	(fhandler_socket::wait): Ditto.
	(fhandler_socket::release): New method.
	(fhandler_socket::recvfrom): Simplify loop.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc: Don't include wsock_event.h.
	(wsock_event::prepare): Remove.
	(wsock_event::wait): Ditto.
	* wsock_event.h: Remove.
@
text
@d344 1
d349 1
a349 1
      closed (0), connect_state (unconnected)
d354 1
a354 1
  int wait (HANDLE event);
d367 1
@


1.206
log
@	* fhandler_disk_file.cc (fhandler_base::open_fs): Change
	set_file_attribute call to indicate that NT security isn't used.
	(fhandler_disk_file::fchmod): Rearrange to isolate 9x related
	statements.
	Do not set FILE_ATTRIBUTE_SYSTEM.
	(fhandler_disk_file::fchown): Check noop case first.
	* fhandler.cc (fhandler_base::open9x): Remove ntsec related statements.
	(fhandler_base::set_name): Do not set namehash.
	* fhandler.h (fhandler_base::get_namehash): Compute and set namehash if
	needed.
	* syscalls.cc (access): Verify that fh is not NULL. Do not set PC_FULL.
	(chmod): Ditto.
	(chown_worker): Ditto.
	(stat_worker): Ditto. Verify if the path exists.
@
text
@d343 1
d348 1
a348 1
      connect_state (unconnected)
d352 4
d365 1
@


1.205
log
@	* errno.cc (errmap): Handle ERROR_IO_PENDING.
	* fhandler.cc (fhandler_base::open): Make tape I/O asynchronous.
	* fhandler.h (class fhandler_dev_tape): Add mt_evt member.
	* fhandler_tape.cc (mtinfo_drive::initialize): Initialize async_writes.
	(mtinfo_drive::close): Handle async writes.
	(mtinfo_drive::read): Add mt_evt parameter.  Use overlapped I/O.
	(mtinfo_drive::async_wait): New function.
	(mtinfo_drive::write): Add mt_evt parameter.  Use overlapped I/O.
	Handle async writes.
	(mtinfo_drive::_set_pos): Handle async writes.
	(mtinfo_drive::set_partition): Ditto.
	(mtinfo_drive::prepare): Ditto.
	(mtinfo_drive::get_status): Drop useless "else".  Handle async_writes
	flag.
	(mtinfo_drive::set_options): Handle async_writes flags.
	(fhandler_dev_tape::close): Close mt_evt handle.
	(fhandler_dev_tape::raw_read): Create mt_evt handle and use in call
	to mtinfo_drive::read.
	(fhandler_dev_tape::raw_write): Create mt_evt handle and use in call
	to mtinfo_drive::write.
	* mtinfo.h (MTINFO_VERSION): Bump.
	(enum dirty_state): Add async_write_pending state.
	(class mtinfo_drive): Add OVERLAPPED struct "ov".  Add async_writes
	flag.
	(mtinfo_drive::async_wait): Add declaration.
	(mtinfo_drive::read): Add mt_evt parameter.
	(mtinfo_drive::write): Ditto.

	* registry.cc (load_registry_hive): Call enable_restore_privilege
	instead of set_process_privilege.
@
text
@d220 1
a220 1
  __ino64_t get_namehash () { return namehash; }
@


1.204
log
@	* autoload.cc (NtCreateFile): Add.
	* dir.cc (mkdir): Change set_file_attribute call to indicate that
	NT security isn't used.
	* fhandler.cc (fhandler_base::open_9x): New method, created from
	fhandler_base::open.
	(fhandler_base::open): Rearrange to use NtCreateFile instead of
	CreateFile.
	* fhandler.h (enum query_state): Redefine query_null_access to
	query_stat_control.  query_null_access isn't allowed in NtCreateFile.
	(fhandler_base::open_9x): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use
	query_stat_control first, query_read_control if that fails.
	(fhandler_disk_file::fchmod): Call enable_restore_privilege before
	trying to open for query_write_control.  Don't fall back to
	opening for query_read_control.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl):  Only request restore privilege and query
	access necessary for given cmd.
	* fhandler_raw.cc (fhandler_dev_raw::open): Call fhandler_base::open
	instead of opening device here.
	* ntdll.h (NtCreateFile): Declare.
	* path.cc (symlink_worker): Change set_file_attribute call to indicate
	that NT security isn't used.
	* sec_acl.cc (getacl): Fix bracketing.
	* sec_helper.cc (enable_restore_privilege): New function.
	* security.cc (str2buf2uni_cat): New function.
	(write_sd): Don't request restore permission here.
	* security.h (set_process_privileges): Drop stale declaration.
	(str2buf2uni): Declare.
	(str2buf2uni_cat): Declare.
	(enable_restore_privilege): Declare.
	* syscalls.cc (fchown32): Return immediate success on 9x.
@
text
@d538 1
@


1.203
log
@	* fhandler.cc (fhandler_base::open): Simplify access evaluation
	expression.
	(fhandler_base::facl): New method.
	* fhandler.h: Declare facl method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): New method.
	* fhandler_virtual.cc (fhandler_virtual::facl): New method.
	* sec_acl.cc: Remove forward declaration for aclsort32 and acl32.
	(setacl): Remove static.  Add and use handle parameter.
	(getacl): Ditto.
	(acl_worker): Reorganize to call fhandler's facl method eventually.
	(facl32): Ditto.
	* security.cc (get_nt_object_security): Remove static.
	* security.h: Add extern declarations for get_nt_object_security,
	aclsort32, acl32, getacl and setacl.


	Apply missing syscalls.cc patch and ChangeLog of previous check in.
	* syscalls.cc (chown_worker): Reorganize to call fhandler's fchown
	method eventually.
	(fchown): Ditto.
@
text
@d66 2
a67 2
  query_null_access = 1,
  query_read_control = 2,
d229 1
@


1.202
log
@	* fhandler.cc (fhandler_base::open): Accomodate query_write_control
	query_state.
	(fhandler_base::fchown): New method.
	* fhandler.h: Declare fchown method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	(enum query_state): Add query_write_control.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Set query_state
	to query_write_control.  Only remove FILE_ATTRIBUTE_READONLY if not
	setting security descriptor.
	(fhandler_disk_file::fchown): New method.
	* fhandler_virtual.cc (fhandler_virtual::fchown): New method.
	* sec_acl.cc (setacl): Call write_sd with additional handle attribute.
	* security.cc (write_sd): Take handle argument.  Only request owner
	if getting SE_RESTORE_NAME privilege failed.  Only open file if
	NtSetSecurityObject failed or handle is NULL.
	(set_nt_attribute): Call write_sd with additional handle attribute.
	* security.h (write_sd): Declare with additional handle argument.
@
text
@d38 1
d249 1
d576 1
d1111 1
@


1.201
log
@	* dir.cc (mkdir): Call set_file_attribute with additional handle
	argument.
	* fhandler.cc (fhandler_base::fchmod): New method.
	* fhandler.h: Declare fchmod method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): New method.
	(fhandler_base::open_fs): Call set_file_attribute with additional
	handle argument.
	* fhandler_virtual.cc (fhandler_virtual::fchmod): New method.
	* path.cc (symlink_worker): Call set_file_attribute with additional
	handle argument.
	* security.cc (get_nt_object_security): New function.
	(get_nt_object_attribute): Call get_nt_object_security.
	(set_nt_attribute): Add handle argument.  Call get_nt_object_security
	first, read_sd only if that fails.
	(set_file_attribute): Add handle argument.
	* security.h (set_file_attribute): Declare with additional handle
	argument.
	* syscalls.cc (stat_suffixes): Move to beginning of file.
	(chown_worker): Call set_file_attribute with additional handle argument.
	(chmod): Reorganize to call fhandler's fchmod method eventually.
	(fchmod): Ditto.
@
text
@d65 3
a67 2
  query_read_control = 1,
  query_null_access = 2
d247 1
d573 1
d1107 1
@


1.200
log
@	* winsup.h (IMPLEMENT_STATUS_FLAG): New macro to define status flag
	accessor methods unambiguously.
	* fhandler.h: Use IMPLEMENT_STATUS_FLAG throughout where possible.
	* fhandler_termios.cc (fhandler_termios::tcinit): Call corrected
	accessor for initialized status flag.
	* mtinfo.h (class mtinfo_drive): Use IMPLEMENT_STATUS_FLAG throughout.
	* path.cc (fs_info::update): Remove duplicate call to flags().
	* path.h (struct fs_info): Use IMPLEMENT_STATUS_FLAG where possible.
	(path_conv::is_auto_device): Fix spacing.
	* tty.h (class tty_min): Use IMPLEMENT_STATUS_FLAG throughout.
@
text
@d245 1
d570 1
d1103 1
@


1.199
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@a156 3
  bool wbinset () const { return status.wbinset; }
  bool rbinset () const { return status.rbinset; }

d168 9
a176 20
  bool nohandle () const { return status.nohandle; }
  void nohandle (bool x) { status.nohandle = x; }

  bool uninterruptible_io () const { return status.uninterruptible_io; }
  void uninterruptible_io (bool b) { status.uninterruptible_io = b; }

  bool append_mode () const { return status.append_mode; }
  void append_mode (bool b) { status.append_mode = b; }

  bool did_lseek () const { return status.did_lseek; }
  void did_lseek (bool b) { status.did_lseek = b; }

  query_state query_open () const { return (query_state) status.query_open; }
  void query_open (query_state val) { status.query_open = val; }

  bool close_on_exec () const { return status.close_on_exec; }
  void close_on_exec (bool b) { status.close_on_exec = b; }

  bool need_fork_fixup () const { return status.need_fork_fixup; }
  void need_fork_fixup (bool b) { status.need_fork_fixup = b; }
d351 4
a354 13
  bool async_io () const { return status.async_io; }
  void async_io (bool b) { status.async_io = b; }

  bool saw_shutdown_read () const { return status.saw_shutdown_read; }
  bool saw_shutdown_write () const { return status.saw_shutdown_write; }

  void saw_shutdown_read (bool b) { status.saw_shutdown_read = b;}
  void saw_shutdown_write (bool b) { status.saw_shutdown_write = b;}

  conn_state connect_state () const
	{ return (conn_state) status.connect_state; }
  void connect_state (conn_state newstate)
	{ status.connect_state = newstate; }
d476 4
a479 11
  bool eom_detected () const { return status.eom_detected; }
  void eom_detected (bool b) { status.eom_detected = b; }

  bool eof_detected () const { return status.eof_detected; }
  void eof_detected (bool b) { status.eof_detected = b; }

  bool lastblk_to_read () const { return status.lastblk_to_read; }
  void lastblk_to_read (bool b) { status.lastblk_to_read = b; }

  bool is_writing () const { return status.is_writing; }
  void is_writing (bool b) { status.is_writing = b; }
@


1.198
log
@	* fhandler.h (class fhandler_dev_raw): Move status bits into protected
	bitfield struct type status_flags.  Drop unused has_written bit.
	Add accessor methods.
	(fhandler_dev_raw::clear): Remove.
	(fhandler_dev_raw::reset_devbuf): Remove.
	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Use accessor method
	for is_writing.
	* fhandler_raw.cc: Use status accessor methods throughout.
	(fhandler_dev_raw::clear): Remove.
	(fhandler_dev_raw::fhandler_dev_raw): Drop clear call.
	(fhandler_dev_raw::~fhandler_dev_raw): Ditto.
	* fhandler_tape.cc: Use mtinfo::status accessor methods throughout.
	(mtinfo_drive::close): Fix conditional to enable BSD semantics
	correctly.
	(mtinfo_drive::get_status): Rename from mtinfo_drive::status.
	* mtinfo.h (class mtinfo_drive): Move status bits into private bitfield
	struct type status_flags.  Add accessor methods.
	Rename status method to get_status.
@
text
@d39 1
a39 1
enum connect_state
d80 1
a80 2
    unsigned no_handle          : 1; /* No handle associated with fhandler. */
    unsigned async_io           : 1; /* async I/O */
d83 1
a83 1
    unsigned lseeked            : 1; /* set when lseek is called as a flag that
a86 1
    unsigned encoded            : 1; /* native path is encoded */
d94 3
a96 4
      rbinary (0), rbinset (0), wbinary (0), wbinset (0), no_handle (0),
      async_io (0), uninterruptible_io (0), append_mode (0), lseeked (0),
      encoded (0), query_open (no_query), close_on_exec (0),
      need_fork_fixup (0)
a147 3
  bool get_async () { return status.async_io; }
  void set_async (int x) { status.async_io = (x ? 1 : 0); }

d154 2
a155 5
  bool get_w_binary () { return status.wbinset ? status.wbinary : 1; }
  bool get_r_binary () { return status.rbinset ? status.rbinary : 1; }

  bool get_w_binset () { return status.wbinset; }
  bool get_r_binset () { return status.rbinset; }
d157 2
a158 4
  void set_w_binary (int b) {status.wbinary = (b ? 1 : 0); status.wbinset = 1;}
  void set_r_binary (int b) {status.rbinary = (b ? 1 : 0); status.rbinset = 1;}
  void clear_w_binary () { status.wbinary = 0; status.wbinset = 0; }
  void clear_r_binary () { status.rbinary = 0; status.rbinset = 0; }
d160 2
a161 2
  bool get_nohandle () { return status.no_handle; }
  void set_nohandle (bool x) { status.no_handle = x; }
d171 21
d194 1
a194 5
  bool get_r_no_interrupt () { return status.uninterruptible_io; }
  void set_r_no_interrupt (bool b) { status.uninterruptible_io = b; }

  bool get_close_on_exec () { return status.close_on_exec; }
  void set_close_on_exec_flag (int b) { status.close_on_exec = (b ? 1 : 0); }
d199 1
a199 1
      return get_close_on_exec () ? &sec_all_nih : &sec_all;
d201 1
a201 1
      return get_close_on_exec () ? &sec_none_nih : &sec_none;
a203 11
  void set_did_lseek (bool b) { status.lseeked = b; }
  bool get_did_lseek () { return status.lseeked; }

  bool get_need_fork_fixup () { return status.need_fork_fixup; }
  void set_need_fork_fixup () { status.need_fork_fixup = 1; }

  bool get_encoded () { return status.encoded;}
  void set_encoded () { status.encoded = 1;}

  virtual void set_close_on_exec (int val);

a207 3
  bool get_append_p () { return status.append_mode; }
  void set_append_p () { status.append_mode = 1; }

a211 3
  query_state get_query_open () { return (query_state) status.query_open; }
  void set_query_open (query_state val) { status.query_open = val; }

d348 4
a351 3
    unsigned sock_saw_shut_rd      : 1; /* Socket saw a SHUT_RD */
    unsigned sock_saw_shut_wr      : 1; /* Socket saw a SHUT_WR */
    unsigned had_connect_or_listen : 2;
d354 2
a355 2
      sock_saw_shut_rd (0), sock_saw_shut_wr (0),
      had_connect_or_listen (unconnected)
d365 5
a369 2
  bool saw_shutdown_read () const { return status.sock_saw_shut_rd; }
  bool saw_shutdown_write () const { return status.sock_saw_shut_wr; }
d371 2
a372 2
  void set_shutdown_read () { status.sock_saw_shut_rd = 1;}
  void set_shutdown_write () { status.sock_saw_shut_wr = 1;}
d374 4
a377 10
  bool is_unconnected () const
  	{ return status.had_connect_or_listen == unconnected; }
  bool is_connect_pending () const
    { return status.had_connect_or_listen == connect_pending; }
  bool is_connected () const
  	{ return status.had_connect_or_listen == connected; }
  void set_connect_state (connect_state newstate)
	{ status.had_connect_or_listen = newstate; }
  connect_state get_connect_state () const
	{ return (connect_state) status.had_connect_or_listen; }
d404 1
a404 1
  void set_close_on_exec (int val);
d443 1
a443 1
  void set_close_on_exec (int val);
d499 1
d501 2
a502 1
  bool eom_detected () { return status.eom_detected; }
d504 2
a505 1
  bool eof_detected () { return status.eof_detected; }
d507 2
a508 1
  bool lastblk_to_read () { return status.lastblk_to_read; }
a509 1
  bool is_writing () { return status.is_writing; }
d697 1
a697 1
    set_need_fork_fixup ();
d843 1
a843 1
  void set_close_on_exec (int val);
d879 1
a879 1
  void set_close_on_exec (int val);
d940 1
a940 1
  void set_close_on_exec (int val);
d1067 1
a1067 1
  void set_close_on_exec (int val);
@


1.197
log
@	* fhandler.h (fhandler_base::status): Declare private.
	(fhandler_base::open_status): Ditto.
	(class fhandler_socket): Move status bits into private bitfield struct
	type status_flags.  Change accessor methods appropriately.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	above status bit changes.
	* tty.h: Remove status bit enumerator.
	(TTYISSETF): Remove.
	(TTYSETF): Remove.
	(TTYCLEARF): Remove.
	(TTYCONDSETF): Remove.
	(tty_min::status): Define as private bitfield struct type status_flags.
	Add appropriate accessor methods.
	* fhandler_console.cc: Use tty_min::status accessor methods throughout.
	* fhandler_termios.cc: Ditto.
	* winsup.h (__ISSETF): Remove.
	(__SETF): Remove.
	(__CLEARF): Remove.
	(__CONDSETF): Remove.
@
text
@d500 20
a519 5
  int eom_detected    : 1;
  int eof_detected    : 1;
  int lastblk_to_read : 1;
  int is_writing      : 1;
  int has_written     : 1;
a520 1
  virtual void clear (void);
a531 7

  inline void reset_devbuf (void)
    {
      devbufstart = devbufend = 0;
      eom_detected = eof_detected = 0;
      lastblk_to_read = is_writing = has_written = 0;
    }
@


1.196
log
@	* fhandler.cc (fhandler_base::write): Use bool parameter in calls to
	set_did_lseek.
	(fhandler_base::fhandler_base): Accomodate new status and open_status
	constructor.
	* fhandler.h: Remove status bit enumerator.
	(FHDEVN): Remove.
	(FHISSETF): Remove.
	(FHSETF): Remove.
	(FHCLEARF): Remove.
	(FHCONDSETF): Remove.
	(FHSTATOFF): Remove.
	(UNCONNECTED, CONNECT_PENDING, CONNECTED): Substitute by enum
	connect_state.
	(fhandler_base::status): Define as bitfield struct type status_flags.
	Remove unused flags entirely.  Accomodate all status access methods.
	(open_status): Define as bitfield struct type status_flags.
	(fhandler_socket): Move socket related status bits to here.  Redefine
	had_connect_or_listen to be part of these status bits.  Accomodate
	related access methods.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Use pc.issymlink
	instead of dropped method get_symlink_p.
	(fhandler_base::open_fs): Remove setting dropped status flags.
	* fhandler_socket.cc: Use values from enum connect_state throughout.
	(fhandler_socket::fhandler_socket): Initialize status bits.
	* fhandler_virtual.cc (fhandler_virtual::open): Remove setting dropped
	status flags.
	* net.cc: Use values from enum connect_state throughout.
	* select.cc: Ditto.
	* shared_info.h: Protect struct console_state using _FHANDLER_H_
	instead of FHDEVN.
@
text
@a73 1
 protected:
d94 1
a94 1
    public:
d357 11
a367 3
  unsigned sock_saw_shut_rd      : 1; /* Socket saw a SHUT_RD */
  unsigned sock_saw_shut_wr      : 1; /* Socket saw a SHUT_WR */
  unsigned had_connect_or_listen : 2;
d375 2
a376 2
  bool saw_shutdown_read () const {return sock_saw_shut_rd;}
  bool saw_shutdown_write () const {return sock_saw_shut_wr;}
d378 2
a379 2
  void set_shutdown_read () { sock_saw_shut_rd = 1;}
  void set_shutdown_write () { sock_saw_shut_wr = 1;}
d381 2
a382 1
  bool is_unconnected () const { return had_connect_or_listen == unconnected; }
d384 3
a386 2
    { return had_connect_or_listen == connect_pending; }
  bool is_connected () const { return had_connect_or_listen == connected; }
d388 1
a388 1
    { had_connect_or_listen = newstate; }
d390 1
a390 1
    { return (connect_state) had_connect_or_listen; }
@


1.195
log
@	* fhandler.cc (fhandler_base::open): Set query access mode according
	to query_open setting.
	(fhandler_base::fhandler_base): Initialize query_open.
	* fhandler.h (FH_QUERYOPEN): Drop.
	(enum query_state): Add.
	(class fhandler_base): Add query_open member.
	(fhandler_base::get_query_open): Redefine to use query_open.
	(fhandler_base::set_query_open): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Remove O_DIROPEN
	from open_flags since it's added in open_fs anyway.  Remove
	query_open_already.  Use new query_open settings.  Rearrange slightly.
	(fhandler_base::fstat_helper): Add get_io_handle as parameter to
	get_file_attribute.
	* security.cc (get_nt_object_attribute): Make returning an int.
	Return -1 on error, 0 otherwise.
	(get_file_attribute): Take an object handle as argument. Move down
	to allow calling get_nt_object_attribute in case a non-NULL handle
	is given.
	* security.h (get_file_attribute): Add handle to argument list.
	* syscalls.cc (chown_worker): Accomodate new definition of
	get_file_attribute.
@
text
@a13 36
enum
{
  FH_RBINARY	= 0x00001000,	/* binary read mode */
  FH_WBINARY	= 0x00002000,	/* binary write mode */
  FH_CLOEXEC	= 0x00004000,	/* close-on-exec */
  FH_RBINSET	= 0x00008000,	/* binary read mode has been explicitly set */
  FH_WBINSET	= 0x00010000,	/* binary write mode has been explicitly set */
  FH_APPEND	= 0x00020000,	/* always append */
  FH_ASYNC	= 0x00040000,	/* async I/O */
  FH_ENC	= 0x00080000,	/* native path is encoded */
  FH_SYMLINK	= 0x00100000,	/* is a symlink */
  FH_EXECABL	= 0x00200000,	/* file looked like it would run:
				 * ends in .exe or .bat or begins with #! */
  FH_LSEEKED	= 0x00400000,	/* set when lseek is called as a flag that
				 * _write should check if we've moved beyond
				 * EOF, zero filling or making file sparse
				   if so. */
  FH_NOHANDLE	= 0x00800000,	/* No handle associated with fhandler. */
  FH_NOEINTR	= 0x01000000,	/* Set if I/O should be uninterruptible. */
  FH_FFIXUP	= 0x02000000,	/* Set if need to fixup after fork. */
  FH_LOCAL	= 0x04000000,	/* File is unix domain socket */
  FH_SHUTRD	= 0x08000000,	/* Socket saw a SHUT_RD */
  FH_SHUTWR	= 0x10000000,	/* Socket saw a SHUT_WR */
  FH_ISREMOTE	= 0x10000000,	/* File is on a remote drive */
  FH_DCEXEC	= 0x20000000,	/* Don't care if this is executable */
  FH_HASACLS	= 0x40000000,	/* True if fs of file has ACLS */
};

#define FHDEVN(n)	(n)
#define FHISSETF(x)	__ISSETF (this, x, FH)
#define FHSETF(x)	__SETF (this, x, FH)
#define FHCLEARF(x)	__CLEARF (this, x, FH)
#define FHCONDSETF(n, x) __CONDSETF(n, this, x, FH)

#define FHSTATOFF	0

a26 4
#define UNCONNECTED     0
#define CONNECT_PENDING 1
#define CONNECTED       2

d39 7
d73 1
d75 29
a103 2
  DWORD status;
  unsigned query_open : 2;
a119 1
  DWORD open_status;
d152 2
a153 2
  bool get_async () { return FHISSETF (ASYNC); }
  void set_async (int x) { FHCONDSETF (x, ASYNC); }
d161 2
a162 2
  bool get_w_binary () { return FHISSETF (WBINSET) ? FHISSETF (WBINARY) : 1; }
  bool get_r_binary () { return FHISSETF (RBINSET) ? FHISSETF (RBINARY) : 1; }
d164 2
a165 2
  bool get_w_binset () { return FHISSETF (WBINSET); }
  bool get_r_binset () { return FHISSETF (RBINSET); }
d167 4
a170 4
  void set_w_binary (int b) { FHCONDSETF (b, WBINARY); FHSETF (WBINSET); }
  void set_r_binary (int b) { FHCONDSETF (b, RBINARY); FHSETF (RBINSET); }
  void clear_w_binary () {FHCLEARF (WBINARY); FHCLEARF (WBINSET); }
  void clear_r_binary () {FHCLEARF (RBINARY); FHCLEARF (RBINSET); }
d172 2
a173 2
  bool get_nohandle () { return FHISSETF (NOHANDLE); }
  void set_nohandle (int x) { FHCONDSETF (x, NOHANDLE); }
a175 1
  DWORD get_open_status () {return open_status;}
d179 2
a180 2
	       | ((open_status & (FH_WBINARY | FH_RBINARY)
		   ? O_BINARY : O_TEXT)));
d185 2
a186 2
  bool get_r_no_interrupt () { return FHISSETF (NOEINTR); }
  void set_r_no_interrupt (bool b) { FHCONDSETF (b, NOEINTR); }
d188 2
a189 2
  bool get_close_on_exec () { return FHISSETF (CLOEXEC); }
  int set_close_on_exec_flag (int b) { return FHCONDSETF (b, CLOEXEC); }
d199 2
a200 2
  void set_did_lseek (int b = 1) { FHCONDSETF (b, LSEEKED); }
  bool get_did_lseek () { return FHISSETF (LSEEKED); }
d202 2
a203 2
  bool get_need_fork_fixup () { return FHISSETF (FFIXUP); }
  void set_need_fork_fixup () { FHSETF (FFIXUP); }
d205 2
a206 2
  bool get_encoded () { return FHISSETF (ENC);}
  void set_encoded () { FHSETF (ENC);}
d214 2
a215 21
  bool get_symlink_p () { return FHISSETF (SYMLINK); }
  void set_symlink_p (int val) { FHCONDSETF (val, SYMLINK); }
  void set_symlink_p () { FHSETF (SYMLINK); }

  bool get_socket_p () { return FHISSETF (LOCAL); }
  void set_socket_p (int val) { FHCONDSETF (val, LOCAL); }
  void set_socket_p () { FHSETF (LOCAL); }

  bool get_execable_p () { return FHISSETF (EXECABL); }
  void set_execable_p (executable_states val)
  {
    FHCONDSETF (val == is_executable, EXECABL);
    FHCONDSETF (val == dont_care_if_executable, DCEXEC);
  }
  void set_execable_p () { FHSETF (EXECABL); }
  bool dont_care_if_execable () { return FHISSETF (DCEXEC); }
  bool exec_state_isknown () { return FHISSETF (DCEXEC) || FHISSETF (EXECABL); }

  bool get_append_p () { return FHISSETF (APPEND); }
  void set_append_p (int val) { FHCONDSETF (val, APPEND); }
  void set_append_p () { FHSETF (APPEND); }
d221 2
a222 2
  query_state get_query_open () { return (query_state) query_open; }
  void set_query_open (query_state val) { query_open = val; }
d358 3
a360 1
  int had_connect_or_listen;
d368 2
a369 2
  bool saw_shutdown_read () const {return FHISSETF (SHUTRD);}
  bool saw_shutdown_write () const {return FHISSETF (SHUTWR);}
d371 2
a372 2
  void set_shutdown_read () {FHSETF (SHUTRD);}
  void set_shutdown_write () {FHSETF (SHUTWR);}
d374 8
a381 5
  bool is_unconnected () const {return had_connect_or_listen == UNCONNECTED;}
  bool is_connect_pending () const {return had_connect_or_listen == CONNECT_PENDING;}
  bool is_connected () const {return had_connect_or_listen == CONNECTED;}
  void set_connect_state (int newstate) { had_connect_or_listen = newstate; }
  int get_connect_state () const { return had_connect_or_listen; }
@


1.194
log
@	* fhandler.h (class fhandler_socket): Remove has_been_closed member.
	* fhandler_socket.cc (fhandler_socket::recvfrom): Revert to
	overlapped I/O.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (wsock_event::prepare): Ditto.
	(wsock_event::wait): Ditto.  Evaluate overlapped result also after
	calling CancelIo (thanks to Patrick Samson <p_samson@@yahoo.com>).
	(wsock_event::release): Remove.
	* wsock_event.h: Revert to overlapped I/O.
@
text
@a39 2
  FH_QUERYOPEN	= 0x80000000,	/* open file without requesting either read
				   or write access */
d96 6
d108 1
d247 2
a248 2
  bool get_query_open () { return FHISSETF (QUERYOPEN); }
  void set_query_open (bool val) { FHCONDSETF (val, QUERYOPEN); }
@


1.193
log
@	* fhandler.h (class fhandler_socket): Add has_been_closed member.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	has_been_closed to 0.
	(fhandler_socket::recvfrom): Use new asynchronous I/O driven
	wsock_event methods.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (wsock_event::prepare): Reimplement using asynchronous I/O.
	(wsock_event::wait): Ditto.
	(wsock_event::release): New method.
	* wsock_event.h (class wsock_event): Remove ovr member.  Accomodate
	new implementation of prepare and wait methods.  Add release method.
@
text
@a379 1
  int has_been_closed;
@


1.192
log
@	* errno.cc (errmap): Map ERROR_SHARING_VIOLATION to EBUSY,
	ERROR_EOM_OVERFLOW and ERROR_NO_DATA_DETECTED to EIO.  Add mappings
	for ERROR_NO_MEDIA_IN_DRIVE, ERROR_DEVICE_REQUIRES_CLEANING and
	ERROR_DEVICE_DOOR_OPEN.
	* fhandler.h (class fhandler_dev_raw): Drop varblkop member.
	(fhandler_dev_raw::is_eom): De-virtualize.
	(fhandler_dev_raw::is_eof): Ditto.
	(class fhandler_dev_tape): Drop lasterr and dp member.  Add mt_mtx
	member.  Drop all private methods formerly used by ioctl.
	(fhandler_dev_tape::is_rewind_device): Use get_minor for clarity.
	(fhandler_dev_tape::driveno): New method.
	(fhandler_dev_tape::drive_init): New method.
	(fhandler_dev_tape::clear): Remove method.
	(fhandler_dev_tape::is_eom): Ditto.
	(fhandler_dev_tape::is_eof): Ditto.
	(fhandler_dev_tape::write_file): Ditto.
	(fhandler_dev_tape::read_file): Ditto.
	(fhandler_dev_tape::_lock): New method.
	(fhandler_dev_tape::unlock): New method.
	(fhandler_dev_tape::raw_read): New method.
	(fhandler_dev_tape::raw_write): New method.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): New method.
	(fhandler_dev_raw::is_eof): New method.
	(fhandler_dev_raw::open): Allow setting write through option by
	using the O_TEXT flag as ... flag.
	(fhandler_dev_raw::writebuf): Remove usage of varblkop and other
	tape specific code.
	(fhandler_dev_raw::raw_read): Ditto.
	(fhandler_dev_raw::dup): Ditto.
	* fhandler_tape.cc: Rewrite tape operations entirely.  Implement
	new tape driver classes mtinfo, mtinfo_drive and mtinfo_part.
	Reduce fhandler_dev_tape methods to mostly just calling appropriate
	mtinfo_drive methods.
	(mtinfo_init): New function adding the mtinfo shared memory area.
	* mtinfo.h: New file, containing the definition of the new tape
	driver classes.
	* shared.cc: Include mtinfo.h.
	(offsets): Add entry for mtinfo shared memory area.
	(memory_init): Call mtinfo_init.
	* shared_info.h (shared_locations): Add SH_MTINFO shared location.
	* include/cygwin/mtio.h: Change and add various comments.  Add GMT_xxx
	macros for new generic flags.  Add MT_ST_xxx bitfield definitions
	for MTSETDRVBUFFER ioctl.
	* include/cygwin/version.h: Bump API minor version number.
@
text
@d380 1
@


1.191
log
@	* autoload.cc: Load eight more functions for waveIn support.
	* fhandler.h (class fhandler_dev_dsp): Add class Audio, class Audio_in
	and class Audio_out members and audio_in_, audio_out_ pointers so
	that future changes are restricted to file fhandler_dsp.cc.
	* fhandler_dsp.cc (fhandler_dev_dsp::Audio): Add this class to treat
	things common to audio recording and playback.
	Add more format conversions.
	(fhandler_dev_dsp::Audio::queue): New queues for buffer management
	to fix incomplete cleanup of buffers passed to the wave device.
	(fhandler_dev_dsp::Audio_in): New, added class to implement audio
	recording.
	(fhandler_dev_dsp::Audio_out): Rework to use functionality provided
	by fhandler_dev_dsp::Audio.  Allocate memory audio buffers late,
	just before write.
	(fhandler_dev_dsp::Audio_out::start): Size of wave buffer allocated
	here depends on audio rate/bits/channels.
	(fhandler_dev_dsp::Audio_in::start): Ditto.
	(fhandler_dev_dsp::setupwav): Replaced by following function.
	(fhandler_dev_dsp::Audio_out::parsewav): Does not setup wave device
	any more. Discard wave header properly.
	(fhandler_dev_dsp::open): Add O_RDONLY and_RDWR as legal modes.
	Protect against re-open. Activate fork_fixup.
	(fhandler_dev_dsp::ioctl): Protect against actions when audio is
	active.  SNDCTL_DSP_GETFMTS only returns formats supported by
	mmsystem wave API, not all supported formats.  SNDCTL_DSP_GETBLKSIZE
	result now depends on current audio format.
	(fhandler_dev_dsp::fixup_after_fork): Call fork_fixup for the Audio
	classes to let them duplicate the CRITICAL_SECTION.
@
text
@a511 1
  int varblkop	      : 1;
d520 1
a520 1
  virtual int is_eom(int win_error) = 0;
d522 1
a522 1
  virtual int is_eof(int win_error) = 0;
d571 1
a571 2
  int lasterr;
  TAPE_GET_DRIVE_PARAMETERS dp;
d573 3
a575 1
  bool is_rewind_device () { return get_unit () < 128; }
d577 2
a578 7
 protected:
  virtual void clear (void);
  virtual int is_eom (int win_error);
  virtual int is_eof (int win_error);
  virtual BOOL write_file (const void *buf, DWORD to_write,
			   DWORD *written, int *err);
  virtual BOOL read_file (void *buf, DWORD to_read, DWORD *read, int *err);
d586 3
a593 1

a594 20

 private:
  inline bool tape_get_feature (DWORD parm)
    {
      return ((parm & TAPE_DRIVE_HIGH_FEATURES)
	      ? ((dp.FeaturesHigh & parm) != 0)
	      : ((dp.FeaturesLow & parm) != 0));
    }
  int tape_error (const char *txt);
  int tape_write_marks (int marktype, DWORD len);
  int tape_get_pos (unsigned long *block, unsigned long *partition = NULL);
  int tape_set_pos (int mode, long count, bool sfm_func = false);
  int _tape_set_pos (int mode, long count, int partition = 0);
  int tape_erase (int mode);
  int tape_prepare (int action);
  int tape_set_blocksize (long count);
  int tape_status (struct mtget *get);
  int tape_compression (long count);
  int tape_partition (long count);
  int tape_set_partition (long count);
@


1.190
log
@* cygheap.cc (init_cheap): Add ability to specify minimal cygwin heap size when
debugging.
(_csbrk): Report error in allocation to stderr.
(ccalloc): Ditto.
* dtable.cc (dtable::find_fifo): Remove use of atoms.
* dtable.h (dtable::find_fifo): Ditto.
* fhandler.h (fhandler_fifo): Ditto.
* fhandler_fifo.cc (fhandler_fifo::fhandler_fifo): Ditto.
(fhandler_fifo::set_use): Ditto.
(fhandler_fifo::open_not_mine): Ditto.
(fhandler_fifo::open): Ditto.
* pinfo.cc (_pinfo::commune_recv): Ditto.
(_pinfo::commune_send): Ditto.
@
text
@d1108 1
a1108 1
class fhandler_dev_dsp : public fhandler_base
d1110 4
d1119 3
a1121 1
  bool setupwav(const char *pData, int nBytes);
d1134 1
@


1.189
log
@	Fix ChangeLog dates.

	* fhandler.h (fhandler_dev_tape::tape_get_pos): Declare with extra
	parameter for partition number.
	(fhandler_dev_tape::_tape_set_pos): Ditto.
	(fhandler_dev_tape::tape_partition): New method.
	(fhandler_dev_tape::tape_set_partition): New method.
	* fhandler_tape.cc (fhandler_dev_tape::open): Call private methods
	directly instead of ioctl.
	(fhandler_dev_tape::ioctl): Use long erase on MTERASE by default.
	Don't use absolute positioning on MTSEEK.  Call tape_set_partition
	on MTSETPART, tape_partition on MTMKPART.
	(fhandler_dev_tape::tape_get_pos): Add partition number parameter.
	Prefer logical position information over absolute position information.
	Return partition number.
	(fhandler_dev_tape::_tape_set_pos): Add partition number parameter.
	Use in SetTapePosition.
	(fhandler_dev_tape::tape_set_pos): Remove special TAPE_ABSOLUTE_BLOCK
	handling.
	(fhandler_dev_tape::tape_erase): Rewind before erasing.
	(fhandler_dev_tape::tape_status): Rearrange slightly. Try to get a
	MediaType even if no tape is loaded. Store active partition in
	mt_resid as on Linux.
	(fhandler_dev_tape::tape_partition): New method.
	(fhandler_dev_tape::tape_set_partition): New method.
	* include/cygwin/mtio.h: Fix copyright. Add comment to explain
	mt_resid content.
	* include/cygwin/version.h: Bump API minor number.
@
text
@a483 1
  ATOM upand;
a497 1
  ATOM& get_atom () {return upand;}
@


1.188
log
@	* errno.cc (errmap): Handle ERROR_BUS_RESET.
	* fhandler.h (fhandler_dev_raw::write_file): New method, created
	from former static function.
	(fhandler_dev_raw::read_file): Ditto.
	(reset_devbuf): New inline method.
	(class fhandler_dev_tape): Add TAPE_GET_DRIVE_PARAMETERS
	member `dp'.
	(fhandler_dev_tape::write_file): New method.
	(fhandler_dev_tape::read_file): Ditto.
	(fhandler_dev_tape::tape_get_feature): Convert to inline method.
	(fhandler_dev_tape::tape_error): New method, created from former
	static function.
	(fhandler_dev_tape::tape_get_blocksize): Remove declaration.
	* fhandler_raw.cc (fhandler_dev_raw::write_file): New method, created
	from former static function.
	(fhandler_dev_raw::read_file): Ditto.
	(fhandler_dev_raw::writebuf): Accomodate the fact that no devbuf
	exists under variable block size condition.
	(fhandler_dev_raw::raw_read): Ditto. Add local p pointer to simplify
	pointer arithmetic.
	(fhandler_dev_raw::raw_write): Always set devbufend to 0 when starting
	with writing. Accomodate the fact that no devbuf exists under
	variable block size condition.
	* fhandler_tape.cc: Various formatting changes.
	(TAPE_FUNC): New macro. Use throughout as tape function loop.
	(get_ll): Convert into macro.
	(IS_EOM): New macro.
	(IS_EOF): New macro.
	(fhandler_dev_tape::is_eom): Use IS_EOM macro.
	(fhandler_dev_tape::is_eof): Use IS_EOF macro.
	(fhandler_dev_tape::write_file): New method.
	(fhandler_dev_tape::read_file): New method.
	(fhandler_dev_tape::open): Get drive information block here once.
	(fhandler_dev_tape::lseek): Remove unneeded duplicate code.
	(fhandler_dev_tape::dup): Duplicate drive information block.
	(fhandler_dev_tape::ioctl): Remove drvbuf in variable block size mode.
	Return ERROR_INVALID_BLOCK_LENGTH instead of ERROR_MORE_DATA if
	buffer contains data which would get lost on buffer size changing.
	Use absolute tape positioning also if drive only supports logical
	block positioning.
	(fhandler_dev_tape::tape_error): New method, created from former
	static function.
	(fhandler_dev_tape::tape_get_pos): Allow logical block reporting.
	Workaround tape driver bug.
	(fhandler_dev_tape::_tape_set_pos): Reset device buffer and flags
	after successful repositioning.
	(fhandler_dev_tape::tape_set_pos): Allow logical block positioning.
	Workaround tape driver bug.
	(fhandler_dev_tape::tape_erase): Use dp instead of calling
	GetTapeParameters.
	(fhandler_dev_tape::tape_prepare): Ditto.
	(fhandler_dev_tape::tape_get_blocksize): Remove.
	(fhandler_dev_tape::tape_set_blocksize): Don't call tape_get_blocksize.
	Error handling already done in fhandler_dev_tape::ioctl.
	(fhandler_dev_tape::tape_status): Remove local `dp' variable.
	Accomodate logical tape reporting.  Call tape_get_feature instead
	of accessing feature words directly.
	(fhandler_dev_tape::tape_compression): Use dp instead of calling
	GetTapeParameters.  Fix resetting datcompression.
@
text
@d610 1
a610 1
  int tape_get_pos (unsigned long *ret);
d612 1
a612 1
  int _tape_set_pos (int mode, long count);
d618 2
@


1.187
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d517 3
d529 7
d575 1
a580 1

d583 3
d602 7
d612 1
a614 2
  bool tape_get_feature (DWORD parm);
  int tape_get_blocksize (long *min, long *def, long *max, long *cur);
@


1.186
log
@* fhandler.h (*::fixup_after_exec): Eliminate unused handle argument.
* fhandler.h (dtable::fixup_after_exec): Eliminate unused handle argument.
* dcrt0.cc (dll_crt0_1): Reflect elimination of unused handle argument to
fixup_after_exec.
* dtable.cc (dtable::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_raw::fixup_after_exec): Ditto.
* fhandler_socket.cc (fhandler_socket::fixup_after_exec): Ditto.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Ditto.
* pipe.cc (fhandler_pipe::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Do not set ciresrv.parent.
* child_info.h (child_info_spawn::~child_info_spawn): Do not close parent.
Update CURR_CHILD_INFO_MAGIC.
* dcrt0.cc (dll_crt0_0): Do not close spawn_info->parent.  Pass NULL to
cygheap->fdtab.fixup_after_exec().
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.185
log
@Throughout, change name from set_inheritance to set_no_inheritance to better
reflect input arguments of this function.
* cygheap.h (CYGHEAPSIZE): Increase size of cygheap to something closer to the
21st century.
@
text
@d214 1
a214 1
  virtual void fixup_after_exec (HANDLE) {}
d427 1
a427 1
  void fixup_after_exec (HANDLE);
d470 1
a470 1
  void fixup_after_exec (HANDLE);
d542 1
a542 1
  void fixup_after_exec (HANDLE);
d679 1
a679 1
  void fixup_after_exec (HANDLE);
d724 1
a724 1
  void fixup_after_exec (HANDLE parent) { fixup_after_fork (parent); }
d856 1
a856 1
  void fixup_after_exec (HANDLE);
d1109 1
a1109 1
  void fixup_after_exec (HANDLE);
d1139 1
a1139 1
  void fixup_after_exec (HANDLE);
@


1.184
log
@* fhandler.h (fhandler_base::fhaccess): Return int for compatibility with
access.
* fhandler.cc (fhandler_base::fhaccess): Return int.  Use consistent variable
name for exit value.  Exit at bottom, printing debugging information, like
other cygwin functions.
@
text
@d268 1
a268 1
  virtual void set_inheritance (HANDLE &h, int not_inheriting);
@


1.183
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@d367 1
a367 1
  bool fhaccess (int flags) __attribute__ ((regparm (2)));
@


1.182
log
@Move open_fhs from fhandler.h to cygheap.h for easier tracking.  Accommodate
this change throughout.
* dtable.cc (dtable::add_archetype): Use correct count when iterating through
*active* archetypes.
* dtable.cc (dtable::fixup_after_exec): Close handle if close_on_exec and
archetype exists since archetype currently does not set windows close-on-exec
flag (FIXME).
* fhandler_tty.cc (fhandler_tty_slave::open): Change debugging output slightly.
(fhandler_tty_slave::close): Ditto.
(fhandler_tty_slave::fixup_after_fork): Just report on inherited use counts
since since archetype currently does not set windows close-on-exec flag
(FIXME).
* pinfo.cc (_pinfo::set_ctty): Change debugging output slightly.
* cygheap.cc (cygheap_init): Remove open_fhs accommodation and use count
reporting.
* perthread.h (vfork_save::fhctty): New element.
* perthread.h (vfork_save::open_fhs): New element.
* fork.cc (vfork): Muck around with ctty and open_fhs stuff, both of which are
now saved in the vfork_save structure.
@
text
@a110 1
  /* Full unix path name of this file */
d258 1
a258 2
  bool has_acls () { return FHISSETF (HASACLS); }
  void set_has_acls (int val) { FHCONDSETF (val, HASACLS); }
d260 1
a260 2
  bool isremote () { return FHISSETF (ISREMOTE); }
  void set_isremote (int val) { FHCONDSETF (val, ISREMOTE); }
d262 1
d365 3
a367 2
  bool is_fs_special () {return dev ().isfs ();}
  bool device_access_denied (int) __attribute__ ((regparm (1)));
@


1.182.6.1
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@d111 1
d259 2
a260 1
  bool has_acls () const { return pc.has_acls (); }
d262 2
a263 1
  bool isremote () { return pc.isremote (); }
a264 1
  bool has_attribute (DWORD x) const {return pc.has_attribute (x);}
d367 2
a368 3
  bool is_fs_special () {return pc.is_fs_special ();}
  bool device_access_denied (int) __attribute__ ((regparm (2)));
  bool fhaccess (int flags) __attribute__ ((regparm (2)));
@


1.182.6.2
log
@* fhandler.h (fhandler_base::fhaccess): Return int for compatibility with
access.
* fhandler.cc (fhandler_base::fhaccess): Return int.  Use consistent variable
name for exit value.  Exit at bottom, printing debugging information, like
other cygwin functions.
@
text
@d367 1
a367 1
  int fhaccess (int flags) __attribute__ ((regparm (2)));
@


1.181
log
@* fhandler.h (fhandler_tty_slave::archetype): Make public.
(report_tty_counts): New macro.  Use throughout for reporting tty use counts.
* dtable.cc (dtable::vfork_child_dup): Add debugging output for usecount
increment.  Increment open_fhs if appropriate.
(dtable::vfork_parent_restore): "Close" artificially bumped ctty.
(dtable::vfork_child_fixup): Close ctty since it was bumped prior to vfork.
Save open_fhs around close since the closing of these handles has no effect on
the console.
* fhandler_tty.cc (fhandler_tty_slave::open): Reorganize calls to allow for
easier tracking of usecount modification.
(fhandler_tty_slave::open): Ditto.
@
text
@a831 2
  static int open_fhs;

d1198 1
a1198 1
		  fhs_op, fhandler_console::open_fhs,\
@


1.180
log
@* fhandler.h (fhandler_tty_master::fixup_after_fork): Remove declaration.
(fhandler_tty_master::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_master::init): Fix so that children do not
inherit master tty handles.
(fhandler_tty_master::fixup_after_fork): Remove, since it was never used.
(fhandler_tty_master::fixup_after_exec): Ditto.
* pinfo.cc (_pinfo::set_ctty): Increment open_fhs when ctty is set.
* cygheap.cc (cygheap_init): Ditto.
* syscalls.cc (setsid): *Always* call close on opened ctty since the archetype
is associated with the ctty and it counts as an opened handle.
* tty.cc (tty::common_init): Don't protect input/output mutex since it confuses
subsequent fork/execs when CYGWIN=tty.
@
text
@a124 1
  class fhandler_base *archetype;
d127 1
d1196 6
@


1.179
log
@* exceptions.cc (set_signal_mask): Report on input argument rather than
getsigmask.
* fhandler.h (fhandler_base): Make friends with close_all_files.
* pinfo.cc (_pinfo::set_ctty): Add more debugging.
* sigproc.cc (proc_can_be_signalled): Detect state when signal handler thread
is gone in target process as an EPERM situation.  Set errno to ESRCH if process
doesn't exist.
(sigproc_terminate): Set sendsig to illegal value when closed.
(sig_send): Rely on proc_can_be_signalled setting the proper errno.
* syscalls.cc (close_all_files): Detect when all ttys are closed prior to
calling close_all_files.  The ctty needs to be closed explicitly in this case.
@
text
@d893 1
a893 1
  tty *get_ttyp () { return (tty *)tc; }
a971 2
  void fixup_after_fork (HANDLE parent);
  void fixup_after_exec (HANDLE);
@


1.178
log
@* cygheap.h (cygheap_types): Add HEAP_ARCHETYPES.
(init_cheap::ctty): Change to pointer.
* dtable.h (dtable::find_archetype): Declare new function.
(dtable::add_archetype): Declare new function.
(dtable::delete_archetype): Declare new function.
(dtable::narchetypes): Declare.
(dtable::farchetypes): Declare.
(dtable::initial_archetype_size): Declare.
(dtable::dtable): Initialize new fields.
(dtable::initial_archetype_size): Declare.
* dtable.cc (dtable::find_archetype): Define new function.
(dtable::add_archetype): Define new function.
(dtable::delete_archetype): Define new function.
(dtable::initial_archetype_size): Define.
* fhandler.h (fhandler_base::archetype): Declare.
(fhandler_base::usecount): Declare.
* fhandler.cc (fhandler_base::fhandler_base): Initialize new fields.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass NULL to third
argument of set_ctty.
* fhandler_tty.cc (fhandler_tty_slave::open): Accommodate new archetype method
to create only one instance of a tty.
(fhandler_tty_slave::close): Don't close handles unless archetype usecount is
zero.  When that happens, close archetype too.
(fhandler_tty_slave::dup): Just copy archetype.  Set use count appropriately.
Set ctty, if appropriate.
(fhandler_tty_common::dup): Remove slave considerations.
(fhandler_tty_common::set_close_on_exec): Remove cygheap->ctty considerations.
* pinfo.cc (_pinfo::set_ctty): Accommodate new archetype methods.
* pinfo.h (_pinfo::set_ctty): Make third argument explicit.
* syscalls.cc (close_all_files): Decrement controlling tty use count before
closing all handles to allow controlling tty to be closed.  Remove previous
controlling tty considerations.
@
text
@d101 1
@


1.177
log
@* fhandler_tty.cc (fhandler_tty_common::dup): Just copy cygheap->ctty to child
if duping the current ctty.
(fhandler_tty_common::close): Move debugging statement earlier in function.
(fhandler_tty_slave::close): Return success when closing ctty.
* syscalls.cc (close_all_files): Avoid calling fhandler_tty_slave close method
so that open_fhs will not be decremented when closing cygheap ctty.
(setsid): Ditto.
* dcrt0.cc (do_exit): Reorganize to avoid leaving a critical section active
after vfork.
* fhandler.h (fhandler_tty_slave::get_unit): Remove regparm parameter since it
can't work in a virtualized function.
@
text
@d124 1
d127 2
d136 1
d145 1
a145 1
  DWORD get_device () { return dev ().devn; }
@


1.176
log
@* fhandler.h (fhandler_tty_slave::ttyname): Use name from pc since it is
guaranteed to be accurate.
* fhandler_tty.cc (fhandler_tty_slave::open): Increment open_fhs appropriate
when copying ctty.
(fhandler_tty_slave::close): Remove special case handling for exit_state.  Use
ctty < 0 check instead.
(fhandler_tty_common::close): Set io_handle to NULL after closing.
* syscalls.cc (close_all_files): Specifically close cygheap->ctty, if
appropriate.
@
text
@d921 1
a921 1
  int get_unit () __attribute__ ((regparm (1)));
@


1.175
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d922 1
@


1.174
log
@	Substitute 0x7fffffff and 0xffffffff by INT32_MAX and UINT32_MAX
	throughout, except in assembler code.
@
text
@d305 1
a305 1
  virtual BOOL fixup_mmap_after_fork (HANDLE h, DWORD access, DWORD offset,
d336 1
a336 1
  virtual bool hit_eof () {return FALSE;}
d587 1
a587 1
  int tape_set_pos (int mode, long count, BOOLEAN sfm_func = FALSE);
d590 1
a590 1
  BOOLEAN tape_get_feature (DWORD parm);
d613 1
a613 1
  BOOL fixup_mmap_after_fork (HANDLE h, DWORD access, DWORD offset,
d712 1
a712 1
  void tcinit (tty_min *this_tc, int force = FALSE);
d794 2
a795 2
  BOOL con_to_str (char *d, const char *s, DWORD sz);
  BOOL str_to_con (char *d, const char *s, DWORD sz);
d810 1
a810 1
  BOOL fillin_info ();
d813 1
a813 1
  void cursor_set (BOOL, int, int);
d818 1
a818 1
  BOOL set_raw_win32_keyboard_mode (BOOL);
d1000 1
a1000 1
  BOOL crypt_gen_random (void *ptr, size_t len);
d1037 1
a1037 1
  BOOL fixup_mmap_after_fork (HANDLE h, DWORD access, DWORD offset,
@


1.173
log
@	* Makefile.in (OBSOLETE_FUNCTIONS): Add fcntl.
	(NEW_FUNCTIONS): Add fcntl64.
	* cygwin.din: Export fcntl64.  Make fcntl being SIGFE.
	* fcntl.cc (fcntl_worker): New function.
	(fcntl64): New function.
	(_fcntl): Call fcntl_worker.  Convert 32 bit flock structure into
	64 bit flock structure and vice versa.
	* fhandler.cc (fhandler_base::lock): Change 2nd parameter to
	struct __flock64 *.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Ditto.  Rework
	to be 64 bit aware.
	* fhandler.h: Accomodate above method argument changes.
	* include/cygwin/types.h: Add struct __flock32 and __flock64.
	Define struct flock according to setting of __CYGWIN_USE_BIG_TYPES__.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d235 1
a235 1
  bool get_fs_flags (DWORD flagval = 0xffffffffUL)
@


1.172
log
@* dtable.cc (build_fh_name): Set error in dummy fhandler when one is noted
during path_conv.
* fhandler.h (fhandler_base::set_error): New method.
@
text
@d297 1
a297 1
  virtual int lock (int, struct flock *);
d606 1
a606 1
  int lock (int, struct flock *);
@


1.171
log
@	* dcrt0.cc: Remove local variable alternate_charset_active.
	* fhandler.h: Add variable alternate_charset_active, functions
	str_to_con, con_to_str to dev_console structure.
	* fhandler_console.cc (con_to_str): Move function into dev_console
	class.
	(str_to_con): Ditto.
	(fhandler_console::read): Call con_to_str on dev_state.
	(fhandler_console::write_normal): Call str_to_con on dev_state.
	(fhandler_console::char_command): Change active_charset_active
	assignment to be on dev_state.
	* winsup.h: Remove global external variable alternate_charset_active.
@
text
@d128 1
@


1.170
log
@* Makefile.in: Add YA method for generating devices.cc.
* child_info.h: YA update of another magic number.
* gendevices: New file.
* devices.in: New file.
* devices.cc: Regenerate.
* devices.shilka: Remove.
* devices.h: Correctly define device pointers.
(device): Remove now obsolete fields.
(device::native): Renamed from device::fmt.
* dtable.cc (build_fh_dev): Simplify in light of new unit parsing scheme.
(build_fh_pc): Ditto.
* path.cc (win32_device_name): Ditto.
* fhandler.h (fhandler_base::get_native_name): Reflect renaming of fmt to
native.
* fhandler_tty.cc (fhandler_tty_mster::init): Initialize slave device prior to
reporting unit.
@
text
@d755 1
d792 4
@


1.169
log
@	* fhandler.h (class fhandler_dev_raw): Add method fstat.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): New method.

	Add missing ChangeLog for previous patch.
@
text
@d342 1
a342 1
    return dev ().fmt;
@


1.168
log
@* cygwin-shilka: Remove '#line directives' or suffer debugging oddities.  Use
-length option so that device prefixes are used.
* devices.cc: Regenerate.
* syscalls.cc (ttyname): Add debugging output.
@
text
@d530 2
@


1.167
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d290 1
a290 1
  virtual char const *ttyname () { return get_name(); }
@


1.166
log
@* cygheap.cc (creturn): Set appropriate errno when out of memory.
(ccalloc): Only issue system_printf when debugging.
* dtable.cc (dtable::extend): Only allocate 100 * the incremental growth size
max.  Set errno appropriately.
(dtable::build_fhandler): Check for error from set_name.
* fhandler.cc (fhandler_base::set_name): Set errno and return error on OOM.
* fhandler.h (fhandler_base::set_name): Change to bool.
* fhandler_process.cc (format_process_stat): Fix formatting.
* resource.cc (getrlimit): Return greater of OPEN_MAX or fd table size.
* sysconf.cc (sysconf): Ditto.
@
text
@a13 3
#include <sys/ioctl.h>
#include <fcntl.h>

a41 36

  /* Device flags */

  /* Slow devices */
  FH_CONSOLE = 0x00000001,	/* is a console */
  FH_CONIN   = 0x00000002,	/* console input */
  FH_CONOUT  = 0x00000003,	/* console output */
  FH_TTYM    = 0x00000004,	/* is a tty master */
  FH_TTYS    = 0x00000005,	/* is a tty slave */
  FH_PTYM    = 0x00000006,	/* is a pty master */
  FH_SERIAL  = 0x00000007,	/* is a serial port */
  FH_PIPE    = 0x00000008,	/* is a pipe */
  FH_PIPER   = 0x00000009,	/* read end of a pipe */
  FH_PIPEW   = 0x0000000a,	/* write end of a pipe */
  FH_SOCKET  = 0x0000000b,	/* is a socket */
  FH_WINDOWS = 0x0000000c,	/* is a window */
  FH_SLOW    = 0x00000010,	/* "slow" device if below this */

  /* Fast devices */
  FH_DISK    = 0x00000010,	/* is a disk */
  FH_FLOPPY  = 0x00000011,	/* is a floppy */
  FH_TAPE    = 0x00000012,	/* is a tape */
  FH_NULL    = 0x00000013,	/* is the null device */
  FH_ZERO    = 0x00000014,	/* is the zero device */
  FH_RANDOM  = 0x00000015,	/* is a random device */
  FH_MEM     = 0x00000016,	/* is a mem device */
  FH_CLIPBOARD = 0x00000017,	/* is a clipboard device */
  FH_OSS_DSP = 0x00000018,	/* is a dsp audio device */
  FH_CYGDRIVE= 0x00000019,	/* /cygdrive/x */
  FH_PROC    = 0x0000001a,      /* /proc */
  FH_REGISTRY =0x0000001b,      /* /proc/registry */
  FH_PROCESS = 0x0000001c,      /* /proc/<n> */

  FH_NDEV    = 0x0000001d,      /* Maximum number of devices */
  FH_DEVMASK = 0x00000fff,	/* devices live here */
  FH_BAD     = 0xffffffff
d44 1
a44 1
#define FHDEVN(n)	((n) & FH_DEVMASK)
a75 1
class path_conv;
a97 8
enum executable_states
{
  is_executable,
  dont_care_if_executable,
  not_executable = dont_care_if_executable,
  dont_know_if_executable
};

d100 1
a119 2
  const char *unix_path_name;
  const char *win32_path_name;
d123 1
d126 6
a131 1
  bool set_name (const char * unix_path, const char *win32_path = NULL, int unit = 0);
d134 1
a134 1
  fhandler_base (DWORD dev, int unit = 0);
d140 4
a143 3
  DWORD get_device () { return status & FH_DEVMASK; }
  virtual int get_unit () { return 0; }
  virtual BOOL is_slow () { return get_device () < FH_SLOW; }
d145 1
a145 1
  int get_access () { return access; }
d259 2
a260 2
  const char *get_name () { return unix_path_name; }
  const char *get_win32_name () { return win32_path_name; }
d268 1
d270 2
a271 1
  virtual int open (path_conv *real_path, int flags, mode_t mode = 0);
d273 15
a287 1
  virtual int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d290 1
a290 1
  virtual char const * ttyname () { return get_name(); }
d320 2
a321 1
  virtual BOOL is_device () { return TRUE; }
d323 1
a323 1
  virtual class fhandler_socket *is_socket () { return 0; }
d340 1
a340 1
  virtual const char * get_native_name ()
d342 1
a342 1
    return windows_device_names[FHDEVN (status)];
d353 1
a353 1
  virtual DIR *opendir (path_conv& pc);
d359 4
a374 1
  int unit;
d377 1
a377 1
  fhandler_socket (int unit);
d380 1
a380 2
  fhandler_socket * is_socket () { return this; }
  int get_unit () { return unit; }
d423 1
d440 2
a441 1
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d446 1
d452 2
a453 2
 public:
  fhandler_pipe (DWORD devtype);
a467 1
  friend int make_pipe (int fildes[2], unsigned int psize, int mode);
d470 25
a509 1
  int unit;
d519 1
a519 1
  fhandler_dev_raw (DWORD dev, int unit);
d524 1
a524 3
  int get_unit () { return unit; }

  int open (path_conv *, int flags, mode_t mode = 0);
d545 1
a545 1
  fhandler_dev_floppy (int unit);
d547 1
a547 1
  virtual int open (path_conv *, int flags, mode_t mode = 0);
d568 1
a568 1
  fhandler_dev_tape (int unit);
d570 1
a570 1
  virtual int open (path_conv *, int flags, mode_t mode = 0);
d575 1
a575 1
  virtual int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
a599 1
  fhandler_disk_file (DWORD devtype);
d601 1
a601 1
  int open (path_conv * real_path, int flags, mode_t mode);
d604 2
a605 14
  BOOL is_device () { return FALSE; }
  int __stdcall fstat (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
  int __stdcall fstat_helper (struct __stat64 *buf, path_conv *pc,
			      FILETIME ftCreateionTime,
			      FILETIME ftLastAccessTime,
			      FILETIME ftLastWriteTime,
			      DWORD nFileSizeHigh,
			      DWORD nFileSizeLow,
			      DWORD nFileIndexHigh = 0,
			      DWORD nFileIndexLow = 0,
			      DWORD nNumberOfLinks = 1)
    __attribute__ ((regparm (3)));
  int __stdcall fstat_by_handle (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
  int __stdcall fstat_by_name (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
d612 1
a612 1
  DIR *opendir (path_conv& pc);
a621 1
  int unit;
d626 3
a628 3
  bool iscygdrive_root () const { return !unit; }
  fhandler_cygdrive (int unit);
  DIR *opendir (path_conv& pc);
d634 1
a634 1
  int __stdcall fstat (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
d652 1
a652 1
  fhandler_serial (int unit);
d654 1
a654 1
  int open (path_conv *, int flags, mode_t mode);
d682 1
d701 2
a702 2
  fhandler_termios (DWORD dev, int unit = 0) :
  fhandler_base (dev, unit)
d808 1
a808 1
  const unsigned char * write_normal (unsigned const char*, unsigned const char *);
d825 1
a825 1
  int open (path_conv *, int flags, mode_t mode = 0);
d852 1
d858 2
a859 2
  fhandler_tty_common (DWORD dev, int unit = 0)
    : fhandler_termios (dev, unit), output_done_event (NULL),
d861 1
a861 1
    input_mutex (NULL), input_available_event (NULL), inuse (NULL), ttynum (unit)
a873 1
  int ttynum;			// Master tty num.
a880 1
  int get_unit () { return ttynum; }
d888 1
a895 1
  fhandler_tty_slave (int);
d897 1
a897 1
  int open (path_conv *, int flags, mode_t mode = 0);
d913 1
d919 3
a921 1
 public:
d925 1
a925 1
  fhandler_pty_master (DWORD devtype = FH_PTYM, int unit = -1);
d930 1
a930 1
  int open (path_conv *, int flags, mode_t mode = 0);
d945 1
d954 2
a955 2
  fhandler_tty_master (int unit);
  int init (int);
d960 1
d978 1
a978 1
  int open (path_conv *, int flags, mode_t mode = 0);
a988 1
  int unit;
d997 2
a998 3
  fhandler_dev_random (int unit);
  int get_unit () { return unit; }
  int open (path_conv *, int flags, mode_t mode = 0);
a1010 1
  int unit;
d1015 1
a1015 1
  fhandler_dev_mem (int unit);
d1018 1
a1018 1
  int open (path_conv *, int flags, mode_t mode = 0);
d1023 1
a1023 1
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d1040 1
a1040 1
  int open (path_conv *, int flags, mode_t mode = 0);
d1065 1
a1065 1
  int open (path_conv *, int flags, mode_t mode = 0);
d1077 1
d1092 1
a1092 1
  int open (path_conv *, int flags, mode_t mode = 0);
d1098 1
a1098 1
  int dup (fhandler_base * child);
d1113 1
a1113 1
  fhandler_virtual (DWORD devtype);
d1117 1
a1117 1
  DIR *opendir (path_conv& pc);
d1125 2
a1126 2
  int dup (fhandler_base * child);
  int open (path_conv *, int flags, mode_t mode = 0);
d1128 1
a1136 1
  fhandler_proc (DWORD devtype);
d1141 2
a1142 2
  int open (path_conv *real_path, int flags, mode_t mode = 0);
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d1159 2
a1160 2
  int open (path_conv *real_path, int flags, mode_t mode = 0);
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d1173 2
a1174 2
  int open (path_conv *real_path, int flags, mode_t mode = 0);
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d1178 7
d1213 1
a1245 4
  select_stuff (): always_ready (0), windows_used (0), start (0)
  {
    memset (device_specific, 0, sizeof (device_specific));
  }
d1248 3
a1250 1
  void *device_specific[FH_NDEV];
d1257 4
@


1.165
log
@	* fhandler.h (fhandler_socket::get_connect_state): New method to
	return socket connection state.
	* fhandler_socket.cc (dup): Copy socket connect state to new file
	handle.
	* net.cc (cygwin_rcmd): Mark file handles of sockets returned by
	rcmd() as CONNECTED state.
	(cygwin_rexec): Similarly for rexec().
	(socketpair): Mark both ends of a new socket pair as CONNECTED.
@
text
@d174 1
a174 1
  void set_name (const char * unix_path, const char *win32_path = NULL, int unit = 0);
@


1.164
log
@* fhandler.h (FH_ENC): New enum.
(fhandler_base::get_encoded): New function.
(fhandler_base::set_encoded): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set encoded flag in
fhandler, as appropriate.
(fhandler_disk_file::readdir): Unmunge filename as appropriate based on new
encoding flag.
* path.cc (normalize_posix_path): Don't punt on files with colons.
(special_char): New function.
(mount_item::fnmunge): Ditto.
(fnunmunge): Ditto.
(special_name): Ditto.
(mount_item::build_win32): Avoid drive considerations when file is encoded.
(mount_info::conv_to_win32_path): Handle encoded filenames.
(mount_info::conv_to_posix_path): Ditto.
(fillout_mntent): Add posix string when directory is encoded.
* path.h (fnunmunge): Declare.
(path_conv::is_encoded): Declare.
@
text
@d415 1
@


1.163
log
@	* fhandler.h: Rename FH_W95LSBUG flag to FH_LSEEKED.
	(fhandler_base::set_did_lseek): Rename from set_check_win95_lseek_bug.
	(fhandler_base::get_did_lseek): Rename from get_check_win95_lseek_bug.
	(fhandler_base::set_fs_flags): New method.
	(fhandler_base::get_fs_flags): Ditto.
	* fhandler.cc (fhandler_base::write): Make 64 bit clean.  Convert file
	to a "sparse" file when writing after a long lseek (>64K) beyond EOF.
	(fhandler_base::lseek): Call set_did_lseek() instead of
	set_check_win95_lseek_bug().
	(fhandler_base::fhandler_base): Initialize fs_flags to 0.
	* fhandler_disk_file.cc (fhandler_disk_file::open): Don't create files
	as "sparse" unconditionally.  Set fs_flags member.
@
text
@d26 1
a26 2
  FH_SIGCLOSE	= 0x00080000,	/* signal handler should close fd on interrupt */

d243 3
@


1.162
log
@	* Makefile.in (CYGWIN_START): Define as crt0.o.  Add to TARGET_LIBS.
	* fhandler.h (fhandler_virtual::fstat): Remove useless declaration.
	* fhandler_virtual.cc: Remove _COMPILING_NEWLIB define.
	* ipc.cc (ftok): Use stat64.
	* syscalls.cc (_fstat64): Remove alias.
	(_fstat): Ditto.
	(_stat): Ditto.
	(_fstat64_r): New function.
	(_fstat_r): Ditto.
	(_stat64_r): Ditto.
	(stat_r): Ditto.
	* crt0.o: New file, moved from newlib.
	* include/sys/param.h: Ditto.
	* include/sys/utime.h: Ditto.
	* include/sys/utmp.h: Ditto.
	* include/sys/dirent.h: Ditto.  Expose different struct dirent,
	dependening of the environment.
@
text
@d31 1
a31 1
  FH_W95LSBUG	= 0x00400000,	/* set when lseek is called as a flag that
d33 2
a34 1
				 * EOF, zero filling if so. */
d171 1
d239 2
a240 2
  void set_check_win95_lseek_bug (int b = 1) { FHCONDSETF (b, W95LSBUG); }
  bool get_check_win95_lseek_bug () { return FHISSETF (W95LSBUG); }
d272 4
@


1.161
log
@	Replace ino_t by __ino64_t throughout.
@
text
@a1128 1
  int __stdcall fstat (struct stat *buf, path_conv *pc) __attribute__ ((regparm (3)));
@


1.160
log
@* dir.cc (readdir): Fill out new old_d_ino field.
* fhandler.h (fhandler_base::namehash): Define as ino_t.
(fhandler_base::get_namehash): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Accommodate new 64
bit st_ino.
* fhandler_socket.cc (fhandler_socket::fstat): Ditto.
* path.cc (hash_path_name): Return ino_t.
* syscalls.cc (stat64_to_stat32): Convert 64 bit inode to 32 bit.
* winsup.h (hash_path_name): Declare as returning ino_t.
* include/cygwin/stat.h (__stat32): Use 32 bit st_ino.
(__stat64): Use 64 bit st_ino.
* include/cygwin/types.h (__ino64_t): Define.
(__ino32_t): Ditto.
(ino_t): Define appropriately.
@
text
@d154 1
a154 1
  ino_t namehash;	/* hashed filename, used as inode num */
d295 1
a295 1
  ino_t get_namehash () { return namehash; }
@


1.159
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@d154 1
a154 1
  unsigned long namehash;	/* hashed filename, used as inode num */
d295 1
a295 1
  unsigned long get_namehash () { return namehash; }
@


1.158
log
@	* external.cc (cygwin_internal): Change n to __off64_t to match change
	of _pinfo::cmdline.
	* fhandler.h (class fhandler_virtual): Change filesize member to
	__off64_t.
	* fhandler_proc.cc (format_proc_meminfo): Change to return __off64_t.
	(format_proc_stat): Ditto.
	(format_proc_uptime): Ditto.
	* fhandler_process.cc (format_process_stat): Ditto.
	(format_process_status): Ditto.
	(format_process_statm): Ditto.
	* pinfo.cc (_pinfo::cmdline): Expect __off64_t parameter.
	* pinfo.h (class _pinfo): Change declaration of cmdline accordingly.
@
text
@d313 1
a313 1
  virtual __off64_t lseek (__off64_t offset, int whence);
d319 1
a319 1
		       int flags, __off64_t off);
d372 2
a373 2
  virtual __off64_t telldir (DIR *);
  virtual void seekdir (DIR *, __off64_t);
d427 1
a427 1
  __off64_t lseek (__off64_t, int) { return 0; }
d465 1
a465 1
  __off64_t lseek (__off64_t offset, int whence);
d540 1
a540 1
  virtual __off64_t lseek (__off64_t offset, int whence);
d563 1
a563 1
  virtual __off64_t lseek (__off64_t offset, int whence);
d610 1
a610 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, __off64_t off);
d617 2
a618 2
  __off64_t telldir (DIR *);
  void seekdir (DIR *, __off64_t);
d634 2
a635 2
  __off64_t telldir (DIR *);
  void seekdir (DIR *, __off64_t);
d671 1
a671 1
  __off64_t lseek (__off64_t, int) { return 0; }
d722 1
a722 1
  virtual __off64_t lseek (__off64_t, int);
d914 1
a914 1
  __off64_t lseek (__off64_t, int) { return 0; }
d941 1
a941 1
  __off64_t lseek (__off64_t, int) { return 0; }
d980 1
a980 1
  __off64_t lseek (__off64_t offset, int whence);
d1002 1
a1002 1
  __off64_t lseek (__off64_t offset, int whence);
d1014 1
a1014 1
  __off64_t pos;
d1023 1
a1023 1
  __off64_t lseek (__off64_t offset, int whence);
d1028 1
a1028 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, __off64_t off);
d1045 1
a1045 1
  __off64_t lseek (__off64_t offset, int whence);
d1053 1
a1053 1
  __off64_t pos;
d1071 1
a1071 1
  __off64_t lseek (__off64_t, int) { return 0; }
d1097 1
a1097 1
  __off64_t lseek (__off64_t, int);
d1109 2
a1110 2
  __off64_t filesize;
  __off64_t position;
d1119 2
a1120 2
  __off64_t telldir (DIR *);
  void seekdir (DIR *, __off64_t);
d1125 1
a1125 1
  __off64_t lseek (__off64_t, int);
d1156 2
a1157 2
  __off64_t telldir (DIR *);
  void seekdir (DIR *, __off64_t);
@


1.157
log
@* fhandler.h (fhandler_tty_slave::close): Declare new function.
(fhandler_tty_slave::dup): Declare new function.
(fhandler_tty_slave::fixup_after_function): Declare new function.
* fhandler_tty.cc (fhandler_tty_slave_open): Only increment
fhandler_console::open_fhs when associated with a pty.
(fhandler_tty_slave::close): Define new function.  Decrement
fhandler_console::open_fhs when associated with a pty.
(fhandler_tty_slave::dup): Define new function.  Increment
fhandler_console::open_fhs when associated with a pty.
(fhandler_tty_slave::fixup_after_fork): Define new function.  Increment
fhandler_console::open_fhs when associated with a pty.
@
text
@d1108 2
a1109 1
  size_t bufalloc, filesize;
@


1.156
log
@* dll_init.cc (dll_list::load_after_fork): Don't revert to LoadLibrary if
LoadLibraryEx fails.
* dtable.cc (dtable::dec_console_fds): Eliminate.
(dtable::release): Don't treat console specially.
(dtable::build_fhandler): Ditto.
* dtable.h (console_fds): Eliminate.
(dtable::dec_console_fds): Eliminate.
(dtable::inc_console_fds): Eliminate.
* fhandler.h (fhandler_console::open_fhs): New static element.
* fhandler_console.cc (fhandler_console::open): Increment open_fs.
(fhandler_console::close): Call FreeConsole if no more open consoles and ctty
is not associated with the console.
* syscalls.cc (setsid): Simplify check for when to call FreeConsole.
(check_pty_fds): Eliminate definition.
* winsup.h (check_pty_fds): Eliminate declaration.
@
text
@d910 3
@


1.155
log
@	* dtable.cc (dtable::build_fhandler_from_name): Set some fhandler
	data on sockets to evaluate AF_LOCAL sockets correctly.
	(dtable::build_fhandler): Set unit number on sockets.
	* fhandler.h (fhandler_socket): Add unit number.
	(fhandler_socket::get_unit): New method.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Set unit
	number.
	(fhandler_socket::fstat): Reorganize to return more Linux-like
	values.
	* net.cc: include ctype.h.
	(fdsock): Set unit number when building fhandler.
	* path.cc (path_conv::check): Set device type to FH_SOCKET if file
	is a AF_UNIX socket.
	(get_devn): Evaluate unit for virtual socket devices.
	(win32_device_name): Set windows path for sockets to unix_path with
	just backslashes to keep the different names.
	* syscalls.cc (fstat64): Don't override st_ino, st_dev and st_rdev
	for sockets.
	(stat_worker): Ditto.

From Pierre Humblet:

	* autoload.cc (AccessCheck): Add.
	(DuplicateToken): Add.
	* security.h (check_file_access): Declare.
	* syscalls.cc (access): Convert path to Windows, check existence
	and readonly attribute. Call check_file_access instead of acl_access.
	* security.cc (check_file_access): Create.
	* sec_acl (acl_access): Delete.
@
text
@d822 1
@


1.154
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d388 1
d391 1
a391 1
  fhandler_socket ();
d395 1
@


1.154.2.1
log
@merge from trunk
@
text
@d45 36
d83 1
a83 3
#include "devices.h"

#define FHDEVN(n)	(n)
d173 1
a173 2
  device dev;
  void set_name (const char *unix_path, const char *win32_path = NULL);
d176 1
a176 1
  fhandler_base ();
d182 3
a184 4
  DWORD get_device () const { return dev.devn; }
  DWORD get_major () const { return dev.major; }
  DWORD get_minor () const { return dev.minor; }
  virtual int get_unit () const { return dev.minor; }
d186 1
a186 1
  int get_access () const { return access; }
a303 1
  int open_fs (path_conv *real_path, int flags, mode_t mode = 0);
a304 1
  int close_fs ();
a305 13
  int __stdcall fstat_fs (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
  int __stdcall fstat_helper (struct __stat64 *buf, path_conv *pc,
			      FILETIME ftCreateionTime,
			      FILETIME ftLastAccessTime,
			      FILETIME ftLastWriteTime,
			      DWORD nFileSizeHigh,
			      DWORD nFileSizeLow,
			      DWORD nFileIndexHigh = 0,
			      DWORD nFileIndexLow = 0,
			      DWORD nNumberOfLinks = 1)
    __attribute__ ((regparm (3)));
  int __stdcall fstat_by_handle (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
  int __stdcall fstat_by_name (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
d308 1
a308 1
  virtual char const *ttyname () { return get_name(); }
d338 1
a338 2
  virtual bool isdevice () { return true; }
  virtual bool isfifo () { return false; }
d357 1
a357 1
  virtual const char *get_native_name ()
d359 1
a359 1
    return dev.fmt;
a375 4
  virtual bool is_slow () {return 0;}
  bool is_auto_device () {return isdevice () && !dev.isfs ();}
  bool is_fs_special () {return dev.isfs ();}
  bool device_access_denied (int) __attribute__ ((regparm (1)));
d393 1
a393 1
  fhandler_socket *is_socket () { return this; }
a451 1
  bool is_slow () {return 1;}
a455 1
protected:
d461 2
a462 2
public:
  fhandler_pipe ();
d477 1
a479 24
  static int create (fhandler_pipe *[2], unsigned, int, bool = false);
  bool is_slow () {return 1;}
  friend class fhandler_fifo;
};

class fhandler_fifo: public fhandler_pipe
{
  HANDLE output_handle;
  HANDLE owner;		// You can't have too many mutexes, now, can you?
  ATOM upand;
  long read_use;
  long write_use;
public:
  fhandler_fifo ();
  int open (path_conv *, int flags, mode_t mode = 0);
  int open_not_mine (int flags) __attribute__ ((regparm (2)));
  int close ();
  void set_use (int flags) __attribute__ ((regparm (2)));
  bool isfifo () { return true; }
  HANDLE& get_output_handle () { return output_handle; }
  void set_output_handle (HANDLE h) { output_handle = h; }
  void set_use ();
  bool is_slow () {return 1;}
  ATOM& get_atom () {return upand;}
d495 1
d505 1
a505 1
  fhandler_dev_raw ();
d510 2
d533 1
a533 1
  fhandler_dev_floppy ();
d556 1
a556 1
  fhandler_dev_tape ();
d588 1
d590 1
a590 1
  int open (path_conv *real_path, int flags, mode_t mode);
d593 1
a593 1
  bool isdevice () { return false; }
d595 12
d623 1
d628 2
a629 2
  bool iscygdrive_root () const { return !dev.minor; }
  fhandler_cygdrive ();
d654 1
a654 1
  fhandler_serial ();
a683 1
  bool is_slow () {return 1;}
d702 2
a703 2
  fhandler_termios () :
  fhandler_base ()
d809 1
a809 1
  const unsigned char *write_normal (unsigned const char*, unsigned const char *);
a851 1
  bool is_slow () {return 1;}
d857 2
a858 2
  fhandler_tty_common ()
    : fhandler_termios (), output_done_event (NULL),
d860 1
a860 1
    input_mutex (NULL), input_available_event (NULL), inuse (NULL)
d873 1
d881 1
a888 1
  bool is_slow () {return 1;}
d896 1
a910 1
  int get_unit () __attribute__ ((regparm (1)));
d916 1
a916 3
protected:
  device slave;			// device type of slave
public:
d920 1
a920 1
  fhandler_pty_master ();
a939 1
  int get_unit () const { return slave.minor; }
d948 2
a949 2
  fhandler_tty_master ();
  int init ();
a953 1
  bool is_slow () {return 1;}
d982 1
d991 2
a992 1
  fhandler_dev_random ();
d1006 1
d1011 1
a1011 1
  fhandler_dev_mem ();
a1072 1
  bool is_slow () {return 1;}
d1093 1
a1093 1
  int dup (fhandler_base *child);
d1107 1
a1107 1
  fhandler_virtual ();
d1119 1
a1119 1
  int dup (fhandler_base *child);
d1131 1
d1233 4
d1239 1
a1239 3
  void *device_specific_pipe;
  void *device_specific_socket;
  void *device_specific_serial;
a1245 4
  select_stuff (): always_ready (0), windows_used (0), start (0),
		   device_specific_pipe (0),
		   device_specific_socket (0),
		   device_specific_serial (0) {}
@


1.154.2.2
log
@* Makefile.in (DLL_OFILES): Add fhandler_nodevice.o.
* devices.gperf (device::parse): Just set devn to input if device not found --
nonexistent device will be caught later.
* dtable.cc (dtable::build_fhandler): Build fhandler_nodevice type when unknown
device.
* fhandler.h (fhandler_nodevice): New class.
(fhandler_union): Add fhandler_nodevice.
* path.cc (path_conv::check): Always set device stuff if major/minor are
specified.
@
text
@a1170 7
struct fhandler_nodevice: public fhandler_base
{
  fhandler_nodevice ();
  int open (path_conv *real_path, int flags, mode_t mode = 0);
  // int __stdcall fstat (struct __stat64 *buf, path_conv *);
};

a1198 1
  char __nodevice[sizeof (fhandler_nodevice)];
@


1.154.2.3
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d14 3
d47 2
d81 1
d104 8
a113 1
  friend class dtable;
d133 2
a136 1
  path_conv pc;
d139 2
a140 6
  void set_name (path_conv &pc);
  int error () const {return pc.error;}
  bool exists () const {return pc.exists ();}
  int pc_binmode () const {return pc.binmode ();}
  device& dev () {return pc.dev;}
  operator DWORD& () {return (DWORD) pc;}
d149 4
a152 4
  DWORD get_device () { return dev ().devn; }
  DWORD get_major () { return dev ().major; }
  DWORD get_minor () { return dev ().minor; }
  virtual int get_unit () { return dev ().minor; }
d261 2
a262 2
  const char *get_name () const { return pc.normalized_path; }
  const char *get_win32_name () { return pc.get_win32 (); }
d271 2
a272 2
  virtual int open (int flags, mode_t mode = 0);
  int open_fs (int flags, mode_t mode = 0);
d275 3
a277 3
  virtual int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fstat_fs (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fstat_helper (struct __stat64 *buf,
d287 2
a288 2
  int __stdcall fstat_by_handle (struct __stat64 *buf) __attribute__ ((regparm (2)));
  int __stdcall fstat_by_name (struct __stat64 *buf) __attribute__ ((regparm (2)));
d343 1
a343 1
    return dev ().fmt;
d354 1
a354 1
  virtual DIR *opendir ();
d361 2
a362 2
  bool is_auto_device () {return isdevice () && !dev ().isfs ();}
  bool is_fs_special () {return dev ().isfs ();}
d439 1
a439 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d483 1
a483 1
  int open (int flags, mode_t mode = 0);
d522 1
a522 1
  int open (int flags, mode_t mode = 0);
d545 1
a545 1
  virtual int open (int flags, mode_t mode = 0);
d568 1
a568 1
  virtual int open (int flags, mode_t mode = 0);
d573 1
a573 1
  virtual int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d599 1
a599 1
  int open (int flags, mode_t mode);
d603 1
a603 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d610 1
a610 1
  DIR *opendir ();
d624 1
a624 1
  bool iscygdrive_root () { return !dev ().minor; }
d626 1
a626 1
  DIR *opendir ();
d632 1
a632 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d652 1
a652 1
  int open (int flags, mode_t mode);
d822 1
a822 1
  int open (int flags, mode_t mode = 0);
d894 1
a894 1
  int open (int flags, mode_t mode = 0);
d924 1
a924 1
  int open (int flags, mode_t mode = 0);
d972 1
a972 1
  int open (int flags, mode_t mode = 0);
d992 1
a992 1
  int open (int flags, mode_t mode = 0);
d1012 1
a1012 1
  int open (int flags, mode_t mode = 0);
d1017 1
a1017 1
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d1034 1
a1034 1
  int open (int flags, mode_t mode = 0);
d1059 1
a1059 1
  int open (int flags, mode_t mode = 0);
d1086 1
a1086 1
  int open (int flags, mode_t mode = 0);
d1110 1
a1110 1
  DIR *opendir ();
d1119 1
a1119 1
  int open (int flags, mode_t mode = 0);
d1121 1
a1121 1
  int __stdcall fstat (struct stat *buf) __attribute__ ((regparm (2)));
d1134 2
a1135 2
  int open (int flags, mode_t mode = 0);
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d1152 2
a1153 2
  int open (int flags, mode_t mode = 0);
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d1166 2
a1167 2
  int open (int flags, mode_t mode = 0);
  int __stdcall fstat (struct __stat64 *buf) __attribute__ ((regparm (2)));
d1174 1
a1174 1
  int open (int flags, mode_t mode = 0);
@


1.154.2.4
log
@merge from trunk
@
text
@a806 1
  static int open_fhs;
@


1.154.2.5
log
@Merge from trunk.
* Makefile.in (devicess.cc): Make generation dependent on cygwin-gperf.
* cygheap.h (cygheap_fdmanip): Add fhandler_socket cast.
* cygwin-gperf: Autogenerate references to network devices.
* devices.h: Create separate device types for all network types.  Export
references to global network device storage.
* dtable.cc (dtable::release): Use generic determination to control when
need_fixup_before needs to be decremented.
(dtable::init_std_file_from_handle): Replace use of 'socket_dev' with
'tcp_dev'.
(build_fh_pc): Adapt to new socket types.  Don't increment fixup_before here.
* fhandler.h (fhandler_base::need_fixup_before): Declare/define.
(fhandler_socket::need_fixup_before): Ditto.
* fhandler_socket.cc (fhandler_socket::accept): Accommodate new fdsock
definition.
* net.cc: Throughout, change use of fdsock to return true/false for
success/failure and take cygheap_fdmanip type and device
* select.cc (set_bits): Use 'is_socket ()' test rather than specificially
testing device type.
@
text
@a259 1
  virtual bool need_fixup_before () const {return false;}
d314 1
a314 1
  virtual class fhandler_socket *is_socket () { return NULL; }
a412 1
  bool need_fixup_before () const {return true;}
@


1.154.2.6
log
@merge from trunk
@
text
@a895 3
  int close ();
  int dup (fhandler_base *child);
  void fixup_after_fork (HANDLE parent);
@


1.154.2.7
log
@merge from trunk
@
text
@d1097 1
a1097 2
  size_t bufalloc;
  __off64_t filesize;
@


1.154.2.8
log
@merge from trunk
@
text
@d287 1
a287 1
  virtual _off64_t lseek (_off64_t offset, int whence);
d293 1
a293 1
		       int flags, _off64_t off);
d347 2
a348 2
  virtual _off64_t telldir (DIR *);
  virtual void seekdir (DIR *, _off64_t);
d404 1
a404 1
  _off64_t lseek (_off64_t, int) { return 0; }
d445 1
a445 1
  _off64_t lseek (_off64_t offset, int whence);
a482 1
  int dup (fhandler_base *child);
d540 1
a540 1
  virtual _off64_t lseek (_off64_t offset, int whence);
d563 1
a563 1
  virtual _off64_t lseek (_off64_t offset, int whence);
d597 1
a597 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, _off64_t off);
d604 2
a605 2
  _off64_t telldir (DIR *);
  void seekdir (DIR *, _off64_t);
d620 2
a621 2
  _off64_t telldir (DIR *);
  void seekdir (DIR *, _off64_t);
d657 1
a657 1
  _off64_t lseek (_off64_t, int) { return 0; }
d709 1
a709 1
  virtual _off64_t lseek (_off64_t, int);
d900 1
a900 1
  _off64_t lseek (_off64_t, int) { return 0; }
d930 1
a930 1
  _off64_t lseek (_off64_t, int) { return 0; }
d971 1
a971 1
  _off64_t lseek (_off64_t offset, int whence);
d991 1
a991 1
  _off64_t lseek (_off64_t offset, int whence);
d1002 1
a1002 1
  _off64_t pos;
d1011 1
a1011 1
  _off64_t lseek (_off64_t offset, int whence);
d1016 1
a1016 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, _off64_t off);
d1033 1
a1033 1
  _off64_t lseek (_off64_t offset, int whence);
d1041 1
a1041 1
  _off64_t pos;
d1059 1
a1059 1
  _off64_t lseek (_off64_t, int) { return 0; }
d1086 1
a1086 1
  _off64_t lseek (_off64_t, int);
d1098 2
a1099 2
  _off64_t filesize;
  _off64_t position;
d1108 2
a1109 2
  _off64_t telldir (DIR *);
  void seekdir (DIR *, _off64_t);
d1114 1
a1114 1
  _off64_t lseek (_off64_t, int);
d1144 2
a1145 2
  _off64_t telldir (DIR *);
  void seekdir (DIR *, _off64_t);
@


1.154.2.9
log
@merge from trunk
@
text
@d28 1
a28 1
  FH_LSEEKED	= 0x00400000,	/* set when lseek is called as a flag that
d30 1
a30 2
				 * EOF, zero filling or making file sparse
				   if so. */
d107 1
a107 1
  __ino64_t namehash;	/* hashed filename, used as inode num */
a120 1
  DWORD fs_flags;
d195 2
a196 2
  void set_did_lseek (int b = 1) { FHCONDSETF (b, LSEEKED); }
  bool get_did_lseek () { return FHISSETF (LSEEKED); }
a228 4
  void set_fs_flags (DWORD flags) { fs_flags = flags; }
  bool get_fs_flags (DWORD flagval = 0xffffffffUL)
    { return (fs_flags & (flagval)); }

d253 1
a253 1
  __ino64_t get_namehash () { return namehash; }
@


1.154.2.10
log
@merge from trunk
@
text
@d23 2
a24 1
  FH_ENC	= 0x00080000,	/* native path is encoded */
a202 3
  bool get_encoded () { return FHISSETF (ENC);}
  void set_encoded () { FHSETF (ENC);}

a389 1
  int get_connect_state () const { return had_connect_or_listen; }
@


1.153
log
@* fhandler.h (fhandler_tty_master::set_winsize): Declare new function.
* fhandler_console.cc (fhandler_console::send_winch_maybe): If appropriate,
call tty master function to handle screen size change.
* fhandler_tty.cc (fhandler_tty_master::set_winsize): New function.
(fhandler_tty_master::init): Call set_winsize to set initial screen size.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.153.2.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d45 36
d83 1
a83 3
#include "devices.h"

#define FHDEVN(n)	(n)
d173 1
a173 2
  device dev;
  void set_name (const char *unix_path, const char *win32_path = NULL);
d176 1
a176 1
  fhandler_base (DWORD dev);
d182 3
a184 4
  DWORD get_device () { return dev.devn; }
  DWORD get_major () { return dev.major; }
  DWORD get_minor () { return dev.minor; }
  virtual int get_unit () { return dev.minor; }
d308 1
a308 1
  virtual char const *ttyname () { return get_name(); }
d357 1
a357 1
  virtual const char *get_native_name ()
d359 1
a359 1
    return dev.fmt;
a375 1
  virtual bool is_slow () {return 0;}
d393 1
a393 1
  fhandler_socket *is_socket () { return this; }
a451 1
  bool is_slow () {return 1;}
a479 10
  static int create (fhandler_pipe *[2], unsigned, int, bool = false);
  bool is_slow () {return 1;}
};

class fhandler_fifo: public fhandler_pipe
{
public:
  fhandler_fifo ();
  int open (path_conv *, int flags, mode_t mode = 0);
  bool is_slow () {return 1;}
d590 1
a590 1
  int open (path_conv *real_path, int flags, mode_t mode);
a683 1
  bool is_slow () {return 1;}
d809 1
a809 1
  const unsigned char *write_normal (unsigned const char*, unsigned const char *);
a851 1
  bool is_slow () {return 1;}
d881 1
a888 1
  bool is_slow () {return 1;}
a953 1
  bool is_slow () {return 1;}
a1072 1
  bool is_slow () {return 1;}
d1093 1
a1093 1
  int dup (fhandler_base *child);
d1119 1
a1119 1
  int dup (fhandler_base  child);
d1233 4
d1239 1
a1239 3
  void *device_specific_pipe;
  void *device_specific_socket;
  void *device_specific_serial;
a1245 4
  select_stuff (): always_ready (0), windows_used (0), start (0),
		   device_specific_pipe (0),
		   device_specific_socket (0),
		   device_specific_serial (0) {}
@


1.153.2.2
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d432 1
a432 1
  fhandler_pipe ();
d475 1
d485 1
a485 1
  fhandler_dev_raw (DWORD dev);
d490 2
d513 1
a513 1
  fhandler_dev_floppy ();
d536 1
a536 1
  fhandler_dev_tape ();
d603 1
d608 2
a609 2
  bool iscygdrive_root () const { return !dev.minor; }
  fhandler_cygdrive ();
d634 1
a634 1
  fhandler_serial ();
d683 2
a684 2
  fhandler_termios (DWORD dev) :
  fhandler_base (dev)
d839 2
a840 2
  fhandler_tty_common (DWORD dev)
    : fhandler_termios (dev), output_done_event (NULL),
d842 1
a842 1
    input_mutex (NULL), input_available_event (NULL), inuse (NULL)
d855 1
d878 1
d902 1
a902 1
  fhandler_pty_master (DWORD devtype = FH_PTYM);
d930 2
a931 2
  fhandler_tty_master ();
  int init ();
d965 1
d974 2
a975 1
  fhandler_dev_random ();
d989 1
d994 1
a994 1
  fhandler_dev_mem ();
d1103 1
a1103 1
  int dup (fhandler_base *child);
@


1.153.2.3
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d143 1
a143 1
  fhandler_base ();
d484 1
a484 1
  fhandler_dev_raw ();
d565 1
d679 2
a680 2
  fhandler_termios () :
  fhandler_base ()
d835 2
a836 2
  fhandler_tty_common ()
    : fhandler_termios (), output_done_event (NULL),
d896 1
a896 1
  fhandler_pty_master ();
d1082 1
a1082 1
  fhandler_virtual ();
d1106 1
@


1.153.2.4
log
@* cygwin-gperf: New file.
* Makefile.in: Use cygwin-gperf script to build devices.cc.
* configure.in: Remove some comments.
* configure: Regenerate.
* devices.gperf: Remove max unit determination from FH_TTY.  Add /dev/kmem.
Add /dev/fifo.  Add /dev/rawdrive.  Remove specific "const device *"
declarations since they are now autogenerated.
(device::parse): Treat FH_TTY specially.  Move logic for determining real tty
device to separate function.
(device::init): Reduce to nothing.
(device::parse): New function taking different arguments.
(device::parse): Ditto.
(device::tty_to_real_device): New function.
* devices.h (struct device): Define above new functions.
(device::dev_on_fs): New element.
(device::setfs): New function.
(device::isfs): Ditto.
* dtable.cc (dtable::build_fhandler): Treat FH_TTY specially.
* fhandler.cc (fhandler_base::set_name): Make special determination for
non-disk-resident devices.
* fhandler.h (fhandler_base::isdevice): Renamed from 'is_device'.
(fhandler_disk_file::isdevice): Ditto.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_device): New function.
(fhandler_tty_slave::get_unit): Declare.
(fhandler_disk_file::readdir): Take special .lnk consideration for devices as
well as symlinks.
* fhandler_tty.cc: Use get_unit () rather than dev.minor throughout.
(fhandler_tty_slave::get_unit): Define new function.
* path.cc (symlink_info::major): New element.
(symlink_info::major): Ditto.
(symlink_info::devtype): Ditto.
(path_conv::check): Handle devices detected by symlink_info::check.
(win32_device_name): Eliminate special FH_TTY handling.
(symlink): Move bulk of procesing to symlink_worker.
(symlink_worker): New function.  Handles devices.
(symlink_info::parse_device): Parse info from potential device file into
symlink_info elements.
(symlink_info::check): If contents of .lnk file begin with a ':' then treat the
file as a device file.
* path.h (isdevice): Renamed from is_device.
(is_auto_device): New function.
(is_fs_device): Ditto.
* syscalls.cc (chown_worker): Allow setting of ownership for on-disk devices.
(chmod): Ditto.
(mknod): Implement.
* winsup.h (symlink_worker): Declare.
@
text
@d306 1
a306 1
  virtual bool isdevice () { return true; }
a344 2
  bool is_auto_device () {return isdevice () && !dev.isfs ();}
  bool is_fs_device () {return dev.isfs ();}
d569 1
a569 1
  bool isdevice () { return false; }
a885 1
  int get_unit () __attribute__ ((regparm (1)));
@


1.153.2.5
log
@* sysconf.cc (sysconf): Return arbitrary values for _SC_GETGR_R_SIZE_MAX,
_SC_LOGIN_NAME_MAX, _SC_GETPW_R_SIZE_MAX.
* passwd.cc (getpwuid_r32): Add uid/gid fields to size check calculation.
* exceptions.cc (events_init): Display name of mutex on failure.
* windows.cc (setitimer): Return ENOSYS on invalid argument.
@
text
@a271 1
  int open_fs (path_conv *real_path, int flags, mode_t mode = 0);
a272 1
  int close_fs ();
a273 13
  int __stdcall fstat_fs (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
  int __stdcall fstat_helper (struct __stat64 *buf, path_conv *pc,
			      FILETIME ftCreateionTime,
			      FILETIME ftLastAccessTime,
			      FILETIME ftLastWriteTime,
			      DWORD nFileSizeHigh,
			      DWORD nFileSizeLow,
			      DWORD nFileIndexHigh = 0,
			      DWORD nFileIndexLow = 0,
			      DWORD nNumberOfLinks = 1)
    __attribute__ ((regparm (3)));
  int __stdcall fstat_by_handle (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
  int __stdcall fstat_by_name (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
a306 1
  virtual bool isfifo () { return false; }
a460 1
  bool isfifo () { return true; }
d573 12
@


1.153.2.6
log
@* devices.h (_devtype_t): Eliminate.
(_mode_t): New typedef.
(device::mode): Replace type.
* fhandler.h (fhandler_base::device_access_denied): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Define new function.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Just copy mode directly
from dev.mode to st_mode if it is a disk device.
* path.cc (path_conv::check): Set device mode from sym mode.
(symlink_worker): Let "exists" check happen when file is attempted to be
opened, or not, in the case of creating a device.
(symlink_info::parse_device): Change device type argument to device mode
argument.
(mknod_worker): New function.
(chmod_device): Ditto.
(chmod): Use chmod_device to set protection if it is an fs device.
(mknod): Use mknod_worker to actually create the device.  Don't take any
special action with the protection since it is now implicit.
@
text
@a362 1
  bool device_access_denied (int) __attribute__ ((regparm (1)));
@


1.153.2.7
log
@Replace is_fs_device with is_fs_special throughout.
* Makefile.in (DLL_OFILES): Add fhandler_fifo.o.
* devices.h (fh_devices): Renumber some minor numbers to fit in 8 bits.
* dtable.cc (dtable::build_fhandler): Handle FH_FIFO.  Set errno to ENODEV if
device not found.
* dtable::find_fifo: Define new function.
* dtable.h (dtable::find_fifo): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Fix O_RDONLY test.
(fhandler_base::write): Use output file handle for writing.
(fhandler_base::fstat): Use is_fs_special rather than is_fs_device.
* fhandler.h (fhandler_base::is_fs_special): Rename from is_fs_device.
(fhandler_pipe): Make private elements protected so that fhandler_fifo can use
them too.
(fhandler_pipe::create): New function derived from make_pipe.
(fhandler_fifo): Add more needed elements.
(fhandler_pty_master::slave): Add to track slave device.
(fhandler_pty_master::get_unit): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Register slave device.
(fhandler_pty_master::open): Ditto.
(symlink_info::parse_device): Handle fifo specially.
* pinfo.cc (_pinfo::commune_recv): Initial fifo implementation.
(_pinfo::commune_send): Ditto.
* pinfo.h (picom): Add PICOM_FIFO.
* pipe.cc (fhandler_pipe::close): Close input handle here specifically.
(fhandler_pipe::create): Rename from make_pipe.  Create fhandlers rather than
fds.
(pipe): Use fhandler_pipe::create to create pipe.
(_pipe): Ditto.
* syscalls.cc (mknod): Accommodate fifos.
@
text
@d149 4
a152 4
  DWORD get_device () const { return dev.devn; }
  DWORD get_major () const { return dev.major; }
  DWORD get_minor () const { return dev.minor; }
  virtual int get_unit () const { return dev.minor; }
d154 1
a154 1
  int get_access () const { return access; }
d362 1
a362 1
  bool is_fs_special () {return dev.isfs ();}
a444 1
protected:
d450 1
a450 1
public:
d466 1
a470 1
  friend class fhandler_fifo;
a474 5
  HANDLE output_handle;
  HANDLE owner;		// You can't have too many mutexes, now, can you?
  ATOM upand;
  long read_use;
  long write_use;
a477 3
  int open_not_mine (int flags) __attribute__ ((regparm (2)));
  int close ();
  void set_use (int flags) __attribute__ ((regparm (2)));
a478 3
  HANDLE& get_output_handle () { return output_handle; }
  void set_output_handle (HANDLE h) { output_handle = h; }
  void set_use ();
a479 1
  ATOM& get_atom () {return upand;}
d900 1
a900 3
protected:
  device slave;			// device type of slave
public:
a923 1
  int get_unit () const { return slave.minor; }
@


1.152
log
@* fhandler.h (fhandler_termios::line_edit): Replace third argument with
passed-in termios struct.
* fhandler_console.cc (fhandler_console::read): Prior to loop, make a copy of
current termios for passing to line_edit prior so that all characters are
processed consistently.
* fhandler_tty.cc (fhandler_pty_master::write): Ditto.
(process_input): Make a copy of curent termios prior to read for use in
subsequent line_edit.
* fhandler_termios.cc (fhandler_termios::line_edit): Replace third parameter
with passed-in termios struct and use it throughout rather than the data from
the current fhandler_termios class.
@
text
@d951 1
@


1.151
log
@* fhandler.h (line_edit_status): Reorganize so that tests for error condition
can be < or >.
* fhandler_tty.cc (fhandler_pty_master::write): Don't return after sending a
signal.
* fhandler_termios.cc (fhandler_termios::line_edit): Trivial change to use
built-in bool types.
@
text
@d708 1
a708 1
  line_edit_status line_edit (const char *rptr, int nread, int always_accept = 0);
@


1.150
log
@* fhandler.h (line_edit_status): Add a new element.
* fhandler_termios.cc (fhandler_termios::line_edit): After accept_input, handle
both potential error condition and pipe full conditions.
* fhandler_tty.cc (fhandler_pty_master::accept_input): Return -1 on error.
(fhandler_pty_master::write): Handle pipe full condition.
@
text
@a122 1
  line_edit_signalled = -1,
d125 3
a127 2
  line_edit_error = 2,
  line_edit_pipe_full = 3
@


1.149
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d126 2
a127 1
  line_edit_error = 2
@


1.148
log
@* cygthread.h (cygthread::stack_ptr): New element.
(cygthread::detach): Accept a "wait_for_signal" argument.
(cygthread::terminate_thread): New function.
* cygthread.cc (cygthread::stub): Set stack pointer argument.
(cygthread::terminate_thread): New function.  Forcibly terminate thread.
(cygthread::detach): Optionally wait for signals and kill thread when signal
arrives.
* exceptions.cc (signal_exit): Set signal_arrived prior to exiting to wake up
anything blocking on signals.
* fhandler.h (fhandler_base::set_r_no_interrupt): Change to accept bool
argument.
(fhandler_pipe::ready_for_read): Declare.
* pipe.cc (pipeargs): New structure.
(read_pipe): New thread stub wrapper for normal pipe read.
(fhandler_pipe::read): Modify to call reader in a cygthread, terminating on
signal, as appropriate.
* select.cc (fhandler_pipe::ready_for_read): Define new function.
@
text
@d169 1
d308 1
a308 1
  virtual int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d343 1
a343 1
  virtual int raw_read (void *ptr, size_t ulen);
d467 1
a467 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d473 1
d514 1
a514 1
  int raw_read (void *ptr, size_t ulen);
d660 1
a660 1
  int raw_read (void *ptr, size_t ulen);
d828 1
a828 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d899 1
a899 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d926 1
a926 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d971 1
a971 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d993 1
a993 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d1014 1
a1014 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d1036 1
a1036 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d1061 1
a1061 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d1087 1
a1087 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d1115 1
a1115 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
@


1.147
log
@* fhandler.h (fhandler_termios::line_edit): Change return from an int to an
enum to allow the function to return an error.
* fhandler_console.cc (fhandler_console::read): Update the line_edit call to
use the new enum.
* fhandler_termios.cc (fhandler_termios::line_edit): Change return from an int
to an enum to allow the function to return an error.  Put put_readahead call
before doecho for future patch.
* fhandler_tty.cc (fhandler_pty_master::write): Change to call line_edit one
character at a time, and stop if an error occurs.
@
text
@d222 1
a222 1
  void set_r_no_interrupt (int b) { FHCONDSETF (b, NOEINTR); }
d476 1
@


1.146
log
@* fhandler.h (class fhandler_pipe): New ioctl() method.
* pipe.cc (fhandler_pipe::ioctl): New.
@
text
@d121 8
d704 1
a704 1
  int line_edit (const char *rptr, int nread, int always_accept = 0);
@


1.145
log
@* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
@
text
@d462 1
@


1.144
log
@* external.cc (cygwin_internal): Implement CW_CMDLINE.
* pinfo.h (SIGCOMMUNE): New signal type.
(commune_result): New structure for commune functions.
(picom): New enum for commune functions.
(_pinfo::hello_pid): New.  Pid who's communicating with me.
(_pinfo::tothem): New.  Handle of communicating pipe.
(_pinfo::fromthem): Ditto.
(_pinfo::commune_recv): Declare.
(_pinfo::commune_send): Declare.
(_pinfo::alive): Declare.
(_pinfo::cmdline): Declare.
(_pinfo::lock): Declare.
* pinfo.cc (set_myself): Initialize new _pinfo lock.
(_pinfo::alive): Define.  Determines if process still exists.
(_pinfo::commune_recv): Define.  Receive info from another cooperating process.
(_pinfo::commune_send): Define.  Send info to another cooperating process.
(_pinfo::cmdline): Define.  Determine command line of a given process.
* include/sys/cygwin.h (CW_CMDLINE): Define.
*sigproc.cc (talktome): Communicate with any processes who want to talk to me.
(wait_sig): Honor __SIGCOMMUNE.
* fhandler.cc (fhandler_virtual::fixup_after_exec): Declare.
* fhandler_proc.cc: Use malloc/free/realloc throughout rather than cmalloc
since buffers don't need to be propagated to subprocesses.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
(fhandler_virtual::fixup_after_exec): Define.
* fhandler_process.cc: Ditto for malloc/free/realloc.
(process_listin): Add "cmdline".
(fhandler_process::fill_filebuf): Implement PROCESS_CMDLINE.
* miscfuncs.cc (isalpha_array): New array populated with xor values for alpha
characters to switch from one case to another.
* string.h (cygwin_strcasematch): New asm implementation of case match.
* string.h (cygwin_nstrcasematch): New asm implementation of counted case
match.
@
text
@d629 1
a629 1
  unsigned int vmin_;			/* from termios */
@


1.144.2.1
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
* fhandler.h (fhandler_serial::vmin_): Declare as size_t.
* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@d629 1
a629 1
  size_t vmin_;				/* from termios */
d1110 1
@


1.143
log
@* cygthread.cc (cygthread::stub): Don't create an event for "cygself" threads.
Assume that they exit via an ExitThread call.
* cygthread.h (cygthread::SetThreadPriority): New function.
(cygthread::zap_h): New function.
* dcrt0.cc (do_exit): Move cygthread::terminate earlier and establish
exit_state guard.
* fhandler.h (fhandler_tty_master::output_thread): Delete.
* fhandler_tty.cc (fhandler_tty_master::init): Set priority for threads via
method.  Zap handles when done.  Don't treat process_output specially.
(process_output): Call ExitThread directly.
(fhandler_tty_master::fixup_after_fork): Don't worry about output_thread.
(fhandler_tty_master::fixup_after_exec): Ditto.
* sigproc.cc (proc_terminate): Don't detach from hwait_subproc.  Just let it
exit.
(sigproc_init): Close thread handle after initialization.
(wait_sig): Use GetCurrentThread() as SetThreadPriority call rather than
*event* handle.  Call ExitThread directly on termination.
(wait_subproc): Call ExitThread directly on termination.
* tty.cc (tty_list::terminate): Don't attempt t detach from output_thread.
@
text
@d1110 1
@


1.142
log
@* cygheap.cc (dup_now): Make fatal error a little more informative.
(cygheap_setup_for_child): Detect when default size of shared region is less
than the current size and allocate that much.
(_cbrk): Just return NULL on inability to allocate.
(_cmalloc): Ditto.
* cygheap.h (CYGHEAPSIZE): Change size to reflect newer, tinier fhandler sizes.
* spawn.cc (av::error): New element, reflects potential errno from cmalloc.
(av::~av): Don't free NULL pointers.
(av::replace0_maybe): Detect out-of-memory conditions.
(av::dup_maybe): Ditto.
(av::dup_all): Ditto.
(av::unshift): Ditto.
(spawn_guts): Set errno and return if argv creation ran into problems.
* fhandler.h (fhandler_union): Change member names to something safer.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Always set
fhandler_console::dev_state regardless of whether shared region is initialized.
* cygthread.cc (cygthread::runner): Use ExitThread rather than return
(planning for future).
@
text
@a928 1
class cygthread;
a933 1
  cygthread *output_thread;		// process_output thread
@


1.141
log
@* fhandler.h (dev_console): New class.
(fhandler_console::dev_state): New class element.
(fhandler_console::mouse_aware): Use dev_state element.
(fhandler_console::get_tty_stuff): Declare new function.
* fhandler_console.cc: Use dev_state fhandler_console element, throughout.
(fhandler_console::get_tty_stuff): Move to fhandler_console class.  Incorporate
dev_console information.  Move constructor stuff here.
@
text
@a727 1
class fhandler_console;
d1162 26
a1187 24
  char base[sizeof(fhandler_base)];
  char console[sizeof(fhandler_console)];
  char dev_clipboard[sizeof(fhandler_dev_clipboard)];
  char dev_dsp[sizeof(fhandler_dev_dsp)];
  char dev_floppy[sizeof(fhandler_dev_floppy)];
  char dev_mem[sizeof(fhandler_dev_mem)];
  char dev_null[sizeof(fhandler_dev_null)];
  char dev_random[sizeof(fhandler_dev_random)];
  char dev_raw[sizeof(fhandler_dev_raw)];
  char dev_tape[sizeof(fhandler_dev_tape)];
  char dev_zero[sizeof(fhandler_dev_zero)];
  char disk_file[sizeof(fhandler_disk_file)];
  char pipe[sizeof(fhandler_pipe)];
  char proc[sizeof(fhandler_proc)];
  char process[sizeof(fhandler_process)];
  char pty_master[sizeof(fhandler_pty_master)];
  char registry[sizeof(fhandler_registry)];
  char serial[sizeof(fhandler_serial)];
  char socket[sizeof(fhandler_socket)];
  char termios[sizeof(fhandler_termios)];
  char tty_common[sizeof(fhandler_tty_common)];
  char tty_master[sizeof(fhandler_tty_master)];
  char tty_slave[sizeof(fhandler_tty_slave)];
  char windows[sizeof(fhandler_windows)];
@


1.140
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d718 8
a725 8
#define normal 1
#define gotesc 2
#define gotsquare 3
#define gotarg1 4
#define gotrsquare 5
#define gotcommand 6
#define gettitle 7
#define eattitle 8
d728 2
a729 2
/* This is a input and output console handle */
class fhandler_console: public fhandler_termios
a730 2
 private:

d778 8
d829 1
a829 1
  bool mouse_aware () {return use_mouse;}
d839 1
@


1.139
log
@	* fhandler.h (fhandler_socket::read): Remove method.
	(fhandler_socket::write): Ditto.
	(fhandler_socket::readv): New method.
	(fhandler_socket::writev): Ditto.
	(fhandler_socket::recvmsg): Add new optional argument.
	(fhandler_socket::sendmsg): Ditto.
	* fhandler.cc (fhandler_socket::read): Remove method.
	(fhandler_socket::write): Ditto.
	(fhandler_socket::readv): New method.
	(fhandler_socket::writev): Ditto.
	(fhandler_socket::recvmsg): Use win32's scatter/gather IO where
	possible.
	(fhandler_socket::sendmsg): Ditto.
	* net.cc (cygwin_recvmsg): Check the msghdr's iovec fields.
	(cygwin_sendmsg): Ditto.  Add omitted sigframe.
@
text
@a956 1
  int close (void);
@


1.138
log
@(inspired by a patch from Egor Duda)
* select.cc (fhandler_tty_slave::ready_for_read): Remove.
* fhandler.h (fhandler_tty_slave::ready_for_read): Remove declaration.
* fhandler_tty.cc (fhandler_tty_slave::read): Don't do anything special with
vtime when vmin == 0.
* autoload.cc (GetConsoleWindow): Correct parameter count.
@
text
@d403 1
a403 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d406 1
a406 1
  int recvmsg (struct msghdr *msg, int flags);
d408 1
a408 1
  int write (const void *ptr, size_t len);
d411 1
a411 1
  int sendmsg (const struct msghdr *msg, int flags);
@


1.137
log
@* miscfuncs.cc (check_iovec_for_read): Don't check buffer when zero length
iov_len.
(check_iovec_for_write): Ditto.
* fhandler.h (fhandler_base::readv): New method.
(fhandler_base::writev): Ditto.
* fhandler.cc (fhandler_base::readv): New method.
(fhandler_base::writev): Ditto.
* syscalls.cc (_read): Delegate to readv(2).
(_write): Ditto, mutatis mutandi.
(readv): Rewrite, based on the old _read code, to use the new
fhandler_base::readv method.  Improve access mode handling and ensure all calls
reach the final strace statement.
(writev): Ditto, mutatis mutandi.
* include/sys/uio.h (struct iovec): Change field types to match SUSv3.
* winsup.h (check_iovec_for_read): New function.
(check_iovec_for_write): Ditto.
* miscfuncs.cc (check_iovec_for_read): Ditto.
(check_iovec_for_write): Ditto.
@
text
@a890 2
  int ready_for_read (int fd, DWORD howlong);

@


1.136
log
@	* fhandler.h (fhandler_socket::recvfrom): Fix prototype.
	(fhandler_socket::sendto): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::sendto): Ditto.
	* include/sys/socket.h (recv): Fix prototype.
	(recvfrom): Ditto.
	(send): Ditto.
	(sendto): Ditto.
	* net.cc (cygwin_sendto): Ditto. Improve strace message
	(cygwin_recvfrom): Ditto.  Ditto.
	(cygwin_setsockopt): Improve strace message.
	(cygwin_getsockopt): Ditto.
	(cygwin_connect): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_bind): Ditto.
	(cygwin_getsockname): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_recv): Fix prototype.
	(cygwin_send): Ditto.
	(cygwin_recvmsg): Improve strace message.
	(cygwin_sendmsg): Ditto.
@
text
@d119 1
d301 2
@


1.135
log
@* fhandler.h (fhandler_console::send_winch_maybe): New method.
* fhandler_console.cc (set_console_state_for_spawn): Remove if 0'ed code.
(fhandler_console::send_winch_maybe): Define new method.
(fhandler_console::read): Use send_winch_maybe where appropriate.
(fhandler_console::init): Just call all tcsetattr rather than output_tcsetattr.
* select.cc (peek_console): Reorganize so that send_winch_maybe is called for
everything but keyboard input.
@
text
@d401 1
a401 1
  int recvfrom (void *ptr, size_t len, unsigned int flags,
d406 1
a406 1
  int sendto (const void *ptr, size_t len, unsigned int flags,
@


1.134
log
@	* fhandler.h (fhandler_socket::recv): Remove method.
	(fhandler_socket::send): Ditto.
	* fhandler_socket.cc (fhandler_socket::recv): Ditto.
	(fhandler_socket::send): Ditto.
	(fhandler_socket::read): Delegate to fhandler_socket::recvfrom.
	(fhandler_socket::write): Delegate to fhandler_socket::sendto.
	(fhandler_socket::sendto): Check for null `to' address.
	* net.cc (cygwin_sendto): Check for zero request length.
	(cygwin_recvfrom): Ditto.  Fix signature, use void *buf.
	(cygwin_recv): Delegate to cygwin_recvfrom.
	(cygwin_send): Delegate to cygwin_sendto.
@
text
@d829 1
@


1.133
log
@* cygthread.cc (cygthread::exit_thread): Define new method.
* cygthread.h (cygthread::exit_thread): Declare new method.
* fhandler.h (fhandler_tty_master::hThread): Delete.
(fhandler_tty_master::output_thread): Define.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Adjust
constructor.
(fhandler_tty_master::init): Use cygthread rather than handle.
(process_output): Use cygthread method to exit.
(fhandler_tty_master::fixup_after_fork): Set output_thread to NULL after fork.
(fhandler_tty_master::fixup_after_exec): Set output_thread to NULL after
spawn/exec.
* tty.cc (tty_list::terminate): Detach from output_thread using cygthread
method.
@
text
@a399 1
  int recv (void *ptr, size_t len, unsigned int flags);
a404 1
  int send (const void *ptr, size_t len, unsigned int flags);
a405 1

@


1.132
log
@	* fhandler.h (fhandler_base::get_r_no_interrupt): Make non-virtual.
	* net.cc (fdsock): Call set_r_no_interrupt.
@
text
@d924 1
d930 1
a930 1
  HANDLE hThread;		// process_output thread handle.
@


1.131
log
@* fhandler.h (fhandler_base::get_r_no_interrupt): Make virtual.
@
text
@d212 1
a212 1
  virtual bool get_r_no_interrupt () { return FHISSETF (NOEINTR); }
@


1.130
log
@	* fhandler.h (class fhandler_serial): Add new members of
	the class - rts,dtr and method ioctl(). Variables rts and dtr
	important for Win 9x only.
	* fhandler_serial.cc (fhandler_serial::open): Add initial setting
	of dtr and rts. Important for Win 9x only.
	(fhandler_serial::ioctl): New function. Implements commands TIOCMGET,
	TIOCMSET and TIOCINQ.
	(fhandler_serial::tcflush): Fixed found error.
	(fhandler_serial::tcsetattr): Add settings of rts and dtr. Important
	for Win 9x only.
	* termios.h: Add new defines as a support for ioctl() function
	on serial device.
@
text
@d212 1
a212 1
  bool get_r_no_interrupt () { return FHISSETF (NOEINTR); }
@


1.129
log
@	* fhandler.h (fhandler_socket::is_unconnected): Constify.
	(fhandler_socket::is_connect_pending): Ditto.
	(fhandler_socket::is_connected): Ditto.
	(fhandler_socket::set_connect_state): New method.
	(struct select_record): Add member `except_on_write'.
	(select_record::select_record): Initialize all bool values to `false'.
	* fhandler_socket.cc: Use set_connect_state() method throughout.
	(fhandler_socket::connect): Set state always to connected if connection
	isn't pending.
	* net.cc (cygwin_getsockopt): Revert erroneous previous patch.
	* select.cc (set_bits): Check for `except_on_write'.  Set fd in
	write_fds if set.  Set connect state to connected if fd has been
	returned by WINSOCK_SELECT.
	(peek_socket): Check for `except_on_write'.
	(start_thread_socket): Ditto.
	(fhandler_socket::select_write): Don't set `write_ready' if connect
	is pending.  Set `except_on_write' if connect is pending.
@
text
@d632 2
d653 1
@


1.128
log
@	* fhandler.h (UNCONNECTED): New define.
	(CONNECT_PENDING): Ditto.
	(CONNECTED): Ditto.
	(class fhandler_socket): Add member `had_connect_or_listen'.
	Add member functions `is_unconnected', `is_connect_pending' and
	`is_connected'.
	* fhandler_socket.cc (fhandler_socket::connect): Set member
	`had_connect_or_listen' according to return code of WinSock
	call.
	(fhandler_socket::listen): Ditto.
	* net.cc (cygwin_getsockopt): Modify SO_ERROR return value in
	case of socket with pending connect().
	* select.cc (peek_socket): Only add socket to matching fd_set
	if it's not "ready".  Call WINSOCK_SELECT only if at least one
	socket is in one of the fd_sets.
	(start_thread_socket): Only add socket to matching fd_set
	if it's not "ready".
	(fhandler_socket::select_write): Set write_ready to true also
	if socket isn't connected or listening.
@
text
@d388 4
a391 3
  bool is_unconnected () {return had_connect_or_listen == UNCONNECTED;}
  bool is_connect_pending () {return had_connect_or_listen == CONNECT_PENDING;}
  bool is_connected () {return had_connect_or_listen == CONNECTED;}
d1189 1
d1198 4
a1201 3
		 fh (in_fh), saw_error (0), windows_handle (0),
		 read_ready (0), write_ready (0), except_ready (0),
		 read_selected (0), write_selected (0), except_selected (0),
@


1.127
log
@* autoload.cc (GetSecurityInfo): Define new autoload function.
(RegQueryInfoKeyA): Ditto.
* fhandler.h (fhandler_virtual::fill_filebuf): Change return type to bool.
(fhandler_proc::fill_filebuf): Ditto.
(fhandler_registry::fill_filebuf): Ditto.
(fhandler_process::fill_filebuf): Ditto.
(fhandler_registry::value_name): Add new member.
(fhandler_registry::close): Add new method.
(fhandler_process::p): Remove member.
* fhandler_proc.cc (fhandler_proc::open): Add set_nohandle after calling
superclass method.  Check return value of fill_filebuf.
(fhandler_proc::fill_filebuf): Change return type to bool.  Add return
statement.
* fhandler_process.cc (fhandler_process::open): Add set_nohandle after calling
superclass method.  Remove references to p.  Check return value of
fill_filebuf.
(fhandler_process::fill_filebuf): Change return type to bool.  Don't use
dereference operator on p.  Add return statement.
(fhandler_process::format_process_stat): Fix typo.
* fhandler_registry.cc: Add static open_key declaration.
(fhandler_registry::exists): Assume path is already normalised.  Try opening
the path as a key in its own right first, before reverting to enumerating
subkeys and values of the parent key.
(fhandler_registry::fstat): Add additional code to return more relevant
information about the registry key/value.
(fhandler_registry::readdir): Explicitly set desired access when opening
registry key.  Remove output of buf from debug_printf format string.
(fhandler_registry::open): Use set_io_handle to store registry key handle.  Set
value_name member.  Move code to read a value from the registry to
fill_filebuf.  Add call to fill_filebuf.
(fhandler_registry::close): New method.
(fhandler_registry::fill_filebuf): Change return type to bool.  Add code to
read a value from registry.
(fhandler_registry::open_key): Make function static.  Use KEY_READ as desired
access unless this is the last path component.  Check the return value of
RegOpenKeyEx for an error instead of hKey.
* fhandler_virtual.cc (fhandler_virtual::lseek): Check the return value of
fill_filebuf.
(fhandler_virtual::open): Remove call to set_nohandle.
(fhandler_virtual::fill_filebuf): Change return type to bool.  Add return
statement.
* security.cc (get_nt_object_attribute): New function.
(get_object_attribute): New function.
* security.h (get_object_attribute): New function declaration.
@
text
@d104 4
d374 1
d387 4
@


1.126
log
@* fhandler.h (fhandler_process::pid): New field.
(fhandler_process::fstat): Remove unneeded array.  Set pid element.
(fhandler_process::open): Ditto.
(fhandler_process::fill_filebuf): Handle case where 'p' field is NULL.
@
text
@d1093 1
a1093 1
  virtual void fill_filebuf ();
d1107 1
a1107 1
  void fill_filebuf ();
d1112 2
d1125 2
a1126 2
  HKEY open_key(const char *name, REGSAM access = KEY_READ, bool isValue = false);
  void fill_filebuf ();
a1132 1
  pinfo *p;
d1139 1
a1139 1
  void fill_filebuf ();
@


1.125
log
@* fhandler.h (fhandler_process::p): New field.
(fhandler_process:fill_filebuf): Revert to same definition as virtual in parent
class.
(fhandler_process::open): Fill out p field rather than passing as an argument.
(fhandler_process::fill_filebuf): Use p pointer rather than argument.
@
text
@a1109 1
class pinfo;
d1127 1
a1127 1
struct _pinfo;
d1130 1
@


1.124
log
@	* fhandler.h (fhandler_socket::bind): Add method definition.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::getsockname): Ditto.
	(fhandler_socket::getpeername): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	(fhandler_socket::shutdown): Ditto.
	* fhandler_socket.cc (get_inet_addr): Move here from net.cc.
	(fhandler_socket::bind): New method.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::getsockname): Ditto.
	(fhandler_socket::getpeername): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	(fhandler_socket::shutdown): Ditto.
	* net.cc: Various formatting cleanups throughout.
	(get_inet_addr): Move to fhandler_socket.cc.
	(cygwin_bind): Move base functionality to appropriate fhandler_socket
	method.
	(cygwin_connect): Ditto.
	(cygwin_listen): Ditto.
	(cygwin_accept): Ditto.
	(cygwin_getsockname): Ditto.
	(cygwin_getpeername): Ditto.
	(cygwin_recvfrom): Ditto.
	(cygwin_recvmsg): Ditto.
	(cygwin_sendto): Ditto.
	(cygwin_sendmsg): Ditto.
	(cygwin_shutdown): Ditto.
@
text
@d1131 1
d1138 1
a1138 1
  void fill_filebuf (pinfo& p);
@


1.123
log
@	* fhandler.h (fhandler_socket::fixup_after_fork): Revert patch from
	2002-06-04.
	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Ditto.
	(fhandler_socket::dup): Ditto.
	* net.cc (fdsock): Make sockets explicitely noninheritable on NT.
@
text
@d383 7
d392 3
d399 4
d406 1
@


1.122
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@a370 2
  void fixup_after_fork (bool, HANDLE);

@


1.121
log
@	* fhandler.h (class fhandler_socket): Add private method
	fixup_after_fork (bool, HANDLE).
	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Move
	functionality to new private method.  Add closing parent socket
	if not called from dup().  Create method new calling private method
	with appropriate parameter.
	(fhandler_socket::fixup_after_exec): Call private method
	fixup_after_fork with appropriate parameter.
	(fhandler_socket::dup): Ditto.
@
text
@d15 1
d178 1
a178 1
  void set_flags (int x) { openflags = x; }
d201 3
a203 3
    status = status & ~(FH_WBINARY | FH_WBINSET | FH_RBINARY | FH_RBINSET);
    status = status | ((FH_WBINARY | FH_WBINSET | FH_RBINARY | FH_RBINSET)
		       & open_status);
@


1.120
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d370 2
@


1.119
log
@* fhandler_console.cc (fhandler_console::open): Reinstate setting of flags.
@
text
@d1094 1
a1114 3
 private:
  pid_t saved_pid;
  _pinfo *saved_p;
d1121 1
a1121 1
  void fill_filebuf ();
@


1.118
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d182 2
a183 2
  bool get_w_binary () { return FHISSETF (WBINARY); }
  bool get_r_binary () { return FHISSETF (RBINARY); }
@


1.117
log
@* dtable.cc (dtable::build_fhandler_from_name): Just pass posix path along to
set_name via return_and_clear_normalized_path.
(dtable::build_fhandler): New method with const char * argument.
(dtable::reset_unix_path_name): Eliminate.
(dtable::dup_worker): Use correct build_fhandler method.
* mmap.cc (mmap_record::alloc_fh): Ditto.
* dtable.h (dtable::build_fhandler): New method.
(dtable::reset_unix_path_name): Eliminate.
* fhandler.cc (fhandler_base::set_name): Assume that unix_name has already been
cmalloced.
(fhandler_base::reset_unix_path_name): Eliminate.
(fhandler_base::~fhandler_base): Coercion for cfree.
* fhandler.h (fhandler_base::unix_path_name): Make const char *.
(fhandler_base::win32_path_name): Ditto.
(fhandler_base::reset_unix_path_name): Eliminate.
* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Accommodate const char
*ness of win32_path_name.
* fhandler_socket.cc (fhandler_socket::fstat): Accommodate new set_name
requirements.
* path.cc (path_conv::return_and_clear_normalized_path): New method.
(path_conv::clear_normalized_path): Eliminate.
(path_conv::~path_conv): Ditto.
(path_conv::check): Accommodate new build_fhandler method.
* path.h (path_conv::~path_conv): Eliminate.
(path_conv::clear_normalized_path): Ditto.
(path_conv::return_and_clear_normalized_path): Declare new method.
@
text
@d249 1
d256 1
a256 1
  void set_query_open (int val) { FHCONDSETF (val, QUERYOPEN); }
d556 12
a567 1
  int __stdcall fstat_helper (struct __stat64 *buf) __attribute__ ((regparm (2)));
@


1.116
log
@* fhandler.h (fhandler_virtual::exists): Eliminate path argument.
(fhandler_proc::exists): Ditto.
(fhandler_registry::exists): Ditto.
(fhandler_process::exists): Ditto.
* fhandler_proc.cc (fhandler_proc::exists): Ditto.  Use built-in name.
* fhandler_process.cc (fhandler_process::exists): Ditto.
(fstat): Ditto.
* fhandler_registry.cc (fhandler_registry::exists): Ditto.
(fhandler_registry::fstat): Ditto.
* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
* path.cc (path_conv::check): Ditto.  Add debugging.
* syscalls.cc (dup): Always call dup2 for error handling.
@
text
@d152 2
a153 2
  char *unix_path_name;
  char *win32_path_name;
d157 1
a157 2
  void set_name (const char * unix_path, const char * win32_path = NULL,
		 int unit = 0);
a158 1
  void reset_unix_path_name (const char *);
@


1.115
log
@* fhandler.h (executable_states): For now, make dont_care_if_executable
equivalent to not_executable.
* sys/mount.h: Define MOUNT_NOTEXEC.
* path.h (fs_info): New class.
(path_conv): Move fs-specific fields to new 'fs' structure.
(path_conv::update_fs_info): Move to fs_info and rename to just 'update'.
* path.cc (fs_info::update): Ditto.  Return 'true' if successful.
(fillout_mntent): Add ',noexec' to list of reported options.
@
text
@d1054 1
a1054 1
  virtual int exists(const char *path);
d1075 1
a1075 1
  int exists(const char *path);
d1088 1
a1088 1
  int exists(const char *path);
d1109 1
a1109 1
  int exists(const char *path);
@


1.114
log
@* autoload.cc: Add dynamic load statements for 'ZwQueryInformationProcess' and
'ZwQueryVirtualMemory'.
* fhandler.h: Change type of bufalloc and filesize members of fhandler_virtual
from int to size_t.  Change type of position member from __off32_t to
__off64_t.  Add new fileid member to fhandler_virtual class.  Make seekdir take
an __off64_t argument.  Make lseek take an __off64_t argument.  Add
fill_filebuf method to fhandler_virtual.  Add fill_filebuf method to
fhandler_proc.  Add fill_filebuf method to fhandler_registry.  Add fill_filebuf
method to fhandler_process.  Add saved_pid and saved_p members to
fhandler_process.
* fhandler_proc.cc (proc_listing_array): Add 'loadavg', 'meminfo', and 'stat'.
(proc_fhandlers array): Ditto.
(fhandler_proc::open): Use fill_filebuf to flesh out the file contents.
(fhandler_proc::fill_filebuf): New method.
(fhandler_proc::format_proc_meminfo): Ditto.
(fhandler_proc::format_proc_stat): Ditto.
(fhandler_proc::format_proc_uptime): Ditto.
* fhandler_process.cc (process_listing): Add 'stat' and 'statm'.
(fhandler_process::fstat): Find the _pinfo structure for the process named in
the filename.  Return ENOENT if the process is no longer around.  Set the gid
and uid fields of the stat structure.
(fhandler_process::open): Store pid and pointer to _pinfo structure in
saved_pid and saved_p respectively.  Use fill_filebuf to flesh out file
contents.
(fhandler_proc::fill_filebuf): New method.
(format_process_stat): New function.
(format_process_status): Ditto.
(format_process_statm): Ditto.
(get_process_state): Ditto.
(get_mem_values): Ditto.
* fhandler_registry.cc (fhandler_registry::seekdir): Change argument type from
__off32_t to __off64_t.
(fhandler_registry::fill_filebuf): New method.
* fhandler_virtual.cc (fhandler_virtual::seekdir): Change argument type from
__off32_t to __off64_t.
(fhandler_virtual::lseek): Ditto.
(fhandler_virtual::fill_filebuf): New method.
(fhandler_virtual::fhandler_virtual): Initialise fileid to -1.
* wincap.cc: Set flag has_process_io_counters appropriately.
* wincap.h: Add flag has_process_io_counters.
@
text
@a125 1
  not_executable,
d127 1
@


1.113
log
@* path.h (pathconv_arg): Add PC_POSIX.
(path_conv): Add normalized_path field.
* path.cc (path_conv::~path_conv): New destructor.
(path_conv::check): Set normalized_path, where appropriate.
* dtable.cc (build_fhandler_from_name): Use normalized path from path_conv.
* syscalls.cc (chroot): Ditto.
* cygheap.h: Remove path_prefix_p declaration.  Christopher Faylor
<cgf@@redhat.com> (minor fixups)
* Makefile.in: Add fhandler_proc.o, fhandler_registry.o, fhandler_process.o and
fhandler_virtual.o.
* dtable.cc (dtable::build_fhandler): Add entries for FH_PROC, FH_REGISTRY and
FH_PROCESS.  Set unix_name to the normalized posix path.
* fhandler.h: Add constants for FH_PROC, FH_REGISTRY and FH_PROCESS.  Add class
declarations for fhandler_virtual, fhandler_proc, fhandler_registry and
fhandler_virtual.  Update fhandler_union accordingly.
* fhandler_proc.cc: New file.  Add implementation for fhandler_proc.
* fhandler_virtual.cc: New file.  Add implementation for fhandler_virtual.
* fhandler_process.cc: New file.  Add implementation for fhandler_process.
* fhandler_registry.cc: New file.  Add implementation for fhandler_registry.
* path.cc: Add isproc and isvirtual_dev macros.
* path.cc (path_conv::check): Add check for virtual devices.
* path.cc (mount_info::conv_to_win32_path): Convert paths in /proc to empty
Win32 paths.
* path.cc (chdir): Replace check for FH_CYGDRIVE with more generic
isvirtual_dev macro.  Force setting of posix path for virtual fhandlers.
* path.h: Add externally visible path_prefix_p and normalized_posix_path
prototypes.
@
text
@d1046 3
a1048 2
  int bufalloc, filesize;
  __off32_t position;
d1057 1
a1057 1
  void seekdir (DIR *, __off32_t);
d1062 1
a1062 1
  __off64_t lseek (__off32_t, int);
d1067 1
d1081 1
d1091 1
a1091 1
  void seekdir (DIR *, __off32_t);
d1098 1
d1101 1
d1104 3
d1113 1
@


1.112
log
@	* net.cc (cygwin_accept): Set socket type for accepted socket.
	(socketpair): Set socket type for both sockets.

	From Egor Duda <deo@@logos-m.ru>:

	* fhandler.h (class fhandler_socket): New member to store socket type.
	(fhandler_socket::get_socket_type): Access it.
	(fhandler_socket::set_socket_type): Ditto.
	* net.cc (cygwin_socket): Store socket type.
	(cygwin_connect): Disable security checks for connectionless sockets.
	(cygwin_accept): Ditto.
@
text
@d73 3
d77 1
a77 1
  FH_NDEV    = 0x0000001a,	/* Maximum number of devices */
d106 2
d288 1
a288 1
  virtual int open (path_conv * real_path, int flags, mode_t mode = 0);
d520 2
a521 2
  int open (path_conv *, int flags, mode_t mode = 0);
  int close (void);
d523 1
a523 1
  __off64_t lseek (__off64_t offset, int whence);
d525 1
a525 1
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d527 1
a527 1
  int dup (fhandler_base *child);
d529 1
a529 1
  int ioctl (unsigned int cmd, void *buf);
d1042 65
d1122 2
d1125 1
@


1.111
log
@2002-03-15  Robert Collins  <rbtcollins@@hotmail.com>

        * fhandler.h (fhandler_termios::lseek): Override lseek.
        * fhandler_termios.cc (fhandler_termios::lseek): Implement this.
@
text
@d360 1
d401 2
@


1.110
log
@2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* Merged cygwin_daemon into head minus the new shm and ipc exports.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* fhandler_tty.cc (fhandler_tty_slave::open): More debugging.
	(fhandler_tty_slave::read): Fix printf type for the handle.
	* tty.cc (tty::common_init): Add a FIXME for security.

2002-01-29  Robert Collins  <rbtcollins@@hotmail.com>

	* Makefile.in (OBJS): Remove duplicate localtime.o.

2002-01-17  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (check_and_dup_handle): Consolidate the two variants for
	simplicity.
	Add Some basic debug output.
	(client_request_attach_tty::serve): Use the new debug_printf for clarity.
	Mark the duplicated handles as inheritable - fixup_after_fork() doesn't reopen
	tty's.

2002-01-16  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (transport): Correct scope.
	(client_request_attach_tty::serve): Add more debug information.
	Fix erroneous use of transport instead of conn.
	* cygserver_transport_pipes.cc (transport_layer_pipes::close): More debug.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.

Mon Oct  8  7:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (server_request::process): Rename client_request_shm_get to
	client_request_shm.
	* cygserver_process.cc (process_cache::add): Rename to add_task.
	Use process_cleanup instead of process_request.
	(process_cache::remove_process): New method.
	(process::process): Initialize new members.
	(process::~process): New member.
	(process::cleanup): New method.
	(process::add_cleanup_routine): New method.
	(process_request::process): Rename to process_cleanup.
	Call the process object's cleanup method and then delete it.
	(process_process_param::request_loop): Remove the signalling process.
	* cygserver_shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm_get::serve): Handle attach request counting.
	* cygserver_shm.h: Globally rename client_request_shm_get to client_request_shm.
	(class shm_cleanup): New class.
	* shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm::client_request_shm): New constructor for attach requests.
	(shmat): Use it.
	* include/cygwin/cygserver_process.h (class process_request): Rename to
	process_cleanup.
	(class cleanup_routine): New class.
	(class process): New members and methods to allow calling back when the process
	terminates.

Thu Oct  4 14:12:00 2001  Robert Collins <rbtcollins@@hotmail.com>
	* cygserver.cc (request_loop): Make static.
	(main): Use new cache constructor syntax.
	Start cache worker threads.
	Cleanup the cache at shutdown.
	* cygserver_process.cc: Run indent.
	(process_cache::process_cache): Add a trigger to use when adding a process.
	(process_cache::process): Move process_entry to process.
	Insert at the end of the list.
	Trigger the request loop when new process's inserted.
	(process_cache::process_requests): Do it.
	(process_cache::add): New method.
	(process_cache::handle_snapshot): New method.
	(process::process): Merge in the process_entry fields.
	(process::handle): Make a stub function.
	(process::exit_code): New method.
	(process_request::process): New method.
	(process_process_param::request_loop): New method.
	* cygserver_shm.cc: New header dependency - threaded_queue.h.
	* threaded_queue.cc (threaded_queue::cleanup): Clearer messages.
	(queue_process_param::stop): Short spinlock on interruptible threads.
	* threaded_queue.h (class threaded_queue): New constructor.
	* include/cygwin/cygserver_process.h (process_request): New class.
	(process_entry): Remove.
	(process): Merge in process_entry.
	(process_cache): Inherit from threaded_queue.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (class server_process_param): Use new constructor syntax.
	* cygserver_process.cc (process_cache::~process_cache): New function.
	* threaded_queue.cc: Define condition debug_printf.
	Run indent.
	(threaded_queue::cleanup): Move queue_process_param guts to a method.
	(threaded_queue::process_requests): Ditto.
	(queue_process_param::queue_process_param): New method.
	(queue_process_param::~queue_process_param): Ditto.
	(queue_process_param::start): Ditto.
	(queue_process_param::stop): Ditto.
	* threaded_queue.h (class queue_process_param): Add support for
	interruptible request loops.
	* cygwin/include/cygwin/cygserver_process.h (class process_cache): Add
	destructor.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver_client.cc: New flag allow_daemon to disable the daemon completely.
	(cygserver_request): Check it.
	(cygserver_init): Ditto.
	* environ.cc (parse_thing): Add (no)daemon option.

Tue Oct  2 23:00:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* shm.cc: Update to handle include changes from HEAD.

Tue Oct  2 16:06:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Remove cygserver_shm.o from cygwin1.dll.
	Rename cygserver_shm_outside.o to cygserver_shm.o.
	* cygserver.cc (server_request::process): Use the new client_request
	constructor.
	* cygserver_client.cc: Remove the #ifdef's stubs for the server method
	within cygwin.
	(client_request_attach_tty::client_request_attach_tty): Use the new
	client_request constructor.
	(client_request_shutdown::client_request_shutdown): Ditto.
	(client_request::client_request): Ditto.
	* cygserver_shm.cc (client_request_shm_get::serve): Remove the
	#ifdef'd stub for in-cygwin builds.
	(client_request_shm_get::client_request_shm_get): Use the new
	client_request constructor, and remove the in-cygwin variants.
	* cygserver_shm.h (class client_request_shm_get): #ifndef test the
	serve method - it's only used in cygserver.
	* shm.cc (client_request_shm_get::client_request_shm_get): New function.
	* include/cygwin/cygserver.h (request_header): New constructor.
	(class client_request): Use it.
	New constructor accepting the header size.
	#ifndef test the server method - it's only used within cygserver.
	(client_request_get_version): #ifdef test the server method.
	(client_request_shutdown): Ditto.
	(client_request_attach_tty): Ditto.

Tue Oct  2  9:57:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: add threaded_queue.o to cygserver.exe.
	* cygserver.cc: Include threaded_queue.h
	(class server_request): Inherit from queue_request.
	(class server_process_param): Inherit from queue_process_param.
	(class server_request_queue): Inherit from threaded_queue.
	(request_loop): Adjust for new types.
	(server_request_queue::process_requests): Remove guts to
	threaded_queue::process_requests.
	(server_request::server_request): Adjust for new types.
	(worker_function): Delete.
	(server_request_queue::create_workers): Delete.
	(server_request_queue::cleanup): Delete.
	(server_request_queue::add): Move guts to threaded_queue::add.
	* threaded_queue.cc: New file.
	* threaded_queue.h: New file.

Mon Oct  1 12:38:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (client_request::serve): New function.
	* cygserver_process.cc: Inlude <pthread.h> for pthread_once.
	(process_cache::process_cache): Initialise a crtiical section for write access.
	(process_cache::process): Use the critical section. Also add missing entries to
	the cache.
	(do_process_init): New function to initalise class process static variables.
	(process::process): Ensure that the process access critical section is
	initialised.
	(process::handle): Close the handle of old process's when they have terminated
	and we are returning the handle for a process with the same pid.
	* cygserver_shm.cc: Run indent.
	Include cygserver_process.h to allow process cache functionality.
	(client_request_shm_get::serve): New parameter for process cache support.
	Use the process cache, not OpenProcess to get a handle to the originating process.
	Fix a handle leak with token_handle.
	* cygserver_shm.h (class client_request_shm_get): Update ::serve for process
	cache support.
	* cygserver_transport_pipes.cc: Redefine debug_printf to be conditional on DEBUG.
	* include/cygwin/cygserver.h: Do not implement client_request::serve in the
	header.
	* include/cygwin/cygserver_process.h (class process_cache): Add a write access
	critical section to prevent races when requests from a  multithreaded
	application arrive.

Sun Sep 30 23:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_process.o to cygserver.exe.
	* cygserver.cc: Include signal.h and cygwin_version.h.
	Define debug_printf as a macro.
	Define DEBUG to a value.
	(client_request_attach_tty::serve): Add beginning of process cache support.
	Change from #ifdef DEBUG to work with new DEBUG style.
	(client_request_get_version::serve): Add beginning of process cache support.
	(class server_request): New prototype for support of process cache.
	(class queue_process_param): New class to allow request loop threading.
	(class server_request_queue): Add beginning of process cache support.
	Allow request loop threading.
	(request_loop): Thread function for request loops.
	(server_request_queue::process_requests): Initiator for threaded request loops.
	(client_request_shutdown::serve): Add beginning of process cache support.
	(server_request::server_request): Ditto.
	(server_request::process): Use debug_printf. Add beginning of process cache
	support.
	(server_request_queue::cleanup): Kill off any request loop threads.
	(server_request_queue::add): Add beginning of process cache support.
	(handle_signal): Trigger a shutdown.
	(main): Print out some useful info at startup - version, date time.
	Add process cache support.
	Spawn a separate thread for the transport request loop, thus allowing concurrent
	support for multiple transports.
	* cygserver_client.cc (client_request_get_version::serve): Add process cache
	support.
	(client_request_attach_tty::serve): Add process cache support.
	(client_request_shutdown::serve): Add process cache support.
	* cygsserver_process.cc: New file with the process cache support.
	* cygserver_shm.cc: Redefine debug_printf to allow conditional output.
	* cygwin.din: Export shmdt().
	* shm.cc: Run indent.
	Update FIXME's.
	(shmdt): New function.
	* include/cygwin/cygserver.h (class client_request): Add process cache support.
	(class client_request_get_version): Ditto.
	(class client_request_shutdown): Ditto.
	(class client_request_attach_tty): Ditto.
	* include/cygwin/cygserver_process.h: New header for process cache support.

Sun Sep 30  8:52:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* include/cygwin/cygserver_transport.h: Add copyright header.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.

Sat Sep 29 20:40:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_transport_sockets.o to DLL_OFILES.
	Add cygserver_transport_sockets_outside.o to cygserver.exe.
	* cygserver.cc: Include new include files.
	* cygserver_client.cc: Ditto.
	* cygserver_shm.h: No need to include <sys/socket.h> now.
	* cygerver_transport.cc: Include new include files.
	(transport_layer_base::transport_layer_base): Strip back to a stub.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.
	* cygserver_transport_pipes.cc: Include new header
	"cygwin/cygserver_transport_pipes.h".
	* cygserver_transport_sockets.cc: New file.
	* dcrt0.cc: No need to include <sys/socket.h> now.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.
	* include/cygwin/cygserver_transport.h: Strip the base class to a stub.
	Remove the cygserver_transport_pipes class.
	* include/cygwin/cygserver_transport_pipes.h: New file.
	* include/cygwin/cygserver_transport_sockets.h: New file.

Tue Sep 25 16:22:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* autoload.cc: Add dynamic load statement for 'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when obtaining
	handles from the parent process. On failure or 9x use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
	* cygserver.cc: New file.
	* cygserver_client.cc: New file.
	* cygserver_shm.cc: New file.
	* cygserver_shm.h: New file.
	* cygserver_transport.cc: New file.
	* cygserver_transport_pipes.cc: New file.
	* ipc.cc: New file.
	* shm.cc: New file.
	* include/cygwin/cygserver.h: New file.
	* include/cygwin/cygserver_transport.h: New file.
	* include/sys/ipc.h: New file.
	* include/sys/shm.h: New file.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* thread.cc (semaphore::TryWait): Set errno as required by posix 1003.1.
	(__sem_wait): Ditto.
	(__sem_trywait): Ditto.
@
text
@d660 1
@


1.109
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@d843 2
@


1.108
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d285 1
a285 1
  virtual int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (3)));
d291 1
a291 1
  virtual __off32_t lseek (__off32_t offset, int whence);
d297 1
a297 1
		       int flags, __off32_t off);
d350 2
a351 2
  virtual __off32_t telldir (DIR *);
  virtual void seekdir (DIR *, __off32_t);
d385 1
a385 1
  __off32_t lseek (__off32_t, int) { return 0; }
d408 1
a408 1
  int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (3)));
d420 1
a420 1
  __off32_t lseek (__off32_t offset, int whence);
d492 1
a492 1
  virtual __off32_t lseek (__off32_t offset, int whence);
d515 1
a515 1
  __off32_t lseek (__off32_t offset, int whence);
d517 1
a517 1
  int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (3)));
d548 2
a549 2
  int __stdcall fstat (struct stat *buf, path_conv *pc) __attribute__ ((regparm (3)));
  int __stdcall fstat_helper (struct stat *buf) __attribute__ ((regparm (2)));
d551 1
a551 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, __off32_t off);
d558 2
a559 2
  __off32_t telldir (DIR *);
  void seekdir (DIR *, __off32_t);
d575 2
a576 2
  __off32_t telldir (DIR *);
  void seekdir (DIR *, __off32_t);
d579 1
a579 1
  int __stdcall fstat (struct stat *buf, path_conv *pc) __attribute__ ((regparm (3)));
d609 1
a609 1
  __off32_t lseek (__off32_t, int) { return 0; }
d840 1
a840 1
  __off32_t lseek (__off32_t, int) { return 0; }
d867 1
a867 1
  __off32_t lseek (__off32_t, int) { return 0; }
d906 1
a906 1
  __off32_t lseek (__off32_t offset, int whence);
d929 1
a929 1
  __off32_t lseek (__off32_t offset, int whence);
d941 1
a941 1
  DWORD pos;
d950 1
a950 1
  __off32_t lseek (__off32_t offset, int whence);
d952 1
a952 1
  int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (3)));
d955 1
a955 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, __off32_t off);
d972 1
a972 1
  __off32_t lseek (__off32_t offset, int whence);
d980 1
a980 1
  __off32_t pos;
d998 1
a998 1
  __off32_t lseek (__off32_t, int) { return 0; }
d1024 1
a1024 1
  __off32_t lseek (__off32_t, int);
@


1.107
log
@	* dtable.cc (dtable::dup2): Revert previous patch.
	* fhandler.h: Ditto.
	(fhandler_socket::recv): Define new method.
	(fhandler_socket::send): Ditto.
	* fhandler_socket.cc (fhandler_socket::recv): New method.
	(fhandler_socket::send): Ditto.
	(fhandler_socket::read): Call fhandler_socket::recv() now.
	(fhandler_socket::write): Call fhandler_socket::send() now.
	* net.cc (class wsock_event): Move definition to wsock_event.h.
	(fdsock): Revert previous patch.
	(cygwin_recv): Move implementation to fhandler_socket::recv().
	(cygwin_send): Move implementation to fhandler_socket::send().
	* wsock_event.h: New file.
@
text
@d291 1
a291 1
  virtual off_t lseek (off_t offset, int whence);
d297 1
a297 1
		       int flags, off_t off);
d350 2
a351 2
  virtual off_t telldir (DIR *);
  virtual void seekdir (DIR *, off_t);
d385 1
a385 1
  off_t lseek (off_t, int) { return 0; }
d420 1
a420 1
  off_t lseek (off_t offset, int whence);
d492 1
a492 1
  virtual off_t lseek (off_t offset, int whence);
d515 1
a515 1
  off_t lseek (off_t offset, int whence);
d551 1
a551 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, off_t off);
d558 2
a559 2
  off_t telldir (DIR *);
  void seekdir (DIR *, off_t);
d575 2
a576 2
  off_t telldir (DIR *);
  void seekdir (DIR *, off_t);
d609 1
a609 1
  off_t lseek (off_t, int) { return 0; }
d840 1
a840 1
  off_t lseek (off_t, int) { return 0; }
d867 1
a867 1
  off_t lseek (off_t, int) { return 0; }
d906 1
a906 1
  off_t lseek (off_t offset, int whence);
d929 1
a929 1
  off_t lseek (off_t offset, int whence);
d950 1
a950 1
  off_t lseek (off_t offset, int whence);
d955 1
a955 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, off_t off);
d972 1
a972 1
  off_t lseek (off_t offset, int whence);
d980 1
a980 1
  off_t pos;
d998 1
a998 1
  off_t lseek (off_t, int) { return 0; }
d1024 1
a1024 1
  off_t lseek (off_t, int);
@


1.106
log
@	* dtable.cc (dtable::dup2): Store fd for fhandler_socket.
	* fhandler.h (fhandler_base::set_fd): New virtual method.
	(fhandler_base::get_fd): Ditto.
	(fhandler_socket::set_fd): Ditto.
	(fhandler_socket::get_fd): Ditto.
	* fhandler_socket.cc (fhandler_socket::read): Call cygwin_recv instead
	of native Winsock recv.
	(fhandler_socket::write): Call cygwin_send instead of native Winsock
	send.
	* net.cc (fdsock): Store fd in fhandler_socket.
@
text
@a353 3

  virtual void set_fd (int nfd) {}
  virtual int get_fd () { return -1; }
a363 1
  int fd;
d377 4
d382 1
a382 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
a397 2
  void set_fd (int nfd) { fd = nfd; }
  int get_fd () { return fd; }
@


1.105
log
@	* fhandler.h (fhandler_socket::sun_path): New private member.
	(fhandler_socket::set_sun_path): New method.
	(fhandler_socket::get_sun_path): Ditto.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	sun_path to NULL.
	(fhandler_socket::~fhandler_socket): Free sun_path if needed.
	(fhandler_socket::set_sun_path): New method.
	* net.cc (cygwin_bind): Set sun_path to path of local socket file.
	(cygwin_getsockname): Add code to return correct sockaddr for unix
	domain sockets.
@
text
@d354 3
d367 1
d398 3
a401 1
  void set_addr_family (int af) {addr_family = af;}
@


1.104
log
@* fhandler.h (fhandler_serial::ev): New class member.
* fhandler_serial.cc (fhandler_serial::raw_read): Use class member for event
status.
* select.cc (peek_serial): Ditto.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
d363 1
d396 2
@


1.103
log
@* dtable.cc (dtable::vfork_parent_restore): Add debugging statement.
* exceptions.cc (try_to_debug): Spin only as long as we don't have a debugger
attached.
* fhandler.h (fhandler_base::set_nohandle): New method.
(fhandler_base::get_nohandle): New method.
* fhandler.cc (fhandler_base::dup): Avoid duplicating handle if there is no
handle.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set nohandle flag on
dummy fd.
* Makefile.in: Make intermediate library for eventual inclusion in libcygwin.a
* fhandler.h (fhandler_pipe::fhandler_pipe): Remove default argument setting
since it is no longer used.
* miscfuncs.cc (check_null_str): New function.
(+check_null_str_errno): Ditto.
* net.cc: Add defensive buffer checking throughout.
(cygwin_sendto): Protect against invalid fd.
(cygwin_recvfrom): Ditto.
(cygwin_getpeername): Ditto.
(cygwin_recv): Ditto.
(cygwin_send): Ditto.
* winsup.h: Declare a new function.
* select.cc (set_bits): Fix conditional for setting fd in exceptfds.
* dtable.cc (dtable::build_fhandler): Create fhandler_pipe using correct device
type.
* path.cc (get_devn): Set correct pipe device type from device name.
@
text
@d585 1
@


1.102
log
@* path.cc (conv_path_list): Fix wild indexing into path due to conflicting
methods for setting src pointer.
* dir.cc (opendir): Only pass path_conv argument to opendir, since name is
already part of the fhandler.
* dtable.cc (dtable::build_fhandler): Accomodate new FH_CYGDRIVE type.
* fhandler.cc (fhandler_base::opendir): Nuke name argument.
* fhandler.h: Add FH_CYGDRIVE to "device" enum.
(fhandler_base::opendir): Nuke name argument.
(fhandler_disk_file::opendir): Ditto.
(fhandler_disk_file::fhandler_disk_file): Declare new method which passes
devtype through.
(fhandler_cygdrive): Add elements for tracking drives.
(fhandler_cygdrive::set_drives): Declare new method.
(fhandler_cygdrive::iscygdrive_root): Declare new method.
(fhandler_cygdrive::opendir): Declare new method.
(fhandler_cygdrive::readdir): Declare new method.
(fhandler_cygdrive::telldir): Declare new method.
(fhandler_cygdrive::seekdir): Declare new method.
(fhandler_cygdrive::rewinddir): Declare new method.
(fhandler_cygdrive::closedir): Declare new method.
(fhandler_cygdrive::fstat): Declare new method.
* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file): Define new
method which passes devtype through.
(fhandler_disk_file::open): Tweak debug output.
(fhandler_disk_file::opendir): Nuke first argument.  Use info from path_conv
and class rather than calling fstat.
(fhandler_cygdrive::set_drives): New method.
(fhandler_cygdrive::iscygdrive_root): New method.
(fhandler_cygdrive::opendir): New method.
(fhandler_cygdrive::readdir): New method.
(fhandler_cygdrive::telldir): New method.
(fhandler_cygdrive::seekdir): New method.
(fhandler_cygdrive::rewinddir): New method.
(fhandler_cygdrive::closedir): New method.
(fhandler_cygdrive::fstat): New method.
* path.cc (iscygdrive_device): Assume cygdriveness is already verified.
(path_conv::check): Treat FH_CYGDRIVE "method" as a special case, setting file
attributes as needed.
(mount_info::conv_to_win32_path): Allow stand-alone /cygdrive, meaning "the
directory which contains all of the drives on the system".
(fillout_mntent): Use cyg_tolower for conversions.
(mount_info::cygdrive_win32_path): Replace unused argument with unit number.
* shared_info.h (mount_info::cygdrive_win32_path): Reflect argument change.
@
text
@d33 1
a33 1
  FH_UNUSED	= 0x00800000,	/* currently unused. */
d170 1
a170 1
  int get_async () { return FHISSETF (ASYNC); }
d176 1
a176 1
  int is_nonblocking ();
d179 2
a180 2
  int get_w_binary () { return FHISSETF (WBINARY); }
  int get_r_binary () { return FHISSETF (RBINARY); }
d182 2
a183 2
  int get_w_binset () { return FHISSETF (WBINSET); }
  int get_r_binset () { return FHISSETF (RBINSET); }
d189 4
d204 1
a204 1
  int get_r_no_interrupt () { return FHISSETF (NOEINTR); }
d207 1
a207 1
  int get_close_on_exec () { return FHISSETF (CLOEXEC); }
d219 1
a219 1
  int get_check_win95_lseek_bug () { return FHISSETF (W95LSBUG); }
d221 1
a221 1
  int get_need_fork_fixup () { return FHISSETF (FFIXUP); }
d230 1
a230 1
  int get_symlink_p () { return FHISSETF (SYMLINK); }
d234 1
a234 1
  int get_socket_p () { return FHISSETF (LOCAL); }
d238 1
a238 1
  int get_execable_p () { return FHISSETF (EXECABL); }
d245 1
a245 1
  int dont_care_if_execable () { return FHISSETF (DCEXEC); }
d247 1
a247 1
  int get_append_p () { return FHISSETF (APPEND); }
d251 1
a251 1
  int get_query_open () { return FHISSETF (QUERYOPEN); }
d254 1
a254 1
  int get_readahead_valid () { return raixget < ralen; }
d267 1
a267 1
  int has_acls () { return FHISSETF (HASACLS); }
d270 1
a270 1
  int isremote () { return FHISSETF (ISREMOTE); }
d412 1
a412 1
  fhandler_pipe (DWORD devtype = FH_PIPE);
@


1.101
log
@* Makefile.in (DLL_OFILES): Add fhandler_disk_file.o.
* cygheap.h (cygheap_fdnew::operator =): New operator.
* dir.cc: Add invalid struct checking throughout.  Use methods for all
directory manipulation throughout.
* fhandler.cc: Move fhandler_disk_file stuff to own file.
(fhandler_base::opendir): New method.
(fhandler_base::readdir): New method.
(fhandler_base::telldir): New method.
(fhandler_base::seekdir): New method.
(fhandler_base::rewinddir): New method.
(fhandler_base::closedir): New method.
* fhandler_disk_file.cc: New file.
* fhandler.h (fhandler_base): Declare new virtual methods.
(fhandler_disk_file): Ditto.
(fhandler_cygdrive): New class.
* path.cc (conv_path_list): Use strccpy to break apart path.
@
text
@d70 1
a70 1
  FH_CLIPBOARD = 0x00000017, /* is a clipbaord device */
d72 1
d74 1
a74 1
  FH_NDEV    = 0x00000019,	/* Maximum number of devices */
d344 1
a344 1
  virtual DIR *opendir (const char *dirname, path_conv& pc);
d531 1
d545 1
a545 1
  DIR *opendir (const char *dirname, path_conv& pc);
d553 18
a611 6
};

class fhandler_cygdrive: public fhandler_disk_file
{
 public:
  fhandler_cygdrive ();
@


1.100
log
@* fhandler.h (fhandler_pipe::broken_pipe): Renamed from saweof.
(fhandler_pipe::set_eof): Reflect above change.
* pipe.cc (fhandler_pipe::fhandler_pipe): Ditto.
(fhandler_pipe::read): Ditto.
(fhandler_pipe::hiteof): Ditto.
@
text
@d106 2
d343 6
d543 6
d592 6
@


1.99
log
@* fhandler.h (fhandler_base::ready_for_read): Remove unused argument.
(fhandler_tty_slave::ready_for_read): Ditto.
(select_record): Remove poll, initialize peek.
* select.cc: Remove all poll functions, throughout.  Change second argument of
peek_* functions to 'bool' throughout.  Specifically initialize *_ready
variables throughout.
(select_stuff::poll): Subsume previous poll functionality.
(peek_pipe): Don't grab guard mutex when in select loop.  select()/read() is
racy by design so there is no need to worry about a race in select().
(fhandler_base::ready_for_read): Remove unused argument.
(fhandler_tty_slave::ready_for_read): Ditto.
* syscalls.cc (_read): Eliminate third argument in ready_for_read call.
@
text
@d394 1
a394 1
  bool saweof;
d411 1
a411 1
  void set_eof () {saweof = true;}
@


1.98
log
@* fhandler.cc (fhandler_base::read): Return just read ahead characters if slow
device.
* fhandler.h (fhandler_base::set_eof): New virtual method.
(fhandler_pipe::set_eof): New method.
* pipe.cc (fhandler_pipe::fhandler_pipe): Clear saweof flag.
(fhandler_pipe::read): Return immediately if hit eof.
(fhandler_pipe::hit_eof): Return true if saweof flag is set.
* select.cc (peek_pipe): Don't call PeekNamedPipe if we couldn't grab the guard
mutex.
@
text
@d327 1
a327 1
  virtual int ready_for_read (int fd, DWORD howlong, int ignra);
d796 1
a796 1
  int ready_for_read (int fd, DWORD howlong, int ignra);
d1020 1
a1020 3
  int (*poll) (select_record *me, fd_set *readfds, fd_set *writefds,
	       fd_set *exceptfds);
  int (*peek) (select_record *, int);
d1030 1
a1030 1
		 startup (NULL), poll (NULL), verify (NULL), cleanup (NULL),
@


1.97
log
@* dll_init.h (class dll_list): Reorder functions to avoid compiler "can't
inline" warnings.
* security.h (class cygsid): Ditto.
* sigproc.cc (get_proc_lock): Ditto.
* sigproc.h (class sigframe): Ditto.
* sync.h (class muto): Ditto.
* fhandler.h (fhandler_base::get_guard): Actually MAKE virtual as previously
indicated.
* pipe.cc (make_pipe): Remove extraneous set_errno.
* syscalls.cc (_open): Ditto.
* select.cc (peek_pipe): Need to check that there is still something to read
from the pipe after acquiring the mutex since another process/thread could have
eaten the input before we got to acquiring the lock.  (Thanks to Nick Duffek
for this inspiration.)
@
text
@a15 35
/* Classes

  Code is located in fhandler.cc unless another file name is given.

  fhandler_base		  normal I/O

     fhandler_disk_file
     fhandler_serial      Adds vmin and vtime.
     fhandler_dev_null    Not really I/O
     fhandler_dev_zero    Faked

     fhandler_dev_raw     (fhandler_raw.cc)
     fhandler_dev_floppy  (fhandler_floppy.cc)
     fhandler_dev_tape    (fhandler_tape.cc)

     fhandler_pipe
     fhandler_socket      (fhandler_socket.cc)

     fhandler_tty_slave   (tty.cc)
     fhandler_pty_master  (tty.cc)
     fhandler_tty_master  (tty.cc)

     fhandler_console     Out with ansi control. (console.cc)

     fhandler_windows	  Windows messages I/O (fhandler_windows.cc)

     fhandler_dev_random  /dev/[u]random implementation (fhandler_random.cc)

     fhandler_dev_mem     /dev/mem implementation (fhandler_mem.cc)

     fhandler_dev_clipboard	/dev/clipboard implementation (fhandler_clipboard.cc)

     fhandler_proc	  Interesting possibility, not implemented yet
*/

d340 1
d394 1
d411 1
@


1.96
log
@* fhandler.h: Change Windows 'BOOL's to c++ 'bool's for all variables.
* select.cc (fhandler_base::ready_for_read): Set read_ready to zero prior to
testing it or it will be uninitialized.
* Makefile.in (CFLAGS): Move setting to Makefile.common.
@
text
@d374 1
a374 1
  HANDLE get_guard () const {return NULL;}
@


1.95
log
@* dtable.cc (dtable::build_fhandler): Issue internal error on unknown device.
* fhandler.cc (fhandler_base::close): Show both name and handle in debugging
output.
* fhandler.h (fhandler_base::get_guard): New virtual method.
(fhandler_pipe::get_guard): New method.
(fhandler_socket::ready_for_read): Delete declaration.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(struct select_record::peek): Declare new method.
* select.cc (MAKEready): Delete.
(peek_pipe): Use get_guard method to retrieve potential guard mutex handle.
(fhandler_base::ready_for_read): Rewrite as generic ready-for-read handler.
Should only be called for "slow" devices.
(fhandler_socket::ready_for_read): Delete definition.
(fhandler_pipe::ready_for_read): Ditto.
(fhandler_serial::ready_for_read): Ditto.
(fhandler_console::ready_for_read): Ditto.
(fhandler_tty_common::ready_for_read): Ditto.
(fhandler_windows::ready_for_read): Ditto.
(fhandler_pipe::select_read): Fill in new peek record in select_record
structure.
(fhandler_console::select_read): Ditto.
(fhandler_tty_common::select_read): Ditto.
(fhandler_serial::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_socket::select_read): Ditto.
(fhandler_tty_slave::ready_for_read): Check for tty not open.  Set errnos
appropriately.
* syscalls.cc (_read): Allow ready_for_read to set errno.
* pinfo.cc (pinfo::init): Return spawn/NO_WAIT process as valid if it is
initializing.
* sigproc.cc (getsem): Adjust wait for process to initialize downward to avoid
huge waits.
@
text
@d681 1
a681 1
  BOOL saw_question_mark;
d687 1
a687 1
  BOOL underline, blink, reverse;
d715 3
a717 3
  BOOL insert_mode;
  BOOL use_mouse;
  BOOL raw_win32_keyboard_mode;
d969 1
a969 1
  BOOL eof;
d1047 4
a1050 4
  BOOL saw_error;
  BOOL windows_handle;
  BOOL read_ready, write_ready, except_ready;
  BOOL read_selected, write_selected, except_selected;
d1076 1
a1076 1
  BOOL always_ready, windows_used;
@


1.94
log
@* fhandler.h (fhandler_serial::fhandler_serial): Change to only accept unit
argument.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
(fhandler_serial::open): Avoid else when previous clause is a return().
* path.cc (get_devn): Alias /dev/ttyS0 -> /dev/com1, etc.
(get_device_number): Reallow standalone "com1" as a valid name for /dev/com1.
@
text
@d160 1
a160 1
protected:
d162 1
a162 1
private:
d168 1
a168 1
protected:
d183 1
a183 1
public:
d374 1
d379 1
a379 1
private:
d385 1
a385 1
public:
a413 1
  int ready_for_read (int fd, DWORD howlong, int ignra);
d431 1
a431 1
public:
a436 1
  int ready_for_read (int fd, DWORD howlong, int ignra);
d445 1
d450 1
a450 1
protected:
d473 1
a473 1
public:
d494 1
a494 1
protected:
d498 1
a498 1
public:
d515 1
a515 1
protected:
d521 1
a521 1
public:
d535 1
a535 1
private:
d552 1
a552 1
public:
d571 1
a571 1
private:
d576 1
a576 1
public:
a609 1
  int ready_for_read (int fd, DWORD howlong, int ignra);
d622 1
a622 1
protected:
d626 1
a626 1
public:
d669 1
a669 1
private:
d739 1
a739 1
public:
a765 1
  int ready_for_read (int fd, DWORD howlong, int ignra);
d774 1
a774 1
public:
a806 1
  int ready_for_read (int fd, DWORD howlong, int ignra);
d811 1
a811 1
public:
d834 1
a834 1
public:
d862 1
a862 1
public:
d876 1
a876 1
public:
d887 1
a887 1
public:
d900 1
a900 1
protected:
d909 1
a909 1
public:
d924 1
a924 1
protected:
d929 1
a929 1
public:
d952 1
a952 1
public:
d965 1
a965 1
private:
d974 1
a974 1
private:
d977 1
a977 1
public:
a991 1
  int ready_for_read (int fd, DWORD howlong, int ignra);
d996 1
a996 1
private:
d1002 1
a1002 1
public:
d1054 1
d1070 1
a1070 1
public:
@


1.93
log
@fix spelling errors
@
text
@a161 1
public:
d581 1
a581 1
  fhandler_serial (DWORD devtype = FH_SERIAL, int unit = 0);
@


1.92
log
@Ensure that all fhandler_*::read definitions are __stdcall throughout.
* fhandler.cc (fhandler_base::set_inheritance): Be more defensive in debugging
code.
* fhandler.h: Adjust regparms throughout to reflect passing 'this' parameter.
* fhandler_console.cc (fhandler_console::read): Remove unneeded test.  Only
honor "key down" events.
* miscfuncs.cc (strcasestr): Reorganize for efficient code use.
(check_null_empty_str_errno): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
* syscalls.cc (_read): Return 0 when length == 0, as per Single UNIX
Specification.
@
text
@d127 1
a127 1
   behave properly the old version, too, to accomodate older executables. */
@


1.91
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d314 1
a314 1
  virtual int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (2)));
d318 1
a318 1
  virtual int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d398 1
a398 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d423 1
a423 1
  int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (2)));
d440 1
a440 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d530 1
a530 1
  int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (2)));
d560 2
a561 2
  int __stdcall fstat (struct stat *buf, path_conv *pc) __attribute__ ((regparm (2)));
  int __stdcall fstat_helper (struct stat *buf) __attribute__ ((regparm (1)));
d751 1
a751 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d822 1
a822 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d849 1
a849 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d895 1
a895 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d918 1
a918 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d939 1
a939 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d942 1
a942 1
  int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (2)));
d961 1
a961 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d986 1
a986 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
d1013 1
a1013 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (2)));
@


1.90
log
@	* autoload.cc: Add load statement for `NtOpenFile'.
	* fhandler.h (fhandler_dev_raw::get_unit): New method.
	(fhandler_dev_tape::norewind): Eliminate.
	(fhandler_dev_tape::is_rewind_device): New method.
	* fhandler_raw.cc (fhandler_dev_raw::open): Open new
	fixed device name devices using NT internal method.
	Keep calling fhandler_base::open() for old mount table
	device mapping compatibility devices.
	(fhandler_dev_raw::fstat): Eliminate.  Settings are done
	by fhandler_base::fstat() already.
	* fhandler_tape.cc: Remove `norewind' usage throughout.
	* ntdll.h: Define FILE_SYNCHRONOUS_IO_NONALERT.
	Define struct _IO_STATUS_BLOCK.
	Declare NtOpenFile().
	* path.cc (get_raw_device_number): Add new approach for
	using fixed device names.
	(win32_device_name): Ditto.
	(get_device_number): Ditto.  Require POSIX path to begin
	with "/dev/".
	(mount_info::conv_to_win32_path): Call win32_device_name()
	instead of get_device_number() after evaluating mount points
	to allow changing the win32 destination path again.
	* security.cc (str2buf2uni): Remove `static' to be able to
	call function from fhandler_dev_raw::open().
	* wincap.cc: Set flag has_raw_devices appropriately.
	* wincap.h: Add flag has_raw_devices.
@
text
@a162 1
  int cb;
a195 1
  void set_cb (size_t size) { cb = size; }
d779 3
a781 1
    : fhandler_termios (dev, unit), ttynum (unit)
d794 1
a794 1

a798 1
  int ttynum;			// Master tty num.
a867 1
  fhandler_tty_master (int unit);
d871 1
@


1.89
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@d479 2
a486 2
  int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (2)));

a513 1
  int norewind;
d515 2
@


1.88
log
@* dtable.cc (dtable::build_fhandler): Allocate correct amount for given
fhandler class.
* fhandler.h (fhandler_union): Properly define rather than relying on
fhandler_console being "big enough".
@
text
@d191 1
a191 1
  fhandler_base (DWORD dev, const char *name = 0, int unit = 0);
d388 1
a388 1
  fhandler_socket (const char *name = 0);
d425 1
d435 1
a435 1
  fhandler_pipe (const char *name = 0, DWORD devtype = FH_PIPE);
d474 1
a474 1
  fhandler_dev_raw (DWORD dev, const char *name, int unit);
d502 1
a502 1
  fhandler_dev_floppy (const char *name, int unit);
d524 1
a524 1
  fhandler_dev_tape (const char *name, int unit);
d555 1
a555 1
  fhandler_disk_file (const char *name);
d583 1
a583 1
  fhandler_serial (const char *name, DWORD devtype = FH_SERIAL, int unit = 0);
d631 2
a632 2
  fhandler_termios (DWORD dev, const char *name = 0, int unit = 0) :
  fhandler_base (dev, name, unit)
d744 1
a744 1
  fhandler_console (const char *name);
d779 2
a780 3
  fhandler_tty_common (DWORD dev, const char *name = 0, int unit = 0) :
    fhandler_termios (dev, name, unit),
    ttynum (unit)
d817 2
a818 2
  fhandler_tty_slave (const char *name);
  fhandler_tty_slave (int, const char *name);
d842 1
a842 1
  fhandler_pty_master (const char *name, DWORD devtype = FH_PTYM, int unit = -1);
d868 1
a868 1
  fhandler_tty_master (const char *name, int unit);
d881 1
a881 1
  fhandler_dev_null (const char *name);
d892 1
a892 1
  fhandler_dev_zero (const char *name);
d914 1
a914 1
  fhandler_dev_random (const char *name, int unit);
d934 1
a934 1
  fhandler_dev_mem (const char *name, int unit);
d957 1
a957 1
  fhandler_dev_clipboard (const char *name);
d982 1
a982 1
  fhandler_windows (const char *name = 0);
d1008 1
a1008 1
  fhandler_dev_dsp (const char *name = 0);
@


1.87
log
@Add second path_conv * argument to fstat()s throughout.
* fhandler.h: Change read and fstat to regparm/stdcall throughout.
(fhandler_base::fstat): Just declare.  Don't define.
(fhandler_disk_file::fstat_helper): Declare.
* fhandler.cc (fhandler_base::fstat): Move here from fhandler.h, adapt from
former stat_dev().
(fhandler_disk_file::fstat): Move most of the disk-file-specific logic from
stat_worker to here.  Use fstat_helper to derive final fstat output.
(fhandler_disk_file::fstat_helper): New method, renamed from former fstat
method.
(num_entries): Moved here from syscalls.cc.
* fhandler_mem.cc (fhandler_dev_mem::fstat): Use base class to initialize most
stuff.  Invert has_physical_mem_access test for establishing permissions.
* fhandler_raw.cc (fhandler_dev_raw::fstat): Eliminate unneed test and memory
clearing.  Use base class to initialize most stuff.
* syscalls.cc (stat_dev): Eliminate.
(stat_worker): Simply call fstat method to generate fstat output.  Move all
device specific code to appropriate fstats.
* dir.cc (opendir): Pass correct arg to stat_worker to allow following
symlinks.
@
text
@a1021 2
#if 0
/* You can't do this */
d1024 21
a1044 4
  fhandler_normal normal;
  fhandler_dev_null dev_null;
  fhandler bare;
  fhandler_serial tty;
d1046 1
a1046 3
#else
#define fhandler_union fhandler_console
#endif
@


1.86
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d316 1
a316 1
  virtual int fstat (struct stat *buf) { return stat_dev (get_device (), get_unit (), get_namehash (), buf); }
d320 1
a320 1
  virtual int read (void *ptr, size_t len);
d400 1
a400 1
  int read (void *ptr, size_t len);
d441 1
a441 1
  int read (void *ptr, size_t len);
d484 1
a484 1
  int fstat (struct stat *buf);
d525 2
a526 2
  virtual int open (path_conv *, int flags, mode_t mode = 0);
  virtual int close (void);
d528 1
a528 1
  virtual off_t lseek (off_t offset, int whence);
d530 1
a530 1
  virtual int fstat (struct stat *buf);
d532 1
a532 1
  virtual int dup (fhandler_base *child);
d534 1
a534 1
  virtual int ioctl (unsigned int cmd, void *buf);
d560 2
a561 1
  int fstat (struct stat *buf);
d751 1
a751 1
  int read (void *ptr, size_t len);
d822 1
a822 1
  int read (void *ptr, size_t len);
d849 1
a849 1
  int read (void *ptr, size_t len);
d895 1
a895 1
  int read (void *ptr, size_t len);
d918 1
a918 1
  int read (void *ptr, size_t len);
d939 1
a939 1
  int read (void *ptr, size_t ulen);
d942 1
a942 1
  int fstat (struct stat *buf);
d961 1
a961 1
  int read (void *ptr, size_t len);
d986 1
a986 1
  int read (void *ptr, size_t len);
d1013 1
a1013 1
  int read (void *ptr, size_t len);
@


1.85
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d314 1
a314 7
  /* Potentially overridden virtual functions. */
  virtual int open (const char *, int flags, mode_t mode = 0)
  {
    return open (flags, mode);
  }
  virtual int open (path_conv& real_path, int flags, mode_t mode);
  virtual int open (int flags, mode_t mode = 0);
d478 1
a478 1
  int open (const char *path, int flags, mode_t mode = 0);
d503 1
a503 1
  virtual int open (const char *path, int flags, mode_t mode = 0);
d525 1
a525 1
  virtual int open (const char *path, int flags, mode_t mode = 0);
d556 1
a556 2
  int open (const char *path, int flags, mode_t mode = 0);
  int open (path_conv& real_path, int flags, mode_t mode);
d583 1
a583 1
  int open (const char *path, int flags, mode_t mode);
d746 1
a746 1
  int open (const char *path, int flags, mode_t mode = 0);
d819 1
a819 1
  int open (const char *path, int flags, mode_t mode = 0);
d846 1
a846 1
  int open (const char *path, int flags, mode_t mode = 0);
d892 1
a892 1
  int open (const char *path, int flags, mode_t mode = 0);
d915 1
a915 1
  int open (const char *path, int flags, mode_t mode = 0);
d936 1
a936 1
  int open (const char *path, int flags, mode_t mode = 0);
d958 1
a958 1
  int open (const char *path, int flags, mode_t mode = 0);
d983 1
a983 1
  int open (const char *path, int flags, mode_t mode = 0);
d1010 1
a1010 1
  int open (const char *path, int flags, mode_t mode = 0);
@


1.84
log
@* pipe.cc (fhandler_pipe::fixup_after_fork): New method.
* fhandler.h (fhandler_pipe::fixup_after_fork): Declare new method.
@
text
@d68 1
a68 2
  FH_NOFRNAME	= 0x00800000,	/* Set if shouldn't free unix_path_name and
				   windows_path_name_ on destruction. */
d189 1
a302 4

  int no_free_names () { return FHISSETF (NOFRNAME); }
  void set_no_free_names (int val) { FHCONDSETF (val, NOFRNAME); }
  void set_no_free_names () { FHSETF (NOFRNAME); }
@


1.83
log
@* fhandler.h (fhandler_pipe::hit_eof): New method.
(writepipe_exists): New class element.
(orig_pid): Ditto.
(id): Ditto.
(is_slow): Eliminate.
* pipe.cc (fhandler_pipe::set_close_on_exec): Set inheritance on
writepipe_exists, if it exists.
(fhandler_pipe::hit_eof): New method, modelled after tty.
(fhandler_pipe::dup): Duplicate writepipe_exists, if it exists.
(make_pipe): Set up a dummy event for pipes on windows 9x.  The nonexistence
of this event means that the write side of the pipe has closed.
(_dup): Move to syscalls.cc
(_dup2): Ditto.

* dtable.cc (dtable::build_fhandler): Fill out set_names here, if appropriate.
* syscalls.cc (_open): Call set_names in build_fhandler.
@
text
@d455 1
@


1.83.2.1
log
@Tue Sep 25 16:22:00 2001 Robert Collins <rbtcollins@@hotmail.com>

        * autoload.cc: Add dynamic load statement for
	'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build
	instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when
	obtaining handles from the parent process. On failure or 9x
	use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
										CVS: ----------------------------------------------------------------------
@
text
@a841 2

  int cygserver_attach_tty (HANDLE*, HANDLE*);
@


1.83.2.2
log
@Merged changes from HEAD
@
text
@a454 1
  void fixup_after_fork (HANDLE);
@


1.83.2.3
log
@Merged changes from HEAD
@
text
@d68 2
a69 1
  FH_UNUSED	= 0x00800000,	/* currently unused. */
a189 1
  void reset_unix_path_name (const char *);
d303 4
@


1.83.2.4
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d16 35
d68 1
a68 1
  FH_NOHANDLE	= 0x00800000,	/* No handle associated with fhandler. */
d105 1
a105 1
  FH_CLIPBOARD = 0x00000017,	/* is a clipboard device */
a106 1
  FH_CYGDRIVE= 0x00000019,	/* /cygdrive/x */
d108 1
a108 1
  FH_NDEV    = 0x0000001a,	/* Maximum number of devices */
d127 1
a127 1
   behave properly the old version, too, to accommodate older executables. */
a140 2
typedef struct __DIR DIR;
struct dirent;
d160 1
a160 1
 protected:
d162 3
a164 1
 private:
d170 1
a170 1
 protected:
d185 1
a185 1
 public:
d191 1
a191 1
  fhandler_base (DWORD dev, int unit = 0);
d197 1
d205 1
a205 1
  bool get_async () { return FHISSETF (ASYNC); }
d211 1
a211 1
  bool is_nonblocking ();
d214 2
a215 2
  bool get_w_binary () { return FHISSETF (WBINARY); }
  bool get_r_binary () { return FHISSETF (RBINARY); }
d217 2
a218 2
  bool get_w_binset () { return FHISSETF (WBINSET); }
  bool get_r_binset () { return FHISSETF (RBINSET); }
a223 4

  bool get_nohandle () { return FHISSETF (NOHANDLE); }
  void set_nohandle (int x) { FHCONDSETF (x, NOHANDLE); }

d235 1
a235 1
  bool get_r_no_interrupt () { return FHISSETF (NOEINTR); }
d238 1
a238 1
  bool get_close_on_exec () { return FHISSETF (CLOEXEC); }
d250 1
a250 1
  bool get_check_win95_lseek_bug () { return FHISSETF (W95LSBUG); }
d252 1
a252 1
  bool get_need_fork_fixup () { return FHISSETF (FFIXUP); }
d261 1
a261 1
  bool get_symlink_p () { return FHISSETF (SYMLINK); }
d265 1
a265 1
  bool get_socket_p () { return FHISSETF (LOCAL); }
d269 1
a269 1
  bool get_execable_p () { return FHISSETF (EXECABL); }
d276 1
a276 1
  bool dont_care_if_execable () { return FHISSETF (DCEXEC); }
d278 1
a278 1
  bool get_append_p () { return FHISSETF (APPEND); }
d282 1
a282 1
  bool get_query_open () { return FHISSETF (QUERYOPEN); }
d285 1
a285 1
  bool get_readahead_valid () { return raixget < ralen; }
d298 1
a298 1
  bool has_acls () { return FHISSETF (HASACLS); }
d301 1
a301 1
  bool isremote () { return FHISSETF (ISREMOTE); }
d314 7
a320 1
  virtual int open (path_conv * real_path, int flags, mode_t mode = 0);
d322 1
a322 1
  virtual int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (3)));
d326 1
a326 1
  virtual int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d371 1
a371 1
  virtual int ready_for_read (int fd, DWORD howlong);
a382 8
  virtual HANDLE get_guard () const {return NULL;}
  virtual void set_eof () {}
  virtual DIR *opendir (path_conv& pc);
  virtual dirent *readdir (DIR *);
  virtual off_t telldir (DIR *);
  virtual void seekdir (DIR *, off_t);
  virtual void rewinddir (DIR *);
  virtual int closedir (DIR *);
d387 1
a387 1
 private:
a391 1
  char *sun_path;
d393 2
a394 2
 public:
  fhandler_socket ();
d406 1
a406 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d422 1
a424 2
  void set_sun_path (const char *path);
  char *get_sun_path () {return sun_path;}
a430 1
  int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (3)));
a435 1
  bool broken_pipe;
d439 2
a440 2
 public:
  fhandler_pipe (DWORD devtype);
d445 1
d447 1
a447 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
a452 1
  void set_eof () {broken_pipe = true;}
a453 1
  HANDLE get_guard () const {return guard;}
d458 1
a458 1
 protected:
d479 1
a479 1
  fhandler_dev_raw (DWORD dev, int unit);
d481 1
a481 1
 public:
d484 1
a484 3
  int get_unit () { return unit; }

  int open (path_conv *, int flags, mode_t mode = 0);
d490 2
d502 1
a502 1
 protected:
d506 2
a507 2
 public:
  fhandler_dev_floppy (int unit);
d509 1
a509 1
  virtual int open (path_conv *, int flags, mode_t mode = 0);
d519 1
d522 1
a522 3
  bool is_rewind_device () { return get_unit () < 128; }

 protected:
d528 2
a529 2
 public:
  fhandler_dev_tape (int unit);
d531 2
a532 2
  int open (path_conv *, int flags, mode_t mode = 0);
  int close (void);
d534 1
a534 1
  off_t lseek (off_t offset, int whence);
d536 1
a536 1
  int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (3)));
d538 1
a538 1
  int dup (fhandler_base *child);
d540 1
a540 1
  int ioctl (unsigned int cmd, void *buf);
d542 1
a542 1
 private:
d559 2
a560 3
 public:
  fhandler_disk_file ();
  fhandler_disk_file (DWORD devtype);
d562 2
a563 1
  int open (path_conv * real_path, int flags, mode_t mode);
d567 1
a567 2
  int __stdcall fstat (struct stat *buf, path_conv *pc) __attribute__ ((regparm (3)));
  int __stdcall fstat_helper (struct stat *buf) __attribute__ ((regparm (2)));
a573 24
  DIR *opendir (path_conv& pc);
  struct dirent *readdir (DIR *);
  off_t telldir (DIR *);
  void seekdir (DIR *, off_t);
  void rewinddir (DIR *);
  int closedir (DIR *);
};

class fhandler_cygdrive: public fhandler_disk_file
{
  int unit;
  int ndrives;
  const char *pdrive;
  void set_drives ();
 public:
  bool iscygdrive_root () const { return !unit; }
  fhandler_cygdrive (int unit);
  DIR *opendir (path_conv& pc);
  struct dirent *readdir (DIR *);
  off_t telldir (DIR *);
  void seekdir (DIR *, off_t);
  void rewinddir (DIR *);
  int closedir (DIR *);
  int __stdcall fstat (struct stat *buf, path_conv *pc) __attribute__ ((regparm (3)));
d578 1
a578 1
 private:
d583 1
a583 1
 public:
a585 1
  DWORD ev;
d588 1
a588 1
  fhandler_serial (int unit);
d590 1
a590 1
  int open (path_conv *, int flags, mode_t mode);
d617 1
d630 1
a630 1
 protected:
d634 1
a634 1
 public:
d636 2
a637 2
  fhandler_termios (DWORD dev, int unit = 0) :
  fhandler_base (dev, unit)
d677 1
a677 1
 private:
d689 1
a689 1
  bool saw_question_mark;
d695 1
a695 1
  bool underline, blink, reverse;
d723 3
a725 3
  bool insert_mode;
  bool use_mouse;
  bool raw_win32_keyboard_mode;
d747 1
a747 1
 public:
d749 1
a749 1
  fhandler_console ();
d753 1
a753 1
  int open (path_conv *, int flags, mode_t mode = 0);
d757 1
a757 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d774 1
d783 4
a786 5
 public:
  fhandler_tty_common (DWORD dev, int unit = 0)
    : fhandler_termios (dev, unit), output_done_event (NULL),
    ioctl_request_event (NULL), ioctl_done_event (NULL), output_mutex (NULL),
    input_mutex (NULL), input_available_event (NULL), inuse (NULL), ttynum (unit)
d799 1
a799 1
  int ttynum;			// Master tty num.
d804 1
d816 1
d821 1
a821 1
 public:
d823 2
a824 2
  fhandler_tty_slave ();
  fhandler_tty_slave (int);
d826 1
a826 1
  int open (path_conv *, int flags, mode_t mode = 0);
d828 1
a828 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d838 1
a838 1
  int ready_for_read (int fd, DWORD howlong);
d846 1
a846 1
 public:
d850 1
a850 1
  fhandler_pty_master (DWORD devtype = FH_PTYM, int unit = -1);
d855 1
a855 1
  int open (path_conv *, int flags, mode_t mode = 0);
d857 1
a857 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d874 1
a874 1
 public:
d876 1
a879 1
  fhandler_tty_master (int unit);
d888 2
a889 2
 public:
  fhandler_dev_null ();
d899 3
a901 3
 public:
  fhandler_dev_zero ();
  int open (path_conv *, int flags, mode_t mode = 0);
d903 1
a903 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d912 1
a912 1
 protected:
d921 2
a922 2
 public:
  fhandler_dev_random (int unit);
d924 1
a924 1
  int open (path_conv *, int flags, mode_t mode = 0);
d926 1
a926 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d936 1
a936 1
 protected:
d941 2
a942 2
 public:
  fhandler_dev_mem (int unit);
d945 1
a945 1
  int open (path_conv *, int flags, mode_t mode = 0);
d947 1
a947 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d950 1
a950 1
  int __stdcall fstat (struct stat *buf, path_conv *) __attribute__ ((regparm (3)));
d964 2
a965 2
 public:
  fhandler_dev_clipboard ();
d967 1
a967 1
  int open (path_conv *, int flags, mode_t mode = 0);
d969 1
a969 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d977 1
a977 1
 private:
d981 1
a981 1
  bool eof;
d986 1
a986 1
 private:
d989 2
a990 2
 public:
  fhandler_windows ();
d992 1
a992 1
  int open (path_conv *, int flags, mode_t mode = 0);
d994 1
a994 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d1004 1
d1009 1
a1009 1
 private:
d1015 2
a1016 2
 public:
  fhandler_dev_dsp ();
d1019 1
a1019 1
  int open (path_conv *, int flags, mode_t mode = 0);
d1021 1
a1021 1
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
d1030 2
d1034 4
a1037 21
  char base[sizeof(fhandler_base)];
  char console[sizeof(fhandler_console)];
  char dev_clipboard[sizeof(fhandler_dev_clipboard)];
  char dev_dsp[sizeof(fhandler_dev_dsp)];
  char dev_floppy[sizeof(fhandler_dev_floppy)];
  char dev_mem[sizeof(fhandler_dev_mem)];
  char dev_null[sizeof(fhandler_dev_null)];
  char dev_random[sizeof(fhandler_dev_random)];
  char dev_raw[sizeof(fhandler_dev_raw)];
  char dev_tape[sizeof(fhandler_dev_tape)];
  char dev_zero[sizeof(fhandler_dev_zero)];
  char disk_file[sizeof(fhandler_disk_file)];
  char pipe[sizeof(fhandler_pipe)];
  char pty_master[sizeof(fhandler_pty_master)];
  char serial[sizeof(fhandler_serial)];
  char socket[sizeof(fhandler_socket)];
  char termios[sizeof(fhandler_termios)];
  char tty_common[sizeof(fhandler_tty_common)];
  char tty_master[sizeof(fhandler_tty_master)];
  char tty_slave[sizeof(fhandler_tty_slave)];
  char windows[sizeof(fhandler_windows)];
d1039 3
a1041 1

d1047 4
a1050 4
  bool saw_error;
  bool windows_handle;
  bool read_ready, write_ready, except_ready;
  bool read_selected, write_selected, except_selected;
d1052 2
a1053 1
  int (*peek) (select_record *, bool);
d1063 1
a1063 1
		 startup (NULL), peek (NULL), verify (NULL), cleanup (NULL),
d1069 1
a1069 1
 public:
d1075 1
a1075 1
  bool always_ready, windows_used;
@


1.83.2.5
log
@Merged changes from HEAD
@
text
@d285 1
a285 1
  virtual int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d291 1
a291 1
  virtual __off64_t lseek (__off64_t offset, int whence);
d297 1
a297 1
		       int flags, __off64_t off);
d350 2
a351 2
  virtual __off64_t telldir (DIR *);
  virtual void seekdir (DIR *, __off64_t);
d377 1
a377 1
  int recv (void *ptr, size_t len, unsigned int flags);
a378 4

  int send (const void *ptr, size_t len, unsigned int flags);
  int write (const void *ptr, size_t len);

d381 1
a381 1
  __off64_t lseek (__off64_t, int) { return 0; }
d394 1
a395 1
  int get_addr_family () {return addr_family;}
d404 1
a404 1
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d416 1
a416 1
  __off64_t lseek (__off64_t offset, int whence);
d488 1
a488 1
  virtual __off64_t lseek (__off64_t offset, int whence);
d511 1
a511 1
  __off64_t lseek (__off64_t offset, int whence);
d513 1
a513 1
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d544 2
a545 2
  int __stdcall fstat (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
  int __stdcall fstat_helper (struct __stat64 *buf) __attribute__ ((regparm (2)));
d547 1
a547 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, __off64_t off);
d554 2
a555 2
  __off64_t telldir (DIR *);
  void seekdir (DIR *, __off64_t);
d571 2
a572 2
  __off64_t telldir (DIR *);
  void seekdir (DIR *, __off64_t);
d575 1
a575 1
  int __stdcall fstat (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
d605 1
a605 1
  __off64_t lseek (__off64_t, int) { return 0; }
d836 1
a836 1
  __off64_t lseek (__off64_t, int) { return 0; }
d865 1
a865 1
  __off64_t lseek (__off64_t, int) { return 0; }
d904 1
a904 1
  __off64_t lseek (__off64_t offset, int whence);
d927 1
a927 1
  __off64_t lseek (__off64_t offset, int whence);
d939 1
a939 1
  __off64_t pos;
d948 1
a948 1
  __off64_t lseek (__off64_t offset, int whence);
d950 1
a950 1
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d953 1
a953 1
  HANDLE mmap (caddr_t *addr, size_t len, DWORD access, int flags, __off64_t off);
d970 1
a970 1
  __off64_t lseek (__off64_t offset, int whence);
d978 1
a978 1
  __off64_t pos;
d996 1
a996 1
  __off64_t lseek (__off64_t, int) { return 0; }
d1022 1
a1022 1
  __off64_t lseek (__off64_t, int);
@


1.83.2.6
log
@Merged changes from HEAD
@
text
@a14 1
#include <fcntl.h>
a72 3
  FH_PROC    = 0x0000001a,      /* /proc */
  FH_REGISTRY =0x0000001b,      /* /proc/registry */
  FH_PROCESS = 0x0000001c,      /* /proc/<n> */
d74 1
a74 1
  FH_NDEV    = 0x0000001d,      /* Maximum number of devices */
a102 2
extern const char proc[];
extern const int proc_len;
d121 1
a122 1
  not_executable = dont_care_if_executable,
d147 2
a148 2
  const char *unix_path_name;
  const char *win32_path_name;
d152 2
a153 1
  void set_name (const char * unix_path, const char *win32_path = NULL, int unit = 0);
d155 1
d174 1
a174 1
  void set_flags (int x, int supplied_bin = 0);
d179 2
a180 2
  bool get_w_binary () { return FHISSETF (WBINSET) ? FHISSETF (WBINARY) : 1; }
  bool get_r_binary () { return FHISSETF (RBINSET) ? FHISSETF (RBINARY) : 1; }
d197 3
a199 3
    set_flags ((get_flags () & ~(O_TEXT | O_BINARY))
	       | ((open_status & (FH_WBINARY | FH_RBINARY)
		   ? O_BINARY : O_TEXT)));
a245 1
  bool exec_state_isknown () { return FHISSETF (DCEXEC) || FHISSETF (EXECABL); }
d252 1
a252 1
  void set_query_open (bool val) { FHCONDSETF (val, QUERYOPEN); }
d283 1
a283 1
  virtual int open (path_conv *real_path, int flags, mode_t mode = 0);
a359 1
  int type;
a399 2
  void set_socket_type (int st) { type = st;}
  int get_socket_type () {return type;}
d512 2
a513 2
  virtual int open (path_conv *, int flags, mode_t mode = 0);
  virtual int close (void);
d515 1
a515 1
  virtual __off64_t lseek (__off64_t offset, int whence);
d517 1
a517 1
  virtual int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
d519 1
a519 1
  virtual int dup (fhandler_base *child);
d521 1
a521 1
  virtual int ioctl (unsigned int cmd, void *buf);
d549 1
a549 12
  int __stdcall fstat_helper (struct __stat64 *buf, path_conv *pc,
			      FILETIME ftCreateionTime,
			      FILETIME ftLastAccessTime,
			      FILETIME ftLastWriteTime,
			      DWORD nFileSizeHigh,
			      DWORD nFileSizeLow,
			      DWORD nFileIndexHigh = 0,
			      DWORD nFileIndexLow = 0,
			      DWORD nNumberOfLinks = 1)
    __attribute__ ((regparm (3)));
  int __stdcall fstat_by_handle (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
  int __stdcall fstat_by_name (struct __stat64 *buf, path_conv *pc) __attribute__ ((regparm (3)));
a659 1
  virtual __off64_t lseek (__off64_t, int);
a1032 72
class fhandler_virtual : public fhandler_base
{
 protected:
  char *filebuf;
  size_t bufalloc, filesize;
  __off64_t position;
  int fileid; // unique within each class
 public:

  fhandler_virtual (DWORD devtype);
  virtual ~fhandler_virtual();

  virtual int exists();
  DIR *opendir (path_conv& pc);
  __off64_t telldir (DIR *);
  void seekdir (DIR *, __off64_t);
  void rewinddir (DIR *);
  int closedir (DIR *);
  int write (const void *ptr, size_t len);
  int __stdcall read (void *ptr, size_t len) __attribute__ ((regparm (3)));
  __off64_t lseek (__off64_t, int);
  int dup (fhandler_base * child);
  int open (path_conv *, int flags, mode_t mode = 0);
  int close (void);
  int __stdcall fstat (struct stat *buf, path_conv *pc) __attribute__ ((regparm (3)));
  virtual void fill_filebuf ();
};

class fhandler_proc: public fhandler_virtual
{
 public:
  fhandler_proc ();
  fhandler_proc (DWORD devtype);
  int exists();
  struct dirent *readdir (DIR *);
  static DWORD get_proc_fhandler(const char *path);

  int open (path_conv *real_path, int flags, mode_t mode = 0);
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
  void fill_filebuf ();
};

class pinfo;
class fhandler_registry: public fhandler_proc
{
 public:
  fhandler_registry ();
  int exists();
  struct dirent *readdir (DIR *);
  __off64_t telldir (DIR *);
  void seekdir (DIR *, __off64_t);
  void rewinddir (DIR *);
  int closedir (DIR *);

  int open (path_conv *real_path, int flags, mode_t mode = 0);
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
  HKEY open_key(const char *name, REGSAM access = KEY_READ, bool isValue = false);
  void fill_filebuf ();
};

struct _pinfo;
class fhandler_process: public fhandler_proc
{
 public:
  fhandler_process ();
  int exists();
  struct dirent *readdir (DIR *);
  int open (path_conv *real_path, int flags, mode_t mode = 0);
  int __stdcall fstat (struct __stat64 *buf, path_conv *) __attribute__ ((regparm (3)));
  void fill_filebuf (pinfo& p);
};

a1047 2
  char proc[sizeof(fhandler_proc)];
  char process[sizeof(fhandler_process)];
a1048 1
  char registry[sizeof(fhandler_registry)];
@


1.83.2.7
log
@Merged changes from HEAD
@
text
@a382 7
  int bind (const struct sockaddr *name, int namelen);
  int connect (const struct sockaddr *name, int namelen);
  int listen (int backlog);
  int accept (struct sockaddr *peer, int *len);
  int getsockname (struct sockaddr *name, int *namelen);
  int getpeername (struct sockaddr *name, int *namelen);

a384 3
  int recvfrom (void *ptr, size_t len, unsigned int flags,
		struct sockaddr *from, int *fromlen);
  int recvmsg (struct msghdr *msg, int flags);
a388 4
  int sendto (const void *ptr, size_t len, unsigned int flags,
	      const struct sockaddr *to, int tolen);
  int sendmsg (const struct msghdr *msg, int flags);

a391 1
  int shutdown (int how);
@


1.83.2.8
log
@Merged changes from HEAD
@
text
@d1110 1
d1128 1
a1128 1
class pinfo;
a1130 2
  pid_t pid;
  pinfo *p;
d1137 1
a1137 1
  void fill_filebuf ();
@


1.83.2.9
log
@Merged changes from HEAD
@
text
@d1093 1
a1093 1
  virtual bool fill_filebuf ();
d1107 1
a1107 1
  bool fill_filebuf ();
a1111 2
 private:
  char *value_name;
d1123 2
a1124 2
  bool fill_filebuf ();
  int close (void);
d1131 1
d1138 1
a1138 1
  bool fill_filebuf ();
@


1.83.2.10
log
@Merged changes from HEAD
@
text
@a103 4
#define UNCONNECTED     0
#define CONNECT_PENDING 1
#define CONNECTED       2

a369 1
  int had_connect_or_listen;
a382 5
  bool is_unconnected () const {return had_connect_or_listen == UNCONNECTED;}
  bool is_connect_pending () const {return had_connect_or_listen == CONNECT_PENDING;}
  bool is_connected () const {return had_connect_or_listen == CONNECTED;}
  void set_connect_state (int newstate) { had_connect_or_listen = newstate; }

a1178 1
  bool except_on_write;
d1187 3
a1189 4
		 fh (in_fh), saw_error (false), windows_handle (false),
		 read_ready (false), write_ready (false), except_ready (false),
		 read_selected (false), write_selected (false),
		 except_selected (false), except_on_write (false),
@


1.83.2.11
log
@Merged changes from HEAD
@
text
@a631 2
  int rts;				/* for Windows 9x purposes only */
  int dtr;				/* for Windows 9x purposes only */
a650 1
  int ioctl (unsigned int cmd, void *);
@


1.83.2.12
log
@Merged changes from HEAD
@
text
@a923 1
class cygthread;
d929 1
a929 1
  cygthread *output_thread;		// process_output thread
@


1.83.2.13
log
@Merged changes from HEAD
@
text
@d400 1
d406 1
d408 1
@


1.83.2.14
log
@Merged changes from HEAD
@
text
@a828 1
  void send_winch_maybe ();
@


1.83.2.15
log
@Merged changes from HEAD
@
text
@d401 1
a401 1
  int recvfrom (void *ptr, size_t len, int flags,
d406 1
a406 1
  int sendto (const void *ptr, size_t len, int flags,
@


1.83.2.16
log
@Merged changes from HEAD
@
text
@a118 1
struct iovec;
a299 2
  virtual ssize_t readv (const struct iovec *, int iovcnt, ssize_t tot = -1);
  virtual ssize_t writev (const struct iovec *, int iovcnt, ssize_t tot = -1);
@


1.83.2.17
log
@Merged changes from HEAD
@
text
@d891 2
@


1.83.2.18
log
@Merged changes from HEAD
@
text
@d403 1
a403 1
  ssize_t readv (const struct iovec *, int iovcnt, ssize_t tot = -1);
d406 1
a406 1
  int recvmsg (struct msghdr *msg, int flags, ssize_t tot = -1);
d408 1
a408 1
  ssize_t writev (const struct iovec *, int iovcnt, ssize_t tot = -1);
d411 1
a411 1
  int sendmsg (const struct msghdr *msg, int flags, ssize_t tot = -1);
@


1.83.2.19
log
@Merged changes from HEAD
@
text
@d957 1
@


1.82
log
@* dtable.cc (dtable::build_fhandler): Accept an optional path_conv argument.
If available, use this to calculate path name and device number.
* dtable.h (dtable): Reflect above change.
* fhandler.h (fhandler_base): Declare virtual method which accepts path_conv
rather than path string as first argument.
* fhandler.cc (fhandler_base::open): Define above new method.
* syscalls.cc (_open): Set aside a path_conv variable for use in build_fhandler
and subsequent call to open.
@
text
@d371 1
a371 1
  virtual BOOL hit_eof () {return FALSE;}
d440 3
a445 1
  BOOL is_slow () {return !wincap.has_unreliable_pipes ();}
d455 2
d870 1
a870 1
  BOOL hit_eof ();
@


1.81
log
@* exceptions.cc (setup_handler): Always relinquish lock after we've
interrupted.
* fhandler.cc: Move pipe methods to pipe.cc.
* fhandler.h (fhandler_pipe): Add new methods.
* fork.cc (sync_with_parent): Make error messages more informative.
* pipe.cc (fhandler_pipe::fhandler_pipe): Move here from fhandler.cc.
(fhandler_pipe::lseek): Ditto.
(fhandler_pipe::set_close_on_exec): New method.
(fhandler_pipe::read): Ditto.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::dup): Ditto.
(make_pipe): Create the guard mutex on the read side of the pipe.
* select.cc (peek_pipe): Use guard_mutex to discover if we have the right to
read on this pipe.
(fhandler_pipe::readh_for_read): Pass the read pipe guard mutex to peek_pipe.
* syscalls.cc (_read): Always detect signal catchers, for now.
* debug.cc (makethread): Eliminate hack to make thread inheritable.
* sigproc.cc (subproc_init): Don't use hack to make thread inheritable.
@
text
@d323 1
@


1.80
log
@* fhandler.cc (fhandler_base::set_inheritance): Just use DUPLICATE_CLOSE_SOURCE
to change inheritance.  Eliminate all other logic dealing with closed handles.
* fhandler.h (fhandler_base::set_inheritance): Reflect above change.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Ditto.
@
text
@d438 1
a441 3
  /* This strange test is due to the fact that we can't rely on
     Windows shells to "do the right thing" with pipes.  Apparently
     the can keep one end of the pipe open when it shouldn't be. */
d447 5
@


1.79
log
@        * fhandler.h (fhandler_socket::fixup_after_exec): Remove inline
        implementation.
        (fhandler_dev_raw::fixup_after_exec): Ditto.
        * fhandler_raw.cc (fhandler_dev_raw::fixup_after_fork): Don't
        duplicate buffer on fork to avoid memory leak.
        (fhandler_dev_raw::fixup_after_exec): New implementation equal to
        former fixup_after_fork() implementation.
        * fhandler_socket.cc (fhandler_socket::fixup_after_fork): Do
        nothing when not using Winsock2.
        (fhandler_socket::fixup_after_exec): New implementation.
        (fhandler_socket::set_close_on_exec): Never call set_inheritance().
@
text
@d313 1
a313 2
  virtual void set_inheritance (HANDLE &h, int not_inheriting,
				const char *name = NULL);
@


1.78
log
@* fhandler.h (fhandler_pipe::is_slow): Return true only if pipes are reliable
(i.e., not Win9x).
* wincap.cc: Make statics NO_COPY to avoid fork overhead.
@
text
@d421 1
a421 1
  void fixup_after_exec (HANDLE parent) { fixup_after_fork (parent); }
d493 1
a493 1
  void fixup_after_exec (HANDLE parent) { fixup_after_fork (parent); }
@


1.77
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d445 1
a445 1
  BOOL is_slow () {return wincap.has_unreliable_pipes ();}
@


1.76
log
@Update copyrights.
@
text
@d445 1
a445 1
  BOOL is_slow () {return iswinnt;}
@


1.75
log
@* debug.cc (mark_closed): Rename from debug_mark_closed and make static.
(setclexec_pid): New function for marking saved handle as close-on-exec.
(delete_handle): New function.
(debug_fixup_after_fork): New function.
* debug.h: Declare new functions, remove obsolete ones.
* fork.cc (debug_fixup_after_fork): Call to cleanup close-on-exec handles.
* fhandler.cc (fhandler_disk_file::close): Minor reorg.
(fhandler_base::set_inheritance): Set flag appropriately for debugging when
close-on-exec so forked process can delete closed handles.
* tty.h (open_output_mutex): Eliminate unneeded argument.
(open_input_mutex): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): reflect open_*_mutex argument
changes.
* fhandler.h (fhandler_socket): Make saw_shutdown_* functions type bool.
* tty.cc (tty::get_event): Eliminate unneeded argument.
(tty::common_init): Reflect change to get_event.  Events should always be
inherited.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.74
log
@space reduction.
@
text
@d403 2
a404 2
  int saw_shutdown_read () const {return FHISSETF (SHUTRD);}
  int saw_shutdown_write () const {return FHISSETF (SHUTWR);}
@


1.73
log
@* cygwin.sc: New file -- linker script for building cygwin DLL.
* Makefile.in: Use linker script to control location of cygheap.
* cygheap.cc (buckets): Make static.
(init_cheap): Remove special iswinnt handling.  Allocate cygheap at a fixed
location.  Display more info when allocation fails.
(cygheap_fixup_in_child): Try harder to move cygheap to correct location.
Display more info when allocation fails.
* fhandler.h (fhandler_socket): Add macros for tracking socket shutdown state.
* net.cc (cygwin_shutdown): Set appropriate shutdown value for future use.
* select.cc (select_stuff::cleanup): New method.
(cygwin_select): Call cleanup explicitly to avoid a race.
(select_stuff:~select_stuff): Call cleanup chain via cleanup method.
(fhandler_socket::select_read): Set *_ready when shutdown has been called on
the socket.
(fhandler_socket::select_write): Ditto.
(fhandler_socket::select_except): Ditto.
* winsup.h: Move NO_COPY to "COMMON" section.
* autoload.cc (wsock_started): Avoid initializing NO_COPY value.
* sigproc.cc: Remove initialization from NO_COPY variables.
(sigproc_init): Initialize sig_loop_wait here, rather than via initialization.
(subproc_init): Initialize proc_loop_wait here, rather than via initialization.
@
text
@d338 1
a338 1
                       int flags, off_t off);
d464 1
a464 1
  int varblkop        : 1;
@


1.72
log
@        * fhandler.cc (fhandler_base::is_nonblocking): New method.
        (fhandler_base::set_nonblocking): Ditto.
        * fhandler.h (fhandler_base): Declare new methods `is_nonblocking' and
        `set_nonblocking'.
        * fhandler_socket.cc (fhandler_socket::ioctl): Use `set_nonblocking'.
        * fhandler_tty.cc (fhandler_pty_master::process_slave_output):
        Use `is_nonblocking'.
        (fhandler_tty_slave::read): Ditto.
        (fhandler_tty_slave::ioctl): Use `set_nonblocking'.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (cygwin_sendto): Fallback to winsock 1 functionality
        in case of nonblocking IO.
        (cygwin_recvfrom): Ditto.
        (cygwin_recv): Ditto.
        (cygwin_send): Ditto.
        * syscalls.cc (_read): Use `is_nonblocking'.
@
text
@d73 2
a74 1
  FH_FIFO	= 0x08000000,	/* File is FIFO */
d161 1
a161 1
private:
d402 7
d1077 1
@


1.71
log
@        * fhandler.cc (fhandler_base::fcntl): Use new O_NONBLOCK_MASK define.
        * fhandler.h: Move definitions of O_NOSYMLINK, O_DIROPEN and
        OLD_O_NDELAY from winsup.h to here. Add O_NONBLOCK_MASK define.
        * fhandler_socket.cc (fhandler_socket::close): Add hack to allow
        a graceful shutdown even if shutdown() hasn't been called by the
        application. Add debug output.
        (fhandler_socket::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_socket::fcntl): Use new O_NONBLOCK_MASK define. Actually
        set `request' before using it.
        * fhandler_tty.cc: Use new O_NONBLOCK_MASK define throughout.
        (fhandler_tty_slave::ioctl): Set fhandler's NONBLOCK flag according
        to FIONBIO setting.
        (fhandler_pty_master::ioctl): Ditto.
        * net.cc (wsock_event::prepare): Compare WSACreateEvent return code
        with `WSA_INVALID_EVENT' according to MSDN.
        * syscalls.cc (_read): Use new O_NONBLOCK_MASK define.
@
text
@d210 3
@


1.70
log
@* cygheap.cc (cygheap_root::set): Avoid treating '/' specially.
* fhandler.cc (fhandler_base::fcntl): Only set specific O_NDELAY style flag
passed in from application.
* fhandler_socket.cc (fhandler_socket::fcntl): Ditto.
* fhandler.h: Set constant for future use.
* winsup.h: Define OLD_O_NDELAY only for old programs.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_OLD_O_NONBLOCK.
@
text
@d121 13
@


1.69
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d60 1
a60 1
  FH_HADEOF	= 0x00080000,	/* EOF seen */
@


1.68
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d421 1
a421 1
  BOOL is_slow () {return os_being_run == winNT;}
@


1.67
log
@* mmap.cc: Clean up *ResourceLock calls throughout.
* thread.cc (pthread_cond::TimedWait): Check for WAIT_TIMEOUT as well as
WAIT_ABANDONED.
(__pthread_cond_timedwait): Calculate a relative wait from the abstime
parameter.
@
text
@d224 8
@


1.66
log
@forced commit
@
text
@a976 1
  
@


1.65
log
@        * fhandler.h class fhandler_socket): Declare new method
        `set_close_on_exec'.
        * fhandler_socket.cc (fhandler_socket::set_close_on_exec):
        New method.
@
text
@@


1.64
log
@* fhandler_socket.cc (fhandler_socket::signal_secret_event): New
function.
* fhandler.h: Declare it.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Don't
signal secret event immediately.
(fhandler_socket::check_peer_secret_event): Do it after peer event
was opened.
* net.cc (cygwin_connect): Or if socket is non-blocking.
(cygwin_accept): Ditto.
@
text
@d386 1
@


1.63
log
@* fhandler.cc (fhandler_base::open): Set win32 access flags
to 0, when requested.
* fhandler.h: New status flag FH_QUERYOPEN.
(fhandler::get_query_open): New function.
(fhandler::set_query_open): Ditto.
* syscalls.cc (stat_worker): Request query-only open mode.
@
text
@d400 1
@


1.62
log
@* path.cc (chdir): Always send unsigned chars to isspace since newlib's isspace
doesn't deal well with "negative" chars.
* fhandler.cc (fhandler_disk_file::open): Propagate remote status of file
garnered from path_conv.  Move #! checking to fstat.
(fhandler_disk_file::fstat): Reorganize st_mode setting to eliminate
duplication.  Move check for #! here from fhandler::open.
* fhandler.h (fhandler_base::isremote): New method.
(fhandler_base::set_isremote): Ditto.
(fhandler_base::set_execable_p): Also record "don't care if executable state".
(fhandler_base::dont_care_if_execable): New method.
* path.cc (path_conv::check): Clear new flags.  Appropriately set vol_flags,
drive_type, and is_remote_drive.
* path.h: Add new flags and methods for manipulating them.
* syscalls.cc (_unlink): Use isremote() to determine if a path is remote rather
than calling GetDriveType.
(stat_worker): Ditto.
* security.cc (get_file_attribute): Or attribute with result of NTReadEA to be
consistent with get_nt_attribute.
@
text
@d53 8
a60 8
  FH_RBINARY = 0x00001000,	/* binary read mode */
  FH_WBINARY = 0x00002000,	/* binary write mode */
  FH_CLOEXEC = 0x00004000,	/* close-on-exec */
  FH_RBINSET = 0x00008000,	/* binary read mode has been explicitly set */
  FH_WBINSET = 0x00010000,	/* binary write mode has been explicitly set */
  FH_APPEND  = 0x00020000,	/* always append */
  FH_ASYNC   = 0x00040000,	/* async I/O */
  FH_HADEOF  = 0x00080000,	/* EOF seen */
d62 2
a63 2
  FH_SYMLINK = 0x00100000,	/* is a symlink */
  FH_EXECABL = 0x00200000,	/* file looked like it would run:
d65 1
a65 1
  FH_W95LSBUG= 0x00400000,	/* set when lseek is called as a flag that
d68 1
a68 1
  FH_NOFRNAME= 0x00800000,	/* Set if shouldn't free unix_path_name and
d70 9
a78 7
  FH_NOEINTR = 0x01000000,	/* Set if I/O should be uninterruptible. */
  FH_FFIXUP  = 0x02000000,	/* Set if need to fixup after fork. */
  FH_LOCAL   = 0x04000000,	/* File is unix domain socket */
  FH_FIFO    = 0x08000000,	/* File is FIFO */
  FH_ISREMOTE= 0x10000000,	/* File is on a remote drive */
  FH_DCEXEC  = 0x20000000,	/* Don't care if this is executable */
  FH_HASACLS = 0x40000000,	/* True if fs of file has ACLS */
d256 3
@


1.61
log
@* exceptions.cc (handle_exceptions): Bump repeat count for debugging kick out.
* fhandler.h (fhandler_dev_dsp): Add a fixup_after_exec.
* fhandler_dsp.cc (class Audio): Add TOT_BLOCK_SIZE to enum.
(operator new): New.
(bigwavebuffer): Declare using TOT_BLOCK_SIZE to avoid buffer overruns.
(Audio::Audio): Optimize slightly.
(fhandler_dev_dsp::open): Allocate s_audio using static buffer.
(fhandler_dev_dsp::fixup_after_exec): New function.  Ditto.
@
text
@d74 2
d246 1
d249 1
d270 3
@


1.60
log
@* fhandler.h (fhandler_termios::echo_erase): Declare new method.
* fhandler_termios.cc (fhandler_termios::echo_erase): New method for echoing
erase characters.
(fhandler_termios::line_edit): Check the echo flag before echoing control
characters (from Kazuhiro Fujieda <fujieda@@jaist.ac.jp>).
@
text
@d976 1
@


1.59
log
@* cygheap.cc (_cfree): Add regparm attribute.
(_crealloc): Ditto.
* dcrt0.cc (dll_crt0_1): Default to always checking for executable for now.
* dtable.cc (dtable::not_open): Move method.
* dtable.h (dtable): Here.
* exceptions.cc (ctrl_c_handler): Don't expect process group leader to handle a
signal if it doesn't exist.
* fhandler.h (fhandler_base): Make openflags protected.
* localtime.c (tzsetwall): Check for __CYGWIN__ as well as __WIN32__.
* path.cc (path_conv::check): Add some comments.  Change strcat to assignment.
* lib/_cygwin_S_IEXEC.cc (_cygwin_bob__): Eliminate.
* fhandler_tty.cc (fhandler_console::dup): Set controlling terminal if
necessary.
* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
@
text
@d603 1
@


1.58
log
@Throughout, change 'tty_attached' to 'real_tty_attached', for clarity.
Throughout, change 'OutputStopped' to 'output_stopped', for consistency.
* dtable.cc (stdio_init): Set controlling tty if not set by stdio opens.
* exceptions.cc (ctrl_c_handler): Avoid special pgid checking if no tty is
associated with the process.
(Suggested by Tim Baker <dbaker@@direct.ca>)
* external.cc (fillout_pinfo): Return actual tty number for ctty.
* fhandler_console.cc (get_tty_stuff): Set ctty when shared memory is
allocated.  Accept flags input from open().
(set_console_ctty): New function.
(fhandler_console::open): Pass flags to get_tty_stuff and rely on this function
to set the ctty, if appropriate.
* fhandler_termios.cc (fhandler_termios::set_ctty): Move to tty_min class.
* fhandler_tty.cc (fhandler_tty_slave::open): Use tc field to access
set_ctty().
* tty.h (TTY_CONSOLE): Move to include/sys/cygwin.h.
(tty_min): Add set_ctty class here.
* include/sys/cygwin.h (TTY_CONSOLE): New home here.
* path.cc (symlink_info): Make contents an actual buffer.  Pass more flags to
case_check.
(path_conv::check): Reorganize to do parsing based on posix path rather than
native path.
(symlink_info::check): Expect posix path as input.  Translate to native path
here.  Accept path_conv flags.  Stop parsing if not a symlink regardless of
whether previous path was a symlink.
@
text
@d153 1
a157 1
protected:
@


1.57
log
@Remove trailing underscore from fhandler_base and friends, throughout.
* fhandler.h (fhandler_base::set_open_status): New method.  Stores original
open status.
(fhandler_base::get_open_status): New method.  Retrieves original open status.
(fhandler_base::reset_to_open_binmode): New method.
* fhandler.cc (fhandler_base::open): Save open status.
(fhandler_base::init): Ditto.
* fhandler_clipboard.cc (fhandler_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
* fhandler_dsp.cc (fhandler_dsp::open): Ditto.
* fhandler_dev_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_dev_random.cc (fhandler_dev_random::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tty_slave.cc (fhandler_tty_slave::open): Ditto.
* fhandler_tty_master.cc (fhandler_tty_master::open): Ditto.
* fhandler_dev_zero.cc (fhandler_dev_zero::open): Ditto.
* syscalls.cc (setmode): Rework so that 0 mode value causes reversion to open
state.
* fhandler_tty_slave.cc (fhandler_tty_slave::read): Use correct multiplier when
converting from deciseconds to milliseconds.
@
text
@a597 1
  void set_ctty (int ttynum, int flags);
@


1.56
log
@* fhandler.h (fhandler_base::clear_r_binary): New method.
(fhandler_base::clear_w_binary): New method.
* syscalls.cc (setmode): Accept 0 as mode value.  Resets text/binary behavior
for fd to default.
@
text
@d68 1
a68 1
  FH_NOFRNAME= 0x00800000,	/* Set if shouldn't free unix_path_name_ and
d148 1
a148 1
  int access_;
d151 1
a151 1
  unsigned long namehash_;	/* hashed filename, used as inode num */
d155 1
a155 1
  int openflags_;
d164 3
a166 2
  char *unix_path_name_;
  char *win32_path_name_;
d184 2
a185 2
  int get_access () { return access_; }
  void set_access (int x) { access_ = x; }
d190 2
a191 2
  int get_flags () { return openflags_; }
  void set_flags (int x) { openflags_ = x; }
d203 8
d271 3
a273 3
  const char *get_name () { return unix_path_name_; }
  const char *get_win32_name () { return win32_path_name_; }
  unsigned long get_namehash () { return namehash_; }
@


1.55
log
@* path.h (cwdstuff): Move class.
* cygheap.h (cwdstuff): To here.
(init_cygheap): Add cwd field.
* child_info.h (cygheap_exec_info): Eliminate cwd stuff.
(child_info_spawn): Ditto.
* dcrt0.cc (dll_crt0_1): Remove cygcwd.fixup_after_exec call.  Convert cygcwd
reference to cygheap->cwd.
* path.cc: Ditto, throughout.
(cwdstuff::copy): Eliminate.
(cwdstuff::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Eliminate call to cygcwd.copy.
* fhandler.h (FH_OSS_DSP): Move into "fast" device category.
@
text
@d200 2
@


1.54
log
@* autoload.cc: Add winmm functions needed by fhandler_dsp.cc.
* fhandler_dsp.cc: New file.  Implements OSS like /dev/dsp.
* include/sys/soundcard.h: New file.  User land includes for OSS /dev/dsp.
* fhandler.h: Add new class fhandler_dev_dsp and a FH_OSS_DSP definition.
* dtable.cc (dtable::build_fhandler): Allow creation of the /dev/dsp device.
* path.cc (windows_device_names): Add /dev/dsp into list of device names.
* Makefile.in (DLL_OFILES): Add fhandler_dsp.o.
@
text
@a90 1
  FH_OSS_DSP = 0x0000000d,	/* is the dsp audio device */
d102 1
d104 1
a104 1
  FH_NDEV    = 0x00000018,	/* Maximum number of devices */
@


1.53
log
@* fhandler.h (class fhandler_socket): Add members and methods to
support secure connections on AF_UNIX sockets.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): New method.
(fhandler_socket::get_connect_secret): Ditto.
(fhandler_socket::create_secret_event): Ditto.
(fhandler_socket::close_secret_event): Ditto.
(fhandler_socket::check_peer_secret_event): Ditto.
(fhandler_socket::fixup_after_fork): Duplicate secret event to child.
(fhandler_socket::dup): Copy address family.
(fhandler_socket::close): Close secret event.
* net.cc (get_inet_addr): Read secret cookie.
(cygwin_connect): Check if peer knows secret cookie value.
(cygwin_accept): Ditto. Copy address family to newly created socket.
(cygwin_bind): Generate and write secret cookie.
(wsock_init): Initialize random number generator.
@
text
@d91 1
a91 1

d942 23
@


1.52
log
@        * fhandler.h (class fhandler_console): Add members `insert_mode'.
        * fhandler_console.cc (fhandler_console::dup): Duplicate `insert_mode'.
        (fhandler_console::fhandler_console): Initialize `insert_mode'.
        fhandler_console::char_command): Add terminal capabilities
        "enter insert mode" = \E[4h and "exit insert mode" = \E[4l.
        Care for insert mode on terminal capability "repeat char" = \E[x;yb.
        (fhandler_console::write_normal): Care for insert mode before writing
        to the console.
        (array keytable): Add keymapping for modified cursor and control
        block keys (xterm like).
@
text
@d345 2
d373 5
@


1.51
log
@        * fhandler.h (class fhandler_console): Add members `savebufsiz' and
        `savebuf' to allow save/restore of screen.
        * fhandler_console.cc (fhandler_console::dup): Duplicate savebuf.
        (fhandler_console::fhandler_console): Initialize `savebufsiz' and
        `savebuf'.
        (fhandler_console::char_command): Add terminal capabilities
        "save screen content" = \E[?47h and "restore screen content" = \E[?47l.
@
text
@d655 1
@


1.50
log
@* fhandler.h (fhandler_dev_clipboard): Extend to support writing.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Initialize new fields.  Open clipboard here.
(fhandler_dev_clipboard::dup): New method.
(fhandler_dev_clipboard::open): Accomodate new fields.  Register clipboard
here, if appropriate.
(set_clipboard): New function.  Moves buffer to clipboard.
(fhandler_dev_clipboard::write): Truly implement clipboard writing.
(fhandler_dev_clipboard::read): Reimplement to allow successive reads.
(fhandler_dev_clipboard::lseek): Truly implement seeks in clipboard.
(fhandler_dev_clipboard::close): Clear out new fields.  Support sequential
reads and sequential writes.  Support for binary data via a native clipboard
format.
@
text
@d633 4
@


1.49
log
@* fhandler.h (fhandler_tty_slave): Declare new methods.
* select.cc (fhandler_tty_slave::select_read): New method.
* select.cc (fhandler_tty_slave::ready_for_read): Ditto.
* select.cc (verify_tty_slave): New function.
* fhandler_termios.cc (fhandler_termios::line_edit): Empty input
buffer on signal.
* fhandler_tty.cc (fhandler_tty_slave::read): Check for input data
after reading from pipe. Reset event if input pipe is empty.
* tty.h (class tty): Allow creating events with manual reset.
* tty.cc (tty::get_event): Use manual_reset flag.
* tty.cc (tty::common_init): Create input_available_event with
manual reset.
@
text
@d898 2
d901 6
@


1.48
log
@* fhandler.h (fhandler_termios::fixup_after_exec): New function.
* fhandler.cc (fhandler_termios::fixup_after_fork): New function.
Fixup output handle.
* fhandler_tty.cc (fhandler_tty_common::fixup_after_fork): Output
handle is now fixed up in fhandler_termios::fixup_after_fork().
@
text
@d764 2
@


1.47
log
@* fhandler.h (fhandler_termios::fhandler_termios): Enable fixup
after fork.
* fhandler_console.cc (fhandler_console::fhandler_console): Fixup
after fork is now enabled in the base class constructor.
@
text
@d584 2
@


1.46
log
@* autoload.cc (noload): Use proper method for multiline strings or newer gcc's
complain.
* exceptions.cc (unused_sig_wrapper): Ditto.
* fhandler.h (fhandler_base): Make get_io_handle and friends return self.
* fhandler_tty.cc (fhandler_pty_common::close_on_exec): Accomodate DEBUGGING
flag to avoid spurious warnings when inheritance is set.
@
text
@d571 1
a571 1
    // nothing to do
@


1.45
log
@        * autoload.c (cygwin_premain0): Add missing parameter.
        * binmode.c (cygwin_premain0): Ditto.
        * textmode.c (cygwin_premain0): Ditto.

Patch contributed by Jason Tiller <jtiller@@sjm.com> :
        * auto_load.cc: Add "GetKeyboardLayout" entry in the list of
        Win32 User32.DLL exports to provide.
        * fhandler.h (class fhandler_console): Add meta_mask private
        member to remember which keystroke modifiers should generate
        META.
        * fhandler_console.cc (fhandler_console::read): Modify code that
        tests a keystroke for a META-escaped key to use the 'meta_mask'
        variable.
        (fhandler_console::fhandler_console): Add definition for
        variable "meta_mask" used to determine if a keystroke should be
        preceded by META in the client console stream.  Set meta_mask
        based on whether or not user's keyboard language is English -
        non-English keyboards pass AltGr (right <ALT>) unmolested,
        whereas English keyboards now interpret left- and right-<ALT>
        as META.
@
text
@d320 3
a322 3
  virtual HANDLE get_handle () const { return io_handle; }
  virtual HANDLE get_io_handle () const { return io_handle; }
  virtual HANDLE get_output_handle () const { return io_handle; }
d350 1
a350 1
  int get_socket () const { return (int) get_handle(); }
d573 1
a573 1
  HANDLE get_output_handle () const { return output_handle; }
@


1.44
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@d611 3
@


1.43
log
@* fhandler.h (class fhandler_tty_common): New mutex and event to
syncronize input on master tty with slave tty.
* fhandler_tty.cc (fhandler_pty_master::accept_input): Use them to
syncronize with slave.
* fhandler_tty.cc (fhandler_tty_slave::read): Use input mutex and
event to syncronize with master. Do not limit amount of data read
from master to vmin value. Interrupt on signal and return already
read data, if any.
* fhandler_tty.cc (fhandler_tty_slave::open): Handle input mutex and
event.
* fhandler_tty.cc (fhandler_tty_common::close): Ditto.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::fixup_after_fork): Ditto.
* fhandler_tty.cc (fhandler_tty_common::dup): Ditto.
* tty.h (tty::open_input_mutex): New function.
* tty.cc (tty::common_init): Create input mutex and event.
@
text
@d133 8
d230 4
a233 1
  void set_execable_p (int val) { FHCONDSETF (val, EXECABL); }
a490 3
private:
  int check_execable_p (const char *path);

@


1.42
log
@* select.cc (peek_console): Don't report read_ready on mouse events unless we
are looking for mouse events.
* fhandler.h (fhandler_console::mouse_aware): New method.
@
text
@d710 2
a711 1
  HANDLE output_mutex;
@


1.41
log
@* fhandler.h (class fhandler_console): Make all variables that
describe "state" of console to be members of fhandler_console.
default_color is now the color which is set when console recieves
reset command.
* fhandler_console.cc (fhandler_console::fhandler_console): Turn
mouse handling and raw keyboard mode off by default. Initialize
state information.
* fhandler.cc (fhandler_console::set_raw_win32_keyboard_mode): New
function.
* fhandler_console.cc (fhandler_console::set_default_attr): New
function. Reset console attributes to default values.
* fhandler_console.cc (fhandler_console::open): Reset attributes.
* fhandler_console.cc (fhandler_console::get_win32_attr): New function.
Calculate win32-style console attribute based on terminal attributes.
* fhandler_console.cc (fhandler_console::set_cursor_maybe): Use
member variable.
* fhandler_console.cc (fhandler_console::read): If in raw-win32
keyboard mode, encode win32 keyboard events in \033{x;y;z;t;u;wK
sequences.
* fhandler_console.cc (fhandler_console::dup): Copy all state
information to the dup()ed handle.
* fhandler_console.cc (fhandler_console::scroll_screen): Use current
fill-in	attribute.
* fhandler_console.cc (fhandler_console::clear_screen): Ditto.
* fhandler_console.cc (fhandler_console::char_command): Check if we
saw '?' symbol by member variable. Set terminal	attributes on \033[Xm
commands. \033[24m - turn off underline mode, \033[27m - turn off
reverse mode, \033[39m - restore default foreground color.
\033[49m - restore default background color. \033[2000h - turn on raw
keyboard mode, \033[2000l - turn off raw keyboard mode.
* fhandler_console.cc (fhandler_console::write): Set attribues to
default values on reset command.
@
text
@d683 1
@


1.40
log
@* autoload.cc (LoadDLLinitfunc): Remove debugging statement.
* exceptions.cc (sig_handle_tty_stop): Move setting of PID_STOPPED to earlier
in interrupt.
((interrupt_setup): i.e., here.
(sig_handle): Don't queue multiple SIGSTOPS.
* fhandler.h (bg_check_types): Enumerate return value of bg_check for clarity.
* signal.cc (kill_pgrp): Minor cleanup.
* fhandler_termios.cc (fhandler_termios::bg_check): Use enumerated type for
function return.  Don't raise signal if a signal is already queued.
* fhandler_console.cc (fhandler_console::read): Use enumerated return type for
bg_check.
* select.cc: Ditto, throughout.
* read.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
(_read): YA interrupt detect simplification.
* wait.cc (wait4): Ditto.
@
text
@d578 1
a578 2
/* This is a input and output console handle */
class fhandler_console: public fhandler_termios
d580 5
a584 3
private:

/* Output state */
a585 1
  // enum {normal, gotesc, gotsquare, gotarg1, gotcommand} state;
d595 9
d607 30
d638 2
a639 1
  DWORD default_color;
d642 2
d652 2
a653 1
  void char_command (char, bool);
@


1.39
log
@        * fhandler.h (fhandler_base): New method `fixup_mmap_after_fork'.
        (fhandler_disk_file: Ditto.
        (fhandler_dev_mem): Ditto.
        * fhandler_mem.cc (fhandler_dev_mem::open): Set OBJ_INHERIT attribute
        for device\physicalmemory handle.
        (fhandler_dev_mem::mmap): Ditto.
        * fhandler_mem.cc (fhandler_dev_mem::fixup_mmap_after_fork): New method.
        * mmap.cc (mmap_record): Add private `fdesc_' member. Change constructor
        accordingly.
        (get_fd): New method.
        (mmap): Use new mmap_record constructor.
        (fhandler_base::fixup_mmap_after_fork): New method.
        (fhandler_disk_file::fixup_mmap_after_fork): Ditto.
        (fixup_mmaps_after_fork): Call `fixup_mmap_after_fork' of appropriate
        fhandler class.
@
text
@d125 8
d321 1
a321 1
  virtual int bg_check (int) {return 1;}
d573 1
a573 1
  int bg_check (int sig);
@


1.38
log
@* fhandler.h (fhandler_console): Add additional argument to char_command
method.
* fhandler_console.cc (fhandler_console::read): Revert previously misapplied
patch.
(fhandler_console::char_command): Add a second argument.
(fhandler_console::write): Recognize when a '?' is found after a <esc>[.
@
text
@d274 2
d488 2
d813 2
@


1.37
log
@* path.cc (get_device_number): Allow /dev/ttySn to designate a com port.
@
text
@d598 1
a598 1
  void char_command (char);
@


1.36
log
@        * fhandler.h (fhandler_dev_raw): Add method `fixup_after_exec'.
@
text
@a904 2
uid_t __stdcall get_file_owner (int, const char *);
gid_t __stdcall get_file_group (int, const char *);
@


1.35
log
@        * fhandler.h (fhandler_dev_raw): Add definition for method
        `fixup_after_fork'.
        * fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Add
        `set_need_fixup_after_fork' call.
        (fhandler_dev_raw::~fhandler_dev_raw): Revert to user space
        allocation.
        (fhandler_dev_raw::open): Ditto.
        (fhandler_dev_raw::dup): Ditto. Reset buffer pointer.
        (fhandler_dev_raw::fixup_after_fork): New function.
        * fhandler_tape.cc (fhandler_dev_tape::open): Revert to user space
        memory allocation.
        (fhandler_dev_tape::ioctl): Ditto. Change behaviour on MTSETBLK when
        new size is 1.
@
text
@d408 1
@


1.34
log
@Whitespace cleanup.

* configure.in: Eliminate subdir stuff.
* configure: Regenerate.
* include/getopt.h (option): Make name field 'const'.
@
text
@d406 2
@


1.33
log
@        * fhandler_socket.cc: New file.
        * Makefile.in: Add fhandler_socket.o to dependencies.
        * fhandler.h: Change comment.
        * net.cc Move all fhandler_socket methods to fhandler_socket.cc.
        * winsup.h: Add declaration for `ws2_32_handle'.
@
text
@d809 1
a809 1
 
@


1.32
log
@        * dtable.cc (dtable::release): Check for socket. Change
        cnt_need_fixup_before accordingly.
        (dtable::dup2): Ditto.
        (dtable::fixup_before_fork): New method.
        (dtable::fixup_before_exec): Ditto.
        * dtable.h (class dtable): Add member `cnt_need_fixup_before'. Add
        definition for methods `dec_need_fixup_before', `inc_need_fixup_before',
        `need_fixup_before', `fixup_before_exec' and `fixup_before_fork'.
        * fhandler.h (class fhandler_base): Slight rearrangements. Add
        definitions for methods `fixup_before_fork_exec'.
        (class fhandler_socket): Eliminate superfluous constructor.
        Add member `prot_info_ptr'. Add destructor. Add definitions for
        methods `dup', `fixup_before_fork_exec', `fixup_after_fork' and
        `fixup_after_exec'.
        * fork.cc (fork_parent): Care for file types which need a fixup
        before fork. Start child in suspended state then.
        * net.cc: New global variable `ws2_32_handle' and `wsadata'.
        (fdsock): Check for Winsock version. Call `set_socket_inheritance'
        only if Winsock version < 2.0. Care for `need_fixup' count in fdtab.
        (cygwin_socket): Eliminate call to `set_socket_inheritance'.
        (cygwin_accept): Ditto.
        (cygwin_rcmd): Ditto.
        (cygwin_rresvport): Ditto.
        (cygwin_rexec): Ditto.
        (socketpair): Ditto.
        (fhandler_socket::fhandler_socket): Set `need_fork_fixup'. Allocate
        space for the WSAPROTOCOL_INFOA struct used in fixup.
        (fhandler_socket::~fhandler_socket): New destructor.
        (fhandler_socket::fixup_before_fork_exec): New method.
        (fhandler_socket::fixup_after_fork): Ditto.
        (fhandler_socket::dup): Ditto.
        (wsock_init): New static function.
        (LoadDLLinitfunc (wsock32)): Rearranged.
        (LoadDLLinitfunc (ws2_32)): New function.
        (dummy_autoload): Add autoload statemants for `WSADuplicateSocketA'
        and `WSASocketA'.
        * spawn.cc (spawn_guts): Care for file types which need a fixup
        before exec. Start child in suspended state then.
@
text
@d32 1
a32 1
     fhandler_socket      (net.cc)
@


1.31
log
@        * fcntl.cc (_fcntl): Rearrange as wrapper function. Move all
        functionality except F_DUPFD to fhandler classes.
        * fhandler.cc (fhandler_base::fcntl): New method.
        * net.cc (fhandler_socket::fcntl): Ditto.
        * fhandler.h (class fhandler_base): Add method prototype for fcntl().
        (class fhandler_socket): Ditto.
@
text
@d200 4
a203 1
  virtual void fixup_after_fork (HANDLE parent);
a296 2
  virtual void fixup_after_exec (HANDLE) {}

d324 2
d328 1
a328 1
  fhandler_socket (unsigned int, const char *name = 0);
d338 5
@


1.30
log
@* fhandler.h (fhandler_console): Remove tcsetpgrp.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Eliminate.
* fork.cc (fork_parent): Avoid returning same pid twice in a row regardless of
OS.
* pinfo.cc (pinfo::init): Rename create argument to flags and treat it as such.
* signal.cc (set_sigcatchers): New function.
(signal): Use set_sigcatchers to increment or decrement sigcatcher tracker.
(sigaction): Ditto.  Add debugging output.
* spawn.cc (spawn_guts): Always quote first argv[0] argument when it's a
COMSPEC shell.
@
text
@d258 1
d331 1
@


1.29
log
@* fhandler_clipboard.cc: new file
* Makefile.in: include fhandler_clipboard.o in DLL_OFILES list.
* fhandler.h: add FH_CLIPBOARD to the devices enum.
(fhandler_dev_clipboard): new
* path.cc (windows_device_names): add "\\dev\\clipboard"
(get_device_number): check for "clipboard"
* dcrt0.cc: declare a few more functions from winuser.h
* dtable.cc (dtable::build_fhandler): check for FH_CLIPBOARD in
switch().
@
text
@a609 2
  int tcsetpgrp (const pid_t pid);

@


1.28
log
@* errno.cc (seterrno_from_win_error): Fix debugging output.
* fhandler.cc (fhandler_base::fstat): Move to inline method in fhandler.h.
(fhandler_base::set_io_handle): Ditto.
* fhandler.h (fhandler_base): Make some methods inline.
* fhandler_console.cc (fhandler_console::write_normal): Make buffer larger.
* sigproc.h (sigframe::sigframe): Actually use set ebp parameter correctly.
* spawn.cc (spawn_guts): Set dwProcessId when exec'ing.  Just exit immediately
after reparenting.
* syscalls.cc: Sprinkle sigframe stuff throughout.
* wait.cc (wait4): Set signal frame here.
* dcrt0.cc (__api_fatal): Don't rely on small_printf to display errors.  Always
display problems to the console, if possible.
@
text
@d46 2
d102 1
d104 1
a104 1
  FH_NDEV    = 0x00000017,	/* Maximum number of devices */
d798 14
@


1.27
log
@        * fhandler.h (fhandler_dev_mem): Erase member `init_phase' and
        member function `init'.
        * fhandler_mem.cc: Add typedefs for NT internal data types
        `SYSTEM_INFORMATION_CLASS' and `SYSTEM_BASIC_INFORMATION'.
        Add prototype for `NtQuerySystemInformation' function.
        (fhandler_dev_mem::fhandler_dev_mem): Takes over initialization task
        from `init'. Use `NtQuerySystemInformation' function to evaluate the
        size of physical memory instead of interval search.
        (fhandler_dev_mem::init): Eliminated.
        (fhandler_dev_mem::open): Don't call `init'.
        (fhandler_dev_mem::read): Eliminate check for `init_phase'.
        (dummy_autoload): Add load statement for `NtQuerySystemInformation'.
@
text
@d157 1
a157 1
  void set_io_handle (HANDLE);
d253 1
a253 1
  virtual int fstat (struct stat *buf);
@


1.26
log
@* fhandler.h (fhandler_base): Remove obsolete _rpos and _rsize elements.
* fhandler.cc (fhandler_base::open): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Ditto.
(fhandler_base::read): Ditto.  Add more debugging output.  Don't issue a \r
when \r\n detected.
* pipe.cc (make_pipe): Streamline slightly.  Make debug output more
interesting.
* strace.cc (strace::vsprintf): Use __progname where appropriate to distinguish
strace output when exec'ing.
@
text
@a778 3
  bool init_phase;

  void init (void);
@


1.25
log
@        * fhandler.h (fhandler_dev_mem): Add methods mmap, munmap and msync.
        Add `unit' member.
        * fhandler_mem.cc (fhandler_dev_mem): Initialize `unit' as well.
        (init): Care for differences between /dev/mem, /dev/kmem (not
        implemented yet) and /dev/port.
        (open): Change debug message to reflect the device.
        (mmap): New function.
        (munmap): Ditto.
        (msync): Ditto.
        (fstat): Use unit when setting st_dev in stat structure.
        * mmap.cc (mmap): Handle MAP_ANONYMOUS flag.
        Change error handling slightly.
        * path.cc (get_device_number): Handle /dev/port.
@
text
@a131 3
  int rpos_; /* Used in text reading */
  int rsize_;

@


1.24
log
@        =====================================
        These changes require rebuilding all.
        =====================================
        * fhandler.h: Add mmap(), munmap() and msync() to fhandler_base
        and fhandler_disk_file.
        * mmem.cc (mmap): Eliminated device dependent implementation details.
        These are moved to the appropriate fhandler class.
        (munmap): Ditto.
        (msync): Ditto.
        (fhandler_base::mmap): New method.
        (fhandler_base::munmap): Ditto.
        (fhandler_base::msync): Ditto.
        (fhandler_disk_file::mmap): Ditto.
        (fhandler_disk_file::munmap): Ditto.
        (fhandler_disk_file::msync): Ditto.
@
text
@d470 3
a472 4
  virtual HANDLE mmap (caddr_t *addr, size_t len, DWORD access,
                       int flags, off_t off);
  virtual int munmap (HANDLE h, caddr_t addr, size_t len);
  virtual int msync (HANDLE h, caddr_t addr, size_t len, int flags);
d779 3
a781 2
  unsigned long mem_size;
  unsigned long pos;
d797 4
@


1.23
log
@        * fhandler.h (fhandler_dev_mem): Add method `init'. Add members
        `mem_size' and `init_phase'.
        * fhandler_mem.cc (init): New function to figure out the size of
        the physical memory.
        (open): Add checking for illegal flags. Change usage of access mode.
        (write): Add intended functionality.
        (read): Add parameter checking. Eliminate page size constant. Use
        getpagesize() instead. Don't touch errno and don't create debug output
        while init() is running.
        (lseek): Add bounds checking. Fix SEEK_END.
        (fstat): Eliminate page size constant. Use getpagesize() instead.
        (dup): Add intended functionality.
@
text
@d266 5
d469 5
@


1.22
log
@        * Makefile.in: Add fhandler_mem.o to the dependencies.
        * dtable.cc (dtable::build_fhandler): Add case for FH_MEM.
        * fhandler.h: Add FH_MEM device type.  Add class fhandler_dev_mem.
        * fhandler_mem.cc: New file. Implementation of class fhandler_dev_mem.
        * path.cc: Add /dev/mem to windows_device_names.
        (get_device_number): Add FH_MEM type.
@
text
@d770 1
d772 3
@


1.21
log
@* dcrt0.cc (quoted): Fix problem where ' quoted strings were skipped.
* fhandler.h (fhandler_socket::~fhandler_socket): Delete declaration.
* net.cc: Remove unnecessary "number_of_sockets" usage.
(fhandler_socket::fhandler_socket): Ditto.
(fhandler_socket::~fhandler_socket): Delete definition.
* spawn.cc (spawn_guts): Force first argument passed to CreateProcess as a
command line to be windows style.
@
text
@d44 2
d99 1
d101 1
a101 1
  FH_NDEV    = 0x00000016,	/* Maximum number of devices */
d762 20
@


1.20
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@a316 1
  ~fhandler_socket ();
@


1.19
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@d845 1
@


1.18
log
@* exceptions.cc (signal_exit): Reset all mutos owned by the main thread.
* fhandler.h: Define *_output_mutex macros for serializing tty output.
(fhandler_termios): Remove restart_output_event.  Define dummy output mutex
methods.
(fhandler_pty_master): Remove unneeded fixup_after_fork method.
* fhandler_termios.cc (fhandler_termios::line_edit): Acquire output_mutex when
CTRL-S is hit.  Release it on CTRL-Q.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Remove
inappropriate OutputStopped test here.  Just use the output mutex.
(fhandler_pty_master::fhandler_pty_master): Remove obsolete reference to
restart_output_event.
(fhandler_tty_common::close): Ditto.
(fhandler_pty_master::set_close_on_exec): Ditto.
(fhandler_pty_master::fixup_after_fork): Delete.
* tty.cc (tty::common_init): Ditto.
* sync.cc (muto::reset): New method.
* sync.h: Declare above method.
@
text
@d514 2
d599 1
a599 1
  int tcsetpgrp (const pid_t pid) { tc->pgid = pid; return 0; }
d614 1
a614 5
  void set_input_state ()
  {
    if (TTYISSETF (RSTCONS))
      input_tcsetattr (0, &tc->ti);
  }
@


1.17
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d508 6
a526 1
  HANDLE restart_output_event;
d536 2
a701 1
  void fixup_after_fork (HANDLE parent);
@


1.16
log
@* include/cygwin/cygwin_dll.h: Update for modern compilers.
* lib/cygwin_crt0.c: Inexplicably need to define alloca for newer compilers.
* fhandler.h (fhandler_console): Add new method.
* fhandler.cc (fhandler_console::set_cursor_maybe): New method.
(fhandler_console::read): Set cursor if it has moved to make it visible.
@
text
@d152 1
a152 7
  virtual fhandler_base& operator =(fhandler_base &x)
  {
    memcpy (this, &x, sizeof *this);
    unix_path_name_ = x.unix_path_name_ ? strdup (x.unix_path_name_) : NULL;
    win32_path_name_ = x.win32_path_name_ ? strdup (x.win32_path_name_) : NULL;
    return *this;
  };
d240 2
a241 1
  virtual void set_inheritance (HANDLE &h, int not_inheriting, const char *name = NULL);
d285 1
a285 4
  /* Function to save state of a fhandler_base into memory. */
  virtual int linearize (unsigned char *);
  /* Function to de-linearize into a fd */
  virtual int de_linearize (const char *, const char *, const char *);
d302 6
a377 3
  /* Function to de-linearize into a fd */
  int de_linearize (const char *, const char *, const char *);

d495 1
a495 1
  int de_linearize (const char *, const char *, const char *);
d602 1
a602 1
  int de_linearize (const char *, const char *, const char *);
d710 1
a710 1
  int de_linearize (const char *, const char *, const char *);
@


1.15
log
@        * fhandler.h (class fhandler_dev_random): Add members for managing
        pseudo randomness.
        * fhandler_random.cc: Rearrange. Use pseudo random number generator
        as entropy source if system entropy isn't available and if device is
        used as /dev/urandom. Allow initializing device by calling write().
@
text
@d576 1
@


1.14
log
@        * fhandler.h: Add comment.
@
text
@d746 5
@


1.13
log
@        * fhandler.h (class fhandler_dev_raw): Add private member `varblkop'
        to be set when variable blocksize mode is on.
        * fhandler_raw.cc: Eliminate `\n' from trace output.
        (clear): Set `varblkop' to 0.
        (dup): Copy varblkop as well.
        (writebuf): Care for variable blocksize.
        (open): Ditto.
        (raw_read): Ditto.
        (raw_write): Ditto.
        * fhandler_tape.cc (open): Ditto.
        (ioctl): Ditto. Some cleanups.
@
text
@d42 2
d746 1
@


1.12
log
@* cygwin.din: Export _getmode and getmode to allow querying of binary state of
an fd.
* external.cc (cygwin_internal): Add handling of perfile_table setting.
* fhandler.cc (perfile_table): New global.
(fhandler_base::get_default_fmode): New method to return a file's default mode
based on its name.
(fhandler_base::open): Use get_default_mode method to determine a file's mode.
Record file mode in file flags.
* fhandler.h (fhandler_base): Declare get_default_fmode
* syscalls.cc (getmode): New function.
* sys/cygwin.h (__cygwin_perfile): New structure.
(cygwin_getinfo_types): Move outside of WINVER conditional.
(per_process): Move inside of WINVER conditional.
@
text
@d362 1
@


1.11
log
@* fhandler.h (set_name): Don't use 'unix' as name since this is defined by gcc
now.
* fhandler.cc (set_name): Ditto.
@
text
@d110 1
d185 2
@


1.10
log
@* Makefile.in (DLL_OFILES): Sort.
* fhandler_tty.cc (fhandler_tty_slave::send_ioctl_request): Eliminate.
(fhandler_tty_slave::ioctl): Rewrite to avoid races.
@
text
@d146 2
a147 1
  void set_name (const char *unix, const char *win32 = NULL, int unit = 0);
@


1.9
log
@        * Makefile.in: Add dependencies for fhandler_random.o
        * fhandler.h: Add device type FH_RANDOM. Add class
        fhandler_dev_random.
        * fhandler_random.cc: New file. Implementation of
        fhandler_dev_random.
        * hinfo.cc (build_fhandler): Add case for FH_RANDOM.
        * path.cc: Add device names for random devices to
        windows_device_names.
        (get_device_number): Add if branch for random devices.
        (win32_device_name): Add device name generation for
        random devices.
        winsup.h: Include <wincrypt.h>.
@
text
@a647 2
  void send_ioctl_request ();

@


1.8
log
@* fhandler.h (fhandler_base::hclose): New virtual method.
(fhandler_base::set_inheritance): Make this a method so that we can use the
appropriate close methods.
* fhandler.cc (fhandler_base::set_inheritance): Ditto.
* path.cc (normalize_posix_path): Eliminate /.  trailing path component.
@
text
@d94 1
d96 1
a96 1
  FH_NDEV    = 0x00000015,	/* Maximum number of devices */
d732 18
@


1.7
log
@* fhandler.h (select_stuff): Eliminate use of 'total'.
* select.cc (cygwin_select): Ditto.
(select_stuff::wait): Use maximum size for w4 rather than calculating what will
fit.
@
text
@d238 2
d320 1
a814 2

void __stdcall set_inheritance (HANDLE &h, int val, const char *name = NULL);
@


1.6
log
@Simplify constructors and initializers for select_record.
@
text
@d796 1
a796 2
  select_stuff (): always_ready (0), windows_used (0),
		   total (0), start (0)
a800 1
  int total;
@


1.5
log
@* fhandler.h (select_record): Explicitly zero elements of this class.
(select_stuff): Ditto.
* select.cc (cygwin_select): Eliminate memset zero of sel.
@
text
@d784 6
a789 6
  select_record (fhandler_base *in_fh = NULL) {memset (this, 0, sizeof(select_record)); fh = in_fh;}
  select_record (int) : fd (0), h (NULL), fh (0), saw_error (0), windows_handle (0),
		     read_ready (0), write_ready (0), except_ready (0),
		     read_selected (0), write_selected (0), except_selected (0),
		     startup (NULL), poll (NULL), verify (NULL), cleanup (NULL),
		     next (NULL) {}
@


1.4
log
@Pipe changes throughout suggested by Eric Fifer <EFifer@@sanwaint.com>
* debug.cc (threadname_init): Pass name of lock as arg 2 of new_muto.
* malloc.cc (malloc_init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* exceptions.cc (events_init): Ditto.
(call_handler): Eliminate special case for hExeced.  Report locked thread in
debugging output.
* fhandler.cc (fhandker_pipe::fhandler_pipe): Propagate device type to base
class.
* fhandler.h (fhandler_pipe): Ditto.
* hinfo.cc (hinfo::build_fhandler): Pass specific type of pipe to constructor.
* spawn.cc (spawn_guts): Eliminate dependency on signal when waiting for
subprocess.
* strace.cc: Remove obsolete #ifdef.
* sync.cc (muto::muto): Save the name of the muto.
(muto:~muto): Also release the muto.
* sync.h: Add a muto name field.
* select.cc (peek_pipe): Avoid doing a PeekNamedPipe on the write end of a
pipe.
@
text
@a775 1
  select_record (fhandler_base *in_fh = NULL) {memset (this, 0, sizeof(select_record)); fh = in_fh;}
d783 7
d796 5
@


1.3
log
@* fhandler.cc (fhandler_base::get_readahead_into_buffer): New function.
* fhandler.h: Declare new function.  Add extra argument to
process_slave_output.
* fhandler_console.cc (fhandler_console::read): Move read ahead code to new
function.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Move common code
here.
(fhandler_tty_slave::read): Understand readahead.
(fhandler_pty_master::read): Move code to process_slave_output.
* select.cc (peek_pipe): Avoid performing certain checks when non-read and on
inappropriate fh types.
@
text
@d330 1
a330 1
  fhandler_pipe (const char *name = 0);
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d225 2
d668 1
a668 1
  int neednl_;			// Next read should start with \n
d673 1
a673 1
  int process_slave_output (char *buf, size_t len);
@


1.1
log
@Initial revision
@
text
@d298 1
a298 1
  virtual int bg_check (int, int x = 0) {return 1;}
d314 1
a314 1
  off_t lseek (off_t offset, int whence) { return 0; }
d482 1
a482 1
  off_t lseek (off_t offset, int whence) { return 0; }
d504 1
a504 1
  virtual void doecho (const void *str, DWORD len) {};
d522 1
a522 1
  int bg_check (int sig, int blocksigs = 1);
d659 1
a659 1
  off_t lseek (off_t offset, int whence) { return 0; }
d684 1
a684 1
  off_t lseek (off_t offset, int whence) { return 0; }
d742 1
a742 1
  off_t lseek (off_t offset, int whence) { return 0; }
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
