head	1.25;
access;
symbols
	cygwin-1_7_35-release:1.25
	cygwin-1_7_34-release:1.25
	cygwin-1_7_33-release:1.25
	cygwin-1_7_32-release:1.25
	cygwin-1_7_31-release:1.25
	cygwin-1_7_30-release:1.25
	cygwin-1_7_29-release:1.25
	cygwin-1_7_29-release-branchpoint:1.25.0.2
	cygwin-pre-user-db:1.25
	cygwin-1_7_28-release:1.25
	cygwin-1_7_27-release:1.25
	cygwin-1_7_26-release:1.25
	cygwin-1_7_25-release:1.25
	cygwin-1_7_24-release:1.25
	cygwin-1_7_23-release:1.25
	cygwin-1_7_22-release:1.25
	cygwin-1_7_21-release:1.25
	cygwin-1_7_20-release:1.25
	cygwin-1_7_19-release:1.25
	cygwin-64bit-postmerge:1.25
	cygwin-64bit-premerge-branch:1.24.0.2
	cygwin-64bit-premerge:1.24
	cygwin-1_7_18-release:1.24
	post-ptmalloc3:1.21.2.4
	pre-ptmalloc3:1.21.2.4
	cygwin-1_7_17-release:1.21
	cygwin-64bit-branch:1.21.0.2
	cygwin-1_7_16-release:1.21
	cygwin-1_7_15-release:1.20
	cygwin-1_7_14_2-release:1.20
	cygwin-1_7_14-release:1.20
	cygwin-1_7_12-release:1.20
	cygwin-1_7_11-release:1.20
	cygwin-1_7_10-release:1.20
	signal-rewrite:1.20.0.2
	pre-notty:1.19
	cygwin-1_7_9-release:1.17
	cv-post-1_7_9:1.17.0.2
	cygwin-1_7_8-release:1.17
	cygwin-1_7_7-release:1.17
	cygwin-1_7_5-release:1.17
	cygwin-1_7_4-release:1.17
	cygwin-1_7_3-release:1.17
	cygwin-1_7_2-release:1.17
	fifo_doover3:1.16.0.4
	cygwin-1_7_1-release:1.16
	prefifo:1.16
	cv-branch-2:1.16.0.2
	pre-ripout-set_console_state_for_spawn:1.15
	EOL_registry_mounts:1.13
	preoverlapped:1.13
	drop_9x_support_start:1.12
	cr-0x5f1:1.11.0.8
	cv-branch:1.11.0.6
	pre-ptymaster-archetype:1.11
	cr-0x3b58:1.11.0.4
	cr-0x5ef:1.11.0.2
	after-mmap-privanon-noreserve:1.11
	after-mmap-revamp:1.11
	before-mmap-revamp:1.11
	cgf-more-exit-sync:1.11
	post_wait_sig_exit:1.11
	pre_wait_sig_exit:1.11
	reparent-point:1.10
	noreparent:1.10.0.2
	cr-0x5e6:1.9.0.8
	cr-0x9e:1.9.0.6
	cr-0x9d:1.9.0.4
	cgf-deleteme:1.9.0.2
	pre-sigrewrite:1.9
	corinna-01:1.9
	cr-0x9c:1.8.0.6
	cr-0x9b:1.8.0.4
	cr-0x99:1.8
	Z-emcb-cygwin_daemon:1.8.0.2
	w32api-2_2:1.7
	mingw-runtime-2_4:1.7
	pre-cgf-merge:1.8
	cgf-dev-branch:1.7.0.8
	predaemon:1.4
	cygwin_daemon_merge_HEAD:1.4
	pregp02r1:1.4.0.34
	cygnus_cvs_20020108_pre:1.4
	Z-cygwin_daemon_merge-new_HEAD:1.5
	Z-cygwin_daemon_merge_HEAD:1.5
	cygwin_daemon:1.4.0.4;
locks; strict;
comment	@// @;


1.25
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2012.11.26.13.28.53;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2012.11.23.13.22.46;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2012.07.06.13.49.53;	author corinna;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2011.07.06.18.35.44;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.23.13.15.46;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.19.10.02.06;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2010.03.12.23.13.47;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.11.05.43.11;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.19.09.15.26;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.05.03.16.45;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.27.03.44.31;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.13.19.36.12;	author cgf;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.02.06.07.01;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.26.14.47.48;	author cgf;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.12.04.04.53;	author rbcollins;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.21.14.00.28;	author cgf;	state Exp;
branches;
next	;

1.21.2.1
date	2012.11.16.09.41.13;	author corinna;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2012.11.23.15.14.38;	author corinna;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2012.11.26.13.29.09;	author corinna;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	1.21.2.5;

1.21.2.5
date	2013.03.14.12.09.52;	author corinna;	state Exp;
branches;
next	;

1.7.8.1
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.13.14.34.10;	author rbcollins;	state Exp;
branches;
next	;


desc
@@


1.25
log
@	* Merge in cygwin-64bit-branch.
@
text
@/* sched.cc: scheduler interface for Cygwin

   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011, 2012,
   2013 Red Hat, Inc.

   Written by Robert Collins <rbtcollins@@hotmail.com>

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */

#include "winsup.h"
#include "miscfuncs.h"
#include "cygerrno.h"
#include "pinfo.h"
/* for getpid */
#include <unistd.h>
#include "registry.h"

/* Win32 priority to UNIX priority Mapping.

   For now, I'm just following the spec: any range of priorities is ok.
   There are probably many many issues with this...

   FIXME: We don't support pre-Windows 2000 so we should fix the priority
          computation.  Here's the description for the current code:

     We don't want process's going realtime. Well, they probably could, but
     the issues with avoiding the priority values 17-22 and 27-30 (not
     supported before win2k) make that inefficient.

     However to complicate things most unixes use lower is better priorities.

     So we map -14 to 15, and 15 to 1 via (16- ((n+16) >> 1)).  We then map 1
     to 15 to various process class and thread priority combinations.  Then we
     need to look at the threads process priority.  As win95, 98 and NT 4
     don't support opening threads cross-process (unless a thread HANDLE is
     passed around) for now, we'll just use the priority class.

     The code and logic are present to calculate the priority for thread, if a
     thread handle can be obtained.  Alternatively, if the symbols wouldn't be
     resolved until they are used we could support this.

   Lastly, because we can't assume that the pid we're given are Windows pids,
   we can't alter non-cygwin started programs.  */

extern "C"
{

/* max priority for policy */
int
sched_get_priority_max (int policy)
{
  if (policy < 1 || policy > 3)
    {
      set_errno (EINVAL);
      return -1;
    }
  return -14;
}

/* min priority for policy */
int
sched_get_priority_min (int policy)
{
  if (policy < 1 || policy > 3)
    {
      set_errno (EINVAL);
      return -1;
    }
  return 15;
}

/* Check a scheduler parameter struct for valid settings */
int
valid_sched_parameters (const struct sched_param *param)
{
  if (param->sched_priority < -14 || param->sched_priority > 15)
    {
      return 0;
    }
  return -1;

}

/* get sched params for process

   Note, I'm never returning EPERM,
   Always ESRCH. This is by design (If cygwin ever looks at paranoid security
   Walking the pid values is a known hole in some os's)
*/
int
sched_getparam (pid_t pid, struct sched_param *param)
{
  pid_t localpid;
  int winpri;
  if (!param || pid < 0)
    {
      set_errno (EINVAL);
      return -1;
    }

  localpid = pid ? pid : getpid ();

  DWORD Class;
  int ThreadPriority;
  HANDLE process;
  pinfo p (localpid);

  /* get the class */

  if (!p)
    {
      set_errno (ESRCH);
      return -1;
    }
  process = OpenProcess (PROCESS_QUERY_INFORMATION, FALSE, p->dwProcessId);
  if (!process)
    {
      set_errno (ESRCH);
      return -1;
    }
  Class = GetPriorityClass (process);
  CloseHandle (process);
  if (!Class)
    {
      set_errno (ESRCH);
      return -1;
    }
  ThreadPriority = THREAD_PRIORITY_NORMAL;

  /* calculate the unix priority. */

  switch (Class)
    {
    case IDLE_PRIORITY_CLASS:
      switch (ThreadPriority)
	{
	case THREAD_PRIORITY_IDLE:
	  winpri = 1;
	  break;
	case THREAD_PRIORITY_LOWEST:
	  winpri = 2;
	  break;
	case THREAD_PRIORITY_BELOW_NORMAL:
	  winpri = 3;
	  break;
	case THREAD_PRIORITY_NORMAL:
	  winpri = 4;
	  break;
	case THREAD_PRIORITY_ABOVE_NORMAL:
	  winpri = 5;
	  break;
	case THREAD_PRIORITY_HIGHEST:
	default:
	  winpri = 6;
	  break;
	}
      break;
    case HIGH_PRIORITY_CLASS:
      switch (ThreadPriority)
	{
	case THREAD_PRIORITY_IDLE:
	  winpri = 1;
	  break;
	case THREAD_PRIORITY_LOWEST:
	  winpri = 11;
	  break;
	case THREAD_PRIORITY_BELOW_NORMAL:
	  winpri = 12;
	  break;
	case THREAD_PRIORITY_NORMAL:
	  winpri = 13;
	  break;
	case THREAD_PRIORITY_ABOVE_NORMAL:
	  winpri = 14;
	  break;
	case THREAD_PRIORITY_HIGHEST:
	default:
	  winpri = 15;
	  break;
	}
      break;
    case NORMAL_PRIORITY_CLASS:
    default:
      switch (ThreadPriority)
	{
	case THREAD_PRIORITY_IDLE:
	  winpri = 1;
	  break;
	case THREAD_PRIORITY_LOWEST:
	  winpri = 7;
	  break;
	case THREAD_PRIORITY_BELOW_NORMAL:
	  winpri = 8;
	  break;
	case THREAD_PRIORITY_NORMAL:
	  winpri = 9;
	  break;
	case THREAD_PRIORITY_ABOVE_NORMAL:
	  winpri = 10;
	  break;
	case THREAD_PRIORITY_HIGHEST:
	default:
	  winpri = 11;
	  break;
	}
      break;
    }

  /* reverse out winpri = (16- ((unixpri+16) >> 1)) */
  /*
     winpri-16 = -  (unixpri +16 ) >> 1

     -(winpri-16) = unixpri +16 >> 1
     (-(winpri-16)) << 1 = unixpri+16
     ((-(winpri - 16)) << 1) - 16 = unixpri
   */

  param->sched_priority = ((-(winpri - 16)) << 1) - 16;

  return 0;
}

/* get the scheduler for pid

   All process's on WIN32 run with SCHED_FIFO.
   So we just give an answer.
   (WIN32 uses a multi queue FIFO).
*/
int
sched_getscheduler (pid_t pid)
{
  if (pid < 0)
    return ESRCH;
  else
    return SCHED_FIFO;
}

/* get the time quantum for pid */
int
sched_rr_get_interval (pid_t pid, struct timespec *interval)
{
  static const char quantable[2][2][3] =
    {{{12, 24, 36}, { 6, 12, 18}},
     {{36, 36, 36}, {18, 18, 18}}};
  /* FIXME: Clocktickinterval can be 15 ms for multi-processor system. */
  static const int clocktickinterval = 10;
  static const int quantapertick = 3;

  HWND forwin;
  DWORD forprocid;
  DWORD vfindex, slindex, qindex, prisep;
  long nsec;

  forwin = GetForegroundWindow ();
  if (!forwin)
    GetWindowThreadProcessId (forwin, &forprocid);
  else
    forprocid = 0;

  reg_key reg (HKEY_LOCAL_MACHINE, KEY_READ, L"SYSTEM", L"CurrentControlSet",
	       L"Control", L"PriorityControl", NULL);
  if (reg.error ())
    {
      set_errno (ESRCH);
      return -1;
    }
  prisep = reg.get_dword (L"Win32PrioritySeparation", 2);
  pinfo pi (pid ? pid : myself->pid);
  if (!pi)
    {
      set_errno (ESRCH);
      return -1;
    }

  if (pi->dwProcessId == forprocid)
    {
      qindex = prisep & 3;
      qindex = qindex == 3 ? 2 : qindex;
    }
  else
    qindex = 0;
  vfindex = ((prisep >> 2) & 3) % 3;
  if (vfindex == 0)
    vfindex = wincap.is_server () || (prisep & 3) == 0 ? 1 : 0;
  else
    vfindex -= 1;
  slindex = ((prisep >> 4) & 3) % 3;
  if (slindex == 0)
    slindex = wincap.is_server () ? 1 : 0;
  else
    slindex -= 1;

  nsec = quantable[vfindex][slindex][qindex] / quantapertick
    * clocktickinterval * 1000000;
  interval->tv_sec = nsec / 1000000000;
  interval->tv_nsec = nsec % 1000000000;

  return 0;
}

/* set the scheduling parameters */
int
sched_setparam (pid_t pid, const struct sched_param *param)
{
  pid_t localpid;
  int winpri;
  DWORD Class;
  HANDLE process;

  if (!param || pid < 0)
    {
      set_errno (EINVAL);
      return -1;
    }

  if (!valid_sched_parameters (param))
    {
      set_errno (EINVAL);
      return -1;
    }

  /*  winpri = (16- ((unixpri+16) >> 1)) */
  winpri = 16 - ((param->sched_priority + 16) >> 1);

  /* calculate our desired priority class and thread priority */

  if (winpri < 7)
    Class = IDLE_PRIORITY_CLASS;
  else if (winpri > 10)
    Class = HIGH_PRIORITY_CLASS;
  else
    Class = NORMAL_PRIORITY_CLASS;

  localpid = pid ? pid : getpid ();

  pinfo p (localpid);

  /* set the class */

  if (!p)
    {
      set_errno (ESRCH);
      return -1;
    }
  process =
    OpenProcess (PROCESS_SET_INFORMATION, FALSE, (DWORD) p->dwProcessId);
  if (!process)
    {
      set_errno (2);		//ESRCH);
      return -1;
    }
  if (!SetPriorityClass (process, Class))
    {
      CloseHandle (process);
      set_errno (EPERM);
      return -1;
    }
  CloseHandle (process);

  return 0;
}

/* we map -14 to 15, and 15 to 1 via (16- ((n+16) >> 1)). This lines up with
   the allowed values we return elsewhere in the sched* functions. We then
   map in groups of three to allowed thread priority's. The reason for dropping
   accuracy while still returning a wide range of values is to allow more
   flexible code in the future. */
int
sched_set_thread_priority (HANDLE thread, int priority)
{
  int real_pri;
  real_pri = 16 - ((priority + 16) >> 1);
  if (real_pri <1 || real_pri > 15)
    return EINVAL;

  if (real_pri < 4)
    real_pri = THREAD_PRIORITY_LOWEST;
  else if (real_pri < 7)
    real_pri = THREAD_PRIORITY_BELOW_NORMAL;
  else if (real_pri < 10)
    real_pri = THREAD_PRIORITY_NORMAL;
  else if (real_pri < 13)
    real_pri = THREAD_PRIORITY_ABOVE_NORMAL;
  else
    real_pri = THREAD_PRIORITY_HIGHEST;

  if (!SetThreadPriority (thread, real_pri))
    /* invalid handle, no access are the only expected errors. */
    return EPERM;
  return 0;
}

/* set the scheduler */
int
sched_setscheduler (pid_t pid, int policy,
		    const struct sched_param *param)
{
  /* on win32, you can't change the scheduler. Doh! */
  set_errno (ENOSYS);
  return -1;
}

/* yield the cpu */
int
sched_yield ()
{
  SwitchToThread ();
  return 0;
}
}
@


1.24
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d3 2
a4 2
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011, 2012
   Red Hat, Inc.
d23 1
d27 18
a44 17
   We don't want process's going realtime. Well, they probably could, but the issues
   with avoiding the priority values 17-22 and 27-30 (not supported before win2k)
   make that inefficient.
   However to complicate things most unixes use lower is better priorities.

   So we map -14 to 15, and 15 to 1 via (16- ((n+16) >> 1))
   we then map 1 to 15 to various process class and thread priority combinations

   Then we need to look at the threads vi process priority. As win95 98 and NT 4
   Don't support opening threads cross-process (unless a thread HANDLE is passed around)
   for now, we'll just use the priority class.

   The code and logic are present to calculate the priority for thread
   , if a thread handle can be obtained. Alternatively, if the symbols wouldn't be
   resolved until they are used
   we could support this on windows 2000 and ME now, and just fall back to the
   class only on pre win2000 machines.
d46 2
a47 3
   Lastly, because we can't assume that the pid we're given are Windows pids, we can't
   alter non-cygwin started programs.
*/
d134 1
a134 4
  /* calculate the unix priority.

     FIXME: windows 2000 supports ABOVE_NORMAL and BELOW_NORMAL class's
     So this logic just defaults those class factors to NORMAL in the calculations */
d242 1
a242 5
/* get the time quantum for pid

   Implemented only for NT systems, it fails and sets errno to ESRCH
   for non-NT systems.
*/
a311 1
  int ThreadPriority;
a337 64
  switch (Class)
    {
    case IDLE_PRIORITY_CLASS:
      switch (winpri)
	{
	case 1:
	  ThreadPriority = THREAD_PRIORITY_IDLE;
	  break;
	case 2:
	  ThreadPriority = THREAD_PRIORITY_LOWEST;
	  break;
	case 3:
	  ThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
	  break;
	case 4:
	  ThreadPriority = THREAD_PRIORITY_NORMAL;
	  break;
	case 5:
	  ThreadPriority = THREAD_PRIORITY_ABOVE_NORMAL;
	  break;
	case 6:
	  ThreadPriority = THREAD_PRIORITY_HIGHEST;
	  break;
	}
      break;
    case NORMAL_PRIORITY_CLASS:
      switch (winpri)
	{
	case 7:
	  ThreadPriority = THREAD_PRIORITY_LOWEST;
	  break;
	case 8:
	  ThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
	  break;
	case 9:
	  ThreadPriority = THREAD_PRIORITY_NORMAL;
	  break;
	case 10:
	  ThreadPriority = THREAD_PRIORITY_ABOVE_NORMAL;
	  break;
	case 11:
	  ThreadPriority = THREAD_PRIORITY_HIGHEST;
	  break;
	}
      break;
    case HIGH_PRIORITY_CLASS:
      switch (winpri)
	{
	case 12:
	  ThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
	  break;
	case 13:
	  ThreadPriority = THREAD_PRIORITY_NORMAL;
	  break;
	case 14:
	  ThreadPriority = THREAD_PRIORITY_ABOVE_NORMAL;
	  break;
	case 15:
	  ThreadPriority = THREAD_PRIORITY_HIGHEST;
	  break;
	}
      break;
    }

d346 1
a346 1
      set_errno (1);		//ESRCH);
d367 5
a371 5
/* we map -14 to 15, and 15 to 1 via (16- ((n+16) >> 1)). This lines up with the allowed
 * valueswe return elsewhere in the sched* functions. We then map in groups of three to
 * allowed thread priority's. The reason for dropping accuracy while still returning
 * a wide range of values is to allow more flexible code in the future.
 */
@


1.23
log
@	* fhandler_registry.cc: Drop Mingw.org considerations.
	* fhandler_serial.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* sched.cc: Ditto.
	* sec_helper.cc: Ditto.
@
text
@d3 2
a4 1
   Copyright 2001, 2003, 2006, 2008, 2011 Red Hat, Inc.
@


1.22
log
@ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.common: Revamp for new configury.  Add default compilation
	targets, include .E processing.  Add magic for allowing "CFLAGS" to
	control optimization options in "CXXFLAGS".
	* configure.cygwin: New include for Cygwin configure.in's.
	* acinclude.m4: Delete old definitions.  Implement AC_WINDOWS_HEADERS,
	AC_WINDOWS_LIBS, AC_CYGWIN_INCLUDES, target_builddir, winsup_srcdir.
	* aclocal.m4: Regenerate.
	* autogen.sh: New file.
	* ccwrap: New script.
	* c++wrap: New script.
	* config.guess: New script.
	* config.sub: New script.
	* configure: Regenerate.
	* configure.in: Eliminate LIB_AC_PROG_* calls in favor of standard.
	Delete ancient target test.
	* install-sh: New script.

cygserver/ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.in: Revamp for new configury.
	* configure.in: Revamp for new configury.
	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.

cygwin/ChangeLog:
2012-11-22  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* select.cc (select): Don't return -1 when we've timed out after
	looping.

2012-11-22  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* Makefile.in: Revamp for new configury.
	(datarootdir): Add variable setting.
	(winver_stamp): Accommodate changes to mkvers.sh setting.
	(libc.a): Fix race when libm.a might not have been built yet.
	* configure.in: Revamp for new configury.
	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.
	* mkvers.sh: Find include directives via CFLAGS and friends rather than
	assuming that w32api lives nearby.

utils/ChangeLog:
2012-11-12  Christopher Faylor  <me.cygwin2012@@cgf.cx>

	* aclocal.m4: Regenerate.
	* configure: Ditto.
	* autogen.sh: New script.
	* configure.in: Revamp for new configury.
	* Makefile.in: Revamp for new configury.  Rename ALL_* to just *.
	Always use "VERBOSE" setting.
	(MINGW_CXX): Don't include CFLAGS in definition.
	(all): Define target first, before everything else so that it is the
	default.
	(ps.exe): Don't add useless -lcygwin.
	(ldh.exe): For consistency, add to existing MINGW_LDFLAGS rather than
	redefining them.
	(cygcheck.exe): Always include -lz for MINGW_LDFLAGS.  Don't try to
	figure out where to find it.
	(dumper.exe): Simplify check.  Assume libraries are installed rather
	than trying to retrieve from source tree.
	(install): Just use /bin/mkdir to create directories.
	(Makefile): Regenerate when standard dependencies change.
	* dump_setup.cc: Always include zlib.h.  Remove accommodations for it
	possibly not existing.
	* parse_pe.cc: Add define which allows building with installed
	binutils package.
	* dumper.cc: Ditto.
@
text
@a20 4
#ifndef __MINGW64_VERSION_MAJOR
extern "C" HWND WINAPI GetForegroundWindow();
#endif

@


1.21
log
@	* fhandler_registry.cc (RegOpenUserClassesRoot): Only define when
	building against w32api headers.
	(RegOpenCurrentUser): Ditto.
	* fhandler_tty.cc (GetNamedPipeClientProcessId): Ditto.
	* ntdll.h (enum _PROCESSINFOCLASS): Add ProcessImageFileName.
	(RtlInitAnsiString): Declare.
	(RtlUnicodeStringToAnsiSize): Declare.
	* sched.cc (GetForegroundWindow): Ditto.
	* sec_helper.cc (SECURITY_NT_NON_UNIQUE): Define as
	SECURITY_NT_NON_UNIQUE_RID when building against w32api headers.
	(cygsid::get_sid): Use SECURITY_NT_NON_UNIQUE rather than
	SECURITY_NT_NON_UNIQUE_RID.
	(__sec_user): Use PISECURITY_DESCRIPTOR rather than PSECURITY_DESCRIPTOR
	to allow valid pointer arithmetic.
	(_recycler_sd): Ditto.
	(_everyone_sd): Ditto.
@
text
@a12 3
#ifdef HAVE_CONFIG_H
#endif

@


1.21.2.1
log
@	* include/cygwin/acl.h (struct __acl32): Drop.  Use struct acl or
	aclent_t throughout instead.
	* sec_acl.cc (aclcheck32): Mark currently unused variables as unused.
	(lacl32): Disable on x86_64.
	(acl): Alias to acl32 on x86_64.
	(facl): Alias to facl32 on x86_64.
	(aclcheck): Alias to aclcheck32 on x86_64.
	(aclsort): Alias to aclsort32 on x86_64.
	(acltomode): Alias to acltomode32 on x86_64.
	(aclfrommode): Alias to aclfrommode32 on x86_64.
	(acltopbits): Alias to acltopbits32 on x86_64.
	(aclfrompbits): Alias to aclfrompbits32 on x86_64.
	(acltotext): Alias to acltotext32 on x86_64.
	(aclfromtext): Alias to aclfromtext32 on x86_64.
	* resource.cc (getrlimit): Use correct cast to rlim_t rather than DWORD.
	* sched.cc (sched_setparam): Drop ThreadPriority and all code setting
	it.
@
text
@d3 1
a3 1
   Copyright 2001, 2003, 2006, 2008, 2011, 2012 Red Hat, Inc.
d324 1
d351 64
@


1.21.2.2
log
@Pull in changes from HEAD
@
text
@d13 3
@


1.21.2.3
log
@Pull in changes from HEAD
@
text
@d21 4
@


1.21.2.4
log
@Pull in changes from HEAD
@
text
@d3 1
a3 2
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011, 2012
   Red Hat, Inc.
@


1.21.2.5
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@d3 2
a4 2
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011, 2012,
   2013 Red Hat, Inc.
a22 1

d26 17
a42 2
   FIXME: We don't support pre-Windows 2000 so we should fix the priority
          computation.  Here's the description for the current code:
d44 3
a46 18
     We don't want process's going realtime. Well, they probably could, but
     the issues with avoiding the priority values 17-22 and 27-30 (not
     supported before win2k) make that inefficient.

     However to complicate things most unixes use lower is better priorities.

     So we map -14 to 15, and 15 to 1 via (16- ((n+16) >> 1)).  We then map 1
     to 15 to various process class and thread priority combinations.  Then we
     need to look at the threads process priority.  As win95, 98 and NT 4
     don't support opening threads cross-process (unless a thread HANDLE is
     passed around) for now, we'll just use the priority class.

     The code and logic are present to calculate the priority for thread, if a
     thread handle can be obtained.  Alternatively, if the symbols wouldn't be
     resolved until they are used we could support this.

   Lastly, because we can't assume that the pid we're given are Windows pids,
   we can't alter non-cygwin started programs.  */
d133 4
a136 1
  /* calculate the unix priority. */
d244 5
a248 1
/* get the time quantum for pid */
d352 1
a352 1
      set_errno (ESRCH);
d373 5
a377 5
/* we map -14 to 15, and 15 to 1 via (16- ((n+16) >> 1)). This lines up with
   the allowed values we return elsewhere in the sched* functions. We then
   map in groups of three to allowed thread priority's. The reason for dropping
   accuracy while still returning a wide range of values is to allow more
   flexible code in the future. */
@


1.20
log
@	* sched.c (sched_yield): Just call SwitchToThread because yield now
	potentially switches CPU.
@
text
@d24 1
d26 1
@


1.19
log
@	* registry.cc (reg_key::get_dword): Rename from get_int, use DWORD
	rather than int type.  Avoid compiler warning.
	(reg_key::set_dword): Rename from set_int, use DWORD rather than int
	type.  Change return type to NTSTATUS.
	(reg_key::get_string): Change return type to NTSTATUS.
	(reg_key::set_string): Ditto.
	* registry.h: Accommodate above changes.
	* environ.cc (regopt): Test return value of reg_key::get_string as
	NTSTATUS.
	* sched.cc (sched_rr_get_interval): Change local int vars to DWORD.
	Call reg_key::get_dword instead of reg_key::get_int.
	* shared.cc (init_installation_root): Test return value of
	reg_key::get_string as NTSTATUS.
	(shared_info::heap_slop_size): Call reg_key::get_dword rather than
	reg_key::get_int.
	(shared_info::heap_chunk_size): Ditto.
	* shared_info.h (CURR_SHARED_MAGIC): Update.
	(class shared_info): Change heap_chunk and heap_slop to DWORD  values.
@
text
@d486 1
a486 1
  yield ();
@


1.18
log
@	* Makefile.in (DLL_IMPORTS): Drop advapi32.dll.
	* autoload.cc: Enable autoloading advapi32 functions.
	* environ.cc (regopt): Use wide char arguments in reg_key functions.
	* fhandler_console.cc (beep): Ditto.  Use WCHAR throughout.
	* registry.cc (reg_key): Rewrite reg_key class to use native NT registry
	functions.  Use WCHAR string parameters throughout.  Use PCWSTR rather
	than const WCHAR.  Drop multibyte char functionality.  Drop unused
	methods.
	(get_registry_hive_path): Use RtlQueryRegistryValues to fetch path from
	registry.
	(load_registry_hive): Drop useless check for user hive being available.
	Load hive using NtLoadKey.
	* registry.h: Accommodate above changes.
	* sched.cc (sched_rr_get_interval): Use wide char arguments in reg_key
	functions.
	* shared.cc (init_installation_root): Ditto.
	(shared_info::init_obcaseinsensitive): Use RtlQueryRegistryValues to
	fetch obcaseinsensitive value.
	(shared_info::heap_slop_size): Use wide char arguments in reg_key
	functions.
	(shared_info::heap_chunk_size): Ditto.
	* syscalls.cc (gethostid): Ditto.
	* winsup.h (__WIDE): Define.
	(_WIDE): Define.
	* libc/minires-os-if.c (get_registry_dns_items): Don't fetch values
	from registry.  Just extract them from given UNICODE_STRING parameter.
	(get_registry_dns): Fetch all registry values at once using
	RtlQueryRegistryValues.
@
text
@d265 1
a265 1
  int vfindex, slindex, qindex, prisep;
d281 1
a281 1
  prisep = reg.get_int (L"Win32PrioritySeparation", 2);
@


1.17
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2006, 2007 Red Hat, Inc.
d274 2
a275 2
  reg_key reg (HKEY_LOCAL_MACHINE, KEY_READ, "SYSTEM", "CurrentControlSet",
	       "Control", "PriorityControl", NULL);
d281 1
a281 1
  prisep = reg.get_int ("Win32PrioritySeparation", 2);
@


1.16
log
@* localtime.cc (increment_overflow): Mark as non-inline to prevent compiler
from complaining about the very thing we're trying to test.
* ntea.cc (read_ea): Reorganize to avoid a new compiler warning/error.
* sched.cc (sched_rr_get_interval): Ditto.
* select.cc (peek_serial): Ditto.
* libc/rexec.cc (ruserpass): Ditto.
* posix_ipc.cc (ipc_names): Make static to avoid a compiler warning
(and it's the right thing to do anyway).
@
text
@d486 1
a486 1
  low_priority_sleep (0);
@


1.15
log
@Remove unneeded header files from source files throughout.
@
text
@d298 1
a298 1
    vfindex = wincap.is_server () || prisep & 3 == 0 ? 1 : 0;
@


1.14
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a13 1
# include "config.h"
a17 1
#include <limits.h>
a18 4
#include <assert.h>
#include <stdlib.h>
#include <syslog.h>
#include <sched.h>
@


1.13
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@d18 1
@


1.12
log
@	* fhandler_proc.cc: Drop superfluous definition of _WIN32_WINNT.
	* miscfuncs.cc: Ditto.
	* sched.cc: Ditto.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2006  Red Hat, Inc.
a272 6
  if (!wincap.is_winnt ())
    {
      set_errno (ESRCH);
      return -1;
    }

@


1.11
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d3 1
a3 1
   Copyright 2001, 2002  Red Hat, Inc.
a16 1
#define _WIN32_WINNT 0x300
@


1.10
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d496 1
a496 1
sched_yield (void)
@


1.9
log
@* Makefile.in: Add libusr32.a to DLL_IMPORTS.
* wincap.h (wincaps::is_server): New flag.
(wincapc::version): Change type to OSVERSIONINFOEX.
(wincapc::is_server): New function.
* wincap.cc (wincap_unknown::is_server): New initializer.
(wincap_95): Ditto.
(wincap_95osr2): Ditto.
(wincap_98): Ditto.
(wincap_me): Ditto.
(wincap_nt3): Ditto.
(wincap_nt4): Ditto.
(wincap_nt4sp4): Ditto.
(wincap_2000): Ditto.
(wincap_xp): Ditto.
(wincapc::init): Adapt to OSVERSIONINFOEX.  Add detection of NT server systems.
* sched.cc: Include windows.h and registry.h.
(sched_rr_get_interval): Re-implement for NT systems.
@
text
@d287 1
a287 1
               "Control", "PriorityControl", NULL);
@


1.8
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d17 1
d28 3
d256 2
a257 9
   We can't return -11, errno ENOSYS, because that implies that
   sched_get_priority_max & min are also not supported (according to the spec)
   so some spec-driven autoconf tests will likely assume they aren't present either

   returning ESRCH might confuse some applications (if they assumed that when
   rr_get_interval is called on pid 0 it always works).

   If someone knows the time quanta for the various win32 platforms, then a
   simple check for the os we're running on will finish this function
d262 63
a324 2
  set_errno (ESRCH);
  return -1;
@


1.7
log
@* miscfuncs.cc (low_priority_sleep): New function.  Use throughout where code
is supposed to be giving up time slice.
* fhandler_console.cc (fhandler_console::read): Switch button 2/3 output escape
sequences to be consistent with xterm.
@
text
@a18 1
#include <errno.h>
@


1.7.8.1
log
@merge from trunk
@
text
@d19 1
@


1.6
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d441 1
a441 1
  Sleep (0);
@


1.5
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d3 1
a3 1
   Copyright 2001  Red Hat, Inc.
d84 1
a84 1
valid_sched_parameters(const struct sched_param *param)
d286 1
a286 1
  if (!valid_sched_parameters(param))
d403 1
a403 1
sched_set_thread_priority(HANDLE thread, int priority)
d421 1
a421 1
  if (!SetThreadPriority(thread, real_pri))
@


1.4
log
@* mmap.cc: Clean up *ResourceLock calls throughout.
* thread.cc (pthread_cond::TimedWait): Check for WAIT_TIMEOUT as well as
WAIT_ABANDONED.
(__pthread_cond_timedwait): Calculate a relative wait from the abstime
parameter.
@
text
@a24 1
#include "sigproc.h"
@


1.4.4.1
log
@Merged changes from HEAD
@
text
@d25 1
@


1.3
log
@forced commit
@
text
@a29 1

d33 2
a34 2
  
   We don't want process's going realtime. Well, they probably could, but the issues 
d36 1
a36 1
   make that inefficient. 
d38 2
a39 2
  
   So we map -14 to 15, and 15 to 1 via (16- ((n+16) >> 1)) 
d41 2
a42 2
  
   Then we need to look at the threads vi process priority. As win95 98 and NT 4 
d44 2
a45 2
   for now, we'll just use the priority class. 
  
d47 1
a47 1
   , if a thread handle can be obtained. Alternatively, if the symbols wouldn't be 
d49 1
a49 1
   we could support this on windows 2000 and ME now, and just fall back to the 
d51 1
a51 1
  
d53 1
a53 1
   alter non-cygwin started programs. 
d97 1
a97 1
   Note, I'm never returning EPERM, 
d99 1
a99 1
   Walking the pid values is a known hole in some os's) 
d224 1
a224 1
  /*  
d240 1
a240 1
   So we just give an answer. 
d257 5
a261 5
  
   returning ESRCH might confuse some applications (if they assumed that when 
   rr_get_interval is called on pid 0 it always works). 
  
   If someone knows the time quanta for the various win32 platforms, then a 
d410 2
a411 2
  
  if (real_pri < 4) 
@


1.2
log
@	* configure.in: Remove PTH_ALLOW.
	* cygwin.din: Remove @@PTH_ALLOW@@ prefixes to pthread functions.
	Add new pthread exports.
	* pthread.cc: New wrapper functions for the above new exports.
	* sched.cc (valid_sched_parameters): New function.
	(sched_setparam): Use it.
	(sched_set_thread_priority): New function. Used by pthread_sched*.
	* thread.cc (pthread_key_destructor::InsertAfter): New function.
	(pthread_key_destructor::UnlinkNext): New function.
	(pthread_key_destructor::Next): New function.
	(pthread_key_destructor_list::Insert): New function.
	(pthread_key_destructor_list::Remove): New function.
	(pthread_key_destructor_list::Pop): New function.
	(pthread_key_destructor::pthread_key_destructor): New function.
	(pthread_key_destructor_list::IterateNull): New function.
	(MTinterface::Init): Initialise new member.
	(pthread::pthread): Initialise new members.
	(pthread::create): Copy new attributes. Set the new thread priority.
	(pthread_attr::pthread_attr): Initialise new members.
	(pthread_key::pthread_key): Setup destructor function.
	(pthread_key::~pthread_key): Remove destructor function.
	(pthread_mutexattr::pthread_mutexattr): New function.
	(pthread_mutexattr::~pthread_mutexattr): New function.
	(__pthread_once): New function.
	(__pthread_cleanup): New function.
	(__pthread_cancel): New function.
	(__pthread_setcancelstate): New function.
	(__pthread_setcanceltype): New function.
	(__pthread_testcancel): New function.
	(__pthread_attr_getinheritsched): New function.
	(__pthread_attr_getschedparam): New function.
	(__pthread_attr_getschedpolicy): New function.
	(__pthread_attr_getscope): New function.
	(__pthread_attr_setinheritsched): New function.
	(__pthread_attr_setschedparam): New function.
	(__pthread_attr_setschedpolicy): New function.
	(__pthread_attr_setscope): New function.
	(__pthread_exit): Call any key destructors on thread exit.
	(__pthread_join): Use the embedded attr values.
	(__pthread_detach): Use the embedded attr values.
	(__pthread_getconcurrency): New function.
	(__pthread_getschedparam): New function.
	(__pthread_key_create): Pass the destructor on object creation.
	(__pthread_key_delete): Correct incorrect prototype.
	(__pthread_setconcurrency): New function.
	(__pthread_setschedparam): New function.
	(__pthread_cond_timedwait): Support static mutex initialisers.
	(__pthread_cond_wait): Ditto.
	(__pthread_mutex_getprioceiling): New function.
	(__pthread_mutex_lock): Support static mutex initialisers.
	(__pthread_mutex_trylock): Ditto.
	(__pthread_mutex_unlock): Ditto.
	(__pthread_mutex_destroy): Ditto.
	(__pthread_mutex_setprioceiling): New function.
	(__pthread_mutexattr_getprotocol): New function.
	(__pthread_mutexattr_getpshared): New function.
	(__pthread_mutexattr_gettype): New function.
	(__pthread_mutexattr_init): New function.
	(__pthread_mutexattr_destroy): New function.
	(__pthread_mutexattr_setprotocol): New function.
	(__pthread_mutexattr_setprioceiling): New function.
	(__pthread_mutexattr_getprioceiling): New function.
	(__pthread_mutexattr_setpshared): New function.
	(__pthread_mutexattr_settype): New function.
	Remove stubs for non MT_SAFE compilation.
	* thread.h: Remove duplicate #defines.
	Add prototypes for new functions in thread.cc.
	(pthread_key_destructor): New class.
	(pthread_key_destructor_list): New class.
	(pthread_attr): Add new members.
	(pthread): Remove members that are duplicated in the pthread_attr class.
	(pthread_mutex_attr): Add new members.
	(pthread_once): New class.
	* include/pthread.h: Add prototypes for new functions exported from cygwin1.dll.
	Remove typedefs.
	* include/sched.h: Add prototypes for new functions in sched.cc.
	* include/cygwin/types.h: Add typedefs from pthread.h
@
text
@@


1.1
log
@Add missing files.
@
text
@d84 12
d288 1
a288 1
  if (param->sched_priority < -14 || param->sched_priority > 15)
d396 30
@

