head	1.70;
access;
symbols
	cygwin-1_7_35-release:1.70
	cygwin-1_7_34-release:1.70
	cygwin-1_7_33-release:1.69.2.1
	cygwin-1_7_32-release:1.69.2.1
	cygwin-1_7_31-release:1.69.2.1
	cygwin-1_7_30-release:1.69.2.1
	cygwin-1_7_29-release:1.69
	cygwin-1_7_29-release-branchpoint:1.69.0.2
	cygwin-pre-user-db:1.69
	cygwin-1_7_28-release:1.69
	cygwin-1_7_27-release:1.69
	cygwin-1_7_26-release:1.69
	cygwin-1_7_25-release:1.69
	cygwin-1_7_24-release:1.69
	cygwin-1_7_23-release:1.69
	cygwin-1_7_22-release:1.69
	cygwin-1_7_21-release:1.69
	cygwin-1_7_20-release:1.69
	cygwin-1_7_19-release:1.69
	cygwin-64bit-postmerge:1.68
	cygwin-64bit-premerge-branch:1.67.0.2
	cygwin-64bit-premerge:1.67
	cygwin-1_7_18-release:1.67
	post-ptmalloc3:1.62.2.6
	pre-ptmalloc3:1.62.2.6
	cygwin-1_7_17-release:1.65
	cygwin-64bit-branch:1.62.0.2
	cygwin-1_7_16-release:1.62
	cygwin-1_7_15-release:1.62
	cygwin-1_7_14_2-release:1.62
	cygwin-1_7_14-release:1.62
	cygwin-1_7_12-release:1.62
	cygwin-1_7_11-release:1.61
	cygwin-1_7_10-release:1.61
	signal-rewrite:1.60.0.2
	pre-notty:1.59
	cygwin-1_7_9-release:1.57
	cv-post-1_7_9:1.57.0.2
	cygwin-1_7_8-release:1.57
	cygwin-1_7_7-release:1.55
	cygwin-1_7_5-release:1.55
	cygwin-1_7_4-release:1.55
	cygwin-1_7_3-release:1.55
	cygwin-1_7_2-release:1.55
	fifo_doover3:1.55.0.2
	cygwin-1_7_1-release:1.55
	prefifo:1.54
	cv-branch-2:1.54.0.2
	pre-ripout-set_console_state_for_spawn:1.49
	EOL_registry_mounts:1.48
	preoverlapped:1.48
	drop_9x_support_start:1.46
	cr-0x5f1:1.46.0.2
	cv-branch:1.44.0.2
	pre-ptymaster-archetype:1.44
	cr-0x3b58:1.42.0.4
	cr-0x5ef:1.42.0.2
	after-mmap-privanon-noreserve:1.39
	after-mmap-revamp:1.39
	before-mmap-revamp:1.39
	cgf-more-exit-sync:1.39
	post_wait_sig_exit:1.34
	pre_wait_sig_exit:1.34
	reparent-point:1.33
	noreparent:1.33.0.2
	cr-0x5e6:1.31.0.2
	cr-0x9e:1.29.0.6
	cr-0x9d:1.29.0.4
	cgf-deleteme:1.29.0.2
	pre-sigrewrite:1.28
	corinna-01:1.28
	cr-0x9c:1.27.0.6
	cr-0x9b:1.27.0.4
	cr-0x99:1.27
	Z-emcb-cygwin_daemon:1.27.0.2
	w32api-2_2:1.25
	mingw-runtime-2_4:1.25
	pre-cgf-merge:1.27
	cgf-dev-branch:1.24.0.6
	predaemon:1.20
	cygwin_daemon_merge_HEAD:1.20
	pregp02r1:1.19.0.2
	cygnus_cvs_20020108_pre:1.17
	Z-cygwin_daemon_merge-new_HEAD:1.22
	Z-cygwin_daemon_merge_HEAD:1.22
	cygwin_daemon:1.14.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.70
date	2014.05.20.10.25.32;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2013.03.31.12.37.45;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2012.10.16.09.52.26;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2012.10.15.14.58.39;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2012.10.13.12.34.18;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2012.03.08.09.36.11;	author corinna;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.31.12.37.52;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2011.06.06.05.02.10;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2011.03.29.10.42.10;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2011.01.12.09.16.51;	author corinna;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2011.01.11.14.50.45;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2009.02.09.18.28.52;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2008.11.21.13.46.17;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2008.11.07.18.32.41;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2008.10.09.12.41.52;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2008.08.09.11.09.02;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.22.07.16.19;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.21.09.11.27;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.18.12.56.37;	author corinna;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2006.07.17.19.30.30;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2006.03.24.14.52.08;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.22.05.57.54;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.14.15.54.33;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.07.18.11.10;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.30.10.54.45;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.29.16.57.09;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.28.19.33.18;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.27.15.33.02;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.26.14.55.40;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2005.01.12.22.40.45;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.19.13.13.48;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.15.14.56.05;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.09.20.39.19;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.03.16.35.52;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.26.06.42.40;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.14.04.01.32;	author cgf;	state Exp;
branches
	1.24.4.1
	1.24.6.1;
next	1.23;

1.23
date	2002.11.07.14.16.27;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.25.17.47.46;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.22.18.39.22;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.09.05.10.14.15;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.18.03.34.05;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.03.03.56.34;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.28.09.59.54;	author duda;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.05.16.10.06;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.24.02.49.44;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.69.2.1
date	2014.05.20.10.25.40;	author corinna;	state Exp;
branches;
next	;

1.62.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.62.2.3;

1.62.2.3
date	2012.11.05.17.20.20;	author corinna;	state Exp;
branches;
next	1.62.2.4;

1.62.2.4
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.62.2.5;

1.62.2.5
date	2013.02.12.11.24.35;	author corinna;	state Exp;
branches;
next	1.62.2.6;

1.62.2.6
date	2013.02.20.20.15.56;	author yselkowitz;	state Exp;
branches;
next	1.62.2.7;

1.62.2.7
date	2013.03.01.16.32.33;	author corinna;	state Exp;
branches;
next	1.62.2.8;

1.62.2.8
date	2013.03.14.12.09.51;	author corinna;	state Exp;
branches;
next	;

1.57.2.1
date	2011.03.13.12.05.58;	author corinna;	state Exp;
branches;
next	;

1.46.2.1
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	;

1.44.2.1
date	2006.07.18.10.33.54;	author corinna;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2006.07.18.12.56.39;	author corinna;	state Exp;
branches;
next	;

1.24.4.1
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.24.4.2;

1.24.4.2
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	;

1.24.6.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.24.6.2;

1.24.6.2
date	2003.01.26.06.43.32;	author cgf;	state Exp;
branches;
next	1.24.6.3;

1.24.6.3
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.24.6.4;

1.24.6.4
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.24.6.5;

1.24.6.5
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.14.4.1
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2002.02.28.12.53.24;	author rbcollins;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2002.06.13.14.34.05;	author rbcollins;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.70
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Fix floppy
	drive handling broken with 1.7.19.
@
text
@/* fhandler_floppy.cc.  See fhandler.h for a description of the
   fhandler classes.

   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2011, 2012, 2013, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <alloca.h>
#include <unistd.h>
#include <sys/param.h>
#include <winioctl.h>
#include <cygwin/rdevio.h>
#include <cygwin/hdreg.h>
#include <cygwin/fs.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "ntdll.h"

#define IS_EOM(err)	((err) == ERROR_INVALID_PARAMETER \
			 || (err) == ERROR_SEEK \
			 || (err) == ERROR_SECTOR_NOT_FOUND)

#define bytes_per_sector devbufalign

/**********************************************************************/
/* fhandler_dev_floppy */

fhandler_dev_floppy::fhandler_dev_floppy ()
  : fhandler_dev_raw (), status ()
{
}

int
fhandler_dev_floppy::get_drive_info (struct hd_geometry *geo)
{
  char dbuf[256];
  char pbuf[256];

  DISK_GEOMETRY_EX *dix = NULL;
  DISK_GEOMETRY *di = NULL;
  PARTITION_INFORMATION_EX *pix = NULL;
  PARTITION_INFORMATION *pi = NULL;
  DWORD bytes_read = 0;

  /* Always try using the new EX ioctls first (>= XP).  If not available,
     fall back to trying the old non-EX ioctls.
     Unfortunately the EX ioctls are not implemented in the floppy driver. */
  if (get_major () != DEV_FLOPPY_MAJOR)
    {
      if (!DeviceIoControl (get_handle (),
			    IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, NULL, 0,
			    dbuf, 256, &bytes_read, NULL))
	__seterrno ();
      else
	{
	  dix = (DISK_GEOMETRY_EX *) dbuf;
	  di = &dix->Geometry;
	}
    }
  if (!di)
    {
      if (!DeviceIoControl (get_handle (),
			    IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
			    dbuf, 256, &bytes_read, NULL))
	{
	  __seterrno ();
	  return -1;
	}
      di = (DISK_GEOMETRY *) dbuf;
    }
  if (dix) /* Don't try IOCTL_DISK_GET_PARTITION_INFO_EX if
	      IOCTL_DISK_GET_DRIVE_GEOMETRY_EX didn't work. 
	      Probably a floppy.*/
    {
      if (!DeviceIoControl (get_handle (),
			    IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0,
			    pbuf, 256, &bytes_read, NULL))
	__seterrno ();
      else
	pix = (PARTITION_INFORMATION_EX *) pbuf;
    }
  if (!pix && get_major () != DEV_FLOPPY_MAJOR)
    {
      /* It's unlikely that this code path will be used at all.  Either the
	 _EX call already worked, or it's a floppy.  But it doesn't hurt to
	 keep the code in. */
      if (!DeviceIoControl (get_handle (),
			    IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
			    pbuf, 256, &bytes_read, NULL))
	__seterrno ();
      else
	pi = (PARTITION_INFORMATION *) pbuf;
    }
  debug_printf ("disk geometry: (%D cyl)*(%u trk)*(%u sec)*(%u bps)",
		 di->Cylinders.QuadPart,
		 di->TracksPerCylinder,
		 di->SectorsPerTrack,
		 di->BytesPerSector);
  bytes_per_sector = di->BytesPerSector;
  if (pix)
    {
      debug_printf ("partition info: offset %D  length %D",
		    pix->StartingOffset.QuadPart,
		    pix->PartitionLength.QuadPart);
      drive_size = pix->PartitionLength.QuadPart;
    }
  else if (pi)
    {
      debug_printf ("partition info: offset %D  length %D",
		    pi->StartingOffset.QuadPart,
		    pi->PartitionLength.QuadPart);
      drive_size = pi->PartitionLength.QuadPart;
    }
  else	/* Floppy drive. */
    drive_size = di->Cylinders.QuadPart * di->TracksPerCylinder
		 * di->SectorsPerTrack * di->BytesPerSector;
  if (geo)
    {
      geo->heads = di->TracksPerCylinder;
      geo->sectors = di->SectorsPerTrack;
      geo->cylinders = di->Cylinders.LowPart;
      if (pix)
	geo->start = pix->StartingOffset.QuadPart >> 9ULL;
      else if (pi)
	geo->start = pi->StartingOffset.QuadPart >> 9ULL;
      else
	geo->start = 0;
    }
  debug_printf ("drive size: %D", drive_size);

  return 0;
}

/* Wrapper functions for ReadFile and WriteFile to simplify error handling. */
BOOL
fhandler_dev_floppy::read_file (void *buf, DWORD to_read, DWORD *read, int *err)
{
  BOOL ret;

  *err = 0;
  if (!(ret = ReadFile (get_handle (), buf, to_read, read, 0)))
    *err = GetLastError ();
  syscall_printf ("%d (err %d) = ReadFile (%p, %p, to_read %u, read %u, 0)",
		  ret, *err, get_handle (), buf, to_read, *read);
  return ret;
}

/* See comment in write_file below. */
BOOL
fhandler_dev_floppy::lock_partition (DWORD to_write)
{
  DWORD bytes_read;

  /* The simple case.  We have only a single partition open anyway.
     Try to lock the partition so that a subsequent write succeeds.
     If there's some file handle open on one of the affected partitions,
     this fails, but that's how it works on Vista and later... */
  if (get_minor () % 16 != 0)
    {
      if (!DeviceIoControl (get_handle (), FSCTL_LOCK_VOLUME,
			   NULL, 0, NULL, 0, &bytes_read, NULL))
	{
	  debug_printf ("DeviceIoControl (FSCTL_LOCK_VOLUME) failed, %E");
	  return FALSE;
	}
      return TRUE;
    }

  /* The tricky case.  We're writing to the entire disk.  What this code
     basically does is to find out if the current write operation affects
     one or more partitions on the disk.  If so, it tries to lock all these
     partitions and stores the handles for a subsequent close(). */
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  FILE_POSITION_INFORMATION fpi;
  /* Allocate space for 4 times the maximum partition count we can handle.
     The reason is that for *every* single logical drive in an extended
     partition on an MBR drive, 3 filler entries with partition number set
     to 0 are added into the partition table returned by
     IOCTL_DISK_GET_DRIVE_LAYOUT_EX.  The first of them reproduces the data
     of the next partition entry, if any, except for the partiton number.
     Then two entries with everything set to 0 follow.  Well, the
     documentation states that for MBR drives the number of partition entries
     in the PARTITION_INFORMATION_EX array is always a multiple of 4, but,
     nevertheless, how crappy is that layout? */
  const DWORD size = sizeof (DRIVE_LAYOUT_INFORMATION_EX)
		     + 4 * MAX_PARTITIONS * sizeof (PARTITION_INFORMATION_EX);
  PDRIVE_LAYOUT_INFORMATION_EX pdlix = (PDRIVE_LAYOUT_INFORMATION_EX)
				       alloca (size);
  BOOL found = FALSE;

  /* Fetch current file pointer position on disk. */
  status = NtQueryInformationFile (get_handle (), &io, &fpi, sizeof fpi,
				   FilePositionInformation);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtQueryInformationFile(FilePositionInformation): %y",
		    status);
      return FALSE;
    }
  /* Fetch drive layout to get start and end positions of partitions on disk. */
  if (!DeviceIoControl (get_handle (), IOCTL_DISK_GET_DRIVE_LAYOUT_EX, NULL, 0,
			pdlix, size, &bytes_read, NULL))
    {
      debug_printf ("DeviceIoControl(IOCTL_DISK_GET_DRIVE_LAYOUT_EX): %E");
      return FALSE;
    }
  /* Scan through partition info to find the partition(s) into which we're
     currently trying to write. */
  PARTITION_INFORMATION_EX *ppie = pdlix->PartitionEntry;
  for (DWORD i = 0; i < pdlix->PartitionCount; ++i, ++ppie)
    {
      /* A partition number of 0 denotes an extended partition or one of the
	 aforementioned filler entries.  Just skip. */
      if (ppie->PartitionNumber == 0)
	continue;
      /* Check if our writing range affects this partition. */
      if (fpi.CurrentByteOffset.QuadPart   < ppie->StartingOffset.QuadPart
					     + ppie->PartitionLength.QuadPart
	  && ppie->StartingOffset.QuadPart < fpi.CurrentByteOffset.QuadPart
					     + to_write)
	{
	  /* Yes.  Now check if we can handle it.  We can only handle
	     up to MAX_PARTITIONS partitions.  The partition numbering is
	     one-based, so we decrement the partition number by 1 when using
	     as index into the partition array. */
	  DWORD &part_no = ppie->PartitionNumber;
	  if (part_no >= MAX_PARTITIONS)
	    return FALSE;
	  found = TRUE;
	  debug_printf ("%u %D->%D : %D->%D", part_no,
			ppie->StartingOffset.QuadPart,
			ppie->StartingOffset.QuadPart
			+ ppie->PartitionLength.QuadPart,
			fpi.CurrentByteOffset.QuadPart,
			fpi.CurrentByteOffset.QuadPart + to_write);
	  /* Do we already have partitions?  If not, create it. */
	  if (!partitions)
	    {
	      partitions = (part_t *) ccalloc_abort (HEAP_FHANDLER, 1,
						     sizeof (part_t));
	      partitions->refcnt = 1;
	    }
	  /* Next, check if the partition is already open.  If so, skip it. */
	  if (partitions->hdl[part_no - 1])
	    continue;
	  /* Now open the partition and lock it. */
	  WCHAR part[MAX_PATH], *p;
	  NTSTATUS status;
	  UNICODE_STRING upart;
	  OBJECT_ATTRIBUTES attr;
	  IO_STATUS_BLOCK io;

	  sys_mbstowcs (part, MAX_PATH, get_win32_name ());
	  p = wcschr (part, L'\0') - 1;
	  __small_swprintf (p, L"%d", part_no);
	  RtlInitUnicodeString (&upart, part);
	  InitializeObjectAttributes (&attr, &upart,
				      OBJ_CASE_INSENSITIVE
				      | ((get_flags () & O_CLOEXEC)
					 ? 0 : OBJ_INHERIT),
				      NULL, NULL);
	  status = NtOpenFile (&partitions->hdl[part_no - 1],
			       GENERIC_READ | GENERIC_WRITE, &attr,
			       &io, FILE_SHARE_READ | FILE_SHARE_WRITE, 0);
	  if (!NT_SUCCESS (status))
	    {
	      debug_printf ("NtCreateFile(%W): %y", part, status);
	      return FALSE;
	    }
	  if (!DeviceIoControl (partitions->hdl[part_no - 1], FSCTL_LOCK_VOLUME,
				NULL, 0, NULL, 0, &bytes_read, NULL))
	    {
	      debug_printf ("DeviceIoControl (%W, FSCTL_LOCK_VOLUME) "
			    "failed, %E", part);
	      return FALSE;
	    }
	}
    }
  /* If we didn't find a single matching partition, the "Access denied"
     had another reason, so return FALSE in that case. */
  return found;
}

BOOL
fhandler_dev_floppy::write_file (const void *buf, DWORD to_write,
				 DWORD *written, int *err)
{
  BOOL ret;

  *err = 0;
  if (!(ret = WriteFile (get_handle (), buf, to_write, written, 0)))
    *err = GetLastError ();
  /* When writing to a disk or partition on Vista, an "Access denied" error
     is potentially a result of the raw disk write restriction.  See
     http://support.microsoft.com/kb/942448 for details.  What we have to
     do here is to lock the partition and retry.  The previous solution
     locked one or all partitions immediately in open.  Which is overly
     wasteful, given that the user might only want to change, say, the boot
     sector. */
  if (*err == ERROR_ACCESS_DENIED
      && wincap.has_restricted_raw_disk_access ()
      && get_major () != DEV_FLOPPY_MAJOR
      && get_major () != DEV_CDROM_MAJOR
      && (get_flags () & O_ACCMODE) != O_RDONLY
      && lock_partition (to_write))
    {
      *err = 0;
      if (!(ret = WriteFile (get_handle (), buf, to_write, written, 0)))
	*err = GetLastError ();
    }
  syscall_printf ("%d (err %d) = WriteFile (%p, %p, write %u, written %u, 0)",
		  ret, *err, get_handle (), buf, to_write, *written);
  return ret;
}

int
fhandler_dev_floppy::open (int flags, mode_t)
{
  int ret = fhandler_dev_raw::open (flags);

  if (ret)
    {
      DWORD bytes_read;

      if (get_drive_info (NULL))
	{
	  close ();
	  return 0;
	}
      if (!(flags & O_DIRECT))
	{
	  /* Create sector-aligned buffer.  As default buffer size, we're using
	     some big, sector-aligned value.  Since direct blockdev IO is
	     usually non-buffered and non-cached, the performance without
	     buffering is worse than access to a file system on same device.
	     Whoever uses O_DIRECT has my condolences. */
	  devbufsiz = MAX (16 * bytes_per_sector, 65536);
	  devbufalloc = new char [devbufsiz + devbufalign];
	  devbuf = (char *) roundup2 ((uintptr_t) devbufalloc,
				      (uintptr_t) devbufalign);
	}

      /* If we're not trying to access a floppy disk, make sure we're actually
         allowed to read *all* of the device or volume.  This is actually
	 documented in the MSDN CreateFile man page. */
      if (get_major () != DEV_FLOPPY_MAJOR
	  && !DeviceIoControl (get_handle (), FSCTL_ALLOW_EXTENDED_DASD_IO,
			       NULL, 0, NULL, 0, &bytes_read, NULL))
	debug_printf ("DeviceIoControl (FSCTL_ALLOW_EXTENDED_DASD_IO) "
		      "failed, %E");
    }

  return ret;
}

int
fhandler_dev_floppy::close ()
{
  int ret = fhandler_dev_raw::close ();

  if (partitions && InterlockedDecrement (&partitions->refcnt) == 0)
    {
      for (int i = 0; i < MAX_PARTITIONS; ++i)
	if (partitions->hdl[i])
	  NtClose (partitions->hdl[i]);
      cfree (partitions);
    }
  return ret;
}

int
fhandler_dev_floppy::dup (fhandler_base *child, int flags)
{
  int ret = fhandler_dev_raw::dup (child, flags);

  if (!ret && partitions)
    InterlockedIncrement (&partitions->refcnt);
  return ret;
}

inline off_t
fhandler_dev_floppy::get_current_position ()
{
  LARGE_INTEGER off = { QuadPart: 0LL };
  off.LowPart = SetFilePointer (get_handle (), 0, &off.HighPart, FILE_CURRENT);
  return off.QuadPart;
}

void __reg3
fhandler_dev_floppy::raw_read (void *ptr, size_t& ulen)
{
  DWORD bytes_read = 0;
  DWORD read2;
  DWORD bytes_to_read;
  int ret;
  size_t len = ulen;
  char *tgt;
  char *p = (char *) ptr;

  /* Checking a previous end of media */
  if (eom_detected () && !lastblk_to_read ())
    {
      set_errno (ENOSPC);
      goto err;
    }

  if (devbuf)
    {
      while (len > 0)
	{
	  if (devbufstart < devbufend)
	    {
	      bytes_to_read = MIN (len, devbufend - devbufstart);
	      debug_printf ("read %u bytes from buffer (rest %u)",
			    bytes_to_read,
			    devbufend - devbufstart - bytes_to_read);
	      memcpy (p, devbuf + devbufstart, bytes_to_read);
	      len -= bytes_to_read;
	      p += bytes_to_read;
	      bytes_read += bytes_to_read;
	      devbufstart += bytes_to_read;

	      if (lastblk_to_read ())
		{
		  lastblk_to_read (false);
		  break;
		}
	    }
	  if (len > 0)
	    {
	      if (len >= devbufsiz)
		{
		  bytes_to_read = (len / bytes_per_sector) * bytes_per_sector;
		  tgt = p;
		}
	      else
		{
		  tgt = devbuf;
		  bytes_to_read = devbufsiz;
		}
	      off_t current_position = get_current_position ();
	      if (current_position + bytes_to_read >= drive_size)
		bytes_to_read = drive_size - current_position;
	      if (!bytes_to_read)
		break;

	      debug_printf ("read %u bytes from pos %U %s", bytes_to_read,
			    current_position,
			    len < devbufsiz ? "into buffer" : "directly");
	      if (!read_file (tgt, bytes_to_read, &read2, &ret))
		{
		  if (!IS_EOM (ret))
		    {
		      __seterrno ();
		      goto err;
		    }

		  eom_detected (true);

		  if (!read2)
		    {
		      if (!bytes_read)
			{
			  debug_printf ("return -1, set errno to ENOSPC");
			  set_errno (ENOSPC);
			  goto err;
			}
		      break;
		    }
		  lastblk_to_read (true);
		}
	      if (!read2)
	       break;
	      if (tgt == devbuf)
		{
		  devbufstart = 0;
		  devbufend = read2;
		}
	      else
		{
		  len -= read2;
		  p += read2;
		  bytes_read += read2;
		}
	    }
	}
    }
  else
    {
      off_t current_position = get_current_position ();
      bytes_to_read = len;
      if (current_position + bytes_to_read >= drive_size)
	bytes_to_read = drive_size - current_position;
      debug_printf ("read %u bytes from pos %U directly", bytes_to_read,
		    current_position);
      if (bytes_to_read && !read_file (p, bytes_to_read, &bytes_read, &ret))
	{
	  if (!IS_EOM (ret))
	    {
	      __seterrno ();
	      goto err;
	    }
	  if (bytes_read)
	    eom_detected (true);
	  else
	    {
	      debug_printf ("return -1, set errno to ENOSPC");
	      set_errno (ENOSPC);
	      goto err;
	    }
	}
    }

  ulen = (size_t) bytes_read;
  return;

err:
  ulen = (size_t) -1;
}

ssize_t __reg3
fhandler_dev_floppy::raw_write (const void *ptr, size_t len)
{
  DWORD bytes_written = 0;
  char *p = (char *) ptr;
  int ret;

  /* Checking a previous end of media */
  if (eom_detected ())
    {
      set_errno (ENOSPC);
      return -1;
    }

  if (!len)
    return 0;

  if (devbuf)
    {
      DWORD cplen, written;

      /* First check if we have an active read buffer.  If so, try to fit in
      	 the start of the input buffer and write out the entire result.
	 This also covers the situation after lseek since lseek fills the read
	 buffer in case we seek to an address which is not sector aligned. */
      if (devbufend && devbufstart < devbufend)
      	{
	  off_t current_pos = get_current_position ();
	  cplen = MIN (len, devbufend - devbufstart);
	  memcpy (devbuf + devbufstart, p, cplen);
	  LARGE_INTEGER off = { QuadPart:current_pos - devbufend };
	  if (!SetFilePointerEx (get_handle (), off, NULL, FILE_BEGIN))
	    {
	      devbufstart = devbufend = 0;
	      __seterrno ();
	      return -1;
	    }
	  if (!write_file (devbuf, devbufend, &written, &ret))
	    {
	      devbufstart = devbufend = 0;
	      goto err;
	    }
	  /* Align pointers, lengths, etc. */
	  cplen = MIN (cplen, written);
	  devbufstart += cplen;
	  p += cplen;
	  len -= cplen;
	  bytes_written += cplen;
	  if (len)
	    devbufstart = devbufend = 0;
	}
      /* As long as there's still something left in the input buffer ... */
      while (len)
	{
	  /* Compute the length to write.  The problem is that the underlying
	     driver may require sector aligned read/write.  So we copy the data
	     over to devbuf, which is guaranteed to be sector aligned. */
	  cplen = MIN (len, devbufsiz);
	  if (cplen >= bytes_per_sector)
	    /* If the remaining len is >= sector size, write out the maximum
	       possible multiple of the sector size which fits into devbuf. */
	    cplen = rounddown (cplen, bytes_per_sector);
	  else
	    {
	      /* If len < sector size, read in the next sector, seek back,
		 and just copy the new data over the old one before writing. */
	      LARGE_INTEGER off = { QuadPart:get_current_position () };
	      if (!read_file (devbuf, bytes_per_sector, &written, &ret))
		goto err;
	      if (!SetFilePointerEx (get_handle (), off, NULL, FILE_BEGIN))
		{
		  __seterrno ();
		  return -1;
		}
	    }
	  memcpy (devbuf, p, cplen);
	  if (!write_file (devbuf, MAX (cplen, bytes_per_sector), &written,
			   &ret))
	    {
	      bytes_written += MIN (cplen, written);
	      goto err;
	    }
	  cplen = MIN (cplen, written);
	  p += cplen;
	  len -= cplen;
	  bytes_written += cplen;
	}
      return bytes_written;
    }
  
  /* In O_DIRECT case, just write. */
  if (write_file (p, len, &bytes_written, &ret))
    return bytes_written;

err:
  if (IS_EOM (ret))
    {
      eom_detected (true);
      if (!bytes_written)
	set_errno (ENOSPC);
    }
  else if (!bytes_written)
    __seterrno ();
  return bytes_written ?: -1;
}

off_t
fhandler_dev_floppy::lseek (off_t offset, int whence)
{
  char buf[bytes_per_sector];
  off_t current_pos = (off_t) -1;
  LARGE_INTEGER sector_aligned_offset;
  size_t bytes_left;

  if (whence == SEEK_END)
    {
      offset += drive_size;
      whence = SEEK_SET;
    }
  else if (whence == SEEK_CUR)
    {
      current_pos = get_current_position ();
      off_t exact_pos = current_pos - (devbufend - devbufstart);
      /* Shortcut when used to get current position. */
      if (offset == 0)
      	return exact_pos;
      offset += exact_pos;
      whence = SEEK_SET;
    }

  if (whence != SEEK_SET || offset < 0 || offset > drive_size)
    {
      set_errno (EINVAL);
      return -1;
    }

  /* If new position is in buffered range, adjust buffer and return */
  if (devbufstart < devbufend)
    {
      if (current_pos == (off_t) -1)
	current_pos = get_current_position ();
      if (current_pos - devbufend <= offset && offset <= current_pos)
	{
	  devbufstart = devbufend - (current_pos - offset);
	  return offset;
	}
    }

  sector_aligned_offset.QuadPart = rounddown (offset, bytes_per_sector);
  bytes_left = offset - sector_aligned_offset.QuadPart;

  /* Invalidate buffer. */
  devbufstart = devbufend = 0;

  if (!SetFilePointerEx (get_handle (), sector_aligned_offset, NULL,
			 FILE_BEGIN))
    {
      __seterrno ();
      return -1;
    }

  eom_detected (false);

  if (bytes_left)
    {
      raw_read (buf, bytes_left);
      if (bytes_left == (size_t) -1)
	return -1;
    }

  return sector_aligned_offset.QuadPart + bytes_left;
}

int
fhandler_dev_floppy::ioctl (unsigned int cmd, void *buf)
{
  int ret = 0;
  DWORD bytes_read;

  switch (cmd)
    {
    case HDIO_GETGEO:
      debug_printf ("HDIO_GETGEO");
      ret = get_drive_info ((struct hd_geometry *) buf);
      break;
    case BLKGETSIZE:
    case BLKGETSIZE64:
      debug_printf ("BLKGETSIZE");
      if (cmd == BLKGETSIZE)
	*(long *)buf = drive_size >> 9UL;
      else
	*(off_t *)buf = drive_size;
      break;
    case BLKRRPART:
      debug_printf ("BLKRRPART");
      if (!DeviceIoControl (get_handle (), IOCTL_DISK_UPDATE_PROPERTIES,
			    NULL, 0, NULL, 0, &bytes_read, NULL))
	{
	  __seterrno ();
	  ret = -1;
	}
      else
	get_drive_info (NULL);
      break;
    case BLKSSZGET:
      debug_printf ("BLKSSZGET");
      *(int *)buf = (int) bytes_per_sector;
      break;
    case BLKIOMIN:
      debug_printf ("BLKIOMIN");
      *(int *)buf = (int) bytes_per_sector;
      break;
    case BLKIOOPT:
      debug_printf ("BLKIOOPT");
      *(int *)buf = (int) bytes_per_sector;
      break;
    case BLKPBSZGET:
      debug_printf ("BLKPBSZGET");
      *(int *)buf = (int) bytes_per_sector;
      break;
    case BLKALIGNOFF:
      debug_printf ("BLKALIGNOFF");
      *(int *)buf = 0;
      break;
    default:
      ret = fhandler_dev_raw::ioctl (cmd, buf);
      break;
    }
  return ret;
}

@


1.69
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d5 1
a5 1
   2011, 2012, 2013 Red Hat, Inc.
a65 6
	  if (!DeviceIoControl (get_handle (),
				IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0,
				pbuf, 256, &bytes_read, NULL))
	    __seterrno ();
	  else
	    pix = (PARTITION_INFORMATION_EX *) pbuf;
d78 17
d115 1
a115 1
  else
d122 3
@


1.69.2.1
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Fix floppy
	drive handling broken with 1.7.19.
@
text
@d5 1
a5 1
   2011, 2012, 2013, 2014 Red Hat, Inc.
d66 6
a83 17
    }
  if (dix) /* Don't try IOCTL_DISK_GET_PARTITION_INFO_EX if
	      IOCTL_DISK_GET_DRIVE_GEOMETRY_EX didn't work. 
	      Probably a floppy.*/
    {
      if (!DeviceIoControl (get_handle (),
			    IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0,
			    pbuf, 256, &bytes_read, NULL))
	__seterrno ();
      else
	pix = (PARTITION_INFORMATION_EX *) pbuf;
    }
  if (!pix && get_major () != DEV_FLOPPY_MAJOR)
    {
      /* It's unlikely that this code path will be used at all.  Either the
	 _EX call already worked, or it's a floppy.  But it doesn't hurt to
	 keep the code in. */
d104 1
a104 1
  else if (pi)
a110 3
  else	/* Floppy drive. */
    drive_size = di->Cylinders.QuadPart * di->TracksPerCylinder
		 * di->SectorsPerTrack * di->BytesPerSector;
@


1.68
log
@	* Merge in cygwin-64bit-branch.
@
text
@d384 1
a384 1
void __stdcall
d516 1
a516 1
ssize_t __stdcall
@


1.67
log
@whitespace
@
text
@d56 1
a56 1
  if (wincap.has_disk_ex_ioctls () && get_major () != DEV_FLOPPY_MAJOR)
d79 8
d89 1
a89 9
	{
	  di = (DISK_GEOMETRY *) dbuf;
	  if (!DeviceIoControl (get_handle (),
				IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
				pbuf, 256, &bytes_read, NULL))
	    __seterrno ();
	  else
	    pi = (PARTITION_INFORMATION *) pbuf;
	}
d91 12
a102 32
  if (!di)
    {
      /* Up to Win2K, even IOCTL_DISK_GET_DRIVE_GEOMETRY fails when trying
	 it on CD or DVD drives.  In that case fall back to requesting
	 simple file system information. */
      NTSTATUS status;
      IO_STATUS_BLOCK io;
      FILE_FS_SIZE_INFORMATION ffsi;

      status = NtQueryVolumeInformationFile (get_handle (), &io, &ffsi,
					     sizeof ffsi,
					     FileFsSizeInformation);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  return -1;
	}
      debug_printf ("fsys geometry: (%D units)*(%u sec)*(%u bps)",
		    ffsi.TotalAllocationUnits.QuadPart,
		    ffsi.SectorsPerAllocationUnit,
		    ffsi.BytesPerSector);
      bytes_per_sector = ffsi.BytesPerSector;
      drive_size = ffsi.TotalAllocationUnits.QuadPart
		   * ffsi.SectorsPerAllocationUnit
		   * ffsi.BytesPerSector;
      if (geo)
	{
	  geo->heads = 1;
	  geo->sectors = ffsi.SectorsPerAllocationUnit;
	  geo->cylinders = ffsi.TotalAllocationUnits.LowPart;
	  geo->start = 0;
	}
d106 10
a115 6
      debug_printf ("disk geometry: (%D cyl)*(%u trk)*(%u sec)*(%u bps)",
		     di->Cylinders.QuadPart,
		     di->TracksPerCylinder,
		     di->SectorsPerTrack,
		     di->BytesPerSector);
      bytes_per_sector = di->BytesPerSector;
d117 1
a117 6
	{
	  debug_printf ("partition info: offset %D  length %D",
			pix->StartingOffset.QuadPart,
			pix->PartitionLength.QuadPart);
	  drive_size = pix->PartitionLength.QuadPart;
	}
d119 1
a119 6
	{
	  debug_printf ("partition info: offset %D  length %D",
			pi->StartingOffset.QuadPart,
			pi->PartitionLength.QuadPart);
	  drive_size = pi->PartitionLength.QuadPart;
	}
d121 1
a121 21
	{
	  /* Getting the partition size by using the drive geometry information
	     looks wrong, but this is a historical necessity.  NT4 didn't
	     maintain partition information for the whole drive (aka
	     "partition 0"), but returned ERROR_INVALID_HANDLE instead.  That
	     got fixed in W2K. */
	  drive_size = di->Cylinders.QuadPart * di->TracksPerCylinder
		       * di->SectorsPerTrack * di->BytesPerSector;
	}
      if (geo)
	{
	  geo->heads = di->TracksPerCylinder;
	  geo->sectors = di->SectorsPerTrack;
	  geo->cylinders = di->Cylinders.LowPart;
	  if (pix)
	    geo->start = pix->StartingOffset.QuadPart >> 9ULL;
	  else if (pi)
	    geo->start = pi->StartingOffset.QuadPart >> 9ULL;
	  else
	    geo->start = 0;
	}
d137 1
a137 1
  syscall_printf ("%d (err %d) = ReadFile (%d, %d, to_read %d, read %d, 0)",
d191 1
a191 1
      debug_printf ("NtQueryInformationFile(FilePositionInformation): %p",
d225 1
a225 1
	  debug_printf ("%d %D->%D : %D->%D", part_no,
d262 1
a262 1
	      debug_printf ("NtCreateFile(%W): %p", part, status);
d306 1
a306 1
  syscall_printf ("%d (err %d) = WriteFile (%d, %d, write %d, written %d, 0)",
d334 2
a335 1
	  devbuf = (char *) roundup2 ((uintptr_t) devbufalloc, devbufalign);
d376 1
a376 1
inline _off64_t
d409 1
a409 1
	      debug_printf ("read %d bytes from buffer (rest %d)",
d436 1
a436 1
	      _off64_t current_position = get_current_position ();
d442 1
a442 1
	      debug_printf ("read %d bytes from pos %U %s", bytes_to_read,
d485 1
a485 1
      _off64_t current_position = get_current_position ();
d489 1
a489 1
      debug_printf ("read %d bytes from pos %U directly", bytes_to_read,
d516 1
a516 1
int __stdcall
d543 1
a543 1
	  _off64_t current_pos = get_current_position ();
d605 1
a605 1

d622 2
a623 2
_off64_t
fhandler_dev_floppy::lseek (_off64_t offset, int whence)
d626 1
a626 1
  _off64_t current_pos = (_off64_t) -1;
d638 1
a638 1
      _off64_t exact_pos = current_pos - (devbufend - devbufstart);
d655 1
a655 1
      if (current_pos == (_off64_t) -1)
d707 1
a707 1
	*(_off64_t *)buf = drive_size;
d722 1
a722 1
      *(int *)buf = bytes_per_sector;
d726 1
a726 1
      *(int *)buf = bytes_per_sector;
d730 1
a730 1
      *(int *)buf = bytes_per_sector;
d734 1
a734 1
      *(int *)buf = bytes_per_sector;
@


1.66
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d5 1
a5 1
   2011, 2012 Red Hat, Inc.
d650 1
a650 1
  
@


1.65
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Remove lloffset.
	Use offset directly.  Add shortcut for lseek(fd, 0, SEEK_CUR) case.
	(fhandler_dev_floppy::ioctl): Drop wrong RDSETBLK case.
	* fhandler_raw.cc (fhandler_dev_raw::ioctl): Revamp RDSETBLK code.
@
text
@d4 2
a5 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2011, 2012 Red Hat, Inc.
@


1.64
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::open): Fix comment.
@
text
@a670 1
  _off64_t lloffset = offset;
d677 1
a677 1
      lloffset += drive_size;
d683 5
a687 1
      lloffset += current_pos - (devbufend - devbufstart);
d691 1
a691 1
  if (whence != SEEK_SET || lloffset < 0 || lloffset > drive_size)
d702 1
a702 1
      if (current_pos - devbufend <= lloffset && lloffset <= current_pos)
d704 2
a705 2
	  devbufstart = devbufend - (current_pos - lloffset);
	  return lloffset;
d709 2
a710 2
  sector_aligned_offset.QuadPart = rounddown (lloffset, bytes_per_sector);
  bytes_left = lloffset - sector_aligned_offset.QuadPart;
a784 11
    case RDSETBLK:
      /* Just check the restriction that blocksize must be a multiple
	 of the sector size of the underlying volume sector size,
	 then fall through to fhandler_dev_raw::ioctl. */
      debug_printf ("RDSETBLK");
      if (((struct rdop *) buf)->rd_parm % bytes_per_sector)
	{
	  set_errno (EINVAL);
	  return -1;
	}
      /*FALLTHRU*/
@


1.63
log
@	* fhandler.h (class fhandler_dev_raw): Add members devbufalloc and
	devbufalign.
	(class fhandler_dev_floppy): Remove member bytes_per_sector;
	* fhandler_floppy.cc (bytes_per_sector): Define as devbufalign.
	(fhandler_dev_floppy::open): Set devbufalign to a multiple of the
	sector size and handle devbuf allocation and alignment in !O_DIRECT
	case here.  Change comment accordingly.
	Call FSCTL_ALLOW_EXTENDED_DASD_IO for partitions as well.
	(fhandler_dev_floppy::raw_write): Fix comment.  Rewrite and fix
	writing behaviour when application uses read and lseek.
	(fhandler_dev_floppy::lseek): Use rounddown macro.  Call
	SetFilePointerEx rather than the old SetFilePointer.
	(fhandler_dev_floppy::ioctl): Reformat switch.  Call
	IOCTL_DISK_UPDATE_PROPERTIES rather than IOCTL_DISK_UPDATE_DRIVE_SIZE
	in BLKRRPART case.  Support BLKIOMIN, BLKIOOPT, BLKPBSZGET and
	BLKALIGNOFF.
	* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Initialize
	all devbuf-related members.
	(fhandler_dev_raw::~fhandler_dev_raw): Delete devbufalloc rather than
	devbuf.
	(fhandler_dev_raw::open): Drop allocating devbuf.
	(fhandler_dev_raw::dup): Allocate devbufalloc and set devbuf to support
	new sector-aligned devbuf handling.
	(fhandler_dev_raw::fixup_after_exec): Ditto.
	* fhandler_tape.cc (fhandler_dev_tape::open): Ditto, set devbufalign
	to 1.
	* include/cygwin/fs.h (BLKIOMIN): Define.
	(BLKIOOPT): Define.
	(BLKALIGNOFF): Define.
	(BLKPBSZGET): Define.
@
text
@d383 3
a385 3
      /* If we're trying to access a CD/DVD drive, or an entire disk,
	 make sure we're actually allowed to read *all* of the device.
	 This is actually documented in the MSDN CreateFile man page. */
@


1.62
log
@	* Throughout, replace usage of w32api's min with MIN from sys/param.h.
@
text
@d31 2
a359 10
  /* The correct size of the buffer would be 512 bytes, which is the atomic
     size, supported by WinNT.  Unfortunately, the performance is worse than
     access to file system on same device!  Setting buffer size to a
     relatively big value increases performance by means.  The new ioctl call
     with 'rdevio.h' header file supports changing this value.

     As default buffer size, we're using some value which is a multiple of
     the typical tar and cpio buffer sizes, Except O_DIRECT is set, in which
     case we're not buffering at all. */
  devbufsiz = (flags & O_DIRECT) ? 0L : 61440L;
d371 12
a386 1
	  && (get_major () == DEV_CDROM_MAJOR || get_minor () % 16 == 0)
d568 1
a568 1
  /* Checking a previous end of media on tape */
d575 2
a576 2
  /* Invalidate buffer. */
  devbufstart = devbufend = 0;
d578 1
a578 1
  if (len > 0)
d580 13
a592 3
      if (!write_file (p, len, &bytes_written, &ret))
	{
	  if (!IS_EOM (ret))
d594 1
d598 41
a638 2
	  eom_detected (true);
	  if (!bytes_written)
d640 2
a641 2
	      set_errno (ENOSPC);
	      return -1;
d643 22
a664 3
	}
    }
  return bytes_written;
d706 1
a706 2
  sector_aligned_offset.QuadPart = (lloffset / bytes_per_sector)
				   * bytes_per_sector;
d712 2
a713 7
  sector_aligned_offset.LowPart =
			SetFilePointer (get_handle (),
					sector_aligned_offset.LowPart,
					&sector_aligned_offset.HighPart,
					FILE_BEGIN);
  if (sector_aligned_offset.LowPart == INVALID_SET_FILE_POINTER
      && GetLastError ())
d734 1
a734 1
  DISK_GEOMETRY di;
d736 1
d740 3
a742 4
      {
	debug_printf ("HDIO_GETGEO");
	return get_drive_info ((struct hd_geometry *) buf);
      }
d745 6
a750 8
      {
	debug_printf ("BLKGETSIZE");
	if (cmd == BLKGETSIZE)
	  *(long *)buf = drive_size >> 9UL;
	else
	  *(_off64_t *)buf = drive_size;
	return 0;
      }
d752 8
a759 11
      {
	debug_printf ("BLKRRPART");
	if (!DeviceIoControl (get_handle (),
			      IOCTL_DISK_UPDATE_DRIVE_SIZE,
			      NULL, 0,
			      &di, sizeof (di),
			      &bytes_read, NULL))
	  {
	    __seterrno ();
	    return -1;
	  }
d761 1
a761 2
	return 0;
      }
d763 19
a781 5
      {
	debug_printf ("BLKSSZGET");
	*(int *)buf = bytes_per_sector;
	return 0;
      }
d786 1
d789 1
a789 2
	  SetLastError (ERROR_INVALID_PARAMETER);
	  __seterrno ();
d794 2
a795 1
      return fhandler_dev_raw::ioctl (cmd, buf);
d797 1
@


1.62.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d418 1
a418 1
inline off_t
d478 1
a478 1
	      off_t current_position = get_current_position ();
d527 1
a527 1
      off_t current_position = get_current_position ();
d595 2
a596 2
off_t
fhandler_dev_floppy::lseek (off_t offset, int whence)
d599 2
a600 2
  off_t lloffset = offset;
  off_t current_pos = (off_t) -1;
d625 1
a625 1
      if (current_pos == (off_t) -1)
d684 1
a684 1
	  *(off_t *)buf = drive_size;
@


1.62.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@a30 2
#define bytes_per_sector devbufalign

d358 10
d379 3
a381 15
      if (!(flags & O_DIRECT))
	{
	  /* Create sector-aligned buffer.  As default buffer size, we're using
	     some big, sector-aligned value.  Since direct blockdev IO is
	     usually non-buffered and non-cached, the performance without
	     buffering is worse than access to a file system on same device.
	     Whoever uses O_DIRECT has my condolences. */
	  devbufsiz = MAX (16 * bytes_per_sector, 65536);
	  devbufalloc = new char [devbufsiz + devbufalign];
	  devbuf = (char *) roundup2 ((uintptr_t) devbufalloc, devbufalign);
	}

      /* If we're not trying to access a floppy disk, make sure we're actually
         allowed to read *all* of the device or volume.  This is actually
	 documented in the MSDN CreateFile man page. */
d383 1
d565 1
a565 1
  /* Checking a previous end of media */
d572 2
a573 2
  if (!len)
    return 0;
d575 1
a575 1
  if (devbuf)
d577 3
a579 13
      DWORD cplen, written;

      /* First check if we have an active read buffer.  If so, try to fit in
      	 the start of the input buffer and write out the entire result.
	 This also covers the situation after lseek since lseek fills the read
	 buffer in case we seek to an address which is not sector aligned. */
      if (devbufend && devbufstart < devbufend)
      	{
	  off_t current_pos = get_current_position ();
	  cplen = MIN (len, devbufend - devbufstart);
	  memcpy (devbuf + devbufstart, p, cplen);
	  LARGE_INTEGER off = { QuadPart:current_pos - devbufend };
	  if (!SetFilePointerEx (get_handle (), off, NULL, FILE_BEGIN))
a580 1
	      devbufstart = devbufend = 0;
d584 2
a585 1
	  if (!write_file (devbuf, devbufend, &written, &ret))
d587 2
a588 2
	      devbufstart = devbufend = 0;
	      goto err;
d590 3
a592 62
	  /* Align pointers, lengths, etc. */
	  cplen = MIN (cplen, written);
	  devbufstart += cplen;
	  p += cplen;
	  len -= cplen;
	  bytes_written += cplen;
	  if (len)
	    devbufstart = devbufend = 0;
	}
      /* As long as there's still something left in the input buffer ... */
      while (len)
	{
	  /* Compute the length to write.  The problem is that the underlying
	     driver may require sector aligned read/write.  So we copy the data
	     over to devbuf, which is guaranteed to be sector aligned. */
	  cplen = MIN (len, devbufsiz);
	  if (cplen >= bytes_per_sector)
	    /* If the remaining len is >= sector size, write out the maximum
	       possible multiple of the sector size which fits into devbuf. */
	    cplen = rounddown (cplen, bytes_per_sector);
	  else
	    {
	      /* If len < sector size, read in the next sector, seek back,
		 and just copy the new data over the old one before writing. */
	      LARGE_INTEGER off = { QuadPart:get_current_position () };
	      if (!read_file (devbuf, bytes_per_sector, &written, &ret))
		goto err;
	      if (!SetFilePointerEx (get_handle (), off, NULL, FILE_BEGIN))
		{
		  __seterrno ();
		  return -1;
		}
	    }
	  memcpy (devbuf, p, cplen);
	  if (!write_file (devbuf, MAX (cplen, bytes_per_sector), &written,
			   &ret))
	    {
	      bytes_written += MIN (cplen, written);
	      goto err;
	    }
	  cplen = MIN (cplen, written);
	  p += cplen;
	  len -= cplen;
	  bytes_written += cplen;
	}
      return bytes_written;
    }
  
  /* In O_DIRECT case, just write. */
  if (write_file (p, len, &bytes_written, &ret))
    return bytes_written;

err:
  if (IS_EOM (ret))
    {
      eom_detected (true);
      if (!bytes_written)
	set_errno (ENOSPC);
    }
  else if (!bytes_written)
    __seterrno ();
  return bytes_written ?: -1;
d599 1
d606 1
a606 1
      offset += drive_size;
d612 1
a612 5
      off_t exact_pos = current_pos - (devbufend - devbufstart);
      /* Shortcut when used to get current position. */
      if (offset == 0)
      	return exact_pos;
      offset += exact_pos;
d616 1
a616 1
  if (whence != SEEK_SET || offset < 0 || offset > drive_size)
d627 1
a627 1
      if (current_pos - devbufend <= offset && offset <= current_pos)
d629 2
a630 2
	  devbufstart = devbufend - (current_pos - offset);
	  return offset;
d634 3
a636 2
  sector_aligned_offset.QuadPart = rounddown (offset, bytes_per_sector);
  bytes_left = offset - sector_aligned_offset.QuadPart;
d641 7
a647 2
  if (!SetFilePointerEx (get_handle (), sector_aligned_offset, NULL,
			 FILE_BEGIN))
d668 1
a668 1
  int ret = 0;
a669 1

d673 4
a676 3
      debug_printf ("HDIO_GETGEO");
      ret = get_drive_info ((struct hd_geometry *) buf);
      break;
d679 8
a686 6
      debug_printf ("BLKGETSIZE");
      if (cmd == BLKGETSIZE)
	*(long *)buf = drive_size >> 9UL;
      else
	*(off_t *)buf = drive_size;
      break;
d688 25
a712 3
      debug_printf ("BLKRRPART");
      if (!DeviceIoControl (get_handle (), IOCTL_DISK_UPDATE_PROPERTIES,
			    NULL, 0, NULL, 0, &bytes_read, NULL))
d714 1
d716 1
a716 1
	  ret = -1;
d718 1
a718 23
      else
	get_drive_info (NULL);
      break;
    case BLKSSZGET:
      debug_printf ("BLKSSZGET");
      *(int *)buf = bytes_per_sector;
      break;
    case BLKIOMIN:
      debug_printf ("BLKIOMIN");
      *(int *)buf = bytes_per_sector;
      break;
    case BLKIOOPT:
      debug_printf ("BLKIOOPT");
      *(int *)buf = bytes_per_sector;
      break;
    case BLKPBSZGET:
      debug_printf ("BLKPBSZGET");
      *(int *)buf = bytes_per_sector;
      break;
    case BLKALIGNOFF:
      debug_printf ("BLKALIGNOFF");
      *(int *)buf = 0;
      break;
d720 1
a720 2
      ret = fhandler_dev_raw::ioctl (cmd, buf);
      break;
a721 1
  return ret;
@


1.62.2.3
log
@	* cpuid.h (can_set_flag): Implement for x86_64.
	* fhandler.h (class fhandler_dev_raw): Define devbuf members taking
	numerical values as DWORD, rather than size_t.
	* fhandler_dsp.cc: Fix debug printf calls to be type safe.
	(waveOut_callback): Align parameter types to latest MSDN description.
	(waveIn_callback): Ditto.
	(fhandler_dev_dsp::Audio_out::start): Change casts in call to
	waveOutOpen according to MSDN.
	(fhandler_dev_dsp::Audio_out::parsewav): Fix a cast.
	(fhandler_dev_dsp::Audio_in::start): Change casts in call to
	waveInOpen according to MSDN.
	* fhandler_floppy.cc: Fix debug printf calls to be type safe.
	(fhandler_dev_floppy::ioctl): Add casts to be on the safe side.
	* fhandler_proc.cc: Fix debug printf calls to be type safe.
@
text
@d183 1
a183 1
  syscall_printf ("%d (err %d) = ReadFile (%p, %p, to_read %u, read %u, 0)",
d237 1
a237 1
      debug_printf ("NtQueryInformationFile(FilePositionInformation): %y",
d271 1
a271 1
	  debug_printf ("%u %D->%D : %D->%D", part_no,
d308 1
a308 1
	      debug_printf ("NtCreateFile(%W): %y", part, status);
d352 1
a352 1
  syscall_printf ("%d (err %d) = WriteFile (%p, %p, write %u, written %u, 0)",
d454 1
a454 1
	      debug_printf ("read %u bytes from buffer (rest %u)",
d487 1
a487 1
	      debug_printf ("read %u bytes from pos %U %s", bytes_to_read,
d534 1
a534 1
      debug_printf ("read %u bytes from pos %U directly", bytes_to_read,
d767 1
a767 1
      *(int *)buf = (int) bytes_per_sector;
d771 1
a771 1
      *(int *)buf = (int) bytes_per_sector;
d775 1
a775 1
      *(int *)buf = (int) bytes_per_sector;
d779 1
a779 1
      *(int *)buf = (int) bytes_per_sector;
@


1.62.2.4
log
@Pull in changes from HEAD
@
text
@d4 2
a5 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2011, 2012 Red Hat, Inc.
@


1.62.2.5
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::open): Cast second parameter
	in roundup2 to same size as first parameter to make sure mask size is
	correct.
	* fhandler_process.cc (format_process_maps): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::dup): Ditto.
	* hookapi.cc (find_first_notloaded_dll): Add cast.
	* spawn.cc (av::fixup): Ditto.
	* wincap.h: Add comment to explain the folowing change.
	(wincapc::page_size): Return size_t.
	(wincapc::allocation_granularity): Ditto.

	* mmap.cc: Throughout, accommodate the fact that AT_ROUND_TO_PAGE isn't
	support on 64 bit at all.
	(class mmap_allocator): New class to allocate mmap slots on x86_64.
	(mmap_alloc): Define global instant of mmap_allocator.
	(mmap64): Call mmap_alloc.alloc on x86_64.
@
text
@d5 1
a5 1
   2011, 2012, 2013 Red Hat, Inc.
d380 1
a380 2
	  devbuf = (char *) roundup2 ((uintptr_t) devbufalloc,
				      (uintptr_t) devbufalign);
@


1.62.2.6
log
@* cygserver_ipc (class ipc_retval): Add ssize_t member to anonymous union.
(ipc_retval::operator =): Add ssize_t variant for x86_64.
* fhandler_floppy.cc (fhandler_dev_floppy::raw_write): Change return
type to ssize_t to match fhandler.h.
* fhandler_socket.cc (fhandler_socket::readv): Ditto.
(fhandler_socket::write): Ditto.
(fhandler_socket::writev): Ditto.
(fhandler_socket::sendmsg): Ditto.
@
text
@d562 1
a562 1
ssize_t __stdcall
@


1.62.2.7
log
@	* autoload.cc (AttachConsole): Remove.
	(GetModuleHandleExW): Remove.
	(GetSystemWow64DirectoryW): Remove.
	(GetVolumePathNamesForVolumeNameW): Remove.
	* exceptions.cc (cygwin_stackdump): Always call RtlCaptureContext.
	(exception::handle): Drop accidentally left in debugging statement.
	Always call RtlCaptureContext.
	(sigpacket::process): Always call RtlCaptureContext for current thread.
	* fhandler_disk_file.cc (fstatvfs): Drop code using
	FileFsSizeInformation.
	(struct __DIR_cache): Remove comment.
	(fhandler_disk_file::rewinddir): Drop W2K-only code.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Don't
	check for old OS.  Extend a comment.
	* fhandler_mem.cc (fhandler_dev_mem::open): Drop NT4 and W2K from
	debug output.
	* fhandler_proc.cc (format_proc_partitions): Drop Pre-XP considerations.
	* fhandler_procnet.cc (fhandler_procnet::exists): Ditto.
	(fhandler_procnet::readdir): Ditto.
	(format_procnet_ifinet6): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvmsg): Ditto.
	* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
	* init.cc (dll_entry): Drop W2K-only code.
	* net.cc (get_ifs): Rename from get_xp_ifs.
	(get_2k_ifs): Remove.
	(getifaddrs): Always call get_ifs.
	(get_ifconf): Ditto.
	(if_nametoindex): Drop Pre-XP considerations.
	(load_ipv6_funcs): Ditto.  Fix preceeding comment.
	* sec_auth.cc (lsaauth): Drop code handling fake_login_sid.
	* sec_helper.cc (fake_logon_sid): Remove.
	(set_cygwin_privileges): Fix uncommented statement to drop pre-XP
	considerations.
	* security.h (fake_logon_sid): Drop declaration.
	* shared.cc (shared_info::init_obcaseinsensitive): Drop W2K-only code.
	* wincap.cc: Throughout, remove setting all deprecated wincapc members.
	(wincap_minimal): Set to wincap_xpsp2.
	(wincap_2000): Remove.
	(wincap_2000sp4): Remove.
	(wincap_xp): Remove.
	(wincap_xpsp1): Remove.
	(wincapc::init): Drop OS 5.0 and pre-SP2 XP.
	* wincap.h (struct wincaps): Remove the following members:
	has_create_global_privilege, has_ioctl_storage_get_media_types_ex,
	has_disk_ex_ioctls, has_buggy_restart_scan, needs_logon_sid_in_sid_list,
	has_gaa_prefixes, has_recvmsg, has_stack_size_param_is_a_reservation,
	kernel_is_always_casesensitive, has_rtl_capture_context.
@
text
@d56 1
a56 1
  if (get_major () != DEV_FLOPPY_MAJOR)
d152 1
a152 1
	     got fixed in W2K, but we keep it here as fallback. */
@


1.62.2.8
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@d79 2
d82 24
a105 1
	  __seterrno ();
d108 15
a122 20
      di = (DISK_GEOMETRY *) dbuf;
      if (!DeviceIoControl (get_handle (),
			    IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
			    pbuf, 256, &bytes_read, NULL))
	__seterrno ();
      else
	pi = (PARTITION_INFORMATION *) pbuf;
    }
  debug_printf ("disk geometry: (%D cyl)*(%u trk)*(%u sec)*(%u bps)",
		 di->Cylinders.QuadPart,
		 di->TracksPerCylinder,
		 di->SectorsPerTrack,
		 di->BytesPerSector);
  bytes_per_sector = di->BytesPerSector;
  if (pix)
    {
      debug_printf ("partition info: offset %D  length %D",
		    pix->StartingOffset.QuadPart,
		    pix->PartitionLength.QuadPart);
      drive_size = pix->PartitionLength.QuadPart;
d126 6
a131 10
      debug_printf ("partition info: offset %D  length %D",
		    pi->StartingOffset.QuadPart,
		    pi->PartitionLength.QuadPart);
      drive_size = pi->PartitionLength.QuadPart;
    }
  if (geo)
    {
      geo->heads = di->TracksPerCylinder;
      geo->sectors = di->SectorsPerTrack;
      geo->cylinders = di->Cylinders.LowPart;
d133 6
a138 1
	geo->start = pix->StartingOffset.QuadPart >> 9ULL;
d140 6
a145 1
	geo->start = pi->StartingOffset.QuadPart >> 9ULL;
d147 21
a167 1
	geo->start = 0;
@


1.61
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d5 1
a5 1
   2009, 2011 Red Hat, Inc.
d16 1
d450 1
a450 1
	      bytes_to_read = min (len, devbufend - devbufstart);
@


1.60
log
@	* fhandler.h (class fhandler_dev_mem): Remove dup method declaration.
	* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Accommodate the
	fact that the entire fhandler gets copied over to the child in
	operator =.
	* fhandler_floppy.cc (fhandler_dev_floppy::dup): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::dup): Ditto.
	* fhandler_serial.cc (fhandler_serial::dup): Ditto.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::dup): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::dup): Ditto.  Remove entirely.
@
text
@d408 1
a408 1
fhandler_dev_floppy::dup (fhandler_base *child)
d410 1
a410 1
  int ret = fhandler_dev_raw::dup (child);
@


1.59
log
@whitespace elimination
@
text
@a409 2
  fhandler_dev_floppy *fhc = (fhandler_dev_floppy *) child;

d412 2
a413 11
  if (!ret)
    {
      fhc->drive_size = drive_size;
      fhc->bytes_per_sector = bytes_per_sector;
      if (partitions)
	{
	  InterlockedIncrement (&partitions->refcnt);
	  fhc->partitions = partitions;
	}
      fhc->eom_detected (eom_detected ());
    }
@


1.58
log
@	* autoload.cc (UuidCreate): Remove.
	(UuidCreateSequential): Remove.
	* passwd.cc (internal_getpwsid): Avoid a strict-aliasing compiler
	error with gcc 4.5.1.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Ditto.
	* ntdll.h (NtAllocateUuids): Declare.
	* syscalls.cc (gethostid): Use NtAllocateUuids function rather than
	UuidCreateSequential/UuidCreate to get rid of rpcrt4 dependency.
@
text
@d191 1
a191 1
  /* The simple case.  We have only a single partition open anyway. 
d228 1
a228 1
  
d240 1
a240 1
  			pdlix, size, &bytes_read, NULL))
d253 1
a253 1
      	continue;
d379 1
a379 1
         make sure we're actually allowed to read *all* of the device.
@


1.57
log
@	* fhandler.h (struct part_t): New type.
	(class fhandler_dev_floppy): Convert partitions to part_t pointer.
	Add lock_partition method.
	* fhandler_floppy.cc (fhandler_dev_floppy::lock_partition): New method
	to implement ondemand partition locking.
	(fhandler_dev_floppy::write_file): Call lock_partition from here if
	writing failed due to a potential write restriction on a disk
	partition.
	(fhandler_dev_floppy::open): Don't lock partitions here.
	(fhandler_dev_floppy::close): Keep track of partition handle reference
	count.  Close handles and remove partitions pointer ony if count is 0.
	(fhandler_dev_floppy::dup): Just copy partitions pointer and increment
	reference count.
@
text
@d44 1
d61 2
a62 1
	  di = &((DISK_GEOMETRY_EX *) dbuf)->Geometry;
@


1.57.2.1
log
@	* passwd.cc (internal_getpwsid): Avoid a strict-aliasing compiler
	error with gcc 4.5.1.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Ditto.
	* syscalls.cc (gethostid): Ditto.
@
text
@a43 1
  DISK_GEOMETRY_EX *dix = NULL;
d60 1
a60 2
	  dix = (DISK_GEOMETRY_EX *) dbuf;
	  di = &dix->Geometry;
@


1.56
log
@	* fhandler.h (MAX_PARTITIONS): New definition.
	(class fhandler_dev_floppy): Add partitions array member.  Add close
	method.
	* fhandler_floppy.cc (fhandler_dev_floppy::fhandler_dev_floppy): Zero
	out partitions array.
	(fhandler_dev_floppy::open): Fix "entire disk" condition for call to
	DeviceIoControl (FSCTL_ALLOW_EXTENDED_DASD_IO).
	When opening disks for writing, call DeviceIoControl (FSCTL_LOCK_VOLUME)
	on all affected disk partitions starting with Vista.
	(fhandler_dev_floppy::close): New method.
	(fhandler_dev_floppy::dup): Duplicate handles in partitions, if any.
	* wincap.h (wincaps::has_restricted_raw_disk_access): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d14 1
a35 1
  memset (partitions, 0, sizeof partitions);
d183 137
d329 18
a384 46
      /* If we're trying to write to a disk partition, lock the partition,
	 otherwise we will get "Access denied" starting with Vista. */
      if (wincap.has_restricted_raw_disk_access ()
	  && get_major () != DEV_FLOPPY_MAJOR
	  && get_major () != DEV_CDROM_MAJOR
	  && (flags & O_ACCMODE) != O_RDONLY)
	{
	  /* Special case: If we try to write to the entire disk, we have to
	     lock all partitions, otherwise writing fails as soon as we cross
	     a partition boundary. */
	  if (get_minor () % 16 == 0)
	    {
	      WCHAR part[MAX_PATH], *p;

	      sys_mbstowcs (part, MAX_PATH, get_win32_name ());
	      p = wcschr (part, L'\0') - 1;
	      for (int i = 0; i < MAX_PARTITIONS; ++i)
	      	{
		  NTSTATUS status;
		  UNICODE_STRING upart;
		  OBJECT_ATTRIBUTES attr;
		  IO_STATUS_BLOCK io;

		  __small_swprintf (p, L"%d", i + 1);
		  RtlInitUnicodeString (&upart, part);
		  InitializeObjectAttributes (&attr, &upart,
					      OBJ_INHERIT|OBJ_CASE_INSENSITIVE,
					      NULL, NULL);
		  status = NtOpenFile (&partitions[i], GENERIC_WRITE, &attr,
				       &io, FILE_SHARE_VALID_FLAGS, 0);
		  if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
		      status == STATUS_OBJECT_PATH_NOT_FOUND)
		    break;
		  else if (!NT_SUCCESS (status))
		    debug_printf ("NtCreateFile(%W): status %p", part, status);
		  else if (!DeviceIoControl (partitions[i], FSCTL_LOCK_VOLUME,
					     NULL, 0, NULL, 0,
					     &bytes_read, NULL))
		    debug_printf ("DeviceIoControl (%W, FSCTL_LOCK_VOLUME) "
				  "failed, %E", part);
		}
	    }
	  else if (!DeviceIoControl (get_handle (), FSCTL_LOCK_VOLUME,
				     NULL, 0, NULL, 0, &bytes_read, NULL))
	    debug_printf ("DeviceIoControl (FSCTL_LOCK_VOLUME) failed, %E");
	}
d395 7
a401 5
  /* See "Special case" comment in fhandler_dev_floppy::open. */
  if (wincap.has_restricted_raw_disk_access ())
    for (int i = 0; i < MAX_PARTITIONS && partitions[i]; ++i)
      NtClose (partitions[i]);

a409 14
  /* See "Special case" comment in fhandler_dev_floppy::open. */
  memset (fhc->partitions, 0, sizeof fhc->partitions);
  if (wincap.has_restricted_raw_disk_access ())
    for (int i = 0; i < MAX_PARTITIONS && partitions[i]; ++i)
      if (!DuplicateHandle (GetCurrentProcess (), partitions[i],
			    GetCurrentProcess (), &fhc->partitions[i],
			    0, TRUE, DUPLICATE_SAME_ACCESS))
	{
	  __seterrno ();
	  while (--i >= 0)
	    NtClose (partitions[i]);
	  return -1;
	}

d416 5
@


1.55
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d5 1
a5 1
   2009 Red Hat, Inc.
d35 1
d225 1
a225 1
	  && (get_major () == DEV_CDROM_MAJOR || get_minor () == 0)
d230 46
d282 13
d297 16
a316 2
      fhandler_dev_floppy *fhc = (fhandler_dev_floppy *) child;

@


1.54
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::open): Fix format.  Add
	code to allow to read disk and CD/DVD devices in full length.  Explain
	why.
	(fhandler_dev_floppy::raw_read): Add current position to debug output.

	* include/sys/sched.h: New stub file to override newlib file with
	clashing definitions.
@
text
@d258 1
a258 1
void
d390 1
a390 1
int
@


1.53
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::raw_read): Drop
	initialization of bytes_to_read.  Set bytes_to_read to len in
	non-buffered case.  Call read_bytes correctly with bytes_to_read
	instead of len.
@
text
@d4 2
a5 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d209 1
a209 1
  int ret =  fhandler_dev_raw::open (flags);
d211 1
a211 1
  if (ret && get_drive_info (NULL))
d213 16
a228 2
      close ();
      return 0;
d316 2
a317 1
	      debug_printf ("read %d bytes %s", bytes_to_read,
d363 2
@


1.52
log
@* pthread.cc (pthread_mutex::_unlock): Avoid unlocking a mutex if the
recursion_counter is already 0.
(pthread_mutex::_destroy): Don't consider a mutex busy if its recursion_counter
== 0.
(pthread_mutex::_fixup_after_fork): Set recursion_counter to 0 to flag that
we've just forked.  Don't reset the owner of this mutex since the forkee may
think it still owns the mutex.  Reinstate initialization of win32_obj_id.
* fhandler_floppy.cc (fhandler_dev_floppy::raw_read): Initialize a variable to
bypass a C++ warning.
@
text
@d248 1
a248 1
  DWORD bytes_to_read = 0;
d344 1
d347 1
a347 1
      if (bytes_to_read && !read_file (p, len, &bytes_read, &ret))
@


1.51
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::raw_read): Keep track of
	current position in non-buffered case, too.
@
text
@d248 1
a248 1
  DWORD bytes_to_read;
@


1.50
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::raw_read): Don't set
	eom_detected when EOF is detected, thus returning 0 instead of
	setting errno to ENOSPC.
@
text
@d341 1
a341 1
  else if (!read_file (p, len, &bytes_read, &ret))
d343 4
a346 1
      if (!IS_EOM (ret))
d348 13
a360 10
	  __seterrno ();
	  goto err;
	}
      if (bytes_read)
	eom_detected (true);
      else
	{
	  debug_printf ("return -1, set errno to ENOSPC");
	  set_errno (ENOSPC);
	  goto err;
@


1.49
log
@Remove unneeded header files from source files throughout.
@
text
@d299 1
a299 4
		{
		  eom_detected (true);
		  break;
		}
@


1.48
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.
@
text
@a12 1
#include <sys/termios.h>
a14 1
#include <asm/socket.h>
a21 1
#include <ntdef.h>
@


1.47
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.
@
text
@d413 1
d424 2
a425 1
      lloffset += get_current_position () - (devbufend - devbufstart);
d435 12
@


1.46
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Fix typo in lint
	directive.
@
text
@d411 1
a411 1
  char buf[512];
d414 1
a414 1
  _off64_t bytes_left;
d456 3
a458 2
      size_t len = bytes_left;
      raw_read (buf, len);
d460 1
@


1.46.2.1
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d411 1
a411 1
  char buf[bytes_per_sector];
a412 1
  _off64_t current_pos = (_off64_t) -1;
d414 1
a414 1
  size_t bytes_left;
d423 1
a423 2
      current_pos = get_current_position ();
      lloffset += current_pos - (devbufend - devbufstart);
a432 12
  /* If new position is in buffered range, adjust buffer and return */
  if (devbufstart < devbufend)
    {
      if (current_pos == (_off64_t) -1)
	current_pos = get_current_position ();
      if (current_pos - devbufend <= lloffset && lloffset <= current_pos)
	{
	  devbufstart = devbufend - (current_pos - lloffset);
	  return lloffset;
	}
    }

d456 2
a457 3
      raw_read (buf, bytes_left);
      if (bytes_left == (size_t) -1)
	return -1;
a458 1

@


1.45
log
@GCC 4.1 fixes.
* cygheap.h (cygheap_user): Remove unneeded class names from function
declaration.
* fhandler.h (fhandler_base): Ditto.
(fhandler_dev_floppy): Ditto.
(fhandler_console): Ditto.
* wininfo.h (wininfo): Ditto.
* exceptions.cc (sigpacket::process): Avoid compiler errors about gotos and
initialization.
* fhandler_fifo.cc (fhandler_fifo::open): Ditto.
* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Ditto.
* mmap.cc (mmap64): Ditto.
* pipe.cc (fhandler_pipe::open): Ditto.
* spawn.cc (spawn_guts): Ditto.
* sec_helper.cc: Fix some comments.
(get_null_sd): Move file-scope static to only function where it is used.
@
text
@d515 1
a515 1
      /*FALLTHRUGH*/
@


1.44
log
@white space
@
text
@d509 1
a509 2
      struct rdop *op = (struct rdop *) buf;
      if (op->rd_parm % bytes_per_sector)
@


1.44.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@d509 2
a510 1
      if (((struct rdop *) buf)->rd_parm % bytes_per_sector)
@


1.44.2.2
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Fix typo in lint
	directive.
@
text
@d515 1
a515 1
      /*FALLTHRU*/
@


1.43
log
@	* fhandler_floppy.cc: Include ntdef.h and ntdll.h.
	(fhandler_dev_floppy::get_drive_info): Rearrange so that now
	NtQueryVolumeInformationFile is called on drives which don't support
	IOCTL_DISK_GET_DRIVE_GEOMETRY.
	* ntdll.h (struct _FILE_FS_SIZE_INFORMATION): Add.
	(enum _FSINFOCLASS): Add missing values.
@
text
@d90 1
a90 1
         it on CD or DVD drives.  In that case fall back to requesting
d95 1
a95 1
      
d100 1
a100 1
        {
d111 1
a111 1
      		   * ffsi.BytesPerSector;
d113 1
a113 1
        {
d166 1
a166 1
   
@


1.42
log
@whitespace cleanup to force snapshot.
@
text
@d24 2
d45 1
a45 1
  DISK_GEOMETRY *di;
d58 2
d61 7
a67 2
	  __seterrno ();
	  return -1;
a68 5
      di = &((DISK_GEOMETRY_EX *) dbuf)->Geometry;
      if (DeviceIoControl (get_handle (),
			   IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0,
			   pbuf, 256, &bytes_read, NULL))
	pix = (PARTITION_INFORMATION_EX *) pbuf;
d70 1
a70 1
  else
d75 2
d78 24
a101 1
	  __seterrno ();
d104 15
a118 26
      di = (DISK_GEOMETRY *) dbuf;
      if (DeviceIoControl (get_handle (),
			   IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
			   pbuf, 256, &bytes_read, NULL))
	pi = (PARTITION_INFORMATION *) pbuf;
    }

  debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
		 di->Cylinders.LowPart,
		 di->TracksPerCylinder,
		 di->SectorsPerTrack,
		 di->BytesPerSector);
  bytes_per_sector = di->BytesPerSector;
  if (pix)
    {
      debug_printf ("partition info: offset %D  length %D",
		    pix->StartingOffset.QuadPart,
		    pix->PartitionLength.QuadPart);
      drive_size = pix->PartitionLength.QuadPart;
    }
  else if (pi)
    {
      debug_printf ("partition info: offset %D  length %D",
		    pi->StartingOffset.QuadPart,
		    pi->PartitionLength.QuadPart);
      drive_size = pi->PartitionLength.QuadPart;
d122 6
a127 13
      /* Getting the partition size by using the drive geometry information
	 looks wrong, but this is a historical necessity.  NT4 didn't maintain
	 partition information for the whole drive (aka "partition 0"), but
	 returned ERROR_INVALID_HANDLE instead.  That got fixed in W2K. */
      drive_size = di->Cylinders.QuadPart * di->TracksPerCylinder *
		   di->SectorsPerTrack * di->BytesPerSector;
    }
  debug_printf ("drive size: %D", drive_size);
  if (geo)
    {
      geo->heads = di->TracksPerCylinder;
      geo->sectors = di->SectorsPerTrack;
      geo->cylinders = di->Cylinders.LowPart;
d129 6
a134 1
	geo->start = pix->StartingOffset.QuadPart >> 9ULL;
d136 6
a141 1
	geo->start = pi->StartingOffset.QuadPart >> 9ULL;
d143 21
a163 1
	geo->start = 0;
d165 2
@


1.41
log
@	* fhandler.cc (fhandler_base::open_9x): Handle O_SYNC and O_DIRECT
	flags.
	(fhandler_base::open): Ditto.
	* fhandler_floppy.cc (fhandler_dev_floppy::open): Don't allocate devbuf
	in O_DIRECT case.
	* fhandler_raw.cc (fhandler_dev_raw::ioctl): Don't allow buffer
	changes in O_DIRECT case.  Allow returning a buffer size 0, which
	indicates O_DIRECT.
	* fhandler_tape.cc (fhandler_dev_tape::open): Use O_SYNC flag to
	hand down the !buffer_writes case.  Don't allocate devbuf in O_DIRECT
	case.
	(fhandler_dev_tape::raw_read): Don't mess with devbuf if it's NULL.
	* include/fcntl.h: Define _FDIRECT, O_DIRECT, O_DSYNC and O_RSYNC.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d105 1
a105 1
         looks wrong, but this is a historical necessity.  NT4 didn't maintain
d122 1
a122 1
        geo->start = 0;
d464 1
a464 1
         of the sector size of the underlying volume sector size,
@


1.40
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Fix test for
	valid file position at EOM.
@
text
@d164 4
a167 3
     Let's try to be smart: Let's take a multiple of typical tar and cpio
     buffer sizes by default. */
  devbufsiz = 61440L;
@


1.39
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Use
	fhandler method to access majoer device number.  Add comment to
	explain floppy weirdness.
@
text
@d383 1
a383 1
  if (whence != SEEK_SET || lloffset < 0 || lloffset >= drive_size)
@


1.38
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Don't call
	EX ioctls on floppy drives.
@
text
@d49 3
a51 2
     fall back to trying the old non-EX ioctls. */
  if (wincap.has_disk_ex_ioctls () && pc.dev.major != DEV_FLOPPY_MAJOR)
@


1.37
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d50 1
a50 1
  if (wincap.has_disk_ex_ioctls ())
@


1.36
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Always
	try IOCTL_DISK_GET_DRIVE_GEOMETRY_EX and
	IOCTL_DISK_GET_PARTITION_INFO_EX ioctls first, to allow access to GPT
	partitioned disks.  Fall back to old non-EX ioctls otherwise.
	Add comment to explain NT4 weirdness.
@
text
@d17 1
d25 4
a31 20
int
fhandler_dev_floppy::is_eom (int win_error)
{
  int ret = (win_error == ERROR_INVALID_PARAMETER
	     || win_error == ERROR_SEEK
	     || win_error == ERROR_SECTOR_NOT_FOUND);
  if (ret)
    debug_printf ("end of medium");
  return ret;
}

int
fhandler_dev_floppy::is_eof (int)
{
  int ret = 0;
  if (ret)
    debug_printf ("end of file");
  return ret;
}

d33 1
a33 1
  : fhandler_dev_raw ()
d50 16
a65 3
  if (!DeviceIoControl (get_handle (),
			IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, NULL, 0,
			dbuf, 256, &bytes_read, NULL))
d75 4
a79 11
  else
    di = &((DISK_GEOMETRY_EX *) dbuf)->Geometry;
    
  if (DeviceIoControl (get_handle (),
		       IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0,
		       pbuf, 256, &bytes_read, NULL))
    pix = (PARTITION_INFORMATION_EX *) pbuf;
  else if (DeviceIoControl (get_handle (),
			    IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
			    pbuf, 256, &bytes_read, NULL))
    pi = (PARTITION_INFORMATION *) pbuf;
d126 28
d157 9
a165 13
  /* The correct size of the buffer would be 512 bytes,
   * which is the atomic size, supported by WinNT.
   * Unfortunately, the performance is worse than
   * access to file system on same device!
   * Setting buffer size to a relatively big value
   * increases performance by means.
   * The new ioctl call with 'rdevio.h' header file
   * supports changing this value.
   *
   * Let's be smart: Let's take a multiplier of typical tar
   * and cpio buffer sizes by default!
  */
  devbufsiz = 61440L; /* 512L; */
d177 186
d368 1
a368 1
  _off64_t sector_aligned_offset;
a369 2
  DWORD low;
  LONG high = 0;
d371 1
a371 1
  if (whence == SEEK_END && drive_size > 0)
d373 1
a373 1
      lloffset = offset + drive_size;
d376 1
a376 2

  if (whence == SEEK_CUR)
d378 1
a378 1
      lloffset += current_position - (devbufend - devbufstart);
d382 1
a382 3
  if (whence != SEEK_SET
      || lloffset < 0
      || drive_size > 0 && lloffset >= drive_size)
d388 3
a390 2
  sector_aligned_offset = (lloffset / bytes_per_sector) * bytes_per_sector;
  bytes_left = lloffset - sector_aligned_offset;
d395 7
a401 4
  low = sector_aligned_offset & UINT32_MAX;
  high = sector_aligned_offset >> 32;
  if (SetFilePointer (get_handle (), low, &high, FILE_BEGIN)
      == INVALID_SET_FILE_POINTER && GetLastError ())
d408 1
a408 1
  current_position = sector_aligned_offset;
d414 1
a414 1
  return current_position + bytes_left;
d460 12
@


1.35
log
@	* fhandler.h (class fhandler_dev_raw): Add drive information members
	drive_size, current_position and bytes_per_sector.
	(fhandler_dev_floppy::get_drive_info): Declare.
	* fhandler_floppy.cc (fhandler_dev_floppy::is_eom): Define ERROR_SEEK
	and ERROR_SECTOR_NOT_FOUND as end-of-medium conditions.
	(fhandler_dev_floppy::get_drive_info): New method to have one function
	retrieving drive info.
	(fhandler_dev_floppy::open): Call get_drive_info to get drive
	information right from the start.
	(fhandler_dev_floppy::lseek): Use and set drive information members.
	Especially keep track of current_position.
	(fhandler_dev_floppy::ioctl): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::write_file): Keep track of
	current_position.
	(fhandler_dev_raw::read_file): Ditto.
	(fhandler_dev_raw::raw_read): Never try to read beyond end-of-medium.
	(fhandler_dev_raw::dup): Handle new drive information members.
@
text
@d55 6
a60 2
  DISK_GEOMETRY di;
  PARTITION_INFORMATION pi;
d63 2
d66 2
a67 4
			  IOCTL_DISK_GET_DRIVE_GEOMETRY,
			  NULL, 0,
			  &di, sizeof (di),
			  &bytes_read, NULL))
d69 8
a76 2
      __seterrno ();
      return -1;
d78 12
d91 13
a103 10
		 di.Cylinders.LowPart,
		 di.TracksPerCylinder,
		 di.SectorsPerTrack,
		 di.BytesPerSector);
  bytes_per_sector = di.BytesPerSector;
  if (DeviceIoControl (get_handle (),
			 IOCTL_DISK_GET_PARTITION_INFO,
			 NULL, 0,
			 &pi, sizeof (pi),
			 &bytes_read, NULL))
d106 3
a108 3
		      pi.StartingOffset.QuadPart,
		      pi.PartitionLength.QuadPart);
      drive_size = pi.PartitionLength.QuadPart;
d112 6
a117 2
      drive_size = di.Cylinders.QuadPart * di.TracksPerCylinder *
		   di.SectorsPerTrack * di.BytesPerSector;
d122 9
a130 4
      geo->heads = di.TracksPerCylinder;
      geo->sectors = di.SectorsPerTrack;
      geo->cylinders = di.Cylinders.LowPart;
      geo->start = pi.StartingOffset.QuadPart >> 9ULL;
@


1.34
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d30 3
a32 1
  int ret = (win_error == ERROR_INVALID_PARAMETER);
d53 1
a53 20
fhandler_dev_floppy::open (int flags, mode_t)
{
  /* The correct size of the buffer would be 512 bytes,
   * which is the atomic size, supported by WinNT.
   * Unfortunately, the performance is worse than
   * access to file system on same device!
   * Setting buffer size to a relatively big value
   * increases performance by means.
   * The new ioctl call with 'rdevio.h' header file
   * supports changing this value.
   *
   * Let's be smart: Let's take a multiplier of typical tar
   * and cpio buffer sizes by default!
  */
  devbufsiz = 61440L; /* 512L; */
  return fhandler_dev_raw::open (flags);
}

_off64_t
fhandler_dev_floppy::lseek (_off64_t offset, int whence)
a54 9
  char buf[512];
  _off64_t drive_size = 0;
  _off64_t lloffset = offset;
  _off64_t current_position;
  _off64_t sector_aligned_offset;
  _off64_t bytes_left;
  DWORD low;
  LONG high = 0;

d57 1
a57 1
  DWORD bytes_read;
d73 1
d80 3
a82 3
      debug_printf ("partition info: %ld (%ld)",
		      pi.StartingOffset.LowPart,
		      pi.PartitionLength.LowPart);
d90 47
a136 1
  debug_printf ("drive size: %ld", drive_size);
d146 1
a146 11
      low = SetFilePointer (get_handle (), 0, &high, FILE_CURRENT);
      if (low == INVALID_SET_FILE_POINTER && GetLastError ())
	{
	  __seterrno ();
	  return -1;
	}
      current_position = low + ((_off64_t) high << 32);
      /* devbufend and devbufstart are always 0 when writing. */
      current_position -= devbufend - devbufstart;

      lloffset += current_position;
d150 3
a152 2
  if (lloffset < 0 ||
      drive_size > 0 && lloffset > drive_size)
d158 1
a158 2
  /* FIXME: sector can possibly be not 512 bytes long */
  sector_aligned_offset = (lloffset / 512) * 512;
d161 7
a167 1
  if (whence == SEEK_SET)
d169 3
a171 2
      /* Invalidate buffer. */
      devbufstart = devbufend = 0;
d173 4
a176 10
      low = sector_aligned_offset & UINT32_MAX;
      high = sector_aligned_offset >> 32;
      if (SetFilePointer (get_handle (), low, &high, FILE_BEGIN)
	  == INVALID_SET_FILE_POINTER && GetLastError ())
	{
	  __seterrno ();
	  return -1;
	}

      eom_detected (false);
a178 1
      return sector_aligned_offset + bytes_left;
d180 1
a180 3

  set_errno (EINVAL);
  return -1;
a186 1
  PARTITION_INFORMATION pi;
a187 2
  _off64_t drive_size = 0;
  _off64_t start = 0;
d193 1
a193 31
	if (!DeviceIoControl (get_handle (),
			      IOCTL_DISK_GET_DRIVE_GEOMETRY,
			      NULL, 0,
			      &di, sizeof (di),
			      &bytes_read, NULL))
	  {
	    __seterrno ();
	    return -1;
	  }
	debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
		      di.Cylinders.LowPart,
		      di.TracksPerCylinder,
		      di.SectorsPerTrack,
		      di.BytesPerSector);
	if (DeviceIoControl (get_handle (),
			     IOCTL_DISK_GET_PARTITION_INFO,
			     NULL, 0,
			     &pi, sizeof (pi),
			     &bytes_read, NULL))
	  {
	    debug_printf ("partition info: %ld (%ld)",
			  pi.StartingOffset.LowPart,
			  pi.PartitionLength.LowPart);
	    start = pi.StartingOffset.QuadPart >> 9ULL;
	  }
	struct hd_geometry *geo = (struct hd_geometry *) buf;
	geo->heads = di.TracksPerCylinder;
	geo->sectors = di.SectorsPerTrack;
	geo->cylinders = di.Cylinders.LowPart;
	geo->start = start;
	return 0;
a198 30
	if (!DeviceIoControl (get_handle (),
			      IOCTL_DISK_GET_DRIVE_GEOMETRY,
			      NULL, 0,
			      &di, sizeof (di),
			      &bytes_read, NULL))
	  {
	    __seterrno ();
	    return -1;
	  }
	debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
		      di.Cylinders.LowPart,
		      di.TracksPerCylinder,
		      di.SectorsPerTrack,
		      di.BytesPerSector);
	if (DeviceIoControl (get_handle (),
			     IOCTL_DISK_GET_PARTITION_INFO,
			     NULL, 0,
			     &pi, sizeof (pi),
			     &bytes_read, NULL))
	  {
	    debug_printf ("partition info: %ld (%ld)",
			  pi.StartingOffset.LowPart,
			  pi.PartitionLength.LowPart);
	    drive_size = pi.PartitionLength.QuadPart;
	  }
	else
	  {
	    drive_size = di.Cylinders.QuadPart * di.TracksPerCylinder *
			 di.SectorsPerTrack * di.BytesPerSector;
	  }
d217 1
d223 1
a223 15
	if (!DeviceIoControl (get_handle (),
			      IOCTL_DISK_GET_DRIVE_GEOMETRY,
			      NULL, 0,
			      &di, sizeof (di),
			      &bytes_read, NULL))
	  {
	    __seterrno ();
	    return -1;
	  }
	debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
		      di.Cylinders.LowPart,
		      di.TracksPerCylinder,
		      di.SectorsPerTrack,
		      di.BytesPerSector);
	*(int *)buf = di.BytesPerSector;
@


1.33
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::init): Fix non-ISO
	expression.
	* fhandler_floppy.cc (fhandler_dev_floppy::open): Remove unused
	variable.
	* fhandler_proc.cc (format_proc_meminfo): Fix compiler warning.
@
text
@d19 1
a22 1
#include "cygerrno.h"
@


1.32
log
@	* fhandler.h (class fhandler_dev_raw): Remove is_writing flag.
	Remove declaration of writebuf.
	(class fhandler_dev_floppy): Remove declaration of close.
	* fhandler_floppy.cc (fhandler_dev_floppy::close): Delete.
	(fhandler_dev_floppy::lseek): Remove calls to writebuf.  Set
	eom_detected to false after successful seek.
	* fhandler_raw.cc (fhandler_dev_raw::writebuf): Delete.
	(fhandler_dev_raw::raw_read): Remove calls to writebuf.
	(fhandler_dev_raw::raw_write): Always invalidate buffer.
@
text
@a71 1
  int ret;
@


1.31
log
@	* fhandler.h (class fhandler_dev_raw): Move status bits into protected
	bitfield struct type status_flags.  Drop unused has_written bit.
	Add accessor methods.
	(fhandler_dev_raw::clear): Remove.
	(fhandler_dev_raw::reset_devbuf): Remove.
	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Use accessor method
	for is_writing.
	* fhandler_raw.cc: Use status accessor methods throughout.
	(fhandler_dev_raw::clear): Remove.
	(fhandler_dev_raw::fhandler_dev_raw): Drop clear call.
	(fhandler_dev_raw::~fhandler_dev_raw): Ditto.
	* fhandler_tape.cc: Use mtinfo::status accessor methods throughout.
	(mtinfo_drive::close): Fix conditional to enable BSD semantics
	correctly.
	(mtinfo_drive::get_status): Rename from mtinfo_drive::status.
	* mtinfo.h (class mtinfo_drive): Move status bits into private bitfield
	struct type status_flags.  Add accessor methods.
	Rename status method to get_status.
@
text
@a68 14
int
fhandler_dev_floppy::close (void)
{
  int ret;

  ret = writebuf ();
  if (ret)
    {
      fhandler_dev_raw::close ();
      return ret;
    }
  return fhandler_dev_raw::close ();
}

d133 2
a134 4
      if (is_writing ())
	current_position += devbufend - devbufstart;
      else
	current_position -= devbufend - devbufstart;
a153 3
      ret = writebuf ();
      if (ret)
	return ret;
d165 1
@


1.30
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d147 1
a147 1
      if (is_writing)
@


1.29
log
@	Substitute 0x7fffffff and 0xffffffff by INT32_MAX and UINT32_MAX
	throughout, except in assembler code.
@
text
@d4 1
a4 1
   Copyright 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.28
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d175 1
a175 1
      low = sector_aligned_offset & 0xffffffff;
@


1.27
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d20 1
d45 2
a46 1
fhandler_dev_floppy::fhandler_dev_floppy (int unit) : fhandler_dev_raw (FH_FLOPPY, unit)
d51 1
a51 1
fhandler_dev_floppy::open (path_conv *real_path, int flags, mode_t)
d66 1
a66 1
  return fhandler_dev_raw::open (real_path, flags);
@


1.26
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@a13 1
#include <errno.h>
@


1.25
log
@* uinfo.cc (pwdgrp::load): Regularize strace output.  Add warning for
CreateFile failure.
@
text
@d82 2
a83 2
__off64_t
fhandler_dev_floppy::lseek (__off64_t offset, int whence)
d87 5
a91 5
  __off64_t drive_size = 0;
  __off64_t lloffset = offset;
  __off64_t current_position;
  __off64_t sector_aligned_offset;
  __off64_t bytes_left;
d145 1
a145 1
      current_position = low + ((__off64_t) high << 32);
d198 2
a199 2
  __off64_t drive_size = 0;
  __off64_t start = 0;
d274 1
a274 1
	  *(__off64_t *)buf = drive_size;
@


1.24
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d204 32
a235 32
        debug_printf ("HDIO_GETGEO");
        if (!DeviceIoControl (get_handle (),
                              IOCTL_DISK_GET_DRIVE_GEOMETRY,
                              NULL, 0,
                              &di, sizeof (di),
                              &bytes_read, NULL))
          {
            __seterrno ();
            return -1;
          }
        debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
                      di.Cylinders.LowPart,
                      di.TracksPerCylinder,
                      di.SectorsPerTrack,
                      di.BytesPerSector);
        if (DeviceIoControl (get_handle (),
                             IOCTL_DISK_GET_PARTITION_INFO,
                             NULL, 0,
                             &pi, sizeof (pi),
                             &bytes_read, NULL))
          {
            debug_printf ("partition info: %ld (%ld)",
                          pi.StartingOffset.LowPart,
                          pi.PartitionLength.LowPart);
            start = pi.StartingOffset.QuadPart >> 9ULL;
          }
        struct hd_geometry *geo = (struct hd_geometry *) buf;
        geo->heads = di.TracksPerCylinder;
        geo->sectors = di.SectorsPerTrack;
        geo->cylinders = di.Cylinders.LowPart;
        geo->start = start;
        return 0;
d240 36
a275 36
        debug_printf ("BLKGETSIZE");
        if (!DeviceIoControl (get_handle (),
                              IOCTL_DISK_GET_DRIVE_GEOMETRY,
                              NULL, 0,
                              &di, sizeof (di),
                              &bytes_read, NULL))
          {
            __seterrno ();
            return -1;
          }
        debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
                      di.Cylinders.LowPart,
                      di.TracksPerCylinder,
                      di.SectorsPerTrack,
                      di.BytesPerSector);
        if (DeviceIoControl (get_handle (),
                             IOCTL_DISK_GET_PARTITION_INFO,
                             NULL, 0,
                             &pi, sizeof (pi),
                             &bytes_read, NULL))
          {
            debug_printf ("partition info: %ld (%ld)",
                          pi.StartingOffset.LowPart,
                          pi.PartitionLength.LowPart);
            drive_size = pi.PartitionLength.QuadPart;
          }
        else
          {
            drive_size = di.Cylinders.QuadPart * di.TracksPerCylinder *
                         di.SectorsPerTrack * di.BytesPerSector;
          }
        if (cmd == BLKGETSIZE)
          *(long *)buf = drive_size >> 9UL;
        else
          *(__off64_t *)buf = drive_size;
        return 0;
d279 11
a289 11
        debug_printf ("BLKRRPART");
        if (!DeviceIoControl (get_handle (),
                              IOCTL_DISK_UPDATE_DRIVE_SIZE,
                              NULL, 0,
                              &di, sizeof (di),
                              &bytes_read, NULL))
          {
            __seterrno ();
            return -1;
          }
        return 0;
d293 17
a309 17
        debug_printf ("BLKSSZGET");
        if (!DeviceIoControl (get_handle (),
                              IOCTL_DISK_GET_DRIVE_GEOMETRY,
                              NULL, 0,
                              &di, sizeof (di),
                              &bytes_read, NULL))
          {
            __seterrno ();
            return -1;
          }
        debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
                      di.Cylinders.LowPart,
                      di.TracksPerCylinder,
                      di.SectorsPerTrack,
                      di.BytesPerSector);
        *(int *)buf = di.BytesPerSector;
        return 0;
@


1.24.6.1
log
@merge from trunk
@
text
@d45 1
a45 2
fhandler_dev_floppy::fhandler_dev_floppy ()
  : fhandler_dev_raw ()
@


1.24.6.2
log
@merge from trunk
@
text
@d205 32
a236 32
	debug_printf ("HDIO_GETGEO");
	if (!DeviceIoControl (get_handle (),
			      IOCTL_DISK_GET_DRIVE_GEOMETRY,
			      NULL, 0,
			      &di, sizeof (di),
			      &bytes_read, NULL))
	  {
	    __seterrno ();
	    return -1;
	  }
	debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
		      di.Cylinders.LowPart,
		      di.TracksPerCylinder,
		      di.SectorsPerTrack,
		      di.BytesPerSector);
	if (DeviceIoControl (get_handle (),
			     IOCTL_DISK_GET_PARTITION_INFO,
			     NULL, 0,
			     &pi, sizeof (pi),
			     &bytes_read, NULL))
	  {
	    debug_printf ("partition info: %ld (%ld)",
			  pi.StartingOffset.LowPart,
			  pi.PartitionLength.LowPart);
	    start = pi.StartingOffset.QuadPart >> 9ULL;
	  }
	struct hd_geometry *geo = (struct hd_geometry *) buf;
	geo->heads = di.TracksPerCylinder;
	geo->sectors = di.SectorsPerTrack;
	geo->cylinders = di.Cylinders.LowPart;
	geo->start = start;
	return 0;
d241 36
a276 36
	debug_printf ("BLKGETSIZE");
	if (!DeviceIoControl (get_handle (),
			      IOCTL_DISK_GET_DRIVE_GEOMETRY,
			      NULL, 0,
			      &di, sizeof (di),
			      &bytes_read, NULL))
	  {
	    __seterrno ();
	    return -1;
	  }
	debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
		      di.Cylinders.LowPart,
		      di.TracksPerCylinder,
		      di.SectorsPerTrack,
		      di.BytesPerSector);
	if (DeviceIoControl (get_handle (),
			     IOCTL_DISK_GET_PARTITION_INFO,
			     NULL, 0,
			     &pi, sizeof (pi),
			     &bytes_read, NULL))
	  {
	    debug_printf ("partition info: %ld (%ld)",
			  pi.StartingOffset.LowPart,
			  pi.PartitionLength.LowPart);
	    drive_size = pi.PartitionLength.QuadPart;
	  }
	else
	  {
	    drive_size = di.Cylinders.QuadPart * di.TracksPerCylinder *
			 di.SectorsPerTrack * di.BytesPerSector;
	  }
	if (cmd == BLKGETSIZE)
	  *(long *)buf = drive_size >> 9UL;
	else
	  *(__off64_t *)buf = drive_size;
	return 0;
d280 11
a290 11
	debug_printf ("BLKRRPART");
	if (!DeviceIoControl (get_handle (),
			      IOCTL_DISK_UPDATE_DRIVE_SIZE,
			      NULL, 0,
			      &di, sizeof (di),
			      &bytes_read, NULL))
	  {
	    __seterrno ();
	    return -1;
	  }
	return 0;
d294 17
a310 17
	debug_printf ("BLKSSZGET");
	if (!DeviceIoControl (get_handle (),
			      IOCTL_DISK_GET_DRIVE_GEOMETRY,
			      NULL, 0,
			      &di, sizeof (di),
			      &bytes_read, NULL))
	  {
	    __seterrno ();
	    return -1;
	  }
	debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
		      di.Cylinders.LowPart,
		      di.TracksPerCylinder,
		      di.SectorsPerTrack,
		      di.BytesPerSector);
	*(int *)buf = di.BytesPerSector;
	return 0;
@


1.24.6.3
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@a20 1
#include "path.h"
d51 1
a51 1
fhandler_dev_floppy::open (int flags, mode_t)
d66 1
a66 1
  return fhandler_dev_raw::open (flags);
@


1.24.6.4
log
@merge from trunk
@
text
@d84 2
a85 2
_off64_t
fhandler_dev_floppy::lseek (_off64_t offset, int whence)
d89 5
a93 5
  _off64_t drive_size = 0;
  _off64_t lloffset = offset;
  _off64_t current_position;
  _off64_t sector_aligned_offset;
  _off64_t bytes_left;
d147 1
a147 1
      current_position = low + ((_off64_t) high << 32);
d200 2
a201 2
  _off64_t drive_size = 0;
  _off64_t start = 0;
d276 1
a276 1
	  *(_off64_t *)buf = drive_size;
@


1.24.6.5
log
@merge from trunk
@
text
@d14 1
@


1.24.4.1
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d45 1
a45 1
fhandler_dev_floppy::fhandler_dev_floppy () : fhandler_dev_raw (FH_FLOPPY)
@


1.24.4.2
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d45 1
a45 2
fhandler_dev_floppy::fhandler_dev_floppy ()
  : fhandler_dev_raw ()
@


1.23
log
@	* include/cygwin/fs.h: New file.
	* include/cygwin/hdreg.h: New file.
	* fhandler_floppy.cc (fhandler_floppy::ioctl): Add implementation for
	HDIO_GETGEO, BLKGETSIZE, BLKGETSIZE64, BLKRRPART and BLKSSZGET ioctls.
@
text
@d182 4
a185 1
      return sector_aligned_offset + raw_read (buf, bytes_left);
@


1.22
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d17 3
d192 119
a310 1
  return fhandler_dev_raw::ioctl (cmd, buf);
@


1.21
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d96 1
a96 1
  if (!DeviceIoControl (get_handle(),
@


1.20
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@a13 1
#include <fcntl.h>
@


1.19
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d80 2
a81 2
__off32_t
fhandler_dev_floppy::lseek (__off32_t offset, int whence)
d85 5
a89 5
  long long drive_size = 0;
  long long lloffset = offset;
  long long current_position;
  __off32_t sector_aligned_offset;
  __off32_t bytes_left;
d120 1
a120 1
      drive_size = (long long) pi.PartitionLength.QuadPart;
d124 1
a124 1
      drive_size = (long long) di.Cylinders.QuadPart * di.TracksPerCylinder *
d143 1
a143 1
      current_position = (long long) low + ((long long) high << 32);
a158 8
  high = lloffset >> 32;
  low = lloffset & 0xffffffff;
  if (high || (__off32_t) low < 0)
    {
      set_errno (EFBIG);
      return -1;
    }
  offset = (__off32_t) low;
d161 2
a162 2
  sector_aligned_offset = (offset / 512) * 512;
  bytes_left = offset - sector_aligned_offset;
d172 4
a175 2
      if (SetFilePointer (get_handle (), sector_aligned_offset, NULL, FILE_BEGIN)
	  == INVALID_SET_FILE_POINTER)
@


1.18
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d4 1
a4 1
   Copyright 1999, 2000, 2001 Red Hat, Inc.
@


1.17
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d80 2
a81 2
off_t
fhandler_dev_floppy::lseek (off_t offset, int whence)
d88 2
a89 2
  off_t sector_aligned_offset;
  off_t bytes_left;
d161 1
a161 1
  if (high || (off_t) low < 0)
d166 1
a166 1
  offset = (off_t) low;
@


1.16
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@a44 1
  set_cb (sizeof *this);
@


1.15
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d43 1
a43 1
fhandler_dev_floppy::fhandler_dev_floppy (const char *name, int unit) : fhandler_dev_raw (FH_FLOPPY, name, unit)
@


1.14
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d49 1
a49 1
fhandler_dev_floppy::open (const char *path, int flags, mode_t)
d64 1
a64 1
  return fhandler_dev_raw::open (path, flags);
@


1.14.4.1
log
@Merged changes from HEAD
@
text
@d43 1
a43 1
fhandler_dev_floppy::fhandler_dev_floppy (int unit) : fhandler_dev_raw (FH_FLOPPY, unit)
d45 1
d49 1
a49 1
fhandler_dev_floppy::open (path_conv *real_path, int flags, mode_t)
d64 1
a64 1
  return fhandler_dev_raw::open (real_path, flags);
@


1.14.4.2
log
@Merged changes from HEAD
@
text
@d4 1
a4 1
   Copyright 1999, 2000, 2001, 2002 Red Hat, Inc.
d80 2
a81 2
__off64_t
fhandler_dev_floppy::lseek (__off64_t offset, int whence)
d85 5
a89 5
  __off64_t drive_size = 0;
  __off64_t lloffset = offset;
  __off64_t current_position;
  __off64_t sector_aligned_offset;
  __off64_t bytes_left;
d120 1
a120 1
      drive_size = pi.PartitionLength.QuadPart;
d124 1
a124 1
      drive_size = di.Cylinders.QuadPart * di.TracksPerCylinder *
d143 1
a143 1
      current_position = low + ((__off64_t) high << 32);
d159 8
d169 2
a170 2
  sector_aligned_offset = (lloffset / 512) * 512;
  bytes_left = lloffset - sector_aligned_offset;
d180 2
a181 4
      low = sector_aligned_offset & 0xffffffff;
      high = sector_aligned_offset >> 32;
      if (SetFilePointer (get_handle (), low, &high, FILE_BEGIN)
	  == INVALID_SET_FILE_POINTER && GetLastError ())
@


1.14.4.3
log
@Merged changes from HEAD
@
text
@d14 1
@


1.14.4.4
log
@Merged changes from HEAD
@
text
@d96 1
a96 1
  if (!DeviceIoControl (get_handle (),
@


1.13
log
@        * fhandler_floppy.cc (fhandler_floppy::lseek): Remove iswinnt check.
@
text
@d182 2
a183 2
          == INVALID_SET_FILE_POINTER)
        {
@


1.12
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d94 23
a116 1
  if (iswinnt)
d118 9
a126 35
      DISK_GEOMETRY di;
      PARTITION_INFORMATION pi;
      DWORD bytes_read;

      if (!DeviceIoControl (get_handle(),
                              IOCTL_DISK_GET_DRIVE_GEOMETRY,
                              NULL, 0,
                              &di, sizeof (di),
                              &bytes_read, NULL))
        {
          __seterrno ();
          return -1;
        }
      debug_printf ("disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
                     di.Cylinders.LowPart,
                     di.TracksPerCylinder,
                     di.SectorsPerTrack,
                     di.BytesPerSector);
      if (DeviceIoControl (get_handle (),
                             IOCTL_DISK_GET_PARTITION_INFO,
                             NULL, 0,
                             &pi, sizeof (pi),
                             &bytes_read, NULL))
        {
          debug_printf ("partition info: %ld (%ld)",
                          pi.StartingOffset.LowPart,
                          pi.PartitionLength.LowPart);
          drive_size = (long long) pi.PartitionLength.QuadPart;
        }
      else
        {
          drive_size = (long long) di.Cylinders.QuadPart * di.TracksPerCylinder *
                       di.SectorsPerTrack * di.BytesPerSector;
        }
      debug_printf ("drive size: %ld", drive_size);
d128 1
@


1.11
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d94 1
a94 1
  if (os_being_run == winNT)
@


1.10
log
@forced commit
@
text
@d17 2
a20 1
#include <winioctl.h>
@


1.9
log
@Update copyrights.
@
text
@@


1.8
log
@*** empty log message ***
@
text
@d4 1
a4 1
   Copyright 1999, 2000 Cygnus Solutions.
@


1.7
log
@* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Determine
drive geometry or partition size to allow seeking from the end of
raw floppy device. Don't allow positioning past the end of media or
to offsets bigger then max off_t.
@
text
@d99 1
a99 1
      if ( !DeviceIoControl ( get_handle(),
d103 1
a103 1
                              &bytes_read, NULL) )
d108 1
a108 1
      debug_printf ( "disk geometry: (%ld cyl)*(%ld trk)*(%ld sec)*(%ld bps)",
d112 2
a113 2
                     di.BytesPerSector );
      if ( DeviceIoControl ( get_handle (),
d117 1
a117 1
                             &bytes_read, NULL ))
d119 1
a119 1
          debug_printf ( "partition info: %ld (%ld)",
d129 1
a129 1
      debug_printf ( "drive size: %ld", drive_size );
d135 1
a135 1
      whence = SEEK_SET; 
d164 1
a164 1
  if ( high || (off_t) low < 0 )
@


1.6
log
@        * fhandler.cc (fhandler_base::open): Always add GENERIC_READ access
        when opening raw disk devices.
        * fhandler_floppy.cc (fhandler_dev_floppy::lseek): Implement bytewise
        access.
        * fhandler_raw.cc (fhandler_dev_raw::open): Always open raw disk device
        binary.
        (fhandler_dev_raw::raw_write): Don't drop read buffer content when
        writing after read.
@
text
@d19 1
a83 1
  DWORD off;
d85 7
d93 1
a93 1
  if (whence == SEEK_SET)
d95 23
a117 1
      if (offset < 0)
d119 6
a124 14
	  set_errno (EINVAL);
	  return -1;
	}

      /* Invalidate buffer. */
      ret = writebuf ();
      if (ret)
	return ret;
      devbufstart = devbufend = 0;

      off = (offset / 512) * 512;

      if (SetFilePointer (get_handle (), off, NULL, FILE_BEGIN)
          == INVALID_SET_FILE_POINTER)
d126 4
a129 4
	  __seterrno ();
	  return -1;
	}
      return raw_read (buf, offset - off);
d131 2
a132 1
  else if (whence == SEEK_CUR)
d134 3
a136 2
      DWORD low;
      LONG high = 0;
d138 2
d146 1
a146 1
      long long cur = (long long) high << 32 + low;
d148 1
a148 1
	cur += devbufend - devbufstart;
d150 27
a176 2
	cur -= devbufend - devbufstart;
      
d183 3
a185 16
      cur += offset;
      if (cur < 0)
	{
	  set_errno (EINVAL);
	  return -1;
	}

      long long set = (cur / 512) * 512;
      high = set >> 32;
      low = set & 0xffffffff;

      off = cur - set;

      low = SetFilePointer (get_handle (), low, &high, FILE_BEGIN);
      if (low == INVALID_SET_FILE_POINTER && GetLastError ())
	{
d189 1
a189 1
      return raw_read (buf, off);
d191 1
a191 1
  /* SEEK_END is not supported on raw disk devices. */
@


1.5
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d18 1
d82 75
a156 3
  /* FIXME: Need to implement better. */
  offset = (offset / 512) * 512;
  return fhandler_base::lseek (offset, whence);
@


1.4
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d17 1
@


1.3
log
@* exceptions.cc (interruptible): Change method for determining if something is
interruptible.
(call_handler): Avoid suspending a thread if it owns a mutex.  Only set
signal_arrived if the thread was actually interrupted.
(events_init): Initialize module information needed by interruptible().
(sigdelayed): Don't call sig_dispatch_pending since it could screw up
* init.cc (dll_entry): Record module handle of main for use by interruptible().
(proc_subproc): Reorganize handling of terminated child so that the bulk of the
processing comes from the signal thread.
(wait_sig): Force processing of waiting threads if SIGCHLD is not processed.
* sync.cc (muto::release): Set tid == 0 after lock is released or signal
processor will be confused.
@
text
@d12 1
a16 1
#include "winsup.h"
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d4 1
a4 1
   Copyright 1999 Cygnus Solutions.
@


1.1
log
@Initial revision
@
text
@d31 1
a31 1
fhandler_dev_floppy::is_eof (int win_error)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
