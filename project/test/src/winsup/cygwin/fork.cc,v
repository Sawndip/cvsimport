head	1.245;
access;
symbols
	cygwin-1_7_35-release:1.245
	cygwin-1_7_34-release:1.245
	cygwin-1_7_33-release:1.245
	cygwin-1_7_32-release:1.245
	cygwin-1_7_31-release:1.245
	cygwin-1_7_30-release:1.245
	cygwin-1_7_29-release:1.245
	cygwin-1_7_29-release-branchpoint:1.245.0.2
	cygwin-pre-user-db:1.245
	cygwin-1_7_28-release:1.245
	cygwin-1_7_27-release:1.244
	cygwin-1_7_26-release:1.244
	cygwin-1_7_25-release:1.244
	cygwin-1_7_24-release:1.244
	cygwin-1_7_23-release:1.244
	cygwin-1_7_22-release:1.244
	cygwin-1_7_21-release:1.244
	cygwin-1_7_20-release:1.243
	cygwin-1_7_19-release:1.243
	cygwin-64bit-postmerge:1.240
	cygwin-64bit-premerge-branch:1.239.0.2
	cygwin-64bit-premerge:1.239
	cygwin-1_7_18-release:1.239
	post-ptmalloc3:1.237.2.5
	pre-ptmalloc3:1.237.2.4
	cygwin-1_7_17-release:1.237
	cygwin-64bit-branch:1.237.0.2
	cygwin-1_7_16-release:1.237
	cygwin-1_7_15-release:1.237
	cygwin-1_7_14_2-release:1.236
	cygwin-1_7_14-release:1.236
	cygwin-1_7_12-release:1.236
	cygwin-1_7_11-release:1.232
	cygwin-1_7_10-release:1.231
	signal-rewrite:1.227.0.2
	pre-notty:1.226
	cygwin-1_7_9-release:1.215
	cv-post-1_7_9:1.215.0.2
	cygwin-1_7_8-release:1.215
	cygwin-1_7_7-release:1.213
	cygwin-1_7_5-release:1.210
	cygwin-1_7_4-release:1.210
	cygwin-1_7_3-release:1.210
	cygwin-1_7_2-release:1.210
	fifo_doover3:1.210.0.2
	cygwin-1_7_1-release:1.209
	prefifo:1.206
	cv-branch-2:1.205.0.2
	pre-ripout-set_console_state_for_spawn:1.200
	EOL_registry_mounts:1.198
	preoverlapped:1.193
	drop_9x_support_start:1.189
	cr-0x5f1:1.185.0.2
	cv-branch:1.183.0.2
	pre-ptymaster-archetype:1.183
	cr-0x3b58:1.175.0.4
	cr-0x5ef:1.175.0.2
	after-mmap-privanon-noreserve:1.172
	after-mmap-revamp:1.172
	before-mmap-revamp:1.172
	cgf-more-exit-sync:1.166
	post_wait_sig_exit:1.164
	pre_wait_sig_exit:1.163
	reparent-point:1.137
	noreparent:1.137.0.2
	cr-0x5e6:1.131.0.2
	cr-0x9e:1.123.0.4
	cr-0x9d:1.123.0.2
	cgf-deleteme:1.122.0.2
	pre-sigrewrite:1.114
	corinna-01:1.114
	cr-0x9c:1.112.0.4
	cr-0x9b:1.112.0.2
	cr-0x99:1.111
	Z-emcb-cygwin_daemon:1.111.0.2
	w32api-2_2:1.104
	mingw-runtime-2_4:1.104
	pre-cgf-merge:1.112
	cgf-dev-branch:1.104.0.12
	predaemon:1.77
	cygwin_daemon_merge_HEAD:1.77
	pregp02r1:1.77.0.2
	cygnus_cvs_20020108_pre:1.76
	Z-cygwin_daemon_merge-new_HEAD:1.94
	Z-cygwin_daemon_merge_HEAD:1.94
	cygwin_daemon:1.68.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.245
date	2013.12.18.03.58.11;	author cgf;	state Exp;
branches;
next	1.244;

1.244
date	2013.06.27.17.00.12;	author corinna;	state Exp;
branches;
next	1.243;

1.243
date	2013.05.24.08.43.43;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2013.05.23.20.47.44;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2013.05.23.20.10.35;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.239;

1.239
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.238;

1.238
date	2012.12.27.17.25.17;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2012.05.08.15.06.43;	author cgf;	state Exp;
branches
	1.237.2.1;
next	1.236;

1.236
date	2012.03.21.15.54.49;	author cgf;	state Exp;
branches;
next	1.235;

1.235
date	2012.03.20.23.13.40;	author cgf;	state Exp;
branches;
next	1.234;

1.234
date	2012.03.20.15.07.29;	author cgf;	state Exp;
branches;
next	1.233;

1.233
date	2012.03.16.20.20.27;	author cgf;	state Exp;
branches;
next	1.232;

1.232
date	2012.02.20.14.08.37;	author corinna;	state Exp;
branches;
next	1.231;

1.231
date	2012.01.11.19.07.10;	author cgf;	state Exp;
branches;
next	1.230;

1.230
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2011.11.24.21.36.52;	author cgf;	state Exp;
branches;
next	1.228;

1.228
date	2011.11.14.01.29.48;	author cgf;	state Exp;
branches;
next	1.227;

1.227
date	2011.07.04.15.25.36;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.225;

1.225
date	2011.05.30.16.09.29;	author cgf;	state Exp;
branches;
next	1.224;

1.224
date	2011.05.30.06.52.12;	author cgf;	state Exp;
branches;
next	1.223;

1.223
date	2011.05.30.06.24.53;	author cgf;	state Exp;
branches;
next	1.222;

1.222
date	2011.05.28.20.41.51;	author cgf;	state Exp;
branches;
next	1.221;

1.221
date	2011.05.28.20.17.09;	author cgf;	state Exp;
branches;
next	1.220;

1.220
date	2011.05.28.20.09.03;	author cgf;	state Exp;
branches;
next	1.219;

1.219
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2011.05.20.07.23.11;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2011.05.10.10.17.30;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2011.05.05.15.03.54;	author cgf;	state Exp;
branches;
next	1.215;

1.215
date	2010.09.01.21.06.36;	author cgf;	state Exp;
branches;
next	1.214;

1.214
date	2010.09.01.18.24.10;	author cgf;	state Exp;
branches;
next	1.213;

1.213
date	2010.06.29.10.28.40;	author corinna;	state Exp;
branches;
next	1.212;

1.212
date	2010.06.28.18.32.12;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2010.05.18.14.30.51;	author cgf;	state Exp;
branches;
next	1.210;

1.210
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.209;

1.209
date	2009.11.17.10.43.00;	author corinna;	state Exp;
branches;
next	1.208;

1.208
date	2009.10.14.04.17.05;	author ericb;	state Exp;
branches;
next	1.207;

1.207
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2009.07.20.14.16.06;	author corinna;	state Exp;
branches;
next	1.205;

1.205
date	2009.06.08.19.45.39;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2009.06.08.03.53.40;	author cgf;	state Exp;
branches;
next	1.203;

1.203
date	2009.03.24.12.18.34;	author corinna;	state Exp;
branches;
next	1.202;

1.202
date	2009.01.21.17.14.37;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2009.01.03.05.12.20;	author cgf;	state Exp;
branches;
next	1.200;

1.200
date	2008.04.30.09.51.38;	author corinna;	state Exp;
branches;
next	1.199;

1.199
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.197;

1.197
date	2008.03.31.18.03.25;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2008.03.24.14.48.58;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2008.03.07.11.24.51;	author corinna;	state Exp;
branches;
next	1.194;

1.194
date	2008.02.25.18.32.23;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2007.07.07.16.43.03;	author cgf;	state Exp;
branches;
next	1.192;

1.192
date	2007.03.01.18.43.38;	author cgf;	state Exp;
branches;
next	1.191;

1.191
date	2007.02.23.15.15.49;	author corinna;	state Exp;
branches;
next	1.190;

1.190
date	2007.02.22.12.34.55;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2007.01.12.15.26.02;	author corinna;	state Exp;
branches;
next	1.188;

1.188
date	2006.12.12.16.27.32;	author corinna;	state Exp;
branches;
next	1.187;

1.187
date	2006.12.11.18.55.28;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2006.12.05.10.59.21;	author corinna;	state Exp;
branches;
next	1.185;

1.185
date	2006.07.14.22.15.12;	author cgf;	state Exp;
branches
	1.185.2.1;
next	1.184;

1.184
date	2006.07.06.17.16.36;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2006.03.29.06.35.25;	author cgf;	state Exp;
branches
	1.183.2.1;
next	1.182;

1.182
date	2006.03.22.16.42.45;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2006.03.18.19.17.21;	author cgf;	state Exp;
branches;
next	1.180;

1.180
date	2006.03.15.00.29.14;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2006.03.14.21.01.35;	author cgf;	state Exp;
branches;
next	1.178;

1.178
date	2006.03.13.21.10.14;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2006.03.13.18.29.48;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2006.03.12.23.57.04;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2005.12.29.20.46.34;	author cgf;	state Exp;
branches;
next	1.174;

1.174
date	2005.12.23.01.24.14;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2005.12.17.04.36.39;	author cgf;	state Exp;
branches;
next	1.172;

1.172
date	2005.11.17.16.36.00;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2005.11.14.04.28.44;	author cgf;	state Exp;
branches;
next	1.170;

1.170
date	2005.11.04.17.38.32;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2005.10.29.20.33.59;	author cgf;	state Exp;
branches;
next	1.168;

1.168
date	2005.10.29.15.19.34;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2005.10.21.14.08.19;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2005.09.30.00.18.30;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2005.09.28.15.18.49;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2005.09.16.01.47.08;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2005.09.05.17.30.04;	author cgf;	state Exp;
branches;
next	1.162;

1.162
date	2005.09.02.17.35.21;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2005.09.02.17.12.35;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2005.09.02.04.51.09;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2005.09.02.04.46.50;	author cgf;	state Exp;
branches;
next	1.158;

1.158
date	2005.08.11.16.30.48;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2005.07.29.14.22.56;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2005.07.17.00.51.03;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2005.07.06.20.05.01;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2005.06.15.22.50.31;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2005.06.01.03.46.56;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2005.05.18.23.30.02;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2005.04.14.17.08.02;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2005.04.03.13.06.41;	author corinna;	state Exp;
branches;
next	1.149;

1.149
date	2005.04.01.16.52.48;	author corinna;	state Exp;
branches;
next	1.148;

1.148
date	2005.04.01.15.27.52;	author cgf;	state Exp;
branches;
next	1.147;

1.147
date	2005.04.01.11.47.00;	author corinna;	state Exp;
branches;
next	1.146;

1.146
date	2005.03.22.19.00.30;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2005.02.20.04.25.32;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2005.01.25.22.45.09;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2005.01.12.22.40.45;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2004.12.23.14.57.07;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2004.12.06.00.29.38;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2004.12.05.19.41.24;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2004.12.03.04.46.00;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2004.11.26.04.15.08;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2004.10.28.17.34.29;	author cgf;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2004.09.14.23.44.49;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2004.09.14.02.21.09;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2004.09.12.03.47.56;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2004.08.31.03.34.04;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2004.08.30.22.08.50;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2004.03.07.04.57.47;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2004.02.18.22.32.15;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2004.02.17.21.17.25;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2004.02.14.04.38.37;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2004.02.12.03.01.58;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2004.02.06.10.37.37;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2004.02.01.18.29.11;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2004.01.19.05.46.54;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2004.01.14.15.45.36;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2004.01.03.18.53.48;	author cgf;	state Exp;
branches
	1.122.2.1;
next	1.121;

1.121
date	2004.01.03.18.15.03;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2003.12.30.01.57.16;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2003.12.23.22.24.38;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2003.12.14.07.09.22;	author cgf;	state Exp;
branches;
next	1.116;

1.116
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.26.03.20.30;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2003.09.09.03.11.31;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2003.08.25.18.21.07;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2003.07.02.03.16.00;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2003.06.30.13.07.36;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2003.04.24.01.57.07;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2003.03.26.04.18.01;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2003.03.22.01.45.18;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2002.10.22.20.16.31;	author cgf;	state Exp;
branches
	1.104.12.1;
next	1.103;

1.103
date	2002.10.22.16.18.55;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2002.10.21.01.00.56;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2002.10.19.18.29.37;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2002.10.19.00.57.06;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2002.10.18.23.52.58;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2002.10.15.07.03.44;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2002.10.14.20.25.52;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2002.10.09.04.08.05;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2002.09.30.04.35.17;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2002.09.19.15.12.48;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2002.09.17.09.12.36;	author rbcollins;	state Exp;
branches;
next	1.91;

1.91
date	2002.08.18.05.49.25;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2002.08.16.19.41.39;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2002.08.11.19.19.29;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2002.07.13.20.00.26;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2002.07.09.04.37.13;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2002.06.16.23.34.43;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2002.06.15.21.59.32;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2002.05.06.10.05.46;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2002.04.09.16.33.13;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2002.03.11.17.57.22;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2002.02.28.14.25.53;	author rbcollins;	state Exp;
branches;
next	1.77;

1.77
date	2002.02.19.05.58.44;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2001.11.25.03.28.16;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2001.11.05.06.09.07;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2001.10.14.15.49.13;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2001.10.10.02.32.12;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2001.10.05.04.37.33;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2001.10.05.04.36.14;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2001.09.22.16.55.02;	author cgf;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2001.09.15.00.47.44;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2001.09.14.04.39.56;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2001.09.14.04.37.57;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2001.09.14.00.49.00;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2001.09.11.08.15.39;	author rbcollins;	state Exp;
branches;
next	1.61;

1.61
date	2001.09.09.03.34.36;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2001.09.06.03.39.18;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2001.09.01.05.17.34;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2001.07.21.03.20.01;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2001.07.18.17.05.34;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.17.03.41.52;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.24.21.57.50;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.18.21.18.59;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.12.11.31.05;	author duda;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.20.01.19.20;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.15.19.23.31;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2001.04.30.21.19.42;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2001.04.13.15.28.20;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.18.03.34.05;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.10.04.20.52;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.16.05.21.03;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2000.11.16.05.16.59;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.15.21.04.02;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.15.06.46.19;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.15.06.27.48;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.15.00.13.08;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.06.06.36.32;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2000.10.26.10.13.41;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.25.03.54.50;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2000.10.23.03.35.50;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.21.04.53.49;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.15.01.37.06;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.14.05.52.38;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.12.22.15.47;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.12.04.38.29;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2000.09.30.04.54.11;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.01.20.54.22;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.09.02.33.47;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.03.03.02.41;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.29.16.24.38;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.19.20.14.24;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.15.02.48.11;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.03.20.16.23;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.03.20.14.06;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.02.10.17.44;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.24.17.37.52;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.16.19.36.07;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.08.04.13.12;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.24.02.49.44;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.23.04.07.13;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.237.2.1
date	2012.11.08.17.25.47;	author corinna;	state Exp;
branches;
next	1.237.2.2;

1.237.2.2
date	2012.12.10.11.45.49;	author corinna;	state Exp;
branches;
next	1.237.2.3;

1.237.2.3
date	2013.01.09.16.27.21;	author corinna;	state Exp;
branches;
next	1.237.2.4;

1.237.2.4
date	2013.01.21.13.52.06;	author corinna;	state Exp;
branches;
next	1.237.2.5;

1.237.2.5
date	2013.02.27.08.36.58;	author corinna;	state Exp;
branches;
next	1.237.2.6;

1.237.2.6
date	2013.03.13.16.51.25;	author corinna;	state Exp;
branches;
next	1.237.2.7;

1.237.2.7
date	2013.04.10.12.29.48;	author corinna;	state Exp;
branches;
next	1.237.2.8;

1.237.2.8
date	2013.04.23.09.06.12;	author corinna;	state Exp;
branches;
next	;

1.185.2.1
date	2006.12.05.11.33.59;	author corinna;	state Exp;
branches;
next	1.185.2.2;

1.185.2.2
date	2007.01.12.19.44.19;	author corinna;	state Exp;
branches;
next	1.185.2.3;

1.185.2.3
date	2007.01.15.11.56.07;	author corinna;	state Exp;
branches;
next	1.185.2.4;

1.185.2.4
date	2007.11.15.20.32.12;	author corinna;	state Exp;
branches;
next	;

1.183.2.1
date	2006.07.06.19.10.32;	author corinna;	state Exp;
branches;
next	1.183.2.2;

1.183.2.2
date	2006.07.18.10.33.54;	author corinna;	state Exp;
branches;
next	;

1.137.2.1
date	2004.11.16.06.02.05;	author cgf;	state Exp;
branches;
next	1.137.2.2;

1.137.2.2
date	2004.11.18.00.48.40;	author cgf;	state Exp;
branches;
next	1.137.2.3;

1.137.2.3
date	2004.11.20.18.35.10;	author cgf;	state Exp;
branches;
next	1.137.2.4;

1.137.2.4
date	2004.11.24.05.48.30;	author cgf;	state Exp;
branches;
next	;

1.122.2.1
date	2004.01.11.18.13.52;	author cgf;	state Exp;
branches;
next	1.122.2.2;

1.122.2.2
date	2004.01.19.05.38.24;	author cgf;	state Exp;
branches;
next	;

1.104.12.1
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.104.12.2;

1.104.12.2
date	2003.03.22.01.45.51;	author cgf;	state Exp;
branches;
next	1.104.12.3;

1.104.12.3
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.104.12.4;

1.104.12.4
date	2003.05.10.17.20.53;	author cgf;	state Exp;
branches;
next	1.104.12.5;

1.104.12.5
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.104.12.6;

1.104.12.6
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.104.12.7;

1.104.12.7
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	;

1.68.2.1
date	2001.09.25.06.31.04;	author rbcollins;	state Exp;
branches;
next	1.68.2.2;

1.68.2.2
date	2001.10.02.12.09.54;	author rbcollins;	state Exp;
branches;
next	1.68.2.3;

1.68.2.3
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.68.2.4;

1.68.2.4
date	2002.02.28.12.53.24;	author rbcollins;	state Exp;
branches;
next	1.68.2.5;

1.68.2.5
date	2002.06.13.14.34.06;	author rbcollins;	state Exp;
branches;
next	1.68.2.6;

1.68.2.6
date	2002.06.18.00.17.07;	author scottc;	state Exp;
branches;
next	1.68.2.7;

1.68.2.7
date	2002.07.09.12.01.02;	author scottc;	state Exp;
branches;
next	1.68.2.8;

1.68.2.8
date	2002.07.13.20.39.24;	author scottc;	state Exp;
branches;
next	1.68.2.9;

1.68.2.9
date	2002.08.12.14.06.34;	author scottc;	state Exp;
branches;
next	1.68.2.10;

1.68.2.10
date	2002.08.16.21.46.48;	author scottc;	state Exp;
branches;
next	1.68.2.11;

1.68.2.11
date	2002.08.18.12.09.27;	author scottc;	state Exp;
branches;
next	1.68.2.12;

1.68.2.12
date	2002.09.17.09.54.50;	author scottc;	state Exp;
branches;
next	1.68.2.13;

1.68.2.13
date	2002.09.19.21.51.22;	author scottc;	state Exp;
branches;
next	1.68.2.14;

1.68.2.14
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.245
log
@* external.cc (fillout_pinfo): Remove nonsensical loop.
* fork.cc (frok::parent): When initializing pinfo for child new PID_NEW flag +
actual defined constant rather than raw number.  Don't set start_time here.
* pinfo.cc (pinfo::thisproc): Use PID_NEW when initializing pinfo.  Avoid
checking h for NULL multiple times.  Don't set start_time here.
(pinfo_init): Aways set ppid last.  Tweak strace output.
(pinfo::init): Handle new PID_NEW flag.  Wait for shared memory to contain
useful information.  Set start_time if PID_NEW.
(_onreturn:h): Define as HANDLE rather than HANDLE *.
(_onreturn::~onreturn): Accommodate h definition change.
(_onreturn::no_close_handle): Rename from no_close_p_handle.  Take a pinfo arg
and set hProcess to h before zeroing.
(winpids::add): Don't open a handle to our own process.  Change logic
associated with when a handle gets closed.  Accommodate no_close_handle
changes.
(winpids::enum_processes): Simplify process enumeration loop.
(winpids::set): Eliminate ill-considered malloc locking.
* sigproc.cc (proc_subproc): Always set ppid last.
@
text
@/* fork.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include "cygerrno.h"
#include "sigproc.h"
#include "pinfo.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "child_info.h"
#include "cygtls.h"
#include "tls_pbuf.h"
#include "dll_init.h"
#include "cygmalloc.h"
#include "ntdll.h"

#define NPIDS_HELD 4

/* Timeout to wait for child to start, parent to init child, etc.  */
/* FIXME: Once things stabilize, bump up to a few minutes.  */
#define FORK_WAIT_TIMEOUT (300 * 1000)     /* 300 seconds */

class frok
{
  bool load_dlls;
  child_info_fork ch;
  const char *errmsg;
  int child_pid;
  int this_errno;
  HANDLE hchild;
  int __stdcall parent (volatile char * volatile here);
  int __stdcall child (volatile char * volatile here);
  bool error (const char *fmt, ...);
  friend int fork ();
};

static void
resume_child (HANDLE forker_finished)
{
  SetEvent (forker_finished);
  debug_printf ("signalled child");
  return;
}

/* Notify parent that it is time for the next step. */
static void __stdcall
sync_with_parent (const char *s, bool hang_self)
{
  debug_printf ("signalling parent: %s", s);
  fork_info->ready (false);
  if (hang_self)
    {
      HANDLE h = fork_info->forker_finished;
      /* Wait for the parent to fill in our stack and heap.
	 Don't wait forever here.  If our parent dies we don't want to clog
	 the system.  If the wait fails, we really can't continue so exit.  */
      DWORD psync_rc = WaitForSingleObject (h, FORK_WAIT_TIMEOUT);
      debug_printf ("awake");
      switch (psync_rc)
	{
	case WAIT_TIMEOUT:
	  api_fatal ("WFSO timed out %s", s);
	  break;
	case WAIT_FAILED:
	  if (GetLastError () == ERROR_INVALID_HANDLE &&
	      WaitForSingleObject (fork_info->forker_finished, 1) != WAIT_FAILED)
	    break;
	  api_fatal ("WFSO failed %s, fork_finished %p, %E", s,
		     fork_info->forker_finished);
	  break;
	default:
	  debug_printf ("no problems");
	  break;
	}
    }
}

bool
frok::error (const char *fmt, ...)
{
  DWORD exit_code = ch.exit_code;
  if (!exit_code && hchild)
    {
      exit_code = ch.proc_retry (hchild);
      if (!exit_code)
	return false;
    }
  if (exit_code != EXITCODE_FORK_FAILED)
    {
      va_list ap;
      static char buf[NT_MAX_PATH + 256];
      va_start (ap, fmt);
      __small_vsprintf (buf, fmt, ap);
      errmsg = buf;
    }
  return true;
}

/* Set up a pipe which will track the life of a "pid" through
   even after we've exec'ed.  */
void
child_info::prefork (bool detached)
{
  if (!detached)
    {
      if (!CreatePipe (&rd_proc_pipe, &wr_proc_pipe, &sec_none_nih, 16))
	api_fatal ("prefork: couldn't create pipe process tracker, %E");

      if (!SetHandleInformation (wr_proc_pipe, HANDLE_FLAG_INHERIT,
				 HANDLE_FLAG_INHERIT))
	api_fatal ("prefork: couldn't set process pipe(%p) inherit state, %E",
		   wr_proc_pipe);
      ProtectHandle1 (rd_proc_pipe, rd_proc_pipe);
      ProtectHandle1 (wr_proc_pipe, wr_proc_pipe);
    }
}

int __stdcall
frok::child (volatile char * volatile here)
{
  HANDLE& hParent = ch.parent;
  extern void fixup_hooks_after_fork ();
  extern void fixup_timers_after_fork ();

  /* NOTE: Logically this belongs in dll_list::load_after_fork, but by
     doing it here, before the first sync_with_parent, we can exploit
     the existing retry mechanism in hopes of getting a more favorable
     address space layout next time. */
  dlls.reserve_space ();

  sync_with_parent ("after longjmp", true);
  debug_printf ("child is running.  pid %d, ppid %d, stack here %p",
		myself->pid, myself->ppid, __builtin_frame_address (0));
  sigproc_printf ("hParent %p, load_dlls %d", hParent, load_dlls);

  /* If we've played with the stack, stacksize != 0.  That means that
     fork() was invoked from other than the main thread.  Make sure that
     the threadinfo information is properly set up.  */
  if (fork_info->stackaddr)
    {
      _main_tls = &_my_tls;
      _main_tls->init_thread (NULL, NULL);
      _main_tls->local_clib = *_impure_ptr;
      _impure_ptr = &_main_tls->local_clib;
    }

  set_cygwin_privileges (hProcToken);
  clear_procimptoken ();
  cygheap->user.reimpersonate ();

#ifdef DEBUGGING
  if (GetEnvironmentVariableA ("FORKDEBUG", NULL, 0))
    try_to_debug ();
  char buf[80];
  /* This is useful for debugging fork problems.  Use gdb to attach to
     the pid reported here. */
  if (GetEnvironmentVariableA ("CYGWIN_FORK_SLEEP", buf, sizeof (buf)))
    {
      small_printf ("Sleeping %d after fork, pid %u\n", atoi (buf), GetCurrentProcessId ());
      Sleep (atoi (buf));
    }
#endif

  MALLOC_CHECK;

  /* Incredible but true:  If we use sockets and SYSV IPC shared memory,
     there's a good chance that a duplicated socket in the child occupies
     memory which is needed to duplicate shared memory from the parent
     process, if the shared memory hasn't been duplicated already.
     The same goes very likely for "normal" mmap shared memory, too, but
     with SYSV IPC it was the first time observed.  So, *never* fixup
     fdtab before fixing up shared memory. */
  if (fixup_shms_after_fork ())
    api_fatal ("recreate_shm areas after fork failed");

  MALLOC_CHECK;

  /* If we haven't dynamically loaded any dlls, just signal
     the parent.  Otherwise, load all the dlls, tell the parent
      that we're done, and wait for the parent to fill in the.
      loaded dlls' data/bss. */
  if (!load_dlls)
    {
      cygheap->fdtab.fixup_after_fork (hParent);
      sync_with_parent ("performed fork fixup", false);
    }
  else
    {
      dlls.load_after_fork (hParent);
      cygheap->fdtab.fixup_after_fork (hParent);
      sync_with_parent ("loaded dlls", true);
    }

  init_console_handler (myself->ctty > 0);
  ForceCloseHandle1 (fork_info->forker_finished, forker_finished);

  pthread::atforkchild ();
  fixup_timers_after_fork ();
  cygbench ("fork-child");
  ld_preload ();
  fixup_hooks_after_fork ();
  _my_tls.fixup_after_fork ();
  /* Clear this or the destructor will close them.  In the case of
     rd_proc_pipe that would be an invalid handle.  In the case of
     wr_proc_pipe it would be == my_wr_proc_pipe.  Both would be bad. */
  ch.rd_proc_pipe = ch.wr_proc_pipe = NULL;
  cygwin_finished_initializing = true;
  return 0;
}

#define NO_SLOW_PID_REUSE
#ifndef NO_SLOW_PID_REUSE
static void
slow_pid_reuse (HANDLE h)
{
  static NO_COPY HANDLE last_fork_procs[NPIDS_HELD];
  static NO_COPY unsigned nfork_procs;

  if (nfork_procs >= (sizeof (last_fork_procs) / sizeof (last_fork_procs [0])))
    nfork_procs = 0;
  /* Keep a list of handles to child processes sitting around to prevent
     Windows from reusing the same pid n times in a row.  Having the same pids
     close in succesion confuses bash.  Keeping a handle open will stop
     windows from reusing the same pid.  */
  if (last_fork_procs[nfork_procs])
    ForceCloseHandle1 (last_fork_procs[nfork_procs], fork_stupidity);
  if (DuplicateHandle (GetCurrentProcess (), h,
		       GetCurrentProcess (), &last_fork_procs[nfork_procs],
		       0, FALSE, DUPLICATE_SAME_ACCESS))
    ProtectHandle1 (last_fork_procs[nfork_procs], fork_stupidity);
  else
    {
      last_fork_procs[nfork_procs] = NULL;
      system_printf ("couldn't create last_fork_proc, %E");
    }
  nfork_procs++;
}
#endif

int __stdcall
frok::parent (volatile char * volatile stack_here)
{
  HANDLE forker_finished;
  DWORD rc;
  child_pid = -1;
  this_errno = 0;
  bool fix_impersonation = false;
  pinfo child;

  int c_flags = GetPriorityClass (GetCurrentProcess ());
  debug_printf ("priority class %d", c_flags);
  /* Per MSDN, this must be specified even if lpEnvironment is set to NULL,
     otherwise UNICODE characters in the parent environment are not copied
     correctly to the child.  Omitting it may scramble %PATH% on non-English
     systems. */
  c_flags |= CREATE_UNICODE_ENVIRONMENT;

  errmsg = NULL;
  hchild = NULL;

  /* If we don't have a console, then don't create a console for the
     child either.  */
  HANDLE console_handle = CreateFile ("CONOUT$", GENERIC_WRITE,
				      FILE_SHARE_READ | FILE_SHARE_WRITE,
				      &sec_none_nih, OPEN_EXISTING,
				      FILE_ATTRIBUTE_NORMAL, NULL);

  if (console_handle != INVALID_HANDLE_VALUE)
    CloseHandle (console_handle);
  else
    c_flags |= DETACHED_PROCESS;

  /* Some file types (currently only sockets) need extra effort in the
     parent after CreateProcess and before copying the datastructures
     to the child. So we have to start the child in suspend state,
     unfortunately, to avoid a race condition. */
  if (cygheap->fdtab.need_fixup_before ())
    c_flags |= CREATE_SUSPENDED;

  /* Remember if we need to load dynamically linked dlls.
     We do this here so that this information will be available
     in the parent and, when the stack is copied, in the child. */
  load_dlls = dlls.reload_on_fork && dlls.loaded_dlls;

  forker_finished = CreateEvent (&sec_all, FALSE, FALSE, NULL);
  if (forker_finished == NULL)
    {
      this_errno = geterrno_from_win_error ();
      error ("unable to allocate forker_finished event");
      return -1;
    }

  ProtectHandleINH (forker_finished);

  ch.forker_finished = forker_finished;

  PTEB teb = NtCurrentTeb ();
  ch.stackbottom = _tlsbase;
  ch.stacktop = (void *) _tlstop;
  ch.stackaddr = teb->DeallocationStack;
  ch.guardsize = 0;
  if (&_my_tls != _main_tls)
    {
      /* We have not been started from the main thread.  Fetch the
	 information required to set up the thread stack identically
	 in the child. */
      if (!ch.stackaddr)
	{
	  /* Pthread with application-provided stack.  Don't set up a
	     PAGE_GUARD page.  guardsize == -1 is used in alloc_stack_hard_way
	     to recognize this type of stack. */
	  ch.stackaddr = _my_tls.tid->attr.stackaddr;
	  ch.guardsize = (size_t) -1;
	}
      else if (_my_tls.tid)
	/* If it's a pthread, fetch guardsize from thread attributes. */
	ch.guardsize = _my_tls.tid->attr.guardsize;
    }
  debug_printf ("stack - bottom %p, top %p, addr %p, guardsize %ly",
		ch.stackbottom, ch.stacktop, ch.stackaddr, ch.guardsize);

  PROCESS_INFORMATION pi;
  STARTUPINFOW si;

  memset (&si, 0, sizeof (si));
  si.cb = sizeof si;

  si.lpReserved2 = (LPBYTE) &ch;
  si.cbReserved2 = sizeof (ch);

  syscall_printf ("CreateProcessW (%W, %W, 0, 0, 1, %y, 0, 0, %p, %p)",
		  myself->progname, myself->progname, c_flags, &si, &pi);
  bool locked = __malloc_lock ();

  /* Remove impersonation */
  cygheap->user.deimpersonate ();
  fix_impersonation = true;
  ch.refresh_cygheap ();
  ch.prefork ();	/* set up process tracking pipes. */

  while (1)
    {
      hchild = NULL;
      rc = CreateProcessW (myself->progname,	/* image to run */
			   GetCommandLineW (),	/* Take same space for command
						   line as in parent to make
						   sure child stack is allocated
						   in the same memory location
						   as in parent. */
			   &sec_none_nih,
			   &sec_none_nih,
			   TRUE,		/* inherit handles from parent */
			   c_flags,
			   NULL,		/* environment filled in later */
			   0,	  		/* use current drive/directory */
			   &si,
			   &pi);

      if (rc)
	debug_printf ("forked pid %u", pi.dwProcessId);
      else
	{
	  this_errno = geterrno_from_win_error ();
	  error ("CreateProcessW failed for '%W'", myself->progname);
	  memset (&pi, 0, sizeof (pi));
	  goto cleanup;
	}

      if (cygheap->fdtab.need_fixup_before ())
	{
	  cygheap->fdtab.fixup_before_fork (pi.dwProcessId);
	  ResumeThread (pi.hThread);
	}

      CloseHandle (pi.hThread);
      hchild = pi.hProcess;

      /* Protect the handle but name it similarly to the way it will
	 be called in subproc handling. */
      ProtectHandle1 (hchild, childhProc);

      strace.write_childpid (pi.dwProcessId);

      /* Wait for subproc to initialize itself. */
      if (!ch.sync (pi.dwProcessId, hchild, FORK_WAIT_TIMEOUT))
	{
	  if (!error ("forked process %u died unexpectedly, retry %d, exit code %y",
		      pi.dwProcessId, ch.retry, ch.exit_code))
	    continue;
	  this_errno = EAGAIN;
	  goto cleanup;
	}
      break;
    }

  /* Restore impersonation */
  cygheap->user.reimpersonate ();
  fix_impersonation = false;

  child_pid = cygwin_pid (pi.dwProcessId);
  child.init (child_pid, PID_IN_USE | PID_NEW, NULL);

  if (!child)
    {
      this_errno = get_errno () == ENOMEM ? ENOMEM : EAGAIN;
      syscall_printf ("pinfo failed");
      goto cleanup;
    }

  child->nice = myself->nice;

  /* Initialize things that are done later in dll_crt0_1 that aren't done
     for the forkee.  */
  wcscpy (child->progname, myself->progname);

  /* Fill in fields in the child's process table entry.  */
  child->dwProcessId = pi.dwProcessId;
  child.hProcess = hchild;
  ch.postfork (child);

  /* Hopefully, this will succeed.  The alternative to doing things this
     way is to reserve space prior to calling CreateProcess and then fill
     it in afterwards.  This requires more bookkeeping than I like, though,
     so we'll just do it the easy way.  So, terminate any child process if
     we can't actually record the pid in the internal table. */
  if (!child.remember (false))
    {
      TerminateProcess (hchild, 1);
      this_errno = EAGAIN;
#ifdef DEBUGGING0
      error ("child remember failed");
#endif
      goto cleanup;
    }

#ifndef NO_SLOW_PID_REUSE
  slow_pid_reuse (hchild);
#endif

  /* CHILD IS STOPPED */
  debug_printf ("child is alive (but stopped)");


  /* Initialize, in order: stack, dll data, dll bss.
     data, bss, heap were done earlier (in dcrt0.cc)
     Note: variables marked as NO_COPY will not be copied since they are
     placed in a protected segment.  */

  MALLOC_CHECK;
  const void *impure_beg;
  const void *impure_end;
  const char *impure;
  if (&_my_tls == _main_tls)
    impure_beg = impure_end = impure = NULL;
  else
    {
      impure = "impure";
      impure_beg = _impure_ptr;
      impure_end = _impure_ptr + 1;
    }
  rc = child_copy (hchild, true,
		   "stack", stack_here, ch.stackbottom,
		   impure, impure_beg, impure_end,
		   NULL);

  __malloc_unlock ();
  locked = false;
  MALLOC_CHECK;
  if (!rc)
    {
      this_errno = get_errno ();
      error ("pid %u, exitval %p", pi.dwProcessId, ch.exit_code);
      goto cleanup;
    }

  /* Now fill data/bss of any DLLs that were linked into the program. */
  for (dll *d = dlls.istart (DLL_LINK); d; d = dlls.inext ())
    {
      debug_printf ("copying data/bss of a linked dll");
      if (!child_copy (hchild, true,
		       "linked dll data", d->p.data_start, d->p.data_end,
		       "linked dll bss", d->p.bss_start, d->p.bss_end,
		       NULL))
	{
	  this_errno = get_errno ();
	  error ("couldn't copy linked dll data/bss");
	  goto cleanup;
	}
    }

  /* Start thread, and then wait for it to reload dlls.  */
  resume_child (forker_finished);
  if (!ch.sync (child->pid, hchild, FORK_WAIT_TIMEOUT))
    {
      this_errno = EAGAIN;
      error ("died waiting for dll loading");
      goto cleanup;
    }

  /* If DLLs were loaded in the parent, then the child has reloaded all
     of them and is now waiting to have all of the individual data and
     bss sections filled in. */
  if (load_dlls)
    {
      /* CHILD IS STOPPED */
      /* write memory of reloaded dlls */
      for (dll *d = dlls.istart (DLL_LOAD); d; d = dlls.inext ())
	{
	  debug_printf ("copying data/bss for a loaded dll");
	  if (!child_copy (hchild, true,
			   "loaded dll data", d->p.data_start, d->p.data_end,
			   "loaded dll bss", d->p.bss_start, d->p.bss_end,
			   NULL))
	    {
	      this_errno = get_errno ();
#ifdef DEBUGGING
	      error ("copying data/bss for a loaded dll");
#endif
	      goto cleanup;
	    }
	}
      /* Start the child up again. */
      resume_child (forker_finished);
    }

  ForceCloseHandle (forker_finished);
  forker_finished = NULL;

  return child_pid;

/* Common cleanup code for failure cases */
cleanup:
  if (fix_impersonation)
    cygheap->user.reimpersonate ();
  if (locked)
    __malloc_unlock ();

  /* Remember to de-allocate the fd table. */
  if (hchild && !child.hProcess)
    ForceCloseHandle1 (hchild, childhProc);
  if (forker_finished)
    ForceCloseHandle (forker_finished);
  debug_printf ("returning -1");
  return -1;
}

extern "C" int
fork ()
{
  frok grouped;

  debug_printf ("entering");
  grouped.load_dlls = 0;

  int res;
  bool ischild = false;

  myself->set_has_pgid_children ();

  if (grouped.ch.parent == NULL)
    return -1;
  if (grouped.ch.subproc_ready == NULL)
    {
      system_printf ("unable to allocate subproc_ready event, %E");
      return -1;
    }

  {
    hold_everything held_everything (ischild);
    /* This tmp_pathbuf constructor is required here because the below setjmp
       magic will otherwise not restore the original buffer count values in
       the thread-local storage.  A process forking too deeply will run into
       the problem to be out of temporary TLS path buffers. */
    tmp_pathbuf tp;

    if (!held_everything)
      {
	if (exit_state)
	  Sleep (INFINITE);
	set_errno (EAGAIN);
	return -1;
      }

    /* Put the dll list in topological dependency ordering, in
       hopes that the child will have a better shot at loading dlls
       properly if it only has to deal with one at a time.  */
    dlls.topsort ();

    ischild = !!setjmp (grouped.ch.jmp);

    volatile char * volatile stackp;
#ifdef __x86_64__
    __asm__ volatile ("movq %%rsp,%0": "=r" (stackp));
#else
    __asm__ volatile ("movl %%esp,%0": "=r" (stackp));
#endif

    if (!ischild)
      res = grouped.parent (stackp);
    else
      {
	res = grouped.child (stackp);
	in_forkee = false;
	ischild = true;	/* might have been reset by fork mem copy */
      }
  }

  MALLOC_CHECK;
  if (ischild)
    {
      myself->process_state |= PID_ACTIVE;
      myself->process_state &= ~(PID_INITIALIZING | PID_EXITED | PID_REAPED);
    }
  else if (res < 0)
    {
      if (!grouped.errmsg)
	syscall_printf ("fork failed - child pid %d, errno %d", grouped.child_pid, grouped.this_errno);
      else
	{
	  char buf[strlen (grouped.errmsg) + sizeof ("child %d - , errno 4294967295  ")];
	  strcpy (buf, "child %d - ");
	  strcat (buf, grouped.errmsg);
	  strcat (buf, ", errno %d");
	  system_printf (buf, grouped.child_pid, grouped.this_errno);
	}

      set_errno (grouped.this_errno);
    }
  syscall_printf ("%R = fork()", res);
  return res;
}
#ifdef DEBUGGING
void
fork_init ()
{
}
#endif /*DEBUGGING*/


extern "C" int
vfork ()
{
  debug_printf ("stub called");
  return fork ();
}

/* Copy memory from one process to another. */

bool
child_copy (HANDLE hp, bool write, ...)
{
  va_list args;
  va_start (args, write);
  static const char *huh[] = {"read", "write"};

  char *what;
  while ((what = va_arg (args, char *)))
    {
      char *low = va_arg (args, char *);
      char *high = va_arg (args, char *);
      SIZE_T todo = high - low;
      char *here;

      for (here = low; here < high; here += todo)
	{
	  SIZE_T done = 0;
	  if (here + todo > high)
	    todo = high - here;
	  int res;
	  if (write)
	    res = WriteProcessMemory (hp, here, here, todo, &done);
	  else
	    res = ReadProcessMemory (hp, here, here, todo, &done);
	  debug_printf ("%s - hp %p low %p, high %p, res %d", what, hp, low, high, res);
	  if (!res || todo != done)
	    {
	      if (!res)
		__seterrno ();
	      /* If this happens then there is a bug in our fork
		 implementation somewhere. */
	      system_printf ("%s %s copy failed, %p..%p, done %lu, windows pid %u, %E",
			    what, huh[write], low, high, done, myself->dwProcessId);
	      goto err;
	    }
	}
    }

  va_end (args);
  debug_printf ("done");
  return true;

 err:
  va_end (args);
  TerminateProcess (hp, 1);
  set_errno (EAGAIN);
  return false;
}
@


1.244
log
@	* dcrt0.cc (child_info_fork::alloc_stack): Fix a comparison to avoid
	taking 4K more stack in forked child.
	* fork.cc (frok::parent): Print child exit code in hex if sync failed.
@
text
@a346 1
  time_t start_time = time (NULL);
d414 1
a414 1
  child.init (child_pid, 1, NULL);
a422 1
  child->start_time = start_time; /* Register child's starting time. */
@


1.243
log
@	* fork.cc (frok::parent): Always set CREATE_UNICODE_ENVIRONMENT flag.
	Explain why.
@
text
@d401 1
a401 1
	  if (!error ("forked process %u died unexpectedly, retry %d, exit code %d",
@


1.242
log
@	* fork.cc (frok::parent): Call CreateProcessW with command line set
	to the parent command line.  Change comment to explain why.
@
text
@d265 5
@


1.241
log
@	* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Fix datatype of
	stacksize to SIZE_T.  Cast to SIZE_T in pointer arithmetic.  Slightly
	enhance output in case of a fatal error.
	* fork.cc (frok::parent): Always set ch.stackaddr to DeallocationStack
	value of current thread to help stack reservation in
	child_info_fork::alloc_stack_hard_way along.  Simplify subsequent code
	storing stack values in ch.  Print guardsize in hex, too.
@
text
@d354 5
a358 1
			   myself->progname,	/* what we send in arg0 */
@


1.240
log
@	* Merge in cygwin-64bit-branch.
@
text
@d305 1
d308 1
a308 1
  ch.stackaddr = 0;
d315 1
a315 2
      PTEB teb = NtCurrentTeb ();
      if (!teb->DeallocationStack)
d323 3
a325 7
      else
	{
	  ch.stackaddr = teb->DeallocationStack;
	  /* If it's a pthread, fetch guardsize from thread attributes. */
	  if (_my_tls.tid)
	    ch.guardsize = _my_tls.tid->attr.guardsize;
	}
d327 1
a327 1
  debug_printf ("stack - bottom %p, top %p, addr %p, guardsize %lu",
@


1.239
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d331 1
a331 1
  debug_printf ("stack - bottom %p, top %p, addr %p, guardsize %p",
d343 1
a343 1
  syscall_printf ("CreateProcessW (%W, %W, 0, 0, 1, %p, 0, 0, %p, %p)",
d601 6
a606 2
    volatile char * volatile esp;
    __asm__ volatile ("movl %%esp,%0": "=r" (esp));
d609 1
a609 1
      res = grouped.parent (esp);
d612 1
a612 1
	res = grouped.child (esp);
d671 1
a671 1
      DWORD todo = high - low;
d676 1
a676 1
	  DWORD done = 0;
d691 1
a691 1
	      system_printf ("%s %s copy failed, %p..%p, done %d, windows pid %u, %E",
@


1.238
log
@* fork.cc (child_info::prefork): Fix error message formatting.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006,
@


1.237
log
@* DevNotes: Add entry cgf-000004.
* pinfo.cc (pinfo::init): Reuse shared memory if the state is marked with
PID_REAPED.
* spawn.cc (child_info_spawn::worker): Don't duplicate myself_pinfo into
non-cygwin child.
* fork.cc (frok::parent): Improve error output.
@
text
@d120 1
a120 1
	api_fatal ("prefork: couldn't create pipe process tracker%E");
@


1.237.2.1
log
@	* cygheap.h (struct user_heap_info): Change type of chunk to SIZE_T.
	Remove unused slop member.
	* fork.cc (fork): Rename esp to stackp.  Add 64 bit asm expression to
	fetch stack pointer.
	(child_copy): Use platform independent types.
	* heap.cc (eval_start_address): Add comment. Disable 3GB code on 64 bit.
	(eval_initial_heap_size): Use platform independent types.  Fix debug
	printf format strings.
	(sbrk): Add comment.  Change argument type according to newlib
	definition.  Use platform independent types.  Drop unneeded else and
	move comment to the right spot.
	* hookapi.cc (PEHeaderFromHModule): Return PVOID.  Add comment to
	explain why.  Add bool parameter to return if target executable is
	64 bit or not.
	(rvadelta_get): New inline function to fetch section address platform
	independent.
	(rvadelta32, rvadelta64): Platform dependent wrappers.
	(rvadelta): Change to macro calling the platform dependent rvadelta
	wrappers.
	(putmem): Define platform dependent THUNK_FUNC_TYPE and use throughout.
	(RedirectIAT): Add comment.
	(get_export): Add comment.
	(find_first_notloaded_dll): Allow to fetch information in a platform
	and target independent way.
	(hook_or_detect_cygwin): Ditto.  Recognize the cyg64win1.dll file name
	as well.
	* kernel32.cc (CreateFileMappingW): Cast to avoid compiler warning.

	* fhandler.h (class fhandler_dev_tape): Replace mt_evt with an
	OVERLAPPED structure ov.
	* mtinfo.h (class mtinfo_part): Define members as int32_t rather than
	long.  Change member function declarations accordingly.
	(class mtinfo_drive): Ditto.  Store OVERLAPPED pointer rather than
	holding the full structure.  Add comment to explain why.
	* fhandler_tape.cc: Accommodate above changes throughout.
@
text
@d601 2
a602 6
    volatile char * volatile stackp;
#ifdef __x86_64__
    __asm__ volatile ("movq %%rsp,%0": "=r" (stackp));
#else
    __asm__ volatile ("movl %%esp,%0": "=r" (stackp));
#endif
d605 1
a605 1
      res = grouped.parent (stackp);
d608 1
a608 1
	res = grouped.child (stackp);
d667 1
a667 1
      SIZE_T todo = high - low;
d672 1
a672 1
	  SIZE_T done = 0;
@


1.237.2.2
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d120 1
a120 1
	api_fatal ("prefork: couldn't create pipe process tracker %E");
d331 1
a331 1
  debug_printf ("stack - bottom %p, top %p, addr %p, guardsize %lu",
d343 1
a343 1
  syscall_printf ("CreateProcessW (%W, %W, 0, 0, 1, %y, 0, 0, %p, %p)",
d691 1
a691 1
	      system_printf ("%s %s copy failed, %p..%p, done %lu, windows pid %u, %E",
@


1.237.2.3
log
@Pull in changes from HEAD
@
text
@d120 1
a120 1
	api_fatal ("prefork: couldn't create pipe process tracker, %E");
@


1.237.2.4
log
@Pull in changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
@


1.237.2.5
log
@	* configure.ac (MALLOC_OFILES): Add ptmalloc3.o.
	* configure: Regenerate.
	* cygmalloc.h: Declare pt* functions rather than dl* functions.
	(mmap64): Declare.
	(mmap): Define as mmap64.
	(__malloc_lock): Drop macro.
	(__malloc_unlock): Ditto.
	(MSPACES): Define.
	(ONLY_MSPACES): Define.
	* debug.h: Include malloc.h rather than otherwise unused dlmalloc.h.
	* fork.cc (frok::parent): Drop malloc locking since that's performed
	by malloc_atfork now.
	* heap.cc (heap_init): Accommodate the fact that there's a chance
	that no heap space has been allocated at fork time.
	* malloc-private.h: New file from ptmalloc3, having malloc-machine.h
	and malloc-2.8.3.h folded in.
	* malloc.cc: Replaced by new file from ptmalloc3.
	* malloc_wrapper.cc: Throughout, remove malloc locks and call pt*
	functions rather than dl* functions.
	* pinfo.cc (winpids::set): Drop malloc locking.
	* ptmalloc3.cc: New file from ptmalloc3.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d27 1
d345 1
d476 2
d545 2
@


1.237.2.6
log
@	* Revert to old malloc.
	* mmap.cc (MMAP_STORAGE_LOW): Set higher.  Add comment.
	(MMAP_STORAGE_HIGH): Add comment.
	(class mmap_allocator): Change comment.  Add mmap_current_low member.
	(mmap_allocator::mmap_allocator): Define default constructor.
	(mmap_allocator::alloc): Change to a round-robin mechanism.  Add or
	change comments accordingly.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
a26 1
#include "cygmalloc.h"
a343 1
  bool locked = __malloc_lock ();
a473 2
  __malloc_unlock ();
  locked = false;
a540 2
  if (locked)
    __malloc_unlock ();
@


1.237.2.7
log
@	* Reinstantiate ptmalloc3.
	* configure.ac (MALLOC_OFILES): Drop here.
	* configure: Regenerate.
	* Makefile.in (MALLOC_OFILES): Set to fixed value here.
	* cygmalloc.h (HAVE_MORECORE): Define.
	* malloc.cc (init_user_mstate): Don't disable MORECORE if building
	with ONLY_MSPACES.
@
text
@d345 1
d476 2
d545 2
@


1.237.2.8
log
@	* Remove ptmalloc3 once and for all.
@
text
@a344 1
  bool locked = __malloc_lock ();
a474 2
  __malloc_unlock ();
  locked = false;
a541 2
  if (locked)
    __malloc_unlock ();
@


1.236
log
@* child_info.h (child_info::postfork): Define new function.
* fork.cc (frok::parent): Call postfork to do all of the manipulation required
prior to calling pinfo::remember.
* pinfo.h (pinfo::set_rd_proc_pipe): Just set pinfo's rd_proc_pipe.  Don't
bother setting it to NULL.
* sigproc.cc (child_info_spawn::wait_for_myself): Call postfork to set up
myself for waiting.
* spawn.cc (child_info_spawn::worker): Avoid now-unnecessary global lock.
Consistently test mode rather than chtype when making wr_proc_pipe decisions.
Call postfork() to set up stuff prior to pinfo::remember.
@
text
@d396 2
a397 2
	  if (!error ("forked process died unexpectedly, retry %d, exit code %d",
		      ch.retry, ch.exit_code))
@


1.235
log
@* dtable.cc (set_std_handle): Call SetStdHandle with NULL if fd is closed.
(dtable::release): "Close" standard handle if appropriate.
* dcrt0.cc (dll_crt0_0): Fix minor switch formatting problem.
* fork.cc (frok::parent): Make minor comment indentation change.
@
text
@d429 1
a429 1
  child.set_rd_proc_pipe (ch.rd_proc_pipe);
@


1.234
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::rd_proc_pipe): Declare new field.
(child_info::wr_proc_pipe): Ditto.
(child_info::prefork): Declare new function, derived from previous pinfo
version.
* dcrt0.cc (child_info_fork::handle_fork): Close previous wr_proc_pipe when
appropriate and assign new one from passed-in child_info block.
(child_info_spawn::handle_spawn): Assign our wr_proc_pipe handle from passed-in
child_info block.
* fork.cc (child_info::prefork): Define new function.
(frok::child): Clear rd_proc_pipe and wr_proc_pipe so they will not be closed
by the child_info destructor.
(frok::parent): Use child_info prefork handling, outside of retry loop.  Set
rd_proc_pipe in child's pinfo after successful CreateProcess.  Eliminate
postfork call.
* globals.cc (my_wr_proc_pipe): Define/declare new variable.
* pinfo.cc (pinfo::pending_rd_proc_pipe): Delete.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Ditto.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wait): Assume that rd_proc_pipe is set up correctly prior to call.
(_pinfo::alert_parent): Replace "wr_proc_pipe" with "my_wr_proc_pipe".
* pinfo.h (_pinfo::_wr_proc_pipe): Delete declaration.
(_pinfo::set_rd_proc_pipe): Define new function.
(pinfo::pending_rd_proc_pipe): Delete declaration.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Ditto.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wr_proc_pipe): Ditto.
* sigproc.cc (child_info::child_info): Clear rd_proc_pipe and wr_proc_pipe.
(child_info::cleanup): Close rd_proc_pipe and wr_proc_pipe if necessary.
(child_info_fork::child_info_fork): Set forker_finished to NULL by default.
(child_info_spawn::child_info_spawn): Use my_wr_proc_pipe rather than
myself->wr_proc_pipe.
(child_info::sync): Ditto.
(child_info_spawn::cleanup): Call child_info::cleanup.
* spawn.cc (child_info_spawn::worker): Remove call to myself.prefork().  Set
wr_proc_pipe when execing or set up new rd_proc_pipe/wr_proc_pipe via
child_info::prefork when spawning.  Remove call to pinfo::postexec.  Set
rd_proc_pipe in child pinfo when spawning.  Use my_wr_proc_pipe rather than
myself->wr_proc_pipe.  Remove call to postfork.
@
text
@d357 2
a358 2
      rc = CreateProcessW (myself->progname, /* image to run */
			   myself->progname, /* what we send in arg0 */
d361 1
a361 1
			   TRUE,	  /* inherit handles from parent */
d363 2
a364 2
			   NULL,	  /* environment filled in later */
			   0,	  /* use current drive/directory */
@


1.233
log
@* fork.cc (lock_signals): Move to sigproc.h.
(lock_pthread): Ditto.
(hold_everything): Ditto.
(frok::parent): Call myself.prefork() just before calling CreateProcess.  Call
myself.postfork () on function exit.
* pinfo.cc (pinfo::pending_rd_proc_pipe): Define.
(pinfo::pending_wr_proc_pipe): Ditto.
(_pinfo::dup_proc_pipe): Delete.
(pinfo::wait): Move pipe creation into pinfo::prefork.  Set pipe variables from
pending_*.
(_pinfo::sync_proc_pipe): Delete.
(_pinfo::proc_pipe_owner): Ditto.
(pinfo::prefork): Define new function.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(_pinfo::alert_parent): Remove obsolete call to sync_proc_pipe.
(_pinfo::dup_proc_pipe): Delete declaration.
(_pinfo::sync_proc_pipe): Ditto.
(pinfo::pending_rd_proc_pipe): Declare.
(pinfo::pending_wr_proc_pipe): Ditto.
(pinfo::prefork): Declare new function.
(pinfo::postfork): Ditto.
(pinfo::postexec): Ditto.
(pinfo::wr_proc_pipe): Define new wrapper function.
* sigproc.h: Include "sync.h".  Move locking functions from fork to here.
* spawn.cc (child_info_spawn::worker): Delete now-unneeded requirement to
record orig_wr_proc_pipe.  Call hold_everything prior to doing anything.  Call
myself.prefork() if spawning.  Replace wr_proc_pipe synchronization with call
to myself.postexec().  Call myself.postfork() if not execing.
* sync.h: Replace #ifdef wrapper with "#pragma once".
@
text
@d112 19
d216 4
d352 1
a356 1
      myself.prefork ();
d429 1
a542 1
  myself.postfork ();
@


1.232
log
@	* flock.cc (inode_t::del_my_locks): Drop useless counter lc.  Close
	lock object handle explicitely in case of called during fork.  Add
	comment to explain why.
	* fork.cc (frok::child): Drop declaration of fixup_lockf_after_fork.
@
text
@a49 77
class lock_signals
{
  bool worked;
public:
  lock_signals ()
  {
    worked = sig_send (NULL, __SIGHOLD) == 0;
  }
  operator int () const
  {
    return worked;
  }
  void dont_bother ()
  {
    worked = false;
  }
  ~lock_signals ()
  {
    if (worked)
      sig_send (NULL, __SIGNOHOLD);
  }
};

class lock_pthread
{
  bool bother;
public:
  lock_pthread (): bother (1)
  {
    pthread::atforkprepare ();
  }
  void dont_bother ()
  {
    bother = false;
  }
  ~lock_pthread ()
  {
    if (bother)
      pthread::atforkparent ();
  }
};

class hold_everything
{
public: /* DELETEME*/
  bool& ischild;
  /* Note the order of the locks below.  It is important,
     to avoid races, that the lock order be preserved.

     pthread is first because it serves as a master lock
     against other forks being attempted while this one is active.

     signals is next to stop signal processing for the duration
     of the fork.

     process is last.  If it is put before signals, then a deadlock
     could be introduced if the process attempts to exit due to a signal. */
  lock_pthread pthread;
  lock_signals signals;
  lock_process process;

public:
  hold_everything (bool& x): ischild (x) {}
  operator int () const {return signals;}

  ~hold_everything()
  {
    if (ischild)
      {
	pthread.dont_bother ();
	process.dont_bother ();
	signals.dont_bother ();
      }
  }

};

d333 1
d519 1
@


1.231
log
@Update copyright on all files checked in so far this year.
* fhandler.h: Use #pragma once rather than ifdef guards.
(fhandler_console::tc_getpgid): Return our pgid if we have never opened a
console.
* fork.cc: Rearrange includes to accommodate fhandler.h use of pinfo.h.
* sigproc.cc: Ditto.
* spawn.cc: Ditto.
(child_info_spawn::worker): Query myself->pgid rather than calling expensive
function.
* thread.h: Use #pragma once rather than ifdef guards.
* pinfo.h: Use #pragma once rather than ifdef guards.
(pinfo::remember): Don't define if sigproc.h has not been included.
(pinfo::reattach): Ditto.
* sigproc.h: Use #pragma once rather than ifdef guards.  Use different test to
see if pinfo.h has been included.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
a192 1
  extern void fixup_lockf_after_fork ();
@


1.230
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d17 2
a21 2
#include "sigproc.h"
#include "pinfo.h"
@


1.229
log
@* cygthread.h (cygthread::name): Default name to "main" if we are early in the
process of setting up the DLL and no name is known.
* dcrt0.cc (initial_env): Remove CYGWIN_SLEEP stuff.
(get_cygwin_startup_info): Activate strace here as appropriate.
(dll_crt0_0): Move get_cygwin_startup_info as early as possible to avoid
missing strace output.
* fork.cc (frok::child): Move debugging statement to point where ppid will be
set.
* pinfo.cc (pinfo::thisproc): Remove obsolete call to strace.hello.  Tweak
debug output slightly.
* select.cc (select_stuff::wait): Allow APCS to be triggered while waiting
since we use them now.  Report when that happens.
* sigproc.cc (child_info::child_info): Use strace.active() rather than
strace.attached().
* spawn.cc (child_info_spawn::worker): Only write strace child pid when we know
it's a cygwin process.  Accommodate change to write_child argument list.
* strace.cc (strace::hello): Delete.  Move functionality...
(strace::activate): ...to here.
(mypid): Just use raw GetCurrentProcessId () if myself isn't set.
(strace::write_childpid): Don't wait for subproc_ready.  Remove arg which was
required for it.
* include/sys/strace.h (strace::hello): Delete.
(strace::write_childpid): Delete first argument.
@
text
@d688 1
a688 1
  syscall_printf ("%d = fork()", res);
@


1.228
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@a195 2
  debug_printf ("child is running.  pid %d, ppid %d, stack here %p",
		myself->pid, myself->ppid, __builtin_frame_address (0));
d204 2
d445 1
a445 1
      strace.write_childpid (ch, pi.dwProcessId);
d506 1
@


1.227
log
@	Throughout, open console handles with sharing for reading and writing.
	* dcrt0.cc (insert_file): Open file with full sharing allowed.
	* hookapi.cc (find_first_notloaded_dll): Ditto.
	* spawn.cc (av::fixup): Ditto.
@
text
@d422 3
a424 1
      if (!rc)
@


1.226
log
@whitespace elimination
@
text
@d327 3
a329 3
				      FILE_SHARE_WRITE, &sec_none_nih,
				      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
				      NULL);
@


1.225
log
@* dll_init.cc (reserve_upto): Remove.
(release_upto): Ditto.
(dll_list::reserve_space): New function to reserve space needed by DLL_LOAD
dlls early in the fork process.
(dll_list::load_after_fork): Rewrite to use recursion to track reservations it
makes while trying to make dlls land where they belong.
(dll_list::load_after_fork_impl): New function used by load_after_fork.
(dll_list::alloc): Initialize image base field.
* dll_init.h (dll_list::prefered_base): New field.
(dll_list::reserve_space): Declare new function.
(dll_list::load_after_fork): Declare new function.
* fork.cc (frok::child): call dll_list::reserve_space early, so we can retry if
it fails.
@
text
@d371 1
a371 1
      	{
@


1.224
log
@* dll_init.cc (dll_list::find_by_modname): New function to search the dll list
for a module name only (no path).
(dll_list::alloc): Initialize newly-added members of struct dll.
(dll_list::append): New function to factor out the append operation
(used by dll_list::topsort).
(dll_list::populate_deps): New function to identify dll dependencies.
(dll_list::topsort): New function to sort the dll list topologically by
dependencies.
(dll_list::topsort_visit): New helper function for the above.
* dll_init.h (dll::ndeps): New class member.
(dll::deps): Ditto.
(dll::modname): Ditto.
(dll_list::find_by_modname): New function related to topsort.
(dll_list::populate_all_deps): Ditto.
(dll_list::populate_deps): Ditto.
(dll_list::topsort): Ditto.
(dll_list::topsort_visit): Ditto.
(dll_list::append): Ditto.
(pefile): New struct allowing simple introspection of dll images.
* fork.cc (fork): Topologically sort the dll list before forking
* child_info.h (CURR_CHILD_INFO_MAGIC): Refresh.
(child_info::refresh_cygheap): New function.
* spawn.cc (spawn_guts): Call refresh_cygheap before creating a new process to
ensure that cygheap_max is up-to-date.
* fork.cc (frok::parent): Ditto.
@
text
@d199 6
@


1.223
log
@* cygheap.cc (cygheap_dummy): Rename from cygheap_at_start.
(cygheap): Accommodate name change to cygheap_dummy.
(cygheap_init): Ditto.
(cygheap_fixup_in_child): Simplify slightly.
* fork.cc (fork): Add an advisory comment.
@
text
@d400 1
a604 1
  /* No cygheap allocation beyond this point. */
d638 5
@


1.222
log
@Revert previous checkins as they introduced a bug when running zsh.
@
text
@d604 1
@


1.221
log
@* dll_init.cc (dll_list::find_by_modname): New function to search the dll list
for a module name only (no path).
(dll_list::alloc): Initialize newly-added members of struct dll.
(dll_list::append): New function to factor out the append operation
(used by dll_list::topsort).
(dll_list::populate_deps): New function to identify dll dependencies.
(dll_list::topsort): New function to sort the dll list topologically by
dependencies.
(dll_list::topsort_visit): New helper function for the above.
* dll_init.h (dll::ndeps): New class member.
(dll::deps): Ditto.
(dll::modname): Ditto.
(dll_list::find_by_modname): New function related to topsort.
(dll_list::populate_all_deps): Ditto.
(dll_list::populate_deps): Ditto.
(dll_list::topsort): Ditto.
(dll_list::topsort_visit): Ditto.
(dll_list::append): Ditto.
(pefile): New struct allowing simple introspection of dll images.
* fork.cc (fork): Topologically sort the dll list before forking.
@
text
@d628 1
a628 1
  
a636 6
    /* Put the dll list in topological dependency ordering, in
       hopes that the child will have a better shot at loading dlls
       properly if it only has to deal with one at a time.
    */
    dlls.topsort ();

@


1.220
log
@* dll_init.c (dll_list::load_after_fork): Don't clear in_forkee here.
* fork.cc (frok::errmsg): Rename from 'error'.
(frok::error): New function.  Handle conditional printing of error messages.
(frok::parent): Record hchild handle for use by error function.  Use
throughout.  Use error function rather than setting error pointer directly.
(fork): Clear is_forkee here.  Accommodate rename of 'error' to 'errmsg'.
* sigproc.cc (child_info::proc_retry): Detect EXITCODE_FORK_FAILED.
@
text
@d628 1
a628 1

d637 6
@


1.219
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d40 1
a40 1
  const char *error;
d43 1
d46 1
d168 21
a307 1
  error = NULL;
a310 1
  static char errbuf[NT_MAX_PATH + 256];
d315 3
d346 1
a346 1
      error = "unable to allocate forker_finished event";
d403 1
d418 1
a418 2
	  __small_sprintf (errbuf, "CreateProcessW failed for '%W'", myself->progname);
	  error = errbuf;
d430 1
d434 1
a434 1
      ProtectHandle1 (pi.hProcess, childhProc);
d439 1
a439 1
      if (!ch.sync (pi.dwProcessId, pi.hProcess, FORK_WAIT_TIMEOUT))
d441 2
a442 2
	  DWORD exit_code = ch.proc_retry (pi.hProcess);
	  if (!exit_code)
a444 4
	  /* Not thread safe, but do we care? */
	  __small_sprintf (errbuf, "died waiting for longjmp before initialization, "
			   "retry %d, exit code %p", ch.retry, exit_code);
	  error = errbuf;
a459 3
#ifdef DEBUGGING
      error = "pinfo failed";
#else
a460 1
#endif
d473 1
a473 1
  child.hProcess = pi.hProcess;
d482 1
a482 1
      TerminateProcess (pi.hProcess, 1);
d485 1
a485 1
      error = "child.remember failed";
d491 1
a491 1
  slow_pid_reuse (pi.hProcess);
d514 1
a514 1
  rc = child_copy (pi.hProcess, true,
d525 1
a525 5
      DWORD exit_code;
      if (!GetExitCodeProcess (pi.hProcess, &exit_code))
	exit_code = 0xdeadbeef;
      __small_sprintf (errbuf, "pid %u, exitval %p", pi.dwProcessId, exit_code);
      error = errbuf;
d533 1
a533 1
      if (!child_copy (pi.hProcess, true,
d539 1
a539 7
#ifdef DEBUGGING
	  DWORD exit_code;
	  if (!GetExitCodeProcess (pi.hProcess, &exit_code))
	    exit_code = 0xdeadbeef;
	  __small_sprintf (errbuf, "pid %u, exitval %p", pi.dwProcessId, exit_code);
	  error = errbuf;
#endif
d546 1
a546 1
  if (!ch.sync (child->pid, pi.hProcess, FORK_WAIT_TIMEOUT))
d549 1
a549 1
      error = "died waiting for dll loading";
d563 1
a563 1
	  if (!child_copy (pi.hProcess, true,
d570 1
a570 1
	      error = "copying data/bss for a loaded dll";
d592 2
a593 2
  if (pi.hProcess && !child.hProcess)
    ForceCloseHandle1 (pi.hProcess, childhProc);
d647 1
d660 1
a660 1
      if (!grouped.error)
d664 1
a664 1
	  char buf[strlen (grouped.error) + sizeof ("child %d - , errno 4294967295  ")];
d666 1
a666 1
	  strcat (buf, grouped.error);
@


1.218
log
@	* child_info.h (CURR_CHILD_INFO_MAGIC): Update.
	(class child_info_fork): Remove stacksize, add stackaddr and guardsize
	members.
	* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Partial rewrite
	to regenerate the stack exactly as in the parent.
	(child_info_fork::alloc_stack): Set stackaddr to 0, rather than
	stacksize.
	(dll_crt0_1): Check for stackaddr before changing the stack addresses
	in the TEB.
	* fork.cc (frok::child): Check for stackaddr here.
	(frok::parent): Set ch.stackaddr and ch.guardsize if not called from
	the main thread.
	* init.cc (dll_entry): Replace pointer to NT_TIB with pointer to TEB.
	Fix incorrectly changed address test before removing _my_tls.
	Set StackLimit to NULL on Windows 2000.  Explain why.
	* miscfuncs.cc (struct thread_wrapper_arg): Store stackbase rather
	than stacksize, store commitaddr, remove guardsize.  Store all pointers
	as char * for easier address arithmetic.
	(thread_wrapper): Rewrite to remove OS stack before calling thread
	function.  Add lots of comments to explain what we do.
	(CygwinCreateThread): Reserve our own stack in case we got no
	application stack.  Add comments.
	* ntdll.h (struct _TEB): Extend defintion up to DeallocationStack
	member.
	* thread.cc (pthread_attr::pthread_attr): Use "(size_t) -1"
	rather then 0xffffffff.
	* wincap.h (wincaps::has_stack_size_param_is_a_reservation): New
	element.
	* wincap.cc: Implement above element throughout.
@
text
@d237 1
a237 1
  init_console_handler (myself->ctty >= 0);
a674 9
#ifdef NEWVFORK
/* Dummy function to force second assignment below to actually be
   carried out */
static vfork_save *
get_vfork_val ()
{
  return vfork_storage.val ();
}
#endif
a678 1
#ifndef NEWVFORK
a680 63
#else
  vfork_save *vf = get_vfork_val ();
  char **esp, **pp;

  if (vf == NULL)
    vf = vfork_storage.create ();
  else if (vf->pid)
    return fork ();

  // FIXME the tls stuff could introduce a signal race if a child process
  // exits quickly.
  if (!setjmp (vf->j))
    {
      vf->pid = -1;
      __asm__ volatile ("movl %%esp,%0": "=r" (vf->vfork_esp):);
      __asm__ volatile ("movl %%ebp,%0": "=r" (vf->vfork_ebp):);
      for (pp = (char **) vf->frame, esp = vf->vfork_esp;
	   esp <= vf->vfork_ebp + 2; pp++, esp++)
	*pp = *esp;
      vf->ctty = myself->ctty;
      vf->sid = myself->sid;
      vf->pgid = myself->pgid;
      cygheap->ctty_on_hold = cygheap->ctty;
      vf->console_count = cygheap->console_count;
      debug_printf ("cygheap->ctty_on_hold %p, cygheap->console_count %d", cygheap->ctty_on_hold, cygheap->console_count);
      int res = cygheap->fdtab.vfork_child_dup () ? 0 : -1;
      debug_printf ("%d = vfork()", res);
      _my_tls.call_signal_handler ();	// FIXME: racy
      vf->tls = _my_tls;
      return res;
    }

  vf = get_vfork_val ();

  for (pp = (char **) vf->frame, esp = vf->vfork_esp;
       esp <= vf->vfork_ebp + 2; pp++, esp++)
    *esp = *pp;

  cygheap->fdtab.vfork_parent_restore ();

  myself->ctty = vf->ctty;
  myself->sid = vf->sid;
  myself->pgid = vf->pgid;
  termios_printf ("cygheap->ctty %p, cygheap->ctty_on_hold %p", cygheap->ctty, cygheap->ctty_on_hold);
  cygheap->console_count = vf->console_count;

  if (vf->pid < 0)
    {
      int exitval = vf->exitval;
      vf->pid = 0;
      if ((vf->pid = fork ()) == 0)
	exit (exitval);
    }

  int pid = vf->pid;
  vf->pid = 0;
  debug_printf ("exiting vfork, pid %d", pid);
  sig_dispatch_pending ();

  _my_tls.call_signal_handler ();	// FIXME: racy
  _my_tls = vf->tls;
  return pid;
#endif
@


1.217
log
@	* environ.cc (set_chunksize): Remove.
	(parse_thing): Remove forkchunk entry.
	* fork.cc (child_copy): Drop handling external chunksize setting.
	* wincap.cc: Througout, drop chunksize.
	(wincapc::set_chunksize): Remove.
	* wincap.h (struct wincaps): Drop chunksize and declaration of
	set_chunksize.
@
text
@d28 1
d182 1
a182 1
  if (fork_info->stacksize)
d331 27
a357 4
  ch.stacktop = (void *) stack_here;
  ch.stacksize = (char *) ch.stackbottom - (char *) stack_here;
  debug_printf ("stack - bottom %p, top %p, size %d",
		ch.stackbottom, ch.stacktop, ch.stacksize);
@


1.216
log
@* fork.cc (fork): Clear PID_REAPED.
* pinfo.cc (pinfo_init): Ditto.
(pinfo::init): Check for PID_REAPED.
* sigproc.cc (stopped_or_terminated): Ditto.
@
text
@d4 1
a4 1
   2007, 2008, 2009 Red Hat, Inc.
d746 1
a746 1
      DWORD todo = wincap.chunksize () ?: high - low;
@


1.215
log
@* dcrt0.cc (dll_crt0_0): Remove myself settings.
* fork.cc (fork): Set myself process_state
* pinfo.cc (pinfo_init): Ditto.
(pinfo::thisproc): Make sure any sendsig setting is correctly copied.
* pinfo.h: Update copyright.  Remove unused code.
@
text
@d624 1
a624 1
      myself->process_state &= ~(PID_INITIALIZING | PID_EXITED);
@


1.214
log
@* cygthread.cc (cygthread::create): Fix incorrect use of name rather than
__name.
* cygthread.h (cygthread::cygthread): Create versions which eliminate 'n'
parameter.
* dcrt0.cc (dll_crt0_1): Remove check for threadfunc_ix.  Remove obsolete
comments.  Set process_state to active here.
* fhandler_netdrive.cc (create_thread_and_wait): Use shortened cygthread
constructor.
* timer.cc (timer_tracker::settime): Ditto.
* window.cc (HWND): Ditto.
* fhandler_tty.cc: Use shortened cygthread constructor, where appropriate,
throughout.
* select.cc: Ditto.
* fork.cc (frok::child): Remove wait_for_sigthread.
(fork): Reformat if for slightly better clarity.
* init.cc (dll_finished_loading): New variable.
(dll_entry): Use dll_finished_loading to determine when we should call
merge_threadfunc.
* sigproc.cc (no_signals_available): Simplify by using my_readsig.
(wait_sig_inited): Delete.
(wait_sig): Define as void function.
(pending_signals): Accommodate change to wait_sig definition.
(wait_for_sigthread): Delete definition.
(sigproc_init): Initialize signal pipe here, before wait_sig thread is created.
Use void form of cygthread creation.
(init_sig_pipe): Delete.
(wait_sig): Return void rather than DWORD.  Assume previous initialization of
signal pipe.  Set my_sendsig to NULL when exiting.
* sigproc.h (wait_for_sigthread): Delete declaration.
@
text
@d622 4
a625 1
    /* nothing to do */;
@


1.213
log
@	* exceptions.cc (dump_exception): Use %W instead of %s for printing
	progname.
	* fork.cc (frok::parent): Fix typos in debug output.
	* spawn.cc (spawn_guts): Copy wide Win32 filename into _pinfo::progname,
	rather than native NT name.
@
text
@a244 1
  wait_for_sigthread ();
d621 3
a623 3
  if (ischild || res > 0)
    /* everything is ok */;
  else
@


1.212
log
@* fork.cc (frok::parent): Improve error message.
@
text
@d345 1
a345 1
  syscall_printf ("CreateProcess (%W, %W, 0, 0, 1, %p, 0, 0, %p, %p)",
d370 1
a370 1
	  __small_sprintf (errbuf, "CreatProcessW failed for '%W'", myself->progname);
@


1.211
log
@* environ.cc (regopt): Change the first argument to wide char string.
(environ_init): Accommodate change to the first argument of regopt.
* exception.cc (open_stackdumpfile): Accommodate change to the type of progname
in _pinfo.
* external.cc (fillout_pinfo): Ditto.
* fhandler_process.cc (format_process_winexename): Ditto.
(format_process_stat): Ditto.
* fork.cc (fork::parent): Ditto.
* pinfo.cc (pinfo_basic::pinfo_basic): Call GetModuleFileNameW instead of
GetModuleFileName.
(pinfo::thisproc): Accommodate change to the type of progname in _pinfo.
(pinfo_init): Ditto.
* pinfo.h (_pinfo): Change the type of progname to a wide char array.
* registry.h (reg_key::get_int): Change the first argument from constant point
to pointer to constant.
(reg_key::get_string): Ditto.  Change the last argument likewise.
* registry.cc (reg_key::get_int): Accommodate change to the declaration.
(reg_key::get_string): Ditto.
* strace.cc (strace::hello): Accommodate change to the type of progname in
_pinfo.
(strace::vsprntf): Ditto.
@
text
@d289 1
a289 1
  static char errbuf[256];
d370 2
a371 1
	  error = "CreateProcessW failed";
@


1.210
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@a344 5
  /* FIXME: myself->progname should be converted to WCHAR. */
  tmp_pathbuf tp;
  PWCHAR progname = tp.w_get ();
  sys_mbstowcs (progname, NT_MAX_PATH, myself->progname);

d346 1
a346 1
		  progname, progname, c_flags, &si, &pi);
d356 2
a357 2
      rc = CreateProcessW (progname, /* image to run */
			   progname, /* what we send in arg0 */
d428 1
a428 1
  strcpy (child->progname, myself->progname);
@


1.209
log
@	Reintegrate socket duplication via WSADuplicateSocket/WSASocket.
	* autoload.cc (WSADuplicateSocketW): Define.
	(WSASocketW): Define.
	* dtable.cc (dtable::release): Call dec_need_fixup_before if necessary.
	(dtable::fixup_before_fork): New function.
	(dtable::fixup_before_exec): New function.
	* dtable.h (class dtable): Add member cnt_need_fixup_before.  Add
	declarations for above new functions.
	(dtable::dec_need_fixup_before): New inline method.
	(dtable::inc_need_fixup_before): New inline method.
	(dtable::need_fixup_before): New inline method.
	* fhandler.h (fhandler_base::fixup_before_fork_exec): New virtual
	method.
	(fhandler_base::need_fixup_before): New virtual method.
	(class fhandler_socket): Add member prot_info_ptr.
	(fhandler_socket::init_fixup_before): Declare.
	(fhandler_socket::need_fixup_before): New inline method.
	(fhandler_socket::fixup_before_fork_exec): Declare.
	(fhandler_socket::fixup_after_exec): Declare.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Initialize
	prot_info_ptr to NULL.
	(fhandler_socket::~fhandler_socket): Free prot_info_ptr conditionally.
	(fhandler_socket::init_fixup_before): New method.
	(fhandler_socket::fixup_before_fork_exec): Ditto.
	(fhandler_socket::fixup_after_fork): Use WSASocketW to duplicate
	socket if necessary.
	(fhandler_socket::fixup_after_exec): New method.
	(fhandler_socket::dup): Use fixup_before_fork_exec/fixup_after_fork
	to duplicate socket if necessary.
	* fork.cc (frok::parent): Start child suspended if some fhandler
	needs fixup before fork.  If so, call dtable::fixup_before_fork after
	CreateProcess and resume child.
	* net.cc (fdsock): Try to find out if socket needs fixup before and
	initialize socket accordingly.  Add HUGE comment to explain what happens
	and why.
	* spawn.cc (spawn_guts): Start child suspended if some fhandler needs
	fixup before exec.  If so, call dtable::fixup_before_exec after
	CreateProcess.
@
text
@d266 3
a268 2
  if (DuplicateHandle (hMainProc, h, hMainProc, &last_fork_procs[nfork_procs],
			0, FALSE, DUPLICATE_SAME_ACCESS))
d291 1
a291 1
  int c_flags = GetPriorityClass (hMainProc);
@


1.208
log
@Consistently use va_end.

* external.cc (cygwin_internal): Use va_end.
* fork.cc (child_copy): Likewise.
* libc/bsdlib.cc (warn, warnx, err, errx): Likewise.
* pinfo.cc (commune_request): Likewise.
* strace.cc (strace::prntf, strace_printf): Likewise.
@
text
@d305 7
d379 6
@


1.207
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d761 1
d766 1
@


1.206
log
@	* fork.cc (fork): Create local tmp_pathbuf.  Explain why.
@
text
@d245 1
a245 1
  wait_for_sigthread (true);
@


1.205
log
@	* fork.cc (frok::parent): Remove ancient code erroneously flushing
	stdout descriptor.
@
text
@d583 5
@


1.204
log
@* cygheap.h (mini_cygheap): New struct.
(init_cygheap): Inherit locale field via mini_cygheap.
* cygheap.cc (cygheap_at_start): Define new variable.
(cygheap): Initialize as cygheap_at_start so that locale information is always
available.
(cygheap_init): Initialize cygheap iff it is set to cygheap_at_start.
* shared_info.h (memory_init): Accommodate argument change.
* memory.cc (memory_init): Accept an argument indicating whether cygheap should
be initialized or not.
* dcrt0.cc (child_info_fork::handle_fork): Pass false to memory_init().
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Pass true to memory_init when not forking or execing.
* cygheap.h (cygheap_types::HEAP_2_DLL): New enum.
* dll_init.h (dll): Remove unused namelen field.
(dll_list::load_after_fork): Accommodate change in arguments.
* dll_init.cc (dll_list::alloc): Allocate dll information in the cygwin heap.
(dll_list::detach): Free dll information from the cygwin heap.
(dll_list::load_after_fork): Use dll information in the cygwin heap directly
rather than querying parent.
* fork.cc (frok::first_dll): Delete.
(frok::child): Don't report on first_dll.  Don't pass it to load_on_fork.
(frok::parent): Don't set first_dll.
(fork): Ditto.
@
text
@a309 4
  /* This will help some of the confusion.  */
  /* FIXME: Is this really appropriate?  What if stdout is closed? */
  fflush (stdout);

@


1.203
log
@	* ctype.cc (_CTYPE_DATA_0_127): Add _B class to TAB character.
	(__ctype_default): New character class array for default ASCII
	character set.
	(__ctype_iso): New array of character class array for ISO charsets.
	(__ctype_cp): Ditto for singlebyte Windows codepages.
	(tolower): Implement as distinct function to support any singlebyte
	charset.
	(toupper): Ditto.
	(__set_ctype): New function to copy singlebyte character classes
	corresponding to current charset to ctype_b array.
	Align copyright text to upstream.
	* dcrt0.cc (dll_crt0_1): Reset current locale to "C" per POSIX.
	* environ.cc (set_file_api_mode): Remove.
	(codepage_init): Remove.
	(parse_thing): Remove "codepage" setting.
	(environ_init): Set locale according to environment settings, or
	to current codepage, before converting environment to multibyte.
	* fhandler.h (fhandler_console::write_replacement_char): Drop argument.
	* fhandler_console.cc (dev_console::str_to_con): Call sys_cp_mbstowcs
	rather than MultiByteToWideChar.
	(fhandler_console::write_replacement_char): Always print a funny
	half filled square if a character isn't in the current charset.
	(fhandler_console::write_normal): Convert to using __mbtowc
	rather than next_char.
	* fork.cc (frok::child): Drop call to set_file_api_mode.
	* globals.cc (enum codepage_type) Remove.
	(current_codepage): Remove.
	* miscfuncs.cc (cygwin_wcslwr): Unused, dangerous.  Remove.
	(cygwin_wcsupr): Ditto.
	(is_cp_multibyte): Remove.
	(next_char): Remove.
	* miscfuncs.h (is_cp_multibyte): Drop declaration.
	(next_char): Ditto.
	* strfuncs.cc (get_cp): Remove.
	(__db_wctomb): New function to implement _wctomb_r functionality for
	doublebyte charsets using WideCharToMultiByte.
	(__sjis_wctomb): New function to replace unusable newlib function.
	(__jis_wctomb): Ditto.
	(__eucjp_wctomb): Ditto.
	(__gbk_wctomb): New function.
	(__kr_wctomb): Ditto.
	(__big5_wctomb): Ditto.
	(__db_mbtowc): New function to implement _mbtowc_r functionality for
	doublebyte charsets using MultiByteToWideChar.
	(__sjis_mbtowc): New function to replace unusable newlib function.
	(__jis_mbtowc): Ditto.
	(__eucjp_mbtowc): Ditto.
	(__gbk_mbtowc): New function.
	(__kr_mbtowc): New function
	(__big5_mbtowc): New function
	(__set_charset_from_codepage): New function.
	(sys_wcstombs): Reimplement, basically using same wide char to multibyte
	conversion as newlib's application level functions.  Plus extras.
	Add lengthy comment to explain.  Change return type to size_t.
	(sys_wcstombs_alloc): Just use sys_wcstombs.  Change return type to
	size_t.
	(sys_cp_mbstowcs): Replace sys_mbstowcs, take additional codepage
	argument.  Explain why.  Change return type to size_t.
	(sys_mbstowcs_alloc): Just use sys_mbstowcs.  Change return type to
	size_t.
	* wchar.h: Declare internal functions implemented in strfuncs.cc.
	(wcscasecmp): Remove.
	(wcsncasecmp): Remove.
	(wcslwr): Remove.
	(wcsupr): Remove.
	* winsup.h (codepage_init): Remove declaration.
	(get_cp): Ditto.
	(sys_wcstombs): Align declaration to new implementation.
	(sys_wcstombs_alloc): Ditto.
	(sys_cp_mbstowcs): Add declaration.
	(sys_mbstowcs): Define as inline function.
	(sys_mbstowcs_alloc): Align declaration to new implementation.
	(set_file_api_mode): Remove declaration.
	* include/ctype.h (isblank): Redefine to use _B character class.
	(toupper): Remove ASCII-only definition.
	(tolower): Ditto.
@
text
@a36 1
  dll *first_dll;
d176 1
a176 2
  sigproc_printf ("hParent %p, child 1 first_dll %p, load_dlls %d", hParent,
		  first_dll, load_dlls);
d231 1
a231 1
      dlls.load_after_fork (hParent, first_dll);
d305 3
a307 5
  /* Remember the address of the first loaded dll and decide
     if we need to load dlls.  We do this here so that this
     information will be available in the parent and, when
     the stack is copied, in the child. */
  first_dll = dlls.start.next;
d311 1
a569 1
  grouped.first_dll = NULL;
@


1.202
log
@ChangeLog:

	* configure.in: Remove --enable-server option.  Allways add the
	cygserver directory to $SUBDIRS.
	* configure: Regenerate.

cygwin/ChangeLog:

	Remove USE_SERVER define.  Accommodate throughout.
	* configure.in: Remove --enable-server option.
	* configure: Regenerate.
	* environ.cc: Remove CYGWIN=server setting.

cygserver/ChangeLog:

	* client.cc (allow_server): Remove variable.
	(client_request_get_version::client_request_get_version): Drop checking
	allow_server.

utils/ChangeLog:

	* passwd.c: Remove CYGWIN=server requirement from usage text.

doc/ChangeLog:

	* cygserver.sgml: Remove the "How to use the Cygserver services"
	section.
	* cygwinenv.sgml: Move "(no)server" to the removed options section.
	* faq-programming.xml: Remove CYGWIN=server requirement for running
	the Cygwin testsuite.
	* ntsec.sgml: Ditto for using `passwd -R'.
@
text
@a207 2
  set_file_api_mode (current_codepage);

@


1.201
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@a211 1
#ifdef USE_SERVER
a220 1
#endif
@


1.200
log
@	* dtable.cc (dtable::release): Drop fixup_before handling.
	(dtable::fixup_before_fork): Remove.
	(dtable::fixup_before_exec): Remove.
	* dtable.h (class dtable): Remove cnt_need_fixup_before member.
	(dtable::dtable): Accommodate above change.
	(dtable::dec_need_fixup_before): Remove.
	(dtable::inc_need_fixup_before): Remove.
	(dtable::need_fixup_before): Remove.
	(dtable::fixup_before_exec): Remove declaration.
	(dtable::fixup_before_fork): Ditto.
	* fhandler.h (fhandler_base::fixup_before_fork_exec): Remove.
	(fhandler_base::need_fixup_before): Remove.
	* fork.cc (frok::parent): Drop fixup_before handling.
	* spawn.cc (spawn_guts): Ditto.
@
text
@d4 1
a4 1
   2007, 2008 Red Hat, Inc.
a16 1
#include "security.h"
a25 1
#include "perprocess.h"
@


1.199
log
@Remove unneeded header files from source files throughout.
@
text
@a312 7
  /* Some file types (currently only sockets) need extra effort in the
     parent after CreateProcess and before copying the datastructures
     to the child. So we have to start the child in suspend state,
     unfortunately, to avoid a race condition. */
  if (cygheap->fdtab.need_fixup_before ())
    c_flags |= CREATE_SUSPENDED;

a384 8
      /* Fixup the parent datastructure if needed and resume the child's
	 main thread. */
      if (c_flags & CREATE_SUSPENDED)
	{
	  cygheap->fdtab.fixup_before_fork (pi.dwProcessId);
	  ResumeThread (pi.hThread);
	}

@


1.198
log
@	* Fix copyright dates.
@
text
@a15 1
#include <stdarg.h>
a28 2
#include "sync.h"
#include "shared_info.h"
a29 1
#include "cygthread.h"
@


1.197
log
@	* smallprint.cc (__small_vswprintf): Fix uninitialized usage of `w'.

	Revamp advisory file locking to avoid cross reference pointers as well
	as to allow BSD flock semantics.  More agressively delete unused nodes
	and sync objects.
	* fhandler.h (fhandler_base::ino): Rename from namehash.  Fix comment.
	(fhandler_base::node): Remove.
	(fhandler_base::unique_id): Add.
	(fhandler_base::del_my_locks): New method.
	(get_ino): Rename from get_namehash.  Change usage throughout Cygwin.
	(get_unique_id): New method.
	* fhandler.cc (fhandler_base::close): Call own del_my_locks method.
	Fix comment.
	(fhandler_base::fhandler_base): Accommodate new and changed members.
	(fhandler_base::fixup_after_fork): Call del_my_locks.
	(fhandler_base::fixup_after_exec): Ditto for files with close-on-exec
	flag set.
	* fhandler_disk_file.cc (get_ino_by_handle): Rename from
	readdir_get_ino_by_handle.  Accommodate throughout.
	(fhandler_base::open_fs): Fill ino with inode number if FS has good
	inodes.  Allocate a LUID and store in unique_id to recognize file
	descriptors referencing the same file object.
	* flock.cc: Drop flock TODO comments.  Use explicit types __dev32_t
	and __ino64_t instead of dev_t and ino_t.
	(LOCK_OBJ_NAME_LEN): Change to reflect longer lf_id length.
	(get_obj_handle_count): New method.
	(lockf_t::lf_id): Change type to long long.
	(inode_t::get_lock_obj_handle_count): Drop in favor of static function
	get_obj_handle_count.
	(inode_t::del_locks): Remove.
	(inode_t::get): Add create_if_missing flag argument.
	(inode_t::del_my_locks): Reimplement to handle POSIX and BSD flock
	locks.  Return if node can be deleted or not.
	(inode_t::~inode_t): Ditto.  Close handles to i_dir and i_mtx.
	(fixup_lockf_after_fork): Remove.
	(fhandler_base::del_my_locks): New method.
	(fixup_lockf_after_exec): Check if node can be deleted.
	(inode_t::get): Only create node if create_if_missing is set.  Lock
	the returned node here before unlocking the node list.
	(inode_t::get_all_locks_list): Accommodate new lf_id length.
	(inode_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.  Change return type to bool.  De-const.
	Set lf_obj instead of returning a handle.
	(lockf_t::del_lock_obj): Call SetEvent only if new incoming parameters
	allow it.  Explain how it's supposed to work.
	(fhandler_disk_file::lock): Only fetch file length in SEEK_END case.
	Use NtQueryInformationFile(FileStandardInformation) instead of
	calling fstat_by_handle.  Always unlock node before returning.
	Use fhandler's unique id to create lf_id for BSD flock locks.
	Rely on node lock from inode_t::get.  Call del_lock_obj on removed
	locks here to allow explicit unlocking.  Delete node if no lock exists
	on the file anymore.
	(lf_setlock): Get file handle as additional parameter.  Handle the fact
	that lf_getblock now always opens the attached event object.  Reactivate
	erroneously applied patch which deactivates setting thread priority.
	Additionally handle blocking on BSD flock locks.
	(lf_clearlock): Get file handle as additional parameter.
	(lf_getlock): Close event handle opened by lf_getblock.
	(lf_getblock): Open potentially blocking event object here and check
	its signal state if it's a BSD flock lock.
	(lf_wakelock): Get file handle as additional parameter.
	* fork.cc (frok::child): Drop call to fixup_lockf_after_fork.
	* ntdll.h (struct _EVENT_BASIC_INFORMATION): Define.
	(enum _EVENT_INFORMATION_CLASS): Define.
	(NtQueryEvent): Declare.

	* fhandler.h (fhandler_base::fs_flags): Remove.
	(fhandler_base::set_fs_flags): Remove.
	(fhandler_base::get_fs_flags): Remove.
	* fhandler.cc (fhandler_base::write): Check for sparse file using
	pc.fs_flags().
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.

	The return of the volume serial number in fs_info.
	* fhandler.h (get_dev): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call to
	NtQueryVolumeInformationFile(FileFsVolumeInformation).  Just use
	get_dev() method.
	* fhandler_fifo.cc (fhandler_fifo::open) Use device ID and inode number
	to generate fifo name.
	* path.h (fs_info::sernum): New member.
	(fs_info::serial_number): New method.
	(path_conv::fs_serial_number): New method.
	* path.cc (fs_info::update): Fetch volume serial number and store in
	sernum.
@
text
@d4 1
a4 1
   2007 Red Hat, Inc.
@


1.196
log
@	* fhandler.cc (fhandler_base::dup): Drop setting flags in the parent.

	Implement advisory file locking.
	* cygheap.h (struct init_cygheap): Add inode_list member.
	* cygwin.din (lockf): Export.
	* dcrt0.cc (child_info_spawn::handle_spawn): Call
	fixup_lockf_after_exec.
	* dtable.h (class dtable): Add fhandler_disk_file as friend class.
	* fhandler.cc (fhandler_base::close): Call del_my_locks if node is set.
	(fhandler_base::fhandler_base): Initialize node to NULL.
	(fhandler_base::fixup_after_fork): Ditto.
	* fhandler.h (class fhandler_base): Add member node.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Delete.
	* flock.cc: Implement all advisory file locking here.
	(fhandler_disk_file::lock): Implement here.
	(flock): Call fcntl with F_FLOCK bit set.  Remove test main function.
	(lockf): New function.
	* fork.cc (frok::child): Call fixup_lockf_after_fork.
	* ntdll.h (DIRECTORY_ALL_ACCESS): Define.
	(struct _OBJECT_BASIC_INFORMATION): Define.
	(enum _EVENT_TYPE): Define.
	(NtCreateDirectoryObject): Declare.
	(NtCreateEvent): Declare.
	(NtCreateMutant): Declare.
	(NtOpenEvent): Declare.
	(NtOpenMutant): Declare.
	* include/cygwin/version.h: Bump API minor number.
@
text
@a256 1
  fixup_lockf_after_fork ();
@


1.195
log
@	* Makefile.in (DLL_OFILES): Add tls_pbuf.o.
	* autoload.cc (CreateDesktopW): Replace CreateDesktopA.
	(CreateWindowStationW): Replace CreateWindowStationA.
	(GetUserObjectInformationW): Replace GetUserObjectInformationA.
	* cygheap.h (cwdstuff::get): Assume default buffer size NT_MAX_PATH.
	* cygtls.cc (_cygtls::remove): Free temporary TLS path buffers.
	* cygtls.h (TP_NUM_C_BUFS): Define.
	(TP_NUM_W_BUFS): Define.
	(class tls_pathbuf): New class to store pointers to thread local
	temporary path buffers.
	(_local_storage::pathbufs): New member.
	* environ.cc (win_env::add_cache): Use temporary TLS path buffer instead
	of stack based buffer.
	(posify): Get temporary outenv buffer from calling function.
	(environ_init): Create temporary TLS path buffer for posify.
	(build_env): Create Windows environment block as WCHAR buffer.
	* environ.h (build_env): Change declaration accordingly.
	* external.cc (sync_winenv): Accommodate build_env change.
	* fhandler_console.cc (fhandler_console::need_invisible): Use
	GetUserObjectInformationW and CreateWindowStationW.
	* fhandler_process.cc (format_process_maps): Use temporary TLS path
	buffer instead of stack based buffer.
	* fork.cc (frok::parent): Convert to use CreateProcessW.
	* path.cc: Throughout use temporary TLS path buffers instead of stack
	based buffer.  Replace checks for CYG_MAX_PATH by checks for
	NT_MAX_PATH.
	(getfileattr): New function to replace GetFileAttributesA.
	(normalize_win32_path): Remove Win32 and NT long path prefixes.
	(getwd): Assume PATH_MAX + 1 buffer per SUSv3.
	* path.h (class path_conv): Set path buffer to size NT_MAX_PATH.
	(iswdrive): Define.
	* pinfo.cc (commune_process): Use temporary TLS path buffer instead of
	stack based buffer.
	* registry.cc (get_registry_hive_path): Ditto.
	(load_registry_hive): Ditto.
	* spawn.cc (spawn_guts): Convert to use CreateProcessW and
	CreateProcessAsUserW.
	(av::fixup): Open/close file using NtOpenFile/NtClose.
	* syscalls.cc (mknod_worker): Allow PATH_MAX file name.
	(mknod32): Ditto.
	(getusershell): Ditto.
	* tls_pbuf.cc: New file implementing tls_pathbuf and tmp_pathbuf
	methods.
	* tls_pbuf.h: New header for files using tmp_pathbuf.
	* tlsoffsets.h: Regenerate.
	* winsup.h (NT_MAX_PATH): Define as 32767 to avoid USHORT overflow.
@
text
@d176 1
d257 1
@


1.194
log
@	* dcrt0.cc (initial_env): Only use local buffer "buf" if DEBUGGING is
	enabled.  Replace calls to GetEnvironmentVariable by calls to
	GetEnvironmentVariableA for clarity.  Call GetEnvironmentVariableA
	with NULL buffer.
	(cygbench): Ditto, drop local buffer.
	* environ.cc (getearly): Call GetEnvironmentVariableA.
	(environ_init): Retrieve unicode environment and convert to current
	codepage locally.
	(getwinenveq): Ditto.
	* exceptions.cc (try_to_debug): Accommodate new sys_mbstowcs calling
	convention.
	* fhandler_clipboard.cc (set_clipboard): Call sys_mbstowcs to retrieve
	required buffer length.
	* fork.cc (frok::child): Call GetEnvironmentVariableA.
	* miscfuncs.cc: Accommodate changed arguments in calls to sys_mbstowcs.
	* sec_auth.cc: Ditto.
	* strfuncs.cc (sys_wcstombs_alloc): Fix formatting.
	(sys_mbstowcs): Change arguments to allow specifying a source string
	length.
	(sys_mbstowcs_alloc): Ditto.
	* uinfo.cc (cygheap_user::ontherange): Accommodate changed arguments in
	calls to sys_mbstowcs.
	* winsup.h (sys_mbstowcs): Adjust declaration.
	(sys_mbstowcs_alloc): Ditto.
@
text
@d27 1
d352 1
a352 1
  STARTUPINFO si;
d355 1
a355 1
  si.cb = sizeof (STARTUPINFO);
d360 7
a366 2
  syscall_printf ("CreateProcess (%s, %s, 0, 0, 1, %p, 0, 0, %p, %p)",
		  myself->progname, myself->progname, c_flags, &si, &pi);
d376 10
a385 10
      rc = CreateProcess (myself->progname, /* image to run */
			  myself->progname, /* what we send in arg0 */
			  &sec_none_nih,
			  &sec_none_nih,
			  TRUE,	  /* inherit handles from parent */
			  c_flags,
			  NULL,	  /* environment filled in later */
			  0,	  /* use current drive/directory */
			  &si,
			  &pi);
d390 1
a390 1
	  error = "CreateProcessA failed";
@


1.193
log
@* fork.cc: White space.
* net.cc: Ditto.
* posix_ipc.cc: Ditto.
@
text
@d200 1
a200 2
  char c;
  if (GetEnvironmentVariable ("FORKDEBUG", &c, 1))
d205 1
a205 1
  if (GetEnvironmentVariable ("CYGWIN_FORK_SLEEP", buf, sizeof (buf)))
@


1.192
log
@* fork.cc (fork): Reset child to true after fork since it may have been reset
by fork memory copies.
@
text
@d101 1
a101 1
     
d104 1
a104 1
     
@


1.191
log
@	Throughout remove all usage of wincap.has_security.
	* environ.cc (environ_init): Drop setting allow_ntsec here.
	* grp.cc (initgroups32): Drop usage of label "out".
	* security.cc (allow_ntsec): Set to true by default.
	* syscalls.cc (seteuid32): Remove label success_9x.
	* wincap.cc: Remove has_security throughout.
	* wincap.h: Ditto.
@
text
@d97 1
a623 1

d627 4
a630 1
      res = grouped.child (esp);
@


1.190
log
@* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Change sense of guard test.
Increase size of stack reserved and increase size before the current stack
pointer.  Use pointers when doing arithmetic.
(dll_crt0_1): Initialize exception handler when we notice we're the child of a
fork from non-main thread.
* fork.cc (frok::parent): Make argument volatile.
(frok::child): Ditto.
(lock_signals): New class.
(lock_pthread): Ditto.
(hold_everhthing): Ditto.
(frok::parent): Move atforkprepare and atforkparent to lock_pthread class.
(fork): Make ischild boolean.  Use hold_everything variable within limited
scope to set various mutexes in such a way as to avoid deadlocks.
* thread.h (pthread_mutex::tid): New variable, active when debugging for
tracking thread id of owner.
(pthread_mutex::set_owner): Set tid when debugging.
* thread.cc (pthread_mutex::pthread_mutex): Clear tid.
(pthread_mutex::_unlock): Ditto when unlocking.
(pthread_mutex::fixup_after_fork): Set tid to special value after forking since
owner is unknown.
@
text
@d194 3
a196 6
  if (wincap.has_security ())
    {
      set_cygwin_privileges (hProcToken);
      clear_procimptoken ();
      cygheap->user.reimpersonate ();
    }
@


1.189
log
@	* fork.cc (child_copy): Add missing Windows PID in debug output.
@
text
@d48 2
a49 2
  int __stdcall parent (void *esp);
  int __stdcall child (void *esp);
d53 76
d171 1
a171 1
frok::child (void *)
d292 1
a292 1
frok::parent (void *stack_here)
a302 2
  pthread::atforkprepare ();

d348 1
a348 1
  ch.stacktop = stack_here;
a568 1
  pthread::atforkparent ();
a591 1
  MALLOC_CHECK;
d598 1
a598 1
  int ischild;
d610 12
a621 8
  lock_process now;
  if (sig_send (NULL, __SIGHOLD))
    {
      if (exit_state)
	Sleep (INFINITE);
      set_errno (EAGAIN);
      return -1;
    }
d623 2
a624 1
  ischild = setjmp (grouped.ch.jmp);
a625 2
  void *esp;
  __asm__ volatile ("movl %%esp,%0": "=r" (esp));
d627 3
a629 2
  if (ischild)
    {
d631 1
a631 7
      now.dont_bother ();
    }
  else
    {
      res = grouped.parent (esp);
      sig_send (NULL, __SIGNOHOLD);
    }
@


1.188
log
@	Partially revert change from 2005-04-03, always running under an
	impersonation token, which collides with Vista UAC.
	* cygheap.h (deimpersonate): revert to self instead of impersonating
	hProcImpToken.
	(reimpersonate): Only impersonate if setuid.
	* dcrt0.cc (dll_crt0_0): Don't initialize hProcImpToken here.
	(dll_crt0_1): Set privileges on hProcToken.
	* fork.cc (frok::child): Set privileges on hProcToken.  Close handle to
	hProcImpToken.
	* grp.cc (internal_getgroups): Use hProcToken instead of hProcImpToken.
	* security.cc (check_access): Create hProcImpToken on demand here.
	* security.h (set_process_privilege): Set privileges on hProcToken.
	(_push_thread_privilege): Use hProcToken instead of hProcImpToken.
	(pop_thread_privilege): If not setuid'ed, revert to self.
	* syscalls.cc (setegid32): Drop setting primary group on hProcImpToken.
	Close handle to hProcImpToken.
	* uinfo.cc (internal_getlogin): Ditto.
	* winsup.h (clear_procimptoken): New inline function.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006
   Red Hat, Inc.
d707 1
a707 1
			    what, huh[write], low, high, done);
@


1.187
log
@* child_info.h (child_info_spawn::__stdin): New element.
(child_info_spawn::__stdin): Ditto.
(CURR_CHILD_INFO_MAGIC): Regenerate.
* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
(child_info_spawn::handle_spawn): Handle new __std* elements by calling
move_fd.
* dtable.cc (dtable::move_fd): Define new function.
* dtable.h (dtable::move_fd): Declare new function.
* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
(fhandler_pipe::dup): Ditto.
* spawn.cc (handle): Change second argument to bool.
(spawn_guts): Accept __stdin/__stdout arguments and set them appropriately in
child_info structure and in STARTUPINFO structure.
* syscalls.cc (popen): New cygwin-specific implementation using spawn.
(pclose): Ditto.
* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.
* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.
* child_info.h (child_info::msv_count): Rename from the now-inappropriate
"zero".
(child_info_spawn::filler): Add filler to work around Vista bug.
(child_info_fork::filler): Ditto.
* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is now
always filled out.
* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
* sigproc.cc (child_info::child_info): Initialize starter[].
* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d120 2
a121 1
      set_cygwin_privileges (hProcImpToken);
@


1.186
log
@	* dcrt0.cc (get_cygwin_startup_info): Change zeros to DWORD array.
	Expect first DWORD in child_info struct being set to non-zero if
	wincap.needs_count_in_si_lpres2 is set.  Add comment to explain why.
	* fork.cc (frok::parent): Set ch.zero[0] to a sensible count value
	if wincap.needs_count_in_si_lpres2 is set.
	* spawn.cc (spawn_guts): Ditto.  Add filler bytes after ch on stack
	to accomodate needs_count_in_si_lpres2.
	* wincap.h: Define needs_count_in_si_lpres2 throughout.
	* wincap.cc: Ditto.
@
text
@a286 4
  /* See comment in dcrt0.cc, function get_cygwin_startup_info. */
  if (wincap.needs_count_in_si_lpres2 ())
    ch.zero[0] = sizeof (ch) / 5;

@


1.185
log
@* fork.cc (fork): Lock the process before forking to prevent things like new
fds from being opened, etc.
* sync.h (lock_process::dont_bother): New function.
@
text
@d283 1
d287 4
@


1.185.2.1
log
@	* dcrt0.cc (get_cygwin_startup_info): Change zeros to DWORD array.
	Expect first DWORD in child_info struct being set to non-zero if
	wincap.needs_count_in_si_lpres2 is set.  Add comment to explain why.
	* fork.cc (frok::parent): Set ch.zero[0] to a sensible count value
	if wincap.needs_count_in_si_lpres2 is set.
	* spawn.cc (spawn_guts): Ditto.  Add filler bytes after ch on stack
	to accomodate needs_count_in_si_lpres2.
	* wincap.h: Define needs_count_in_si_lpres2 throughout.
	* wincap.cc: Ditto.
@
text
@a282 1

a285 4
  /* See comment in dcrt0.cc, function get_cygwin_startup_info. */
  if (wincap.needs_count_in_si_lpres2 ())
    ch.zero[0] = sizeof (ch) / 5;

@


1.185.2.2
log
@2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006,
   2007 Red Hat, Inc.
d710 1
a710 1
			    what, huh[write], low, high, done, myself->dwProcessId);
@


1.185.2.3
log
@2007-01-13  Christopher Faylor  <me@@cgf.cx>

	* glob.cc: Update copyright notice with latest from FreeBSD.
	(glob0): Use correct type for c variable to propagate previously
	detected protection.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (_csbrk): Fix off-by-one error.
	* cygwin.sc: Give .cygheap a minimum size of 512K.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fork.cc (child_copy): Add missing Windows PID in debug output.

2007-01-12  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc: Update copyright.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (mmap64): Pre-Reserve space for the whole mapping to get a
	useful, valid address before the actual mappings take place.
	Fix typo in comment.

2007-01-10  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (sync): Use b_drive for B: drive (Thanks to Howard Chu).

2007-01-09  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc: Do bookkeeping in 4K pages, rather than in 64K chunks.

2007-01-01  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Don't expect synchronization from a non-cygwin
	_P_NOWAIT process.

2006-12-12  Christopher Faylor  <me@@cgf.cx>

	* syscalls.cc (popen): Allow '[rw][bt]'.

2006-12-11  Christopher Faylor  <me@@cgf.cx>

	* sigproc.cc (child_info::child_info): Move old comment about msv_count
	here.  Edit it slightly to reflect new sensibilities.

2006-12-11  Christopher Faylor  <me+cygwin@@cgf.cx>

	* child_info.h (child_info_spawn::__stdin): New element.
	(child_info_spawn::__stdin): Ditto.
	(CURR_CHILD_INFO_MAGIC): Regenerate.
	* dcrt0.cc (check_sanity_and_sync): Minor cleanup.
	(child_info_spawn::handle_spawn): Handle new __std* elements by calling
	move_fd.
	* dtable.cc (dtable::move_fd): Define new function.
	* dtable.h (dtable::move_fd): Declare new function.
	* fhandler.h (fhandler_pipe::popen_pid): Declare new element.
	* fhandler.h (fhandler_pipe::get_popen_pid): Define new function.
	* fhandler.h (fhandler_pipe::set_popen_pid): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Zero popen_pid.
	(fhandler_pipe::dup): Ditto.
	* spawn.cc (handle): Change second argument to bool.
	(spawn_guts): Accept __stdin/__stdout arguments and set them
	appropriately in child_info structure and in STARTUPINFO structure.
	* syscalls.cc (popen): New cygwin-specific implementation using spawn.
	(pclose): Ditto.
	* winsup.h (spawn_guts): Accommodate new arguments for spawn_guts.

	* fhandler.cc (fhandler_base::set_no_inheritance): Make second arg a bool.
	* fhandler.h (fhandler_base::set_no_inheritance): Ditto for declaration.

	* child_info.h (child_info::msv_count): Rename from the now-inappropriate
	"zero".
	(child_info_spawn::filler): Add filler to work around Vista bug.
	(child_info_fork::filler): Ditto.
	* dcrt0.cc (get_cygwin_startup_info): Remove "zero" check since it is
	now always filled out.
	* fork.cc (frok::parent): Move ch.zero manipulation to constructor.
	* spawn.cc (spawn_guts): Ditto.  Remove _ch wrapper.
	* sigproc.cc (child_info::child_info): Initialize starter[].

	* shared.cc (shared_info::heap_slop_size): Remove noisy system_printfs.
	* shared_info.h (CURR_SHARED_MAGIC): Regenerate.
@
text
@d287 4
@


1.185.2.4
log
@2007-03-01  Christopher Faylor  <me@@cgf.cx>

	* fork.cc (fork): Reset child to true after fork since it may have been
	reset by fork memory copies.

2007-02-22  Christopher Faylor  <me@@cgf.cx>

	* fork.cc (frok::parent): Make argument volatile.
	(frok::child): Ditto.
	(lock_signals): New class.
	(lock_pthread): Ditto.
	(hold_everhthing): Ditto.
	(frok::parent): Move atforkprepare and atforkparent to lock_pthread
	class.
	(fork): Make ischild boolean.  Use hold_everything variable within
	limited scope to set various mutexes in such a way as to avoid
	deadlocks.
@
text
@d48 2
a49 2
  int __stdcall parent (volatile char * volatile here);
  int __stdcall child (volatile char * volatile here);
a52 77
class lock_signals
{
  bool worked;
public:
  lock_signals ()
  {
    worked = sig_send (NULL, __SIGHOLD) == 0;
  }
  operator int () const
  {
    return worked;
  }
  void dont_bother ()
  {
    worked = false;
  }
  ~lock_signals ()
  {
    if (worked)
      sig_send (NULL, __SIGNOHOLD);
  }
};

class lock_pthread
{
  bool bother;
public:
  lock_pthread (): bother (1)
  {
    pthread::atforkprepare ();
  }
  void dont_bother ()
  {
    bother = false;
  }
  ~lock_pthread ()
  {
    if (bother)
      pthread::atforkparent ();
  }
};

class hold_everything
{
public: /* DELETEME*/
  bool& ischild;
  /* Note the order of the locks below.  It is important,
     to avoid races, that the lock order be preserved.
     
     pthread is first because it serves as a master lock
     against other forks being attempted while this one is active.
     
     signals is next to stop signal processing for the duration
     of the fork.

     process is last.  If it is put before signals, then a deadlock
     could be introduced if the process attempts to exit due to a signal. */
  lock_pthread pthread;
  lock_signals signals;
  lock_process process;

public:
  hold_everything (bool& x): ischild (x) {}
  operator int () const {return signals;}

  ~hold_everything()
  {
    if (ischild)
      {
	pthread.dont_bother ();
	process.dont_bother ();
	signals.dont_bother ();
      }
  }

};

d95 1
a95 1
frok::child (volatile char * volatile here)
d215 1
a215 1
frok::parent (volatile char * volatile stack_here)
d226 2
d273 1
a273 1
  ch.stacktop = (void *) stack_here;
d494 1
d518 1
d525 1
a525 1
  bool ischild = false;
d537 8
a544 2
  {
    hold_everything held_everything (ischild);
d546 1
a546 7
    if (!held_everything)
      {
	if (exit_state)
	  Sleep (INFINITE);
	set_errno (EAGAIN);
	return -1;
      }
d548 2
a549 1
    ischild = !!setjmp (grouped.ch.jmp);
d551 7
a557 4
    volatile char * volatile esp;
    __asm__ volatile ("movl %%esp,%0": "=r" (esp));

    if (!ischild)
d559 2
a560 6
    else
      {
	res = grouped.child (esp);
	ischild = true;	/* might have been reset by fork mem copy */
      }
  }
@


1.184
log
@* hookapi.cc: Add comment header
(putmem): Make static.
(get_export): Ditto.
(rvadelta): Ditto.  Don't assume that a section which ends where the import_rva
begins is the import list.
* child_info.h: Update copyright.
* fork.cc: Ditto.
@
text
@d536 1
d551 4
a554 1
    res = grouped.child (esp);
@


1.183
log
@* dcrt0.cc (child_info_fork::handle_fork): Set uid/gid in myself so that it can
be used by subsequent startup functions.
(dll_crt0_0): Issue a warning if DuplicateTokenEx fails and DEBUGGING.
(dll_crt0_1): Move user_data->{resourcelocks,threadinterface} initialization
here from dll_crt0_0.
* fork.cc (frok::child): Tell wait_for_sigthread that this is fork.
(frok::parent): Only initialize start_time once.  Tighten time when we're
"deimpersonated".
* sigproc.cc (signal_fixup_after_exec): Rework (futiley) sa_buf stuff.  Add
debugging output.
(wait_for_sigthread): Accept an argument which illustrates whether we are
forked or not.
(wait_sig): Avoid using myself pointer.
* winsup.h ((wait_for_sigthread): Reflect change to argument.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005
@


1.183.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006
@


1.183.2.2
log
@	* Merge HEAD into cv-branch.
@
text
@a535 1
  lock_process now;
d550 1
a550 4
    {
      res = grouped.child (esp);
      now.dont_bother ();
    }
@


1.182
log
@* fhandler.cc (fcntl): Print flags in hex.
* dcrt0.cc (dll_crt0_0): Semi-revert 2006-03-14 change which moved pinfo_init
and uinfo_init here.
(dll_crt0_1): Ditto.
(__dll_crt0): Ditto.  Don't call update_envptrs here.
(dll_crt0_1): Ditto.  Move wait_for_sigthread call here from dll_crt0_0.
* environ.cc (environ_init): Call it here instead.
* sigproc.cc (my_readsig): New static variable.
(wait_for_sigthread): Set up read pipe here since we are assured that we have
the proper privileges when this is called.
(talktome): Eliminate second argument since it is available as a global now.
(wait_sig): Reflect use of my_readsig.
@
text
@d181 1
a181 1
  wait_for_sigthread ();
d286 5
a294 4
  syscall_printf ("CreateProcess (%s, %s, 0, 0, 1, %p, 0, 0, %p, %p)",
		  myself->progname, myself->progname, c_flags, &si, &pi);
  bool locked = __malloc_lock ();
  time_t start_time;
a296 1
      start_time = time (NULL);
d348 4
a372 4
  /* Restore impersonation */
  cygheap->user.reimpersonate ();
  fix_impersonation = false;

d399 4
a402 4
  /* Initialize, in order: data, bss, heap, stack, dll data, dll bss
     Note: variables marked as NO_COPY will not be copied
     since they are placed in a protected segment. */

@


1.181
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Regenerate.
(child_info::retry): Move here from fork subclass.
(child_info::exit_code): New field.
(child_info::retry_count): Max retry count for process start.
(child_info::proc_retry): Declare new function.
(child_info_fork::retry): Move to parent.
(child_info_fork::fork_retry): Ditto.
* dcrt0.cc (child_info::fork_retry): Rename and move.
(child_info_fork::handle_failure): Move.
(dll_crt0_0): Initialize console handler based on whether we have a controlling
tty or not.  Avoid nonsensical check for fork where it can never occur.
* environ.cc (set_proc_retry): Rename from set_fork_retry.  Set retry_count in
child_info.
(parse_thing): Reflect above change.
* exceptions.cc (dummy_ctrl_c_handler): Remove unused variable name.
(ctrl_c_handler): Always return TRUE for the annoying CTRL_LOGOFF_EVENT.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Remove call to
init_console_handler.
* fhandler_tty.cc (fhandler_tty_slave::open): Just call mange_console_count
here and let it decide what to do with initializing console control handling.
* fork.cc (fork_retry): Remove definition.
(frok::parent): Define static errbuf and use in error messages (not thread safe
yet).  Close pi.hThread as soon as possible.  Protect pi.hProcess as soon as
possible.  Don't set retry_count.  That happens automatically in the
constructor now.  Accommodate name change from fork_retry to proc_retry.
* init.cc (dll_entry): Turn off ctrl-c handling early until we know how it is
supposed to be handled.
* pinfo.cc (_pinfo::dup_proc_pipe): Remember original proc pipe value for
failure error message.  Tweak debug message slightly.
* sigproc.cc (child_info::retry_count): Define.
(child_info::child_info): Initialize retry count.
(child_info::sync): Set exit code if process dies before synchronization.
(child_info::proc_retry): Rename from child_info_fork::fork_retry.  Use
previously derived exit code.  Be more defensive about what is classified as an
error exit.
(child_info_fork::handle_failure): Move here from dcrt0.cc.
* spawn.cc (spawn_guts): Maintain error mode when starting new process to avoid
annoying pop ups.  Move deimpersonate call within new loop.  Move envblock
freeing to end.  Loop if process dies prematurely with bad exit code.
* syscalls.cc (init_console_handler): Remove hopefully unneeded call to
init_console_handler.
@
text
@d181 1
d549 2
a550 2
  if (!ischild)
    res = grouped.parent (esp);
d552 4
a555 1
    res = grouped.child (esp);
a574 1
  sig_send (NULL, __SIGNOHOLD);
@


1.180
log
@* child_info.h (child_info_fork::fork_retry): Declare new function.
* dcrt0.cc (child_info_fork::fork_retry): Define new function.
* fork.cc (frok::parent): Move retry decision into child_info_fork::fork_retry
and honor what it tells us to do.
* sigproc.cc (sig_send): Unhold signals on __SIGEXIT.
@
text
@a35 2
int fork_retry = 5;

d172 1
d223 1
a292 1
  ch.retry = fork_retry;
d323 6
d334 1
a334 1
	  DWORD exit_code = ch.fork_retry (pi.hProcess);
d339 1
a339 4
	  static char buf[sizeof("died waiting for longjmp before "
				 "initialization, retry 4294967295, "
				 "exit code 0xfffffffff")];
	  __small_sprintf (buf, "died waiting for longjmp before initialization, "
d341 1
a341 1
	  error = buf;
a371 5
  ProtectHandle (pi.hThread);
  /* Protect the handle but name it similarly to the way it will
     be called in subproc handling. */
  ProtectHandle1 (pi.hProcess, childhProc);

d426 5
d445 5
a449 1
	  error = "fork_copy for linked dll data/bss failed";
a489 1
  ForceCloseHandle (pi.hThread);
a491 1
  pi.hThread = NULL;
a505 2
  if (pi.hThread)
    ForceCloseHandle (pi.hThread);
@


1.179
log
@* fork.cc (frok::parent): Improve error message.
@
text
@d329 3
a331 6
	  DWORD exit_code;
	  if (GetExitCodeProcess (pi.hProcess, &exit_code) && exit_code == EXITCODE_RETRY)
	    {
	      ch.retry--;
	      continue;
	    }
@


1.178
log
@* child_info.h (child_info_fork::handle_failure): Declare new function.
(child_info_fork::retry): New field.
* dcrt0.cc (__api_fatal_exit_val): Define.
(child_info_fork::handle_failure): Define new function.
(__api_fatal): Exit using __api_fatal_exit_val value.
* environ.cc (set_fork_retry): Set fork_retry based on CYGWIN environment
variable.
(parse_thing): Add "fork_retry" setting.
* fork.cc (fork_retry): Define.
(frok::parent): Reorganize to allow retry of failed child creation if child
signalled that it was ok to do so.
* heap.cc (heap_init): Signal parent via handle_failure when VirtualAlloc
fails.
* pinfo.h (EXITCODE_RETRY): Declare.
* sigproc.cc (child_info::sync): Properly exit with failure condition if called
for fork and didn't see subproc_ready.
* spawn.cc (spawn_guts): Use windows pid as first argument.
* winsup.h: Remove obsolete NEW_MACRO_VARARGS define.
(__api_fatal_exit_val): Declare.
(set_api_fatal_return): Define.
(in_dllentry): Declare.
* exceptions.cc (inside_kernel): Remove unneeded in_dllentry declaration.
@
text
@d336 7
a342 1
	  error = "died waiting for longjmp before initialization";
@


1.177
log
@* dcrt0.cc (dll_crt0_0): Reorganize so that sigproc_init is called a little
later.  Add a comment.
* fork.cc (resume_child): Make void.
(frok::parent): Only zero pi when necessary.  Explicitly zero si.  Set
this_errno when child_copy fails.  Accommodate change to resume_child.
* sigproc.cc (sigalloc): Move global_sigs initialization here.
(sigproc_init): Move global_sigs.
(sig_send): Just check for flush signals once.
* wincap.h: Define supports_setconsolectrlhandler_null throughout.
* wincap.cc: Ditto.
@
text
@d36 2
d292 15
a306 10
  rc = CreateProcess (myself->progname, /* image to run */
		      myself->progname, /* what we send in arg0 */
		      &sec_none_nih,
		      &sec_none_nih,
		      TRUE,	  /* inherit handles from parent */
		      c_flags,
		      NULL,	  /* environment filled in later */
		      0,	  /* use current drive/directory */
		      &si,
		      &pi);
d308 17
a324 7
  if (!rc)
    {
      this_errno = geterrno_from_win_error ();
      error = "CreateProcessA failed";
      memset (&pi, 0, sizeof (pi));
      goto cleanup;
    }
d326 14
a339 6
  /* Fixup the parent datastructure if needed and resume the child's
     main thread. */
  if (c_flags & CREATE_SUSPENDED)
    {
      cygheap->fdtab.fixup_before_fork (pi.dwProcessId);
      ResumeThread (pi.hThread);
a341 2
  strace.write_childpid (ch, pi.dwProcessId);

d356 1
a356 1
  child->start_time = time (NULL); /* Register child's starting time. */
a394 8
  /* Wait for subproc to initialize itself. */
  if (!ch.sync (child->pid, pi.hProcess, FORK_WAIT_TIMEOUT))
    {
      this_errno = EAGAIN;
      error = "died waiting for longjmp before initialization";
      goto cleanup;
    }

@


1.176
log
@* cygtls.h (CYGTLS_INITIALIZED): Change to a little more unlikely value.
(CYGTLSMAGIC): Delete.
* dcrt0.cc (dll_crt0_0): Call sigproc_init during init startup.
(_dll_crt0): Don't worry about sync_startup.  Just wait for sigthread here.
* dll_init.cc (cygwin_detach_dll): Only pick up tls version of retaddr if we
have a valid tls.
* fork.cc (frok::child): Remove sigproc_init initialization since it happens
much earlier now.
* gendef: Recognize SIGFE_MAYBE.
(fefunc): Generate calls to _sigfe_maybe, if appropriate.
(_sigfe_maybe): New function.
* init.cc (search_for): Always initialize search_for, even on fork.
(calibration_thread): Delete.
(calibration_id): Delete.
(prime_threads): Delete.
(munge_threadfunc): Remove calibration_thread special case.  Avoid calling
thread function if we haven't yet hit the "search_for" thread.
(dll_entry): Remove prime_threads call.  Only call munge_threadfunc when
hwait_sig is active.  Ditto.  for _my_tls.remove ();
* sigproc.cc (hwait_sig): Make global.
(sigproc_init): Don't bother with sync_startup.
(sig_send): Treat flush as a no-op when signals are held.
(wait_sig): Cause signals to be held after fork.
@
text
@d53 1
a53 1
static int
d58 1
a58 1
  return 1;
a216 1
  PROCESS_INFORMATION pi = {0, NULL, 0, 0};
a226 1
  STARTUPINFO si = {0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL};
d275 4
d305 1
d409 4
a412 1
    goto cleanup;
d431 3
a433 4
  /* Start thread, and wait for it to reload dlls.  */
  if (!resume_child (forker_finished))
    goto cleanup;
  else if (!ch.sync (child->pid, pi.hProcess, FORK_WAIT_TIMEOUT))
@


1.175
log
@*** cygwin DLL Changes:
* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::dwProcessId): Delete.
(child_info::straced): New variable.
(child_info::handle_fork): New member function.
* dcrt0.cc (in_forkee): New global variable.
(__cygwin_user_data::forkee): Mark as obsolete.
(do_global_ctors): Use in_forkee rather than user_data->forkee.
(get_cygwin_startup_info): Ditto.  Deal with new straced field to allow strace
to deal with children of attached processes.
(initial_env): Accommodate changes to strace::hello.
(child_info_fork::handle_fork): Rename from plain old 'handle_fork'.  Move
alloc_stack() call elsewhere.
(dll_crt0_0): Fill out more of user_data.  Reference handle_fork via fork_info.
Add some debugging output.
(_dll_crt0): Don't wait for sync thread if sync_startup is invalid.  Zero
sync_startup here.  Call alloc_stack() here, if appropriate.
(dll_crt0_1): Use in_forkee rather than user_data->forkee.
(dll_crt0): Ditto.
* malloc_wrapper.cc (malloc_init): Ditto.
* dll_init.cc (in_forkee): Remove local static version of this variable.
(dll_list::load_after_fork): Don't set in_forkee here.
* external.cc (cygwin_internal): Use strace method rather than accessing field
directly.
* fhandler.cc (fhandler_base::read): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fork.cc (frok::parent): Invoke strace write_childpid to communicate with
potential strace.
(child_copy): Add more detail to debugging output.
* init.cc (calibration_id): New static variable.
(prime_threads): Set sync_startup to invalid handle if we already know about
thread_func_ix.  Use static calibration_id to hold calibration thread id.
* munge_threadfunc (munge_threadfunc): Don't try to debug if we don't find
threadfunc_ix.
(dll_entry): Avoid calling munge_threadfunc and _cygtls::remove on non-cygwin
threads invoked during process startup.
* pinfo.cc (set_myself): Always call strace.hello here regardless of DEBUGGING.
* sigproc.cc (child_info::child_info): Remove spurious handling of dwProcessId.
Set straced as appropriate.
* spawn.cc (spawn_guts): Rename ciresrv to ch.  Invoke strace write_childpid to
communicate with potential strace.
* strace.cc: Include child_info.h.
(strace::hello): Remove inited test.  Use active() method to test if strace has
been activated.  Handle case where we are started before
(mypid): New function.
(strace::vsprntf): Try to deal more intelligently with case where progname may
not be filled out.  Put pid in parentheses if it is a windows pid rather than a
cygwin pid.  myself has been filled out.
(strace::write_childpid): New function for notifying strace about the creation
of children.
(strace::vprntf): Use strace method rather than accessing field directly.
(strace_printf): Ditto.
(strace::wm): Ditto.
* winsup.h (in_forkee): Declare.
* include/sys/strace.h (strace::write_childpid): Declare new function.
(strace::attached): Define new function.
(strace::active): Ditto.
(strace::active_val): Ditto.
(_STRACE_ON): Delete.
(_STRACE_OFF): Ditto.
(define_strace0): Use strace method rather than accessing field directly.
(strace_printf_wrap): Ditto.
(strace_printf_wrap1): Ditto.

*** cygwin utils changes:
* strace.cc (nprocesses): Make static global.
(quiet): New variable.
(strace_active): Ditto.
(add_child): Increment nprocesses here.  Don't add a child if it is already
added (windows bug?).  Report on child if not quiet.
(get_child): Just return NULL if child not found.
(remove_child): Report on child if not quiet.
(attach_process): Don't complain if given a windows process.  Use windows pid
in error.
(handle_output_debug_string): Issue error if trying to manipulate a process
that we don't know about.  Handle _STRACE_CHILD_PID - attach to reported child
when we get this.
(proc_child): Move nprocesses to file scope.  Report on exceptions.
(longopts): Implement "--quiet".
(opts): Implement "-q".
(main): Manipulate quiet flag.
* utils.sgml (strace): Add words describing '-q'.
@
text
@a173 2
  sigproc_init ();

@


1.174
log
@* fork.cc (fork): Honor error return from sig_send.  Don't continue with fork
if we couldn't suspend signals.
* sigproc.cc (sig_send): Set sigCONT event when we see __SIGNOHOLD.
(wait_sig): Remove holding_signals.  Create pipe with a buffer which will
theoretically cause blocking if there is nothing reading on the pipe.  Wait for
sigCONT at end of loop when we have a __SIGHOLD.
@
text
@d310 1
a310 1
  if (cygheap->fdtab.need_fixup_before ())
d316 2
d667 1
a667 1
	  debug_printf ("hp %p, low %p, high %p, res %d", hp, low, high, res);
@


1.173
log
@* winsup.h (child_copy): Change prototype to match new functionality.
* cygheap.cc (cygheap_fixup_in_child): Accommodate new child_copy arguments.
* dcrt0.cc (dll_data_start): Move definition here from fork.
(dll_data_end): Ditto.
(dll_bss_start): Ditto.
(dll_bss_end): Ditto.
(handle_fork): New function.  Called when forked to deal with fork issues and
copy data to this process from the parent.
(dll_crt0_0): Call handle_fork when _PROC_FORK condition.
(dll_crt0): Don't copy user_data when we've forked.  Don't zero first element
of main_environment ever.
(cygwin_dll_init): Ditto.
* fork.cc (child_copy): Rename from fork_copy and change arguments so that each
pair of things to copy gets its own descriptor.
(frok::child): Remove fixup_mmaps_after_fork call here.  Move to handle_fork in
dcrt0.cc.
(frok::parent): Use child_copy rather than fork_copy and accommodate changes in
parameters.
* exceptions.cc (setup_handler): Delay test of whether we're locked until after
GetThreadContext has been called since there are apparently cases where
SuspendThread does not cause an immediate thread suspension.
@
text
@d510 8
a517 1
  sig_send (NULL, __SIGHOLD);
@


1.172
log
@* fork.cc (fork): Move top-of-stack calculation later.
* pinfo.cc (_pinfo::set_ctty): Use __ctty to print current console in debugging
output.
@
text
@a39 5
#define dll_data_start &_data_start__
#define dll_data_end &_data_end__
#define dll_bss_start &_bss_start__
#define dll_bss_end &_bss_end__

a52 54
/* Copy memory from parent to child.
   The result is a boolean indicating success.  */

static int
fork_copy (PROCESS_INFORMATION& pi, const char *what, ...)
{
  va_list args;
  char *low;
  int pass = 0;

  va_start (args, what);

  while ((low = va_arg (args, char *)))
    {
      char *high = va_arg (args, char *);
      DWORD todo = wincap.chunksize () ?: high - low;
      char *here;

      for (here = low; here < high; here += todo)
	{
	  DWORD done = 0;
	  if (here + todo > high)
	    todo = high - here;
	  int res;
	  if (pi.hThread)
	    res = WriteProcessMemory (pi.hProcess, here, here, todo, &done);
	  else
	    res = ReadProcessMemory (pi.hProcess, here, here, todo, &done);
	  debug_printf ("child handle %p, low %p, high %p, res %d", pi.hProcess,
			low, high, res);
	  if (!res || todo != done)
	    {
	      if (!res)
		__seterrno ();
	      /* If this happens then there is a bug in our fork
		 implementation somewhere. */
	      system_printf ("%s pass %d failed, %p..%p, done %d, windows pid %u, %E",
			    what, pass, low, high, done, pi.dwProcessId);
	      goto err;
	    }
	}

      pass++;
    }

  debug_printf ("done");
  return 1;

 err:
  TerminateProcess (pi.hProcess, 1);
  set_errno (EAGAIN);
  return 0;
}

a141 3
  if (fixup_mmaps_after_fork (hParent))
    api_fatal ("recreate_mmaps_after_fork_failed");

a307 1

d386 3
a388 2
  void *impure_beg;
  void *impure_end;
d390 1
a390 1
    impure_beg = impure_end = NULL;
d393 1
d397 4
a400 7
  rc = fork_copy (pi, "user/cygwin data",
		  user_data->data_start, user_data->data_end,
		  user_data->bss_start, user_data->bss_end,
		  cygheap->user_heap.base, cygheap->user_heap.ptr,
		  stack_here, ch.stackbottom,
		  dll_data_start, dll_data_end,
		  dll_bss_start, dll_bss_end, impure_beg, impure_end, NULL);
d412 4
a415 3
      if (!fork_copy (pi, "linked dll data/bss", d->p.data_start, d->p.data_end,
						 d->p.bss_start, d->p.bss_end,
						 NULL))
d445 4
a448 3
	  if (!fork_copy (pi, "loaded dll data/bss", d->p.data_start, d->p.data_end,
						     d->p.bss_start, d->p.bss_end,
						     NULL))
d631 4
a634 2
int
child_copy (HANDLE h, DWORD pid, const char *what, void *child_start, void *child_end)
d636 43
a678 6
  PROCESS_INFORMATION pi;
  pi.hProcess = h;
  pi.dwProcessId = pid;
  pi.hThread = NULL;
  debug_printf ("%s, start %p, end %p", what, child_start, child_end);
  return fork_copy (pi, what, child_start, child_end, NULL);
@


1.171
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@a559 1
  void *esp;
a561 2
  __asm__ volatile ("movl %%esp,%0": "=r" (esp));

d574 4
@


1.170
log
@* times.cc (hires_ms::prime): More debugging.
(hires_ms::usecs): Ditto.
@
text
@d650 2
a651 2
      vf->open_fhs = cygheap->open_fhs;
      debug_printf ("cygheap->ctty_on_hold %p, cygheap->open_fhs %d", cygheap->ctty_on_hold, cygheap->open_fhs);
d671 1
a671 1
  cygheap->open_fhs = vf->open_fhs;
@


1.169
log
@* exceptions.cc (signal_exit): Eliminate setting of main thread priority since
process lock should make that unnecessary.
* fork.cc (stack_base): Eliminate.
(frok::parent): Subsume stack_base and just set stack stuff here.  Report on
priority class in debugging output.
* spawn.cc (spawn_guts): Report on priority class in debugging output.
@
text
@d243 1
a244 1
  _my_tls.fixup_after_fork ();
@


1.168
log
@* fork.cc (frok::child): Change order of cleanup prior to return.
(fork): Save more of the stack.
* gendef: Fix some comments.
* sigproc.cc (wait_sig): Clarify debug output.
@
text
@a57 11
static void
stack_base (child_info_fork *ch)
{
  ch->stackbottom = _tlsbase;
  ch->stacktop = &ch;
  ch->stacksize = (char *) ch->stackbottom - (char *) &ch;
  debug_printf ("bottom %p, top %p, stack %p, size %d, reserve %d",
		ch->stackbottom, ch->stacktop, &ch, ch->stacksize,
		(char *) ch->stackbottom - (char *) ch->stacktop);
}

d291 1
d335 5
a339 1
  stack_base (&ch);
@


1.167
log
@* dir.cc (rmdir): Eliminate nonsensical code.
* fork.cc (fork): Move exit debug_printf to last statement.
@
text
@a246 1
  _my_tls.fixup_after_fork ();
a250 1
  fixup_hooks_after_fork ();
d253 1
d255 1
d565 1
d567 2
d582 1
a582 2
  int res;
  int ischild = setjmp (grouped.ch.jmp);
@


1.166
log
@* fork.cc (frok::parent): Simplify error messages.  Don't issue an error when
child.remember fails.
(fork): When appropriate, build up an error message from grouped.error.
@
text
@d604 1
a605 1
  sig_send (NULL, __SIGNOHOLD);
@


1.165
log
@* dcrt0.cc (getstack): New function.
(alloc_stack): Use tls stuff for stack info rather than calling VirtualQuery.
(dll_crt0_0): Initialize _impure_ptr stuff much earlier.  Move
init_console_handler here.
* fork.cc (class frok): New class renamed from local fork() struct.
(stack_base): Change argument type.  Use tls stuff to determine stack info
rather than calling VirtualQuery.
(frok::child): Rename from fork_child.  Eliminate now unneeded arguments.
(frok::parent): Rename from fork_parent and ditto.  Set error and errno as
appropriate.  Fixup impersonation in cleanup, if needed.  Try harder to set
errno appropriately.
(fork): Define "grouped" as a frok type.  Deal with errors from fork_parent
here.
* init.cc (dll_entry): Remove init_console_handler call.
@
text
@d337 1
a337 1
      error = "child %d - unable to allocate forker_finished event, %E";
d372 1
a372 1
      error = "child %d - CreateProcessA failed, %E";
d392 1
a392 1
      error = "child %d - pinfo failed";
d428 2
a429 2
#ifdef DEBUGGING
      error = "child %d - child.remember failed";
d442 1
a442 1
      error = "child %d - died waiting for longjmp before initialization";
d488 1
a488 1
	  error = "child %d - fork_copy for linked dll data/bss failed";
d500 1
a500 1
      error = "child %d died waiting for dll loading";
d520 1
a520 1
	      error = "child %d - copying data/bss for a loaded dll";
d592 1
a592 1
	syscall_printf ("fork failed - child pid %d", grouped.child_pid);
d594 8
a601 1
	system_printf (grouped.error, grouped.child_pid);
@


1.164
log
@* sigproc.cc (no_signals_available): Return true if sending to self from the
signal thread.
(wait_sig): Correct so that WaitForSingleObject is called when hMainThread is
!= 0, rather than the reverse.
* cygheap.cc (cygheap_fixup_in_child): Clarify potential error message.
* fork.cc (fork_copy): Cosmetic change.
@
text
@d45 13
d59 1
a59 1
stack_base (child_info_fork &ch)
d61 3
a63 8
  MEMORY_BASIC_INFORMATION m;
  memset (&m, 0, sizeof m);
  if (!VirtualQuery ((LPCVOID) &m, &m, sizeof m))
    system_printf ("couldn't get memory info, %E");

  ch.stacktop = m.AllocationBase;
  ch.stackbottom = (LPBYTE) m.BaseAddress + m.RegionSize;
  ch.stacksize = (DWORD) ch.stackbottom - (DWORD) &m;
d65 2
a66 2
		ch.stackbottom, ch.stacktop, &m, ch.stacksize,
		(DWORD) ch.stackbottom - (DWORD) ch.stacktop);
d164 2
a165 2
static int __stdcall
fork_child (HANDLE& hParent, dll *&first_dll, bool& load_dlls)
d167 1
d259 1
d287 2
a288 2
static int __stdcall
fork_parent (HANDLE&, dll *&first_dll, bool& load_dlls, void *stack_here, child_info_fork &ch)
d293 5
d336 2
a337 1
      system_printf ("unable to allocate forker_finished event, %E");
d345 1
a345 1
  stack_base (ch);
d353 1
d371 3
a373 7
      __seterrno ();
      syscall_printf ("CreateProcessA failed, %E");
      ForceCloseHandle (forker_finished);
      /* Restore impersonation */
      cygheap->user.reimpersonate ();
      __malloc_unlock ();
      return -1;
d376 1
d385 2
a386 2
  int child_pid = cygwin_pid (pi.dwProcessId);
  pinfo child (child_pid, 1);
d390 4
d395 1
a395 2
      if (get_errno () != ENOMEM)
	set_errno (EAGAIN);
d408 1
d427 4
a430 1
      set_errno (EAGAIN);
d441 2
a442 2
      if (NOTSTATE (child, PID_EXITED))
	system_printf ("child %d died waiting for longjmp before initialization", child_pid);
d485 7
a491 1
	goto cleanup;
d499 2
a500 2
      if (NOTSTATE (child, PID_EXITED))
	system_printf ("child %d died waiting for dll loading", child_pid);
d517 7
a523 1
	    goto cleanup;
d538 3
a540 1
 cleanup:
d551 1
d558 1
a558 7
  struct
  {
    dll *first_dll;
    bool load_dlls;
    child_info_fork ch;
  } grouped;

d579 4
a582 3
  int res = setjmp (grouped.ch.jmp);
  if (res)
    res = fork_child (grouped.ch.parent, grouped.first_dll, grouped.load_dlls);
d584 1
a584 2
    res = fork_parent (grouped.ch.parent, grouped.first_dll, grouped.load_dlls, esp, grouped.ch);
  sig_send (NULL, __SIGNOHOLD);
d587 10
d598 1
@


1.163
log
@* cygheap.cc (cygheap_init): Eliminate debugging #if.
* fork.cc (fork_parent): Don't issue errors if "somebody" has set the
PID_EXITED flag on a child.  Don't close process handle if it has potentially
already been closed.
* pinfo.cc (winpids::add): Eliminate PID_ALLPIDS handling which was obsoleted
by previous changes.
* spawn.cc (av::fixup): Do win16 detection for .com files.  Make sure that
buffer has been unmapped in all cases.
@
text
@d65 1
a65 1
fork_copy (PROCESS_INFORMATION &pi, const char *what, ...)
@


1.162
log
@Grr.  REVERT erroneous checkin.  AGAIN.
@
text
@d286 1
a286 2
  int c_flags = GetPriorityClass (hMainProc) /*|
		CREATE_NEW_PROCESS_GROUP*/;
d338 1
a338 1
  syscall_printf ("CreateProcess (%s, %s, 0, 0, 1, %x, 0, 0, %p, %p)",
d420 2
a421 1
      system_printf ("child %d died waiting for longjmp before initialization", child_pid);
d472 2
a473 1
      system_printf ("child %d died waiting for dll loading", child_pid);
d510 1
a510 1
  if (pi.hProcess)
@


1.161
log
@* Makefile.in (CXXFLAGS): Use 'override' to correctly set flags to generate
dependencies when invoked from top-level make.
@
text
@d286 2
a287 1
  int c_flags = GetPriorityClass (hMainProc);
d339 1
a339 1
  syscall_printf ("CreateProcess (%s, %s, 0, 0, 1, %p, 0, 0, %p, %p)",
d421 1
a421 2
      if (NOTSTATE (child, PID_EXITED))
	system_printf ("child %d died waiting for longjmp before initialization", child_pid);
d472 1
a472 2
      if (NOTSTATE (child, PID_EXITED))
	system_printf ("child %d died waiting for dll loading", child_pid);
d509 1
a509 1
  if (pi.hProcess && !child.hProcess)
@


1.160
log
@revert inexplicable previous checkin
@
text
@d286 1
a286 2
  int c_flags = GetPriorityClass (hMainProc) /*|
		CREATE_NEW_PROCESS_GROUP*/;
d338 1
a338 1
  syscall_printf ("CreateProcess (%s, %s, 0, 0, 1, %x, 0, 0, %p, %p)",
d420 2
a421 1
      system_printf ("child %d died waiting for longjmp before initialization", child_pid);
d472 2
a473 1
      system_printf ("child %d died waiting for dll loading", child_pid);
d510 1
a510 1
  if (pi.hProcess)
@


1.159
log
@bad_addresses
@
text
@d286 2
a287 1
  int c_flags = GetPriorityClass (hMainProc);
d339 1
a339 1
  syscall_printf ("CreateProcess (%s, %s, 0, 0, 1, %p, 0, 0, %p, %p)",
d421 1
a421 2
      if (NOTSTATE (child, PID_EXITED))
	system_printf ("child %d died waiting for longjmp before initialization", child_pid);
d472 1
a472 2
      if (NOTSTATE (child, PID_EXITED))
	system_printf ("child %d died waiting for dll loading", child_pid);
d509 1
a509 1
  if (pi.hProcess && !child.hProcess)
@


1.158
log
@* dcrt0.cc: Remove ld_preload declaration.
* winsup.h: Move ld_preload declaration here.
* fork.cc (fork_child): Call ld_preload() before returning.
@
text
@d286 1
a286 2
  int c_flags = GetPriorityClass (hMainProc) /*|
		CREATE_NEW_PROCESS_GROUP*/;
d338 1
a338 1
  syscall_printf ("CreateProcess (%s, %s, 0, 0, 1, %x, 0, 0, %p, %p)",
d420 2
a421 1
      system_printf ("child %d died waiting for longjmp before initialization", child_pid);
d472 2
a473 1
      system_printf ("child %d died waiting for dll loading", child_pid);
d510 1
a510 1
  if (pi.hProcess)
@


1.157
log
@* fork.cc (fork_parent): Fix null deref if pinfo creation fails.
@
text
@d245 1
@


1.156
log
@* child_info.h (child_info::sync): Pass pid and HANDLE rather than using pinfo.
(child_info::child_info): Accept an argument controlling whether to create
proc_subproc.
(child_info_spawn::child_info_spawn): Ditto.
* sigproc.cc (child_info::child_info): Ditto.
(child_info_spawn::child_info_spawn): Ditto.
(child_info::sync): Use passed in pid and HANDLE.
* fork.cc (fork_parent): Reflect additional arguments required for
child_info::sync.
* hookapi.cc (hook_or_detect_cygwin): Rename.  Change so that NULL 'fn'
argument just returns "true", indicating that program uses cygwin1.dll.
* spawn.cc (av::win16_exe): New element.
* spawn.cc (av::iscygwin): New element.
(av::fixup): New function.
(spawn_guts): Protect against SEGV.  Use fixup function to detect when it is
safe to wait for a spawned (as opposed to an execed) program.  Reflect changes
in child_info::sync arguments.
* external.cc (cygwin_internal): Reflect function renaming to
hook_or_detect_cygwin.
* cygheap.cc (cygheap_fixup_in_child): Close handle after debug fixup has been
done to prevent false positives in handle collision.
* exceptions.cc (try_to_debug): Notify debugger if already being debugged.
@
text
@a372 2
  child->start_time = time (NULL); /* Register child's starting time. */
  child->nice = myself->nice;
d382 3
@


1.155
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d417 1
a417 1
  if (!ch.sync (child, FORK_WAIT_TIMEOUT))
d468 1
a468 1
  else if (!ch.sync (child, FORK_WAIT_TIMEOUT))
@


1.154
log
@* cygthread.cc (cygthread::detach): Fix debugging output.
* dcrt0.cc (dll_crt0_1): Create signal_arrived early -- before any filename
manipulation.
* sigproc.cc (sigproc_init): Don't create signal_arrived here.
* fork.cc (fork_child): Ditto.
@
text
@d236 1
a236 1
  (void) ForceCloseHandle1 (fork_info->forker_finished, forker_finished);
d490 1
a490 1
      (void) resume_child (forker_finished);
@


1.153
log
@* child_info.h (child_info::cygheap_h): Delete.
(child_info::dwProcessId): New field.
* cygheap.cc (init_cheap): Delete.
(dup_now): Ditto.
(cygheap_setup_for_child): Ditto.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_fixup_in_child): Simplify.  Use new "child_copy" function to copy heap
from parent.
(_csbrk): Don't attempt allocation if within cygheap section.  Fix so that more
than one allocation will succeed.
(cygheap_init): Reset possibly-nonzero region to zero.
* cygheap.h (cygheap_setup_for_child): Delete declaration.
(cygheap_setup_for_child_cleanup): Ditto.
(cygheap_start): Define as an array.
* cygwin.sc: Modernize.  Remove unneeded sections.  Define cygheap here.
* dcrt0.cc (do_exit): Reflect argument change to close_all_files.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
* dtable.h: Ditto.
* fhandler.h: Ditto.
* fork.cc (fork_copy): Call ReadProcessMemory if there is no thread
(indicating that we're execing).
(fork_child): Don't mess with hParent.
(fork_parent): Remove hParent stuff.  It happens earlier now.  Remove call to
cygheap_setup_for_child* stuff.
(fork): Put child_info_stuff in grouped structure.  Issue error if parent
handle is not set.
(child_copy): New function.
* sigproc.cc (child_info::child_info): Put cygheap settings here.  Set parent
handle.
(child_info::~child_info): Close parent handle if it exists.
* spawn.cc (spawn_guts): Reorganize so that ciresrv is allocated at only the
last minute so that cygheap changes are reflected.  Delete cygheap_setup*
calls.
* syscalls.cc (close_all_files): Add an argument to flag when the fd entry
should be released.
* winsup.h (close_all_files): Add an argument to close_all_files declaration.
Declare child_copy.
@
text
@a160 1
  extern void __stdcall create_signal_arrived ();
a205 2
  create_signal_arrived ();

@


1.152
log
@* cygtls.h (_local_storage::unknown_thread_name): New buffer.
* tlsoffsets.h: Regenerate.
* cygthread.cc (cygthread::name): Use new thread-local buffer.
* exceptions.cc (handle_exceptions): Avoid unnecessary initialization of static
variables to zero.
* fork.cc (slow_pid_reuse) Ditto.
@
text
@d84 5
a88 1
	  int res = WriteProcessMemory (pi.hProcess, here, here, todo, &done);
a229 1
      ProtectHandleINH (hParent);
a235 1
      ProtectHandleINH (hParent);
a238 1
  ForceCloseHandle (hParent);
d280 1
a280 2
fork_parent (HANDLE& hParent, dll *&first_dll,
	     bool& load_dlls, void *stack_here, child_info_fork &ch)
a310 10
  /* Create an inheritable handle to pass to the child process.  This will
     allow the child to duplicate handles from the parent to itself. */
  hParent = NULL;
  if (!DuplicateHandle (hMainProc, hMainProc, hMainProc, &hParent, 0, TRUE,
			DUPLICATE_SAME_ACCESS))
    {
      system_printf ("couldn't create handle to myself for child, %E");
      return -1;
    }

a323 1
      CloseHandle (hParent);
a340 2
  ch.parent = hParent;

a343 2
  void *newheap;
  newheap = cygheap_setup_for_child (&ch, cygheap->fdtab.need_fixup_before ());
a354 2
  CloseHandle (hParent);

a361 1
      cygheap_setup_for_child_cleanup (newheap, &ch, 0);
d368 1
a368 3
  if (!cygheap->fdtab.need_fixup_before ())
    cygheap_setup_for_child_cleanup (newheap, &ch, 0);
  else
a370 1
      cygheap_setup_for_child_cleanup (newheap, &ch, 1);
a523 1
    HANDLE hParent;
d526 1
d532 1
a532 1
  grouped.hParent = grouped.first_dll = NULL;
d540 3
a542 2
  child_info_fork ch;
  if (ch.subproc_ready == NULL)
d549 1
a549 1
  int res = setjmp (ch.jmp);
d551 1
a551 1
    res = fork_child (grouped.hParent, grouped.first_dll, grouped.load_dlls);
d553 1
a553 1
    res = fork_parent (grouped.hParent, grouped.first_dll, grouped.load_dlls, esp, ch);
d647 11
@


1.151
log
@.
@
text
@d255 2
a256 2
  static NO_COPY HANDLE last_fork_procs[NPIDS_HELD] = {0};
  static NO_COPY unsigned nfork_procs = 0;
@


1.150
log
@	* cygheap.cc (cygheap_init): Accomodate set_process_privilege change.
	* cygheap.h (cygheap_user::curr_primary_token): New member.
	(cygheap_user::primary_token): New method.
	(cygheap_user::deimpersonate): Always revert to processes'
	impersonation token.
	(cygheap_user::reimpersonate): Set processes' or setuid token as
	necessary.
	(cygheap_user::has_impersonation_tokens): Look for curr_primary_token
	value.
	(cygheap_user::close_impersonation_tokens): Close curr_primary_token
	here if necessary.  Don't reset token values to NO_IMPERSONATION since
	that's done in uinfo_init anyway.
	(init_cygheap::luid): New LUID array keeping privilege LUIDs.
	* cygtls.cc (_cygtls::init_thread): Call cygheap->user.reimpersonate.
	* dcrt0.cc (hProcToken): New global variable to keep process token.
	(hProcImpToken): Ditto for process impersonation token.
	(dll_crt0_0): Open process token here once.  Duplicate to create
	hProcImpToken.
	(dll_crt0_1): Call set_cygwin_privileges.
	* environ.cc (allow_ntea): Drop duplicate declaration.
	(allow_smbntsec): Ditto.
	(set_traverse): Only set allow_traverse here.
	(environ_init): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop call to
	enable_restore_privilege.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	* fork.cc (fork_child): Move call to cygheap->user.reimpersonate after
	syn with parent. Call set_cygwin_privileges.
	* grp.cc (internal_getgroups): Use hProcImpToken instead of opening
	process token.
	* path.cc (fs_info::update): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges.
	* registry.cc (load_registry_hive): Drop setting restore privilege
	since it's already set if available.
	* sec_helper.cc: Include cygtls.h.
	(cygpriv): Privilege string array.
	(privilege_luid): New function, evaluate LUID from cygpriv_idx.
	(privilege_luid_by_name): New function, evaluate LUID from privilege
	string.
	(privilege_name): New function, evaluate privilege string from
	cygpriv_idx.
	(set_privilege): New static function called by set_process_privilege
	and set_thread_privilege.  Call privilege_luid to get privilege LUID.
	Fix bug in return value evaluation. Improve debug output.
	(set_cygwin_privileges): New function.
	(set_process_privilege): Remove.
	(enable_restore_privilege): Remove.
	* security.cc (allow_traverse): New global variable.
	(sys_privs): Change type to cygpriv_idx and store privilege indices
	instead of strings.
	(SYSTEM_PRIVILEGES_COUNT): Renamed from SYSTEM_PERMISSION_COUNT.
	(get_system_priv_list): Don't use numerical constant in malloc call.
	Use privilege_luid to get privilege LUIDs.
	(get_priv_list): Call privilege_luid_by_name to get LUIDs. Improve
	inner privilege LUID comparison loop.
	(create_token): Enable create token privilege using
	push/pop_self_privileges. Use hProcToken instead of opening process
	token. Use default DACL when duplicating token.
	(subauth): Enable tcb privilege using push/pop_self_privileges.
	Use sec_none instead of homw made security attributes when duplicating
	token.
	(check_file_access): Don't duplicate access token, use active
	impersonation token as is.
	* security.h (enum cygpriv_idx): New enumeration type enumerating
	possible privileges.
	(privilege_luid): Declare new function.
	(privilege_luid_by_name): Ditto.
	(privilege_name): Ditto.
	(allow_traverse): Declare.
	(set_privilege): Declare function.
	(set_process_privilege): Define as macro.
	(enable_restore_privilege): Remove declaration.
	(_push_thread_privilege): Define macro.
	(push_thread_privilege): Ditto.
	(pop_thread_privilege): Ditto.
	(pop_self_privilege): Ditto.
	* spawn.cc (spawn_guts): Use cygheap->user.primary_token instead of
	cygheap->user.token.
	* syscalls.cc (statvfs): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges. Rearrange code
	to simplify push/pop bracketing.
	(seteuid32): Use hProcToken instead of opening process token. Call
	cygheap->user.deimpersonate instead of RevertToSelf.  Create
	impersonation token from primary internal or external token.  Set
	cygheap->user.curr_primary_token and cygheap->user.current_token
	privileges once here.  Drop "failed" and "failed_ptok" labels.
	Drop setting DefaultDacl of process token.
	(setegid32): Use hProcToken and hProcImpToken instead of opening
	process token. Always reimpersonate afterwards.
	* uinfo.cc (cygheap_user::init): Use hProcToken instead of opening
	process token.
	(internal_getlogin): Ditto. Set hProcImpToken, too.
	(uinfo_init): Initialize cygheap->user.curr_primary_token.
	* winsup.h (hProcToken): Declare.
	(hProcImpToken): Declare.
@
text
@d119 1
a119 3
/* Notify parent that it is time for the next step.
   Note that this has to be a macro since the parent may be messing with
   our stack. */
@


1.149
log
@	* fork.cc (fork_child): Add missing __stdcall.
@
text
@a162 4
  /* Restore the inheritance state as in parent
     Don't call setuid here! The flags are already set. */
  cygheap->user.reimpersonate ();

d178 6
@


1.148
log
@* sigproc.cc (create_signal_arrive): New (temporary?) function to create
signal_arrived event.
(sigproc_init): Use create_signal_arrived.
* fork.cc (fork_child): Create signal_arrived early.
@
text
@d159 1
a159 1
  extern void create_signal_arrived ();
@


1.147
log
@	* fork.cc (fork_child): Fixup SYSV IPC shared memory before fixing
	up fdtab.
@
text
@d159 1
d203 2
@


1.146
log
@* Makefile.in (DLL_OFILES): Add hookapi.o.  Eliminate some cruft.
* cygheap.h (cygheap_types): Add new enum: HEAP_1_HOOK.
(hook_chain): New struct.
(init_cygheap::hooks): Define new element.
* cygheap.cc (cygheap_fixup_in_child): Zero hook chain on exec.
* dcrt0.cc (dll_crt0_1): Call ld_preload just before calling main function.
* external.cc (cygwin_internal): Implement CW_HOOK.
* fork.cc (fork_child): Call fixup_hooks_after_fork.
* init.cc (cygwin_hmodule): Reinstate after a long absence.
* include/sys/cygwin.h: Define CW_HOOK.
* hookapi.cc: New file.
* select.cc (start_thread_socket): Add debugging output.
* fhandler_disk_file.cc (fhandler_disk_file::fchmod): gcc 4.x accommodation.
* fhandler_socket.cc (fhandler_socket::connect): Make sure that err is
initialized.
@
text
@d202 11
a239 5
#ifdef USE_SERVER
  if (fixup_shms_after_fork ())
    api_fatal ("recreate_shm areas after fork failed");
#endif

@


1.145
log
@copyright
@
text
@d157 1
d236 1
@


1.144
log
@	* cygwin.din: Export getpriority and setpriority.
	* fork.cc (fork_parent): Copy parent's nice value into child.
	* spawn.cc (spawn_guts): Ditto.
	* miscfuncs.cc (winprio_to_nice): New function.
	(nice_to_winprio): Ditto.
	* pinfo.cc (pinfo_init): If parent is not a Cygwin process, set
	default nice value according to current Win32 priority class.
	* pinfo.h (class _pinfo): Add nice member.
	* syscalls.cc (setpriority): New function, only implementing
	PRIO_PROCESS for now.
	(getpriority): Ditto.
	(nice): Just call setpriority.
	* wincap.h (wincaps::has_extended_priority_class): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h: Add prototypes for winprio_to_nice and nice_to_winprio.
	* include/limits.h (NZERO): New define.
	* include/cygwin/types.h (id_t): New datatype.
	* include/cygwin/version.h: Bump API minor version.
	* include/sys/resource.h: Add PRIO_XXX defines and prototypes for
	getpriority and setpriority.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004 Red Hat, Inc.
@


1.143
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d386 1
@


1.142
log
@* cygthread.cc (cygthread::stub): Detect if thread function wants to release
itself here, to avoid a race.
(cygthread::release): Clear more stuff.  Add a diagnostic for an internal
error.
* cygthread.h (auto_release): New function.
* pinfo.h (pinfo::remember): Add an argument to denote whether child is
detached.
* fork.cc (fork_parent): Reflect change in arguments to pinfo::remember.
* pinfo.cc (_pinfo::exit): Signal exit more forcibly.
(proc_waiter): Use cygthread::auto_release to signify that cygthread::stub
should release the thread.  This should avoid a race.
(pinfo::alert_parent): Don't signify an error when wr_proc_pipe == NULL.
* sigproc.cc (proc_subproc): Add support for PROC_DETACHED_CHILD.
* sigproc.h: Ditto.
* spawn.cc (spawn_guts): Specify whether child is detached or not when calling
pinfo::remember.
@
text
@d16 1
a20 1
#include "cygerrno.h"
@


1.141
log
@* fork.cc (fork_parent): Reinstate "childhProc" protection.  Don't close
hProcess handle here since it is used to ensure that a new process isn't
created with the old pid after the old pid exits.
* spawn.cc (spawn_guts): Ditto.
* pinfo.cc (proc_waiter): Don't send any signals if we've execed since this
process doesn't officially exist.
* pinfo.h (pinfo::pid_handle): Eliminate.  Just use hProc.
* sigproc.cc (sig_send): Don't send any signals if our sendsig doesn't exist.
That's a sign that we are execing.
(remove_proc): Eliminate pid_handle close.
@
text
@d416 1
a416 1
  if (!child.remember ())
@


1.140
log
@* sigproc.cc (mychild): Reimplement as list scan.
(proc_subproc): Don't mess with pinfo if it's myself.
* child_info.h (child_info_types): Label enum for _PROC constants.
(child_info::child_info): New constructor.
(child_info::~child_info): New destructor.
(child_info::sync): Declare new function.
(child_info_fork::child_info_fork): New constructor.
(child_info_spawn::child_info_spawn): Remove old constructor.
(child_info_spawn::child_info_spawn): New constructor.
* dcrt0.cc (dll_crt0_0): Use correct sizeof when doing sanity check on passed
in child_info.  Signal readiness to parent when not forking (and not spawning).
* fork.cc (sync_with_child): Delete.
(resume_child): Remove extra argument.
(sync_with_parent): Use child_info method to sync with parent.
(fork_child): Don't close fork_info->subproc_ready since that is now handled by
the destructor.
(fork_parent): Remove subproc_ready stuff.  Use child_info sync method for
waiting..  Set start time here for child.  Rename "forked" to "child".
(fork): Check ch.subproc_ready for validity here.
* pinfo.h (_pinfo::exec_sendsig): Temp storage for exec stub which may be
staying around to handle non-cygwin captive process.
(_pinfo::exec_dwProcessId): Ditto.
(_pinfo::_lock): Renamed from lock.
(_pinfo::lock): New method.
(_pinfo::unlock): Ditto.
(_pinfo::initialize_lock): Ditto.
* pinfo.cc (set_myself): Use initialize_lock method to initialize myself lock.
Set "exec" fields in _pinfo to zero to indicate that we've started
successfully.  Set start time here when appropriate.
(_pinfo::commune_send): Use pinfo lock/unlock methods.
(proc_waiter): Remove special case for non-cywin processes.  Reinstitute
handling for PID_NOCLDSTOP.
* sigproc.cc (proc_subproc): Set proper EAGAIN errno when process table is
filled.
(sig_send): Use exec_* fields from _pinfo for sending signals if the the _pinfo
sendsig never materializes.
(child_info::child_info): New constructor, renamed from init_child_info.
Zeroes child_info structure and sets appropriate fields in structure based on
chtype.
(child_info::~child_info): New destructor.  Closes subproc_ready if it exists.
(child_info_fork::child_info_fork): New constructor.
(child_info_spawn::child_info_spawn): New constructor.
(child_info::ready): New function.  Signals parent when child is ready.
(child_info::sync): New function.  Wait for child to signal us or process to
die.
(remove_proc): Remove closing of hProcess since this should now be handled
shortly after process creation.
* spawn.cc (spawn_guts): Use child_info_spawn constructor rather than
init_child_info.  Save exec_sendsig and exec_dwProcessId in execing _pinfo.
Rely on child_info constructor to properly set parent_wr_proc_pipe in ciresrv.
Revert to previous determination on whether to start a process in suspended
mode.  Remove reparenting stuff.  Just keep a stub around if starting a
non-cygwin process.
@
text
@d405 1
a405 1
  ProtectHandle (pi.hProcess);
a503 1
  ForceCloseHandle (pi.hProcess);
@


1.139
log
@* child_info.h (child_info_fork::parent_wr_proc_pipe): New element.
* fork.cc (fork_parent): Set parent_wr_proc.
* pinfo.cc (set_myself): Close child_proc_info->parent_wr_proc if it exists
rather than trying to get value from parent _pinfo.
* pinfo.h (enum parent_aleter): New enum.
(pinfo::alert_parent): Declare as returning a value.
(pinfo::parent_alive): New function.
* pinfo.cc (pinfo::alert_parent): Set wr_proc_pipe to invalid non-NULL value
when parent disappears.  Return success of operation.
(proc_waiter): Use __ALERT_* enum for control since these are not really
signals.  Implement __ALERT_ALIVE.
* sigproc.cc (my_parent_is_alive): Eliminate.
* sigproc.h (my_parent_is_alive): Ditto for declaration.
(__SIGREPARENT): Eliminate.
@
text
@a109 4
/* Wait for child to finish what it's doing and signal us.
   We don't want to wait forever here.If there's a problem somewhere
   it'll hang the entire system (since all forks are mutex'd). If we
   time out, set errno = EAGAIN and hope the app tries again.  */
d111 1
a111 57
sync_with_child (PROCESS_INFORMATION &pi, HANDLE subproc_ready,
		 bool hang_child, const char *s)
{
  /* We also add the child process handle to the wait. If the child fails
     to initialize (eg. because of a missing dll). Then this
     handle will become signalled. This stops a *looong* timeout wait.
  */
  HANDLE w4[2];

  debug_printf ("waiting for child.  reason: %s, hang_child %d", s,
		hang_child);
  w4[1] = pi.hProcess;
  w4[0] = subproc_ready;
  DWORD rc = WaitForMultipleObjects (2, w4, FALSE, FORK_WAIT_TIMEOUT);

  if (rc == WAIT_OBJECT_0 ||
      WaitForSingleObject (subproc_ready, 0) == WAIT_OBJECT_0)
    /* That's ok */;
  else if (rc == WAIT_FAILED || rc == WAIT_TIMEOUT)
    {
      if (rc != WAIT_FAILED)
	system_printf ("WaitForMultipleObjects timed out");
      else
	system_printf ("WaitForMultipleObjects failed, %E");
      set_errno (EAGAIN);
      syscall_printf ("-1 = fork(), WaitForMultipleObjects failed");
      TerminateProcess (pi.hProcess, 1);
      return 0;
    }
  else
    {
      /* Child died. Clean up and exit. */
      DWORD errcode;
      GetExitCodeProcess (pi.hProcess, &errcode);
      /* Fix me.  This is not enough.  The fork should not be considered
       * to have failed if the process was essentially killed by a signal.
       */
      if (errcode != STATUS_CONTROL_C_EXIT)
	{
	  system_printf ("child %u(%p) died before initialization with status code %p",
			 cygwin_pid (pi.dwProcessId), pi.hProcess, errcode);
	  system_printf ("*** child state %s", s);
#ifdef DEBUGGING
	  try_to_debug ();
#endif
	}
      set_errno (EAGAIN);
      syscall_printf ("Child died before subproc_ready signalled");
      return 0;
    }

  debug_printf ("child signalled me");
  return 1;
}

static int
resume_child (PROCESS_INFORMATION &pi, HANDLE forker_finished)
d125 1
a125 3
  /* Tell our parent we're waiting. */
  if (!SetEvent (fork_info->subproc_ready))
    api_fatal ("fork child - SetEvent for %s failed, %E", s);
a221 1
  (void) ForceCloseHandle1 (fork_info->subproc_ready, subproc_ready);
d248 1
a248 1
  /* Keep a list of handles to forked processes sitting around to prevent
d270 1
a270 1
  HANDLE subproc_ready, forker_finished;
a318 7
  subproc_ready = CreateEvent (&sec_all, FALSE, FALSE, NULL);
  if (subproc_ready == NULL)
    {
      CloseHandle (hParent);
      system_printf ("unable to allocate subproc_ready event, %E");
      return -1;
    }
a322 1
      CloseHandle (subproc_ready);
a326 1
  ProtectHandleINH (subproc_ready);
a328 2
  init_child_info (PROC_FORK, &ch, subproc_ready);

a329 2
  ch.parent_wr_proc_pipe = myself->wr_proc_pipe == INVALID_HANDLE_VALUE
    			   ? NULL : myself->wr_proc_pipe;
d334 1
a334 1
  si.lpReserved2 = (LPBYTE)&ch;
a363 1
      ForceCloseHandle (subproc_ready);
d383 3
a385 2
  int forked_pid = cygwin_pid (pi.dwProcessId);
  pinfo forked (forked_pid, 1);
d387 1
a387 1
  if (!forked)
d397 1
a397 1
  strcpy (forked->progname, myself->progname);
d405 1
a405 1
  ProtectHandle1 (pi.hProcess, childhProc);
d408 2
a409 2
  forked->dwProcessId = pi.dwProcessId;
  forked.hProcess = pi.hProcess;
d416 1
a416 1
  if (!forked.remember ())
d428 5
a432 2
  if (!sync_with_child (pi, subproc_ready, true, "waiting for longjmp"))
    goto cleanup;
d477 1
a477 2
  if (!resume_child (pi, forker_finished) ||
      !sync_with_child (pi, subproc_ready, load_dlls, "child loading dlls"))
d479 5
d501 1
a501 1
      (void) resume_child (pi, forker_finished);
d504 1
a504 1
  ForceCloseHandle (subproc_ready);
d511 1
a511 1
  return forked_pid;
a522 2
  if (subproc_ready)
    ForceCloseHandle (subproc_ready);
d550 5
@


1.138
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d404 2
@


1.137
log
@* fork.cc (NPIDS_HELD): Reduce to former number now that bash problem has been
identified.
@
text
@d25 1
a25 2
#define NEED_VFORK
#include "perthread.h"
a43 11
void
per_thread::set (void *s)
{
  if (s == PER_THREAD_FORK_CLEAR)
    {
      tls = TlsAlloc ();
      s = NULL;
    }
  TlsSetValue (get_tls (), s);
}

a286 1
  pinfo_fixup_after_fork ();
a294 7
  /* Set thread local stuff to zero.  Under Windows 95/98 this is sometimes
     non-zero, for some reason.
     FIXME:  There is a memory leak here after a fork. */
  for (per_thread **t = threadstuff; *t; t++)
    if ((*t)->clear_on_fork ())
      (*t)->set ();

a338 2
  subproc_init ();

d365 1
a365 1
  if (!DuplicateHandle (hMainProc, hMainProc, hMainProc, &hParent, 0, 1,
a481 1
  forked->hProcess = pi.hProcess;
d483 1
@


1.137.2.1
log
@experimental branch which removes cygwin's reparenting code, in favor of a pipe.
@
text
@d359 2
d387 1
a387 1
  if (!DuplicateHandle (hMainProc, hMainProc, hMainProc, &hParent, 0, TRUE,
d504 1
a505 1
  forked.hProcess = pi.hProcess;
a592 2
  if (pi.hProcess)
    ForceCloseHandle1 (pi.hProcess, childhProc);
@


1.137.2.2
log
@checkpoint
@
text
@d25 2
a26 1
#include "cygtls.h"
d45 11
d308 7
@


1.137.2.3
log
@* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.
@
text
@d572 2
@


1.137.2.4
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
@
text
@d287 1
@


1.136
log
@* cygtls.h: Add alignment kludge to fix disparity between compilers.
* tlsoffsets.h: Regenerate.
* fork.cc (slow_pid_reuse): Use define to control number of pids held to
prevent pid reuse.
@
text
@d34 1
a34 1
#define NPIDS_HELD 8
@


1.135
log
@* fork.cc (slow_pid_reuse): Temporarily double the number of pids held to
prevent pid reuse.
@
text
@d34 2
d326 1
a326 1
  static NO_COPY HANDLE last_fork_procs[8] = {0};
@


1.134
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d324 1
a324 1
  static NO_COPY HANDLE last_fork_procs[4] = {0};
@


1.133
log
@* fork.cc (fork_parent): Return the cygpid directly derived from the winpid.
@
text
@a33 6
#ifdef DEBUGGING
static int npid;
static int npid_max;
static pid_t fork_pids[100];
#endif

a314 1
  wait_for_sigthread ();
d421 1
a421 1
  init_child_info (PROC_FORK, &ch, 1, subproc_ready);
a434 17
#ifdef DEBUGGING
  if (npid_max)
    {
      for (int pass = 0; pass < 2; pass++)
	{
	  pid_t pid;
	  while ((pid = fork_pids[npid++]))
	    if (!pinfo (pid))
	      {
		ch.cygpid = pid;
		goto out;
	      }
	  npid = 0;
	}
    }
 out:
#endif
a477 3
#ifdef DEBUGGING
  int forked_pid = ch.cygpid != 1 ? ch.cygpid : cygwin_pid (pi.dwProcessId);
#else
a478 1
#endif
d640 1
d646 1
a655 7
  char buf[1024];
  if (!GetEnvironmentVariable ("CYGWIN_FORK_PIDS", buf, 1024))
    return;
  pid_t pid;
  char *p, *pe;
  for (p = buf; (pid = strtol (p, &pe, 10)); p = pe)
    fork_pids[npid_max++] = pid;
@


1.132
log
@* fork.cc (fork_parent): Record child's pid when we're sure that it has been
filled out by the child.
* pinfo.cc (pinfo::init): Trivial change.
@
text
@d503 1
a503 1
  pinfo forked ((ch.cygpid != 1 ? ch.cygpid : cygwin_pid (pi.dwProcessId)), 1);
d505 1
a505 1
  pinfo forked (cygwin_pid (pi.dwProcessId), 1);
d507 2
a516 2
  int forked_pid;

a552 1
  forked_pid = forked->pid;
@


1.131
log
@* fork.cc (fork_parent): Save parent pid in a temporary variable since child
could conceivably exit before function returns, rendering the child's shared
memory area invalid.
* cygtls.h (_cygtls::incyg): Declare new field.
(_cygtls::in_exception): Define new function.
* exceptions.cc (setup_handler): Remove locked flag.  Use 'incyg' flag and
in_exception function to determine when we're in a cygwin function.
(_cygtls::call_signal_handler): Decrement incyg flag prior to calling a
handler.  Increment it on return.
* gendef (_sigfe): Increment incyg flag.  Use testl for zero testing rather
than orl, for consistency.
(_sigbe): Decrement incyg flag.  Use testl for zero testing rather than orl,
for consistency.
(_cygtls::pop): Use testl for zero testing rather than orl, for consistency.
(stabilize_sig_stack): Ditto.
@
text
@a516 2
  forked_pid = forked->pid;

d553 1
@


1.130
log
@* fork.cc (fork_child): Invert sense of test which defeated correct handling in
a fork from a non-main thread.
* dcrt0.cc (initial_env): Eliminate parameter and just send DebugBreak when
appropriate.
(dll_crt0_0): Reflect parameter change to initial_env.
(dll_crt0_1): Don't call initial_env.
@
text
@d515 4
d628 1
a628 1
  return forked->pid;
@


1.129
log
@	* fork.cc (fork_child): Move fixup_shms_after_fork so that
	signal_arrived is initialized when calling it.
@
text
@d249 1
a249 1
  if (!fork_info->stacksize)
@


1.128
log
@* dcrt0.cc (alloc_stack_hard_way): Revert to previous implementation.
(alloc_stack): Ditto.
* exceptions.cc (ctrl_c_handler): Add debugging output.
@
text
@d303 4
a310 4

  pinfo_fixup_after_fork ();
  _my_tls.fixup_after_fork ();
  sigproc_init ();
@


1.127
log
@Rename _threadinfo to _cygtls, throughout.
* cygtls.h (_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::push): Make second argument mandatory.
(_cygtls::fixup_after_fork): Declare new function.
(_cygtls::lock): Ditto.
* cygtls.cc (_cygtls::fixup_after_fork): Define new function.
* dcrt0.cc (cygwin_finished_initializing): Define as bool.
(alloc_stack): Use _tlstop rather than arbitrary variable in probably vain
attempt to avoid strange fork problem on CTRL-C.
(dll_crt0_0): Remove obsolete winpids::init call.
* dll_init.cc (dll_dllcrt0): Detect forkee condition as equivalent to
initializing.
* winsup.h (cygwin_finished_initializing): Declare as bool.
* exceptions.cc (handle_exceptions): Rely on cygwin_finished_initializing to
determine how to handle exception during process startup.
(_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::interrupt_now): Fill in second argument to push.
(signal_fixup_after_fork): Eliminate.
(setup_handler): Initialize locked to avoid potential inappropriate unlock.
Resume thread if it has acquired the stack lock.
(ctrl_c_handler): Just exit if ctrl-c is hit before cygiwn has finished
initializing.
* fork.cc (sync_with_child): Don't call abort since it can cause exit
deadlocks.
(sync_with_child): Change debugging output slightly.
(fork_child): Set cygwin_finished_initializing here.  Call _cygtls fork fixup
and explicitly call sigproc_init.
(fork_parent): Release malloc lock on fork failure.
(vfork): Call signal handler via _my_tls.
* sigproc.cc (sig_send): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* signal.cc (nanosleep): Ditto.
(abort): Ditto.
(kill_pgrp): Avoid killing self if exiting.
* sync.cc (muto::acquire): Remove (temporarily?) ill-advised exiting_thread
check.
* gendef (_sigfe): Be more agressive in protecting stack pointer from other
access by signal thread.
(_cygtls::locked): Define new function.
(_sigbe): Ditto.
(_cygtls::pop): Protect edx.
(_cygtls::lock): Use guaranteed method to set eax to 1.
(longjmp): Aggressively protect signal stack.
* miscfuncs.cc (low_priority_sleep): Reduce "sleep time" for secs == 0.
* pinfo.cc (winpids::set): Counterintuitively use malloc's lock to protect
simultaneous access to the pids list since there are pathological conditions
which can cause malloc to call winpid.
(winpids::init): Eliminate.
* pinfo.h (winpids::cs): Eliminate declaration.
* pinfo.h (winpids::init): Eliminate definition.
@
text
@a666 1

@


1.126
log
@	* uinfo.cc (cygheap_user::init): Use sec_user_nih to build a
	security descriptor. Set both the process and the default DACLs.
	* fork.cc (fork_parent): Use sec_none_nih security attributes.
	* spawn.cc (spawn_guts): Ditto.
@
text
@d170 3
a172 3
	    system_printf ("child %u(%p) died before initialization with status code %p",
			  cygwin_pid (pi.dwProcessId), pi.hProcess, errcode);
	    system_printf ("*** child state %s", s);
d174 1
a174 1
	    abort ();
d215 1
a215 1
	  api_fatal ("WFSO timed out for %s", s);
d221 1
a221 1
	  api_fatal ("WFSO failed for %s, fork_finished %p, %E", s,
d246 11
a270 12
  /* If we've played with the stack, stacksize != 0.  That means that
     fork() was invoked from other than the main thread.  Make sure that
     when the "main" thread exits it calls do_exit, like a normal process.
     Exit with a status code of 0. */
  if (fork_info->stacksize)
    {
      _main_tls = &_my_tls;
      _main_tls->init_thread (NULL, NULL);
      _main_tls->local_clib = *_impure_ptr;
      _impure_ptr = &_main_tls->local_clib;
    }

d309 2
a310 1
  signal_fixup_after_fork ();
d323 1
d462 1
a462 1
  __malloc_lock ();
d487 1
d578 1
d628 3
d734 1
a734 1
      call_signal_handler_now ();	// FIXME: racy
d766 1
a766 1
  call_signal_handler_now (); // FIXME: racy
@


1.125
log
@* cygerrno.h (set_errno): Set global errno whenever setting thread specific
version.
* debug.cc (__set_errno): Ditto.
* exceptions.cc (handle_sigsuspend): Remove spurious sig_dispatch_pending call.
(set_signal_mask): When there seem to be pending signals to dispatch, tell
signal_dispatch_pending/sig_send not to specifically call any handlers.
* sigproc.h (sig_dispatch_pending): Change declaration to void.
* sigproc.cc (sig_dispatch_pending): Change definition to void.  Take an
argument to determine whether to tell sig_send to wait for handler to be
called.
* sigproc.cc (sig_send): Don't call signal handler when sig == __SIGFLUSHFAST.
(wait_sig): Honor __SIGFLUSHFAST.  Guard against sigpacket::process nuking
si_signo.
* sigproc.h (__SIGFLUSHFAST): Define new special signal.
(sig_dispatch_pending): Change declaration to void.  Take optional boolean
argument.
* fork.cc (vfork): Add debugging output.
@
text
@a458 2
  char sa_buf[1024];
  PSECURITY_ATTRIBUTES sec_attribs = sec_user_nih (sa_buf);
d466 2
a467 2
		      sec_attribs,
		      sec_attribs,
@


1.124
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
@
text
@d701 1
@


1.123
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d234 1
d320 1
@


1.122
log
@2004 stuff
@
text
@d170 2
a171 2
	    system_printf ("child %d(%p) died before initialization with status code %p",
			  pi.dwProcessId, pi.hProcess, errcode);
d266 1
a266 1
      _main_tls->init_thread (NULL);
d724 1
@


1.122.2.1
log
@* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d170 2
a171 2
	    system_printf ("child %u(%p) died before initialization with status code %p",
			  cygwin_pid (pi.dwProcessId), pi.hProcess, errcode);
d266 1
a266 1
      _main_tls->init_thread (NULL, NULL);
a723 1
      debug_printf ("cygheap->ctty_on_hold %p, cygheap->open_fhs %d", cygheap->ctty_on_hold, cygheap->open_fhs);
@


1.122.2.2
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
@
text
@a233 1
  extern void fixup_timers_after_fork ();
a318 1
  fixup_timers_after_fork ();
@


1.121
log
@* cygheap.h (init_cygheap): Play more vfork shell games and move ctty_on_hold
and open_fhs_on_hold (back) here.
* dcrt0.cc (_dll_crt0): Just set impure_ptr_ptr here and let later
initialization deal with tls.
* dtable.cc (dtable::vfork_child_fixup): Move ctty considerations here.
(dtable:vfork_parent_restore): And here.
* fork.cc (vfork): Reflect change to ctty handling.
* perthread.h (vfork_save::fhctty): Eliminate.
* cygwin.din: Make more exports NOSIGFE that will never be interrupted by a
signal.
* init.cc (dll_entry): Set stackptr to NULL to catch problems earlier.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.120
log
@Move open_fhs from fhandler.h to cygheap.h for easier tracking.  Accommodate
this change throughout.
* dtable.cc (dtable::add_archetype): Use correct count when iterating through
*active* archetypes.
* dtable.cc (dtable::fixup_after_exec): Close handle if close_on_exec and
archetype exists since archetype currently does not set windows close-on-exec
flag (FIXME).
* fhandler_tty.cc (fhandler_tty_slave::open): Change debugging output slightly.
(fhandler_tty_slave::close): Ditto.
(fhandler_tty_slave::fixup_after_fork): Just report on inherited use counts
since since archetype currently does not set windows close-on-exec flag
(FIXME).
* pinfo.cc (_pinfo::set_ctty): Change debugging output slightly.
* cygheap.cc (cygheap_init): Remove open_fhs accommodation and use count
reporting.
* perthread.h (vfork_save::fhctty): New element.
* perthread.h (vfork_save::open_fhs): New element.
* fork.cc (vfork): Muck around with ctty and open_fhs stuff, both of which are
now saved in the vfork_save structure.
@
text
@d722 1
a722 1
      vf->fhctty = cygheap->ctty;
d742 2
a743 14
  termios_printf ("cygheap->ctty %p, vf->fhctty %p", cygheap->ctty, vf->fhctty);
  if (cygheap->ctty != vf->fhctty)
    {
      vf->fhctty->close ();
      if (vf->pid <= 0)
	{
	  if (vf->ctty)
	    vf->fhctty->close ();
	  cygheap->ctty = vf->fhctty;
	}
    }

  if (vf->pid <= 0)
    cygheap->open_fhs = vf->open_fhs;
@


1.119
log
@* fork.cc (fork_child): After a pthread/fork, ensure that impure pointer stuff
which resides in parent is propagated to child thread.
@
text
@d722 2
d726 1
a726 1
      call_signal_handler_now (); // FIXME: racy
d742 14
@


1.118
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d267 2
a268 1
      // memcpy (&_main_tls->local_clib, _impure_ptr, sizeof (*_main_tls->local_lib));
@


1.117
log
@* cygthread.cc (cygthread::stub): Revert previous change and again subsume
cygthread::stub2.  Just return from function now since ExitThread is guaranteed
by automatic _threadinfo wrapper.  Define as per ThreadProc convention.
(cygthread::stub2): Remove.
(cygthread::simplestub): Perform similar operations to cygthread::stub.
(cygthread::simplestub2): Remove.
* cygthread.h (cygthread::stub): Declare as per ThreadProc convention.
(cygthread::stub2): Remove declaration.
(cygthread::simplestub): Declare as per ThreadProc convention.
(cygthread::simplestub2): Remove declaration.
* cygtls.h (_threadinfo::call): Define first argument as per ThreadProc
convention.
(_threadinfo::call2): Ditto.
(_tlsbase): Define as char * pointer.
(_tlstop): New definition.
(_main_tls): Define here.
* dcrt0.cc (alloc_stack): Revert previous change which called init_thread since
information would be overwritten by fork later anyway.
(dll_crt0_1): Use _tlsbase and _tlstop for setting stack bottom, top.
* exceptions.cc: Move _main_tls declaration to cygtls.h.
(_threadinfo::call): Define first argument as per ThreadProc convention.
(_threadinfo::call2): Call ExitThread with thread function return value.
(_threadinfo::init_thread): Don't initialize cygtls to zero if input arg is
NULL.
* fork.cc (fork_child): Reset _main_tls here.  Reinitialize parts of _my_tls
after copying data from parent.
* init.cc (threadfunc_fe): New function.  Front-end for all threads created in
cygwin processes.
(munge_threadfunc): New function.
(dll_entry): Call munge_threadfunc to force the call of a thread wrapper.
* thread.cc (pthread::thread_init_wrapper): Perform similar operations to
cygthread::stub.
(pthread::thread_init_wrapper2): Remove.
* thread.h (pthread::thread_init_wrapper): Declare as per ThreadProc
convention.
(pthread::thread_init_wrapper2): Remove declaration.
* window.cc (Winmain): Just return from function now since ExitThread is
guaranteed by automatic _threadinfo wrapper.
@
text
@d266 2
a267 1
      _my_tls.init_thread (NULL);
d557 9
d572 1
a572 1
		  dll_bss_start, dll_bss_end, NULL);
@


1.116
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d265 2
a266 2
      ((DWORD *)fork_info->stackbottom)[-17] = (DWORD)do_exit;
      ((DWORD *)fork_info->stackbottom)[-15] = (DWORD)0;
@


1.115
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d132 1
a132 1
		 BOOL hang_child, const char *s)
d241 1
a241 1
  sync_with_parent ("after longjmp.", TRUE);
d287 1
a287 1
      sync_with_parent ("performed fork fixup.", FALSE);
d294 1
a294 1
      sync_with_parent ("loaded dlls", TRUE);
d544 1
a544 1
  if (!sync_with_child (pi, subproc_ready, TRUE, "waiting for longjmp"))
@


1.114
log
@* fork.cc (fork_parent): Detect failed pinfo constructor.
* spawn.cc (spawn_guts): Don't overwrite ENOMEM errno on failed pinfo
constructor.
@
text
@a636 1
  sigframe thisframe (mainthread);
a689 1
  sigframe thisframe;
d698 2
d705 1
a705 1
      for (pp = (char **)vf->frame, esp = vf->vfork_esp;
d713 2
d720 1
a720 1
  for (pp = (char **)vf->frame, esp = vf->vfork_esp;
a723 1
  thisframe.init (mainthread);
d742 3
@


1.113
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d503 7
@


1.112
log
@* dcrt0.cc (dlL_crt0_1): Set __argc_safe after __argc is absolutely know to be
set.
* exceptions.cc (sig_handle_tty_stop): Don't reset sigCONT event since it is
reset automatically.
* fork.cc (fork): Remove obsolete usage of PID_SPLIT_HEAP.
* include/sys/cygwin.h: Ditto.
* sigproc.cc (sig_send): Use sigframe init method to set frame since it checks
for previous ownership of the frame.
* sigproc.h (sigframe::init): Accept an "is_exception" argument.
@
text
@d17 1
a18 1
#include "path.h"
@


1.111
log
@Throughout, change USE_CYGSERVER to USE_SERVER.
* Makefile.in (LIBSERVER): Define and use.
* configure.in: Set LIBSERVER as appropriate.
* environ.cc: Rename allow_daemon to allow_server.  Only recognize when
USE_SERVER is defined.
@
text
@a635 9
  if (ISSTATE(myself, PID_SPLIT_HEAP))
    {
      system_printf ("The heap has been split, CYGWIN can't fork this process.");
      system_printf ("Increase the heap_chunk_size in the registry and try again.");
      set_errno (ENOMEM);
      syscall_printf ("-1 = fork (), split heap");
      return -1;
    }

@


1.110
log
@* Makefile.in: Remove cygserver stuff.
* acconfig.h: Add USE_CYGSERVER define.
* config.h.in: Regenerate.
* configure.in: Add --enable-server setting.
* configure: Regenerate.
* fhandler_tty.cc (fhandler_tty_slave::open): Conditionalize compilation of
cygserver stuff.
* fork.cc (fork_child): Ditto.
* shm.cc: Ditto.
* tty.cc (tty::common_init): Ditto.
* dcrt0.cc: Use bool rather than BOOL for CYGWIN environment variable
definitions.
* environ.cc: Ditto.
* ntea.cc: Ditto.
* security.cc: Ditto.
* security.h: Ditto.
* syscalls.cc (check_posix_perm): Remove externs that were already declared in
a header.
* winsup.h: Ditto.  Declare _MT_SAFE here.  Delete it someday since cygwin
should always be _MT_SAFE.
@
text
@d301 1
a301 1
#ifdef USE_CYGSERVER
@


1.109
log
@	* cygheap.h (enum impersonation): New enum.
	(cygheap_user::token): Delete.
	(cygheap_user::impersonated): Delete.
	(cygheap_user::external_token): New member.
	(cygheap_user::internal_token): New member.
	(cygheap_user::impersonation_state): New member.
	(cygheap_user::issetuid): Modify.
	(cygheap_user::token): New method.
	(cygheap_user::deimpersonate): New method.
	(cygheap_user::reimpersonate): New method.
	(cygheap_user::has_impersonation_tokens): New method.
	(cygheap_user::close_impersonation_tokens): New method.
	* dtable.cc (dtable::vfork_child_dup): Use new cygheap_user methods.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fork.cc (fork_child): Ditto.
	(fork_parent): Ditto.
	* grp.cc (internal_getgroups): Ditto.
	* security.cc (verify_token): Ditto.
	(check_file_access): Ditto.
	(cygwin_set_impersonation_token): Detect conflicts. Set
	user.external_token.
	* spawn.cc (spawn_guts): Use new cygheap_user methods.
	* syscalls.cc (seteuid32): Rearrange to use the two tokens
	in cygheap_user.
	(setegid32): Use new cygheap_user methods.
	* uinfo.cc: (internal_getlogin): Ditto.
@
text
@d301 1
d304 1
@


1.108
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d239 1
a239 8
  if (cygheap->user.impersonated)
    {
      debug_printf ("Impersonation of child, token: %d", cygheap->user.token);
      if (cygheap->user.token == INVALID_HANDLE_VALUE)
	RevertToSelf (); // probably not needed
      else if (!ImpersonateLoggedOnUser (cygheap->user.token))
	system_printf ("Impersonate for forked child failed: %E");
    }
d432 1
a432 2
  if (cygheap->user.issetuid ())
    RevertToSelf ();
d480 1
a480 2
      if (cygheap->user.issetuid ())
	ImpersonateLoggedOnUser (cygheap->user.token);
d507 1
a507 2
  if (cygheap->user.issetuid ())
    ImpersonateLoggedOnUser (cygheap->user.token);
@


1.107
log
@* fork.cc: Change SLOW_PID_REUSE to NO_SLOW_PID_REUSE and invert ifdef sense
throughout.
@
text
@a15 1
#include <errno.h>
@


1.106
log
@Joe Buehler <jhpb@@draco.hekimian.com>
* fork.cc (fork_parent): Don't copy signals from parent to child here.
* sigproc.cc (proc_subproc): Copy signals from parent to child pinfo here.
@
text
@d328 1
a328 1
#ifdef SLOW_PID_REUSE
d332 1
a332 1
  static NO_COPY HANDLE last_fork_procs[8] = {0};
d541 1
a541 1
#ifdef SLOW_PID_REUSE
@


1.105
log
@* fork.cc: Conditionalize use of slow_pid_reuse throughout.  It's not necessary
for newer versions of bash.
@
text
@a527 1
  forked->copysigs (myself);
@


1.104
log
@* cygthread.cc (cygthread::exiting): New variable.
(cygthread::initialized): Delete.
(cygthread::stub): Use exiting variable to determine when to exit.
(cygthread::runner): Delete.
(cygthread_protect): New variable.
(cygthread::init): Don't start runner thread.  Initialize muto for list
protection.
(cygthread::freerange): Return pointer to cygthread.
(cygthread::operator new): Change logic to start threads on an as-needed basis.
(cygthread::detach): Don't zero id.
(cygthread::terminate): Don't kill any executing threads.  Just set exiting
flag.
* cygthread.h (cygthread): Reflect above changes.
* dcrt0.cc (dll_crt0_1): Move cygthread initialization later.
* fork.cc (fork_child): Do fdtab fixup after dll fixup or (apparently) winsock
may allocate memory in dll load address.
@
text
@d328 1
d353 1
d542 1
d544 1
@


1.104.12.1
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d18 1
a19 1
#include "fhandler.h"
@


1.104.12.2
log
@merge from trunk
@
text
@a327 1
#ifdef SLOW_PID_REUSE
a351 1
#endif
a539 1
#ifdef SLOW_PID_REUSE
a540 1
#endif
@


1.104.12.3
log
@merge from trunk
@
text
@d528 1
@


1.104.12.4
log
@merge from trunk
@
text
@d328 1
a328 1
#ifndef NO_SLOW_PID_REUSE
d332 1
a332 1
  static NO_COPY HANDLE last_fork_procs[4] = {0};
d541 1
a541 1
#ifndef NO_SLOW_PID_REUSE
@


1.104.12.5
log
@merge from trunk
@
text
@d16 1
d240 8
a247 1
  cygheap->user.reimpersonate ();
a308 1
#ifdef USE_CYGSERVER
a310 1
#endif
d440 2
a441 1
  cygheap->user.deimpersonate ();
d489 2
a490 1
      cygheap->user.reimpersonate ();
d517 2
a518 1
  cygheap->user.reimpersonate ();
@


1.104.12.6
log
@merge from trunk
@
text
@d301 1
a301 1
#ifdef USE_SERVER
@


1.104.12.7
log
@merge from trunk
@
text
@d636 9
@


1.103
log
@* cygheap.cc (cygheap_fixup_in_child): Use user_heap element in cygheap.
(init_cheap): Ditto for declaration.
* fork.cc (fork_parent): Use user_heap element in cygheap.
* heap.h (inheap): Ditto.
* heap.cc (sbrk): Ditto.
(heap_init): Ditto.  Reorganize to shrink heap chunk as required and record new
value in cygheap.
* dcrt0.cc (dll_crt0_1): More "move the cygthread init" games.
* shared.cc (open_shared): Rework memory protection to properly deal with
relocated shared segment.
(shared_info::heap_chunk_size): Rename element to 'heap_chunk'.
* shared_info.h (shared_info): Ditto for declaration.
* strace.cc (strace::hello): Report on heap chunk size from cygheap since it
may shrink.
@
text
@a283 2
  cygheap->fdtab.fixup_after_fork (hParent);
  ProtectHandleINH (hParent);
d292 5
a296 1
    sync_with_parent ("performed fork fixup.", FALSE);
d300 2
@


1.102
log
@Change _function() to function() throughout.
* cygwin.din: Remove last vestiges (?) of newlib wrappers.
* cygthread.cc (cygthread::detach): Always wait for event or suffer an
apparently inavoidable race.
* dcrt0.cc (dll_crt0_1): Allocate threads after stack has been relocated.
* debub.cc (lock_debug): Don't acquire lock on exit.
* fork.cc (fork_child): Recreate mmaps before doing anything else since Windows
has a habit of using blocks of memory in the child that could previously have
been occupied by shared memory in the parent.
* mmap.cc (fhandler_disk_file::fixup_mmap_after_fork): Issue error here and
provide some details about what went wrong.
(fixup_mmaps_after_fork): Remove error message.
* shared.cc (open_shared): Move warning message so that more detail is
possible.
* sigproc.cc (sigproc_init): Initialize sync_proc_subproc to avoid a race.
(sigproc_terminate): Specifically wait for process thread to terminate.
@
text
@d554 1
a554 1
		  cygheap->heapbase, cygheap->heapptr,
@


1.101
log
@* fork.cc (fork_child): Move pinfo fixup later to attempt some minor gains from
concurrency from cythread::init.
@
text
@d281 3
a286 3
  if (fixup_mmaps_after_fork (hParent))
    api_fatal ("recreate_mmaps_after_fork_failed");

a307 1
  cygthread::init ();
d318 1
a319 1
  pthread::atforkchild ();
@


1.100
log
@* dcrt0.cc (dll_crt0_1): Initialize cygwin threads here only when not forking.
* fork.cc (fork_child): Initialize cygwin thread later in process to avoid
allocating memory for thread stacks.
* shared.cc (open_shared): Issue warning if NT and shared segment is relocated.
@
text
@a286 2
  pinfo_fixup_after_fork ();

d309 1
@


1.99
log
@* fork.cc (fork_child): Move mmap initialization.
* shared.cc (shared_info::heap_chunk_size): Store info as megabytes.  Search
HKEY_LOCAL_MACHINE as well as HKEY_CURRENT_USER.
* shared_info.h (shared_info::initial_heap_size): Change element name to
reflect new functionality.
* strace.cc (strace::hello): Report on initial heap size.
@
text
@d33 1
a287 1
  signal_fixup_after_fork ();
d309 3
@


1.98
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info_fork::mount_table): Remove.
(child_info_fork::myself_addr): Remove.
* fork.cc (fork_child): Don't set either of the above.
* dcrt0.cc (dll_crt0_1): Call memory_init as early as possible.
* fhandler_console.cc (console_state): Move to shared_info.h.
(fhandler_console::get_tty_stuff): Reflect open_shared arg change.
* pinfo.cc (myself_addr): Remove definition.
(pinfo::init): Get myself address from open_shared.
* pinfo.h (myself_addr): Remove declaration.
* shared.cc (open_shared): Rework so that known shared memory locations are
protected.  Take shared memory type as fifth argument.
(memory_init): Reflect open_shared arg change.
* shared_info.h (shared_locations): New enum.
(console_state): Move here.
(open_shared): Reflect open_shared arg change in declaration.
@
text
@d283 3
a289 3

  if (fixup_mmaps_after_fork (hParent))
    api_fatal ("recreate_mmaps_after_fork_failed");
@


1.97
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info_fork::heaptop): Remove obsolete element.
(child_info_fork::heabbase): Ditto.
(child_info_fork::heapptr): Ditto.
(child_info_fork::mount_table): New element.
(child_info_fork::myself_addr): Ditto.
* dcrt0.cc (dll_crt0_1): Set mount_table and myself_addr when forking.
(initial_env): Add newline to "sleeping" message.
* dll_init.cc (reserve_upto): Accommodate cygwin heap when freeing memory.
Make debugging output a little more descriptive.
* fork.cc (fork_parent): Save mount_table and myself_addr.
* pinfo.cc (myself_addr): New variable.
(set_myself): Pass PID_MYSELF flag to init.
(pinfo::Init): Honor PID_MYSELF.  Save address where myself shared memory
resides in myself_addr, for fork.
* pinfo.h (myself_addr): Declare.
* shared.cc (memory_init): On fork, use previously saved address for location
of mount table.
* include/sys/cygwin.h (PID_MYSELF): New value.
* dtable.cc (dtable::stdio_init): Don't pass access type to
init_std_file_from_handle.  It's always the same.
(dtable::init_std_file_from_handle): Remove access type argument.  Assume
read/write.
* dtable.h (dtable::init_std_file_from_handle): Ditto for declaration.
* exceptions.cc (try_to_debug): Don't try to debug if already being debugged.
* fhandler_console.cc (shared_console_info_save): New variable.
(fhandler_console::get_tty_stuff): Save address of shared console stuff for
fork.
@
text
@a424 2
  ch.mount_table = mount_table;
  ch.myself_addr = myself_addr;
@


1.96
log
@* cygheap.cc (dup_now): Make fatal error a little more informative.
(cygheap_setup_for_child): Detect when default size of shared region is less
than the current size and allocate that much.
(_cbrk): Just return NULL on inability to allocate.
(_cmalloc): Ditto.
* cygheap.h (CYGHEAPSIZE): Change size to reflect newer, tinier fhandler sizes.
* spawn.cc (av::error): New element, reflects potential errno from cmalloc.
(av::~av): Don't free NULL pointers.
(av::replace0_maybe): Detect out-of-memory conditions.
(av::dup_maybe): Ditto.
(av::dup_all): Ditto.
(av::unshift): Ditto.
(spawn_guts): Set errno and return if argv creation ran into problems.
* fhandler.h (fhandler_union): Change member names to something safer.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Always set
fhandler_console::dev_state regardless of whether shared region is initialized.
* cygthread.cc (cygthread::runner): Use ExitThread rather than return
(planning for future).
@
text
@d31 1
d425 2
@


1.95
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d460 1
a460 1
  newheap = cygheap_setup_for_child (&ch,cygheap->fdtab.need_fixup_before ());
@


1.94
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d248 1
a248 1
  sigproc_printf ("hParent %p, child 1 first_dll %p, load_dlls %d\n", hParent,
@


1.93
log
@Cleanup calls to CreateFile throughout.
* dcrt0.cc (__api_fatal): Correctly check for failing return from CreateFile.
* assert.cc (__assert): Don't check return value from CreateFile for NULL.
* fhandler_console.cc (set_console_state_for_spawn): Ditto.
* fork.cc (fork_parent): Ditto.
@
text
@d197 1
a197 1
sync_with_parent(const char *s, bool hang_self)
d261 1
a261 1
      Sleep (atoi(buf));
d429 1
a429 1
  si.cbReserved2 = sizeof(ch);
d478 2
a479 2
      ForceCloseHandle(subproc_ready);
      ForceCloseHandle(forker_finished);
d506 1
a506 1
  strcpy(forked->progname, myself->progname);
d520 1
a520 1
  forked->copysigs(myself);
@


1.92
log
@2002-09-17  Robert Collins  <rbtcollins@@hotmail.com>

        This work inspires by Thomas Pfaff's pthread_fork patch (1).
        * fork.cc (fork_child): Remove MTinterface fixup call, it's
        adsorbed by pthread::atforkchild.
        Rename __pthread_atforkchild to pthread::atforkchild to give
        access to private members.
        (fork_parent): Rename __pthread_atforkparent to
        pthread::atforkparent to give it access to private members.
        Ditto for __pthread_atforkprepare.
        * thread.cc: Fix some formatting problems throughout.
        (MTinterface::fixup_before_fork): Implement.
        (MTinterface::fixup_after_fork): Fix pthread_keys.
        (pthread_key::keys): Implement.
        (pthread_key::fixup_before_fork): Ditto.
        (pthread_key::fixup_after_fork): Ditto.
        (pthread_key::pthread_key): Add to pthread_key::keys.
        (pthread_key::~pthread_key): Remove from pthread_key::keys.
        (pthread_key::saveKeyToBuffer): Implement.
        (pthread_key::recreateKeyFromBuffer): Ditto.
        (pthread::atforkprepare): Prepare all MT classes for fork.
        (pthread::atforkchild): And fix them up afterwards.
        * thread.h (pthread_key): Buffer the key value during
        fork in fork_buf.
        List the keys needing to be fixed up in a linked list with
        head pthread_key::keys.
        (pthread): Move atfork cygwin internal calls into the class.
        (MTInterface): Provide a fixup_before_fork for objecst that
        need to save state.
        (__pthread_atforkprepare): Remove.
        (__pthread_atforkparent): Remove.
        (__pthread_atforkchild): Remove.
@
text
@d365 4
a368 4
  HANDLE console_handle = CreateFileA ("CONOUT$", GENERIC_WRITE,
				       FILE_SHARE_WRITE, &sec_none_nih,
				       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
				       NULL);
d370 1
a370 1
  if (console_handle != INVALID_HANDLE_VALUE && console_handle != 0)
@


1.91
log
@* perthread.h (vfork_save): Add ctty, sid, pgid, exitval fields.
(vfork_save::restore_pid): New method.
(vfork_save::restore_exit): New method.
* fork.cc (vfork): Save ctty, sid, pgid and restore them when returning to
"parent".  Use exitval field if exiting but never created a new process.
* syscalls.cc (setsid): Detect when in "vfork" and force an actual fork so that
pid will be allocated (UGLY!).
(getsid): New function.
* dcrt0.cc (do_exit): Use vfork_save::restore_exit method for returning from a
vfork.
* spawn.cc (spawnve): Use vfork_save::{restore_pid,restore_exit} methods for
returning from vfork.
* cygwin.din: Export getsid.
* include/cygwin/version.h: Bump api minor number.
* malloc.cc: #ifdef sYSTRIm for when MORECORE_CANNOT_TRIM is true.
@
text
@a315 2
  user_data->threadinterface->fixup_after_fork ();

d317 1
a317 1
  __pthread_atforkchild ();
d355 1
a355 2
  /* call the pthread_atfork prepare functions */
  __pthread_atforkprepare ();
d601 1
a601 1
  __pthread_atforkparent ();
@


1.90
log
@* Makefile.in: Add support for new malloc.o and renamed malloc_wrapper.o.  Use
-fomit-frame-pointer for malloc.o compilation.
* malloc_wrapper.cc: New file.  Rename from malloc.cc.  Add support for more
malloc functions.  Eliminate export_* calls.  Just use straight malloc names.
Remove unused argument from malloc lock functions.
* cygwin.din: Just export straight malloc names.  Add malloc_stats,
malloc_trim, malloc_usable_size, mallopt, memalign, valloc.
* dcrt0.cc (__cygwin_user): Eliminate export_* malloc entries.
* fork.cc (fork_parent): Remove unused argument from malloc_lock argument.
* malloc.cc: New file.  Doug Lea's malloc v2.7.1.
* cygmalloc.h: New file.
* include/cygwin/version.h: Bump API_MINOR.
* sync.h (muto::acquire): Use appropriate number for regparm attribute.
(muto::reset): Ditto.
(muto::release): Ditto.
@
text
@d690 1
a690 2
extern "C"
int
d713 3
a717 1
      debug_printf ("exiting vfork, res %d", res);
d730 4
d736 1
a736 1
      int exitval = -vf->pid;
@


1.89
log
@* assert.cc (__assert): Call debugger on assertion failure if debugging.
* dcrt0.cc (dll_crt0_1): Just wait for signal thread to go live rather than
going through the overhead of invoking it.
* fork.cc (fork_child): Ditto.
* exceptions.cc (signal_fixup_after_fork): Call sigproc_init here.
* sigproc.cc (proc_can_be_signalled): Assume that the signal thread is live.
(sig_dispatch): Ditto.
(sig_send): Ditto.
(wait_for_sigthread): Renamed from "wait_for_me".  Assume that wait_sig_inited
has been set and that this function is only called from the main thread.
* winsup.h (wait_for_sigthread): Declare new function.
@
text
@d30 2
d461 1
a461 1
  __malloc_lock (_reent_clib ());
d560 1
a560 1
  __malloc_unlock (_reent_clib ());
@


1.88
log
@* debug.h (handle_list): Move here from debug.cc.  Add "inherit" flag
functionality.
* cygheap.cc (init_cheap): Move cygheap_max calculation to _csbrk.
(_csbrk): Reorganize to not assume first allocation is <= 1 page.
(cygheap_setup_for_child): Mark protected handle as inheritable.
* cygheap.h (cygheap_debug): New struct.
(init_cygheap): Add new structure when debugging.
* dcrt0.cc (dll_crt0_1): Remove call to debug_init.  Close ppid_handle here, if
appropriate.  Don't protect subproc_ready, since it is already protected in the
parent.  Call memory_init prior to ProtectHandle to ensure that cygheap is set
up.  Call debug_fixup_after_fork_exec when appropriate.
(_dll_crt0): Don't close ppid_handle here.
* debug.cc: Use cygheap debug structure rather than static elements throughout.
(add_handle): Don't issue a warning if attempt to protect handle in exactly the
same way from exactly the same place.  Add pid info to warning output.  Accept
additional argument controlling whether handle is to be inherited.  Add pid to
stored information.
(debug_fixup_after_fork_exec): Renamed from debug_fixup_after_fork.  Reorganize
to avoid erroneously skipping handles.
(mark_closed): Add pid info to warning output.
(setclexec): Rename from setclexec_pid.
* fhandler.cc (fhandler_base::get_default_fmode): Minor reorg.
(fhandler_base::fstat): Add debugging output.
(fhandler_base::set_inheritance): Call setclexec rather than setclexec_pid.
(fhandler_base::fork_fixup): Ditto.
* fhandler_console.cc (get_tty_stuff): Mark protected handle as inheritable.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* tty.cc (tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* fork.cc (fork_parent): Ditto.
(fork_child): Close protected handles with correct name.  Remove
debug_fixup_after_fork call.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Mark protected
handle as inheritable/non-inheritable, as appropriate.
* shared.cc (memory_init): Mark protected handle as inheritable.  Call
debug_init here.
* sigproc.cc (wait_sig): Close protected handle with correct name.
* spawn.cc (spawn_guts): Rename spr to subproc_ready and mark it as
inheritable.
* exceptions.cc (debugger_command): Try to run dumper.exe, if found.
* syscalls.cc (fstat64): Don't follow symlinks for path_conv lookup since path
is already resolved.
@
text
@d316 1
a316 2
  /* Initialize signal/process handling */
  sigproc_init ();
@


1.87
log
@* debug.cc: Avoid explicit zeroing of globals.
(lock_debug): Make locker a static member.  Avoid unlocking when already
unlocked (from Conrad Scott).
(debug_init): Initialize lock_debug::locker here.
* fork.cc (fork_child): Fix up fdtab earlier to avoid some (but not all)
confusion with close-on-exec craziness.
@
text
@d278 1
a278 1
  ProtectHandle (hParent);
a279 1
  debug_fixup_after_fork ();
d301 2
a302 2
  (void) ForceCloseHandle (fork_info->subproc_ready);
  (void) ForceCloseHandle (fork_info->forker_finished);
a360 10
#ifdef DEBUGGING_NOTNEEDED
  /* The ProtectHandle call allocates memory so we need to make sure
     that enough is set aside here so that the sbrk pointer does not
     move when ProtectHandle is called after the child is started.
     Otherwise the sbrk pointers in the parent will not agree with
     the child and when user_data is (regrettably) copied over,
     the user_data->ptr field will not be accurate. */
  free (malloc (4096));
#endif

d420 2
a421 2
  ProtectHandle (subproc_ready);
  ProtectHandle (forker_finished);
@


1.86
log
@* cygheap.h (cygheap_user::issetuid): New method.
* dtable.cc (dtable::vfork_child_dup): Use new method to determine if we are in
"setuid mode."
* fork.cc (fork_parent): Ditto.
* spawn.cc (spawn_guts): Ditto.
* syscalls.cc (seteuid32): Ditto.
(setegid32): Ditto.
* environ.cc (spenv::retrieve): (Suggested by Pierre Humblet) Do potential
recalculation of cygheap_user stuff when in setuid mode.  Return special value
when environment variable exists but should not be added.
(build_env): Don't add retrieved value to dstp if it is 'dont_add'.
@
text
@a245 1
  ProtectHandle (hParent);
d277 3
a281 1
  cygheap->fdtab.fixup_after_fork (hParent);
@


1.85
log
@* child_info.h (child_proc_info): Declare as base class.
(spawn_info): Declare as alias of child_proc_info to aid debugging.
(fork_info): Ditto.
* cygheap.cc (cygheap_fixup_in_child): Use child_proc_info global rather than
parameter.
* cygheap.h (cygheap_fixup_in_child): Reflect above change in declaration.
* dcrt0.cc (_dll_crt0): Move 'si' definition here.  Assign child_proc_info.
(dll_crt0_1): Accommodate cygheap_fixup_in_child and *_info changes.
* environ.cc (spenv::retrieve): Make regparm.
* environ.h (environ_init): Ditto.
(win_env::add_cache): Ditto.
(build_env): Ditto.
(getwinenv): Ditto.
* fork.cc (sync_with_parent): Use fork_info global.
(fork_child): Ditto.
@
text
@d444 1
a444 1
  if (cygheap->user.impersonated && cygheap->user.token != INVALID_HANDLE_VALUE)
d493 1
a493 2
      if (cygheap->user.impersonated
	  && cygheap->user.token != INVALID_HANDLE_VALUE)
d521 1
a521 1
  if (cygheap->user.impersonated && cygheap->user.token != INVALID_HANDLE_VALUE)
@


1.84
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d199 1
a199 1
  if (!SetEvent (child_proc_info->subproc_ready))
d203 1
a203 1
      HANDLE h = child_proc_info->forker_finished;
d216 1
a216 1
	      WaitForSingleObject (child_proc_info->forker_finished, 1) != WAIT_FAILED)
d219 1
a219 1
		     child_proc_info->forker_finished);
d268 1
a268 1
  if (child_proc_info->stacksize)
d270 2
a271 2
      ((DWORD *)child_proc_info->stackbottom)[-17] = (DWORD)do_exit;
      ((DWORD *)child_proc_info->stackbottom)[-15] = (DWORD)0;
d301 2
a302 2
  (void) ForceCloseHandle (child_proc_info->subproc_ready);
  (void) ForceCloseHandle (child_proc_info->forker_finished);
@


1.83
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.82
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@a14 1
#include <fcntl.h>
@


1.81
log
@	* spawn.cc (spawn_guts): Move call to set_process_privilege()
	to load_registry_hive().
	* registry.cc (load_registry_hive): ditto.
	* fork.cc (fork_parent): Call sec_user_nih() only once.
@
text
@a22 1
#include "sync.h"
@


1.80
log
@	* fork.cc (fork_child): Call fixup_mmaps_after_fork() somewhat earlier.
@
text
@d469 1
d477 2
a478 2
		      sec_user_nih (sa_buf),
		      sec_user_nih (sa_buf),
@


1.79
log
@	* fork.cc (fork_child): Call fixup_mmaps_after_fork() before
	closing parent process handle.  Call fixup_mmaps_after_fork()
	with parent process handle as parameter.
	* mmap.cc (mmap_record::access): New method.
	(fixup_mmaps_after_fork): Take process handle as parameter.
	In case of FILE_MAP_COPY access, copy valid memory regions to child.
	* pinfo.h (fixup_mmaps_after_fork): Change prototype accordingly.
@
text
@d287 3
a300 3

  if (fixup_mmaps_after_fork (hParent))
    api_fatal ("recreate_mmaps_after_fork_failed");
@


1.78
log
@2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* Merged cygwin_daemon into head minus the new shm and ipc exports.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* fhandler_tty.cc (fhandler_tty_slave::open): More debugging.
	(fhandler_tty_slave::read): Fix printf type for the handle.
	* tty.cc (tty::common_init): Add a FIXME for security.

2002-01-29  Robert Collins  <rbtcollins@@hotmail.com>

	* Makefile.in (OBJS): Remove duplicate localtime.o.

2002-01-17  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (check_and_dup_handle): Consolidate the two variants for
	simplicity.
	Add Some basic debug output.
	(client_request_attach_tty::serve): Use the new debug_printf for clarity.
	Mark the duplicated handles as inheritable - fixup_after_fork() doesn't reopen
	tty's.

2002-01-16  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (transport): Correct scope.
	(client_request_attach_tty::serve): Add more debug information.
	Fix erroneous use of transport instead of conn.
	* cygserver_transport_pipes.cc (transport_layer_pipes::close): More debug.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.

Mon Oct  8  7:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (server_request::process): Rename client_request_shm_get to
	client_request_shm.
	* cygserver_process.cc (process_cache::add): Rename to add_task.
	Use process_cleanup instead of process_request.
	(process_cache::remove_process): New method.
	(process::process): Initialize new members.
	(process::~process): New member.
	(process::cleanup): New method.
	(process::add_cleanup_routine): New method.
	(process_request::process): Rename to process_cleanup.
	Call the process object's cleanup method and then delete it.
	(process_process_param::request_loop): Remove the signalling process.
	* cygserver_shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm_get::serve): Handle attach request counting.
	* cygserver_shm.h: Globally rename client_request_shm_get to client_request_shm.
	(class shm_cleanup): New class.
	* shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm::client_request_shm): New constructor for attach requests.
	(shmat): Use it.
	* include/cygwin/cygserver_process.h (class process_request): Rename to
	process_cleanup.
	(class cleanup_routine): New class.
	(class process): New members and methods to allow calling back when the process
	terminates.

Thu Oct  4 14:12:00 2001  Robert Collins <rbtcollins@@hotmail.com>
	* cygserver.cc (request_loop): Make static.
	(main): Use new cache constructor syntax.
	Start cache worker threads.
	Cleanup the cache at shutdown.
	* cygserver_process.cc: Run indent.
	(process_cache::process_cache): Add a trigger to use when adding a process.
	(process_cache::process): Move process_entry to process.
	Insert at the end of the list.
	Trigger the request loop when new process's inserted.
	(process_cache::process_requests): Do it.
	(process_cache::add): New method.
	(process_cache::handle_snapshot): New method.
	(process::process): Merge in the process_entry fields.
	(process::handle): Make a stub function.
	(process::exit_code): New method.
	(process_request::process): New method.
	(process_process_param::request_loop): New method.
	* cygserver_shm.cc: New header dependency - threaded_queue.h.
	* threaded_queue.cc (threaded_queue::cleanup): Clearer messages.
	(queue_process_param::stop): Short spinlock on interruptible threads.
	* threaded_queue.h (class threaded_queue): New constructor.
	* include/cygwin/cygserver_process.h (process_request): New class.
	(process_entry): Remove.
	(process): Merge in process_entry.
	(process_cache): Inherit from threaded_queue.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (class server_process_param): Use new constructor syntax.
	* cygserver_process.cc (process_cache::~process_cache): New function.
	* threaded_queue.cc: Define condition debug_printf.
	Run indent.
	(threaded_queue::cleanup): Move queue_process_param guts to a method.
	(threaded_queue::process_requests): Ditto.
	(queue_process_param::queue_process_param): New method.
	(queue_process_param::~queue_process_param): Ditto.
	(queue_process_param::start): Ditto.
	(queue_process_param::stop): Ditto.
	* threaded_queue.h (class queue_process_param): Add support for
	interruptible request loops.
	* cygwin/include/cygwin/cygserver_process.h (class process_cache): Add
	destructor.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver_client.cc: New flag allow_daemon to disable the daemon completely.
	(cygserver_request): Check it.
	(cygserver_init): Ditto.
	* environ.cc (parse_thing): Add (no)daemon option.

Tue Oct  2 23:00:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* shm.cc: Update to handle include changes from HEAD.

Tue Oct  2 16:06:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Remove cygserver_shm.o from cygwin1.dll.
	Rename cygserver_shm_outside.o to cygserver_shm.o.
	* cygserver.cc (server_request::process): Use the new client_request
	constructor.
	* cygserver_client.cc: Remove the #ifdef's stubs for the server method
	within cygwin.
	(client_request_attach_tty::client_request_attach_tty): Use the new
	client_request constructor.
	(client_request_shutdown::client_request_shutdown): Ditto.
	(client_request::client_request): Ditto.
	* cygserver_shm.cc (client_request_shm_get::serve): Remove the
	#ifdef'd stub for in-cygwin builds.
	(client_request_shm_get::client_request_shm_get): Use the new
	client_request constructor, and remove the in-cygwin variants.
	* cygserver_shm.h (class client_request_shm_get): #ifndef test the
	serve method - it's only used in cygserver.
	* shm.cc (client_request_shm_get::client_request_shm_get): New function.
	* include/cygwin/cygserver.h (request_header): New constructor.
	(class client_request): Use it.
	New constructor accepting the header size.
	#ifndef test the server method - it's only used within cygserver.
	(client_request_get_version): #ifdef test the server method.
	(client_request_shutdown): Ditto.
	(client_request_attach_tty): Ditto.

Tue Oct  2  9:57:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: add threaded_queue.o to cygserver.exe.
	* cygserver.cc: Include threaded_queue.h
	(class server_request): Inherit from queue_request.
	(class server_process_param): Inherit from queue_process_param.
	(class server_request_queue): Inherit from threaded_queue.
	(request_loop): Adjust for new types.
	(server_request_queue::process_requests): Remove guts to
	threaded_queue::process_requests.
	(server_request::server_request): Adjust for new types.
	(worker_function): Delete.
	(server_request_queue::create_workers): Delete.
	(server_request_queue::cleanup): Delete.
	(server_request_queue::add): Move guts to threaded_queue::add.
	* threaded_queue.cc: New file.
	* threaded_queue.h: New file.

Mon Oct  1 12:38:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (client_request::serve): New function.
	* cygserver_process.cc: Inlude <pthread.h> for pthread_once.
	(process_cache::process_cache): Initialise a crtiical section for write access.
	(process_cache::process): Use the critical section. Also add missing entries to
	the cache.
	(do_process_init): New function to initalise class process static variables.
	(process::process): Ensure that the process access critical section is
	initialised.
	(process::handle): Close the handle of old process's when they have terminated
	and we are returning the handle for a process with the same pid.
	* cygserver_shm.cc: Run indent.
	Include cygserver_process.h to allow process cache functionality.
	(client_request_shm_get::serve): New parameter for process cache support.
	Use the process cache, not OpenProcess to get a handle to the originating process.
	Fix a handle leak with token_handle.
	* cygserver_shm.h (class client_request_shm_get): Update ::serve for process
	cache support.
	* cygserver_transport_pipes.cc: Redefine debug_printf to be conditional on DEBUG.
	* include/cygwin/cygserver.h: Do not implement client_request::serve in the
	header.
	* include/cygwin/cygserver_process.h (class process_cache): Add a write access
	critical section to prevent races when requests from a  multithreaded
	application arrive.

Sun Sep 30 23:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_process.o to cygserver.exe.
	* cygserver.cc: Include signal.h and cygwin_version.h.
	Define debug_printf as a macro.
	Define DEBUG to a value.
	(client_request_attach_tty::serve): Add beginning of process cache support.
	Change from #ifdef DEBUG to work with new DEBUG style.
	(client_request_get_version::serve): Add beginning of process cache support.
	(class server_request): New prototype for support of process cache.
	(class queue_process_param): New class to allow request loop threading.
	(class server_request_queue): Add beginning of process cache support.
	Allow request loop threading.
	(request_loop): Thread function for request loops.
	(server_request_queue::process_requests): Initiator for threaded request loops.
	(client_request_shutdown::serve): Add beginning of process cache support.
	(server_request::server_request): Ditto.
	(server_request::process): Use debug_printf. Add beginning of process cache
	support.
	(server_request_queue::cleanup): Kill off any request loop threads.
	(server_request_queue::add): Add beginning of process cache support.
	(handle_signal): Trigger a shutdown.
	(main): Print out some useful info at startup - version, date time.
	Add process cache support.
	Spawn a separate thread for the transport request loop, thus allowing concurrent
	support for multiple transports.
	* cygserver_client.cc (client_request_get_version::serve): Add process cache
	support.
	(client_request_attach_tty::serve): Add process cache support.
	(client_request_shutdown::serve): Add process cache support.
	* cygsserver_process.cc: New file with the process cache support.
	* cygserver_shm.cc: Redefine debug_printf to allow conditional output.
	* cygwin.din: Export shmdt().
	* shm.cc: Run indent.
	Update FIXME's.
	(shmdt): New function.
	* include/cygwin/cygserver.h (class client_request): Add process cache support.
	(class client_request_get_version): Ditto.
	(class client_request_shutdown): Ditto.
	(class client_request_attach_tty): Ditto.
	* include/cygwin/cygserver_process.h: New header for process cache support.

Sun Sep 30  8:52:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* include/cygwin/cygserver_transport.h: Add copyright header.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.

Sat Sep 29 20:40:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_transport_sockets.o to DLL_OFILES.
	Add cygserver_transport_sockets_outside.o to cygserver.exe.
	* cygserver.cc: Include new include files.
	* cygserver_client.cc: Ditto.
	* cygserver_shm.h: No need to include <sys/socket.h> now.
	* cygerver_transport.cc: Include new include files.
	(transport_layer_base::transport_layer_base): Strip back to a stub.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.
	* cygserver_transport_pipes.cc: Include new header
	"cygwin/cygserver_transport_pipes.h".
	* cygserver_transport_sockets.cc: New file.
	* dcrt0.cc: No need to include <sys/socket.h> now.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.
	* include/cygwin/cygserver_transport.h: Strip the base class to a stub.
	Remove the cygserver_transport_pipes class.
	* include/cygwin/cygserver_transport_pipes.h: New file.
	* include/cygwin/cygserver_transport_sockets.h: New file.

Tue Sep 25 16:22:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* autoload.cc: Add dynamic load statement for 'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when obtaining
	handles from the parent process. On failure or 9x use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
	* cygserver.cc: New file.
	* cygserver_client.cc: New file.
	* cygserver_shm.cc: New file.
	* cygserver_shm.h: New file.
	* cygserver_transport.cc: New file.
	* cygserver_transport_pipes.cc: New file.
	* ipc.cc: New file.
	* shm.cc: New file.
	* include/cygwin/cygserver.h: New file.
	* include/cygwin/cygserver_transport.h: New file.
	* include/sys/ipc.h: New file.
	* include/sys/shm.h: New file.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* thread.cc (semaphore::TryWait): Set errno as required by posix 1003.1.
	(__sem_wait): Ditto.
	(__sem_trywait): Ditto.
@
text
@d299 3
a304 3

  if (fixup_mmaps_after_fork ())
    api_fatal ("recreate_mmaps_after_fork_failed");
@


1.77
log
@* fork.cc (fork_parent): Use sec_user_nih to control process/thread
inheritance/permission.
* spawn.cc (spawn_guts): Ditto.
* security.cc (create_token): Initialize token so that it is not tested for
bogus value later.  Use sec_user to control process/thread creation.
* security.h (__sec_user): Rename declaration from sec_user.
(sec_user_nih): Declare here as inline function wrapper for __sec_user.
(sec_user): Ditto.
* sigproc.cc (czombies): Allocate a character array for zombies to avoid
constructor overhead
(extremely hackish, I know).
(cpchildren): Ditto.
(pchildren): New define.
(zombies): Ditto.
(getsem): Use sec_user_nih to control semaphore inheritance/permission.
@
text
@d306 3
@


1.76
log
@* fhandler_disk_file.cc (fhandler_cygdrive::readdir): Avoid reporting
inaccessible drives.
@
text
@d473 2
a474 2
		      allow_ntsec ? sec_user (sa_buf) : &sec_none_nih,
		      allow_ntsec ? sec_user (sa_buf) : &sec_none_nih,
@


1.75
log
@Eliminate excess whitespace.
@
text
@d548 1
a548 1
  if (!sync_with_child(pi, subproc_ready, TRUE, "waiting for longjmp"))
@


1.74
log
@* dtable.cc (dtable::build_fhandler_from_name): Use PC_FULL to determine path
name.
* fork.cc (fork_parent): Correct the "unable to allocate forker_finished event"
error message.  It named the wrong event before.
@
text
@d221 1
a221 1
	      	     child_proc_info->forker_finished);
@


1.73
log
@Throughout, rename PROC_FORK1 to PROC_FORK.
* child_info.h: Rename PROC_* to _PROC_*.  Define PROC_* with additional
testing magic.  Eliminate old PROC_FORK and rename PROC_FORK1 to PROC_FORK.
* dcrt0.cc (_cygwin_testing_magic): New variable.  Added to magic number in
proc_info.
(alloc_stack): Eliminate old PROC_FORK test.
(dll_crt0_1): Ditto.  Use _PROC_* enums for test.  Subtract
_cygwin_testing_magic from child_proc_info->type so that normal cygwin programs
invoked by test suite programs do not consider themselves to be in a cygwin
environment.
(_dll_crt0): Ditto.  Move environment checks to initial_env function to
conserve on stack space.
(initial_env): New function.  Checks for testing and debugging environment
variables.
* init.cc (cygwin_hmodule): Move declaration.
* winsup.h: Declare variables used for cygwin testing.
@
text
@d425 1
a425 1
      system_printf ("unable to allocate subproc_ready event, %E");
@


1.72
log
@Revert incorrect checkins.
@
text
@d432 1
a432 1
  init_child_info (PROC_FORK1, &ch, 1, subproc_ready);
@


1.71
log
@* heap.h (inheap): Check for NULL.
@
text
@a317 1
  MALLOC_CHECK;
@


1.70
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d318 1
@


1.69
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d724 1
d747 1
@


1.68
log
@* exceptions.cc (setup_handler): Always relinquish lock after we've
interrupted.
* fhandler.cc: Move pipe methods to pipe.cc.
* fhandler.h (fhandler_pipe): Add new methods.
* fork.cc (sync_with_parent): Make error messages more informative.
* pipe.cc (fhandler_pipe::fhandler_pipe): Move here from fhandler.cc.
(fhandler_pipe::lseek): Ditto.
(fhandler_pipe::set_close_on_exec): New method.
(fhandler_pipe::read): Ditto.
(fhandler_pipe::close): Ditto.
(fhandler_pipe::dup): Ditto.
(make_pipe): Create the guard mutex on the read side of the pipe.
* select.cc (peek_pipe): Use guard_mutex to discover if we have the right to
read on this pipe.
(fhandler_pipe::readh_for_read): Pass the read pipe guard mutex to peek_pipe.
* syscalls.cc (_read): Always detect signal catchers, for now.
* debug.cc (makethread): Eliminate hack to make thread inheritable.
* sigproc.cc (subproc_init): Don't use hack to make thread inheritable.
@
text
@d20 1
@


1.68.2.1
log
@Tue Sep 25 16:22:00 2001 Robert Collins <rbtcollins@@hotmail.com>

        * autoload.cc: Add dynamic load statement for
	'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build
	instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when
	obtaining handles from the parent process. On failure or 9x
	use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
										CVS: ----------------------------------------------------------------------
@
text
@a304 3
  if (fixup_shms_after_fork ())
    api_fatal ("recreate_shm areas after fork failed");

@


1.68.2.2
log
@Merged changes from HEAD
@
text
@a19 1
#include "path.h"
@


1.68.2.3
log
@Merged changes from HEAD
@
text
@d221 1
a221 1
		     child_proc_info->forker_finished);
d428 1
a428 1
      system_printf ("unable to allocate forker_finished event, %E");
d435 1
a435 1
  init_child_info (PROC_FORK, &ch, 1, subproc_ready);
d551 1
a551 1
  if (!sync_with_child (pi, subproc_ready, TRUE, "waiting for longjmp"))
a726 1
      debug_printf ("exiting vfork, res %d", res);
a748 1
  debug_printf ("exiting vfork, pid %d", pid);
@


1.68.2.4
log
@Merged changes from HEAD
@
text
@d476 2
a477 2
		      sec_user_nih (sa_buf),
		      sec_user_nih (sa_buf),
@


1.68.2.5
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d15 1
d23 1
a286 3
  if (fixup_mmaps_after_fork (hParent))
    api_fatal ("recreate_mmaps_after_fork_failed");

d303 3
a468 1
  PSECURITY_ATTRIBUTES sec_attribs = sec_user_nih (sa_buf);
d476 2
a477 2
		      sec_attribs,
		      sec_attribs,
@


1.68.2.6
log
@Merged changes from HEAD
@
text
@d199 1
a199 1
  if (!SetEvent (fork_info->subproc_ready))
d203 1
a203 1
      HANDLE h = fork_info->forker_finished;
d216 1
a216 1
	      WaitForSingleObject (fork_info->forker_finished, 1) != WAIT_FAILED)
d219 1
a219 1
		     fork_info->forker_finished);
d268 1
a268 1
  if (fork_info->stacksize)
d270 2
a271 2
      ((DWORD *)fork_info->stackbottom)[-17] = (DWORD)do_exit;
      ((DWORD *)fork_info->stackbottom)[-15] = (DWORD)0;
d301 2
a302 2
  (void) ForceCloseHandle (fork_info->subproc_ready);
  (void) ForceCloseHandle (fork_info->forker_finished);
d444 1
a444 1
  if (cygheap->user.issetuid ())
d493 2
a494 1
      if (cygheap->user.issetuid ())
d522 1
a522 1
  if (cygheap->user.issetuid ())
@


1.68.2.7
log
@Merged changes from HEAD
@
text
@d246 1
a277 3
  cygheap->fdtab.fixup_after_fork (hParent);
  ProtectHandle (hParent);

d280 1
@


1.68.2.8
log
@Merged changes from HEAD
@
text
@d278 1
a278 1
  ProtectHandleINH (hParent);
d280 1
d302 2
a303 2
  (void) ForceCloseHandle1 (fork_info->subproc_ready, subproc_ready);
  (void) ForceCloseHandle1 (fork_info->forker_finished, forker_finished);
d362 10
d431 2
a432 2
  ProtectHandleINH (subproc_ready);
  ProtectHandleINH (forker_finished);
@


1.68.2.9
log
@Merged changes from HEAD
@
text
@d316 2
a317 1
  wait_for_sigthread ();
@


1.68.2.10
log
@Merged changes from HEAD
@
text
@a29 2
#include "sync.h"
#include "cygmalloc.h"
d459 1
a459 1
  __malloc_lock ();
d558 1
a558 1
  __malloc_unlock ();
@


1.68.2.11
log
@Merged changes from HEAD
@
text
@d690 2
a691 1
extern "C" int
a713 3
      vf->ctty = myself->ctty;
      vf->sid = myself->sid;
      vf->pgid = myself->pgid;
d716 1
a728 4
  myself->ctty = vf->ctty;
  myself->sid = vf->sid;
  myself->pgid = vf->pgid;

d731 1
a731 1
      int exitval = vf->exitval;
@


1.68.2.12
log
@Merged changes from HEAD
@
text
@d316 2
d319 1
a319 1
  pthread::atforkchild ();
d357 2
a358 1
  pthread::atforkprepare ();
d604 1
a604 1
  pthread::atforkparent ();
@


1.68.2.13
log
@Merged changes from HEAD
@
text
@d365 4
a368 4
  HANDLE console_handle = CreateFile ("CONOUT$", GENERIC_WRITE,
				      FILE_SHARE_WRITE, &sec_none_nih,
				      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
				      NULL);
d370 1
a370 1
  if (console_handle != INVALID_HANDLE_VALUE)
@


1.68.2.14
log
@Merged changes from HEAD
@
text
@d197 1
a197 1
sync_with_parent (const char *s, bool hang_self)
d261 1
a261 1
      Sleep (atoi (buf));
d429 1
a429 1
  si.cbReserved2 = sizeof (ch);
d478 2
a479 2
      ForceCloseHandle (subproc_ready);
      ForceCloseHandle (forker_finished);
d506 1
a506 1
  strcpy (forked->progname, myself->progname);
d520 1
a520 1
  forked->copysigs (myself);
@


1.67
log
@* dcrt0.cc (dll_crt0_1): Create vfork main storage here so that it can be
queried in waitsig later.
* sigproc.cc (wait_sig): Don't deliver a signal if in a vfork.
* fork.cc (vfork): Deliver all signals on parent return from vfork.
@
text
@d201 1
a201 1
    api_fatal ("fork child - SetEvent failed, %E");
d213 1
a213 1
	  api_fatal ("WFSO timed out");
d219 2
a220 1
	  api_fatal ("WFSO failed, fork_finished %p, %E", child_proc_info->forker_finished);
@


1.66
log
@*** empty log message ***
@
text
@d703 1
d718 1
a718 1
	   esp <= vf->vfork_ebp + 1; pp++, esp++)
a724 2
  cygheap->fdtab.vfork_parent_restore ();

a726 1
  __asm__ volatile ("movl %%esp,%0": "=r" (esp):);
d728 1
a728 1
       esp <= vf->vfork_ebp + 1; pp++, esp++)
d731 3
d744 1
@


1.65
log
@* fork.cc (vfork): Avoid recursive vforks.
@
text
@d736 1
@


1.64
log
@* cygheap.cc (dup_now): New function.
(cygheap_setup_for_child): Accept new argument controlling whether to delay
copying of cygheap to shared memory region.
(cygheap_setup_for_child_cleanup): Accept new arguments controlling whether to
copy cygheap at this point.
* cygheap.h: Reflect above changes.
* fork.cc (fork_parent): Break copying of cygheap into two parts when
fork_fixup is required so that the child can see the parent's changes.
(vfork): Do stack cleanup prior to forcing a fork error.
* spawn.cc (spawn_guts): Ditto.
@
text
@d708 2
d740 3
a742 1
  return vf->pid;
@


1.63
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d467 2
a468 1
  cygheap_setup_for_child (&ch);
a480 1
  cygheap_setup_for_child_cleanup (&ch);
d492 1
d498 3
a500 1
  if (cygheap->fdtab.need_fixup_before ())
d503 1
d725 6
a736 5

  __asm__ volatile ("movl %%esp,%0": "=r" (esp):);
  for (pp = (char **)vf->frame, esp = vf->vfork_esp;
       esp <= vf->vfork_ebp + 1; pp++, esp++)
    *esp = *pp;
@


1.62
log
@Tue Sep 11 18:15:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * dcrt0.cc (cygwin_finished_initializing): Copy _mtinterf on fork;
        * fork.cc (fork_child): fixup thread-related structures after fork;
        * thread.cc (MTinterface::Init): Initialise the new mutex, condition and semaphore lists.
        (MTinterface::fixup_after_fork): Iterate through each list and fixup the objects.
        (pthread_cond::pthread_cond): Add this to the condition list.
        (pthread_cond::~pthread_cond): Remove this from the condition list.
        (pthread_cond::fixup_after_fork): Recreate as best we can the pre-fork state.
        (pthread_mutex::pthread_mutex): Add this to the mutex list.
        (pthread_mutex::~pthread_mutex): Remove this from the mutex list.
        (pthread_mutex::fixup_after_fork): Recreate as best we can the pre-fork state.
        (semaphore::semaphore): Store the initial value, and add this to the semaphore list.
        (semaphore::~semaphore): Remove this from the semaphore list.
        (semaphore::Post): Increment the current semaphore value.
        (semaphore::TryWait): Decrement the current semaphore value.
        (semaphore::Wait): Ditto.
        (semaphote::fixup_after_fork): Recreate the pre-fork state as best we can.
        * thread.h (pthread_mutex): New members to allow fixup_after_fork.
        (pthread_cond): Ditto.
        (semaphore): Ditto.
        (MTinterface): New list heads for tracking conds and semaphores.
@
text
@a37 1
DWORD NO_COPY chunksize = 0;
d89 1
a89 1
      DWORD todo = chunksize ?: high - low;
@


1.61
log
@* fork.cc (fork_parent): Stop malloc activity while fork is in control of the
heap.
* sigproc.cc (NZOMBIES): Rename from ZOMBIEMAX for clarity.
(zombies): Revert to original behavior.  Allocating zombie array resulted in
performance hit.
* winsup.h: Declare malloc lock routines.
@
text
@d312 2
@


1.60
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d465 1
d561 1
@


1.59
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d249 1
a249 1
      		  first_dll, load_dlls);
a281 1
  sigproc_fixup_after_fork ();
a431 3
  ch.heaptop = user_data->heaptop;
  ch.heapbase = user_data->heapbase;
  ch.heapptr = user_data->heapptr;
d488 1
a488 1
          && cygheap->user.token != INVALID_HANDLE_VALUE)
d555 1
a555 1
		  ch.heapbase, ch.heapptr,
@


1.58
log
@* cygheap.h (init_cygheap): Move bucket array here from cygheap.cc.
* cygheap.cc: Throughout use bucket array from cygheap.
* sigproc.cc (proc_subproc): Dynamically allocate zombie buffer to save DLL
space.
(sigproc_fixup_after_fork): Free zombie array after a fork.
* sigproc.h (sigproc_fixup_after_fork): Declare.
* dir.cc (mkdir): Expand buffer for security descriptor to 4K to avoid stack
corruption.
* fhandler.cc (fhandler_base::open): Ditto.
* path.cc (symlink): Ditto.
@
text
@d33 3
a35 3
static int npid = 0;
static int npid_max = 0;
static pid_t fork_pids[100] = {0};
@


1.57
log
@* debug.cc (mark_closed): Rename from debug_mark_closed and make static.
(setclexec_pid): New function for marking saved handle as close-on-exec.
(delete_handle): New function.
(debug_fixup_after_fork): New function.
* debug.h: Declare new functions, remove obsolete ones.
* fork.cc (debug_fixup_after_fork): Call to cleanup close-on-exec handles.
* fhandler.cc (fhandler_disk_file::close): Minor reorg.
(fhandler_base::set_inheritance): Set flag appropriately for debugging when
close-on-exec so forked process can delete closed handles.
* tty.h (open_output_mutex): Eliminate unneeded argument.
(open_input_mutex): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): reflect open_*_mutex argument
changes.
* fhandler.h (fhandler_socket): Make saw_shutdown_* functions type bool.
* tty.cc (tty::get_event): Eliminate unneeded argument.
(tty::common_init): Reflect change to get_event.  Events should always be
inherited.
@
text
@d282 1
@


1.56
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d279 1
@


1.55
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d119 1
a119 1
err:
d461 1
a461 1
out:
d480 1
a480 1
  ForceCloseHandle1 (ch.cygheap_h, passed_cygheap_h);
d610 1
a610 1
cleanup:
@


1.54
log
@* cygheap.cc (cygheap_fixup_in_child): Attempt Win95 workaround.
* dtable.cc (dtable::dup_worker): Add debugging output.
(dtable::vfork_child_dup): Correctly set close_on_exec.
* fhandler.cc (fhandler_base::fork_fixup): Don't mess with handle if there is
no need to get it from the parent.
* fhandler_tty.cc (fhandler_tty_common::close): Add debugging output.
@
text
@d18 1
a30 1
#include "security.h"
@


1.53
log
@* cygheap.cc (_cmalloc): Use correct constants for size calculation.
* dcrt0.cc (dll_crt0_1): Move uid initialization earlier.
* fork.cc (fork_parent): Move cygheap_setup_in_child to just prior to
CreateProcess so that all contents of cygheap are copied.
* spawn.cc (spawn_guts): Ditto.
@
text
@d248 2
a249 1
  sigproc_printf ("hParent %p, child 1 first_dll %p, load_dlls %d\n", hParent, first_dll, load_dlls);
@


1.52
log
@* child_info.h: Bump magic number.
(class child_info): Add an element.
* cygheap.cc (init_cheap): Allocate cygwin heap in shared memory area.
(cygheap_fixup_in_child): Map cygwin heap, passed from parent via shared memory
into correct address.
(cygheap_setup_for_child): New function.
* cygheap.h: Declare new functions.
* dcrt0.cc (dll_crt0_1): Accomodate new cygheap_fixup_in_child arguments.
Avoid protecting subproc_ready unless it is spawn/nowait.
* fork.cc (fork_parent): Use new cygheap_setup_for_child function to setup
cygwin heap info.  Close passed cygheap shared memory handle.
* spawn.cc (spawn_guts): Ditto.  Also, reorganize to avoid synchronization
between parent and child in non-P_OVERLAY case.
* sigproc.cc (wait_sig): Only signal subproc_ready when execing.
@
text
@a444 1
  cygheap_setup_for_child (&ch);
d466 1
@


1.51
log
@forced commit
@
text
@d445 1
a445 2
  ch.cygheap = cygheap;
  ch.cygheap_max = cygheap_max;
d479 1
@


1.50
log
@* exceptions.cc (interrupt_setup): Move actions from setup_handler to here.
(setup_handler): Move actions after a successful interrupt to interrupt_setup.
* fork.cc (vfork): Augment debugging output.
* sigproc.cc (proc_subproc): Ditto.
* spawn.cc (spawn_guts): Ditto.  Correctly fill out progname when spawn
NO_WAIT.  Call signal handler when a signal arrives.
* sigproc.h: Declare a function.
@
text
@@


1.49
log
@* fhandler_tty.cc (fhandler_tty_slave::init): Revert 2001-06-16 change.
* fork.cc (fork_copy): Print more debugging info.
(fork_parent): Change order of arguments to accomdate buggy gcc.
(fork): Ditto.
* syscalls.cc (_unlink): Reorganize to try harder to delete file with
DeleteFile and to recover more gracefully if FILE_FLAG_DELETE_ON_CLOSE doesn't
work properly.
@
text
@d711 3
a713 1
      return cygheap->fdtab.vfork_child_dup () ? 0 : -1;
@


1.48
log
@* environ.cc (set_file_api_mode): New function. Move setting
of file APIs mode (OEM/ANSI) here.
(codepage_init): From here.
* winsup.h (set_file_api_mode): Declare it.
* fork.cc (fork_child): Set file APIs mode in forkee.
@
text
@d107 2
a108 2
	      system_printf ("%s pass %d failed, %p..%p, done %d, %E",
			    what, pass, low, high, done);
d343 2
a344 2
fork_parent (void *stack_here, HANDLE& hParent, dll *&first_dll,
	     bool& load_dlls, child_info_fork &ch)
d649 1
a649 1
  __asm ("movl %%esp,%0": "=r" (esp));
d660 1
a660 1
    res = fork_parent (esp, grouped.hParent, grouped.first_dll, grouped.load_dlls, ch);
@


1.47
log
@* fork.cc (fork_parent): Move atforkprepare call here.
(fork): From here.
@
text
@d274 2
@


1.46
log
@        * fork.cc (fork): Eliminate superfluous call to getuid().
        * security.h: New define `NO_SID'. Remove declarations of functions
        moved to methods into class cygsid.
        (class cygsid): Declare new methods `getfromstr', `get_sid',
        `getfrompw', `getfromgr', `get_rid', `get_uid', `get_gid', `string'
        and new constructors and operators =, == and !=.
        Declare new global cygsids `well_known_XXX_sid' substituting the
        corresponding `get_XXX_sid' functions. Remove declarations of
        these functions.
        * sec_helper.cc (well_known_admin_sid): New global variable.
        (well_known_system_sid): Ditto
        (well_known_creator_owner_sid): Ditto
        (well_known_world_sid): Ditto
        (cygsid::string): New method, substituting `convert_sid_to_string_sid'.
        (cygsid::get_sid): New method, substituting `get_sid'.
        (cygsid::getfromstr): New method, substituting
        `convert_string_sid_to_sid'.
        (cygsid::getfrompw): New method, substituting `get_pw_sid'.
        (cygsid::getfromgr): New method, substituting `get_gr_sid'.
        (cygsid::get_id): New method, substituting `get_id_from_sid'.
        (get_admin_sid): Eliminated.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * grp.cc: Use new cygsid methods and well known sids throughout.
        * registry.cc: Ditto.
        * sec_acl.cc: Ditto.
        * security.cc: Ditto.
        * shared.cc: Ditto.
        * syscalls.cc (seteuid): Ditto. Eliminate redundant conditional.
        * uinfo.cc (internal_getlogin): Ditto.
        * spawn.cc (spawn_guts) Revert previous patch.
@
text
@d310 1
a310 1
  __pthread_atforkchild();
d348 3
d602 1
a602 1
  __pthread_atforkparent();
a644 3

  /* call the pthread_atfork prepare functions */
  __pthread_atforkprepare();
@


1.45
log
@        * autoload.cc: Add LoadDLLinitfunc for secur32.dll.
        Add LoadDLLfuncEx statements for AllocateLocallyUniqueId@@4,
        DuplicateTokenEx@@24, LsaNtStatusToWinError@@4,
        LsaDeregisterLogonProcess@@4, LsaFreeReturnBuffer@@4,
        LsaLogonUser@@56, LsaLookupAuthenticationPackage@@12,
        LsaRegisterLogonProcess@@12,
        * environ.cc: Add extern declaration for `subauth_id'.
        (subauth_id_init): New function for setting `subauth_id'.
        (struct parse_thing): Add entry for `subauth_id'.
        * fork.cc (fork_parent): Call `RevertToSelf' and
        `ImpersonateLoggedOnUser' instead of `seteuid'.
        * security.cc: Define global variable `subauth_id'.
        (extract_nt_dom_user): New function.
        (cygwin_logon_user): Call `extract_nt_dom_user' now.
        (str2lsa): New static function.
        (str2buf2lsa): Ditto.
        (str2buf2uni): Ditto.
        (subauth): Ditto.
        * security.h: Add prototype for `subauth'.
        * spawn.cc (spawn_guts): Use cygheap->user.token only if impersonated.
        Use `cygsid' type. Remove impersonation before allowing access to
        workstation/desktop to everyone. Call `RevertToSelf' and
        `ImpersonateLoggedOnUser' instead of `seteuid'.
        * syscalls.cc (seteuid): Rearranged to allow using subauthentication
        to retrieve user tokens when needed.
@
text
@a435 2
  uid_t uid;
  uid = geteuid();
@


1.44
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d439 1
a439 1
    seteuid (cygheap->user.orig_uid);
d487 1
a487 1
	seteuid (uid);
d511 1
a511 1
    seteuid (uid);
@


1.43
log
@* fork.cc (fork_child): Call the __pthread_atforkchild function.
(fork_parent): Call the __pthread_atforkparent function.
* cygwin.din: Export pthread_atfork.
* thread.h (callback): New class.
(MTinterface): Use it.
* thread.cc (__pthread_atforkprepare): New function.
(__pthread_atforkparent): New function.
(__pthread_atforkchild): New function.
(__pthread_atfork): New function.
* pthread.cc (pthread_atfork): New function.
@
text
@d277 1
a277 1
  fdtab.fixup_after_fork (hParent);
d380 1
a380 1
  if (fdtab.need_fixup_before ())
d493 1
a493 1
  if (fdtab.need_fixup_before ())
d495 1
a495 1
      fdtab.fixup_before_fork (pi.dwProcessId);
d711 1
a711 1
      return fdtab.vfork_child_dup () ? 0 : -1;
d714 1
a714 1
  fdtab.vfork_parent_restore ();
@


1.42
log
@Update copyrights.
@
text
@d310 1
d601 1
d644 3
@


1.41
log
@* fork.cc (fork_parent): Return EAGAIN when can't record pid.
* pinfo.h (pinfo::remember): Return value of call to proc_subproc.
* sigproc.cc (proc_subproc): Return error if can't record pid.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.40
log
@Update ChangeLog.
@
text
@a516 2
  slow_pid_reuse (pi.hProcess);

d521 14
a534 1
  forked.remember ();
@


1.39
log
@* sigproc.cc (wait_sig): Remove unneeded for loop iteration.
* exceptions.cc (interrupt_setup): Don't set signal mask here or races occur
with main thread.  Set it in sigdelayed instead.
(sigreturn): Reflect change in stack order of ebp and flags.
(sigdelayed): Set stack frame correctly.  Call set_process_mask here with flags
for last trapped signal.
(signal_dispatch): Add newmask.
* sigproc.cc (wait_sig): Eliminate ill-considered attempt to halt looping
signal processors.
@
text
@d317 1
a317 1
  static NO_COPY HANDLE last_fork_procs[128] = {0};
@


1.38
log
@        * cygheap.h: Move `token' and `impersonated' from class _pinfo
        to class cygheap_user.
        * pinfo.h: Ditto.
        * fork.cc (fork_child): Change usage of `token' and `impersonated'
        accordingly.
        (fork_parent): Ditto.
        * security.cc (cygwin_set_impersonation_token): Ditto.
        * sigproc.cc (proc_subproc): Ditto.
        * spawn.cc (spawn_guts): Ditto.
        * syscalls.cc (seteuid): Ditto.
        * uinfo.cc (uinfo_init): Ditto.
@
text
@d317 1
a317 1
  static NO_COPY HANDLE last_fork_procs[64] = {0};
@


1.37
log
@* fork.cc (slow_pid_reuse): Off-by-one.
@
text
@d237 1
a237 1
  if (myself->impersonated)
d239 2
a240 2
      debug_printf ("Impersonation of child, token: %d", myself->token);
      if (myself->token == INVALID_HANDLE_VALUE)
d242 1
a242 1
      else if (!ImpersonateLoggedOnUser (myself->token))
d437 1
a437 1
  if (myself->impersonated && myself->token != INVALID_HANDLE_VALUE)
d484 2
a485 1
      if (myself->impersonated && myself->token != INVALID_HANDLE_VALUE)
d509 1
a509 1
  if (myself->impersonated && myself->token != INVALID_HANDLE_VALUE)
@


1.36
log
@Throughout use myself->ppid_handle rather than parent_alive.
* child_info.h (child_info): Eliminate parent_alive.
* dcrt0.cc (dll_crt0_1): Call fork_init for debugging pid creation.
* fork.cc (fork_child): Reflect change to fixup_mmaps_after_fork arguments.
(slow_pid_reuse): New function to grab last 'n' pids to prevent pid reuse.
(fork_parent): Move last_fork_proc into slow_pid_reuse.  Handle fork_pids
debugging.  Eliminate unnecessary call to set_child_mmap_ptr.
(fork_init): New debugging function.
* mmap.cc (fixup_mmaps_after_fork): Renamed from recreate_mmaps_after_fork.
Rely on copied data after a fork.
(set_child_mmap_ptr): Eliminate.
* pinfo.h (_pinfo): Eliminate parent_alive, mmap_ptr and reflect above changes.
* spawn.cc (spawn_guts): Eliminate vestiges of "old way" of sending new hProc
to parent process.
@
text
@d317 1
a317 1
  static NO_COPY HANDLE last_fork_procs[64];
d320 1
a320 1
  if (nfork_procs > (sizeof (last_fork_procs) / sizeof (last_fork_procs [0])))
d327 2
a328 2
    CloseHandle (last_fork_procs[nfork_procs]);
  if (!DuplicateHandle (hMainProc, h, hMainProc, &last_fork_procs[nfork_procs],
d330 2
@


1.35
log
@        * cygheap.cc (cygheap_root::cygheap_root): New function.
        (cygheap_root::~cygheap_root): Ditto.
        (cygheap_root::operator=): Ditto.
        (cygheap_user::~cygheap_user): Ditto.
        (cygheap_user::set_name): Ditto.
        (cygheap_user::set_logsrv): Ditto.
        (cygheap_user::set_domain): Ditto.
        (cygheap_user::set_sid): Ditto.
        * cygheap.h (cygheap_root): New class.
        (cygheap_user): Ditto.
        (init_cygheap): Change type of `root' member to cygheap_root.
        Add `user' member.
        * dir.cc (opendir): Use new `cygheap_root' class.
        * dcrt0.cc (dll_crt0_1): Use new `cygheap_user' class.
        * fork.cc (fork_parent): Ditto.
        * grp.cc (getgroups): Ditto.
        * passwd.cc (search_for): Ditto.
        * path.cc: Use new `cygheap_root' class throughout.
        * pinfo.h (_pinfo): Remove `use_psid'. Move `username', `psid',
        `logsrv', `domain', `orig_{uid,gid}' and `real_{uid,gid}' to
        cygheap_user class.
        * security.cc: Use new `cygheap_user' class throughout.
        * shared.cc (sec_user): Ditto.
        * sigproc.cc (proc_subproc): Remove copy statements for user
        related information moved to `cygheap_user' class.
        * spawn.cc (spawn_guts): Invalidate current chroot settings
        when creating Windows environment. Use new `cygheap_user' class.
        * syscalls.cc: Use new `cygheap_user' class throughout.
        * uinfo.cc: Ditto.
        * uinfo.cc (internal_getlogin): Change parameters to reflect the
        move of user information to cygheap.
@
text
@d32 6
d298 1
a298 1
  if (recreate_mmaps_after_fork (myself->mmap_ptr))
d314 23
d338 2
a339 1
fork_parent (void *stack_here, HANDLE& hParent, dll *&first_dll, bool& load_dlls, child_info_fork &ch)
a343 1
  static NO_COPY HANDLE last_fork_proc = NULL;
d347 1
a347 1
#ifdef DEBUGGING
d380 2
d441 17
d469 1
a469 1
		      0,		  /* use current drive/directory */
d495 3
d499 1
d514 1
a514 10
  /* Keep a handle to the current forked process sitting around to prevent
     Windows from reusing the same pid twice in a row.  Having the same pid
     twice in a row confuses bash.  So, after every CreateProcess, we can safely
     remove the old pid and save a handle to the newly created process.  Keeping
     a handle open will stop windows from reusing the same pid.  */
  if (last_fork_proc)
    CloseHandle (last_fork_proc);
  if (!DuplicateHandle (hMainProc, pi.hProcess, hMainProc, &last_fork_proc,
			0, FALSE, DUPLICATE_SAME_ACCESS))
    system_printf ("couldn't create last_fork_proc, %E");
a519 1
  set_child_mmap_ptr (forked);
d647 13
@


1.34
log
@* child_info.h (child_info): Add pppid_handle for closing the parent's of the
parent handle.
* dcrt0.cc (_dll_crt0): Close parent's parent handle when spawned or forked.
* debug.cc (add_handle): Correct erroneous reference to handle structure when
printing warning.
* exceptions.cc (interrupt_now): Always return 1.
(interrupt_on_return): Accept a sigthread argument.  Check to see if this
argument has been trashed prior to setting up the stack return.
(call_handler): Add a loop around attempts to dispatch signals to detect case
where interrupt_on_return fails.
(_sigdelayed): Set up a temporary frame pointer prior to calling stuff that
could trigger an interrupt or the stack walking code will be very confused.
* fork.cc (fork_parent): Move a lot of the setup of the child process into
proc_subproc.
* spawn.cc (spawn_guts): Ditto.  Use ppid_handle to contact logical parent when
reparenting.
* pinfo.h (_pinfo): Remember the logical handle of the parent process.
* sigproc.cc (proc_subproc): Record most stuff necessary for the _pinfo
structure that is inferrable from myself when adding children.
(wait_sig): Always set 'pending_signals' flag when about to kick off the signal
scanning loop.  Reset it only if there are no pending signals.
@
text
@d405 1
a405 1
    seteuid (myself->orig_uid);
a476 1
  memcpy (forked->username, myself->username, MAX_USER_NAME);
@


1.33
log
@        * dtable.cc (dtable::release): Check for socket. Change
        cnt_need_fixup_before accordingly.
        (dtable::dup2): Ditto.
        (dtable::fixup_before_fork): New method.
        (dtable::fixup_before_exec): Ditto.
        * dtable.h (class dtable): Add member `cnt_need_fixup_before'. Add
        definition for methods `dec_need_fixup_before', `inc_need_fixup_before',
        `need_fixup_before', `fixup_before_exec' and `fixup_before_fork'.
        * fhandler.h (class fhandler_base): Slight rearrangements. Add
        definitions for methods `fixup_before_fork_exec'.
        (class fhandler_socket): Eliminate superfluous constructor.
        Add member `prot_info_ptr'. Add destructor. Add definitions for
        methods `dup', `fixup_before_fork_exec', `fixup_after_fork' and
        `fixup_after_exec'.
        * fork.cc (fork_parent): Care for file types which need a fixup
        before fork. Start child in suspended state then.
        * net.cc: New global variable `ws2_32_handle' and `wsadata'.
        (fdsock): Check for Winsock version. Call `set_socket_inheritance'
        only if Winsock version < 2.0. Care for `need_fixup' count in fdtab.
        (cygwin_socket): Eliminate call to `set_socket_inheritance'.
        (cygwin_accept): Ditto.
        (cygwin_rcmd): Ditto.
        (cygwin_rresvport): Ditto.
        (cygwin_rexec): Ditto.
        (socketpair): Ditto.
        (fhandler_socket::fhandler_socket): Set `need_fork_fixup'. Allocate
        space for the WSAPROTOCOL_INFOA struct used in fixup.
        (fhandler_socket::~fhandler_socket): New destructor.
        (fhandler_socket::fixup_before_fork_exec): New method.
        (fhandler_socket::fixup_after_fork): Ditto.
        (fhandler_socket::dup): Ditto.
        (wsock_init): New static function.
        (LoadDLLinitfunc (wsock32)): Rearranged.
        (LoadDLLinitfunc (ws2_32)): New function.
        (dummy_autoload): Add autoload statemants for `WSADuplicateSocketA'
        and `WSASocketA'.
        * spawn.cc (spawn_guts): Care for file types which need a fixup
        before exec. Start child in suspended state then.
@
text
@a473 1
  forked->ppid = myself->pid;
a475 6
  forked->uid = myself->uid;
  forked->gid = myself->gid;
  forked->pgid = myself->pgid;
  forked->sid = myself->sid;
  forked->ctty = myself->ctty;
  forked->umask = myself->umask;
a476 2
  forked->process_state |= PID_INITIALIZING |
			  (myself->process_state & PID_USETTY);
a477 15
  if (myself->use_psid)
    {
      memcpy (forked->psid, myself->psid, MAX_SID_LEN);
      forked->use_psid = 1;
    }
  memcpy (forked->logsrv, myself->logsrv, MAX_HOST_NAME);
  memcpy (forked->domain, myself->domain, MAX_COMPUTERNAME_LENGTH+1);
  forked->token = myself->token;
  forked->impersonated = myself->impersonated;
  forked->orig_uid = myself->orig_uid;
  forked->orig_gid = myself->orig_gid;
  forked->real_uid = myself->real_uid;
  forked->real_gid = myself->real_gid;
  strcpy (forked->root, myself->root);
  forked->rootlen = myself->rootlen;
d479 1
a514 2

  forked.remember ();
@


1.32
log
@* dcrt0.cc (do_exit): Don't bother looking for pgrp children to send SIGHUP if
process has never created any children.
* fork.cc (fork): Set flag indicating that there is another process with our
process group.
* spawn.cc (spawn_guts): Ditto.
* pinfo.h (set_has_pgid_children): New methods for setting when process has
children in its process group.
* syscalls.cc (setpgid): Clear has_gid_children if pgid changes.
@
text
@d344 7
d437 8
@


1.31
log
@* fork.cc (fork): Set sigframe here, since it can pause for a considerable
amount of time.
* environ.cc (_addenv): Add debugging.
* fhandler.cc: Eliminate unneeded include.
* smallprint.c: Ditto.
@
text
@d601 2
@


1.30
log
@* fhandler.h (fhandler_console): Remove tcsetpgrp.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Eliminate.
* fork.cc (fork_parent): Avoid returning same pid twice in a row regardless of
OS.
* pinfo.cc (pinfo::init): Rename create argument to flags and treat it as such.
* signal.cc (set_sigcatchers): New function.
(signal): Use set_sigcatchers to increment or decrement sigcatcher tracker.
(sigaction): Ditto.  Add debugging output.
* spawn.cc (spawn_guts): Always quote first argv[0] argument when it's a
COMSPEC shell.
@
text
@d583 1
@


1.29
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d446 11
a456 8
  if (os_being_run != winNT)
    {
      if (last_fork_proc)
	CloseHandle (last_fork_proc);
      if (!DuplicateHandle (hMainProc, pi.hProcess, hMainProc, &last_fork_proc,
			    0, FALSE, DUPLICATE_SAME_ACCESS))
	system_printf ("couldn't create last_fork_proc, %E");
    }
@


1.28
log
@* exceptions.cc (set_console_handler): Don't allocate
console_handler_thread_waiter.  It is obsolete.
(ctrl_c_handler): Don't use console_handler_thread_waiter.
* path.cc (hash_path_name): Fix handling of relative names.  Make case
insensitive.
* path.h (suffix_info): Use initializers.
* pinfo.h (_pinfo): Avoid initializers for null case.
* resource.cc (fill_rusage): Zero rest of rusage structure.
* security.cc (set_process_privileges): Don't reopen parent process.  Just use
hMainProc.
* signal.cc (signal): Track when a signal handler has been used.
(sigaction): Ditto.
* sigproc.cc (pchildren): Use default initializer.
(zombies): Ditto.
(sigproc_terminate): Avoid closing handles that will be closed on exit anyway.
(wait_sig): Send signal to "parent" on EXECing, not FORKing.
(wait_subproc): Send SIGCHLD here rather than in proc_wait to avoid potential
muto conflicts.
* sigproc.h (sigthread): Don't initialize to zero.  It's the default.
* spawn.cc (spawn_guts): Fill in resources from exec parent prior to
termination.
* sync.h (muto): Don't initialize to zero.
* syscalls.cc (close_all_files): Use one lock around entire loop and call
fhandler close/release stuff directly.
(_read): Don't use ready_for_read if there are not signal handlers active.
* dcrt0.cc (dll_crt0_1): Fix display of "title".
(do_exit): Use pinfo exit method to exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_child): Remove debugging stuff.  Use pinfo_fixup_after fork in
place of exec_fixup_after_fork.
* pinfo.cc (pinfo_fixup_after_fork): New method.
(pinfo_fixup_in_spawned_child): Ditto.
(_pinfo::exit): New method.
(_pinfo::init): Remove recursion.  Detect pathological case where pinfo
structure already exists for new pid.
* pinfo.h (_pinfo): Reorganize slightly.  Add new method and new function
declarations.
* sigproc.cc (proc_exists): Previous simplification was a little to simple.
Try harder to detect if a process exists.
(proc_terminate): Use PID_EXITED setting to determine if process is still
around.
(WFSO): Remove debugging statement.
(WFMO): Ditto.
* spawn.cc (exec_fixup_after_fork): Eliminate.
(spawn_guts): Always set old_title to NULL.  Is it really needed?  Move
hexec_proc to pinfo.cc.  Call pinfo_fixup_in_spawned_child to eliminate handle
link after a spawn.
* include/sys/cygwin.h: Remove PID_NOT_IN_USE.  Add PID_EXITED.
@
text
@d304 1
@


1.27
log
@* cygheap.cc (cygheap_fixup_in_child): Don't page round cygheap copied from
parent.
* dcrt0.cc (do_exit): Don't cleanup pinfo on exit.  That happens automatically
now.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_parent): Use stack_here value passed in from fork().
(fork): Figure out top of stack here and pass it to fork_parent.
* pinfo.cc (_pinfo::record_death): Eliminate.
* pinfo.h (_pinfo): Ditto.
* sigproc.cc (proc_exists): Simplify.
(proc_terminate): Ditto.
(remove_zombie): Don't cleanup pinfo stuff.
(wait_sig): Send subproc_ready signal whether execed or spawned.
* spawn.cc (spawn_guts): Always create subproc_ready event.  Use it for both
exec and spawn.
(_spawnve): Send proper mode to spawn_guts when mode != _P_OVERLAY.
@
text
@a227 2
  child_info_fork ch;
  stack_base (ch);
a240 1
debug_printf ("hParent %p", hParent);
d242 1
a242 1
// small_printf ("child 1 first_dll %p, load_dlls %d\n", first_dll, load_dlls);
d270 1
a272 1
  exec_fixup_after_fork ();
@


1.26
log
@* child_info: Bump child_info "version".
(child_info): Move some fields from child_info_spawn to here.
* cygheap.cc: Make cygheap pointers NOCOPY.
* dcrt0.cc (dll_crt0_1): Copy cygwin heap here regardless of whether we've been
forked or execed.
* dtable.cc (dtable::fixup_after_fork): Just release close-on-exec fds.
* exceptions.cc (stackdump): Respond to C warning.
* fork.cc: Reorganize to minimize stack copying.
(fork_child): New function.
(fork_parent): Ditto.
(sync_with_child): Don't suspend the forkee.
(sync_with_parent): Ditto.  Make into a function.
* heap.cc (heap_init): Add some debugging output.
* path.cc (path_conv::check): Add an assertion.
(has_suffix): Ditto.
* security.cc (get_pw_sid): Defend against NULL.
* sigproc.cc (proc_subproc): Fix debugging output.
(wait_sig): Ditto.
* strace.cc: Make statics NO_COPY throughout.
(strace::vsprntf): Defend against NULL.
@
text
@d311 1
a311 1
fork_parent (HANDLE& hParent, dll *&first_dll, bool& load_dlls, child_info_fork &ch)
a313 1
  void *stack_here = &hParent;
a340 2
  syscall_printf ("CreateProcessA (%s, %s,0,0,1,%x, 0,0,%p,%p)",
		  myself->progname, myself->progname, c_flags, &si, &pi);
d407 12
a418 10
  rc = CreateProcessA (myself->progname, /* image to run */
		       myself->progname, /* what we send in arg0 */
		       allow_ntsec ? sec_user (sa_buf) : &sec_none_nih,
		       allow_ntsec ? sec_user (sa_buf) : &sec_none_nih,
		       TRUE,	  /* inherit handles from parent */
		       c_flags,
		       NULL,	  /* environment filled in later */
		       0,		  /* use current drive/directory */
		       &si,
		       &pi);
a580 3
  int res;
  int x;

a582 2
  // grow_stack_slack ();

d584 2
d596 3
a599 1
  x = setjmp (ch.jmp);
d601 3
a603 1
  if (x != 0)
d606 1
a606 1
    res = fork_parent (grouped.hParent, grouped.first_dll, grouped.load_dlls, ch);
@


1.25
log
@* errno.cc (seterrno_from_win_error): Fix debugging output.
* fhandler.cc (fhandler_base::fstat): Move to inline method in fhandler.h.
(fhandler_base::set_io_handle): Ditto.
* fhandler.h (fhandler_base): Make some methods inline.
* fhandler_console.cc (fhandler_console::write_normal): Make buffer larger.
* sigproc.h (sigframe::sigframe): Actually use set ebp parameter correctly.
* spawn.cc (spawn_guts): Set dwProcessId when exec'ing.  Just exit immediately
after reparenting.
* syscalls.cc: Sprinkle sigframe stuff throughout.
* wait.cc (wait4): Set signal frame here.
* dcrt0.cc (__api_fatal): Don't rely on small_printf to display errors.  Always
display problems to the console, if possible.
@
text
@a175 5
  if (hang_child)
    {
      int n = SuspendThread (pi.hThread);
      debug_printf ("suspend count %d", n); \
    }
a181 3
  int rc;

  debug_printf ("here");
d183 2
a184 16

  rc = ResumeThread (pi.hThread);

  debug_printf ("rc %d", rc);
  if (rc == 1)
    return 1;		// Successful resumption

  /* Can't resume the thread.  Not sure why this would happen unless
     there's a bug in the system.  Things seem to be working OK now
     though, so flag this with EAGAIN, but print a message on the
     console.  */
  small_printf ("fork: ResumeThread failed, rc = %d, %E\n", rc);
  set_errno (EAGAIN);
  syscall_printf ("-1 = fork(), ResumeThread failed");
  TerminateProcess (pi.hProcess, 1);
  return 0;
d190 88
a277 30
#define sync_with_parent(s, hang_self) \
((void) ({ \
  debug_printf ("signalling parent: %s", s); \
  /* Tell our parent we're waiting. */ \
  if (!SetEvent (child_proc_info->subproc_ready)) \
    api_fatal ("fork child - SetEvent failed, %E"); \
  if (hang_self) \
    { \
      /* Wait for the parent to fill in our stack and heap. \
	 Don't wait forever here.  If our parent dies we don't want to clog \
	 the system.  If the wait fails, we really can't continue so exit.  */ \
      DWORD psync_rc = WaitForSingleObject (child_proc_info->forker_finished, FORK_WAIT_TIMEOUT); \
      switch (psync_rc) \
	{ \
	case WAIT_TIMEOUT: \
	  api_fatal ("sync_with_parent - WFSO timed out"); \
	  break; \
	case WAIT_FAILED: \
	  if (GetLastError () == ERROR_INVALID_HANDLE && \
	      WaitForSingleObject (child_proc_info->forker_finished, 1) != WAIT_FAILED) \
	    break; \
	  api_fatal ("sync_with_parent - WFSO failed, fork_finished %p, %E", child_proc_info->forker_finished); \
	  break; \
	default: \
	  break; \
	} \
      debug_printf ("awake"); \
    } \
  0; \
}))
d279 11
a289 1
static volatile void grow_stack_slack();
d291 17
a307 4
static void *
stack_dummy (int here)
{
  return &here;
d310 2
a311 2
extern "C" int
fork ()
d313 2
a314 1
  int res;
a315 4
  HANDLE hParent;
  HANDLE subproc_ready, forker_finished;
  void *stack_here;
  int x;
d319 1
a319 1
  MALLOC_CHECK;
d321 9
a329 6
  /* FIXME: something is broken when copying the stack from the parent
     to the child; we try various tricks here to make sure that the
     stack is good enough to prevent page faults, but the true cause
     is still unknown.  DJ */
  volatile char dummy[4096];
  dummy[0] = dummy[4095] = 0;	// Just to leave some slack in the stack
d331 17
a347 5
  grow_stack_slack ();

  debug_printf ("entering");
  /* Calculate how much of stack to copy to child */
  stack_here = stack_dummy (0);
d349 3
a351 1
  if (ISSTATE(myself, PID_SPLIT_HEAP))
d353 1
a353 4
      system_printf ("The heap has been split, CYGWIN can't fork this process.");
      system_printf ("Increase the heap_chunk_size in the registry and try again.");
      set_errno (ENOMEM);
      syscall_printf ("-1 = fork (), split heap");
d361 2
a362 2
  dll *first_dll = dlls.start.next;
  int load_dlls = dlls.reload_on_fork && dlls.loaded_dlls;
d364 2
a365 2
  static child_info_fork ch;
  x = setjmp (ch.jmp);
d367 9
a375 1
  if (x == 0)
d377 5
a381 2
      /* This will help some of the confusion.  */
      fflush (stdout);
d383 2
a384 13
      subproc_ready = CreateEvent (&sec_all, FALSE, FALSE, NULL);
      forker_finished = CreateEvent (&sec_all, FALSE, FALSE, NULL);
      ProtectHandle (subproc_ready);
      ProtectHandle (forker_finished);

      /* If we didn't obtain all the resources we need to fork, allow the program
	 to continue, but record the fact that fork won't work.  */
      if (forker_finished == NULL || subproc_ready == NULL)
	{
	  system_printf ("unable to allocate fork() resources.");
	  system_printf ("fork() disabled.");
	  return -1;
	}
d386 1
a386 13
      subproc_init ();

      debug_printf ("about to call setjmp");
      /* Parent.  */
#ifdef DEBUGGING
      /* The ProtectHandle call allocates memory so we need to make sure
	 that enough is set aside here so that the sbrk pointer does not
	 move when ProtectHandle is called after the child is started.
	 Otherwise the sbrk pointers in the parent will not agree with
	 the child and when user_data is (regrettably) copied over,
	 the user_data->ptr field will not be accurate. */
      free (malloc (4096));
#endif
d388 32
a419 1
      init_child_info (PROC_FORK1, &ch, 1, subproc_ready);
d421 1
a421 37
      ch.forker_finished = forker_finished;
      ch.heaptop = user_data->heaptop;
      ch.heapbase = user_data->heapbase;
      ch.heapptr = user_data->heapptr;

      stack_base (ch);

      STARTUPINFO si = {0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL};

      si.cb = sizeof (STARTUPINFO);
      si.lpReserved2 = (LPBYTE)&ch;
      si.cbReserved2 = sizeof(ch);

      int c_flags = GetPriorityClass (hMainProc) /*|
		    CREATE_NEW_PROCESS_GROUP*/;

      /* If we don't have a console, then don't create a console for the
	 child either.  */
      HANDLE console_handle = CreateFileA ("CONOUT$", GENERIC_WRITE,
					   FILE_SHARE_WRITE, &sec_none_nih,
					   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
					   NULL);

      syscall_printf ("CreateProcessA (%s, %s,0,0,1,%x, 0,0,%p,%p)",
		      myself->progname, myself->progname, c_flags, &si, &pi);
      if (console_handle != INVALID_HANDLE_VALUE && console_handle != 0)
	CloseHandle (console_handle);
      else
	c_flags |= DETACHED_PROCESS;

      hParent = NULL;
      if (!DuplicateHandle (hMainProc, hMainProc, hMainProc, &hParent, 0, 1,
			    DUPLICATE_SAME_ACCESS))
	{
	  system_printf ("couldn't create handle to myself for child, %E");
	  goto cleanup;
	}
d423 7
a429 2
      /* Remove impersonation */
      uid_t uid = geteuid();
d431 3
a433 1
	seteuid (myself->orig_uid);
d435 1
a435 11
      char sa_buf[1024];
      rc = CreateProcessA (myself->progname, /* image to run */
			   myself->progname, /* what we send in arg0 */
			   allow_ntsec ? sec_user (sa_buf) : &sec_none_nih,
			   allow_ntsec ? sec_user (sa_buf) : &sec_none_nih,
			   TRUE,	  /* inherit handles from parent */
			   c_flags,
			   NULL,	  /* environment filled in later */
			   0,		  /* use current drive/directory */
			   &si,
			   &pi);
d437 20
a456 1
      CloseHandle (hParent);
d458 41
a498 12
      if (!rc)
	{
	  __seterrno ();
	  syscall_printf ("-1 = fork(), CreateProcessA failed");
	  ForceCloseHandle(subproc_ready);
	  ForceCloseHandle(forker_finished);
	  subproc_ready = forker_finished = NULL;
	  /* Restore impersonation */
	  if (myself->impersonated && myself->token != INVALID_HANDLE_VALUE)
	    seteuid (uid);
	  return -1;
	}
a499 1
      pinfo forked (cygwin_pid (pi.dwProcessId), 1);
d501 8
a508 3
      /* Initialize things that are done later in dll_crt0_1 that aren't done
	 for the forkee.  */
      strcpy(forked->progname, myself->progname);
d510 3
a512 3
      /* Restore impersonation */
      if (myself->impersonated && myself->token != INVALID_HANDLE_VALUE)
	seteuid (uid);
d514 9
a522 12
      ProtectHandle (pi.hThread);
      /* Protect the handle but name it similarly to the way it will
	 be called in subproc handling. */
      ProtectHandle1 (pi.hProcess, childhProc);
      if (os_being_run != winNT)
	{
	  if (last_fork_proc)
	    CloseHandle (last_fork_proc);
	  if (!DuplicateHandle (hMainProc, pi.hProcess, hMainProc, &last_fork_proc,
				0, FALSE, DUPLICATE_SAME_ACCESS))
	    system_printf ("couldn't create last_fork_proc, %E");
	}
d524 1
a524 34
      /* Fill in fields in the child's process table entry.  */
      forked->ppid = myself->pid;
      forked->hProcess = pi.hProcess;
      forked->dwProcessId = pi.dwProcessId;
      forked->uid = myself->uid;
      forked->gid = myself->gid;
      forked->pgid = myself->pgid;
      forked->sid = myself->sid;
      forked->ctty = myself->ctty;
      forked->umask = myself->umask;
      forked->copysigs(myself);
      forked->process_state |= PID_INITIALIZING |
			      (myself->process_state & PID_USETTY);
      memcpy (forked->username, myself->username, MAX_USER_NAME);
      if (myself->use_psid)
	{
	  memcpy (forked->psid, myself->psid, MAX_SID_LEN);
	  forked->use_psid = 1;
	}
      memcpy (forked->logsrv, myself->logsrv, MAX_HOST_NAME);
      memcpy (forked->domain, myself->domain, MAX_COMPUTERNAME_LENGTH+1);
      forked->token = myself->token;
      forked->impersonated = myself->impersonated;
      forked->orig_uid = myself->orig_uid;
      forked->orig_gid = myself->orig_gid;
      forked->real_uid = myself->real_uid;
      forked->real_gid = myself->real_gid;
      strcpy (forked->root, myself->root);
      forked->rootlen = myself->rootlen;
      set_child_mmap_ptr (forked);

      /* Wait for subproc to initialize itself. */
      if (!sync_with_child(pi, subproc_ready, TRUE, "waiting for longjmp"))
	goto cleanup;
d526 10
d537 2
a538 22
      debug_printf ("child is alive (but stopped)");

      /* Initialize, in order: data, bss, heap, stack, dll data, dll bss
	 Note: variables marked as NO_COPY will not be copied
	 since they are placed in a protected segment. */


      MALLOC_CHECK;
      rc = fork_copy (pi, "user/cygwin data",
		      user_data->data_start, user_data->data_end,
		      user_data->bss_start, user_data->bss_end,
		      ch.heapbase, ch.heapptr,
		      stack_here, ch.stackbottom,
		      dll_data_start, dll_data_end,
		      dll_bss_start, dll_bss_end, NULL);

      MALLOC_CHECK;
      if (!rc)
	goto cleanup;

      /* Now fill data/bss of any DLLs that were linked into the program. */
      for (dll *d = dlls.istart (DLL_LINK); d; d = dlls.inext ())
d540 2
a541 2
	  debug_printf ("copying data/bss of a linked dll");
	  if (!fork_copy (pi, "linked dll data/bss", d->p.data_start, d->p.data_end,
d546 2
a547 121

      forked.remember ();

      /* Start thread, and wait for it to reload dlls.  */
      if (!resume_child (pi, forker_finished) ||
	  !sync_with_child (pi, subproc_ready, load_dlls, "child loading dlls"))
	goto cleanup;

      /* If DLLs were loaded in the parent, then the child has reloaded all
	 of them and is now waiting to have all of the individual data and
	 bss sections filled in. */
      if (load_dlls)
	{
	  /* CHILD IS STOPPED */
	  /* write memory of reloaded dlls */
	  for (dll *d = dlls.istart (DLL_LOAD); d; d = dlls.inext ())
	    {
	      debug_printf ("copying data/bss for a loaded dll");
	      if (!fork_copy (pi, "loaded dll data/bss", d->p.data_start, d->p.data_end,
							 d->p.bss_start, d->p.bss_end,
							 NULL))
		goto cleanup;
	    }
	  /* Start the child up again. */
	  (void) resume_child (pi, forker_finished);
	}

      ForceCloseHandle (subproc_ready);
      ForceCloseHandle (pi.hThread);
      ForceCloseHandle (forker_finished);
      forker_finished = NULL;
      pi.hThread = NULL;

      res = forked->pid;
    }
  else
    {
      /**** Child *****/

      /* We arrive here via a longjmp from "crt0".  */
      (void) stack_dummy (0);		// Just to make sure
      debug_printf ("child is running %d", x);

      debug_printf ("pid %d, ppid %d", x, myself->ppid);

      /* Restore the inheritance state as in parent
	 Don't call setuid here! The flags are already set. */
      if (myself->impersonated)
	{
	  debug_printf ("Impersonation of child, token: %d", myself->token);
	  if (myself->token == INVALID_HANDLE_VALUE)
	    RevertToSelf (); // probably not needed
	  else if (!ImpersonateLoggedOnUser (myself->token))
	    system_printf ("Impersonate for forked child failed: %E");
	}

      sync_with_parent ("after longjmp.", TRUE);
      ProtectHandle (hParent);

#ifdef DEBUGGING
      char c;
      if (GetEnvironmentVariable ("FORKDEBUG", &c, 1))
	try_to_debug ();
      char buf[80];
      /* This is useful for debugging fork problems.  Use gdb to attach to
	 the pid reported here. */
      if (GetEnvironmentVariable ("CYGWIN_FORK_SLEEP", buf, sizeof (buf)))
	{
	  small_printf ("Sleeping %d after fork, pid %u\n", atoi (buf), GetCurrentProcessId ());
	  Sleep (atoi(buf));
	}
#endif

      /* If we've played with the stack, stacksize != 0.  That means that
	 fork() was invoked from other than the main thread.  Make sure that
	 when the "main" thread exits it calls do_exit, like a normal process.
	 Exit with a status code of 0. */
      if (child_proc_info->stacksize)
	{
	  ((DWORD *)child_proc_info->stackbottom)[-17] = (DWORD)do_exit;
	  ((DWORD *)child_proc_info->stackbottom)[-15] = (DWORD)0;
	}

      MALLOC_CHECK;

      cygheap_fixup_in_child (hParent, 0);
      fdtab.fixup_after_fork (hParent);
      signal_fixup_after_fork ();
      exec_fixup_after_fork ();

      MALLOC_CHECK;

      /* If we haven't dynamically loaded any dlls, just signal
	 the parent.  Otherwise, load all the dlls, tell the parent
	  that we're done, and wait for the parent to fill in the.
	  loaded dlls' data/bss. */
      if (!load_dlls)
	sync_with_parent ("performed fork fixup.", FALSE);
      else
	{
	  dlls.load_after_fork (hParent, first_dll);
	  sync_with_parent ("loaded dlls", TRUE);
	}

      ForceCloseHandle (hParent);
      (void) ForceCloseHandle (child_proc_info->subproc_ready);
      (void) ForceCloseHandle (child_proc_info->forker_finished);

      if (recreate_mmaps_after_fork (myself->mmap_ptr))
	api_fatal ("recreate_mmaps_after_fork_failed");

      res = 0;
      /* Set thread local stuff to zero.  Under Windows 95/98 this is sometimes
	 non-zero, for some reason.
	 FIXME:  There is a memory leak here after a fork. */
      for (per_thread **t = threadstuff; *t; t++)
	if ((*t)->clear_on_fork ())
	  (*t)->set ();

      /* Initialize signal/process handling */
      sigproc_init ();
d550 5
d556 1
a556 3
  MALLOC_CHECK;
  syscall_printf ("%d = fork()", res);
  return res;
a568 1
  forker_finished = subproc_ready = NULL;
d572 2
a573 2
static volatile void
grow_stack_slack ()
d575 36
a610 2
  volatile char dummy[16384];
  dummy[0] = dummy[16383] = 0;	// Just to make some slack in the stack
@


1.24
log
@* cygheap.cc (init_cheap): Set aside space for heap walk pointer.
(_csbrk): Make logic for detecting when to alloc cognizant of initialization
condition.
(_cmalloc): Use a structure to hold bucket size and heap chain pointer.  Store
pointer to next freed block in bucket size location so that it will be easy to
see if a block is allocated.
(_cfree): Store pointer to next freed block in bucket size location.
(_crealloc): Use macro to retrieve bucket size.
(cygheap_init): Eliminate.
(cygheap_fixup_in_child): Add second argument to determine if we were execed or
not.  In execed case, walk the heap, cleaning up any orphaned blocks.
* cygheap.h: Add a "MAX" value to cygheap_types.  Remove cygheap_init
declaration.  Accomodate new argument to cygheap_fixup_in child.
* fork.cc (fork): Accomodate extra argument to cygheap_fixup_in_child.
* dcrt0.cc (dll_crt0_1): Ditto.  Remove call to cygheap_init.
@
text
@d133 2
a134 1
  debug_printf ("waiting for child.  reason: %s", s);
@


1.23
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d574 1
a574 1
      cygheap_fixup_in_child (hParent);
@


1.22
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@a17 1
#include "dll_init.h"
d26 1
d28 3
@


1.21
log
@* sigproc.cc (proc_info): Rename proc_exists which takes a pid to "pid_exists".
* shared.h: Split out "child_info" stuff into a new header file and use where
necessary.  Declare pid_exists.
* child_info.h: New file.
@
text
@d25 1
d41 8
a48 8
  {
    if (s == PER_THREAD_FORK_CLEAR)
      {
        tls = TlsAlloc ();
	s = NULL;
      }
    TlsSetValue (get_tls (), s);
  }
d360 1
a360 1
			   DUPLICATE_SAME_ACCESS))
d369 1
a369 1
        seteuid (myself->orig_uid);
d374 2
a375 2
                           allow_ntsec ? sec_user (sa_buf) : &sec_none_nih,
                           allow_ntsec ? sec_user (sa_buf) : &sec_none_nih,
d392 3
a394 3
          /* Restore impersonation */
          if (myself->impersonated && myself->token != INVALID_HANDLE_VALUE)
            seteuid (uid);
d406 1
a406 1
        seteuid (uid);
d417 1
a417 1
			        0, FALSE, DUPLICATE_SAME_ACCESS))
d532 1
a532 1
         Don't call setuid here! The flags are already set. */
d534 7
a540 7
        {
          debug_printf ("Impersonation of child, token: %d", myself->token);
          if (myself->token == INVALID_HANDLE_VALUE)
            RevertToSelf (); // probably not needed
          else if (!ImpersonateLoggedOnUser (myself->token))
            system_printf ("Impersonate for forked child failed: %E");
        }
d571 1
@


1.20
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d25 1
@


1.19
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d19 1
d21 3
d25 1
a25 1
#include "cygerrno.h"
@


1.18
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d21 1
@


1.17
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d19 2
@


1.16
log
@* select.cc (allocfd_set): Zero allocated fd_set.
(cygwin_select): Move fd_set copying logic from ::wait to here.  Use common
return through sell.poll.
(select_stuff::wait): Just return success or failure and let caller fill in
fd_set.
* pinfo.h (pinfo): Eliminate self-referential pointer to sidbuf since pinfo
structure exists at random locations now.
* fork.cc (fork): Use 'use_psid' element to control when the psid is relevant.
* shared.cc (sec_user): Ditto.
* spawn.cc (spawn_guts): Ditto.
* uinfo.cc (internal_getlogin): Ditto.
* syscall.cc (seteuid): Ditto.  Set use_psid element.
@
text
@d562 1
a562 1
      dtable.fixup_after_fork (hParent);
d657 1
a657 1
      return dtable.vfork_child_dup () ? 0 : -1;
d660 1
a660 1
  dtable.vfork_parent_restore ();
@


1.15
log
@* fork.cc (vfork): Store complete stack frame in vfork_save structure for later
recovery.
* spawn.cc (spawn_guts): Reorganize slightly to consolidate handling when there
is a CreateProcess error.
(_spawnve): Only longjmp back to vfork handling when a process has been
successfuly started.
* winsup.h (vfork_save): Extend to include frame info.  Remove obsolete cpplus
conditionals.
@
text
@d426 5
a430 3
      memcpy (forked->sidbuf, myself->sidbuf, MAX_SID_LEN);
      if (myself->psid)
        forked->psid = forked->sidbuf;
@


1.14
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d642 1
d650 1
d652 3
a654 2
      __asm__ volatile ("movl (%%ebp),%0": "=r" (vf->caller_ebp):);
      __asm__ volatile ("movl 4(%%ebp),%0": "=r" (vf->retaddr):);
d668 5
a672 2
  vf->vfork_ebp[0] = vf->caller_ebp;
  vf->vfork_ebp[1] = vf->retaddr;
@


1.13
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d11 1
a17 1
#include "winsup.h"
@


1.12
log
@        * shared.h (class pinfo): New members `root' and `rootlen'.
        * syscalls.cc (chroot): Set new root for process.
        * path.cc (getcwd_inner): Add parameter to force use of
        new root from chroot() call.
        (ischrootpath): New macro.
        (normalize_posix_path): Care for changed root dir.
        (normalize_win32_path): Ditto.
        (getcwd_inner): Ditto.
        (chdir): Eliminate trailing path component consisting
        entirely of dots.
        * fork.cc (fork): Copy pinfo members regarding chroot().
        * spawn.cc (_spawnve): Ditto.
        * dir.cc (opendir): Don't use computed win32 path if
        chroot() took place.
@
text
@a243 1
  pinfo *child;
d248 1
a273 9
  /* Don't start the fork until we have the lock.  */
  child = cygwin_shared->p.allocate_pid ();
  if (!child)
    {
      set_errno (EAGAIN);
      syscall_printf ("-1 = fork (), process table full");
      return -1;
    }

a285 1

a288 2
      debug_printf ("parent pid %d, child pid %d", myself->pid, child->pid);

d317 1
a317 1
      init_child_info (PROC_FORK1, &ch, child->pid, subproc_ready);
a325 4
      /* Initialize things that are done later in dll_crt0_1 that aren't done
	 for the forkee.  */
      strcpy(child->progname, myself->progname);

a379 1
	  child->process_state = PID_NOT_IN_USE;
d389 6
d403 8
d413 11
a423 11
      child->ppid = myself->pid;
      child->hProcess = pi.hProcess;
      child->dwProcessId = pi.dwProcessId;
      child->uid = myself->uid;
      child->gid = myself->gid;
      child->pgid = myself->pgid;
      child->sid = myself->sid;
      child->ctty = myself->ctty;
      child->umask = myself->umask;
      child->copysigs(myself);
      child->process_state |= PID_INITIALIZING |
d425 2
a426 2
      memcpy (child->username, myself->username, MAX_USER_NAME);
      memcpy (child->sidbuf, myself->sidbuf, MAX_SID_LEN);
d428 12
a439 12
        child->psid = child->sidbuf;
      memcpy (child->logsrv, myself->logsrv, MAX_HOST_NAME);
      memcpy (child->domain, myself->domain, MAX_COMPUTERNAME_LENGTH+1);
      child->token = myself->token;
      child->impersonated = myself->impersonated;
      child->orig_uid = myself->orig_uid;
      child->orig_gid = myself->orig_gid;
      child->real_uid = myself->real_uid;
      child->real_gid = myself->real_gid;
      memcpy (child->root, myself->root, MAX_PATH+1);
      child->rootlen = myself->rootlen;
      set_child_mmap_ptr (child);
d476 1
a476 1
      proc_register (child);
d508 1
a508 1
      res = child->pid;
d518 1
a518 2
      debug_printf ("self %p, pid %d, ppid %d",
		    myself, x, myself ? myself->ppid : -1);
d562 1
a604 1
  child->process_state = PID_NOT_IN_USE;
d613 1
a613 1
  forker_finished = subproc_ready = child->hProcess = NULL;
@


1.11
log
@* hinfo.cc (hinfo::linearize_fd_array): Make max_used_fd an int so that we can
detect when there are no fds to pass.
* dcrt0.cc (host_dependent_constants::init): Revert Sat Mar 18 01:32:04 2000
change.
(dll_crt0_1): Set "cygwin_finished_initializing" flag.
(dll_crt0): Don't perform memcpy if uptr is already set to internal structure.
(_dll_crt0): Remember location of programs envptr.
* dll_init.h (per_module, dll, dll_list): Revamp.
* dll_init.cc: Revamp.  Use new classes.
* fork.cc (fork): Use new revamped dll, dll_list, and per_module stuff.
* environ.cc: Use __cygwin_environ throughout rather than the
user_data->envptr.
* exec.cc: Ditto.
* spawn.cc: Ditto.
* winsup.h: Declare update_envptrs, cygwin_finished_initializing.
* lib/_cygwin_crt0_common.cc (_cygwin_crt0_common): Revert previous change.
* lib/cygwin_attach_dll.cc (cygwin_attach_dll): Always pass in own per_process
structure or we end up overwriting information from the main program.
@
text
@d440 2
@


1.10
log
@Revert errnoneous commit.
@
text
@d283 7
d467 9
a475 10
      /* Now fill data/bss of linked dll */
      DO_LINKED_DLL (p)
      {
	debug_printf ("copying data/bss of a linked dll");
	if (!fork_copy (pi, "linked dll data/bss", p->data_start, p->data_end,
						   p->bss_start, p->bss_end,
						   NULL))
	  goto cleanup;
      }
      DLL_DONE;
a477 2
      int load_dll = DllList::the().forkeeMustReloadDlls() &&
		     DllList::the().numberOfOpenedDlls();
d481 1
a481 1
	  !sync_with_child (pi, subproc_ready, load_dll, "child loading dlls"))
d484 4
a487 6
      /* child reload dlls & then write their data and bss */
      if (load_dll)
      {
	/* CHILD IS STOPPED */
	/* write memory of reloaded dlls */
	DO_LOADED_DLL (p)
d489 12
a500 5
	  debug_printf ("copying data/bss for a loaded dll");
	  if (!fork_copy (pi, "loaded dll data/bss", p->data_start, p->data_end,
						     p->bss_start, p->bss_end,
						     NULL))
	    goto cleanup;
a501 4
	DLL_DONE;
	/* Start the child up again. */
	(void) resume_child (pi, forker_finished);
      }
d540 8
a563 1
      ForceCloseHandle (hParent);
d567 5
a571 3
      /* reload dlls if necessary */
      if (!DllList::the().forkeeMustReloadDlls() ||
	  !DllList::the().numberOfOpenedDlls())
d575 1
a575 1
	  DllList::the().forkeeLoadDlls();
d579 1
@


1.9
log
@* exceptions.cc (stack_info::walk): Use method to find offset.
(handle_exceptions): Be more assertive in finding ebp for use under W2K.
Create a dummy stack frame for cases where program is dying and a stack dump is
being output.
(sig_handle): Fill out a GetThreadContext for use with a user-generated "core
dump".
@
text
@a447 2
      rc = fork_copy (pi, "dll data", dll_data_start, dll_data_end,
		      dll_bss_start, dll_bss_end, NULL);
d451 1
d453 2
a454 1
		      NULL);
d529 1
a534 6
      char buf[80];
      if (GetEnvironmentVariable ("CYGWIN_FORK_SLEEP", buf, sizeof (buf)))
	{
	  small_printf ("Sleeping %d after fork, pid %u\n", atoi (buf), GetCurrentProcessId ());
	  Sleep (atoi(buf));
	}
a535 3

      heap_init ();
      ProtectHandle (hParent);
@


1.8
log
@        * winsup.h: Define MAX_SID_LEN and new MAX_HOST_NAME.
        * fork.cc (fork): Use above defines instead of numerical constants.
        * shared.cc (sec_user): Ditto.
        * shared.h (class pinfo): Ditto.
        * syscall.cc (seteuid): Ditto.
        * spawn.cc (_spawnve): Ditto. Eliminate conditional.
        (spawn_guts): Set child->uid = USHRT_MAX when user context will be
        changed in child process.
        * uinfo.cc (uinfo_init): Check for myself->uid instead of myself->psid
        to avoid reloading of /etc/passwd on process startup if ntsec is off.
        Use above defines instead of numerical constants.
        * security.cc: Move define for MAX_SID_LEN to winsup.h.
@
text
@d448 2
a452 1
		      ch.heapbase, ch.heapptr,
d454 1
a454 2
		      dll_data_start, dll_data_end,
		      dll_bss_start, dll_bss_end, NULL);
a528 1
      ProtectHandle (hParent);
d534 6
d541 3
@


1.7
log
@        * fork.cc (fork): Fix error in copying SID pointer.
        * spawn.cc (_spawnve): Ditto.
        * passwd.cc: Remove static from `passwd_in_memory_p'.
        (read_etc_passwd): Remove static.
        * uinfo.cc: Move global declaration of `read_etc_group' and
        `group_in_memory_p' into `uinfo_init'.
        (internal_getlogin): Try to get SID from current process first.
        (uinfo_init): Don't set uid and gid if `myself' has a valid SID.
        Only load /etc/passwd and /etc/group in that case.
@
text
@d422 1
a422 1
      memcpy (child->sidbuf, myself->sidbuf, 40);
d425 1
a425 1
      memcpy (child->logsrv, myself->logsrv, 256);
@


1.6
log
@        * cygwin.din: Define symbols for `cygwin_logon_user' and
        `cygwin_set_impersonation_token'.
        * dcrt0.cc (dll_crt0_1): Eliminate superfluous conditional
        statements.
        Add load statements for `ImpersonateLoggedOnUser', `LogonUserA'
        and `RevertToSelf'.
        * fork.cc (fork): Care for correct impersonation of parent
        and child process.
        * security.cc (cygwin_set_impersonation_token): New function.
        (cygwin_logon_user): Ditto.
        shared.h (class pinfo): New members `orig_uid', `orig_gid',
        `real_uid' nad `real_gid'.
        spawn.cc (spawn_guts): Care for impersonation when starting
        child process in a different user context.
        * syscalls.cc (setgid): Call `setegid' now. Set real_gid.
        (setuid): Call `seteuid' now. Set real_uid.
        (seteuid): Functionality moved from setuid to here. Care for
        correct impersonation.
        (setegid): Functionality moved from setgid to here.
        * uinfo.cc (uinfo_init): Initialization of additional pinfo
        members.
        (getuid): Return real uid.
        (getgid): Return real gid.
        (geteuid): Return effective uid.
        (getegid): Return effective gid.
        include/sys/cygwin.h: Add prototypes for `cygwin_logon_user' and
        `cygwin_set_impersonation_token'.
        include/cygwin/version.h: Bumb API minor version to 22.
@
text
@a421 1
      child->psid = myself->psid;
d423 2
@


1.5
log
@* exceptions.cc (sigsave): Copy on fork so that we can restore correct behavior
in forked process.
(interruptible): Flag as interruptible when running in main process module.
(interrupt_setup): Save return address and address of return address.
(signal_fixup_after_fork): New function.  Uses above two values to restore
proper behavior to forked process.
(interrupt_on_return): Pass return address address to interupt_setup.
(interrupt_now): Pass NULL for return address address to interrupt_setup.
* fork.cc (fork): Call signal_fixup_after_fork.
* shared.h: Lint cleanups.
* winsup.h: Ditto.
@
text
@d366 6
d374 2
a375 2
			   &sec_none_nih,  /* process security attrs */
			   &sec_none_nih,  /* thread security attrs */
d393 3
d399 4
d426 6
d515 11
@


1.4
log
@* exceptions.cc (interruptible): Change method for determining if something is
interruptible.
(call_handler): Avoid suspending a thread if it owns a mutex.  Only set
signal_arrived if the thread was actually interrupted.
(events_init): Initialize module information needed by interruptible().
(sigdelayed): Don't call sig_dispatch_pending since it could screw up
* init.cc (dll_entry): Record module handle of main for use by interruptible().
(proc_subproc): Reorganize handling of terminated child so that the bulk of the
processing comes from the signal thread.
(wait_sig): Force processing of waiting threads if SIGCHLD is not processed.
* sync.cc (muto::release): Set tid == 0 after lock is released or signal
processor will be confused.
@
text
@d20 1
a20 1
DWORD chunksize = 0;
d519 1
@


1.3
log
@Respond to more g++ warnings relating to initializing structures.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999 Cygnus Solutions.
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d248 1
a248 1
  PROCESS_INFORMATION pi = {0};
d335 1
a335 1
      STARTUPINFO si = {0};
@


1.1
log
@Initial revision
@
text
@d172 1
a172 2
resume_child (PROCESS_INFORMATION &pi, HANDLE subproc_ready,
	      HANDLE forker_finished)
d456 1
a456 1
      if (!resume_child (pi, subproc_ready, forker_finished) ||
d475 1
a475 1
	(void) resume_child (pi, subproc_ready, forker_finished);
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
