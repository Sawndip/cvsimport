head	1.82;
access;
symbols
	cygwin-1_7_35-release:1.82
	cygwin-1_7_34-release:1.81
	cygwin-1_7_33-release:1.80
	cygwin-1_7_32-release:1.80
	cygwin-1_7_31-release:1.80
	cygwin-1_7_30-release:1.80
	cygwin-1_7_29-release:1.80
	cygwin-1_7_29-release-branchpoint:1.80.0.2
	cygwin-pre-user-db:1.80
	cygwin-1_7_28-release:1.80
	cygwin-1_7_27-release:1.80
	cygwin-1_7_26-release:1.80
	cygwin-1_7_25-release:1.79
	cygwin-1_7_24-release:1.79
	cygwin-1_7_23-release:1.79
	cygwin-1_7_22-release:1.79
	cygwin-1_7_21-release:1.79
	cygwin-1_7_20-release:1.78
	cygwin-1_7_19-release:1.78
	cygwin-64bit-postmerge:1.78
	cygwin-64bit-premerge-branch:1.77.0.2
	cygwin-64bit-premerge:1.77
	cygwin-1_7_18-release:1.77
	post-ptmalloc3:1.75.2.5
	pre-ptmalloc3:1.75.2.5
	cygwin-1_7_17-release:1.75
	cygwin-64bit-branch:1.75.0.2
	cygwin-1_7_16-release:1.75
	cygwin-1_7_15-release:1.73
	cygwin-1_7_14_2-release:1.73
	cygwin-1_7_14-release:1.73
	cygwin-1_7_12-release:1.73
	cygwin-1_7_11-release:1.73
	cygwin-1_7_10-release:1.73
	signal-rewrite:1.67.0.2
	pre-notty:1.66
	cygwin-1_7_9-release:1.63
	cv-post-1_7_9:1.63.0.2
	cygwin-1_7_8-release:1.63
	cygwin-1_7_7-release:1.61
	cygwin-1_7_5-release:1.59
	cygwin-1_7_4-release:1.59
	cygwin-1_7_3-release:1.59
	cygwin-1_7_2-release:1.59
	fifo_doover3:1.58.0.2
	cygwin-1_7_1-release:1.57
	prefifo:1.56
	cv-branch-2:1.56.0.2
	pre-ripout-set_console_state_for_spawn:1.45
	EOL_registry_mounts:1.44
	preoverlapped:1.41
	drop_9x_support_start:1.39
	cr-0x5f1:1.35.0.4
	cv-branch:1.35.0.2
	pre-ptymaster-archetype:1.35
	cr-0x3b58:1.34.0.4
	cr-0x5ef:1.34.0.2
	after-mmap-privanon-noreserve:1.34
	after-mmap-revamp:1.34
	before-mmap-revamp:1.34
	cgf-more-exit-sync:1.34
	post_wait_sig_exit:1.34
	pre_wait_sig_exit:1.33
	reparent-point:1.25
	noreparent:1.25.0.2
	cr-0x5e6:1.24.0.2
	cr-0x9e:1.23.0.6
	cr-0x9d:1.23.0.4
	cgf-deleteme:1.23.0.2
	pre-sigrewrite:1.23
	corinna-01:1.22
	cr-0x9c:1.21.0.4
	cr-0x9b:1.21.0.2
	cr-0x99:1.20
	Z-emcb-cygwin_daemon:1.20.0.2
	w32api-2_2:1.17
	mingw-runtime-2_4:1.17
	pre-cgf-merge:1.21
	cgf-dev-branch:1.15.0.2
	Z-cygwin_daemon_merge_HEAD:1.12
	cygwin_daemon:1.8.0.2
	Z-cygwin_daemon_merge-new_HEAD:1.12;
locks; strict;
comment	@// @;


1.82
date	2015.02.15.08.59.55;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2014.02.09.19.44.54;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2013.10.31.14.26.42;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2013.06.14.09.09.41;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2012.11.26.13.28.52;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2012.07.06.13.49.52;	author corinna;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2012.07.02.20.00.22;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2012.02.02.13.58.20;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2012.01.22.06.45.08;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2012.01.20.12.53.26;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2011.11.14.01.29.48;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2011.07.30.08.09.44;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2011.05.05.06.45.21;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.19.08.45.36;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.06.09.47.01;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.01.10.30.52;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.05.16.59.56;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2010.05.26.16.58.44;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2009.12.18.17.14.21;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2009.12.01.16.31.04;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.20.18.04.32;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2009.01.20.17.22.11;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2008.12.19.14.31.40;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2008.12.16.09.20.05;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2008.12.15.12.51.46;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2008.12.15.12.33.27;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2008.12.13.21.05.31;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2008.12.08.11.45.18;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2008.12.02.11.44.58;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2008.12.02.11.40.13;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.05.15.10.19;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2007.07.20.14.29.43;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2007.03.06.14.48.24;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.26.12.39.25;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2006.10.22.09.38.47;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2006.10.21.10.58.35;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.19.10.01.03;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.27.21.50.40;	author corinna;	state Exp;
branches
	1.35.4.1;
next	1.34;

1.34
date	2005.09.14.14.27.54;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.24.04.38.39;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.20.06.19.54;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.08.15.33.32;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.06.20.05.00;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.16.21.20.56;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.20.04.25.31;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.31.10.28.53;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.15.02.07.14;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.08.04.04.18;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.05.03.04.28;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.04.03.01.17;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.30.23.15.15;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2003.01.09.08.22.04;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.30.21.05.17;	author cgf;	state Exp;
branches
	1.13.2.1
	1.13.10.1;
next	1.12;

1.12
date	2002.07.26.19.58.00;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.13.20.00.25;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.02.01.36.15;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.01.19.03.26;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2002.05.31.20.30.36;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.22.22.09.57;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.12.01.37.48;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.04.03.24.35;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.03.02.43.45;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.02.04.26.05;	author cgf;	state Exp;
branches;
next	;

1.75.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.75.2.2;

1.75.2.2
date	2012.11.07.09.40.14;	author corinna;	state Exp;
branches;
next	1.75.2.3;

1.75.2.3
date	2012.11.26.13.29.09;	author corinna;	state Exp;
branches;
next	1.75.2.4;

1.75.2.4
date	2012.12.10.11.45.48;	author corinna;	state Exp;
branches;
next	1.75.2.5;

1.75.2.5
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.75.2.6;

1.75.2.6
date	2013.03.14.12.09.51;	author corinna;	state Exp;
branches;
next	;

1.35.4.1
date	2007.11.22.11.10.48;	author corinna;	state Exp;
branches;
next	;

1.15.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.01.31.00.20.11;	author cgf;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2003.02.05.14.25.08;	author cgf;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.15.2.6;

1.15.2.6
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.15.2.7;

1.15.2.7
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.15.2.8;

1.15.2.8
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	;

1.13.2.1
date	2002.11.07.03.47.46;	author cgf;	state Exp;
branches;
next	;

1.13.10.1
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	1.13.10.2;

1.13.10.2
date	2003.01.09.08.22.51;	author cgf;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.13.14.34.05;	author rbcollins;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.07.02.10.58.18;	author scottc;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.07.13.20.39.24;	author scottc;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.07.29.10.54.14;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.82
log
@	* path.h (path_conv): Make path_flags private.  Rename known_suffix to
	suffix and make private.  Rename normalized_path to posix_path and
	make privtae.  Accommodate name changes throughout in path_conv
	methods.
	(path_conv::known_suffix): New method.  Use throughout instead of
	accessing suffix directly.
	(path_conv::get_win32): Constify.
	(path_conv::get_posix): New method to read posix_path.  Use throughout
	instead of accessing normalized_path directly.
	(path_conv::set_posix): Rename from set_normalized_path.  Accommodate
	name change throughout.
	* spawn.cc (find_exec): Return POSIX path, not Win32 path.
@
text
@/* fhandler_registry.cc: fhandler for /proc/registry virtual filesystem

   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
   2013, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* FIXME: Access permissions are ignored at the moment.  */

#include "winsup.h"
#include <stdlib.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "child_info.h"

#define _COMPILING_NEWLIB
#include <dirent.h>

/* If this bit is set in __d_position then we are enumerating values,
 * else sub-keys. keeping track of where we are is horribly messy
 * the bottom 16 bits are the absolute position and the top 15 bits
 * make up the value index if we are enuerating values.
 */
static const __int32_t REG_ENUM_VALUES_MASK = 0x8000000;
static const __int32_t REG_POSITION_MASK = 0xffff;

/* These key paths are used below whenever we return key information.
   The problem is UAC virtualization when running an admin account with
   restricted rights.  In that case the subkey "Classes" in the VirtualStore
   points to the HKEY_CLASSES_ROOT key again.  If "Classes" is handled as a
   normal subdirectory, applications recursing throught the directory
   hirarchy will invariably run into an infinite recursion.  What we do here
   is to handle the "Classes" subkey as a symlink to HKEY_CLASSES_ROOT.  This
   avoids the infinite recursion, unless the application blindly follows
   symlinks pointing to directories, in which case it's their own fault. */
#define VIRT_CLASSES_KEY_PREFIX "/VirtualStore/MACHINE/SOFTWARE"
#define VIRT_CLASSES_KEY_SUFFIX "Classes"
#define VIRT_CLASSES_KEY VIRT_CLASSES_KEY_PREFIX "/" VIRT_CLASSES_KEY_SUFFIX
#define VIRT_CLASSES_LINKTGT "/proc/registry/HKEY_CLASSES_ROOT"

/* List of root keys in /proc/registry.
 * Possibly we should filter out those not relevant to the flavour of Windows
 * Cygwin is running on.
 */
static const char *registry_listing[] =
{
  ".",
  "..",
  "HKEY_CLASSES_ROOT",
  "HKEY_CURRENT_CONFIG",
  "HKEY_CURRENT_USER",
  "HKEY_LOCAL_MACHINE",
  "HKEY_USERS",
  "HKEY_PERFORMANCE_DATA",
  NULL
};

static const HKEY registry_keys[] =
{
  (HKEY) INVALID_HANDLE_VALUE,
  (HKEY) INVALID_HANDLE_VALUE,
  HKEY_CLASSES_ROOT,
  HKEY_CURRENT_CONFIG,
  HKEY_CURRENT_USER,
  HKEY_LOCAL_MACHINE,
  HKEY_USERS,
  HKEY_PERFORMANCE_DATA
};

static const int ROOT_KEY_COUNT = sizeof (registry_keys) / sizeof (HKEY);

/* Make sure to access the correct per-user HKCR and HKCU hives, even if
   the current user is only impersonated in another user's session. */
static HKEY
fetch_hkey (int idx) /* idx *must* be valid */
{
  HKEY key;

  if (registry_keys[idx] == HKEY_CLASSES_ROOT)
    {
      if (RegOpenUserClassesRoot (cygheap->user.issetuid ()
				  ? cygheap->user.imp_token () : hProcToken,
				  0, KEY_READ, &key) == ERROR_SUCCESS)
	return key;
    }
  else if (registry_keys[idx] == HKEY_CURRENT_USER)
    {
      if (RegOpenCurrentUser (KEY_READ, &key) == ERROR_SUCCESS)
	return key;
    }
  else if (registry_keys[idx] == HKEY_CURRENT_CONFIG)
    {
      if (RegOpenKeyExW (HKEY_LOCAL_MACHINE,
		       L"System\\CurrentControlSet\\Hardware Profiles\\Current",
		       0, KEY_READ, &key) == ERROR_SUCCESS)
	return key;
    }
  /* Unfortunately there's no way to generate a valid OS registry key for
     the other root keys.  HKEY_USERS and HKEY_LOCAL_MACHINE are file
     handles internally, HKEY_PERFORMANCE_DATA is just a bad hack and
     no registry key at all. */
  return registry_keys[idx];
}

/* These get added to each subdirectory in /proc/registry.
 * If we wanted to implement writing, we could maybe add a '.writable' entry or
 * suchlike.
 */
static const char *special_dot_files[] =
{
  ".",
  "..",
  NULL
};

static const int SPECIAL_DOT_FILE_COUNT =
  (sizeof (special_dot_files) / sizeof (const char *)) - 1;

/* Value names for HKEY_PERFORMANCE_DATA.
 *
 * CAUTION: Never call RegQueryValueEx (HKEY_PERFORMANCE_DATA, "Add", ...).
 * It WRITES data and may destroy the perfc009.dat file.  Same applies to
 * name prefixes "Ad" and "A".
 */
static const char * const perf_data_files[] =
{
  "@@",
  "Costly",
  "Global"
};

static const int PERF_DATA_FILE_COUNT =
  sizeof (perf_data_files) / sizeof (perf_data_files[0]);

static HKEY open_key (const char *name, REGSAM access, DWORD wow64, bool isValue);

/* Return true if char must be encoded.
 */
static inline bool
must_encode (wchar_t c)
{
  return (iswdirsep (c) || c == L':' || c == L'%');
}

/* Encode special chars in registry key or value name.
 * Returns 0: success, -1: error.
 */
static int
encode_regname (char *dst, const wchar_t *src, bool add_val)
{
  int di = 0;
  if (!src[0])
    dst[di++] = '@@'; // Default value.
  else
    for (int si = 0; src[si]; si++)
      {
	wchar_t c = src[si];
	if (must_encode (c) ||
	    (si == 0 && ((c == L'.'
			  && (!src[1] || (src[1] == L'.' && !src[2])))
			 || (c == L'@@' && !src[1]))))
	  {
	    if (di + 3 >= NAME_MAX + 1)
	      return -1;
	    __small_sprintf (dst + di, "%%%02x", c);
	    di += 3;
	  }
	else
	  di += sys_wcstombs (dst + di, NAME_MAX + 1 - di, &c, 1);
      }

  if (add_val)
    {
      if (di + 4 >= NAME_MAX + 1)
	return -1;
      memcpy (dst + di, "%val", 4);
      di += 4;
    }

  dst[di] = 0;
  return 0;
}

/* Decode special chars in registry key or value name.
 * Returns 0: success, 1: "%val" detected, -1: error.
 */
static int
decode_regname (wchar_t *wdst, const char *src, int len = -1)
{
  if (len < 0)
    len = strlen (src);
  char dst[len + 1];
  int res = 0;

  if (len > 4 && !memcmp (src + len - 4, "%val", 4))
    {
      len -= 4;
      res = 1;
    }

  int di = 0;
  if (len == 1 && src[0] == '@@')
    ; // Default value.
  else
    for (int si = 0; si < len; si++)
      {
	char c = src[si];
	if (c == '%')
	  {
	    if (si + 2 >= len)
	      return -1;
	    char s[] = {src[si+1], src[si+2], '\0'};
	    char *p;
	    c = strtoul (s, &p, 16);
	    if (!(must_encode ((wchar_t) c) ||
		  (si == 0 && ((c == '.' && (len == 3 || (src[3] == '.' && len == 4))) ||
			       (c == '@@' && len == 3)))))
	      return -1;
	    dst[di++] = c;
	    si += 2;
	  }
	else
	  dst[di++] = c;
      }

  dst[di] = 0;
  sys_mbstowcs (wdst, NAME_MAX + 1, dst);
  return res;
}


/* Hash table to limit calls to key_exists ().
 */
class __DIR_hash
{
public:
  __DIR_hash ()
    {
      memset (table, 0, sizeof(table));
    }

  void set (unsigned h)
    {
      table [(h >> 3) & (HASH_SIZE - 1)] |= (1 << (h & 0x3));
    }

  bool is_set (unsigned h) const
    {
      return (table [(h >> 3) & (HASH_SIZE - 1)] & (1 << (h & 0x3))) != 0;
    }

private:
  enum { HASH_SIZE = 1024 };
  unsigned char table[HASH_SIZE];
};

#define d_hash(d)	((__DIR_hash *) (d)->__d_internal)


/* Return true if subkey NAME exists in key PARENT.
 */
static bool
key_exists (HKEY parent, const wchar_t *name, DWORD wow64)
{
  HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
  LONG error = RegOpenKeyExW (parent, name, 0, KEY_READ | wow64, &hKey);
  if (error == ERROR_SUCCESS)
    RegCloseKey (hKey);

  return (error == ERROR_SUCCESS || error == ERROR_ACCESS_DENIED);
}

static size_t
multi_wcstombs (char *dst, size_t len, const wchar_t *src, size_t nwc)
{
  size_t siz, sum = 0;
  const wchar_t *nsrc;

  while (nwc)
    {
      siz = sys_wcstombs (dst, len, src, nwc);
      sum += siz;
      if (dst)
	{
	  dst += siz;
	  len -= siz;
	}
      nsrc = wcschr (src, L'\0') + 1;
      if ((size_t) (nsrc - src) >= nwc)
	break;
      nwc -= nsrc - src;
      src = nsrc;
      if (*src == L'\0')
	{
	  if (dst)
	    *dst++ = '\0';
	  ++sum;
	  break;
	}
    }
  return sum;
}

/* Returns 0 if path doesn't exist, >0 if path is a directory,
 * <0 if path is a file.
 *
 * We open the last key but one and then enum it's sub-keys and values to see if the
 * final component is there. This gets round the problem of not having security access
 * to the final key in the path.
 */
virtual_ftype_t
fhandler_registry::exists ()
{
  virtual_ftype_t file_type = virt_none;
  int index = 0, pathlen;
  DWORD buf_size = NAME_MAX + 1;
  LONG error;
  wchar_t buf[buf_size];
  const char *file;
  HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;

  const char *path = get_name ();
  debug_printf ("exists (%s)", path);
  path += proc_len + prefix_len + 1;
  if (*path)
    path++;
  else
    {
      file_type = virt_rootdir;
      goto out;
    }
  pathlen = strlen (path);
  file = path + pathlen - 1;
  if (isdirsep (*file) && pathlen > 1)
    file--;
  while (!isdirsep (*file))
    file--;
  file++;

  if (file == path)
    {
      for (int i = 0; registry_listing[i]; i++)
	if (path_prefix_p (registry_listing[i], path,
			   strlen (registry_listing[i]), true))
	  {
	    file_type = virt_directory;
	    break;
	  }
    }
  else
    {
      wchar_t dec_file[NAME_MAX + 1];

      int val_only = decode_regname (dec_file, file);
      if (val_only < 0)
	goto out;

      if (!val_only)
	hKey = open_key (path, KEY_READ, wow64, false);
      if (hKey != (HKEY) INVALID_HANDLE_VALUE)
	{
	  if (!strcasecmp (path + strlen (path)
			   - sizeof (VIRT_CLASSES_KEY) + 1,
			   VIRT_CLASSES_KEY))
	    file_type = virt_symlink;
	  else
	    file_type = virt_directory;
	}
      else
	{
	  /* Key does not exist or open failed with EACCES,
	     enumerate subkey and value names of parent key.  */
	  hKey = open_key (path, KEY_READ, wow64, true);
	  if (hKey == (HKEY) INVALID_HANDLE_VALUE)
	    return virt_none;

	  if (hKey == HKEY_PERFORMANCE_DATA)
	    {
	      /* RegEnumValue () returns garbage for this key.
		 RegQueryValueEx () returns a PERF_DATA_BLOCK even
		 if a value does not contain any counter objects.
		 So allow access to the generic names and to
		 (blank separated) lists of counter numbers.
		 Never allow access to "Add", see above comment.  */
	      for (int i = 0; i < PERF_DATA_FILE_COUNT
			      && file_type == virt_none; i++)
		{
		  if (strcasematch (perf_data_files[i], file))
		    file_type = virt_file;
		}
	      if (file_type == virt_none && !file[strspn (file, " 0123456789")])
		file_type = virt_file;
	      goto out;
	    }

	  if (!val_only && dec_file[0])
	    {
	      while (ERROR_SUCCESS ==
		     (error = RegEnumKeyExW (hKey, index++, buf, &buf_size,
					     NULL, NULL, NULL, NULL))
		     || (error == ERROR_MORE_DATA))
		{
		  if (!wcscasecmp (buf, dec_file))
		    {
		      file_type = virt_directory;
		      goto out;
		    }
		    buf_size = NAME_MAX + 1;
		}
	      if (error != ERROR_NO_MORE_ITEMS)
		{
		  seterrno_from_win_error (__FILE__, __LINE__, error);
		  goto out;
		}
	      index = 0;
	      buf_size = NAME_MAX + 1;
	    }

	  while (ERROR_SUCCESS ==
		 (error = RegEnumValueW (hKey, index++, buf, &buf_size,
					 NULL, NULL, NULL, NULL))
		 || (error == ERROR_MORE_DATA))
	    {
	      if (!wcscasecmp (buf, dec_file))
		{
		  file_type = virt_file;
		  goto out;
		}
	      buf_size = NAME_MAX + 1;
	    }
	  if (error != ERROR_NO_MORE_ITEMS)
	    {
	      seterrno_from_win_error (__FILE__, __LINE__, error);
	      goto out;
	    }
	}
    }
out:
  if (hKey != (HKEY) INVALID_HANDLE_VALUE)
    RegCloseKey (hKey);
  return file_type;
}

void
fhandler_registry::set_name (path_conv &in_pc)
{
  if (strncasematch (in_pc.get_posix (), "/proc/registry32", 16))
    {
      wow64 = KEY_WOW64_32KEY;
      prefix_len += 2;
    }
  else if (strncasematch (in_pc.get_posix (), "/proc/registry64", 16))
    {
      wow64 = KEY_WOW64_64KEY;
      prefix_len += 2;
    }
  fhandler_base::set_name (in_pc);
}

fhandler_registry::fhandler_registry ():
fhandler_proc ()
{
  wow64 = 0;
  prefix_len = sizeof ("registry") - 1;
}

int __reg2
fhandler_registry::fstat (struct stat *buf)
{
  fhandler_base::fstat (buf);
  buf->st_mode &= ~_IFMT & NO_W;
  virtual_ftype_t file_type = exists ();
  switch (file_type)
    {
    case virt_none:
      set_errno (ENOENT);
      return -1;
    case virt_symlink:
      buf->st_mode |= S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;
      break;
    case virt_directory:
      buf->st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
      break;
    case virt_rootdir:
      buf->st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
      buf->st_nlink = ROOT_KEY_COUNT;
      break;
    default:
    case virt_file:
      buf->st_mode |= S_IFREG;
      buf->st_mode &= NO_X;
      break;
    }
  if (file_type != virt_none && file_type != virt_rootdir)
    {
      HKEY hKey;
      const char *path = get_name () + proc_len + prefix_len + 2;
      hKey =
	open_key (path, STANDARD_RIGHTS_READ | KEY_QUERY_VALUE, wow64,
		  (file_type < virt_none) ? true : false);

      if (hKey == HKEY_PERFORMANCE_DATA)
	/* RegQueryInfoKey () always returns write time 0,
	   RegQueryValueEx () does not return required buffer size.  */
	;
      else if (hKey != (HKEY) INVALID_HANDLE_VALUE)
	{
	  FILETIME ftLastWriteTime;
	  DWORD subkey_count;
	  if (ERROR_SUCCESS ==
	      RegQueryInfoKeyW (hKey, NULL, NULL, NULL, &subkey_count, NULL,
				NULL, NULL, NULL, NULL, NULL, &ftLastWriteTime))
	    {
	      to_timestruc_t ((PLARGE_INTEGER) &ftLastWriteTime, &buf->st_mtim);
	      buf->st_ctim = buf->st_birthtim = buf->st_mtim;
	      time_as_timestruc_t (&buf->st_atim);
	      if (file_type > virt_none)
		buf->st_nlink = subkey_count + 2;
	      else
		{
		  int pathlen = strlen (path);
		  const char *value_name = path + pathlen - 1;
		  if (isdirsep (*value_name) && pathlen > 1)
		    value_name--;
		  while (!isdirsep (*value_name))
		    value_name--;
		  value_name++;
		  wchar_t dec_value_name[NAME_MAX + 1];
		  DWORD dwSize = 0;
		  DWORD type;
		  if (decode_regname (dec_value_name, value_name) >= 0
		      && RegQueryValueExW (hKey, dec_value_name, NULL, &type,
					   NULL, &dwSize) == ERROR_SUCCESS
		      && (type == REG_SZ || type == REG_EXPAND_SZ
			  || type == REG_MULTI_SZ || type == REG_LINK))
		    {
		      PBYTE tmpbuf = (PBYTE) malloc (dwSize);
		      if (!tmpbuf
			  || RegQueryValueExW (hKey, dec_value_name,
					       NULL, NULL, tmpbuf, &dwSize)
			     != ERROR_SUCCESS)
			buf->st_size = dwSize / sizeof (wchar_t);
		      else if (type == REG_MULTI_SZ)
			buf->st_size = multi_wcstombs (NULL, 0,
						     (wchar_t *) tmpbuf,
						     dwSize / sizeof (wchar_t));
		      else
			buf->st_size = sys_wcstombs (NULL, 0,
						     (wchar_t *) tmpbuf,
						     dwSize / sizeof (wchar_t));
		      if (tmpbuf)
			free (tmpbuf);
		    }
		  else
		    buf->st_size = dwSize;
		}
	      uid_t uid;
	      gid_t gid;
	      if (get_reg_attribute (hKey, &buf->st_mode, &uid, &gid) == 0)
		{
		  buf->st_uid = uid;
		  buf->st_gid = gid;
		  buf->st_mode &= ~(S_IWUSR | S_IWGRP | S_IWOTH);
		  if (file_type > virt_none)
		    buf->st_mode |= S_IFDIR;
		  else
		    buf->st_mode &= NO_X;
		}
	    }
	  RegCloseKey (hKey);
	}
      else
	{
	  /* Here's the problem:  If we can't open the key, we don't know
	     nothing at all about the key/value.  It's only clear that
	     the current user has no read access.  At this point it's
	     rather unlikely that the user has write or execute access
	     and it's also rather unlikely that the user is the owner.
	     Therefore it's probably most safe to assume unknown ownership
	     and no permissions for nobody. */
	  buf->st_uid = ILLEGAL_UID;
	  buf->st_gid = ILLEGAL_GID;
	  buf->st_mode &= ~0777;
	}
    }
  return 0;
}

DIR *
fhandler_registry::opendir (int fd)
{
  /* Skip fhandler_proc::opendir, which allocates dir->_d_handle for its
     own devilish purposes... */
  return fhandler_virtual::opendir (fd);
}

int
fhandler_registry::readdir (DIR *dir, dirent *de)
{
  DWORD buf_size = NAME_MAX + 1;
  wchar_t buf[buf_size];
  const char *path = dir->__d_dirname + proc_len + 1 + prefix_len;
  LONG error;
  int res = ENMFILE;

  dir->__flags |= dirent_saw_dot | dirent_saw_dot_dot;
  if (*path == 0)
    {
      if (dir->__d_position >= ROOT_KEY_COUNT)
	goto out;
      strcpy (de->d_name, registry_listing[dir->__d_position++]);
      res = 0;
      goto out;
    }
  if (dir->__handle == INVALID_HANDLE_VALUE)
    {
      if (dir->__d_position != 0)
	goto out;
      dir->__handle = open_key (path + 1, KEY_READ, wow64, false);
      if (dir->__handle == INVALID_HANDLE_VALUE)
	goto out;
      dir->__d_internal = (uintptr_t) new __DIR_hash ();
    }
  if (dir->__d_position < SPECIAL_DOT_FILE_COUNT)
    {
      strcpy (de->d_name, special_dot_files[dir->__d_position++]);
      res = 0;
      goto out;
    }
  if ((HKEY) dir->__handle == HKEY_PERFORMANCE_DATA)
    {
      /* RegEnumValue () returns garbage for this key,
	 simulate only a minimal listing of the generic names.  */
      if (dir->__d_position >= SPECIAL_DOT_FILE_COUNT + PERF_DATA_FILE_COUNT)
	goto out;
      strcpy (de->d_name, perf_data_files[dir->__d_position - SPECIAL_DOT_FILE_COUNT]);
      dir->__d_position++;
      res = 0;
      goto out;
    }

retry:
  if (dir->__d_position & REG_ENUM_VALUES_MASK)
    /* For the moment, the type of key is ignored here. when write access is added,
     * maybe add an extension for the type of each value?
     */
    error = RegEnumValueW ((HKEY) dir->__handle,
			   (dir->__d_position & ~REG_ENUM_VALUES_MASK) >> 16,
			   buf, &buf_size, NULL, NULL, NULL, NULL);
  else
    error =
      RegEnumKeyExW ((HKEY) dir->__handle, dir->__d_position -
		     SPECIAL_DOT_FILE_COUNT, buf, &buf_size,
		     NULL, NULL, NULL, NULL);
  if (error == ERROR_NO_MORE_ITEMS
      && (dir->__d_position & REG_ENUM_VALUES_MASK) == 0)
    {
      /* If we're finished with sub-keys, start on values under this key.  */
      dir->__d_position |= REG_ENUM_VALUES_MASK;
      buf_size = NAME_MAX + 1;
      goto retry;
    }
  if (error != ERROR_SUCCESS && error != ERROR_MORE_DATA)
    {
      delete d_hash (dir);
      RegCloseKey ((HKEY) dir->__handle);
      dir->__handle = INVALID_HANDLE_VALUE;
      if (error != ERROR_NO_MORE_ITEMS)
	seterrno_from_win_error (__FILE__, __LINE__, error);
      goto out;
    }

  /* We get here if `buf' contains valid data.  */
  dir->__d_position++;
  if (dir->__d_position & REG_ENUM_VALUES_MASK)
    dir->__d_position += 0x10000;

  {
    /* Append "%val" if value name is identical to a previous key name.  */
    unsigned h = hash_path_name (1, buf);
    bool add_val = false;
    if (! (dir->__d_position & REG_ENUM_VALUES_MASK))
      d_hash (dir)->set (h);
    else if (d_hash (dir)->is_set (h)
	     && key_exists ((HKEY) dir->__handle, buf, wow64))
      add_val = true;

    if (encode_regname (de->d_name, buf, add_val))
      {
	buf_size = NAME_MAX + 1;
	goto retry;
      }
  }

  if (dir->__d_position & REG_ENUM_VALUES_MASK)
    de->d_type = DT_REG;
  else if (!strcasecmp (de->d_name, "Classes")
	   && !strcasecmp (path + strlen (path)
			   - sizeof (VIRT_CLASSES_KEY_PREFIX) + 1,
			   VIRT_CLASSES_KEY_PREFIX))
    de->d_type = DT_LNK;
  else
    de->d_type = DT_DIR;

  res = 0;
out:
  syscall_printf ("%d = readdir(%p, %p)", res, dir, de);
  return res;
}

long
fhandler_registry::telldir (DIR * dir)
{
  return dir->__d_position & REG_POSITION_MASK;
}

void
fhandler_registry::seekdir (DIR * dir, long loc)
{
  /* Unfortunately cannot simply set __d_position due to transition from sub-keys to
   * values.
   */
  rewinddir (dir);
  while (loc > (dir->__d_position & REG_POSITION_MASK))
    if (readdir (dir, dir->__d_dirent))
      break;
}

void
fhandler_registry::rewinddir (DIR * dir)
{
  if (dir->__handle != INVALID_HANDLE_VALUE)
    {
      delete d_hash (dir);
      RegCloseKey ((HKEY) dir->__handle);
      dir->__handle = INVALID_HANDLE_VALUE;
    }
  dir->__d_position = 0;
  dir->__flags = dirent_saw_dot | dirent_saw_dot_dot;
}

int
fhandler_registry::closedir (DIR * dir)
{
  int res = 0;
  if (dir->__handle != INVALID_HANDLE_VALUE)
    {
      delete d_hash (dir);
      if (RegCloseKey ((HKEY) dir->__handle) != ERROR_SUCCESS)
	{
	  __seterrno ();
	  res = -1;
	}
    }
  syscall_printf ("%d = closedir(%p)", res, dir);
  return 0;
}

int
fhandler_registry::open (int flags, mode_t mode)
{
  int pathlen;
  const char *file;
  HKEY handle = (HKEY) INVALID_HANDLE_VALUE;

  int res = fhandler_virtual::open (flags, mode);
  if (!res)
    goto out;

  const char *path;
  path = get_name () + proc_len + 1 + prefix_len;
  if (!*path)
    {
      if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
	{
	  set_errno (EEXIST);
	  res = 0;
	  goto out;
	}
      else if (flags & O_WRONLY)
	{
	  set_errno (EISDIR);
	  res = 0;
	  goto out;
	}
      else
	{
	  flags |= O_DIROPEN;
	  /* Marking as nohandle allows to call dup. */
	  nohandle (true);
	  goto success;
	}
    }
  path++;
  pathlen = strlen (path);
  file = path + pathlen - 1;
  if (isdirsep (*file) && pathlen > 1)
    file--;
  while (!isdirsep (*file))
    file--;
  file++;

  if (file == path)
    {
      for (int i = 0; registry_listing[i]; i++)
	if (path_prefix_p (registry_listing[i], path,
			   strlen (registry_listing[i]), true))
	  {
	    if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
	      {
		set_errno (EEXIST);
		res = 0;
		goto out;
	      }
	    else if (flags & O_WRONLY)
	      {
		set_errno (EISDIR);
		res = 0;
		goto out;
	      }
	    else
	      {
		set_io_handle (fetch_hkey (i));
		/* Marking as nohandle allows to call dup on pseudo registry
		   handles. */
		if (get_handle () >= HKEY_CLASSES_ROOT)
		  nohandle (true);
		flags |= O_DIROPEN;
		goto success;
	      }
	  }

      if (flags & O_CREAT)
	{
	  set_errno (EROFS);
	  res = 0;
	}
      else
	{
	  set_errno (ENOENT);
	  res = 0;
	}
      goto out;
    }

  if (flags & O_WRONLY)
    {
      set_errno (EROFS);
      res = 0;
      goto out;
    }
  else
    {
      wchar_t dec_file[NAME_MAX + 1];
      int val_only = decode_regname (dec_file, file);
      if (val_only < 0)
	{
	  set_errno (EINVAL);
	  res = 0;
	  goto out;
	}

      if (!val_only)
	handle = open_key (path, KEY_READ, wow64, false);
      if (handle == (HKEY) INVALID_HANDLE_VALUE)
	{
	  if (val_only || get_errno () != EACCES)
	    handle = open_key (path, KEY_READ, wow64, true);
	  if (handle == (HKEY) INVALID_HANDLE_VALUE)
	    {
	      res = 0;
	      goto out;
	    }
	}
      else
	flags |= O_DIROPEN;

      set_io_handle (handle);
      set_close_on_exec (!!(flags & O_CLOEXEC));
      value_name = cwcsdup (dec_file);

      if (!(flags & O_DIROPEN) && !fill_filebuf ())
	{
	  RegCloseKey (handle);
	  res = 0;
	  goto out;
	}

      if (flags & O_APPEND)
	position = filesize;
      else
	position = 0;
  }

success:
  res = 1;
  set_flags ((flags & ~O_TEXT) | O_BINARY);
  set_open_status ();
out:
  syscall_printf ("%d = fhandler_registry::open(%p, 0%o)", res, flags, mode);
  return res;
}

int
fhandler_registry::close ()
{
  int res = fhandler_virtual::close ();
  if (res != 0)
    return res;
  HKEY handle = (HKEY) get_handle ();
  if (handle != (HKEY) INVALID_HANDLE_VALUE && handle < HKEY_CLASSES_ROOT)
    {
      if (RegCloseKey (handle) != ERROR_SUCCESS)
	{
	  __seterrno ();
	  res = -1;
	}
    }
  if (!have_execed && value_name)
    {
      cfree (value_name);
      value_name = NULL;
    }
  return res;
}

bool
fhandler_registry::fill_filebuf ()
{
  DWORD type, size;
  LONG error;
  HKEY handle = (HKEY) get_handle ();
  size_t bufalloc;

  if (handle != HKEY_PERFORMANCE_DATA)
    {
      error = RegQueryValueExW (handle, value_name, NULL, &type, NULL, &size);
      if (error != ERROR_SUCCESS)
	{
	  if (error == ERROR_INVALID_HANDLE
	      && !strcasecmp (get_name () + strlen (get_name ())
			      - sizeof (VIRT_CLASSES_KEY) + 1,
			      VIRT_CLASSES_KEY))
	    {
	      filesize = sizeof (VIRT_CLASSES_LINKTGT);
	      filebuf = (char *) cmalloc_abort (HEAP_BUF, filesize);
	      strcpy (filebuf, VIRT_CLASSES_LINKTGT);
	      return true;
	    }
	  if (error != ERROR_FILE_NOT_FOUND)
	    {
	      seterrno_from_win_error (__FILE__, __LINE__, error);
	      return false;
	    }
	  goto value_not_found;
	}
      PBYTE tmpbuf = (PBYTE) cmalloc_abort (HEAP_BUF, size);
      error =
	RegQueryValueExW (handle, value_name, NULL, NULL, tmpbuf, &size);
      if (error != ERROR_SUCCESS)
	{
	  seterrno_from_win_error (__FILE__, __LINE__, error);
	  return true;
	}
      if (type == REG_SZ || type == REG_EXPAND_SZ || type == REG_LINK)
	bufalloc = sys_wcstombs (NULL, 0, (wchar_t *) tmpbuf,
				 size / sizeof (wchar_t));
      else if (type == REG_MULTI_SZ)
	bufalloc = multi_wcstombs (NULL, 0, (wchar_t *) tmpbuf,
				   size / sizeof (wchar_t));
      else
	bufalloc = size;
      filebuf = (char *) cmalloc_abort (HEAP_BUF, bufalloc);
      if (type == REG_SZ || type == REG_EXPAND_SZ || type == REG_LINK)
	sys_wcstombs (filebuf, bufalloc, (wchar_t *) tmpbuf,
		      size / sizeof (wchar_t));
      else if (type == REG_MULTI_SZ)
	multi_wcstombs (filebuf, bufalloc, (wchar_t *) tmpbuf,
			size / sizeof (wchar_t));
      else
	memcpy (filebuf, tmpbuf, bufalloc);
      filesize = bufalloc;
    }
  else
    {
      bufalloc = 0;
      do
	{
	  bufalloc += 16 * 1024;
	  filebuf = (char *) crealloc_abort (filebuf, bufalloc);
	  size = bufalloc;
	  error = RegQueryValueExW (handle, value_name, NULL, &type,
				    (PBYTE) filebuf, &size);
	  if (error != ERROR_SUCCESS && error != ERROR_MORE_DATA)
	    {
	      seterrno_from_win_error (__FILE__, __LINE__, error);
	      return false;
	    }
	}
      while (error == ERROR_MORE_DATA);
      filesize = size;
      /* RegQueryValueEx () opens HKEY_PERFORMANCE_DATA.  */
      RegCloseKey (handle);
    }
  return true;
value_not_found:
  DWORD buf_size = NAME_MAX + 1;
  wchar_t buf[buf_size];
  int index = 0;
  while (ERROR_SUCCESS ==
	 (error = RegEnumKeyExW (handle, index++, buf, &buf_size, NULL, NULL,
				 NULL, NULL)) || (error == ERROR_MORE_DATA))
    {
      if (!wcscasecmp (buf, value_name))
	{
	  set_errno (EISDIR);
	  return false;
	}
      buf_size = NAME_MAX + 1;
    }
  if (error != ERROR_NO_MORE_ITEMS)
    {
      seterrno_from_win_error (__FILE__, __LINE__, error);
      return false;
    }
  set_errno (ENOENT);
  return false;
}

/* Auxillary member function to open registry keys.  */
static HKEY
open_key (const char *name, REGSAM access, DWORD wow64, bool isValue)
{
  HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
  HKEY hParentKey = (HKEY) INVALID_HANDLE_VALUE;
  bool parentOpened = false;
  wchar_t component[NAME_MAX + 1];

  while (*name)
    {
      const char *anchor = name;
      while (*name && !isdirsep (*name))
	name++;
      int val_only = decode_regname (component, anchor, name - anchor);
      if (val_only < 0)
	{
	  set_errno (EINVAL);
	  if (parentOpened)
	    RegCloseKey (hParentKey);
	  hKey = (HKEY) INVALID_HANDLE_VALUE;
	  break;
	}
      if (*name)
	name++;
      if (*name == 0 && isValue == true)
	break;

      if (val_only || !component[0] || hKey == HKEY_PERFORMANCE_DATA)
	{
	  set_errno (ENOENT);
	  if (parentOpened)
	    RegCloseKey (hParentKey);
	  hKey = (HKEY) INVALID_HANDLE_VALUE;
	  break;
	}

      if (hParentKey != (HKEY) INVALID_HANDLE_VALUE)
	{
	  REGSAM effective_access = KEY_READ;
	  if ((strchr (name, '/') == NULL && isValue == true) || *name == 0)
	    effective_access = access;
	  LONG error = RegOpenKeyExW (hParentKey, component, 0,
				      effective_access | wow64, &hKey);
	  if (error == ERROR_ACCESS_DENIED) /* Try opening with backup intent */
	    error = RegCreateKeyExW (hParentKey, component, 0, NULL,
				     REG_OPTION_BACKUP_RESTORE,
				     effective_access | wow64, NULL,
				     &hKey, NULL);
	  if (parentOpened)
	    RegCloseKey (hParentKey);
	  if (error != ERROR_SUCCESS)
	    {
	      hKey = (HKEY) INVALID_HANDLE_VALUE;
	      seterrno_from_win_error (__FILE__, __LINE__, error);
	      return hKey;
	    }
	  hParentKey = hKey;
	  parentOpened = true;
	}
      else
	{
	  for (int i = 0; registry_listing[i]; i++)
	    if (strncasematch (anchor, registry_listing[i], name - anchor - 1))
	      hKey = fetch_hkey (i);
	  if (hKey == (HKEY) INVALID_HANDLE_VALUE)
	    return hKey;
	  hParentKey = hKey;
	}
    }
  return hKey;
}

int
fhandler_registry::dup (fhandler_base *child, int flags)
{
  debug_printf ("here");
  fhandler_registry *fhs = (fhandler_registry *) child;

  int ret = fhandler_virtual::dup (fhs, flags);
  /* Pseudo registry handles can't be duplicated using DuplicateHandle.
     Therefore those fhandlers are marked with the nohandle flag.  This
     allows fhandler_base::dup to succeed as usual for nohandle fhandlers.
     Here we just have to fix up by copying the pseudo handle value. */
  if ((HKEY) get_handle () >= HKEY_CLASSES_ROOT)
    fhs->set_io_handle (get_handle ());
  if (value_name)
    fhs->value_name = cwcsdup (value_name);
  return ret;
}
@


1.81
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d4 1
a4 1
   2013 Red Hat, Inc.
d455 1
a455 1
  if (strncasematch (in_pc.normalized_path, "/proc/registry32", 16))
d460 1
a460 1
  else if (strncasematch (in_pc.normalized_path, "/proc/registry64", 16))
@


1.80
log
@	* devices.in (dev_cygdrive_storage): Revert mapping to \Device\Null.
	(dev_storage): Ditto for /dev.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::open_null): New method to open a fake
	\Device\Null handler.
	(fhandler_base::open): Fix formatting.  Change O_ACCMODE test to a
	switch statement.  Simplify a test which still tested for a now unused
	create_disposition.
	* fhandler.h (fhandler_base::open_null): Declare.
	(fhandler_netdrive::close): Declare.
	* fhandler_dev.cc (fhandler_dev::open): Open fake \Device\Null handle
	by just calling new open_null method.
	* fhandler_disk_file.cc (fhandler_cygdrive::open): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::open): Call open_null
	rather than setting nohandle.
	(fhandler_netdrive::close): New method.
	* fhandler_registry.cc (fetch_hkey): Fix token in RegOpenUserClassesRoot
	call.  Create valid key for HKEY_CURRENT_CONFIG by mapping to real key
	HKEY_LOCAL_MACHINE\System\CurrentControlSet\Hardware Profiles\Current.
	(fhandler_registry::open): Set nohandle only when using pseudo registry
	handle.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Call open rather
	than just setting nohandle here.
	* fhandler_virtual::fstatvfs): Set ST_RDONLY fs flag.
	* globals.cc (ro_u_null): New readonly UNICODE_STRING for \Device\Null.
	* path.h (path_conv::set_path): Revert previous change caring for
	wide_path.
@
text
@d589 2
a590 2
	  buf->st_uid = UNKNOWN_UID;
	  buf->st_gid = UNKNOWN_GID;
@


1.79
log
@	Streamline time/times functionality.  Remove last remains of former
	Windows 9x compatibility.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Drop now unneeded
	casts in calls to_timestruc_t.
	(fhandler_base::utimens_fs): Ditto for timespec_to_filetime.
	* fhandler_proc.cc (format_proc_stat): Ditto for to_time_t.
	* hires.h (class hires_ms): Remove unused member initime_ns.
	Remove declarations for timeGetTime_ns and prime.
	(hires_ms::uptime): Remove.
	* posix_ipc.cc (ipc_cond_timedwait): Ditto for timespec_to_filetime.
	* fhandler_registry.cc (fhandler_registry::fstat): Add cast.
	* resource.cc (fill_rusage): Call NtQueryInformationProcess rather than
	GetProcessTimes to deal with LARGE_INTEGER rather than FILETIME.
	* times.cc: Simplify time handling.  Throughout, use LARGE_INTEGER
	rather than FILETIME to simplify computations.  Throughout use
	{u}int64_t rather than {unsigned} long long.  Drop unneeded casts since
	NSPERSEC is 64 bit anyway.
	(systime_ns): Remove.
	(times): Call NtQuerySystemInformation to fetch boot time.  Call
	NtQueryInformationProcess rather than GetProcessTimes to deal with
	LARGE_INTEGER rather than FILETIME.  Call GetSystemTimeAsFileTime.
	(totimeval): Use constant 1000000 as in other functions.
	(time_t_to_filetime): Remove.
	(to_time_t): Change return type to time_t.
	(time_as_timestruc_t): Rename filetime to systime.
	(time): Ditto. Add cast.
	(hires_ns::nsecs): Fix return type cast.
	(hires_ms::timeGetTime_ns): Remove.
	(hires_ns::prime): Remove.
	(hires_ms::nsecs): Drop call to prime.  Call GetSystemTimeAsFileTime
	directly.  Subtract FACTOR here since it's the only function needing
	to do so.
	(minperiod): Cosmetically change to ULONG.
	(hires_ns::resolution): Fix return type cast.
	(hires_ms::resolution): Simplify, rely on NtQueryTimerResolution.
	* winsup.h: Align time related prototypes to above changes.
@
text
@d90 1
a90 1
				  ? cygheap->user.imp_token () : hProcImpToken,
d99 11
d834 2
a835 1
		nohandle (true);
@


1.78
log
@	* Merge in cygwin-64bit-branch.
@
text
@d511 1
a511 1
	      to_timestruc_t (&ftLastWriteTime, &buf->st_mtim);
@


1.77
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d32 2
a33 2
static const _off_t REG_ENUM_VALUES_MASK = 0x8000000;
static const _off_t REG_POSITION_MASK = 0xffff;
d62 1
a62 1
  "HKEY_PERFORMANCE_DATA",	// NT/2000/XP
d465 1
a465 1
fhandler_registry::fstat (struct __stat64 *buf)
d554 2
a555 2
	      __uid32_t uid;
	      __gid32_t gid;
d619 1
a619 1
      dir->__d_internal = (unsigned) new __DIR_hash ();
d896 1
a896 1
  syscall_printf ("%d = fhandler_registry::open(%p, %d)", res, flags, mode);
@


1.76
log
@	* fhandler_registry.cc: Drop Mingw.org considerations.
	* fhandler_serial.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* sched.cc: Ditto.
	* sec_helper.cc: Ditto.
@
text
@d3 2
a4 2
   Copyright 2002, 2003, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012 Red Hat, Inc.
d464 1
a464 1
int
@


1.75
log
@	* fhandler_registry.cc (RegOpenUserClassesRoot): Only define when
	building against w32api headers.
	(RegOpenCurrentUser): Ditto.
	* fhandler_tty.cc (GetNamedPipeClientProcessId): Ditto.
	* ntdll.h (enum _PROCESSINFOCLASS): Add ProcessImageFileName.
	(RtlInitAnsiString): Declare.
	(RtlUnicodeStringToAnsiSize): Declare.
	* sched.cc (GetForegroundWindow): Ditto.
	* sec_helper.cc (SECURITY_NT_NON_UNIQUE): Define as
	SECURITY_NT_NON_UNIQUE_RID when building against w32api headers.
	(cygsid::get_sid): Use SECURITY_NT_NON_UNIQUE rather than
	SECURITY_NT_NON_UNIQUE_RID.
	(__sec_user): Use PISECURITY_DESCRIPTOR rather than PSECURITY_DESCRIPTOR
	to allow valid pointer arithmetic.
	(_recycler_sd): Ditto.
	(_everyone_sd): Ditto.
@
text
@a79 7
#ifndef __MINGW64_VERSION_MAJOR
extern "C" {
  LONG WINAPI RegOpenUserClassesRoot (HANDLE, DWORD, REGSAM, PHKEY);
  LONG WINAPI RegOpenCurrentUser (REGSAM, PHKEY);
};
#endif

@


1.75.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d32 2
a33 2
static const __int32_t REG_ENUM_VALUES_MASK = 0x8000000;
static const __int32_t REG_POSITION_MASK = 0xffff;
d472 1
a472 1
fhandler_registry::fstat (struct stat *buf)
d561 2
a562 2
	      uid_t uid;
	      gid_t gid;
@


1.75.2.2
log
@	* fhandler_procsysvipc.cc (format_procsysvipc_msg): Fix printf format
	string for 64 bit.
	* fhandler_registry.cc (fhandler_registry::readdir): Fix cast.
	* fhandler_serial.cc (ibuf): Avoid compiler warning.
	* include/cygwin/ipc.h: Include stdint.h.
	* include/cygwin/msg.h (msgqnum_t): Define as uint32_t.
	(msglen_t): Ditto.
	(struct msginfo): Convert all long members to int32_t.
	(struct msg_info): Ditto.
	* include/cygwin/sem.h (struct seminfo): Ditto.
	* include/cygwin/shm.h (shmatt_t): Define as uint32_t.
	(struct shmid_ds): Define shm_segsz as uint32_t.
	(struct shminfo): Convert all long members to int32_t.
@
text
@d626 1
a626 1
      dir->__d_internal = (uintptr_t) new __DIR_hash ();
@


1.75.2.3
log
@Pull in changes from HEAD
@
text
@d80 7
@


1.75.2.4
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d896 1
a896 1
  syscall_printf ("%d = fhandler_registry::open(%p, 0%o)", res, flags, mode);
@


1.75.2.5
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
   2013 Red Hat, Inc.
d464 1
a464 1
int __reg2
@


1.75.2.6
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@d62 1
a62 1
  "HKEY_PERFORMANCE_DATA",
@


1.74
log
@* fhandler_registry.cc (fhandler_registry::open): Handle missing EROFS error
condition pointed to by Clang.
@
text
@d80 1
d85 1
@


1.73
log
@	Fix memory and handle leaks due to fdopendir:
	* dir.cc (closedir): Call global close instead of just releasing the
	fhandler.
	* fhandler_disk_file.cc (fhandler_disk_file::closedir): Don't close
	fhandler handle here, rely on global closedir doing the right thing.
	* fhandler_registry.cc (fhandler_registry::readdir): Also delete
	d_hash when closing registry key.
	(fhandler_registry::rewinddir): Ditto.

	Avoid infinite recursion in VirtualStore under UAC:
	* fhandler_registry.cc (VIRT_CLASSES_KEY_PREFIX): Define.
	(VIRT_CLASSES_KEY_SUFFIX): Ditto.
	(VIRT_CLASSES_KEY): Ditto.
	(VIRT_CLASSES_LINKTGT): Ditto.
	(fhandler_registry::exists): Return virt_symlink as file type if
	this is a Classes key under the VirtualStore.
	(fhandler_registry::fstat): Handle virt_symlink.
	(fhandler_registry::readdir): Return DT_LNK as d_type if this is a
	Classes key under the VirtualStore.
	(fhandler_registry::fill_filebuf): Handle Classes symlink.

	Handle user impersonation in /proc/registry access:
	* autoload.cc (RegOpenUserClassesRoot): Define.
	(RegOpenCurrentUser): Define.
	* fhandler_registry.cc (RegOpenUserClassesRoot): Declare function
	missing in w32api.
	(RegOpenCurrentUser): Ditto.
	(fetch_hkey): New function.
	(fhandler_registry::open): Call fetch_hkey to get root registry key.
	(open_key): Ditto.
@
text
@d851 1
@


1.72
log
@* cygheap.h (cygheap_fdget::~cygheap_fdget): Simplify now that refcnt reports
reference count changes itself.
* fhandler.cc (fhandler_base::reset): Set _refcnt to 0.
* fhandler.h (fhandler_base::refcnt): Report refcnt when debugging.
* select.cc (cygwin_select): Set return_on_signal to indicate when select
should be interrupted.
(select_stuff::wait): Keep looping unless return_on_signal is set.
* select.h (select_stuff::return_on_signal): New variable.
(select_stuff::select_stuff): Zero return_on_signal.
@
text
@d35 14
d80 27
d363 8
a370 1
	file_type = virt_directory;
d480 3
a603 1
  HANDLE handle;
d621 1
a621 2
      handle = open_key (path + 1, KEY_READ, wow64, false);
      dir->__handle = handle;
d667 1
d699 5
d736 1
d825 1
a825 1
		set_io_handle (registry_keys[i]);
d940 10
d1094 1
a1094 1
	      hKey = registry_keys[i];
@


1.71
log
@	* fhandler.h (fhandler_registry::opendir): Declare.
	* fhandler_registry.cc (fhandler_registry::opendir): New function.
@
text
@d4 1
a4 1
   2010, 2011 Red Hat, Inc.
@


1.70
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d540 8
@


1.69
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@d646 1
a646 1
  syscall_printf ("%d = readdir (%p, %p)", res, dir, de);
d693 1
a693 1
  syscall_printf ("%d = closedir (%p)", res, dir);
d836 1
a836 1
  syscall_printf ("%d = fhandler_registry::open (%p, %d)", res, flags, mode);
@


1.68
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d22 1
d855 1
a855 1
  if (!hExeced && value_name)
@


1.67
log
@	* fhandler_registry.cc (fhandler_registry::dup): Duplicate value_name.
@
text
@d1029 1
a1029 1
fhandler_registry::dup (fhandler_base *child)
d1034 1
a1034 1
  int ret = fhandler_virtual::dup (fhs);
@


1.66
log
@whitespace elimination
@
text
@d1031 4
a1034 1
  int ret = fhandler_virtual::dup (child);
d1040 3
a1042 1
    child->set_io_handle (get_handle ());
@


1.65
log
@	* fhandler_registry.cc (fhandler_registry::exists): Fix regression
	in EACCES handling.
	(fhandler_registry::open): Fix "%val" case.
@
text
@d333 5
a337 5
	         RegQueryValueEx () returns a PERF_DATA_BLOCK even
	         if a value does not contain any counter objects.
	         So allow access to the generic names and to
	         (blank separated) lists of counter numbers.
	         Never allow access to "Add", see above comment.  */
d577 1
a577 1
         simulate only a minimal listing of the generic names.  */
@


1.64
log
@	* fhandler_registry.cc (fhandler_registry::fstat): Use RegQueryInfoKeyW.
@
text
@d320 1
a320 1
      if (hKey != (HKEY) INVALID_HANDLE_VALUE || get_errno () == EACCES)
d324 2
d802 1
a802 1
	  if (get_errno () != EACCES)
@


1.63
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procsys.o.
	* devices.h (enum fh_devices): Add FH_PROCSYS.
	* devices.in (dev_procsys_storage): New device.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add code to allocate fhandler_procsys.
	* fhandler.h (proc_len): Convert to size_t.
	(procsys): Declare.
	(procsys_len): Declare.
	(enum virtual_ftype_t): Move here from fhandler_virtual.h.
	Add members supported by fhandler_procsys.
	(fhandler_virtual::exists): Return virtual_ftype_t.  Change
	in all derived classes.
	(class fhandler_procsys): New class.
	(fhandler_union): Add fhandler_procnet and fhandler_procsys members.
	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Use
	ro_u_proc.
	(fhandler_base::fstat_by_handle): Don't copy attributes if file is an
	NT device.
	(fhandler_base::fstat_by_name): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::exists): Return
	virtual_ftype_t.
	* fhandler_proc.cc (proc_tab): Sort alphabetically.  Use _VN macro
	to store length.
	(proc_len): Change to size_t.
	(proc_tab_cmp): New static function.
	(virt_tab_search): New function to search entry in virt_tab_t
	arrays.  Use throughout in /proc and sibling classes instead of
	loop.
	(fhandler_proc::exists): Return virtual_ftype_t.
	* fhandler_process.cc (process_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_process::exists): Return virtual_ftype_t.
	(fhandler_process::open): Simplify code.
	* fhandler_procnet.cc (procnet_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_procnet::exists): Return virtual_ftype_t.
	(fhandler_procnet::open): Simplify.
	* fhandler_procsys.cc: New file.
	* fhandler_registry.cc (fhandler_registry::exists): Return
	virtual_ftype_t.
	* fhandler_virtual.cc (fhandler_virtual::exists): Ditto.
	* fhandler_virtual.h (enum virtual_ftype_t): Move to fhandler.h.
	(virt_tab_t): Add name_len member.
	(_VN): New macro.
	(virt_tab_search): Declare.
	* mount.cc (mount_info::conv_to_win32_path): Fix comment.  Backslashify
	isprocsys_dev paths.
	* ntdll.h (STATUS_OBJECT_TYPE_MISMATCH): Define
	(STATUS_INSTANCE_NOT_AVAILABLE): Define.
	(STATUS_PIPE_NOT_AVAILABLE): Define.
	(STATUS_INVALID_PIPE_STATE): Define.
	(STATUS_PIPE_BUSY): Define.
	(SYMBOLIC_LINK_QUERY): Define.
	(NtOpenSymbolicLinkObject): Declare.
	(NtQuerySymbolicLinkObject): Declare.
	* path.cc (path_conv::check): Accommodate fact that exists method
	returns virtual_ftype_t now.  Add cases for new virtual_ftype_t
	types.
	(cygwin_conv_path): Add GLOBALROOT prefix to native device paths.
	Make sure to strip \\?\ prefix only for actual filesystem-based
	paths, not for all paths.
	* path.h (isproc_dev): Add FH_PROCSYS.
	(isprocsys_dev): Define.
@
text
@d4 1
a4 1
   2010 Red Hat, Inc.
d459 2
a460 3
	      RegQueryInfoKey (hKey, NULL, NULL, NULL, &subkey_count, NULL,
			       NULL, NULL, NULL, NULL, NULL,
			       &ftLastWriteTime))
@


1.62
log
@	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Set d_type.
	(fhandler_netdrive::seekdir): Fix test for readdir return value.
	* fhandler_registry.cc (fhandler_registry::seekdir): Ditto.
@
text
@d271 1
a271 1
int
d274 2
a275 1
  int file_type = 0, index = 0, pathlen;
d289 1
a289 1
      file_type = 2;
d306 1
a306 1
	    file_type = 1;
d321 1
a321 1
	file_type = 1;
d326 1
a326 1
	    return 0;
d336 2
a337 1
	      for (int i = 0; i < PERF_DATA_FILE_COUNT && file_type == 0; i++)
d340 1
a340 1
		    file_type = -1;
d342 2
a343 2
	      if (file_type == 0 && !file[strspn (file, " 0123456789")])
		file_type = -1;
d356 1
a356 1
		      file_type = 1;
d377 1
a377 1
		  file_type = -1;
d423 1
a423 1
  int file_type = exists ();
d426 1
a426 1
    case 0:
d429 1
a429 1
    case 1:
d432 1
a432 1
    case 2:
d437 1
a437 1
    case -1:
d442 1
a442 1
  if (file_type != 0 && file_type != 2)
d448 1
a448 1
		  (file_type < 0) ? true : false);
d466 1
a466 1
	      if (file_type > 0)
d513 1
a513 1
		  if (file_type > 0)
@


1.61
log
@	Align seekdir and telldir API to POSIX definition.
	* Makefile.in (NEW_FUNCTIONS): Remove seekdir and telldir mappings.
	* dir.cc (telldir): Move functionality from telldir64 here.  Use
	long, rather than _off_t.
	(telldir64): Just call telldir.  Only keep for backward compatibility.
	(seekdir): Move functionality from seekdir64 here.  Use long, rather
	than _off_t.
	(seekdir64): Just call seekdir.  Only keep for backward compatibility.
	* fhandler.h: Throughout, change prototypes of seekdir and telldir
	methods to use long, rather than _off64_t.
	* fhandler_disk_file.cc: Change aforementioned methods accordingly.
	* fhandler_netdrive.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* include/sys/dirent.h (struct __DIR): Change __d_position from
	_off_t to long to reflect API change.
	(telldir): Change prototype to use long, rather than off_t.
	(seekdir): Ditto.
@
text
@d660 1
a660 1
    if (!readdir (dir, dir->__d_dirent))
@


1.60
log
@	* fhandler_registry.cc (multi_wcstombs): New function.
	(fhandler_registry::fstat): Call multi_wcstombs for strings of type
	REG_MULTI_SZ.
	(fhandler_registry::fill_filebuf): Ditto.
@
text
@d646 1
a646 1
_off64_t
d653 1
a653 1
fhandler_registry::seekdir (DIR * dir, _off64_t loc)
@


1.59
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d233 31
d490 4
d498 2
a499 1
		      free (tmpbuf);
d887 1
a887 2
      if (type == REG_SZ || type == REG_EXPAND_SZ || type == REG_MULTI_SZ
	  || type == REG_LINK)
d890 3
d896 1
a896 2
      if (type == REG_SZ || type == REG_EXPAND_SZ || type == REG_MULTI_SZ
	  || type == REG_LINK)
d899 3
@


1.58
log
@	* fhandler.h (fhandler_registry::value_name): Convert to wchar_t*.
	* fhandler_registry.cc: Call UNICODE registry functions throughout
	and convert to multibyte using current locale's charset.  Accommodate
	throughout.
	(must_encode): Take wchar_t.
	(encode_regname): Convert from wchar_t *.
	(decode_regname): Convert to wchar_t *.
@
text
@d3 2
a4 1
   Copyright 2002, 2003, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d775 1
@


1.57
log
@	* fhandler_registry.cc (fhandler_registry::open): Mark /proc/registry
	directory and siblings as nohandle fhandler.
@
text
@d99 1
a99 1
must_encode (char c)
d101 1
a101 1
  return (isdirsep (c) || c == ':' || c == '%');
d108 1
a108 1
encode_regname (char * dst, const char * src, bool add_val)
d116 1
a116 1
	char c = src[si];
d118 3
a120 2
	    (si == 0 && ((c == '.' && (!src[1] || (src[1] == '.' && !src[2]))) ||
			(c == '@@' && !src[1]))))
d128 1
a128 1
	  dst[di++] = c;
d147 1
a147 1
decode_regname (char * dst, const char * src, int len = -1)
d151 2
a153 1
  int res = 0;
d174 1
a174 1
	    if (!(must_encode (c) ||
d186 1
d222 1
a222 1
key_exists (HKEY parent, const char * name, DWORD wow64)
d225 1
a225 1
  LONG error = RegOpenKeyEx (parent, name, 0, KEY_READ | wow64, &hKey);
d245 1
a245 1
  char buf[buf_size];
d279 1
a279 1
      char dec_file[NAME_MAX + 1];
d316 2
a317 2
		     (error = RegEnumKeyEx (hKey, index++, buf, &buf_size,
					    NULL, NULL, NULL, NULL))
d320 1
a320 1
		  if (strcasematch (buf, dec_file))
d337 2
a338 2
		 (error = RegEnumValue (hKey, index++, buf, &buf_size, NULL, NULL,
					NULL, NULL))
d341 1
a341 1
	      if (strcasematch (buf, dec_file))
d443 22
a464 6
		  char dec_value_name[NAME_MAX + 1];
		  DWORD dwSize;
		  if (decode_regname (dec_value_name, value_name) >= 0 &&
		      ERROR_SUCCESS ==
		      RegQueryValueEx (hKey, dec_value_name, NULL, NULL, NULL,
				       &dwSize))
d503 1
a503 1
  char buf[buf_size];
d551 3
a553 3
    error = RegEnumValue ((HKEY) dir->__handle,
			  (dir->__d_position & ~REG_ENUM_VALUES_MASK) >> 16,
			  buf, &buf_size, NULL, NULL, NULL, NULL);
d556 3
a558 3
      RegEnumKeyEx ((HKEY) dir->__handle, dir->__d_position -
		    SPECIAL_DOT_FILE_COUNT, buf, &buf_size, NULL, NULL, NULL,
		    NULL);
d749 1
a749 1
      char dec_file[NAME_MAX + 1];
d774 1
a774 1
      value_name = cstrdup (dec_file);
d831 1
a831 1
      error = RegQueryValueEx (handle, value_name, NULL, &type, NULL, &size);
d841 1
a841 2
      bufalloc = size;
      filebuf = (char *) cmalloc_abort (HEAP_BUF, bufalloc);
d843 1
a843 2
	RegQueryValueEx (handle, value_name, NULL, NULL, (BYTE *) filebuf,
			 &size);
d849 14
a862 1
      filesize = size;
d872 2
a873 2
	  error = RegQueryValueEx (handle, value_name, NULL, &type,
				   (BYTE *) filebuf, &size);
d888 1
a888 1
  char buf[buf_size];
d891 2
a892 2
	 (error = RegEnumKeyEx (handle, index++, buf, &buf_size, NULL, NULL,
				NULL, NULL)) || (error == ERROR_MORE_DATA))
d894 1
a894 1
      if (strcasematch (buf, value_name))
d917 1
a917 1
  char component[NAME_MAX + 1];
d952 2
a953 2
	  LONG error = RegOpenKeyEx (hParentKey, component, 0,
				     effective_access | wow64, &hKey);
d955 4
a958 4
	    error = RegCreateKeyEx (hParentKey, component, 0, NULL,
				    REG_OPTION_BACKUP_RESTORE,
				    effective_access | wow64, NULL,
				    &hKey, NULL);
d973 1
a973 1
	    if (strcasematch (component, registry_listing[i]))
@


1.56
log
@	* fhandler_procnet.cc: Reorganize global procnet content data into a
	new struct virt_tab_t.  Accommodate throughout.

	* fhandler.h: Fix copyright dates.
	* fhandler_process.cc: Ditto.
	* fhandler_registry.cc: Ditto.
@
text
@d667 2
@


1.55
log
@	* devices.h (FH_PROCESSFD): New device type.
	* dtable.cc (build_fh_pc): Add case for FH_PROCESSFD.
	* fhandler.h (class fhandler_virtual): Drop bufalloc member.
	* fhandler_virtual.h: New header.
	* fhandler_proc.cc: Remove types proc_type_t and proc_tab_t in favor
	of types virt_type_t and virt_tab_t from fhandler_virtual.h.
	Change prototypes of format_XXX functions accordingly.
	(proc_tab): Drop size member info.
	(fhandler_proc::fill_filebuf): Don't allocate filebuf here.  Allocate
	it in the format_XXX functions.
	* fhandler_process.cc: Reorganize global process content data into a
	new struct virt_tab_t.  Accommodate throughout.
	(format_process_winexename): New function.
	(format_process_winpid): New function.
	(format_process_exename): New function.
	(format_process_root): New function.
	(format_process_cwd): New function.
	(format_process_cmdline): New function.
	(format_process_ppid): New function.
	(format_process_uid): New function.
	(format_process_pgid): New function.
	(format_process_sid): New function.
	(format_process_gid): New function.
	(format_process_ctty): New function.
	(format_process_fd): New function.
	* fhandler_procnet.cc (fhandler_procnet::fill_filebuf): Don't use
	bufalloc.
	* fhandler_registry.cc (fhandler_registry::fill_filebuf): Define
	bufalloc locally.
	* fhandler_virtual.cc (fhandler_virtual::fhandler_virtual): Drop
	initialization of bufalloc.
	(fhandler_virtual::dup): Drop copying bufalloc.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2003, 2004, 2005, 2006, 2007 Red Hat, Inc.
@


1.54
log
@	* fhandler_registry.cc (perf_data_files): New table.
	(PERF_DATA_FILE_COUNT): New constant.
	(fhandler_registry::exists): Add check for HKEY_PERFORMANCE_DATA
	value names.
	(fhandler_registry::fstat): For HKEY_PERFORMANCE_DATA, return
	default values only.
	(fhandler_registry::readdir): For HKEY_PERFORMANCE_DATA, list
	names from perf_data_files only.
	(fhandler_registry::fill_filebuf): Use larger buffer to speed up
	access to HKEY_PERFORMANCE_DATA values.  Remove check for possible
	subkey.  Add RegCloseKey ().
	(open_key): Replace goto by break, remove label.  Do not try to
	open subkey of HKEY_PERFORMANCE_DATA.  Add missing RegCloseKey ()
	after open subkey error.
@
text
@d806 2
@


1.53
log
@	* fhandler_registry.cc (DEFAULT_VALUE_NAME): Remove constant.
	(encode_regname): Encode empty (default) name to "@@".
	Encode "@@" to "%40".  Change error return to -1.
	(decode_regname): Decode "@@" to empty name.  Decode "%40" to "@@".
	(fhandler_registry::exists): Skip check for keys if name is empty.
	Remove check for DEFAULT_VALUE_NAME, now handled by decode_regname ().
	(fhandler_registry::readdir): Remove check for empty name, now
	handled by encode_regname ().
	(fhandler_registry::open): Remove check for DEFAULT_VALUE_NAME.
	(fhandler_registry::open_key): Fail with ENOENT if key name is empty.
@
text
@d78 16
d292 18
d413 5
a417 1
      if (hKey != (HKEY) INVALID_HANDLE_VALUE)
d515 12
d835 1
a835 1
	  bufalloc += 1000;
d842 2
a843 6
	      if (error != ERROR_FILE_NOT_FOUND)
		{
		  seterrno_from_win_error (__FILE__, __LINE__, error);
		  return true;
		}
	      goto value_not_found;
d848 2
d902 1
a902 1
	goto out;
d904 1
a904 1
      if (val_only || !component[0])
d925 2
a932 2
	  if (parentOpened)
	    RegCloseKey (hParentKey);
a945 1
out:
@


1.52
log
@	* fhandler_registry.cc (fhandler_registry::exists): Handle EACCES.
	(fhandler_registry::open): Ditto.
@
text
@a77 3
/* Name given to default values */
static const char *DEFAULT_VALUE_NAME = "@@";

d89 1
d95 18
a112 14
  for (int si = 0; src[si]; si++)
    {
      char c = src[si];
      if (must_encode (c) ||
	  (c == '.' && si == 0 && (!src[1] || (src[1] == '.' && !src[2]))))
	{
	  if (di + 3 >= NAME_MAX + 1)
	    return ENAMETOOLONG;
	  __small_sprintf (dst + di, "%%%02x", c);
	  di += 3;
	}
      else
	dst[di++] = c;
    }
d117 1
a117 1
	return ENAMETOOLONG;
d134 1
d136 6
d143 21
a163 18
  for (int si = 0; si < len; si++)
    {
      char c = src[si];
      if (c == '%')
	{
	  if (si + 4 == len && !memcmp (src + si, "%val", 4))
	    {
	      res = 1;
	      break;
	    }
	  if (si + 2 >= len)
	    return -1;
	  char s[] = {src[si+1], src[si+2], '\0'};
	  char *p;
	  c = strtoul (s, &p, 16);
	  if (!(must_encode (c) ||
		(c == '.' && si == 0 && (len == 3 || (src[3] == '.' && len == 4)))))
	    return -1;
d165 2
a166 5
	  si += 2;
	}
      else
	dst[di++] = c;
    }
d276 1
a276 1
	  if (!val_only)
d304 1
a304 2
	      if (   (buf[0] == '\0' && strcasematch (file, DEFAULT_VALUE_NAME))
		  || strcasematch (buf, dec_file))
d512 16
a527 19
  if (*buf == 0)
    strcpy (de->d_name, DEFAULT_VALUE_NAME);
  else
    {
      /* Append "%val" if value name is identical to a previous key name.  */
      unsigned h = hash_path_name (1, buf);
      bool add_val = false;
      if (! (dir->__d_position & REG_ENUM_VALUES_MASK))
	d_hash (dir)->set (h);
      else if (d_hash (dir)->is_set (h)
	       && key_exists ((HKEY) dir->__handle, buf, wow64))
	add_val = true;

      if (encode_regname (de->d_name, buf, add_val))
	{
	  buf_size = NAME_MAX + 1;
	  goto retry;
	}
    }
d703 1
a703 5

      if (strcasematch (dec_file, DEFAULT_VALUE_NAME))
	value_name = cstrdup ("");
      else
	value_name = cstrdup (dec_file);
d856 1
a856 1
      if (val_only)
@


1.51
log
@	* fhandler.h (class fhandler_registry): Declare dup method.
	* fhandler_registry.cc (fhandler_registry::exists): Fix missing
	parenthesis.
	(fhandler_registry::dup): New method.
@
text
@d259 1
a259 1
      if (hKey != (HKEY) INVALID_HANDLE_VALUE)
d686 2
a687 1
	  handle = open_key (path, KEY_READ, wow64, true);
@


1.50
log
@* cygheap.cc (cygheap_user::~cygheap_user): Remove unneeded if 0'ed code.
* fhandler_registry.cc (fhandler_registry::exists): Recode goto as if/else to
avoid a gcc4 compiler warning.
(fhandler_registry::open): Ditto.  Use one goto rather than two.
* gentls_offsets: Fix compiler warning in generated output.
* tlsoffsets.h: Regenerate.
* mount.cc (fillout_mntent): slashify native paths returned via getmntent.
@
text
@d240 9
a248 7
    for (int i = 0; registry_listing[i]; i++)
      if (path_prefix_p (registry_listing[i], path,
			 strlen (registry_listing[i]), true))
	{
	  file_type = 1;
	  break;
	}
d645 3
d732 1
a732 1
  if (handle != (HKEY) INVALID_HANDLE_VALUE)
d899 13
@


1.49
log
@	* fhandler_registry.cc (encode_regname): Add Parameter add_val.
	Append "%val" if add_val is set.
	(decode_regname): Remove trailing "%val". Change returncode accordingly.
	(__DIR_hash): New class.
	(d_hash): New macro.
	(key_exists): New function.
	(fhandler_registry::exists): Remove encode of registry name before path
	compare, decode file part of path instead.  Skip checks for keys if
	trailing "%val" detected.
	(fhandler_registry::fstat): Change check of return value of
	decode_regname ().
	(fhandler_registry::readdir): Allocate __DIR_hash.  Record key names in
	hash table. Append "%val" if key with same name exists. Fix error
	handling of encode_regname ().  Set dirent.d_type.
	(fhandler_registry::closedir): Delete __DIR_hash.
	(fhandler_registry::open): Don't open key if trailing "%val" detected
	by decode_regname ().
	(open_key): Ditto.
@
text
@d150 1
a150 1
	        (c == '.' && si == 0 && (len == 3 || (src[3] == '.' && len == 4)))))
d240 8
d249 1
a249 9
      for (int i = 0; registry_listing[i]; i++)
	if (path_prefix_p (registry_listing[i], path,
			   strlen (registry_listing[i]), true))
	  {
	    file_type = 1;
	    goto out;
	  }
      goto out;
    }
d251 3
a253 14
  char dec_file[NAME_MAX + 1];
  int val_only = decode_regname (dec_file, file);
  if (val_only < 0)
    goto out;

  if (!val_only)
    hKey = open_key (path, KEY_READ, wow64, false);
  if (hKey != (HKEY) INVALID_HANDLE_VALUE)
    file_type = 1;
  else
    {
      hKey = open_key (path, KEY_READ, wow64, true);
      if (hKey == (HKEY) INVALID_HANDLE_VALUE)
	return 0;
d256 4
d261 27
d289 2
a290 2
		 (error = RegEnumKeyEx (hKey, index++, buf, &buf_size,
					NULL, NULL, NULL, NULL))
d293 2
a294 1
	      if (strcasematch (buf, dec_file))
d296 1
a296 1
		  file_type = 1;
d299 1
a299 1
		buf_size = NAME_MAX + 1;
a305 21
	  index = 0;
	  buf_size = NAME_MAX + 1;
	}

      while (ERROR_SUCCESS ==
	     (error = RegEnumValue (hKey, index++, buf, &buf_size, NULL, NULL,
				    NULL, NULL))
	     || (error == ERROR_MORE_DATA))
	{
	  if (   (buf[0] == '\0' && strcasematch (file, DEFAULT_VALUE_NAME))
	      || strcasematch (buf, dec_file))
	    {
	      file_type = -1;
	      goto out;
	    }
	  buf_size = NAME_MAX + 1;
	}
      if (error != ERROR_NO_MORE_ITEMS)
	{
	  seterrno_from_win_error (__FILE__, __LINE__, error);
	  goto out;
a651 1
	  goto out;
a656 1
	  goto out;
d658 1
a664 1
      goto out;
d666 1
a666 4

  char dec_file[NAME_MAX + 1];
  int val_only = decode_regname (dec_file, file);
  if (val_only < 0)
d668 8
a675 4
      set_errno (EINVAL);
      res = 0;
      goto out;
    }
d677 2
a678 5
  if (!val_only)
    handle = open_key (path, KEY_READ, wow64, false);
  if (handle == (HKEY) INVALID_HANDLE_VALUE)
    {
      handle = open_key (path, KEY_READ, wow64, true);
d681 6
a686 2
	  res = 0;
	  goto out;
d688 2
a689 3
    }
  else
    flags |= O_DIROPEN;
d691 1
a691 1
  set_io_handle (handle);
d693 4
a696 4
  if (strcasematch (dec_file, DEFAULT_VALUE_NAME))
    value_name = cstrdup ("");
  else
    value_name = cstrdup (dec_file);
d698 6
a703 6
  if (!(flags & O_DIROPEN) && !fill_filebuf ())
    {
      RegCloseKey (handle);
      res = 0;
      goto out;
    }
d705 5
a709 4
  if (flags & O_APPEND)
    position = filesize;
  else
    position = 0;
d837 1
a837 1
        {
@


1.48
log
@	* fhandler_registry.cc (must_encode): Fix condition changed for testing.
@
text
@d94 1
a94 1
encode_regname (char * dst, const char * src)
d111 9
d125 1
d132 1
d139 5
d145 1
a145 1
	    return EINVAL;
d151 1
a151 1
	    return EINVAL;
d159 43
a201 1
  return 0;
d251 7
a257 1
  hKey = open_key (path, KEY_READ, wow64, false);
d266 1
a266 4
      while (ERROR_SUCCESS ==
	     (error = RegEnumKeyEx (hKey, index++, buf, &buf_size, NULL, NULL,
				     NULL, NULL))
	     || (error == ERROR_MORE_DATA))
d268 4
a271 1
	  if (strcasematch (buf, file))
d273 10
a282 1
	      file_type = 1;
d285 1
d288 1
a288 7
      if (error != ERROR_NO_MORE_ITEMS)
	{
	  seterrno_from_win_error (__FILE__, __LINE__, error);
	  goto out;
	}
      index = 0;
      buf_size = NAME_MAX + 1;
a293 1
	  char enc_buf[NAME_MAX + 1];
d295 1
a295 1
	      || (!encode_regname (enc_buf, buf) && strcasematch (enc_buf, file)))
d394 1
a394 1
		  if (!decode_regname (dec_value_name, value_name) &&
d451 1
a451 1
  if (dir->__handle == INVALID_HANDLE_VALUE && dir->__d_position == 0)
d453 2
d457 3
a460 2
  if (dir->__handle == INVALID_HANDLE_VALUE)
    goto out;
d498 4
d504 17
a520 2
  else if (encode_regname (de->d_name, buf))
    goto retry;
a521 1
  dir->__d_position++;
d523 4
a526 1
    dir->__d_position += 0x10000;
d567 1
a567 2
  if (dir->__handle != INVALID_HANDLE_VALUE &&
      RegCloseKey ((HKEY) dir->__handle) != ERROR_SUCCESS)
d569 6
a574 2
      __seterrno ();
      res = -1;
d585 1
a585 1
  HKEY handle;
d670 2
a671 1
  if (decode_regname (dec_file, file))
d678 2
a679 1
  handle = open_key (path, KEY_READ, wow64, false);
d835 2
a836 1
      if (decode_regname (component, anchor, name - anchor))
d849 9
@


1.47
log
@	* fhandler_registry.cc (must_encode): New function.
	(encode_regname): Ditto.
	(decode_regname): Ditto.
	(fhandler_registry::exists): Encode name before path compare.
	(fhandler_registry::fstat): Pass decoded name to win32 registry call.
	(fhandler_registry::readdir): Return encoded name to user.
	(fhandler_registry::open): Store decoded name into value_name.
	(open_key): Pass decoded name to win32 registry call.
@
text
@d88 1
a88 1
  return (isdirsep (c) || c == '%');
@


1.46
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@d14 1
d83 63
d226 3
a228 2
	  if (strcasematch (buf, file)
	      || (buf[0] == '\0' && strcasematch (file, DEFAULT_VALUE_NAME)))
d325 1
d327 3
a329 2
		  if (ERROR_SUCCESS ==
		      RegQueryValueEx (hKey, value_name, NULL, NULL, NULL,
d430 2
a431 2
  else
    strcpy (de->d_name, buf);
d575 8
d598 1
a598 1
  if (strcasematch (file, DEFAULT_VALUE_NAME))
d601 1
a601 1
    value_name = cstrdup (file);
d739 8
a746 2
      strncpy (component, anchor, name - anchor);
      component[name - anchor] = '\0';
@


1.45
log
@Remove unneeded header files from source files throughout.
@
text
@d120 2
a121 2
	if (path_prefix_p
	    (registry_listing[i], path, strlen (registry_listing[i])))
d143 1
a143 1
	  if (pathmatch (buf, file))
d162 2
a163 2
	  if (pathmatch (buf, file) || (buf[0] == '\0' &&
					pathmatch (file, DEFAULT_VALUE_NAME)))
d464 2
a465 2
	if (path_prefix_p
	    (registry_listing[i], path, strlen (registry_listing[i])))
d523 1
a523 1
  if (pathmatch (file, DEFAULT_VALUE_NAME))
d634 1
a634 1
      if (pathmatch (buf, value_name))
d697 1
a697 1
	    if (pathmatch (component, registry_listing[i]))
@


1.44
log
@	* fhandler_registry.cc: Use NAME_MAX + 1 instead of CYG_MAX_PATH
	throughout for subkey name buffer size.
	* fhandler_socket.cc (search_wsa_event_slot): Use MAX_PATH instead of
	CYG_MAX_PATH for mutext name buffer size.
	(fhandler_socket::init_events): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Check path length
	against PATH_MAX instead of against CYG_MAX_PATH.
	* registry.cc (get_registry_hive_path): Use PATH_MAX instead of
	CYG_MAX_PATH for registry value path buffer size.
	* shared.cc (open_shared): Use MAX_PATH instead of CYG_MAX_PATH
	for shared memory name buffer size.
	* thread.cc (semaphore::semaphore): Use MAX_PATH instead of CYG_MAX_PATH
	for semaphore name buffer size.
	* uinfo.cc (cygheap_user::env_userprofile): Use PATH_MAX instead of
	CYG_MAX_PATH for temporary path name buffer size.
	* winf.h (LINE_BUF_CHUNK): Define as MAX_PATH * 2.
	* include/sys/dirent.h: Include sys/limits.h.  Define name buffer sizes
	using NAME_MAX.
@
text
@a13 3
#include <unistd.h>
#include <stdlib.h>
#include <sys/cygwin.h>
a19 1
#include <assert.h>
@


1.43
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d97 1
a97 1
  DWORD buf_size = CYG_MAX_PATH;
d144 1
a144 1
				    NULL, NULL))
d152 1
a152 1
	  buf_size = CYG_MAX_PATH;
d160 1
a160 1
      buf_size = CYG_MAX_PATH;
d172 1
a172 1
	  buf_size = CYG_MAX_PATH;
d305 1
a305 1
  DWORD buf_size = CYG_MAX_PATH;
d352 1
a352 1
      buf_size = CYG_MAX_PATH;
d631 1
a631 1
  DWORD buf_size = CYG_MAX_PATH;
d643 1
a643 1
      buf_size = CYG_MAX_PATH;
d661 1
a661 1
  char component[CYG_MAX_PATH];
@


1.42
log
@	* fhandler.cc (fhandler_base::fhaccess): Accommodate interface changes
	of access control functions throughout.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* sec_acl.cc: Drop unnecessary includes.
	(setacl): Take path_conv instead of file name as parameter.
	Accommodate interface changes of access control functions.
	(getacl): Ditto.
	* sec_auth.cc: New file, taking over all authentication related
	functions from security.cc.
	* sec_helper.cc: Drop unnecessary includes.
	* security.cc: Ditto.  Move all authentication related functions to
	sec_auth.cc.
	(ALL_SECURITY_INFORMATION): New define.  Use throughout.
	(set_file_sd): New function, replacing read_sd and the file related
	part of get_nt_object_security.
	(get_reg_sd): Rename from get_reg_security.  Drop type parameter.
	(get_reg_attribute): New function, replacing the registry related part
	of get_nt_object_security.
	(get_file_attribute): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(set_file_attribute): Ditto plus new set_file_sd.  Drop unnecessary
	implementation without uid/gid parameters.
	(check_file_access): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(check_registry_access): Use new get_reg_sd call.
	* security.h: Accommodate above interface changes.
@
text
@d595 1
a595 1
      filebuf = (char *) cmalloc (HEAP_BUF, bufalloc);
d612 1
a612 1
	  filebuf = (char *) crealloc (filebuf, bufalloc);
@


1.41
log
@	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Set new stat member
	st_birthtim to useful value.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Take
	additional parameter for creation time.  Fill st_birthtim with it.
	Accomodate additional creation time parameter throughout.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Set new stat member
	st_birthtim to useful value.
	* fhandler.cc (fhandler_base::fstat): Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Ditto.
	* include/cygwin/version.h: Bump API minor number.
	* include/cygwin/stat.h (struct __stat64): Replace st_spare4 with
	timestruc_t st_birthtim.
	(struct stat): Ditto if __CYGWIN_USE_BIG_TYPES__ is defined.
	(st_birthtime): Define if __CYGWIN_USE_BIG_TYPES__ is defined.
@
text
@d272 1
a272 3
	      if (get_object_attribute
		  ((HANDLE) hKey, SE_REGISTRY_KEY, &buf->st_mode, &uid,
		   &gid) == 0)
@


1.40
log
@	* fhandler_registry.cc (registry_listing): Drop name of HKEY_DYN_DATA.
	(registry_keys): Drop HKEY_DYN_DATA.
	* net.cc: Fix comment.
	* syslog.cc: Ditto.
@
text
@d251 1
a251 1
	      buf->st_ctim = buf->st_mtim;
@


1.39
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2003, 2004, 2005, 2006 Red Hat, Inc.
a48 1
  "HKEY_DYN_DATA",		// 95/98/Me
a61 1
  HKEY_DYN_DATA,
@


1.38
log
@	* fhandler.cc (fhandler_base::fhaccess): Check if opening registry
	actually created a handle.  This handles the registry root dir.
	* fhandler_registry.cc (fhandler_registry::open): Set io_handle in
	case of opening one of the predefined registry keys.
@
text
@d190 1
a190 1
{   
d290 1
a290 1
        {
@


1.37
log
@	* fhandler_registry.cc (fhandler_registry::fstat): Set restrictive
	permission and ownership if key can't be opened for reading security.
	(open_key): If opening key fails, retry opening with backup intent.
@
text
@d489 1
@


1.36
log
@	* fhandler.h (fhandler_base::set_name): Make virtual.
	(class fhandler_registry): Add wow64 and prefix_len members.
	Declare set_name method.
	* fhandler_proc.cc (PROC_REGISTRY32): Define.
	(PROC_REGISTRY64): Define.
	(proc_listing): Add "registry32" and "registry64" elements.
	(proc_fhandlers): Add corresponding FH_REGISTRY values.
	* fhandler_registry.cc (registry_len): Drop static value in favor of
	class member prefix_len.  Use preifx_len instead of registry_len
	throughout.
	(fhandler_registry::set_name): Define.  Set wow64 and prefix_len
	according to directory prefix.
	(fhandler_registry::fhandler_registry): Set wow64 and prefix_len to
	default values.
	(open_key): Add wow64 argument.  Handle wow64 in call to RegOpenKeyEx.
	Use fhandler_registry member wow64 in this place throughout.
@
text
@d289 13
d683 7
a689 4
	  LONG
	    error =
	    RegOpenKeyEx (hParentKey, component, 0, effective_access | wow64,
	    		  &hKey);
@


1.35
log
@	* autoload.cc (NtQueryDirectoryFile): Define.
	* dir.cc (__opendir_with_d_ino): Just call opendir.
	(opendir): Remove CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO handling.
	(readdir_worker): Only try generating d_ino if it's 0.
	Utilize namehash of directories fhandler.  Call readdir_get_ino to
	generate d_ino for "..".
	(seekdir64): Keep dirent_set_d_ino flag.
	* fhandler.h (enum dirent_states): Add dirent_get_d_ino.
	(class fhandler_disk_file): Declare new private methods readdir_helper
	and readdir_9x.
	* fhandler_disk_file.cc (path_conv::hasgood_inode): New method to
	evaluate if a filesystem has reliable inode numbers.
	(fhandler_base::fstat_by_handle): Accomodate structure member name
	change from IndexNumber to FileId.
	(fhandler_base::fstat_helper): Call hasgood_inode here.
	(fhandler_disk_file::opendir): Call fhaccess only for real files.
	Don't append '*' to __d_dirname here, move to readdir_9x.  On NT,
	open directory handle here.  Set dirent_get_d_ino and dirent_set_d_ino
	flags according to wincap and filesystem.
	(fhandler_disk_file::readdir_helper): New method to implement readdir
	postprocessing only once.
	(readdir_get_ino_by_handle): New static function.
	(readdir_get_ino): New function to centralize inode number evaluation
	in case inode number hasn't been returned by NtQueryDirectoryFile.
	(fhandler_disk_file::readdir): Move old functionality to readdir_9x.
	Call readdir_9x when on 9x/Me.  Implement NT specific readdir here.
	(fhandler_disk_file::readdir_9x): Move 9x specific readdir here.
	(fhandler_disk_file::seekdir): Accomodate new NT readdir method.
	(fhandler_disk_file::closedir): Ditto.
	(fhandler_cygdrive::fstat): Set d_ino to namehash. Add comment.
	(fhandler_cygdrive::opendir): Call get_namehash to prepare later
	correct evaluation of d_ino.
	(fhandler_cygdrive::readdir): Replace recursion with loop. Evaluate
	drive's d_ino by calling readdir_get_ino.
	* fhandler_proc.cc (fhandler_proc::readdir): Set dirent_saw_dot and
	dirent_saw_dot_dot to avoid seeing . and .. entries twice.
	* fhandler_process.cc (fhandler_process::readdir): Ditto.
	* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
	* ntdll.h (STATUS_INVALID_PARAMETER): New define.
	(STATUS_INVALID_LEVEL): New define.
	(struct _FILE_INTERNAL_INFORMATION): Rename member IndexNumber to
	FileId (as in Nebbitt).
	* path.h (path_conv::hasgood_inode): Now implemented in
	fhandler_disk_file.cc.
	* wincap.h (wincaps::has_fileid_dirinfo): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (readdir_get_ino): Add declaration.
	* include/sys/dirent.h (struct dirent): Slightly rename structure
	members to accomodate changes.
	Remove __USE_EXPENSIVE_CYGWIN_D_INO handling and declaration of
	__opendir_with_d_ino.
@
text
@a27 1
static const int registry_len = sizeof ("registry") - 1;
d86 1
a86 1
static HKEY open_key (const char *name, REGSAM access, bool isValue);
d107 1
a107 1
  path += proc_len + registry_len + 1;
d135 1
a135 1
  hKey = open_key (path, KEY_READ, false);
d140 1
a140 1
      hKey = open_key (path, KEY_READ, true);
d188 16
d207 2
d238 1
a238 1
      const char *path = get_name () + proc_len + registry_len + 2;
d240 1
a240 1
	open_key (path, STANDARD_RIGHTS_READ | KEY_QUERY_VALUE,
d299 1
a299 1
  const char *path = dir->__d_dirname + proc_len + 1 + registry_len;
d314 1
a314 1
      handle = open_key (path + 1, KEY_READ, false);
d426 1
a426 1
  path = get_name () + proc_len + 1 + registry_len;
d502 1
a502 1
  handle = open_key (path, KEY_READ, false);
d505 1
a505 1
      handle = open_key (path, KEY_READ, true);
d646 1
a646 1
open_key (const char *name, REGSAM access, bool isValue)
d672 2
a673 1
	    RegOpenKeyEx (hParentKey, component, 0, effective_access, &hKey);
@


1.35.4.1
log
@	* fhandler_registry.cc (must_encode): New function.
	(encode_regname): Ditto.
	(decode_regname): Ditto.
	(fhandler_registry::exists): Encode name before path compare.
	(fhandler_registry::fstat): Pass decoded name to win32 registry call.
	(fhandler_registry::readdir): Return encoded name to user.
	(fhandler_registry::open): Store decoded name into value_name.
	(open_key): Pass decoded name to win32 registry call.
@
text
@a88 63
/* Return true if char must be encoded.
 */
static inline bool
must_encode (char c)
{
  return (isdirsep (c) || c == ':' || c == '%');
}

/* Encode special chars in registry key or value name.
 */
static int
encode_regname (char * dst, const char * src)
{
  int di = 0;
  for (int si = 0; src[si]; si++)
    {
      char c = src[si];
      if (must_encode (c) ||
	  (c == '.' && si == 0 && (!src[1] || (src[1] == '.' && !src[2]))))
	{
	  if (di + 3 >= CYG_MAX_PATH)
	    return ENAMETOOLONG;
	  __small_sprintf (dst + di, "%%%02x", c);
	  di += 3;
	}
      else
	dst[di++] = c;
    }
  dst[di] = 0;
  return 0;
}

/* Decode special chars in registry key or value name.
 */
static int
decode_regname (char * dst, const char * src, int len = -1)
{
  if (len < 0)
    len = strlen (src);
  int di = 0;
  for (int si = 0; si < len; si++)
    {
      char c = src[si];
      if (c == '%')
	{
	  if (si + 2 >= len)
	    return EINVAL;
	  char s[] = {src[si+1], src[si+2], '\0'};
	  char *p;
	  c = strtoul (s, &p, 16);
	  if (!(must_encode (c) ||
	        (c == '.' && si == 0 && (len == 3 || (src[3] == '.' && len == 4)))))
	    return EINVAL;
	  dst[di++] = c;
	  si += 2;
	}
      else
	dst[di++] = c;
    }
  dst[di] = 0;
  return 0;
}

d169 2
a170 3
	  char enc_buf[CYG_MAX_PATH];
	  if (   (buf[0] == '\0' && pathmatch (file, DEFAULT_VALUE_NAME))
	      || (!encode_regname (enc_buf, buf) && pathmatch (enc_buf, file)))
a248 1
		  char dec_value_name[CYG_MAX_PATH];
d250 2
a251 3
		  if (!decode_regname (dec_value_name, value_name) &&
		      ERROR_SUCCESS ==
		      RegQueryValueEx (hKey, dec_value_name, NULL, NULL, NULL,
d341 2
a342 2
  else if (encode_regname (de->d_name, buf))
    goto retry;
a484 8
  char dec_file[CYG_MAX_PATH];
  if (decode_regname (dec_file, file))
    {
      set_errno (EINVAL);
      res = 0;
      goto out;
    }

d500 1
a500 1
  if (pathmatch (dec_file, DEFAULT_VALUE_NAME))
d503 1
a503 1
    value_name = cstrdup (dec_file);
d641 2
a642 8
      if (decode_regname (component, anchor, name - anchor))
        {
	  set_errno (EINVAL);
	  if (parentOpened)
	    RegCloseKey (hParentKey);
	  hKey = (HKEY) INVALID_HANDLE_VALUE;
	  break;
	}
@


1.34
log
@Remove some more unneeded 'return;'s throughout.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2003, 2004, 2005 Red Hat, Inc.
d286 1
@


1.33
log
@* cygheap.h (cygheap_types): Add HEAP_COMMUNE.
* fhandler_proc.cc: Use cygheap rather than user heap for allocation of filebuf
throughout.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_process.cc: Ditto.
(get_mem_values): Use malloc/realloc/free rather than new.
* pinfo.cc (_pinfo::commune_send): Allocate on cygwin heap rather than user
heap.  Avoid calling ReadFile when correct number of characters have been read
or suffer buffer corruption.
(_pinfo::fd): Allocate on cygwin heap rather than user heap.
(_pinfo::fds): Ditto.
(_pinfo::root): Ditto.
(_pinfo::cwd): Ditto.
(_pinfo::cmdline): Ditto.
* devices.h (FH_DEV): New define.
* devices.in: Detect lone /dev.
* devices.cc: Regenerate.
* path.cc (path_conv::check): Treat FH_DEV as a special case.
@
text
@a379 1
  return;
@


1.32
log
@* cygerrno.h (geterrno_from_win_error): Change declaration to default to using
GetLastError and EACCESS.
* cygwin.din: Export readdir_r.
* include/cygwin/version.h: Bump API version number to 138.
* syscalls.cc (readdir_worker): New function, renamed from old readdir()
function.
(readdir): Use readdir_worker.
(readdir_r): New function.
* fhandler.h (fhandler_base::readdir): Accommodate second argument indicating
dirent buffer.
(fhandler_disk_file::readdir): Ditto.
(fhandler_cygdrive::readdir): Ditto.
(fhandler_proc::readdir): Ditto.
(fhandler_netdrive::readdir): Ditto.
(fhandler_registry::readdir): Ditto.
(fhandler_process::readdir): Ditto.
* fhandler.cc (fhandler_base::readdir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Ditto.
* fhandler_cygdrive.cc (fhandler_cygdrive::readdir): Ditto.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_netdrive.cc (fhandler_netdrive::readdir): Ditto.
* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
* fhandler_process.cc (fhandler_process::readdir): Ditto.
@
text
@d542 4
a545 1
    cfree (value_name);
d568 1
a568 1
      filebuf = (char *) malloc (bufalloc);
d585 1
a585 1
	  filebuf = (char *) realloc (filebuf, bufalloc);
@


1.31
log
@	* fhandler_process.cc (fhandler_process::open): Allow opening of
	/proc/<pid>/fd for reading.
	* fhandler_registry.cc (fhandler_registry::open): Ditto for registry
	keys.
@
text
@d276 2
a277 2
struct dirent *
fhandler_registry::readdir (DIR * dir)
a281 1
  struct dirent *res = NULL;
d284 1
d290 2
a291 2
      strcpy (dir->__d_dirent->d_name, registry_listing[dir->__d_position++]);
      res = dir->__d_dirent;
d294 1
a294 2
  if (dir->__handle == INVALID_HANDLE_VALUE
      && dir->__d_position == 0)
d303 2
a304 3
      strcpy (dir->__d_dirent->d_name,
	      special_dot_files[dir->__d_position++]);
      res = dir->__d_dirent;
d339 1
a339 1
    strcpy (dir->__d_dirent->d_name, DEFAULT_VALUE_NAME);
d341 1
a341 1
    strcpy (dir->__d_dirent->d_name, buf);
d346 1
a346 1
  res = dir->__d_dirent;
d348 1
a348 1
  syscall_printf ("%p = readdir (%p)", &dir->__d_dirent, dir);
d366 1
a366 1
    if (!readdir (dir))
@


1.30
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d487 1
a487 1
  handle = open_key (path, KEY_READ, true);
d490 6
a495 2
      res = 0;
      goto out;
d497 2
d507 1
a507 1
  if (!fill_filebuf ())
@


1.29
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d377 1
a377 1
      (void) RegCloseKey ((HKEY) dir->__handle);
@


1.28
log
@* dir.cc: Rename opendir_* to dirent_* throughout.
(opendir_states): Move and rename.
* fhandler.h (dirent_states): to here.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Use raw readdir when
skipping through entries since it is keeping track of "." and "..".
(fhandler_cygdrive::seekdir): Use fhandler_disk_file::readdir to do everything.
* fhandler_virtual.cc (fhandler_virtual::opendir): Set flag indicating that we
provide .  and ..
(fhandler_virtual::seekdir): Ditto.
(fhandler_virtual::rewinddir): Ditto.
* fhandler_registry.cc (fhandler_registry::rewinddir): Ditto.
@
text
@d537 1
a537 1
  if (value_name)
@


1.27
log
@copyright
@
text
@d381 1
@


1.26
log
@	* cygheap.h (class cygheap_fdenum): New class to enumerate used
	fhandlers.
	* dtable.h (class dtable): Add cygheap_fdenum as friend class.
	* fhandler.h (fhandler_base::get_proc_fd_name): New virtual method
	to return a name for /proc/<pid>/fd.
	(fhandler_socket::get_proc_fd_name): Ditto.
	(fhandler_pipe::get_proc_fd_name): Ditto.
	(fhandler_virtual::opendir): Make virtual method.
	(fhandler_process::opendir): New method.
	* fhandler.cc (fhandler_base::get_proc_fd_name): New method.
	* fhandler_process.cc: Include ctype.h.
	(PROCESS_FD): Define.
	(process_listing): Add "fd".
	(fhandler_process::exists): Fix comment.  Return 1 in case of "fd"
	directory. Handle files below "fd".
	(fhandler_process::fstat): Drop "self" handling.  Set correct link
	count for directories.
	(fhandler_process::opendir): New method to handle "fd" directory.
	(fhandler_process::readdir): Add "fd" handling.
	(fhandler_process::open): Drop "self" handling.
	(fhandler_process::fill_filebuf): Ditto.  Add "fd" handling.  Fix
	"maps" output string.
	* fhandler_registry.cc (fhandler_registry::fstat): Set correct link
	count for directories.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): New method.
	* path.cc (symlink_info::set): Fix thinko.
	* pinfo.cc (_pinfo::commune_recv): Rename pathbuf to path throughout.
	Drop local path variable in PICOM_FIFO case.  Fix debug output.
	Close handles as early as possible. Add PICOM_FDS and PICOM_FD
	handling.
	(_pinfo::commune_send): Add PICOM_FDS and PICOM_FD handling.
	(_pinfo::fd): New method.
	(_pinfo::fds): New method.
	* pinfo.h (enum picom): Add PICOM_FDS and PICOM_FD.
	(_pinfo::fd): Declare.
	(_pinfo::fds): Declare.
	* pipe.cc (fhandler_pipe::get_proc_fd_name): New method.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2003, 2004 Red Hat, Inc.
@


1.25
log
@* fhandler_registry.cc (registry_listing): Correct typo.
(fhandler_registry::fill_filebuf): Set size of newly expanded buffer prior to
calling RegQueryValueEx.
@
text
@d239 1
a239 1
		buf->st_nlink = subkey_count;
@


1.24
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d51 1
a51 1
  "HKEY_PERFOMANCE_DATA",	// NT/2000/XP
d578 1
@


1.23
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002, 2003 Red Hat, Inc.
@


1.22
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d100 1
a100 1
  DWORD buf_size = MAX_PATH;
d155 1
a155 1
	  buf_size = MAX_PATH;
d163 1
a163 1
      buf_size = MAX_PATH;
d175 1
a175 1
	  buf_size = MAX_PATH;
d279 1
a279 1
  DWORD buf_size = MAX_PATH;
d327 1
a327 1
      buf_size = MAX_PATH;
d595 1
a595 1
  DWORD buf_size = MAX_PATH;
d607 1
a607 1
      buf_size = MAX_PATH;
d625 1
a625 1
  char component[MAX_PATH];
@


1.21
log
@Throughout, remove __d_u.__d_data fields from DIR structure.
* include/sys/dirent.h (dirent): Remvoe old_d_ino.
(DIR): Make __d_dirhash a 64 bit value.  Remove __d_data and __d_u.  Add
__flags.
* dir.cc (opendir_states): New enum.
(opendir): Clear new DIR __flags field.
(readdir): Fill in '.' and '..' entries if we hit EOF and we haven't seen them
already.  Nuke setting of old_d_ino.
(rewinddir): Reset DIR __flags field.
(seekdir64): Ditto.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove special
handling of "." and ".." since they are now handled automatically.
@
text
@d19 1
a20 1
#include "path.h"
d190 1
a190 1
fhandler_proc (FH_REGISTRY)
d195 1
a195 1
fhandler_registry::fstat (struct __stat64 *buf, path_conv *pc)
d197 1
a197 1
  fhandler_base::fstat (buf, pc);
d399 1
a399 1
fhandler_registry::open (path_conv * pc, int flags, mode_t mode)
d405 1
a405 1
  int res = fhandler_virtual::open (pc, flags, mode);
@


1.20
log
@* fhandler_disk_file.cc (fhandler_cygdrive::readdir): Do not change 'errno' if
end of directory condition is encountered as per SUSv2.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_process (fhandler_process::readdir): Ditto.
* fhandler_registry (fhandler_registry::readdir): Ditto.
@
text
@d294 1
a294 1
  if (dir->__d_u.__d_data.__handle == INVALID_HANDLE_VALUE
d298 1
a298 1
      dir->__d_u.__d_data.__handle = handle;
d300 1
a300 1
  if (dir->__d_u.__d_data.__handle == INVALID_HANDLE_VALUE)
d314 1
a314 1
    error = RegEnumValue ((HKEY) dir->__d_u.__d_data.__handle,
d319 1
a319 1
      RegEnumKeyEx ((HKEY) dir->__d_u.__d_data.__handle, dir->__d_position -
d332 2
a333 2
      RegCloseKey ((HKEY) dir->__d_u.__d_data.__handle);
      dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
d375 1
a375 1
  if (dir->__d_u.__d_data.__handle != INVALID_HANDLE_VALUE)
d377 2
a378 2
      (void) RegCloseKey ((HKEY) dir->__d_u.__d_data.__handle);
      dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
d388 2
a389 2
  if (dir->__d_u.__d_data.__handle != INVALID_HANDLE_VALUE &&
      RegCloseKey ((HKEY) dir->__d_u.__d_data.__handle) != ERROR_SUCCESS)
@


1.19
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d334 2
a335 1
      seterrno_from_win_error (__FILE__, __LINE__, error);
@


1.18
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@a13 1
#include <errno.h>
@


1.17
log
@Eliminate most unneeded this-> pointers throughout.
@
text
@d35 2
a36 2
static const __off32_t REG_ENUM_VALUES_MASK = 0x8000000;
static const __off32_t REG_POSITION_MASK = 0xffff;
d354 1
a354 1
__off64_t
d361 1
a361 1
fhandler_registry::seekdir (DIR * dir, __off64_t loc)
@


1.16
log
@* fhandler_registry.cc (fhandler_registry::exists): Fix off-by-one error when
inspecting path.
@
text
@d198 1
a198 1
  this->fhandler_base::fstat (buf, pc);
@


1.15
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d109 4
a112 2
  path += proc_len + registry_len + 2;
  if (*path == 0)
@


1.15.2.1
log
@merge from trunk
@
text
@d189 1
a189 1
fhandler_proc ()
@


1.15.2.2
log
@merge from trunk
@
text
@d109 2
a110 4
  path += proc_len + registry_len + 1;
  if (*path)
    path++;
  else
@


1.15.2.3
log
@merge from trunk
@
text
@d198 1
a198 1
  fhandler_base::fstat (buf, pc);
@


1.15.2.4
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d20 1
a21 1
#include "fhandler.h"
d196 1
a196 1
fhandler_registry::fstat (struct __stat64 *buf)
d198 1
a198 1
  fhandler_base::fstat (buf);
d399 1
a399 1
fhandler_registry::open (int flags, mode_t mode)
d405 1
a405 1
  int res = fhandler_virtual::open (flags, mode);
@


1.15.2.5
log
@merge from trunk
@
text
@d35 2
a36 2
static const _off_t REG_ENUM_VALUES_MASK = 0x8000000;
static const _off_t REG_POSITION_MASK = 0xffff;
d354 1
a354 1
_off64_t
d361 1
a361 1
fhandler_registry::seekdir (DIR * dir, _off64_t loc)
@


1.15.2.6
log
@merge from trunk
@
text
@d14 1
@


1.15.2.7
log
@merge from trunk
@
text
@d334 1
a334 2
      if (error != ERROR_NO_MORE_ITEMS)
	seterrno_from_win_error (__FILE__, __LINE__, error);
@


1.15.2.8
log
@merge from trunk
@
text
@d294 1
a294 1
  if (dir->__handle == INVALID_HANDLE_VALUE
d298 1
a298 1
      dir->__handle = handle;
d300 1
a300 1
  if (dir->__handle == INVALID_HANDLE_VALUE)
d314 1
a314 1
    error = RegEnumValue ((HKEY) dir->__handle,
d319 1
a319 1
      RegEnumKeyEx ((HKEY) dir->__handle, dir->__d_position -
d332 2
a333 2
      RegCloseKey ((HKEY) dir->__handle);
      dir->__handle = INVALID_HANDLE_VALUE;
d375 1
a375 1
  if (dir->__handle != INVALID_HANDLE_VALUE)
d377 2
a378 2
      (void) RegCloseKey ((HKEY) dir->__handle);
      dir->__handle = INVALID_HANDLE_VALUE;
d388 2
a389 2
  if (dir->__handle != INVALID_HANDLE_VALUE &&
      RegCloseKey ((HKEY) dir->__handle) != ERROR_SUCCESS)
@


1.14
log
@Use isdirsep rather than SLASH_P throughout.
* path.cc (iscygdrive): Disallow /cygdrive\x.
(normalize_posix_path): "Normalize" a windows path, if detected, rather than
converting to posix.
* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support and capability
checking for B230400 bitrate.
(fhandler_serial::tcgetattr): Add support for B230400 bitrate.
* include/sys/termios.h: Add B230400 definition for Posix support of 230.4Kbps.
@
text
@d3 1
a3 1
   Copyright 2002 Red Hat, Inc.
@


1.13
log
@* external.cc (cygwin_internal): Implement CW_CMDLINE.
* pinfo.h (SIGCOMMUNE): New signal type.
(commune_result): New structure for commune functions.
(picom): New enum for commune functions.
(_pinfo::hello_pid): New.  Pid who's communicating with me.
(_pinfo::tothem): New.  Handle of communicating pipe.
(_pinfo::fromthem): Ditto.
(_pinfo::commune_recv): Declare.
(_pinfo::commune_send): Declare.
(_pinfo::alive): Declare.
(_pinfo::cmdline): Declare.
(_pinfo::lock): Declare.
* pinfo.cc (set_myself): Initialize new _pinfo lock.
(_pinfo::alive): Define.  Determines if process still exists.
(_pinfo::commune_recv): Define.  Receive info from another cooperating process.
(_pinfo::commune_send): Define.  Send info to another cooperating process.
(_pinfo::cmdline): Define.  Determine command line of a given process.
* include/sys/cygwin.h (CW_CMDLINE): Define.
*sigproc.cc (talktome): Communicate with any processes who want to talk to me.
(wait_sig): Honor __SIGCOMMUNE.
* fhandler.cc (fhandler_virtual::fixup_after_exec): Declare.
* fhandler_proc.cc: Use malloc/free/realloc throughout rather than cmalloc
since buffers don't need to be propagated to subprocesses.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
(fhandler_virtual::fixup_after_exec): Define.
* fhandler_process.cc: Ditto for malloc/free/realloc.
(process_listin): Add "cmdline".
(fhandler_process::fill_filebuf): Implement PROCESS_CMDLINE.
* miscfuncs.cc (isalpha_array): New array populated with xor values for alpha
characters to switch from one case to another.
* string.h (cygwin_strcasematch): New asm implementation of case match.
* string.h (cygwin_nstrcasematch): New asm implementation of counted case
match.
@
text
@d117 1
a117 1
  if (SLASH_P (*file) && pathlen > 1)
d119 1
a119 1
  while (!SLASH_P (*file))
d243 1
a243 1
		  if (SLASH_P (*value_name) && pathlen > 1)
d245 1
a245 1
		  while (!SLASH_P (*value_name))
d432 1
a432 1
  if (SLASH_P (*file) && pathlen > 1)
d434 1
a434 1
  while (!SLASH_P (*file))
d628 1
a628 1
      while (*name && !SLASH_P (*name))
@


1.13.10.1
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d189 1
a189 1
fhandler_proc ()
@


1.13.10.2
log
@.
@
text
@d117 1
a117 1
  if (isdirsep (*file) && pathlen > 1)
d119 1
a119 1
  while (!isdirsep (*file))
d243 1
a243 1
		  if (isdirsep (*value_name) && pathlen > 1)
d245 1
a245 1
		  while (!isdirsep (*value_name))
d432 1
a432 1
  if (isdirsep (*file) && pathlen > 1)
d434 1
a434 1
  while (!isdirsep (*file))
d628 1
a628 1
      while (*name && !isdirsep (*name))
@


1.13.2.1
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
* fhandler.h (fhandler_serial::vmin_): Declare as size_t.
* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@d558 1
a558 1
      filebuf = (char *) cmalloc (HEAP_BUF, bufalloc);
d575 3
a577 8
	  if (filebuf)
	    {
	      cfree (filebuf);
	      filebuf = (char *) cmalloc (HEAP_BUF, bufalloc);
	    }
	  error =
	    RegQueryValueEx (handle, value_name, NULL, &type,
			     (BYTE *) filebuf, &size);
@


1.12
log
@* fhandler_registry.cc (fhandler_registry::close): Return any error result to
the caller.
* syscalls.cc (_close): Return result of fhandler::close to the caller.
@
text
@d558 1
a558 1
      filebuf = (char *) cmalloc (HEAP_BUF, bufalloc);
d575 3
a577 8
	  if (filebuf)
	    {
	      cfree (filebuf);
	      filebuf = (char *) cmalloc (HEAP_BUF, bufalloc);
	    }
	  error =
	    RegQueryValueEx (handle, value_name, NULL, &type,
			     (BYTE *) filebuf, &size);
@


1.11
log
@* debug.h (handle_list): Move here from debug.cc.  Add "inherit" flag
functionality.
* cygheap.cc (init_cheap): Move cygheap_max calculation to _csbrk.
(_csbrk): Reorganize to not assume first allocation is <= 1 page.
(cygheap_setup_for_child): Mark protected handle as inheritable.
* cygheap.h (cygheap_debug): New struct.
(init_cygheap): Add new structure when debugging.
* dcrt0.cc (dll_crt0_1): Remove call to debug_init.  Close ppid_handle here, if
appropriate.  Don't protect subproc_ready, since it is already protected in the
parent.  Call memory_init prior to ProtectHandle to ensure that cygheap is set
up.  Call debug_fixup_after_fork_exec when appropriate.
(_dll_crt0): Don't close ppid_handle here.
* debug.cc: Use cygheap debug structure rather than static elements throughout.
(add_handle): Don't issue a warning if attempt to protect handle in exactly the
same way from exactly the same place.  Add pid info to warning output.  Accept
additional argument controlling whether handle is to be inherited.  Add pid to
stored information.
(debug_fixup_after_fork_exec): Renamed from debug_fixup_after_fork.  Reorganize
to avoid erroneously skipping handles.
(mark_closed): Add pid info to warning output.
(setclexec): Rename from setclexec_pid.
* fhandler.cc (fhandler_base::get_default_fmode): Minor reorg.
(fhandler_base::fstat): Add debugging output.
(fhandler_base::set_inheritance): Call setclexec rather than setclexec_pid.
(fhandler_base::fork_fixup): Ditto.
* fhandler_console.cc (get_tty_stuff): Mark protected handle as inheritable.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* tty.cc (tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* fork.cc (fork_parent): Ditto.
(fork_child): Close protected handles with correct name.  Remove
debug_fixup_after_fork call.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Mark protected
handle as inheritable/non-inheritable, as appropriate.
* shared.cc (memory_init): Mark protected handle as inheritable.  Call
debug_init here.
* sigproc.cc (wait_sig): Close protected handle with correct name.
* spawn.cc (spawn_guts): Rename spr to subproc_ready and mark it as
inheritable.
* exceptions.cc (debugger_command): Try to run dumper.exe, if found.
* syscalls.cc (fstat64): Don't follow symlinks for path_conv lookup since path
is already resolved.
@
text
@d536 1
a536 1
  return 0;
@


1.10
log
@* autoload.cc (GetSecurityInfo): Define new autoload function.
(RegQueryInfoKeyA): Ditto.
* fhandler.h (fhandler_virtual::fill_filebuf): Change return type to bool.
(fhandler_proc::fill_filebuf): Ditto.
(fhandler_registry::fill_filebuf): Ditto.
(fhandler_process::fill_filebuf): Ditto.
(fhandler_registry::value_name): Add new member.
(fhandler_registry::close): Add new method.
(fhandler_process::p): Remove member.
* fhandler_proc.cc (fhandler_proc::open): Add set_nohandle after calling
superclass method.  Check return value of fill_filebuf.
(fhandler_proc::fill_filebuf): Change return type to bool.  Add return
statement.
* fhandler_process.cc (fhandler_process::open): Add set_nohandle after calling
superclass method.  Remove references to p.  Check return value of
fill_filebuf.
(fhandler_process::fill_filebuf): Change return type to bool.  Don't use
dereference operator on p.  Add return statement.
(fhandler_process::format_process_stat): Fix typo.
* fhandler_registry.cc: Add static open_key declaration.
(fhandler_registry::exists): Assume path is already normalised.  Try opening
the path as a key in its own right first, before reverting to enumerating
subkeys and values of the parent key.
(fhandler_registry::fstat): Add additional code to return more relevant
information about the registry key/value.
(fhandler_registry::readdir): Explicitly set desired access when opening
registry key.  Remove output of buf from debug_printf format string.
(fhandler_registry::open): Use set_io_handle to store registry key handle.  Set
value_name member.  Move code to read a value from the registry to
fill_filebuf.  Add call to fill_filebuf.
(fhandler_registry::close): New method.
(fhandler_registry::fill_filebuf): Change return type to bool.  Add code to
read a value from registry.
(fhandler_registry::open_key): Make function static.  Use KEY_READ as desired
access unless this is the last path component.  Check the return value of
RegOpenKeyEx for an error instead of hKey.
* fhandler_virtual.cc (fhandler_virtual::lseek): Check the return value of
fill_filebuf.
(fhandler_virtual::open): Remove call to set_nohandle.
(fhandler_virtual::fill_filebuf): Change return type to bool.  Add return
statement.
* security.cc (get_nt_object_attribute): New function.
(get_object_attribute): New function.
* security.h (get_object_attribute): New function declaration.
@
text
@d194 1
a194 1
fhandler_registry::fstat (struct __stat64 *buf, path_conv * pc)
@


1.9
log
@* fhandler_clipboard.c (fhandler_dev_clipboard::open): Force text mode.
* fhandler_console.cc (fhandler_console::open): *Really* force binary mode
rather than make it optional.
* fhandler_proc.cc (fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (set_flags): Add more debugging.
@
text
@d36 1
a36 1
static const __off32_t REG_POSITION_MASK    = 0xffff;
d52 1
a52 1
  "HKEY_PERFOMANCE_DATA",       // NT/2000/XP
d69 1
a69 1
static const int ROOT_KEY_COUNT = sizeof(registry_keys) / sizeof(HKEY);
d82 2
a83 1
static const int SPECIAL_DOT_FILE_COUNT = (sizeof(special_dot_files) / sizeof(const char *)) - 1;
d88 2
d109 1
a109 4
  path += proc_len + 1 + registry_len;

  while (SLASH_P (*path))
    path++;
d135 4
a138 7
  hKey = open_key (path, KEY_READ, true);
  if (hKey == (HKEY) INVALID_HANDLE_VALUE)
    return 0;

  while (ERROR_SUCCESS ==
	 (error = RegEnumKeyEx (hKey, index++, buf, &buf_size, NULL, NULL,
				NULL, NULL)) || (error == ERROR_MORE_DATA))
d140 17
a156 1
      if (pathmatch (buf, file))
d158 1
a158 1
	  file_type = 1;
d161 1
d163 14
a176 14
    }
  if (error != ERROR_NO_MORE_ITEMS)
    {
      seterrno_from_win_error (__FILE__, __LINE__, error);
      goto out;
    }
  index = 0;
  buf_size = MAX_PATH;
  while (ERROR_SUCCESS ==
	 (error = RegEnumValue (hKey, index++, buf, &buf_size, NULL, NULL,
				NULL, NULL)) || (error == ERROR_MORE_DATA))
    {
      if (pathmatch (buf, file) || (buf[0] == '\0' &&
				    pathmatch (file, DEFAULT_VALUE_NAME)))
d178 1
a178 1
	  file_type = -1;
a180 6
      buf_size = MAX_PATH;
    }
  if (error != ERROR_NO_MORE_ITEMS)
    {
      seterrno_from_win_error (__FILE__, __LINE__, error);
      goto out;
d189 1
a189 1
  fhandler_proc (FH_REGISTRY)
d194 1
a194 1
fhandler_registry::fstat (struct __stat64 *buf, path_conv *pc)
d217 55
d296 2
a297 2
      handle = open_key (path + 1);
      dir->__d_u.__d_data.__handle = handle;;
d303 2
a304 1
      strcpy (dir->__d_dirent->d_name, special_dot_files[dir->__d_position++]);
d319 2
a320 1
		    SPECIAL_DOT_FILE_COUNT, buf, &buf_size, NULL, NULL, NULL, NULL);
d348 1
a348 1
  syscall_printf ("%p = readdir (%p) (%s)", &dir->__d_dirent, dir, buf);
d397 1
a397 1
fhandler_registry::open (path_conv *pc, int flags, mode_t mode)
a398 3
  DWORD type, size;
  LONG error;
  HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
d401 1
d484 2
a485 2
  hKey = open_key (path, KEY_READ, true);
  if (hKey == (HKEY) INVALID_HANDLE_VALUE)
d490 3
d494 24
a517 1
    file = "";
d519 8
a526 1
  if (hKey != HKEY_PERFORMANCE_DATA)
d528 20
a547 1
      error = RegQueryValueEx (hKey, file, NULL, &type, NULL, &size);
d550 6
a555 3
	  seterrno_from_win_error (__FILE__, __LINE__, error);
	  res = -1;
	  goto out;
d560 2
a561 1
	RegQueryValueEx (hKey, file, NULL, NULL, (BYTE *) filebuf, &size);
d565 1
a565 2
	  res = 0;
	  goto out;
d581 3
a583 3
	    RegQueryValueEx (hKey, file, NULL, &type, (BYTE *) filebuf,
			     &size);
	  if (error != ERROR_SUCCESS && res != ERROR_MORE_DATA)
d585 6
a590 3
	      seterrno_from_win_error (__FILE__, __LINE__, error);
	      res = 0;
	      goto out;
d596 23
a618 20

  if (flags & O_APPEND)
    position = filesize;
  else
    position = 0;

success:
  res = 1;
  set_flags ((flags & ~O_TEXT) | O_BINARY);
  set_open_status ();
out:
  if (hKey != (HKEY) INVALID_HANDLE_VALUE)
    RegCloseKey (hKey);
  syscall_printf ("%d = fhandler_registry::open (%p, %d)", res, flags, mode);
  return res;
}

void
fhandler_registry::fill_filebuf ()
{
d622 2
a623 2
HKEY
fhandler_registry::open_key (const char *name, REGSAM access, bool isValue)
d644 7
a650 3
	  hKey = (HKEY) INVALID_HANDLE_VALUE;
	  LONG error = RegOpenKeyEx (hParentKey, component, 0, access, &hKey);
	  if (hKey == (HKEY) INVALID_HANDLE_VALUE)
d652 1
@


1.8
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d483 1
a483 1
  set_flags (flags & ~O_TEXT, O_BINARY);
@


1.8.2.1
log
@Merged changes from HEAD
@
text
@@


1.8.2.2
log
@Merged changes from HEAD
@
text
@d36 1
a36 1
static const __off32_t REG_POSITION_MASK = 0xffff;
d52 1
a52 1
  "HKEY_PERFOMANCE_DATA",	// NT/2000/XP
d69 1
a69 1
static const int ROOT_KEY_COUNT = sizeof (registry_keys) / sizeof (HKEY);
d82 1
a82 2
static const int SPECIAL_DOT_FILE_COUNT =
  (sizeof (special_dot_files) / sizeof (const char *)) - 1;
a86 2
static HKEY open_key (const char *name, REGSAM access, bool isValue);

d106 4
a109 1
  path += proc_len + registry_len + 2;
d135 7
a141 4
  hKey = open_key (path, KEY_READ, false);
  if (hKey != (HKEY) INVALID_HANDLE_VALUE)
    file_type = 1;
  else
d143 1
a143 8
      hKey = open_key (path, KEY_READ, true);
      if (hKey == (HKEY) INVALID_HANDLE_VALUE)
	return 0;

      while (ERROR_SUCCESS ==
	     (error = RegEnumKeyEx (hKey, index++, buf, &buf_size, NULL, NULL,
				    NULL, NULL))
	     || (error == ERROR_MORE_DATA))
d145 1
a145 10
	  if (pathmatch (buf, file))
	    {
	      file_type = 1;
	      goto out;
	    }
	  buf_size = MAX_PATH;
	}
      if (error != ERROR_NO_MORE_ITEMS)
	{
	  seterrno_from_win_error (__FILE__, __LINE__, error);
a147 1
      index = 0;
d149 14
a162 4
      while (ERROR_SUCCESS ==
	     (error = RegEnumValue (hKey, index++, buf, &buf_size, NULL, NULL,
				    NULL, NULL))
	     || (error == ERROR_MORE_DATA))
d164 1
a164 11
	  if (pathmatch (buf, file) || (buf[0] == '\0' &&
					pathmatch (file, DEFAULT_VALUE_NAME)))
	    {
	      file_type = -1;
	      goto out;
	    }
	  buf_size = MAX_PATH;
	}
      if (error != ERROR_NO_MORE_ITEMS)
	{
	  seterrno_from_win_error (__FILE__, __LINE__, error);
d167 6
d181 1
a181 1
fhandler_proc (FH_REGISTRY)
d186 1
a186 1
fhandler_registry::fstat (struct __stat64 *buf, path_conv * pc)
a208 55
  if (file_type != 0 && file_type != 2)
    {
      HKEY hKey;
      const char *path = get_name () + proc_len + registry_len + 2;
      hKey =
	open_key (path, STANDARD_RIGHTS_READ | KEY_QUERY_VALUE,
		  (file_type < 0) ? true : false);

      if (hKey != (HKEY) INVALID_HANDLE_VALUE)
	{
	  FILETIME ftLastWriteTime;
	  DWORD subkey_count;
	  if (ERROR_SUCCESS ==
	      RegQueryInfoKey (hKey, NULL, NULL, NULL, &subkey_count, NULL,
			       NULL, NULL, NULL, NULL, NULL,
			       &ftLastWriteTime))
	    {
	      to_timestruc_t (&ftLastWriteTime, &buf->st_mtim);
	      buf->st_ctim = buf->st_mtim;
	      time_as_timestruc_t (&buf->st_atim);
	      if (file_type > 0)
		buf->st_nlink = subkey_count;
	      else
		{
		  int pathlen = strlen (path);
		  const char *value_name = path + pathlen - 1;
		  if (SLASH_P (*value_name) && pathlen > 1)
		    value_name--;
		  while (!SLASH_P (*value_name))
		    value_name--;
		  value_name++;
		  DWORD dwSize;
		  if (ERROR_SUCCESS ==
		      RegQueryValueEx (hKey, value_name, NULL, NULL, NULL,
				       &dwSize))
		    buf->st_size = dwSize;
		}
	      __uid32_t uid;
	      __gid32_t gid;
	      if (get_object_attribute
		  ((HANDLE) hKey, SE_REGISTRY_KEY, &buf->st_mode, &uid,
		   &gid) == 0)
		{
		  buf->st_uid = uid;
		  buf->st_gid = gid;
		  buf->st_mode &= ~(S_IWUSR | S_IWGRP | S_IWOTH);
		  if (file_type > 0)
		    buf->st_mode |= S_IFDIR;
		  else
		    buf->st_mode &= NO_X;
		}
	    }
	  RegCloseKey (hKey);
	}
    }
d233 2
a234 2
      handle = open_key (path + 1, KEY_READ, false);
      dir->__d_u.__d_data.__handle = handle;
d240 1
a240 2
      strcpy (dir->__d_dirent->d_name,
	      special_dot_files[dir->__d_position++]);
d255 1
a255 2
		    SPECIAL_DOT_FILE_COUNT, buf, &buf_size, NULL, NULL, NULL,
		    NULL);
d283 1
a283 1
  syscall_printf ("%p = readdir (%p)", &dir->__d_dirent, dir);
d332 1
a332 1
fhandler_registry::open (path_conv * pc, int flags, mode_t mode)
d334 3
a338 1
  HKEY handle;
d421 2
a422 2
  handle = open_key (path, KEY_READ, true);
  if (handle == (HKEY) INVALID_HANDLE_VALUE)
a426 3

  set_io_handle (handle);

d428 1
a428 3
    value_name = cstrdup ("");
  else
    value_name = cstrdup (file);
d430 1
a430 1
  if (!fill_filebuf ())
d432 2
a433 29
      RegCloseKey (handle);
      res = 0;
      goto out;
    }

  if (flags & O_APPEND)
    position = filesize;
  else
    position = 0;

success:
  res = 1;
  set_flags ((flags & ~O_TEXT) | O_BINARY);
  set_open_status ();
out:
  syscall_printf ("%d = fhandler_registry::open (%p, %d)", res, flags, mode);
  return res;
}

int
fhandler_registry::close ()
{
  int res = fhandler_virtual::close ();
  if (res != 0)
    return res;
  HKEY handle = (HKEY) get_handle ();
  if (handle != (HKEY) INVALID_HANDLE_VALUE)
    {
      if (RegCloseKey (handle) != ERROR_SUCCESS)
d435 1
a435 1
	  __seterrno ();
d437 1
a437 24
	}
    }
  if (value_name)
    cfree (value_name);
  return 0;
}

bool
fhandler_registry::fill_filebuf ()
{
  DWORD type, size;
  LONG error;
  HKEY handle = (HKEY) get_handle ();
  if (handle != HKEY_PERFORMANCE_DATA)
    {
      error = RegQueryValueEx (handle, value_name, NULL, &type, NULL, &size);
      if (error != ERROR_SUCCESS)
	{
	  if (error != ERROR_FILE_NOT_FOUND)
	    {
	      seterrno_from_win_error (__FILE__, __LINE__, error);
	      return false;
	    }
	  goto value_not_found;
d442 1
a442 2
	RegQueryValueEx (handle, value_name, NULL, NULL, (BYTE *) filebuf,
			 &size);
d446 2
a447 1
	  return true;
d463 3
a465 3
	    RegQueryValueEx (handle, value_name, NULL, &type,
			     (BYTE *) filebuf, &size);
	  if (error != ERROR_SUCCESS && error != ERROR_MORE_DATA)
d467 3
a469 6
	      if (error != ERROR_FILE_NOT_FOUND)
		{
		  seterrno_from_win_error (__FILE__, __LINE__, error);
		  return true;
		}
	      goto value_not_found;
d475 20
a494 23
  return true;
value_not_found:
  DWORD buf_size = MAX_PATH;
  char buf[buf_size];
  int index = 0;
  while (ERROR_SUCCESS ==
	 (error = RegEnumKeyEx (handle, index++, buf, &buf_size, NULL, NULL,
				NULL, NULL)) || (error == ERROR_MORE_DATA))
    {
      if (pathmatch (buf, value_name))
	{
	  set_errno (EISDIR);
	  return false;
	}
      buf_size = MAX_PATH;
    }
  if (error != ERROR_NO_MORE_ITEMS)
    {
      seterrno_from_win_error (__FILE__, __LINE__, error);
      return false;
    }
  set_errno (ENOENT);
  return false;
d498 2
a499 2
static HKEY
open_key (const char *name, REGSAM access, bool isValue)
d520 3
a522 7
	  REGSAM effective_access = KEY_READ;
	  if ((strchr (name, '/') == NULL && isValue == true) || *name == 0)
	    effective_access = access;
	  LONG
	    error =
	    RegOpenKeyEx (hParentKey, component, 0, effective_access, &hKey);
	  if (error != ERROR_SUCCESS)
a523 1
	      hKey = (HKEY) INVALID_HANDLE_VALUE;
@


1.8.2.3
log
@Merged changes from HEAD
@
text
@d194 1
a194 1
fhandler_registry::fstat (struct __stat64 *buf, path_conv *pc)
@


1.8.2.4
log
@Merged changes from HEAD
@
text
@d536 1
a536 1
  return res;
@


1.7
log
@* fhandler_proc.cc (fhandler_proc::readdir): Set errno when no more files.
* fhandler_process.cc (fhandler_process::readdir): Ditto.
* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
@
text
@a13 1
#include <sys/fcntl.h>
d483 1
a484 1
  set_flags (flags);
@


1.6
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d269 1
a269 2
      if (error != ERROR_NO_MORE_ITEMS)
	seterrno_from_win_error (__FILE__, __LINE__, error);
@


1.5
log
@* fhandler.h (fhandler_virtual::exists): Eliminate path argument.
(fhandler_proc::exists): Ditto.
(fhandler_registry::exists): Ditto.
(fhandler_process::exists): Ditto.
* fhandler_proc.cc (fhandler_proc::exists): Ditto.  Use built-in name.
* fhandler_process.cc (fhandler_process::exists): Ditto.
(fstat): Ditto.
* fhandler_registry.cc (fhandler_registry::exists): Ditto.
(fhandler_registry::fstat): Ditto.
* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
* path.cc (path_conv::check): Ditto.  Add debugging.
* syscalls.cc (dup): Always call dup2 for error handling.
@
text
@d52 1
a52 1
  "HKEY_DYN_DATA",              // 95/98/Me
d127 6
a132 6
        if (path_prefix_p
            (registry_listing[i], path, strlen (registry_listing[i])))
          {
            file_type = 1;
            goto out;
          }
d141 2
a142 2
         (error = RegEnumKeyEx (hKey, index++, buf, &buf_size, NULL, NULL,
                                NULL, NULL)) || (error == ERROR_MORE_DATA))
d145 4
a148 4
        {
          file_type = 1;
          goto out;
        }
d159 2
a160 2
         (error = RegEnumValue (hKey, index++, buf, &buf_size, NULL, NULL,
                                NULL, NULL)) || (error == ERROR_MORE_DATA))
d163 5
a167 5
                                    pathmatch (file, DEFAULT_VALUE_NAME)))
        {
          file_type = -1;
          goto out;
        }
d226 1
a226 1
        goto out;
d251 2
a252 2
                          (dir->__d_position & ~REG_ENUM_VALUES_MASK) >> 16,
                          buf, &buf_size, NULL, NULL, NULL, NULL);
d256 1
a256 1
                    SPECIAL_DOT_FILE_COUNT, buf, &buf_size, NULL, NULL, NULL, NULL);
d270 1
a270 1
        seterrno_from_win_error (__FILE__, __LINE__, error);
d351 5
a355 5
        {
          set_errno (EEXIST);
          res = 0;
          goto out;
        }
d357 5
a361 5
        {
          set_errno (EISDIR);
          res = 0;
          goto out;
        }
d363 4
a366 4
        {
          flags |= O_DIROPEN;
          goto success;
        }
d380 21
a400 21
        if (path_prefix_p
            (registry_listing[i], path, strlen (registry_listing[i])))
          {
            if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
              {
                set_errno (EEXIST);
                res = 0;
                goto out;
              }
            else if (flags & O_WRONLY)
              {
                set_errno (EISDIR);
                res = 0;
                goto out;
              }
            else
              {
                flags |= O_DIROPEN;
                goto success;
              }
          }
d403 5
a407 5
        {
          set_errno (EROFS);
          res = 0;
          goto out;
        }
d409 5
a413 5
        {
          set_errno (ENOENT);
          res = 0;
          goto out;
        }
d436 5
a440 5
        {
          seterrno_from_win_error (__FILE__, __LINE__, error);
          res = -1;
          goto out;
        }
d444 1
a444 1
        RegQueryValueEx (hKey, file, NULL, NULL, (BYTE *) filebuf, &size);
d446 5
a450 5
        {
          seterrno_from_win_error (__FILE__, __LINE__, error);
          res = 0;
          goto out;
        }
d457 17
a473 17
        {
          bufalloc += 1000;
          if (filebuf)
            {
              cfree (filebuf);
              filebuf = (char *) cmalloc (HEAP_BUF, bufalloc);
            }
          error =
            RegQueryValueEx (hKey, file, NULL, &type, (BYTE *) filebuf,
                             &size);
          if (error != ERROR_SUCCESS && res != ERROR_MORE_DATA)
            {
              seterrno_from_win_error (__FILE__, __LINE__, error);
              res = 0;
              goto out;
            }
        }
d512 1
a512 1
        name++;
d516 1
a516 1
        name++;
d518 1
a518 1
        goto out;
d521 13
a533 13
        {
          hKey = (HKEY) INVALID_HANDLE_VALUE;
          LONG error = RegOpenKeyEx (hParentKey, component, 0, access, &hKey);
          if (hKey == (HKEY) INVALID_HANDLE_VALUE)
            {
              seterrno_from_win_error (__FILE__, __LINE__, error);
              return hKey;
            }
          if (parentOpened)
            RegCloseKey (hParentKey);
          hParentKey = hKey;
          parentOpened = true;
        }
d535 8
a542 8
        {
          for (int i = 0; registry_listing[i]; i++)
            if (pathmatch (component, registry_listing[i]))
              hKey = registry_keys[i];
          if (hKey == (HKEY) INVALID_HANDLE_VALUE)
            return hKey;
          hParentKey = hKey;
        }
@


1.4
log
@* autoload.cc: Add dynamic load statements for 'ZwQueryInformationProcess' and
'ZwQueryVirtualMemory'.
* fhandler.h: Change type of bufalloc and filesize members of fhandler_virtual
from int to size_t.  Change type of position member from __off32_t to
__off64_t.  Add new fileid member to fhandler_virtual class.  Make seekdir take
an __off64_t argument.  Make lseek take an __off64_t argument.  Add
fill_filebuf method to fhandler_virtual.  Add fill_filebuf method to
fhandler_proc.  Add fill_filebuf method to fhandler_registry.  Add fill_filebuf
method to fhandler_process.  Add saved_pid and saved_p members to
fhandler_process.
* fhandler_proc.cc (proc_listing_array): Add 'loadavg', 'meminfo', and 'stat'.
(proc_fhandlers array): Ditto.
(fhandler_proc::open): Use fill_filebuf to flesh out the file contents.
(fhandler_proc::fill_filebuf): New method.
(fhandler_proc::format_proc_meminfo): Ditto.
(fhandler_proc::format_proc_stat): Ditto.
(fhandler_proc::format_proc_uptime): Ditto.
* fhandler_process.cc (process_listing): Add 'stat' and 'statm'.
(fhandler_process::fstat): Find the _pinfo structure for the process named in
the filename.  Return ENOENT if the process is no longer around.  Set the gid
and uid fields of the stat structure.
(fhandler_process::open): Store pid and pointer to _pinfo structure in
saved_pid and saved_p respectively.  Use fill_filebuf to flesh out file
contents.
(fhandler_proc::fill_filebuf): New method.
(format_process_stat): New function.
(format_process_status): Ditto.
(format_process_statm): Ditto.
(get_process_state): Ditto.
(get_mem_values): Ditto.
* fhandler_registry.cc (fhandler_registry::seekdir): Change argument type from
__off32_t to __off64_t.
(fhandler_registry::fill_filebuf): New method.
* fhandler_virtual.cc (fhandler_virtual::seekdir): Change argument type from
__off32_t to __off64_t.
(fhandler_virtual::lseek): Ditto.
(fhandler_virtual::fill_filebuf): New method.
(fhandler_virtual::fhandler_virtual): Initialise fileid to -1.
* wincap.cc: Set flag has_process_io_counters appropriately.
* wincap.h: Add flag has_process_io_counters.
@
text
@d96 1
a96 1
fhandler_registry::exists (const char *path)
d105 1
d191 1
a191 1
  int file_type = exists (get_name ());
@


1.3
log
@* net.cc (getdomainname): Change second argument of getdomainname to size_t.
* fhandler_proc.cc (proc_listing): Add '.' and '..' to directory listing.
(fhandler_proc::open): Change use of mode to flags.  If the file does not exist
already, fail with EROFS if O_CREAT flag is set.  Change EROFS error to EACCES
error when writing to a file.  Use cmalloc to allocate memory for filebuf.
(fhandler_proc::close): Use cfree to free filebuf.
(fhandler_proc::get_proc_fhandler): Properly detect attempts to access unknown
subdir.
* fhandler_process.cc (process_listing): Add '.' and '..' to directory listing.
(fhandler_process::open): Use cmalloc to allocate memory for filebuf.
(fhandler_process::close): Use cfree to free filebuf.
* fhandler_registry.cc (registry_listing): Add .  and '..' to directory
listing.
(fhandler_registry::open): Move check for open for writing before open_key.
Use cmalloc to allocate memory for filebuf.
(fhandler_registry::close): Use cfree to free filebuf.
(fhandler_registry::telldir): Use lower 16 bits of __d_position as position in
directory.
(fhandler_registry::seekdir): Ditto.
* fhandler_virtual.cc (fhandler_virtual::write): Change EROFS error to EACCES
error.
(fhandler_virtual::open): Set the NOHANDLE flag.
(fhandler_virtual::dup): Add call to fhandler_base::dup.  Allocate child's
filebuf using cmalloc.  Copy filebuf from parent to child.
(fhandler_virtual::close): Use cfree to free filebuf.
(fhandler_virtual::~fhandler_virtual): Ditto.
(from Chris Faylor <cgf@@redhat.com>).
(fhandler_registry::readdir): Add support for '.' and '..' files in
subdirectories of /proc/registry.
* path.cc (path_conv::check): Do not return ENOENT if a file is not found in
/proc.
@
text
@d295 1
a295 1
fhandler_registry::seekdir (DIR * dir, __off32_t loc)
d491 5
@


1.2
log
@* fhandler_proc.cc (fhandler_proc::fstat): Use fhandler name rather than
path_conv name.
(fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::fstat): Use fhandler name rather than
path_conv name.
(fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::fstat): Use fhandler name rather
than path_conv name.
(fhandler_registry::open): Ditto.
* path.cc (path_conv::check): Don't copy posix path when virtual.
(mount_info::conv_to_win32_path): Don't zero string when isproc.  Just derive
normal windows path.
* path.h (path_conv::clear_normalized_path): Declare new method.
* path.cc (path_conv::clear_normalized_path): Define new method.
* dtable.cc (build_fhandler_from_name): Clear normalized path when finished to
conserve space.
@
text
@d23 2
d37 1
d43 4
a46 1
static const char *registry_listing[] = {
d57 4
a60 1
static const HKEY registry_keys[] = {
d72 13
d238 6
d254 2
a255 2
      RegEnumKeyEx ((HKEY) dir->__d_u.__d_data.__handle, dir->__d_position,
                    buf, &buf_size, NULL, NULL, NULL, NULL);
d291 1
a291 1
  return dir->__d_position & REG_ENUM_VALUES_MASK;
d301 1
a301 1
  while (loc > dir->__d_position)
d349 1
a349 1
      if ((mode & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
d355 1
a355 1
      else if (mode & O_WRONLY)
d382 1
a382 1
            if ((mode & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
d388 1
a388 1
            else if (mode & O_WRONLY)
d401 1
a401 1
      if ((mode & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
d415 1
a415 2
  hKey = open_key (path, KEY_READ, true);
  if (hKey == (HKEY) INVALID_HANDLE_VALUE)
d417 1
d421 3
a423 1
  if (mode & O_WRONLY)
a424 1
      set_errno (EROFS);
d441 1
a441 1
      filebuf = new char[bufalloc];
d460 2
a461 2
              delete filebuf;
              filebuf = new char[bufalloc];
@


1.1
log
@add new files
@
text
@d164 1
a164 1
fhandler_registry::fstat (struct __stat64 *buf, path_conv *path)
d166 1
a166 1
  this->fhandler_base::fstat (buf, path);
d318 1
a318 1
  path = (const char *) *pc + proc_len + 1 + registry_len;
@

