head	1.256;
access;
symbols
	cygwin-1_7_35-release:1.256
	cygwin-1_7_34-release:1.248
	cygwin-1_7_33-release:1.191.2.1
	cygwin-1_7_32-release:1.191
	cygwin-1_7_31-release:1.191
	cygwin-1_7_30-release:1.191
	cygwin-1_7_29-release:1.191
	cygwin-1_7_29-release-branchpoint:1.191.0.2
	cygwin-pre-user-db:1.191
	cygwin-1_7_28-release:1.191
	cygwin-1_7_27-release:1.191
	cygwin-1_7_26-release:1.191
	cygwin-1_7_25-release:1.191
	cygwin-1_7_24-release:1.191
	cygwin-1_7_23-release:1.191
	cygwin-1_7_22-release:1.191
	cygwin-1_7_21-release:1.191
	cygwin-1_7_20-release:1.191
	cygwin-1_7_19-release:1.191
	cygwin-64bit-postmerge:1.191
	cygwin-64bit-premerge-branch:1.190.0.2
	cygwin-64bit-premerge:1.190
	cygwin-1_7_18-release:1.190
	post-ptmalloc3:1.188.2.4
	pre-ptmalloc3:1.188.2.4
	cygwin-1_7_17-release:1.188
	cygwin-64bit-branch:1.188.0.2
	cygwin-1_7_16-release:1.188
	cygwin-1_7_15-release:1.188
	cygwin-1_7_14_2-release:1.188
	cygwin-1_7_14-release:1.188
	cygwin-1_7_12-release:1.188
	cygwin-1_7_11-release:1.188
	cygwin-1_7_10-release:1.183
	signal-rewrite:1.183.0.2
	pre-notty:1.183
	cygwin-1_7_9-release:1.175
	cv-post-1_7_9:1.175.0.2
	cygwin-1_7_8-release:1.175
	cygwin-1_7_7-release:1.172
	cygwin-1_7_5-release:1.172
	cygwin-1_7_4-release:1.172
	cygwin-1_7_3-release:1.172
	cygwin-1_7_2-release:1.172
	fifo_doover3:1.172.0.2
	cygwin-1_7_1-release:1.171
	prefifo:1.168
	cv-branch-2:1.168.0.2
	pre-ripout-set_console_state_for_spawn:1.160
	EOL_registry_mounts:1.159
	preoverlapped:1.147
	drop_9x_support_start:1.145
	cr-0x5f1:1.143.0.4
	cv-branch:1.143.0.2
	pre-ptymaster-archetype:1.143
	cr-0x3b58:1.142.0.4
	cr-0x5ef:1.142.0.2
	after-mmap-privanon-noreserve:1.142
	after-mmap-revamp:1.142
	before-mmap-revamp:1.142
	cgf-more-exit-sync:1.142
	post_wait_sig_exit:1.142
	pre_wait_sig_exit:1.141
	reparent-point:1.132
	noreparent:1.132.0.2
	cr-0x5e6:1.127.0.2
	cr-0x9e:1.124.0.6
	cr-0x9d:1.124.0.4
	cgf-deleteme:1.124.0.2
	pre-sigrewrite:1.122
	corinna-01:1.121
	cr-0x9c:1.118.0.4
	cr-0x9b:1.118.0.2
	cr-0x99:1.117
	Z-emcb-cygwin_daemon:1.117.0.2
	w32api-2_2:1.111
	mingw-runtime-2_4:1.111
	pre-cgf-merge:1.119
	cgf-dev-branch:1.97.0.4
	predaemon:1.63
	cygwin_daemon_merge_HEAD:1.63
	pregp02r1:1.63.0.2
	cygnus_cvs_20020108_pre:1.58
	Z-cygwin_daemon_merge-new_HEAD:1.92
	Z-cygwin_daemon_merge_HEAD:1.92
	cygwin_daemon:1.51.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.256
date	2015.02.28.12.12.34;	author corinna;	state Exp;
branches;
next	1.255;

1.255
date	2015.02.27.14.03.29;	author corinna;	state Exp;
branches;
next	1.254;

1.254
date	2015.02.27.12.59.09;	author corinna;	state Exp;
branches;
next	1.253;

1.253
date	2015.02.25.08.44.54;	author corinna;	state Exp;
branches;
next	1.252;

1.252
date	2015.02.24.20.52.57;	author corinna;	state Exp;
branches;
next	1.251;

1.251
date	2015.02.23.20.51.12;	author corinna;	state Exp;
branches;
next	1.250;

1.250
date	2015.02.20.15.13.46;	author corinna;	state Exp;
branches;
next	1.249;

1.249
date	2015.02.12.16.55.38;	author corinna;	state Exp;
branches;
next	1.248;

1.248
date	2015.01.21.20.40.33;	author corinna;	state Exp;
branches;
next	1.247;

1.247
date	2015.01.14.11.13.23;	author corinna;	state Exp;
branches;
next	1.246;

1.246
date	2015.01.13.09.06.53;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2015.01.08.17.08.47;	author corinna;	state Exp;
branches;
next	1.244;

1.244
date	2014.12.02.11.30.04;	author corinna;	state Exp;
branches;
next	1.243;

1.243
date	2014.12.02.11.26.22;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2014.12.02.10.49.47;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2014.12.02.10.28.42;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2014.11.27.16.49.41;	author corinna;	state Exp;
branches;
next	1.239;

1.239
date	2014.11.26.19.46.59;	author corinna;	state Exp;
branches;
next	1.238;

1.238
date	2014.11.17.10.09.01;	author corinna;	state Exp;
branches;
next	1.237;

1.237
date	2014.11.12.11.19.08;	author corinna;	state Exp;
branches;
next	1.236;

1.236
date	2014.10.30.16.07.04;	author corinna;	state Exp;
branches;
next	1.235;

1.235
date	2014.10.27.11.33.53;	author corinna;	state Exp;
branches;
next	1.234;

1.234
date	2014.09.05.11.47.33;	author corinna;	state Exp;
branches;
next	1.233;

1.233
date	2014.09.05.09.46.26;	author corinna;	state Exp;
branches;
next	1.232;

1.232
date	2014.08.31.19.33.19;	author corinna;	state Exp;
branches;
next	1.231;

1.231
date	2014.08.31.18.18.49;	author corinna;	state Exp;
branches;
next	1.230;

1.230
date	2014.08.31.14.16.04;	author corinna;	state Exp;
branches;
next	1.229;

1.229
date	2014.08.22.09.21.33;	author corinna;	state Exp;
branches;
next	1.228;

1.228
date	2014.08.04.15.50.42;	author corinna;	state Exp;
branches;
next	1.227;

1.227
date	2014.07.30.14.23.53;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2014.07.29.08.53.13;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2014.07.21.09.55.52;	author corinna;	state Exp;
branches;
next	1.224;

1.224
date	2014.07.14.13.33.20;	author corinna;	state Exp;
branches;
next	1.223;

1.223
date	2014.06.25.09.10.50;	author corinna;	state Exp;
branches;
next	1.222;

1.222
date	2014.06.18.17.41.52;	author corinna;	state Exp;
branches;
next	1.221;

1.221
date	2014.05.22.14.50.24;	author corinna;	state Exp;
branches;
next	1.220;

1.220
date	2014.05.22.09.47.23;	author corinna;	state Exp;
branches;
next	1.219;

1.219
date	2014.05.14.11.27.47;	author corinna;	state Exp;
branches;
next	1.218;

1.218
date	2014.05.13.16.07.50;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2014.05.08.19.33.07;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2014.05.07.14.49.54;	author corinna;	state Exp;
branches;
next	1.215;

1.215
date	2014.05.07.12.07.12;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2014.05.06.12.28.33;	author corinna;	state Exp;
branches;
next	1.213;

1.213
date	2014.05.06.12.02.48;	author corinna;	state Exp;
branches;
next	1.212;

1.212
date	2014.04.22.10.36.35;	author corinna;	state Exp;
branches;
next	1.211;

1.211
date	2014.04.12.11.10.13;	author corinna;	state Exp;
branches;
next	1.210;

1.210
date	2014.03.12.17.36.56;	author corinna;	state Exp;
branches;
next	1.209;

1.209
date	2014.03.12.15.46.07;	author corinna;	state Exp;
branches;
next	1.208;

1.208
date	2014.03.07.20.38.48;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2014.03.06.18.54.08;	author corinna;	state Exp;
branches;
next	1.206;

1.206
date	2014.02.28.19.10.40;	author corinna;	state Exp;
branches;
next	1.205;

1.205
date	2014.02.28.11.37.02;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2014.02.27.12.57.27;	author corinna;	state Exp;
branches;
next	1.203;

1.203
date	2014.02.22.19.38.12;	author corinna;	state Exp;
branches;
next	1.202;

1.202
date	2014.02.21.10.01.00;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2014.02.17.15.36.33;	author corinna;	state Exp;
branches;
next	1.200;

1.200
date	2014.02.14.14.25.19;	author corinna;	state Exp;
branches;
next	1.199;

1.199
date	2014.02.13.14.04.03;	author corinna;	state Exp;
branches;
next	1.198;

1.198
date	2014.02.12.13.01.10;	author corinna;	state Exp;
branches;
next	1.197;

1.197
date	2014.02.11.17.45.09;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2014.02.11.11.51.29;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2014.02.10.20.28.32;	author corinna;	state Exp;
branches;
next	1.194;

1.194
date	2014.02.10.20.16.55;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2014.02.10.18.28.51;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2014.02.09.19.44.56;	author corinna;	state Exp;
branches;
next	1.191;

1.191
date	2013.04.23.09.44.34;	author corinna;	state Exp;
branches
	1.191.2.1;
next	1.190;

1.190
date	2013.01.21.04.38.29;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2012.10.27.12.09.38;	author ktietz;	state Exp;
branches;
next	1.188;

1.188
date	2012.02.14.11.27.43;	author corinna;	state Exp;
branches
	1.188.2.1;
next	1.187;

1.187
date	2012.02.10.20.56.22;	author corinna;	state Exp;
branches;
next	1.186;

1.186
date	2012.02.09.09.04.10;	author corinna;	state Exp;
branches;
next	1.185;

1.185
date	2012.02.08.17.51.34;	author corinna;	state Exp;
branches;
next	1.184;

1.184
date	2012.02.08.17.45.43;	author corinna;	state Exp;
branches;
next	1.183;

1.183
date	2011.06.06.05.02.13;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2011.05.16.17.58.21;	author corinna;	state Exp;
branches;
next	1.181;

1.181
date	2011.05.16.15.12.35;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2011.04.29.07.34.05;	author corinna;	state Exp;
branches;
next	1.179;

1.179
date	2011.04.28.09.53.11;	author corinna;	state Exp;
branches;
next	1.178;

1.178
date	2011.04.19.10.15.09;	author corinna;	state Exp;
branches;
next	1.177;

1.177
date	2011.03.31.15.33.53;	author corinna;	state Exp;
branches;
next	1.176;

1.176
date	2011.03.29.10.46.04;	author corinna;	state Exp;
branches;
next	1.175;

1.175
date	2010.09.28.14.49.31;	author corinna;	state Exp;
branches
	1.175.2.1;
next	1.174;

1.174
date	2010.09.28.14.40.18;	author corinna;	state Exp;
branches;
next	1.173;

1.173
date	2010.09.26.15.45.10;	author corinna;	state Exp;
branches;
next	1.172;

1.172
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.171;

1.171
date	2009.10.31.13.24.06;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2009.10.18.09.07.13;	author corinna;	state Exp;
branches;
next	1.169;

1.169
date	2009.10.13.10.23.31;	author corinna;	state Exp;
branches;
next	1.168;

1.168
date	2009.05.06.11.52.20;	author corinna;	state Exp;
branches;
next	1.167;

1.167
date	2009.01.26.13.03.49;	author corinna;	state Exp;
branches;
next	1.166;

1.166
date	2008.12.20.09.35.18;	author corinna;	state Exp;
branches;
next	1.165;

1.165
date	2008.09.11.04.34.24;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2008.07.24.18.25.52;	author corinna;	state Exp;
branches;
next	1.163;

1.163
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.162;

1.162
date	2008.07.11.10.00.36;	author corinna;	state Exp;
branches;
next	1.161;

1.161
date	2008.07.09.11.58.38;	author corinna;	state Exp;
branches;
next	1.160;

1.160
date	2008.04.07.18.45.59;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2008.04.01.13.22.47;	author corinna;	state Exp;
branches;
next	1.158;

1.158
date	2008.03.12.12.41.49;	author corinna;	state Exp;
branches;
next	1.157;

1.157
date	2008.02.25.18.32.23;	author corinna;	state Exp;
branches;
next	1.156;

1.156
date	2008.02.14.16.47.11;	author corinna;	state Exp;
branches;
next	1.155;

1.155
date	2008.02.01.12.37.51;	author corinna;	state Exp;
branches;
next	1.154;

1.154
date	2007.12.05.15.10.19;	author corinna;	state Exp;
branches;
next	1.153;

1.153
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2007.08.21.17.38.27;	author corinna;	state Exp;
branches;
next	1.151;

1.151
date	2007.08.21.12.37.39;	author corinna;	state Exp;
branches;
next	1.150;

1.150
date	2007.08.16.15.07.42;	author corinna;	state Exp;
branches;
next	1.149;

1.149
date	2007.07.19.08.36.32;	author corinna;	state Exp;
branches;
next	1.148;

1.148
date	2007.07.16.20.01.15;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2007.02.23.15.15.50;	author corinna;	state Exp;
branches;
next	1.146;

1.146
date	2007.02.22.11.17.01;	author corinna;	state Exp;
branches;
next	1.145;

1.145
date	2006.12.12.16.27.32;	author corinna;	state Exp;
branches;
next	1.144;

1.144
date	2006.07.25.19.23.23;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2006.02.07.15.49.08;	author corinna;	state Exp;
branches
	1.143.2.1;
next	1.142;

1.142
date	2005.09.14.14.27.56;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2005.07.06.20.05.03;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2005.07.03.02.40.30;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2005.06.21.20.09.31;	author corinna;	state Exp;
branches;
next	1.138;

1.138
date	2005.06.07.19.31.42;	author corinna;	state Exp;
branches;
next	1.137;

1.137
date	2005.05.02.03.50.09;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2005.04.03.13.06.43;	author corinna;	state Exp;
branches;
next	1.135;

1.135
date	2005.04.03.08.45.21;	author corinna;	state Exp;
branches;
next	1.134;

1.134
date	2005.01.12.22.40.46;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2004.11.20.19.09.18;	author phumblet;	state Exp;
branches;
next	1.132;

1.132
date	2004.10.28.01.46.01;	author phumblet;	state Exp;
branches;
next	1.131;

1.131
date	2004.10.07.21.28.57;	author corinna;	state Exp;
branches;
next	1.130;

1.130
date	2004.10.02.02.20.21;	author phumblet;	state Exp;
branches;
next	1.129;

1.129
date	2004.09.03.01.53.12;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2004.05.28.19.50.07;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2004.05.17.16.06.01;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2004.02.09.04.04.24;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2004.02.06.10.37.37;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2003.12.23.16.26.31;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2003.11.14.23.40.06;	author rbcollins;	state Exp;
branches;
next	1.121;

1.121
date	2003.09.27.01.56.36;	author phumblet;	state Exp;
branches;
next	1.120;

1.120
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2003.09.16.09.24.52;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2003.09.10.21.01.40;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2003.08.17.17.50.40;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2003.07.14.17.04.21;	author corinna;	state Exp;
branches;
next	1.115;

1.115
date	2003.06.30.13.07.36;	author corinna;	state Exp;
branches;
next	1.114;

1.114
date	2003.06.16.03.24.12;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2003.06.09.13.29.12;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2003.02.27.17.41.15;	author corinna;	state Exp;
branches;
next	1.111;

1.111
date	2003.02.06.14.01.54;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2003.01.27.00.31.30;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2003.01.27.00.16.01;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2003.01.26.06.42.40;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2003.01.26.05.38.37;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2003.01.25.16.34.32;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2003.01.25.10.36.46;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2003.01.24.03.53.46;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2003.01.21.06.58.11;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2003.01.21.05.07.28;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2003.01.20.02.57.54;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2003.01.17.05.43.43;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2003.01.17.05.24.28;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2003.01.17.05.18.30;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2002.12.10.12.43.49;	author corinna;	state Exp;
branches
	1.97.4.1;
next	1.96;

1.96
date	2002.11.27.02.26.44;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2002.11.25.15.11.39;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2002.11.20.17.10.05;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2002.09.30.04.35.18;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2002.07.29.12.51.52;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2002.07.01.16.37.46;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2002.07.01.15.50.02;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2002.07.01.03.57.17;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2002.06.29.23.45.07;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2002.06.29.22.05.30;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2002.06.29.06.50.17;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2002.06.29.03.14.12;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2002.06.29.02.36.08;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2002.06.27.20.44.27;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2002.06.24.15.40.57;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2002.06.21.05.01.17;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.19.15.27.27;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.19.13.56.34;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2002.06.16.05.26.14;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2002.06.15.01.17.45;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2002.06.14.21.46.19;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2002.06.14.20.36.42;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2002.06.14.18.01.21;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.13.03.04.50;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.12.05.13.54;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.06.11.17.51;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.03.17.04.03;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.02.06.07.01;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2002.05.29.15.04.27;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2002.05.28.14.10.52;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2002.02.17.04.59.55;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2002.02.14.21.20.06;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2002.02.10.11.15.56;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2001.11.05.06.09.09;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2001.10.29.11.53.52;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2001.10.22.18.31.00;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.15.23.39.33;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2001.10.13.01.35.15;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.09.23.28.24;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2001.10.01.04.10.07;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2001.09.11.20.01.01;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2001.09.07.21.32.05;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2001.07.09.09.05.17;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.24.22.26.53;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.10.10.00.20;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.09.21.25.55;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.04.14.29.54;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.29.20.43.40;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.20.08.10.47;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.16.21.53.18;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.15.19.23.31;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2001.04.30.18.27.24;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.30.18.21.48;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.25.12.54.21;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.25.09.43.25;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.18.21.10.14;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.18.21.11.25;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.28.14.14.03;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.16.09.53.26;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.15.21.14.27;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.15.21.04.02;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.15.00.13.09;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.28.05.41.43;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.27.18.53.56;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.08.02.56.55;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.09.02.33.47;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.29.16.24.41;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.27.17.30.48;	author dj;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.22.16.43.54;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.02.10.17.44;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.02.00.00.17;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.01.17.30.35;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.28.17.42.28;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.24.17.37.52;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.19.17.36.30;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.17.11.34.33;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.16.19.36.07;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.01.05.57.54;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.30.00.38.51;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.22.00.54.22;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.19.20.03.51;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.191.2.1
date	2014.11.13.12.53.08;	author corinna;	state Exp;
branches;
next	;

1.188.2.1
date	2012.08.13.20.04.35;	author corinna;	state Exp;
branches;
next	1.188.2.2;

1.188.2.2
date	2012.10.27.12.11.51;	author ktietz;	state Exp;
branches;
next	1.188.2.3;

1.188.2.3
date	2012.12.10.11.45.51;	author corinna;	state Exp;
branches;
next	1.188.2.4;

1.188.2.4
date	2013.01.21.13.52.11;	author corinna;	state Exp;
branches;
next	;

1.175.2.1
date	2011.03.14.21.09.52;	author corinna;	state Exp;
branches;
next	;

1.143.2.1
date	2006.07.06.13.40.58;	author corinna;	state Exp;
branches;
next	;

1.97.4.1
date	2003.01.24.04.04.20;	author cgf;	state Exp;
branches;
next	1.97.4.2;

1.97.4.2
date	2003.01.25.16.37.00;	author cgf;	state Exp;
branches;
next	1.97.4.3;

1.97.4.3
date	2003.01.26.05.39.17;	author cgf;	state Exp;
branches;
next	1.97.4.4;

1.97.4.4
date	2003.01.26.06.43.33;	author cgf;	state Exp;
branches;
next	1.97.4.5;

1.97.4.5
date	2003.01.27.00.16.44;	author cgf;	state Exp;
branches;
next	1.97.4.6;

1.97.4.6
date	2003.01.27.00.32.04;	author cgf;	state Exp;
branches;
next	1.97.4.7;

1.97.4.7
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.97.4.8;

1.97.4.8
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.97.4.9;

1.97.4.9
date	2003.03.01.02.05.42;	author cgf;	state Exp;
branches;
next	1.97.4.10;

1.97.4.10
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.97.4.11;

1.97.4.11
date	2003.08.06.03.58.58;	author cgf;	state Exp;
branches;
next	1.97.4.12;

1.97.4.12
date	2003.08.27.20.19.55;	author cgf;	state Exp;
branches;
next	1.97.4.13;

1.97.4.13
date	2003.09.11.04.47.23;	author cgf;	state Exp;
branches;
next	;

1.51.2.1
date	2001.10.02.12.09.56;	author rbcollins;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2002.01.04.03.56.11;	author rbcollins;	state Exp;
branches;
next	1.51.2.3;

1.51.2.3
date	2002.02.28.12.53.28;	author rbcollins;	state Exp;
branches;
next	1.51.2.4;

1.51.2.4
date	2002.06.13.14.34.14;	author rbcollins;	state Exp;
branches;
next	1.51.2.5;

1.51.2.5
date	2002.06.15.10.26.32;	author rbcollins;	state Exp;
branches;
next	1.51.2.6;

1.51.2.6
date	2002.06.18.00.17.09;	author scottc;	state Exp;
branches;
next	1.51.2.7;

1.51.2.7
date	2002.06.19.20.58.59;	author scottc;	state Exp;
branches;
next	1.51.2.8;

1.51.2.8
date	2002.06.21.12.18.52;	author scottc;	state Exp;
branches;
next	1.51.2.9;

1.51.2.9
date	2002.06.25.10.50.38;	author scottc;	state Exp;
branches;
next	1.51.2.10;

1.51.2.10
date	2002.06.28.18.15.48;	author scottc;	state Exp;
branches;
next	1.51.2.11;

1.51.2.11
date	2002.06.29.18.25.44;	author scottc;	state Exp;
branches;
next	1.51.2.12;

1.51.2.12
date	2002.06.30.13.28.09;	author scottc;	state Exp;
branches;
next	1.51.2.13;

1.51.2.13
date	2002.07.01.13.53.40;	author scottc;	state Exp;
branches;
next	1.51.2.14;

1.51.2.14
date	2002.07.02.10.58.20;	author scottc;	state Exp;
branches;
next	1.51.2.15;

1.51.2.15
date	2002.07.30.13.31.46;	author scottc;	state Exp;
branches;
next	1.51.2.16;

1.51.2.16
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	1.51.2.17;

1.51.2.17
date	2002.09.22.10.01.29;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.256
log
@	* uinfo.cc (pwdgrp::add_line): Return NULL if parsing a line failed.
	(pwdgrp::add_account_post_fetch): Check return value from add_line and
	return NULL if add_line returns NULL.
@
text
@/* uinfo.cc: user info (uid, gid, etc...)

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <iptypes.h>
#include <lm.h>
#include <ntsecapi.h>
#include <wininet.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <sys/cygwin.h>
#include "cygerrno.h"
#include "pinfo.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "shared_info.h"
#include "registry.h"
#include "child_info.h"
#include "environ.h"
#include "tls_pbuf.h"
#include "miscfuncs.h"
#include "ntdll.h"
#include "ldap.h"
#include "cygserver_pwdgrp.h"

/* Initialize the part of cygheap_user that does not depend on files.
   The information is used in shared.cc for the user shared.
   Final initialization occurs in uinfo_init */
void
cygheap_user::init ()
{
  WCHAR user_name[UNLEN + 1];
  DWORD user_name_len = UNLEN + 1;

  /* This code is only run if a Cygwin process gets started by a native
     Win32 process.  We try to get the username from the environment,
     first USERNAME (Win32), then USER (POSIX).  If that fails (which is
     very unlikely), it only has an impact if we don't have an entry in
     /etc/passwd for this user either.  In that case the username sticks
     to "unknown".  Since this is called early in initialization, and
     since we don't want pull in a dependency to any other DLL except
     ntdll and kernel32 at this early stage, don't call GetUserName,
     GetUserNameEx, NetWkstaUserGetInfo, etc. */
  if (GetEnvironmentVariableW (L"USERNAME", user_name, user_name_len)
      || GetEnvironmentVariableW (L"USER", user_name, user_name_len))
    {
      char mb_user_name[user_name_len = sys_wcstombs (NULL, 0, user_name)];
      sys_wcstombs (mb_user_name, user_name_len, user_name);
      set_name (mb_user_name);
    }
  else
    set_name ("unknown");

  NTSTATUS status;
  ULONG size;
  PSECURITY_DESCRIPTOR psd;

  status = NtQueryInformationToken (hProcToken, TokenPrimaryGroup,
				    &groups.pgsid, sizeof (cygsid), &size);
  if (!NT_SUCCESS (status))
    system_printf ("NtQueryInformationToken (TokenPrimaryGroup), %y", status);

  /* Get the SID from current process and store it in effec_cygsid */
  status = NtQueryInformationToken (hProcToken, TokenUser, &effec_cygsid,
				    sizeof (cygsid), &size);
  if (!NT_SUCCESS (status))
    {
      system_printf ("NtQueryInformationToken (TokenUser), %y", status);
      return;
    }

  /* Set token owner to the same value as token user */
  status = NtSetInformationToken (hProcToken, TokenOwner, &effec_cygsid,
				  sizeof (cygsid));
  if (!NT_SUCCESS (status))
    debug_printf ("NtSetInformationToken (TokenOwner), %y", status);

  /* Standard way to build a security descriptor with the usual DACL */
  PSECURITY_ATTRIBUTES sa_buf = (PSECURITY_ATTRIBUTES) alloca (1024);
  psd = (PSECURITY_DESCRIPTOR)
		(sec_user_nih (sa_buf, sid()))->lpSecurityDescriptor;

  BOOLEAN acl_exists, dummy;
  TOKEN_DEFAULT_DACL dacl;

  status = RtlGetDaclSecurityDescriptor (psd, &acl_exists, &dacl.DefaultDacl,
					 &dummy);
  if (NT_SUCCESS (status) && acl_exists && dacl.DefaultDacl)
    {

      /* Set the default DACL and the process DACL */
      status = NtSetInformationToken (hProcToken, TokenDefaultDacl, &dacl,
				      sizeof (dacl));
      if (!NT_SUCCESS (status))
	system_printf ("NtSetInformationToken (TokenDefaultDacl), %y", status);
      if ((status = NtSetSecurityObject (NtCurrentProcess (),
					 DACL_SECURITY_INFORMATION, psd)))
	system_printf ("NtSetSecurityObject, %y", status);
    }
  else
    system_printf("Cannot get dacl, %E");
}

void
internal_getlogin (cygheap_user &user)
{
  struct passwd *pwd;
  struct group *pgrp, *grp, *grp2;
  cyg_ldap cldap;

  /* Fetch (and potentially generate) passwd and group entries for the user
     and the primary group in the token. */
  pwd = internal_getpwsid (user.sid (), &cldap);
  pgrp = internal_getgrsid (user.groups.pgsid, &cldap);
  if (!cygheap->pg.nss_cygserver_caching ())
    internal_getgroups (0, NULL, &cldap, 3000000U); /* 300ms in 100ns units */
  if (!pwd)
    debug_printf ("user not found in passwd DB");
  else
    {
      cygsid gsid;

      user.set_name (pwd->pw_name);
      myself->uid = pwd->pw_uid;
      myself->gid = pwd->pw_gid;
      /* If the primary group in the passwd DB is different from the primary
	 group in the user token, we have to find the SID of that group and
	 try to override the token primary group. */
      if (!pgrp || myself->gid != pgrp->gr_gid)
	{
	  if (gsid.getfromgr (grp = internal_getgrgid (pwd->pw_gid, &cldap)))
	    {
	      /* We might have a group file with a group entry for the current
		 user's primary group, but the current user has no entry in
		 passwd.  If so, pw_gid is taken from windows and might
		 disagree with gr_gid from the group file.  Overwrite it. */
	      if ((grp2 = internal_getgrsid (gsid, &cldap)) && grp2 != grp)
		myself->gid = pwd->pw_gid = grp2->gr_gid;
	      /* Set primary group to the group in /etc/passwd. */
	      if (gsid != user.groups.pgsid)
		{
		  NTSTATUS status = NtSetInformationToken (hProcToken,
							   TokenPrimaryGroup,
							   &gsid, sizeof gsid);
		  if (!NT_SUCCESS (status))
		    {
		      debug_printf ("NtSetInformationToken (TokenPrimaryGroup),"
				    " %y", status);
		      /* Revert the primary group setting and override the
			 setting in the passwd entry. */
		      if (pgrp)
			myself->gid = pwd->pw_gid = pgrp->gr_gid;
		    }
		  else
		    user.groups.pgsid = gsid;
		  clear_procimptoken ();
		}
	    }
	  else
	    debug_printf ("group not found in group DB");
	}
    }
  cygheap->user.ontherange (CH_HOME, pwd);
}

void
uinfo_init ()
{
  if (child_proc_info && !cygheap->user.has_impersonation_tokens ())
    return;

  if (!child_proc_info)
    internal_getlogin (cygheap->user); /* Set the cygheap->user. */
  /* Conditions must match those in spawn to allow starting child
     processes with ruid != euid and rgid != egid. */
  else if (cygheap->user.issetuid ()
	   && cygheap->user.saved_uid == cygheap->user.real_uid
	   && cygheap->user.saved_gid == cygheap->user.real_gid
	   && !cygheap->user.groups.issetgroups ()
	   && !cygheap->user.setuid_to_restricted)
    {
      cygheap->user.reimpersonate ();
      return;
    }
  else
    cygheap->user.close_impersonation_tokens ();

  cygheap->user.saved_uid = cygheap->user.real_uid = myself->uid;
  cygheap->user.saved_gid = cygheap->user.real_gid = myself->gid;
  cygheap->user.external_token = NO_IMPERSONATION;
  cygheap->user.internal_token = NO_IMPERSONATION;
  cygheap->user.curr_primary_token = NO_IMPERSONATION;
  cygheap->user.curr_imp_token = NO_IMPERSONATION;
  cygheap->user.ext_token_is_restricted = false;
  cygheap->user.curr_token_is_restricted = false;
  cygheap->user.setuid_to_restricted = false;
  cygheap->user.set_saved_sid ();	/* Update the original sid */
  cygheap->user.deimpersonate ();
}

extern "C" int
getlogin_r (char *name, size_t namesize)
{
  const char *login = cygheap->user.name ();
  size_t len = strlen (login) + 1;
  if (len > namesize)
    return ERANGE;
  __try
    {
      strncpy (name, login, len);
    }
  __except (NO_ERROR)
    {
      return EFAULT;
    }
  __endtry
  return 0;
}

extern "C" char *
getlogin (void)
{
  static char username[UNLEN];
  int ret = getlogin_r (username, UNLEN);
  if (ret)
    {
      set_errno (ret);
      return NULL;
    }
  return username;
}

extern "C" uid_t
getuid32 (void)
{
  return cygheap->user.real_uid;
}

#ifdef __x86_64__
EXPORT_ALIAS (getuid32, getuid)
#else
extern "C" __uid16_t
getuid (void)
{
  return cygheap->user.real_uid;
}
#endif

extern "C" gid_t
getgid32 (void)
{
  return cygheap->user.real_gid;
}

#ifdef __x86_64__
EXPORT_ALIAS (getgid32, getgid)
#else
extern "C" __gid16_t
getgid (void)
{
  return cygheap->user.real_gid;
}
#endif

extern "C" uid_t
geteuid32 (void)
{
  return myself->uid;
}

#ifdef __x86_64__
EXPORT_ALIAS (geteuid32, geteuid)
#else
extern "C" uid_t
geteuid (void)
{
  return myself->uid;
}
#endif

extern "C" gid_t
getegid32 (void)
{
  return myself->gid;
}

#ifdef __x86_64__
EXPORT_ALIAS (getegid32, getegid)
#else
extern "C" __gid16_t
getegid (void)
{
  return myself->gid;
}
#endif

/* Not quite right - cuserid can change, getlogin can't */
extern "C" char *
cuserid (char *src)
{
  if (!src)
    return getlogin ();

  strcpy (src, getlogin ());
  return src;
}

const char *
cygheap_user::ontherange (homebodies what, struct passwd *pw)
{
  char homedrive_env_buf[3];
  char *newhomedrive = NULL;
  char *newhomepath = NULL;
  tmp_pathbuf tp;

  debug_printf ("what %d, pw %p", what, pw);
  if (what == CH_HOME)
    {
      char *p;

      if ((p = getenv ("HOME")))
	debug_printf ("HOME is already in the environment %s", p);
      else
	{
	  if (pw && pw->pw_dir && *pw->pw_dir)
	    {
	      debug_printf ("Set HOME (from account db) to %s", pw->pw_dir);
	      setenv ("HOME", pw->pw_dir, 1);
	    }
	  else
	    {
	      char home[strlen (name ()) + 8];

	      debug_printf ("Set HOME to default /home/USER");
	      __small_sprintf (home, "/home/%s", name ());
	      setenv ("HOME", home, 1);
	    }
	}
    }

  if (what != CH_HOME && homepath == NULL)
    {
      WCHAR wuser[UNLEN + 1];
      WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
      PUSER_INFO_3 ui = NULL;
      char *homepath_env_buf = tp.c_get ();
      WCHAR profile[MAX_PATH];
      WCHAR win_id[UNLEN + 1]; /* Large enough for SID */

      homepath_env_buf[0] = homepath_env_buf[1] = '\0';
      /* Use Cygwin home as HOMEDRIVE/HOMEPATH in the first place.  This
	 should cover it completely, in theory.  Still, it might be the
	 wrong choice in the long run, which might demand to set HOMEDRIVE/
	 HOMEPATH to the correct values per Windows.  Keep the entire rest
	 of the code mainly for this reason, so switching is easy. */
      pw = internal_getpwsid (sid ());
      if (pw && pw->pw_dir && *pw->pw_dir)
	cygwin_conv_path (CCP_POSIX_TO_WIN_A, pw->pw_dir, homepath_env_buf,
			  NT_MAX_PATH);
      /* First fallback: Windows path per Windows user DB. */
      else if (logsrv ())
	{
	  sys_mbstowcs (wlogsrv, sizeof (wlogsrv) / sizeof (*wlogsrv),
			logsrv ());
	  sys_mbstowcs (wuser, sizeof wuser / sizeof *wuser, winname ());
	  if (NetUserGetInfo (wlogsrv, wuser, 3, (LPBYTE *) &ui)
	      == NERR_Success)
	    {
	      if (ui->usri3_home_dir_drive && *ui->usri3_home_dir_drive)
		{
		  sys_wcstombs (homepath_env_buf, NT_MAX_PATH,
				ui->usri3_home_dir_drive);
		  strcat (homepath_env_buf, "\\");
		}
	      else if (ui->usri3_home_dir && *ui->usri3_home_dir)
		sys_wcstombs (homepath_env_buf, NT_MAX_PATH,
			      ui->usri3_home_dir);
	    }
	  if (ui)
	    NetApiBufferFree (ui);
	}
      /* Second fallback: Windows profile dir. */
      if (!homepath_env_buf[0]
	  && get_user_profile_directory (get_windows_id (win_id),
					 profile, MAX_PATH))
	sys_wcstombs (homepath_env_buf, NT_MAX_PATH, profile);
      /* Last fallback: Cygwin root dir. */
      if (!homepath_env_buf[0])
	cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_ABSOLUTE,
			  "/", homepath_env_buf, NT_MAX_PATH);

      if (homepath_env_buf[1] != ':')
	{
	  newhomedrive = almost_null;
	  newhomepath = homepath_env_buf;
	}
      else
	{
	  homedrive_env_buf[0] = homepath_env_buf[0];
	  homedrive_env_buf[1] = homepath_env_buf[1];
	  homedrive_env_buf[2] = '\0';
	  newhomedrive = homedrive_env_buf;
	  newhomepath = homepath_env_buf + 2;
	}
    }

  if (newhomedrive && newhomedrive != homedrive)
    cfree_and_set (homedrive, (newhomedrive == almost_null)
			      ? almost_null : cstrdup (newhomedrive));

  if (newhomepath && newhomepath != homepath)
    cfree_and_set (homepath, cstrdup (newhomepath));

  switch (what)
    {
    case CH_HOMEDRIVE:
      return homedrive;
    case CH_HOMEPATH:
      return homepath;
    default:
      return homepath;
    }
}

const char *
cygheap_user::test_uid (char *&what, const char *name, size_t namelen)
{
  if (!what && !issetuid ())
    what = getwinenveq (name, namelen, HEAP_STR);
  return what;
}

const char *
cygheap_user::env_logsrv (const char *name, size_t namelen)
{
  if (test_uid (plogsrv, name, namelen))
    return plogsrv;

  const char *mydomain = domain ();
  const char *myname = winname ();
  if (!mydomain || ascii_strcasematch (myname, "SYSTEM"))
    return almost_null;

  WCHAR wdomain[MAX_DOMAIN_NAME_LEN + 1];
  WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
  sys_mbstowcs (wdomain, MAX_DOMAIN_NAME_LEN + 1, mydomain);
  cfree_and_set (plogsrv, almost_null);
  if (get_logon_server (wdomain, wlogsrv, DS_IS_FLAT_NAME))
    sys_wcstombs_alloc (&plogsrv, HEAP_STR, wlogsrv);
  return plogsrv;
}

const char *
cygheap_user::env_domain (const char *name, size_t namelen)
{
  if (pwinname && test_uid (pdomain, name, namelen))
    return pdomain;

  DWORD ulen = UNLEN + 1;
  WCHAR username[ulen];
  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;
  WCHAR userdomain[dlen];
  SID_NAME_USE use;

  cfree_and_set (pwinname, almost_null);
  cfree_and_set (pdomain, almost_null);
  if (!LookupAccountSidW (NULL, sid (), username, &ulen,
			  userdomain, &dlen, &use))
    __seterrno ();
  else
    {
      sys_wcstombs_alloc (&pwinname, HEAP_STR, username);
      sys_wcstombs_alloc (&pdomain, HEAP_STR, userdomain);
    }
  return pdomain;
}

const char *
cygheap_user::env_userprofile (const char *name, size_t namelen)
{
  if (test_uid (puserprof, name, namelen))
    return puserprof;

  /* User profile path is never longer than MAX_PATH. */
  WCHAR profile[MAX_PATH];
  WCHAR win_id[UNLEN + 1]; /* Large enough for SID */

  cfree_and_set (puserprof, almost_null);
  if (get_user_profile_directory (get_windows_id (win_id), profile, MAX_PATH))
    sys_wcstombs_alloc (&puserprof, HEAP_STR, profile);

  return puserprof;
}

const char *
cygheap_user::env_homepath (const char *name, size_t namelen)
{
  return ontherange (CH_HOMEPATH);
}

const char *
cygheap_user::env_homedrive (const char *name, size_t namelen)
{
  return ontherange (CH_HOMEDRIVE);
}

const char *
cygheap_user::env_name (const char *name, size_t namelen)
{
  if (!test_uid (pwinname, name, namelen))
    domain ();
  return pwinname;
}

const char *
cygheap_user::env_systemroot (const char *name, size_t namelen)
{
  if (!psystemroot)
    {
      int size = GetSystemWindowsDirectoryW (NULL, 0);
      if (size > 0)
	{
	  WCHAR wsystemroot[size];
	  size = GetSystemWindowsDirectoryW (wsystemroot, size);
	  if (size > 0)
	    sys_wcstombs_alloc (&psystemroot, HEAP_STR, wsystemroot);
	}
      if (size <= 0)
	debug_printf ("GetSystemWindowsDirectoryW(), %E");
    }
  return psystemroot;
}

char *
pwdgrp::next_str (char c)
{
  char *res = lptr;
  lptr = strchrnul (lptr, c);
  if (*lptr)
    *lptr++ = '\0';
  return res;
}

bool
pwdgrp::next_num (unsigned long& n)
{
  char *p = next_str (':');
  char *cp;
  n = strtoul (p, &cp, 10);
  return p != cp && !*cp;
}

char *
pwdgrp::add_line (char *eptr)
{
  if (eptr)
    {
      if (curr_lines >= max_lines)
	{
	  max_lines += 10;
	  pwdgrp_buf = crealloc_abort (pwdgrp_buf,
				       max_lines * pwdgrp_buf_elem_size);
	}
      lptr = eptr;
      if (!(this->*parse) ())
	return NULL;
      curr_lines++;
    }
  return eptr;
}

void
cygheap_pwdgrp::init ()
{
  pwd_cache.cygserver.init_pwd ();
  pwd_cache.file.init_pwd ();
  pwd_cache.win.init_pwd ();
  grp_cache.cygserver.init_grp ();
  grp_cache.file.init_grp ();
  grp_cache.win.init_grp ();
  /* Default settings:

     passwd: files db
     group:  files db
     db_prefix: auto		DISABLED
     db_separator: +		DISABLED
     db_home: cygwin desc
     db_shell: cygwin desc
     db_gecos: cygwin desc
     db_enum: cache builtin
  */
  pwd_src = (NSS_SRC_FILES | NSS_SRC_DB);
  grp_src = (NSS_SRC_FILES | NSS_SRC_DB);
  prefix = NSS_PFX_AUTO;
  separator[0] = L'+';
#if 0
  home_scheme[0].method = NSS_SCHEME_CYGWIN;
  home_scheme[1].method = NSS_SCHEME_DESC;
  shell_scheme[0].method = NSS_SCHEME_CYGWIN;
  shell_scheme[1].method = NSS_SCHEME_DESC;
  gecos_scheme[0].method = NSS_SCHEME_CYGWIN;
  gecos_scheme[1].method = NSS_SCHEME_DESC;
#endif
  enums = (ENUM_CACHE | ENUM_BUILTIN);
  enum_tdoms = NULL;
  caching = true;	/* INTERNAL ONLY */
}

#define NSS_NCMP(s) (!strncmp(c, (s), sizeof(s)-1))
#define NSS_CMP(s) (!strncmp(c, (s), sizeof(s)-1) \
		    && strchr (" \t", c[sizeof(s)-1]))

/* The /etc/nsswitch.conf file is read exactly once by the root process of a
   process tree.  We can't afford methodical changes during the lifetime of a 
   process tree. */
void
cygheap_pwdgrp::nss_init_line (const char *line)
{
  const char *c = line + strspn (line, " \t");
  char *comment = strchr (c, '#');
  if (comment)
    *comment = '\0';
  switch (*c)
    {
    case 'p':
    case 'g':
      {
	uint32_t *src = NULL;
	if (NSS_NCMP ("passwd:"))
	  src = &pwd_src;
	else if (NSS_NCMP ("group:"))
	  src = &grp_src;
	c = strchr (c, ':') + 1;
	if (src)
	  {
	    *src = 0;
	    while (*(c += strspn (c, " \t")))
	      {
		if (NSS_CMP ("files"))
		  {
		    *src |= NSS_SRC_FILES;
		    c += 5;
		  }
		else if (NSS_CMP ("db"))
		  {
		    *src |= NSS_SRC_DB;
		    c += 2;
		  }
		else
		  {
		    c += strcspn (c, " \t");
		    debug_printf ("Invalid nsswitch.conf content: %s", line);
		  }
	      }
	    if (*src == 0)
	      *src = (NSS_SRC_FILES | NSS_SRC_DB);
	  }
      }
      break;
    case 'd':
      if (!NSS_NCMP ("db_"))
	{
	  debug_printf ("Invalid nsswitch.conf content: %s", line);
	  break;
	}
      c += 3;
#if 0 /* Disable setting prefix and separator from nsswitch.conf for now.
	 Remove if nobody complains too loudly. */
      if (NSS_NCMP ("prefix:"))
	{
	  c = strchr (c, ':') + 1;
	  c += strspn (c, " \t");
	  if (NSS_CMP ("auto"))
	    prefix = NSS_AUTO;
	  else if (NSS_CMP ("primary"))
	    prefix = NSS_PRIMARY;
	  else if (NSS_CMP ("always"))
	    prefix = NSS_ALWAYS;
	  else
	    debug_printf ("Invalid nsswitch.conf content: %s", line);
	}
      else if (NSS_NCMP ("separator:"))
	{
	  c = strchr (c, ':') + 1;
	  c += strspn (c, " \t");
	  if ((unsigned char) *c <= 0x7f && *c != ':' && strchr (" \t", c[1]))
	    separator[0] = (unsigned char) *c;
	  else
	    debug_printf ("Invalid nsswitch.conf content: %s", line);
	}
      else
#endif
      if (NSS_NCMP ("enum:"))
	{
	  tmp_pathbuf tp;
	  char *tdoms = tp.c_get ();
	  char *td = tdoms;
	  int new_enums = ENUM_NONE;

	  td[0] = '\0';
	  c = strchr (c, ':') + 1;
	  c += strspn (c, " \t");
	  while (!strchr (" \t", *c))
	    {
	      const char *e = c + strcspn (c, " \t");
	      if (NSS_CMP ("none"))
		new_enums = ENUM_NONE;
	      else if (NSS_CMP ("builtin"))
		new_enums |= ENUM_BUILTIN;
	      else if (NSS_CMP ("cache"))
		new_enums |= ENUM_CACHE;
	      else if (NSS_CMP ("files"))
		new_enums |= ENUM_FILES;
	      else if (NSS_CMP ("local"))
		new_enums |= ENUM_LOCAL;
	      else if (NSS_CMP ("primary"))
		new_enums |= ENUM_PRIMARY;
	      else if (NSS_CMP ("alltrusted"))
		new_enums |= ENUM_TDOMS | ENUM_TDOMS_ALL;
	      else if (NSS_CMP ("all"))
		new_enums |= ENUM_ALL;
	      else
		{
		  td = stpcpy (stpncpy (td, c, e - c), " ");
		  new_enums |= ENUM_TDOMS;
		}
	      c = e;
	      c += strspn (c, " \t");
	    }
	  if ((new_enums & (ENUM_TDOMS | ENUM_TDOMS_ALL)) == ENUM_TDOMS)
	    {
	      if (td > tdoms)
		{
		  PWCHAR spc;
		  sys_mbstowcs_alloc (&enum_tdoms, HEAP_BUF, tdoms);
		  /* Convert string to REG_MULTI_SZ-style. */
		  while ((spc = wcsrchr (enum_tdoms, L' ')))
		    *spc = L'\0';
		}
	      else
	      	new_enums &= ~(ENUM_TDOMS | ENUM_TDOMS_ALL);
	    }
	  enums = new_enums;
	}
      else
	{
	  nss_scheme_t *scheme = NULL;
	  if (NSS_NCMP ("home:"))
	    scheme = home_scheme;
	  else if (NSS_NCMP ("shell:"))
	    scheme = shell_scheme;
	  else if (NSS_NCMP ("gecos:"))
	    scheme = gecos_scheme;
	  if (scheme)
	    {
	      uint16_t idx = 0;

	      scheme[0].method = scheme[1].method = NSS_SCHEME_FALLBACK;
	      c = strchr (c, ':') + 1;
	      c += strspn (c, " \t");
	      while (*c && idx < NSS_SCHEME_MAX)
		{
		  if (NSS_CMP ("windows"))
		    scheme[idx].method = NSS_SCHEME_WINDOWS;
		  else if (NSS_CMP ("cygwin"))
		    scheme[idx].method = NSS_SCHEME_CYGWIN;
		  else if (NSS_CMP ("unix"))
		    scheme[idx].method = NSS_SCHEME_UNIX;
		  else if (NSS_CMP ("desc"))
		    scheme[idx].method = NSS_SCHEME_DESC;
		  else if (NSS_NCMP ("/"))
		    {
		      const char *e = c + strcspn (c, " \t");
		      scheme[idx].method = NSS_SCHEME_PATH;
		      sys_mbstowcs_alloc (&scheme[idx].attrib, HEAP_STR,
					  c, e - c);
		    }
		  else if (NSS_NCMP ("@@") && isalnum ((unsigned) *++c))
		    {
		      const char *e = c + strcspn (c, " \t");
		      scheme[idx].method = NSS_SCHEME_FREEATTR;
		      sys_mbstowcs_alloc (&scheme[idx].attrib, HEAP_STR,
					  c, e - c);
		    }
		  else
		    debug_printf ("Invalid nsswitch.conf content: %s", line);
		  c += strcspn (c, " \t");
		  c += strspn (c, " \t");
		  ++idx;
		}
	      /* If nothing has been set, revert to default. */
	      if (scheme[0].method == NSS_SCHEME_FALLBACK)
		{
		  scheme[0].method = NSS_SCHEME_CYGWIN;
		  scheme[1].method = NSS_SCHEME_DESC;
		}
	    }
	}
      break;
    case '\0':
      break;
    default:
      debug_printf ("Invalid nsswitch.conf content: %s", line);
      break;
    }
}

static char *
fetch_windows_home (cyg_ldap *pldap, PUSER_INFO_3 ui, cygpsid &sid,
		    PCWSTR dnsdomain)
{
  PCWSTR home_from_db = NULL;
  char *home = NULL;

  if (pldap)
    {
      if (pldap->fetch_ad_account (sid, false, dnsdomain))
	{
#if 0
	  /* Disable preferring homeDrive for now.  The drive letter may not
	     be available when it's needed. */
	  home_from_db = pldap->get_string_attribute (L"homeDrive");
	  if (!home_from_db || !*home_from_db)
#endif
	  home_from_db = pldap->get_string_attribute (L"homeDirectory");
	}
    }
  else if (ui)
    {
#if 0
      /* Ditto. */
      if (ui->usri3_home_dir_drive && *ui->usri3_home_dir_drive)
	home_from_db = ui->usri3_home_dir_drive;
      else
#endif
      if (ui->usri3_home_dir && *ui->usri3_home_dir)
	home_from_db = ui->usri3_home_dir;
    }
  if (home_from_db && *home_from_db)
    home = (char *) cygwin_create_path (CCP_WIN_W_TO_POSIX, home_from_db);
  else
    {
      /* The db fields are empty, so we have to evaluate the local profile
	 path, which is the same thing as the default home directory on
	 Windows.  So what we do here is to try to find out if the user
	 already has a profile on this machine.
	 Note that we don't try to generate the profile if it doesn't exist.
	 Think what would happen if we actually have the permissions to do
	 so and call getpwent... in a domain environment.  The problem is,
	 of course, that we can't know the profile path, unless the OS
	 created it.
	 The only reason this could occur is if a user account, which never
	 logged on to the machine before, tries to logon via a Cygwin service
	 like sshd. */
      WCHAR profile[MAX_PATH];
      WCHAR sidstr[128];

      if (get_user_profile_directory (sid.string (sidstr), profile, MAX_PATH))
      	home = (char *) cygwin_create_path (CCP_WIN_W_TO_POSIX, profile);
    }
  return home;
}

/* Local SAM accounts have only a handful attributes available to home users.
   Therefore, allow to fetch additional passwd/group attributes from the
   "Comment" field in XML short style.  For symmetry, this is also allowed
   from the equivalent "description" AD attribute. */
static char *
fetch_from_description (PCWSTR desc, PCWSTR search, size_t len)
{
  PWCHAR s, e;
  char *ret = NULL;

  if ((s = wcsstr (desc, L"<cygwin ")) && (e = wcsstr (s + 8, L"/>")))
    {
      s += 8;
      while (s && s < e)
	{
	  while (*s == L' ')
	    ++s;
	  if (!wcsncmp (s, search, len)) /* Found what we're searching? */
	    {
	      s += len;
	      if ((e = wcschr (s, L'"')))
		{
		  sys_wcstombs_alloc (&ret, HEAP_NOTHEAP, s, e - s);
		  s = e + 1;
		}
	      break;
	    }
	  else /* Skip the current foo="bar" string. */
	    if ((s = wcschr (s, L'"')) && (s = wcschr (s + 1, L'"')))
	      ++s;
	}
    }
  return ret;
}

static char *
fetch_from_path (cyg_ldap *pldap, PUSER_INFO_3 ui, cygpsid &sid, PCWSTR str,
		 PCWSTR dom, PCWSTR dnsdomain, PCWSTR name, bool full_qualified)
{
  tmp_pathbuf tp;
  PWCHAR wpath = tp.w_get ();
  PWCHAR w = wpath;
  PWCHAR we = wpath + NT_MAX_PATH - 1;
  char *home;
  char *ret = NULL;

  while (*str && w < we)
    {
      if (*str != L'%')
      	*w++ = *str++;
      else
      	{
	  switch (*++str)
	    {
	    case L'u':
	      if (full_qualified)
		{
		  w = wcpncpy (w, dom, we - w);
		  if (w < we)
		    *w++ = cygheap->pg.nss_separator ()[0];
		}
	      w = wcpncpy (w, name, we - w);
	      break;
	    case L'U':
	      w = wcpncpy (w, name, we - w);
	      break;
	    case L'D':
	      w = wcpncpy (w, dom, we - w);
	      break;
	    case L'H':
	      home = fetch_windows_home (pldap, ui, sid, dnsdomain);
	      if (home)
		{
		  /* Drop one leading slash to accommodate home being an
		     absolute path.  We don't check for broken usage of
		     %H here, of course. */
		  if (w > wpath && w[-1] == L'/')
		    --w;
		  w += sys_mbstowcs (w, we - w, home) - 1;
		  free (home);
		}
	      break;
	    case L'_':
	      *w++ = L' ';
	      break;
	    default:
	      *w++ = *str;
	      break;
	    }
	  ++str;
	}
    }
  *w = L'\0';
  sys_wcstombs_alloc (&ret, HEAP_NOTHEAP, wpath);
  return ret;
}

char *
cygheap_pwdgrp::get_home (cyg_ldap *pldap, cygpsid &sid, PCWSTR dom,
			  PCWSTR dnsdomain, PCWSTR name, bool full_qualified)
{
  PWCHAR val;
  char *home = NULL;

  for (uint16_t idx = 0; !home && idx < NSS_SCHEME_MAX; ++idx)
    {
      switch (home_scheme[idx].method)
	{
	case NSS_SCHEME_FALLBACK:
	  return NULL;
	case NSS_SCHEME_WINDOWS:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    home = fetch_windows_home (pldap, NULL, sid, dnsdomain);
	  break;
	case NSS_SCHEME_CYGWIN:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (L"cygwinHome");
	      if (val && *val)
		sys_wcstombs_alloc (&home, HEAP_NOTHEAP, val);
	    }
	  break;
	case NSS_SCHEME_UNIX:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (L"unixHomeDirectory");
	      if (val && *val)
		sys_wcstombs_alloc (&home, HEAP_NOTHEAP, val);
	    }
	  break;
	case NSS_SCHEME_DESC:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (L"description");
	      if (val && *val)
		home = fetch_from_description (val, L"home=\"", 6);
	    }
	  break;
	case NSS_SCHEME_PATH:
	  home = fetch_from_path (pldap, NULL, sid, home_scheme[idx].attrib,
				  dom, dnsdomain, name, full_qualified);
	  break;
	case NSS_SCHEME_FREEATTR:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (home_scheme[idx].attrib);
	      if (val && *val)
		{
		  if (isdrive (val) || *val == '\\')
		    home = (char *)
			   cygwin_create_path (CCP_WIN_W_TO_POSIX, val);
		  else
		    sys_wcstombs_alloc (&home, HEAP_NOTHEAP, val);
		}
	    }
	  break;
	}
    }
  return home;
}

char *
cygheap_pwdgrp::get_home (PUSER_INFO_3 ui, cygpsid &sid, PCWSTR dom,
			  PCWSTR name, bool full_qualified)
{
  char *home = NULL;

  for (uint16_t idx = 0; !home && idx < NSS_SCHEME_MAX; ++idx)
    {
      switch (home_scheme[idx].method)
	{
	case NSS_SCHEME_FALLBACK:
	  return NULL;
	case NSS_SCHEME_WINDOWS:
	  home = fetch_windows_home (NULL, ui, sid, NULL);
	  break;
	case NSS_SCHEME_CYGWIN:
	case NSS_SCHEME_UNIX:
	case NSS_SCHEME_FREEATTR:
	  break;
	case NSS_SCHEME_DESC:
	  home = fetch_from_description (ui->usri3_comment, L"home=\"", 6);
	  break;
	case NSS_SCHEME_PATH:
	  home = fetch_from_path (NULL, ui, sid, home_scheme[idx].attrib,
				  dom, NULL, name, full_qualified);
	  break;
	}
    }
  return home;
}

char *
cygheap_pwdgrp::get_shell (cyg_ldap *pldap, cygpsid &sid, PCWSTR dom,
			   PCWSTR dnsdomain, PCWSTR name, bool full_qualified)
{
  PWCHAR val;
  char *shell = NULL;

  for (uint16_t idx = 0; !shell && idx < NSS_SCHEME_MAX; ++idx)
    {
      switch (shell_scheme[idx].method)
	{
	case NSS_SCHEME_FALLBACK:
	  return NULL;
	case NSS_SCHEME_WINDOWS:
	  break;
	case NSS_SCHEME_CYGWIN:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (L"cygwinShell");
	      if (val && *val)
		sys_wcstombs_alloc (&shell, HEAP_NOTHEAP, val);
	    }
	  break;
	case NSS_SCHEME_UNIX:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (L"loginShell");
	      if (val && *val)
		sys_wcstombs_alloc (&shell, HEAP_NOTHEAP, val);
	    }
	  break;
	case NSS_SCHEME_DESC:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (L"description");
	      if (val && *val)
		shell = fetch_from_description (val, L"shell=\"", 7);
	    }
	  break;
	case NSS_SCHEME_PATH:
	  shell = fetch_from_path (pldap, NULL, sid, shell_scheme[idx].attrib,
	  			   dom, dnsdomain, name, full_qualified);
	  break;
	case NSS_SCHEME_FREEATTR:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (shell_scheme[idx].attrib);
	      if (val && *val)
		{
		  if (isdrive (val) || *val == '\\')
		    shell = (char *)
			    cygwin_create_path (CCP_WIN_W_TO_POSIX, val);
		  else
		    sys_wcstombs_alloc (&shell, HEAP_NOTHEAP, val);
		}
	    }
	  break;
	}
    }
  return shell;
}

char *
cygheap_pwdgrp::get_shell (PUSER_INFO_3 ui, cygpsid &sid, PCWSTR dom,
			   PCWSTR name, bool full_qualified)
{
  char *shell = NULL;

  for (uint16_t idx = 0; !shell && idx < NSS_SCHEME_MAX; ++idx)
    {
      switch (shell_scheme[idx].method)
	{
	case NSS_SCHEME_FALLBACK:
	  return NULL;
	case NSS_SCHEME_WINDOWS:
	case NSS_SCHEME_CYGWIN:
	case NSS_SCHEME_UNIX:
	case NSS_SCHEME_FREEATTR:
	  break;
	case NSS_SCHEME_DESC:
	  shell = fetch_from_description (ui->usri3_comment, L"shell=\"", 7);
	  break;
	case NSS_SCHEME_PATH:
	  shell = fetch_from_path (NULL, ui, sid, shell_scheme[idx].attrib,
				   dom, NULL, name, full_qualified);
	  break;
	}
    }
  return shell;
}

/* Helper function to replace colons with semicolons in pw_gecos field. */
static inline void
colon_to_semicolon (char *str)
{
  char *cp = str;
  while ((cp = strchr (cp, L':')) != NULL)
    *cp++ = L';';
}

char *
cygheap_pwdgrp::get_gecos (cyg_ldap *pldap, cygpsid &sid, PCWSTR dom,
			   PCWSTR dnsdomain, PCWSTR name, bool full_qualified)
{
  PWCHAR val;
  char *gecos = NULL;

  for (uint16_t idx = 0; !gecos && idx < NSS_SCHEME_MAX; ++idx)
    {
      switch (gecos_scheme[idx].method)
	{
	case NSS_SCHEME_FALLBACK:
	  return NULL;
	case NSS_SCHEME_WINDOWS:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (L"displayName");
	      if (val && *val)
		sys_wcstombs_alloc (&gecos, HEAP_NOTHEAP, val);
	    }
	  break;
	case NSS_SCHEME_CYGWIN:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (L"cygwinGecos");
	      if (val && *val)
		sys_wcstombs_alloc (&gecos, HEAP_NOTHEAP, val);
	    }
	  break;
	case NSS_SCHEME_UNIX:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (L"gecos");
	      if (val && *val)
		sys_wcstombs_alloc (&gecos, HEAP_NOTHEAP, val);
	    }
	  break;
	case NSS_SCHEME_DESC:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (L"description");
	      if (val && *val)
		gecos = fetch_from_description (val, L"gecos=\"", 7);
	    }
	  break;
	case NSS_SCHEME_PATH:
	  gecos = fetch_from_path (pldap, NULL, sid,
				   gecos_scheme[idx].attrib + 1,
				   dom, dnsdomain, name, full_qualified);
	  break;
	case NSS_SCHEME_FREEATTR:
	  if (pldap->fetch_ad_account (sid, false, dnsdomain))
	    {
	      val = pldap->get_string_attribute (gecos_scheme[idx].attrib);
	      if (val && *val)
		sys_wcstombs_alloc (&gecos, HEAP_NOTHEAP, val);
	    }
	  break;
	}
    }
  if (gecos)
    colon_to_semicolon (gecos);
  return gecos;
}

char *
cygheap_pwdgrp::get_gecos (PUSER_INFO_3 ui, cygpsid &sid, PCWSTR dom,
			   PCWSTR name, bool full_qualified)
{
  char *gecos = NULL;

  for (uint16_t idx = 0; !gecos && idx < NSS_SCHEME_MAX; ++idx)
    {
      switch (gecos_scheme[idx].method)
	{
	case NSS_SCHEME_FALLBACK:
	  return NULL;
	case NSS_SCHEME_WINDOWS:
	  if (ui->usri3_full_name && *ui->usri3_full_name)
	    sys_wcstombs_alloc (&gecos, HEAP_NOTHEAP, ui->usri3_full_name);
	  break;
	case NSS_SCHEME_CYGWIN:
	case NSS_SCHEME_UNIX:
	case NSS_SCHEME_FREEATTR:
	  break;
	case NSS_SCHEME_DESC:
	  gecos = fetch_from_description (ui->usri3_comment, L"gecos=\"", 7);
	  break;
	case NSS_SCHEME_PATH:
	  gecos = fetch_from_path (NULL, ui, sid, gecos_scheme[idx].attrib + 1,
				   dom, NULL, name, full_qualified);
	  break;
	}
    }
  if (gecos)
    colon_to_semicolon (gecos);
  return gecos;
}

void
cygheap_pwdgrp::_nss_init ()
{
  UNICODE_STRING path;
  OBJECT_ATTRIBUTES attr;
  NT_readline rl;
  tmp_pathbuf tp;
  char *buf = tp.c_get ();

  PCWSTR rel_path = L"\\etc\\nsswitch.conf";
  path.Length = (wcslen (cygheap->installation_root) + wcslen (rel_path))
		* sizeof (WCHAR);
  path.MaximumLength = path.Length + sizeof (WCHAR);
  path.Buffer = (PWCHAR) alloca (path.MaximumLength);
  wcpcpy (wcpcpy (path.Buffer, cygheap->installation_root), rel_path);
  InitializeObjectAttributes (&attr, &path, OBJ_CASE_INSENSITIVE,
			      NULL, NULL);
  if (rl.init (&attr, buf, NT_MAX_PATH))
    while ((buf = rl.gets ()))
      nss_init_line (buf);
  nss_inited = true;
}

/* Override the ParentIndex value of the PDS_DOMAIN_TRUSTSW entry with the
   PosixOffset. */
#define PosixOffset ParentIndex

bool
cygheap_domain_info::init ()
{
  HANDLE lsa;
  NTSTATUS status;
  ULONG ret;
  /* We *have* to copy the information.  Apart from our wish to have the
     stuff in the cygheap, even when not calling LsaFreeMemory on the result,
     the data will be overwritten later.  From what I gather, the information
     is, in fact, stored on the stack. */
  PPOLICY_DNS_DOMAIN_INFO pdom;
  PPOLICY_ACCOUNT_DOMAIN_INFO adom;
  PDS_DOMAIN_TRUSTSW td;
  ULONG tdom_cnt;

  if (adom_name)
    return true;
  lsa = lsa_open_policy (NULL, POLICY_VIEW_LOCAL_INFORMATION);
  if (!lsa)
    {
      system_printf ("lsa_open_policy(NULL) failed");
      return false;
    }
  /* Fetch primary domain information from local LSA. */
  status = LsaQueryInformationPolicy (lsa, PolicyDnsDomainInformation,
				      (PVOID *) &pdom);
  if (status != STATUS_SUCCESS)
    {
      system_printf ("LsaQueryInformationPolicy(Primary) %y", status);
      return false;
    }
  /* Copy primary domain info to cygheap. */
  pdom_name = cwcsdup (pdom->Name.Buffer);
  pdom_dns_name = pdom->DnsDomainName.Length
		  ? cwcsdup (pdom->DnsDomainName.Buffer) : NULL;
  pdom_sid = pdom->Sid;
  LsaFreeMemory (pdom);
  /* Fetch account domain information from local LSA. */
  status = LsaQueryInformationPolicy (lsa, PolicyAccountDomainInformation,
				      (PVOID *) &adom);
  if (status != STATUS_SUCCESS)
    {
      system_printf ("LsaQueryInformationPolicy(Account) %y", status);
      return false;
    }
  /* Copy account domain info to cygheap.  If we're running on a DC the account
     domain is identical to the primary domain.  This leads to confusion when
     trying to compute the uid/gid values.  Therefore we invalidate the account
     domain name if we're running on a DC. */
  adom_sid = adom->DomainSid;
  adom_name = cwcsdup (pdom_sid == adom_sid ? L"@@" : adom->DomainName.Buffer);
  LsaFreeMemory (adom);
  lsa_close_policy (lsa);
  if (cygheap->dom.member_machine ())
    {
      ret = DsEnumerateDomainTrustsW (NULL, DS_DOMAIN_DIRECT_INBOUND
					    | DS_DOMAIN_DIRECT_OUTBOUND
					    | DS_DOMAIN_IN_FOREST,
				      &td, &tdom_cnt);
      if (ret != ERROR_SUCCESS)
	{
	  SetLastError (ret);
	  debug_printf ("DsEnumerateDomainTrusts: %E");
	  return true;
	}
      if (tdom_cnt == 0)
	{
	  return true;
	}
      /* Copy trusted domain info to cygheap, setting PosixOffset on the fly. */
      tdom = (PDS_DOMAIN_TRUSTSW)
	cmalloc_abort (HEAP_BUF, tdom_cnt * sizeof (DS_DOMAIN_TRUSTSW));
      memcpy (tdom, td, tdom_cnt * sizeof (DS_DOMAIN_TRUSTSW));
      for (ULONG idx = 0; idx < tdom_cnt; ++idx)
	{
	  /* Copy... */
	  tdom[idx].NetbiosDomainName = cwcsdup (td[idx].NetbiosDomainName);
	  /* DnsDomainName as well as DomainSid can be NULL.  The reason is
	     usually a domain of type TRUST_TYPE_DOWNLEVEL.  This can be an
	     old pre-AD domain, or a Netware domain, etc.  If DnsDomainName
	     is NULL, just set it to NetbiosDomainName.  This simplifies
	     subsequent code which doesn't have to check for a NULL pointer. */
	  tdom[idx].DnsDomainName = td[idx].DnsDomainName
				    ? cwcsdup (td[idx].DnsDomainName)
				    : tdom[idx].NetbiosDomainName;
	  if (td[idx].DomainSid)
	    {
	      ULONG len = RtlLengthSid (td[idx].DomainSid);
	      tdom[idx].DomainSid = cmalloc_abort(HEAP_BUF, len);
	      RtlCopySid (len, tdom[idx].DomainSid, td[idx].DomainSid);
	    }
	  /* ...and set PosixOffset to 0.  This */
	  tdom[idx].PosixOffset = 0;
	}
      NetApiBufferFree (td);
      tdom_count = tdom_cnt;
    }
  /* If we have Microsoft Client for NFS installed, we make use of a name
     mapping server.  This can be either Active Directory to map uids/gids
     directly to Windows SIDs, or an AD LDS or other RFC 2307 compatible
     identity store.  The name of the mapping domain can be fetched from the
     registry key created by the NFS client installation and entered by the
     user via nfsadmin or the "Services For NFS" MMC snap-in.

     Reference:
     http://blogs.technet.com/b/filecab/archive/2012/10/09/nfs-identity-mapping-in-windows-server-2012.aspx
     Note that we neither support UNMP nor local passwd/group file mapping,
     nor UUUA.

     This function returns the mapping server from the aforementioned registry
     key, or, if none is configured, NULL, which will be resolved to the
     primary domain of the machine by the ldap_init function.

     The latter is useful to get an RFC 2307 mapping for Samba UNIX accounts,
     even if no NFS name mapping is configured on the machine.  Fortunately,
     the posixAccount and posixGroup schemas are already available in the
     Active Directory default setup since Windows Server 2003 R2. */
  reg_key reg (HKEY_LOCAL_MACHINE, KEY_READ | KEY_WOW64_64KEY,
	       L"SOFTWARE", L"Microsoft", L"ServicesForNFS", NULL);
  if (!reg.error ())
    {
      DWORD rfc2307 = reg.get_dword (L"Rfc2307", 0);
      if (rfc2307)
	{
	  rfc2307_domain_buf = (PWCHAR) ccalloc_abort (HEAP_STR, 257,
						       sizeof (WCHAR));
	  reg.get_string (L"Rfc2307Domain", rfc2307_domain_buf, 257, L"");
	  if (!rfc2307_domain_buf[0])
	    {
	      cfree (rfc2307_domain_buf);
	      rfc2307_domain_buf = NULL;
	    }
	}
    }
  return true;
}

/* Per session, so it changes potentially when switching the user context. */
static cygsid logon_sid ("");

static void
get_logon_sid ()
{
  if (PSID (logon_sid) == NO_SID)
    {
      NTSTATUS status;
      ULONG size;
      tmp_pathbuf tp;
      PTOKEN_GROUPS groups = (PTOKEN_GROUPS) tp.c_get ();

      status = NtQueryInformationToken (hProcToken, TokenGroups, groups,
					NT_MAX_PATH, &size);
      if (!NT_SUCCESS (status))
	debug_printf ("NtQueryInformationToken() %y", status);
      else
	{
	  for (DWORD pg = 0; pg < groups->GroupCount; ++pg)
	    if (groups->Groups[pg].Attributes & SE_GROUP_LOGON_ID)
	      {
		logon_sid = groups->Groups[pg].Sid;
		break;
	      }
	}
    }
}

void *
pwdgrp::add_account_post_fetch (char *line, bool lock)
{
  void *ret = NULL;

  if (line)
    { 
      if (lock)
	pglock.init ("pglock")->acquire ();
      if (add_line (line))
	ret = ((char *) pwdgrp_buf) + (curr_lines - 1) * pwdgrp_buf_elem_size;
      if (lock)
	pglock.release ();
    }
  return ret;
}

void *
pwdgrp::add_account_from_file (cygpsid &sid)
{
  if (!path.MaximumLength)
    return NULL;
  fetch_user_arg_t arg;
  arg.type = SID_arg;
  arg.sid = &sid;
  char *line = fetch_account_from_file (arg);
  return (struct passwd *) add_account_post_fetch (line, true);
}

void *
pwdgrp::add_account_from_file (const char *name)
{
  if (!path.MaximumLength)
    return NULL;
  fetch_user_arg_t arg;
  arg.type = NAME_arg;
  arg.name = name;
  char *line = fetch_account_from_file (arg);
  return (struct passwd *) add_account_post_fetch (line, true);
}

void *
pwdgrp::add_account_from_file (uint32_t id)
{
  if (!path.MaximumLength)
    return NULL;
  fetch_user_arg_t arg;
  arg.type = ID_arg;
  arg.id = id;
  char *line = fetch_account_from_file (arg);
  return (struct passwd *) add_account_post_fetch (line, true);
}

void *
pwdgrp::add_account_from_windows (cygpsid &sid, cyg_ldap *pldap)
{
  fetch_user_arg_t arg;
  arg.type = SID_arg;
  arg.sid = &sid;
  char *line = fetch_account_from_windows (arg, pldap);
  if (!line)
    return NULL;
  return add_account_post_fetch (line, true);
}

void *
pwdgrp::add_account_from_windows (const char *name, cyg_ldap *pldap)
{
  fetch_user_arg_t arg;
  arg.type = NAME_arg;
  arg.name = name;
  char *line = fetch_account_from_windows (arg, pldap);
  if (!line)
    return NULL;
  return add_account_post_fetch (line, true);
}

void *
pwdgrp::add_account_from_windows (uint32_t id, cyg_ldap *pldap)
{
  fetch_user_arg_t arg;
  arg.type = ID_arg;
  arg.id = id;
  char *line = fetch_account_from_windows (arg, pldap);
  if (!line)
    return NULL;
  return add_account_post_fetch (line, true);
}

/* Called from internal_getgrfull, in turn called from internal_getgroups. */
struct group *
pwdgrp::add_group_from_windows (fetch_acc_t &full_acc, cyg_ldap *pldap)
{
  fetch_user_arg_t arg;
  arg.type = FULL_acc_arg;
  arg.full_acc = &full_acc;
  char *line = fetch_account_from_windows (arg, pldap);
  if (!line)
    return NULL;
  return (struct group *) add_account_post_fetch (line, true);
}

/* Check if file exists and if it has been written to since last checked.
   If file has been changed, invalidate the current cache.
   
   If the file doesn't exist when this function is called the first time,
   by the first Cygwin process in a process tree, the file will never be
   visited again by any process in this process tree.  This is important,
   because we cannot allow a change of UID/GID values for the lifetime
   of a process tree.
   
   If the file gets deleted or unreadable, the file cache will stay in
   place, but we won't try to read new accounts from the file.
   
   The return code indicates to the calling function if the file exists. */
bool
pwdgrp::check_file ()
{
  FILE_BASIC_INFORMATION fbi;
  NTSTATUS status;

  if (!path.Buffer)
    {
      PCWSTR rel_path = is_group () ? L"\\etc\\group" : L"\\etc\\passwd";
      path.Length = (wcslen (cygheap->installation_root) + wcslen (rel_path))
		    * sizeof (WCHAR);
      path.MaximumLength = path.Length + sizeof (WCHAR);
      path.Buffer = (PWCHAR) cmalloc_abort (HEAP_BUF, path.MaximumLength);
      wcpcpy (wcpcpy (path.Buffer, cygheap->installation_root), rel_path);
      InitializeObjectAttributes (&attr, &path, OBJ_CASE_INSENSITIVE,
				  NULL, NULL);
    }
  else if (path.MaximumLength == 0) /* Indicates that the file doesn't exist. */
    return false;
  status = NtQueryAttributesFile (&attr, &fbi);
  if (!NT_SUCCESS (status))
    {
      if (last_modified.QuadPart)
	last_modified.QuadPart = 0LL;
      else
	path.MaximumLength = 0;
      return false;
    }
  if (fbi.LastWriteTime.QuadPart > last_modified.QuadPart)
    {
      last_modified.QuadPart = fbi.LastWriteTime.QuadPart;
      if (curr_lines > 0)
	{
	  pglock.init ("pglock")->acquire ();
	  int curr = curr_lines;
	  curr_lines = 0;
	  for (int i = 0; i < curr; ++i)
	    cfree (is_group () ? this->group ()[i].g.gr_name
			 : this->passwd ()[i].p.pw_name);
	  pglock.release ();
	}
    }
  return true;
}

char *
pwdgrp::fetch_account_from_line (fetch_user_arg_t &arg, const char *line)
{
  char *p, *e;

  switch (arg.type)
    {
    case SID_arg:
      /* Ignore fields, just scan for SID string. */
      if (!(p = strstr (line, arg.name)) || p[arg.len] != ':')
	return NULL;
      break;
    case NAME_arg:
      /* First field is always name. */
      if (!strncasematch (line, arg.name, arg.len) || line[arg.len] != ':')
	return NULL;
      break;
    case ID_arg:
      /* Skip to third field. */
      if (!(p = strchr (line, ':')) || !(p = strchr (p + 1, ':')))
	return NULL;
      if (strtoul (p + 1, &e, 10) != arg.id || !e || *e != ':')
	return NULL;
      break;
    default:
      return NULL;
    }
  return cstrdup (line);
}

char *
pwdgrp::fetch_account_from_file (fetch_user_arg_t &arg)
{
  NT_readline rl;
  tmp_pathbuf tp;
  char *buf = tp.c_get ();
  char str[128];
  char *ret = NULL;

  /* Create search string. */
  switch (arg.type)
    {
    case SID_arg:
      /* Override SID with SID string. */
      arg.sid->string (str);
      arg.name = str;
      /*FALLTHRU*/
    case NAME_arg:
      arg.len = strlen (arg.name);
      break;
    case ID_arg:
      break;
    default:
      return NULL;
    }
  if (rl.init (&attr, buf, NT_MAX_PATH))
    while ((buf = rl.gets ()))
      if ((ret = fetch_account_from_line (arg, buf)))
	return ret;
  return NULL;
}

static ULONG
fetch_posix_offset (PDS_DOMAIN_TRUSTSW td, cyg_ldap *cldap)
{
  uint32_t id_val = UINT32_MAX;

  if (!td->PosixOffset && !(td->Flags & DS_DOMAIN_PRIMARY) && td->DomainSid)
    {
      if (cldap->open (NULL) == NO_ERROR)
	id_val = cldap->fetch_posix_offset_for_domain (td->DnsDomainName);
      if (id_val < PRIMARY_POSIX_OFFSET)
	{
	  /* If the offset is less than the primay domain offset, we're bound
	     to suffer collisions with system and local accounts.  Move offset
	     to a fixed replacement fake offset.  This may result in collisions
	     between other domains all of which were moved to this replacement
	     offset, but we can't fix all problems caused by careless admins. */
	  id_val = UNUSABLE_POSIX_OFFSET;
	}
      else if (id_val == UINT32_MAX)
	{
	  /* We're probably running under a local account, so we're not allowed
	     to fetch any information from AD beyond the most obvious.  Fake a
	     reasonable posix offset as above and hope for the best. */
	  id_val = NOACCESS_POSIX_OFFSET;
	}
      td->PosixOffset = id_val;
    }
  return td->PosixOffset;
}

/* CV 2014-05-08: USER_INFO_24 is not yet defined in Mingw64, but will be in
   the next release.  For the time being, define the structure here with
   another name which won't collide with the upcoming correct definition
   in lmaccess.h. */
struct cyg_USER_INFO_24
{
  BOOL   usri24_internet_identity;
  DWORD  usri24_flags;
  LPWSTR usri24_internet_provider_name;
  LPWSTR usri24_internet_principal_name;
  PSID   usri24_user_sid;
};

char *
pwdgrp::fetch_account_from_windows (fetch_user_arg_t &arg, cyg_ldap *pldap)
{
  /* Used in LookupAccount calls. */
  WCHAR namebuf[UNLEN + 1], *name = namebuf;
  WCHAR dom[DNLEN + 1] = L"";
  cygsid csid;
  DWORD nlen = UNLEN + 1;
  DWORD dlen = DNLEN + 1;
  DWORD slen = SECURITY_MAX_SID_SIZE;
  cygpsid sid (NO_SID);
  SID_NAME_USE acc_type;
  BOOL ret = false;
  /* Cygwin user name style. */
  bool fully_qualified_name = false;
  /* Computed stuff. */
  uid_t uid = ILLEGAL_UID;
  gid_t gid = ILLEGAL_GID;
  bool is_domain_account = true;
  PCWSTR domain = NULL;
  bool is_current_user = false;
  char *shell = NULL;
  char *home = NULL;
  char *gecos = NULL;
  /* Temporary stuff. */
  PWCHAR p;
  WCHAR sidstr[128];
  ULONG posix_offset = 0;
  uint32_t id_val;
  cyg_ldap loc_ldap;
  cyg_ldap *cldap = pldap ?: &loc_ldap;

  /* Initialize */
  if (!cygheap->dom.init ())
    return NULL;

  switch (arg.type)
    {
    case FULL_acc_arg:
      {
	sid = arg.full_acc->sid;
	*wcpncpy (name, arg.full_acc->name->Buffer,
		  arg.full_acc->name->Length / sizeof (WCHAR)) = L'\0';
	*wcpncpy (dom, arg.full_acc->dom->Buffer,
		  arg.full_acc->dom->Length / sizeof (WCHAR)) = L'\0';
	acc_type = arg.full_acc->acc_type;
      	ret = acc_type != SidTypeUnknown;
      }
      break;
    case SID_arg:
      sid = *arg.sid;
      ret = LookupAccountSidW (NULL, sid, name, &nlen, dom, &dlen, &acc_type);
      if (!ret
	  && cygheap->dom.member_machine ()
	  && sid_id_auth (sid) == 5 /* SECURITY_NT_AUTHORITY */
	  && sid_sub_auth (sid, 0) == SECURITY_BUILTIN_DOMAIN_RID)
	{
	  /* LookupAccountSid called on a non-DC cannot resolve aliases which
	     are not defined in the local SAM.  If we encounter an alias which
	     can't be resolved, and if we're a domain member machine, ask a DC.
	     Do *not* use LookupAccountSidW.  It can take ages when called on a
	     DC for some weird reason.  Use LDAP instead. */
	  PWCHAR val;

	  if (cldap->fetch_ad_account (sid, true)
	      && (val = cldap->get_group_name ()))
	    {
	      wcpcpy (name, val);
	      wcpcpy (dom, L"BUILTIN");
	      acc_type = SidTypeAlias;
	      ret = true;
	    }
	}
      if (!ret)
	debug_printf ("LookupAccountSid(%W), %E", sid.string (sidstr));
      break;
    case NAME_arg:
      bool fq_name;

      fq_name = false;
      /* Copy over to wchar for search. */
      sys_mbstowcs (name, UNLEN + 1, arg.name);
      /* Replace domain separator char with backslash and make sure p is NULL
	 or points to the backslash. */
      if ((p = wcschr (name, cygheap->pg.nss_separator ()[0])))
	{
	  fq_name = true;
	  *p = L'\\';
	}
      sid = csid;
      ret = LookupAccountNameW (NULL, name, sid, &slen, dom, &dlen, &acc_type);
      /* If this is a name-only S-1-5-21 account *and* it's a machine account
	 on a domain member machine, then we found the wrong one.  Another
	 weird, but perfectly valid case is, if the group name is identical
	 to the domain name.  Try again with domain name prepended. */
      if (ret
	  && !fq_name
	  && sid_id_auth (sid) == 5 /* SECURITY_NT_AUTHORITY */
	  && sid_sub_auth (sid, 0) == SECURITY_NT_NON_UNIQUE
	  && cygheap->dom.member_machine ()
	  && (wcscasecmp (dom, cygheap->dom.account_flat_name ()) == 0
	      || acc_type == SidTypeDomain))
	{
	  p = wcpcpy (name, cygheap->dom.primary_flat_name ());
	  *p = L'\\';
	  sys_mbstowcs (p + 1, UNLEN + 1, arg.name);
	  slen = SECURITY_MAX_SID_SIZE;
	  dlen = DNLEN + 1;
	  sid = csid;
	  ret = LookupAccountNameW (NULL, name, sid, &slen, dom, &dlen,
				    &acc_type);
	}
      if (!ret)
	{
	  debug_printf ("LookupAccountNameW (%W), %E", name);
	  return NULL;
	}
      /* We can skip the backslash in the rest of this function. */
      if (p)
	name = p + 1;
      /* Last but not least, some validity checks on the name style. */
      if (!fq_name)
	{
	  /* name_only only if db_prefix is auto. */
	  if (!cygheap->pg.nss_prefix_auto ())
	    {
	      debug_printf ("Invalid account name <%s> (name only/"
			    "db_prefix not auto)", arg.name);
	      return NULL;
	    }
	  /* name_only account is either builtin or primary domain, or
	     account domain on non-domain machines. */
	  if (sid_id_auth (sid) == 5 /* SECURITY_NT_AUTHORITY */
	      && sid_sub_auth (sid, 0) == SECURITY_NT_NON_UNIQUE)
	    {
	      if (cygheap->dom.member_machine ())
		{
		  if (wcscasecmp (dom, cygheap->dom.primary_flat_name ()) != 0)
		    {
		      debug_printf ("Invalid account name <%s> (name only/"
				    "non primary on domain machine)", arg.name);
		      return NULL;
		    }
		}
	      else if (wcscasecmp (dom, cygheap->dom.account_flat_name ()) != 0)
		{
		  debug_printf ("Invalid account name <%s> (name only/"
				"non machine on non-domain machine)", arg.name);
		  return NULL;
		}
	    }
	}
      else
	{
	  /* All is well if db_prefix is always. */
	  if (cygheap->pg.nss_prefix_always ())
	    break;
	  /* Otherwise, no fully_qualified for builtin accounts, except for
	     NT SERVICE, for which we require the prefix.  Note that there's
	     no equivalent test in the `if (!fq_name)' branch above, because
	     LookupAccountName never returns NT SERVICE accounts if they are
	     not prependend with the domain anyway. */
	  if (sid_id_auth (sid) != 5 /* SECURITY_NT_AUTHORITY */
	      || (sid_sub_auth (sid, 0) != SECURITY_NT_NON_UNIQUE
		  && sid_sub_auth (sid, 0) != SECURITY_SERVICE_ID_BASE_RID))
	    {
	      debug_printf ("Invalid account name <%s> (fully qualified/"
			    "not NON_UNIQUE or NT_SERVICE)", arg.name);
	      return NULL;
	    }
	  /* All is well if db_prefix is primary. */
	  if (cygheap->pg.nss_prefix_primary ())
	    break;
	  /* Domain member and domain == primary domain? */
	  if (cygheap->dom.member_machine ())
	    {
	      if (!wcscasecmp (dom, cygheap->dom.primary_flat_name ()))
		{
		  debug_printf ("Invalid account name <%s> (fully qualified/"
				"primary domain account)", arg.name);
		  return NULL;
		}
	    }
	  /* Not domain member and domain == account domain? */
	  else if (!wcscasecmp (dom, cygheap->dom.account_flat_name ()))
	    {
	      debug_printf ("Invalid account name <%s> (fully qualified/"
			    "local account)", arg.name);
	      return NULL;
	    }
	}
      break;
    case ID_arg:
      /* Construct SID from ID using the SFU rules, just like the code below
         goes the opposite route. */
#ifndef INTERIX_COMPATIBLE
      /* Except for Builtin and Alias groups in the SECURITY_NT_AUTHORITY.
	 We create uid/gid values compatible with the old values generated
	 by mkpasswd/mkgroup. */
      if (arg.id < 0x200)
	__small_swprintf (sidstr, L"S-1-5-%u", arg.id & 0x1ff);
      else if (arg.id == 0x3e8) /* Special case "Other Organization" */
	wcpcpy (sidstr, L"S-1-5-1000");
      else if (arg.id <= 0x7ff)
	__small_swprintf (sidstr, L"S-1-5-32-%u", arg.id & 0x7ff);
      else
#endif
      if (arg.id == 0xffe)
	{
	  /* OtherSession != Logon SID. */
	  get_logon_sid ();
	  /* LookupAccountSidW will fail. */
	  sid = csid = logon_sid;
	  sid_sub_auth_rid (sid) = 0;
	  break;
	}
      else if (arg.id == 0xfff)
	{
	  /* CurrentSession == Logon SID. */
	  get_logon_sid ();
	  /* LookupAccountSidW will fail. */
	  sid = logon_sid;
	  break;
	}
      else if (arg.id < 0x10000)
	{
	  /* Nothing. */
	  debug_printf ("Invalid POSIX id %u", arg.id);
	  return NULL;
	}
      else if (arg.id < 0x20000)
	{
	  /* Well-Known Group */
	  arg.id -= 0x10000;
	  /* SECURITY_APP_PACKAGE_AUTHORITY */
	  if (arg.id >= 0xf20 && arg.id <= 0xf3f)
	    __small_swprintf (sidstr, L"S-1-15-%u-%u", (arg.id >> 4) & 0xf,
						       arg.id & 0xf);
	  else
	    __small_swprintf (sidstr, L"S-1-%u-%u", arg.id >> 8, arg.id & 0xff);
	}
      else if (arg.id >= 0x30000 && arg.id < 0x40000)
	{
	  /* Account domain user or group. */
	  PWCHAR s = cygheap->dom.account_sid ().pstring (sidstr);
	  __small_swprintf (s, L"-%u", arg.id & 0xffff);
	}
      else if (arg.id < 0x60000)
	{
	  /* Builtin Alias */
	  __small_swprintf (sidstr, L"S-1-5-%u-%u",
			    arg.id >> 12, arg.id & 0xffff);
	}
      else if (arg.id < 0x70000)
	{
	  /* Mandatory Label. */
	  __small_swprintf (sidstr, L"S-1-16-%u", arg.id & 0xffff);
	}
      else if (arg.id < 0x80000)
	{
	  /* Identity assertion SIDs. */
	  __small_swprintf (sidstr, L"S-1-18-%u", arg.id & 0xffff);
	}
      else if (arg.id < PRIMARY_POSIX_OFFSET)
	{
	  /* Nothing. */
	  debug_printf ("Invalid POSIX id %u", arg.id);
	  return NULL;
	}
      else if (arg.id == ILLEGAL_UID)
	{
	  /* Just some fake. */
	  sid = csid = "S-1-99-0";
	  break;
	}
      else if (arg.id >= UNIX_POSIX_OFFSET)
	{
	  /* UNIX (unknown NFS or Samba) user account. */
	  __small_swprintf (sidstr, L"S-1-22-%u-%u",
			    is_group () ? 2 : 1,  arg.id & UNIX_POSIX_MASK);
	  /* LookupAccountSidW will fail. */
	  sid = csid = sidstr;
	  break;
	}
      else
	{
	  /* Some trusted domain? */
	  PDS_DOMAIN_TRUSTSW td = NULL, this_td = NULL;

	  for (ULONG idx = 0; (td = cygheap->dom.trusted_domain (idx)); ++idx)
	    {
	      fetch_posix_offset (td, &loc_ldap);
	      if (td->PosixOffset > posix_offset && td->PosixOffset <= arg.id)
		posix_offset = (this_td = td)->PosixOffset;
	    }
	  if (this_td)
	    {
	      cygpsid tsid (this_td->DomainSid);
	      PWCHAR s = tsid.pstring (sidstr);
	      __small_swprintf (s, L"-%u", arg.id - posix_offset);
	    }
	  else
	    {
	      /* Primary domain */
	      PWCHAR s = cygheap->dom.primary_sid ().pstring (sidstr);
	      __small_swprintf (s, L"-%u", arg.id - PRIMARY_POSIX_OFFSET);
	    }
	  posix_offset = 0;
	}
      sid = csid = sidstr;
      ret = LookupAccountSidW (NULL, sid, name, &nlen, dom, &dlen, &acc_type);
      if (!ret)
	{
	  debug_printf ("LookupAccountSidW (%W), %E", sidstr);
	  return NULL;
	}
      break;
    }
  if (ret)
    {
      /* Builtin account?  SYSTEM, for instance, is returned as SidTypeUser,
	 if a process is running as LocalSystem service.
	 Microsoft Account?  These show up in the user's group list, using the
	 undocumented security authority 11.  Even though this is officially a
	 user account, it only matters as part of the group list, so we convert
	 it to a well-known group here. */
      if (acc_type == SidTypeUser
	  && (sid_sub_auth_count (sid) <= 3 || sid_id_auth (sid) == 11))
	acc_type = SidTypeWellKnownGroup;
      switch (acc_type)
      	{
	case SidTypeUser:
	  if (is_group ())
	    {
	      /* Don't allow users as group.  While this is technically
		 possible, it doesn't make sense in a POSIX scenario.
	 
		 And then there are the so-called Microsoft Accounts.  The
		 special SID with security authority 11 is converted to a
		 well known group above, but additionally, when logging in
		 with such an account, the user's primary group SID is the
		 user's SID.  Those we let pass, but no others. */
	      bool its_ok = false;
	      if (wincap.has_microsoft_accounts ())
		{
		  struct cyg_USER_INFO_24 *ui24;
		  if (NetUserGetInfo (NULL, name, 24, (PBYTE *) &ui24)
		      == NERR_Success)
		    {
		      if (ui24->usri24_internet_identity)
			its_ok = true;
		      NetApiBufferFree (ui24);
		    }
		}
	      if (!its_ok)
		return NULL;
	    }
	  /*FALLTHRU*/
	case SidTypeGroup:
	case SidTypeAlias:
	  /* Predefined alias? */
	  if (acc_type == SidTypeAlias
	      && sid_sub_auth (sid, 0) != SECURITY_NT_NON_UNIQUE)
	    {
#ifdef INTERIX_COMPATIBLE
	      posix_offset = 0x30000;
	      uid = 0x1000 * sid_sub_auth (sid, 0)
		    + (sid_sub_auth_rid (sid) & 0xffff);
#else
	      posix_offset = 0;
#endif
	      fully_qualified_name = cygheap->pg.nss_prefix_always ();
	      is_domain_account = false;
	    }
	  /* Account domain account? */
	  else if (!wcscasecmp (dom, cygheap->dom.account_flat_name ()))
	    {
	      posix_offset = 0x30000;
	      if (cygheap->dom.member_machine ()
		  || !cygheap->pg.nss_prefix_auto ())
		fully_qualified_name = true;
	      is_domain_account = false;
	    }
	  /* Domain member machine? */
	  else if (cygheap->dom.member_machine ())
	    {
	      /* Primary domain account? */
	      if (!wcscasecmp (dom, cygheap->dom.primary_flat_name ()))
		{
		  posix_offset = PRIMARY_POSIX_OFFSET;
		  /* In theory domain should have been set to
		     cygheap->dom.primary_dns_name (), but it turns out that
		     not setting the domain here has advantages.  We open the
		     ldap connection to NULL (== some DC of our primary domain)
		     anyway.  So the domain is only used later on.  So, don't
		     set domain here to non-NULL, unless you're sure you have
		     also changed subsequent assumptions that domain is NULL
		     if it's a primary domain account. */
		  if (!cygheap->pg.nss_prefix_auto ())
		    fully_qualified_name = true;
		}
	      else
		{
		  /* No, fetch POSIX offset. */
		  PDS_DOMAIN_TRUSTSW td = NULL;

		  fully_qualified_name = true;
		  for (ULONG idx = 0;
		       (td = cygheap->dom.trusted_domain (idx));
		       ++idx)
		    if (!wcscasecmp (dom, td->NetbiosDomainName))
		      {
			domain = td->DnsDomainName;
			posix_offset =
			  fetch_posix_offset (td, &loc_ldap);
			break;
		      }

		  if (!domain)
		    {
		      debug_printf ("Unknown domain %W", dom);
		      return NULL;
		    }
		}
	    }
	  /* If the domain returned by LookupAccountSid is not our machine
	     name, and if our machine is no domain member, we lose.  We have
	     nobody to ask for the POSIX offset. */
	  else
	    {
	      debug_printf ("Unknown domain %W", dom);
	      return NULL;
	    }
	  /* Generate uid/gid values. */
	  if (uid == ILLEGAL_UID)
	    uid = posix_offset + sid_sub_auth_rid (sid);
	  if (!is_group () && acc_type == SidTypeUser)
	    {
	      /* Default primary group.  If the sid is the current user, fetch
		 the default group from the current user token, otherwise make
		 the educated guess that the user is in group "Domain Users"
		 or "None". */
	      if (sid == cygheap->user.sid ())
		{
		  is_current_user = true;
		  gid = posix_offset
			+ sid_sub_auth_rid (cygheap->user.groups.pgsid);
		}
	      else
		gid = posix_offset + DOMAIN_GROUP_RID_USERS;
	    }

	  if (is_domain_account)
	    {
	      /* Skip this when creating group entries and for non-users. */
	      if (is_group() || acc_type != SidTypeUser)
		break;
	      /* On AD machines, use LDAP to fetch domain account infos. */
	      if (cygheap->dom.primary_dns_name ())
		{
		  /* For the current user we got the primary group from the
		     user token.  For any other user we fetch it from AD. */
		  if (!is_current_user
		      && cldap->fetch_ad_account (sid, false, domain)
		      && (id_val = cldap->get_primary_gid ()) != ILLEGAL_GID)
		    gid = posix_offset + id_val;
		  home = cygheap->pg.get_home (cldap, sid, dom, domain,
					       name, fully_qualified_name);
		  shell = cygheap->pg.get_shell (cldap, sid, dom, domain,
						 name,
						 fully_qualified_name);
		  gecos = cygheap->pg.get_gecos (cldap, sid, dom, domain,
						 name, fully_qualified_name);
		  /* Check and, if necessary, add unix<->windows id mapping
		     on the fly, unless we're called from getpwent. */
		  if (!pldap && cldap->is_open ())
		    {
		      id_val = cldap->get_unix_uid ();
		      if (id_val != ILLEGAL_UID
			  && cygheap->ugid_cache.get_uid (id_val)
			     == ILLEGAL_UID)
			cygheap->ugid_cache.add_uid (id_val, uid);
		    }
		}
	      /* If primary_dns_name() is empty, we're likely running under an
		 NT4 domain, so we can't use LDAP.  For user accounts fall back
		 to NetUserGetInfo.  This isn't overly fast, but keep in mind
		 that NT4 domains are mostly replaced by AD these days. */
	      else
		{
		  WCHAR server[INTERNET_MAX_HOST_NAME_LENGTH + 3];
		  NET_API_STATUS nas;
		  PUSER_INFO_3 ui;
		  
		  if (!get_logon_server (cygheap->dom.primary_flat_name (),
					 server, DS_IS_FLAT_NAME))
		    break;
		  nas = NetUserGetInfo (server, name, 3, (PBYTE *) &ui);
		  if (nas != NERR_Success)
		    {
		      debug_printf ("NetUserGetInfo(%W) %u", name, nas);
		      break;
		    }
		  gid = posix_offset + ui->usri3_primary_group_id;
		  home = cygheap->pg.get_home (ui, sid, dom, name,
					       fully_qualified_name);
		  shell = cygheap->pg.get_shell (ui, sid, dom, name,
						 fully_qualified_name);
		  gecos = cygheap->pg.get_gecos (ui, sid, dom, name,
						 fully_qualified_name);
		}
	    }
	  /* Otherwise check account domain (local SAM).*/
	  else
	    {
	      NET_API_STATUS nas;
	      PUSER_INFO_3 ui;
	      PLOCALGROUP_INFO_1 gi;
	      char *pgrp = NULL;
	      char *uxid = NULL;

	      if (acc_type == SidTypeUser)
		{
		  nas = NetUserGetInfo (NULL, name, 3, (PBYTE *) &ui);
		  if (nas != NERR_Success)
		    {
		      debug_printf ("NetUserGetInfo(%W) %u", name, nas);
		      break;
		    }
		  /* Fetch user attributes. */
		  home = cygheap->pg.get_home (ui, sid, dom, name,
					       fully_qualified_name);
		  shell = cygheap->pg.get_shell (ui, sid, dom, name,
						 fully_qualified_name);
		  gecos = cygheap->pg.get_gecos (ui, sid, dom, name,
						 fully_qualified_name);
		  uxid = fetch_from_description (ui->usri3_comment,
						 L"unix=\"", 6);
		  pgrp = fetch_from_description (ui->usri3_comment,
						 L"group=\"", 7);
		}
	      else /* acc_type == SidTypeAlias */
		{
		  nas = NetLocalGroupGetInfo (NULL, name, 1, (PBYTE *) &gi);
		  if (nas != NERR_Success)
		    {
		      debug_printf ("NetLocalGroupGetInfo(%W) %u", name, nas);
		      break;
		    }
		  /* Fetch unix gid from comment field. */
		  uxid = fetch_from_description (gi->lgrpi1_comment,
						 L"unix=\"", 6);
		}

	      if (acc_type == SidTypeUser)
		NetApiBufferFree (ui);
	      else
		NetApiBufferFree (gi);
	      if (pgrp)
		{
		  /* Set primary group from the "Description" field.  Prepend
		     account domain if this is a domain member machine or the
		     db_prefix setting requires it. */
		  char gname[2 * DNLEN + strlen (pgrp) + 1], *gp = gname;
		  struct group *gr;

		  if (cygheap->dom.member_machine ()
		      || !cygheap->pg.nss_prefix_auto ())
		    {
		      gp = gname
			   + sys_wcstombs (gname, sizeof gname,
					   cygheap->dom.account_flat_name ());
		      *gp++ = cygheap->pg.nss_separator ()[0];
		    }
		  stpcpy (gp, pgrp);
		  if ((gr = internal_getgrnam (gname, cldap)))
		    gid = gr->gr_gid;
		}
	      char *e;
	      if (!pldap && uxid && ((id_val = strtoul (uxid, &e, 10)), !*e))
		{
		  if (acc_type == SidTypeUser)
		    {
		      if (cygheap->ugid_cache.get_uid (id_val) == ILLEGAL_UID)
			cygheap->ugid_cache.add_uid (id_val, uid);
		    }
		  else if (cygheap->ugid_cache.get_gid (id_val) == ILLEGAL_GID)
		    cygheap->ugid_cache.add_gid (id_val, uid);
		}
	      if (pgrp)
		free (pgrp);
	      if (uxid)
		free (uxid);
	    }
	  break;
	case SidTypeWellKnownGroup:
	  fully_qualified_name = (cygheap->pg.nss_prefix_always ()
		  /* NT SERVICE Account */
		  || (sid_id_auth (sid) == 5 /* SECURITY_NT_AUTHORITY */
		      && sid_sub_auth (sid, 0) == SECURITY_SERVICE_ID_BASE_RID)
		  /* Microsoft Account */
		  || sid_id_auth (sid) == 11);
#ifdef INTERIX_COMPATIBLE
	  if (sid_id_auth (sid) == 5 /* SECURITY_NT_AUTHORITY */
	      && sid_sub_auth_count (sid) > 1)
	    {
	      uid = 0x1000 * sid_sub_auth (sid, 0)
		    + (sid_sub_auth_rid (sid) & 0xffff);
	      fully_qualified_name = true;
	    }
	  else
	    uid = 0x10000 + 0x100 * sid_id_auth (sid)
		  + (sid_sub_auth_rid (sid) & 0xff);
#else
	  if (sid_id_auth (sid) == 15 /* SECURITY_APP_PACKAGE_AUTHORITY */)
	    uid = 0x10000 + 0x100 * sid_id_auth (sid)
		  + 0x10 * sid_sub_auth (sid, 0)
		  + (sid_sub_auth_rid (sid) & 0xf);
	  else if (sid_id_auth (sid) != 5 /* SECURITY_NT_AUTHORITY */)
	    uid = 0x10000 + 0x100 * sid_id_auth (sid)
		  + (sid_sub_auth_rid (sid) & 0xff);
	  else if (sid_sub_auth (sid, 0) < SECURITY_PACKAGE_BASE_RID
		   || sid_sub_auth (sid, 0) > SECURITY_MAX_BASE_RID)
	    uid = sid_sub_auth_rid (sid) & 0x7ff;
	  else
	    {
	      uid = 0x1000 * sid_sub_auth (sid, 0)
		    + (sid_sub_auth_rid (sid) & 0xffff);
	    }
#endif
	  /* Special case for "NULL SID", S-1-0-0 and "Everyone", S-1-1-0.
	     Never return "NULL SID" or Everyone as user or group. */
	  if (uid == 0x10000 || uid == 0x10100)
	    return NULL;
	  break;
	case SidTypeLabel:
	  uid = 0x60000 + sid_sub_auth_rid (sid);
	  fully_qualified_name = cygheap->pg.nss_prefix_always ();
	  break;
	default:
	  return NULL;
	}
    } 
  else if (sid_id_auth (sid) == 5 /* SECURITY_NT_AUTHORITY */
	   && sid_sub_auth (sid, 0) == SECURITY_LOGON_IDS_RID)
    {
      /* Logon ID. Mine or other? */
      get_logon_sid ();
      if (PSID (logon_sid) == NO_SID)
	return NULL;
      if (RtlEqualSid (sid, logon_sid))
	{
	  uid = 0xfff;
	  wcpcpy (name = namebuf, L"CurrentSession");
	}
      else
	{
	  uid = 0xffe;
	  wcpcpy (name = namebuf, L"OtherSession");
	}
      acc_type = SidTypeUnknown;
    }
  else if (sid_id_auth (sid) == 18)
    {
      /* Authentication assertion SIDs.
      
         Available when using a 2012R2 DC, but not supported by
	 LookupAccountXXX on pre Windows 8/2012 machines */
      uid = 0x11200 + sid_sub_auth_rid (sid);
      wcpcpy (name = namebuf, sid_sub_auth_rid (sid) == 1
	      ? (PWCHAR) L"Authentication authority asserted identity"
	      : (PWCHAR) L"Service asserted identity");
      fully_qualified_name = false;
      acc_type = SidTypeUnknown;
    }
  else if (sid_id_auth (sid) == 22)
    {
      /* Samba UNIX Users/Groups

         This *might* collide with a posix_offset of some trusted domain.
         It's just very unlikely. */
      uid = MAP_UNIX_TO_CYGWIN_ID (sid_sub_auth_rid (sid));
      /* Unfortunately we have no access to the file server from here,
	 so we can't generate correct user names. */
      p = wcpcpy (dom, L"Unix_");
      wcpcpy (p, sid_sub_auth (sid, 0) == 1 ? L"User" : L"Group");
      __small_swprintf (name = namebuf, L"%d", uid & UNIX_POSIX_MASK);
      fully_qualified_name = true;
      acc_type = SidTypeUnknown;
    }
  else
    {
      if (cygheap->dom.member_machine ()
	  && sid_id_auth (sid) == 5 /* SECURITY_NT_AUTHORITY */
	  && sid_sub_auth (sid, 0) == SECURITY_NT_NON_UNIQUE)
	{
	  /* Check if we know the domain.  If so, create a passwd/group
	     entry with domain prefix and RID as username. */
	  PDS_DOMAIN_TRUSTSW td = NULL;

	  sid_sub_auth_count (sid) = sid_sub_auth_count (sid) - 1;
	  if (RtlEqualSid (sid, cygheap->dom.primary_sid ()))
	    {
	      domain = cygheap->dom.primary_flat_name ();
	      posix_offset = PRIMARY_POSIX_OFFSET;
	    }
	  else
	    for (ULONG idx = 0; (td = cygheap->dom.trusted_domain (idx)); ++idx)
	      if (td->DomainSid && RtlEqualSid (sid, td->DomainSid))
		{
		  domain = td->NetbiosDomainName;
		  posix_offset = fetch_posix_offset (td, &loc_ldap);
		  break;
		}
	}
      if (domain)
	{
	  sid_sub_auth_count (sid) = sid_sub_auth_count (sid) + 1;
	  wcscpy (dom, domain);
	  __small_swprintf (name = namebuf, L"%W(%u)",
			    is_group () ? L"Group" : L"User",
			    sid_sub_auth_rid (sid));
	  uid = posix_offset + sid_sub_auth_rid (sid);
	}
      else
	{
	  wcpcpy (dom, L"Unknown");
	  wcpcpy (name = namebuf, is_group () ? L"Group" : L"User");
	}
      fully_qualified_name = true;
      acc_type = SidTypeUnknown;
    }

  tmp_pathbuf tp;
  char *linebuf = tp.c_get ();
  char *line = NULL;

  WCHAR posix_name[UNLEN + 1 + DNLEN + 1];
  p = posix_name;
  if (gid == ILLEGAL_GID)
    gid = uid;
  if (fully_qualified_name)
    p = wcpcpy (wcpcpy (p, dom), cygheap->pg.nss_separator ());
  wcpcpy (p, name);

  if (is_group ())
    __small_sprintf (linebuf, "%W:%s:%u:",
		     posix_name, sid.string ((char *) sidstr), uid);
  /* For non-users, create a passwd entry which doesn't allow interactive
     logon.  Unless it's the SYSTEM account.  This conveniently allows to
     logon interactively as SYSTEM for debugging purposes. */
  else if (acc_type != SidTypeUser && sid != well_known_system_sid)
    __small_sprintf (linebuf, "%W:*:%u:%u:U-%W\\%W,%s:/:/sbin/nologin",
		     posix_name, uid, gid,
		     dom, name,
		     sid.string ((char *) sidstr));
  else
    __small_sprintf (linebuf, "%W:*:%u:%u:%s%sU-%W\\%W,%s:%s%W:%s",
		     posix_name, uid, gid,
		     gecos ?: "", gecos ? "," : "",
		     dom, name,
		     sid.string ((char *) sidstr),
		     home ?: "/home/", home ? L"" : name,
		     shell ?: "/bin/bash");
  if (gecos)
    free (gecos);
  if (home)
    free (home);
  if (shell)
    free (shell);
  line = cstrdup (linebuf);
  debug_printf ("line: <%s>", line);
  return line;
}

client_request_pwdgrp::client_request_pwdgrp (fetch_user_arg_t &arg, bool group)
  : client_request (CYGSERVER_REQUEST_PWDGRP, &_parameters, sizeof (_parameters))
{
  size_t len = 0;
  char *p;

  _parameters.in.group = group;
  _parameters.in.type = arg.type;
  switch (arg.type)
    {
    case SID_arg:
      RtlCopySid (sizeof (DBGSID), (PSID) &_parameters.in.arg.sid, *arg.sid);
      len = RtlLengthSid (*arg.sid);
      break;
    case NAME_arg:
      p = stpcpy (_parameters.in.arg.name, arg.name);
      len = p - _parameters.in.arg.name + 1;
      break;
    case ID_arg:
      _parameters.in.arg.id = arg.id;
      len = sizeof (uint32_t);
      break;
    default:
      api_fatal ("Fetching account info from cygserver with wrong arg.type "
		 "%d", arg.type);
    }
  msglen (__builtin_offsetof (struct _pwdgrp_param_t::_pwdgrp_in_t, arg) + len);
}

char *
pwdgrp::fetch_account_from_cygserver (fetch_user_arg_t &arg)
{
  client_request_pwdgrp request (arg, is_group ());
  if (request.make_request () == -1 || request.error_code ())
    {
      /* Cygserver not running?  Don't try again.  This will automatically
	 avoid an endless loop in cygserver itself. */
      if (request.error_code () == ENOSYS)
	cygheap->pg.nss_disable_cygserver_caching ();
      return NULL;
    }
  if (!request.line ())
    return NULL;
  return cstrdup (request.line ());
}

void *
pwdgrp::add_account_from_cygserver (cygpsid &sid)
{
  /* No, Everyone is no group in terms of POSIX. */
  if (sid_id_auth (sid) == 1 /* SECURITY_WORLD_SID_AUTHORITY */
      && sid_sub_auth (sid, 0) == SECURITY_WORLD_RID)
    return NULL;
  fetch_user_arg_t arg;
  arg.type = SID_arg;
  arg.sid = &sid;
  char *line = fetch_account_from_cygserver (arg);
  return add_account_post_fetch (line, true);
}

void *
pwdgrp::add_account_from_cygserver (const char *name)
{
  fetch_user_arg_t arg;
  arg.type = NAME_arg;
  arg.name = name;
  char *line = fetch_account_from_cygserver (arg);
  return add_account_post_fetch (line, true);
}

void *
pwdgrp::add_account_from_cygserver (uint32_t id)
{
  fetch_user_arg_t arg;
  arg.type = ID_arg;
  arg.id = id;
  char *line = fetch_account_from_cygserver (arg);
  return add_account_post_fetch (line, true);
}
@


1.255
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Drop redundant test
	for SidTypeUser.
@
text
@d577 3
a579 2
      if ((this->*parse) ())
	curr_lines++;
d1463 2
a1466 1
      void *ret;
d1469 2
a1470 2
      add_line (line);
      ret = ((char *) pwdgrp_buf) + (curr_lines - 1) * pwdgrp_buf_elem_size;
a1472 1
      return ret;
d1474 1
a1474 1
  return NULL;
@


1.254
log
@	* sec_acl.cc (setacl): Fix bug which leads to ACE duplication in
	case owner SID == group SID.
	(getacl): Reverse order of SID test against group or owner sid to
	prefer owner attributes over group attributes.  Disable setting group
	permissions equivalent to owner permissions if owner == group.  Add
	comment to explain why.  Fix indentation.
	* security.cc (get_attribute_from_acl): Change type of local variables
	containing permission to mode_t.  Apply deny mask to group if group SID
	== owner SID to avoid Everyone permissions to spill over into group
	permissions.  Disable setting group permissions equivalent to owner
	permissions if owner == group.  Add comment to explain why.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Allow user SID as
	group account if user is a "Microsoft Account".  Explain why.  Drop
	workaround enforcing primary group "Users" for "Microsoft Accounts".
@
text
@d2056 1
a2056 1
	  if (is_group () && acc_type == SidTypeUser)
@


1.253
log
@	* uinfo.cc (client_request_pwdgrp::client_request_pwdgrp): Add missing
	break in switch statement.
@
text
@d2056 25
a2080 6
	  /* Don't allow users as group.  While this is technically possible,
	     it doesn't make sense in a POSIX scenario.  It *is* used for
	     Microsoft Accounts, but those are converted to well-known groups
	     above. */
	  if (is_group ())
	    return NULL;
a2252 19
		  /* Logging in with a Microsoft Account, the user's primary
		     group SID is the user's SID.  Security sensitive tools
		     expecting tight file permissions choke on that.  We need
		     an explicit primary group which is not identical to the
		     user account.  Unfortunately, while the default primary
		     group of the account in SAM is still "None", "None" is not
		     in the user token group list.  So, what we do here is to
		     use "Users" as a sane default primary group instead. */
		  if (wincap.has_microsoft_accounts ())
		    {
		      struct cyg_USER_INFO_24 *ui24;
		      nas = NetUserGetInfo (NULL, name, 24, (PBYTE *) &ui24);
		      if (nas == NERR_Success)
			{
			  if (ui24->usri24_internet_identity)
			    gid = DOMAIN_ALIAS_RID_USERS;
			  NetApiBufferFree (ui24);
			}
		    }
@


1.252
log
@	* ldap.h: Remove index macros.
	(class cyg_ldap): Remove members srch_msg and srch_entry.
	(cyg_ldap::get_string_attribute): Remove private method taking index
	argument.
	(cyg_ldap::get_num_attribute): Ditto.  Add method taking attribute name.
	(cyg_ldap::get_primary_gid): Adjust to aforementioned change.
	(cyg_ldap::get_unix_uid): Ditto.
	(cyg_ldap::get_unix_gid): Ditto.
	* ldap.cc: Throughout, use msg and entry in place of srch_msg and
	srch_entry.
	(std_user_attr): Add sAMAccountName and objectSid.
	(group_attr): Ditto.
	(cyg_ldap::close): Drop handling of srch_msg and srch_entry.
	(cyg_ldap::get_string_attribute): Move earlier in file.
	(cyg_ldap::get_num_attribute): Ditto.
	(cyg_ldap::enumerate_ad_accounts): Add comments for clarity.
	Use group_attr or user_attr rather than sid_attr to fetch all desired
	attributes for an account right away.
	(cyg_ldap::next_account): Store found SID in last_fetched_sid to
	skip calls to fetch_ad_account from fetch_account_from_windows.
	(cyg_ldap::get_string_attribute): Remove method taking index argument.
	(cyg_ldap::get_num_attribute): Ditto.
	* pwdgrp.h (class pg_ent): Fix formatting.  Add member dom.
	* passwd.cc (pg_ent::enumerate_ad): Store current flat domain name
	in dom.  Construct fetch_acc_t argument from LDAP attributes and
	call fetch_account_from_windows with that.
	* userinfo.h (enum fetch_user_arg_type_t): Rename FULL_grp_arg to
	FULL_acc_arg.  Change throughout.
	(struct fetch_acc_t): Rename from fetch_full_grp_t.  Change throughout.
	(struct fetch_user_arg_t): Rename full_grp to full_acc.  Change
	throughout.
@
text
@d2520 1
@


1.251
log
@	* autoload.cc (LsaLookupSids): Import.
	* cygserver_pwdgrp.h: Include userinfo.h.  Drop workaround defining
	fetch_user_arg_type_t locally.
	* grp.cc (internal_getgrsid_cachedonly): New function.
	(internal_getgrfull): Ditto.
	(internal_getgroups): Rearrange function.  Center around fetching all
	cached group info first, calling LsaLookupSids on all so far non-cached
	groups second.  Pass all available info to new internal_getgrfull call.
	* pwdgrp.h: Include userinfo.h.  Move definitions of
	fetch_user_arg_type_t and fetch_user_arg_t there.
	(pwdgrp::add_group_from_windows): Declare with getting full group info.
	Called from internal_getgrfull.
	* uinfo.cc (pwdgrp::add_group_from_windows): Define.
	(pwdgrp::fetch_account_from_line): Add default case.
	(pwdgrp::fetch_account_from_file): Ditto.
	(pwdgrp::fetch_account_from_windows): Handle FULL_grp_arg.
	(client_request_pwdgrp::client_request_pwdgrp): Add default case.
	* userinfo.h: New header.
	(enum fetch_user_arg_type_t): Add FULL_grp_arg.
	(struct fetch_full_grp_t): New datatype.
@
text
@d1550 1
a1550 1
pwdgrp::add_group_from_windows (fetch_full_grp_t &full_grp, cyg_ldap *pldap)
d1553 2
a1554 2
  arg.type = FULL_grp_arg;
  arg.full_grp = &full_grp;
d1762 1
a1762 1
    case FULL_grp_arg:
d1764 6
a1769 6
	sid = arg.full_grp->sid;
	*wcpncpy (name, arg.full_grp->name->Buffer,
		  arg.full_grp->name->Length / sizeof (WCHAR)) = L'\0';
	*wcpncpy (dom, arg.full_grp->dom->Buffer,
		  arg.full_grp->dom->Length / sizeof (WCHAR)) = L'\0';
	acc_type = arg.full_grp->acc_type;
@


1.250
log
@	* grp.cc (internal_getgroups): Take additional timeout_ns parameter.
	Restrict fetching group account entries from user token groups by
	timeout_ns 100ns-intervals.  Add preceding comment to explain why.
	* pwdgrp.h (internal_getgroups): Align prototype.
	* times.cc (GetTickCount_ns): New function.
	* uinfo.cc (internal_getlogin): Call internal_getgroups wih 300ms
	timeout.
	* winsup.h (GetTickCount_ns): Declare.
@
text
@d1548 13
d1643 2
d1671 2
d1762 11
d2520 3
@


1.249
log
@	* cygheap.h (cygheap_pwdgrp::get_home): Add dnsdomain parameter to
	declaration in ldap-related method.
	(cygheap_pwdgrp::get_shell): Ditto.
	(cygheap_pwdgrp::get_gecos): Ditto.
	* ldap.cc (cyg_ldap::open): Use NO_ERROR instead of 0.
	(cyg_ldap::close): Reset last_fetched_sid.
	(cyg_ldap::fetch_ad_account): Return immediately if sid is the same as
	last_fetched_sid.  Open LDAP connection from here.  Move initialization
	of rdse after open call.  Set last_fetched_sid if LDAP call was
	successful.
	* ldap.h (class cyg_ldap): Add member last_fetched_sid.
	(cyg_ldap::cyg_ldap): Initialize last_fetched_sid.
	(cyg_ldap::is_open): New inline method.
	* uinfo.cc (cygheap_pwdgrp::init): Drop initialization of db_home,
	db_shell and db_gecos with "cygwin desc", thus only using the fallback
	by default.
	(fetch_windows_home): Add parameter dnsdomain.  Call
	cyg_ldap::fetch_ad_account if required.
	(fetch_from_path): Add parameter dnsdomain.  Call fetch_windows_home
	accordingly.
	(cygheap_pwdgrp::get_home): Accomodate call to fetch_windows_home.
	Add dnsdomain parameter in ldap-related method.  Call
	cyg_ldap::fetch_ad_account if required.
	(cygheap_pwdgrp::get_shell): Ditto.
	(cygheap_pwdgrp::get_gecos): Ditto.
	(pwdgrp::fetch_account_from_windows): Drop cyg_ldap::open call prior to
	cyg_ldap::fetch_ad_account call.  Set is_current_user to true if we're
	handling the current user account.  Make sure to perform the LDAP calls
	only for users, and only if required.
@
text
@d128 1
a128 1
    internal_getgroups (0, NULL, &cldap);
@


1.248
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Allow fetching gid,
	home, shell and gecos info from NT4 domain.
@
text
@d607 1
d614 1
d820 2
a821 1
fetch_windows_home (cyg_ldap *pldap, PUSER_INFO_3 ui, cygpsid &sid)
d828 2
d831 4
a834 4
      /* Disable preferring homeDrive for now.  The drive letter may not
         be available when it's needed. */
      home_from_db = pldap->get_string_attribute (L"homeDrive");
      if (!home_from_db || !*home_from_db)
d836 2
a837 1
	home_from_db = pldap->get_string_attribute (L"homeDirectory");
d911 2
a912 2
fetch_from_path (cyg_ldap *pldap, PUSER_INFO_3 ui, cygpsid &sid,
		 PCWSTR str, PCWSTR dom, PCWSTR name, bool full_qualified)
d945 1
a945 1
	      home = fetch_windows_home (pldap, ui, sid);
d974 1
a974 1
			  PCWSTR name, bool full_qualified)
d986 2
a987 1
	  home = fetch_windows_home (pldap, NULL, sid);
d990 6
a995 3
	  val = pldap->get_string_attribute (L"cygwinHome");
	  if (val && *val)
	    sys_wcstombs_alloc (&home, HEAP_NOTHEAP, val);
d998 6
a1003 3
	  val = pldap->get_string_attribute (L"unixHomeDirectory");
	  if (val && *val)
	    sys_wcstombs_alloc (&home, HEAP_NOTHEAP, val);
d1006 6
a1011 3
	  val = pldap->get_string_attribute (L"description");
	  if (val && *val)
	    home = fetch_from_description (val, L"home=\"", 6);
d1015 1
a1015 1
				  dom, name, full_qualified);
d1018 1
a1018 2
	  val = pldap->get_string_attribute (home_scheme[idx].attrib);
	  if (val && *val)
d1020 9
a1028 4
	      if (isdrive (val) || *val == '\\')
		home = (char *) cygwin_create_path (CCP_WIN_W_TO_POSIX, val);
	      else
		sys_wcstombs_alloc (&home, HEAP_NOTHEAP, val);
d1049 1
a1049 1
	  home = fetch_windows_home (NULL, ui, sid);
d1060 1
a1060 1
				  dom, name, full_qualified);
d1069 1
a1069 1
			   PCWSTR name, bool full_qualified)
d1083 6
a1088 3
	  val = pldap->get_string_attribute (L"cygwinShell");
	  if (val && *val)
	    sys_wcstombs_alloc (&shell, HEAP_NOTHEAP, val);
d1091 6
a1096 3
	  val = pldap->get_string_attribute (L"loginShell");
	  if (val && *val)
	    sys_wcstombs_alloc (&shell, HEAP_NOTHEAP, val);
d1099 6
a1104 3
	  val = pldap->get_string_attribute (L"description");
	  if (val && *val)
	    shell = fetch_from_description (val, L"shell=\"", 7);
d1108 1
a1108 1
	  			   dom, name, full_qualified);
d1111 1
a1111 2
	  val = pldap->get_string_attribute (shell_scheme[idx].attrib);
	  if (val && *val)
d1113 9
a1121 4
	      if (isdrive (val) || *val == '\\')
		shell = (char *) cygwin_create_path (CCP_WIN_W_TO_POSIX, val);
	      else
		sys_wcstombs_alloc (&shell, HEAP_NOTHEAP, val);
d1151 1
a1151 1
				   dom, name, full_qualified);
d1169 1
a1169 1
			   PCWSTR name, bool full_qualified)
d1181 6
a1186 3
	  val = pldap->get_string_attribute (L"displayName");
	  if (val && *val)
	    sys_wcstombs_alloc (&gecos, HEAP_NOTHEAP, val);
d1189 6
a1194 3
	  val = pldap->get_string_attribute (L"cygwinGecos");
	  if (val && *val)
	    sys_wcstombs_alloc (&gecos, HEAP_NOTHEAP, val);
d1197 6
a1202 3
	  val = pldap->get_string_attribute (L"gecos");
	  if (val && *val)
	    sys_wcstombs_alloc (&gecos, HEAP_NOTHEAP, val);
d1205 6
a1210 3
	  val = pldap->get_string_attribute (L"description");
	  if (val && *val)
	    gecos = fetch_from_description (val, L"gecos=\"", 7);
d1215 1
a1215 1
				   dom, name, full_qualified);
d1218 6
a1223 3
	  val = pldap->get_string_attribute (gecos_scheme[idx].attrib);
	  if (val && *val)
	    sys_wcstombs_alloc (&gecos, HEAP_NOTHEAP, val);
d1257 1
a1257 1
				   dom, name, full_qualified);
d1727 1
d1760 1
a1760 2
	  if (cldap->open (NULL) == NO_ERROR
	      && cldap->fetch_ad_account (sid, is_group ())
d2120 5
a2124 2
		gid = posix_offset
		      + sid_sub_auth_rid (cygheap->user.groups.pgsid);
d2131 3
d2137 16
a2152 3
		  if (cldap->open (NULL) != NO_ERROR)
		    break;
		  if (cldap->fetch_ad_account (sid, is_group (), domain))
d2154 5
a2158 21
		      if ((id_val = cldap->get_primary_gid ()) != ILLEGAL_GID)
			gid = posix_offset + id_val;
		      if (!is_group ())
			{
			  home = cygheap->pg.get_home (cldap, sid, dom, name,
						       fully_qualified_name);
			  shell = cygheap->pg.get_shell (cldap, sid, dom, name,
							 fully_qualified_name);
			  gecos = cygheap->pg.get_gecos (cldap, sid, dom, name,
							 fully_qualified_name);
			}
		      /* Check and, if necessary, add unix<->windows id mapping
			 on the fly, unless we're called from getpwent. */
		      if (!pldap)
			{
			  id_val = cldap->get_unix_uid ();
			  if (id_val != ILLEGAL_UID
			      && cygheap->ugid_cache.get_uid (id_val)
				 == ILLEGAL_UID)
			    cygheap->ugid_cache.add_uid (id_val, uid);
			}
d2165 1
a2165 1
	      else if (!is_group () && acc_type == SidTypeUser)
@


1.247
log
@	* uinfo.cc (fetch_windows_home): Disable fetching from homeDrive or
	usri3_home_dir_drive.  Add comment.
@
text
@d2080 2
a2081 4
	      /* Use LDAP to fetch domain account infos. */
	      if (cldap->open (NULL) != NO_ERROR)
		break;
	      if (cldap->fetch_ad_account (sid, is_group (), domain))
d2083 3
a2085 3
		  if ((id_val = cldap->get_primary_gid ()) != ILLEGAL_GID)
		    gid = posix_offset + id_val;
		  if (!is_group ())
d2087 21
a2107 6
		      home = cygheap->pg.get_home (cldap, sid, dom, name,
						   fully_qualified_name);
		      shell = cygheap->pg.get_shell (cldap, sid, dom, name,
						     fully_qualified_name);
		      gecos = cygheap->pg.get_gecos (cldap, sid, dom, name,
						     fully_qualified_name);
d2109 16
a2124 3
		  /* Check and, if necessary, add unix<->windows id mapping on
		     the fly, unless we're called from getpwent. */
		  if (!pldap)
d2126 2
a2127 5
		      id_val = cldap->get_unix_uid ();
		      if (id_val != ILLEGAL_UID
			  && cygheap->ugid_cache.get_uid (id_val)
			     == ILLEGAL_UID)
			cygheap->ugid_cache.add_uid (id_val, uid);
d2129 7
@


1.246
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Drop code from
	2014-11-17, always prepending domain to NT SERVICE accounts when
	searching by name.  Fix test expression to allow fully qualified
	names for NT SERVICE accounts.  Extend comment to explain a bit.
@
text
@d825 3
d830 1
d835 2
d839 3
a841 1
      else if (ui->usri3_home_dir && *ui->usri3_home_dir)
@


1.245
log
@	* cygheap.h (cygheap_pwdgrp::get_shell): Add sid to argument list.
	(cygheap_pwdgrp::get_gecos): Ditto.
	* uinfo.cc (fetch_windows_home): Accept cyg_ldap and PUSER_INFO_3
	arguments, and fetch db home dir values right here.
	(fetch_from_path): Accept cyg_ldap, PUSER_INFO_3 pointers and sid
	arguments.  Add '%H' format specifier to fetch Windows home dir in
	POSIX notation.
	(cygheap_pwdgrp::get_home): Accommodate changes to fetch_windows_home
	and fetch_from_path.
	(cygheap_pwdgrp::get_shell): Ditto.
	(cygheap_pwdgrp::get_gecos): Ditto.
	(pwdgrp::fetch_account_from_windows): Accommodate sid argument to
	cygheap_pwdgrp::get_shell and cygheap_pwdgrp::get_gecos.
@
text
@a1751 13
      /* LookupAccountName doesn't find NT SERVICE accounts.  Try just for
      	 kicks (and to make TrustedInstaller work here :-P */
      else if (!ret)
	{
	  p = wcpcpy (name, L"NT SERVICE");
	  *p = L'\\';
	  sys_mbstowcs (p + 1, UNLEN + 1, arg.name);
	  slen = SECURITY_MAX_SID_SIZE;
	  dlen = DNLEN + 1;
	  sid = csid;
	  ret = LookupAccountNameW (NULL, name, sid, &slen, dom, &dlen,
				    &acc_type);
	}
d1797 5
a1801 1
	  /* Otherwise, no fully_qualified for builtin accounts. */
d1803 2
a1804 1
	      || sid_sub_auth (sid, 0) != SECURITY_NT_NON_UNIQUE)
d1807 1
a1807 1
			    "not NON_UNIQUE)", arg.name);
@


1.244
log
@	* uinfo.cc (fetch_windows_home): New function fetching Windows-compliant
	home directory.  Include longish comment to explain what we're doing.
	(cygheap_pwdgrp::get_home): Take additional sid parameter.  In
	NSS_SCHEME_WINDOWS case, call fetch_windows_home to create home
	directory.
	(pwdgrp::fetch_account_from_windows): Call cygheap_pwdgrp::get_home
	with additional sid argument.
	* cygheap.h (cygheap_pwdgrp::get_home): Align declaration to above
	change.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2014 Red Hat, Inc.
d818 1
a818 1
fetch_windows_home (PCWSTR home_from_db, cygpsid &sid)
d820 1
d823 13
d897 2
a898 1
fetch_from_path (PCWSTR str, PCWSTR dom, PCWSTR name, bool full_qualified)
d904 1
d930 13
d972 1
a972 4
	  val = pldap->get_string_attribute (L"homeDrive");
	  if (!val || !*val)
	    val = pldap->get_string_attribute (L"homeDirectory");
	  home = fetch_windows_home (val, sid);
d990 2
a991 2
	  home = fetch_from_path (home_scheme[idx].attrib, dom, name,
				  full_qualified);
a1011 1
  PWCHAR val = NULL;
d1021 1
a1021 5
	  if (ui->usri3_home_dir_drive && *ui->usri3_home_dir_drive)
	    val = ui->usri3_home_dir_drive;
	  else if (ui->usri3_home_dir && *ui->usri3_home_dir)
	    val = ui->usri3_home_dir;
	  home = fetch_windows_home (val, sid);
d1031 2
a1032 2
	  home = fetch_from_path (home_scheme[idx].attrib, dom, name,
				  full_qualified);
d1040 2
a1041 2
cygheap_pwdgrp::get_shell (cyg_ldap *pldap, PCWSTR dom, PCWSTR name,
			   bool full_qualified)
d1070 2
a1071 2
	  shell = fetch_from_path (shell_scheme[idx].attrib, dom, name,
				   full_qualified);
d1089 2
a1090 2
cygheap_pwdgrp::get_shell (PUSER_INFO_3 ui, PCWSTR dom, PCWSTR name,
			   bool full_qualified)
d1109 2
a1110 2
	  shell = fetch_from_path (shell_scheme[idx].attrib, dom, name,
				   full_qualified);
d1127 2
a1128 2
cygheap_pwdgrp::get_gecos (cyg_ldap *pldap, PCWSTR dom, PCWSTR name,
			   bool full_qualified)
d1160 3
a1162 2
	  gecos = fetch_from_path (gecos_scheme[idx].attrib + 1, dom, name,
				   full_qualified);
d1177 2
a1178 2
cygheap_pwdgrp::get_gecos (PUSER_INFO_3 ui, PCWSTR dom, PCWSTR name,
			   bool full_qualified)
d1200 2
a1201 2
	  gecos = fetch_from_path (gecos_scheme[idx].attrib + 1, dom, name,
				   full_qualified);
d2091 1
a2091 1
		      shell = cygheap->pg.get_shell (cldap, dom, name,
d2093 1
a2093 1
		      gecos = cygheap->pg.get_gecos (cldap, dom, name,
d2147 1
a2147 1
		  shell = cygheap->pg.get_shell (ui, dom, name,
d2149 1
a2149 1
		  gecos = cygheap->pg.get_gecos (ui, dom, name,
@


1.243
log
@	* uinfo.cc (cygheap_user::ontherange): Fix order of fallbacks creating
	HOMEDRIVE/HOMEPATH values to be Windows-compliant.  Add comments.
@
text
@d817 30
d930 2
a931 2
cygheap_pwdgrp::get_home (cyg_ldap *pldap, PCWSTR dom, PCWSTR name,
			  bool full_qualified)
d946 1
a946 2
	  if (val && *val)
	    home = (char *) cygwin_create_path (CCP_WIN_W_TO_POSIX, val);
d983 2
a984 2
cygheap_pwdgrp::get_home (PUSER_INFO_3 ui, PCWSTR dom, PCWSTR name,
			  bool full_qualified)
d986 1
d997 1
a997 2
	    home = (char *) cygwin_create_path (CCP_WIN_W_TO_POSIX,
						ui->usri3_home_dir_drive);
d999 2
a1000 2
	    home = (char *) cygwin_create_path (CCP_WIN_W_TO_POSIX,
						ui->usri3_home_dir);
d2067 1
a2067 1
		      home = cygheap->pg.get_home (cldap, dom, name,
d2123 1
a2123 1
		  home = cygheap->pg.get_home (ui, dom, name,
@


1.242
log
@	* autoload.cc (CreateProfile): Import.
	(LoadUserProfileW): Import.
	* registry.cc (get_registry_hive_path): Move to sec_auth.cc.
	(load_registry_hive): Remove.
	* registry.h (get_registry_hive_path): Drop declaration.
	(load_registry_hive): Ditto.
	* sec_auth.cc (get_user_profile_directory): Moved from registry.cc and
	renamed.  Take third parameter with buffer length.
	(load_user_profile): New function taking over for load_registry_hive.
	Use official functions to load profile.  If profile is missing, create
	it on Vista and later.
	* security.h (get_user_profile_directory): Declare.
	(load_user_profile): Declare.
	* syscalls.cc (seteuid32): Replace call to load_registry_hive with call
	to load_user_profile.
	* uinfo.cc (cygheap_user::env_userprofile): Replace call to
	get_registry_hive_path with call to get_user_profile_directory.
@
text
@a322 3
  PUSER_INFO_3 ui = NULL;
  WCHAR wuser[UNLEN + 1];
  NET_API_STATUS ret;
d353 1
a353 1
  if (what != CH_HOME && homepath == NULL && newhomepath == NULL)
d355 3
d359 10
a368 2
      if (!pw)
	pw = internal_getpwnam (name ());
d372 2
a373 1
      else
d375 5
a379 2
	  homepath_env_buf[0] = homepath_env_buf[1] = '\0';
	  if (logsrv ())
d381 1
a381 5
	      WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
	      sys_mbstowcs (wlogsrv, sizeof (wlogsrv) / sizeof (*wlogsrv),
			    logsrv ());
	      sys_mbstowcs (wuser, sizeof wuser / sizeof *wuser, winname ());
	      if (!(ret = NetUserGetInfo (wlogsrv, wuser, 3, (LPBYTE *) &ui)))
d384 2
a385 11
				ui->usri3_home_dir);
		  if (!homepath_env_buf[0])
		    {
		      sys_wcstombs (homepath_env_buf, NT_MAX_PATH,
				    ui->usri3_home_dir_drive);
		      if (homepath_env_buf[0])
			strcat (homepath_env_buf, "\\");
		      else
			cygwin_conv_path (CCP_POSIX_TO_WIN_A | CCP_ABSOLUTE,
					  "/", homepath_env_buf, NT_MAX_PATH);
		    }
d387 3
d394 9
@


1.241
log
@	* uinfo.cc (fetch_from_description): Make static.
	(fetch_from_path): Ditto.
@
text
@d485 2
a486 2
  /* User hive path is never longer than MAX_PATH. */
  WCHAR userprofile_env_buf[MAX_PATH];
d490 2
a491 2
  if (get_registry_hive_path (get_windows_id (win_id), userprofile_env_buf))
    sys_wcstombs_alloc (&puserprof, HEAP_STR, userprofile_env_buf);
@


1.240
log
@	* mount.cc (mount_info::init): Take bool argument and allow to
	initialize mount table in two steps, system and user, depending on
	bool value.
	* mount.h (class mount_info): Align declaration of init function to
	above change.
	* shared.cc (user_info::initialize): Initialize mount table in two
	steps to allow internal_getpwsid to create valid POSIX paths from
	DOS paths given in AD.  Add comments.
	* uinfo.cc (cygheap_pwdgrp::get_home): Allow DOS paths in
	NSS_SCHEME_FREEATTR attributes.
	(cygheap_pwdgrp::get_shell): Ditto.
@
text
@d810 1
a810 1
char *
d841 1
a841 1
char *
@


1.239
log
@	* Makefile.in (install): Add install-ldif target.
	(install-ldif): New target to install cygwin.ldif.
	* cygheap.h (class cygheap_pwdgrp): Rename pfx_t to nss_pfx_t.  Add
	PFX to enum value.  Add nss_scheme_method enum and nss_scheme_t
	structure.  Add home_scheme, shell_scheme and gecos_scheme members.
	(NSS_SCHEME_MAX): Define.
	(cygheap_pwdgrp::get_home): Declare.
	(cygheap_pwdgrp::get_shell): Declare.
	(cygheap_pwdgrp::get_gecos): Declare.
	* cygwin.ldif: New file.
	* ldap.cc (std_user_attr): New array, just defining the standard
	attributes.
	(group_attr): Add cygwinUnixGid.
	(user_attr): Convert to macro pointing to cygheap->pg.ldap_user_attr.
	(cygheap_pwdgrp::init_ldap_user_attr): New method.
	(cyg_ldap::fetch_ad_account): Call cygheap_pwdgrp::init_ldap_user_attr
	if user_attr initialization is required.  Fix comment.
	(cyg_ldap::get_string_attribute): Implement taking attribute name
	as argument.
	* ldap.h: Drop unused macros.
	(cyg_ldap::get_gecos): Remove.
	(cyg_ldap::get_home): Remove.
	(cyg_ldap::get_shell): Remove.
	(cyg_ldap::get_string_attribute): Declare name argument variant public.
	* uinfo.cc (cygheap_user::ontherange): Fix indentation.
	(cygheap_pwdgrp::init): Initialize new home_scheme, shell_scheme and
	gecos_scheme members.  Align comment.
	(NSS_NCMP): Define comparison macro.
	(NSS_CMP): Ditto.
	(cygheap_pwdgrp::nss_init_line): Use aforementioned macros throughout.
	Fix comment handling.  Add db_home, db_shell and db_gecos handling.
	(fetch_from_description): New function to fetch XML-style attributes
	from (description) string.
	(fetch_from_path): New function to evaluate path string with wildcards.
	(cygheap_pwdgrp::get_home): New methods to fetch pw_dir value.
	(cygheap_pwdgrp::get_shell): Ditto for pw_shell.
	(cygheap_pwdgrp::get_gecos): Ditto for pw_gecos.
	(colon_to_semicolon): Move up.
	(pwdgrp::fetch_account_from_windows): Convert home, shell, gecos
	variables to char*.  Drop statement breaking extended group info.
	Fetch home, shell and gecos values using new methods.  Use
	fetch_from_description calls to fetch UNIX id and primary groups from
	SAM comment field.  Accommodate uxid being a char* now.  Accommodate
	the fact that extended info is malloc'ed, rather then alloca'ed.
	Create linebuf content as multibyte string.  Create line buffer by
	just calling cstrdup.
@
text
@d930 6
a935 1
	    sys_wcstombs_alloc (&home, HEAP_NOTHEAP, val);
d1015 6
a1020 1
	    sys_wcstombs_alloc (&shell, HEAP_NOTHEAP, val);
@


1.238
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Allow fetching of
	NT SERVICE accounts by name.  Always prepend domain to NT SERVICE
	accounts.  Add U-domain\username string to pw_gecos for predefined
	builtin accounts as well.
@
text
@d323 1
a323 1
  LPUSER_INFO_3 ui = NULL;
d372 1
a372 1
	     sys_mbstowcs (wuser, sizeof (wuser) / sizeof (*wuser), winname ());
d587 3
d594 1
a594 1
  prefix = NSS_AUTO;
d596 6
d607 4
d618 3
d626 6
a631 11
	int *src = NULL;
	if (!strncmp (c, "passwd:", 7))
	  {
	    src = &pwd_src;
	    c += 7;
	  }
	else if (!strncmp (c, "group:", 6))
	  {
	    src = &grp_src;
	    c += 6;
	  }
d635 1
a635 1
	    while (*c)
d637 1
a637 4
		c += strspn (c, " \t");
		if (!*c || *c == '#')
		  break;
		if (!strncmp (c, "files", 5) && strchr (" \t", c[5]))
d642 1
a642 1
		else if (!strncmp (c, "db", 2) && strchr (" \t", c[2]))
d659 1
a659 1
      if (strncmp (c, "db_", 3))
d667 1
a667 1
      if (!strncmp (c, "prefix:", 7))
d669 1
a669 1
	  c += 7;
d671 1
a671 1
	  if (!strncmp (c, "auto", 4) && strchr (" \t", c[4]))
d673 1
a673 1
	  else if (!strncmp (c, "primary", 7) && strchr (" \t", c[7]))
d675 1
a675 1
	  else if (!strncmp (c, "always", 6) && strchr (" \t", c[6]))
d680 1
a680 1
      else if (!strncmp (c, "separator:", 10))
d682 1
a682 1
	  c += 10;
d691 1
a691 1
      if (!strncmp (c, "enum:", 5))
d699 1
a699 1
	  c += 5;
d704 1
a704 1
	      if (!strncmp (c, "none", 4) && strchr (" \t", c[4]))
d706 1
a706 1
	      else if (!strncmp (c, "builtin", 7) && strchr (" \t", c[7]))
d708 1
a708 1
	      else if (!strncmp (c, "cache", 5) && strchr (" \t", c[5]))
d710 1
a710 1
	      else if (!strncmp (c, "files", 5) && strchr (" \t", c[5]))
d712 1
a712 1
	      else if (!strncmp (c, "local", 5) && strchr (" \t", c[5]))
d714 1
a714 1
	      else if (!strncmp (c, "primary", 7) && strchr (" \t", c[7]))
d716 1
a716 1
	      else if (!strncmp (c, "alltrusted", 10) && strchr (" \t", c[10]))
d718 1
a718 1
	      else if (!strncmp (c, "all", 3) && strchr (" \t", c[3]))
d743 54
a798 1
    case '#':
d806 332
a1565 10
/* Helper function to replace colons with semicolons in pw_gecos field. */
static PWCHAR
colon_to_semicolon (PWCHAR str)
{
  PWCHAR cp = str;
  while ((cp = wcschr (cp, L':')) != NULL)
    *cp++ = L';';
  return str;
}

d1599 3
a1601 3
  PWCHAR shell = NULL;
  PWCHAR home = NULL;
  PWCHAR gecos = NULL;
d1990 1
a1990 1
	  /* Generate values. */
d1993 1
a1993 7

	  /* We only care for extended user information if we're creating a
	     passwd entry and the account is a user or alias. */
	  if (is_group () || acc_type == SidTypeGroup)
	    break;

	  if (acc_type == SidTypeUser)
a2012 2
		  PWCHAR val;

d2015 9
a2023 10
		  if ((val = cldap->get_gecos ()))
		    gecos = colon_to_semicolon (
			      wcscpy ((PWCHAR) alloca ((wcslen (val) + 1)
				      * sizeof (WCHAR)), val));
		  if ((val = cldap->get_home ()))
		    home = wcscpy ((PWCHAR) alloca ((wcslen (val) + 1)
				   * sizeof (WCHAR)), val);
		  if ((val = cldap->get_shell ()))
		    shell = wcscpy ((PWCHAR) alloca ((wcslen (val) + 1)
				    * sizeof (WCHAR)), val);
d2040 1
a2040 1
	      PUSER_INFO_4 ui;
d2042 2
a2043 16
	      PCWSTR comment;
	      PWCHAR pgrp = NULL;
	      PWCHAR uxid = NULL;
	      struct {
		PCWSTR str;
		size_t len;
		PWCHAR *tgt;
		bool group;
	      } search[] = {
		{ L"unix=\"", 6, &uxid, true },
		{ L"home=\"", 6, &home, false },
		{ L"shell=\"", 7, &shell, false },
		{ L"group=\"", 7, &pgrp, false },
		{ NULL, 0, NULL }
	      };
	      PWCHAR s, e;
d2047 1
a2047 1
		  nas = NetUserGetInfo (NULL, name, 4, (PBYTE *) &ui);
a2052 2
		  /* Set comment variable for below attribute loop. */
		  comment = ui->usri4_comment;
d2072 11
d2092 3
a2094 2
		  /* Set comment variable for below attribute loop. */
		  comment = gi->lgrpi1_comment;
a2095 12
	      /* Local SAM accounts have only a handful attributes
		 available to home users.  Therefore, fetch additional
		 passwd/group attributes from the "Description" field
		 in XML short style. */
	      if ((s = wcsstr (comment, L"<cygwin "))
		  && (e = wcsstr (s + 8, L"/>")))
		{
		  s += 8;
		  *e = L'\0';
		  while (*s)
		    {
		      bool found = false;
a2096 24
		      while (*s == L' ')
			++s;
		      for (size_t i = 0; search[i].str; ++i)
			if ((acc_type == SidTypeUser || search[i].group)
			    && !wcsncmp (s, search[i].str, search[i].len))
			  {
			    s += search[i].len;
			    if ((e = wcschr (s, L'"'))
				&& (i > 0 || wcsncmp (name, s, e - s)))
			      {
				*search[i].tgt =
				    (PWCHAR) alloca ((e - s + 1)
						     * sizeof (WCHAR));
				*wcpncpy (*search[i].tgt, s, e - s) = L'\0';
				s = e + 1;
				found = true;
			      }
			    else
			      break;
			  }
		      if (!found)
			break;
		    }
		}
d2106 1
a2106 1
		  char gname[2 * (DNLEN + UNLEN) + 2], *gp = gname;
d2117 1
a2117 1
		  sys_wcstombs (gp, sizeof gname - (gp - gname), pgrp);
d2121 2
a2122 1
	      if (!pldap && uxid && ((id_val = wcstoul (uxid, &e, 10)), !*e))
d2132 4
d2277 1
a2277 1
  PWCHAR linebuf = tp.w_get ();
d2289 2
a2290 2
    __small_swprintf (linebuf, L"%W:%W:%u:",
		      posix_name, sid.string (sidstr), uid);
d2295 4
a2298 2
    __small_swprintf (linebuf, L"%W:*:%u:%u:U-%W\\%W,%W:/:/sbin/nologin",
		      posix_name, uid, gid, dom, name, sid.string (sidstr));
d2300 14
a2313 8
    __small_swprintf (linebuf, L"%W:*:%u:%u:%W%WU-%W\\%W,%W:%W%W:%W",
		      posix_name, uid, gid,
		      gecos ?: L"", gecos ? L"," : L"",
		      dom, name,
		      sid.string (sidstr),
		      home ? L"" : L"/home/", home ?: name,
		      shell ?: L"/bin/bash");
  sys_wcstombs_alloc (&line, HEAP_BUF, linebuf);
@


1.237
log
@	* cygheap.h (cygheap_pwdgrp): Remove constants NSS_FILES and NSS_DB.
	Use NSS_SRC_FILES and NSS_SRC_DB throughout instead.
	(cygheap_pwdgrp::nss_pwd_src): New inline method.
	(cygheap_pwdgrp::nss_grp_src): Ditto.
	* external.cc (cygwin_internal): Add CW_GETNSS_PWD_SRC and
	CW_GETNSS_GRP_SRC cases.
	* uinfo.cc: Use NSS_SRC_FILES and NSS_SRC_DB throughout.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GETNSS_PWD_SRC
	and CW_GETNSS_GRP_SRC.
	(NSS_SRC_FILES): Define.
	(NSS_SRC_DB): Define.
@
text
@d1297 13
d1801 5
a1805 2
				  /* Microsoft Account */
				  || sid_id_auth (sid) == 11);
d1956 2
a1957 2
    __small_swprintf (linebuf, L"%W:*:%u:%u:,%W:/:/sbin/nologin",
		      posix_name, uid, gid, sid.string (sidstr));
@


1.236
log
@	* uinfo.cc (cygheap_user::ontherange): Don't mention /etc/passwd.
@
text
@d589 2
a590 2
  pwd_src = (NSS_FILES | NSS_DB);
  grp_src = (NSS_FILES | NSS_DB);
d631 1
a631 1
		    *src |= NSS_FILES;
d636 1
a636 1
		    *src |= NSS_DB;
d646 1
a646 1
	      *src = (NSS_FILES | NSS_DB);
@


1.235
log
@	* cygheap.cc (cygheap_fixup_in_child): Drop call to set_dll_dir.
	(init_cygheap::init_installation_root): Set installation_dir_len.
	(setup_cygheap): Drop call to set_dll_dir.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	(init_cygheap::set_dll_dir): Remove.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

	* uinfo.cc (cygheap_pwdgrp::_nss_init): Fill UNICODE_STRING members
	on the fly.  Drop call to RtlInitUnicodeString.
	(pwdgrp::check_file): Ditto.
@
text
@d342 1
a342 1
	      debug_printf ("Set HOME (from /etc/passwd) to %s", pw->pw_dir);
@


1.234
log
@	* exception.h (class exception): Remove unnecessary #ifdef.
	* uinfo.cc (client_request_pwdgrp::client_request_pwdgrp): Fix length
	counter to include trailing NUL.

	* sec_auth.cc (get_user_groups): Add experimental exception handler.
	(get_user_local_groups): Ditto.
@
text
@d755 4
a758 2
  path.Buffer = (PWCHAR) alloca ((wcslen (cygheap->installation_root)
				  + wcslen (rel_path) + 1) * sizeof (WCHAR));
a759 1
  RtlInitUnicodeString (&path, path.Buffer);
d1049 4
a1052 4
      path.Buffer = (PWCHAR) cmalloc_abort (HEAP_BUF,
					    (wcslen (cygheap->installation_root)
					     + wcslen (rel_path) + 1)
					    * sizeof (WCHAR));
a1053 1
      RtlInitUnicodeString (&path, path.Buffer);
@


1.233
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Handle APPLICATION
	PACKAGE AUTHORITY SIDs.
	* winlean.h (DNLEN): Raise to 31.  Explain why.
@
text
@d1971 1
a1971 1
      len = p - _parameters.in.arg.name;
@


1.232
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Disallow user accounts
	as groups.  Add comment.
@
text
@d1414 6
a1419 1
	  __small_swprintf (sidstr, L"S-1-%u-%u", arg.id >> 8, arg.id & 0xff);
d1802 5
a1806 1
	  if (sid_id_auth (sid) != 5 /* SECURITY_NT_AUTHORITY */)
@


1.231
log
@	* uinfo.cc (cygheap_pwdgrp::init): Fix comment.  Rearrange code for
	style.
	(cygheap_pwdgrp::nss_init_line): Disable db_prefix and db_separator
	settings.  Add comment.
	(pwdgrp::fetch_account_from_windows): Drop outdated comment.  Fix code
	fetching primary group gid of group setting in SAM description field.
	Change comment accordingly.
@
text
@d1507 7
@


1.230
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Disallow creating an
	entry for "NULL SID".
@
text
@d585 2
a586 3
     db_prefix: auto
     db_cache: yes
     db_separator: +
a592 1
  caching = true;
d595 1
d657 2
d681 3
a683 1
      else if (!strncmp (c, "enum:", 5))
a1261 6
      /* Skip leading domain separator.  This denotes an alias or well-known
         group, which will be found first by LookupAccountNameW anyway.
	 Otherwise, if the name has no leading domain name, it's either a
	 standalone machine, or the username must be from the primary domain.
	 In the latter case, prepend the primary domain name so as not to
	 collide with an account from the account domain with the same name. */
d1268 1
a1268 1
	 or points to the backslash, so... */
d1744 4
a1747 3
		  /* For setting the primary group, we have to test 
		     with and without prepended separator. */
		  char gname[2 * UNLEN + 2];
d1750 10
a1759 4
		  *gname = cygheap->pg.nss_separator ()[0];
		  sys_wcstombs (gname + 1, 2 * UNLEN + 1, pgrp);
		  if ((gr = internal_getgrnam (gname, cldap))
		      || (gr = internal_getgrnam (gname + 1, cldap)))
@


1.229
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d1798 3
a1800 3
	  /* Special case for "Everyone".  We don't want to return Everyone
	     as user or group.  Ever. */
	  if (uid == 0x10100)	/* Computed from S-1-1-0. */
@


1.228
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Drop "plus_prepended"
	as naming style.  Drop enum name_style_t, use a boolean
	"fully_qualified_name" value instead.  Rework function to drop
	"plus_prepended" handling througout and default to "name only" style
	as replacement.
@
text
@d220 9
a228 4
  myfault efault;
  if (efault.faulted ())
    return EFAULT;
  strncpy (name, login, len);
@


1.227
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Fix comment.
@
text
@d1202 1
a1202 5
  enum name_style_t {
    name_only,
    plus_prepended,
    fully_qualified
  } name_style = name_only;
d1260 1
a1260 1
      name_style_t nstyle;
d1262 3
a1264 12
      nstyle = name_only;
      p = name;
      if (*arg.name == cygheap->pg.nss_separator ()[0])
	nstyle = plus_prepended;
      else if (strchr (arg.name, cygheap->pg.nss_separator ()[0]))
	nstyle = fully_qualified;
      else if (cygheap->dom.member_machine ())
	p = wcpcpy (wcpcpy (p, cygheap->dom.primary_flat_name ()),
		    cygheap->pg.nss_separator ());
      /* Now fill up with name to search. */
      sys_mbstowcs (p, UNLEN + 1,
		    arg.name + (nstyle == plus_prepended ? 1 : 0));
d1268 4
a1271 1
	*p = L'\\';
d1274 21
d1300 1
a1300 1
      /* ... we can skip the backslash in the rest of this function. */
d1304 1
a1304 1
      switch (nstyle)
a1305 9
	case name_only:
	  /* name_only account must start with S-1-5-21 */
	  if (sid_id_auth (sid) != 5 /* SECURITY_NT_AUTHORITY */
	      || sid_sub_auth (sid, 0) != SECURITY_NT_NON_UNIQUE)
	    {
	      debug_printf ("Invalid account name <%s> (name only/"
			    "not NON_UNIQUE)", arg.name);
	      return NULL;
	    }
d1313 2
a1314 3
	  break;
	case plus_prepended:
	  /* plus_prepended account must not start with S-1-5-21. */
d1318 15
a1332 3
	      debug_printf ("Invalid account name <%s> (plus prependend/"
			    "NON_UNIQUE)", arg.name);
	      return NULL;
d1334 3
a1336 9
	  /* plus_prepended only if db_prefix is not always. */
	  if (cygheap->pg.nss_prefix_always ())
	    {
	      debug_printf ("Invalid account name <%s> (plus prependend/"
			    "db_prefix not always)", arg.name);
	      return NULL;
	    }
	  break;
	case fully_qualified:
a1367 1
	  break;
d1518 1
a1518 2
	      name_style = (cygheap->pg.nss_prefix_always ()) ? fully_qualified
							      : plus_prepended;
d1527 1
a1527 1
		name_style = fully_qualified;
d1546 1
a1546 1
		    name_style = fully_qualified;
d1553 1
a1553 1
		  name_style = fully_qualified;
d1766 3
a1768 3
	  name_style = (cygheap->pg.nss_prefix_always ()
			|| sid_id_auth (sid) == 11) /* Microsoft Account */
		       ? fully_qualified : plus_prepended;
d1775 1
a1775 1
	      name_style = fully_qualified;
d1800 1
a1800 2
	  name_style = (cygheap->pg.nss_prefix_always ()) ? fully_qualified
							  : plus_prepended;
d1835 1
a1835 1
      name_style = plus_prepended;
d1850 1
a1850 1
      name_style = fully_qualified;
d1892 1
a1892 1
      name_style = fully_qualified;
d1904 2
a1905 4
  if (name_style >= fully_qualified)
    p = wcpcpy (p, dom);
  if (name_style >= plus_prepended)
    p = wcpcpy (p, cygheap->pg.nss_separator ());
@


1.226
log
@	* cygheap.h (class cygheap_domain_info): Remove lowest_tdo_posix_offset.
	* ldap.cc (cyg_ldap::fetch_posix_offset_for_domain): Return UINT32_MAX
	in case of error.
	* security.h (PRIMARY_POSIX_OFFSET): Define.
	(NOACCESS_POSIX_OFFSET): Define.
	(UNUSABLE_POSIX_OFFSET): Define.
	* uinfo.cc (cygheap_domain_info::init): Drop initializing
	lowest_tdo_posix_offset.
	(pwdgrp::fetch_account_from_file): Set PosixOffset to either
	UNUSABLE_POSIX_OFFSET or NOACCESS_POSIX_OFFSET in case we don't get a
	sensible offset from AD.  Explain why.  Drop setting ch
	lowest_tdo_posix_offset.
	(pwdgrp::fetch_account_from_windows): Replace constant 0x100000 with
	PRIMARY_POSIX_OFFSET throughout.
@
text
@d1533 7
a1539 8
		     cygheap->dom.primary_dns_name (), but it turns out
		     that not setting the domain here has advantages.
		     We open the ldap connection to NULL (== some domain
		     control of our primary domain) anyway.  So the domain
		     is only used 
		     later on.  So, don't set domain here to non-NULL, unless
		     you're sure you have also changed subsequent assumptions
		     that domain is NULL if it's a primary domain account. */
@


1.225
log
@       * uinfo.cc: Fix typo in comment.
@
text
@a817 3
      /* For a domain member machine fetch all trusted domain info.
	 Start out with UNIX_POSIX_OFFSET. */
      lowest_tdo_posix_offset = UNIX_POSIX_OFFSET;
d1138 1
a1138 1
  uint32_t id_val = 0;
d1144 10
a1153 1
      if (!id_val)
d1156 3
a1158 5
	     to fetch any information from AD beyond the most obvious.
	     Alternatively we're suffering IT madness and some admin has
	     actually set the POSIX offset to 0.  Either way, fake a reasonable
	     posix offset and hope for the best. */
	  id_val = cygheap->dom.lowest_tdo_posix_offset - 0x00800000;
a1160 2
      if (id_val < cygheap->dom.lowest_tdo_posix_offset)
	cygheap->dom.lowest_tdo_posix_offset = id_val;
d1430 1
a1430 1
      else if (arg.id < 0x100000)
d1472 1
a1472 1
	      __small_swprintf (s, L"-%u", arg.id - 0x100000);
d1531 1
a1531 1
		  posix_offset = 0x100000;
d1864 1
a1864 1
	      posix_offset = 0x100000;
@


1.224
log
@	* uinfo.cc (cygheap_domain_info::init): Correctly set
	lowest_tdo_posix_offset to UNIX_POSIX_OFFSET.
	(fetch_posix_offset): Redesign to fake a POSIX offset in all cases
	where we can't fetch a non-0 POSIX offset from our primary domain.
@
text
@d1163 1
a1163 1
/* Helper function to replace colons with commas in pw_gecos field. */
@


1.223
log
@	* autoload.cc (ldap_search_sW): Replace ldap_search_stW.
	(LdapMapErrorToWin32): Import.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Accommodate
	change to cyg_ldap::open.
	* ldap.cc (CYG_LDAP_TIMEOUT): Remove.
	(CYG_LDAP_ENUM_TIMEOUT): Remove.
	(def_tv): Remove.
	(enum_tv): Remove.
	(cyg_ldap::map_ldaperr_to_errno): New method to map LDAP error codes to
	POSIX errno codes.  Explicitly map LDAP_NO_RESULTS_RETURNED to ENMFILE.
	(cyg_ldap::wait): Ditto.
	(struct cyg_ldap_init): New struct.
	(cyg_ldap::connect_ssl): Return ULONG.  Drop setting LDAP_OPT_TIMELIMIT.
	Add call to ldap_search_sW to fetch root DSE.
	(cyg_ldap::connect_non_ssl): Ditto.
	(ldap_init_thr): New static thread function.
	(cyg_ldap::connect): New method to call connect_ssl/connect_non_ssl in
	an interruptible cygthread.
	(struct cyg_ldap_search): New struct.
	(cyg_ldap::search_s): New method to perform generic synchronous search.
	(ldap_search_thr): New static thread function.
	(cyg_ldap::search): New method to call search_s in an interruptible
	cygthread.
	(struct cyg_ldap_next_page): New struct.
	(cyg_ldap::next_page_s): New method to perform generic synchronous
	paged search.
	(ldap_next_page_thr): New static thread function.
	(cyg_ldap::next_page): New method to call next_page_s in an
	interruptible cygthread.
	(cyg_ldap::open): Return POSIX errno.  Call connect method.
	(cyg_ldap::fetch_ad_account): Call search method rather than
	ldap_search_stW.
	(cyg_ldap::enumerate_ad_accounts): Return POSIX errno.  Use infinite
	timeout in call to ldap_search_init_pageW.
	(cyg_ldap::next_account): Return POSIX errno.  Call next_page method
	rather than ldap_get_next_page_s.
	(cyg_ldap::fetch_posix_offset_for_domain): Call search method rather
	than ldap_search_stW.
	(cyg_ldap::fetch_unix_sid_from_ad): Ditto.
	(cyg_ldap::fetch_unix_name_from_rfc2307): Ditto.
	* ldap.h (class cyg_ldap): Accommodate aforementioned changes.
	* passwd.cc (pg_ent::enumerate_ad): Ditto.  Break search if one of
	cyg_ldap::enumerate_ad_accounts or cldap.next_account returns with
	an error code other than ENMFILE.
	* sec_helper.cc (cygpsid::get_id): Accommodate change to cyg_ldap::open.
	* uinfo.cc (fetch_posix_offset): Ditto.
@
text
@d818 3
a820 2
      /* For a domain member machine fetch all trusted domain info. */
      lowest_tdo_posix_offset = UNIX_POSIX_OFFSET - 1;
d1141 1
a1141 1
  uint32_t id_val;
d1145 3
a1147 1
      if (cldap->open (NULL) != NO_ERROR)
d1150 9
a1158 14
	     to fetch any information from AD beyond the most obvious.  Never
	     mind, just fake a reasonable posix offset. */
	  id_val = cygheap->dom.lowest_tdo_posix_offset
		   - 0x01000000;
	}
      else
	id_val = cldap->fetch_posix_offset_for_domain (td->DnsDomainName);
      if (id_val)
	{
	  td->PosixOffset = id_val;
	  if (id_val < cygheap->dom.lowest_tdo_posix_offset)
	    cygheap->dom.lowest_tdo_posix_offset = id_val;

	}
@


1.222
log
@	* ldap.cc (CYG_LDAP_TIMEOUT): Define as timeout value.  Set to 30 secs
	for now.  Use throughout.
	* uinfo.cc (colon_to_semicolon): New local function.
	(pwdgrp::fetch_account_from_windows): Convert all colons in AD gecos
	entry to commas.
@
text
@d1144 1
a1144 1
      if (!cldap->open (NULL))
d1244 1
a1244 1
	  if (cldap->open (NULL)
d1601 1
a1601 1
	      if (!cldap->open (NULL))
@


1.221
log
@	* ldap.cc (cyg_ldap::fetch_ad_account): Take additional domain string
	parameter.  Convert into likely rootDSE string if not NULL, and use in
	subsequent call to ldap_search_stW.  Add comment to explain that this
	is not the exactly correct solution.
	* ldap.h (cyg_ldap::fetch_ad_account): Change prototype accordingly.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Always use loc_ldap
	in call to fetch_posix_offset to make sure we're fetchoinmg the posix
	offsets from *our* domain controller.  Only set domain variable to
	non-NULL if the account is from a trusted domain.  Use domain in call
	to cyg_ldap::fetch_ad_account.
@
text
@d1165 10
d1610 3
a1612 2
		    gecos = wcscpy ((PWCHAR) alloca ((wcslen (val) + 1)
				    * sizeof (WCHAR)), val);
@


1.220
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Fix potential SEGV
	referencing NULL pointer.
@
text
@d1448 1
a1448 1
	      fetch_posix_offset (td, cldap);
a1503 1
	      domain = cygheap->dom.account_flat_name ();
a1512 1
	      domain = cygheap->dom.account_flat_name ();
a1530 1
		  domain = NULL;
d1547 1
a1547 1
			  fetch_posix_offset (td, cldap);
d1593 1
a1593 1
	      if (cldap->fetch_ad_account (sid, is_group ()))
d1860 1
a1860 1
		  posix_offset = fetch_posix_offset (td, cldap);
@


1.219
log
@	* sec_auth.cc (get_server_groups): Call get_logon_server only for
	non-builtin accounts.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Check incoming
	account name for validity in terms of the current name prefixing rules
	and refuse invalid names.
@
text
@d1444 1
a1444 1
	  PDS_DOMAIN_TRUSTSW td = NULL;
d1450 1
a1450 1
		posix_offset = td->PosixOffset;
d1452 1
a1452 1
	  if (posix_offset)
d1454 1
a1454 1
	      cygpsid tsid (td->DomainSid);
@


1.218
log
@	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.
@
text
@d1192 1
a1192 1
  enum {
d1254 3
d1259 4
a1262 3
	++arg.name;
      else if (!strchr (arg.name, cygheap->pg.nss_separator ()[0])
	       && cygheap->dom.member_machine ())
d1266 2
a1267 1
      sys_mbstowcs (p, UNLEN + 1, arg.name);
d1271 1
a1271 1
      	*p = L'\\';
d1282 71
@


1.217
log
@	* uinfo.cc (cygheap_user::init): Fix formatting in debug output.
	(struct cyg_USER_INFO_24): Define temporarily.  Explain why.
	(pwdgrp::fetch_account_from_windows): Handle sane primary group
	setting for Microsoft Accounts.  Explain why.
	* wincap.h (wincaps::has_microsoft_accounts): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d1828 1
a1828 1
     long interactively as SYSTEM for debugging purposes. */
@


1.216
log
@	* passwd.cc (pwdgrp::parse_passwd): Fix an off by one computing the
	buffer len.  Add comment.
	* uinfo.cc (internal_getlogin): Fix typo in comment.
@
text
@d88 1
a88 1
    debug_printf ("NtSetInformationToken(TokenOwner), %y", status);
d1165 13
d1580 19
@


1.215
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Tweak SID<->uid
	conversion to cover S-1-5-113, S-1-5-114, and S-1-5-1000 groups.
@
text
@d138 1
a138 1
      /* Is the primary group in the passwd DB is different from the primary
@


1.214
log
@	* security.h (MAX_SUBAUTH_CNT): Drop.  Use SID_MAX_SUB_AUTHORITIES
	instead throughout.
	(MAX_SID_LEN): Drop.  Use SECURITY_MAX_SID_SIZE instead throughout.
@
text
@d1274 2
d1664 2
a1665 1
	  else if (sid_sub_auth (sid, 0) < SECURITY_PACKAGE_BASE_RID)
@


1.213
log
@	* grp.cc (internal_getgroups): Drop unused cygsid variable.
	* sec_helper.cc (cygpsid::pstring): Use sid_sub_auth_count macro.
	(cygsid::get_sid): Use MAX_SUBAUTH_CNT rather than wrong constant 8.
	Don't call memcpy to copy subauthorities into SID, use assignment.
	(cygsid::getfromstr): Use MAX_SUBAUTH_CNT rather than wrong constant 8.
	* security.h (MAX_SUBAUTH_CNT): New definition.  Set to 11 to cover
	Microsoft Accounts.
	(MAX_SID_LEN): Define in terms of SID member sizes and MAX_SUBAUTH_CNT.
	(DBGSID): Use MAX_SUBAUTH_CNT to define size of SubAuthority array.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Handle Micosoft
	Accounts.  Handle them as well known group.  Compare domain names
	case-insensitive.
	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.
@
text
@d1174 1
a1174 1
  DWORD slen = MAX_SID_LEN;
@


1.212
log
@	* ldap.cc (user_attr): Remove "uid" attribute.
	* ldap.h (LDAP_USER_NAME_ATTR): Remove.  Change other attribute index
	values as required.
	(cyg_ldap::get_user_name): Remove inline function.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Remove code to handle
	Cygwin username different from Windows username.
	(pwdgrp::add_account_from_cygserver): Remove unnecessary cast.
@
text
@d1387 7
a1393 2
	 if a process is running as LocalSystem service. */
      if (acc_type == SidTypeUser && sid_sub_auth_count (sid) <= 3)
d1417 1
a1417 1
	  else if (!wcscmp (dom, cygheap->dom.account_flat_name ()))
d1430 1
a1430 1
	      if (!wcscmp (dom, cygheap->dom.primary_flat_name ()))
d1455 1
a1455 1
		    if (!wcscmp (dom, td->NetbiosDomainName))
d1644 3
a1646 2
	  name_style = (cygheap->pg.nss_prefix_always ()) ? fully_qualified
							  : plus_prepended;
@


1.211
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Fix gid evaluation
	for local accounts.
@
text
@a1189 1
  PWCHAR user = NULL;
a1505 4
		  if ((val = cldap->get_user_name ())
		      && wcscmp (name, val))
		    user = wcscpy ((PWCHAR) alloca ((wcslen (val) + 1)
				   * sizeof (WCHAR)), val);
a1541 1
		{ L"name=\"", 6, &user, true },
d1777 1
a1777 1
    p = wcpcpy (p, user ? is_group () ? L"Posix_Group" : L"Posix_User" : dom);
d1780 1
a1780 1
  wcpcpy (p, user ?: name);
d1797 1
a1797 1
		      home ? L"" : L"/home/", home ?: user ?: name,
d1857 1
a1857 1
  return (struct passwd *) add_account_post_fetch (line, true);
d1867 1
a1867 1
  return (struct passwd *) add_account_post_fetch (line, true);
d1877 1
a1877 1
  return (struct passwd *) add_account_post_fetch (line, true);
@


1.210
log
@	* cygheap.h (enum cygheap_pwdgrp::cache_t): Remove.
	(cygheap_pwdgrp::caching): Convert to bool.
	(cygheap_pwdgrp::pwd_cache): Add cygserver member.
	(cygheap_pwdgrp::grp_cache): Ditto.
	(cygheap_pwdgrp::nss_db_caching): Drop.
	(cygheap_pwdgrp::nss_db_full_caching): Drop.
	(cygheap_pwdgrp::nss_cygserver_caching): New method.
	(cygheap_pwdgrp::nss_disable_cygserver_caching): New method.
	* cygserver.h (client_request::request_code_t): Add
	CYGSERVER_REQUEST_PWDGRP.
	* cygserver_pwdgrp.h: New file.
	* cygtls.h (struct _local_storage): Remove pwbuf and grbuf members.
	* grp.cc (pwdgrp::prep_tls_grbuf): Drop.
	(internal_getgrsid): Handle cygserver caching and rearrange to check
	the caches first.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(gr_ent::enumerate_caches): Handle cygserver cache.
	* passwd.cc (pwdgrp::prep_tls_pwbuf): Drop.
	(internal_getpwsid): Handle cygserver caching and rearrange to check
	the caches first.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(pw_ent::enumerate_caches): Handle cygserver cache.
	* pwdgrp.h (pwdgrp::add_account_from_cygserver): New method declaration.
	(pwdgrp::fetch_account_from_cygserver): New method declaration.
	(pwdgrp::prep_tls_pwbuf): Drop declaration.
	(pwdgrp::prep_tls_grbuf): Drop declaration.
	(pwdgrp::add_user_from_cygserver): New inline methods.
	(pwdgrp::add_group_from_cygserver): New inline methods.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
	* uinfo.cc (internal_getlogin): Call internal_getgroups if cygserver
	caching is not available.
	(cygheap_pwdgrp::init): Initialize pwd_cache.cygserver and
	grp_cache.cygserver.  Set caching to true.
	(cygheap_pwdgrp::nss_init_line): Drop db_cache handling entirely.
	(pwdgrp::add_account_from_windows): Drop no caching handling.
	(client_request_pwdgrp::client_request_pwdgrp): New method.
	(pwdgrp::fetch_account_from_cygserver): New method.
	(pwdgrp::add_account_from_cygserver): New method.

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Fix formatting.
	* include/sys/cygwin.h: Ditto.
@
text
@d1478 6
a1483 1
	  if (is_domain_account)
a1484 5
	      /* We only care for the extended user information if we're
		 creating a passwd entry and the account is, in fact, a user. */
	      if (is_group () || acc_type != SidTypeUser)
		break;

d1494 1
d1496 2
d1567 1
a1567 1
	      else if (acc_type == SidTypeAlias)
a1577 2
	      else /* SidTypeGroup.  No way to add a comment to "None" :(  */
		break;
@


1.209
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Avoid crash on
	non-domain member machines if an unknown SID comes in.
@
text
@a34 1

d36 1
d127 1
a127 1
  if (cygheap->pg.nss_db_full_caching ())
d570 1
d573 1
d589 1
a589 1
  caching = NSS_FULL_CACHING;
a674 13
      else if (!strncmp (c, "cache:", 6))
	{
	  c += 6;
	  c += strspn (c, " \t");
	  if (!strncmp (c, "full", 3) && strchr (" \t", c[3]))
	    caching = NSS_FULL_CACHING;
	  else if (!strncmp (c, "yes", 3) && strchr (" \t", c[3]))
	    caching = NSS_CACHING;
	  else if (!strncmp (c, "no", 2) && strchr (" \t", c[2]))
	    caching = NSS_NO_CACHING;
	  else
	    debug_printf ("Invalid nsswitch.conf content: %s", line);
	}
d993 1
a993 5
  if (cygheap->pg.nss_db_caching ())
    return add_account_post_fetch (line, true);
  if (is_group ())
    return (prep_tls_grbuf ())->add_account_post_fetch (line, false);
  return (prep_tls_pwbuf ())->add_account_post_fetch (line, false);
d1005 1
a1005 5
  if (cygheap->pg.nss_db_caching ())
    return add_account_post_fetch (line, true);
  if (is_group ())
    return (prep_tls_grbuf ())->add_account_post_fetch (line, false);
  return (prep_tls_pwbuf ())->add_account_post_fetch (line, false);
d1017 1
a1017 5
  if (cygheap->pg.nss_db_caching ())
    return add_account_post_fetch (line, true);
  if (is_group ())
    return (prep_tls_grbuf ())->add_account_post_fetch (line, false);
  return (prep_tls_pwbuf ())->add_account_post_fetch (line, false);
d1808 76
@


1.208
log
@	* pwdgrp.h (pwdgrp::is_passwd): New inline method.
	(pwdgrp::is_group): New inline method.
	(add_account_from_windows): Drop group argument from declaration.
	(fetch_account_from_windows): Ditto.
	(check_file): Ditto.
	(add_user_from_windows): Call add_account_from_windows accordingly.
	(add_group_from_windows): Ditto.
	* uinfo.cc (pwdgrp::add_account_from_windows): Drop group argument.
	Use is_group method instead.
	(pwdgrp::check_file): Ditto.
	(pwdgrp::fetch_account_from_windows): Ditto.
	* grp.cc: Accommodate aforementioned changes.
	* passwd.cc: Ditto.
@
text
@d1755 2
a1756 1
      if (sid_id_auth (sid) == 5 /* SECURITY_NT_AUTHORITY */
@


1.207
log
@	* passwd.cc (pg_ent::enumerate_builtin): Convert pwd_builtins and
	grp_builtins to array of cygpsid pointers.  Replace SID strings with
	pointers to well known SIDs.
	* sec_helper.cc (well_known_local_service_sid): Define.
	(well_known_network_service_sid): Define.
	(trusted_installer_sid): Define.
	* security.h (well_known_local_service_sid): Declare.
	(well_known_network_service_sid): Declare.
	(trusted_installer_sid): Declare.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Throughout set acc_type
	to SidTypeUnknown if LookupAccountXXX function failed.  Create
	simplified passwd entry for non-user accounts, except for LocalSystem.
	Add comment.
@
text
@d996 1
a996 1
pwdgrp::add_account_from_windows (cygpsid &sid, bool group, cyg_ldap *pldap)
d1001 1
a1001 1
  char *line = fetch_account_from_windows (arg, group, pldap);
d1006 1
a1006 1
  if (group)
d1012 1
a1012 1
pwdgrp::add_account_from_windows (const char *name, bool group, cyg_ldap *pldap)
d1017 1
a1017 1
  char *line = fetch_account_from_windows (arg, group, pldap);
d1022 1
a1022 1
  if (group)
d1028 1
a1028 1
pwdgrp::add_account_from_windows (uint32_t id, bool group, cyg_ldap *pldap)
d1033 1
a1033 1
  char *line = fetch_account_from_windows (arg, group, pldap);
d1038 1
a1038 1
  if (group)
d1057 1
a1057 1
pwdgrp::check_file (bool group)
d1064 1
a1064 1
      PCWSTR rel_path = group ? L"\\etc\\group" : L"\\etc\\passwd";
d1094 1
a1094 1
	    cfree (group ? this->group ()[i].g.gr_name
d1189 1
a1189 2
pwdgrp::fetch_account_from_windows (fetch_user_arg_t &arg, bool group,
				    cyg_ldap *pldap)
d1246 1
a1246 1
	      && cldap->fetch_ad_account (sid, group)
d1369 1
a1369 1
			    group ? 2 : 1,  arg.id & UNIX_POSIX_MASK);
d1505 1
a1505 1
	      if (group || acc_type != SidTypeUser)
d1521 1
a1521 1
	      if (cldap->fetch_ad_account (sid, group))
d1782 1
a1782 1
			    group ? L"Group" : L"User",
d1789 1
a1789 1
	  wcpcpy (name = namebuf, group ? L"Group" : L"User");
d1804 1
a1804 1
    p = wcpcpy (p, user ? group ? L"Posix_Group" : L"Posix_User" : dom);
d1809 1
a1809 1
  if (group)
@


1.206
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Only fetch extended
	user info if we're creating a passwd entry.  Add comment.
@
text
@d1724 1
d1737 1
d1752 1
d1793 1
d1813 6
@


1.205
log
@	* cygheap.h (cygheap_user::sid): Return reference to cygpsid rather
	than PSID.
	(cygheap_user::saved_sid): Ditto.
	(cygheap_pwdgrp::cache_t): New type.
	(cygheap_pwdgrp::caching): Convert to cache_t.
	(cygheap_pwdgrp::nss_db_caching): Change accordingly.
	(cygheap_pwdgrp::nss_db_full_caching): New inline method.
	* grp.cc (internal_getgroups): Reinvent.  Take cyg_ldap pointer as
	third parameter and use throughout.
	(getgroups32): Call internal_getgroups.
	* pwdgrp.h (internal_getgroups): Declare.
	* uinfo.cc (internal_getlogin): Partial rewrite to accommodate having
	no connection to the DC.  Give primary group from user token more
	weight.  Generate group entries for all groups in the user token if
	caching is set to NSS_FULL_CACHING.
	(cygheap_pwdgrp::init): Initialize caching to NSS_FULL_CACHING.
	(cygheap_pwdgrp::nss_init_line): Handle "db_cache: full".
	(pwdgrp::add_account_from_windows): Fix group handling in non-caching
	mode.
	(pwdgrp::fetch_account_from_windows): Default primary group for the
	current user to primary group from user token.  Check for primary
	domain first after LookupAccountSid failed.
@
text
@d1504 3
a1506 1
	      if (acc_type != SidTypeUser)
@


1.204
log
@	* autoload.cc (CheckTokenMembership): Import.
	* external.cc (cygwin_internal): Call get_uid/get_gid instead of get_id.
	* grp.cc (internal_getgrsid): Take additional cyg_ldap pointer.
	Forward to pwdgrp::add_group_from_windows.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(gr_ent::enumerate_local): Drop ugid_caching bool from call to
	pwdgrp::fetch_account_from_windows.
	(getgroups32): Rename from internal_getgroups and drop getgroups32 stub.
	Drop srchsid parameter and code handling it.  Add local cyg_ldap
	instance and forward to internal_getgrXXX.
	(getgroups): Call getgroups32.
	(get_groups): Add local cyg_ldap instance and forward to
	internal_getgrXXX.
	(getgrouplist): Ditto.
	(setgroups32): Ditto.
	* ldap.cc (cyg_ldap::open): Don't call close.  Return true if connection
	is already open.
	(cyg_ldap::remap_uid): Forward this to internal_getpwsid.
	(cyg_ldap::remap_gid): Forward this to internal_getgrsid.
	* passwd.cc (internal_getpwsid): Take additional cyg_ldap pointer.
	Forward to pwdgrp::add_user_from_windows.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(pg_ent::enumerate_builtin): Drop ugid_caching bool from call to
	pwdgrp::fetch_account_from_windows.
	(pg_ent::enumerate_sam): Ditto.
	(pg_ent::enumerate_ad): Ditto.  Forward local cldap instead.
	* pwdgrp.h (internal_getpwsid): Align declaration to above change.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(internal_getgrsid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgroups): Drop declaration.
	(pwdgrp::add_account_from_windows): Align declaration to below change.
	(pwdgrp::add_user_from_windows): Ditto.
	(pwdgrp::add_group_from_windows): Ditto.
	* sec_acl.cc (setacl): Add local cyg_ldap instance and forward to
	internal_getpwuid and internal_getgrgid.
	(getacl): Add local cyg_ldap instance and forward to cygpsid::get_id.
	(aclfromtext32): Add local cyg_ldap instance and forward to
	internal_getpwnam and internal_getgrnam.
	* sec_helper.cc (cygpsid::get_id): Take additional cyg_ldap pointer.
	Forward to internal_getgrsid and internal_getpwsid.
	(get_sids_info): Drop ldap_open.  Forward local cldap to
	internal_getpwsid and internal_getgrXXX.  Call CheckTokenMembership
	rather than internal_getgroups.
	* security.h (cygpsid::get_id): Add cyg_ldap pointer, drop default
	parameter.
	(cygpsid::get_uid): Add cyg_ldap pointer.  Call get_id accordingly.
	(cygpsid::get_gid): Ditto.
	* uinfo.cc (internal_getlogin): Add local cyg_ldap instance and forward
	to internal_getpwXXX and internal_getgrXXX calls.
	(pwdgrp::add_account_from_windows): Take additional cyg_ldap pointer.
	Forward to pwdgrp::fetch_account_from_windows.
	(fetch_posix_offset): Drop ldap_open argument and handling.  Get
	cyg_ldap instance as pointer.
	(pwdgrp::fetch_account_from_windows): Take additional cyg_ldap pointer.
	Use it if it's not NULL, local instance otherwise.  Drop ldap_open.
	Drop fetching extended group arguments from AD for speed.
@
text
@d119 2
a120 2
  struct passwd *pw = NULL;
  struct group *gr, *gr2;
d123 8
a130 5
  cygpsid psid = user.sid ();
  pw = internal_getpwsid (psid, &cldap);

  if (!pw && !(pw = internal_getpwnam (user.name (), &cldap)))
    debug_printf ("user not found in /etc/passwd");
d135 35
a169 23
      myself->uid = pw->pw_uid;
      myself->gid = pw->pw_gid;
      user.set_name (pw->pw_name);
      if (gsid.getfromgr (gr = internal_getgrgid (pw->pw_gid, &cldap)))
	{
	  /* We might have a group file with a group entry for the current
	     user's primary group, but the current user has no entry in passwd.
	     If so, pw_gid is taken from windows and might disagree with the
	     gr_gid from the group file.  Overwrite it brutally. */
	  if ((gr2 = internal_getgrsid (gsid, &cldap)) && gr2 != gr)
	    myself->gid = pw->pw_gid = gr2->gr_gid;
	  /* Set primary group to the group in /etc/passwd. */
	  if (gsid != user.groups.pgsid)
	    {
	      NTSTATUS status = NtSetInformationToken (hProcToken,
						       TokenPrimaryGroup,
						       &gsid, sizeof gsid);
	      if (!NT_SUCCESS (status))
		debug_printf ("NtSetInformationToken (TokenPrimaryGroup), %y",
			      status);
	      else
		user.groups.pgsid = gsid;
	      clear_procimptoken ();
d171 2
a173 2
      else
	debug_printf ("gsid not found in augmented /etc/group");
d175 1
a175 1
  cygheap->user.ontherange (CH_HOME, pw);
d587 1
a587 1
  caching = true;
d677 4
a680 2
	  if (!strncmp (c, "yes", 3) && strchr (" \t", c[3]))
	    caching = true;
d682 1
a682 1
	    caching = false;
d1006 2
d1022 2
d1038 2
d1507 10
a1516 1
	      gid = posix_offset + DOMAIN_GROUP_RID_USERS; /* Default. */
d1759 13
a1771 7
	  for (ULONG idx = 0; (td = cygheap->dom.trusted_domain (idx)); ++idx)
	    if (td->DomainSid && RtlEqualSid (sid, td->DomainSid))
	      {
		domain = td->NetbiosDomainName;
		posix_offset = fetch_posix_offset (td, cldap);
		break;
	      }
@


1.203
log
@	* external.cc (cygwin_internal): Add cases for CW_GETNSSSEP,
	CW_GETPWSID and CW_GETGRSID.
	* grp.cc (internal_getgrsid_from_db): New function.
	* passwd.cc (internal_getpwsid_from_db): New function.
	(pg_ent::setent): Add special case for call from mkpasswd/mkgroup.
	* pwdgrp.h (internal_getpwsid_from_db): Declare.
	(internal_getgrsid_from_db): Declare.
	(enum nss_enum_t): Move to include/sys/cygwin.h.
	(class pg_ent): Add comment.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Fix typo in comment.
	Change "UNIX" to "Unix" in domain name.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GETNSSSEP,
	CW_GETPWSID and CW_GETGRSID.
	(enum nss_enum_t): Define here.
@
text
@d121 1
d124 1
a124 1
  pw = internal_getpwsid (psid);
d126 1
a126 1
  if (!pw && !(pw = internal_getpwnam (user.name ())))
d135 1
a135 1
      if (gsid.getfromgr (gr = internal_getgrgid (pw->pw_gid)))
d141 1
a141 1
	  if ((gr2 = internal_getgrsid (gsid)) && gr2 != gr)
d979 1
a979 1
pwdgrp::add_account_from_windows (cygpsid &sid, bool group)
d984 1
a984 1
  char *line = fetch_account_from_windows (arg, group);
d993 1
a993 1
pwdgrp::add_account_from_windows (const char *name, bool group)
d998 1
a998 1
  char *line = fetch_account_from_windows (arg, group);
d1007 1
a1007 1
pwdgrp::add_account_from_windows (uint32_t id, bool group)
d1012 1
a1012 1
  char *line = fetch_account_from_windows (arg, group);
d1138 1
a1138 1
fetch_posix_offset (PDS_DOMAIN_TRUSTSW td, bool &ldap_open, cyg_ldap &cldap)
d1144 1
a1144 1
      if (!ldap_open && !(ldap_open = cldap.open (NULL)))
d1153 1
a1153 1
	id_val = cldap.fetch_posix_offset_for_domain (td->DnsDomainName);
d1167 1
a1167 1
				    bool ugid_caching)
d1176 1
a1176 1
  cygpsid sid = NO_SID;
d1194 1
a1196 1
  /* Temporary stuff. */
d1199 2
a1200 2
  cyg_ldap cldap;
  bool ldap_open = false;
d1223 3
a1225 3
	  if ((ldap_open = cldap.open (NULL))
	      && cldap.fetch_ad_account (sid, group)
	      && (val = cldap.get_group_name ()))
d1359 1
a1359 1
	      fetch_posix_offset (td, ldap_open, cldap);
d1456 1
a1456 1
			  fetch_posix_offset (td, ldap_open, cldap);
a1477 1
	  gid = posix_offset + DOMAIN_GROUP_RID_USERS; /* Default. */
d1481 4
d1486 1
a1486 1
	      if (!ldap_open && !cldap.open (NULL))
d1488 1
a1488 1
	      if (cldap.fetch_ad_account (sid, group))
d1491 19
a1509 1
		  if (acc_type == SidTypeUser)
d1511 5
a1515 42
		      if ((id_val = cldap.get_primary_gid ()) != ILLEGAL_GID)
			gid = posix_offset + id_val;
		      if ((val = cldap.get_user_name ())
			  && wcscmp (name, val))
			user = wcscpy ((PWCHAR) alloca ((wcslen (val) + 1)
				       * sizeof (WCHAR)), val);
		      if ((val = cldap.get_gecos ()))
			gecos = wcscpy ((PWCHAR) alloca ((wcslen (val) + 1)
					* sizeof (WCHAR)), val);
		      if ((val = cldap.get_home ()))
			home = wcscpy ((PWCHAR) alloca ((wcslen (val) + 1)
				       * sizeof (WCHAR)), val);
		      if ((val = cldap.get_shell ()))
			shell = wcscpy ((PWCHAR) alloca ((wcslen (val) + 1)
					* sizeof (WCHAR)), val);
		      /* Check and, if necessary, add unix<->windows
			 id mapping on the fly. */
		      if (ugid_caching)
			{
			  id_val = cldap.get_unix_uid ();
			  if (id_val != ILLEGAL_UID
			      && cygheap->ugid_cache.get_uid (id_val)
				 == ILLEGAL_UID)
			    cygheap->ugid_cache.add_uid (id_val, uid);
			}
		    }
		  else /* SidTypeGroup */
		    {
		      if ((val = cldap.get_group_name ())
			  && wcscmp (name, val))
			user = wcscpy ((PWCHAR) alloca ((wcslen (val) + 1)
				       * sizeof (WCHAR)), val);
		      /* Check and, if necessary, add unix<->windows
			 id mapping on the fly. */
		      if (ugid_caching)
			{
			  id_val = cldap.get_unix_gid ();
			  if (id_val != ILLEGAL_GID
			      && cygheap->ugid_cache.get_gid (id_val)
				 == ILLEGAL_GID)
			    cygheap->ugid_cache.add_gid (id_val, uid);
			}
d1617 2
a1618 2
		  if ((gr = internal_getgrnam (gname))
		      || (gr = internal_getgrnam (gname + 1)))
d1621 1
a1621 2
	      if (ugid_caching && uxid
		  && ((id_val = wcstoul (uxid, &e, 10)), !*e))
d1731 1
a1731 1
		posix_offset = fetch_posix_offset (td, ldap_open, cldap);
@


1.202
log
@	* pwdgrp.h (pwdgrp::fetch_account_from_windows): Add bool parameter
	to declaration, set to true by default.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Add bool parameter
	"ugid_caching".  Only add account to ugid_cache if set to true.
	* grp.cc (gr_ent::enumerate_local): Call fetch_account_from_windows
	with ugid_caching parameter set to false.
	* passwd.cc (pg_ent::enumerate_builtin): Ditto.
	(pg_ent::enumerate_sam): Ditto.
	(pg_ent::enumerate_ad): Ditto.
@
text
@d1723 1
a1723 1
         This *might* colide with a posix_offset of some trusted domain.
d1728 1
a1728 1
      p = wcpcpy (dom, L"UNIX_");
@


1.201
log
@	* autoload.cc (ldap_abandon): Import.
	(ldap_result): Import.
	(ldap_searchW): Import.
	(NetGroupEnum): Import.
	(NetLocalGroupEnum): Import.
	(NetUserEnum): Import.
	* cygheap.h (class cygheap_pwdgrp): Add members enums and enum_tdoms.
	(cygheap_pwdgrp::nss_db_enums): New inline method.
	(cygheap_pwdgrp::nss_db_enum_tdoms): Ditto.
	* cygtls.h (struct _local_storage): Drop unused members pw_pos and
	grp_pos.
	* grp.cc (grent): New static variable of class gr_ent.
	(gr_ent::enumerate_caches): New method.
	(gr_ent::enumerate_local): New method.
	(gr_ent::getgrent): New method.
	(setgrent): Call gr_ent method.
	(getgrent32): Ditto.
	(endgrent): Ditto.
	* ldap.cc (sid_attr): Rename from nfs_attr.
	(cyg_ldap::close): Abandon still running asynchronous search.
	(cyg_ldap::fetch_ad_account): Reduce filter buffer size.
	(cyg_ldap::enumerate_ad_accounts): New method.
	(cyg_ldap::next_account): New method.
	(cyg_ldap::fetch_posix_offset_for_domain): Reduce filter buffer size.
	(cyg_ldap::fetch_unix_sid_from_ad): Ditto.  Fix return value in case
	no value has been read.
	(cyg_ldap::fetch_unix_name_from_rfc2307): Reduce filter buffer size.
	* ldap.h (class cyg_ldap): Add msg_id member.
	(cyg_ldap::enumerate_ad_accounts): Declare.
	(cyg_ldap::next_account): Declare:
	* passwd.cc (pwent): New static variable of class pw_ent.
	(pg_ent::clear_cache): New method.
	(pg_ent::setent): New method.
	(pg_ent::getent): New method.
	(pg_ent::endent): New method.
	(pg_ent::enumerate_file): New method.
	(pg_ent::enumerate_builtin): New method.
	(pg_ent::enumerate_sam): New method.
	(pg_ent::enumerate_ad): New method.
	(pw_ent::enumerate_caches): New method.
	(pw_ent::enumerate_local): New method.
	(pw_ent::getpwent): New method.
	(setpwent): Call pw_ent method.
	(getpwent): Ditto.
	(endpwent): Ditto.
	* pwdgrp.h (class pwdgrp): Define pg_ent, pw_ent and gr_ent as friend
	classes.
	(pwdgrp::add_account_post_fetch): Declare with extra bool parameter.
	(pwdgrp::file_attr): New inline method.
	(enum nss_enum_t): Define.
	(class pg_ent): Define.
	(class pw_ent): Define.
	(class gr_ent): Define.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (cygheap_pwdgrp::init): Initialize enums and enum_tdoms.
	(cygheap_pwdgrp::nss_init_line): Fix typo in preceeding comment.
	Handle new "db_enum" keyword.
	(pwdgrp::add_account_post_fetch): Take additional `bool lock' parameter
	and acquire pglock before adding element to array if lock is true.
	(pwdgrp::add_account_from_file): Call add_account_post_fetch with lock
	set to true.
	(pwdgrp::add_account_from_windows): Ditto in case of caching.
	(pwdgrp::fetch_account_from_windows): Handle builtin aliases only
	known to the domain controller.  Only call NetLocalGroupGetInfo for
	aliases.
@
text
@d1165 2
a1166 1
pwdgrp::fetch_account_from_windows (fetch_user_arg_t &arg, bool group)
d1506 8
a1513 5
		      id_val = cldap.get_unix_uid ();
		      if (id_val != ILLEGAL_UID
			  && cygheap->ugid_cache.get_uid (id_val)
			     == ILLEGAL_UID)
			cygheap->ugid_cache.add_uid (id_val, uid);
d1521 10
a1530 5
		      id_val = cldap.get_unix_gid ();
		      if (id_val != ILLEGAL_GID
			  && cygheap->ugid_cache.get_gid (id_val)
			     == ILLEGAL_GID)
			cygheap->ugid_cache.add_gid (id_val, uid);
d1636 2
a1637 1
	      if (uxid && ((id_val = wcstoul (uxid, &e, 10)), !*e))
@


1.200
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Default to /bin/bash
	as login shell.
@
text
@d565 1
d572 2
d576 1
a576 1
/* The /etc/nssswitch.conf file is read exactly once by the root process of a
d668 52
d925 1
a925 1
pwdgrp::add_account_post_fetch (char *line)
d930 2
a931 1
      pglock.init ("pglock")->acquire ();
d934 2
a935 1
      pglock.release ();
d950 1
a950 1
  return (struct passwd *) add_account_post_fetch (line);
d962 1
a962 1
  return (struct passwd *) add_account_post_fetch (line);
d974 1
a974 1
  return (struct passwd *) add_account_post_fetch (line);
d987 2
a988 2
    return add_account_post_fetch (line);
  return (prep_tls_pwbuf ())->add_account_post_fetch (line);
d1001 2
a1002 2
    return add_account_post_fetch (line);
  return (prep_tls_pwbuf ())->add_account_post_fetch (line);
d1015 2
a1016 2
    return add_account_post_fetch (line);
  return (prep_tls_pwbuf ())->add_account_post_fetch (line);
d1209 22
d1560 1
a1560 1
	      else /* SidTypeGroup || SidTypeAlias */
d1571 2
@


1.199
log
@	* ldap.cc (cyg_ldap::fetch_posix_offset_for_domain): If domain name
	has no dot, it's a Netbios name.  Change the search filter expression
	accordingly and filter by flatName.  Add comment.
	* uinfo.cc (cygheap_domain_info::init):  Gracefully handle NULL
	DnsDomainName and DomainSid members in DS_DOMAIN_TRUSTSW strutures.
	Add comment.  Fix comment preceeding fetching the mapping server
	from registry.
	(pwdgrp::fetch_account_from_file): Convert str to a local array.
	(fetch_posix_offset): New static function.
	(pwdgrp::fetch_account_from_windows): Add debug output in case
	LookupAccountSidW fails.  Simplify code by calling fetch_posix_offset
	where appropriate.  If LookupAccountSidW fails, check if the SID is
	one of the known trusted domains.  If so, create a more informative
	account entry.
@
text
@d1701 1
a1701 1
		      shell ?: L"/bin/sh");
@


1.198
log
@	* uinfo.cc (cygheap_pwdgrp::nss_init_line): Explicitely ignore a colon
	as separator char.
@
text
@d780 14
a793 4
	  tdom[idx].DnsDomainName = cwcsdup (td[idx].DnsDomainName);
	  ULONG len = RtlLengthSid (td[idx].DomainSid);
	  tdom[idx].DomainSid = cmalloc_abort(HEAP_BUF, len);
	  RtlCopySid (len, tdom[idx].DomainSid, td[idx].DomainSid);
d800 6
a805 6
  /* If we have NFS installed, we make use of a name mapping server.  This
     can be either Active Directory to map uids/gids directly to Windows SIDs,
     or an AD LDS or other RFC 2307 compatible identity store.  The name of
     the mapping domain can be fetched from the registry key created by the
     NFS client installation and entered by the user via nfsadmin or the
     "Services For NFS" MMC snap-in.
d1055 1
a1055 1
  char *str = tp.c_get ();
d1079 28
d1152 2
d1278 1
a1278 17
	      /* If we don't have the PosixOffset of the domain, fetch it.
		 Skip primary domain. */
	      if (!td->PosixOffset && !(td->Flags & DS_DOMAIN_PRIMARY))
		{
		  if (!ldap_open && !(ldap_open = cldap.open (NULL)))
		    id_val = cygheap->dom.lowest_tdo_posix_offset
			     - 0x01000000;
		  else
		    id_val =
		      cldap.fetch_posix_offset_for_domain (td->DnsDomainName);
		  if (id_val)
		    {
		      td->PosixOffset = id_val;
		      if (id_val < cygheap->dom.lowest_tdo_posix_offset)
			cygheap->dom.lowest_tdo_posix_offset = id_val;
		    }
		}
d1371 7
a1377 30
		    {
		      if (wcscmp (dom, td->NetbiosDomainName))
			continue;
		      domain = td->DnsDomainName;
		      posix_offset = td->PosixOffset;
		      /* If we don't have the PosixOffset of the domain,
			 fetch it. */
		      if (!posix_offset)
			{
			  if (!ldap_open && !(ldap_open = cldap.open (NULL)))
			    {
			      /* We're probably running under a local account,
				 so we're not allowed to fetch any information
				 from AD beyond the most obvious.  Never mind,
				 just fake a reasonable posix offset. */
			      id_val = cygheap->dom.lowest_tdo_posix_offset
				       - 0x01000000;
			    }
			  else
			    id_val =
			      cldap.fetch_posix_offset_for_domain (domain);
			  if (id_val)
			    {
			      td->PosixOffset = posix_offset = id_val;
			      if (id_val < cygheap->dom.lowest_tdo_posix_offset)
				cygheap->dom.lowest_tdo_posix_offset = id_val;
			    }
			}
		      break;
		    }
d1644 30
a1673 2
      wcpcpy (dom, L"Unknown");
      wcpcpy (name = namebuf, group ? L"Group" : L"User");
@


1.197
log
@	* ldap.cc (rediscover_thread): Give argument a useful name.
	* miscfuncs.cc (NT_readline::init): It's a really bad idea trying to
	print a pointer to a PUNICODE_STRING as PUNICODE_STRING.  Fix it.
	* uinfo.cc (cygheap_domain_info::init): Print status codes as hex
	values in debug output.
@
text
@d649 1
a649 1
	  if ((unsigned char) *c <= 0x7f && strchr (" \t", c[1]))
@


1.196
log
@	* autoload.cc (NetLocalGroupGetInfo): Replace NetGroupGetInfo.
	* cygheap.h (class cygheap_ugid_cache): Move ugid_cache_t type here
	and rename.
	(struct init_cygheap): Add cygheap_ugid_cache member "ugid_cache".
	* pwdgrp.h (class ugid_cache_t): Remove here.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Accommodate
	move of ugid_cache to cygheap.
	* sec_helper.cc (get_sids_info): Ditto.
	* uinfo.cc (ugid_cache): Remove.
	(pwdgrp::fetch_account_from_windows): Define id_val globally.
	Move SidTypeAlias handling into SidTypeUser/SidTypeGroup branch since
	aliases are handled like groups in SAM.  Accommodate move of ugid_cache
	to cygheap.  Consolidate code reading SAM comments into a single branch
	for both, SidTypeUser and SidTypeAlias.  For SidTypeAlias, fix thinko
	and call NetLocalGroupGetInfo rather than NetGroupGetInfo.  Simplify
	code setting Cygwin primary group for SAM accounts.  Add code to handle
	UNIX uid/gid from SAM comment.
@
text
@d729 1
a729 1
      system_printf ("LsaQueryInformationPolicy(Primary) %u", status);
d743 1
a743 1
      system_printf ("LsaQueryInformationPolicy(Account) %u", status);
@


1.195
log
@	* uinfo.cc (cygheap_domain_info::init): Drop accidentally leftover if
	statement.
@
text
@a550 2
ugid_cache_t ugid_cache;

d1101 1
a1241 2
		  uint32_t id_val;

a1286 6
      /* Alias?  There are two types, the builtin aliases like "Administrators"
	 and the local groups in SAM.  Handle local groups as groups. */
      else if (acc_type == SidTypeAlias
	       && sid_sub_auth (sid, 0) == SECURITY_NT_NON_UNIQUE)
	acc_type = SidTypeGroup;

d1291 17
d1309 1
a1309 1
	  if (!wcscmp (dom, cygheap->dom.account_flat_name ()))
a1355 2
			  uint32_t id_val;

d1394 2
a1395 1
	  uid = posix_offset + sid_sub_auth_rid (sid);
d1406 1
a1406 3
		  uint32_t id_val;

		  if (!group)
d1427 3
a1429 2
			  && ugid_cache.get_uid (id_val) == ILLEGAL_UID)
			ugid_cache.add_uid (id_val, uid);
d1431 1
a1431 1
		  else
d1439 3
a1441 2
			  && ugid_cache.get_gid (id_val) == ILLEGAL_GID)
			ugid_cache.add_gid (id_val, uid);
d1446 1
a1446 1
	  else if (acc_type == SidTypeUser)
d1450 18
d1469 12
a1480 4
	      nas = NetUserGetInfo (domain, name, 4, (PBYTE *) &ui);
	      if (nas != NERR_Success)
		debug_printf ("NetUserGetInfo(%W,%W) %u", domain, name, nas);
	      else
d1482 2
a1483 22
		  PWCHAR pgrp = NULL;
		  struct {
		    PCWSTR str;
		    size_t len;
		    PWCHAR *tgt;
		  } search[] = {
		    { L"name=\"", 6, &user },
		    { L"home=\"", 6, &home },
		    { L"shell=\"", 7, &shell },
		    { L"group=\"", 7, &pgrp }
		  };
		  PWCHAR s, e;

		  /* Fetch primary group. */
		  gid = posix_offset + ui->usri4_primary_group_id;
		  /* Local SAM accounts have only a handful attributes
		     available to home users.  Therefore, fetch different
		     Cygwin user name, Cygwin home dir, and Cygwin login
		     shell from the "Description" field in XML short
		     style. */
		  if ((s = wcsstr (ui->usri4_comment, L"<cygwin "))
		      && (e = wcsstr (s + 8, L"/>")))
d1485 2
a1486 28
		      s += 8;
		      *e = L'\0';
		      while (*s)
			{
			  while (*s == L' ')
			    ++s;
			  for (size_t i = 0;
			       i < sizeof search / sizeof search[0];
			       ++i)
			    if (!wcsncmp (s, search[i].str, search[i].len))
			      {
				s += search[i].len;
				if ((e = wcschr (s, L'"'))
				    && (i > 0 || wcsncmp (name, s, e - s)))
				  {
				    *search[i].tgt =
					(PWCHAR) alloca ((e - s + 1)
							 * sizeof (WCHAR));
				    *wcpncpy (*search[i].tgt, s, e - s) = L'\0';
				    s = e + 1;
				  }
				else
				  {
				    *s = L'\0';
				    break;
				  }
			      }
			}
d1488 13
a1500 2
		  NetApiBufferFree (ui);
		  if (pgrp)
d1502 1
a1502 2
		      /* For setting the primary group, we have to test all
			 three possible Cygwin name variations:
d1504 22
a1525 13
			 MACHINE+group, +group, group
		      */
		      char gname[2 * (DNLEN + UNLEN + 1)];
		      char *sep;
		      struct group *gr;

		      sep += sys_wcstombs (sep = gname, 2 * DNLEN + 1, domain);
		      *sep = cygheap->pg.nss_separator ()[0];
		      sys_wcstombs (sep + 1, 2 * UNLEN + 1, pgrp);
		      if ((gr = internal_getgrnam (gname))
			  || (gr = internal_getgrnam (sep))
			  || (gr = internal_getgrnam (sep + 1)))
			gid = gr->gr_gid;
d1528 2
a1529 9
	    }
	  else /* SidTypeGroup */
	    {
	      NET_API_STATUS nas;
	      PGROUP_INFO_3 gi;

	      nas = NetGroupGetInfo (domain, name, 3, (PBYTE *) &gi);
	      if (nas != NERR_Success)
		debug_printf ("NetGroupGetInfo(%W,%W) %u", domain, name, nas);
d1531 2
d1534 14
a1547 5
		  PWCHAR s, e;

		  /* Fetch different Cygwin group name from description. */
		  if ((s = wcsstr (gi->grpi3_comment, L"<cygwin "))
		      && (e = wcsstr (s + 8, L"/>")))
d1549 2
a1550 18
		      s += 8;
		      *e = L'\0';
		      while (*s)
			{
			  while (*s == L' ')
			    ++s;
			  if (!wcsncmp (s, L"name=\"", 6))
			    {
			      s += 6;
			      if ((e = wcschr (s, L'"')))
			      	{
				  *wcpncpy (name = namebuf, s, e - s) = L'\0';
				  s = e + 1;
				}
			      else
			      	break;
			    }
			}
d1552 2
a1553 1
		  NetApiBufferFree (gi);
a1556 1
	case SidTypeAlias:
d1566 1
a1566 2
	      if (sid_sub_auth (sid, 0) > SECURITY_BUILTIN_DOMAIN_RID)
	      	name_style = fully_qualified;
a1580 1
	      //name_style = fully_qualified;
@


1.194
log
@	* uinfo.cc (cygheap_domain_info::init): Fix handling of account domain
	on donmain controllers.  Explain why.
@
text
@d753 1
a753 2
  if (pdom_sid == adom_sid)
    adom_name = cwcsdup (pdom_sid == adom_sid ? L"@@" : adom->DomainName.Buffer);
@


1.193
log
@	* uinfo.cc (pwdgrp::fetch_account_from_windows): Add code to allow
	setting the primary group from the SAM comment field.
@
text
@d748 4
a751 2
  /* Copy account domain info to cygheap. */
  adom_name = cwcsdup (adom->DomainName.Buffer);
d753 2
@


1.192
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d1446 1
d1454 2
a1455 1
		    { L"shell=\"", 7, &shell }
d1499 19
@


1.191
log
@	* Merge in cygwin-64bit-branch.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d13 4
a17 1
#include <wininet.h>
d19 1
a20 2
#include <lm.h>
#include <iptypes.h>
a31 1
#include "pwdgrp.h"
d33 1
d36 2
d120 1
d125 2
a126 3
  if (!pw && !(pw = internal_getpwnam (user.name ()))
      && !(pw = internal_getpwuid (DEFAULT_UID)))
    debug_printf ("user not found in augmented /etc/passwd");
d134 1
a134 1
      if (gsid.getfromgr (internal_getgrgid (pw->pw_gid)))
d136 7
a144 1
	      /* Set primary group to the group in /etc/passwd. */
d428 1
a428 1
  if (get_logon_server (wdomain, wlogsrv, false))
a537 10
      lptr = eptr;
      eptr = strchr (lptr, '\n');
      if (eptr)
	{
	  if (eptr > lptr && eptr[-1] == '\r')
	    eptr[-1] = '\0';
	  else
	    *eptr = '\0';
	  eptr++;
	}
d541 2
a542 1
	  *pwdgrp_buf = realloc (*pwdgrp_buf, max_lines * pwdgrp_buf_elem_size);
d544 1
d551 27
d579 1
a579 1
pwdgrp::load (const wchar_t *rel_path)
d581 104
a684 4
  static const char failed[] = "failed";
  static const char succeeded[] = "succeeded";
  const char *res = failed;
  HANDLE fh = NULL;
d686 21
d708 120
a827 3
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  FILE_STANDARD_INFORMATION fsi;
d829 2
a830 4
  if (buf)
    free (buf);
  buf = NULL;
  curr_lines = 0;
d832 4
a835 3
  if (!path &&
      !(path = (PWCHAR) malloc ((wcslen (cygheap->installation_root)
				 + wcslen (rel_path) + 1) * sizeof (WCHAR))))
d837 18
a854 2
      paranoid_printf ("malloc (%W) failed", rel_path);
      goto out;
d856 1
a856 2
  wcpcpy (wcpcpy (path, cygheap->installation_root), rel_path);
  RtlInitUnicodeString (&upath, path);
d858 14
a871 2
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
  etc_ix = etc::init (etc_ix, &attr);
d873 96
a968 1
  paranoid_printf ("%S", &upath);
d970 15
a984 4
  status = NtOpenFile (&fh, SYNCHRONIZE | FILE_READ_DATA, &attr, &io,
		       FILE_SHARE_VALID_FLAGS,
		       FILE_SYNCHRONOUS_IO_NONALERT
		       | FILE_OPEN_FOR_BACKUP_INTENT);
d987 611
a1597 2
      paranoid_printf ("NtOpenFile(%S) failed, status %y", &upath, status);
      goto out;
d1599 1
a1599 3
  status = NtQueryInformationFile (fh, &io, &fsi, sizeof fsi,
				   FileStandardInformation);
  if (!NT_SUCCESS (status))
d1601 11
a1611 10
      paranoid_printf ("NtQueryInformationFile(%S) failed, status %y",
		       &upath, status);
      goto out;
    }
  /* FIXME: Should we test for HighPart set?  If so, the
     passwd or group file is way beyond what we can handle. */
  /* FIXME 2: It's still ugly that we keep the file in memory.
     Big organizations have naturally large passwd files. */
  buf = (char *) malloc (fsi.EndOfFile.LowPart + 1);
  if (!buf)
d1613 11
a1623 2
      paranoid_printf ("malloc (%u) failed", fsi.EndOfFile.LowPart);
      goto out;
d1625 1
a1625 3
  status = NtReadFile (fh, NULL, NULL, NULL, &io, buf, fsi.EndOfFile.LowPart,
		       NULL, NULL);
  if (!NT_SUCCESS (status))
d1627 33
a1659 15
      paranoid_printf ("NtReadFile(%S) failed, status %y", &upath, status);
      free (buf);
      goto out;
    }
  buf[fsi.EndOfFile.LowPart] = '\0';
  for (char *eptr = buf; (eptr = add_line (eptr)); )
    continue;
  debug_printf ("%W curr_lines %d", rel_path, curr_lines);
  res = succeeded;

out:
  if (fh)
    NtClose (fh);
  debug_printf ("%W load %s", rel_path, res);
  initialized = true;
@


1.191.2.1
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d194 4
a197 9
  __try
    {
      strncpy (name, login, len);
    }
  __except (NO_ERROR)
    {
      return EFAULT;
    }
  __endtry
@


1.190
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d69 1
a69 1
    system_printf ("NtQueryInformationToken (TokenPrimaryGroup), %p", status);
d76 1
a76 1
      system_printf ("NtQueryInformationToken (TokenUser), %p", status);
d84 1
a84 1
    debug_printf ("NtSetInformationToken(TokenOwner), %p", status);
d103 1
a103 1
	system_printf ("NtSetInformationToken (TokenDefaultDacl), %p", status);
d106 1
a106 1
	system_printf ("NtSetSecurityObject, %lx", status);
d139 1
a139 1
		debug_printf ("NtSetInformationToken (TokenPrimaryGroup), %p",
d214 1
a214 1
extern "C" __uid32_t
d220 3
d228 1
d230 1
a230 1
extern "C" __gid32_t
d236 3
d244 1
d246 1
a246 1
extern "C" __uid32_t
d252 4
a255 1
extern "C" __uid16_t
d260 1
d262 1
a262 1
extern "C" __gid32_t
d268 3
d276 1
d588 1
a588 1
      paranoid_printf ("NtOpenFile(%S) failed, status %p", &upath, status);
d595 1
a595 1
      paranoid_printf ("NtQueryInformationFile(%S) failed, status %p",
d606 1
a606 1
      paranoid_printf ("malloc (%d) failed", fsi.EndOfFile.LowPart);
d613 1
a613 1
      paranoid_printf ("NtReadFile(%S) failed, status %p", &upath, status);
@


1.189
log
@        * dcrt0.cc (quoted): Renamed strechr to strchrnul.
        * environ.cc (environ_init): Likewise.
        * sec_acl.cc (aclfromtext32): Likewise.
        * sec_auth.cc (extract_nt_dom_user): Likewise.
        * uinfo.cc (pwdgrp::next_str): Likewise.
        * string.h (strechr): Likewise.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.188
log
@	* cygheap.cc (init_cygheap::init_installation_root): Convert function
	init_installation_root into a cygheap method.
	* cygheap.h (struct init_cygheap): Move installation_root,
	installation_key, and installation_key_buf from shared
	.cygwin_dll_common DLL section to cygheap.  Declare new method
	init_installation_root.
	* dtable.cc (handle_to_fn): Accommodate the move of installation strings
	to the cygheap.
	* external.cc (cygwin_internal): Ditto.
	* fhandler_console.cc (fhandler_console::open_shared_console): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Ditto.
	* fhandler_tty.cc: Ditto, throughout.
	* mount.cc (mount_info::init): Ditto.
	* pipe.cc (fhandler_pipe::create): Ditto.
	* shared.cc: Ditto, throughout.
	(installation_root): Remove.
	(installation_key): Move to cygheap.
	(installation_key_buf): Ditto.
	(installation_root_inited): Remove.
	(SPIN_WAIT): Remove.
	(init_installation_root): Move to cygheap.
	(memory_init): Call cygheap->init_installation_root right after
	cygheap->user.init.  Drop call of init_installation_root function.
	* shared_info.h (init_installation_root): Drop declaration.
	(installation_root): Ditto.
	(installation_key): Ditto.
	* uinfo.cc (pwdgrp::load): Accommodate the move of installation strings
	to the cygheap.
@
text
@d492 1
a492 1
  lptr = strechr (lptr, c);
@


1.188.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d214 1
a214 1
extern "C" uid_t
a219 3
#ifdef __x86_64__
EXPORT_ALIAS (getuid32, getuid)
#else
a224 1
#endif
d226 1
a226 1
extern "C" gid_t
a231 3
#ifdef __x86_64__
EXPORT_ALIAS (getgid32, getgid)
#else
a236 1
#endif
d238 1
a238 1
extern "C" uid_t
d244 1
a244 4
#ifdef __x86_64__
EXPORT_ALIAS (geteuid32, geteuid)
#else
extern "C" uid_t
a248 1
#endif
d250 1
a250 1
extern "C" gid_t
a255 3
#ifdef __x86_64__
EXPORT_ALIAS (getegid32, getegid)
#else
a260 1
#endif
@


1.188.2.2
log
@        * dcrt0.cc (quoted): Renamed strechr to strchrnul.
        * environ.cc (environ_init): Likewise.
        * sec_acl.cc (aclfromtext32): Likewise.
        * sec_auth.cc (extract_nt_dom_user): Likewise.
        * uinfo.cc (pwdgrp::next_str): Likewise.
        * string.h (strechr): Likewise.
@
text
@d508 1
a508 1
  lptr = strchrnul (lptr, c);
@


1.188.2.3
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d69 1
a69 1
    system_printf ("NtQueryInformationToken (TokenPrimaryGroup), %y", status);
d76 1
a76 1
      system_printf ("NtQueryInformationToken (TokenUser), %y", status);
d84 1
a84 1
    debug_printf ("NtSetInformationToken(TokenOwner), %y", status);
d103 1
a103 1
	system_printf ("NtSetInformationToken (TokenDefaultDacl), %y", status);
d106 1
a106 1
	system_printf ("NtSetSecurityObject, %y", status);
d139 1
a139 1
		debug_printf ("NtSetInformationToken (TokenPrimaryGroup), %y",
d588 1
a588 1
      paranoid_printf ("NtOpenFile(%S) failed, status %y", &upath, status);
d595 1
a595 1
      paranoid_printf ("NtQueryInformationFile(%S) failed, status %y",
d606 1
a606 1
      paranoid_printf ("malloc (%u) failed", fsi.EndOfFile.LowPart);
d613 1
a613 1
      paranoid_printf ("NtReadFile(%S) failed, status %y", &upath, status);
@


1.188.2.4
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.187
log
@	* miscfuncs.cc (DEFAULT_STACKSIZE): Set to 1 Megs.  Drop comment about
	RLIMIT_STACK.

	* registry.cc (get_registry_hive_path): Expect the user hive path to
	be never longer than MAX_PATH.  Don't prepend native NT path prefix
	here.  Add comment.
	(load_registry_hive): Prepend native NT path prefix here.  Additionally
	try to load user's classes hive.
	* uinfo.cc (cygheap_user::env_userprofile): Reduce size of
	userprofile_env_buf to MAX_PATH.  Add comment.
@
text
@d552 1
a552 1
      !(path = (PWCHAR) malloc ((wcslen (installation_root)
d558 1
a558 1
  wcpcpy (wcpcpy (path, installation_root), rel_path);
@


1.186
log
@*** empty log message ***
@
text
@d438 2
a439 1
  WCHAR userprofile_env_buf[NT_MAX_PATH];
d444 1
a444 1
    sys_wcstombs_alloc (&puserprof, HEAP_STR, userprofile_env_buf + 4);
@


1.185
log
@	* uinfo.cc (cygheap_user::env_userprofile): Simplify since network
	drives are not supported here.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.184
log
@	* uinfo.cc (cygheap_user::env_userprofile): Convert native
	userprofile path returned from get_registry_hive_path to Win32 path.
@
text
@d443 1
a443 9
    {
      PWCHAR up = userprofile_env_buf + 4;
      if (!wcsncasecmp (up, L"UNC\\", 4))
	{
	  up += 2;
	  *up = L'\\';
	}
      sys_wcstombs_alloc (&puserprof, HEAP_STR, up);
    }
@


1.183
log
@whitespace elimination
@
text
@d443 9
a451 1
    sys_wcstombs_alloc (&puserprof, HEAP_STR, userprofile_env_buf);
@


1.182
log
@	* globals.cc (__getlogin_username): Remove.
	* uinfo.cc (getlogin_r): Fetch username from cygheap.
	(getlogin): Add static buffer username and fetch username from
	getlogin_r.
@
text
@d89 1
a89 1
  		(sec_user_nih (sa_buf, sid()))->lpSecurityDescriptor;
d329 1
a329 1
		  		ui->usri3_home_dir);
@


1.181
log
@	* cygtls.h (struct _local_storage): Remove unused members rarg and
	_localtime_buf.  Remove username in favor of a global buffer.  Reorder
	slightly to keep the net.cc stuff together.
	* globals.cc (__getlogin_username): New global char buffer.
	* tlsoffsets.h: Regenerate.
	* uinfo.cc (getlogin): Copy username into __getlogin_username.
@
text
@d190 1
a190 1
  char *login = getlogin ();
d204 8
a211 1
  return strcpy (__getlogin_username, cygheap->user.name ());
@


1.180
log
@	* advapi32.cc (GetTokenInformation): Remove.
	(SetTokenInformation): Remove.
	* grp.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_auth.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d204 1
a204 1
  return strcpy (_my_tls.locals.username, cygheap->user.name ());
@


1.179
log
@	* advapi32.cc (GetSecurityDescriptorDacl): Remove.
	(GetSecurityDescriptorGroup): Remove.
	(GetSecurityDescriptorOwner): Remove.
	* sec_acl.cc: Replace above functions throughout with their ntdll.dll
	equivalent.  Remove redundant debug output.
	* sec_auth.cc: Ditto.
	* security.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d62 2
a63 1
  DWORD siz;
d66 4
a69 3
  if (!GetTokenInformation (hProcToken, TokenPrimaryGroup,
			    &groups.pgsid, sizeof (cygsid), &siz))
    system_printf ("GetTokenInformation (TokenPrimaryGroup), %E");
d72 3
a74 2
  if (!GetTokenInformation (hProcToken, TokenUser, &effec_cygsid,
			    sizeof (cygsid), &siz))
d76 1
a76 1
      system_printf ("GetTokenInformation (TokenUser), %E");
d81 4
a84 3
  if (!SetTokenInformation (hProcToken, TokenOwner, &effec_cygsid,
			    sizeof (cygsid)))
    debug_printf ("SetTokenInformation(TokenOwner), %E");
a90 1
  NTSTATUS status;
d100 4
a103 3
      if (!SetTokenInformation (hProcToken, TokenDefaultDacl, &dacl,
      				sizeof (dacl)))
	system_printf ("SetTokenInformation (TokenDefaultDacl), %E");
d135 6
a140 3
	      if (!SetTokenInformation (hProcToken, TokenPrimaryGroup,
					&gsid, sizeof gsid))
		debug_printf ("SetTokenInformation(TokenPrimaryGroup), %E");
@


1.178
log
@	* autoload.cc (GetConsoleWindow): Drop.
	(GetSystemWindowsDirectoryW): Drop.
	* fhandler_console.cc (beep): Call GetSystemWindowsDirectoryW instead of
	GetWindowsDirectoryW.
	* uinfo.cc (cygheap_user::env_systemroot): Call
	GetSystemWindowsDirectoryW and convert to multibyte on the fly.
	* winlean.h (GetWindowsDirectoryW): Redefine to something invalid.
	Explain why.
@
text
@d87 2
a88 1
  BOOL acl_exists, dummy;
d90 4
a93 2
  if (GetSecurityDescriptorDacl (psd, &acl_exists, &dacl.DefaultDacl, &dummy)
      && acl_exists && dacl.DefaultDacl)
a94 1
      NTSTATUS status;
@


1.177
log
@	* uinfo.cc (cygheap_user::init): Don't call GetUserName.  Fetch username
	from Windows environment instead.  Explain why.
	(cygheap_user::env_domain): Use MAX_DOMAIN_NAME_LEN rather than DNLEN
	to specify the size of the domain name buffer.
@
text
@d457 1
a457 1
      int size = GetWindowsDirectory (NULL, 0);
d460 4
a463 7
	  psystemroot = (char *) cmalloc_abort (HEAP_STR, ++size);
	  size = GetWindowsDirectory (psystemroot, size);
	  if (size <= 0)
	    {
	      cfree (psystemroot);
	      psystemroot = NULL;
	    }
d466 1
a466 1
	debug_printf ("GetWindowsDirectory(), %E");
@


1.176
log
@	* uinfo.cc (cygheap_user::env_domain): Use LookupAccountSidW and
	convert user and domain to multibyte strings to make sure to use
	correct codeset.
@
text
@d43 18
a60 6
  if (!GetUserNameW (user_name, &user_name_len))
    wcpcpy (user_name, L"unknown");

  char mb_user_name[user_name_len = sys_wcstombs (NULL, 0, user_name)];
  sys_wcstombs (mb_user_name, user_name_len, user_name);
  set_name (mb_user_name);
d399 1
a399 1
  DWORD dlen = DNLEN + 1;
@


1.175
log
@	Revert accidental previous login.
@
text
@d4 1
a4 1
   2006, 2007, 2008 Red Hat, Inc.
d385 4
a388 4
  char username[UNLEN + 1];
  DWORD ulen = sizeof (username);
  char userdomain[DNLEN + 1];
  DWORD dlen = sizeof (userdomain);
d393 2
a394 2
  if (!LookupAccountSid (NULL, sid (), username, &ulen,
			 userdomain, &dlen, &use))
d398 2
a399 2
      pwinname = cstrdup (username);
      pdomain = cstrdup (userdomain);
@


1.175.2.1
log
@	* uinfo.cc (cygheap_user::env_domain): Use LookupAccountSidW and
	convert user and domain to multibyte strings to make sure to use
	correct codeset.
@
text
@d385 4
a388 4
  DWORD ulen = UNLEN + 1;
  WCHAR username[ulen];
  DWORD dlen = DNLEN + 1;
  WCHAR userdomain[dlen];
d393 2
a394 2
  if (!LookupAccountSidW (NULL, sid (), username, &ulen,
			  userdomain, &dlen, &use))
d398 2
a399 2
      sys_wcstombs_alloc (&pwinname, HEAP_STR, username);
      sys_wcstombs_alloc (&pdomain, HEAP_STR, userdomain);
@


1.174
log
@	* Makefile.in (DLL_IMPORTS): Remove libadvapi32.a.
	* autoload.cc: Add all advapi32 entry points.
	* mount.cc (mount_info::init): Read user fstab only if we have a
	username.
	* passwd.cc (pwdgrp::read_passwd): Only use username if we have one.
	* shared.cc (user_info::initialize): Set cb last so as not to override
	planned behaviour in pwdgrp::read_passwd.
	* uinfo.cc (cygheap_user::init): Fetch Windows username from environment
	variable $USERNAME.  Don't set name in cygheap if variable is empty.
	(internal_getlogin): If we still have no username, try GetUserNameW.
@
text
@d41 1
a41 1
  DWORD user_name_len;
d43 6
a48 8
  user_name_len = GetEnvironmentVariableW (L"USERNAME", user_name, UNLEN + 1);
  if (user_name_len)
    {
      user_name[UNLEN] = L'\0';
      char mb_user_name[user_name_len = sys_wcstombs (NULL, 0, user_name)];
      sys_wcstombs (mb_user_name, user_name_len, user_name);
      set_name (mb_user_name);
    }
d99 2
a100 21
  /* Handle a border case.  If neither $USERNAME, nor /etc/passwd exists,
     we tryto fetch the username from the system now. */
  if (!user.name () || !*user.name ())
    {
      WCHAR user_name[UNLEN + 1];
      DWORD user_name_len = UNLEN + 1;

      if (GetUserNameW (user_name, &user_name_len))
	{
	  char mb_user_name[user_name_len = sys_wcstombs (NULL, 0, user_name)];
	  sys_wcstombs (mb_user_name, user_name_len, user_name);
	  user.set_name (mb_user_name);
	}
      else
	user.set_name ("unknown");
    }
  else
    {
      cygpsid psid = user.sid ();
      pw = internal_getpwsid (psid);
    }
d102 1
a102 1
  if (!pw && !(pw = internal_getpwnam (user.name (), true))
@


1.173
log
@	* uinfo.cc (cygheap_user::init): Call GetUserNameW and convert to
	multibyte here so as not to rely on the current ANSI page.
@
text
@d41 1
a41 1
  DWORD user_name_len = UNLEN + 1;
d43 8
a50 6
  if (!GetUserNameW (user_name, &user_name_len))
    wcpcpy (user_name, L"unknown");

  char mb_user_name[user_name_len = sys_wcstombs (NULL, 0, user_name)];
  sys_wcstombs (mb_user_name, user_name_len, user_name);
  set_name (mb_user_name);
d101 21
a121 2
  cygpsid psid = user.sid ();
  pw = internal_getpwsid (psid);
d123 1
a123 1
  if (!pw && !(pw = internal_getpwnam (user.name ()))
@


1.172
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d40 1
a40 1
  char user_name[UNLEN + 1];
d43 6
a48 1
  set_name (GetUserName (user_name, &user_name_len) ? user_name : "unknown");
@


1.171
log
@	* cygprops.h: New file.
	* dtable.cc (handle_to_fn): Add check for correct installation_key
	string in object name for pipes and ttys.
	* external.cc (cygwin_internal): Add CW_GET_INSTKEY to allow fetching
	the installation_key from cygserver.
	* fhandler_fifo.cc (fhandler_fifo::fifo_name): Add installation_key
	to fifo name.
	* globals.cc: Include cygprops.h.
	(_RDATA): Move slightly and add comment.
	(cygwin_props): Define.
	* mount.cc (mount_info::init): Accommodate the fact that
	installation_root is now a global variable in DLL common shared memory,
	rather than a member of cygwin_shared.
	* pipe.cc (fhandler_pipe::create_selectable): Add installation_key to
	pipe name.
	* shared.cc (installation_root): Define here for storage in DLL
	common shared memory.
	(installation_key): Ditto.
	(installation_key_buf): Ditto.
	(init_installation_root): Convert from shared_info method to ordinary
	function.  Add initializing installation_key.  Invalidate
	installation_key depending of value of disable_key property.  Add
	comment to explain.
	(get_shared_parent_dir): Add installation_key to directory name.
	(get_session_parent_dir): Ditto.
	(shared_info::initialize): Move call to init_installation_root from
	here...
	(memory_init): ...to here.  Add debug output to print installation root
	and installation key.  Add comment to explain why.
	* shared_info.h (SHARED_INFO_CB): Recalculate.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Remove definition of installation_root and
	declaration of init_installation_root.
	(init_installation_root): Declare.
	(installation_root): Declare.
	(installation_key): Declare.
	* uinfo.cc (pwdgrp::load): Accommodate the fact that installation_root
	is now a global variable in DLL common shared memory.
	* include/cygwin/version.h: Bump API minor number.
	(CYGWIN_INFO_INSTALLATIONS_NAME): Add.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GET_INSTKEY.
@
text
@d81 2
a82 2
      if ((status = NtSetSecurityObject (hMainProc, DACL_SECURITY_INFORMATION,
					 psd)))
@


1.170
log
@	* uinfo.cc (uinfo_init): Deimpersonate, don't reimpersonate, if
	not in a setuid condition.
@
text
@d521 1
a521 1
      !(path = (PWCHAR) malloc ((wcslen (cygwin_shared->installation_root)
d527 1
a527 1
  wcpcpy (wcpcpy (path, cygwin_shared->installation_root), rel_path);
@


1.169
log
@	* include/sys/cygwin.h: Add new cygwin_getinfo_type
	CW_SET_EXTERNAL_TOKEN.
	Add new enum CW_TOKEN_IMPERSONATION, CW_TOKEN_RESTRICTED.
	* cygheap.h (cyguser): New flags ext_token_is_restricted,
	curr_token_is_restricted and setuid_to_restricted.
	* external.cc (cygwin_internal): Add CW_SET_EXTERNAL_TOKEN.
	* sec_auth.cc (set_imp_token): New function.
	(cygwin_set_impersonation_token): Call set_imp_token ().
	* security.h (set_imp_token): New prototype.
	* spawn.cc (spawn_guts): Use CreateProcessAsUserW if restricted token
	was enabled by setuid().  Do not create new window station in this case.
	* syscalls.cc (seteuid32): Add handling of restricted external tokens.
	Set HANDLE_FLAG_INHERIT for primary token.
	(setuid32): Set setuid_to_restricted flag.
	* uinfo.cc (uinfo_init): Do not reimpersonate if restricted token was
	enabled by setuid ().  Initialize user.*_restricted flags.
@
text
@d158 1
a158 1
  cygheap->user.reimpersonate ();
@


1.168
log
@	* cygheap.cc (cygheap_init): Set umask to a sane default.
	* uinfo.cc (cygheap_user::ontherange): Don't use HOMEDRIVE/HOMEPATH
	to set HOME.  Default to /home/USERNAME.
@
text
@d139 2
a140 1
	   && !cygheap->user.groups.issetgroups ())
d154 3
@


1.167
log
@	* uinfo.cc (pwdgrp::load): Open file with FILE_OPEN_FOR_BACKUP_INTENT
	flag.
@
text
@a250 9
      if (homedrive)
	newhomedrive = homedrive;
      else if ((p = getenv ("HOMEDRIVE")))
	newhomedrive = p;

      if (homepath)
	newhomepath = homepath;
      else if ((p = getenv ("HOMEPATH")))
	newhomepath = p;
a260 2
	  else if (!newhomedrive || !newhomepath)
	    setenv ("HOME", "/", 1);
d263 4
a266 7
	      char *home = tp.c_get ();
	      char *buf = tp.c_get ();
	      strcpy (buf, newhomedrive);
	      strcat (buf, newhomepath);
	      cygwin_conv_path (CCP_WIN_A_TO_POSIX | CCP_ABSOLUTE, buf, home,
				NT_MAX_PATH);
	      debug_printf ("Set HOME (from HOMEDRIVE/HOMEPATH) to %s", home);
@


1.166
log
@	* pwdgrp.h (pwdgrp::refresh): Fix indentation.
	* uinfo.cc (pwdgrp::load): Open file synchronized to avoid truncated
	read.  Drop local variable off.
@
text
@d546 3
a548 1
		       FILE_SHARE_VALID_FLAGS, FILE_SYNCHRONOUS_IO_NONALERT);
@


1.165
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@a518 1
  LARGE_INTEGER off = { QuadPart:0LL };
d545 2
a546 2
  status = NtOpenFile (&fh, FILE_READ_DATA, &attr, &io,
		       FILE_SHARE_VALID_FLAGS, 0);
d570 2
a571 2
  status = NtReadFile (fh, NULL, NULL, NULL, &io, buf,
		       fsi.EndOfFile.LowPart, &off, NULL);
@


1.164
log
@	* shared.cc (user_shared_initialize): Fetch potentially changed Cygwin
	username from /etc/passwd before loading mount table.
	(shared_info::init_installation_root): New function fetching Cygwin's
	installation root dir and storing as native NT path in global shared
	memory.
	(shared_info::initialize): Call init_installation_root exactly once at
	first startup.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add installation_root member.
	(shared_info::init_installation_root): Declare.

	* grp.cc (pwdgrp::read_group): Call pwdgrp::load with native WCHAR path.
	* passwd.cc (pwdgrp::read_passwd): Ditto.  Avoid recursion.
	(etc::init): Take POBJECT_ATTRIBUTES instead of path_conv.
	* path.h (etc::init): Change prototype accordingly.
	* pwdgrp.h (class pwdgrp): Store path as UNICODE_STRING/PWCHAR instead
	of as path_conv.
	(pwdgrp::load): Accommodate prototype.
	* uinfo.cc (pwdgrp::load): Change argument type from char to wchar_t.
	Create native NT path here instead of calling path_conv.

	* mount.cc (find_root_from_cygwin_dll): Drop in favor of global
	initializaion in shared_info.
	(mount_info::init): Fetch native NT root dir from cygwin_shared.
	(mount_info::from_fstab): Expect native NT path and use native NT
	functions to access file.  Convert username part in user fstab path
	according to special char transformation rules.
	* path.cc (tfx_chars): Convert slash to backslash.
	(transform_chars): Implement for path given as PWCHAR.
	(transform_chars): PUNICODE_STRING version calls PWCHAR version.
	Remove useless commented code.
@
text
@d580 1
a580 2
  char *eptr = buf;
  while ((eptr = add_line (eptr)))
@


1.163
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@d16 1
d26 1
d513 1
a513 1
pwdgrp::load (const char *posix_fname)
d531 3
a533 6
  pc.check (posix_fname);
  etc_ix = etc::init (etc_ix, pc);

  paranoid_printf ("%s", posix_fname);

  if (pc.error || !pc.exists () || pc.isdir ())
d535 1
a535 1
      paranoid_printf ("strange path_conv problem");
d538 9
a546 2
  status = NtOpenFile (&fh, FILE_READ_DATA,
		       pc.get_object_attr (attr, sec_none_nih), &io,
d550 1
a550 2
      paranoid_printf ("NtOpenFile(%S) failed, status %p",
			pc.get_nt_native_path (), status);
d558 1
a558 1
		       pc.get_nt_native_path (), status);
d575 1
a575 2
      paranoid_printf ("NtReadFile(%S) failed, status %p",
		       pc.get_nt_native_path (), status);
d583 1
a583 1
  debug_printf ("%s curr_lines %d", posix_fname, curr_lines);
d589 1
a589 1
  debug_printf ("%s load %s", posix_fname, res);
@


1.162
log
@	Change length for domain buffers from INTERNET_MAX_HOST_NAME_LENGTH to
	MAX_DOMAIN_NAME_LEN throughout.
	* cyglsa.h (CYG_LSA_MAGIC): New value.
	(cyglsa_t): Define username and domain as WCHAR arrays.
	* errno.cc (errmap): Add mapping for ERROR_NONE_MAPPED.
	* sec_auth.cc: Drop 'w' prefix from WCHAR string variable names where
	appropriate.
	(extract_nt_dom_user): Prefer resolving by SID before resolving by
	domain\name pair.
	(cygwin_logon_user): Don't print cleartext password in debug output.
	Change comment.
	(get_user_groups): Revert calls to LookupAccountNameW to use NULL
	server instead of explicit server name, according to MSDN.
	(get_user_local_groups): Ditto.
	(get_server_groups): Fetch domain and user name from usersid per
	LookupAccountSidW instead of calling extract_nt_dom_user.
	(lsaauth): Fetch domain and user name from usersid per LookupAccountSidW
	instead of calling extract_nt_dom_user.
	* sec_helper.cc (cygpriv): Convert to wchar_t pointer array.
	(privilege_luid): Convert first parameter to  PWCHAR.
	(privilege_name): Return wchar_t pointer.
	(set_privileges): Accommodate debug output.
	* security.h (privilege_luid): Change prototype accordingly.
@
text
@d530 1
a530 1
  etc_ix = etc::init (etc_ix, pc.get_nt_native_path ());
@


1.161
log
@	* autoload.cc (DsGetDcNameW): Replace DsGetDcNameA.
	* dcrt0.cc (child_info_spawn::handle_spawn): Drop artificial
	supplementary group list from calling setgroups in parent.
	* grp.cc (internal_getgroups): Drop 9x-only code.  Reformat.
	* sec_auth.cc (get_logon_server): Do everything in WCHAR only.
	(get_user_groups): Ditto.  Use wlogonserver in LookupAccountNameW
	calls, too.
	(is_group_member): Get logon server as first argument and use in call
	to NetLocalGroupGetMembers.
	(get_user_local_groups): Get logon server as first argument and use in
	calls to NetLocalGroupEnum and LookupAccountNameW.  Revamp to work
	more correctly in domain environments.
	(get_server_groups): Accommodate aforementioned changed function calls.
	* security.h (get_logon_server): Change prototype accordingly.
	* uinfo.cc (cygheap_user::env_logsrv): Accommodate changed
	get_logon_server call.
@
text
@d17 1
d373 1
a373 1
  WCHAR wdomain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
d375 1
a375 1
  sys_mbstowcs (wdomain, INTERNET_MAX_HOST_NAME_LENGTH + 1, mydomain);
@


1.160
log
@Remove unneeded header files from source files throughout.
@
text
@d372 3
a374 1
  char logsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
d376 2
a377 2
  if (get_logon_server (mydomain, logsrv, NULL, false))
    plogsrv = cstrdup (logsrv);
@


1.159
log
@	* Fix copyright dates.
@
text
@a12 1
#include <pwd.h>
a13 1
#include <winnls.h>
a14 2
#include <utmp.h>
#include <limits.h>
a19 1
#include "security.h"
@


1.158
log
@	* winsup.h (NT_MAX_PATH): Revert ill-advised change to 32767.
	Accommodate change throughout.

	* cygwin.din (cygwin_conv_path): Export.
	(cygwin_conv_path_list): Export.
	(cygwin_create_path): Export.
	* dcrt0.cc (dll_crt0_1): Use cygwin_conv_path.
	* dtable.cc (handle_to_fn): Ditto.  Don't expect UNICODE_STRING being
	0-terminated.
	* environ.cc (env_plist_to_posix): New helper function.
	(env_plist_to_win32): Ditto.
	(env_path_to_posix): Ditto.
	(env_path_to_win32): Ditto.
	(return_MAX_PATH): Remove.
	(conv_envvars): Use new helper functions.  Drop removed members.
	(win_env::operator =): Accommodate removal of path length functions.
	(win_env::add_cache): Accommodate new env helper function API.
	(posify): Ditto.
	* environ.h (struct win_env): Ditto. Remove path length function
	pointers since they are unused.
	* path.cc (warn_msdos): Use cygwin_conv_path.
	(getfileattr): Use new tmp_pathbuf::u_get method.
	(fillout_mntent): Ditto.
	(symlink_info::check): Ditto.
	(path_conv::check): Use sizeof (WCHAR) instead of constant 2.
	(symlink_info::check_reparse_point): Ditto.
	(conv_path_list): Get max size of target string as argument.  Call
	cygwin_conv_path as helper function.
	(cygwin_conv_path): New function.
	(cygwin_create_path): New function.
	(cygwin_conv_to_win32_path): Just call cygwin_conv_path with size set
	to MAX_PATH.
	(cygwin_conv_to_full_win32_path): Ditto.
	(cygwin_conv_to_posix_path): Ditto.
	(cygwin_conv_to_full_posix_path): Ditto.
	(conv_path_list_buf_size): Add FIXME comment.
	(env_PATH_to_posix): Rename from env_win32_to_posix_path_list.
	Add size argument as required for env helper functions.
	(cygwin_win32_to_posix_path_list): Call conv_path_list with size set to
	MAX_PATH.
	(cygwin_posix_to_win32_path_list): Ditto.
	(cygwin_conv_path_list): New function.
	(cwdstuff::get): Fix length argument in call to sys_wcstombs.
	* spawn.cc (find_exec): Use cygwin_conv_path_list.
	* tls_pbuf.h (tmp_pathbuf::u_get: New method.
	* uinfo.cc (cygheap_user::ontherange): Allocate temporary path buffers
	using tmp_pathbuf.  Use cygwin_conv_path.
	* winf.cc (av::unshift): Use cygwin_conv_path.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h: Comment out old cygwin32_XXX API.
	Mark old path handling API as deprecated.
	(cygwin_conv_path_t): Typedef.  Define values.
	(cygwin_conv_path): Declare.
	(cygwin_create_path): Declare.
	(cygwin_conv_path_list): Declare.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
@


1.157
log
@	* dcrt0.cc (initial_env): Only use local buffer "buf" if DEBUGGING is
	enabled.  Replace calls to GetEnvironmentVariable by calls to
	GetEnvironmentVariableA for clarity.  Call GetEnvironmentVariableA
	with NULL buffer.
	(cygbench): Ditto, drop local buffer.
	* environ.cc (getearly): Call GetEnvironmentVariableA.
	(environ_init): Retrieve unicode environment and convert to current
	codepage locally.
	(getwinenveq): Ditto.
	* exceptions.cc (try_to_debug): Accommodate new sys_mbstowcs calling
	convention.
	* fhandler_clipboard.cc (set_clipboard): Call sys_mbstowcs to retrieve
	required buffer length.
	* fork.cc (frok::child): Call GetEnvironmentVariableA.
	* miscfuncs.cc: Accommodate changed arguments in calls to sys_mbstowcs.
	* sec_auth.cc: Ditto.
	* strfuncs.cc (sys_wcstombs_alloc): Fix formatting.
	(sys_mbstowcs): Change arguments to allow specifying a source string
	length.
	(sys_mbstowcs_alloc): Ditto.
	* uinfo.cc (cygheap_user::ontherange): Accommodate changed arguments in
	calls to sys_mbstowcs.
	* winsup.h (sys_mbstowcs): Adjust declaration.
	(sys_mbstowcs_alloc): Ditto.
@
text
@d33 1
a243 1
  char homepath_env_buf[CYG_MAX_PATH];
d247 1
a247 1

d276 2
a277 2
	      char home[CYG_MAX_PATH];
	      char buf[CYG_MAX_PATH];
d280 2
a281 1
	      cygwin_conv_to_full_posix_path (buf, home);
d290 1
d294 2
a295 1
	cygwin_conv_to_full_win32_path (pw->pw_dir, homepath_env_buf);
d307 1
a307 1
		  sys_wcstombs (homepath_env_buf, CYG_MAX_PATH,
d311 1
a311 1
		      sys_wcstombs (homepath_env_buf, CYG_MAX_PATH,
d316 2
a317 1
			cygwin_conv_to_full_win32_path ("/", homepath_env_buf);
@


1.156
log
@	* cygheap.cc (cwcsdup): New function.
	(cwcsdup1): New function.
	* cygheap.h (cygheap_user::get_windows_id): New method returning PWCHAR.
	(cwcsdup): Declare.
	(cwcsdup1): Declare.
	* registry.cc (get_registry_hive_path): Use WCHAR instead of char
	throughout.
	(load_registry_hive): Ditto.
	* registry.h (get_registry_hive_path): Change declaration accordingly.
	(load_registry_hive): Ditto.
	* sec_helper.cc (cygpsid::string): New method returning PWCHAR.
	* security.h (cygpsid::string): Declare.
	* syscalls.cc (seteuid32): Convert local name var to WCHAR.
	* uinfo.cc (cygheap_user::env_userprofile): Convert local name buffers
	to WCHAR.  Call sys_wcstombs_alloc to generate puserprof buffer.

	* winsup.h: Fix comment.
	(NT_MAX_PATH): New definition for maximum internal path length.
	Use throughout where appropriate.
	* include/limits.h (PATH_MAX): Set to 4096 as on Linux.
@
text
@d299 3
a301 3
	      sys_mbstowcs (wlogsrv, logsrv (),
			    sizeof (wlogsrv) / sizeof (*wlogsrv));
	     sys_mbstowcs (wuser, winname (), sizeof (wuser) / sizeof (*wuser));
@


1.155
log
@	* string.h: Re-enable inline strcasematch and strncasematch
	implementations and rename to ascii_strcasematch/ascii_strncasematch.
	* dcrt0.cc: Replace str[n]casematch with ascii_str[n]casematch where
	applicable.
	* environ.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
	* winf.cc: Ditto.
@
text
@d411 2
a412 2
  char userprofile_env_buf[PATH_MAX];
  char win_id[UNLEN + 1]; /* Large enough for SID */
d416 1
a416 1
    puserprof = cstrdup (userprofile_env_buf);
@


1.154
log
@	* fhandler_registry.cc: Use NAME_MAX + 1 instead of CYG_MAX_PATH
	throughout for subkey name buffer size.
	* fhandler_socket.cc (search_wsa_event_slot): Use MAX_PATH instead of
	CYG_MAX_PATH for mutext name buffer size.
	(fhandler_socket::init_events): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Check path length
	against PATH_MAX instead of against CYG_MAX_PATH.
	* registry.cc (get_registry_hive_path): Use PATH_MAX instead of
	CYG_MAX_PATH for registry value path buffer size.
	* shared.cc (open_shared): Use MAX_PATH instead of CYG_MAX_PATH
	for shared memory name buffer size.
	* thread.cc (semaphore::semaphore): Use MAX_PATH instead of CYG_MAX_PATH
	for semaphore name buffer size.
	* uinfo.cc (cygheap_user::env_userprofile): Use PATH_MAX instead of
	CYG_MAX_PATH for temporary path name buffer size.
	* winf.h (LINE_BUF_CHUNK): Define as MAX_PATH * 2.
	* include/sys/dirent.h: Include sys/limits.h.  Define name buffer sizes
	using NAME_MAX.
@
text
@d370 1
a370 1
  if (!mydomain || strcasematch (myname, "SYSTEM"))
@


1.153
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d411 1
a411 1
  char userprofile_env_buf[CYG_MAX_PATH];
@


1.152
log
@	* uinfo.cc (pwdgrp::load): Use NT native functions.
@
text
@d449 1
a449 1
	  psystemroot = (char *) cmalloc (HEAP_STR, ++size);
@


1.151
log
@	* ntdll.h (NtNotifyChangeDirectoryFile): Declare.
	(NtQueryAttributesFile): Move to maintain alphabetical order of
	declarations.  Add comment to note that timestamp information returned
	by NtQueryAttributesFile is unreliable.
	* path.h (etc::changed_h): Move here.
	(etc::fn): Change type to OBJECT_ATTRIBUTES.
	(etc::last_modified): Change type to LARGE_INTEGER.
	(etc::init): Take PUNICODE_STRING as second argument.
	* path.cc: Accomodate above changes.
	(etc::test_file_change): Use NT native functions.
	(etc::dir_changed): Ditto.
	* uinfo.cc (pwdgrp::load): Call etc::init with NT native path.
@
text
@a510 1
  const char *res;
d513 8
d535 28
a562 1
      res = failed;
d564 3
a566 1
  else
d568 4
a571 32
      HANDLE fh = CreateFile (pc.get_win32 (), GENERIC_READ,
			      FILE_SHARE_VALID_FLAGS, NULL, OPEN_EXISTING,
			      FILE_ATTRIBUTE_NORMAL, 0);
      if (fh == INVALID_HANDLE_VALUE)
	{
	  paranoid_printf ("%s CreateFile failed, %E");
	  res = failed;
	}
      else
	{
	  DWORD size = GetFileSize (fh, NULL), read_bytes;
	  buf = (char *) malloc (size + 1);
	  if (!ReadFile (fh, buf, size, &read_bytes, NULL))
	    {
	      paranoid_printf ("ReadFile failed, %E");
	      CloseHandle (fh);
	      if (buf)
		free (buf);
	      buf = NULL;
	      res = failed;
	    }
	  else
	    {
	      CloseHandle (fh);
	      buf[read_bytes] = '\0';
	      char *eptr = buf;
	      while ((eptr = add_line (eptr)))
		continue;
	      debug_printf ("%s curr_lines %d", posix_fname, curr_lines);
	      res = succeeded;
	    }
	}
d573 6
d580 3
@


1.150
log
@	* path.h (path_conv::operator char *): Delete.
	(path_conv::operator const char *): Delete.
	* dlfcn.cc: Throughout, replace path_conv::operator char * and
	path_conv::operator const char * by call to path_conv::get_win32
	for easier transition to UNICODE_PATHs.
	* fhandler_socket.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
@
text
@d521 1
a521 1
  etc_ix = etc::init (etc_ix, pc.get_win32 ());
@


1.149
log
@	* autoload.cc (SetUserObjectSecurity): Drop.
	* pinfo.cc (pinfo::set_acl): Use NtSetSecurityObject instead of
	SetKernelObjectSecurity.
	* spawn.cc (spawn_guts): Use NtSetSecurityObject instead of
	SetUserObjectSecurity.
	* uinfo.cc (cygheap_user::init): Ditto.
@
text
@d521 1
a521 1
  etc_ix = etc::init (etc_ix, pc);
d532 3
a534 2
      HANDLE fh = CreateFile (pc, GENERIC_READ, FILE_SHARE_VALID_FLAGS, NULL,
			      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
@


1.148
log
@	* cygheap.h (cygheap_user::curr_imp_token): Rename from current_token.
	Accommodate changge throughout Cygwin.
	(cygheap_user::imp_token): Rename from token.  Accommodate changge
	throughout Cygwin.
	(rcygheap_user::eimpersonate): Use primary token for impersonation.
	* grp.cc (internal_getgroups): Use primary impersonation token when
	impersonated.
	* security.h (_push_thread_privilege): Use primary impersonation token
	when impersonated.
@
text
@d33 1
d76 2
d82 3
a84 2
      if (!SetKernelObjectSecurity (hMainProc, DACL_SECURITY_INFORMATION, psd))
	system_printf ("SetKernelObjectSecurity, %E");
@


1.147
log
@	Throughout remove all usage of wincap.has_security.
	* environ.cc (environ_init): Drop setting allow_ntsec here.
	* grp.cc (initgroups32): Drop usage of label "out".
	* security.cc (allow_ntsec): Set to true by default.
	* syscalls.cc (seteuid32): Remove label success_9x.
	* wincap.cc: Remove has_security throughout.
	* wincap.h: Ditto.
@
text
@d149 1
a149 1
  cygheap->user.current_token = NO_IMPERSONATION;
@


1.146
log
@	Throughout replace all usage of wincap.shared with the constant
	FILE_SHARE_VALID_FLAGS.
	* fhandler.cc (fhandler_base::open_9x): Drop local variable shared.
	* wincap.cc: Remove shared member throughout.
	* wincap.h: Ditto.
@
text
@a44 3
  if (!wincap.has_security ())
    return;

d91 2
a92 5
  if (wincap.has_security ())
    {
      cygpsid psid = user.sid ();
      pw = internal_getpwsid (psid);
    }
d99 2
d104 1
a104 1
      if (wincap.has_security ())
d106 1
a106 2
	  cygsid gsid;
	  if (gsid.getfromgr (internal_getgrgid (pw->pw_gid)))
d108 7
a114 10
	      if (gsid != user.groups.pgsid)
		{
		  /* Set primary group to the group in /etc/passwd. */
		  if (!SetTokenInformation (hProcToken, TokenPrimaryGroup,
					    &gsid, sizeof gsid))
		    debug_printf ("SetTokenInformation(TokenPrimaryGroup), %E");
		  else
		    user.groups.pgsid = gsid;
		  clear_procimptoken ();
		}
a115 2
	  else
	    debug_printf ("gsid not found in augmented /etc/group");
d117 2
@


1.145
log
@	Partially revert change from 2005-04-03, always running under an
	impersonation token, which collides with Vista UAC.
	* cygheap.h (deimpersonate): revert to self instead of impersonating
	hProcImpToken.
	(reimpersonate): Only impersonate if setuid.
	* dcrt0.cc (dll_crt0_0): Don't initialize hProcImpToken here.
	(dll_crt0_1): Set privileges on hProcToken.
	* fork.cc (frok::child): Set privileges on hProcToken.  Close handle to
	hProcImpToken.
	* grp.cc (internal_getgroups): Use hProcToken instead of hProcImpToken.
	* security.cc (check_access): Create hProcImpToken on demand here.
	* security.h (set_process_privilege): Set privileges on hProcToken.
	(_push_thread_privilege): Use hProcToken instead of hProcImpToken.
	(pop_thread_privilege): If not setuid'ed, revert to self.
	* syscalls.cc (setegid32): Drop setting primary group on hProcImpToken.
	Close handle to hProcImpToken.
	* uinfo.cc (internal_getlogin): Ditto.
	* winsup.h (clear_procimptoken): New inline function.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d536 1
a536 1
      HANDLE fh = CreateFile (pc, GENERIC_READ, wincap.shared (), NULL,
@


1.144
log
@2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h: Bump DLL version to 1.7.0.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* select.h: Remove.
	* fhandler_socket.cc: Don't include select.h.
	* select.cc: Ditto.

2006-07-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h: Drop socket related includes.
	(struct _local_storage): Remove exitsock and exitsock_sin. Add
	select_sockevt.
	* cygtls.cc: Accomodate above change throughout.
	* fhandler.h (class fhandler_socket): Make wsock_evt public.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	reordering members.
	(fhandler_socket::evaluate_events): Drop FD_CONNECT event as soon as
	it gets read once.  Never remove FD_WRITE event here.
	(fhandler_socket::wait_for_events): Wait 50 ms instead of INFINITE for
	socket events.
	(fhandler_socket::accept): Fix conditional.  Set wsock_events members
	of accepted socket to useful start values.
	(fhandler_socket::recv_internal): Always drop FD_READ/FD_OOB events from
	wsock_events after the call to WSARecvFrom.
	(fhandler_socket::send_internal): Drop FD_WRITE event from wsock_events
	if the call to WSASendTo fails with WSAEWOULDBLOCK.  Fix return value
	condition.
	* select.cc (struct socketinf): Change to accomodate using socket event
	handling.
	(peek_socket): Use event handling for peeking socket.
	(thread_socket): Ditto.
	(start_thread_socket): Ditto.
	(socket_cleanup): Same here.
	* tlsoffsets.h: Regenerate.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Rearrange slightly to keep
	event handling methods and members together.  Drop owner status flag.
	Split wait method.  Rename event handling methods for readability.
	* fhandler_socket.cc (struct wsa_event): Add owner field.
	(LOCK_EVENTS): New macro.
	(UNLOCK_EVENTS): Ditto.
	(fhandler_socket::init_events): rename from prepare.
	(fhandler_socket::evaluate_events): First half of former wait method.
	Do everything but wait.  Allow specifiying whether or not events from
	event_mask should be erased from wsock_events->events.  Simplify
	OOB handling.  Allow sending SIGURG to any process (group).
	(fhandler_socket::wait_for_events): Second half of former wait method.
	Call evaluate_events and wait in a loop if socket is blocking.
	(fhandler_socket::release_events): Rename from release.
	(fhandler_socket::connect): Accomodate above name changes.
	(fhandler_socket::accept): Ditto.
	(fhandler_socket::recv_internal): Ditto.
	(fhandler_socket::send_internal): Ditto.
	(fhandler_socket::close): Ditto.
	(fhandler_socket::fcntl): Always set owner to given input value on
	F_SETOWN.  Handle F_GETOWN.
	* net.cc (fdsock): Accomodate above name changes.

2006-07-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Set Winsock errno to
	WSAEWOULDBLOCK instead of WSAEINPROGRESS.

2006-07-18  Brian Ford  <Brian.Ford@@FlightSafety.com>
	    Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (mmap_region_status): New enum.
	(mmap_is_attached_or_noreserve_page): Adjust prototype and rename
	as below.
	* mmap.cc (mmap_is_attached_or_noreserve_page):  Rename
	mmap_is_attached_or_noreserve.  Add region length parameter.
	Return enum above.
	* exceptions.cc (_cygtls::handle_exceptions): Accomodate above.
	* fhandler.cc (fhandler_base::raw_read): Call above for NOACCESS
	errors and retry on success to allow reads into untouched
	MAP_NORESERVE buffers.

2006-07-18  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din (posix_openpt): Export.
	* tty.cc (posix_openpt): New function.
	* include/cygwin/stdlib.h (posix_openpt): Declare.
	* include/cygwin/version.h: Bump API minor number.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Add comment.  Create logon_id group SID by
	copying it from incoming group list.
	(create_token): Add subauth_token parameter.  Use information in
	subauth_token if present.  Tweak SourceIdentifier if subauth_token
	is present for debugging purposes.
	* security.h (create_token): Add subauth_token parameter in declaration.
	* syscalls.cc (seteuid32): Call subauth first.  Call create_token
	regardless.  Use subauth token in call to create_token if subauth
	succeeded.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netinet/in.h: Update copyright.

2006-07-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::wait): Rework function so that
	WaitForMultipleObjects is really only called when necessary.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* include/netdb.h: Declare rcmd, rcmd_af, rexec, rresvport,
	rresvport_af, iruserok, iruserok_sa, ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Drop iruserok.o.  Add rcmd.o.
	* autoload.cc (rcmd): Drop definition.
	* cygwin.din: Export bindresvport, bindresvport_sa, iruserok_sa,
	rcmd_af, rresvport_af.
	* net.cc (cygwin_rcmd): Remove.
	(last_used_bindresvport): Rename from last_used_rrecvport.
	(cygwin_bindresvport_sa): New function implementing bindresvport_sa.
	(cygwin_bindresvport): New function implementing bindresvport.
	(cygwin_rresvport): Remove.
	* include/cygwin/version.h: Bump API minor number.
	* include/netinet/in.h: Declare bindresvport and bindresvport_sa.
	* libc/iruserok.c: Remove file.
	* libc/rcmd.cc: New file implementing rcmd, rcmd_af, rresvport,
	rresvport_af, iruserok_sa, iruserok and ruserok.

2006-07-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::getsockname): Return valid
	result for unbound sockets.

2006-07-11  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::fixup_after_fork): Handle
	wsock_mtx and wsock_evt on fork, thus handling close_on_exec correctly.
	(fhandler_socket::fixup_after_exec): Drop misguided attempt to handle
	close_on_exec here.
	(fhandler_socket::dup): Call fixup_after_fork with NULL parent.
	Add comment.
	(fhandler_socket::set_close_on_exec): Handle wsock_mtx and wsock_evt.

2006-07-10  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (class fhandler_socket): Add wsock_mtx, wsock_evt
	and wsock_events members.  Remove closed status flag, add listener
	status flag.  Accomodate new implementation of socket event handling
	methods.  Declare recv* and send* functions ssize_t as the POSIX
	equivalents.
	(fhandler_socket::recv_internal): Declare.
	(fhandler_socket::send_internal): Ditto.
	* fhandler_socket.cc (EVENT_MASK): Define mask of selected events.
	(fhandler_socket::fhandler_socket): Initialize new members.
	(fhandler_socket::af_local_setblocking): Don't actually set the
	socket to blocking mode.  Keep sane event selection.
	(fhandler_socket::af_local_unsetblocking): Don't actually set the
	socket to previous blocking setting, just remember it.
	(struct wsa_event): New structure to keep event data per shared
	socket.
	(NUM_SOCKS): Define number of shared sockets concurrently handled by
	all active Cygwin processes.
	(wsa_events): New shared datastructure keeping all wsa_event records.
	(socket_serial_number): New shared variable to identify shared sockets.
	(wsa_slot_mtx): Global mutex to serialize wsa_events access.
	(search_wsa_event_slot): New static function to select a new wsa_event
	slot for a new socket.
	(fhandler_socket::prepare): Rewrite.  Prepare event selection
	per new socket.
	(fhandler_socket::wait): Rewrite.  Wait for socket events in thread
	safe and multiple process safe.
	(fhandler_socket::release): Rewrite.  Close per-socket descriptor
	mutex handle and event handle.
	(fhandler_socket::dup): Duplicate wsock_mtx and wsock_evt.  Fix
	copy-paste error in debug output.
	(fhandler_socket::connect): Accomodate new event handling.
	(fhandler_socket::listen): Set listener flag on successful listen.
	(fhandler_socket::accept): Accomodate new event handling.
	(fhandler_socket::recv_internal): New inline method centralizing
	common recv code.
	(fhandler_socket::recvfrom): Call recv_internal now.
	(fhandler_socket::recvmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::send_internal): New inline method centralizing
	common send code.
	(fhandler_socket::sendto): Call send_internal now.
	(fhandler_socket::sendmsg): Ditto.  Streamline copying from iovec
	to WSABUF.
	(fhandler_socket::close): Call release now.
	(fhandler_socket::ioctl): Never actually switch to blocking mode.
	Just keep track of the setting.
	* net.cc (fdsock): Call prepare now.
	(cygwin_connect): Revert again to event driven technique.
	(cygwin_accept): Ditto.
	* poll.cc (poll): Don't call recvfrom on a listening socket.
	Remove special case for failing recvfrom.
	* include/sys/socket.h: Declare recv* and send* functions ssize_t as
	requested by POSIX.

2006-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_inet_ntop): Fix data type of forth parameter.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/in6.h (struct in6_addr): Fix typo.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.din: Export in6addr_any, in6addr_loopback, freeaddrinfo,
	gai_strerror, getaddrinfo, getnameinfo.
	* fhandler_socket.cc: Include cygwin/in6.h.
	(get_inet_addr): Accomodate AF_INET6 usage.
	(fhandler_socket::connect): Ditto.
	(fhandler_socket::listen): Ditto.
	(fhandler_socket::sendto): Ditto.
	* net.cc: Include cygwin/in6.h.
	(in6addr_any): Define.
	(in6addr_loopback): Define.
	(cygwin_socket): Accomodate AF_INET6 usage.
	(socketpair): Bind socketpairs only to loopback for security.
	(inet_pton4): New static function.
	(inet_pton6): Ditto.
	(cygwin_inet_pton): New AF_INET6 aware inet_pton implementation.
	(inet_ntop4): New static function.
	(inet_ntop6): Ditto.
	(cygwin_inet_ntop): New AF_INET6 aware inet_ntop implementation.
	(ga_aistruct): New static function.
	(ga_clone): Ditto.
	(ga_echeck): Ditto.
	(ga_nsearch): Ditto.
	(ga_port): Ditto.
	(ga_serv): Ditto.
	(ga_unix): Ditto.
	(gn_ipv46): Ditto.
	(ipv4_freeaddrinfo): Ditto.
	(ipv4_getaddrinfo): Ditto.
	(ipv4_getnameinfo): Ditto.
	(gai_errmap_t): New structure holding error code - error string mapping.
	(cygwin_gai_strerror): New function implementing gai_strerror.
	(w32_to_gai_err): New static function.
	(get_ipv6_funcs): Ditto.
	(load_ipv6_funcs): Ditto.
	(cygwin_freeaddrinfo): New function implementing freeaddrinfo.
	(cygwin_getaddrinfo): New function implementing getaddrinfo.
	(cygwin_getnameinfo): New function implementing getnameinfo.
	* include/netdb.h: Include stdint.h and cygwin/socket.h.  Define
	data types and macros used by getaddrinfo and friends.  Declare
	freeaddrinfo, gai_strerror, getaddrinfo and getnameinfo.
	* include/cygwin/in.h: Add IPv6 related IPPROTOs. Remove definition
	of struct sockaddr_in6.  Include cygwin/in6.h instead.
	* include/cygwin/in6.h: New header file defining IPv6 releated
	data types and macros.
	* include/cygwin/socket.h: Enable AF_INET6 and PF_INET6.  Add
	IPv6 related socket options.
	* include/cygwin/version.h: Bump API minor number.

2006-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@a117 3
		  if (!SetTokenInformation (hProcImpToken, TokenPrimaryGroup,
					    &gsid, sizeof gsid))
		    debug_printf ("SetTokenInformation(TokenPrimaryGroup), %E");
d120 1
@


1.143
log
@	* dtable.cc (handle_to_fn): Accomodate new argument order in call to
	sys_wcstombs.
	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Call sys_wcstombs
	instead of just wcstombs to accomodate OEM codepages.
	* miscfuncs.cc (sys_wcstombs): Split len argument in source and target
	length.  Always 0-terminate result in target string.
	* security.cc (lsa2wchar): Remove unused function.
	(lsa2str): Ditto.
	(get_lsa_srv_inf): Ditto.
	(get_logon_server): Accomodate new argument order in call to
	sys_wcstombs.
	(get_user_groups): Ditto.
	(get_user_local_groups): Ditto.
	(get_priv_list): Call sys_wcstombs directly instead of lsa2str.
	* uinfo.cc (cygheap_user::ontherange): Accomodate new argument order
	in call to sys_wcstombs.
	* winsup.h (sys_wcstombs): Change prototype to match new argument order.
@
text
@d380 1
a380 1
  if (get_logon_server (mydomain, logsrv, NULL))
@


1.143.2.1
log
@	* autoload.cc (DsGetDcNameA): Define.
	(NetGetAnyDCName): Define.
	* security.cc: Include dsgetdc.h.
	(DsGetDcNameA): Declare.
	(DS_FORCE_REDISCOVERY): Define.
	(get_logon_server): Add bool parameter to control rediscovery of DC.
	Use DsGetDcNameA function if supported, NetGetDCName/NetGetAnyDCName
	otherwise.
	(get_server_groups): Rediscover DC if get_user_groups fails and
	try again.
	(get_reg_security): Use correct error code macro when testing
	RegGetKeySecurity return value.
	* security.h (get_logon_server): Remove default vaue from wserver
	parameter.  Add rediscovery parameter.
	* uinfo.cc (cygheap_user::env_logsrv): Accomodate rediscovery parameter
	in call to get_logon_server.
@
text
@d380 1
a380 1
  if (get_logon_server (mydomain, logsrv, NULL, false))
@


1.142
log
@Remove some more unneeded 'return;'s throughout.
@
text
@d309 2
a310 1
		  sys_wcstombs (homepath_env_buf, ui->usri3_home_dir, CYG_MAX_PATH);
d313 2
a314 2
		      sys_wcstombs (homepath_env_buf, ui->usri3_home_dir_drive,
				    CYG_MAX_PATH);
@


1.141
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@a129 2

  return;
a570 1
  return;
@


1.140
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d129 1
a129 1
  (void) cygheap->user.ontherange (CH_HOME, pw);
d443 1
a443 1
    (void) domain ();
@


1.139
log
@	* uinfo.cc (uinfo_init): Call reimpersonate to set the main thread's
	impersonation token.
@
text
@d172 3
a174 3
  int err = __check_null_invalid_struct (name, len);
  if (err)
    return err;
@


1.138
log
@	* pinfo.cc (pinfo::init): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	(pinfo::set_acl): Replace sa_buf by dynamically allocated acl_buf.
	* sec_acl.cc (setacl): Allocate acl dynamically.
	* sec_helper.cc (sec_acl): Add test for alignment of acl when
	DEBUGGING is defined.
	(__sec_user): Same for sa_buf.
	* security.cc (verify_token): Define sd_buf as PSECURITY_DESCRIPTOR
	and allocate dynamically.
	(alloc_sd): Allocate acl dynamically.
	security.h (sec_user_nih): Change first parameter to
	SECURITY_ATTRIBUTES *.
	(sec_user): Ditto.
	* sigproc.cc (wait_sig): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	* syscalls.cc (seteuid32): Define dacl_buf as PACL and allocate
	dynamically.
	* uinfo.cc (cygheap_user::init): Define sa_buf as PSECURITY_ATTRIBUTES
	and allocate dynamically.
	* winbase.h (ilockincr): Mark first argument of inline assembly as
	earlyclobber.
	(ilockdecr): Ditto.
@
text
@d162 1
@


1.137
log
@white space and minor comment cleanup.
@
text
@d68 1
a68 1
  char sa_buf[1024];
@


1.136
log
@	* cygheap.cc (cygheap_init): Accomodate set_process_privilege change.
	* cygheap.h (cygheap_user::curr_primary_token): New member.
	(cygheap_user::primary_token): New method.
	(cygheap_user::deimpersonate): Always revert to processes'
	impersonation token.
	(cygheap_user::reimpersonate): Set processes' or setuid token as
	necessary.
	(cygheap_user::has_impersonation_tokens): Look for curr_primary_token
	value.
	(cygheap_user::close_impersonation_tokens): Close curr_primary_token
	here if necessary.  Don't reset token values to NO_IMPERSONATION since
	that's done in uinfo_init anyway.
	(init_cygheap::luid): New LUID array keeping privilege LUIDs.
	* cygtls.cc (_cygtls::init_thread): Call cygheap->user.reimpersonate.
	* dcrt0.cc (hProcToken): New global variable to keep process token.
	(hProcImpToken): Ditto for process impersonation token.
	(dll_crt0_0): Open process token here once.  Duplicate to create
	hProcImpToken.
	(dll_crt0_1): Call set_cygwin_privileges.
	* environ.cc (allow_ntea): Drop duplicate declaration.
	(allow_smbntsec): Ditto.
	(set_traverse): Only set allow_traverse here.
	(environ_init): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop call to
	enable_restore_privilege.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	* fork.cc (fork_child): Move call to cygheap->user.reimpersonate after
	syn with parent. Call set_cygwin_privileges.
	* grp.cc (internal_getgroups): Use hProcImpToken instead of opening
	process token.
	* path.cc (fs_info::update): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges.
	* registry.cc (load_registry_hive): Drop setting restore privilege
	since it's already set if available.
	* sec_helper.cc: Include cygtls.h.
	(cygpriv): Privilege string array.
	(privilege_luid): New function, evaluate LUID from cygpriv_idx.
	(privilege_luid_by_name): New function, evaluate LUID from privilege
	string.
	(privilege_name): New function, evaluate privilege string from
	cygpriv_idx.
	(set_privilege): New static function called by set_process_privilege
	and set_thread_privilege.  Call privilege_luid to get privilege LUID.
	Fix bug in return value evaluation. Improve debug output.
	(set_cygwin_privileges): New function.
	(set_process_privilege): Remove.
	(enable_restore_privilege): Remove.
	* security.cc (allow_traverse): New global variable.
	(sys_privs): Change type to cygpriv_idx and store privilege indices
	instead of strings.
	(SYSTEM_PRIVILEGES_COUNT): Renamed from SYSTEM_PERMISSION_COUNT.
	(get_system_priv_list): Don't use numerical constant in malloc call.
	Use privilege_luid to get privilege LUIDs.
	(get_priv_list): Call privilege_luid_by_name to get LUIDs. Improve
	inner privilege LUID comparison loop.
	(create_token): Enable create token privilege using
	push/pop_self_privileges. Use hProcToken instead of opening process
	token. Use default DACL when duplicating token.
	(subauth): Enable tcb privilege using push/pop_self_privileges.
	Use sec_none instead of homw made security attributes when duplicating
	token.
	(check_file_access): Don't duplicate access token, use active
	impersonation token as is.
	* security.h (enum cygpriv_idx): New enumeration type enumerating
	possible privileges.
	(privilege_luid): Declare new function.
	(privilege_luid_by_name): Ditto.
	(privilege_name): Ditto.
	(allow_traverse): Declare.
	(set_privilege): Declare function.
	(set_process_privilege): Define as macro.
	(enable_restore_privilege): Remove declaration.
	(_push_thread_privilege): Define macro.
	(push_thread_privilege): Ditto.
	(pop_thread_privilege): Ditto.
	(pop_self_privilege): Ditto.
	* spawn.cc (spawn_guts): Use cygheap->user.primary_token instead of
	cygheap->user.token.
	* syscalls.cc (statvfs): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges. Rearrange code
	to simplify push/pop bracketing.
	(seteuid32): Use hProcToken instead of opening process token. Call
	cygheap->user.deimpersonate instead of RevertToSelf.  Create
	impersonation token from primary internal or external token.  Set
	cygheap->user.curr_primary_token and cygheap->user.current_token
	privileges once here.  Drop "failed" and "failed_ptok" labels.
	Drop setting DefaultDacl of process token.
	(setegid32): Use hProcToken and hProcImpToken instead of opening
	process token. Always reimpersonate afterwards.
	* uinfo.cc (cygheap_user::init): Use hProcToken instead of opening
	process token.
	(internal_getlogin): Ditto. Set hProcImpToken, too.
	(uinfo_init): Initialize cygheap->user.curr_primary_token.
	* winsup.h (hProcToken): Declare.
	(hProcImpToken): Declare.
@
text
@d453 1
a453 1
        {
d463 1
a463 1
        debug_printf ("GetWindowsDirectory(), %E");
@


1.135
log
@	Unify usage of CYG_MAX_PATH throughout.  Change buffers from
	size CYG_MAX_PATH + 1 to CYG_MAX_PATH.  Change length tests
	accordingly.
@
text
@a46 1
  HANDLE ptok;
d50 1
a50 7
  if (!OpenProcessToken (hMainProc, TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
			 &ptok))
    {
      system_printf ("OpenProcessToken(), %E");
      return;
    }
  if (!GetTokenInformation (ptok, TokenPrimaryGroup,
d55 2
a56 1
  if (!GetTokenInformation (ptok, TokenUser, &effec_cygsid, sizeof (cygsid), &siz))
d59 1
a59 1
      goto out;
d63 2
a64 1
  if (!SetTokenInformation (ptok, TokenOwner, &effec_cygsid, sizeof (cygsid)))
d69 2
a70 1
  psd = (PSECURITY_DESCRIPTOR) (sec_user_nih (sa_buf, sid()))->lpSecurityDescriptor;
d74 1
a74 2
  if (GetSecurityDescriptorDacl (psd, &acl_exists,
				 &dacl.DefaultDacl, &dummy)
d78 2
a79 1
      if (!SetTokenInformation (ptok, TokenDefaultDacl, &dacl, sizeof (dacl)))
a85 2
 out:
  CloseHandle (ptok);
d112 1
a112 3
	      HANDLE ptok;
	      if (gsid != user.groups.pgsid
		  && OpenProcessToken (hMainProc, TOKEN_ADJUST_DEFAULT, &ptok))
d115 4
a118 1
		  if (!SetTokenInformation (ptok, TokenPrimaryGroup,
a122 1
		  CloseHandle (ptok);
d159 1
@


1.134
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d254 1
a254 1
  char homepath_env_buf[CYG_MAX_PATH + 1];
d288 1
a288 1
	      char buf[CYG_MAX_PATH + 1];
d421 1
a421 1
  char userprofile_env_buf[CYG_MAX_PATH + 1];
@


1.133
log
@2004-11-20  Pierre Humblet <pierre.humblet@@ieee.org>

	* cygheap.h (cygheap_user::get_windows_id): New method.
	* registry.h (get_registry_hive_path): Change argument type.
	(load_registry_hive): Ditto.
	* registry.cc (get_registry_hive_path): Change argument type and take
	Win9x keys into account.
	(load_registry_hive): Ditto.
	* uinfo.cc (cygheap_user::env_userprofile): Use get_windows_id, even
	for SYSTEM.
	* shared.cc (user_shared_initialize): Use get_windows_id.
	* syscalls.cc (seteuid32): Load the registry hive and reload the user
	shared also on Win9x.
@
text
@d21 1
a26 1
#include "cygerrno.h"
@


1.132
log
@2004-10-28  Pierre Humblet <pierre.humblet@@ieee.org>

        * path.cc (mount_info::from_registry): Deimpersonate while
        accessing HKLM.
        (mount_info::read_cygdrive_info_from_registry): Ditto.
        * cygheap.h: Define NO_IMPERSONATION.
        (cygheap_user::issetuid): Replace INVALID_HANDLE_VALUE by
        NO_IMPERSONATION.
        (cygheap_user::has_impersonation_tokens): Ditto.
        (cygheap_user::close_impersonation_tokens): Ditto.
        * uinfo.cc (uinfo_init): Ditto.
        * syscalls.cc (seteuid32): Ditto.
        * security.cc (set_impersonation_token): Ditto.
@
text
@d422 2
d425 1
a425 4
  /* FIXME: Should this just be setting a puserprofile like everything else? */
  const char *myname = winname ();
  if (myname && strcasematch (myname, "SYSTEM")
      && get_registry_hive_path (sid (), userprofile_env_buf))
@


1.131
log
@	* cygheap.h (class cygheap_user): Add psystemroot member and
	env_systemroot method.
	* environ.cc (struct spenv): Add add_always member.
	(spenvs): Accomodate new add_always member.  Add
	cygheap_user::env_systemroot method to SYSTEMROOT entry.
	(build_env): Check add_always member when adding missing environment
	variables from spenvs.
	* uinfo.cc (cygheap_user::env_systemroot): New method.
@
text
@d163 3
a165 3
  cygheap->user.external_token = INVALID_HANDLE_VALUE;
  cygheap->user.internal_token = INVALID_HANDLE_VALUE;
  cygheap->user.current_token = INVALID_HANDLE_VALUE;
@


1.130
log
@2004-10-02  Pierre Humblet <pierre.humblet@@ieee.org>

	* path.h (enum path_types): Delete PATH_ISDISK.
	(path_conv::isdisk): Delete method.
	(path_conv::set_isdisk): Ditto.
	* path.cc (path_conv::check): Do not call set_isdisk.
	* uinfo.cc(pwdgrp::load): Do not call pc.isdisk.
@
text
@d452 22
@


1.129
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d514 1
a514 1
  if (pc.error || !pc.exists () || !pc.isdisk () || pc.isdir ())
@


1.128
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d54 1
a54 1
      system_printf ("OpenProcessToken(): %E");
d59 1
a59 1
    system_printf ("GetTokenInformation (TokenPrimaryGroup): %E");
d64 1
a64 1
      system_printf ("GetTokenInformation (TokenUser): %E");
d70 1
a70 1
    debug_printf ("SetTokenInformation(TokenOwner): %E");
d84 1
a84 1
	system_printf ("SetTokenInformation (TokenDefaultDacl): %E");
d86 1
a86 1
	system_printf ("SetKernelObjectSecurity: %E");
d89 1
a89 1
    system_printf("Cannot get dacl: %E");
d125 1
a125 1
		    debug_printf ("SetTokenInformation(TokenPrimaryGroup): %E");
@


1.127
log
@	* cygwin.din: Add symbols flockfile, ftrylockfile, funlockfile,
	getgrgid_r, getgrnam_r and getlogin_r.
	* grp.cc (getgrgid_r): New function.
	(getgrnam_r): Ditto.
	* syscalls.cc (flockfile): Ditto.
	(ftrylockfile): Ditto.
	(funlockfile): Ditto.
	* sysconf.cc (sysconf): Return LOGIN_NAME_MAX in case of
	_SC_LOGIN_NAME_MAX.
	* thread.cc (__cygwin_lock_trylock): Define int.  Return value from
	call to pthread_mutex_trylock.
	* uinfo.cc (getlogin_r): New function.
	* include/limits.h: Define LOGIN_NAME_MAX.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/lock.h: Add declarations for __cygwin_lock_xxx functions.
	* include/sys/stdio.h: Add define for _ftrylockfile.
@
text
@d78 1
a78 1
  if (GetSecurityDescriptorDacl (psd, &acl_exists, 
d121 1
a121 1
	        {
d151 1
a151 1
  	   && cygheap->user.saved_uid == cygheap->user.real_uid
@


1.126
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d169 14
@


1.125
log
@	* uinfo.cc (cygheap_user::init): Use sec_user_nih to build a
	security descriptor. Set both the process and the default DACLs.
	* fork.cc (fork_parent): Use sec_none_nih security attributes.
	* spawn.cc (spawn_guts): Ditto.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.124
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d49 1
a49 2
  char pdacl_buf [sizeof (PTOKEN_DEFAULT_DACL) + ACL_DEFAULT_SIZE];
  PTOKEN_DEFAULT_DACL pdacl = (PTOKEN_DEFAULT_DACL) pdacl_buf;
d72 9
a80 4
  /* Add the user in the default DACL if needed */
  if (!GetTokenInformation (ptok, TokenDefaultDacl, pdacl, sizeof (pdacl_buf), &siz))
    system_printf ("GetTokenInformation (TokenDefaultDacl): %E");
  else if (pdacl->DefaultDacl) /* Running with security */
d82 5
a86 22
      PACL pAcl = pdacl->DefaultDacl;
      PACCESS_ALLOWED_ACE pAce;

      for (int i = 0; i < pAcl->AceCount; i++)
        {
	  if (!GetAce (pAcl, i, (LPVOID *) &pAce))
	    system_printf ("GetAce: %E");
	  else if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE
		   && effec_cygsid == &pAce->SidStart)
	    goto out;
	}
      pAcl->AclSize = &pdacl_buf[sizeof (pdacl_buf)] - (char *) pAcl;
      if (!AddAccessAllowedAce (pAcl, ACL_REVISION, GENERIC_ALL, effec_cygsid))
	system_printf ("AddAccessAllowedAce: %E");
      else if (FindFirstFreeAce (pAcl, (LPVOID *) &pAce), !(pAce))
	debug_printf ("FindFirstFreeAce %E");
      else
        {
          pAcl->AclSize = (char *) pAce - (char *) pAcl;
	  if (!SetTokenInformation (ptok, TokenDefaultDacl, pdacl, sizeof (* pdacl)))
	    system_printf ("SetTokenInformation (TokenDefaultDacl): %E");
        }
d88 2
@


1.123
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d183 1
a183 7
#ifdef _MT_SAFE
  char *this_username=_reent_winsup ()->_username;
#else
  static char this_username[UNLEN + 1] NO_COPY;
#endif

  return strcpy (this_username, cygheap->user.name ());
@


1.122
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d37 1
a37 1
cygheap_user::init()
d73 1
a73 1
  /* Add the user in the default DACL if needed */ 
d83 1
a83 1
	  if (!GetAce(pAcl, i, (LPVOID *) &pAce))
d90 1
a90 1
      if (!AddAccessAllowedAce (pAcl, ACL_REVISION, GENERIC_ALL, effec_cygsid)) 
d101 1
a101 1
 out:	  
d118 1
a118 1
    debug_printf("user not found in augmented /etc/passwd");
d316 1
a316 1
	      if (!(ret = NetUserGetInfo (wlogsrv, wuser, 3,(LPBYTE *)&ui)))
@


1.121
log
@2003-09-26  Pierre Humblet <pierre.humblet@@ieee.org>

	* uinfo.cc (cygheap_user::init): Make sure the current user appears
	in the default DACL. Rearrange to decrease the indentation levels.
	Initialize the effec_cygsid directly.
	(internal_getlogin): Do not reinitialize myself->gid. Open the process
	token with the required access.
	* cygheap.h (class cygheap_user): Delete members pid and saved_psid.
	Create members effec_cygsid and saved_cygsid.
	(cygheap_user::set_sid): Define inline.
	(cygheap_user::set_saved_sid): Ditto.
	(cygheap_user::sid): Modify.
	(cygheap_user::saved_sid): Modify.
	* cygheap.cc (cygheap_user::set_sid): Delete.
	(cygheap_user::set_saved_sid): Ditto.
	* sec_helper.cc (sec_acl): Set the correct acl size.
	* autoload.cc (FindFirstFreeAce): Add.
	* security.h: Define ACL_DEFAULT_SIZE.
@
text
@d257 1
a257 1
  char homepath_env_buf[MAX_PATH + 1];
d290 2
a291 2
	      char home[MAX_PATH];
	      char buf[MAX_PATH + 1];
d318 1
a318 1
		  sys_wcstombs (homepath_env_buf, ui->usri3_home_dir, MAX_PATH);
d322 1
a322 1
				    MAX_PATH);
d424 1
a424 1
  char userprofile_env_buf[MAX_PATH + 1];
@


1.120
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d44 33
a76 1
  if (wincap.has_security ())
d78 16
a93 8
      HANDLE ptok = NULL;
      DWORD siz, ret;
      cygsid tu;

      /* Get the SID from current process and store it in user.psid */
      if (!OpenProcessToken (hMainProc, TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
			     &ptok))
	system_printf ("OpenProcessToken(): %E");
d95 5
a99 13
	{
	  if (!GetTokenInformation (ptok, TokenUser, &tu, sizeof tu, &siz))
	    system_printf ("GetTokenInformation (TokenUser): %E");
	  else if (!(ret = set_sid (tu)))
	    system_printf ("Couldn't retrieve SID from access token!");
	  /* Set token owner to the same value as token user */
	  else if (!SetTokenInformation (ptok, TokenOwner, &tu, sizeof tu))
	    debug_printf ("SetTokenInformation(TokenOwner): %E");
	  if (!GetTokenInformation (ptok, TokenPrimaryGroup,
				    &groups.pgsid, sizeof tu, &siz))
	    system_printf ("GetTokenInformation (TokenPrimaryGroup): %E");
	  CloseHandle (ptok);
	}
d101 2
a109 2
  myself->gid = UNKNOWN_GID;

d131 1
a131 2
		  && OpenProcessToken (hMainProc, TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
				     &ptok))
@


1.119
log
@	* cygheap.cc (cygheap_user::set_saved_sid): Rename from set_orig_sid.
	* cygheap.h (class cygheap_user): Rename orig_psid, orig_uid and
	orig_gid to saved_psid, saved_uid and saved_gid respectively.
	Rename methods orig_sid and set_orig_sid to saved_sid and set_saved_sid
	respectively.
	* sec_helper.cc (sec_acl): Accomodate above changes.
	* spawn.cc (spawn_guts): Ditto.
	* uinfo.cc (uinfo_init): Ditto.
@
text
@d23 1
a24 1
#include "path.h"
@


1.118
log
@* shared_info.h (shared_info::initialize): Remove argument.
* cygheap.h (cygheap_user::init): New declaration.
* uinfo.cc (cygheap_user::init): New.
(internal_getlogin): Move functionality to cygheap_user::init.  Open the
process token to update the group sid.
* shared.cc (user_shared_initialize): Get the user information from
cygheap->user.
(shared_info::initialize): Remove argument.  Call cygheap->user.init instead of
cygheap->user.set_name.
(memory_init): Do not get the user name and do not pass it to
shared_info::initialize.
* registry.cc (get_registry_hive_path): Make csid a cygpsid.
(load_registry_hive): Ditto.
@
text
@d131 2
a132 2
  	   && cygheap->user.orig_uid == cygheap->user.real_uid
	   && cygheap->user.orig_gid == cygheap->user.real_gid
d141 2
a142 2
  cygheap->user.orig_uid = cygheap->user.real_uid = myself->uid;
  cygheap->user.orig_gid = cygheap->user.real_gid = myself->gid;
d146 1
a146 1
  cygheap->user.set_orig_sid ();	/* Update the original sid */
@


1.117
log
@	* grp.cc (read_group): Revert previous change.
	* uinfo.cc (pwdgrp::load): Always reset curr_lines.
@
text
@d33 3
d37 1
a37 1
internal_getlogin (cygheap_user &user)
d39 4
a42 2
  struct passwd *pw = NULL;
  HANDLE ptok = INVALID_HANDLE_VALUE;
a43 1
  myself->gid = UNKNOWN_GID;
d46 2
a47 1
      DWORD siz;
a48 1
      DWORD ret = 0;
d50 1
a50 2
      /* Try to get the SID either from current process and
	 store it in user.psid */
d54 1
a54 12
      else if (!GetTokenInformation (ptok, TokenUser, &tu, sizeof tu, &siz))
	system_printf ("GetTokenInformation (TokenUser): %E");
      else if (!(ret = user.set_sid (tu)))
	system_printf ("Couldn't retrieve SID from access token!");
      else if (!GetTokenInformation (ptok, TokenPrimaryGroup,
				     &user.groups.pgsid, sizeof tu, &siz))
	system_printf ("GetTokenInformation (TokenPrimaryGroup): %E");
       /* We must set the user name, uid and gid.
	 If we have a SID, try to get the corresponding Cygwin
	 password entry. Set user name which can be different
	 from the Windows user name */
      if (ret)
d56 4
a59 1
	  pw = internal_getpwsid (tu);
d61 1
a61 1
	  if (!SetTokenInformation (ptok, TokenOwner, &tu, sizeof tu))
d63 19
a81 1
	 }
d97 13
a109 6
	      /* Set primary group to the group in /etc/passwd. */
	      if (!SetTokenInformation (ptok, TokenPrimaryGroup,
					&gsid, sizeof gsid))
		debug_printf ("SetTokenInformation(TokenPrimaryGroup): %E");
	      else
		user.groups.pgsid = gsid;
a114 2
  if (ptok != INVALID_HANDLE_VALUE)
    CloseHandle (ptok);
@


1.116
log
@	* cygheap.h (class cygheap_user): Use INVALID_HANDLE_VALUE as invalid
	value for tokens.
	* syscalls.cc (seteuid32): Ditto.  Set new_token to process token if
	process token is suitable.
	* uinfo.cc (uinfo_init): Initialize tokens in cygheap user info
	to INVALID_HANDLE_VALUE.

	* cygheap.h (enum impersonation): Delete.
	(cygheap_user::impersonation_state): Delete.
	(cygheap_user::current_token): New.
	(cygheap_user::issetuid): Modify to use current_token.
	(cygheap_user::token): Ditto.
	(cygheap_user::deimpersonate): Ditto.
	(cygheap_user::reimpersonate): Ditto.
	(cygheap_user::has_impersonation_tokens): Ditto.
	(cygheap_user::close_impersonation_tokens): Ditto.
	* security.cc (cygwin_set_impersonation_token): Always set the token.
	(verify_token): Change type of gsid to cygpsid.
	(get_file_attribute): Use the effective ids.
	* syscalls.cc (seteuid32): Modify to use cygheap_user::current_token.
	* uinfo.cc (uinfo_init) Do not set cygheap->user.impersonation_state.
@
text
@d461 1
a499 1
	      curr_lines = 0;
@


1.115
log
@	* cygheap.h (enum impersonation): New enum.
	(cygheap_user::token): Delete.
	(cygheap_user::impersonated): Delete.
	(cygheap_user::external_token): New member.
	(cygheap_user::internal_token): New member.
	(cygheap_user::impersonation_state): New member.
	(cygheap_user::issetuid): Modify.
	(cygheap_user::token): New method.
	(cygheap_user::deimpersonate): New method.
	(cygheap_user::reimpersonate): New method.
	(cygheap_user::has_impersonation_tokens): New method.
	(cygheap_user::close_impersonation_tokens): New method.
	* dtable.cc (dtable::vfork_child_dup): Use new cygheap_user methods.
	* fhandler_socket.cc (fhandler_socket::dup): Ditto.
	* fork.cc (fork_child): Ditto.
	(fork_parent): Ditto.
	* grp.cc (internal_getgroups): Ditto.
	* security.cc (verify_token): Ditto.
	(check_file_access): Ditto.
	(cygwin_set_impersonation_token): Detect conflicts. Set
	user.external_token.
	* spawn.cc (spawn_guts): Use new cygheap_user methods.
	* syscalls.cc (seteuid32): Rearrange to use the two tokens
	in cygheap_user.
	(setegid32): Use new cygheap_user methods.
	* uinfo.cc: (internal_getlogin): Ditto.
@
text
@d125 3
a127 1
  cygheap->user.impersonation_state = IMP_NONE;
@


1.114
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d105 1
a105 1
  if (child_proc_info && cygheap->user.token == INVALID_HANDLE_VALUE)
d117 1
a117 2
      if (!ImpersonateLoggedOnUser (cygheap->user.token))
	system_printf ("ImpersonateLoggedOnUser: %E");
d121 1
a121 1
    CloseHandle (cygheap->user.token);
d125 1
a126 1
  cygheap->user.token = INVALID_HANDLE_VALUE; /* No token present */
@


1.113
log
@	* spawn.cc (spawn_guts): Call CreateProcess while impersonated,
	when the real {u,g}ids and the groups are original.
	Move RevertToSelf and ImpersonateLoggedOnUser to the main line.
	* uinfo.cc (uinfo_init): Reorganize. If CreateProcess was called
	while impersonated, preserve the uids and gids and call
	ImpersonateLoggedOnUser. Preserve the uids and gids on Win9X.

	* exceptions.cc (error_start_init): Quote the pgm in the command.
@
text
@a19 1
#include <errno.h>
@


1.112
log
@	* uinfo.cc (internal_getlogin): Only update user.groups.pgsid
	if the call to set the primary group succeeds.
@
text
@d106 11
a116 1
  if (!child_proc_info || cygheap->user.token != INVALID_HANDLE_VALUE)
d118 3
a120 6
      if (!child_proc_info)
	internal_getlogin (cygheap->user); /* Set the cygheap->user. */
      else
	CloseHandle (cygheap->user.token);
      cygheap->user.set_orig_sid ();	/* Update the original sid */
      cygheap->user.token = INVALID_HANDLE_VALUE; /* No token present */
d122 3
a124 1
  /* Real and effective uid/gid are identical on process start up. */
d127 2
@


1.111
log
@	* security.h: Introduce names UNKNOWN_UID and UNKNOWN_GID and delete
	declaration of is_grp_member.
	* uinfo.cc (internal_getlogin): Use UNKNOWN_GID.
	* passwd.cc (pwdgrp::read_passwd): Use UNKNOWN_UID.
	* grp.cc (pwdgrp::read_group): Change group name to provide better
	feedback.
	(getgrgid): Use gid16togid32.
	* sec_helper.cc (is_grp_member): Delete.
@
text
@a85 1
	      user.groups.pgsid = gsid;
d89 2
@


1.110
log
@* uinfo.cc (pwdgrp::next_num): Remove check for NULL since it is no longer a
valid return from next_str.
(pwdgrp::add_line): Duh.  Revert to use strchr.
@
text
@d40 1
a40 1
  myself->gid = DEFAULT_GID;
@


1.109
log
@* strings.h (strechr): New function.
* uinfo.cc (pwdgrp::next_str): Search only for input char in string.  Return
EOS on failure.  Don't check for NULL since it shouldn't be possible.
(pwdgrp::add_line): Revert to replacing '\n' in input line with '\0'.
(pwdgrp::next_num): Pass explicit separator character to next_str.
* grp.cc (pwdgrp::parse_group): Ditto.
* passwd.cc (pwdgrp::parse_passwd): Ditto.  Revamp test for garbage input.
* pwdgrp.h (pwdgrp::next_str): Don't use default parameter.
@
text
@a407 2
  if (!p)
    return -1;
d419 2
a420 2
      eptr = strechr (lptr, '\n');
      if (*eptr)
@


1.108
log
@* uinfo.cc (pwdgrp::load): Regularize strace output.  Add warning for
CreateFile failure.
@
text
@a396 4
  if (!lptr)
    return NULL;
  char search[] = ":\n\0\0";
  search[2] = c;
d398 3
a400 6
  char *p = strpbrk (lptr, search);
  if (p)
    {
      lptr = (*p == '\n') ? p : p + 1;
      *p = '\0';
    }
d407 1
a407 1
  char *p = next_str ();
d421 2
a422 2
      eptr = strchr (lptr, '\n');
      if (eptr)
d425 3
a427 1
	    eptr[-1] = '\n';
@


1.107
log
@* include/sys/strace.h (paranoid_printf): Define as not being part of "all"
output.
* pwdgrp.h (pwdgrp::next_num): Rename from next_int.  Returns true/false if
parse operation succeeded.
(pwdgrp::reparse): Remove.
(pwdgrp::raw_ptr): New function.  Returns pointer in line.
(pwdgrp::next_num): New functions for parsing other than unsigned long.
* grp.cc (pwdgrp::parse_group): Reinstate previous parsing behavior.  Don't
fill in fields with NULL and assign empty gr_mem to known pointer rather than
doing a pointless calloc.  Streamline gr_mem parsing.  Don't increment
curr_lines here.
* passwd.cc (pwdgrp::parse_passwd): Use new behavior of next_num.  Don't
increment curr_lines here.
* uinfo.cc (pwdgrp::next_str): Keep returning EOL if out of data.
(pwdgrp::reparse): Remove.
(pwdgrp::next_num): Rename from next_int.  Return bool indicating success of
parse, argument returns value parsed.
(pwdgrp::add_line): Increment curr_lines here on successful parse.
(pwdgrp::load): (from Pierre Humblet) Don't return status.  Just report it
here.
@
text
@d110 1
a110 1
        CloseHandle (cygheap->user.token);
d472 4
a475 1
	res = failed;
d503 1
a503 1
  debug_printf ("load of %s %s", posix_fname, res);
@


1.106
log
@* pwdgrp.cc (pwdgrp::reparse): Declare.
* uinfo.cc (pwdgrp::reparse): Define.
* grp.cc (pwdgrp::parse_group): Use.
@
text
@d403 1
a403 3
  if (!p)
    lptr = NULL;
  else
d405 1
a405 1
      lptr = (*p == '\n') ? NULL : p + 1;
d411 2
a412 8
void
pwdgrp::reparse (char *in_lptr)
{
  lptr = in_lptr;
}

int
pwdgrp::next_int (char c)
d414 1
a414 1
  char *p = next_str (c);
d418 2
a419 4
  unsigned n = strtoul (p, &cp, 10);
  if (p == cp)
    return -1;
  return n;
d440 2
a441 1
      (void) (this->*parse) ();
d446 1
a446 1
bool
d449 4
a461 1
  bool res;
d463 4
a466 1
    res = false;
d472 1
a472 1
	res = false;
d479 1
d484 1
a484 1
	      res = false;
d495 1
a495 1
	      res = true;
d500 1
d502 1
a502 1
  return res;
@


1.105
log
@	* syscalls.cc (seteuid32): On Win95 get the pw entry. If it exists
	update the euid and call cygheap->user.set_name. Remove special
	handling of ILLEGAL_UID.
	(setgid32): Add a debug_printf. On Win95, always set the egid.
	Remove special handling of ILLEGAL_GID. Do not compare gid and gr_gid.
	* child_info.h (class cygheap_exec_info): Remove uid.
	* spawn.cc (spawn_guts): Do not set ciresrv.moreinfo->uid.
	* dcrto.cc (dll_crt0_1): Always call uinfo_init.
	* uinfo.cc (uinfo_init): Reorganize and close handle if needed.
	(cygheap_user::ontherange): Do not call internal_getpwnam if pw is NULL.
@
text
@d413 6
@


1.104
log
@* pwdrp.h (pwdgrp::refresh): Lock entire test prior to reading.
* grp.cc (pwdgrp::parse_group): Eliminate arg and use class member instead.
Use next_str and next_int to parse arguments.
* passwd.cc (pwdgrp::parse_passwd): Ditto.
(grab_string): Eliminate.
(grab_int): Ditto.
* pwdgrp.h (pwdgrp::parse): Eliminate input arg.
(pwdgrp::parse_passwd): Reflect above change.
(pwdgrp::parse_group): Reflect above change.
(pwdgrp::next_str): New function.
(pwdgrp::next_int): Ditto.
(pwdgrp::gets): Eliminate.
* uinfo.cc (pwdgrp::next_str): New function.
(pwdgrp::next_int): Ditto.
(pwdgrp::add_line): Subsume gets.
(pwdgrp::gets): Eliminate.
(pwdgrp::load): Just call add_line to parse input buffer.
@
text
@d105 9
a113 3
  if (!child_proc_info)
    internal_getlogin (cygheap->user); /* Set the cygheap->user. */

a116 3
  cygheap->user.set_orig_sid ();	/* Update the original sid */

  cygheap->user.token = INVALID_HANDLE_VALUE; /* No token present */
a219 2
	  if (!pw)
	    pw = internal_getpwnam (name ());
@


1.103
log
@* grp.cc: Call gr.refresh() rather than doing isunitialized tests throughout.
(gr): Use constructor (sigh).
(pwdgrp::parse_group): Rename from parse_grp.
(pwdgrp::read_group): Rename from read_etc_group.  Just call gr.load with a
single argument.
* passwd.cc: Call pr.refresh() rather than doing isunitialized tests
throughout.
(pr): Use constructor (sigh).
(pwdgrp::parse_passwd): Rename from "parse_pwd".
(pwdgrp::read_passwd): Rename from read_etc_passwd.  Just call pr.load with a
single argument.
* pwdgrp.h (pwdgrp_state): Eliminate.
(pwdgrp): Reflect above renamings.
(pwdgrp::etc_ix): Rename from pwd_ix.
(pwdgrp::read): New element.
(pwdgrp::lock): New element.
(pwdgrp::refresh): New function.
(pwdgrp::load): Eliminate variations which take buffer arguments.
(pwdgrp::pwdgrp): New constructors.  Initialize mutex here.
* uinfo.cc (pwdgrp::load): Accommodate pwd_ix -> etc_ix renaming.
(pwdgrp::load): Set initialized state to true rather than setting state to
loaded.
@
text
@d394 1
a394 1
pwdgrp::gets (char*& eptr)
d396 7
a402 2
  char *lptr;
  if (!eptr)
d406 24
d434 3
a436 3
	  if (eptr > lptr && *(eptr - 1) == '\r')
	    *(eptr - 1) = 0;
	  *eptr++ = '\0';
d438 6
d445 1
a445 12
  return lptr;
}

void
pwdgrp::add_line (char *line)
{
  if (curr_lines >= max_lines)
    {
      max_lines += 10;
      *pwdgrp_buf = realloc (*pwdgrp_buf, max_lines * pwdgrp_buf_elem_size);
    }
  (void) (this->*parse) (line);
a485 2
	      eptr = buf;
	      char *line;
d487 2
a488 2
	      while ((line = gets (eptr)) != NULL)
		add_line (line);
@


1.102
log
@* path.h (etc::change_possible): Revert the type to bool.
(etc::set_last_modified): Remove obsolete function.
* path.cc (etc::change_possible): Revert type to bool.
(etc::test_file_change): Do not test for negative values of change_possible and
do not set it to -res.
(etc::dir_changed): When the handle is NULL, call memset instead of
test_file_changed.  When the handle is invalid, return true.
(etc::file_changed): Remove unneeded check for !fn[n].
@
text
@d432 1
a432 1
  pwd_ix = etc::init (pwd_ix, pc);
d473 1
a473 1
  state = loaded;
@


1.101
log
@* pwdgrp.h (etc): Move to path.h.
(pwdgrp::max_lines): New field.
(pwdgrp::curr_lines): New field.
(pwdgrp::pwdgrp_buf): Ditto.
(pwdgrp_buf_elem_size): Ditto.
(pwdgrp_parse): Ditto.
(pwdgrp::gets): Just declare here.
(pwdgrp::load): Ditto.  Just take one argument.
(pwdgrp::load): Define overloaded function accepting passwd buf.
(pwdgrp::load): Define overloaded function accepting group buf.
* grp.cc: Use pwdgrp elements rather than standalone static variables
throughout.
(curr_lines): Eliminate.
(max_lines): Ditto.
(add_grp_line): Ditto.
(parse_grp): Define as returning boolean.  Accept void * arg and line count.
Coerce first argument into __group32 buf reference.  Increment curr_line as
appropriate.
(read_etc_group): Pass pwdgrp buffer to gr.load.
* passwd.cc: Use pwdgrp elements rather than standalone static variables
throughout.
(curr_lines): Eliminate.
(max_lines): Ditto.
(add_grp_line): Ditto.
(parse_passwd): Define as returning boolean.  Accept void * arg and line count.
Coerce first argument into passwd buf reference.  Increment curr_line as
appropriate.
(read_etc_group): Pass pwdgrp buffer to pr.load.
* path.cc (etc::fn): Extend buffer size to allow index by 1 rather than zero.
(etc::last_modified): Ditto.
(etc::change_possible): Ditto.  Renamed from sawchange.  Change to signed char
since elements are now tri-state.
(etc::init): Assume "handle" is 1 based rather than 0.
(etc::test_file_change): New function.  Sets change_possible based on file date
comparison.
(etc::dir_changed): Check file states immediately after changed_h is
initialized to avoid a race.
(etc::file_changed): Use test_file_change to detect if file needs to be
updated.
* path.h (etc): Move class here from pwdgrp.h.
* uinfo.cc: Move etc:: functions to path.cc.  Move pwdgrp functions here.
(pwdgrp::gets): Eliminate buf checks.  Just check eptr and set lptr.
(pwdgrp::add_line): New function.
(pwdgrp::load): Call generic add_line function which will call correct parser.
@
text
@a454 1
	      fh = NULL;
@


1.100
log
@update copyright
@
text
@d393 2
a394 7
int NO_COPY etc::curr_ix = -1;
bool NO_COPY etc::sawchange[MAX_ETC_FILES];
const NO_COPY char *etc::fn[MAX_ETC_FILES];
FILETIME NO_COPY etc::last_modified[MAX_ETC_FILES];

int
etc::init (int n, const char *etc_fn)
d396 3
a398 4
  if (n >= 0)
    /* ok */;
  else if (++curr_ix < MAX_ETC_FILES)
    n = curr_ix;
d400 11
a410 6
    api_fatal ("internal error");

  fn[n] = etc_fn;
  sawchange[n] = false;
  paranoid_printf ("curr_ix %d, n %d", curr_ix, n);
  return curr_ix;
d413 2
a414 2
bool
etc::dir_changed (int n)
d416 1
a416 3
  bool res = sawchange[n];

  if (!res)
d418 2
a419 21
      static HANDLE NO_COPY changed_h;
      if (!changed_h)
	{
	  path_conv pwd ("/etc");
	  changed_h = FindFirstChangeNotification (pwd, FALSE,
						  FILE_NOTIFY_CHANGE_LAST_WRITE);
#ifdef DEBUGGING
	  if (changed_h == INVALID_HANDLE_VALUE)
	    system_printf ("Can't open /etc for checking, %E", (char *) pwd,
			   changed_h);
#endif
	}

      if (changed_h == INVALID_HANDLE_VALUE)
	res = true;
      else if (WaitForSingleObject (changed_h, 0) == WAIT_OBJECT_0)
	{
	  (void) FindNextChangeNotification (changed_h);
	  memset (sawchange, true, sizeof sawchange);
	  res = true;
	}
d421 1
a421 3

  paranoid_printf ("%s res %d", fn[n], res);
  return res;
d425 1
a425 1
etc::file_changed (int n)
d427 13
a439 4
  bool res = false;
  if (!fn[n])
    res = true;
  else if (dir_changed (n))
d441 4
a444 5
      HANDLE h;
      WIN32_FIND_DATA data;

      if ((h = FindFirstFile (fn[n], &data)) == INVALID_HANDLE_VALUE)
	res = true;
d447 24
a470 3
	  FindClose (h);
	  if (CompareFileTime (&data.ftLastWriteTime, last_modified + n) > 0)
	    res = true;
d473 2
a474 2
  sawchange[n] = false;
  paranoid_printf ("%s res %d", fn[n], res);
a475 7
}

void
etc::set_last_modified (int n, FILETIME& ft)
{
  last_modified[n] = ft;
  sawchange[n] = false;
@


1.99
log
@* uinfo.cc (etc::dir_changed): Don't print a warning if can't open /etc, unless
debugging.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.98
log
@* grp.cc (read_etc_group): On NT, add a line for gid = -1.  Change name
"unknown" to "mkgroup".
(internal_getgrgid): Do not return default in nontsec case.
(internal_getgroups): Add argument srchsid and look for it in groups if not
NULL.
* passwd.cc (read_etc_passwd): On NT, add a line for uid = -1.  Use same
default uid for Win95 and NT.  Call cygheap_user::ontherange to initialize
HOME.
* cygheap.cc (init_cygheap::etc_changed): Move to uinfo.cc.
* cygheap.h (init_cygheap::etc_changed_h): Remove.
(init_cygheap::etc_changed): Ditto.
* grp.cc (group_state): Remove.  Use gr instead throughout.
(gr): Define as class pwdgrp.
(read_etc_group): Remove gr definition.  Remove calls to set_last_modified and
close.  Pass add_grp to gr.load to load file.
* passwd.cc (passwd_state): Remove.  Use pr instead, throughout.
(pr): Define as class pwdgrp.
(read_etc_passwd): Remove pr definition.  Remove calls to set_last_modified and
close.  Pass add_pwd_line to pr.load to load file.
* pwdgrp.h (etc): New helper class for pwdgrp.
(pwdgrp): Combine pwdgrp_check and pwdgrp_read into one class.  Remove file_w32
and last_modified fields.
(pwdgrp::set_last_modified): Remove.
(pwdgrp::isinitializing): Remove FindFirstFile stuff.  Move to
etc::file_changed.
(pwdgrp::load): Rename from 'open'.  Call etc::init to initialize etc scanning.
Close file handle after reading buffer into memory.  Parse buffer by calling
second argument.
(pwdgrp::gets): Reorganize slightly to rely on eptr starting at beginning of
buffer.  Free buffer when memory exhausted.
(pwdgrp::close): Remove.
* uinfo.cc (etc::dir_changed): New function.
(etc::init): Ditto.
(etc::file_changed): Ditto.
(etc::set_last_modified): Ditto.
@
text
@d427 1
d431 1
@


1.97
log
@2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* pwdgrp.h (pwdgrp_check::pwdgrp_state): Replace by
	pwdgrp_check::isinitializing ().
	(pwdgrp_check::isinitializing): Create.
	* passwd.cc (grab_int): Change type to unsigned, use strtoul and
	set the pointer content to 0 if the field is invalid.
	(parse_pwd): Move validity test after getting pw_gid.
	(read_etc_passwd): Replace "passwd_state <= " by
	passwd_state::isinitializing ().
	(internal_getpwuid): Ditto.
	(internal_getpwnam): Ditto.
	(getpwent): Ditto.
	(getpass): Ditto.
	* grp.cc (parse_grp): Use strtoul for gr_gid and verify the validity.
	(read_etc_group): Replace "group_state <= " by
	group_state::isinitializing ().
	(internal_getgrgid): Ditto.
	(getgrent32): Ditto.
	(internal_getgrent): Ditto.

2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h: Move declarations of internal_getgrent,
	internal_getpwsid and internal_getgrsid to pwdgrp.h.
	* pwdgrp.h: Declare internal_getpwsid, internal_getpwnam,
	internal_getpwuid, internal_getgrsid, internal_getgrgid,
	internal_getgrnam, internal_getgrent and internal_getgroups.
	Delete "emulated" from enum pwdgrp_state.
	(pwdgrp_check::isuninitialized): Create.
	(pwdgrp_check::pwdgrp_state): Change state to initializing
	rather than to uninitialized.
	(pwdgrp_read::gets): Remove trailing CRs.
	* passwd.cc (grab_string): Don't look for NLs.
	(grab_int): Ditto.
	(parse_pwd): Don't look for CRs. Return 0 if entry is too short.
	(search_for): Delete.
	(read_etc_passwd): Simplify tests to actually read the file.
	Set state to loaded before making internal_getpwXX calls.
	Replace search_for calls by equivalent internal_pwgetXX calls.
	(internal_getpwsid): Use passwd_state.isuninitialized to decide
	to call read_etc_passwd.
	(internal_getpwuid): Create.
	(internal_getpwnam): Create.
	(getpwuid32): Simply call internal_getpwuid.
	(getpwuid_r32): Call internal_getpwuid.
	(getpwnam): Simply call internal_getpwnam.
	(getpwnam_r): Call internal_getpwnam.
	* grp.cc (parse_grp): Don't look for CRs. Adjust blank space.
	(add_grp_line): Adjust blank space.
	(class group_lock): Ditto.
	(read_etc_group): Simplify tests to actually read the file.
	Set state to loaded before making internal_getgrXX calls.
	Replace getgrXX calls by equivalent internal calls.
	(internal_getgrsid): Use group_state.isuninitialized to decide
	to call read_etc_group.
	(internal_getgrgid): Create.
	(internal_getgrnam): Create.
	(getgroups32): Simply call internal_getgrgid.
	(getgrnam32): Simply call internal_getgrnam.
	(internal_getgrent): Call group_state.isuninitialized.
	(internal_getgroups): Create from the former getgroups32, using
	two of the four arguments. Set gid to myself->gid and username
	to cygheap->user.name ().
	(getgroups32): Simply call internal_getgroup.
	(getgroups): Call internal_getgroup instead of getgroups32.
	(setgroups32): Call internal versions of get{pw,gr}XX.
	* sec_helper.cc: Include pwdgrp.h.
	(is_grp_member): Call internal versions of get{pw,gr}XX.
	* security.cc: Include pwdgrp.h.
	(alloc_sd): Call internal versions of get{pw,gr}XX.
	* syscalls.cc: Include pwdgrp.h.
	(seteuid32): Call internal versions of get{pw,gr}XX.
	(setegid32): Ditto.
	* uinfo.cc: Include pwdgrp.h.
	(internal_getlogin): Call internal versions of get{pw,gr}XX.
	(cygheap_user::ontherange): Ditto.
	* sec_acl.cc: Include pwdgrp.h.
	(setacl): Call internal versions of get{pw,gr}XX.
	(acl_access): Ditto and simplify logic.
	(aclfromtext): Ditto.
@
text
@d392 85
@


1.97.4.1
log
@trunk merge
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
a390 106
}

char *
pwdgrp::next_str (char c)
{
  if (!lptr)
    return NULL;
  char search[] = ":\n\0\0";
  search[2] = c;
  char *res = lptr;
  char *p = strpbrk (lptr, search);
  if (!p)
    lptr = NULL;
  else
    {
      lptr = (*p == '\n') ? NULL : p + 1;
      *p = '\0';
    }
  return res;
}

int
pwdgrp::next_int (char c)
{
  char *p = next_str (c);
  if (!p)
    return -1;
  char *cp;
  unsigned n = strtoul (p, &cp, 10);
  if (p == cp)
    return -1;
  return n;
}

char *
pwdgrp::add_line (char *eptr)
{
  if (eptr)
    {
      lptr = eptr;
      eptr = strchr (lptr, '\n');
      if (eptr)
	{
	  if (eptr > lptr && eptr[-1] == '\r')
	    eptr[-1] = '\n';
	  eptr++;
	}
      if (curr_lines >= max_lines)
	{
	  max_lines += 10;
	  *pwdgrp_buf = realloc (*pwdgrp_buf, max_lines * pwdgrp_buf_elem_size);
	}
      (void) (this->*parse) ();
    }
  return eptr;
}

bool
pwdgrp::load (const char *posix_fname)
{
  if (buf)
    free (buf);
  buf = NULL;

  pc.check (posix_fname);
  etc_ix = etc::init (etc_ix, pc);

  paranoid_printf ("%s", posix_fname);

  bool res;
  if (pc.error || !pc.exists () || !pc.isdisk () || pc.isdir ())
    res = false;
  else
    {
      HANDLE fh = CreateFile (pc, GENERIC_READ, wincap.shared (), NULL,
			      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
      if (fh == INVALID_HANDLE_VALUE)
	res = false;
      else
	{
	  DWORD size = GetFileSize (fh, NULL), read_bytes;
	  buf = (char *) malloc (size + 1);
	  if (!ReadFile (fh, buf, size, &read_bytes, NULL))
	    {
	      CloseHandle (fh);
	      if (buf)
		free (buf);
	      buf = NULL;
	      res = false;
	    }
	  else
	    {
	      CloseHandle (fh);
	      buf[read_bytes] = '\0';
	      char *eptr = buf;
	      curr_lines = 0;
	      while ((eptr = add_line (eptr)))
		continue;
	      debug_printf ("%s curr_lines %d", posix_fname, curr_lines);
	      res = true;
	    }
	}
    }

  initialized = true;
  return res;
@


1.97.4.2
log
@merge from trunk
@
text
@d105 3
a107 9
  if (!child_proc_info || cygheap->user.token != INVALID_HANDLE_VALUE)
    {
      if (!child_proc_info)
	internal_getlogin (cygheap->user); /* Set the cygheap->user. */
      else
        CloseHandle (cygheap->user.token);
      cygheap->user.set_orig_sid ();	/* Update the original sid */
      cygheap->user.token = INVALID_HANDLE_VALUE; /* No token present */
    }
d111 3
d217 2
a409 6
}

void
pwdgrp::reparse (char *in_lptr)
{
  lptr = in_lptr;
@


1.97.4.3
log
@merge from trunk
@
text
@d403 3
a405 1
  if (p)
d407 1
a407 1
      lptr = (*p == '\n') ? p : p + 1;
d413 8
a420 2
bool
pwdgrp::next_num (unsigned long& n)
d422 1
a422 1
  char *p = next_str ();
d426 4
a429 2
  n = strtoul (p, &cp, 10);
  return p != cp && !*cp;
d450 1
a450 2
      if ((this->*parse) ())
	curr_lines++;
d455 1
a455 1
void
a457 4
  const char *res;
  static const char failed[] = "failed";
  static const char succeeded[] = "succeeded";

d467 1
d469 1
a469 4
    {
      paranoid_printf ("strange path_conv problem");
      res = failed;
    }
d475 1
a475 1
	res = failed;
a481 1
	      paranoid_printf ("ReadFile failed, %E");
d486 1
a486 1
	      res = failed;
d497 1
a497 1
	      res = succeeded;
a501 1
  debug_printf ("load of %s %s", posix_fname, res);
d503 1
a503 1
  return;
@


1.97.4.4
log
@merge from trunk
@
text
@d110 1
a110 1
	CloseHandle (cygheap->user.token);
d472 1
a472 4
	{
	  paranoid_printf ("%s CreateFile failed, %E");
	  res = failed;
	}
d500 1
a500 1
  debug_printf ("%s load %s", posix_fname, res);
@


1.97.4.5
log
@merge from trunk
@
text
@d397 4
d402 6
a407 3
  lptr = strechr (lptr, c);
  if (*lptr)
    *lptr++ = '\0';
d414 1
a414 1
  char *p = next_str (':');
d428 2
a429 2
      eptr = strechr (lptr, '\n');
      if (*eptr)
d432 1
a432 3
	    eptr[-1] = '\0';
	  else
	    *eptr = '\0';
@


1.97.4.6
log
@merge from trunk
@
text
@d408 2
d421 2
a422 2
      eptr = strchr (lptr, '\n');
      if (eptr)
@


1.97.4.7
log
@merge from trunk
@
text
@d40 1
a40 1
  myself->gid = UNKNOWN_GID;
@


1.97.4.8
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d24 1
a25 1
#include "fhandler.h"
@


1.97.4.9
log
@merge from trunk
@
text
@d86 1
a89 2
	      else
		user.groups.pgsid = gsid;
@


1.97.4.10
log
@merge from trunk
@
text
@d20 1
d106 1
a106 11
  if (child_proc_info && !cygheap->user.has_impersonation_tokens ())
    return;

  if (!child_proc_info)
    internal_getlogin (cygheap->user); /* Set the cygheap->user. */
  /* Conditions must match those in spawn to allow starting child
     processes with ruid != euid and rgid != egid. */
  else if (cygheap->user.issetuid ()
  	   && cygheap->user.orig_uid == cygheap->user.real_uid
	   && cygheap->user.orig_gid == cygheap->user.real_gid
	   && !cygheap->user.groups.issetgroups ())
d108 6
a113 2
      cygheap->user.reimpersonate ();
      return;
d115 1
a115 3
  else
    cygheap->user.close_impersonation_tokens ();

a117 2
  cygheap->user.impersonation_state = IMP_NONE;
  cygheap->user.set_orig_sid ();	/* Update the original sid */
@


1.97.4.11
log
@merge from trunk
@
text
@d125 1
a125 3
  cygheap->user.external_token = INVALID_HANDLE_VALUE;
  cygheap->user.internal_token = INVALID_HANDLE_VALUE;
  cygheap->user.current_token = INVALID_HANDLE_VALUE;
@


1.97.4.12
log
@merge from trunk
@
text
@a460 1
  curr_lines = 0;
d499 1
@


1.97.4.13
log
@merge from trunk
@
text
@a32 3
/* Initialize the part of cygheap_user that does not depend on files.
   The information is used in shared.cc for the user shared.
   Final initialization occurs in uinfo_init */
d34 1
a34 1
cygheap_user::init()
d36 2
a37 4
  char user_name[UNLEN + 1];
  DWORD user_name_len = UNLEN + 1;

  set_name (GetUserName (user_name, &user_name_len) ? user_name : "unknown");
d39 1
d42 1
a42 2
      HANDLE ptok = NULL;
      DWORD siz, ret;
d44 1
d46 2
a47 1
      /* Get the SID from current process and store it in user.psid */
d51 12
a62 1
      else
d64 1
a64 4
	  if (!GetTokenInformation (ptok, TokenUser, &tu, sizeof tu, &siz))
	    system_printf ("GetTokenInformation (TokenUser): %E");
	  else if (!(ret = set_sid (tu)))
	    system_printf ("Couldn't retrieve SID from access token!");
d66 1
a66 1
	  else if (!SetTokenInformation (ptok, TokenOwner, &tu, sizeof tu))
d68 1
a68 19
	  if (!GetTokenInformation (ptok, TokenPrimaryGroup,
				    &groups.pgsid, sizeof tu, &siz))
	    system_printf ("GetTokenInformation (TokenPrimaryGroup): %E");
	  CloseHandle (ptok);
	}
    }
}

void
internal_getlogin (cygheap_user &user)
{
  struct passwd *pw = NULL;

  myself->gid = UNKNOWN_GID;

  if (wincap.has_security ())
    {
      cygpsid psid = user.sid ();
      pw = internal_getpwsid (psid);
d84 6
a89 13
	      HANDLE ptok;
	      if (gsid != user.groups.pgsid
		  && OpenProcessToken (hMainProc, TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
				     &ptok))
	        {
		  /* Set primary group to the group in /etc/passwd. */
		  if (!SetTokenInformation (ptok, TokenPrimaryGroup,
					    &gsid, sizeof gsid))
		    debug_printf ("SetTokenInformation(TokenPrimaryGroup): %E");
		  else
		    user.groups.pgsid = gsid;
		  CloseHandle (ptok);
		}
d95 2
@


1.96
log
@white space
@
text
@d32 1
d72 2
a73 2
  if (!pw && !(pw = getpwnam (user.name ()))
      && !(pw = getpwuid32 (DEFAULT_UID)))
d83 1
a83 1
	  if (gsid.getfromgr (getgrgid32 (pw->pw_gid)))
d218 1
a218 1
	    pw = getpwnam (name ());
d242 1
a242 1
	pw = getpwnam (name ());
@


1.95
log
@	* passwd.cc (read_etc_passwd): Never add an entry when starting
	on Win95/98/ME if a default entry is present.
	* uinfo.cc (internal_getlogin): Look for the default uid if needed.
	Always call user.set_name ().
@
text
@d80 1
a80 1
        {
@


1.94
log
@	* security.h: Declare internal_getpwsid and internal_getgrsid.
	Undeclare internal_getpwent.  Define DEFAULT_UID_NT.  Change
	DEFAULT_GID.
	* passwd.cc (internal_getpwsid): New function.
	(internal_getpwent): Suppress.
	(read_etc_passwd): Make static.  Rewrite the code for the completion
	line.  Set curr_lines to 0.
	(parse_pwd): Change type to static int.  Return 0 for short lines.
	(add_pwd_line): Pay attention to the value of parse_pwd.
	(search_for): Do not look for nor return the DEFAULT_UID.
	* grp.cc (read_etc_group): Make static.  Free gr_mem and set
	curr_lines to 0.  Always call add_pwd_line.  Rewrite the code for the
	completion line.
	(internal_getgrsid): New function.
	(parse_grp): If grp.gr_mem is empty, set it to &null_ptr.
	Never NULL gr_passwd.
	(getgrgid32): Only return the default if ntsec is off and the gid is
	ILLEGAL_GID.
	* sec_helper.cc (cygsid::get_id): Use getpwsid and getgrsid.
	(cygsid_getfrompw): Clean up last line.
	(cygsid_getfromgr): Ditto.
	(is_grp_member): Use getpwuid32 and getgrgid32.
	* uinfo.cc (internal_getlogin): Set DEFAULT_GID at start.
	Use getpwsid. Move the read of /etc/group after the second access
	to /etc/passwd.  Change some debug_printf.
@
text
@d64 1
a64 2
	  if ((pw = internal_getpwsid (tu)))
	    user.set_name (pw->pw_name);
d71 3
a73 2
  if (!pw && !(pw = getpwnam (user.name ())))
    debug_printf("user name not found in augmented /etc/passwd");
d78 1
@


1.93
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d37 1
d39 1
a41 1
      HANDLE ptok = INVALID_HANDLE_VALUE;
d62 5
a66 18
       if (ret)
	 {
	  cygsid gsid (NO_SID);
	  cygsid psid;

	  for (int pidx = 0; (pw = internal_getpwent (pidx)); ++pidx)
	    if (psid.getfrompw (pw) && EqualSid (user.sid (), psid))
	      {
		user.set_name (pw->pw_name);
		struct __group32 *gr = getgrgid32 (pw->pw_gid);
		if (gr)
		  if (!gsid.getfromgr (gr))
		      gsid = NO_SID;
		break;
	      }

	  /* Set token owner to the same value as token user and
	     primary group to the group in /etc/passwd. */
d69 13
a81 1
	  if (gsid)
d83 1
d89 3
a91 3
	 }
      if (ptok != INVALID_HANDLE_VALUE)
	CloseHandle (ptok);
d93 2
a94 15

  if (!pw)
    pw = getpwnam (user.name ());

  if (pw)
    {
      myself->uid = pw->pw_uid;
      myself->gid = pw->pw_gid;
    }
  else
    {
      myself->uid = DEFAULT_UID;
      myself->gid = DEFAULT_GID;
    }

@


1.92
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d49 1
a49 1
	system_printf ("OpenProcessToken(): %E\n");
@


1.91
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d121 1
a121 1
  cygheap->user.set_orig_sid();      /* Update the original sid */
d262 1
a262 1
			    sizeof (wlogsrv) / sizeof(*wlogsrv));
@


1.90
log
@	* security.cc: Change some formatting.
	* include/cygwin/version.h: Bump API minor version.

        * cygheap.h (class cygheap_user): Add member groups.
        * security.h (class cygsidlist): Add members type and maxcount,
        methods position, addfromgr, alloc_sids and free_sids and
        operator+= (const PSID psid). Modify contains () to call
        position () and optimize add () to use maxcount.
        (class user_groups): Create.
        Update declarations of verify_token and create_token.
        * security.cc (cygsidlist::alloc_sids): New.
        (cygsidlist::free_sids): New.
        (get_token_group_sidlist): Create from get_group_sidlist.
        (get_initgroups_sidlist): Create from get_group_sidlist.
        (get_group_sidlist): Suppress.
        (get_setgroups_sidlist): Create.
        (verify_token): Modify arguments. Add setgroups case.
        (create_token): Modify arguments. Call get_initgroups_sidlist and
        get_setgroups_sidlist as needed. Set SE_GROUP_LOGON_ID from auth_pos
        outside of the loop. Rename the various group sid lists consistently.
        * syscalls.cc (seteuid32): Modify to use cygheap->user.groups.
        (setegid32): Call cygheap->user.groups.update_pgrp.
        * grp.cc (setgroups): Create.
        (setgroups32): Create.
        * uinfo.cc (internal_getlogin): Initialize and update user.groups.pgsid.
        * cygwin.din: Add setgroups and setgroups32.
@
text
@d299 1
a299 1
		   	      ? almost_null : cstrdup (newhomedrive));
@


1.89
log
@* debug.cc (threads): Avoid initialization.
* uinfo.cc (cygheap_user::ontherange): (from Corinna Vinschen) Actually make
below changes work.
@
text
@d51 1
a51 1
	system_printf ("GetTokenInformation(): %E");
d54 3
d81 7
a87 3
	  if (gsid && !SetTokenInformation (ptok, TokenPrimaryGroup,
					    &gsid, sizeof gsid))
	    debug_printf ("SetTokenInformation(TokenPrimaryGroup): %E");
a88 1

@


1.88
log
@* uinfo.cc (cygheap_user::ontherange): Make cygwin root the last resort for
HOMEPATH/HOMEDRIVE for consistency with HOME.
@
text
@a259 1
		  char *p;
d268 1
a268 1
			cygwin_conv_to_full_posix_path (homepath_env_buf, "/");
@


1.87
log
@* uinfo.cc (cygheap_user::ontherange): Potentially set HOME from existing
homepath and homedrive cygheap_user fields (not currently used yet).  Set HOME
to / if no other alternative.
(cygheap_user::test_uid): Simplify.
@
text
@d268 2
a269 4
		      else if (!GetSystemDirectory (homepath_env_buf, MAX_PATH))
			strcpy (homepath_env_buf, "c:\\");
		      else if ((p = strchr (homepath_env_buf, '\\')))
			p[1] = '\0';
@


1.86
log
@* uinfo.cc (cygheap_user::test_uid): Use standard issetuid test.
@
text
@d207 3
a209 1
      if ((p = getenv ("HOMEDRIVE")))
d212 3
a214 1
      if ((p = getenv ("HOMEPATH")))
d225 1
a226 1
	      debug_printf ("Set HOME (from /etc/passwd) to %s", pw->pw_dir);
d228 3
a230 1
	  else if (newhomedrive && newhomepath)
d237 1
a238 1
	      debug_printf ("Set HOME (from HOMEDRIVE/HOMEPATH) to %s", home);
d294 1
a294 1
  if (newhomedrive)
d298 1
a298 1
  if (newhomepath)
d315 1
a315 3
  if (what)
    return what;
  if (!issetuid ())
@


1.85
log
@* autoload.cc (NetGetDCName): Change to make this an optional load function.
* cygheap.h (cygheap_user::logsrv): Return NULL when operation fails.
(cygheap_user::winname): Ditto.
(cygheap_user::domain): Ditto.
* uinfo.cc (cygheap_user::env_logsrv): Save results in temp variable.
(cygheap_user::env_userprofile): Ditto.
@
text
@d311 1
a311 1
  if (orig_uid == myself->uid)
@


1.84
log
@* uinfo.cc (cygheap_user::test_uid): Return NULL or further tests are sorta
useless.
(cygheap_user::env_domain): Recalculate if name is missing.
@
text
@d322 3
a324 1
  if (!domain () || strcasematch (winname (), "SYSTEM"))
d329 1
a329 1
  if (get_logon_server (domain (), logsrv, NULL))
d368 2
a369 1
  if (!strcasematch (winname (), "SYSTEM")
@


1.83
log
@* uinfo.cc (cygheap_user::env_logsrv): Return "almost_null" in case where no
domain or username is "SYSTEM".
@
text
@d312 1
a312 1
    what = getwinenveq (name, namelen, HEAP_STR) ?: almost_null;
d335 1
a335 1
  if (test_uid (pdomain, name, namelen))
@


1.82
log
@* cygheap.h (cygheap_user): Reorg to accommodate environment caching.
(cygheap_user::logsrv): New method.
(cygheap_user::winname): Ditto.
(cygheap_user::domain): Ditto.
(cygheap_user::test_uid): Ditto.
* cygheap.cc (cygheap_user::set_name): Reflect name "pwinname" name change.
* environ.cc (getwinenveq): New function.
(spenv::from_cygheap): Change arguments.
(spenv::retrieve): Ditto for call.  Use getwinenveq to retrieve info from
environment.  Always return value from cygwin environment, if it exists.
* environ.h (getwinenveq): Declare.
* uinfo.cc (cygheap_user::ontherange): Use logsrv() rather than env_logsrv().
(cygheap_user::test_uid): Define new method.
(cygheap_user::env_logsrv): Accept environment arguments.  Use test_uid to find
info.
(cygheap_user::env_domain): Ditto.
(cygheap_user::env_userprofile): Ditto.
(cygheap_user::env_homepath): Ditto.
(cygheap_user::env_homedrive): Ditto.
(cygheap_user::env_name): Ditto.
@
text
@d323 1
a323 1
    return NULL;
@


1.81
log
@* cygheap.cc (cfree_and_set): New function.
(cygheap_user::set_name): Use cfree_and_set to reset members.
* cygheap.h (cygheap_user): Delete static members.
(cygheap_user::puserprof): New member.
(cfree_and_set): Declare.
* dcrt0.cc (almost_null): Define.
* winsup.h (almost_null): Declare.
* syscalls.cc (cfree_and_set): Remove unused variable.
* uinfo.cc (cygheap_user::homepath_env_buf): Eliminate.
(cygheap_user::homedrive_env_buf): Ditto.
(cygheap_user::userprofile_env_buf): Ditto.
(cygheap_user::ontherange): YA change to try to preserve existing HOMEPATH and
HOMEDRIVE.  Return almost_null values when variables should not actually exist.
(cygheap_user::env_logsrv): Ditto.
(cygheap_user::env_domain): Ditto.
(cygheap_user::env_userprofile): Ditto.
@
text
@d31 1
d203 1
d237 1
a237 1
  if (homepath == NULL && newhomepath == NULL)
d246 1
a246 1
	  if (env_logsrv ())
d249 1
a249 1
	      sys_mbstowcs (wlogsrv, env_logsrv (),
d251 1
a251 1
	     sys_mbstowcs (wuser, env_name (), sizeof (wuser) / sizeof (*wuser));
d307 1
a307 1
cygheap_user::env_logsrv ()
d309 11
a319 1
  if (plogsrv)
d322 1
a322 1
  if (!env_domain () || strcasematch (env_name (), "SYSTEM"))
d327 1
a327 1
  if (get_logon_server (env_domain (), logsrv, NULL))
d333 1
a333 1
cygheap_user::env_domain ()
d335 1
a335 1
  if (pdomain)
d344 1
a344 1
  cfree_and_set (winname, almost_null);
d351 1
a351 1
      winname = cstrdup (username);
d358 1
a358 1
cygheap_user::env_userprofile ()
d360 3
d366 1
a366 1
  if (!strcasematch (env_name (), "SYSTEM")
d374 1
a374 1
cygheap_user::env_homepath ()
d380 1
a380 1
cygheap_user::env_homedrive ()
d386 1
a386 1
cygheap_user::env_name ()
d388 3
a390 2
  (void) env_domain ();
  return winname;
@


1.80
log
@	* uinfo.cc (internal_getlogin): Set myself->uid and myself->gid instead
	of user.real_uid and user.real_gid.
	(uinfo_init): Evaluate orig_uid and real_uid from myself->uid.  Ditto
	for gid.
@
text
@a189 4
char cygheap_user::homepath_env_buf[MAX_PATH + 1];
char cygheap_user::homedrive_env_buf[3];
char cygheap_user::userprofile_env_buf[MAX_PATH + 1];

d196 5
d206 1
a206 4
	{
	  memcpy (homedrive_env_buf, p, 2);
	  homedrive = homedrive_env_buf;
	}
d209 1
a209 4
	{
	  strcpy (homepath_env_buf, p);
	  homepath = homepath_env_buf;
	}
d222 1
a222 1
	  else if (homedrive && homepath)
d226 2
a227 2
	      strcpy (buf, homedrive);
	      strcat (buf, homepath);
a232 1
      return NULL;
d235 1
a235 1
  if (homedrive == NULL || !homedrive[0])
d243 1
d273 2
a274 2
	  homedrive_env_buf[0] = homedrive_env_buf[1] = '\0';
	  homepath = homepath_env_buf;
d280 3
a282 1
	  homepath = homepath_env_buf + 2;
a283 1
      homedrive = homedrive_env_buf;
d286 7
d314 4
a317 3
  if (!get_logon_server (env_domain (), logsrv, NULL))
    return NULL;
  return plogsrv = cstrdup (logsrv);
d332 2
d336 2
d339 2
a340 2
      __seterrno ();
      return NULL;
d342 1
a342 4
  if (winname)
    cfree (winname);
  winname = cstrdup (username);
  return pdomain = cstrdup (userdomain);
d348 2
d353 1
a353 1
    return userprofile_env_buf;
d355 1
a355 1
  return NULL;
@


1.79
log
@* uinfo.cc (cygheap_user::ontherange): Use env_name for NetUserGetInfo.
(cygheap_user::env_logsrv): Verify env_domain is valid.
* environ.cc: Include child_info.h and keep spenvs[] sorted.
(environ_init): Check child_proc_info instead of myself->ppid_handle.
@
text
@d91 2
a92 2
      user.real_uid = pw->pw_uid;
      user.real_gid = pw->pw_gid;
d96 2
a97 2
      user.real_uid = DEFAULT_UID;
      user.real_gid = DEFAULT_GID;
d112 2
a113 2
  myself->uid = cygheap->user.orig_uid = cygheap->user.real_uid;
  myself->gid = cygheap->user.orig_gid = cygheap->user.real_gid;
@


1.78
log
@Use hMainProc where appropriate, throughout.
* environ.cc (spenv::retrieve): Add debugging statements.
* pinfo.cc (set_myself): Don't call strace.hello if already stracing.
* strace.cc (strace): Move NO_COPY keyword so that it will actually take
effect.
@
text
@d52 1
a52 1
        system_printf ("Couldn't retrieve SID from access token!");
d254 1
a254 1
	      sys_mbstowcs (wuser, name (), sizeof (wuser) / sizeof (*wuser));
d307 1
a307 1
  if (strcasematch (env_name (), "SYSTEM"))
@


1.77
log
@	* uinfo.cc (cygheap_user::ontherange): Call NetUserGetInfo() only with
	non-NULL logserver parameter.
@
text
@d46 1
a46 2
      if (!OpenProcessToken (GetCurrentProcess (),
			     TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
@


1.76
log
@* cygheap.h (cygheap_user::winname): New field.
* cygheap.cc (cygheap_user::set_name): Clear winname when name changes.
* uinfo.cc (cygheap_user::env_logsrv): Avoid calculating server when Windows
user == SYSTEM.
(cygheap_user::env_domain): Set winname here too.
(cygheap_user::env_userprofile): Eliminate superfluous tests.
(cygheap_user::env_name): Seed winname by calling env_domain().
@
text
@d250 1
a250 2
	  sys_mbstowcs (wuser, name (), sizeof (wuser) / sizeof (*wuser));
	  if ((ret = NetUserGetInfo (NULL, wuser, 3, (LPBYTE *)&ui)))
d252 5
a256 1
	      if (env_logsrv ())
d258 13
a270 20
		  WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
		  strcpy (homepath_env_buf, env_logsrv ());
		  sys_mbstowcs (wlogsrv, homepath_env_buf,
				sizeof (wlogsrv) / sizeof(*wlogsrv));
		  ret = NetUserGetInfo (wlogsrv, wuser, 3,(LPBYTE *)&ui);
		}
	    }
	  if (!ret)
	    {
	      char *p;
	      sys_wcstombs (homepath_env_buf, ui->usri3_home_dir, MAX_PATH);
	      if (!homepath_env_buf[0])
		{
		  sys_wcstombs (homepath_env_buf, ui->usri3_home_dir_drive, MAX_PATH);
		  if (homepath_env_buf[0])
		    strcat (homepath_env_buf, "\\");
		  else if (!GetSystemDirectory (homepath_env_buf, MAX_PATH))
		    strcpy (homepath_env_buf, "c:\\");
		  else if ((p = strchr (homepath_env_buf, '\\')))
		    p[1] = '\0';
@


1.75
log
@* uinfo.cc (cygheap_user::ontherange): Don't set HOMEDRIVE or HOMEPATH unless
one or the other is specified.
@
text
@d210 1
d216 1
d312 3
d339 3
d348 4
a351 2
  if (strcasematch (name (), "SYSTEM") || !env_domain () || !env_logsrv ())
    return NULL;
d353 1
a353 4
  if (get_registry_hive_path (sid (), userprofile_env_buf))
    return userprofile_env_buf;
  else
    return NULL;
d371 2
a372 1
  return name ();
@


1.74
log
@* cygheap.h (cygheap_user::userprofile_env_buf): New static member.
* environ.cc (build_env): Add debugging statement.
(spenvs): Switch functions for USERDOMAIN and USERNAME.
* spawn.cc (spawn_guts): Move environment initialization prior to
cygheap_setup_for_child or environment info will never be copied to child.
@
text
@d237 1
@


1.73
log
@* cygheap.h (cygheap_user): Add static members to hold home{drive,path} info.
* uinfo.cc (cygheap_user::ontherange): Use static class members for local HOME*
storage.
@
text
@d193 1
a338 1
  static char buf[512]; /* FIXME: This shouldn't be static. */
d342 2
a343 2
  if (get_registry_hive_path (sid (), buf))
    return buf;
@


1.72
log
@* cygheap.cc (cygheap_user::set_logsrv): Remove.
(cygheap_user::set_domain): Ditto.
* cygheap.h (cygheap_user::set_logsrv): Remove declaration.
(cygheap_user::set_domain): Ditto.
(cygheap_user::env_domain): Declare new method.
(cygheap_user::env_name): Ditto.
* environ.cc (spenvs): Add two environment variables.
* spawn.cc (spawn_guts): Call build_env after RevertToSelf.  Always set
ciresrv.mount_h.
(cygheap_user::ontherange): Recalculate homedrive/homepath if they are empty.
Use env_logsrv to get logon server.
(cygheap_user::env_logsrv): Calculate server name here rather than relying on
it having been previously calculated.
(cygheap_user::env_domain): Ditto for domain name.
(cygheap-user::env_name): New method.
* syscalls.cc (seteuid32): Do not get or set the environment.  Do not call
LookupAccountSid nor internal_getlogin.  Set cygheap->user name and sid from
the passwd entry.
* uinfo.cc (uinfo_init): Only call internal_getlogin when starting from a non
Cygwin process and use the values returned in user.
(internal_getlogin): Simplify to case where starting from a non Cygwin process.
Store return values in user and return void.  Do not set the Windows default
environment.
* dcrt0.cc (dll_crt0_1): Call uinfo_init only when needed.  Do not set
myself->uid nor reset user.sid.
* spawn.cc (spawn_guts): Get the sid from cygheap->user.  Always
RevertToSelf().  Don't set uid in impersonated case.
* cygheap.cc (cygheap_user::set_sid): Do not set orig_sig.
(cygheap_user::set_orig_sid): New.
* cygheap.h: Declare cygheap_user::set_sid.
* winsup.h: Add argument to uinfo_init().
@
text
@d191 3
a196 2
  static char buf[MAX_PATH + 1];
  static char homedrive_buf[3];
d206 2
a207 2
	  memcpy (homedrive_buf, p, 2);
	  homedrive = homedrive_buf;
d211 2
a212 2
	  strcpy (buf, p);
	  homepath = buf;
d228 1
d243 1
a243 1
	cygwin_conv_to_full_win32_path (pw->pw_dir, buf);
d252 3
a254 2
		  strcpy (buf, env_logsrv ());
		  sys_mbstowcs (wlogsrv, buf, sizeof (wlogsrv) / sizeof(*wlogsrv));
d261 2
a262 2
	      sys_wcstombs (buf, ui->usri3_home_dir, MAX_PATH);
	      if (!buf[0])
d264 6
a269 6
		  sys_wcstombs (buf, ui->usri3_home_dir_drive, MAX_PATH);
		  if (buf[0])
		    strcat (buf, "\\");
		  else if (!GetSystemDirectory (buf, MAX_PATH))
		    strcpy (buf, "c:\\");
		  else if ((p = strchr (buf, '\\')))
d277 1
a277 1
      if (buf[1] != ':')
d279 2
a280 2
	  homedrive_buf[0] = homedrive_buf[1] = '\0';
	  homepath = buf;
d284 3
a286 3
	  homedrive_buf[0] = buf[0];
	  homedrive_buf[1] = buf[1];
	  homepath = buf + 2;
d288 1
a288 1
      homedrive = homedrive_buf;
@


1.71
log
@* path.cc (chdir): Minor cleanup.
@
text
@d30 1
d32 1
a32 1
struct passwd *
a34 3
  char buf[512];
  char username[UNLEN + 1];
  DWORD username_len = UNLEN + 1;
a36 6
  if (!GetUserName (username, &username_len))
    user.set_name (NULL);
  else
    user.set_name (username);
  debug_printf ("GetUserName() = %s", user.name ());

d39 1
a39 36
      LPWKSTA_USER_INFO_1 wui;
      NET_API_STATUS ret;
      char *env;

      user.set_logsrv (NULL);
      /* First trying to get logon info from environment */
      if (!*user.name () && (env = getenv ("USERNAME")) != NULL)
	user.set_name (env);
      if ((env = getenv ("USERDOMAIN")) != NULL)
	user.set_domain (env);
      if ((env = getenv ("LOGONSERVER")) != NULL)
	user.set_logsrv (env + 2); /* filter leading double backslashes */
      if (user.name () && user.domain ())
	debug_printf ("User: %s, Domain: %s, Logon Server: %s",
		      user.name (), user.domain (), user.logsrv ());
      else if (!(ret = NetWkstaUserGetInfo (NULL, 1, (LPBYTE *) &wui)))
	{
	  sys_wcstombs (buf, wui->wkui1_username, UNLEN + 1);
	  user.set_name (buf);
	  sys_wcstombs (buf, wui->wkui1_logon_server,
			INTERNET_MAX_HOST_NAME_LENGTH + 1);
	  user.set_logsrv (buf);
	  sys_wcstombs (buf, wui->wkui1_logon_domain,
			INTERNET_MAX_HOST_NAME_LENGTH + 1);
	  user.set_domain (buf);
	  NetApiBufferFree (wui);
	}
      if (!user.logsrv () && user.domain () &&
          get_logon_server (user.domain (), buf, NULL))
	user.set_logsrv (buf + 2);
      debug_printf ("Domain: %s, Logon Server: %s, Windows Username: %s",
		    user.domain (), user.logsrv (), user.name ());


      HANDLE ptok = user.token; /* Which is INVALID_HANDLE_VALUE if no
				   impersonation took place. */
d42 1
a42 1
      ret = 0;
d44 6
a49 9
      /* Try to get the SID either from already impersonated token
	 or from current process first. To differ that two cases is
	 important, because you can't rely on the user information
	 in a process token of a currently impersonated process. */
      if (ptok == INVALID_HANDLE_VALUE
	  && !OpenProcessToken (GetCurrentProcess (),
				TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
				&ptok))
	debug_printf ("OpenProcessToken(): %E\n");
d51 1
a51 1
	debug_printf ("GetTokenInformation(): %E");
d53 8
a60 25
	debug_printf ("Couldn't retrieve SID from access token!");
      /* If that failes, try to get the SID from localhost. This can only
	 be done if a domain is given because there's a chance that a local
	 and a domain user may have the same name. */
      if (!ret && user.domain ())
	{
	  char domain[DNLEN + 1];
	  DWORD dlen = sizeof (domain);
	  siz = sizeof (tu);
	  SID_NAME_USE use = SidTypeInvalid;
	  /* Concat DOMAIN\USERNAME for the next lookup */
	  strcat (strcat (strcpy (buf, user.domain ()), "\\"), user.name ());
          if (!LookupAccountName (NULL, buf, tu, &siz,
	                          domain, &dlen, &use) ||
               !legal_sid_type (use))
	        debug_printf ("Couldn't retrieve SID locally!");
	  else user.set_sid (tu);

	}

      /* If we have a SID, try to get the corresponding Cygwin user name
	 which can be different from the Windows user name. */
      cygsid gsid (NO_SID);
      if (ret)
	{
a72 1
	}
d74 2
a75 6
      /* If this process is started from a non Cygwin process,
	 set token owner to the same value as token user and
	 primary group to the group which is set as primary group
	 in /etc/passwd. */
      if (ptok != INVALID_HANDLE_VALUE && !myself->ppid_handle)
	{
d81 1
a81 1
	}
d83 1
a83 3
      /* Close token only if it's a result from OpenProcessToken(). */
      if (ptok != INVALID_HANDLE_VALUE
	  && user.token == INVALID_HANDLE_VALUE)
a86 2
  debug_printf ("Cygwins Username: %s", user.name ());

d90 12
a101 2
  if (!myself->ppid_handle)
    (void) cygheap->user.ontherange (CH_HOME, pw);
d103 1
a103 1
  return pw;
d109 7
a115 1
  struct passwd *p;
d117 1
a117 29
  /* Initialize to non impersonated values.
     Setting `impersonated' to TRUE seems to be wrong but it
     isn't. Impersonated is thought as "Current User and `token'
     are coincident". See seteuid() for the mechanism behind that. */
  if (cygheap->user.token != INVALID_HANDLE_VALUE && cygheap->user.token != NULL)
    CloseHandle (cygheap->user.token);
  cygheap->user.token = INVALID_HANDLE_VALUE;
  cygheap->user.impersonated = TRUE;

  /* If uid is ILLEGAL_UID, the process is started from a non cygwin
     process or the user context was changed in spawn.cc */
  if (myself->uid == ILLEGAL_UID)
    if ((p = internal_getlogin (cygheap->user)) != NULL)
      {
	myself->uid = p->pw_uid;
	/* Set primary group only if process has been started from a
	   non cygwin process. */
	if (!myself->ppid_handle)
	  myself->gid = p->pw_gid;
      }
    else
      {
	myself->uid = DEFAULT_UID;
	myself->gid = DEFAULT_GID;
      }
  /* Real and effective uid/gid are always identical on process start up.
     This is at least true for NT/W2K. */
  cygheap->user.orig_uid = cygheap->user.real_uid = myself->uid;
  cygheap->user.orig_gid = cygheap->user.real_gid = myself->gid;
d236 1
a236 1
  if (homedrive == NULL)
d247 1
a247 1
	      if (logsrv ())
d250 1
a250 1
		  strcat (strcpy (buf, "\\\\"), logsrv ());
d302 2
a303 1
  char *p = plogsrv - 2;
d305 25
a329 2
  *p = p[1] = '\\';
  return p;
d336 1
a336 1
  if (strcasematch (name (), "SYSTEM") || !domain () || !logsrv ())
d355 6
@


1.70
log
@* cygheap.cc (cygheap_user::set_name): Set homedrive and homepath to NULL on
user name change.
(cygheap_user::set_logsrv): Allocate enough space for leading \\ so that we can
put this in the environment, if needed.
* cygheap.h (homebodies): New enum.
(cygheap_user::homedrive): New field.
(cygheap_user::homepath): Ditto.
(cygheap_user::env_logsrv): New method.
(cygheap_user::env_homepath): New method.
(cygheap_user::env_homedrive): New method.
(cygheap_user::env_userprofile): New method.
(cygheap_user::ontherange): New method.
* environ.cc (envsize): Eliminate debugging argument.
(environ_init): Assume that envc counts number of elments not total size.
(spenv): New class.
(spenvs): New array, renamed from forced_winenv_vars, using spenv.
(spenv::retrieve): New method.
(build_env): Rename from 'winenv' -- one stop shopping for building new
environment blocks for both windows and "unix".
* environ.h (build_env: Declare.
(winenv): Delete declaration.
(envsize): Ditto.
* spawn.cc (spawn_guts): Use build_env to build windows and cygwin environment
blocks.
* uinfo.cc (internal_getlogin): Eliminate environment manipulation.  Default to
info from GetUserName if it exists.  Move HOMEPATH and HOMEDRIVE stuff
elsewhere.  Move HOME setting elsewhere.  Only set HOME environment variable in
processes that are not parented by a cygwin process.
(cygheap_user::ontherange): Define new method.
(cygheap_user::env_logsrv): Ditto.
(cygheap_user::env_homepath): Ditto.
(cygheap_user::env_homedrive): Ditto.
(cygheap_user::env_userprofile): Ditto.
@
text
@d74 2
a75 2
      if (!user.logsrv () && user.domain() &&
          get_logon_server(user.domain(), buf, NULL))
@


1.69
log
@	* sec_helper.cc (lookup_name): Suppress.
	* security.cc (alloc_sd): Remove logsrv argument.
	Remove two calls to lookup_name.
	(set_security_attribute): Remove logsrv argument.
	Remove logsrv argument in call to alloc_sd.
	(set_nt_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_security_attribute.
	(set_file_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_nt_attribute.
	(set_file_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_file_attribute.
	* syscalls.cc (chown_worker): Remove logserver argument in
	call to set_file_attribute.
	(chmod): Ditto.
	* shm.cc (shmget): Remove logsrv argument in call to alloc_sd.
	* uinfo.cc (internal_getlogin): Replace calls to
	lookup_name by call to LookupAccountName.
	* security.h: Remove logsrv in declarations of set_file_attribute
	and alloc_sd. Remove declaration of lookup_name.
@
text
@d40 1
a40 1
    user.set_name ("unknown");
d53 1
a53 1
      if ((env = getenv ("USERNAME")) != NULL)
d76 1
a76 4
	{
	  user.set_logsrv (buf + 2);
	  setenv ("LOGONSERVER", buf, 1);
	}
a79 45
      /* NetUserGetInfo() can be slow in NT domain environment, thus we
       * only obtain HOMEDRIVE and HOMEPATH if they are not already set
       * in the environment. */
      if (!getenv ("HOMEPATH") || !getenv ("HOMEDRIVE"))
	{
	  LPUSER_INFO_3 ui = NULL;
	  WCHAR wuser[UNLEN + 1];

	  sys_mbstowcs (wuser, user.name (), sizeof (wuser) / sizeof (*wuser));
	  if ((ret = NetUserGetInfo (NULL, wuser, 3, (LPBYTE *)&ui)))
	    {
	      if (user.logsrv ())
		{
		  WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
		  strcat (strcpy (buf, "\\\\"), user.logsrv ());

		  sys_mbstowcs (wlogsrv, buf,
				sizeof (wlogsrv) / sizeof(*wlogsrv));
		  ret = NetUserGetInfo (wlogsrv, wuser, 3,(LPBYTE *)&ui);
		}
	    }
	  if (!ret)
	    {
	      sys_wcstombs (buf, ui->usri3_home_dir, MAX_PATH);
	      if (!buf[0])
		{
		  sys_wcstombs (buf, ui->usri3_home_dir_drive, MAX_PATH);
		  if (buf[0])
		    strcat (buf, "\\");
		  else
		    {
		      env = getenv ("SYSTEMDRIVE");
		      if (env && *env)
			strcat (strcpy (buf, env), "\\");
		      else
			GetSystemDirectoryA (buf, MAX_PATH);
		    }
		}
	      setenv ("HOMEPATH", buf + 2, 1);
	      buf[2] = '\0';
	      setenv ("HOMEDRIVE", buf, 1);
	    }
	  if (ui)
	    NetApiBufferFree (ui);
	}
a135 8
	  if (!strcasematch (user.name (), "SYSTEM")
	      && user.domain () && user.logsrv ())
	    {
	      if (get_registry_hive_path (user.sid (), buf))
		setenv ("USERPROFILE", buf, 1);
	      else
		unsetenv ("USERPROFILE");
	    }
d142 1
a142 1
      if (ptok != INVALID_HANDLE_VALUE && myself->ppid == 1)
d160 5
a164 20
    pw = getpwnam(user.name ());
  if (!getenv ("HOME"))
    {
      const char *homedrive, *homepath;
      if (pw && pw->pw_dir && *pw->pw_dir)
	{
	  setenv ("HOME", pw->pw_dir, 1);
	  debug_printf ("Set HOME (from /etc/passwd) to %s", pw->pw_dir);
	}
      else if ((homedrive = getenv ("HOMEDRIVE"))
	       && (homepath = getenv ("HOMEPATH")))
	{
	  char home[MAX_PATH];
	  strcpy (buf, homedrive);
	  strcat (buf, homepath);
	  cygwin_conv_to_full_posix_path (buf, home);
	  setenv ("HOME", home, 1);
	  debug_printf ("Set HOME (from HOMEDRIVE/HOMEPATH) to %s", home);
	}
    }
d268 53
a320 1
  if (src)
d322 48
a369 2
      strcpy (src, getlogin ());
      return src;
d371 2
a372 1
  else
d374 6
a379 1
      return getlogin ();
d381 34
@


1.68
log
@	* security.cc (lsa2wchar): Suppressed.
	(get_lsa_srv_inf): Suppressed.
	(get_logon_server_and_user_domain): Suppressed.
	(get_logon_server): Essentially new.
	(get_user_groups): Add "domain" argument. Only lookup the
	designated server and use "domain" in LookupAccountName.
	(is_group_member): Simplify the arguments.
	(get_user_local_groups): Simplify the arguments. Do only a
	local lookup. Use "BUILTIN" and local domain in LookupAccountName.
	(get_user_primary_group). Only lookup the designated server.
	(get_group_sidlist): Remove logonserver argument. Do not lookup
	any server for the SYSTEM account.
	(create_token): Delete logonserver and call to get_logon_server.
	Adjust arguments of get_group_sidlist, see above.
	* security.h: Delete declaration of get_logon_server_and_user_domain
	and add declaration of get_logon_server.
	* uinfo.cc (internal_get_login): Call get_logon_server instead of
	get_logon_server_and_user_domain.
@
text
@d153 4
d159 6
a164 2
	  if (!(ret = lookup_name (buf, NULL, user.sid ())))
	    debug_printf ("Couldn't retrieve SID locally!");
a165 6

      /* If that fails, too, as a last resort try to get the SID from
	 the logon server. */
      if (!ret && !(ret = lookup_name (user.name (), user.logsrv (),
				       user.sid ())))
	debug_printf ("Couldn't retrieve SID from '%s'!", user.logsrv ());
@


1.67
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d74 2
a75 1
      if (!user.logsrv () && get_logon_server_and_user_domain (buf, NULL))
@


1.66
log
@	Change internal uid datatype from __uid16_t to __uid32_t
	throughout.
	* cygwin.din: Export new symbols getpwuid32, getpwuid_r32, getuid32,
	geteuid32, setuid32, seteuid32.
	* passwd.cc (getpwuid32): New function.
	(getpwuid_r32): Ditto.
	* syscalls.cc (seteuid32): Ditto.
	(setuid32): Ditto.
	* uinfo.cc (getuid32): Ditto.
	(geteuid32): Ditto.
	* winsup.h (uid16touid32): New macro, correclt casting from __uid16_t
	to __uid32_t.
	(gid16togid32): Ditto fir gids.
	(getuid32): Declare.
	(geteuid32): Ditto.
	(getpwuid32): Ditto.
	* include/sys/cygwin.h (struct external_pinfo): Add members uid32 and
	gid32.
@
text
@a21 1
#include "sigproc.h"
@


1.65
log
@	Change internal gid datatype from __gid16_t to __gid32_t
	throughout.
	* cygwin.din: Export new symbols chown32, fchown32, getegid32,
	getgid32, getgrgid32, getgrnam32, getgroups32, initgroups32, lchown32,
	setgid32, setegid32, getgrent32.
	* grp.cc (grp32togrp16): New static function.
	(getgrgid32): New function.
	(getgrnam32): Ditto.
	(getgrent32): Ditto.
	(getgroups32): Change name of internal function from getgroups.
	(getgroups32): New function.
	(initgroups32): Ditto.
	* syscalls.cc (chown32): Ditto.
	(lchown32): Ditto.
	(fchown32): Ditto.
	(setegid32): Ditto.
	(setgid32): Ditto.
	* uinfo.cc (getgid32): Ditto.
	(getegid32): Ditto.
	* include/cygwin/grp.h: Remove declaration of getgrgid() and getgrnam().
	Declare getgrgid32() and getgrnam32() instead.  Declare getgid32().
@
text
@d285 6
d307 6
@


1.64
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d176 1
a176 1
		struct __group16 *gr = getgrgid (pw->pw_gid);
d291 6
d307 6
@


1.63
log
@* times.cc (hires::prime): Restore thread priority on failure condition.
* uinfo.cc (uinfo_init): Use more robust method for determining if process was
invoked from a non-cygwin process.
* sync.h (muto::init): Eliminate "inheritance" parameter.
(new_muto): Reflect removal of parameter.
* sync.cc (muto::init): Ditto.
* cygheap.cc (cygheap_init): Ditto.
* debug.cc (threadname_init): Ditto.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* grp.cc (group_lock): Use different method for locking with static member.
(read_etc_group): REALLY ensure that read lock mutex is released.
* passwd.cc (passwd_lock): Use different method for locking with static member.
(read_etc_passwd): REALLY ensure that read lock mutex is released.
* shared.cc (sec_user): Correct reversed inheritance test.
@
text
@a21 1
#include "sync.h"
@


1.62
log
@* exceptions.cc (unused_sig_wrapper): Eliminate unused parameter to asm.
* external.cc (cygwin_internal): Change CW_STRACE_ON to CW_STRACE_TOGGLE.
* strace.cc (strace::hello): Toggle strace on and off.
* sync.cc (muto::init): Renamed from constructor.
* sync.h (muto::new): Delete.
(muto::delete): Ditto.
(new_muto): Simplify.  Use muto.init for nearly everything.
* uinfo.cc (uinfo_init): Avoid closing a NULL handle.
* include/sys/cygwin.h (cygwin_getinfo_types): Rename CW_STRACE_OFF to
CW_STRACE_TOGGLE.  Delete CW_STRACE_OFF.
* include/sys/strace.h (strace): Add "inited" field.
@
text
@d260 1
a260 1
	if (myself->ppid == 1)
d280 1
a280 1
  static NO_COPY char this_username[UNLEN + 1];
@


1.61
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d247 1
a247 1
  if (cygheap->user.token != INVALID_HANDLE_VALUE)
@


1.60
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.59
log
@	* uinfo.cc (internal_getlogin): Try evaluating user by SID even if
	ntsec is off.
	(uinfo_init): Set primary group even if ntsec is off.
@
text
@d177 1
a177 1
		struct group *gr = getgrgid (pw->pw_gid);
d252 1
a252 1
  /* If uid is USHRT_MAX, the process is started from a non cygwin
d254 1
a254 1
  if (myself->uid == USHRT_MAX)
d286 1
a286 1
extern "C" uid_t
d292 1
a292 1
extern "C" gid_t
d298 1
a298 1
extern "C" uid_t
d304 1
a304 1
extern "C" gid_t
@


1.58
log
@Eliminate excess whitespace.
@
text
@d130 23
a152 1
      if (allow_ntsec)
d154 5
a158 29
	  HANDLE ptok = user.token; /* Which is INVALID_HANDLE_VALUE if no
				       impersonation took place. */
	  DWORD siz;
	  cygsid tu;
	  int ret = 0;

	  /* Try to get the SID either from already impersonated token
	     or from current process first. To differ that two cases is
	     important, because you can't rely on the user information
	     in a process token of a currently impersonated process. */
	  if (ptok == INVALID_HANDLE_VALUE
	      && !OpenProcessToken (GetCurrentProcess (),
				    TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
				    &ptok))
	    debug_printf ("OpenProcessToken(): %E\n");
	  else if (!GetTokenInformation (ptok, TokenUser, &tu, sizeof tu, &siz))
	    debug_printf ("GetTokenInformation(): %E");
	  else if (!(ret = user.set_sid (tu)))
	    debug_printf ("Couldn't retrieve SID from access token!");
	  /* If that failes, try to get the SID from localhost. This can only
	     be done if a domain is given because there's a chance that a local
	     and a domain user may have the same name. */
	  if (!ret && user.domain ())
	    {
	      /* Concat DOMAIN\USERNAME for the next lookup */
	      strcat (strcat (strcpy (buf, user.domain ()), "\\"), user.name ());
	      if (!(ret = lookup_name (buf, NULL, user.sid ())))
		debug_printf ("Couldn't retrieve SID locally!");
	    }
d160 12
a171 32
	  /* If that fails, too, as a last resort try to get the SID from
	     the logon server. */
	  if (!ret && !(ret = lookup_name (user.name (), user.logsrv (),
					   user.sid ())))
	    debug_printf ("Couldn't retrieve SID from '%s'!", user.logsrv ());

	  /* If we have a SID, try to get the corresponding Cygwin user name
	     which can be different from the Windows user name. */
	  cygsid gsid (NO_SID);
	  if (ret)
	    {
	      cygsid psid;

	      for (int pidx = 0; (pw = internal_getpwent (pidx)); ++pidx)
		if (psid.getfrompw (pw) && EqualSid (user.sid (), psid))
		  {
		    user.set_name (pw->pw_name);
		    struct group *gr = getgrgid (pw->pw_gid);
		    if (gr)
		      if (!gsid.getfromgr (gr))
			  gsid = NO_SID;
		    break;
		  }
	      if (!strcasematch (user.name (), "SYSTEM")
		  && user.domain () && user.logsrv ())
		{
		  if (get_registry_hive_path (user.sid (), buf))
		    setenv ("USERPROFILE", buf, 1);
		  else
		    unsetenv ("USERPROFILE");
		}
	    }
d173 12
a184 5
	  /* If this process is started from a non Cygwin process,
	     set token owner to the same value as token user and
	     primary group to the group which is set as primary group
	     in /etc/passwd. */
	  if (ptok != INVALID_HANDLE_VALUE && myself->ppid == 1)
d186 4
a189 5
	      if (!SetTokenInformation (ptok, TokenOwner, &tu, sizeof tu))
		debug_printf ("SetTokenInformation(TokenOwner): %E");
	      if (gsid && !SetTokenInformation (ptok, TokenPrimaryGroup,
						&gsid, sizeof gsid))
		debug_printf ("SetTokenInformation(TokenPrimaryGroup): %E");
d191 1
d193 11
a203 4
	  /* Close token only if it's a result from OpenProcessToken(). */
	  if (ptok != INVALID_HANDLE_VALUE
	      && user.token == INVALID_HANDLE_VALUE)
	    CloseHandle (ptok);
d205 5
d211 1
d213 1
d258 3
a260 3
	/* Set primary group only if ntsec is off or the process has been
	   started from a non cygwin process. */
	if (!allow_ntsec || myself->ppid == 1)
@


1.57
log
@	* uinfo.cc (internal_getlogin): Set environment variable $HOME
	from either /etc/passwd or $HOMEDRIVE/$HOMEPATH if necessary.
@
text
@d88 1
a88 1
        {
d101 1
a101 1
		  		sizeof (wlogsrv) / sizeof(*wlogsrv));
d221 1
a221 1
        {
@


1.56
log
@	Patch suggested by Ian Ray <ian.ray@@nokia.com>:
	* syscalls.cc (seteuid): Unset environment variables HOMEDRIVE and
	HOMEPATH before calling internal_getlogin().
	* uinfo.cc (internal_getlogin): Use default HOMEPATH and HOMEDRIVE
	from environment if both are present, else query NetUserGetInfo().
@
text
@d36 1
a50 1
      char buf[512];
d215 22
a236 1
  return pw ?: getpwnam(user.name ());
@


1.55
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d81 18
a98 2
      LPUSER_INFO_3 ui = NULL;
      WCHAR wuser[UNLEN + 1];
d100 6
a105 16
      /* HOMEDRIVE and HOMEPATH are wrong most of the time, too,
	 after changing user context! */
      sys_mbstowcs (wuser, user.name (), UNLEN + 1);
      if (NetUserGetInfo (NULL, wuser, 3, (LPBYTE *) &ui) && user.logsrv ())
	{
	  WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
	  strcat (strcpy (buf, "\\\\"), user.logsrv ());
	  sys_mbstowcs (wlogsrv, buf, INTERNET_MAX_HOST_NAME_LENGTH + 3);
	  ui = NULL;
	  if (NetUserGetInfo (wlogsrv, wuser, 3, (LPBYTE *) &ui))
	    ui = NULL;
	}
      if (ui)
	{
	  sys_wcstombs (buf, ui->usri3_home_dir, MAX_PATH);
	  if (!buf[0])
d107 2
a108 4
	      sys_wcstombs (buf, ui->usri3_home_dir_drive, MAX_PATH);
	      if (buf[0])
		strcat (buf, "\\");
	      else
d110 3
a112 3
		  env = getenv ("SYSTEMDRIVE");
		  if (env && *env)
		    strcat (strcpy (buf, env), "\\");
d114 7
a120 1
		    GetSystemDirectoryA (buf, MAX_PATH);
d122 3
d126 2
a127 4
	  setenv ("HOMEPATH", buf + 2, 1);
	  buf[2] = '\0';
	  setenv ("HOMEDRIVE", buf, 1);
	  NetApiBufferFree (ui);
a128 2
      debug_printf ("Domain: %s, Logon Server: %s, Windows Username: %s",
		    user.domain (), user.logsrv (), user.name ());
@


1.54
log
@* autoload.cc (wsock_init): Reorganize slightly to accomodate a new compiler.
@
text
@d20 1
d29 1
@


1.53
log
@* uinfo.cc (internal_getlogin): Reorganize slightly to minimize work in default
condition.
@
text
@d62 1
a62 1
      else if (!(ret = NetWkstaUserGetInfo (NULL, 1, (LPBYTE *)&wui)))
a80 1
      WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
d87 1
d91 1
a91 1
	  if (NetUserGetInfo (wlogsrv, wuser, 3,(LPBYTE *) &ui))
@


1.52
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d86 1
a86 2
      wlogsrv[0] = '\0';
      if (user.logsrv ())
d90 3
d94 1
a94 2
      if (!NetUserGetInfo (NULL, wuser, 3, (LPBYTE *)&ui)
	  || (wlogsrv[0] && !NetUserGetInfo (wlogsrv, wuser, 3,(LPBYTE *)&ui)))
@


1.51
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d26 1
@


1.51.2.1
log
@Merged changes from HEAD
@
text
@a25 1
#include "path.h"
@


1.51.2.2
log
@Merged changes from HEAD
@
text
@a19 1
#include <errno.h>
a27 1
#include "cygerrno.h"
a33 1
  char buf[512];
d48 1
d62 1
a62 1
      else if (!(ret = NetWkstaUserGetInfo (NULL, 1, (LPBYTE *) &wui)))
d79 15
a93 7
      debug_printf ("Domain: %s, Logon Server: %s, Windows Username: %s",
		    user.domain (), user.logsrv (), user.name ());

      /* NetUserGetInfo() can be slow in NT domain environment, thus we
       * only obtain HOMEDRIVE and HOMEPATH if they are not already set
       * in the environment. */
      if (!getenv ("HOMEPATH") || !getenv ("HOMEDRIVE"))
d95 2
a96 5
	  LPUSER_INFO_3 ui = NULL;
	  WCHAR wuser[UNLEN + 1];

	  sys_mbstowcs (wuser, user.name (), sizeof (wuser) / sizeof (*wuser));
	  if ((ret = NetUserGetInfo (NULL, wuser, 3, (LPBYTE *)&ui)))
d98 4
a101 1
	      if (user.logsrv ())
d103 3
a105 16
		  WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
		  strcat (strcpy (buf, "\\\\"), user.logsrv ());

		  sys_mbstowcs (wlogsrv, buf,
				sizeof (wlogsrv) / sizeof(*wlogsrv));
		  ret = NetUserGetInfo (wlogsrv, wuser, 3,(LPBYTE *)&ui);
		}
	    }
	  if (!ret)
	    {
	      sys_wcstombs (buf, ui->usri3_home_dir, MAX_PATH);
	      if (!buf[0])
		{
		  sys_wcstombs (buf, ui->usri3_home_dir_drive, MAX_PATH);
		  if (buf[0])
		    strcat (buf, "\\");
d107 1
a107 7
		    {
		      env = getenv ("SYSTEMDRIVE");
		      if (env && *env)
			strcat (strcpy (buf, env), "\\");
		      else
			GetSystemDirectoryA (buf, MAX_PATH);
		    }
a108 3
	      setenv ("HOMEPATH", buf + 2, 1);
	      buf[2] = '\0';
	      setenv ("HOMEDRIVE", buf, 1);
d110 4
a113 2
	  if (ui)
	    NetApiBufferFree (ui);
d115 2
d203 1
a203 22
  if (!pw)
    pw = getpwnam(user.name ());
  if (!getenv ("HOME"))
    {
      const char *homedrive, *homepath;
      if (pw && pw->pw_dir && *pw->pw_dir)
	{
	  setenv ("HOME", pw->pw_dir, 1);
	  debug_printf ("Set HOME (from /etc/passwd) to %s", pw->pw_dir);
	}
      else if ((homedrive = getenv ("HOMEDRIVE"))
	       && (homepath = getenv ("HOMEPATH")))
	{
	  char home[MAX_PATH];
	  strcpy (buf, homedrive);
	  strcat (buf, homepath);
	  cygwin_conv_to_full_posix_path (buf, home);
	  setenv ("HOME", home, 1);
	  debug_printf ("Set HOME (from HOMEDRIVE/HOMEPATH) to %s", home);
	}
    }
  return pw;
@


1.51.2.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d130 1
a130 23
      HANDLE ptok = user.token; /* Which is INVALID_HANDLE_VALUE if no
				   impersonation took place. */
      DWORD siz;
      cygsid tu;
      ret = 0;

      /* Try to get the SID either from already impersonated token
	 or from current process first. To differ that two cases is
	 important, because you can't rely on the user information
	 in a process token of a currently impersonated process. */
      if (ptok == INVALID_HANDLE_VALUE
	  && !OpenProcessToken (GetCurrentProcess (),
				TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
				&ptok))
	debug_printf ("OpenProcessToken(): %E\n");
      else if (!GetTokenInformation (ptok, TokenUser, &tu, sizeof tu, &siz))
	debug_printf ("GetTokenInformation(): %E");
      else if (!(ret = user.set_sid (tu)))
	debug_printf ("Couldn't retrieve SID from access token!");
      /* If that failes, try to get the SID from localhost. This can only
	 be done if a domain is given because there's a chance that a local
	 and a domain user may have the same name. */
      if (!ret && user.domain ())
d132 42
a173 5
	  /* Concat DOMAIN\USERNAME for the next lookup */
	  strcat (strcat (strcpy (buf, user.domain ()), "\\"), user.name ());
	  if (!(ret = lookup_name (buf, NULL, user.sid ())))
	    debug_printf ("Couldn't retrieve SID locally!");
	}
d175 19
a193 12
      /* If that fails, too, as a last resort try to get the SID from
	 the logon server. */
      if (!ret && !(ret = lookup_name (user.name (), user.logsrv (),
				       user.sid ())))
	debug_printf ("Couldn't retrieve SID from '%s'!", user.logsrv ());

      /* If we have a SID, try to get the corresponding Cygwin user name
	 which can be different from the Windows user name. */
      cygsid gsid (NO_SID);
      if (ret)
	{
	  cygsid psid;
d195 5
a199 12
	  for (int pidx = 0; (pw = internal_getpwent (pidx)); ++pidx)
	    if (psid.getfrompw (pw) && EqualSid (user.sid (), psid))
	      {
		user.set_name (pw->pw_name);
		struct __group16 *gr = getgrgid (pw->pw_gid);
		if (gr)
		  if (!gsid.getfromgr (gr))
		      gsid = NO_SID;
		break;
	      }
	  if (!strcasematch (user.name (), "SYSTEM")
	      && user.domain () && user.logsrv ())
d201 5
a205 4
	      if (get_registry_hive_path (user.sid (), buf))
		setenv ("USERPROFILE", buf, 1);
	      else
		unsetenv ("USERPROFILE");
a206 1
	}
d208 4
a211 11
      /* If this process is started from a non Cygwin process,
	 set token owner to the same value as token user and
	 primary group to the group which is set as primary group
	 in /etc/passwd. */
      if (ptok != INVALID_HANDLE_VALUE && myself->ppid == 1)
	{
	  if (!SetTokenInformation (ptok, TokenOwner, &tu, sizeof tu))
	    debug_printf ("SetTokenInformation(TokenOwner): %E");
	  if (gsid && !SetTokenInformation (ptok, TokenPrimaryGroup,
					    &gsid, sizeof gsid))
	    debug_printf ("SetTokenInformation(TokenPrimaryGroup): %E");
a212 5

      /* Close token only if it's a result from OpenProcessToken(). */
      if (ptok != INVALID_HANDLE_VALUE
	  && user.token == INVALID_HANDLE_VALUE)
	CloseHandle (ptok);
a213 1

a214 1

d248 1
a248 1
  if (cygheap->user.token != INVALID_HANDLE_VALUE && cygheap->user.token != NULL)
d253 1
a253 1
  /* If uid is ILLEGAL_UID, the process is started from a non cygwin
d255 1
a255 1
  if (myself->uid == ILLEGAL_UID)
d259 3
a261 3
	/* Set primary group only if process has been started from a
	   non cygwin process. */
	if (!myself->ppid_handle)
d281 1
a281 1
  static char this_username[UNLEN + 1] NO_COPY;
d287 1
a287 1
extern "C" __uid16_t
d293 1
a293 1
extern "C" __gid16_t
d299 1
a299 1
extern "C" __uid16_t
d305 1
a305 1
extern "C" __gid16_t
@


1.51.2.4
log
@Merged changes from HEAD
@
text
@d22 2
d42 1
a42 1
    user.set_name (NULL);
d55 1
a55 1
      if (!*user.name () && (env = getenv ("USERNAME")) != NULL)
d76 5
a80 3
      if (!user.logsrv () && user.domain () &&
          get_logon_server (user.domain (), buf, NULL))
	user.set_logsrv (buf + 2);
d84 45
a153 4
	  char domain[DNLEN + 1];
	  DWORD dlen = sizeof (domain);
	  siz = sizeof (tu);
	  SID_NAME_USE use = SidTypeInvalid;
d156 3
a158 5
          if (!LookupAccountName (NULL, buf, tu, &siz,
	                          domain, &dlen, &use) ||
               !legal_sid_type (use))
	        debug_printf ("Couldn't retrieve SID locally!");
	  else user.set_sid (tu);
d160 5
a164 1
	}
d177 1
a177 1
		struct __group32 *gr = getgrgid32 (pw->pw_gid);
d183 8
d197 1
a197 1
      if (ptok != INVALID_HANDLE_VALUE && !myself->ppid_handle)
d215 20
a234 5
    pw = getpwnam (user.name ());

  if (!myself->ppid_handle)
    (void) cygheap->user.ontherange (CH_HOME, pw);

a285 6
extern "C" __uid32_t
getuid32 (void)
{
  return cygheap->user.real_uid;
}

a291 6
extern "C" __gid32_t
getgid32 (void)
{
  return cygheap->user.real_gid;
}

a297 6
extern "C" __uid32_t
geteuid32 (void)
{
  return myself->uid;
}

a303 6
extern "C" __gid32_t
getegid32 (void)
{
  return myself->gid;
}

d314 1
a314 17
  if (!src)
    return getlogin ();

  strcpy (src, getlogin ());
  return src;
}

const char *
cygheap_user::ontherange (homebodies what, struct passwd *pw)
{
  static char buf[MAX_PATH + 1];
  static char homedrive_buf[3];
  LPUSER_INFO_3 ui = NULL;
  WCHAR wuser[UNLEN + 1];
  NET_API_STATUS ret;

  if (what == CH_HOME)
d316 2
a317 32
      char *p;
      if ((p = getenv ("HOMEDRIVE")))
	{
	  memcpy (homedrive_buf, p, 2);
	  homedrive = homedrive_buf;
	}
      if ((p = getenv ("HOMEPATH")))
	{
	  strcpy (buf, p);
	  homepath = buf;
	}
      if ((p = getenv ("HOME")))
	debug_printf ("HOME is already in the environment %s", p);
      else
	{
	  if (!pw)
	    pw = getpwnam (name ());
	  if (pw && pw->pw_dir && *pw->pw_dir)
	    {
	      setenv ("HOME", pw->pw_dir, 1);
	      debug_printf ("Set HOME (from /etc/passwd) to %s", pw->pw_dir);
	    }
	  else if (homedrive && homepath)
	    {
	      char home[MAX_PATH];
	      strcpy (buf, homedrive);
	      strcat (buf, homepath);
	      cygwin_conv_to_full_posix_path (buf, home);
	      setenv ("HOME", home, 1);
	      debug_printf ("Set HOME (from HOMEDRIVE/HOMEPATH) to %s", home);
	    }
	}
d319 1
a319 54

  if (homedrive == NULL)
    {
      if (!pw)
	pw = getpwnam (name ());
      if (pw && pw->pw_dir && *pw->pw_dir)
	cygwin_conv_to_full_win32_path (pw->pw_dir, buf);
      else
	{
	  sys_mbstowcs (wuser, name (), sizeof (wuser) / sizeof (*wuser));
	  if ((ret = NetUserGetInfo (NULL, wuser, 3, (LPBYTE *)&ui)))
	    {
	      if (logsrv ())
		{
		  WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
		  strcat (strcpy (buf, "\\\\"), logsrv ());
		  sys_mbstowcs (wlogsrv, buf, sizeof (wlogsrv) / sizeof(*wlogsrv));
		  ret = NetUserGetInfo (wlogsrv, wuser, 3,(LPBYTE *)&ui);
		}
	    }
	  if (!ret)
	    {
	      char *p;
	      sys_wcstombs (buf, ui->usri3_home_dir, MAX_PATH);
	      if (!buf[0])
		{
		  sys_wcstombs (buf, ui->usri3_home_dir_drive, MAX_PATH);
		  if (buf[0])
		    strcat (buf, "\\");
		  else if (!GetSystemDirectory (buf, MAX_PATH))
		    strcpy (buf, "c:\\");
		  else if ((p = strchr (buf, '\\')))
		    p[1] = '\0';
		}
	    }
	  if (ui)
	    NetApiBufferFree (ui);
	}

      if (buf[1] != ':')
	{
	  homedrive_buf[0] = homedrive_buf[1] = '\0';
	  homepath = buf;
	}
      else
	{
	  homedrive_buf[0] = buf[0];
	  homedrive_buf[1] = buf[1];
	  homepath = buf + 2;
	}
      homedrive = homedrive_buf;
    }

  switch (what)
d321 1
a321 6
    case CH_HOMEDRIVE:
      return homedrive;
    case CH_HOMEPATH:
      return homepath;
    default:
      return homepath;
a322 34
}

const char *
cygheap_user::env_logsrv ()
{
  char *p = plogsrv - 2;

  *p = p[1] = '\\';
  return p;
}

const char *
cygheap_user::env_userprofile ()
{
  static char buf[512]; /* FIXME: This shouldn't be static. */
  if (strcasematch (name (), "SYSTEM") || !domain () || !logsrv ())
    return NULL;

  if (get_registry_hive_path (sid (), buf))
    return buf;
  else
    return NULL;
}

const char *
cygheap_user::env_homepath ()
{
  return ontherange (CH_HOMEPATH);
}

const char *
cygheap_user::env_homedrive ()
{
  return ontherange (CH_HOMEDRIVE);
@


1.51.2.5
log
@Merged changes from HEAD
@
text
@a29 1
#include "child_info.h"
d31 1
a31 1
void
d34 3
d39 6
d47 36
a82 1
      HANDLE ptok = INVALID_HANDLE_VALUE;
d85 1
a85 1
      DWORD ret = 0;
d87 9
a95 6
      /* Try to get the SID either from current process and
	 store it in user.psid */
      if (!OpenProcessToken (GetCurrentProcess (),
			     TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
			     &ptok))
	system_printf ("OpenProcessToken(): %E\n");
d97 1
a97 1
	system_printf ("GetTokenInformation(): %E");
d99 25
a123 8
        system_printf ("Couldn't retrieve SID from access token!");
       /* We must set the user name, uid and gid.
	 If we have a SID, try to get the corresponding Cygwin
	 password entry. Set user name which can be different
	 from the Windows user name */
       if (ret)
	 {
	  cygsid gsid (NO_SID);
d136 1
d138 6
a143 2
	  /* Set token owner to the same value as token user and
	     primary group to the group in /etc/passwd. */
d149 1
a149 1
	 }
d151 3
a153 1
      if (ptok != INVALID_HANDLE_VALUE)
d157 2
d162 2
a163 12
  if (pw)
    {
      user.real_uid = pw->pw_uid;
      user.real_gid = pw->pw_gid;
    }
  else
    {
      user.real_uid = DEFAULT_UID;
      user.real_gid = DEFAULT_GID;
    }

  (void) cygheap->user.ontherange (CH_HOME, pw);
d165 1
a165 1
  return;
d171 1
a171 2
  if (!child_proc_info)
    internal_getlogin (cygheap->user); /* Set the cygheap->user. */
d173 29
a201 6
  /* Real and effective uid/gid are identical on process start up. */
  myself->uid = cygheap->user.orig_uid = cygheap->user.real_uid;
  myself->gid = cygheap->user.orig_gid = cygheap->user.real_gid;
  cygheap->user.set_orig_sid();      /* Update the original sid */

  cygheap->user.token = INVALID_HANDLE_VALUE; /* No token present */
a274 4
char cygheap_user::homepath_env_buf[MAX_PATH + 1];
char cygheap_user::homedrive_env_buf[3];
char cygheap_user::userprofile_env_buf[MAX_PATH + 1];

d278 2
d289 2
a290 2
	  memcpy (homedrive_env_buf, p, 2);
	  homedrive = homedrive_env_buf;
d294 2
a295 2
	  strcpy (homepath_env_buf, p);
	  homepath = homepath_env_buf;
a310 1
	      char buf[MAX_PATH + 1];
a317 1
      return NULL;
d320 1
a320 1
  if (homedrive == NULL || !homedrive[0])
d325 1
a325 1
	cygwin_conv_to_full_win32_path (pw->pw_dir, homepath_env_buf);
d331 1
a331 1
	      if (env_logsrv ())
d334 2
a335 3
		  strcpy (homepath_env_buf, env_logsrv ());
		  sys_mbstowcs (wlogsrv, homepath_env_buf,
				sizeof (wlogsrv) / sizeof(*wlogsrv));
d342 2
a343 2
	      sys_wcstombs (homepath_env_buf, ui->usri3_home_dir, MAX_PATH);
	      if (!homepath_env_buf[0])
d345 6
a350 6
		  sys_wcstombs (homepath_env_buf, ui->usri3_home_dir_drive, MAX_PATH);
		  if (homepath_env_buf[0])
		    strcat (homepath_env_buf, "\\");
		  else if (!GetSystemDirectory (homepath_env_buf, MAX_PATH))
		    strcpy (homepath_env_buf, "c:\\");
		  else if ((p = strchr (homepath_env_buf, '\\')))
d358 1
a358 1
      if (homepath_env_buf[1] != ':')
d360 2
a361 2
	  homedrive_env_buf[0] = homedrive_env_buf[1] = '\0';
	  homepath = homepath_env_buf;
d365 3
a367 3
	  homedrive_env_buf[0] = homepath_env_buf[0];
	  homedrive_env_buf[1] = homepath_env_buf[1];
	  homepath = homepath_env_buf + 2;
d369 1
a369 1
      homedrive = homedrive_env_buf;
d386 1
a386 2
  if (plogsrv)
    return plogsrv;
d388 2
a389 25
  char logsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
  if (!get_logon_server (env_domain (), logsrv, NULL))
    return NULL;
  return plogsrv = cstrdup (logsrv);
}

const char *
cygheap_user::env_domain ()
{
  if (pdomain)
    return pdomain;

  char username[UNLEN + 1];
  DWORD ulen = sizeof (username);
  char userdomain[DNLEN + 1];
  DWORD dlen = sizeof (userdomain);
  SID_NAME_USE use;

  if (!LookupAccountSid (NULL, sid (), username, &ulen,
			 userdomain, &dlen, &use))
    {
      __seterrno ();
      return NULL;
    }
  return pdomain = cstrdup (userdomain);
d395 2
a396 1
  if (strcasematch (name (), "SYSTEM") || !env_domain () || !env_logsrv ())
d399 2
a400 2
  if (get_registry_hive_path (sid (), userprofile_env_buf))
    return userprofile_env_buf;
a414 6
}

const char *
cygheap_user::env_name ()
{
  return name ();
@


1.51.2.6
log
@Merged changes from HEAD
@
text
@a209 1

a214 1

a309 3
  if (strcasematch (env_name (), "SYSTEM"))
    return NULL;

a333 3
  if (winname)
    cfree (winname);
  winname = cstrdup (username);
d340 4
a343 3
  /* FIXME: Should this just be setting a puserprofile like everything else? */
  if (!strcasematch (env_name (), "SYSTEM")
      && get_registry_hive_path (sid (), userprofile_env_buf))
d345 2
a346 2

  return NULL;
d364 1
a364 2
  (void) env_domain ();
  return winname;
@


1.51.2.7
log
@Merged changes from HEAD
@
text
@d46 2
a47 1
      if (!OpenProcessToken (hMainProc, TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
d250 2
a251 1
	  if (env_logsrv ())
d253 1
a253 5
	      WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 3];
	      sys_mbstowcs (wlogsrv, env_logsrv (),
			    sizeof (wlogsrv) / sizeof(*wlogsrv));
	      sys_mbstowcs (wuser, name (), sizeof (wuser) / sizeof (*wuser));
	      if (!(ret = NetUserGetInfo (wlogsrv, wuser, 3,(LPBYTE *)&ui)))
d255 20
a274 13
		  char *p;
		  sys_wcstombs (homepath_env_buf, ui->usri3_home_dir, MAX_PATH);
		  if (!homepath_env_buf[0])
		    {
		      sys_wcstombs (homepath_env_buf, ui->usri3_home_dir_drive,
				    MAX_PATH);
		      if (homepath_env_buf[0])
			strcat (homepath_env_buf, "\\");
		      else if (!GetSystemDirectory (homepath_env_buf, MAX_PATH))
			strcpy (homepath_env_buf, "c:\\");
		      else if ((p = strchr (homepath_env_buf, '\\')))
			p[1] = '\0';
		    }
@


1.51.2.8
log
@Merged changes from HEAD
@
text
@d52 1
a52 1
	system_printf ("Couldn't retrieve SID from access token!");
d254 1
a254 1
	     sys_mbstowcs (wuser, env_name (), sizeof (wuser) / sizeof (*wuser));
d307 1
a307 1
  if (!env_domain () || strcasematch (env_name (), "SYSTEM"))
@


1.51.2.9
log
@Merged changes from HEAD
@
text
@d91 2
a92 2
      myself->uid = pw->pw_uid;
      myself->gid = pw->pw_gid;
d96 2
a97 2
      myself->uid = DEFAULT_UID;
      myself->gid = DEFAULT_GID;
d112 2
a113 2
  cygheap->user.orig_uid = cygheap->user.real_uid = myself->uid;
  cygheap->user.orig_gid = cygheap->user.real_gid = myself->gid;
@


1.51.2.10
log
@Merged changes from HEAD
@
text
@d190 4
a199 5
  char homepath_env_buf[MAX_PATH + 1];
  char homedrive_env_buf[3];
  char *newhomedrive = NULL;
  char *newhomepath = NULL;

d205 4
a208 1
	newhomedrive = p;
d211 4
a214 1
	newhomepath = p;
d227 1
a227 1
	  else if (newhomedrive && newhomepath)
d231 2
a232 2
	      strcpy (buf, newhomedrive);
	      strcat (buf, newhomepath);
d238 1
d241 1
a241 1
  if (homepath == NULL && newhomepath == NULL)
a248 1
	  homepath_env_buf[0] = homepath_env_buf[1] = '\0';
d278 2
a279 2
	  newhomedrive = almost_null;
	  newhomepath = homepath_env_buf;
d285 1
a285 3
	  homedrive_env_buf[2] = '\0';
	  newhomedrive = homedrive_env_buf;
	  newhomepath = homepath_env_buf + 2;
d287 1
a289 7
  if (newhomedrive)
    cfree_and_set (homedrive, (newhomedrive == almost_null)
		   	      ? almost_null : cstrdup (newhomedrive));

  if (newhomepath)
    cfree_and_set (homepath, cstrdup (newhomepath));

d311 3
a313 4
  cfree_and_set (plogsrv, almost_null);
  if (get_logon_server (env_domain (), logsrv, NULL))
    plogsrv = cstrdup (logsrv);
  return plogsrv;
a327 2
  cfree_and_set (winname, almost_null);
  cfree_and_set (pdomain, almost_null);
a329 2
    __seterrno ();
  else
d331 2
a332 2
      winname = cstrdup (username);
      pdomain = cstrdup (userdomain);
d334 4
a337 1
  return pdomain;
a342 2
  char userprofile_env_buf[MAX_PATH + 1];
  cfree_and_set (puserprof, almost_null);
d346 1
a346 1
    puserprof = cstrdup (userprofile_env_buf);
d348 1
a348 1
  return puserprof;
@


1.51.2.11
log
@Merged changes from HEAD
@
text
@a30 1
#include "environ.h"
a201 1
  debug_printf ("what %d, pw %p", what, pw);
d235 1
a235 1
  if (what != CH_HOME && homepath == NULL && newhomepath == NULL)
d244 1
a244 1
	  if (logsrv ())
d247 1
a247 1
	      sys_mbstowcs (wlogsrv, logsrv (),
d249 1
a249 1
	     sys_mbstowcs (wuser, winname (), sizeof (wuser) / sizeof (*wuser));
d305 1
a305 1
cygheap_user::test_uid (char *&what, const char *name, size_t namelen)
d307 1
a307 11
  if (what)
    return what;
  if (orig_uid == myself->uid)
    what = getwinenveq (name, namelen, HEAP_STR);
  return what;
}

const char *
cygheap_user::env_logsrv (const char *name, size_t namelen)
{
  if (test_uid (plogsrv, name, namelen))
d310 2
a311 2
  if (!domain () || strcasematch (winname (), "SYSTEM"))
    return almost_null;
d315 1
a315 1
  if (get_logon_server (domain (), logsrv, NULL))
d321 1
a321 1
cygheap_user::env_domain (const char *name, size_t namelen)
d323 1
a323 1
  if (pwinname && test_uid (pdomain, name, namelen))
d332 1
a332 1
  cfree_and_set (pwinname, almost_null);
d339 1
a339 1
      pwinname = cstrdup (username);
d346 1
a346 1
cygheap_user::env_userprofile (const char *name, size_t namelen)
a347 3
  if (test_uid (puserprof, name, namelen))
    return puserprof;

d351 1
a351 1
  if (!strcasematch (winname (), "SYSTEM")
d359 1
a359 1
cygheap_user::env_homepath (const char *name, size_t namelen)
d365 1
a365 1
cygheap_user::env_homedrive (const char *name, size_t namelen)
d371 1
a371 1
cygheap_user::env_name (const char *name, size_t namelen)
d373 2
a374 3
  if (!test_uid (pwinname, name, namelen))
    (void) domain ();
  return pwinname;
@


1.51.2.12
log
@Merged changes from HEAD
@
text
@d311 1
a311 1
  if (!issetuid ())
d322 1
a322 3
  const char *mydomain = domain ();
  const char *myname = winname ();
  if (!mydomain || strcasematch (myname, "SYSTEM"))
d327 1
a327 1
  if (get_logon_server (mydomain, logsrv, NULL))
d366 1
a366 2
  const char *myname = winname ();
  if (myname && strcasematch (myname, "SYSTEM")
@


1.51.2.13
log
@Merged changes from HEAD
@
text
@d207 1
a207 3
      if (homedrive)
	newhomedrive = homedrive;
      else if ((p = getenv ("HOMEDRIVE")))
d210 1
a210 3
      if (homepath)
	newhomepath = homepath;
      else if ((p = getenv ("HOMEPATH")))
d221 1
a222 1
	      setenv ("HOME", pw->pw_dir, 1);
d224 1
a224 3
	  else if (!newhomedrive || !newhomepath)
	    setenv ("HOME", "/", 1);
	  else
d231 1
a232 1
	      setenv ("HOME", home, 1);
d288 1
a288 1
  if (newhomedrive && newhomedrive != homedrive)
d292 1
a292 1
  if (newhomepath && newhomepath != homepath)
d309 3
a311 1
  if (!what && !issetuid ())
@


1.51.2.14
log
@Merged changes from HEAD
@
text
@d260 1
d268 4
a271 2
		      else
			cygwin_conv_to_full_win32_path ("/", homepath_env_buf);
@


1.51.2.15
log
@Merged changes from HEAD
@
text
@d51 1
a51 1
	system_printf ("GetTokenInformation (TokenUser): %E");
a53 3
      else if (!GetTokenInformation (ptok, TokenPrimaryGroup,
				     &user.groups.pgsid, sizeof tu, &siz))
	system_printf ("GetTokenInformation (TokenPrimaryGroup): %E");
d78 3
a80 7
	  if (gsid)
	    {
	      user.groups.pgsid = gsid;
	      if (!SetTokenInformation (ptok, TokenPrimaryGroup,
					&gsid, sizeof gsid))
		debug_printf ("SetTokenInformation(TokenPrimaryGroup): %E");
	    }
d82 1
@


1.51.2.16
log
@Merged changes from HEAD
@
text
@d299 1
a299 1
			      ? almost_null : cstrdup (newhomedrive));
@


1.51.2.17
log
@Merged changes from HEAD
@
text
@d121 1
a121 1
  cygheap->user.set_orig_sid ();	/* Update the original sid */
d262 1
a262 1
			    sizeof (wlogsrv) / sizeof (*wlogsrv));
@


1.50
log
@Update copyrights.
@
text
@d43 1
a43 1
  if (iswinnt)
@


1.49
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998 Cygnus Solutions.
@


1.48
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d66 1
a66 1
	  		INTERNET_MAX_HOST_NAME_LENGTH + 1);
d72 1
a72 1
      	}
d87 1
a87 1
        {
d131 1
a131 1
	      			    TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
d191 1
a191 1
		  			        &gsid, sizeof gsid))
@


1.47
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d43 1
a43 1
  if (os_being_run == winNT)
@


1.46
log
@        * uinfo.cc (internal_getlogin): Add pointer check.
@
text
@d24 1
a28 1
#include "security.h"
@


1.45
log
@forced commit
@
text
@d85 6
a90 2
      strcat (strcpy (buf, "\\\\"), user.logsrv ());
      sys_mbstowcs (wlogsrv, buf, INTERNET_MAX_HOST_NAME_LENGTH + 3);
d92 1
a92 1
	  || !NetUserGetInfo (wlogsrv, wuser, 3,(LPBYTE *)&ui))
@


1.44
log
@         * cygwin.din: Add fchdir symbols.
         * path.cc (chdir): Guard against invalid parameter.
         (fchdir): New function.
         * include/cygwin/version.h: Bump API minor version to 40.
         * uinfo.cc (internal_getlogin): Remove unused variable.
@
text
@@


1.43
log
@        * syscalls.cc (seteuid): Set environment variables USERNAME and
        USERDOMAIN before impersonation to workaround a LookupAccountSid()
        misbehaviour.
        * uinfo.cc (internal_getlogin): Revert most of the previous change.
        Don't set environment variables USERNAME and USERDOMAIN. That's
        the job of seteuid() now. Try to get logon server from Lsa
        only if logon server isn't already known.
@
text
@a155 1
	      char dom[INTERNET_MAX_HOST_NAME_LENGTH + 1];
@


1.42
log
@        * cygheap.h (cygheap_user::cygheap_user): Initialize token to
        INVALID_HANDLE_VALUE.
        * uinfo.cc (uinfo_init): Close token handle if needed.
@
text
@d34 1
a34 1
  DWORD ulen = UNLEN + 1;
d37 1
a37 1
  if (!GetUserName (username, &ulen))
d41 1
d45 17
a61 28
      HANDLE ptok = user.token; /* Which is INVALID_HANDLE_VALUE if no
				   impersonation took place. */
      DWORD siz;
      cygsid tu;
      NET_API_STATUS ret = 0;
      char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      DWORD dlen = INTERNET_MAX_HOST_NAME_LENGTH + 1;
      SID_NAME_USE use;
      char buf[MAX_PATH];

      /* Try to get the SID either from already impersonated token
	 or from current process first. To differ that two cases is
	 important, because you can't rely on the user information
	 in a process token of a currently impersonated process. */
      user.set_sid (NO_SID);
      if (ptok == INVALID_HANDLE_VALUE
	  && !OpenProcessToken (GetCurrentProcess (),
				TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
				&ptok))
	debug_printf ("OpenProcessToken(): %E");
      else if (!GetTokenInformation (ptok, TokenUser, &tu, sizeof tu, &siz))
	debug_printf ("GetTokenInformation(): %E");
      else if (!(ret = user.set_sid (tu)))
	debug_printf ("Couldn't retrieve SID from access token!");
      else if (!LookupAccountSid (NULL, user.sid (), username, &ulen,
				  domain, &dlen, &use))
	debug_printf ("LookupAccountSid (): %E");
      else
d63 14
a76 2
	  user.set_name (username);
	  user.set_domain (domain);
d78 3
a80 5
      if (get_logon_server_and_user_domain (domain, NULL))
	user.set_logsrv (domain + 2);
      setenv ("USERNAME", user.name (), 1);
      setenv ("LOGONSERVER", user.logsrv (), 1);
      setenv ("USERDOMAIN", user.domain (), 1);
d82 2
a83 4
      LPUSER_INFO_3 ui;
      WCHAR wlogsrv[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      WCHAR wuser[UNLEN + 1];
      sys_mbstowcs (wlogsrv, user.logsrv (), INTERNET_MAX_HOST_NAME_LENGTH + 1);
d85 4
a88 2
      if (!NetUserGetInfo (wlogsrv, wuser, 3, (LPBYTE *)&ui) ||
          !NetUserGetInfo (NULL, wuser, 3, (LPBYTE *)&ui))
d98 1
a98 1
		  char *env = getenv ("SYSTEMDRIVE");
d110 2
d113 1
a113 4
      /* If we have a SID, try to get the corresponding Cygwin user name
	 which can be different from the Windows user name. */
      cygsid gsid (NO_SID);
      if (user.sid ())
d115 29
a143 1
	  cygsid psid;
d145 46
a190 14
	  for (int pidx = 0; (pw = internal_getpwent (pidx)); ++pidx)
	    if (psid.getfrompw (pw) && EqualSid (user.sid (), psid))
	      {
		user.set_name (pw->pw_name);
		struct group *gr = getgrgid (pw->pw_gid);
		if (gr && !gsid.getfromgr (gr))
		  gsid = NO_SID;
	      }
	  if (!strcasematch (user.name (), "SYSTEM"))
	    if (get_registry_hive_path (user.sid (), buf))
	      setenv ("USERPROFILE", buf, 1);
	    else
	      unsetenv ("USERPROFILE");
	}
d192 4
a195 11
      /* If this process is started from a non Cygwin process,
	 set token owner to the same value as token user and
	 primary group to the group which is set as primary group
	 in /etc/passwd. */
      if (ptok != INVALID_HANDLE_VALUE && myself->ppid == 1)
	{
	  if (!SetTokenInformation (ptok, TokenOwner, &tu, sizeof tu))
	    debug_printf ("SetTokenInformation(TokenOwner): %E");
	  if (gsid && !SetTokenInformation (ptok, TokenPrimaryGroup,
					    &gsid, sizeof gsid))
	    debug_printf ("SetTokenInformation(TokenPrimaryGroup): %E");
a196 5

      /* Close token only if it's a result from OpenProcessToken(). */
      if (ptok != INVALID_HANDLE_VALUE
	  && user.token == INVALID_HANDLE_VALUE)
	CloseHandle (ptok);
@


1.41
log
@        * sec_helper.cc (cygsid::getfrompw): Change parameter to `const'.
        (cygsid::getfromgr): Ditto.
        * security.cc: Use `sys_mbstowcs' and `sys_wcstombs' throughout.
        (extract_nt_dom_user): Try to get user and domain from SID in
        pw->pw_gecos first.
        * security.h (class cygsid): Change parameter of getfrompw() and
        getfromgr() to `const'.
        * uinfo.cc (internal_getlogin): Change order for evaluating user
        information in winNT case. Drop usage of NetWkstaUserGetInfo().
@
text
@d164 2
@


1.40
log
@        * autoload.cc: Add load statements for `LookupAccountNameW',
        `LsaClose', `LsaEnumerateAccountRights', `LsaFreeMemory',
        `LsaOpenPolicy', `LsaQueryInformationPolicy', `NetLocalGroupEnum',
        `NetLocalGroupGetMembers', `NetServerEnum', `NetUserGetGroups' and
        `NtCreateToken'.
        * ntdll.h: Add declaration for `NtCreateToken'.
        * sec_helper.cc: Add `well_known_local_sid', `well_known_dialup_sid',
        `well_known_network_sid', `well_known_batch_sid',
        `well_known_interactive_sid', `well_known_service_sid' and
        `well_known_authenticated_users_sid'.
        (cygsid::string): Define as const method.
        (cygsid::get_sid): Set psid to NO_SID on error.
        (cygsid::getfromstr): Ditto.
        (cygsid::getfrompw): Simplify.
        (cygsid::getfromgr): Check for gr == NULL.
        (legal_sid_type): Move to security.h.
        (set_process_privilege): Return -1 on error, otherwise 0 or 1 related
        to previous privilege setting.
        * security.cc (extract_nt_dom_user): Remove `static'.
        (lsa2wchar): New function.
        (open_local_policy): Ditto.
        (close_local_policy): Ditto.
        (get_lsa_srv_inf): Ditto.
        (get_logon_server): Ditto.
        (get_logon_server_and_user_domain): Ditto.
        (get_user_groups): Ditto.
        (is_group_member): Ditto.
        (get_user_local_groups): Ditto.
        (sid_in_token_groups): Ditto.
        (get_user_primary_group): Ditto.
        (get_group_sidlist): Ditto.
        (get_system_priv_list): Ditto.
        (get_priv_list): Ditto.
        (get_dacl): Ditto.
        (create_token): Ditto.
        (subauth): Return immediately if SE_TCB_NAME can't be assigned.
        Change all return statements in case of error to jumps to `out'
        label. Add `out' label to support cleanup.
        * security.h: Add extern declarations for `well_known_local_sid',
        `well_known_dialup_sid', `well_known_network_sid',
        `well_known_batch_sid', `well_known_interactive_sid',
        `well_known_service_sid' and `well_known_authenticated_users_sid'.
        Add extern declarations for functions `create_token',
        `extract_nt_dom_user' and `get_logon_server_and_user_domain'.
        (class cygsid): Add method `assign'. Change operator= to call new
        `assign' method. Add `debug_print' method.
        (class cygsidlist): New class.
        (legal_sid_type): Moved from sec_helper.cc to here.
        * spawn.cc (spawn_guts) Revert reversion of previous patch.
        Call `RevertToSelf' and `ImpersonateLoggedOnUser' instead of `seteuid'
        again.
        * syscalls.cc (seteuid): Rearranged. Call `create_token' now when
        needed. Call `subauth' if `create_token' fails. Try setting token
        owner and primary group only if token was not explicitely created
        by `create_token'.
        * uinfo.cc (internal_getlogin): Try harder to generate correct user
        information. Especially don't trust return value of `GetUserName'.
@
text
@d34 1
a34 1
  DWORD username_len = UNLEN + 1;
d37 1
a37 1
  if (!GetUserName (username, &username_len))
a40 1
  debug_printf ("GetUserName() = %s", user.name ());
d44 45
a88 20
      LPWKSTA_USER_INFO_1 wui;
      NET_API_STATUS ret;
      char buf[512];
      char dom[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      char *env, *un = NULL;

      /* First trying to get logon info from environment */
      if ((env = getenv ("USERNAME")) != NULL)
	un = env;
      if ((env = getenv ("LOGONSERVER")) != NULL)
	user.set_logsrv (env + 2); /* filter leading double backslashes */
      if ((env = getenv ("USERDOMAIN")) != NULL)
	user.set_domain (env);
      /* Trust only if usernames are identical */
      if (un && strcasematch (user.name (), un)
	  && user.domain () && user.logsrv ())
	debug_printf ("Domain: %s, Logon Server: %s",
		      user.domain (), user.logsrv ());
      /* If that failed, try to get that info from NetBIOS */
      else if (!(ret = NetWkstaUserGetInfo (NULL, 1, (LPBYTE *)&wui)))
d90 2
a91 11
	  sys_wcstombs (buf, wui->wkui1_username, UNLEN + 1);
	  user.set_name (buf);
	  sys_wcstombs (buf, wui->wkui1_logon_server,
	  		INTERNET_MAX_HOST_NAME_LENGTH + 1);
	  user.set_logsrv (buf);
	  sys_wcstombs (buf, wui->wkui1_logon_domain,
			INTERNET_MAX_HOST_NAME_LENGTH + 1);
	  user.set_domain (buf);
	  /* Save values in environment */
	  if (!strcasematch (user.name (), "SYSTEM")
	      && user.domain () && user.logsrv ())
d93 4
a96 12
	      LPUSER_INFO_3 ui = NULL;
	      WCHAR wbuf[INTERNET_MAX_HOST_NAME_LENGTH + 2];

	      strcat (strcpy (buf, "\\\\"), user.logsrv ());
	      setenv ("USERNAME", user.name (), 1);
	      setenv ("LOGONSERVER", buf, 1);
	      setenv ("USERDOMAIN", user.domain (), 1);
	      /* HOMEDRIVE and HOMEPATH are wrong most of the time, too,
		 after changing user context! */
	      sys_mbstowcs (wbuf, buf, INTERNET_MAX_HOST_NAME_LENGTH + 2);
	      if (!NetUserGetInfo (NULL, wui->wkui1_username, 3, (LPBYTE *)&ui)
		  || !NetUserGetInfo (wbuf,wui->wkui1_username,3,(LPBYTE *)&ui))
d98 5
a102 19
		  sys_wcstombs (buf, ui->usri3_home_dir, MAX_PATH);
		  if (!buf[0])
		    {
		      sys_wcstombs (buf, ui->usri3_home_dir_drive, MAX_PATH);
		      if (buf[0])
			strcat (buf, "\\");
		      else
			{
			  env = getenv ("SYSTEMDRIVE");
			  if (env && *env)
			    strcat (strcpy (buf, env), "\\");
			  else
			    GetSystemDirectoryA (buf, MAX_PATH);
			}
		    }
		  setenv ("HOMEPATH", buf + 2, 1);
		  buf[2] = '\0';
		  setenv ("HOMEDRIVE", buf, 1);
		  NetApiBufferFree (ui);
d105 4
a108 3
	  debug_printf ("Domain: %s, Logon Server: %s, Windows Username: %s",
			user.domain (), user.logsrv (), user.name ());
	  NetApiBufferFree (wui);
a109 5
      else
        {
	  /* If `NetWkstaUserGetInfo' failed, try to get default values known
	     by local policy object.*/
          debug_printf ("NetWkstaUserGetInfo() Err %d", ret);
d111 4
a114 11
	  if (get_logon_server_and_user_domain (buf, dom))
	    {
	      user.set_logsrv (buf + 2);
	      user.set_domain (dom);
	      setenv ("LOGONSERVER", buf, 1);
	      setenv ("USERDOMAIN", dom, 1);
	    }
	  else
	    debug_printf ("get_logon_server_and_user_domain() failed");
	}
      if (allow_ntsec)
d116 1
a116 29
	  HANDLE ptok = user.token; /* Which is INVALID_HANDLE_VALUE if no
				       impersonation took place. */
	  DWORD siz;
	  cygsid tu;
	  int ret = 0;

	  /* Try to get the SID either from already impersonated token
	     or from current process first. To differ that two cases is
	     important, because you can't rely on the user information
	     in a process token of a currently impersonated process. */
	  if (ptok == INVALID_HANDLE_VALUE
	      && !OpenProcessToken (GetCurrentProcess (),
	      			    TOKEN_ADJUST_DEFAULT | TOKEN_QUERY,
				    &ptok))
	    debug_printf ("OpenProcessToken(): %E\n");
	  else if (!GetTokenInformation (ptok, TokenUser, &tu, sizeof tu, &siz))
	    debug_printf ("GetTokenInformation(): %E");
	  else if (!(ret = user.set_sid (tu)))
	    debug_printf ("Couldn't retrieve SID from access token!");
	  /* If that failes, try to get the SID from localhost. This can only
	     be done if a domain is given because there's a chance that a local
	     and a domain user may have the same name. */
	  if (!ret && user.domain ())
	    {
	      /* Concat DOMAIN\USERNAME for the next lookup */
	      strcat (strcat (strcpy (buf, user.domain ()), "\\"), user.name ());
	      if (!(ret = lookup_name (buf, NULL, user.sid ())))
		debug_printf ("Couldn't retrieve SID locally!");
	    }
d118 14
a131 12
	  /* If that fails, too, as a last resort try to get the SID from
	     the logon server. */
	  if (!ret && !(ret = lookup_name (user.name (), user.logsrv (),
					   user.sid ())))
	    debug_printf ("Couldn't retrieve SID from '%s'!", user.logsrv ());

	  /* If we have a SID, try to get the corresponding Cygwin user name
	     which can be different from the Windows user name. */
	  cygsid gsid (NO_SID);
	  if (ret)
	    {
	      cygsid psid;
d133 12
a144 27
	      for (int pidx = 0; (pw = internal_getpwent (pidx)); ++pidx)
		if (psid.getfrompw (pw) && EqualSid (user.sid (), psid))
		  {
		    user.set_name (pw->pw_name);
		    struct group *gr = getgrgid (pw->pw_gid);
		    if (gr)
		      if (!gsid.getfromgr (gr))
			  gsid = NO_SID;
		    extract_nt_dom_user (pw, dom, buf);
		    setenv ("USERNAME", buf, 1);
		    if (*dom)
		      user.set_domain (dom);
		    else if (user.logsrv ())
		      user.set_domain (user.logsrv ());
		    if (user.domain ())
		      setenv ("USERDOMAIN", user.domain (), 1);
		    break;
		  }
	      if (!strcasematch (user.name (), "SYSTEM")
		  && user.domain () && user.logsrv ())
		{
		  if (get_registry_hive_path (user.sid (), buf))
		    setenv ("USERPROFILE", buf, 1);
		  else
		    unsetenv ("USERPROFILE");
		}
	    }
d146 4
a149 18
	  /* If this process is started from a non Cygwin process,
	     set token owner to the same value as token user and
	     primary group to the group which is set as primary group
	     in /etc/passwd. */
	  if (ptok != INVALID_HANDLE_VALUE && myself->ppid == 1)
	    {
	      if (!SetTokenInformation (ptok, TokenOwner, &tu, sizeof tu))
		debug_printf ("SetTokenInformation(TokenOwner): %E");
	      if (gsid && !SetTokenInformation (ptok, TokenPrimaryGroup,
		  			        &gsid, sizeof gsid))
		debug_printf ("SetTokenInformation(TokenPrimaryGroup): %E");
	    }

	  /* Close token only if it's a result from OpenProcessToken(). */
	  if (ptok != INVALID_HANDLE_VALUE
	      && user.token == INVALID_HANDLE_VALUE)
	    CloseHandle (ptok);
	}
@


1.39
log
@        * uinfo.cc (uinfo_init): Just set user token to INVALID_HANDLE_VALUE.
        Token value is already invalid at that point.
@
text
@d41 1
d46 4
a49 2
      char buf[MAX_PATH], *env;
      char *un = NULL;
d64 1
a64 1
      else if (!NetWkstaUserGetInfo (NULL, 1, (LPBYTE *)&wui))
a65 2
	  char buf[512]; /* Bigger than each of the below defines. */

d116 16
d167 1
a167 1
					  user.sid ())))
a176 6
	      if (!strcasematch (user.name (), "SYSTEM")
		  && user.domain () && user.logsrv ())
		{
		  if (get_registry_hive_path (user.sid (), buf))
		    setenv ("USERPROFILE", buf, 1);
		}
d185 8
d195 8
@


1.38
log
@        * fork.cc (fork): Eliminate superfluous call to getuid().
        * security.h: New define `NO_SID'. Remove declarations of functions
        moved to methods into class cygsid.
        (class cygsid): Declare new methods `getfromstr', `get_sid',
        `getfrompw', `getfromgr', `get_rid', `get_uid', `get_gid', `string'
        and new constructors and operators =, == and !=.
        Declare new global cygsids `well_known_XXX_sid' substituting the
        corresponding `get_XXX_sid' functions. Remove declarations of
        these functions.
        * sec_helper.cc (well_known_admin_sid): New global variable.
        (well_known_system_sid): Ditto
        (well_known_creator_owner_sid): Ditto
        (well_known_world_sid): Ditto
        (cygsid::string): New method, substituting `convert_sid_to_string_sid'.
        (cygsid::get_sid): New method, substituting `get_sid'.
        (cygsid::getfromstr): New method, substituting
        `convert_string_sid_to_sid'.
        (cygsid::getfrompw): New method, substituting `get_pw_sid'.
        (cygsid::getfromgr): New method, substituting `get_gr_sid'.
        (cygsid::get_id): New method, substituting `get_id_from_sid'.
        (get_admin_sid): Eliminated.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * grp.cc: Use new cygsid methods and well known sids throughout.
        * registry.cc: Ditto.
        * sec_acl.cc: Ditto.
        * security.cc: Ditto.
        * shared.cc: Ditto.
        * syscalls.cc (seteuid): Ditto. Eliminate redundant conditional.
        * uinfo.cc (internal_getlogin): Ditto.
        * spawn.cc (spawn_guts) Revert previous patch.
@
text
@d210 1
a210 1
  cygwin_set_impersonation_token (INVALID_HANDLE_VALUE);
@


1.37
log
@        * uinfo.cc (internal_getlogin): Formatting change.
@
text
@d37 4
a40 5
  if (!user.name ())
    if (!GetUserName (username, &username_len))
      user.set_name ("unknown");
    else
      user.set_name (username);
d155 1
a155 1
	  cygsid gsid (NULL);
d167 1
a167 1
		if (get_pw_sid (psid, pw) && EqualSid (user.sid (), psid))
d172 2
a173 2
		      if (!get_gr_sid (gsid.set (), gr))
			  gsid = NULL;
@


1.36
log
@        * grp.cc: Eliminate MAX_DOMAIN_NAME define.
        (read_etc_group): Substitute MAX_DOMAIN_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * passwd.cc (parse_pwd): Don't force pw_name to be lower case.
        * sec_helper.cc: Substitute MAX_USER_NAME by UNLEN,
        MAX_COMPUTERNAME_LENGTH by INTERNET_MAX_HOST_NAME_LENGTH throughout.
        (lookup_name): Slight cleanup.
        * security.cc (alloc_sd): Substitute MAX_USER_NAME by UNLEN.
        * security.h: Define DEFAULT_UID as DOMAIN_USER_RID_ADMIN and
        DEFAULT_GID as DOMAIN_ALIAS_RID_ADMINS.
        * shared.cc (memory_init): Substitute MAX_USER_NAME by UNLEN.
        * thread.h: Ditto.
        * uinfo.cc (internal_getlogin): Substitute MAX_USER_NAME by UNLEN.
        Substitute MAX_COMPUTERNAME_LENGTH and MAX_HOST_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * winsup.h: Include lmcons.h. Eliminate MAX_USER_NAME and
        MAX_HOST_NAME. Move DEFAULT_UID and DEFAULT_GID to security.h.
@
text
@d64 1
a64 1
	  char buf[512];
d68 2
a69 1
	  sys_wcstombs (buf, wui->wkui1_logon_server, INTERNET_MAX_HOST_NAME_LENGTH + 1);
@


1.35
log
@        * uinfo.cc (internal_getlogin): Return pointer to struct passwd.
        (uinfo_init): Accommodate the above change.
        * syscalls.cc (seteuid): Ditto.
@
text
@d15 1
d33 2
a34 2
  char username[MAX_USER_NAME];
  DWORD username_len = MAX_USER_NAME;
d66 1
a66 1
	  sys_wcstombs (buf, wui->wkui1_username, MAX_USER_NAME);
d68 1
a68 1
	  sys_wcstombs (buf, wui->wkui1_logon_server, MAX_HOST_NAME);
d71 1
a71 1
			MAX_COMPUTERNAME_LENGTH + 1);
d78 1
a78 1
	      WCHAR wbuf[MAX_HOST_NAME + 2];
d86 1
a86 1
	      sys_mbstowcs (wbuf, buf, MAX_HOST_NAME + 2);
d241 1
a241 1
  static NO_COPY char this_username[MAX_USER_NAME];
@


1.34
log
@        * autoload.cc: Add LoadDLLfunc statements for SetTokenInformation@@16.
        * cygheap.cc: Include security.h.
        * grp.cc (internal_getgrent): New function.
        (getgroups): Rearranged using `internal_getgrent' and the new
        `cygsid' class.
        * passwd.cc (internal_getpwent): New function.
        * sec_acl.cc: Use new `cygsid' class throughout.
        (acl_access): Use `internal_getgrent' instead of `getgrent'.
        * sec_helper.cc: Use new `cygsid' class throughout.
        (get_id_from_sid): Use `internal_getgrent' instead of `getgrent'.
        Use `internal_getpwent' instead of `getpwent'.
        * security.cc: Use new `cygsid' class throughout.
        * security.h: Move `MAX_SID_LEN' from winsup.h to here.
        Add extern declarations for `internal_getgrent' and `internal_getpwent'.
        (class cygsid): New class.
        * shared.cc (sec_user): Use new `cygsid' class.
        * syscalls.cc (seteuid): Try to set owner to user and primary group to
        current group in impersonation token before performing impersonation.
        (setegid): Try to set primary group in process token to the new group
        if ntsec is on.
        * uinfo.cc (internal_getlogin): Use new `cygsid' class.
        Try to set owner to user and primary group to current group in process
        token if the process has been started from a non cygwin process.
        (uinfo_init): Set primary group only if the process has been started
        from a non cygwin process.
        * winsup.h: Move define for `MAX_SID_LEN' to security.h.
@
text
@d29 1
a29 1
const char *
d34 1
a156 1
	      struct passwd *pw;
d197 1
a197 1
  return user.name ();
d215 1
a215 1
    if ((p = getpwnam (internal_getlogin (cygheap->user))) != NULL)
@


1.33
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d118 1
a118 1
	  char tu[1024];
d126 3
a128 1
	      && !OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok))
d130 1
a130 2
	  else if (!GetTokenInformation (ptok, TokenUser, (LPVOID) &tu,
					 sizeof tu, &siz))
d132 1
a132 1
	  else if (!(ret = user.set_sid (((TOKEN_USER *) &tu)->User.Sid)))
a133 5
	  /* Close token only if it's a result from OpenProcessToken(). */
	  if (ptok != INVALID_HANDLE_VALUE
	      && user.token == INVALID_HANDLE_VALUE)
	    CloseHandle (ptok);

d145 1
a145 1
	  /* If that failes, too, as a last resort try to get the SID from
d153 1
d157 1
a157 2
	      char psidbuf[MAX_SID_LEN];
	      PSID psid = (PSID) psidbuf;
d165 1
a165 1
	      while ((pw = getpwent ()) != NULL)
d169 4
a174 1
	      endpwent ();
d176 18
d218 4
a221 1
	myself->gid = p->pw_gid;
@


1.32
log
@Fix spacing, copyrights.
@
text
@d23 2
@


1.31
log
@        * uinfo.cc: Eliminate `#include <wchar.h>'.
@
text
@d149 1
a149 1
	  if (!ret && !(ret = lookup_name(user.name (), user.logsrv (),
d216 1
a216 1
  char *this_username=_reent_winsup()->_username;
@


1.30
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@a17 1
#include <wchar.h>
@


1.29
log
@        * uinfo.cc (uinfo_init): Call `cygwin_set_impersonation_token' to
        reset `cygheap->user.token' to INVALID_HANDLE_VALUE.
@
text
@d34 6
a39 4
  if (! GetUserName (username, &username_len))
    user.set_name ("unknown");
  else
    user.set_name (username);
@


1.28
log
@        * uinfo.cc (internal_getlogin): Change parameter list to reflect
        that `token' is member of cygheap_user now.
        (uinfo_init): Use modified internal_getlogin.
        * syscalls.cc (seteuid): Ditto.
@
text
@d20 1
d189 1
a189 1
  cygheap->user.token = INVALID_HANDLE_VALUE;
@


1.27
log
@        * cygheap.h: Move `token' and `impersonated' from class _pinfo
        to class cygheap_user.
        * pinfo.h: Ditto.
        * fork.cc (fork_child): Change usage of `token' and `impersonated'
        accordingly.
        (fork_parent): Ditto.
        * security.cc (cygwin_set_impersonation_token): Ditto.
        * sigproc.cc (proc_subproc): Ditto.
        * spawn.cc (spawn_guts): Ditto.
        * syscalls.cc (seteuid): Ditto.
        * uinfo.cc (uinfo_init): Ditto.
@
text
@d28 1
a28 1
internal_getlogin (cygheap_user &user, HANDLE token)
d111 2
a112 2
	  HANDLE ptok = token; /* Which is INVALID_HANDLE_VALUE if no
				      impersonation took place. */
d130 2
a131 1
	  if (ptok != INVALID_HANDLE_VALUE && token == INVALID_HANDLE_VALUE)
d194 1
a194 2
    if ((p = getpwnam (internal_getlogin (cygheap->user,
  					  INVALID_HANDLE_VALUE))) != NULL)
@


1.26
log
@        * cygheap.cc (cygheap_root::cygheap_root): New function.
        (cygheap_root::~cygheap_root): Ditto.
        (cygheap_root::operator=): Ditto.
        (cygheap_user::~cygheap_user): Ditto.
        (cygheap_user::set_name): Ditto.
        (cygheap_user::set_logsrv): Ditto.
        (cygheap_user::set_domain): Ditto.
        (cygheap_user::set_sid): Ditto.
        * cygheap.h (cygheap_root): New class.
        (cygheap_user): Ditto.
        (init_cygheap): Change type of `root' member to cygheap_root.
        Add `user' member.
        * dir.cc (opendir): Use new `cygheap_root' class.
        * dcrt0.cc (dll_crt0_1): Use new `cygheap_user' class.
        * fork.cc (fork_parent): Ditto.
        * grp.cc (getgroups): Ditto.
        * passwd.cc (search_for): Ditto.
        * path.cc: Use new `cygheap_root' class throughout.
        * pinfo.h (_pinfo): Remove `use_psid'. Move `username', `psid',
        `logsrv', `domain', `orig_{uid,gid}' and `real_{uid,gid}' to
        cygheap_user class.
        * security.cc: Use new `cygheap_user' class throughout.
        * shared.cc (sec_user): Ditto.
        * sigproc.cc (proc_subproc): Remove copy statements for user
        related information moved to `cygheap_user' class.
        * spawn.cc (spawn_guts): Invalidate current chroot settings
        when creating Windows environment. Use new `cygheap_user' class.
        * syscalls.cc: Use new `cygheap_user' class throughout.
        * uinfo.cc: Ditto.
        * uinfo.cc (internal_getlogin): Change parameters to reflect the
        move of user information to cygheap.
@
text
@d187 2
a188 2
  myself->token = INVALID_HANDLE_VALUE;
  myself->impersonated = TRUE;
@


1.25
log
@Whitespace cleanup.

* configure.in: Eliminate subdir stuff.
* configure: Regenerate.
* include/getopt.h (option): Make name field 'const'.
@
text
@d23 1
d27 2
a28 2
char *
internal_getlogin (_pinfo *pi)
d30 2
a31 2
  if (! pi)
    api_fatal ("pinfo pointer is NULL!\n");
d33 4
a36 3
  DWORD username_len = MAX_USER_NAME;
  if (! GetUserName (pi->username, &username_len))
    strcpy (pi->username, "unknown");
d47 1
a47 1
	strcpy (pi->logsrv, env + 2); /* filter leading double backslashes */
d49 1
a49 1
	strcpy (pi->domain, env);
d51 4
a54 3
      if (un && strcasematch (pi->username, un)
	  && pi->domain[0] && pi->logsrv[0])
	debug_printf ("Domain: %s, Logon Server: %s", pi->domain, pi->logsrv);
d58 7
a64 3
	  sys_wcstombs (pi->username, wui->wkui1_username, MAX_USER_NAME);
	  sys_wcstombs (pi->logsrv, wui->wkui1_logon_server, MAX_HOST_NAME);
	  sys_wcstombs (pi->domain, wui->wkui1_logon_domain,
d66 1
d68 2
a69 2
	  if (!strcasematch (pi->username, "SYSTEM")
	      && pi->domain[0] && pi->logsrv[0])
d74 2
a75 2
	      strcat (strcpy (buf, "\\\\"), pi->logsrv);
	      setenv ("USERNAME", pi->username, 1);
d77 1
a77 1
	      setenv ("USERDOMAIN", pi->domain, 1);
d106 1
a106 1
			pi->domain, pi->logsrv, pi->username);
d111 1
a111 1
	  HANDLE ptok = pi->token; /* Which is INVALID_HANDLE_VALUE if no
d127 1
a127 2
	  else if (!(ret = CopySid (MAX_SID_LEN, (PSID) pi->psid,
				    ((TOKEN_USER *) &tu)->User.Sid)))
d130 1
a130 1
	  if (ptok != INVALID_HANDLE_VALUE && pi->token == INVALID_HANDLE_VALUE)
d136 1
a136 1
	  if (!ret && pi->domain[0])
d139 2
a140 2
	      strcat (strcat (strcpy (buf, pi->domain), "\\"), pi->username);
	      if (!(ret = lookup_name (buf, NULL, (PSID) pi->psid)))
d146 3
a148 3
	  if (!ret && !(ret = lookup_name(pi->username, pi->logsrv,
					  (PSID)pi->psid)))
	    debug_printf ("Couldn't retrieve SID from '%s'!", pi->logsrv);
d158 2
a159 3
	      pi->use_psid = 1;
	      if (!strcasematch (pi->username, "SYSTEM")
		  && pi->domain[0] && pi->logsrv[0])
d161 1
a161 1
		  if (get_registry_hive_path (pi->psid, buf))
d165 1
a165 1
		if (get_pw_sid (psid, pw) && EqualSid (pi->psid, psid))
d167 1
a167 1
		    strcpy (pi->username, pw->pw_name);
d174 2
a175 2
  debug_printf ("Cygwins Username: %s", pi->username);
  return pi->username;
a180 1
  char *username;
d193 2
a194 1
    if ((p = getpwnam (username = internal_getlogin (myself))) != NULL)
d206 2
a207 2
  myself->orig_uid = myself->real_uid = myself->uid;
  myself->orig_gid = myself->real_gid = myself->gid;
d219 1
a219 1
  return strcpy (this_username, myself->username);
d225 1
a225 1
  return myself->real_uid;
d231 1
a231 1
  return myself->real_gid;
@


1.24
log
@        * autoload.cc: New file keeping all autoload stuff.
        * Makefile.in: Add autoload.o to dependencies.
        * dcrt0.cc: Move all autoload stuff to autoload.cc.
        * fhandler_mem.cc: Ditto.
        * net.cc: Ditto.
        * uinfo.cc: Ditto.
@
text
@d108 1
a108 1
	    
@


1.23
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@a16 1
#include "autoload.h"
a252 23
}

extern "C" {
LoadDLLinitfunc (netapi32)
{
  HANDLE h;

  if ((h = LoadLibrary ("netapi32.dll")) != NULL)
    netapi32_handle = h;
  else if (! netapi32_handle)
    api_fatal ("could not load netapi32.dll. %d", GetLastError ());
  return 0;
}

static void dummy_autoload (void) __attribute__ ((unused));
static void
dummy_autoload (void)
{
LoadDLLinit (netapi32)
LoadDLLfunc (NetWkstaUserGetInfo, 12, netapi32)
LoadDLLfunc (NetUserGetInfo, 16, netapi32)
LoadDLLfunc (NetApiBufferFree, 4, netapi32)
}
@


1.22
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@a20 1
#include "thread.h"
@


1.21
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d25 2
@


1.20
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d43 1
a43 1
        un = env;
d45 1
a45 1
        strcpy (pi->logsrv, env + 2); /* filter leading double backslashes */
d47 1
a47 1
        strcpy (pi->domain, env);
d50 2
a51 2
          && pi->domain[0] && pi->logsrv[0])
        debug_printf ("Domain: %s, Logon Server: %s", pi->domain, pi->logsrv);
d54 47
a100 47
        {
          sys_wcstombs (pi->username, wui->wkui1_username, MAX_USER_NAME);
          sys_wcstombs (pi->logsrv, wui->wkui1_logon_server, MAX_HOST_NAME);
          sys_wcstombs (pi->domain, wui->wkui1_logon_domain,
                        MAX_COMPUTERNAME_LENGTH + 1);
          /* Save values in environment */
          if (!strcasematch (pi->username, "SYSTEM")
              && pi->domain[0] && pi->logsrv[0])
            {
              LPUSER_INFO_3 ui = NULL;
              WCHAR wbuf[MAX_HOST_NAME + 2];

              strcat (strcpy (buf, "\\\\"), pi->logsrv);
              setenv ("USERNAME", pi->username, 1);
              setenv ("LOGONSERVER", buf, 1);
              setenv ("USERDOMAIN", pi->domain, 1);
              /* HOMEDRIVE and HOMEPATH are wrong most of the time, too,
                 after changing user context! */
              sys_mbstowcs (wbuf, buf, MAX_HOST_NAME + 2);
              if (!NetUserGetInfo (NULL, wui->wkui1_username, 3, (LPBYTE *)&ui)
                  || !NetUserGetInfo (wbuf,wui->wkui1_username,3,(LPBYTE *)&ui))
                {
                  sys_wcstombs (buf, ui->usri3_home_dir, MAX_PATH);
                  if (!buf[0])
                    {
                      sys_wcstombs (buf, ui->usri3_home_dir_drive, MAX_PATH);
                      if (buf[0])
                        strcat (buf, "\\");
                      else
                        {
                          env = getenv ("SYSTEMDRIVE");
                          if (env && *env)
                            strcat (strcpy (buf, env), "\\");
                          else
                            GetSystemDirectoryA (buf, MAX_PATH);
                        }
                    }
                  setenv ("HOMEPATH", buf + 2, 1);
                  buf[2] = '\0';
                  setenv ("HOMEDRIVE", buf, 1);
                  NetApiBufferFree (ui);
                }
            }
          debug_printf ("Domain: %s, Logon Server: %s, Windows Username: %s",
                        pi->domain, pi->logsrv, pi->username);
          NetApiBufferFree (wui);
        }
d102 65
a166 65
        {
          HANDLE ptok = pi->token; /* Which is INVALID_HANDLE_VALUE if no
                                      impersonation took place. */
          DWORD siz;
          char tu[1024];
          int ret = 0;
            
          /* Try to get the SID either from already impersonated token
             or from current process first. To differ that two cases is
             important, because you can't rely on the user information
             in a process token of a currently impersonated process. */
          if (ptok == INVALID_HANDLE_VALUE
              && !OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok))
            debug_printf ("OpenProcessToken(): %E\n");
          else if (!GetTokenInformation (ptok, TokenUser, (LPVOID) &tu,
                                         sizeof tu, &siz))
            debug_printf ("GetTokenInformation(): %E");
          else if (!(ret = CopySid (MAX_SID_LEN, (PSID) pi->psid,
                                    ((TOKEN_USER *) &tu)->User.Sid)))
            debug_printf ("Couldn't retrieve SID from access token!");
          /* Close token only if it's a result from OpenProcessToken(). */
          if (ptok != INVALID_HANDLE_VALUE && pi->token == INVALID_HANDLE_VALUE)
            CloseHandle (ptok);

          /* If that failes, try to get the SID from localhost. This can only
             be done if a domain is given because there's a chance that a local
             and a domain user may have the same name. */
          if (!ret && pi->domain[0])
            {
              /* Concat DOMAIN\USERNAME for the next lookup */
              strcat (strcat (strcpy (buf, pi->domain), "\\"), pi->username);
              if (!(ret = lookup_name (buf, NULL, (PSID) pi->psid)))
                debug_printf ("Couldn't retrieve SID locally!");
            }

          /* If that failes, too, as a last resort try to get the SID from
             the logon server. */
          if (!ret && !(ret = lookup_name(pi->username, pi->logsrv,
                                          (PSID)pi->psid)))
            debug_printf ("Couldn't retrieve SID from '%s'!", pi->logsrv);

          /* If we have a SID, try to get the corresponding Cygwin user name
             which can be different from the Windows user name. */
          if (ret)
            {
              struct passwd *pw;
              char psidbuf[MAX_SID_LEN];
              PSID psid = (PSID) psidbuf;

              pi->use_psid = 1;
              if (!strcasematch (pi->username, "SYSTEM")
                  && pi->domain[0] && pi->logsrv[0])
                {
                  if (get_registry_hive_path (pi->psid, buf))
                    setenv ("USERPROFILE", buf, 1);
                }
              while ((pw = getpwent ()) != NULL)
                if (get_pw_sid (psid, pw) && EqualSid (pi->psid, psid))
                  {
                    strcpy (pi->username, pw->pw_name);
                    break;
                  }
              endpwent ();
            }
        }
d190 2
a191 2
        myself->uid = p->pw_uid;
        myself->gid = p->pw_gid;
d195 2
a196 2
        myself->uid = DEFAULT_UID;
        myself->gid = DEFAULT_GID;
@


1.19
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d21 3
@


1.18
log
@* select.cc (allocfd_set): Zero allocated fd_set.
(cygwin_select): Move fd_set copying logic from ::wait to here.  Use common
return through sell.poll.
(select_stuff::wait): Just return success or failure and let caller fill in
fd_set.
* pinfo.h (pinfo): Eliminate self-referential pointer to sidbuf since pinfo
structure exists at random locations now.
* fork.cc (fork): Use 'use_psid' element to control when the psid is relevant.
* shared.cc (sec_user): Ditto.
* spawn.cc (spawn_guts): Ditto.
* uinfo.cc (internal_getlogin): Ditto.
* syscall.cc (seteuid): Ditto.  Set use_psid element.
@
text
@d21 1
@


1.17
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d115 1
a115 1
          else if (!(ret = CopySid (MAX_SID_LEN, (PSID) pi->sidbuf,
d129 1
a129 1
              if (!(ret = lookup_name (buf, NULL, (PSID) pi->sidbuf)))
d136 1
a136 1
                                          (PSID)pi->sidbuf)))
d147 1
a147 1
              pi->psid = (PSID) pi->sidbuf;
@


1.16
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d11 1
a12 1
#include "winsup.h"
@


1.15
log
@* testsuite/winsup.api/winsup.exp: ignore stdout by default
* testsuite/winsup.api/crlf.c: non-verbose by default

* winsup.h: prune out windows headers we don't normally need
* assert.cc: add wingdi.h and winuser.h
* fhandler_console.cc: ditto
* fhandler_windows.cc: ditto
* select.cc: ditto
* spawn.cc: ditto
* strace.cc: ditto
* tty.cc: ditto
* window.cc: ditto
* hinfo.cc: add winsock.h
* syscalls.cc: add winnls.h
* uinfo.cc: ditto

* include/windows.h: optimize non-inclusion of repeat headers
@
text
@d13 1
a16 1
#include <unistd.h>
d23 1
a23 1
internal_getlogin (struct pinfo *pi)
@


1.14
log
@        Patch suggested by Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>.
        * winsup.h: Add new macros sys_wcstombs and sys_mbstowcs.
        * syscalls.cc (_link): Replace calls to mbstowcs by call to
        sys_mbstowcs.
        * uinfo.cc (internal_getlogin): Replace calls to wcstombs and
        mbstowcs by calls to sys_wcstombs and sys_mbstowcs. Replace
        usage of constants by meaningful defines. Use result of
        GetSystemDirectory for HOMEPATH and HOMEDRIVE as a last resort.
@
text
@d13 1
@


1.13
log
@        * winsup.h: Define MAX_SID_LEN and new MAX_HOST_NAME.
        * fork.cc (fork): Use above defines instead of numerical constants.
        * shared.cc (sec_user): Ditto.
        * shared.h (class pinfo): Ditto.
        * syscall.cc (seteuid): Ditto.
        * spawn.cc (_spawnve): Ditto. Eliminate conditional.
        (spawn_guts): Set child->uid = USHRT_MAX when user context will be
        changed in child process.
        * uinfo.cc (uinfo_init): Check for myself->uid instead of myself->psid
        to avoid reloading of /etc/passwd on process startup if ntsec is off.
        Use above defines instead of numerical constants.
        * security.cc: Move define for MAX_SID_LEN to winsup.h.
@
text
@d33 2
a34 1
      char buf[256], *env;
a36 1
      buf[0] = '\0';
d38 1
a38 1
        strcpy (buf, env);
d44 2
a45 1
      if (strcasematch (pi->username, buf) && pi->domain[0] && pi->logsrv[0])
d50 4
a53 6
          wcstombs (pi->username, wui->wkui1_username,
                    (wcslen (wui->wkui1_username) + 1) * sizeof (WCHAR));
          wcstombs (pi->logsrv, wui->wkui1_logon_server,
                    (wcslen (wui->wkui1_logon_server) + 1) * sizeof (WCHAR));
          wcstombs (pi->domain, wui->wkui1_logon_domain,
                    (wcslen (wui->wkui1_logon_domain) + 1) * sizeof (WCHAR));
d59 1
a59 1
              WCHAR wbuf[256];
d67 1
a67 1
              mbstowcs (wbuf, buf, 256);
d71 1
a71 1
                  wcstombs (buf, ui->usri3_home_dir,  256);
d74 1
a74 1
                      wcstombs (buf, ui->usri3_home_dir_drive, 256);
d77 8
a85 2
                  if (!buf[0])
                    strcat (strcpy (buf, getenv ("SYSTEMDRIVE")), "\\");
@


1.12
log
@        * uinfo.cc (uinfo_init): Eliminate calls to read_etc_group()
        and read_etc_passwd().
@
text
@d109 1
a109 1
          else if (!(ret = CopySid (40, (PSID) pi->sidbuf,
d138 1
a138 1
              char psidbuf[40];
d175 3
a177 5
  /* If psid is non null, the process is forked or spawned from
     another cygwin process without changing the user context.
     So all user infos in myself as well as the environment are
     (perhaps) valid. */
  if (!myself->psid)
@


1.11
log
@Changes by  Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>
        * assert.cc (__assert): Reduce dependency on newlib.
        * exec.cc: Eliminate unnecessary inclusion of ctype.h.
        * glob.c: Ditto.
        * hinfo.cc: Ditto.
        * init.cc: Ditto.
        * strace.cc: Ditto.
        * tty.cc: Ditto.
        * grp.cc (parse_grp): Eliminate atoi.
        * passwd.cc (grab_int): Ditto.
        * grp.cc (getgroups): Eliminate str{n,}casecmp.
        * path.cc (get_raw_device_number): Ditto.
        * path.cc (sort_by_native_name): Ditto.
        * spawn.cc (iscmd): Ditto.
        * uinfo.cc (internal_getlogin): Ditto.
@
text
@a164 5
  void read_etc_passwd ();
  extern int passwd_in_memory_p;
  void read_etc_group ();
  extern int group_in_memory_p;

d179 11
a189 22
  if (myself->psid)
    {
      if (!passwd_in_memory_p)
        read_etc_passwd();
      if (!group_in_memory_p)
        read_etc_group ();
    }
  else if ((p = getpwnam (username = internal_getlogin (myself))) != NULL)
    {
      /* calling getpwnam assures us that /etc/password has been
         read in, but we can't be sure about /etc/group */
      if (!group_in_memory_p)
        read_etc_group ();

      myself->uid = p->pw_uid;
      myself->gid = p->pw_gid;
    }
  else
    {
      myself->uid = DEFAULT_UID;
      myself->gid = DEFAULT_GID;
    }
@


1.10
log
@        * syscalls.cc (seteuid): Initialize pi.token before calling
        internal_getlogin().
        * uinfo.cc (internal_getlogin): Use impersonation token instead
        of process token in case of active impersonation. Add some comments.
        (uinfo_init): Initializing myself->token and myself->impersonated
        before calling internal_getlogin(). Add some comments.
@
text
@d44 1
a44 1
      if (!strcasecmp (pi->username, buf) && pi->domain[0] && pi->logsrv[0])
d56 1
a56 1
          if (strcasecmp (pi->username, "SYSTEM")
d142 1
a142 1
              if (strcasecmp (pi->username, "SYSTEM")
@


1.9
log
@        * fork.cc (fork): Fix error in copying SID pointer.
        * spawn.cc (_spawnve): Ditto.
        * passwd.cc: Remove static from `passwd_in_memory_p'.
        (read_etc_passwd): Remove static.
        * uinfo.cc: Move global declaration of `read_etc_group' and
        `group_in_memory_p' into `uinfo_init'.
        (internal_getlogin): Try to get SID from current process first.
        (uinfo_init): Don't set uid and gid if `myself' has a valid SID.
        Only load /etc/passwd and /etc/group in that case.
@
text
@d93 2
a94 1
          HANDLE ptok = INVALID_HANDLE_VALUE; 
d99 6
a104 2
          /* Try to get the SID from current process first */
          if (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok))
d112 2
a113 1
          if (ptok != INVALID_HANDLE_VALUE)
d173 7
a194 1

d206 2
a207 3
  /* Set to non impersonated value. */
  myself->token = INVALID_HANDLE_VALUE;
  myself->impersonated = TRUE;
@


1.8
log
@        * dcrt0.cc: Add load statements for `GetSidIdentifierAuthority'
        and `RegLoadKeyA'.
        * registry.cc (get_registry_hive_path): New function.
        (load_registry_hive): Ditto.
        * security.cc (convert_sid_to_string_sid): New function.
        (get_ssid): Renamed to `convert_string_sid_to_sid'.
        (get_pw_sid): Call `convert_string_sid_to_sid' instead of `get_ssid'.
        (get_gr_sid): Ditto.
        (get_admin_sid): Ditto.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * shared.h: New prototypes for `get_registry_hive_path' and
        `load_registry_hive'.
        * spawn.cc (spawn_guts): Set child->psid to NULL to force calling
        `internal_getlogin' from child process in case of changing user context.
        Call `load_registry_hive' in case of changing user context.
        (_spawnve): Copy user infos only if user context remains the same.
        * uinfo.cc: Add load statement for `NetUserGetInfo'.
        Remove load statement for `NetGetDCName'.
        (internal_getlogin): Rewrite to speed up process startup
        and to correct user environment in case user context changes.
        (uinfo_init): Call internal_getlogin only if myself->psid is NULL,
        that is user context changes.
        * winsup.h: Add prototypes for `convert_sid_to_string_sid',
        `convert_string_sid_to_sid' and `get_pw_sid'.
@
text
@a20 5
/* FIXME: shouldn't violate internal object space -- these two
   should be static inside grp.cc */
void read_etc_group ();
extern int group_in_memory_p;

d93 3
a95 3
          /* Try to get the SID from localhost first. This can only
             be done if a domain is given because there's a chance that
             a local and a domain user may have the same name. */
d97 17
a113 2

          if (pi->domain[0])
d120 3
d126 3
d159 5
d171 8
a178 2
  username = myself->psid ? myself->username : internal_getlogin (myself);
  if ((p = getpwnam (username)) != NULL)
@


1.7
log
@        * pinfo.cc (pinfo_init): Add missing initializers.
        * uinfo.cc (internal_getlogin): Request domain infos only
        when ntsec is ON.
@
text
@a28 2
  DWORD username_len = MAX_USER_NAME;

d32 3
d37 16
a52 2
      LPWKSTA_USER_INFO_1 ui;
      if (allow_ntsec && !NetWkstaUserGetInfo (NULL, 1, (LPBYTE *)&ui))
d54 9
a62 8
          wcstombs (pi->domain,
                    ui->wkui1_logon_domain,
                    (wcslen (ui->wkui1_logon_domain) + 1) * sizeof (WCHAR));
          debug_printf ("Domain: %s", pi->domain);
          wcstombs (pi->logsrv,
                    ui->wkui1_logon_server,
                    (wcslen (ui->wkui1_logon_server) + 1) * sizeof (WCHAR));
          if (! *pi->logsrv)
d64 2
a65 1
              LPWSTR logon_srv = NULL;
d67 24
a90 9
              if (!NetGetDCName (NULL,
                                 ui->wkui1_logon_domain,
                                 (LPBYTE *)&logon_srv))
                wcstombs (pi->logsrv,
                          logon_srv, // filter leading double backslashes
                          (wcslen (logon_srv) + 1) * sizeof (WCHAR));
              if (logon_srv)
                NetApiBufferFree (logon_srv);
              debug_printf ("DC Server: %s", pi->logsrv);
d92 3
a94 7
          else
            debug_printf ("Logon Server: %s", pi->logsrv);
          wcstombs (pi->username,
                    ui->wkui1_username,
                    (wcslen (ui->wkui1_username) + 1) * sizeof (WCHAR));
          debug_printf ("Windows Username: %s", pi->username);
          NetApiBufferFree (ui);
d96 1
a96 3
      else if (! GetUserName (pi->username, &username_len))
        strcpy (pi->username, "unknown");
      if (!lookup_name (pi->username, pi->logsrv, pi->psid))
d98 36
a133 17
          debug_printf ("myself->psid = NULL");
          pi->psid = NULL;
        }
      else if (allow_ntsec)
        {
          extern BOOL get_pw_sid (PSID, struct passwd*);
          struct passwd *pw;
          char psidbuf[40];
          PSID psid = (PSID) psidbuf;

          while ((pw = getpwent ()) != NULL)
            if (get_pw_sid (psid, pw) && EqualSid (pi->psid, psid))
              {
                strcpy (pi->username, pw->pw_name);
                break;
              }
          endpwent ();
d136 1
a136 8
  else
    {
      debug_printf ("myself->psid = NULL");
      pi->psid = NULL;
      if (! GetUserName (pi->username, &username_len))
        strcpy (pi->username, "unknown");
    }
  debug_printf ("Cygwins Username: %s\n", pi->username);
d143 1
d146 6
a151 2
  myself->psid = (PSID) myself->sidbuf;
  if ((p = getpwnam (internal_getlogin (myself))) != NULL)
d154 1
a154 1
	 read in, but we can't be sure about /etc/group */
d157 1
a157 1
	read_etc_group ();
d243 1
a243 1
LoadDLLfunc (NetGetDCName, 12, netapi32)
@


1.6
log
@        * cygwin.din: Define symbols for `cygwin_logon_user' and
        `cygwin_set_impersonation_token'.
        * dcrt0.cc (dll_crt0_1): Eliminate superfluous conditional
        statements.
        Add load statements for `ImpersonateLoggedOnUser', `LogonUserA'
        and `RevertToSelf'.
        * fork.cc (fork): Care for correct impersonation of parent
        and child process.
        * security.cc (cygwin_set_impersonation_token): New function.
        (cygwin_logon_user): Ditto.
        shared.h (class pinfo): New members `orig_uid', `orig_gid',
        `real_uid' nad `real_gid'.
        spawn.cc (spawn_guts): Care for impersonation when starting
        child process in a different user context.
        * syscalls.cc (setgid): Call `setegid' now. Set real_gid.
        (setuid): Call `seteuid' now. Set real_uid.
        (seteuid): Functionality moved from setuid to here. Care for
        correct impersonation.
        (setegid): Functionality moved from setgid to here.
        * uinfo.cc (uinfo_init): Initialization of additional pinfo
        members.
        (getuid): Return real uid.
        (getgid): Return real gid.
        (geteuid): Return effective uid.
        (getegid): Return effective gid.
        include/sys/cygwin.h: Add prototypes for `cygwin_logon_user' and
        `cygwin_set_impersonation_token'.
        include/cygwin/version.h: Bumb API minor version to 22.
@
text
@a29 1
  LPWKSTA_USER_INFO_1 ui = NULL;
d36 2
a37 2
      int ret = NetWkstaUserGetInfo (NULL, 1, (LPBYTE *)&ui);
      if (! ret)
d58 1
a58 1
              debug_printf ("AnyDC Server: %s", pi->logsrv);
d68 3
a70 1
      else
d72 2
a73 3
          debug_printf ("%d = NetWkstaUserGetInfo ()\n", ret);
          if (! GetUserName (pi->username, &username_len))
            strcpy (pi->username, "unknown");
d75 6
a80 11
        if (!lookup_name (pi->username, pi->logsrv, pi->psid))
          {
            debug_printf ("myself->psid = NULL");
            pi->psid = NULL;
          }
        else if (allow_ntsec)
          {
            extern BOOL get_pw_sid (PSID, struct passwd*);
            struct passwd *pw;
            char psidbuf[40];
            PSID psid = (PSID) psidbuf;
d82 8
a89 8
            while ((pw = getpwent ()) != NULL)
              if (get_pw_sid (psid, pw) && EqualSid (pi->psid, psid))
                {
                  strcpy (pi->username, pw->pw_name);
                  break;
                }
            endpwent ();
          }
@


1.5
log
@* exceptions.cc: Remove unneeded include.
* dcrt0.cc: Wrap LoadDLLfunc stuff in dummy function.
* init.cc: Ditto.
* uinfo.cc: Ditto.
@
text
@d129 5
d151 1
a151 1
  return myself->uid;
d157 1
a157 1
  return myself->gid;
d163 1
a163 1
  return getuid ();
d169 1
a169 1
  return getgid ();
@


1.4
log
@* Makefile.in: Remove libadvapi32.a.
* autoload.h: Add additional field to autoload block for handling unimplemented
functions.
(LoadDLLfuncEx): New function which accepts additional parameter for
controlling unimplemented function behavior.
(LoadDLLfunc): Use LoadDLLfuncEx.
* dcrt0.cc: Use new arguments for LoadDLLfunc.  Add advapi32 routines.
(noload): Rewrite in assembler.  Handle new unimplemented function type.
* exceptions.cc: Eliminate another vestige of StackWalk stuff.
* net.cc: Use new arguments for LoadDLLfunc.
* uinfo.cc: Ditto.

* config.h.in: Remove obsolete define.
* path.h (isdrive): New macro.
* dcrt0.cc (globify): Use new macro to determine if a string refers to an
MS-DOS drive.
* environ.cc (winenv): Ditto.
* spawn.cc (find_exec): Ditto.
* path.cc (get_raw_device_number): Ditto.
(mount_info::conv_to_posix_path): Ditto.
(chdir): Ditto.
(cygwin_posix_path_list_p): Ditto.
(cygwin_split_path): Ditto.
(path_conv::check): Move tmp_buf to beginning of function since it can be used
earlier in the loop.  Use tmp_buf rather than 'root' to hold root information.
(mount_info::conv_to_win32_path): Add trailing slash to end of mount path when
it translates to a drive.  Add defensive code to avoid writing beyond the end
of 'dst'.
@
text
@d182 1
d193 5
d202 2
a203 1

@


1.3
log
@* dcrt0.cc (dll_crt0_1): Move uinfo_init call to before sigproc_init to avoid a
race.
(noload): Add an extra argument for debugging.
* uinfo.cc (uinfo_init): Eliminate test for multiple calls.
(getlogin): Assume that uinfo_init has already been called.
@
text
@d193 3
a195 3
LoadDLLfunc (NetWkstaUserGetInfo, NetWkstaUserGetInfo@@12, netapi32)
LoadDLLfunc (NetGetDCName, NetGetDCName@@12, netapi32)
LoadDLLfunc (NetApiBufferFree, NetApiBufferFree@@4, netapi32)
@


1.2
log
@	* uinfo.cc (internal_getlogin): Use NetGetDCName() instead
	of NetGetAnyDCName().
@
text
@a111 3
  if (myself->username[0])
    return;

a139 1
  uinfo_init ();
@


1.1
log
@Initial revision
@
text
@d51 3
a53 3
              if (!NetGetAnyDCName (NULL,
                                    ui->wkui1_logon_domain,
                                    (LPBYTE *)&logon_srv))
d198 1
a198 1
LoadDLLfunc (NetGetAnyDCName, NetGetAnyDCName@@12, netapi32)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
