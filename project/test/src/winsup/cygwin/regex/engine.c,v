head	1.7;
access;
symbols
	cygwin-1_7_35-release:1.7
	cygwin-1_7_34-release:1.7
	cygwin-1_7_33-release:1.7
	cygwin-1_7_32-release:1.7
	cygwin-1_7_31-release:1.7
	cygwin-1_7_30-release:1.7
	cygwin-1_7_29-release:1.7
	cygwin-1_7_29-release-branchpoint:1.7.0.2
	cygwin-pre-user-db:1.7
	cygwin-1_7_28-release:1.7
	cygwin-1_7_27-release:1.7
	cygwin-1_7_26-release:1.7
	cygwin-1_7_25-release:1.7
	cygwin-1_7_24-release:1.7
	cygwin-1_7_23-release:1.7
	cygwin-1_7_22-release:1.7
	cygwin-1_7_21-release:1.7
	cygwin-1_7_20-release:1.7
	cygwin-1_7_19-release:1.7
	cygwin-64bit-postmerge:1.7
	cygwin-64bit-premerge-branch:1.6.0.8
	cygwin-64bit-premerge:1.6
	cygwin-1_7_18-release:1.6
	post-ptmalloc3:1.6.6.1
	pre-ptmalloc3:1.6.6.1
	cygwin-1_7_17-release:1.6
	cygwin-64bit-branch:1.6.0.6
	cygwin-1_7_16-release:1.6
	cygwin-1_7_15-release:1.6
	cygwin-1_7_14_2-release:1.6
	cygwin-1_7_14-release:1.6
	cygwin-1_7_12-release:1.6
	cygwin-1_7_11-release:1.6
	cygwin-1_7_10-release:1.6
	signal-rewrite:1.6.0.4
	pre-notty:1.6
	cygwin-1_7_9-release:1.6
	cv-post-1_7_9:1.6.0.2
	cygwin-1_7_8-release:1.6
	cygwin-1_7_7-release:1.6
	cygwin-1_7_5-release:1.6
	cygwin-1_7_4-release:1.6
	cygwin-1_7_3-release:1.6
	cygwin-1_7_2-release:1.6
	fifo_doover3:1.3.0.12
	cygwin-1_7_1-release:1.3
	prefifo:1.3
	cv-branch-2:1.3.0.10
	pre-ripout-set_console_state_for_spawn:1.3
	EOL_registry_mounts:1.3
	preoverlapped:1.3
	drop_9x_support_start:1.3
	cr-0x5f1:1.3.0.8
	cv-branch:1.3.0.6
	pre-ptymaster-archetype:1.3
	cr-0x3b58:1.3.0.4
	cr-0x5ef:1.3.0.2
	after-mmap-privanon-noreserve:1.2
	after-mmap-revamp:1.2
	before-mmap-revamp:1.2
	cgf-more-exit-sync:1.2
	post_wait_sig_exit:1.2
	pre_wait_sig_exit:1.2
	reparent-point:1.2
	noreparent:1.2.0.18
	cr-0x5e6:1.2.0.14
	cr-0x9e:1.2.0.12
	cr-0x9d:1.2.0.10
	cgf-deleteme:1.2.0.8
	pre-sigrewrite:1.2
	corinna-01:1.2
	cr-0x9c:1.2.0.6
	cr-0x9b:1.2.0.4
	cr-0x99:1.2
	Z-emcb-cygwin_daemon:1.2.0.2
	w32api-2_2:1.2
	mingw-runtime-2_4:1.2
	pre-cgf-merge:1.2
	cgf-dev-branch:1.2.0.16
	predaemon:1.1
	cygwin_daemon_merge_HEAD:1.1
	pregp02r1:1.1.0.10
	cygnus_cvs_20020108_pre:1.1
	Z-cygwin_daemon_merge_HEAD:1.1
	cygwin_daemon:1.1.0.2
	Z-cygwin_daemon_merge-new_HEAD:1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.04.23.09.44.35;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.11.21.19.19;	author corinna;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2010.02.04.17.34.44;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.04.12.35.49;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.23.22.50.20;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.30.02.51.21;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.20.02.55.09;	author cgf;	state Exp;
branches
	1.1.2.1;
next	;

1.6.6.1
date	2012.11.12.17.26.24;	author corinna;	state Exp;
branches;
next	;

1.1.2.1
date	2002.01.04.03.56.16;	author rbcollins;	state Exp;
branches;
next	;


desc
@@


1.7
log
@	* Merge in cygwin-64bit-branch.
@
text
@/*-
 * Copyright (c) 1992, 1993, 1994 Henry Spencer.
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Henry Spencer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)engine.c	8.5 (Berkeley) 3/20/94
 */

#include <sys/cdefs.h>
__FBSDID("$FreeBSD: src/lib/libc/regex/engine.c,v 1.23 2009/09/16 06:32:23 dds Exp $");

/*
 * The matching engine and friends.  This file is #included by regexec.c
 * after suitable #defines of a variety of macros used herein, so that
 * different state representations can be used without duplicating masses
 * of code.
 */

#ifdef SNAMES
#define	matcher	smatcher
#define	fast	sfast
#define	slow	sslow
#define	dissect	sdissect
#define	backref	sbackref
#define	step	sstep
#define	print	sprint
#define	at	sat
#define	match	smat
#endif
#ifdef LNAMES
#define	matcher	lmatcher
#define	fast	lfast
#define	slow	lslow
#define	dissect	ldissect
#define	backref	lbackref
#define	step	lstep
#define	print	lprint
#define	at	lat
#define	match	lmat
#endif
#ifdef MNAMES
#define	matcher	mmatcher
#define	fast	mfast
#define	slow	mslow
#define	dissect	mdissect
#define	backref	mbackref
#define	step	mstep
#define	print	mprint
#define	at	mat
#define	match	mmat
#endif

/* another structure passed up and down to avoid zillions of parameters */
struct match {
	struct re_guts *g;
	int eflags;
	regmatch_t *pmatch;	/* [nsub+1] (0 element unused) */
	const char *offp;	/* offsets work from here */
	const char *beginp;	/* start of string -- virtual NUL precedes */
	const char *endp;	/* end of string -- virtual NUL here */
	const char *coldp;	/* can be no match starting before here */
	const char **lastpos;	/* [nplus+1] */
	STATEVARS;
	states st;		/* current states */
	states fresh;		/* states for a fresh start */
	states tmp;		/* temporary */
	states empty;		/* empty set of states */
	mbstate_t mbs;		/* multibyte conversion state */
};

/* ========= begin header generated by ./mkh ========= */
#ifdef __cplusplus
extern "C" {
#endif

/* === engine.c === */
static int matcher(struct re_guts *g, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
static const char *dissect(struct match *m, const char *start, const char *stop, sopno startst, sopno stopst);
static const char *backref(struct match *m, const char *start, const char *stop, sopno startst, sopno stopst, sopno lev, int);
static const char *fast(struct match *m, const char *start, const char *stop, sopno startst, sopno stopst);
static const char *slow(struct match *m, const char *start, const char *stop, sopno startst, sopno stopst);
static states step(struct re_guts *g, sopno start, sopno stop, states bef, wint_t ch, states aft);
#define MAX_RECURSION	100
#define	BOL	(OUT-1)
#define	EOL	(BOL-1)
#define	BOLEOL	(BOL-2)
#define	NOTHING	(BOL-3)
#define	BOW	(BOL-4)
#define	EOW	(BOL-5)
#define	BADCHAR	(BOL-6)
/* When using wint_t, which is defined as unsigned int on BSD,
   as well as on Cygwin or Linux, the NONCHAR test is broken without
   the below cast.  I'm wondering how this is supposed to work at all... */
#define	NONCHAR(c)	((int)(c) <= OUT)
#ifdef REDEBUG
static void print(struct match *m, const char *caption, states st, int ch, FILE *d);
#endif
#ifdef REDEBUG
static void at(struct match *m, const char *title, const char *start, const char *stop, sopno startst, sopno stopst);
#endif
#ifdef REDEBUG
static const char *pchar(int ch);
#endif

#ifdef __cplusplus
}
#endif
/* ========= end header generated by ./mkh ========= */

#ifdef REDEBUG
#define	SP(t, s, c)	print(m, t, s, c, stdout)
#define	AT(t, p1, p2, s1, s2)	at(m, t, p1, p2, s1, s2)
#define	NOTE(str)	{ if (m->eflags&REG_TRACE) printf("=%s\n", (str)); }
#else
#define	SP(t, s, c)	/* nothing */
#define	AT(t, p1, p2, s1, s2)	/* nothing */
#define	NOTE(s)	/* nothing */
#endif

/*
 - matcher - the actual matching engine
 == static int matcher(struct re_guts *g, const char *string, \
 ==	size_t nmatch, regmatch_t pmatch[], int eflags);
 */
static int			/* 0 success, REG_NOMATCH failure */
matcher(struct re_guts *g,
	const char *string,
	size_t nmatch,
	regmatch_t pmatch[],
	int eflags)
{
	const char *endp;
	int i;
	struct match mv;
	struct match *m = &mv;
	const char *dp = NULL;
	const sopno gf = g->firststate+1;	/* +1 for OEND */
	const sopno gl = g->laststate;
	const char *start;
	const char *stop;
	/* Boyer-Moore algorithms variables */
	const char *pp;
	int cj, mj;
	const char *mustfirst;
	const char *mustlast;
	int *matchjump;
	int *charjump;

	/* simplify the situation where possible */
	if (g->cflags&REG_NOSUB)
		nmatch = 0;
	if (eflags&REG_STARTEND) {
		start = string + pmatch[0].rm_so;
		stop = string + pmatch[0].rm_eo;
	} else {
		start = string;
		stop = start + strlen(start);
	}
	if (stop < start)
		return(REG_INVARG);

	/* prescreening; this does wonders for this rather slow code */
	if (g->must != NULL) {
		if (g->charjump != NULL && g->matchjump != NULL) {
			mustfirst = g->must;
			mustlast = g->must + g->mlen - 1;
			charjump = g->charjump;
			matchjump = g->matchjump;
			pp = mustlast;
			for (dp = start+g->mlen-1; dp < stop;) {
				/* Fast skip non-matches */
				while (dp < stop && charjump[(int)*dp])
					dp += charjump[(int)*dp];

				if (dp >= stop)
					break;

				/* Greedy matcher */
				/* We depend on not being used for
				 * for strings of length 1
				 */
				while (*--dp == *--pp && pp != mustfirst);

				if (*dp == *pp)
					break;

				/* Jump to next possible match */
				mj = matchjump[pp - mustfirst];
				cj = charjump[(int)*dp];
				dp += (cj < mj ? mj : cj);
				pp = mustlast;
			}
			if (pp != mustfirst)
				return(REG_NOMATCH);
		} else {
			for (dp = start; dp < stop; dp++)
				if (*dp == g->must[0] &&
				    stop - dp >= g->mlen &&
				    memcmp(dp, g->must, (size_t)g->mlen) == 0)
					break;
			if (dp == stop)		/* we didn't find g->must */
				return(REG_NOMATCH);
		}
	}

	/* match struct setup */
	m->g = g;
	m->eflags = eflags;
	m->pmatch = NULL;
	m->lastpos = NULL;
	m->offp = string;
	m->beginp = start;
	m->endp = stop;
	STATESETUP(m, 4);
	SETUP(m->st);
	SETUP(m->fresh);
	SETUP(m->tmp);
	SETUP(m->empty);
	CLEAR(m->empty);
	ZAPSTATE(&m->mbs);

	/* Adjust start according to moffset, to speed things up */
#ifndef MNAMES
	/* The code evaluating moffset doesn't seem to work right
	   in the multibyte case. */
	if (g->moffset > -1)
		start = ((dp - g->moffset) < start) ? start : dp - g->moffset;
#endif
	SP("mloop", m->st, *start);

	/* this loop does only one repetition except for backrefs */
	for (;;) {
		endp = fast(m, start, stop, gf, gl);
		if (endp == NULL) {		/* a miss */
			if (m->pmatch != NULL)
				free((char *)m->pmatch);
			if (m->lastpos != NULL)
				free((char *)m->lastpos);
			STATETEARDOWN(m);
			return(REG_NOMATCH);
		}
		if (nmatch == 0 && !g->backrefs)
			break;		/* no further info needed */

		/* where? */
		assert(m->coldp != NULL);
		for (;;) {
			NOTE("finding start");
			endp = slow(m, m->coldp, stop, gf, gl);
			if (endp != NULL)
				break;
			assert(m->coldp < m->endp);
			m->coldp += XMBRTOWC(NULL, m->coldp,
			    m->endp - m->coldp, &m->mbs, 0);
		}
		if (nmatch == 1 && !g->backrefs)
			break;		/* no further info needed */

		/* oh my, he wants the subexpressions... */
		if (m->pmatch == NULL)
			m->pmatch = (regmatch_t *)malloc((m->g->nsub + 1) *
							sizeof(regmatch_t));
		if (m->pmatch == NULL) {
			STATETEARDOWN(m);
			return(REG_ESPACE);
		}
		for (i = 1; i <= m->g->nsub; i++)
			m->pmatch[i].rm_so = m->pmatch[i].rm_eo = -1;
		if (!g->backrefs && !(m->eflags&REG_BACKR)) {
			NOTE("dissecting");
			dp = dissect(m, m->coldp, endp, gf, gl);
		} else {
			if (g->nplus > 0 && m->lastpos == NULL)
				m->lastpos = malloc((g->nplus+1) *
						sizeof(const char *));
			if (g->nplus > 0 && m->lastpos == NULL) {
				free(m->pmatch);
				STATETEARDOWN(m);
				return(REG_ESPACE);
			}
			NOTE("backref dissect");
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0, 0);
		}
		if (dp != NULL)
			break;

		/* uh-oh... we couldn't find a subexpression-level match */
		assert(g->backrefs);	/* must be back references doing it */
		assert(g->nplus == 0 || m->lastpos != NULL);
		for (;;) {
			if (dp != NULL || endp <= m->coldp)
				break;		/* defeat */
			NOTE("backoff");
			endp = slow(m, m->coldp, endp-1, gf, gl);
			if (endp == NULL)
				break;		/* defeat */
			/* try it on a shorter possibility */
#ifndef NDEBUG
			for (i = 1; i <= m->g->nsub; i++) {
				assert(m->pmatch[i].rm_so == -1);
				assert(m->pmatch[i].rm_eo == -1);
			}
#endif
			NOTE("backoff dissect");
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0, 0);
		}
		assert(dp == NULL || dp == endp);
		if (dp != NULL)		/* found a shorter one */
			break;

		/* despite initial appearances, there is no match here */
		NOTE("false alarm");
		/* recycle starting later */
		start = m->coldp + XMBRTOWC(NULL, m->coldp,
		    stop - m->coldp, &m->mbs, 0);
		assert(start <= stop);
	}

	/* fill in the details if requested */
	if (nmatch > 0) {
		pmatch[0].rm_so = m->coldp - m->offp;
		pmatch[0].rm_eo = endp - m->offp;
	}
	if (nmatch > 1) {
		assert(m->pmatch != NULL);
		for (i = 1; i < nmatch; i++)
			if (i <= m->g->nsub)
				pmatch[i] = m->pmatch[i];
			else {
				pmatch[i].rm_so = -1;
				pmatch[i].rm_eo = -1;
			}
	}

	if (m->pmatch != NULL)
		free((char *)m->pmatch);
	if (m->lastpos != NULL)
		free((char *)m->lastpos);
	STATETEARDOWN(m);
	return(0);
}

/*
 - dissect - figure out what matched what, no back references
 == static const char *dissect(struct match *m, const char *start, \
 ==	const char *stop, sopno startst, sopno stopst);
 */
static const char *		/* == stop (success) always */
dissect(struct match *m,
	const char *start,
	const char *stop,
	sopno startst,
	sopno stopst)
{
	int i;
	sopno ss;		/* start sop of current subRE */
	sopno es;		/* end sop of current subRE */
	const char *sp;		/* start of string matched by it */
	const char *stp;	/* string matched by it cannot pass here */
	const char *rest;	/* start of rest of string */
	const char *tail;	/* string unmatched by rest of RE */
	sopno ssub;		/* start sop of subsubRE */
	sopno esub;		/* end sop of subsubRE */
	const char *ssp;	/* start of string matched by subsubRE */
	const char *sep;	/* end of string matched by subsubRE */
	const char *oldssp;	/* previous ssp */
	const char *dp __attribute__ ((unused));

	AT("diss", start, stop, startst, stopst);
	sp = start;
	for (ss = startst; ss < stopst; ss = es) {
		/* identify end of subRE */
		es = ss;
		switch (OP(m->g->strip[es])) {
		case OPLUS_:
		case OQUEST_:
			es += OPND(m->g->strip[es]);
			break;
		case OCH_:
			while (OP(m->g->strip[es]) != O_CH)
				es += OPND(m->g->strip[es]);
			break;
		}
		es++;

		/* figure out what it matched */
		switch (OP(m->g->strip[ss])) {
		case OEND:
			assert(nope);
			break;
		case OCHAR:
			sp += XMBRTOWC(NULL, sp, stop - start, &m->mbs, 0);
			break;
		case OBOL:
		case OEOL:
		case OBOW:
		case OEOW:
			break;
		case OANY:
		case OANYOF:
			sp += XMBRTOWC(NULL, sp, stop - start, &m->mbs, 0);
			break;
		case OBACK_:
		case O_BACK:
			assert(nope);
			break;
		/* cases where length of match is hard to find */
		case OQUEST_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = es - 1;
			/* did innards match? */
			if (slow(m, sp, rest, ssub, esub) != NULL) {
				dp = dissect(m, sp, rest, ssub, esub);
				assert(dp == rest);
			} else		/* no */
				assert(sp == rest);
			sp = rest;
			break;
		case OPLUS_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = es - 1;
			ssp = sp;
			oldssp = ssp;
			for (;;) {	/* find last match of innards */
				sep = slow(m, ssp, rest, ssub, esub);
				if (sep == NULL || sep == ssp)
					break;	/* failed or matched null */
				oldssp = ssp;	/* on to next try */
				ssp = sep;
			}
			if (sep == NULL) {
				/* last successful match */
				sep = ssp;
				ssp = oldssp;
			}
			assert(sep == rest);	/* must exhaust substring */
			assert(slow(m, ssp, sep, ssub, esub) == rest);
			dp = dissect(m, ssp, sep, ssub, esub);
			assert(dp == sep);
			sp = rest;
			break;
		case OCH_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = ss + OPND(m->g->strip[ss]) - 1;
			assert(OP(m->g->strip[esub]) == OOR1);
			for (;;) {	/* find first matching branch */
				if (slow(m, sp, rest, ssub, esub) == rest)
					break;	/* it matched all of it */
				/* that one missed, try next one */
				assert(OP(m->g->strip[esub]) == OOR1);
				esub++;
				assert(OP(m->g->strip[esub]) == OOR2);
				ssub = esub + 1;
				esub += OPND(m->g->strip[esub]);
				if (OP(m->g->strip[esub]) == OOR2)
					esub--;
				else
					assert(OP(m->g->strip[esub]) == O_CH);
			}
			dp = dissect(m, sp, rest, ssub, esub);
			assert(dp == rest);
			sp = rest;
			break;
		case O_PLUS:
		case O_QUEST:
		case OOR1:
		case OOR2:
		case O_CH:
			assert(nope);
			break;
		case OLPAREN:
			i = OPND(m->g->strip[ss]);
			assert(0 < i && i <= m->g->nsub);
			m->pmatch[i].rm_so = sp - m->offp;
			break;
		case ORPAREN:
			i = OPND(m->g->strip[ss]);
			assert(0 < i && i <= m->g->nsub);
			m->pmatch[i].rm_eo = sp - m->offp;
			break;
		default:		/* uh oh */
			assert(nope);
			break;
		}
	}

	assert(sp == stop);
	return(sp);
}

/*
 - backref - figure out what matched what, figuring in back references
 == static const char *backref(struct match *m, const char *start, \
 ==	const char *stop, sopno startst, sopno stopst, sopno lev);
 */
static const char *		/* == stop (success) or NULL (failure) */
backref(struct match *m,
	const char *start,
	const char *stop,
	sopno startst,
	sopno stopst,
	sopno lev,		/* PLUS nesting level */
	int rec)
{
	int i;
	sopno ss;		/* start sop of current subRE */
	const char *sp;		/* start of string matched by it */
	sopno ssub;		/* start sop of subsubRE */
	sopno esub;		/* end sop of subsubRE */
	const char *ssp;	/* start of string matched by subsubRE */
	const char *dp;
	size_t len;
	int hard;
	sop s;
	regoff_t offsave;
	cset *cs;
	wint_t wc;

	AT("back", start, stop, startst, stopst);
	sp = start;

	/* get as far as we can with easy stuff */
	hard = 0;
	for (ss = startst; !hard && ss < stopst; ss++)
		switch (OP(s = m->g->strip[ss])) {
		case OCHAR:
			if (sp == stop)
				return(NULL);
			sp += XMBRTOWC(&wc, sp, stop - sp, &m->mbs, BADCHAR);
			if (wc != OPND(s))
				return(NULL);
			break;
		case OANY:
			if (sp == stop)
				return(NULL);
			sp += XMBRTOWC(&wc, sp, stop - sp, &m->mbs, BADCHAR);
			if (wc == BADCHAR)
				return (NULL);
			break;
		case OANYOF:
			if (sp == stop)
				return (NULL);
			cs = &m->g->sets[OPND(s)];
			sp += XMBRTOWC(&wc, sp, stop - sp, &m->mbs, BADCHAR);
			if (wc == BADCHAR || !CHIN(cs, wc))
				return(NULL);
			break;
		case OBOL:
			if ( (sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
					(sp < m->endp && *(sp-1) == '\n' &&
						(m->g->cflags&REG_NEWLINE)) )
				{ /* yes */ }
			else
				return(NULL);
			break;
		case OEOL:
			if ( (sp == m->endp && !(m->eflags&REG_NOTEOL)) ||
					(sp < m->endp && *sp == '\n' &&
						(m->g->cflags&REG_NEWLINE)) )
				{ /* yes */ }
			else
				return(NULL);
			break;
		case OBOW:
			if (( (sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
					(sp < m->endp && *(sp-1) == '\n' &&
						(m->g->cflags&REG_NEWLINE)) ||
					(sp > m->beginp &&
							!ISWORD(*(sp-1))) ) &&
					(sp < m->endp && ISWORD(*sp)) )
				{ /* yes */ }
			else
				return(NULL);
			break;
		case OEOW:
			if (( (sp == m->endp && !(m->eflags&REG_NOTEOL)) ||
					(sp < m->endp && *sp == '\n' &&
						(m->g->cflags&REG_NEWLINE)) ||
					(sp < m->endp && !ISWORD(*sp)) ) &&
					(sp > m->beginp && ISWORD(*(sp-1))) )
				{ /* yes */ }
			else
				return(NULL);
			break;
		case O_QUEST:
			break;
		case OOR1:	/* matches null but needs to skip */
			ss++;
			s = m->g->strip[ss];
			do {
				assert(OP(s) == OOR2);
				ss += OPND(s);
			} while (OP(s = m->g->strip[ss]) != O_CH);
			/* note that the ss++ gets us past the O_CH */
			break;
		default:	/* have to make a choice */
			hard = 1;
			break;
		}
	if (!hard) {		/* that was it! */
		if (sp != stop)
			return(NULL);
		return(sp);
	}
	ss--;			/* adjust for the for's final increment */

	/* the hard stuff */
	AT("hard", sp, stop, ss, stopst);
	s = m->g->strip[ss];
	switch (OP(s)) {
	case OBACK_:		/* the vilest depths */
		i = OPND(s);
		assert(0 < i && i <= m->g->nsub);
		if (m->pmatch[i].rm_eo == -1)
			return(NULL);
		assert(m->pmatch[i].rm_so != -1);
		len = m->pmatch[i].rm_eo - m->pmatch[i].rm_so;
		if (len == 0 && rec++ > MAX_RECURSION)
			return(NULL);
		assert(stop - m->beginp >= len);
		if (sp > stop - len)
			return(NULL);	/* not enough left to match */
		ssp = m->offp + m->pmatch[i].rm_so;
		if (memcmp(sp, ssp, len) != 0)
			return(NULL);
		while (m->g->strip[ss] != SOP(O_BACK, i))
			ss++;
		return(backref(m, sp+len, stop, ss+1, stopst, lev, rec));
		break;
	case OQUEST_:		/* to null or not */
		dp = backref(m, sp, stop, ss+1, stopst, lev, rec);
		if (dp != NULL)
			return(dp);	/* not */
		return(backref(m, sp, stop, ss+OPND(s)+1, stopst, lev, rec));
		break;
	case OPLUS_:
		assert(m->lastpos != NULL);
		assert(lev+1 <= m->g->nplus);
		m->lastpos[lev+1] = sp;
		return(backref(m, sp, stop, ss+1, stopst, lev+1, rec));
		break;
	case O_PLUS:
		if (sp == m->lastpos[lev])	/* last pass matched null */
			return(backref(m, sp, stop, ss+1, stopst, lev-1, rec));
		/* try another pass */
		m->lastpos[lev] = sp;
		dp = backref(m, sp, stop, ss-OPND(s)+1, stopst, lev, rec);
		if (dp == NULL)
			return(backref(m, sp, stop, ss+1, stopst, lev-1, rec));
		else
			return(dp);
		break;
	case OCH_:		/* find the right one, if any */
		ssub = ss + 1;
		esub = ss + OPND(s) - 1;
		assert(OP(m->g->strip[esub]) == OOR1);
		for (;;) {	/* find first matching branch */
			dp = backref(m, sp, stop, ssub, esub, lev, rec);
			if (dp != NULL)
				return(dp);
			/* that one missed, try next one */
			if (OP(m->g->strip[esub]) == O_CH)
				return(NULL);	/* there is none */
			esub++;
			assert(OP(m->g->strip[esub]) == OOR2);
			ssub = esub + 1;
			esub += OPND(m->g->strip[esub]);
			if (OP(m->g->strip[esub]) == OOR2)
				esub--;
			else
				assert(OP(m->g->strip[esub]) == O_CH);
		}
		break;
	case OLPAREN:		/* must undo assignment if rest fails */
		i = OPND(s);
		assert(0 < i && i <= m->g->nsub);
		offsave = m->pmatch[i].rm_so;
		m->pmatch[i].rm_so = sp - m->offp;
		dp = backref(m, sp, stop, ss+1, stopst, lev, rec);
		if (dp != NULL)
			return(dp);
		m->pmatch[i].rm_so = offsave;
		return(NULL);
		break;
	case ORPAREN:		/* must undo assignment if rest fails */
		i = OPND(s);
		assert(0 < i && i <= m->g->nsub);
		offsave = m->pmatch[i].rm_eo;
		m->pmatch[i].rm_eo = sp - m->offp;
		dp = backref(m, sp, stop, ss+1, stopst, lev, rec);
		if (dp != NULL)
			return(dp);
		m->pmatch[i].rm_eo = offsave;
		return(NULL);
		break;
	default:		/* uh oh */
		assert(nope);
		break;
	}

	/* "can't happen" */
	assert(nope);
	/* NOTREACHED */
	return "shut up gcc";
}

/*
 - fast - step through the string at top speed
 == static const char *fast(struct match *m, const char *start, \
 ==	const char *stop, sopno startst, sopno stopst);
 */
static const char *		/* where tentative match ended, or NULL */
fast(	struct match *m,
	const char *start,
	const char *stop,
	sopno startst,
	sopno stopst)
{
	states st = m->st;
	states fresh = m->fresh;
	states tmp = m->tmp;
	const char *p = start;
	wint_t c;
	wint_t lastc;		/* previous c */
	wint_t flagch;
	int i;
	const char *coldp;	/* last p after which no match was underway */
	size_t clen;

	CLEAR(st);
	SET1(st, startst);
	SP("fast", st, *p);
	st = step(m->g, startst, stopst, st, NOTHING, st);
	ASSIGN(fresh, st);
	SP("start", st, *p);
	coldp = NULL;
	if (start == m->beginp)
		c = OUT;
	else {
		/*
		 * XXX Wrong if the previous character was multi-byte.
		 * Newline never is (in encodings supported by FreeBSD),
		 * so this only breaks the ISWORD tests below.
		 */
		c = (uch)*(start - 1);
	}
	for (;;) {
		/* next character */
		lastc = c;
		if (p == m->endp) {
			clen = 0;
			c = OUT;
		} else
			clen = XMBRTOWC(&c, p, m->endp - p, &m->mbs, BADCHAR);
		if (EQ(st, fresh))
			coldp = p;

		/* is there an EOL and/or BOL between lastc and c? */
		flagch = '\0';
		i = 0;
		if ( (lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
				(lastc == OUT && !(m->eflags&REG_NOTBOL)) ) {
			flagch = BOL;
			i = m->g->nbol;
		}
		if ( (c == '\n' && m->g->cflags&REG_NEWLINE) ||
				(c == OUT && !(m->eflags&REG_NOTEOL)) ) {
			flagch = (flagch == BOL) ? BOLEOL : EOL;
			i += m->g->neol;
		}
		if (i != 0) {
			for (; i > 0; i--)
				st = step(m->g, startst, stopst, st, flagch, st);
			SP("boleol", st, c);
		}

		/* how about a word boundary? */
		if ( (flagch == BOL || (lastc != OUT && !ISWORD(lastc))) &&
					(c != OUT && ISWORD(c)) ) {
			flagch = BOW;
		}
		if ( (lastc != OUT && ISWORD(lastc)) &&
				(flagch == EOL || (c != OUT && !ISWORD(c))) ) {
			flagch = EOW;
		}
		if (flagch == BOW || flagch == EOW) {
			st = step(m->g, startst, stopst, st, flagch, st);
			SP("boweow", st, c);
		}

		/* are we done? */
		if (ISSET(st, stopst) || p == stop || clen > stop - p)
			break;		/* NOTE BREAK OUT */

		/* no, we must deal with this character */
		ASSIGN(tmp, st);
		ASSIGN(st, fresh);
		assert(c != OUT);
		st = step(m->g, startst, stopst, tmp, c, st);
		SP("aft", st, c);
		assert(EQ(step(m->g, startst, stopst, st, NOTHING, st), st));
		p += clen;
	}

	assert(coldp != NULL);
	m->coldp = coldp;
	if (ISSET(st, stopst))
		return(p+XMBRTOWC(NULL, p, stop - p, &m->mbs, 0));
	else
		return(NULL);
}

/*
 - slow - step through the string more deliberately
 == static const char *slow(struct match *m, const char *start, \
 ==	const char *stop, sopno startst, sopno stopst);
 */
static const char *		/* where it ended */
slow(	struct match *m,
	const char *start,
	const char *stop,
	sopno startst,
	sopno stopst)
{
	states st = m->st;
	states empty = m->empty;
	states tmp = m->tmp;
	const char *p = start;
	wint_t c;
	wint_t lastc;		/* previous c */
	wint_t flagch;
	int i;
	const char *matchp;	/* last p at which a match ended */
	size_t clen;

	AT("slow", start, stop, startst, stopst);
	CLEAR(st);
	SET1(st, startst);
	SP("sstart", st, *p);
	st = step(m->g, startst, stopst, st, NOTHING, st);
	matchp = NULL;
	if (start == m->beginp)
		c = OUT;
	else {
		/*
		 * XXX Wrong if the previous character was multi-byte.
		 * Newline never is (in encodings supported by FreeBSD),
		 * so this only breaks the ISWORD tests below.
		 */
		c = (uch)*(start - 1);
	}
	for (;;) {
		/* next character */
		lastc = c;
		if (p == m->endp) {
			c = OUT;
			clen = 0;
		} else
			clen = XMBRTOWC(&c, p, m->endp - p, &m->mbs, BADCHAR);

		/* is there an EOL and/or BOL between lastc and c? */
		flagch = '\0';
		i = 0;
		if ( (lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
				(lastc == OUT && !(m->eflags&REG_NOTBOL)) ) {
			flagch = BOL;
			i = m->g->nbol;
		}
		if ( (c == '\n' && m->g->cflags&REG_NEWLINE) ||
				(c == OUT && !(m->eflags&REG_NOTEOL)) ) {
			flagch = (flagch == BOL) ? BOLEOL : EOL;
			i += m->g->neol;
		}
		if (i != 0) {
			for (; i > 0; i--)
				st = step(m->g, startst, stopst, st, flagch, st);
			SP("sboleol", st, c);
		}

		/* how about a word boundary? */
		if ( (flagch == BOL || (lastc != OUT && !ISWORD(lastc))) &&
					(c != OUT && ISWORD(c)) ) {
			flagch = BOW;
		}
		if ( (lastc != OUT && ISWORD(lastc)) &&
				(flagch == EOL || (c != OUT && !ISWORD(c))) ) {
			flagch = EOW;
		}
		if (flagch == BOW || flagch == EOW) {
			st = step(m->g, startst, stopst, st, flagch, st);
			SP("sboweow", st, c);
		}

		/* are we done? */
		if (ISSET(st, stopst))
			matchp = p;
		if (EQ(st, empty) || p == stop || clen > stop - p)
			break;		/* NOTE BREAK OUT */

		/* no, we must deal with this character */
		ASSIGN(tmp, st);
		ASSIGN(st, empty);
		assert(c != OUT);
		st = step(m->g, startst, stopst, tmp, c, st);
		SP("saft", st, c);
		assert(EQ(step(m->g, startst, stopst, st, NOTHING, st), st));
		p += clen;
	}

	return(matchp);
}


/*
 - step - map set of states reachable before char to set reachable after
 == static states step(struct re_guts *g, sopno start, sopno stop, \
 ==	states bef, int ch, states aft);
 == #define	BOL	(OUT-1)
 == #define	EOL	(BOL-1)
 == #define	BOLEOL	(BOL-2)
 == #define	NOTHING	(BOL-3)
 == #define	BOW	(BOL-4)
 == #define	EOW	(BOL-5)
 == #define	BADCHAR	(BOL-6)
 == #define	NONCHAR(c)	((c) <= OUT)
 */
static states
step(struct re_guts *g,
	sopno start,		/* start state within strip */
	sopno stop,		/* state after stop state within strip */
	states bef,		/* states reachable before */
	wint_t ch,		/* character or NONCHAR code */
	states aft)		/* states already known reachable after */
{
	cset *cs;
	sop s;
	sopno pc;
	onestate here;		/* note, macros know this name */
	sopno look;
	int i;

	for (pc = start, INIT(here, pc); pc != stop; pc++, INC(here)) {
		s = g->strip[pc];
		switch (OP(s)) {
		case OEND:
			assert(pc == stop-1);
			break;
		case OCHAR:
			/* only characters can match */
			assert(!NONCHAR(ch) || ch != OPND(s));
			if (ch == OPND(s))
				FWD(aft, bef, 1);
			break;
		case OBOL:
			if (ch == BOL || ch == BOLEOL)
				FWD(aft, bef, 1);
			break;
		case OEOL:
			if (ch == EOL || ch == BOLEOL)
				FWD(aft, bef, 1);
			break;
		case OBOW:
			if (ch == BOW)
				FWD(aft, bef, 1);
			break;
		case OEOW:
			if (ch == EOW)
				FWD(aft, bef, 1);
			break;
		case OANY:
			if (!NONCHAR(ch))
				FWD(aft, bef, 1);
			break;
		case OANYOF:
			cs = &g->sets[OPND(s)];
			if (!NONCHAR(ch) && CHIN(cs, ch))
				FWD(aft, bef, 1);
			break;
		case OBACK_:		/* ignored here */
		case O_BACK:
			FWD(aft, aft, 1);
			break;
		case OPLUS_:		/* forward, this is just an empty */
			FWD(aft, aft, 1);
			break;
		case O_PLUS:		/* both forward and back */
			FWD(aft, aft, 1);
			i = ISSETBACK(aft, OPND(s));
			BACK(aft, aft, OPND(s));
			if (!i && ISSETBACK(aft, OPND(s))) {
				/* oho, must reconsider loop body */
				pc -= OPND(s) + 1;
				INIT(here, pc);
			}
			break;
		case OQUEST_:		/* two branches, both forward */
			FWD(aft, aft, 1);
			FWD(aft, aft, OPND(s));
			break;
		case O_QUEST:		/* just an empty */
			FWD(aft, aft, 1);
			break;
		case OLPAREN:		/* not significant here */
		case ORPAREN:
			FWD(aft, aft, 1);
			break;
		case OCH_:		/* mark the first two branches */
			FWD(aft, aft, 1);
			assert(OP(g->strip[pc+OPND(s)]) == OOR2);
			FWD(aft, aft, OPND(s));
			break;
		case OOR1:		/* done a branch, find the O_CH */
			if (ISSTATEIN(aft, here)) {
				for (look = 1;
						OP(s = g->strip[pc+look]) != O_CH;
						look += OPND(s))
					assert(OP(s) == OOR2);
				FWD(aft, aft, look + 1);
			}
			break;
		case OOR2:		/* propagate OCH_'s marking */
			FWD(aft, aft, 1);
			if (OP(g->strip[pc+OPND(s)]) != O_CH) {
				assert(OP(g->strip[pc+OPND(s)]) == OOR2);
				FWD(aft, aft, OPND(s));
			}
			break;
		case O_CH:		/* just empty */
			FWD(aft, aft, 1);
			break;
		default:		/* ooooops... */
			assert(nope);
			break;
		}
	}

	return(aft);
}

#ifdef REDEBUG
/*
 - print - print a set of states
 == #ifdef REDEBUG
 == static void print(struct match *m, const char *caption, states st, \
 ==	int ch, FILE *d);
 == #endif
 */
static void
print(struct match *m,
	const char *caption,
	states st,
	int ch,
	FILE *d)
{
	struct re_guts *g = m->g;
	int i;
	int first = 1;

	if (!(m->eflags&REG_TRACE))
		return;

	fprintf(d, "%s", caption);
	if (ch != '\0')
		fprintf(d, " %s", pchar(ch));
	for (i = 0; i < g->nstates; i++)
		if (ISSET(st, i)) {
			fprintf(d, "%s%d", (first) ? "\t" : ", ", i);
			first = 0;
		}
	fprintf(d, "\n");
}

/*
 - at - print current situation
 == #ifdef REDEBUG
 == static void at(struct match *m, const char *title, const char *start, \
 ==			 const char *stop, sopno startst, sopno stopst);
 == #endif
 */
static void
at(	struct match *m,
	const char *title,
	const char *start,
	const char *stop,
	sopno startst,
	sopno stopst)
{
	if (!(m->eflags&REG_TRACE))
		return;

	printf("%s %s-", title, pchar(*start));
	printf("%s ", pchar(*stop));
	printf("%ld-%ld\n", (long)startst, (long)stopst);
}

#ifndef PCHARDONE
#define	PCHARDONE	/* never again */
/*
 - pchar - make a character printable
 == #ifdef REDEBUG
 == static const char *pchar(int ch);
 == #endif
 *
 * Is this identical to regchar() over in debug.c?  Well, yes.  But a
 * duplicate here avoids having a debugging-capable regexec.o tied to
 * a matching debug.o, and this is convenient.  It all disappears in
 * the non-debug compilation anyway, so it doesn't matter much.
 */
static const char *		/* -> representation */
pchar(int ch)
{
	static char pbuf[10];

	if (isprint((uch)ch) || ch == ' ')
		sprintf(pbuf, "%c", ch);
	else
		sprintf(pbuf, "\\%o", ch);
	return(pbuf);
}
#endif
#endif

#undef	matcher
#undef	fast
#undef	slow
#undef	dissect
#undef	backref
#undef	step
#undef	print
#undef	at
#undef	match
@


1.6
log
@	* regex/engine.c (step): Drop Cygwin-specific definition.
	(NONCHAR): Better cast here to make the test work.  Move comment
	from step here.
	(matcher): Disable skipping initial string in multibyte case.
	* regex/regcomp.c (p_bracket): Don't simplify singleton in the invert
	case.
	(p_b_term): Handle early end of pattern after dash in bracket
	expression.
	(singleton): Don't ignore the wides just because there's already a
	singleton in the single byte chars.  Fix condition for a singleton
	wide accordingly.
	(findmust): Check for LC_CTYPE charset, rather than LC_COLLATE charset.
	* regex2.h (CHIN): Fix condition in the icase & invert case.
	(ISWORD): Fix wrong cast to unsigned char.
@
text
@d163 1
a163 1
	const char *dp;
d394 1
a394 1
	const char *dp;
@


1.6.6.1
log
@	* dlfcn.cc (dlopen): Change cast to accommodate type change in ntdll.h
	* fhandler_process.cc (thread_info::thread_info): Change type of local
	variable size to ULONG to match NtQuerySystemInformation call.
	Add cast to avoid compiler warnings.
	(get_process_state): Add cast to avoid compiler warnings.  Accommodate
	name change of NextEntryOffset member of PSYSTEM_PROCESS_INFORMATION
	structure.
	* mmap.cc: Add casts to avoid compiler warnings.
	(mlock): Change type of local variables min and max to match
	GetProcessWorkingSetSize call.
	* nlsfuncs.cc (__collate_range_cmp): Add casts to avoid compiler
	warnings.
	* ntdll.h: Drop accommodations for Mingw32.  Fix a couple of formatting
	glitches.  Add a comment to all structures explicitely tested on 64 bit.
	(SYSTEM_INFORMATION_CLASS): Change SystemProcessesAndThreadsInformation
	to SystemProcessInformation and SystemProcessorTimes to
	SystemProcessorPerformanceInformation to match MSDN.
	(SYSTEM_BASIC_INFORMATION): Fix member types to match 64 bit.
	(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION): Rename from
	SYSTEM_PROCESSOR_TIMES to use official name from MSDN.  Accommodate
	throughout.  Drop unneeded align attribute.
	(VM_COUNTERS): Fix member types to match 64 bit.
	(SYSTEM_PROCESS_INFORMATION): Rename from SYSTEM_PROCESSES to use
	official name from MSDN.  Fix member types to match 64 bit.  Change
	member names to match MSDN and Mingw64.  Accommodate throughout.
	(IO_STATUS_BLOCK): Change to use MSDN definition.
	(SYSTEM_TIMEOFDAY_INFORMATION): Rename from
	SYSTEM_TIME_OF_DAY_INFORMATION to use official name from MSDN.
	Accommodate throughout.  Add Reserved1 area per MSDN.
	(LDR_DATA_TABLE_ENTRY): Add comment for future reference.  Change
	type of LoadCount to USHORT.
	(PEB_LDR_DATA): Change type of Initialized to BOOLEAN.  Add comment for
	future reference.
	(PEB): Fix member types to match 64 bit.
	(GDI_TEB_BATCH): New type.
	(TEB): Fix member types to match 64 bit.
	(PROCESS_BASIC_INFORMATION): Ditto.
	(MEMORY_WORKING_SET_LIST): Ditto.
	(SharedUserData): Change comment to note the fact that the address
	is valid on 32 and 64 bit.
	* pinfo.cc (winpids::enum_processes): Add cast to avoid compiler
	warnings.
	* select.cc (pipe_data_available): Add braces in initalization of an
	IO_STATUS_BLOCK to match new definition.
	* wincap.h (class wincapc): Change type of wow64 to ULONG_PTR to match
	MSDN description.
	(wincapc::is_wow64): Convert return value explicitely to bool.
	* wow64.cc (wow64_test_for_64bit_parent): Change type of wow64 to
	ULONG_PTR to match MSDN description.  Add a cast to avoid compiler
	warning.
	* regex/engine.c: Avoid compiler warnings about unused and potentially
	uninitialized variables.
	* regex/regcomp.c: Ditto.  Drop unnecessary definition of LCID.
@
text
@d163 1
a163 1
	const char *dp = NULL;
d394 1
a394 1
	const char *dp __attribute__ ((unused));
@


1.5
log
@	* regex/engine.c (step): Declare and define with `int ch' rather than
	`wint_t ch' parameter.  Explain why.
	(NONCHAR): Remove related Cygwin patch here, including wrong comment.
@
text
@a108 3
#ifdef __CYGWIN__
static states step(struct re_guts *g, sopno start, sopno stop, states bef, int ch, states aft);
#else
a109 1
#endif
d118 4
a121 1
#define	NONCHAR(c)	((c) <= OUT)
d250 3
d255 1
a255 1

a997 6
#ifdef __CYGWIN__
	/* When using wint_t, which is defined as unsigned int on BSD,
	   as well as on Cygwin or Linux, the NONCHAR test is broken.
	   I'm wondering how this is supposed to work at all... */
	int ch,			/* character or NONCHAR code */
#else
a998 1
#endif
@


1.4
log
@	Replace regex files with multibyte-aware version from FreeBSD.
	* Makefile.in (install-headers): Remove extra command to install
	regex.h.
	(uninstall-headers): Remove extra command to uninstall regex.h.
	* nlsfuncs.cc (collate_lcid): Make externally available to allow
	access to collation internals from regex functions.
	(collate_charset): Ditto.
	* wchar.h: Add __cplusplus guards to make C-clean.
	* include/regex.h: New file, replacing regex/regex.h.  Remove UCB
	advertising clause.
	* regex/COPYRIGHT: Accommodate BSD license.  Remove UCB advertising
	clause.
	* regex/cclass.h: Remove.
	* regex/cname.h: New file from FreeBSD.
	* regex/engine.c: Ditto.
	(NONCHAR): Tweak for Cygwin.
	* regex/engine.ih: Remove.
	* regex/mkh: Remove.
	* regex/regcomp.c: New file from FreeBSD.  Tweak slightly for Cygwin.
	Import required collate internals from nlsfunc.cc.
	(p_ere_exp): Add GNU-specific \< and \> handling for word boundaries.
	(p_simp_re): Ditto.
	(__collate_range_cmp): Define.
	(p_b_term): Use Cygwin-specific collate internals.
	(findmust): Ditto.
	* regex/regcomp.ih: Remove.
	* regex/regerror.c: New file from FreeBSD.  Fix a few compiler warnings.
	* regex/regerror.ih: Remove.
	* regex/regex.7: New file from FreeBSD.  Remove UCB advertising clause.
	* regex/regex.h: Remove.  Replaced by include/regex.h.
	* regex/regexec.c: New file from FreeBSD.  Fix a few compiler warnings.
	* regex/regfree.c: New file from FreeBSD.
	* regex/tests: Remove.
	* regex/utils.h: New file from FreeBSD.
@
text
@d109 3
d113 1
a121 5
#ifdef __CYGWIN__
/* In contrast to BSD, wint_t on Cygwin is unsigned.  This breaks this test,
   unless the compared values are casted to signed. */
#define	NONCHAR(c)	((int)(c) <= (int)OUT)
#else
a122 1
#endif
d996 6
d1003 1
@


1.3
log
@* cygtls.cc (_cygtls::handle_threadlist_exception): Make an error fatal.
* cygtls.h (sockaddr_in): Use header rather than defining our own structure.
* exceptions.cc (_cygtls::interrupt_setup): Use exact contents of sa_mask
rather than assuming tht current sig should be masked, too.
(_cygtls::call_signal_handler): Use more aggressive locking.
* gendef (_sigbe): Wait until later before releasing incyg.
(_sigreturn): Remove more arguments to accommodate quasi-sa_sigaction support.
(_sigdelayed): Push arguments for sa_sigaction.  More work needed here.
* signal.cc (sigaction): Implement SA_NODEFER.
* tlsoffsets.h: Regenerate.

* sigproc.cc (wait_sig): Use default buffer size of Windows 9x complains.
* pinfo.cc (_onreturn::dummy_handle): Remove.
(_onreturn::h): Make this a pointer.
(_onreturn::~_onreturn): Detect whether pointer is NULL rather than value is
NULL.
(_onreturn::_onreturn): Set h to NULL initially.
(_onreturn::no_close_p_handle): Set h to NULL.
(winpids::add): Initialize onreturn with value from p.hProcess immediately.
@
text
@d1 38
d68 11
d85 5
a89 5
	char *offp;		/* offsets work from here */
	char *beginp;		/* start of string -- virtual NUL precedes */
	char *endp;		/* end of string -- virtual NUL here */
	char *coldp;		/* can be no match starting before here */
	char **lastpos;		/* [nplus+1] */
d95 1
d98 41
a138 1
#include "engine.ih"
d152 1
a152 1
 == static int matcher(register struct re_guts *g, char *string, \
d156 5
a160 6
matcher(g, string, nmatch, pmatch, eflags)
register struct re_guts *g;
char *string;
size_t nmatch;
regmatch_t pmatch[];
int eflags;
d162 2
a163 2
	register char *endp;
	register size_t i;
d165 13
a177 6
	register struct match *m = &mv;
	register char *dp;
	const register sopno gf = g->firststate+1;	/* +1 for OEND */
	const register sopno gl = g->laststate;
	char *start;
	char *stop;
d194 40
a233 6
		for (dp = start; dp < stop; dp++)
			if (*dp == g->must[0] && stop - dp >= g->mlen &&
				memcmp(dp, g->must, (size_t)g->mlen) == 0)
				break;
		if (dp == stop)		/* we didn't find g->must */
			return(REG_NOMATCH);
d250 7
d262 4
d280 2
a281 1
			m->coldp++;
d301 2
a302 2
				m->lastpos = (char **)malloc((g->nplus+1) *
							sizeof(char *));
d309 1
a309 1
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0);
d332 1
a332 1
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0);
d340 3
a342 1
		start = m->coldp + 1;	/* recycle starting later */
d372 2
a373 2
 == static char *dissect(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst);
d375 6
a380 7
static char *			/* == stop (success) always */
dissect(m, start, stop, startst, stopst)
register struct match *m;
char *start;
char *stop;
sopno startst;
sopno stopst;
d382 13
a394 13
	register int i;
	register sopno ss;	/* start sop of current subRE */
	register sopno es;	/* end sop of current subRE */
	register char *sp;	/* start of string matched by it */
	register char *stp;	/* string matched by it cannot pass here */
	register char *rest;	/* start of rest of string */
	register char *tail;	/* string unmatched by rest of RE */
	register sopno ssub;	/* start sop of subsubRE */
	register sopno esub;	/* end sop of subsubRE */
	register char *ssp;	/* start of string matched by subsubRE */
	register char *sep;	/* end of string matched by subsubRE */
	register char *oldssp;	/* previous ssp */
	register char *dp;
d419 1
a419 1
			sp++;
d428 1
a428 1
			sp++;
d559 2
a560 2
 == static char *backref(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst, sopno lev);
d562 8
a569 8
static char *			/* == stop (success) or NULL (failure) */
backref(m, start, stop, startst, stopst, lev)
register struct match *m;
char *start;
char *stop;
sopno startst;
sopno stopst;
sopno lev;			/* PLUS nesting level */
d571 13
a583 12
	register int i;
	register sopno ss;	/* start sop of current subRE */
	register char *sp;	/* start of string matched by it */
	register sopno ssub;	/* start sop of subsubRE */
	register sopno esub;	/* end sop of subsubRE */
	register char *ssp;	/* start of string matched by subsubRE */
	register char *dp;
	register size_t len;
	register int hard;
	register sop s;
	register regoff_t offsave;
	register cset *cs;
d593 4
a596 1
			if (sp == stop || *sp++ != (char)OPND(s))
d602 3
a604 1
			sp++;
d607 2
d610 2
a611 1
			if (sp == stop || !CHIN(cs, *sp++))
d684 2
d694 1
a694 1
		return(backref(m, sp+len, stop, ss+1, stopst, lev));
d697 1
a697 1
		dp = backref(m, sp, stop, ss+1, stopst, lev);
d700 1
a700 1
		return(backref(m, sp, stop, ss+OPND(s)+1, stopst, lev));
d706 1
a706 1
		return(backref(m, sp, stop, ss+1, stopst, lev+1));
d710 1
a710 1
			return(backref(m, sp, stop, ss+1, stopst, lev-1));
d713 1
a713 1
		dp = backref(m, sp, stop, ss-OPND(s)+1, stopst, lev);
d715 1
a715 1
			return(backref(m, sp, stop, ss+1, stopst, lev-1));
d724 1
a724 1
			dp = backref(m, sp, stop, ssub, esub, lev);
d745 1
a745 1
		dp = backref(m, sp, stop, ss+1, stopst, lev);
d756 1
a756 1
		dp = backref(m, sp, stop, ss+1, stopst, lev);
d770 1
a770 1
	return((char *)NULL);	/* dummy */
d775 2
a776 2
 == static char *fast(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst);
d778 6
a783 7
static char *			/* where tentative match ended, or NULL */
fast(m, start, stop, startst, stopst)
register struct match *m;
char *start;
char *stop;
sopno startst;
sopno stopst;
d785 10
a794 9
	register states st = m->st;
	register states fresh = m->fresh;
	register states tmp = m->tmp;
	register char *p = start;
	register int c = (start == m->beginp) ? OUT : *(start-1);
	register int lastc;	/* previous c */
	register int flagch;
	register int i;
	register char *coldp;	/* last p after which no match was underway */
d798 1
d803 10
d816 5
a820 1
		c = (p == m->endp) ? OUT : *p;
d858 1
a858 1
		if (ISSET(st, stopst) || p == stop)
d868 1
a868 1
		p++;
d874 1
a874 1
		return(p+1);
d881 2
a882 2
 == static char *slow(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst);
d884 6
a889 7
static char *			/* where it ended */
slow(m, start, stop, startst, stopst)
register struct match *m;
char *start;
char *stop;
sopno startst;
sopno stopst;
d891 10
a900 9
	register states st = m->st;
	register states empty = m->empty;
	register states tmp = m->tmp;
	register char *p = start;
	register int c = (start == m->beginp) ? OUT : *(start-1);
	register int lastc;	/* previous c */
	register int flagch;
	register int i;
	register char *matchp;	/* last p at which a match ended */
d908 10
d921 5
a925 1
		c = (p == m->endp) ? OUT : *p;
d963 1
a963 1
		if (EQ(st, empty) || p == stop)
d973 1
a973 1
		p++;
d982 10
a991 11
 == static states step(register struct re_guts *g, sopno start, sopno stop, \
 ==	register states bef, int ch, register states aft);
 == #define	BOL	(OUT+1)
 == #define	EOL	(BOL+1)
 == #define	BOLEOL	(BOL+2)
 == #define	NOTHING	(BOL+3)
 == #define	BOW	(BOL+4)
 == #define	EOW	(BOL+5)
 == #define	CODEMAX	(BOL+5)		// highest code used
 == #define	NONCHAR(c)	((c) > CHAR_MAX)
 == #define	NNONCHAR	(CODEMAX-CHAR_MAX)
d994 6
a999 7
step(g, start, stop, bef, ch, aft)
register struct re_guts *g;
sopno start;			/* start state within strip */
sopno stop;			/* state after stop state within strip */
register states bef;		/* states reachable before */
int ch;				/* character or NONCHAR code */
register states aft;		/* states already known reachable after */
d1001 6
a1006 6
	register cset *cs;
	register sop s;
	register sopno pc;
	register onestate here;		/* note, macros know this name */
	register sopno look;
	register long i;
d1016 2
a1017 2
			assert(!NONCHAR(ch) || ch != (char)OPND(s));
			if (ch == (char)OPND(s))
d1084 1
a1084 1
				FWD(aft, aft, look);
d1110 1
a1110 1
 == static void print(struct match *m, char *caption, states st, \
d1115 5
a1119 6
print(m, caption, st, ch, d)
struct match *m;
char *caption;
states st;
int ch;
FILE *d;
d1121 3
a1123 3
	register struct re_guts *g = m->g;
	register int i;
	register int first = 1;
d1142 2
a1143 2
 == static void at(struct match *m, char *title, char *start, char *stop, \
 ==						sopno startst, sopno stopst);
d1147 6
a1152 7
at(m, title, start, stop, startst, stopst)
struct match *m;
char *title;
char *start;
char *stop;
sopno startst;
sopno stopst;
d1167 1
a1167 1
 == static char *pchar(int ch);
d1175 2
a1176 3
static char *			/* -> representation */
pchar(ch)
int ch;
d1180 1
a1180 1
	if (isprint(ch) || ch == ' ')
@


1.2
log
@* environ.cc (environ_init): Avoid a compiler warning.
* path.cc (path_conv::check): Ditto.
* path.h (path_conv::operator int): Ditto.
* regex/engine.c: Ditto throughout.
* regex/regcomp.c: Ditto throughout.
* regex/regexec.c: Ditto throughout.
@
text
@d959 1
a959 1
/* 
@


1.1
log
@* Makefile.in (VPATH): Add regex directory.
(NM): new variable.
(OBSOLETE_FUNCTIONS): Ditto.
(NEW_FUNCTIONS): Ditto.
(install-headers): Install regex.h.
(install-man): New target.
(install): Use new target.
(DLL_OFILES): Add v8_reg* stuff.
(new-cygwin1.dll): Eliminate stamp-cygwin-lib creation.
(libcygwin.a): Remove obsolete functions from import lib.  Add new functions.
* configure.in: Detect 'nm' tool.
* configure: Regenerate.
* cygwin.din: Export posix_reg* functions.  Eliminate export of v8 reg*
functions.  This is now handled in object files themselves.
* regex/*: New files.
* regexp/v8_*.c: New files, renamed from non v8_ equivalents.
@
text
@d74 1
a74 1
	register int i;
@


1.1.2.1
log
@Merged changes from HEAD
@
text
@@

