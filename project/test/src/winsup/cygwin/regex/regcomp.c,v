head	1.17;
access;
symbols
	cygwin-1_7_35-release:1.17
	cygwin-1_7_34-release:1.17
	cygwin-1_7_33-release:1.16.2.1
	cygwin-1_7_32-release:1.16.2.1
	cygwin-1_7_31-release:1.16.2.1
	cygwin-1_7_30-release:1.16
	cygwin-1_7_29-release:1.16
	cygwin-1_7_29-release-branchpoint:1.16.0.2
	cygwin-pre-user-db:1.16
	cygwin-1_7_28-release:1.16
	cygwin-1_7_27-release:1.16
	cygwin-1_7_26-release:1.16
	cygwin-1_7_25-release:1.16
	cygwin-1_7_24-release:1.16
	cygwin-1_7_23-release:1.16
	cygwin-1_7_22-release:1.16
	cygwin-1_7_21-release:1.15
	cygwin-1_7_20-release:1.15
	cygwin-1_7_19-release:1.15
	cygwin-64bit-postmerge:1.15
	cygwin-64bit-premerge-branch:1.14.0.4
	cygwin-64bit-premerge:1.14
	cygwin-1_7_18-release:1.14
	post-ptmalloc3:1.14.2.1
	pre-ptmalloc3:1.14.2.1
	cygwin-1_7_17-release:1.14
	cygwin-64bit-branch:1.14.0.2
	cygwin-1_7_16-release:1.14
	cygwin-1_7_15-release:1.13
	cygwin-1_7_14_2-release:1.13
	cygwin-1_7_14-release:1.13
	cygwin-1_7_12-release:1.13
	cygwin-1_7_11-release:1.13
	cygwin-1_7_10-release:1.12
	signal-rewrite:1.12.0.4
	pre-notty:1.12
	cygwin-1_7_9-release:1.12
	cv-post-1_7_9:1.12.0.2
	cygwin-1_7_8-release:1.12
	cygwin-1_7_7-release:1.12
	cygwin-1_7_5-release:1.12
	cygwin-1_7_4-release:1.12
	cygwin-1_7_3-release:1.12
	cygwin-1_7_2-release:1.12
	fifo_doover3:1.5.0.4
	cygwin-1_7_1-release:1.5
	prefifo:1.5
	cv-branch-2:1.5.0.2
	pre-ripout-set_console_state_for_spawn:1.3
	EOL_registry_mounts:1.3
	preoverlapped:1.3
	drop_9x_support_start:1.3
	cr-0x5f1:1.3.0.26
	cv-branch:1.3.0.24
	pre-ptymaster-archetype:1.3
	cr-0x3b58:1.3.0.22
	cr-0x5ef:1.3.0.20
	after-mmap-privanon-noreserve:1.3
	after-mmap-revamp:1.3
	before-mmap-revamp:1.3
	cgf-more-exit-sync:1.3
	post_wait_sig_exit:1.3
	pre_wait_sig_exit:1.3
	reparent-point:1.3
	noreparent:1.3.0.18
	cr-0x5e6:1.3.0.14
	cr-0x9e:1.3.0.12
	cr-0x9d:1.3.0.10
	cgf-deleteme:1.3.0.8
	pre-sigrewrite:1.3
	corinna-01:1.3
	cr-0x9c:1.3.0.6
	cr-0x9b:1.3.0.4
	cr-0x99:1.3
	Z-emcb-cygwin_daemon:1.3.0.2
	w32api-2_2:1.3
	mingw-runtime-2_4:1.3
	pre-cgf-merge:1.3
	cgf-dev-branch:1.3.0.16
	predaemon:1.2
	cygwin_daemon_merge_HEAD:1.2
	pregp02r1:1.2.0.2
	cygnus_cvs_20020108_pre:1.1
	Z-cygwin_daemon_merge_HEAD:1.2
	cygwin_daemon:1.1.0.2
	Z-cygwin_daemon_merge-new_HEAD:1.2;
locks; strict;
comment	@ * @;


1.17
date	2014.06.23.14.33.55;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2013.07.21.19.28.45;	author corinna;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2013.04.23.09.44.35;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2012.06.11.22.15.27;	author yselkowitz;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2012.02.13.13.12.37;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.14.21.28.44;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.13.12.26.06;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.12.20.17.22;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.12.17.46.39;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.11.21.19.19;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.04.21.05.07;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.04.12.35.49;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.06.12.03.34;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.04.04.30.37;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.30.02.51.22;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.15.17.06.40;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.20.02.55.09;	author cgf;	state Exp;
branches
	1.1.2.1;
next	;

1.16.2.1
date	2014.07.15.14.34.39;	author corinna;	state Exp;
branches;
next	;

1.14.2.1
date	2012.11.12.17.26.24;	author corinna;	state Exp;
branches;
next	;

1.1.2.1
date	2002.01.04.03.56.16;	author rbcollins;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.02.28.12.53.33;	author rbcollins;	state Exp;
branches;
next	;


desc
@@


1.17
log
@	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).
@
text
@/*-
 * Copyright (c) 1992, 1993, 1994 Henry Spencer.
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Henry Spencer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)regcomp.c	8.5 (Berkeley) 3/20/94
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)regcomp.c	8.5 (Berkeley) 3/20/94";
#endif /* LIBC_SCCS and not lint */
#include <sys/cdefs.h>
__FBSDID("$FreeBSD: src/lib/libc/regex/regcomp.c,v 1.36 2007/06/11 03:05:54 delphij Exp $");

#ifdef __CYGWIN__
#include "winsup.h"
#endif
#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <stdlib.h>
#include <regex.h>
#ifndef __CYGWIN__
#include <runetype.h>
#endif
#include <wchar.h>
#include <wctype.h>

#include "collate.h"

#include "utils.h"
#include "regex2.h"

#include "cname.h"

#ifdef __CYGWIN__
/* These are defined in nlsfuncs.cc. */
extern LCID collate_lcid;
extern char collate_charset[];
#endif

/*
 * parse structure, passed up and down to avoid global variables and
 * other clumsinesses
 */
struct parse {
	char *next;		/* next character in RE */
	char *end;		/* end of string (-> NUL normally) */
	int error;		/* has an error been seen? */
	sop *strip;		/* malloced strip */
	sopno ssize;		/* malloced strip size (allocated) */
	sopno slen;		/* malloced strip length (used) */
	int ncsalloc;		/* number of csets allocated */
	struct re_guts *g;
#	define	NPAREN	10	/* we need to remember () 1-9 for back refs */
	sopno pbegin[NPAREN];	/* -> ( ([0] unused) */
	sopno pend[NPAREN];	/* -> ) ([0] unused) */
};

/* ========= begin header generated by ./mkh ========= */
#ifdef __cplusplus
extern "C" {
#endif

/* === regcomp.c === */
#ifdef __CYGWIN__ /* Defined below `int stop'.  Our gcc chokes on that. */
static void p_ere(struct parse *p, int stop);
#else
static void p_ere(struct parse *p, wint_t stop);
#endif
static void p_ere_exp(struct parse *p);
static void p_str(struct parse *p);
#ifdef __CYGWIN__ /* Defined below `int end1/end2'.  Our gcc chokes on that. */
static void p_bre(struct parse *p, int end1, int end2);
#else
static void p_bre(struct parse *p, wint_t end1, wint_t end2);
#endif
static int p_simp_re(struct parse *p, int starordinary);
static int p_count(struct parse *p);
static void p_bracket(struct parse *p);
static void p_b_term(struct parse *p, cset *cs);
static void p_b_cclass(struct parse *p, cset *cs);
static void p_b_eclass(struct parse *p, cset *cs);
static wint_t p_b_symbol(struct parse *p);
static wint_t p_b_coll_elem(struct parse *p, wint_t endc);
static wint_t othercase(wint_t ch);
static void bothcases(struct parse *p, wint_t ch);
static void ordinary(struct parse *p, wint_t ch);
static void nonnewline(struct parse *p);
static void repeat(struct parse *p, sopno start, int from, int to);
static int seterr(struct parse *p, int e);
static cset *allocset(struct parse *p);
static void freeset(struct parse *p, cset *cs);
static void CHadd(struct parse *p, cset *cs, wint_t ch);
static void CHaddrange(struct parse *p, cset *cs, wint_t min, wint_t max);
static void CHaddtype(struct parse *p, cset *cs, wctype_t wct);
static wint_t singleton(cset *cs);
static sopno dupl(struct parse *p, sopno start, sopno finish);
static void doemit(struct parse *p, sop op, size_t opnd);
static void doinsert(struct parse *p, sop op, size_t opnd, sopno pos);
static void dofwd(struct parse *p, sopno pos, sop value);
static void enlarge(struct parse *p, sopno size);
static void stripsnug(struct parse *p, struct re_guts *g);
static void findmust(struct parse *p, struct re_guts *g);
static int altoffset(sop *scan, int offset);
static void computejumps(struct parse *p, struct re_guts *g);
static void computematchjumps(struct parse *p, struct re_guts *g);
static sopno pluscount(struct parse *p, struct re_guts *g);
static wint_t wgetnext(struct parse *p);
static size_t xwcrtomb (char *s, wint_t wc, mbstate_t *ps);

#ifdef __cplusplus
}
#endif
/* ========= end header generated by ./mkh ========= */

static char nuls[10];		/* place to point scanner in event of error */

/*
 * macros for use with parse structure
 * BEWARE:  these know that the parse structure is named `p' !!!
 */
#define	PEEK()	(*p->next)
#define	PEEK2()	(*(p->next+1))
#define	MORE()	(p->next < p->end)
#define	MORE2()	(p->next+1 < p->end)
#define	SEE(c)	(MORE() && PEEK() == (c))
#define	SEETWO(a, b)	(MORE() && MORE2() && PEEK() == (a) && PEEK2() == (b))
#define	EAT(c)	((SEE(c)) ? (NEXT(), 1) : 0)
#define	EATTWO(a, b)	((SEETWO(a, b)) ? (NEXT2(), 1) : 0)
#define	NEXT()	(p->next++)
#define	NEXT2()	(p->next += 2)
#define	NEXTn(n)	(p->next += (n))
#define	GETNEXT()	(*p->next++)
#define	WGETNEXT()	wgetnext(p)
#define	SETERROR(e)	seterr(p, (e))
#define	REQUIRE(co, e)	((co) || SETERROR(e))
#define	MUSTSEE(c, e)	(REQUIRE(MORE() && PEEK() == (c), e))
#define	MUSTEAT(c, e)	(REQUIRE(MORE() && GETNEXT() == (c), e))
#define	MUSTNOTSEE(c, e)	(REQUIRE(!MORE() || PEEK() != (c), e))
#define	EMIT(op, sopnd)	doemit(p, (sop)(op), (size_t)(sopnd))
#define	INSERT(op, pos)	doinsert(p, (sop)(op), HERE()-(pos)+1, pos)
#define	AHEAD(pos)		dofwd(p, pos, HERE()-(pos))
#define	ASTERN(sop, pos)	EMIT(sop, HERE()-pos)
#define	HERE()		(p->slen)
#define	THERE()		(p->slen - 1)
#define	THERETHERE()	(p->slen - 2)
#define	DROP(n)	(p->slen -= (n))

#ifndef NDEBUG
static int never = 0;		/* for use in asserts; shuts lint up */
#else
#define	never	0		/* some <assert.h>s have bugs too */
#endif

/* Macro used by computejump()/computematchjump() */
#define MIN(a,b)	((a)<(b)?(a):(b))

/*
 - regcomp - interface for parser and compilation
 = extern int regcomp(regex_t *, const char *, int);
 = #define	REG_BASIC	0000
 = #define	REG_EXTENDED	0001
 = #define	REG_ICASE	0002
 = #define	REG_NOSUB	0004
 = #define	REG_NEWLINE	0010
 = #define	REG_NOSPEC	0020
 = #define	REG_PEND	0040
 = #define	REG_DUMP	0200
 */
int				/* 0 success, otherwise REG_something */
regcomp(regex_t * __restrict preg,
	const char * __restrict pattern,
	int cflags)
{
	struct parse pa;
	struct re_guts *g;
	struct parse *p = &pa;
	int i;
	size_t len;
#ifdef REDEBUG
#	define	GOODFLAGS(f)	(f)
#else
#	define	GOODFLAGS(f)	((f)&~REG_DUMP)
#endif

	cflags = GOODFLAGS(cflags);
	if ((cflags&REG_EXTENDED) && (cflags&REG_NOSPEC))
		return(REG_INVARG);

	if (cflags&REG_PEND) {
		if (preg->re_endp < pattern)
			return(REG_INVARG);
		len = preg->re_endp - pattern;
	} else
		len = strlen((char *)pattern);

	/* do the mallocs early so failure handling is easy */
	g = (struct re_guts *)malloc(sizeof(struct re_guts));
	if (g == NULL)
		return(REG_ESPACE);
	p->ssize = len/(size_t)2*(size_t)3 + (size_t)1;	/* ugh */
	p->strip = (sop *)malloc(p->ssize * sizeof(sop));
	p->slen = 0;
	if (p->strip == NULL) {
		free((char *)g);
		return(REG_ESPACE);
	}

	/* set things up */
	p->g = g;
	p->next = (char *)pattern;	/* convenience; we do not modify it */
	p->end = p->next + len;
	p->error = 0;
	p->ncsalloc = 0;
	for (i = 0; i < NPAREN; i++) {
		p->pbegin[i] = 0;
		p->pend[i] = 0;
	}
	g->sets = NULL;
	g->ncsets = 0;
	g->cflags = cflags;
	g->iflags = 0;
	g->nbol = 0;
	g->neol = 0;
	g->must = NULL;
	g->moffset = -1;
	g->charjump = NULL;
	g->matchjump = NULL;
	g->mlen = 0;
	g->nsub = 0;
	g->backrefs = 0;

	/* do it */
	EMIT(OEND, 0);
	g->firststate = THERE();
	if (cflags&REG_EXTENDED)
		p_ere(p, OUT);
	else if (cflags&REG_NOSPEC)
		p_str(p);
	else
		p_bre(p, OUT, OUT);
	EMIT(OEND, 0);
	g->laststate = THERE();

	/* tidy up loose ends and fill things in */
	stripsnug(p, g);
	findmust(p, g);
	/* only use Boyer-Moore algorithm if the pattern is bigger
	 * than three characters
	 */
	if(g->mlen > 3) {
		computejumps(p, g);
		computematchjumps(p, g);
		if(g->matchjump == NULL && g->charjump != NULL) {
			free(g->charjump);
			g->charjump = NULL;
		}
	}
	g->nplus = pluscount(p, g);
	g->magic = MAGIC2;
	preg->re_nsub = g->nsub;
	preg->re_g = g;
	preg->re_magic = MAGIC1;
#ifndef REDEBUG
	/* not debugging, so can't rely on the assert() in regexec() */
	if (g->iflags&BAD)
		SETERROR(REG_ASSERT);
#endif

	/* win or lose, we're done */
	if (p->error != 0)	/* lose */
		regfree(preg);
	return(p->error);
}

/*
 - p_ere - ERE parser top level, concatenation and alternation
 == static void p_ere(struct parse *p, int stop);
 */
static void
p_ere(struct parse *p,
	int stop)		/* character this ERE should end at */
{
	char c;
	sopno prevback = 0;
	sopno prevfwd = 0;
	sopno conc;
	int first = 1;		/* is this the first alternative? */

	for (;;) {
		/* do a bunch of concatenated expressions */
		conc = HERE();
		while (MORE() && (c = PEEK()) != '|' && c != stop)
			p_ere_exp(p);
#ifndef __CYGWIN__
		/* undefined behaviour according to POSIX; allowed by glibc */
		(void)REQUIRE(HERE() != conc, REG_EMPTY);	/* require nonempty */
#endif

		if (!EAT('|'))
			break;		/* NOTE BREAK OUT */

		if (first) {
			INSERT(OCH_, conc);	/* offset is wrong */
			prevfwd = conc;
			prevback = conc;
			first = 0;
		}
		ASTERN(OOR1, prevback);
		prevback = THERE();
		AHEAD(prevfwd);			/* fix previous offset */
		prevfwd = HERE();
		EMIT(OOR2, 0);			/* offset is very wrong */
	}

	if (!first) {		/* tail-end fixups */
		AHEAD(prevfwd);
		ASTERN(O_CH, prevback);
	}

	assert(!MORE() || SEE(stop));
}

/*
 - p_ere_exp - parse one subERE, an atom possibly followed by a repetition op
 == static void p_ere_exp(struct parse *p);
 */
static void
p_ere_exp(struct parse *p)
{
	char c;
	wint_t wc;
	sopno pos;
	int count;
	int count2;
	sopno subno;
	int wascaret = 0;

	assert(MORE());		/* caller should have ensured this */
	c = GETNEXT();

	pos = HERE();
	switch (c) {
	case '(':
		(void)REQUIRE(MORE(), REG_EPAREN);
		p->g->nsub++;
		subno = p->g->nsub;
		if (subno < NPAREN)
			p->pbegin[subno] = HERE();
		EMIT(OLPAREN, subno);
		if (!SEE(')'))
			p_ere(p, ')');
		if (subno < NPAREN) {
			p->pend[subno] = HERE();
			assert(p->pend[subno] != 0);
		}
		EMIT(ORPAREN, subno);
		(void)MUSTEAT(')', REG_EPAREN);
		break;
#ifndef POSIX_MISTAKE
	case ')':		/* happens only if no current unmatched ( */
		/*
		 * You may ask, why the ifndef?  Because I didn't notice
		 * this until slightly too late for 1003.2, and none of the
		 * other 1003.2 regular-expression reviewers noticed it at
		 * all.  So an unmatched ) is legal POSIX, at least until
		 * we can get it fixed.
		 */
		SETERROR(REG_EPAREN);
		break;
#endif
	case '^':
		EMIT(OBOL, 0);
		p->g->iflags |= USEBOL;
		p->g->nbol++;
		wascaret = 1;
		break;
	case '$':
		EMIT(OEOL, 0);
		p->g->iflags |= USEEOL;
		p->g->neol++;
		break;
	case '|':
		SETERROR(REG_EMPTY);
		break;
	case '*':
	case '+':
	case '?':
		SETERROR(REG_BADRPT);
		break;
	case '.':
		if (p->g->cflags&REG_NEWLINE)
			nonnewline(p);
		else
			EMIT(OANY, 0);
		break;
	case '[':
		p_bracket(p);
		break;
	case '\\':
		(void)REQUIRE(MORE(), REG_EESCAPE);
		wc = WGETNEXT();
#ifdef __CYGWIN__
		/* \< and \> are the GNU equivalents to [[:<:]] and [[:>:]] */
		switch (wc)
		  {
		  case L'<':
		    EMIT(OBOW, 0);
		    break;
		  case L'>':
		    EMIT(OEOW, 0);
		    break;
		  default:
		    ordinary(p, wc);
		    break;
		  }
#else
		ordinary(p, wc);
#endif
		break;
	case '{':		/* okay as ordinary except if digit follows */
		(void)REQUIRE(!MORE() || !isdigit((uch)PEEK()), REG_BADRPT);
		/* FALLTHROUGH */
	default:
		p->next--;
		wc = WGETNEXT();
		ordinary(p, wc);
		break;
	}

	if (!MORE())
		return;
	c = PEEK();
	/* we call { a repetition if followed by a digit */
	if (!( c == '*' || c == '+' || c == '?' ||
				(c == '{' && MORE2() && isdigit((uch)PEEK2())) ))
		return;		/* no repetition, we're done */
	NEXT();

	(void)REQUIRE(!wascaret, REG_BADRPT);
	switch (c) {
	case '*':	/* implemented as +? */
		/* this case does not require the (y|) trick, noKLUDGE */
		INSERT(OPLUS_, pos);
		ASTERN(O_PLUS, pos);
		INSERT(OQUEST_, pos);
		ASTERN(O_QUEST, pos);
		break;
	case '+':
		INSERT(OPLUS_, pos);
		ASTERN(O_PLUS, pos);
		break;
	case '?':
		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
		INSERT(OCH_, pos);		/* offset slightly wrong */
		ASTERN(OOR1, pos);		/* this one's right */
		AHEAD(pos);			/* fix the OCH_ */
		EMIT(OOR2, 0);			/* offset very wrong... */
		AHEAD(THERE());			/* ...so fix it */
		ASTERN(O_CH, THERETHERE());
		break;
	case '{':
		count = p_count(p);
		if (EAT(',')) {
			if (isdigit((uch)PEEK())) {
				count2 = p_count(p);
				(void)REQUIRE(count <= count2, REG_BADBR);
			} else		/* single number with comma */
				count2 = INFINITY;
		} else		/* just a single number */
			count2 = count;
		repeat(p, pos, count, count2);
		if (!EAT('}')) {	/* error heuristics */
			while (MORE() && PEEK() != '}')
				NEXT();
			(void)REQUIRE(MORE(), REG_EBRACE);
			SETERROR(REG_BADBR);
		}
		break;
	}

	if (!MORE())
		return;
	c = PEEK();
	if (!( c == '*' || c == '+' || c == '?' ||
				(c == '{' && MORE2() && isdigit((uch)PEEK2())) ) )
		return;
	SETERROR(REG_BADRPT);
}

/*
 - p_str - string (no metacharacters) "parser"
 == static void p_str(struct parse *p);
 */
static void
p_str(struct parse *p)
{
	(void)REQUIRE(MORE(), REG_EMPTY);
	while (MORE())
		ordinary(p, WGETNEXT());
}

/*
 - p_bre - BRE parser top level, anchoring and concatenation
 == static void p_bre(struct parse *p, int end1, \
 ==	int end2);
 * Giving end1 as OUT essentially eliminates the end1/end2 check.
 *
 * This implementation is a bit of a kludge, in that a trailing $ is first
 * taken as an ordinary character and then revised to be an anchor.
 * The amount of lookahead needed to avoid this kludge is excessive.
 */
static void
p_bre(struct parse *p,
	int end1,		/* first terminating character */
	int end2)		/* second terminating character */
{
	sopno start = HERE();
	int first = 1;			/* first subexpression? */
	int wasdollar = 0;

	if (EAT('^')) {
		EMIT(OBOL, 0);
		p->g->iflags |= USEBOL;
		p->g->nbol++;
	}
	while (MORE() && !SEETWO(end1, end2)) {
		wasdollar = p_simp_re(p, first);
		first = 0;
	}
	if (wasdollar) {	/* oops, that was a trailing anchor */
		DROP(1);
		EMIT(OEOL, 0);
		p->g->iflags |= USEEOL;
		p->g->neol++;
	}

	(void)REQUIRE(HERE() != start, REG_EMPTY);	/* require nonempty */
}

/*
 - p_simp_re - parse a simple RE, an atom possibly followed by a repetition
 == static int p_simp_re(struct parse *p, int starordinary);
 */
static int			/* was the simple RE an unbackslashed $? */
p_simp_re(struct parse *p,
	int starordinary)	/* is a leading * an ordinary character? */
{
	int c;
	int count;
	int count2;
	sopno pos;
	int i;
	wint_t wc;
	sopno subno;
#	define	BACKSL	(1<<CHAR_BIT)

	pos = HERE();		/* repetion op, if any, covers from here */

	assert(MORE());		/* caller should have ensured this */
	c = GETNEXT();
	if (c == '\\') {
		(void)REQUIRE(MORE(), REG_EESCAPE);
		c = BACKSL | GETNEXT();
	}
	switch (c) {
	case '.':
		if (p->g->cflags&REG_NEWLINE)
			nonnewline(p);
		else
			EMIT(OANY, 0);
		break;
	case '[':
		p_bracket(p);
		break;
#ifdef __CYGWIN__
	case BACKSL|'<':
		/* \< is the GNU equivalents to [[:<:]] */
		EMIT(OBOW, 0);
		break;
	case BACKSL|'>':
		/* \> is the GNU equivalents to [[:>:]] */
		EMIT(OEOW, 0);
		break;
#endif
	case BACKSL|'{':
		SETERROR(REG_BADRPT);
		break;
	case BACKSL|'(':
		p->g->nsub++;
		subno = p->g->nsub;
		if (subno < NPAREN)
			p->pbegin[subno] = HERE();
		EMIT(OLPAREN, subno);
		/* the MORE here is an error heuristic */
		if (MORE() && !SEETWO('\\', ')'))
			p_bre(p, '\\', ')');
		if (subno < NPAREN) {
			p->pend[subno] = HERE();
			assert(p->pend[subno] != 0);
		}
		EMIT(ORPAREN, subno);
		(void)REQUIRE(EATTWO('\\', ')'), REG_EPAREN);
		break;
	case BACKSL|')':	/* should not get here -- must be user */
	case BACKSL|'}':
		SETERROR(REG_EPAREN);
		break;
	case BACKSL|'1':
	case BACKSL|'2':
	case BACKSL|'3':
	case BACKSL|'4':
	case BACKSL|'5':
	case BACKSL|'6':
	case BACKSL|'7':
	case BACKSL|'8':
	case BACKSL|'9':
		i = (c&~BACKSL) - '0';
		assert(i < NPAREN);
		if (p->pend[i] != 0) {
			assert(i <= p->g->nsub);
			EMIT(OBACK_, i);
			assert(p->pbegin[i] != 0);
			assert(OP(p->strip[p->pbegin[i]]) == OLPAREN);
			assert(OP(p->strip[p->pend[i]]) == ORPAREN);
			(void) dupl(p, p->pbegin[i]+1, p->pend[i]);
			EMIT(O_BACK, i);
		} else
			SETERROR(REG_ESUBREG);
		p->g->backrefs = 1;
		break;
	case '*':
		(void)REQUIRE(starordinary, REG_BADRPT);
		/* FALLTHROUGH */
	default:
		p->next--;
		wc = WGETNEXT();
		ordinary(p, wc);
		break;
	}

	if (EAT('*')) {		/* implemented as +? */
		/* this case does not require the (y|) trick, noKLUDGE */
		INSERT(OPLUS_, pos);
		ASTERN(O_PLUS, pos);
		INSERT(OQUEST_, pos);
		ASTERN(O_QUEST, pos);
	} else if (EATTWO('\\', '{')) {
		count = p_count(p);
		if (EAT(',')) {
			if (MORE() && isdigit((uch)PEEK())) {
				count2 = p_count(p);
				(void)REQUIRE(count <= count2, REG_BADBR);
			} else		/* single number with comma */
				count2 = INFINITY;
		} else		/* just a single number */
			count2 = count;
		repeat(p, pos, count, count2);
		if (!EATTWO('\\', '}')) {	/* error heuristics */
			while (MORE() && !SEETWO('\\', '}'))
				NEXT();
			(void)REQUIRE(MORE(), REG_EBRACE);
			SETERROR(REG_BADBR);
		}
	} else if (c == '$')     /* $ (but not \$) ends it */
		return(1);

	return(0);
}

/*
 - p_count - parse a repetition count
 == static int p_count(struct parse *p);
 */
static int			/* the value */
p_count(struct parse *p)
{
	int count = 0;
	int ndigits = 0;

	while (MORE() && isdigit((uch)PEEK()) && count <= DUPMAX) {
		count = count*10 + (GETNEXT() - '0');
		ndigits++;
	}

	(void)REQUIRE(ndigits > 0 && count <= DUPMAX, REG_BADBR);
	return(count);
}

/*
 - p_bracket - parse a bracketed character list
 == static void p_bracket(struct parse *p);
 */
static void
p_bracket(struct parse *p)
{
	cset *cs;
	wint_t ch;

	/* Dept of Truly Sickening Special-Case Kludges */
	if (p->next + 5 < p->end && strncmp(p->next, "[:<:]]", 6) == 0) {
		EMIT(OBOW, 0);
		NEXTn(6);
		return;
	}
	if (p->next + 5 < p->end && strncmp(p->next, "[:>:]]", 6) == 0) {
		EMIT(OEOW, 0);
		NEXTn(6);
		return;
	}

	if ((cs = allocset(p)) == NULL)
		return;

	if (p->g->cflags&REG_ICASE)
		cs->icase = 1;
	if (EAT('^'))
		cs->invert = 1;
	if (EAT(']'))
		CHadd(p, cs, ']');
	else if (EAT('-'))
		CHadd(p, cs, '-');
	while (MORE() && PEEK() != ']' && !SEETWO('-', ']'))
		p_b_term(p, cs);
	if (EAT('-'))
		CHadd(p, cs, '-');
	(void)MUSTEAT(']', REG_EBRACK);

	if (p->error != 0)	/* don't mess things up further */
		return;

	if (cs->invert && p->g->cflags&REG_NEWLINE)
		cs->bmp['\n' >> 3] |= 1 << ('\n' & 7);

	if ((ch = singleton(cs)) != OUT		/* optimize singleton sets */
	     && cs->invert == 0) {		/* But not in invert case. */
		ordinary(p, ch);
		freeset(p, cs);
	} else
		EMIT(OANYOF, (int)(cs - p->g->sets));
}

/*
 - p_b_term - parse one term of a bracketed character list
 == static void p_b_term(struct parse *p, cset *cs);
 */
static void
p_b_term(struct parse *p, cset *cs)
{
	char c;
	wint_t start, finish;
	wint_t i;

	/* classify what we've got */
	switch ((MORE()) ? PEEK() : '\0') {
	case '[':
		c = (MORE2()) ? PEEK2() : '\0';
		break;
	case '-':
		SETERROR(REG_ERANGE);
		return;			/* NOTE RETURN */
		break;
	default:
		c = '\0';
		break;
	}

	switch (c) {
	case ':':		/* character class */
		NEXT2();
		(void)REQUIRE(MORE(), REG_EBRACK);
		c = PEEK();
		(void)REQUIRE(c != '-' && c != ']', REG_ECTYPE);
		p_b_cclass(p, cs);
		(void)REQUIRE(MORE(), REG_EBRACK);
		(void)REQUIRE(EATTWO(':', ']'), REG_ECTYPE);
		break;
	case '=':		/* equivalence class */
		NEXT2();
		(void)REQUIRE(MORE(), REG_EBRACK);
		c = PEEK();
		(void)REQUIRE(c != '-' && c != ']', REG_ECOLLATE);
		p_b_eclass(p, cs);
		(void)REQUIRE(MORE(), REG_EBRACK);
		(void)REQUIRE(EATTWO('=', ']'), REG_ECOLLATE);
		break;
	default:		/* symbol, ordinary character, or range */
		start = p_b_symbol(p);
		if (SEE('-') && MORE2() && PEEK2() != ']') {
			/* range */
			NEXT();
			if (EAT('-'))
				finish = '-';
			else
				finish = p_b_symbol(p);
		} else if (SEE('-') && !MORE2()) {
			SETERROR(REG_EBRACK);
			return;
		} else
			finish = start;
		if (start == finish)
			CHadd(p, cs, start);
		else {
#ifdef __CYGWIN__
			if (!collate_lcid) {
#else
			if (__collate_load_error) {
#endif
				(void)REQUIRE((uch)start <= (uch)finish, REG_ERANGE);
				CHaddrange(p, cs, start, finish);
			} else {
				(void)REQUIRE(__collate_range_cmp(start, finish) <= 0, REG_ERANGE);
				for (i = 0; i <= UCHAR_MAX; i++) {
					if (   __collate_range_cmp(start, i) <= 0
					    && __collate_range_cmp(i, finish) <= 0
					   )
						CHadd(p, cs, i);
				}
			}
		}
		break;
	}
}

/*
 - p_b_cclass - parse a character-class name and deal with it
 == static void p_b_cclass(struct parse *p, cset *cs);
 */
static void
p_b_cclass(struct parse *p, cset *cs)
{
	char *sp = p->next;
	size_t len;
	wctype_t wct;
	char clname[16];

	while (MORE() && isalpha((uch)PEEK()))
		NEXT();
	len = p->next - sp;
	if (len >= sizeof(clname) - 1) {
		SETERROR(REG_ECTYPE);
		return;
	}
	memcpy(clname, sp, len);
	clname[len] = '\0';
	if ((wct = wctype(clname)) == 0) {
		SETERROR(REG_ECTYPE);
		return;
	}
	CHaddtype(p, cs, wct);
}

/*
 - p_b_eclass - parse an equivalence-class name and deal with it
 == static void p_b_eclass(struct parse *p, cset *cs);
 *
 * This implementation is incomplete. xxx
 */
static void
p_b_eclass(struct parse *p, cset *cs)
{
	wint_t c;

	c = p_b_coll_elem(p, '=');
	CHadd(p, cs, c);
}

/*
 - p_b_symbol - parse a character or [..]ed multicharacter collating symbol
 == static char p_b_symbol(struct parse *p);
 */
static wint_t			/* value of symbol */
p_b_symbol(struct parse *p)
{
	wint_t value;

	(void)REQUIRE(MORE(), REG_EBRACK);
	if (!EATTWO('[', '.'))
		return(WGETNEXT());

	/* collating symbol */
	value = p_b_coll_elem(p, '.');
	(void)REQUIRE(EATTWO('.', ']'), REG_ECOLLATE);
	return(value);
}

/*
 - p_b_coll_elem - parse a collating-element name and look it up
 == static char p_b_coll_elem(struct parse *p, int endc);
 */
static wint_t			/* value of collating element */
p_b_coll_elem(struct parse *p,
	wint_t endc)		/* name ended by endc,']' */
{
	char *sp = p->next;
	struct cname *cp;
	int len;
	mbstate_t mbs;
	wchar_t wc;
	size_t clen;

	while (MORE() && !SEETWO(endc, ']'))
		NEXT();
	if (!MORE()) {
		SETERROR(REG_EBRACK);
		return(0);
	}
	len = p->next - sp;
	for (cp = cnames; cp->name != NULL; cp++)
		if (strncmp(cp->name, sp, len) == 0 && cp->name[len] == '\0')
			return(cp->code);	/* known name */
	memset(&mbs, 0, sizeof(mbs));
	if ((clen = mbrtowc(&wc, sp, len, &mbs)) == len)
		return (wc);			/* single character */
	else if (clen == (size_t)-1 || clen == (size_t)-2)
		SETERROR(REG_ILLSEQ);
	else
		SETERROR(REG_ECOLLATE);		/* neither */
	return(0);
}

/*
 - othercase - return the case counterpart of an alphabetic
 == static char othercase(int ch);
 */
static wint_t			/* if no counterpart, return ch */
othercase(wint_t ch)
{
	assert(iswalpha(ch));
	if (iswupper(ch))
		return(towlower(ch));
	else if (iswlower(ch))
		return(towupper(ch));
	else			/* peculiar, but could happen */
		return(ch);
}

/*
 - bothcases - emit a dualcase version of a two-case character
 == static void bothcases(struct parse *p, int ch);
 *
 * Boy, is this implementation ever a kludge...
 */
static void
bothcases(struct parse *p, wint_t ch)
{
	char *oldnext = p->next;
	char *oldend = p->end;
	char bracket[3 + MB_LEN_MAX];
	size_t n;
	mbstate_t mbs;

	assert(othercase(ch) != ch);	/* p_bracket() would recurse */
	p->next = bracket;
	memset(&mbs, 0, sizeof(mbs));
	n = xwcrtomb(bracket, ch, &mbs);
	assert(n != (size_t)-1);
	bracket[n] = ']';
	bracket[n + 1] = '\0';
	p->end = bracket+n+1;
	p_bracket(p);
	assert(p->next == p->end);
	p->next = oldnext;
	p->end = oldend;
}

/*
 - ordinary - emit an ordinary character
 == static void ordinary(struct parse *p, int ch);
 */
static void
ordinary(struct parse *p, wint_t ch)
{
	cset *cs;

	if ((p->g->cflags&REG_ICASE) && iswalpha(ch) && othercase(ch) != ch)
		bothcases(p, ch);
	else if ((ch & OPDMASK) == ch)
		EMIT(OCHAR, ch);
	else {
		/*
		 * Kludge: character is too big to fit into an OCHAR operand.
		 * Emit a singleton set.
		 */
		if ((cs = allocset(p)) == NULL)
			return;
		CHadd(p, cs, ch);
		EMIT(OANYOF, (int)(cs - p->g->sets));
	}
}

/*
 - nonnewline - emit REG_NEWLINE version of OANY
 == static void nonnewline(struct parse *p);
 *
 * Boy, is this implementation ever a kludge...
 */
static void
nonnewline(struct parse *p)
{
	char *oldnext = p->next;
	char *oldend = p->end;
	char bracket[4];

	p->next = bracket;
	p->end = bracket+3;
	bracket[0] = '^';
	bracket[1] = '\n';
	bracket[2] = ']';
	bracket[3] = '\0';
	p_bracket(p);
	assert(p->next == bracket+3);
	p->next = oldnext;
	p->end = oldend;
}

/*
 - repeat - generate code for a bounded repetition, recursively if needed
 == static void repeat(struct parse *p, sopno start, int from, int to);
 */
static void
repeat(struct parse *p,
	sopno start,		/* operand from here to end of strip */
	int from,		/* repeated from this number */
	int to)			/* to this number of times (maybe INFINITY) */
{
	sopno finish = HERE();
#	define	N	2
#	define	INF	3
#	define	REP(f, t)	((f)*8 + (t))
#	define	MAP(n)	(((n) <= 1) ? (n) : ((n) == INFINITY) ? INF : N)
	sopno copy;

	if (p->error != 0)	/* head off possible runaway recursion */
		return;

	assert(from <= to);

	switch (REP(MAP(from), MAP(to))) {
	case REP(0, 0):			/* must be user doing this */
		DROP(finish-start);	/* drop the operand */
		break;
	case REP(0, 1):			/* as x{1,1}? */
	case REP(0, N):			/* as x{1,n}? */
	case REP(0, INF):		/* as x{1,}? */
		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
		INSERT(OCH_, start);		/* offset is wrong... */
		repeat(p, start+1, 1, to);
		ASTERN(OOR1, start);
		AHEAD(start);			/* ... fix it */
		EMIT(OOR2, 0);
		AHEAD(THERE());
		ASTERN(O_CH, THERETHERE());
		break;
	case REP(1, 1):			/* trivial case */
		/* done */
		break;
	case REP(1, N):			/* as x?x{1,n-1} */
		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
		INSERT(OCH_, start);
		ASTERN(OOR1, start);
		AHEAD(start);
		EMIT(OOR2, 0);			/* offset very wrong... */
		AHEAD(THERE());			/* ...so fix it */
		ASTERN(O_CH, THERETHERE());
		copy = dupl(p, start+1, finish+1);
		assert(copy == finish+4);
		repeat(p, copy, 1, to-1);
		break;
	case REP(1, INF):		/* as x+ */
		INSERT(OPLUS_, start);
		ASTERN(O_PLUS, start);
		break;
	case REP(N, N):			/* as xx{m-1,n-1} */
		copy = dupl(p, start, finish);
		repeat(p, copy, from-1, to-1);
		break;
	case REP(N, INF):		/* as xx{n-1,INF} */
		copy = dupl(p, start, finish);
		repeat(p, copy, from-1, to);
		break;
	default:			/* "can't happen" */
		SETERROR(REG_ASSERT);	/* just in case */
		break;
	}
}

/*
 - wgetnext - helper function for WGETNEXT() macro. Gets the next wide
 - character from the parse struct, signals a REG_ILLSEQ error if the
 - character can't be converted. Returns the number of bytes consumed.
 */
static wint_t
wgetnext(struct parse *p)
{
	mbstate_t mbs;
	wchar_t wc;
	wint_t ret;
	size_t n;

#ifdef __CYGWIN__
	/* Kludge for more glibc compatibility.  On Cygwin as well as on
	   Linux, mbrtowc returns -1 if the current local's codeset is ASCII
	   and the character is >= 0x80.  Nevertheless, glibc's regcomp allows
	   any char value, even stuff like [\xc0-\xff], if the locale's codeset
	   is ASCII, so in regcomp it ignores the fact that chars >= 0x80 are
	   invalid ASCII chars.  To be more Linux-compatible, we align the
	   behaviour to glibc here.  Allow any character value if the current
	   local's codeset is ASCII. */
	if (*__locale_charset () == 'A') /* SCII */
	  return (wint_t) (unsigned char) *p->next++;
#endif
	memset(&mbs, 0, sizeof(mbs));
	n = mbrtowc(&wc, p->next, p->end - p->next, &mbs);
	if (n == (size_t)-1 || n == (size_t)-2) {
		SETERROR(REG_ILLSEQ);
		return (0);
	}
	ret = wc;
	if (n == 0)
		n = 1;
	else if (sizeof (wchar_t) == 2 && wc >= 0xd800 && wc <= 0xdbff) {
		/* UTF-16 surrogate pair.  Fetch second half and
		   compute UTF-32 value */
		size_t n2 = mbrtowc(&wc, p->next + n,
				    p->end - p->next - n, &mbs);
		if (n2 == 0 || n2 == (size_t)-1 || n2 == (size_t)-2) {
			SETERROR(REG_ILLSEQ);
			return (0);
		}
		ret = (((ret & 0x3ff) << 10) | (wc & 0x3ff))
		      + 0x10000;
		n += n2;
	  }
	p->next += n;
	return (ret);
}

static size_t
xwcrtomb (char *s, wint_t wc, mbstate_t *ps)
{
  if (sizeof (wchar_t) == 2 && wc >= 0x10000)
    {
      /* UTF-16 wcrtomb can't handle these values directly.  The rest of the
	 code isn't surrogate pair aware, so we handle this here.  Convert
	 value to UTF-16 surrogate and call wcsrtombs to convert the "string"
	 to the correct multibyte representation, if any. */
      wchar_t ws[2];
      const wchar_t *wsp = ws;

      wc -= 0x10000;
      ws[0] = 0xd800 | (wc >> 10);
      ws[1] = 0xdc00 | (wc & 0x3ff);
      return wcsnrtombs (s, &wsp, 2, MB_CUR_MAX, ps);
    }
  return wcrtomb (s, wc, ps);
}


/*
 - seterr - set an error condition
 == static int seterr(struct parse *p, int e);
 */
static int			/* useless but makes type checking happy */
seterr(struct parse *p, int e)
{
	if (p->error == 0)	/* keep earliest error condition */
		p->error = e;
	p->next = nuls;		/* try to bring things to a halt */
	p->end = nuls;
	return(0);		/* make the return value well-defined */
}

/*
 - allocset - allocate a set of characters for []
 == static cset *allocset(struct parse *p);
 */
static cset *
allocset(struct parse *p)
{
	cset *cs, *ncs;

	ncs = realloc(p->g->sets, (p->g->ncsets + 1) * sizeof(*ncs));
	if (ncs == NULL) {
		SETERROR(REG_ESPACE);
		return (NULL);
	}
	p->g->sets = ncs;
	cs = &p->g->sets[p->g->ncsets++];
	memset(cs, 0, sizeof(*cs));

	return(cs);
}

/*
 - freeset - free a now-unused set
 == static void freeset(struct parse *p, cset *cs);
 */
static void
freeset(struct parse *p, cset *cs)
{
	cset *top = &p->g->sets[p->g->ncsets];

	free(cs->wides);
	free(cs->ranges);
	free(cs->types);
	memset(cs, 0, sizeof(*cs));
	if (cs == top-1)	/* recover only the easy case */
		p->g->ncsets--;
}

/*
 - singleton - Determine whether a set contains only one character,
 - returning it if so, otherwise returning OUT.
 */
static wint_t
singleton(cset *cs)
{
	wint_t i, s, n;

	for (i = n = 0; i < NC; i++)
		if (CHIN(cs, i)) {
			n++;
			s = i;
		}
	if (n == 1 && cs->nwides == 0)
		return (s);
	if (n == 0 && cs->nwides == 1 && cs->nranges == 0 && cs->ntypes == 0 &&
	    cs->icase == 0)
		return (cs->wides[0]);
	/* Don't bother handling the other cases. */
	return (OUT);
}

/*
 - CHadd - add character to character set.
 */
static void
CHadd(struct parse *p, cset *cs, wint_t ch)
{
	wint_t nch, *newwides;
	assert(ch >= 0);
	if (ch < NC)
		cs->bmp[ch >> 3] |= 1 << (ch & 7);
	else {
		newwides = realloc(cs->wides, (cs->nwides + 1) *
		    sizeof(*cs->wides));
		if (newwides == NULL) {
			SETERROR(REG_ESPACE);
			return;
		}
		cs->wides = newwides;
		cs->wides[cs->nwides++] = ch;
	}
	if (cs->icase) {
		if ((nch = towlower(ch)) < NC)
			cs->bmp[nch >> 3] |= 1 << (nch & 7);
		if ((nch = towupper(ch)) < NC)
			cs->bmp[nch >> 3] |= 1 << (nch & 7);
	}
}

/*
 - CHaddrange - add all characters in the range [min,max] to a character set.
 */
static void
CHaddrange(struct parse *p, cset *cs, wint_t min, wint_t max)
{
	crange *newranges;

	for (; min < NC && min <= max; min++)
		CHadd(p, cs, min);
	if (min >= max)
		return;
	newranges = realloc(cs->ranges, (cs->nranges + 1) *
	    sizeof(*cs->ranges));
	if (newranges == NULL) {
		SETERROR(REG_ESPACE);
		return;
	}
	cs->ranges = newranges;
	cs->ranges[cs->nranges].min = min;
	cs->ranges[cs->nranges].min = max;
	cs->nranges++;
}

/*
 - CHaddtype - add all characters of a certain type to a character set.
 */
static void
CHaddtype(struct parse *p, cset *cs, wctype_t wct)
{
	wint_t i;
	wctype_t *newtypes;

	for (i = 0; i < NC; i++)
		if (iswctype(i, wct))
			CHadd(p, cs, i);
	newtypes = realloc(cs->types, (cs->ntypes + 1) *
	    sizeof(*cs->types));
	if (newtypes == NULL) {
		SETERROR(REG_ESPACE);
		return;
	}
	cs->types = newtypes;
	cs->types[cs->ntypes++] = wct;
}

/*
 - dupl - emit a duplicate of a bunch of sops
 == static sopno dupl(struct parse *p, sopno start, sopno finish);
 */
static sopno			/* start of duplicate */
dupl(struct parse *p,
	sopno start,		/* from here */
	sopno finish)		/* to this less one */
{
	sopno ret = HERE();
	sopno len = finish - start;

	assert(finish >= start);
	if (len == 0)
		return(ret);
	enlarge(p, p->ssize + len);	/* this many unexpected additions */
	assert(p->ssize >= p->slen + len);
	(void) memcpy((char *)(p->strip + p->slen),
		(char *)(p->strip + start), (size_t)len*sizeof(sop));
	p->slen += len;
	return(ret);
}

/*
 - doemit - emit a strip operator
 == static void doemit(struct parse *p, sop op, size_t opnd);
 *
 * It might seem better to implement this as a macro with a function as
 * hard-case backup, but it's just too big and messy unless there are
 * some changes to the data structures.  Maybe later.
 */
static void
doemit(struct parse *p, sop op, size_t opnd)
{
	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	/* deal with oversize operands ("can't happen", more or less) */
	assert(opnd < 1<<OPSHIFT);

	/* deal with undersized strip */
	if (p->slen >= p->ssize)
		enlarge(p, (p->ssize+1) / 2 * 3);	/* +50% */
	assert(p->slen < p->ssize);

	/* finally, it's all reduced to the easy case */
	p->strip[p->slen++] = SOP(op, opnd);
}

/*
 - doinsert - insert a sop into the strip
 == static void doinsert(struct parse *p, sop op, size_t opnd, sopno pos);
 */
static void
doinsert(struct parse *p, sop op, size_t opnd, sopno pos)
{
	sopno sn;
	sop s;
	int i;

	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	sn = HERE();
	EMIT(op, opnd);		/* do checks, ensure space */
	assert(HERE() == sn+1);
	s = p->strip[sn];

	/* adjust paren pointers */
	assert(pos > 0);
	for (i = 1; i < NPAREN; i++) {
		if (p->pbegin[i] >= pos) {
			p->pbegin[i]++;
		}
		if (p->pend[i] >= pos) {
			p->pend[i]++;
		}
	}

	memmove((char *)&p->strip[pos+1], (char *)&p->strip[pos],
						(HERE()-pos-1)*sizeof(sop));
	p->strip[pos] = s;
}

/*
 - dofwd - complete a forward reference
 == static void dofwd(struct parse *p, sopno pos, sop value);
 */
static void
dofwd(struct parse *p, sopno pos, sop value)
{
	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	assert(value < 1<<OPSHIFT);
	p->strip[pos] = OP(p->strip[pos]) | value;
}

/*
 - enlarge - enlarge the strip
 == static void enlarge(struct parse *p, sopno size);
 */
static void
enlarge(struct parse *p, sopno size)
{
	sop *sp;

	if (p->ssize >= size)
		return;

	sp = (sop *)realloc(p->strip, size*sizeof(sop));
	if (sp == NULL) {
		SETERROR(REG_ESPACE);
		return;
	}
	p->strip = sp;
	p->ssize = size;
}

/*
 - stripsnug - compact the strip
 == static void stripsnug(struct parse *p, struct re_guts *g);
 */
static void
stripsnug(struct parse *p, struct re_guts *g)
{
	g->nstates = p->slen;
	g->strip = (sop *)realloc((char *)p->strip, p->slen * sizeof(sop));
	if (g->strip == NULL) {
		SETERROR(REG_ESPACE);
		g->strip = p->strip;
	}
}

/*
 - findmust - fill in must and mlen with longest mandatory literal string
 == static void findmust(struct parse *p, struct re_guts *g);
 *
 * This algorithm could do fancy things like analyzing the operands of |
 * for common subsequences.  Someday.  This code is simple and finds most
 * of the interesting cases.
 *
 * Note that must and mlen got initialized during setup.
 */
static void
findmust(struct parse *p, struct re_guts *g)
{
	sop *scan;
	sop *start = NULL;
	sop *newstart = NULL;
	sopno newlen;
	sop s;
	char *cp;
	int offset;
	char buf[MB_LEN_MAX];
	size_t clen;
	mbstate_t mbs;

	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	/*
	 * It's not generally safe to do a ``char'' substring search on
	 * multibyte character strings, but it's safe for at least
	 * UTF-8 (see RFC 3629).
	 */
	if (MB_CUR_MAX > 1 &&
#ifdef __CYGWIN__
	    strcmp(__locale_charset (), "UTF-8") != 0)
#else
	    strcmp(_CurrentRuneLocale->__encoding, "UTF-8") != 0)
#endif
		return;

	/* find the longest OCHAR sequence in strip */
	newlen = 0;
	offset = 0;
	g->moffset = 0;
	scan = g->strip + 1;
	do {
		s = *scan++;
		switch (OP(s)) {
		case OCHAR:		/* sequence member */
			if (newlen == 0) {		/* new sequence */
				memset(&mbs, 0, sizeof(mbs));
				newstart = scan - 1;
			}
			clen = xwcrtomb(buf, OPND(s), &mbs);
			if (clen == (size_t)-1)
				goto toohard;
			newlen += clen;
			break;
		case OPLUS_:		/* things that don't break one */
		case OLPAREN:
		case ORPAREN:
			break;
		case OQUEST_:		/* things that must be skipped */
		case OCH_:
			offset = altoffset(scan, offset);
			scan--;
			do {
				scan += OPND(s);
				s = *scan;
				/* assert() interferes w debug printouts */
				if (OP(s) != O_QUEST && OP(s) != O_CH &&
							OP(s) != OOR2) {
					g->iflags |= BAD;
					return;
				}
			} while (OP(s) != O_QUEST && OP(s) != O_CH);
			/* FALLTHROUGH */
		case OBOW:		/* things that break a sequence */
		case OEOW:
		case OBOL:
		case OEOL:
		case O_QUEST:
		case O_CH:
		case OEND:
			if (newlen > g->mlen) {		/* ends one */
				start = newstart;
				g->mlen = newlen;
				if (offset > -1) {
					g->moffset += offset;
					offset = newlen;
				} else
					g->moffset = offset;
			} else {
				if (offset > -1)
					offset += newlen;
			}
			newlen = 0;
			break;
		case OANY:
			if (newlen > g->mlen) {		/* ends one */
				start = newstart;
				g->mlen = newlen;
				if (offset > -1) {
					g->moffset += offset;
					offset = newlen;
				} else
					g->moffset = offset;
			} else {
				if (offset > -1)
					offset += newlen;
			}
			if (offset > -1)
				offset++;
			newlen = 0;
			break;
		case OANYOF:		/* may or may not invalidate offset */
			/* First, everything as OANY */
			if (newlen > g->mlen) {		/* ends one */
				start = newstart;
				g->mlen = newlen;
				if (offset > -1) {
					g->moffset += offset;
					offset = newlen;
				} else
					g->moffset = offset;
			} else {
				if (offset > -1)
					offset += newlen;
			}
			if (offset > -1)
				offset++;
			newlen = 0;
			break;
		toohard:
		default:
			/* Anything here makes it impossible or too hard
			 * to calculate the offset -- so we give up;
			 * save the last known good offset, in case the
			 * must sequence doesn't occur later.
			 */
			if (newlen > g->mlen) {		/* ends one */
				start = newstart;
				g->mlen = newlen;
				if (offset > -1)
					g->moffset += offset;
				else
					g->moffset = offset;
			}
			offset = -1;
			newlen = 0;
			break;
		}
	} while (OP(s) != OEND);

	if (g->mlen == 0) {		/* there isn't one */
		g->moffset = -1;
		return;
	}

	/* turn it into a character string */
	g->must = malloc((size_t)g->mlen + 1);
	if (g->must == NULL) {		/* argh; just forget it */
		g->mlen = 0;
		g->moffset = -1;
		return;
	}
	cp = g->must;
	scan = start;
	memset(&mbs, 0, sizeof(mbs));
	while (cp < g->must + g->mlen) {
		while (OP(s = *scan++) != OCHAR)
			continue;
		clen = xwcrtomb(cp, OPND(s), &mbs);
		assert(clen != (size_t)-1);
		cp += clen;
	}
	assert(cp == g->must + g->mlen);
	*cp++ = '\0';		/* just on general principles */
}

/*
 - altoffset - choose biggest offset among multiple choices
 == static int altoffset(sop *scan, int offset);
 *
 * Compute, recursively if necessary, the largest offset among multiple
 * re paths.
 */
static int
altoffset(sop *scan, int offset)
{
	int largest;
	int try;
	sop s;

	/* If we gave up already on offsets, return */
	if (offset == -1)
		return -1;

	largest = 0;
	try = 0;
	s = *scan++;
	while (OP(s) != O_QUEST && OP(s) != O_CH) {
		switch (OP(s)) {
		case OOR1:
			if (try > largest)
				largest = try;
			try = 0;
			break;
		case OQUEST_:
		case OCH_:
			try = altoffset(scan, try);
			if (try == -1)
				return -1;
			scan--;
			do {
				scan += OPND(s);
				s = *scan;
				if (OP(s) != O_QUEST && OP(s) != O_CH &&
							OP(s) != OOR2)
					return -1;
			} while (OP(s) != O_QUEST && OP(s) != O_CH);
			/* We must skip to the next position, or we'll
			 * leave altoffset() too early.
			 */
			scan++;
			break;
		case OANYOF:
		case OCHAR:
		case OANY:
			try++;
		case OBOW:
		case OEOW:
		case OLPAREN:
		case ORPAREN:
		case OOR2:
			break;
		default:
			try = -1;
			break;
		}
		if (try == -1)
			return -1;
		s = *scan++;
	}

	if (try > largest)
		largest = try;

	return largest+offset;
}

/*
 - computejumps - compute char jumps for BM scan
 == static void computejumps(struct parse *p, struct re_guts *g);
 *
 * This algorithm assumes g->must exists and is has size greater than
 * zero. It's based on the algorithm found on Computer Algorithms by
 * Sara Baase.
 *
 * A char jump is the number of characters one needs to jump based on
 * the value of the character from the text that was mismatched.
 */
static void
computejumps(struct parse *p, struct re_guts *g)
{
	int ch;
	int mindex;

	/* Avoid making errors worse */
	if (p->error != 0)
		return;

	g->charjump = (int*) malloc((NC + 1) * sizeof(int));
	if (g->charjump == NULL)	/* Not a fatal error */
		return;
	/* Adjust for signed chars, if necessary */
	g->charjump = &g->charjump[-(CHAR_MIN)];

	/* If the character does not exist in the pattern, the jump
	 * is equal to the number of characters in the pattern.
	 */
	for (ch = CHAR_MIN; ch < (CHAR_MAX + 1); ch++)
		g->charjump[ch] = g->mlen;

	/* If the character does exist, compute the jump that would
	 * take us to the last character in the pattern equal to it
	 * (notice that we match right to left, so that last character
	 * is the first one that would be matched).
	 */
	for (mindex = 0; mindex < g->mlen; mindex++)
		g->charjump[(int)g->must[mindex]] = g->mlen - mindex - 1;
}

/*
 - computematchjumps - compute match jumps for BM scan
 == static void computematchjumps(struct parse *p, struct re_guts *g);
 *
 * This algorithm assumes g->must exists and is has size greater than
 * zero. It's based on the algorithm found on Computer Algorithms by
 * Sara Baase.
 *
 * A match jump is the number of characters one needs to advance based
 * on the already-matched suffix.
 * Notice that all values here are minus (g->mlen-1), because of the way
 * the search algorithm works.
 */
static void
computematchjumps(struct parse *p, struct re_guts *g)
{
	int mindex;		/* General "must" iterator */
	int suffix;		/* Keeps track of matching suffix */
	int ssuffix;		/* Keeps track of suffixes' suffix */
	int* pmatches;		/* pmatches[k] points to the next i
				 * such that i+1...mlen is a substring
				 * of k+1...k+mlen-i-1
				 */

	/* Avoid making errors worse */
	if (p->error != 0)
		return;

	pmatches = (int*) malloc(g->mlen * sizeof(unsigned int));
	if (pmatches == NULL) {
		g->matchjump = NULL;
		return;
	}

	g->matchjump = (int*) malloc(g->mlen * sizeof(unsigned int));
	if (g->matchjump == NULL)	/* Not a fatal error */
	{
		free (pmatches);
		return;
	}

	/* Set maximum possible jump for each character in the pattern */
	for (mindex = 0; mindex < g->mlen; mindex++)
		g->matchjump[mindex] = 2*g->mlen - mindex - 1;

	/* Compute pmatches[] */
	for (mindex = g->mlen - 1, suffix = g->mlen; mindex >= 0;
	    mindex--, suffix--) {
		pmatches[mindex] = suffix;

		/* If a mismatch is found, interrupting the substring,
		 * compute the matchjump for that position. If no
		 * mismatch is found, then a text substring mismatched
		 * against the suffix will also mismatch against the
		 * substring.
		 */
		while (suffix < g->mlen
		    && g->must[mindex] != g->must[suffix]) {
			g->matchjump[suffix] = MIN(g->matchjump[suffix],
			    g->mlen - mindex - 1);
			suffix = pmatches[suffix];
		}
	}

	/* Compute the matchjump up to the last substring found to jump
	 * to the beginning of the largest must pattern prefix matching
	 * it's own suffix.
	 */
	for (mindex = 0; mindex <= suffix; mindex++)
		g->matchjump[mindex] = MIN(g->matchjump[mindex],
		    g->mlen + suffix - mindex);

        ssuffix = pmatches[suffix];
        while (suffix < g->mlen) {
                while (suffix <= ssuffix && suffix < g->mlen) {
                        g->matchjump[suffix] = MIN(g->matchjump[suffix],
			    g->mlen + ssuffix - suffix);
                        suffix++;
                }
		if (suffix < g->mlen)
                	ssuffix = pmatches[ssuffix];
        }

	free(pmatches);
}

/*
 - pluscount - count + nesting
 == static sopno pluscount(struct parse *p, struct re_guts *g);
 */
static sopno			/* nesting depth */
pluscount(struct parse *p, struct re_guts *g)
{
	sop *scan;
	sop s;
	sopno plusnest = 0;
	sopno maxnest = 0;

	if (p->error != 0)
		return(0);	/* there may not be an OEND */

	scan = g->strip + 1;
	do {
		s = *scan++;
		switch (OP(s)) {
		case OPLUS_:
			plusnest++;
			break;
		case O_PLUS:
			if (plusnest > maxnest)
				maxnest = plusnest;
			plusnest--;
			break;
		}
	} while (OP(s) != OEND);
	if (plusnest != 0)
		g->iflags |= BAD;
	return(maxnest);
}
@


1.16
log
@	* regex/regcomp.c (wgetnext): Add a kludge to be more glibc compatible.
	Add comment to explain.
@
text
@d1806 2
d1809 1
@


1.16.2.1
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@a1805 2
	{
		free (pmatches);
a1806 1
	}
@


1.15
log
@	* Merge in cygwin-64bit-branch.
@
text
@d1131 12
@


1.14
log
@	* regex/regcomp.c (p_ere): Allow vertical-line following
	left-parenthesis in ERE, as in glibc.
@
text
@a65 2
/* Don't pull in windows headers just for LCID. */
typedef unsigned long LCID;
d1478 2
a1479 2
	sop *start;
	sop *newstart;
@


1.14.2.1
log
@	* dlfcn.cc (dlopen): Change cast to accommodate type change in ntdll.h
	* fhandler_process.cc (thread_info::thread_info): Change type of local
	variable size to ULONG to match NtQuerySystemInformation call.
	Add cast to avoid compiler warnings.
	(get_process_state): Add cast to avoid compiler warnings.  Accommodate
	name change of NextEntryOffset member of PSYSTEM_PROCESS_INFORMATION
	structure.
	* mmap.cc: Add casts to avoid compiler warnings.
	(mlock): Change type of local variables min and max to match
	GetProcessWorkingSetSize call.
	* nlsfuncs.cc (__collate_range_cmp): Add casts to avoid compiler
	warnings.
	* ntdll.h: Drop accommodations for Mingw32.  Fix a couple of formatting
	glitches.  Add a comment to all structures explicitely tested on 64 bit.
	(SYSTEM_INFORMATION_CLASS): Change SystemProcessesAndThreadsInformation
	to SystemProcessInformation and SystemProcessorTimes to
	SystemProcessorPerformanceInformation to match MSDN.
	(SYSTEM_BASIC_INFORMATION): Fix member types to match 64 bit.
	(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION): Rename from
	SYSTEM_PROCESSOR_TIMES to use official name from MSDN.  Accommodate
	throughout.  Drop unneeded align attribute.
	(VM_COUNTERS): Fix member types to match 64 bit.
	(SYSTEM_PROCESS_INFORMATION): Rename from SYSTEM_PROCESSES to use
	official name from MSDN.  Fix member types to match 64 bit.  Change
	member names to match MSDN and Mingw64.  Accommodate throughout.
	(IO_STATUS_BLOCK): Change to use MSDN definition.
	(SYSTEM_TIMEOFDAY_INFORMATION): Rename from
	SYSTEM_TIME_OF_DAY_INFORMATION to use official name from MSDN.
	Accommodate throughout.  Add Reserved1 area per MSDN.
	(LDR_DATA_TABLE_ENTRY): Add comment for future reference.  Change
	type of LoadCount to USHORT.
	(PEB_LDR_DATA): Change type of Initialized to BOOLEAN.  Add comment for
	future reference.
	(PEB): Fix member types to match 64 bit.
	(GDI_TEB_BATCH): New type.
	(TEB): Fix member types to match 64 bit.
	(PROCESS_BASIC_INFORMATION): Ditto.
	(MEMORY_WORKING_SET_LIST): Ditto.
	(SharedUserData): Change comment to note the fact that the address
	is valid on 32 and 64 bit.
	* pinfo.cc (winpids::enum_processes): Add cast to avoid compiler
	warnings.
	* select.cc (pipe_data_available): Add braces in initalization of an
	IO_STATUS_BLOCK to match new definition.
	* wincap.h (class wincapc): Change type of wow64 to ULONG_PTR to match
	MSDN description.
	(wincapc::is_wow64): Convert return value explicitely to bool.
	* wow64.cc (wow64_test_for_64bit_parent): Change type of wow64 to
	ULONG_PTR to match MSDN description.  Add a cast to avoid compiler
	warning.
	* regex/engine.c: Avoid compiler warnings about unused and potentially
	uninitialized variables.
	* regex/regcomp.c: Ditto.  Drop unnecessary definition of LCID.
@
text
@d66 2
d1480 2
a1481 2
	sop *start = NULL;
	sop *newstart = NULL;
@


1.13
log
@	* Makefile.in (clean): Remove non-existant regexp dir.

	* collate.h: New header.
	(__collate_range_cmp): Declare.
	(__collate_load_error): Define.
	* glob.cc: Pull in latest version from FreeBSD.  Simplify and reduce
	Cygwin-specific changes.
	* regex/regcomp.c: Include collate.h on Cygwin as well.
	(__collate_range_cmp): Move from here...
	* nlsfuncs.cc (__collate_range_cmp): ...to here.

	* miscfuncs.cc (thread_wrapper): Fix typo in comment.
	(CygwinCreateThread): Take dead zone of Windows stack into account.
	Change the way how the stack is commited and how to handle guardpages.
	Explain how and why.
	* thread.h (PTHREAD_DEFAULT_STACKSIZE): Change definition.  Explain why.
@
text
@d327 2
d330 1
@


1.12
log
@* regex/regcomp.c (xwcrtomb): Fix one explicable and one inexcplicable C
warning.
@
text
@a57 1
#ifndef __CYGWIN__
a58 1
#endif
a771 11
#ifdef __CYGWIN__
/* This function is usually part of FreeBSD's libc. */
int
__collate_range_cmp(int c1, int c2)
{
  char s1[2] = { c1, '\0' };
  char s2[2] = { c2, '\0' };
  return strcoll (s1, s2);
}
#endif

@


1.11
log
@	* regex/regcomp.c (xwcrtomb): Don't convert Unicode chars outside the
	base plane always to UTF-8.  Call wcsnrtombs instead to allow arbitrary
	multibyte charsets.
@
text
@d1178 2
a1179 2
      wchar_t ws[2], *wsp = ws;
      size_t n;
@


1.10
log
@	* regex/regcomp.c (wgetnext): Use size_t as type for n2 since that's
	what's returned by mbrtowc.
	* regex/regexec.c (xmbrtowc): Ditto.
@
text
@d1174 11
a1184 8
      /* UTF-16 systems can't handle these values directly.  Since the
         rest of the code isn't surrogate pair aware, we handle this here,
	 invisible for the rest of the code. */
      *s++ = 0xf0 | ((wc & 0x1c0000) >> 18);
      *s++ = 0x80 | ((wc &  0x3f000) >> 12);
      *s++ = 0x80 | ((wc &    0xfc0) >> 6);
      *s   = 0x80 |  (wc &     0x3f);
      return 4;
@


1.9
log
@	* regex/regcomp.c (xwcrtomb): New function to convert wide chars
	outside of the base plane to UTF-8.  Call throughout instead of
	wcrtomb.
	(wgetnext): Handle surrogate pairs on UTF-16 systems.
	* regex/regexec.c (xmbrtowc): Ditto.
@
text
@d1155 2
a1156 1
		int n2 = mbrtowc(&wc, p->next + n, p->end - p->next - n, &mbs);
@


1.8
log
@	* regex/engine.c (step): Drop Cygwin-specific definition.
	(NONCHAR): Better cast here to make the test work.  Move comment
	from step here.
	(matcher): Disable skipping initial string in multibyte case.
	* regex/regcomp.c (p_bracket): Don't simplify singleton in the invert
	case.
	(p_b_term): Handle early end of pattern after dash in bracket
	expression.
	(singleton): Don't ignore the wides just because there's already a
	singleton in the single byte chars.  Fix condition for a singleton
	wide accordingly.
	(findmust): Check for LC_CTYPE charset, rather than LC_COLLATE charset.
	* regex2.h (CHIN): Fix condition in the icase & invert case.
	(ISWORD): Fix wrong cast to unsigned char.
@
text
@d143 1
d998 1
a998 1
	n = wcrtomb(bracket, ch, &mbs);
d1140 1
d1149 1
d1152 12
d1165 1
a1165 1
	return (wc);
d1168 18
d1526 1
a1526 1
			clen = wcrtomb(buf, OPND(s), &mbs);
d1645 1
a1645 1
		clen = wcrtomb(cp, OPND(s), &mbs);
@


1.7
log
@* regcomp.c (p_ere): Workaround incorrect compiler warning.
* regerror.c (regatoi): Return non-const string or compiler complains in
certain inexplicable situations.
@
text
@d765 2
a766 1
	if ((ch = singleton(cs)) != OUT) {	/* optimize singleton sets */
d837 3
d1219 1
a1219 1
	if (n == 1)
d1221 1
a1221 1
	if (cs->nwides == 1 && cs->nranges == 0 && cs->ntypes == 0 &&
d1474 1
a1474 1
	    strcmp(collate_charset, "UTF-8") != 0)
@


1.6
log
@	Replace regex files with multibyte-aware version from FreeBSD.
	* Makefile.in (install-headers): Remove extra command to install
	regex.h.
	(uninstall-headers): Remove extra command to uninstall regex.h.
	* nlsfuncs.cc (collate_lcid): Make externally available to allow
	access to collation internals from regex functions.
	(collate_charset): Ditto.
	* wchar.h: Add __cplusplus guards to make C-clean.
	* include/regex.h: New file, replacing regex/regex.h.  Remove UCB
	advertising clause.
	* regex/COPYRIGHT: Accommodate BSD license.  Remove UCB advertising
	clause.
	* regex/cclass.h: Remove.
	* regex/cname.h: New file from FreeBSD.
	* regex/engine.c: Ditto.
	(NONCHAR): Tweak for Cygwin.
	* regex/engine.ih: Remove.
	* regex/mkh: Remove.
	* regex/regcomp.c: New file from FreeBSD.  Tweak slightly for Cygwin.
	Import required collate internals from nlsfunc.cc.
	(p_ere_exp): Add GNU-specific \< and \> handling for word boundaries.
	(p_simp_re): Ditto.
	(__collate_range_cmp): Define.
	(p_b_term): Use Cygwin-specific collate internals.
	(findmust): Ditto.
	* regex/regcomp.ih: Remove.
	* regex/regerror.c: New file from FreeBSD.  Fix a few compiler warnings.
	* regex/regerror.ih: Remove.
	* regex/regex.7: New file from FreeBSD.  Remove UCB advertising clause.
	* regex/regex.h: Remove.  Replaced by include/regex.h.
	* regex/regexec.c: New file from FreeBSD.  Fix a few compiler warnings.
	* regex/regfree.c: New file from FreeBSD.
	* regex/tests: Remove.
	* regex/utils.h: New file from FreeBSD.
@
text
@d318 2
a319 2
	sopno prevback;
	sopno prevfwd;
@


1.5
log
@	* libc/minires.c (scanline): Fix type in calls to ctype functions
	to stay in unsigned char range for char values >= 0x80.
	* regex/regcomp.c: Ditto, throughout.
	* regex/regex2.h (ISWORD): Ditto.
@
text
@d1 42
d44 1
d51 10
a60 1
#include "regex.h"
a64 1
#include "cclass.h"
d67 8
d93 55
a147 1
#include "regcomp.ih"
d167 1
d169 1
a169 1
#define	REQUIRE(co, e)	(void) ((co) || SETERROR(e))
d188 3
d204 3
a206 4
regcomp(preg, pattern, cflags)
regex_t *preg;
const char *pattern;
int cflags;
d209 4
a212 4
	register struct re_guts *g;
	register struct parse *p = &pa;
	register int i;
	register size_t len;
d231 1
a231 2
	g = (struct re_guts *)malloc(sizeof(struct re_guts) +
							(NC-1)*sizeof(cat_t));
a251 1
	g->csetsize = NC;
a252 1
	g->setbits = NULL;
d259 3
a263 3
	g->ncategories = 1;	/* category 0 is "everything else" */
	g->categories = &g->catspace[-(CHAR_MIN)];
	(void) memset((char *)g->catspace, 0, NC*sizeof(cat_t));
a278 1
	categorize(p, g);
d281 11
d311 1
a311 1
 == static void p_ere(register struct parse *p, int stop);
d314 8
a321 9
p_ere(p, stop)
register struct parse *p;
int stop;			/* character this ERE should end at */
{
	register char c;
	register sopno prevback = 0;
	register sopno prevfwd = 0;
	register sopno conc = 0;
	register int first = 1;		/* is this the first alternative? */
d328 1
a328 1
		REQUIRE(HERE() != conc, REG_EMPTY);	/* require nonempty */
d356 1
a356 1
 == static void p_ere_exp(register struct parse *p);
d359 1
a359 2
p_ere_exp(p)
register struct parse *p;
d361 6
a366 5
	register char c;
	register sopno pos;
	register int count;
	register int count2;
	register sopno subno;
d375 1
a375 1
		REQUIRE(MORE(), REG_EPAREN);
d388 1
a388 1
		MUSTEAT(')', REG_EPAREN);
d431 19
a449 3
		REQUIRE(MORE(), REG_EESCAPE);
		c = GETNEXT();
		ordinary(p, c);
d452 1
a452 1
		REQUIRE(!MORE() || !isdigit((unsigned char)PEEK()), REG_BADRPT);
d455 3
a457 1
		ordinary(p, c);
d466 1
a466 1
				(c == '{' && MORE2() && isdigit((unsigned char)PEEK2())) ))
d470 1
a470 1
	REQUIRE(!wascaret, REG_BADRPT);
d495 1
a495 1
			if (isdigit((unsigned char)PEEK())) {
d497 1
a497 1
				REQUIRE(count <= count2, REG_BADBR);
d506 1
a506 1
			REQUIRE(MORE(), REG_EBRACE);
d516 1
a516 1
				(c == '{' && MORE2() && isdigit((unsigned char)PEEK2())) ) )
d523 1
a523 1
 == static void p_str(register struct parse *p);
d526 1
a526 2
p_str(p)
register struct parse *p;
d528 1
a528 1
	REQUIRE(MORE(), REG_EMPTY);
d530 1
a530 1
		ordinary(p, GETNEXT());
d535 2
a536 2
 == static void p_bre(register struct parse *p, register int end1, \
 ==	register int end2);
d540 1
a540 3
 * taken as an ordinary character and then revised to be an anchor.  The
 * only undesirable side effect is that '$' gets included as a character
 * category in such cases.  This is fairly harmless; not worth fixing.
d544 7
a550 8
p_bre(p, end1, end2)
register struct parse *p;
register int end1;		/* first terminating character */
register int end2;		/* second terminating character */
{
	register sopno start = HERE();
	register int first = 1;			/* first subexpression? */
	register int wasdollar = 0;
d568 1
a568 1
	REQUIRE(HERE() != start, REG_EMPTY);	/* require nonempty */
d573 1
a573 1
 == static int p_simp_re(register struct parse *p, int starordinary);
d576 10
a585 10
p_simp_re(p, starordinary)
register struct parse *p;
int starordinary;		/* is a leading * an ordinary character? */
{
	register int c;
	register int count;
	register int count2;
	register sopno pos;
	register int i;
	register sopno subno;
d593 2
a594 2
		REQUIRE(MORE(), REG_EESCAPE);
		c = BACKSL | (unsigned char)GETNEXT();
d606 10
d633 1
a633 1
		REQUIRE(EATTWO('\\', ')'), REG_EPAREN);
d663 1
a663 1
		REQUIRE(starordinary, REG_BADRPT);
d666 3
a668 1
		ordinary(p, (char)c);	/* takes off BACKSL, if any */
d681 1
a681 1
			if (MORE() && isdigit((unsigned char)PEEK())) {
d683 1
a683 1
				REQUIRE(count <= count2, REG_BADBR);
d692 1
a692 1
			REQUIRE(MORE(), REG_EBRACE);
d695 1
a695 1
	} else if (c == (unsigned char)'$')	/* $ (but not \$) ends it */
d703 1
a703 1
 == static int p_count(register struct parse *p);
d706 1
a706 2
p_count(p)
register struct parse *p;
d708 2
a709 2
	register int count = 0;
	register int ndigits = 0;
d711 1
a711 1
	while (MORE() && isdigit((unsigned char)PEEK()) && count <= DUPMAX) {
d716 1
a716 1
	REQUIRE(ndigits > 0 && count <= DUPMAX, REG_BADBR);
d722 1
a722 4
 == static void p_bracket(register struct parse *p);
 *
 * Note a significant property of this code:  if the allocset() did SETERROR,
 * no set operations are done.
d725 1
a725 2
p_bracket(p)
register struct parse *p;
d727 2
a728 2
	register cset *cs = allocset(p);
	register int invert = 0;
d742 5
d748 1
a748 1
		invert++;	/* make note to invert set at end */
d750 1
a750 1
		CHadd(cs, ']');
d752 1
a752 1
		CHadd(cs, '-');
d756 2
a757 2
		CHadd(cs, '-');
	MUSTEAT(']', REG_EBRACK);
d762 2
a763 15
	if (p->g->cflags&REG_ICASE) {
		register int i;
		register int ci;

		for (i = p->g->csetsize - 1; i >= 0; i--)
			if (CHIN(cs, i) && isalpha(i)) {
				ci = othercase(i);
				if (ci != i)
					CHadd(cs, ci);
			}
		if (cs->multis != NULL)
			mccase(p, cs);
	}
	if (invert) {
		register int i;
d765 2
a766 15
		for (i = p->g->csetsize - 1; i >= 0; i--)
			if (CHIN(cs, i))
				CHsub(cs, i);
			else
				CHadd(cs, i);
		if (p->g->cflags&REG_NEWLINE)
			CHsub(cs, '\n');
		if (cs->multis != NULL)
			mcinvert(p, cs);
	}

	assert(cs->multis == NULL);		/* xxx */

	if (nch(p, cs) == 1) {		/* optimize singleton sets */
		ordinary(p, firstch(p, cs));
d769 1
a769 1
		EMIT(OANYOF, freezeset(p, cs));
d772 11
d785 1
a785 1
 == static void p_b_term(register struct parse *p, register cset *cs);
d788 1
a788 3
p_b_term(p, cs)
register struct parse *p;
register cset *cs;
d790 3
a792 3
	register char c;
	register char start, finish;
	register int i;
d811 1
a811 1
		REQUIRE(MORE(), REG_EBRACK);
d813 1
a813 1
		REQUIRE(c != '-' && c != ']', REG_ECTYPE);
d815 2
a816 2
		REQUIRE(MORE(), REG_EBRACK);
		REQUIRE(EATTWO(':', ']'), REG_ECTYPE);
d820 1
a820 1
		REQUIRE(MORE(), REG_EBRACK);
d822 1
a822 1
		REQUIRE(c != '-' && c != ']', REG_ECOLLATE);
d824 2
a825 2
		REQUIRE(MORE(), REG_EBRACK);
		REQUIRE(EATTWO('=', ']'), REG_ECOLLATE);
a827 1
/* xxx revision needed for multichar stuff */
d838 20
a857 4
/* xxx what about signed chars here... */
		REQUIRE(start <= finish, REG_ERANGE);
		for (i = start; i <= finish; i++)
			CHadd(cs, i);
d864 1
a864 1
 == static void p_b_cclass(register struct parse *p, register cset *cs);
d867 1
a867 3
p_b_cclass(p, cs)
register struct parse *p;
register cset *cs;
d869 4
a872 5
	register char *sp = p->next;
	register struct cclass *cp;
	register size_t len;
	register const char *u;
	register char c;
d874 1
a874 1
	while (MORE() && isalpha((unsigned char)PEEK()))
d877 7
a883 5
	for (cp = cclasses; cp->name != NULL; cp++)
		if (strncmp(cp->name, sp, len) == 0 && cp->name[len] == '\0')
			break;
	if (cp->name == NULL) {
		/* oops, didn't find it */
d887 1
a887 6

	u = cp->chars;
	while ((c = *u++) != '\0')
		CHadd(cs, c);
	for (u = cp->multis; *u != '\0'; u += strlen(u) + 1)
		MCadd(p, cs, u);
d892 1
a892 1
 == static void p_b_eclass(register struct parse *p, register cset *cs);
d897 1
a897 3
p_b_eclass(p, cs)
register struct parse *p;
register cset *cs;
d899 1
a899 1
	register char c;
d902 1
a902 1
	CHadd(cs, c);
d907 1
a907 1
 == static char p_b_symbol(register struct parse *p);
d909 2
a910 3
static char			/* value of symbol */
p_b_symbol(p)
register struct parse *p;
d912 1
a912 1
	register char value;
d914 1
a914 1
	REQUIRE(MORE(), REG_EBRACK);
d916 1
a916 1
		return(GETNEXT());
d920 1
a920 1
	REQUIRE(EATTWO('.', ']'), REG_ECOLLATE);
d926 1
a926 1
 == static char p_b_coll_elem(register struct parse *p, int endc);
d928 10
a937 8
static char			/* value of collating element */
p_b_coll_elem(p, endc)
register struct parse *p;
int endc;			/* name ended by endc,']' */
{
	register char *sp = p->next;
	register struct cname *cp;
	register int len;
d949 7
a955 3
	if (len == 1)
		return(*sp);	/* single character */
	SETERROR(REG_ECOLLATE);			/* neither */
d963 8
a970 9
static char			/* if no counterpart, return ch */
othercase(ch)
int ch;
{
	assert(isalpha(ch));
	if (isupper(ch))
		return(tolower(ch));
	else if (islower(ch))
		return(toupper(ch));
d977 1
a977 1
 == static void bothcases(register struct parse *p, int ch);
d982 7
a988 7
bothcases(p, ch)
register struct parse *p;
int ch;
{
	register char *oldnext = p->next;
	register char *oldend = p->end;
	char bracket[3];
d992 6
a997 4
	p->end = bracket+2;
	bracket[0] = ch;
	bracket[1] = ']';
	bracket[2] = '\0';
d999 1
a999 1
	assert(p->next == bracket+2);
d1006 1
a1006 1
 == static void ordinary(register struct parse *p, register int ch);
d1009 1
a1009 3
ordinary(p, ch)
register struct parse *p;
register int ch;
d1011 1
a1011 1
	register cat_t *cap = p->g->categories;
d1013 1
a1013 1
	if ((p->g->cflags&REG_ICASE) && isalpha(ch) && othercase(ch) != ch)
d1015 2
d1018 8
a1025 3
		EMIT(OCHAR, (unsigned char)ch);
		if (cap[ch] == 0)
			cap[ch] = p->g->ncategories++;
d1031 1
a1031 1
 == static void nonnewline(register struct parse *p);
d1036 1
a1036 2
nonnewline(p)
register struct parse *p;
d1038 2
a1039 2
	register char *oldnext = p->next;
	register char *oldend = p->end;
d1056 1
a1056 1
 == static void repeat(register struct parse *p, sopno start, int from, int to);
d1059 4
a1062 5
repeat(p, start, from, to)
register struct parse *p;
sopno start;			/* operand from here to end of strip */
int from;			/* repeated from this number */
int to;				/* to this number of times (maybe INFINITY) */
d1064 1
a1064 1
	register sopno finish = HERE();
d1069 1
a1069 1
	register sopno copy;
d1126 24
d1151 1
a1151 1
 == static int seterr(register struct parse *p, int e);
d1154 1
a1154 3
seterr(p, e)
register struct parse *p;
int e;
d1165 1
a1165 1
 == static cset *allocset(register struct parse *p);
d1168 1
a1168 2
allocset(p)
register struct parse *p;
d1170 6
a1175 34
	register int no = p->g->ncsets++;
	register size_t nc;
	register size_t nbytes;
	register cset *cs;
	register size_t css = (size_t)p->g->csetsize;
	register int i;

	if (no >= p->ncsalloc) {	/* need another column of space */
		p->ncsalloc += CHAR_BIT;
		nc = p->ncsalloc;
		assert(nc % CHAR_BIT == 0);
		nbytes = nc / CHAR_BIT * css;
		if (p->g->sets == NULL)
			p->g->sets = (cset *)malloc(nc * sizeof(cset));
		else
			p->g->sets = (cset *)realloc((char *)p->g->sets,
							nc * sizeof(cset));
		if (p->g->setbits == NULL)
			p->g->setbits = (uch *)malloc(nbytes);
		else {
			p->g->setbits = (uch *)realloc((char *)p->g->setbits,
								nbytes);
			/* xxx this isn't right if setbits is now NULL */
			for (i = 0; i < no; i++)
				p->g->sets[i].ptr = p->g->setbits + css*(i/CHAR_BIT);
		}
		if (p->g->sets != NULL && p->g->setbits != NULL)
			(void) memset((char *)p->g->setbits + (nbytes - css),
								0, css);
		else {
			no = 0;
			SETERROR(REG_ESPACE);
			/* caller's responsibility not to do set ops */
		}
d1177 3
a1179 8

	assert(p->g->sets != NULL);	/* xxx */
	cs = &p->g->sets[no];
	cs->ptr = p->g->setbits + css*((no)/CHAR_BIT);
	cs->mask = 1 << ((no) % CHAR_BIT);
	cs->hash = 0;
	cs->smultis = 0;
	cs->multis = NULL;
d1186 1
a1186 1
 == static void freeset(register struct parse *p, register cset *cs);
d1189 1
a1189 3
freeset(p, cs)
register struct parse *p;
register cset *cs;
d1191 1
a1191 3
	register size_t i;
	register cset *top = &p->g->sets[p->g->ncsets];
	register size_t css = (size_t)p->g->csetsize;
d1193 4
a1196 2
	for (i = 0; i < css; i++)
		CHsub(cs, i);
d1202 2
a1203 42
 - freezeset - final processing on a set of characters
 == static int freezeset(register struct parse *p, register cset *cs);
 *
 * The main task here is merging identical sets.  This is usually a waste
 * of time (although the hash code minimizes the overhead), but can win
 * big if REG_ICASE is being used.  REG_ICASE, by the way, is why the hash
 * is done using addition rather than xor -- all ASCII [aA] sets xor to
 * the same value!
 */
static int			/* set number */
freezeset(p, cs)
register struct parse *p;
register cset *cs;
{
	register uch h = cs->hash;
	register size_t i;
	register cset *top = &p->g->sets[p->g->ncsets];
	register cset *cs2;
	register size_t css = (size_t)p->g->csetsize;

	/* look for an earlier one which is the same */
	for (cs2 = &p->g->sets[0]; cs2 < top; cs2++)
		if (cs2->hash == h && cs2 != cs) {
			/* maybe */
			for (i = 0; i < css; i++)
				if (!!CHIN(cs2, i) != !!CHIN(cs, i))
					break;		/* no */
			if (i == css)
				break;			/* yes */
		}

	if (cs2 < top) {	/* found one */
		freeset(p, cs);
		cs = cs2;
	}

	return((int)(cs - p->g->sets));
}

/*
 - firstch - return first character in a set (which must have at least one)
 == static int firstch(register struct parse *p, register cset *cs);
d1205 2
a1206 4
static int			/* character; there is no "none" value */
firstch(p, cs)
register struct parse *p;
register cset *cs;
d1208 1
a1208 22
	register size_t i;
	register size_t css = (size_t)p->g->csetsize;

	for (i = 0; i < css; i++)
		if (CHIN(cs, i))
			return((char)i);
	assert(never);
	return(0);		/* arbitrary */
}

/*
 - nch - number of characters in a set
 == static int nch(register struct parse *p, register cset *cs);
 */
static int
nch(p, cs)
register struct parse *p;
register cset *cs;
{
	register size_t i;
	register size_t css = (size_t)p->g->csetsize;
	register int n = 0;
d1210 2
a1211 2
	for (i = 0; i < css; i++)
		if (CHIN(cs, i))
d1213 9
a1221 1
	return(n);
d1225 1
a1225 3
 - mcadd - add a collating element to a cset
 == static void mcadd(register struct parse *p, register cset *cs, \
 ==	register char *cp);
d1228 1
a1228 4
mcadd(p, cs, cp)
register struct parse *p;
register cset *cs;
register const char *cp;
d1230 19
a1248 10
	register size_t oldend = cs->smultis;

	cs->smultis += strlen(cp) + 1;
	if (cs->multis == NULL)
		cs->multis = malloc(cs->smultis);
	else
		cs->multis = realloc(cs->multis, cs->smultis);
	if (cs->multis == NULL) {
		SETERROR(REG_ESPACE);
		return;
a1249 3

	(void) strcpy(cs->multis + oldend - 1, cp);
	cs->multis[cs->smultis - 1] = '\0';
d1253 1
a1253 5
 - mcinvert - invert the list of collating elements in a cset
 == static void mcinvert(register struct parse *p, register cset *cs);
 *
 * This would have to know the set of possibilities.  Implementation
 * is deferred.
d1256 1
a1256 3
mcinvert(p, cs)
register struct parse *p;
register cset *cs;
d1258 1
a1258 2
	assert(cs->multis == NULL);	/* xxx */
}
d1260 14
a1273 55
/*
 - mccase - add case counterparts of the list of collating elements in a cset
 == static void mccase(register struct parse *p, register cset *cs);
 *
 * This would have to know the set of possibilities.  Implementation
 * is deferred.
 */
static void
mccase(p, cs)
register struct parse *p;
register cset *cs;
{
	assert(cs->multis == NULL);	/* xxx */
}

/*
 - isinsets - is this character in any sets?
 == static int isinsets(register struct re_guts *g, int c);
 */
static int			/* predicate */
isinsets(g, c)
register struct re_guts *g;
int c;
{
	register uch *col;
	register int i;
	register int ncols = (g->ncsets+(CHAR_BIT-1)) / CHAR_BIT;
	register unsigned uc = (unsigned char)c;

	for (i = 0, col = g->setbits; i < ncols; i++, col += g->csetsize)
		if (col[uc] != 0)
			return(1);
	return(0);
}

/*
 - samesets - are these two characters in exactly the same sets?
 == static int samesets(register struct re_guts *g, int c1, int c2);
 */
static int			/* predicate */
samesets(g, c1, c2)
register struct re_guts *g;
int c1;
int c2;
{
	register uch *col;
	register int i;
	register int ncols = (g->ncsets+(CHAR_BIT-1)) / CHAR_BIT;
	register unsigned uc1 = (unsigned char)c1;
	register unsigned uc2 = (unsigned char)c2;

	for (i = 0, col = g->setbits; i < ncols; i++, col += g->csetsize)
		if (col[uc1] != col[uc2])
			return(0);
	return(1);
d1277 1
a1277 2
 - categorize - sort out character categories
 == static void categorize(struct parse *p, register struct re_guts *g);
d1280 1
a1280 3
categorize(p, g)
struct parse *p;
register struct re_guts *g;
d1282 2
a1283 4
	register cat_t *cats = g->categories;
	register int c;
	register int c2;
	register cat_t cat;
d1285 7
a1291 2
	/* avoid making error situations worse */
	if (p->error != 0)
d1293 3
a1295 9

	for (c = CHAR_MIN; c <= CHAR_MAX; c++)
		if (cats[c] == 0 && isinsets(g, c)) {
			cat = g->ncategories++;
			cats[c] = cat;
			for (c2 = c+1; c2 <= CHAR_MAX; c2++)
				if (cats[c2] == 0 && samesets(g, c, c2))
					cats[c2] = cat;
		}
d1300 1
a1300 1
 == static sopno dupl(register struct parse *p, sopno start, sopno finish);
d1303 3
a1305 4
dupl(p, start, finish)
register struct parse *p;
sopno start;			/* from here */
sopno finish;			/* to this less one */
d1307 2
a1308 2
	register sopno ret = HERE();
	register sopno len = finish - start;
d1323 1
a1323 1
 == static void doemit(register struct parse *p, sop op, size_t opnd);
d1330 1
a1330 4
doemit(p, op, opnd)
register struct parse *p;
sop op;
size_t opnd;
d1350 1
a1350 1
 == static void doinsert(register struct parse *p, sop op, size_t opnd, sopno pos);
d1353 5
a1357 9
doinsert(p, op, opnd, pos)
register struct parse *p;
sop op;
size_t opnd;
sopno pos;
{
	register sopno sn;
	register sop s;
	register int i;
d1386 1
a1386 1
 == static void dofwd(register struct parse *p, sopno pos, sop value);
d1389 1
a1389 4
dofwd(p, pos, value)
register struct parse *p;
register sopno pos;
sop value;
d1401 1
a1401 1
 == static void enlarge(register struct parse *p, sopno size);
d1404 1
a1404 3
enlarge(p, size)
register struct parse *p;
register sopno size;
d1406 1
a1406 1
	register sop *sp;
d1422 1
a1422 1
 == static void stripsnug(register struct parse *p, register struct re_guts *g);
d1425 1
a1425 3
stripsnug(p, g)
register struct parse *p;
register struct re_guts *g;
d1437 1
a1437 1
 == static void findmust(register struct parse *p, register struct re_guts *g);
d1446 12
a1457 11
findmust(p, g)
struct parse *p;
register struct re_guts *g;
{
	register sop *scan;
	sop *start = NULL;
	register sop *newstart = NULL;
	register sopno newlen;
	register sop s;
	register char *cp;
	register sopno i;
d1463 13
d1478 2
d1485 2
a1486 1
			if (newlen == 0)		/* new sequence */
d1488 5
a1492 1
			newlen++;
d1500 1
d1512 41
a1552 2
			/* fallthrough */
		default:		/* things that break a sequence */
d1556 8
d1565 20
d1590 2
a1591 1
	if (g->mlen == 0)		/* there isn't one */
d1593 1
d1599 1
d1604 2
a1605 1
	for (i = g->mlen; i > 0; i--) {
d1608 3
a1610 2
		assert(cp < g->must + g->mlen);
		*cp++ = (char)OPND(s);
d1617 196
d1814 1
a1814 1
 == static sopno pluscount(register struct parse *p, register struct re_guts *g);
d1817 6
a1822 8
pluscount(p, g)
struct parse *p;
register struct re_guts *g;
{
	register sop *scan;
	register sop s;
	register sopno plusnest = 0;
	register sopno maxnest = 0;
@


1.4
log
@* libc/minires.c (scanline): Accommodate ctype changes which disallow use of an
unadorned char argument to is* macros.
* regex/regcomp.c: Ditto, throughout.
* regex/regex2.h (ISWORD): Ditto.
@
text
@d314 1
a314 1
		REQUIRE(!MORE() || !isdigit((unsigned)PEEK()), REG_BADRPT);
d326 1
a326 1
				(c == '{' && MORE2() && isdigit((unsigned)PEEK2())) ))
d355 1
a355 1
			if (isdigit((unsigned)PEEK())) {
d376 1
a376 1
				(c == '{' && MORE2() && isdigit((unsigned)PEEK2())) ) )
d533 1
a533 1
			if (MORE() && isdigit((unsigned)PEEK())) {
d564 1
a564 1
	while (MORE() && isdigit((unsigned)PEEK()) && count <= DUPMAX) {
d731 1
a731 1
	while (MORE() && isalpha((unsigned)PEEK()))
@


1.3
log
@* environ.cc (environ_init): Avoid a compiler warning.
* path.cc (path_conv::check): Ditto.
* path.h (path_conv::operator int): Ditto.
* regex/engine.c: Ditto throughout.
* regex/regcomp.c: Ditto throughout.
* regex/regexec.c: Ditto throughout.
@
text
@d314 1
a314 1
		REQUIRE(!MORE() || !isdigit(PEEK()), REG_BADRPT);
d326 1
a326 1
				(c == '{' && MORE2() && isdigit(PEEK2())) ))
d355 1
a355 1
			if (isdigit(PEEK())) {
d376 1
a376 1
				(c == '{' && MORE2() && isdigit(PEEK2())) ) )
d533 1
a533 1
			if (MORE() && isdigit(PEEK())) {
d564 1
a564 1
	while (MORE() && isdigit(PEEK()) && count <= DUPMAX) {
d731 1
a731 1
	while (MORE() && isalpha(PEEK()))
@


1.2
log
@* hires.h (hires::usecs): Rename from utime.  Accept an argument.
* strace.cc (strace::microseconds): Use hires class for calculating times.
* sync.h (new_muto): Use NO_COPY explicitly in declaration.
* times.cc (gettimeofday): Reflect change in usecs argument.
(hires::usecs): Ditto.  Changed name from utime.
* winsup.h (NO_COPY): Add nocommon attribute to force setting aside space for
variable.
* regcomp.c (REQUIRE): Add a void cast to bypass a warning.
@
text
@d1058 1
a1058 1
	register int i;
d1084 1
a1084 1
	register int i;
d1117 1
a1117 1
	register int i;
d1136 1
a1136 1
	register int i;
@


1.1
log
@* Makefile.in (VPATH): Add regex directory.
(NM): new variable.
(OBSOLETE_FUNCTIONS): Ditto.
(NEW_FUNCTIONS): Ditto.
(install-headers): Install regex.h.
(install-man): New target.
(install): Use new target.
(DLL_OFILES): Add v8_reg* stuff.
(new-cygwin1.dll): Eliminate stamp-cygwin-lib creation.
(libcygwin.a): Remove obsolete functions from import lib.  Add new functions.
* configure.in: Detect 'nm' tool.
* configure: Regenerate.
* cygwin.din: Export posix_reg* functions.  Eliminate export of v8 reg*
functions.  This is now handled in object files themselves.
* regex/*: New files.
* regexp/v8_*.c: New files, renamed from non v8_ equivalents.
@
text
@d55 1
a55 1
#define	REQUIRE(co, e)	((co) || SETERROR(e))
@


1.1.2.1
log
@Merged changes from HEAD
@
text
@@


1.1.2.2
log
@Merged changes from HEAD
@
text
@d55 1
a55 1
#define	REQUIRE(co, e)	(void) ((co) || SETERROR(e))
@


