head	1.111;
access;
symbols
	cygwin-1_7_35-release:1.111
	cygwin-1_7_34-release:1.111
	cygwin-1_7_33-release:1.103
	cygwin-1_7_32-release:1.103
	cygwin-1_7_31-release:1.103
	cygwin-1_7_30-release:1.103
	cygwin-1_7_29-release:1.103
	cygwin-1_7_29-release-branchpoint:1.103.0.2
	cygwin-pre-user-db:1.103
	cygwin-1_7_28-release:1.103
	cygwin-1_7_27-release:1.103
	cygwin-1_7_26-release:1.103
	cygwin-1_7_25-release:1.103
	cygwin-1_7_24-release:1.103
	cygwin-1_7_23-release:1.103
	cygwin-1_7_22-release:1.103
	cygwin-1_7_21-release:1.103
	cygwin-1_7_20-release:1.103
	cygwin-1_7_19-release:1.103
	cygwin-64bit-postmerge:1.102
	cygwin-64bit-premerge-branch:1.101.0.2
	cygwin-64bit-premerge:1.101
	cygwin-1_7_18-release:1.101
	post-ptmalloc3:1.98.2.6
	pre-ptmalloc3:1.98.2.6
	cygwin-1_7_17-release:1.99
	cygwin-64bit-branch:1.98.0.2
	cygwin-1_7_16-release:1.98
	cygwin-1_7_15-release:1.96
	cygwin-1_7_14_2-release:1.96
	cygwin-1_7_14-release:1.96
	cygwin-1_7_12-release:1.96
	cygwin-1_7_11-release:1.96
	cygwin-1_7_10-release:1.96
	signal-rewrite:1.93.0.2
	pre-notty:1.93
	cygwin-1_7_9-release:1.88
	cv-post-1_7_9:1.88.0.2
	cygwin-1_7_8-release:1.88
	cygwin-1_7_7-release:1.88
	cygwin-1_7_5-release:1.86
	cygwin-1_7_4-release:1.86
	cygwin-1_7_3-release:1.86
	cygwin-1_7_2-release:1.86
	fifo_doover3:1.84.0.2
	cygwin-1_7_1-release:1.84
	prefifo:1.82
	cv-branch-2:1.82.0.2
	pre-ripout-set_console_state_for_spawn:1.78
	EOL_registry_mounts:1.76
	preoverlapped:1.69
	drop_9x_support_start:1.67
	cr-0x5f1:1.58.0.2
	cv-branch:1.57.0.2
	pre-ptymaster-archetype:1.57
	cr-0x3b58:1.56.0.4
	cr-0x5ef:1.56.0.2
	after-mmap-privanon-noreserve:1.56
	after-mmap-revamp:1.56
	before-mmap-revamp:1.56
	cgf-more-exit-sync:1.56
	post_wait_sig_exit:1.56
	pre_wait_sig_exit:1.56
	reparent-point:1.52
	noreparent:1.52.0.2
	cr-0x5e6:1.51.0.2
	cr-0x9e:1.48.0.6
	cr-0x9d:1.48.0.4
	cgf-deleteme:1.48.0.2
	pre-sigrewrite:1.47
	corinna-01:1.45
	cr-0x9c:1.39.0.6
	cr-0x9b:1.39.0.4
	cr-0x99:1.39
	Z-emcb-cygwin_daemon:1.39.0.2
	w32api-2_2:1.36
	mingw-runtime-2_4:1.36
	pre-cgf-merge:1.41
	cgf-dev-branch:1.31.0.4
	predaemon:1.15
	cygwin_daemon_merge_HEAD:1.15
	pregp02r1:1.15.0.2
	cygnus_cvs_20020108_pre:1.13
	Z-cygwin_daemon_merge-new_HEAD:1.25
	Z-cygwin_daemon_merge_HEAD:1.25
	cygwin_daemon:1.13.0.4;
locks; strict;
comment	@// @;


1.111
date	2014.06.25.09.10.50;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2014.05.06.12.28.33;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2014.05.06.12.02.48;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2014.03.06.18.54.07;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2014.03.03.12.03.47;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2014.02.27.12.57.27;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2014.02.11.11.51.29;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2014.02.09.19.44.55;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.102;

1.102
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2012.11.26.13.28.53;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2012.08.16.23.34.45;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2012.07.06.13.49.53;	author corinna;	state Exp;
branches
	1.98.2.1;
next	1.97;

1.97
date	2012.06.03.16.46.53;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2011.10.15.16.31.57;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2011.04.29.10.38.12;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2011.04.28.15.54.47;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2011.04.28.09.30.36;	author corinna;	state Exp;
branches;
next	1.90;

1.90
date	2011.04.28.08.34.49;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2011.04.04.09.00.02;	author corinna;	state Exp;
branches;
next	1.88;

1.88
date	2010.04.17.15.51.09;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2010.04.15.17.17.59;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2010.02.12.17.40.42;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2010.01.08.15.55.27;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2009.10.31.09.31.47;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2009.10.30.19.58.53;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2009.04.09.09.19.03;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2008.11.26.17.21.04;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2008.09.11.05.43.11;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2008.07.11.10.00.36;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2008.04.22.10.45.34;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2008.04.18.20.13.37;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2008.02.14.16.47.11;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2007.07.20.14.29.43;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2007.07.19.09.12.09;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2007.07.19.08.33.22;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.19.07.24.17;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2007.03.29.16.37.36;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2007.02.23.15.15.49;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2006.12.20.17.14.23;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2006.12.12.18.47.25;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2006.11.27.12.59.58;	author corinna;	state Exp;
branches;
next	1.63;

1.63
date	2006.11.23.16.44.55;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.08.11.38.05;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.01.09.00.14;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2006.10.22.19.31.33;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2006.10.22.14.57.43;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2006.07.17.19.30.30;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.01.23.14.25;	author corinna;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2005.07.05.03.16.45;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2005.07.03.02.40.29;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2005.06.07.19.31.40;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.03.13.06.42;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2004.04.16.21.22.13;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.05.17.23.19;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.07.22.37.12;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2003.11.26.14.29.22;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2003.11.26.13.23.27;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.04.15.48.18;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.27.01.56.36;	author phumblet;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.25.03.51.50;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.16.09.24.52;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.16.00.45.50;	author phumblet;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.09.20.31.07;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.26.08.34.34;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2003.02.06.14.01.54;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.05.13.47.47;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.04.14.58.04;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.03.15.55.19;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.26.06.42.40;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2002.12.14.17.23.42;	author corinna;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2002.12.10.12.43.49;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.20.17.10.05;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.14.19.19.39;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.12.15.51.11;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.22.16.22.10;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.08.14.16.14;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.03.03.20.50;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.01.23.42.04;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.01.14.31.28;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.06.11.17.50;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.02.06.07.01;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.29.15.04.26;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.28.14.10.51;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.09.07.21.32.05;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.15.22.40.07;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.24.22.26.52;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.29.20.43.40;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.20.08.10.47;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.16.07.25.31;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.15.19.23.31;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.30.18.21.48;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.25.09.43.25;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.20.20.36.13;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.20.13.02.32;	author corinna;	state Exp;
branches;
next	;

1.98.2.1
date	2012.08.13.20.04.35;	author corinna;	state Exp;
branches;
next	1.98.2.2;

1.98.2.2
date	2012.10.16.15.18.39;	author corinna;	state Exp;
branches;
next	1.98.2.3;

1.98.2.3
date	2012.11.26.13.29.09;	author corinna;	state Exp;
branches;
next	1.98.2.4;

1.98.2.4
date	2012.12.10.11.45.50;	author corinna;	state Exp;
branches;
next	1.98.2.5;

1.98.2.5
date	2013.01.21.13.52.10;	author corinna;	state Exp;
branches;
next	1.98.2.6;

1.98.2.6
date	2013.02.09.20.38.00;	author corinna;	state Exp;
branches;
next	1.98.2.7;

1.98.2.7
date	2013.03.01.16.32.33;	author corinna;	state Exp;
branches;
next	;

1.57.2.1
date	2006.07.18.10.33.54;	author corinna;	state Exp;
branches;
next	;

1.31.4.1
date	2003.01.26.06.43.32;	author cgf;	state Exp;
branches;
next	1.31.4.2;

1.31.4.2
date	2003.02.05.14.25.09;	author cgf;	state Exp;
branches;
next	1.31.4.3;

1.31.4.3
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.31.4.4;

1.31.4.4
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.31.4.5;

1.31.4.5
date	2003.02.27.15.10.22;	author cgf;	state Exp;
branches;
next	1.31.4.6;

1.31.4.6
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.31.4.7;

1.31.4.7
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.13.4.1
date	2002.02.28.12.53.26;	author rbcollins;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2002.06.13.14.34.10;	author rbcollins;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2002.07.02.10.58.20;	author scottc;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2002.07.03.16.01.46;	author scottc;	state Exp;
branches;
next	1.13.4.5;

1.13.4.5
date	2002.08.12.14.06.35;	author scottc;	state Exp;
branches;
next	1.13.4.6;

1.13.4.6
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.111
log
@	* autoload.cc (ldap_search_sW): Replace ldap_search_stW.
	(LdapMapErrorToWin32): Import.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Accommodate
	change to cyg_ldap::open.
	* ldap.cc (CYG_LDAP_TIMEOUT): Remove.
	(CYG_LDAP_ENUM_TIMEOUT): Remove.
	(def_tv): Remove.
	(enum_tv): Remove.
	(cyg_ldap::map_ldaperr_to_errno): New method to map LDAP error codes to
	POSIX errno codes.  Explicitly map LDAP_NO_RESULTS_RETURNED to ENMFILE.
	(cyg_ldap::wait): Ditto.
	(struct cyg_ldap_init): New struct.
	(cyg_ldap::connect_ssl): Return ULONG.  Drop setting LDAP_OPT_TIMELIMIT.
	Add call to ldap_search_sW to fetch root DSE.
	(cyg_ldap::connect_non_ssl): Ditto.
	(ldap_init_thr): New static thread function.
	(cyg_ldap::connect): New method to call connect_ssl/connect_non_ssl in
	an interruptible cygthread.
	(struct cyg_ldap_search): New struct.
	(cyg_ldap::search_s): New method to perform generic synchronous search.
	(ldap_search_thr): New static thread function.
	(cyg_ldap::search): New method to call search_s in an interruptible
	cygthread.
	(struct cyg_ldap_next_page): New struct.
	(cyg_ldap::next_page_s): New method to perform generic synchronous
	paged search.
	(ldap_next_page_thr): New static thread function.
	(cyg_ldap::next_page): New method to call next_page_s in an
	interruptible cygthread.
	(cyg_ldap::open): Return POSIX errno.  Call connect method.
	(cyg_ldap::fetch_ad_account): Call search method rather than
	ldap_search_stW.
	(cyg_ldap::enumerate_ad_accounts): Return POSIX errno.  Use infinite
	timeout in call to ldap_search_init_pageW.
	(cyg_ldap::next_account): Return POSIX errno.  Call next_page method
	rather than ldap_get_next_page_s.
	(cyg_ldap::fetch_posix_offset_for_domain): Call search method rather
	than ldap_search_stW.
	(cyg_ldap::fetch_unix_sid_from_ad): Ditto.
	(cyg_ldap::fetch_unix_name_from_rfc2307): Ditto.
	* ldap.h (class cyg_ldap): Accommodate aforementioned changes.
	* passwd.cc (pg_ent::enumerate_ad): Ditto.  Break search if one of
	cyg_ldap::enumerate_ad_accounts or cldap.next_account returns with
	an error code other than ENMFILE.
	* sec_helper.cc (cygpsid::get_id): Accommodate change to cyg_ldap::open.
	* uinfo.cc (fetch_posix_offset): Ditto.
@
text
@/* sec_helper.cc: NT security helper functions

   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011, 2012, 2013, 2014 Red Hat, Inc.

   Written by Corinna Vinschen <corinna@@vinschen.de>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include <sys/acl.h>
#include <wchar.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "pinfo.h"
#include "cygheap.h"
#include "ntdll.h"
#include "ldap.h"

/* General purpose security attribute objects for global use. */
static NO_COPY_RO SECURITY_DESCRIPTOR null_sdp =
	{ SECURITY_DESCRIPTOR_REVISION, 0, SE_DACL_PRESENT,
	  NULL, NULL, NULL, NULL };
SECURITY_ATTRIBUTES NO_COPY_RO sec_none =
	{ sizeof (SECURITY_ATTRIBUTES), NULL, TRUE };
SECURITY_ATTRIBUTES NO_COPY_RO sec_none_nih =
	{ sizeof (SECURITY_ATTRIBUTES), NULL, FALSE };
SECURITY_ATTRIBUTES NO_COPY_RO sec_all =
	{ sizeof (SECURITY_ATTRIBUTES), &null_sdp, TRUE };
SECURITY_ATTRIBUTES NO_COPY_RO sec_all_nih =
	{ sizeof (SECURITY_ATTRIBUTES), &null_sdp, FALSE };

MKSID (well_known_null_sid, "S-1-0-0",
       SECURITY_NULL_SID_AUTHORITY, 1, SECURITY_NULL_RID);
MKSID (well_known_world_sid, "S-1-1-0",
       SECURITY_WORLD_SID_AUTHORITY, 1, SECURITY_WORLD_RID);
MKSID (well_known_local_sid, "S-1-2-0",
       SECURITY_LOCAL_SID_AUTHORITY, 1, SECURITY_LOCAL_RID);
MKSID (well_known_console_logon_sid, "S-1-2-1",
       SECURITY_LOCAL_SID_AUTHORITY, 1, 1);
MKSID (well_known_creator_owner_sid, "S-1-3-0",
       SECURITY_CREATOR_SID_AUTHORITY, 1, SECURITY_CREATOR_OWNER_RID);
MKSID (well_known_creator_group_sid, "S-1-3-1",
       SECURITY_CREATOR_SID_AUTHORITY, 1, SECURITY_CREATOR_GROUP_RID);
MKSID (well_known_dialup_sid, "S-1-5-1",
       SECURITY_NT_AUTHORITY, 1, SECURITY_DIALUP_RID);
MKSID (well_known_network_sid, "S-1-5-2",
       SECURITY_NT_AUTHORITY, 1, SECURITY_NETWORK_RID);
MKSID (well_known_batch_sid, "S-1-5-3",
       SECURITY_NT_AUTHORITY, 1, SECURITY_BATCH_RID);
MKSID (well_known_interactive_sid, "S-1-5-4",
       SECURITY_NT_AUTHORITY, 1, SECURITY_INTERACTIVE_RID);
MKSID (well_known_service_sid, "S-1-5-6",
       SECURITY_NT_AUTHORITY, 1, SECURITY_SERVICE_RID);
MKSID (well_known_authenticated_users_sid, "S-1-5-11",
       SECURITY_NT_AUTHORITY, 1, SECURITY_AUTHENTICATED_USER_RID);
MKSID (well_known_this_org_sid, "S-1-5-15",
       SECURITY_NT_AUTHORITY, 1, 15);
MKSID (well_known_system_sid, "S-1-5-18",
       SECURITY_NT_AUTHORITY, 1, SECURITY_LOCAL_SYSTEM_RID);
MKSID (well_known_local_service_sid, "S-1-5-19",
       SECURITY_NT_AUTHORITY, 1, SECURITY_LOCAL_SERVICE_RID);
MKSID (well_known_network_service_sid, "S-1-5-20",
       SECURITY_NT_AUTHORITY, 1, SECURITY_NETWORK_SERVICE_RID);
MKSID (well_known_builtin_sid, "S-1-5-32",
       SECURITY_NT_AUTHORITY, 1, SECURITY_BUILTIN_DOMAIN_RID);
MKSID (well_known_admins_sid, "S-1-5-32-544",
       SECURITY_NT_AUTHORITY, 2, SECURITY_BUILTIN_DOMAIN_RID,
				 DOMAIN_ALIAS_RID_ADMINS);
MKSID (well_known_users_sid, "S-1-5-32-545",
       SECURITY_NT_AUTHORITY, 2, SECURITY_BUILTIN_DOMAIN_RID,
				 DOMAIN_ALIAS_RID_USERS);
MKSID (trusted_installer_sid,
       "S-1-5-80-956008885-3418522649-1831038044-1853292631-2271478464",
       SECURITY_NT_AUTHORITY, SECURITY_SERVICE_ID_RID_COUNT,
       SECURITY_SERVICE_ID_BASE_RID, 956008885U, 3418522649U, 1831038044U,
       1853292631U, 2271478464U);
MKSID (mandatory_medium_integrity_sid, "S-1-16-8192",
       SECURITY_MANDATORY_LABEL_AUTHORITY, 1, SECURITY_MANDATORY_MEDIUM_RID);
MKSID (mandatory_high_integrity_sid, "S-1-16-12288",
       SECURITY_MANDATORY_LABEL_AUTHORITY, 1, SECURITY_MANDATORY_HIGH_RID);
MKSID (mandatory_system_integrity_sid, "S-1-16-16384",
       SECURITY_MANDATORY_LABEL_AUTHORITY, 1, SECURITY_MANDATORY_SYSTEM_RID);
/* UNIX accounts on a Samba server have the SID prefix "S-1-22-1" */
#define SECURITY_SAMBA_UNIX_AUTHORITY {0,0,0,0,0,22}
MKSID (well_known_samba_unix_user_fake_sid, "S-1-22-1-0",
       SECURITY_SAMBA_UNIX_AUTHORITY, 2, 1, 0);

bool
cygpsid::operator== (const char *nsidstr) const
{
  cygsid nsid (nsidstr);
  return psid == nsid;
}

uid_t
cygpsid::get_id (BOOL search_grp, int *type, cyg_ldap *pldap)
{
    /* First try to get SID from group, then passwd */
  uid_t id = ILLEGAL_UID;

  if (search_grp)
    {
      struct group *gr;
      if (cygheap->user.groups.pgsid == psid)
	id = myself->gid;
      else if (sid_id_auth (psid) == 22)
	{
	  /* Samba UNIX group.  Try to map to Cygwin gid.  If there's no
	     mapping in the cache, try to fetch it from the configured
	     RFC 2307 domain (see last comment in cygheap_domain_info::init()
	     for more information) and add it to the mapping cache. */
	  gid_t gid = sid_sub_auth_rid (psid);
	  gid_t map_gid = cygheap->ugid_cache.get_gid (gid);
	  if (map_gid == ILLEGAL_GID)
	    {
	      if (pldap->open (cygheap->dom.get_rfc2307_domain ()) == NO_ERROR)
		map_gid = pldap->remap_gid (gid);
	      if (map_gid == ILLEGAL_GID) 
		map_gid = MAP_UNIX_TO_CYGWIN_ID (gid);
	      cygheap->ugid_cache.add_gid (gid, map_gid);
	    }
	  id = (uid_t) map_gid;
	}
      else if ((gr = internal_getgrsid (*this, pldap)))
	id = gr->gr_gid;
      if ((gid_t) id != ILLEGAL_GID)
	{
	  if (type)
	    *type = GROUP;
	  return id;
	}
    }
  if (!search_grp || type)
    {
      struct passwd *pw;
      if (*this == cygheap->user.sid ())
	id = myself->uid;
      else if (sid_id_auth (psid) == 22)
	{
	  /* Samba UNIX user.  See comment above. */
	  uid_t uid = sid_sub_auth_rid (psid);
	  uid_t map_uid = cygheap->ugid_cache.get_uid (uid);
	  if (map_uid == ILLEGAL_UID)
	    {
	      if (pldap->open (cygheap->dom.get_rfc2307_domain ()) == NO_ERROR)
		map_uid = pldap->remap_uid (uid);
	      if (map_uid == ILLEGAL_UID)
		map_uid = MAP_UNIX_TO_CYGWIN_ID (uid);
	      cygheap->ugid_cache.add_uid (uid, map_uid);
	    }
	  id = map_uid;
	}
      else if ((pw = internal_getpwsid (*this, pldap)))
	id = pw->pw_uid;
      if (id != ILLEGAL_UID && type)
	*type = USER;
    }
  return id;
}

PWCHAR
cygpsid::pstring (PWCHAR nsidstr) const
{
  UNICODE_STRING sid;

  if (!psid || !nsidstr)
    return NULL;
  RtlInitEmptyUnicodeString (&sid, nsidstr, 256);
  RtlConvertSidToUnicodeString (&sid, psid, FALSE);
  return nsidstr + sid.Length / sizeof (WCHAR);
}

PWCHAR
cygpsid::string (PWCHAR nsidstr) const
{
  if (pstring (nsidstr))
    return nsidstr;
  return NULL;
}

char *
cygpsid::pstring (char *nsidstr) const
{
  char *t;
  DWORD i;

  if (!psid || !nsidstr)
    return NULL;
  strcpy (nsidstr, "S-1-");
  t = nsidstr + sizeof ("S-1-") - 1;
  t += __small_sprintf (t, "%u", sid_id_auth (psid));
  for (i = 0; i < sid_sub_auth_count (psid); ++i)
    t += __small_sprintf (t, "-%lu", sid_sub_auth (psid, i));
  return t;
}

char *
cygpsid::string (char *nsidstr) const
{
  if (pstring (nsidstr))
    return nsidstr;
  return NULL;
}

PSID
cygsid::get_sid (DWORD s, DWORD cnt, DWORD *r, bool well_known)
{
  DWORD i;
  SID_IDENTIFIER_AUTHORITY sid_auth = { SECURITY_NULL_SID_AUTHORITY };
# define SECURITY_NT_AUTH 5

  if (s > 255 || cnt < 1 || cnt > SID_MAX_SUB_AUTHORITIES)
    {
      psid = NO_SID;
      return NULL;
    }
  sid_auth.Value[5] = s;
  set ();
  RtlInitializeSid (psid, &sid_auth, cnt);
  PISID dsid = (PISID) psid;
  for (i = 0; i < cnt; ++i)
    dsid->SubAuthority[i] = r[i];
  /* If the well_known flag isn't set explicitely, we check the SID
     for being a well-known SID ourselves. That's necessary because this
     cygsid is created from a SID string, usually from /etc/passwd or
     /etc/group.  The calling code just doesn't know if the SID is well-known
     or not.  All SIDs are well-known SIDs, except those in the non-unique NT
     authority range. */
  if (well_known)
    well_known_sid = well_known;
  else
    well_known_sid = (s != SECURITY_NT_AUTH
		      || r[0] != SECURITY_NT_NON_UNIQUE);
  return psid;
}

const PSID
cygsid::getfromstr (PCWSTR nsidstr, bool well_known)
{
  PWCHAR lasts;
  DWORD s, cnt = 0;
  DWORD r[SID_MAX_SUB_AUTHORITIES];

  if (nsidstr && !wcsncmp (nsidstr, L"S-1-", 4))
    {
      s = wcstoul (nsidstr + 4, &lasts, 10);
      while (cnt < SID_MAX_SUB_AUTHORITIES && *lasts == '-')
	r[cnt++] = wcstoul (lasts + 1, &lasts, 10);
      if (!*lasts)
	return get_sid (s, cnt, r, well_known);
    }
  return psid = NO_SID;
}

const PSID
cygsid::getfromstr (const char *nsidstr, bool well_known)
{
  char *lasts;
  DWORD s, cnt = 0;
  DWORD r[SID_MAX_SUB_AUTHORITIES];

  if (nsidstr && !strncmp (nsidstr, "S-1-", 4))
    {
      s = strtoul (nsidstr + 4, &lasts, 10);
      while (cnt < SID_MAX_SUB_AUTHORITIES && *lasts == '-')
	r[cnt++] = strtoul (lasts + 1, &lasts, 10);
      if (!*lasts)
	return get_sid (s, cnt, r, well_known);
    }
  return psid = NO_SID;
}

BOOL
cygsid::getfrompw (const struct passwd *pw)
{
  char *sp = (pw && pw->pw_gecos) ? strrchr (pw->pw_gecos, ',') : NULL;
  return (*this = sp ? sp + 1 : sp) != NULL;
}

BOOL
cygsid::getfromgr (const struct group *gr)
{
  char *sp = (gr && gr->gr_passwd) ? gr->gr_passwd : NULL;
  return (*this = sp) != NULL;
}

cygsid *
cygsidlist::alloc_sids (int n)
{
  if (n > 0)
    return (cygsid *) cmalloc (HEAP_STR, n * sizeof (cygsid));
  else
    return NULL;
}

void
cygsidlist::free_sids ()
{
  if (sids)
    cfree (sids);
  sids = NULL;
  cnt = maxcnt = 0;
  type = cygsidlist_empty;
}

BOOL
cygsidlist::add (const PSID nsi, bool well_known)
{
  if (contains (nsi))
    return TRUE;
  if (cnt >= maxcnt)
    {
      cygsid *tmp = new cygsid [2 * maxcnt];
      if (!tmp)
	return FALSE;
      maxcnt *= 2;
      for (int i = 0; i < cnt; ++i)
	tmp[i] = sids[i];
      delete [] sids;
      sids = tmp;
    }
  if (well_known)
    sids[cnt++] *= nsi;
  else
    sids[cnt++] = nsi;
  return TRUE;
}

bool
get_sids_info (cygpsid owner_sid, cygpsid group_sid, uid_t * uidret, gid_t * gidret)
{
  BOOL ret = false;
  cyg_ldap cldap;

  owner_sid.debug_print ("get_sids_info: owner SID =");
  group_sid.debug_print ("get_sids_info: group SID =");

  *uidret = owner_sid.get_uid (&cldap);
  *gidret = group_sid.get_gid (&cldap);
  if (*uidret == myself->uid)
    {
      if (*gidret == myself->gid)
	ret = TRUE;
      else
	CheckTokenMembership (cygheap->user.issetuid ()
			      ? cygheap->user.imp_token () : NULL,
			      group_sid, &ret);
    }
  return (bool) ret;
}

PSECURITY_DESCRIPTOR
security_descriptor::malloc (size_t nsize)
{
  free ();
  if ((psd = (PSECURITY_DESCRIPTOR) ::malloc (nsize)))
    sd_size = nsize;
  return psd;
}

PSECURITY_DESCRIPTOR
security_descriptor::realloc (size_t nsize)
{
  PSECURITY_DESCRIPTOR tmp;

  /* Can't re-use buffer allocated by GetSecurityInfo. */
  if (psd && !sd_size)
    free ();
  if (!(tmp = (PSECURITY_DESCRIPTOR) ::realloc (psd, nsize)))
    return NULL;
  sd_size = nsize;
  return psd = tmp;
}

void
security_descriptor::free ()
{
  if (psd)
    {
      if (!sd_size)
	LocalFree (psd);
      else
	::free (psd);
    }
  psd = NULL;
  sd_size = 0;
}

#undef TEXT
#define TEXT(q) L##q

/* Index must match the corresponding foo_PRIVILEGE value, see security.h. */
static const struct {
  const wchar_t *name;
  bool		 high_integrity; /* UAC: High Mandatory Label required to
				    be allowed to enable this privilege in
				    the user token. */
} cygpriv[] =
{
  { L"",				false },
  { L"",				false },
  { SE_CREATE_TOKEN_NAME,		true  },
  { SE_ASSIGNPRIMARYTOKEN_NAME,		true  },
  { SE_LOCK_MEMORY_NAME,		false },
  { SE_INCREASE_QUOTA_NAME,		true  },
  { SE_MACHINE_ACCOUNT_NAME,		false },
  { SE_TCB_NAME,			true  },
  { SE_SECURITY_NAME,			true  },
  { SE_TAKE_OWNERSHIP_NAME,		true  },
  { SE_LOAD_DRIVER_NAME,		true  },
  { SE_SYSTEM_PROFILE_NAME,		true  },
  { SE_SYSTEMTIME_NAME,			true  },
  { SE_PROF_SINGLE_PROCESS_NAME,	true  },
  { SE_INC_BASE_PRIORITY_NAME,		true  },
  { SE_CREATE_PAGEFILE_NAME,		true  },
  { SE_CREATE_PERMANENT_NAME,		false },
  { SE_BACKUP_NAME,			true  },
  { SE_RESTORE_NAME,			true  },
  { SE_SHUTDOWN_NAME,			false },
  { SE_DEBUG_NAME,			true  },
  { SE_AUDIT_NAME,			false },
  { SE_SYSTEM_ENVIRONMENT_NAME,		true  },
  { SE_CHANGE_NOTIFY_NAME,		false },
  { SE_REMOTE_SHUTDOWN_NAME,		true  },
  { SE_UNDOCK_NAME,			false },
  { SE_SYNC_AGENT_NAME,			false },
  { SE_ENABLE_DELEGATION_NAME,		false },
  { SE_MANAGE_VOLUME_NAME,		true  },
  { SE_IMPERSONATE_NAME,		true  },
  { SE_CREATE_GLOBAL_NAME,		false },
  { SE_TRUSTED_CREDMAN_ACCESS_NAME,	false },
  { SE_RELABEL_NAME,			true  },
  { SE_INC_WORKING_SET_NAME,		false },
  { SE_TIME_ZONE_NAME,			true  },
  { SE_CREATE_SYMBOLIC_LINK_NAME,	true  }
};

bool
privilege_luid (const PWCHAR pname, LUID &luid, bool &high_integrity)
{
  ULONG idx;
  for (idx = SE_CREATE_TOKEN_PRIVILEGE;
       idx <= SE_MAX_WELL_KNOWN_PRIVILEGE;
       ++idx)
    if (!wcscmp (cygpriv[idx].name, pname))
      {
	luid.HighPart = 0;
	luid.LowPart = idx;
	high_integrity = cygpriv[idx].high_integrity;
	return true;
      }
  return false;
}

static const wchar_t *
privilege_name (const LUID &priv_luid)
{
  if (priv_luid.HighPart || priv_luid.LowPart < SE_CREATE_TOKEN_PRIVILEGE
      || priv_luid.LowPart > SE_MAX_WELL_KNOWN_PRIVILEGE)
    return L"<unknown privilege>";
  return cygpriv[priv_luid.LowPart].name;
}

int
set_privilege (HANDLE token, DWORD privilege, bool enable)
{
  int ret = -1;
  TOKEN_PRIVILEGES new_priv, orig_priv;
  ULONG size;
  NTSTATUS status;

  new_priv.PrivilegeCount = 1;
  new_priv.Privileges[0].Luid.HighPart = 0L;
  new_priv.Privileges[0].Luid.LowPart = privilege;
  new_priv.Privileges[0].Attributes = enable ? SE_PRIVILEGE_ENABLED : 0;

  status = NtAdjustPrivilegesToken (token, FALSE, &new_priv, sizeof orig_priv,
				    &orig_priv, &size);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      goto out;
    }

  /* If orig_priv.PrivilegeCount is 0, the privilege hasn't been changed. */
  if (!orig_priv.PrivilegeCount)
    ret = enable ? 1 : 0;
  else
    ret = (orig_priv.Privileges[0].Attributes & SE_PRIVILEGE_ENABLED) ? 1 : 0;

out:
  if (ret < 0)
    debug_printf ("%d = set_privilege((token %p) %W, %d)", ret, token,
		  privilege_name (new_priv.Privileges[0].Luid), enable);
  return ret;
}

/* This is called very early in process initialization.  The code must
   not depend on anything. */
void
set_cygwin_privileges (HANDLE token)
{
  /* Setting these rights at process startup allows processes running under
     user tokens which are in the administrstors group to have root-like
     permissions. */
  /* Allow to access all files, independent of their ACL settings. */
  set_privilege (token, SE_RESTORE_PRIVILEGE, true);
  set_privilege (token, SE_BACKUP_PRIVILEGE, true);
  /* Allow full access to other user's processes. */
  set_privilege (token, SE_DEBUG_PRIVILEGE, true);
#if 0
  /* Allow to create global shared memory.  This isn't required anymore since
     Cygwin 1.7.  It uses its own subdirectories in the global NT namespace
     which isn't affected by the SE_CREATE_GLOBAL_PRIVILEGE restriction. */
  set_privilege (token, SE_CREATE_GLOBAL_PRIVILEGE, true);
#endif
}

bool
sec_acl (PACL acl, bool original, bool admins, PSID sid1, PSID sid2, DWORD access2)
{
  NTSTATUS status;
  size_t acl_len = MAX_DACL_LEN (5);
  LPVOID pAce;
  cygpsid psid;

#ifdef DEBUGGING
  if ((unsigned long) acl % 4)
    api_fatal ("Incorrectly aligned incoming ACL buffer!");
#endif
  status = RtlCreateAcl (acl, acl_len, ACL_REVISION);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("RtlCreateAcl: %y", status);
      return false;
    }
  if (sid1)
    {
      status = RtlAddAccessAllowedAce (acl, ACL_REVISION, GENERIC_ALL, sid1);
      if (!NT_SUCCESS (status))
	debug_printf ("RtlAddAccessAllowedAce(sid1) %y", status);
    }
  if (original && (psid = cygheap->user.saved_sid ())
      && psid != sid1 && psid != well_known_system_sid)
    {
      status = RtlAddAccessAllowedAce (acl, ACL_REVISION, GENERIC_ALL, psid);
      if (!NT_SUCCESS (status))
	debug_printf ("RtlAddAccessAllowedAce(original) %y", status);
    }
  if (sid2)
    {
      status = RtlAddAccessAllowedAce (acl, ACL_REVISION, access2, sid2);
      if (!NT_SUCCESS (status))
	debug_printf ("RtlAddAccessAllowedAce(sid2) %y", status);
    }
  if (admins)
    {
      status = RtlAddAccessAllowedAce (acl, ACL_REVISION, GENERIC_ALL,
				       well_known_admins_sid);
      if (!NT_SUCCESS (status))
	debug_printf ("RtlAddAccessAllowedAce(admin) %y", status);
    }
  status = RtlAddAccessAllowedAce (acl, ACL_REVISION, GENERIC_ALL,
				   well_known_system_sid);
  if (!NT_SUCCESS (status))
    debug_printf ("RtlAddAccessAllowedAce(system) %y", status);
  status = RtlFirstFreeAce (acl, &pAce);
  if (NT_SUCCESS (status) && pAce)
    acl->AclSize = (char *) pAce - (char *) acl;
  else
    debug_printf ("RtlFirstFreeAce: %y", status);

  return true;
}

PSECURITY_ATTRIBUTES __reg3
__sec_user (PVOID sa_buf, PSID sid1, PSID sid2, DWORD access2, BOOL inherit)
{
  PSECURITY_ATTRIBUTES psa = (PSECURITY_ATTRIBUTES) sa_buf;
  PISECURITY_DESCRIPTOR psd = (PISECURITY_DESCRIPTOR)
			     ((char *) sa_buf + sizeof (*psa));
  PACL acl = (PACL) ((char *) sa_buf + sizeof (*psa) + sizeof (*psd));
  NTSTATUS status;

#ifdef DEBUGGING
  if ((unsigned long) sa_buf % 4)
    api_fatal ("Incorrectly aligned incoming SA buffer!");
#endif
  if (!sec_acl (acl, true, true, sid1, sid2, access2))
    return inherit ? &sec_none : &sec_none_nih;

  RtlCreateSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION);
  status = RtlSetDaclSecurityDescriptor (psd, TRUE, acl, FALSE);
  if (!NT_SUCCESS (status))
    debug_printf ("RtlSetDaclSecurityDescriptor %y", status);

  psa->nLength = sizeof (SECURITY_ATTRIBUTES);
  psa->lpSecurityDescriptor = psd;
  psa->bInheritHandle = inherit;
  return psa;
}

/* Helper function to create a file security descriptor which allows
   full access to admins, system, and the sid given as parameter.  See
   try_to_bin for how it's used. */

PSECURITY_DESCRIPTOR
_recycler_sd (void *buf, bool users, bool dir)
{
  NTSTATUS status;
  PISECURITY_DESCRIPTOR psd = (PISECURITY_DESCRIPTOR) buf;

  if (!psd)
    return NULL;
  RtlCreateSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION);
  PACL dacl = (PACL) (psd + 1);
  /* Pre-Vista, the per-user recycler dir has a rather too complicated
     ACL by default, which has distinct ACEs for inheritable and non-inheritable
     permissions.  However, this ACL is practically equivalent to the ACL
     created since Vista.  Therefore we simplify our job here and create the
     pre-Vista permissions the same way as on Vista and later. */
  RtlCreateAcl (dacl, MAX_DACL_LEN (3), ACL_REVISION);
  RtlAddAccessAllowedAceEx (dacl, ACL_REVISION,
			    dir ? CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
				: NO_INHERITANCE,
			    FILE_ALL_ACCESS, well_known_admins_sid);
  RtlAddAccessAllowedAceEx (dacl, ACL_REVISION,
			    dir ? CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
				: NO_INHERITANCE,
			    FILE_ALL_ACCESS, well_known_system_sid);
  if (users)
    RtlAddAccessAllowedAceEx (dacl, ACL_REVISION, NO_PROPAGATE_INHERIT_ACE,
			      FILE_GENERIC_READ | FILE_GENERIC_EXECUTE
			      | FILE_APPEND_DATA | FILE_WRITE_ATTRIBUTES,
			      well_known_users_sid);
  else
    RtlAddAccessAllowedAceEx (dacl, ACL_REVISION,
			      dir ? CONTAINER_INHERIT_ACE
				    | OBJECT_INHERIT_ACE
				  : NO_INHERITANCE,
			      FILE_ALL_ACCESS, cygheap->user.sid ());
  LPVOID ace;
  status = RtlFirstFreeAce (dacl, &ace);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("RtlFirstFreeAce: %y", status);
      return NULL;
    }
  dacl->AclSize = (char *) ace - (char *) dacl;
  RtlSetDaclSecurityDescriptor (psd, TRUE, dacl, FALSE);
  /* If the directory DACL is not marked as protected, shell32 thinks
     the recycle dir is corrupted.  As soon as Explorer accesses the
     Recycler, the user will get a GUI dialog "The Recycle Bin on X:\
     is corrupted. Do you want to empty the Recycle Bin for this drive?"
     Of course we want to avoid that. */
  if (dir)
    psd->Control |= SE_DACL_PROTECTED;
  return psd;
}

/* Helper function to create an event security descriptor which only allows
   specific access to everyone.  Only the creating process has all access
   rights. */

PSECURITY_DESCRIPTOR
_everyone_sd (void *buf, ACCESS_MASK access)
{
  NTSTATUS status;
  PISECURITY_DESCRIPTOR psd = (PISECURITY_DESCRIPTOR) buf;

  if (psd)
    {
      RtlCreateSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION);
      PACL dacl = (PACL) (psd + 1);
      RtlCreateAcl (dacl, MAX_DACL_LEN (1), ACL_REVISION);
      status = RtlAddAccessAllowedAce (dacl, ACL_REVISION, access,
				       well_known_world_sid);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("RtlAddAccessAllowedAce: %y", status);
	  return NULL;
	}
      LPVOID ace;
      status = RtlFirstFreeAce (dacl, &ace);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("RtlFirstFreeAce: %y", status);
	  return NULL;
	}
      dacl->AclSize = (char *) ace - (char *) dacl;
      RtlSetDaclSecurityDescriptor (psd, TRUE, dacl, FALSE);
    }
  return psd;
}

@


1.110
log
@	* security.h (MAX_SUBAUTH_CNT): Drop.  Use SID_MAX_SUB_AUTHORITIES
	instead throughout.
	(MAX_SID_LEN): Drop.  Use SECURITY_MAX_SID_SIZE instead throughout.
@
text
@d125 1
a125 1
	      if (pldap->open (cygheap->dom.get_rfc2307_domain ()))
d154 1
a154 1
	      if (pldap->open (cygheap->dom.get_rfc2307_domain ()))
@


1.109
log
@	* grp.cc (internal_getgroups): Drop unused cygsid variable.
	* sec_helper.cc (cygpsid::pstring): Use sid_sub_auth_count macro.
	(cygsid::get_sid): Use MAX_SUBAUTH_CNT rather than wrong constant 8.
	Don't call memcpy to copy subauthorities into SID, use assignment.
	(cygsid::getfromstr): Use MAX_SUBAUTH_CNT rather than wrong constant 8.
	* security.h (MAX_SUBAUTH_CNT): New definition.  Set to 11 to cover
	Microsoft Accounts.
	(MAX_SID_LEN): Define in terms of SID member sizes and MAX_SUBAUTH_CNT.
	(DBGSID): Use MAX_SUBAUTH_CNT to define size of SubAuthority array.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Handle Micosoft
	Accounts.  Handle them as well known group.  Compare domain names
	case-insensitive.
	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.
@
text
@d221 1
a221 1
  if (s > 255 || cnt < 1 || cnt > MAX_SUBAUTH_CNT)
d229 1
a229 1
  PDBGSID dsid = (PDBGSID) psid;
d251 1
a251 1
  DWORD r[MAX_SUBAUTH_CNT];
d256 1
a256 1
      while (cnt < MAX_SUBAUTH_CNT && *lasts == '-')
d269 1
a269 1
  DWORD r[MAX_SUBAUTH_CNT];
d274 1
a274 1
      while (cnt < MAX_SUBAUTH_CNT && *lasts == '-')
@


1.108
log
@	* passwd.cc (pg_ent::enumerate_builtin): Convert pwd_builtins and
	grp_builtins to array of cygpsid pointers.  Replace SID strings with
	pointers to well known SIDs.
	* sec_helper.cc (well_known_local_service_sid): Define.
	(well_known_network_service_sid): Define.
	(trusted_installer_sid): Define.
	* security.h (well_known_local_service_sid): Declare.
	(well_known_network_service_sid): Declare.
	(trusted_installer_sid): Declare.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Throughout set acc_type
	to SidTypeUnknown if LookupAccountXXX function failed.  Create
	simplified passwd entry for non-user accounts, except for LocalSystem.
	Add comment.
@
text
@d201 1
a201 1
  for (i = 0; i < *RtlSubAuthorityCountSid (psid); ++i)
d221 1
a221 1
  if (s > 255 || cnt < 1 || cnt > 8)
d229 1
d231 1
a231 1
    memcpy ((char *) psid + 8 + sizeof (DWORD) * i, &r[i], sizeof (DWORD));
d251 1
a251 1
  DWORD r[8];
d256 1
a256 1
      while (cnt < 8 && *lasts == '-')
d269 1
a269 1
  DWORD r[8];
d274 1
a274 1
      while (cnt < 8 && *lasts == '-')
@


1.107
log
@	* sec_helper.cc (cygpsid::get_id): Move Samba SID->uid/gid mapping
	from get_sids_info here.
	(get_sids_info): Vice versa.
	* security.cc (convert_samba_sd): New static function to map a Samba
	security descriptor to a security descriptor with UNIX users and groups
	converted to Windows SIDs per RFC 2307 mapping.
	(check_file_access): Call convert_samba_sd on Samba security
	descriptors.
@
text
@d69 4
d81 5
@


1.106
log
@	* autoload.cc (CheckTokenMembership): Import.
	* external.cc (cygwin_internal): Call get_uid/get_gid instead of get_id.
	* grp.cc (internal_getgrsid): Take additional cyg_ldap pointer.
	Forward to pwdgrp::add_group_from_windows.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(gr_ent::enumerate_local): Drop ugid_caching bool from call to
	pwdgrp::fetch_account_from_windows.
	(getgroups32): Rename from internal_getgroups and drop getgroups32 stub.
	Drop srchsid parameter and code handling it.  Add local cyg_ldap
	instance and forward to internal_getgrXXX.
	(getgroups): Call getgroups32.
	(get_groups): Add local cyg_ldap instance and forward to
	internal_getgrXXX.
	(getgrouplist): Ditto.
	(setgroups32): Ditto.
	* ldap.cc (cyg_ldap::open): Don't call close.  Return true if connection
	is already open.
	(cyg_ldap::remap_uid): Forward this to internal_getpwsid.
	(cyg_ldap::remap_gid): Forward this to internal_getgrsid.
	* passwd.cc (internal_getpwsid): Take additional cyg_ldap pointer.
	Forward to pwdgrp::add_user_from_windows.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(pg_ent::enumerate_builtin): Drop ugid_caching bool from call to
	pwdgrp::fetch_account_from_windows.
	(pg_ent::enumerate_sam): Ditto.
	(pg_ent::enumerate_ad): Ditto.  Forward local cldap instead.
	* pwdgrp.h (internal_getpwsid): Align declaration to above change.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(internal_getgrsid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgroups): Drop declaration.
	(pwdgrp::add_account_from_windows): Align declaration to below change.
	(pwdgrp::add_user_from_windows): Ditto.
	(pwdgrp::add_group_from_windows): Ditto.
	* sec_acl.cc (setacl): Add local cyg_ldap instance and forward to
	internal_getpwuid and internal_getgrgid.
	(getacl): Add local cyg_ldap instance and forward to cygpsid::get_id.
	(aclfromtext32): Add local cyg_ldap instance and forward to
	internal_getpwnam and internal_getgrnam.
	* sec_helper.cc (cygpsid::get_id): Take additional cyg_ldap pointer.
	Forward to internal_getgrsid and internal_getpwsid.
	(get_sids_info): Drop ldap_open.  Forward local cldap to
	internal_getpwsid and internal_getgrXXX.  Call CheckTokenMembership
	rather than internal_getgroups.
	* security.h (cygpsid::get_id): Add cyg_ldap pointer, drop default
	parameter.
	(cygpsid::get_uid): Add cyg_ldap pointer.  Call get_id accordingly.
	(cygpsid::get_gid): Ditto.
	* uinfo.cc (internal_getlogin): Add local cyg_ldap instance and forward
	to internal_getpwXXX and internal_getgrXXX calls.
	(pwdgrp::add_account_from_windows): Take additional cyg_ldap pointer.
	Forward to pwdgrp::fetch_account_from_windows.
	(fetch_posix_offset): Drop ldap_open argument and handling.  Get
	cyg_ldap instance as pointer.
	(pwdgrp::fetch_account_from_windows): Take additional cyg_ldap pointer.
	Use it if it's not NULL, local instance otherwise.  Drop ldap_open.
	Drop fetching extended group arguments from AD for speed.
@
text
@d106 18
d126 1
a126 1
      if (id != ILLEGAL_UID)
d138 15
a330 2
  struct passwd *pw;
  struct group *gr = NULL;
a331 1
  PWCHAR domain;
d337 3
a339 27
  if (group_sid == cygheap->user.groups.pgsid)
    *gidret = myself->gid;
  else if (sid_id_auth (group_sid) == 22)
    {
      /* Samba UNIX group.  Try to map to Cygwin gid.  If there's no mapping in
	 the cache, try to fetch it from the configured RFC 2307 domain (see
	 last comment in cygheap_domain_info::init() for more information) and
	 add it to the mapping cache. */
      gid_t gid = sid_sub_auth_rid (group_sid);
      gid_t map_gid = cygheap->ugid_cache.get_gid (gid);
      if (map_gid == ILLEGAL_GID)
	{
	  domain = cygheap->dom.get_rfc2307_domain ();
	  if (cldap.open (domain))
	    map_gid = cldap.remap_gid (gid);
	  if (map_gid == ILLEGAL_GID)
	    map_gid = MAP_UNIX_TO_CYGWIN_ID (gid);
	  cygheap->ugid_cache.add_gid (gid, map_gid);
	}
      *gidret = map_gid;
    }
  else if ((gr = internal_getgrsid (group_sid, &cldap)))
    *gidret = gr->gr_gid;
  else
    *gidret = ILLEGAL_GID;

  if (owner_sid == cygheap->user.sid ())
a340 1
      *uidret = myself->uid;
a347 28
  else if (sid_id_auth (owner_sid) == 22)
    {
      /* Samba UNIX user.  See comment above. */
      uid_t uid = sid_sub_auth_rid (owner_sid);
      uid_t map_uid = cygheap->ugid_cache.get_uid (uid);
      if (map_uid == ILLEGAL_UID)
	{
	  domain = cygheap->dom.get_rfc2307_domain ();
	  if (cldap.open (domain))
	    map_uid = cldap.remap_uid (uid);
	  if (map_uid == ILLEGAL_UID)
	    map_uid = MAP_UNIX_TO_CYGWIN_ID (uid);
	  cygheap->ugid_cache.add_uid (uid, map_uid);
	}
      *uidret = map_uid;
    }
  else if ((pw = internal_getpwsid (owner_sid, &cldap)))
    {
      *uidret = pw->pw_uid;
      if (gr || (*gidret != ILLEGAL_GID
		 && (gr = internal_getgrgid (*gidret, &cldap))))
	for (int idx = 0; gr->gr_mem[idx]; ++idx)
	  if ((ret = strcasematch (pw->pw_name, gr->gr_mem[idx])))
	    break;
    }
  else
    *uidret = ILLEGAL_UID;

@


1.105
log
@	* autoload.cc (NetLocalGroupGetInfo): Replace NetGroupGetInfo.
	* cygheap.h (class cygheap_ugid_cache): Move ugid_cache_t type here
	and rename.
	(struct init_cygheap): Add cygheap_ugid_cache member "ugid_cache".
	* pwdgrp.h (class ugid_cache_t): Remove here.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Accommodate
	move of ugid_cache to cygheap.
	* sec_helper.cc (get_sids_info): Ditto.
	* uinfo.cc (ugid_cache): Remove.
	(pwdgrp::fetch_account_from_windows): Define id_val globally.
	Move SidTypeAlias handling into SidTypeUser/SidTypeGroup branch since
	aliases are handled like groups in SAM.  Accommodate move of ugid_cache
	to cygheap.  Consolidate code reading SAM comments into a single branch
	for both, SidTypeUser and SidTypeAlias.  For SidTypeAlias, fix thinko
	and call NetLocalGroupGetInfo rather than NetGroupGetInfo.  Simplify
	code setting Cygwin primary group for SAM accounts.  Add code to handle
	UNIX uid/gid from SAM comment.
@
text
@d96 1
a96 1
cygpsid::get_id (BOOL search_grp, int *type)
d106 1
a106 1
      else if ((gr = internal_getgrsid (*this)))
d120 1
a120 1
      else if ((pw = internal_getpwsid (*this)))
d300 1
a300 1
  bool ret = false;
a302 1
  bool ldap_open = false;
d320 1
a320 1
	  if ((ldap_open = cldap.open (domain)))
d328 1
a328 1
  else if ((gr = internal_getgrsid (group_sid)))
d337 1
a337 1
	ret = true;
d339 3
a341 1
	ret = (internal_getgroups (0, NULL, &group_sid) > 0);
d351 1
a351 1
	  if ((ldap_open || cldap.open (domain)))
d359 1
a359 1
  else if ((pw = internal_getpwsid (owner_sid)))
d363 1
a363 1
		 && (gr = internal_getgrgid (*gidret))))
d371 1
a371 1
  return ret;
@


1.104
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d317 1
a317 1
      gid_t map_gid = ugid_cache.get_gid (gid);
d325 1
a325 1
	  ugid_cache.add_gid (gid, map_gid);
d346 1
a346 1
      uid_t map_uid = ugid_cache.get_uid (uid);
d354 1
a354 1
	  ugid_cache.add_uid (uid, map_uid);
@


1.103
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d4 1
a4 1
   2011, 2012, 2013 Red Hat, Inc.
a24 1
#include "pwdgrp.h"
d26 1
d129 1
a129 1
cygpsid::string (PWCHAR nsidstr) const
d137 9
a145 1
  return nsidstr;
d149 1
a149 1
cygpsid::string (char *nsidstr) const
d158 1
a158 1
  t += __small_sprintf (t, "%u", RtlIdentifierAuthoritySid (psid)->Value[5]);
d160 10
a169 2
    t += __small_sprintf (t, "-%lu", *RtlSubAuthoritySid (psid, i));
  return nsidstr;
d204 18
d301 3
d310 19
d342 16
@


1.102
log
@	* Merge in cygwin-64bit-branch.
@
text
@d525 1
a525 1
PSECURITY_ATTRIBUTES __stdcall
@


1.101
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d4 1
a4 1
   2011, 2012 Red Hat, Inc.
d29 11
a39 4
SECURITY_ATTRIBUTES NO_COPY sec_none;
SECURITY_ATTRIBUTES NO_COPY sec_none_nih;
SECURITY_ATTRIBUTES NO_COPY sec_all;
SECURITY_ATTRIBUTES NO_COPY sec_all_nih;
a76 2
MKSID (fake_logon_sid, "S-1-5-5-0-0",
       SECURITY_NT_AUTHORITY, 3, SECURITY_LOGON_IDS_RID, 0, 0);
d95 1
a95 1
__uid32_t
d99 1
a99 1
  __uid32_t id = ILLEGAL_UID;
d103 1
a103 1
      struct __group32 *gr;
d213 1
a213 1
cygsid::getfromgr (const struct __group32 *gr)
d262 1
a262 1
get_sids_info (cygpsid owner_sid, cygpsid group_sid, __uid32_t * uidret, __gid32_t * gidret)
d265 1
a265 1
  struct __group32 *gr = NULL;
d442 1
a442 1
    debug_printf ("%d = set_privilege((token %x) %W, %d)", ret, token,
d464 1
a464 2
  if (wincap.has_create_global_privilege ())
    set_privilege (token, SE_CREATE_GLOBAL_PRIVILEGE, true);
a467 33
/* Function to return a common SECURITY_DESCRIPTOR that
   allows all access.  */

static inline PSECURITY_DESCRIPTOR
get_null_sd ()
{
  static NO_COPY SECURITY_DESCRIPTOR sd;
  static NO_COPY PSECURITY_DESCRIPTOR null_sdp;

  if (!null_sdp)
    {
      RtlCreateSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
      RtlSetDaclSecurityDescriptor (&sd, TRUE, NULL, FALSE);
      null_sdp = &sd;
    }
  return null_sdp;
}

/* Initialize global security attributes.
   Called from dcrt0.cc (_dll_crt0).  */

void
init_global_security ()
{
  sec_none.nLength = sec_none_nih.nLength =
  sec_all.nLength = sec_all_nih.nLength = sizeof (SECURITY_ATTRIBUTES);
  sec_none.bInheritHandle = sec_all.bInheritHandle = TRUE;
  sec_none_nih.bInheritHandle = sec_all_nih.bInheritHandle = FALSE;
  sec_none.lpSecurityDescriptor = sec_none_nih.lpSecurityDescriptor = NULL;
  sec_all.lpSecurityDescriptor = sec_all_nih.lpSecurityDescriptor =
    get_null_sd ();
}

d483 1
a483 1
      debug_printf ("RtlCreateAcl: %p", status);
d490 1
a490 1
	debug_printf ("RtlAddAccessAllowedAce(sid1) %p", status);
d497 1
a497 1
	debug_printf ("RtlAddAccessAllowedAce(original) %p", status);
d503 1
a503 1
	debug_printf ("RtlAddAccessAllowedAce(sid2) %p", status);
d510 1
a510 1
	debug_printf ("RtlAddAccessAllowedAce(admin) %p", status);
d515 1
a515 1
    debug_printf ("RtlAddAccessAllowedAce(system) %p", status);
d520 1
a520 1
    debug_printf ("RtlFirstFreeAce: %p", status);
d544 1
a544 1
    debug_printf ("RtlSetDaclSecurityDescriptor %p", status);
d595 1
a595 1
      debug_printf ("RtlFirstFreeAce: %p", status);
d629 1
a629 1
	  debug_printf ("RtlAddAccessAllowedAce: %p", status);
d636 1
a636 1
	  debug_printf ("RtlFirstFreeAce: %p", status);
@


1.100
log
@	* fhandler_registry.cc: Drop Mingw.org considerations.
	* fhandler_serial.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* net.cc: Ditto.
	* ntdll.h: Ditto.
	* sched.cc: Ditto.
	* sec_helper.cc: Ditto.
@
text
@d3 2
a4 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008, 2009,
   2010, 2011, 2012 Red Hat, Inc.
@


1.99
log
@whitespace cleanup
@
text
@a27 4
#ifndef __MINGW64_VERSION_MAJOR
#define SECURITY_NT_NON_UNIQUE SECURITY_NT_NON_UNIQUE_RID
#endif

a376 3
#ifndef __MINGW64_VERSION_MAJOR
  { SE_INCREASE_WORKING_SET_NAME,	false },
#else
a377 1
#endif
@


1.98
log
@	* fhandler_registry.cc (RegOpenUserClassesRoot): Only define when
	building against w32api headers.
	(RegOpenCurrentUser): Ditto.
	* fhandler_tty.cc (GetNamedPipeClientProcessId): Ditto.
	* ntdll.h (enum _PROCESSINFOCLASS): Add ProcessImageFileName.
	(RtlInitAnsiString): Declare.
	(RtlUnicodeStringToAnsiSize): Declare.
	* sched.cc (GetForegroundWindow): Ditto.
	* sec_helper.cc (SECURITY_NT_NON_UNIQUE): Define as
	SECURITY_NT_NON_UNIQUE_RID when building against w32api headers.
	(cygsid::get_sid): Use SECURITY_NT_NON_UNIQUE rather than
	SECURITY_NT_NON_UNIQUE_RID.
	(__sec_user): Use PISECURITY_DESCRIPTOR rather than PSECURITY_DESCRIPTOR
	to allow valid pointer arithmetic.
	(_recycler_sd): Ditto.
	(_everyone_sd): Ditto.
@
text
@d598 1
a598 1
  
d617 1
a617 1
  if (users)	
@


1.98.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d94 1
a94 1
uid_t
d98 1
a98 1
  uid_t id = ILLEGAL_UID;
d102 1
a102 1
      struct group *gr;
d212 1
a212 1
cygsid::getfromgr (const struct group *gr)
d261 1
a261 1
get_sids_info (cygpsid owner_sid, cygpsid group_sid, uid_t * uidret, gid_t * gidret)
d264 1
a264 1
  struct group *gr = NULL;
@


1.98.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d598 1
a598 1

d617 1
a617 1
  if (users)
@


1.98.2.3
log
@Pull in changes from HEAD
@
text
@d28 4
d381 3
d385 1
@


1.98.2.4
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d437 1
a437 1
    debug_printf ("%d = set_privilege((token %p) %W, %d)", ret, token,
d512 1
a512 1
      debug_printf ("RtlCreateAcl: %y", status);
d519 1
a519 1
	debug_printf ("RtlAddAccessAllowedAce(sid1) %y", status);
d526 1
a526 1
	debug_printf ("RtlAddAccessAllowedAce(original) %y", status);
d532 1
a532 1
	debug_printf ("RtlAddAccessAllowedAce(sid2) %y", status);
d539 1
a539 1
	debug_printf ("RtlAddAccessAllowedAce(admin) %y", status);
d544 1
a544 1
    debug_printf ("RtlAddAccessAllowedAce(system) %y", status);
d549 1
a549 1
    debug_printf ("RtlFirstFreeAce: %y", status);
d573 1
a573 1
    debug_printf ("RtlSetDaclSecurityDescriptor %y", status);
d624 1
a624 1
      debug_printf ("RtlFirstFreeAce: %y", status);
d658 1
a658 1
	  debug_printf ("RtlAddAccessAllowedAce: %y", status);
d665 1
a665 1
	  debug_printf ("RtlFirstFreeAce: %y", status);
@


1.98.2.5
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011, 2012 Red Hat, Inc.
@


1.98.2.6
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d4 1
a4 1
   2011, 2012, 2013 Red Hat, Inc.
d29 4
a32 11
static NO_COPY_RO SECURITY_DESCRIPTOR null_sdp =
	{ SECURITY_DESCRIPTOR_REVISION, 0, SE_DACL_PRESENT,
	  NULL, NULL, NULL, NULL };
SECURITY_ATTRIBUTES NO_COPY_RO sec_none =
	{ sizeof (SECURITY_ATTRIBUTES), NULL, TRUE };
SECURITY_ATTRIBUTES NO_COPY_RO sec_none_nih =
	{ sizeof (SECURITY_ATTRIBUTES), NULL, FALSE };
SECURITY_ATTRIBUTES NO_COPY_RO sec_all =
	{ sizeof (SECURITY_ATTRIBUTES), &null_sdp, TRUE };
SECURITY_ATTRIBUTES NO_COPY_RO sec_all_nih =
	{ sizeof (SECURITY_ATTRIBUTES), &null_sdp, FALSE };
d464 33
@


1.98.2.7
log
@	* autoload.cc (AttachConsole): Remove.
	(GetModuleHandleExW): Remove.
	(GetSystemWow64DirectoryW): Remove.
	(GetVolumePathNamesForVolumeNameW): Remove.
	* exceptions.cc (cygwin_stackdump): Always call RtlCaptureContext.
	(exception::handle): Drop accidentally left in debugging statement.
	Always call RtlCaptureContext.
	(sigpacket::process): Always call RtlCaptureContext for current thread.
	* fhandler_disk_file.cc (fstatvfs): Drop code using
	FileFsSizeInformation.
	(struct __DIR_cache): Remove comment.
	(fhandler_disk_file::rewinddir): Drop W2K-only code.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Don't
	check for old OS.  Extend a comment.
	* fhandler_mem.cc (fhandler_dev_mem::open): Drop NT4 and W2K from
	debug output.
	* fhandler_proc.cc (format_proc_partitions): Drop Pre-XP considerations.
	* fhandler_procnet.cc (fhandler_procnet::exists): Ditto.
	(fhandler_procnet::readdir): Ditto.
	(format_procnet_ifinet6): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvmsg): Ditto.
	* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
	* init.cc (dll_entry): Drop W2K-only code.
	* net.cc (get_ifs): Rename from get_xp_ifs.
	(get_2k_ifs): Remove.
	(getifaddrs): Always call get_ifs.
	(get_ifconf): Ditto.
	(if_nametoindex): Drop Pre-XP considerations.
	(load_ipv6_funcs): Ditto.  Fix preceeding comment.
	* sec_auth.cc (lsaauth): Drop code handling fake_login_sid.
	* sec_helper.cc (fake_logon_sid): Remove.
	(set_cygwin_privileges): Fix uncommented statement to drop pre-XP
	considerations.
	* security.h (fake_logon_sid): Drop declaration.
	* shared.cc (shared_info::init_obcaseinsensitive): Drop W2K-only code.
	* wincap.cc: Throughout, remove setting all deprecated wincapc members.
	(wincap_minimal): Set to wincap_xpsp2.
	(wincap_2000): Remove.
	(wincap_2000sp4): Remove.
	(wincap_xp): Remove.
	(wincap_xpsp1): Remove.
	(wincapc::init): Drop OS 5.0 and pre-SP2 XP.
	* wincap.h (struct wincaps): Remove the following members:
	has_create_global_privilege, has_ioctl_storage_get_media_types_ex,
	has_disk_ex_ioctls, has_buggy_restart_scan, needs_logon_sid_in_sid_list,
	has_gaa_prefixes, has_recvmsg, has_stack_size_param_is_a_reservation,
	kernel_is_always_casesensitive, has_rtl_capture_context.
@
text
@d77 2
d466 2
a467 1
  set_privilege (token, SE_CREATE_GLOBAL_PRIVILEGE, true);
@


1.97
log
@	* globals.cc (ro_u_refs): New R/O unicode string.
	* mount.cc (fs_info::update): Recognize ReFS.
	* mount.h (enum fs_info_type): Add refs.
	(class fs_info): Add refs flag and accessor methods.
	* ntdll.h (RtlAddAccessAllowedAceEx): Declare.
	(RtlAddAccessDeniedAceEx): Declare.
	* path.h (path_conv::fs_is_refs): Define.
	* sec_helper.cc (_recycler_sd): New function to create security
	descriptors suitable for the recycler bin starting with Vista.
	* security.cc (add_access_allowed_ace): Use RtlAddAccessAllowedAceEx
	and drop code to set AceFlags explicitely.
	(add_access_denied_ace): Use RtlAddAccessDeniedAceEx and drop code to
	set AceFlags explicitely.
	* security.h (_recycler_sd): Declare.
	(recycler_sd): Define.
	* syscalls.cc (desktop_ini): Change formatting.
	(desktop_ini_ext): Define third line of recycler desktop.ini file
	since Vista,
	(try_to_bin): Handle ReFS just like NTFS.  Write Vista and later
	Recycler in all uppercase, just like shell32 does when recreating it.
	Fix comments to include ReFS.  Don't implicitely reuse object
	attributes from earlier NtOpenFile call, rather recreate it for safety.
	Use recycler_sd call when creating security descriptor for Recycler
	dirs and files on Vista and later.  Write third line of desktop.ini
	when on Vista and later.
@
text
@d28 4
d182 1
a182 1
		      || r[0] != SECURITY_NT_NON_UNIQUE_RID);
d381 1
d383 3
d566 1
a566 1
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR)
d597 1
a597 1
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) buf;
d655 1
a655 1
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) buf;
@


1.96
log
@Clean up whitespace.
@
text
@d4 1
a4 1
   2010, 2011 Red Hat, Inc.
d581 58
@


1.95
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d339 1
a339 1
  bool		 high_integrity; /* UAC: High Mandatory Label required to 
@


1.94
log
@	* sec_auth.cc (get_token_group_sidlist): Add CONSOLE LOGON SID on
	systems supporting it.  Never add SERVICE SID but keep code in for
	future reference.  Explain why.
	(get_priv_list): Add cygpsid pointer parameter.  Point it to the
	mandatory integrity SID which matches account and privileges.
	(create_token): Fetch mandatory integrity SID from call to
	get_priv_list.
	(lsaauth): Call get_priv_list with additional NULL pointer.  Change
	comment accordingly.
	* sec_helper.cc (well_known_console_logon_sid): New static SID.
	(cygpriv): Change to structure containing extra flag to store info
	about required integrity level.
	(privilege_luid): Accommodate changes to cygpriv.  Return integrity
	level in new high_integrity parameter.
	(privilege_name): Accommodate changes to cygpriv.
	(set_privilege): Drop trailing \n from debug output.
	(set_cygwin_privileges): Don't set SE_CREATE_GLOBAL_PRIVILEGE anymore
	since it's just not needed, but keep code in for future reference.
	Change comment accordingly.
	* security.h (well_known_console_logon_sid): Declare.
	(privilege_luid): Align declaration to above change.
	* wincap.h (wincaps::has_console_logon_sid): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d437 1
a437 1
    debug_printf ("%d = set_privilege ((token %x) %W, %d)", ret, token,
@


1.93
log
@	* advapi32.cc: Add comment.
	(EqualSid): Remove.
	(CopySid): Remove.
	(AddAccessAllowedAce): Remove.
	(AddAccessDeniedAce): Remove.
	(MakeSelfRelativeSD): Remove.
	* flock.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
	* security.h: Ditto.
	(RtlEqualSid): Declare.  Explain why.
	(RtlCopySid): Ditto.
@
text
@d40 2
d336 44
a379 39
/* Index must match the correspoding foo_PRIVILEGE value, see security.h. */
static const wchar_t *cygpriv[] =
{
  L"",
  L"",
  SE_CREATE_TOKEN_NAME,
  SE_ASSIGNPRIMARYTOKEN_NAME,
  SE_LOCK_MEMORY_NAME,
  SE_INCREASE_QUOTA_NAME,
  SE_MACHINE_ACCOUNT_NAME,
  SE_TCB_NAME,
  SE_SECURITY_NAME,
  SE_TAKE_OWNERSHIP_NAME,
  SE_LOAD_DRIVER_NAME,
  SE_SYSTEM_PROFILE_NAME,
  SE_SYSTEMTIME_NAME,
  SE_PROF_SINGLE_PROCESS_NAME,
  SE_INC_BASE_PRIORITY_NAME,
  SE_CREATE_PAGEFILE_NAME,
  SE_CREATE_PERMANENT_NAME,
  SE_BACKUP_NAME,
  SE_RESTORE_NAME,
  SE_SHUTDOWN_NAME,
  SE_DEBUG_NAME,
  SE_AUDIT_NAME,
  SE_SYSTEM_ENVIRONMENT_NAME,
  SE_CHANGE_NOTIFY_NAME,
  SE_REMOTE_SHUTDOWN_NAME,
  SE_UNDOCK_NAME,
  SE_SYNC_AGENT_NAME,
  SE_ENABLE_DELEGATION_NAME,
  SE_MANAGE_VOLUME_NAME,
  SE_IMPERSONATE_NAME,
  SE_CREATE_GLOBAL_NAME,
  SE_TRUSTED_CREDMAN_ACCESS_NAME,
  SE_RELABEL_NAME,
  SE_INCREASE_WORKING_SET_NAME,
  SE_TIME_ZONE_NAME,
  SE_CREATE_SYMBOLIC_LINK_NAME
d383 1
a383 1
privilege_luid (const PWCHAR pname, LUID *luid)
d389 1
a389 1
    if (!wcscmp (cygpriv[idx], pname))
d391 3
a393 2
	luid->HighPart = 0;
	luid->LowPart = idx;
d405 1
a405 1
  return cygpriv[priv_luid.LowPart];
d437 1
a437 1
    debug_printf ("%d = set_privilege ((token %x) %W, %d)\n", ret, token,
d455 2
a456 1
  /* Allow to create global shared memory.  This shouldn't be required since
d458 1
a458 2
     which isn't affected by the SE_CREATE_GLOBAL_PRIVILEGE restriction.
     Anyway, better safe than sorry. */
d461 1
@


1.92
log
@	* advapi32.cc (SetSecurityDescriptorDacl): Remove.
	(SetSecurityDescriptorGroup): Remove.
	(SetSecurityDescriptorOwner): Remove.
	* pinfo.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_acl.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.

	* sec_helper.cc (__sec_user): Remove old comment.
@
text
@d507 5
a511 3
    if (!AddAccessAllowedAce (acl, ACL_REVISION,
			      GENERIC_ALL, sid1))
      debug_printf ("AddAccessAllowedAce(sid1) %E");
d514 5
a518 3
    if (!AddAccessAllowedAce (acl, ACL_REVISION,
			      GENERIC_ALL, psid))
      debug_printf ("AddAccessAllowedAce(original) %E");
d520 5
a524 3
    if (!AddAccessAllowedAce (acl, ACL_REVISION,
			      access2, sid2))
      debug_printf ("AddAccessAllowedAce(sid2) %E");
d526 10
a535 6
    if (!AddAccessAllowedAce (acl, ACL_REVISION,
			      GENERIC_ALL, well_known_admins_sid))
      debug_printf ("AddAccessAllowedAce(admin) %E");
  if (!AddAccessAllowedAce (acl, ACL_REVISION,
			    GENERIC_ALL, well_known_system_sid))
    debug_printf ("AddAccessAllowedAce(system) %E");
d587 3
a589 2
      if (!AddAccessAllowedAce (dacl, ACL_REVISION, access,
				well_known_world_sid))
d591 1
a591 1
	  debug_printf ("AddAccessAllowedAce: %lu", GetLastError ());
@


1.91
log
@	* advapi32.cc (InitializeAcl): Remove.
	(AddAce): Remove.
	(FindFirstFreeAce): Remove.
	(GetAce): Remove.
	(InitializeSecurityDescriptor): Remove.
	(OpenProcessToken): Remove.
	* dcrt0.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* fhandler_tty.cc: Ditto.
	* flock.cc: Ditto.
	* pinfo.cc: Ditto.  Drop unnecessary error handling.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d467 1
a467 1
      SetSecurityDescriptorDacl (&sd, TRUE, NULL, FALSE);
d542 1
d552 3
a554 13

/*
 * Setting the owner lets the created security attribute not work
 * on NT4 SP3 Server. Don't know why, but the function still does
 * what it should do also if the owner isn't set.
*/
#if 0
  if (!SetSecurityDescriptorOwner (psd, sid, FALSE))
    debug_printf ("SetSecurityDescriptorOwner %E");
#endif

  if (!SetSecurityDescriptorDacl (psd, TRUE, acl, FALSE))
    debug_printf ("SetSecurityDescriptorDacl %E");
d591 1
a591 1
      SetSecurityDescriptorDacl (psd, TRUE, dacl, FALSE);
@


1.90
log
@	* advapi32.cc (InitializeSid): Remove.
	(EqualPrefixSid): Remove.
	(GetLengthSid): Remove.
	(GetSidSubAuthority): Remove.
	(GetSidSubAuthorityCount): Remove.
	(GetSidIdentifierAuthority): Remove.
	* fhandler_disk_file.cc: Remove above functions throughout with their
	ntdll.dll equivalent.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d466 1
a466 1
      InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
d491 1
d500 2
a501 1
  if (!InitializeAcl (acl, acl_len, ACL_REVISION))
d503 1
a503 1
      debug_printf ("InitializeAcl %E");
d526 2
a527 2
  FindFirstFreeAce (acl, &pAce);
  if (pAce)
d530 1
a530 1
    debug_printf ("FindFirstFreeAce %E");
d550 1
a550 2
  if (!InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION))
    debug_printf ("InitializeSecurityDescriptor %E");
d578 1
d583 1
a583 1
      InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION);
d585 1
a585 1
      InitializeAcl (dacl, MAX_DACL_LEN (1), ACL_REVISION);
d593 2
a594 1
      if (!FindFirstFreeAce (dacl, &ace))
d596 1
a596 1
	  debug_printf ("FindFirstFreeAce: %lu", GetLastError ());
@


1.89
log
@	* sec_auth.cc (get_user_groups): Mark well-known groups as well-known.
	(get_user_local_groups): Ditto.
	(verify_token): Drop useless label.
	* sec_helper.cc (cygsid::get_sid): Check for well-known SID if
	well_known isn't set.
	* security.h (well_known_sid_type): New inline function.
@
text
@d143 3
a145 3
  t += __small_sprintf (t, "%u", GetSidIdentifierAuthority (psid)->Value[5]);
  for (i = 0; i < *GetSidSubAuthorityCount (psid); ++i)
    t += __small_sprintf (t, "-%lu", *GetSidSubAuthority (psid, i));
d163 1
a163 1
  InitializeSid (psid, &sid_auth, cnt);
@


1.88
log
@	* sec_helper.cc (get_null_sd): Make static.  Use PSECURITY_DESCRIPTOR
	instead of SECURITY_DESCRIPTOR *.
	(sec_acl): Fix fomratting.
	* security.h (get_null_sd): Drop declaration.
@
text
@d4 1
a4 1
   2010 Red Hat, Inc.
d153 2
a154 1
  SID_IDENTIFIER_AUTHORITY sid_auth = {{0,0,0,0,0,0}};
d166 11
a176 1
  well_known_sid = well_known;
@


1.87
log
@	* sec_helper.cc (set_cygwin_privileges): Enable SE_DEBUG_PRIVILEGE, if
	available.  Add comments.
@
text
@d447 1
a447 2

SECURITY_DESCRIPTOR *__stdcall
d451 1
a451 1
  static NO_COPY SECURITY_DESCRIPTOR *null_sdp;
d456 1
a456 1
      SetSecurityDescriptorDacl (&sd, TRUE, 0, FALSE);
d480 1
a480 1
  size_t acl_len = MAX_DACL_LEN(5);
@


1.86
log
@	* sec_auth.cc (get_user_local_groups): Retrieve name of well known
	builtin group from system.  Explain why.
	* sec_helper.cc (well_known_builtin_sid): New SID for BUILTIN group.
	* security.h (well_known_builtin_sid): Declare.
@
text
@d428 4
d434 6
@


1.85
log
@	* sec_auth.cc (get_token_group_sidlist): Add BUILTIN\Users account
	to all created tokens.
	* sec_helper.cc (well_known_users_sid): Define as BUILTIN\Users.
	* security.h (well_known_users_sid): Declare.
@
text
@d60 2
@


1.84
log
@	* sec_helper.cc (security_descriptor::realloc): Call free first if
	current security desriptor has been allocated by GetSecurityInfo.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008 Red Hat, Inc.
d63 3
@


1.83
log
@	* sec_helper.cc (security_descriptor::free): If sd_size is 0, call
	LocalFree instead of ::free.

	* sec_acl.cc: Throughout replace old ACE flag definitions with current
	definitions as used in MSDN man pages.
	* security.cc: Ditto.

	* fhandler.cc (fhandler_base::open): Make sure file has really been
	just created before fixing file permissions.  Add S_JUSTCREATED
	attribute to set_file_attribute call.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Always create dir
	with default security descriptor and fix descriptor afterwards.
	Add S_JUSTCREATED flag to set_file_attribute call.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Call GetSecurityInfo rather than
	NtQuerySecurityObject.  Explain why.  Change error handling accordingly.
	(alloc_sd): Skip non-inherited, non-standard entries in ACL if
	S_JUSTCREATED attribute is set.  Explain why.  Minor format fixes.
	* security.h (S_JUSTCREATED): New define.
	(security_descriptor::operator=): New operator.
@
text
@d291 3
@


1.82
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchown): Catch an
	error when changing the user account on a standalone Samba server.
	Explain why.
	* sec_acl.cc (setacl): Accommodate additional parameter to set_file_sd.
	* sec_helper.cc (SECURITY_SAMBA_UNIX_AUTHORITY): Define.
	(well_known_samba_unix_user_fake_sid): Define.
	* security.cc (set_file_sd): Take additional parameter if ownership
	should be changed.  Restrict requested permissions accordingly.
	(set_file_attribute): Accommodate additional parameter to set_file_sd.
	* security.h (well_known_samba_unix_user_fake_sid): Declare.
	(set_file_sd): Align declaration to above change.
@
text
@d301 6
a306 1
    ::free (psd);
@


1.81
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d70 4
@


1.80
log
@* localtime.cc (increment_overflow): Mark as non-inline to prevent compiler
from complaining about the very thing we're trying to test.
* ntea.cc (read_ea): Reorganize to avoid a new compiler warning/error.
* sched.cc (sched_rr_get_interval): Ditto.
* select.cc (peek_serial): Ditto.
* libc/rexec.cc (ruserpass): Ditto.
* posix_ipc.cc (ipc_names): Make static to avoid a compiler warning
(and it's the right thing to do anyway).
@
text
@d546 1
a546 1
      if (!AddAccessAllowedAce (dacl, ACL_REVISION, access, 
@


1.79
log
@	Change length for domain buffers from INTERNET_MAX_HOST_NAME_LENGTH to
	MAX_DOMAIN_NAME_LEN throughout.
	* cyglsa.h (CYG_LSA_MAGIC): New value.
	(cyglsa_t): Define username and domain as WCHAR arrays.
	* errno.cc (errmap): Add mapping for ERROR_NONE_MAPPED.
	* sec_auth.cc: Drop 'w' prefix from WCHAR string variable names where
	appropriate.
	(extract_nt_dom_user): Prefer resolving by SID before resolving by
	domain\name pair.
	(cygwin_logon_user): Don't print cleartext password in debug output.
	Change comment.
	(get_user_groups): Revert calls to LookupAccountNameW to use NULL
	server instead of explicit server name, according to MSDN.
	(get_user_local_groups): Ditto.
	(get_server_groups): Fetch domain and user name from usersid per
	LookupAccountSidW instead of calling extract_nt_dom_user.
	(lsaauth): Fetch domain and user name from usersid per LookupAccountSidW
	instead of calling extract_nt_dom_user.
	* sec_helper.cc (cygpriv): Convert to wchar_t pointer array.
	(privilege_luid): Convert first parameter to  PWCHAR.
	(privilege_name): Return wchar_t pointer.
	(set_privileges): Accommodate debug output.
	* security.h (privilege_luid): Change prototype accordingly.
@
text
@d143 1
a143 1
  SID_IDENTIFIER_AUTHORITY sid_auth = {0,0,0,0,0,0};
@


1.78
log
@	* sec_auth.cc (create_token): Add integrity level SID to token on
	systems supporting that.  Remove useless check for dynamically loading
	NtCreateToken function.
	* sec_helper.cc (mandatory_medium_integrity_sid): Define.
	(mandatory_high_integrity_sid): Define.
	(mandatory_system_integrity_sid): Define.
	* sec_helper.h (mandatory_medium_integrity_sid): Declare.
	(mandatory_high_integrity_sid): Declare.
	(mandatory_system_integrity_sid): Declare.
@
text
@d16 1
d302 3
d306 1
a306 1
static const char *cygpriv[] =
d308 2
a309 2
  "",
  "",
d347 1
a347 1
privilege_luid (const char *pname, LUID *luid)
d353 1
a353 1
    if (!strcmp (cygpriv[idx], pname))
d362 1
a362 1
static const char *
d367 1
a367 1
    return "<unknown privilege>";
d400 1
a400 1
    debug_printf ("%d = set_privilege ((token %x) %s, %d)\n", ret, token,
@


1.77
log
@	* fhandler.h (-struct wsa_event): Move to wsa_event.h.  Include
	wsa_event.h instead.
	* fhandler_socket.cc (NUM_SOCKS): Move to wsa_event.h.
	(wsa_events): Move from DLL shared area to cygwin_shared shared
	memory.  Accommodate throughout.
	(socket_serial_number): Ditto.
	* fhandler_tape.cc (mt): Ditto.
	(mtinfo_init): Remove.
	(mt): Define as cygwin_shared->mt.
	* flock.cc (FLOCK_PARENT_DIR_ACCESS): Remove.
	(FLOCK_INODE_DIR_ACCESS): Move up in file.
	(FLOCK_MUTANT_ACCESS): Ditto.
	(FLOCK_EVENT_ACCESS): Ditto.
	(get_lock_parent_dir): Remove.
	(inode_t::inode_t): Call get_shared_parent_dir to get parent dir handle.
	Add a "flock-" prefix to file's lock directory name for clarity.
	* mtinfo.h (mtinfo_init): Drop declaration.
	* net.cc (last_used_bindresvport): Move from DLL shared area to
	cygwin_shared shared memory.
	(cygwin_bindresvport_sa): Accommodate above change.
	* sec_helper.cc (_everyone_sd): Move here from flock.cc.
	* security.h (SD_MIN_SIZE): Ditto.
	(everyone_sd): Ditto.
	* shared.cc (cygwin_shared_area): Remove.
	(cygwin_shared_h): New handle.
	(get_shared_parent_dir): New static function.
	(shared_name): Drop session_local argument.  Call get_shared_parent_dir
	here.  Add cygwin-shared subdir to object name.
	(offsets): Reinstantiate SH_CYGWIN_SHARED member.
	(open_shared): Revert change from 2007-03-29 for systems supporting
	SeCreateGlobalPrivilege.
	(shared_info::initialize): Call mtinfo's initialize here.
	(memory_init): Drop call to mtinfo_init.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add members for global socket and tape info
	sharing.
	(enum shared_locations): Reinstantiate SH_CYGWIN_SHARED.
	(get_shared_parent_dir): Declare.
	(shared_name): Drop session_local argument from declaration.
	* wsa_event.h: New file.  Move definitions of NUM_SOCKS and
	struct wsa_event here.
@
text
@d63 6
@


1.76
log
@	* Fix copyright dates.
@
text
@d521 33
@


1.75
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2006, 2007 Red Hat, Inc.
@


1.74
log
@	* cygheap.cc (cwcsdup): New function.
	(cwcsdup1): New function.
	* cygheap.h (cygheap_user::get_windows_id): New method returning PWCHAR.
	(cwcsdup): Declare.
	(cwcsdup1): Declare.
	* registry.cc (get_registry_hive_path): Use WCHAR instead of char
	throughout.
	(load_registry_hive): Ditto.
	* registry.h (get_registry_hive_path): Change declaration accordingly.
	(load_registry_hive): Ditto.
	* sec_helper.cc (cygpsid::string): New method returning PWCHAR.
	* security.h (cygpsid::string): Declare.
	* syscalls.cc (seteuid32): Convert local name var to WCHAR.
	* uinfo.cc (cygheap_user::env_userprofile): Convert local name buffers
	to WCHAR.  Call sys_wcstombs_alloc to generate puserprof buffer.

	* winsup.h: Fix comment.
	(NT_MAX_PATH): New definition for maximum internal path length.
	Use throughout where appropriate.
	* include/limits.h (PATH_MAX): Set to 4096 as on Linux.
@
text
@d109 1
a109 1
  if (!psid || !nsidstr) 
@


1.73
log
@	* fhandler.cc (fhandler_base::fhaccess): Accommodate interface changes
	of access control functions throughout.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* sec_acl.cc: Drop unnecessary includes.
	(setacl): Take path_conv instead of file name as parameter.
	Accommodate interface changes of access control functions.
	(getacl): Ditto.
	* sec_auth.cc: New file, taking over all authentication related
	functions from security.cc.
	* sec_helper.cc: Drop unnecessary includes.
	* security.cc: Ditto.  Move all authentication related functions to
	sec_auth.cc.
	(ALL_SECURITY_INFORMATION): New define.  Use throughout.
	(set_file_sd): New function, replacing read_sd and the file related
	part of get_nt_object_security.
	(get_reg_sd): Rename from get_reg_security.  Drop type parameter.
	(get_reg_attribute): New function, replacing the registry related part
	of get_nt_object_security.
	(get_file_attribute): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(set_file_attribute): Ditto plus new set_file_sd.  Drop unnecessary
	implementation without uid/gid parameters.
	(check_file_access): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(check_registry_access): Use new get_reg_sd call.
	* security.h: Accommodate above interface changes.
@
text
@d104 11
@


1.72
log
@	* sec_helper.cc: Remove unused code.
@
text
@a13 3
#include <grp.h>
#include <pwd.h>
#include <unistd.h>
a14 2
#include <limits.h>
#include <sys/stat.h>
a15 4
#include <ctype.h>
#include <wingdi.h>
#include <winuser.h>
#include <wininet.h>
a22 1
#include "cygtls.h"
@


1.71
log
@	* cygheap.h (init_cygheap::luid): Remove.
	* mmap.cc (mlock): Accommodate parameter change in call to
	push_thread_privilege.
	(munlock): Ditto.
	* ntdll.h (STATUS_NOT_ALL_ASSIGNED): Define.
	(NtAdjustPrivilegesToken): Declare.
	* sec_helper.cc (cygpriv): Reorder to match numerical privilege order.
	(privilege_luid): Take job of privilege_luid_by_name, using new
	cygpriv.
	(privilege_luid_by_name): Remove.
	(privilege_name): Accommodate new cygpriv array.
	(set_privilege): Call NtAdjustPrivilegesToken to avoid using advapi32.
	Accommodate changes to privilege_name.
	(set_cygwin_privileges): Simplify.  Don't try to set
	SE_CREATE_GLOBAL_PRIVILEGE on systems not supporting it.
	* security.cc (sys_privs): Reorder to match numerical privilege order.
	Use real privilege values as defined in security.h.
	(get_system_priv_list): Drop unused grp_list argument.  Create
	list of privileges according to new wincapc::max_sys_priv value.
	(get_priv_list): Call privilege_luid instead of privilege_luid_by_name.
	Make priv a local value instead of a pointer.
	(create_token): Accommodate parameter change in call to
	push_self_privilege.
	(lsaauth): Ditto.
	(check_access): Use privilege values directly instead of calling
	privilege_luid.
	* security.h: Define real privilege values.
	(cygpriv_idx): Remove.
	(privilege_luid): Change declaration.
	(privilege_luid_by_name): Drop declaration.
	(set_privilege): Change declaration.
	(set_process_privilege): Drop definition.
	(_push_thread_privilege): Accomodate new set_privilege parameters.
	* wincap.h (wincapc::max_sys_priv): New element.
	* wincap.cc: Implement above element throughout.
	(wincap_2000sp4): New wincaps structure.
	(wincap_xpsp1): Ditto.
	(wincap_xpsp2): Ditto.
	(wincapc::init): Use new wincaps.
	(wincapc::max_sys_priv): New element.
@
text
@a293 71
#if 0 // unused
#define SIDLEN	(sidlen = MAX_SID_LEN, &sidlen)
#define DOMLEN	(domlen = INTERNET_MAX_HOST_NAME_LENGTH, &domlen)

BOOL
lookup_name (const char *name, const char *logsrv, PSID ret_sid)
{
  cygsid sid;
  DWORD sidlen;
  char domuser[INTERNET_MAX_HOST_NAME_LENGTH + UNLEN + 2];
  char dom[INTERNET_MAX_HOST_NAME_LENGTH + 1];
  DWORD domlen;
  SID_NAME_USE acc_type;

  debug_printf ("name  : %s", name ? name : "NULL");

  if (!name)
    return FALSE;

  if (cygheap->user.domain ())
    {
      strcat (strcat (strcpy (domuser, cygheap->user.domain ()), "\\"), name);
      if (LookupAccountName (NULL, domuser, sid, SIDLEN, dom, DOMLEN, &acc_type)
	  && legal_sid_type (acc_type))
	goto got_it;
      if (logsrv && *logsrv
	  && LookupAccountName (logsrv, domuser, sid, SIDLEN,
				dom, DOMLEN, &acc_type)
	  && legal_sid_type (acc_type))
	goto got_it;
    }
  if (logsrv && *logsrv)
    {
      if (LookupAccountName (logsrv, name, sid, SIDLEN, dom, DOMLEN, &acc_type)
	  && legal_sid_type (acc_type))
	goto got_it;
      if (acc_type == SidTypeDomain)
	{
	  strcat (strcat (strcpy (domuser, dom), "\\"), name);
	  if (LookupAccountName (logsrv, domuser, sid, SIDLEN,
				 dom, DOMLEN, &acc_type))
	    goto got_it;
	}
    }
  if (LookupAccountName (NULL, name, sid, SIDLEN, dom, DOMLEN, &acc_type)
      && legal_sid_type (acc_type))
    goto got_it;
  if (acc_type == SidTypeDomain)
    {
      strcat (strcat (strcpy (domuser, dom), "\\"), name);
      if (LookupAccountName (NULL, domuser, sid, SIDLEN, dom, DOMLEN,&acc_type))
	goto got_it;
    }
  debug_printf ("LookupAccountName (%s) %E", name);
  __seterrno ();
  return FALSE;

got_it:
  debug_printf ("sid : [%d]", *GetSidSubAuthority ((PSID) sid,
			      *GetSidSubAuthorityCount ((PSID) sid) - 1));

  if (ret_sid)
    memcpy (ret_sid, sid, sidlen);

  return TRUE;
}

#undef SIDLEN
#undef DOMLEN
#endif //unused

@


1.70
log
@	* dcrt0.cc (dll_crt0_0): Call set_cygwin_privileges here, after
	initializing hProcToken.
	* sec_helper.cc (init_global_security): Don't call set_cygwin_privileges        here.
@
text
@d34 1
d365 1
a365 1
/* Order must be same as cygpriv_idx in security.h. */
d368 2
a373 1
  SE_UNSOLICITED_INPUT_NAME,
a392 1
  SE_CREATE_GLOBAL_NAME,
d394 2
d398 2
a399 2
  SE_ENABLE_DELEGATION_NAME,
  SE_SYNC_AGENT_NAME,
d406 2
a407 16
const LUID *
privilege_luid (cygpriv_idx idx)
{
  if (idx < 0 || idx >= SE_NUM_PRIVS)
    return NULL;
  if (!cygheap->luid[idx].LowPart && !cygheap->luid[idx].HighPart
      && !LookupPrivilegeValue (NULL, cygpriv[idx], &cygheap->luid[idx]))
    {
      __seterrno ();
      return NULL;
    }
  return &cygheap->luid[idx];
}

const LUID *
privilege_luid_by_name (const char *pname)
d409 11
a419 8
  int idx;

  if (!pname)
    return NULL;
  for (idx = 0; idx < SE_NUM_PRIVS; ++idx)
    if (!strcmp (pname, cygpriv[idx]))
      return privilege_luid ((cygpriv_idx) idx);
  return NULL;
d423 1
a423 1
privilege_name (const LUID *priv_luid, char *buf, DWORD *size)
d425 2
a426 1
  if (!priv_luid || !LookupPrivilegeName (NULL, (LUID *) priv_luid, buf, size))
d428 1
a428 1
  return buf;
d432 1
a432 1
set_privilege (HANDLE token, const LUID *priv_luid, bool enable)
d436 2
a437 7
  DWORD size;

  if (!priv_luid)
    {
      __seterrno ();
      goto out;
    }
d440 2
a441 1
  new_priv.Privileges[0].Luid = *priv_luid;
d444 3
a446 2
  if (!AdjustTokenPrivileges (token, FALSE, &new_priv,
			      sizeof orig_priv, &orig_priv, &size))
d448 1
a448 8
      __seterrno ();
      goto out;
    }
  /* AdjustTokenPrivileges returns TRUE even if the privilege could not
     be enabled. GetLastError () returns an correct error code, though. */
  if (enable && GetLastError () == ERROR_NOT_ALL_ASSIGNED)
    {
      __seterrno ();
d460 2
a461 6
    {
      DWORD siz = 256;
      char buf[siz];
      debug_printf ("%d = set_privilege ((token %x) %s, %d)",
		    ret, token, privilege_name (priv_luid, buf, &siz), enable);
    }
d470 4
a473 8
  LUID priv_luid;

  if (LookupPrivilegeValue (NULL, SE_RESTORE_NAME, &priv_luid))
    set_privilege (token, &priv_luid, true);
  if (LookupPrivilegeValue (NULL, SE_BACKUP_NAME, &priv_luid))
    set_privilege (token, &priv_luid, true);
  if (LookupPrivilegeValue (NULL, SE_CREATE_GLOBAL_NAME, &priv_luid))
    set_privilege (token, &priv_luid, true);
@


1.69
log
@	* cygheap.cc (cygheap_init): Fix formatting.  Remove comment.  Set
	shared_prefix depending only on terminal service capability.
	* dcrt0.cc (dll_crt0_1): Don't call set_cygwin_privileges here.
	* fhandler_fifo.cc (fhandler_fifo::open): Create the mutex as global
	object.
	* posix_ipc.cc (ipc_mutex_init): Use cygheap->shared_prefix.
	(ipc_cond_init): Ditto.
	* sec_helper.cc (privilege_name): Make static.  Use LookupPrivilegeName
	directly to be independent of the state of cygheap.
	(set_privilege): Take a LUID as parameter instead of an index value.
	Only print debug output in case of failure.
	(set_cygwin_privileges): Add comment.  Use LookupPrivilegeValue to
	get privilege LUIDs.
	(init_global_security): Call set_cygwin_privileges here.
	* security.h (privilege_name): Drop declaration.
	(set_privilege): Declare according to above change.
	(set_process_privilege): Call privilege_luid to get LUID.
	(_push_thread_privilege): Ditto.
	* shared.cc (open_shared): Add comment.  On systems supporting the
	SeCreateGlobalPrivilege, try to create/open global shared memory first.
	Fall back to local shared memory if that fails.
	* thread.cc (semaphore::semaphore): Use cygheap->shared_prefix.
	* wincap.h (wincapc::has_create_global_privilege): New element.
	* wincap.cc: Implement above element throughout.
@
text
@a532 2

  set_cygwin_privileges (hProcToken);
@


1.68
log
@	Throughout remove all usage of wincap.has_security.
	* environ.cc (environ_init): Drop setting allow_ntsec here.
	* grp.cc (initgroups32): Drop usage of label "out".
	* security.cc (allow_ntsec): Set to true by default.
	* syscalls.cc (seteuid32): Remove label success_9x.
	* wincap.cc: Remove has_security throughout.
	* wincap.h: Ditto.
@
text
@d430 2
a431 2
const char *
privilege_name (cygpriv_idx idx)
d433 1
a433 1
  if (idx < 0 || idx >= SE_NUM_PRIVS)
d435 1
a435 1
  return cygpriv[idx];
d439 1
a439 1
set_privilege (HANDLE token, cygpriv_idx privilege, bool enable)
a441 1
  const LUID *priv_luid;
d445 1
a445 1
  if (!(priv_luid = privilege_luid (privilege)))
d476 7
a482 2
  syscall_printf ("%d = set_privilege ((token %x) %s, %d)",
		  ret, token, privilege_name (privilege), enable);
d486 2
d491 8
a498 2
  set_privilege (token, SE_RESTORE_PRIV, true);
  set_privilege (token, SE_BACKUP_PRIV, true);
d533 2
@


1.67
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2006 Red Hat, Inc.
d580 1
a580 2
  if (!wincap.has_security ()
      || !sec_acl (acl, true, true, sid1, sid2, access2))
@


1.66
log
@	Partially revert change from 2006-10-22.  GetSecurityInfo messes up
	user information on NT4.
	* sec_helper.cc (security_descriptor::malloc): Drop LocalAlloc
	considerations.
	(security_descriptor::realloc): Ditto.
	(security_descriptor::free): Ditto.
	* security.cc (get_reg_security): Reinstantiate.
	(get_nt_object_security): Revert to using NtQuerySecurityObject.
	* security.h (class security_descriptor): Drop type member.
	Accommodate throughout.
	(security_descriptor::size): Constify.
	(security_descriptor::copy): Ditto.
@
text
@d203 2
a204 2
{ 
  if (contains (nsi)) 
d209 1
a209 1
      if (!tmp) 
d217 1
a217 1
  if (well_known) 
d222 1
a222 1
} 
d277 1
a277 1
  
@


1.65
log
@	* environ.cc (set_traverse): Remove.
	(parse_thing): Drop "traverse" option.
	* path.cc (fs_info::update): Don't request SE_CHANGE_NOTIFY_PRIV
	privilege.
	* sec_helper.cc (set_cygwin_privileges): Ditto.
	* security.cc (allow_traverse): Remove.
	(alloc_sd): Drop special allow_traverse code.
	* security.h (allow_traverse): Drop declaration.
	* syscalls.cc (statvfs): Don't request SE_CHANGE_NOTIFY_PRIV privilege.
@
text
@d269 1
a269 4
    {
      sd_size = nsize;
      type = malloced;
    }
d278 2
a279 15
  if (type == malloced)
    {
      if (!(tmp = (PSECURITY_DESCRIPTOR) ::realloc (psd, nsize)))
	return NULL;
    }
  else
    {
      if (!(tmp = (PSECURITY_DESCRIPTOR) ::malloc (nsize)))
	return NULL;
      if (psd)
	{
	  memcpy (tmp, psd, LocalSize (psd));
	  LocalFree (psd);
	}
    }
a280 1
  type = malloced;
d288 1
a288 6
    {
      if (type == local_alloced)
	LocalFree (psd);
      else
	::free (psd);
    }
a290 1
  type = local_alloced;
@


1.64
log
@	* cyglsa.h: New header file.
	* environ.cc: Disable subauth settings.
	* grp.cc: Accomodate cygsidlist's count now being a method.
	* sec_helper.cc (SECURITY_MANDATORY_INTEGRITY_AUTHORITY): Remove.
	(mandatory_medium_integrity_sid): Remove.
	(mandatory_high_integrity_sid): Remove.
	(mandatory_system_integrity_sid): Remove.
	(fake_logon_sid): Add.
	(cygsid::get_sid): Add well_known parameter.  Set well_known_sid
	accordingly.
	(cygsid::getfromstr): Ditto.
	(cygsidlist::alloc_sids): Move here from security.cc.
	(cygsidlist::free_sids): Ditto.
	(cygsidlist::add): Move here from security.h.  Add well_known parameter.
	Set well_known_sid accordingly.  Don't allow duplicate SIDs.
	* security.cc: Include cyglsa.h and cygwin/version.h.  Throughout
	accomodate cygsidlist's count now being a method.  Throughout drop
	redundant "contains" tests.
	(get_user_local_groups): Add local groups as well known SIDs.
	(get_token_group_sidlist): Add well known groups as well known SIDs.
	(get_server_groups): Ditto.  Only call get_unix_group_sidlist after
	get_user_local_groups to maintain "well_known_sid" attribute.
	(get_initgroups_sidlist): Add well known groups as well known SIDs.
	(get_setgroups_sidlist): Add usersid and struct passwd parameter to
	allow calling get_server_groups from here.
	(get_system_priv_list): Make static.  Return size of TOKEN_PRIVILEGES
	structure.
	(get_priv_list): Ditto.
	(create_token): Accomodate above changes.  Drop misguided attempt to
	add MIC SIDs to created user token.  Print returned token as hex value.
	(subauth): Disable.
	(lsaauth): New function implementing client side of LSA authentication.
	* security.h (class cygsid): Add well_known_sid attribute.  Accomodate
	throughout.  Add *= operator to create a well known SID.
	(class cygsidlist): Rename count to cnt.  Make count a method.
	(cygsidlist::add): Move to sec_helper.cc.
	(cygsidlist::operator *=): New method to add well known SID.
	(cygsidlist::non_well_known_count): New method returning number of
	non well known SIDs in list.
	(cygsidlist::next_non_well_known_sid): New method returning next non
	well known SID by index.
	(mandatory_medium_integrity_sid): Drop declaration.
	(mandatory_high_integrity_sid): Drop declaration.
	(mandatory_system_integrity_sid): Drop declaration.
	(fake_logon_sid): Add declaration.
	(subauth): Disable declaration.
	(lsaauth): Add declaration.
	* syscalls.cc (seteuid32): Disable subauthentication.  Add LSA
	authentication.
	* wincap.h: Define needs_logon_sid_in_sid_list throughout.
	* wincap.cc: Ditto.
@
text
@a509 1
  set_privilege (token, SE_CHANGE_NOTIFY_PRIV, !allow_traverse);
@


1.63
log
@	* security.h (DBGSID): Define for debugging purposes.
	(MKSID): Rename from SID so as to not hide SID definition from winnt.h.
	* sec_helper.cc: Change SID to MKSID throughout.
@
text
@d70 2
a71 9

#define SECURITY_MANDATORY_INTEGRITY_AUTHORITY       {0,0,0,0,0,16}

MKSID (mandatory_medium_integrity_sid, "S-1-64-8192",
       SECURITY_MANDATORY_INTEGRITY_AUTHORITY, 1, 8192);
MKSID (mandatory_high_integrity_sid, "S-1-64-12288",
       SECURITY_MANDATORY_INTEGRITY_AUTHORITY, 1, 12288);
MKSID (mandatory_system_integrity_sid, "S-1-64-16384",
       SECURITY_MANDATORY_INTEGRITY_AUTHORITY, 1, 16384);
d131 1
a131 1
cygsid::get_sid (DWORD s, DWORD cnt, DWORD *r)
d146 1
d151 1
a151 1
cygsid::getfromstr (const char *nsidstr)
d163 1
a163 1
	return get_sid (s, cnt, r);
d182 42
@


1.62
log
@	* sec_helper.cc (sid_auth): Remove.
	(well_known_this_org_sid): New well known sid.
	(SECURITY_MANDATORY_INTEGRITY_AUTHORITY): Define.
	(mandatory_medium_integrity_sid): New well known sid.
	(mandatory_high_integrity_sid): Ditto.
	(mandatory_system_integrity_sid): Ditto.
	(cygsid::get_sid): Use local SID_IDENTIFIER_AUTHORITY.  Allow all
	authorities fitting in a UCHAR.
	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.  Add comment.  Add "This Organization" group
	if available in incoming group list.
	(get_server_groups): Only add world and authenticated users groups
	if not already in list.
	(create_token): Add matching mandatory integrity SID to group list
	on systems supporting Mandatory Integrity Control.
	* security.h (well_known_this_org_sid): Define.
	(mandatory_medium_integrity_sid): Define.
	(mandatory_high_integrity_sid): Define.
	(mandatory_system_integrity_sid): Define.
	* wincap.h: Define has_mandatory_integrity_control throughout.
	* wincap.cc: Ditto.
@
text
@d41 29
a69 29
SID (well_known_null_sid, "S-1-0-0",
     SECURITY_NULL_SID_AUTHORITY, 1, SECURITY_NULL_RID);
SID (well_known_world_sid, "S-1-1-0",
     SECURITY_WORLD_SID_AUTHORITY, 1, SECURITY_WORLD_RID);
SID (well_known_local_sid, "S-1-2-0",
     SECURITY_LOCAL_SID_AUTHORITY, 1, SECURITY_LOCAL_RID);
SID (well_known_creator_owner_sid, "S-1-3-0",
     SECURITY_CREATOR_SID_AUTHORITY, 1, SECURITY_CREATOR_OWNER_RID);
SID (well_known_creator_group_sid, "S-1-3-1",
     SECURITY_CREATOR_SID_AUTHORITY, 1, SECURITY_CREATOR_GROUP_RID);
SID (well_known_dialup_sid, "S-1-5-1",
     SECURITY_NT_AUTHORITY, 1, SECURITY_DIALUP_RID);
SID (well_known_network_sid, "S-1-5-2",
     SECURITY_NT_AUTHORITY, 1, SECURITY_NETWORK_RID);
SID (well_known_batch_sid, "S-1-5-3",
     SECURITY_NT_AUTHORITY, 1, SECURITY_BATCH_RID);
SID (well_known_interactive_sid, "S-1-5-4",
     SECURITY_NT_AUTHORITY, 1, SECURITY_INTERACTIVE_RID);
SID (well_known_service_sid, "S-1-5-6",
     SECURITY_NT_AUTHORITY, 1, SECURITY_SERVICE_RID);
SID (well_known_authenticated_users_sid, "S-1-5-11",
     SECURITY_NT_AUTHORITY, 1, SECURITY_AUTHENTICATED_USER_RID);
SID (well_known_this_org_sid, "S-1-5-15",
     SECURITY_NT_AUTHORITY, 1, 15);
SID (well_known_system_sid, "S-1-5-18",
     SECURITY_NT_AUTHORITY, 1, SECURITY_LOCAL_SYSTEM_RID);
SID (well_known_admins_sid, "S-1-5-32-544",
     SECURITY_NT_AUTHORITY, 2, SECURITY_BUILTIN_DOMAIN_RID,
			       DOMAIN_ALIAS_RID_ADMINS);
d73 6
a78 6
SID (mandatory_medium_integrity_sid, "S-1-64-8192",
     SECURITY_MANDATORY_INTEGRITY_AUTHORITY, 1, 8192);
SID (mandatory_high_integrity_sid, "S-1-64-12288",
     SECURITY_MANDATORY_INTEGRITY_AUTHORITY, 1, 12288);
SID (mandatory_system_integrity_sid, "S-1-64-16384",
     SECURITY_MANDATORY_INTEGRITY_AUTHORITY, 1, 16384);
@


1.61
log
@	* security.h (cygpriv_idx): Add privileges new in Vista.
	* security.cc (sys_privs): Ditto.
	* sec_helper.cc (cygpriv): Ditto.  Fix comment.
@
text
@a40 9
SID_IDENTIFIER_AUTHORITY NO_COPY sid_auth[] = {
	{SECURITY_NULL_SID_AUTHORITY},
	{SECURITY_WORLD_SID_AUTHORITY},
	{SECURITY_LOCAL_SID_AUTHORITY},
	{SECURITY_CREATOR_SID_AUTHORITY},
	{SECURITY_NON_UNIQUE_AUTHORITY},
	{SECURITY_NT_AUTHORITY}
};

d63 2
d71 9
d141 1
d143 1
a143 1
  if (s > 5 || cnt < 1 || cnt > 8)
d148 1
d150 1
a150 1
  InitializeSid (psid, &sid_auth[s], cnt);
@


1.60
log
@	* fhandler_disk_file.cc (fhandler_disk_file::facl): Fix whitespace.
	* external.cc: Update copyright.
	* fhandler.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.h: Ditto.
	* security.cc: Ditto.
	(check_registry_access): Return -1 if W_OK is requested.
@
text
@d347 1
a347 1
/* Order must be same as cygperm_idx in winsup.h. */
d379 5
a383 1
  SE_SYNC_AGENT_NAME
@


1.59
log
@	* external.cc (cygwin_internal): Use security_descriptor::copy method.
	* sec_helper.cc (security_descriptor::malloc): Use own free method.
	Set type.
	(security_descriptor::realloc): Handle the case that psd has been
	allocated using LocalAlloc.  Set type.
	(security_descriptor::free): Ditto.
	* security.cc (get_nt_attribute): Remove.
	(get_reg_security): Remove.
	(get_nt_object_security): Use GetSecurityInfo which handles all
	securable objects.
	(get_nt_object_attribute): Remove.
	(get_object_attribute): Call get_nt_object_security instead of
	get_nt_object_attribute.
	(get_file_attribute): Ditto.
	(check_registry_access): Call get_nt_object_security instead of
	get_reg_security.
	* security.h (cygpsid::operator PSID): Make method const, not the
	result.
	(class security_descriptor): Add type member.  Accomodate throughout.
	(security_descriptor::copy): New method.
	(security_descriptor::operator PSECURITY_DESCRIPTOR *): New operator.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.58
log
@GCC 4.1 fixes.
* cygheap.h (cygheap_user): Remove unneeded class names from function
declaration.
* fhandler.h (fhandler_base): Ditto.
(fhandler_dev_floppy): Ditto.
(fhandler_console): Ditto.
* wininfo.h (wininfo): Ditto.
* exceptions.cc (sigpacket::process): Avoid compiler errors about gotos and
initialization.
* fhandler_fifo.cc (fhandler_fifo::open): Ditto.
* fhandler_floppy.cc (fhandler_dev_floppy::ioctl): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Ditto.
* mmap.cc (mmap64): Ditto.
* pipe.cc (fhandler_pipe::open): Ditto.
* spawn.cc (spawn_guts): Ditto.
* sec_helper.cc: Fix some comments.
(get_null_sd): Move file-scope static to only function where it is used.
@
text
@d227 6
a232 4
  if (psd)
    ::free (psd);
  psd = (PSECURITY_DESCRIPTOR) ::malloc (nsize);
  sd_size = psd ? nsize : 0;
d239 17
a255 3
  PSECURITY_DESCRIPTOR tmp = (PSECURITY_DESCRIPTOR) ::realloc (psd, nsize);
  if (!tmp)
    return NULL;
d257 1
d265 6
a270 1
    ::free (psd);
d273 1
@


1.57
log
@	* sec_helper.cc (set_cygwin_privileges): Request SE_BACKUP_NAME
	privileges.
@
text
@d446 2
a447 4
/*
 * Function to return a common SECURITY_DESCRIPTOR * that
 * allows all access.
 */
a448 1
static NO_COPY SECURITY_DESCRIPTOR *null_sdp = 0;
d454 1
d456 1
a456 1
  if (null_sdp == 0)
d465 2
a466 5
/*
 * Initialize global security attributes.
 *
 * Called from dcrt0.cc (_dll_crt0).
 */
@


1.57.2.1
log
@	* Merge HEAD into cv-branch.
@
text
@d446 4
a449 2
/* Function to return a common SECURITY_DESCRIPTOR that
   allows all access.  */
d451 1
a456 1
  static NO_COPY SECURITY_DESCRIPTOR *null_sdp;
d458 1
a458 1
  if (!null_sdp)
d467 5
a471 2
/* Initialize global security attributes.
   Called from dcrt0.cc (_dll_crt0).  */
@


1.56
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d442 1
@


1.55
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d245 1
a245 1
security_descriptor::free (void)
@


1.54
log
@	* pinfo.cc (pinfo::init): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	(pinfo::set_acl): Replace sa_buf by dynamically allocated acl_buf.
	* sec_acl.cc (setacl): Allocate acl dynamically.
	* sec_helper.cc (sec_acl): Add test for alignment of acl when
	DEBUGGING is defined.
	(__sec_user): Same for sa_buf.
	* security.cc (verify_token): Define sd_buf as PSECURITY_DESCRIPTOR
	and allocate dynamically.
	(alloc_sd): Allocate acl dynamically.
	security.h (sec_user_nih): Change first parameter to
	SECURITY_ATTRIBUTES *.
	(sec_user): Ditto.
	* sigproc.cc (wait_sig): Define sa_buf as PSECURITY_ATTRIBUTES and
	allocate dynamically.
	* syscalls.cc (seteuid32): Define dacl_buf as PACL and allocate
	dynamically.
	* uinfo.cc (cygheap_user::init): Define sa_buf as PSECURITY_ATTRIBUTES
	and allocate dynamically.
	* winbase.h (ilockincr): Mark first argument of inline assembly as
	earlyclobber.
	(ilockdecr): Ditto.
@
text
@a18 1
#include <sys/types.h>
@


1.53
log
@	* cygheap.cc (cygheap_init): Accomodate set_process_privilege change.
	* cygheap.h (cygheap_user::curr_primary_token): New member.
	(cygheap_user::primary_token): New method.
	(cygheap_user::deimpersonate): Always revert to processes'
	impersonation token.
	(cygheap_user::reimpersonate): Set processes' or setuid token as
	necessary.
	(cygheap_user::has_impersonation_tokens): Look for curr_primary_token
	value.
	(cygheap_user::close_impersonation_tokens): Close curr_primary_token
	here if necessary.  Don't reset token values to NO_IMPERSONATION since
	that's done in uinfo_init anyway.
	(init_cygheap::luid): New LUID array keeping privilege LUIDs.
	* cygtls.cc (_cygtls::init_thread): Call cygheap->user.reimpersonate.
	* dcrt0.cc (hProcToken): New global variable to keep process token.
	(hProcImpToken): Ditto for process impersonation token.
	(dll_crt0_0): Open process token here once.  Duplicate to create
	hProcImpToken.
	(dll_crt0_1): Call set_cygwin_privileges.
	* environ.cc (allow_ntea): Drop duplicate declaration.
	(allow_smbntsec): Ditto.
	(set_traverse): Only set allow_traverse here.
	(environ_init): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop call to
	enable_restore_privilege.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	* fork.cc (fork_child): Move call to cygheap->user.reimpersonate after
	syn with parent. Call set_cygwin_privileges.
	* grp.cc (internal_getgroups): Use hProcImpToken instead of opening
	process token.
	* path.cc (fs_info::update): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges.
	* registry.cc (load_registry_hive): Drop setting restore privilege
	since it's already set if available.
	* sec_helper.cc: Include cygtls.h.
	(cygpriv): Privilege string array.
	(privilege_luid): New function, evaluate LUID from cygpriv_idx.
	(privilege_luid_by_name): New function, evaluate LUID from privilege
	string.
	(privilege_name): New function, evaluate privilege string from
	cygpriv_idx.
	(set_privilege): New static function called by set_process_privilege
	and set_thread_privilege.  Call privilege_luid to get privilege LUID.
	Fix bug in return value evaluation. Improve debug output.
	(set_cygwin_privileges): New function.
	(set_process_privilege): Remove.
	(enable_restore_privilege): Remove.
	* security.cc (allow_traverse): New global variable.
	(sys_privs): Change type to cygpriv_idx and store privilege indices
	instead of strings.
	(SYSTEM_PRIVILEGES_COUNT): Renamed from SYSTEM_PERMISSION_COUNT.
	(get_system_priv_list): Don't use numerical constant in malloc call.
	Use privilege_luid to get privilege LUIDs.
	(get_priv_list): Call privilege_luid_by_name to get LUIDs. Improve
	inner privilege LUID comparison loop.
	(create_token): Enable create token privilege using
	push/pop_self_privileges. Use hProcToken instead of opening process
	token. Use default DACL when duplicating token.
	(subauth): Enable tcb privilege using push/pop_self_privileges.
	Use sec_none instead of homw made security attributes when duplicating
	token.
	(check_file_access): Don't duplicate access token, use active
	impersonation token as is.
	* security.h (enum cygpriv_idx): New enumeration type enumerating
	possible privileges.
	(privilege_luid): Declare new function.
	(privilege_luid_by_name): Ditto.
	(privilege_name): Ditto.
	(allow_traverse): Declare.
	(set_privilege): Declare function.
	(set_process_privilege): Define as macro.
	(enable_restore_privilege): Remove declaration.
	(_push_thread_privilege): Define macro.
	(push_thread_privilege): Ditto.
	(pop_thread_privilege): Ditto.
	(pop_self_privilege): Ditto.
	* spawn.cc (spawn_guts): Use cygheap->user.primary_token instead of
	cygheap->user.token.
	* syscalls.cc (statvfs): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges. Rearrange code
	to simplify push/pop bracketing.
	(seteuid32): Use hProcToken instead of opening process token. Call
	cygheap->user.deimpersonate instead of RevertToSelf.  Create
	impersonation token from primary internal or external token.  Set
	cygheap->user.curr_primary_token and cygheap->user.current_token
	privileges once here.  Drop "failed" and "failed_ptok" labels.
	Drop setting DefaultDacl of process token.
	(setegid32): Use hProcToken and hProcImpToken instead of opening
	process token. Always reimpersonate afterwards.
	* uinfo.cc (cygheap_user::init): Use hProcToken instead of opening
	process token.
	(internal_getlogin): Ditto. Set hProcImpToken, too.
	(uinfo_init): Initialize cygheap->user.curr_primary_token.
	* winsup.h (hProcToken): Declare.
	(hProcImpToken): Declare.
@
text
@d492 4
d538 6
a543 1
  if (!wincap.has_security () || !sec_acl (acl, true, true, sid1, sid2, access2))
@


1.52
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d33 1
d325 2
a326 2
int
set_process_privilege (const char *privilege, bool enable, bool use_thread)
d328 31
a358 5
  HANDLE hToken = NULL;
  LUID priv_luid;
  TOKEN_PRIVILEGES new_priv, orig_priv;
  int ret = -1;
  DWORD size;
d360 7
a366 1
  if (!LookupPrivilegeValue (NULL, privilege, &priv_luid))
d369 1
a369 1
      goto out;
d371 23
d395 9
a403 6
  if ((use_thread
       && !OpenThreadToken (GetCurrentThread (), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			    0, &hToken))
      ||(!use_thread
	 && !OpenProcessToken (hMainProc, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			     &hToken)))
d410 1
a410 1
  new_priv.Privileges[0].Luid = priv_luid;
d413 1
a413 1
  if (!AdjustTokenPrivileges (hToken, FALSE, &new_priv,
d427 5
a431 1
  ret = orig_priv.Privileges[0].Attributes == SE_PRIVILEGE_ENABLED ? 1 : 0;
d434 2
a435 4
  if (hToken)
    CloseHandle (hToken);

  syscall_printf ("%d = set_process_privilege (%s, %d)", ret, privilege, enable);
a438 1
/* Helper function to set the SE_RESTORE_NAME privilege once. */
d440 1
a440 1
enable_restore_privilege ()
d442 2
a443 8
  static int NO_COPY saved_res;
  bool issetuid = cygheap->user.issetuid ();
  if (!saved_res || issetuid)
    {
      int res = 2 + set_process_privilege (SE_RESTORE_NAME, true, issetuid);
      if (!issetuid)
	saved_res = res;
    }
@


1.51
log
@	* autoload.cc (NtCreateFile): Add.
	* dir.cc (mkdir): Change set_file_attribute call to indicate that
	NT security isn't used.
	* fhandler.cc (fhandler_base::open_9x): New method, created from
	fhandler_base::open.
	(fhandler_base::open): Rearrange to use NtCreateFile instead of
	CreateFile.
	* fhandler.h (enum query_state): Redefine query_null_access to
	query_stat_control.  query_null_access isn't allowed in NtCreateFile.
	(fhandler_base::open_9x): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use
	query_stat_control first, query_read_control if that fails.
	(fhandler_disk_file::fchmod): Call enable_restore_privilege before
	trying to open for query_write_control.  Don't fall back to
	opening for query_read_control.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl):  Only request restore privilege and query
	access necessary for given cmd.
	* fhandler_raw.cc (fhandler_dev_raw::open): Call fhandler_base::open
	instead of opening device here.
	* ntdll.h (NtCreateFile): Declare.
	* path.cc (symlink_worker): Change set_file_attribute call to indicate
	that NT security isn't used.
	* sec_acl.cc (getacl): Fix bracketing.
	* sec_helper.cc (enable_restore_privilege): New function.
	* security.cc (str2buf2uni_cat): New function.
	(write_sd): Don't request restore permission here.
	* security.h (set_process_privileges): Drop stale declaration.
	(str2buf2uni): Declare.
	(str2buf2uni_cat): Declare.
	(enable_restore_privilege): Declare.
	* syscalls.cc (fchown32): Return immediate success on 9x.
@
text
@d388 1
a388 1
        saved_res = res;
@


1.50
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d378 14
@


1.49
log
@	* security.h (SID): New macro.
	(well_known_*_sid): Change type to cygpsid.
	(cygsid::init): Delete declaration.
	* sec_helper.cc (well_known_*_sid): Define using above SID macro.
	(cygsid::init): Delete.
	* dcrt0.cc (dll_crt0_0): Do not call cygsid::init.
	* security.cc (get_user_local_groups): Change the second argument type
	to cygpsid.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Red Hat, Inc.
@


1.48
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d50 27
a76 13
cygsid well_known_null_sid;
cygsid well_known_world_sid;
cygsid well_known_local_sid;
cygsid well_known_creator_owner_sid;
cygsid well_known_creator_group_sid;
cygsid well_known_dialup_sid;
cygsid well_known_network_sid;
cygsid well_known_batch_sid;
cygsid well_known_interactive_sid;
cygsid well_known_service_sid;
cygsid well_known_authenticated_users_sid;
cygsid well_known_system_sid;
cygsid well_known_admins_sid;
a132 18
}

void
cygsid::init ()
{
  well_known_null_sid = "S-1-0-0";
  well_known_world_sid = "S-1-1-0";
  well_known_local_sid = "S-1-2-0";
  well_known_creator_owner_sid = "S-1-3-0";
  well_known_creator_group_sid = "S-1-3-1";
  well_known_dialup_sid = "S-1-5-1";
  well_known_network_sid = "S-1-5-2";
  well_known_batch_sid = "S-1-5-3";
  well_known_interactive_sid = "S-1-5-4";
  well_known_service_sid = "S-1-5-6";
  well_known_authenticated_users_sid = "S-1-5-11";
  well_known_system_sid = "S-1-5-18";
  well_known_admins_sid = "S-1-5-32-544";
@


1.47
log
@	* sec_helper.cc (set_process_privilege): Rename restore_priv to
	priv_luid.

	* sec_helper.cc (set_process_privilege): Call LookupPrivilegeValue
	before opening the token.
@
text
@d421 1
a421 1
BOOL
d431 1
a431 1
      return FALSE;
d459 1
a459 1
  return TRUE;
@


1.46
log
@	* dir.cc (mkdir): Use local security_descriptor. Call
	set_security_attribute appropriately.
	* external.cc (cygwin_internal): Ditto.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
	* sec_acl.cc (setacl): Ditto. Call read_sd appropriately.
	(getace): Ditto.
	* sec_helper.cc (security_descriptor::malloc): New method.
	(security_descriptor::realloc): New method.
	(security_descriptor::free): New method.
	* security.cc (read_sd): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	Allocate the security_descriptor buffer according to size returned by
	a call to GetFileSecurity. Return buffer size on success.
	(write_sd): Get security_descriptor as parameter instead of
	PSECURITY_DESCRIPTOR and a size.
	(get_nt_attribute): Use local security_descriptor.
	(get_nt_object_attribute): Ditto in case of type == SE_REGISTRY_KEY.
	Allocate security_descriptor buffer according to size returned by
	a call to RegGetKeySecurity.
	(alloc_sd): Make static. Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	(set_security_attribute): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size.
	(set_nt_attribute): Use local security_descriptor.
	(check_file_access): Ditto.
	* security.h: Add class security_descriptor.
	(read_sd): Change declaration to get security_descriptor as parameter
	instead of PSECURITY_DESCRIPTOR and a size.
	(write_sd): Ditto.
	(set_security_attribute): Ditto.
	(alloc_sd): Remove declaration.
	* thread.cc (semaphore::semaphore): Use local security_descriptor. Call
	set_security_attribute appropriately.
@
text
@d332 1
a332 1
  LUID restore_priv;
d337 6
a353 6
  if (!LookupPrivilegeValue (NULL, privilege, &restore_priv))
    {
      __seterrno ();
      goto out;
    }

d355 1
a355 1
  new_priv.Privileges[0].Luid = restore_priv;
@


1.45
log
@	* external.cc (cygwin_internal): Add CW_GET_POSIX_SECURITY_ATTRIBUTE
	handling.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add
	CW_GET_POSIX_SECURITY_ATTRIBUTE.

	* exceptions.cc (init_global_security): Move from here...
	* sec_helper.cc (init_global_security): ...to here.
@
text
@d228 29
@


1.44
log
@2003-09-26  Pierre Humblet <pierre.humblet@@ieee.org>

	* uinfo.cc (cygheap_user::init): Make sure the current user appears
	in the default DACL. Rearrange to decrease the indentation levels.
	Initialize the effec_cygsid directly.
	(internal_getlogin): Do not reinitialize myself->gid. Open the process
	token with the required access.
	* cygheap.h (class cygheap_user): Delete members pid and saved_psid.
	Create members effec_cygsid and saved_cygsid.
	(cygheap_user::set_sid): Define inline.
	(cygheap_user::set_saved_sid): Ditto.
	(cygheap_user::sid): Modify.
	(cygheap_user::saved_sid): Modify.
	* cygheap.cc (cygheap_user::set_sid): Delete.
	(cygheap_user::set_saved_sid): Ditto.
	* sec_helper.cc (sec_acl): Set the correct acl size.
	* autoload.cc (FindFirstFreeAce): Add.
	* security.h: Define ACL_DEFAULT_SIZE.
@
text
@d374 18
@


1.43
log
@* include/tzfile.h: Add some missing entries.
@
text
@d378 1
d406 6
@


1.42
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d166 1
a166 1
      while ( cnt < 8 && *lasts == '-')
@


1.41
log
@	* cygheap.cc (cygheap_user::set_saved_sid): Rename from set_orig_sid.
	* cygheap.h (class cygheap_user): Rename orig_psid, orig_uid and
	orig_gid to saved_psid, saved_uid and saved_gid respectively.
	Rename methods orig_sid and set_orig_sid to saved_sid and set_saved_sid
	respectively.
	* sec_helper.cc (sec_acl): Accomodate above changes.
	* spawn.cc (spawn_guts): Ditto.
	* uinfo.cc (uinfo_init): Ditto.
@
text
@d28 1
a29 1
#include "path.h"
@


1.40
log
@2003-09-15  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h (__sec_user): Add "access2" argument.
	(sec_acl): Add "original" and "access2" arguments.
	(sec_user): Add "sid2" and "access2" argument. Remove dependence on
	allow_ntsec.
	(sec_user_nih): Ditto.
	* sec_helper.cc (__sec_user): Add "has_security" test.
	Call sec_acl with new arguments, letting it handle original_sid.
	(sec_acl): Add "original" and "access2" arguments. Handle original_sid
	depending on flag but avoiding duplicates. Use "access2" for sid2.
	* pinfo.cc (pinfo::init): Use security attributes created by sec_user
	when creating the mapping.
	* security.cc (create_token): Adjust arguments in call to sec_acl.
	Call sec_user instead of __sec_user.
	* syscall.cc (seteuid32):  Adjust arguments in call to sec_acl. Remove
	now unnecessary test. Remove useless conversions to psid.
	* dcrt0.cc (dll_crt0_1): Call cygsid::init before pinfo_init.
@
text
@d389 1
a389 1
  if (original && (psid = cygheap->user.orig_sid ())
@


1.39
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d375 1
a375 1
sec_acl (PACL acl, BOOL admins, PSID sid1, PSID sid2)
d378 1
a384 4
  if (sid2)
    if (!AddAccessAllowedAce (acl, ACL_REVISION,
			      GENERIC_ALL, sid2))
      debug_printf ("AddAccessAllowedAce(sid2) %E");
d389 9
a404 5
#if 0 /* Does not seem to help */
  if (!AddAccessAllowedAce (acl, ACL_REVISION,
			    GENERIC_ALL, well_known_creator_owner_sid))
    debug_printf ("AddAccessAllowedAce(creator_owner) %E");
#endif
d409 1
a409 1
__sec_user (PVOID sa_buf, PSID sid2, BOOL inherit)
d416 1
a416 4
  cygsid sid;

  if (!(sid = cygheap->user.orig_sid ()) ||
	  (!sec_acl (acl, TRUE, sid, sid2)))
@


1.38
log
@whitespace cleanup
@
text
@a17 1
#include <errno.h>
@


1.37
log
@	* sec_helper.cc (get_sids_info): debug_print owner_sid and group_sid.
@
text
@d86 1
a86 1
        {
d100 1
a100 1
        *type = USER;
@


1.36
log
@	* security.h: Introduce names UNKNOWN_UID and UNKNOWN_GID and delete
	declaration of is_grp_member.
	* uinfo.cc (internal_getlogin): Use UNKNOWN_GID.
	* passwd.cc (pwdgrp::read_passwd): Use UNKNOWN_UID.
	* grp.cc (pwdgrp::read_group): Change group name to provide better
	feedback.
	(getgrgid): Use gid16togid32.
	* sec_helper.cc (is_grp_member): Delete.
@
text
@d196 3
@


1.35
log
@	* sec_helper.cc (get_sids_info): New function.
	* security.cc (extract_nt_dom_user): Simplify with strechr.
	(get_user_groups): Initialize glen to MAX_SID_LEN.
	(get_user_local_groups): Ditto.
	(get_attribute_from_acl): Define ace_sid as cygpsid.
	(get_nt_attribute): Define owner_sid and group_sid as cygpsid.
	Call get_sids_info instead of cygsid.get_{u,g}id and is_grp_member.
	(get_nt_object_attribute): Ditto.
	(alloc_sd): Define ace_sid as cygpsid.
@
text
@a225 41
BOOL
is_grp_member (__uid32_t uid, __gid32_t gid)
{
  struct passwd *pw;
  struct __group32 *gr;
  int idx;

  /* Evaluate current user info by examining the info given in cygheap and
     the current access token if ntsec is on. */
  if (uid == myself->uid)
    {
      /* If gid == primary group of current user, return immediately. */
      if (gid == myself->gid)
	return TRUE;
      /* Calling getgroups only makes sense when reading the access token. */
      if (allow_ntsec)
	{
	  __gid32_t grps[NGROUPS_MAX];
	  int cnt = internal_getgroups (NGROUPS_MAX, grps);
	  for (idx = 0; idx < cnt; ++idx)
	    if (grps[idx] == gid)
	      return TRUE;
	  return FALSE;
	}
    }

  /* Otherwise try getting info from examining passwd and group files. */
  if ((pw = internal_getpwuid (uid)))
    {
      /* If gid == primary group of uid, return immediately. */
      if ((__gid32_t) pw->pw_gid == gid)
	return TRUE;
      /* Otherwise search for supplementary user list of this group. */
      if ((gr = internal_getgrgid (gid)))
	for (idx = 0; gr->gr_mem[idx]; ++idx)
	  if (strcasematch (cygheap->user.name (), gr->gr_mem[idx]))
	    return TRUE;
    }
  return FALSE;
}

@


1.34
log
@	* security.h (class cygpsid): New class.
	(class cygsid): Use cygpsid as base. Remove members psid, get_id,
	get_uid, get_gid, string, debug_printf and the == and != operators.
	(cygsidlist::clear_supp): Only do work if setgroups has been called.
	* sec_helper.cc: Define sid_auth NO_COPY.
	(cygpsid::operator==): New operator.
	(cygpsid::get_id): New function.
	(cygpsid::string): New function.
	(cygsid::string): Delete.
	(cygsid::get_id): Delete.
	* pwdgrp.h: Change arguments of internal_getpwsid,
	internal_getgrsid and internal_getgroups to cygpsid.
	* passwd.cc (internal_getpwsid): Change argument from cygsid to cygpsid.
	* grp.cc (internal_getgrsid): Ditto.
	(internal_getgroups): Ditto.
@
text
@d189 37
@


1.33
log
@	* security.h: Add third argument to set_process_privilege.
	* autoload.cc: Add OpenThreadToken.
	* sec_helper.cc (set_process_privilege): Add and use use_thread
	argument.
	* security.cc (alloc_sd): Modify call to set_process_privilege.
	Remember the result in each process. If failed and file owner is not
	the user, fail.
@
text
@d42 1
a42 1
SID_IDENTIFIER_AUTHORITY sid_auth[] = {
d65 57
a139 19
char *
cygsid::string (char *nsidstr) const
{
  char t[32];
  DWORD i;

  if (!psid || !nsidstr)
    return NULL;
  strcpy (nsidstr, "S-1-");
  __small_sprintf (t, "%u", GetSidIdentifierAuthority (psid)->Value[5]);
  strcat (nsidstr, t);
  for (i = 0; i < *GetSidSubAuthorityCount (psid); ++i)
    {
      __small_sprintf (t, "-%lu", *GetSidSubAuthority (psid, i));
      strcat (nsidstr, t);
    }
  return nsidstr;
}

a186 33
}

__uid32_t
cygsid::get_id (BOOL search_grp, int *type)
{
  /* First try to get SID from passwd or group entry */
  __uid32_t id = ILLEGAL_UID;

  if (!search_grp)
    {
      struct passwd *pw;
      if (*this == cygheap->user.sid ())
	id = myself->uid;
      else if ((pw = internal_getpwsid (*this)))
	id = pw->pw_uid;
      if (id != ILLEGAL_UID)
	{
	  if (type)
	    *type = USER;
	   return id;
	}
    }
  if (search_grp || type)
    {
      struct __group32 *gr;
      if (cygheap->user.groups.pgsid == psid)
	id = myself->gid;
      else if ((gr = internal_getgrsid (*this)))
	id = gr->gr_gid;
      if (id != ILLEGAL_UID && type)
	*type = GROUP;
    }
  return id;
@


1.32
log
@* uinfo.cc (pwdgrp::load): Regularize strace output.  Add warning for
CreateFile failure.
@
text
@d297 1
a297 1
set_process_privilege (const char *privilege, BOOL enable)
d305 6
a310 2
  if (!OpenProcessToken (hMainProc, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			 &hToken))
a335 1
      debug_printf ("Privilege %s couldn't be assigned", privilege);
@


1.31
log
@2002-12-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (dll_crt0_1): Call well known SID initializer function.
	* security.h (cygsid::init): Declare new static method.
	* sec_helper.cc (cygsid::init): New method for initializing well
	known SIDs.

2002-12-14  Pierre Humblet  <pierre.humblet@@ieee.org>

	* security.h: Declare well_known_creator_group_sid.
	* sec_helper.cc: Define and initialize well_known_creator_group_sid.
@
text
@d197 1
a197 1
        return TRUE;
d200 1
a200 1
        {
@


1.31.4.1
log
@merge from trunk
@
text
@d197 1
a197 1
	return TRUE;
d200 1
a200 1
	{
@


1.31.4.2
log
@merge from trunk
@
text
@d42 1
a42 1
SID_IDENTIFIER_AUTHORITY NO_COPY sid_auth[] = {
a64 57
bool
cygpsid::operator== (const char *nsidstr) const
{
  cygsid nsid (nsidstr);
  return psid == nsid;
}

__uid32_t
cygpsid::get_id (BOOL search_grp, int *type)
{
    /* First try to get SID from group, then passwd */
  __uid32_t id = ILLEGAL_UID;

  if (search_grp)
    {
      struct __group32 *gr;
      if (cygheap->user.groups.pgsid == psid)
	id = myself->gid;
      else if ((gr = internal_getgrsid (*this)))
	id = gr->gr_gid;
      if (id != ILLEGAL_UID)
        {
	  if (type)
	    *type = GROUP;
	  return id;
	}
    }
  if (!search_grp || type)
    {
      struct passwd *pw;
      if (*this == cygheap->user.sid ())
	id = myself->uid;
      else if ((pw = internal_getpwsid (*this)))
	id = pw->pw_uid;
      if (id != ILLEGAL_UID && type)
        *type = USER;
    }
  return id;
}


char *
cygpsid::string (char *nsidstr) const
{
  char *t;
  DWORD i;

  if (!psid || !nsidstr)
    return NULL;
  strcpy (nsidstr, "S-1-");
  t = nsidstr + sizeof ("S-1-") - 1;
  t += __small_sprintf (t, "%u", GetSidIdentifierAuthority (psid)->Value[5]);
  for (i = 0; i < *GetSidSubAuthorityCount (psid); ++i)
    t += __small_sprintf (t, "-%lu", *GetSidSubAuthority (psid, i));
  return nsidstr;
}

d83 19
d151 2
a152 2
bool
get_sids_info (cygpsid owner_sid, cygpsid group_sid, __uid32_t * uidret, __gid32_t * gidret)
d154 2
a155 3
  struct passwd *pw;
  struct __group32 *gr = NULL;
  bool ret = false;
d157 13
a169 23
  if (group_sid == cygheap->user.groups.pgsid)
    *gidret = myself->gid;
  else if ((gr = internal_getgrsid (group_sid)))
    *gidret = gr->gr_gid;
  else
    *gidret = ILLEGAL_GID;

  if (owner_sid == cygheap->user.sid ())
    {
      *uidret = myself->uid;
      if (*gidret == myself->gid)
	ret = true;
      else
	ret = (internal_getgroups (0, NULL, &group_sid) > 0);
    }
  else if ((pw = internal_getpwsid (owner_sid)))
    {
      *uidret = pw->pw_uid;
      if (gr || (*gidret != ILLEGAL_GID
		 && (gr = internal_getgrgid (*gidret))))
	for (int idx = 0; gr->gr_mem[idx]; ++idx)
	  if ((ret = strcasematch (pw->pw_name, gr->gr_mem[idx])))
	    break;
d171 11
a181 4
  else
    *uidret = ILLEGAL_UID;

  return ret;
d297 1
a297 1
set_process_privilege (const char *privilege, bool enable, bool use_thread)
d305 2
a306 6
  if ((use_thread
       && !OpenThreadToken (GetCurrentThread (), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			    0, &hToken))
      ||(!use_thread
	 && !OpenProcessToken (hMainProc, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
			     &hToken)))
d332 1
@


1.31.4.3
log
@merge from trunk
@
text
@d226 41
@


1.31.4.4
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d29 1
a30 1
#include "fhandler.h"
@


1.31.4.5
log
@merge from trunk
@
text
@a195 3
  owner_sid.debug_print ("get_sids_info: owner SID =");
  group_sid.debug_print ("get_sids_info: group SID =");

@


1.31.4.6
log
@merge from trunk
@
text
@d86 1
a86 1
	{
d100 1
a100 1
	*type = USER;
@


1.31.4.7
log
@merge from trunk
@
text
@d18 1
@


1.30
log
@2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* pwdgrp.h (pwdgrp_check::pwdgrp_state): Replace by
	pwdgrp_check::isinitializing ().
	(pwdgrp_check::isinitializing): Create.
	* passwd.cc (grab_int): Change type to unsigned, use strtoul and
	set the pointer content to 0 if the field is invalid.
	(parse_pwd): Move validity test after getting pw_gid.
	(read_etc_passwd): Replace "passwd_state <= " by
	passwd_state::isinitializing ().
	(internal_getpwuid): Ditto.
	(internal_getpwnam): Ditto.
	(getpwent): Ditto.
	(getpass): Ditto.
	* grp.cc (parse_grp): Use strtoul for gr_gid and verify the validity.
	(read_etc_group): Replace "group_state <= " by
	group_state::isinitializing ().
	(internal_getgrgid): Ditto.
	(getgrent32): Ditto.
	(internal_getgrent): Ditto.

2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h: Move declarations of internal_getgrent,
	internal_getpwsid and internal_getgrsid to pwdgrp.h.
	* pwdgrp.h: Declare internal_getpwsid, internal_getpwnam,
	internal_getpwuid, internal_getgrsid, internal_getgrgid,
	internal_getgrnam, internal_getgrent and internal_getgroups.
	Delete "emulated" from enum pwdgrp_state.
	(pwdgrp_check::isuninitialized): Create.
	(pwdgrp_check::pwdgrp_state): Change state to initializing
	rather than to uninitialized.
	(pwdgrp_read::gets): Remove trailing CRs.
	* passwd.cc (grab_string): Don't look for NLs.
	(grab_int): Ditto.
	(parse_pwd): Don't look for CRs. Return 0 if entry is too short.
	(search_for): Delete.
	(read_etc_passwd): Simplify tests to actually read the file.
	Set state to loaded before making internal_getpwXX calls.
	Replace search_for calls by equivalent internal_pwgetXX calls.
	(internal_getpwsid): Use passwd_state.isuninitialized to decide
	to call read_etc_passwd.
	(internal_getpwuid): Create.
	(internal_getpwnam): Create.
	(getpwuid32): Simply call internal_getpwuid.
	(getpwuid_r32): Call internal_getpwuid.
	(getpwnam): Simply call internal_getpwnam.
	(getpwnam_r): Call internal_getpwnam.
	* grp.cc (parse_grp): Don't look for CRs. Adjust blank space.
	(add_grp_line): Adjust blank space.
	(class group_lock): Ditto.
	(read_etc_group): Simplify tests to actually read the file.
	Set state to loaded before making internal_getgrXX calls.
	Replace getgrXX calls by equivalent internal calls.
	(internal_getgrsid): Use group_state.isuninitialized to decide
	to call read_etc_group.
	(internal_getgrgid): Create.
	(internal_getgrnam): Create.
	(getgroups32): Simply call internal_getgrgid.
	(getgrnam32): Simply call internal_getgrnam.
	(internal_getgrent): Call group_state.isuninitialized.
	(internal_getgroups): Create from the former getgroups32, using
	two of the four arguments. Set gid to myself->gid and username
	to cygheap->user.name ().
	(getgroups32): Simply call internal_getgroup.
	(getgroups): Call internal_getgroup instead of getgroups32.
	(setgroups32): Call internal versions of get{pw,gr}XX.
	* sec_helper.cc: Include pwdgrp.h.
	(is_grp_member): Call internal versions of get{pw,gr}XX.
	* security.cc: Include pwdgrp.h.
	(alloc_sd): Call internal versions of get{pw,gr}XX.
	* syscalls.cc: Include pwdgrp.h.
	(seteuid32): Call internal versions of get{pw,gr}XX.
	(setegid32): Ditto.
	* uinfo.cc: Include pwdgrp.h.
	(internal_getlogin): Call internal versions of get{pw,gr}XX.
	(cygheap_user::ontherange): Ditto.
	* sec_acl.cc: Include pwdgrp.h.
	(setacl): Call internal versions of get{pw,gr}XX.
	(acl_access): Ditto and simplify logic.
	(aclfromtext): Ditto.
@
text
@d51 31
a81 12
cygsid well_known_null_sid ("S-1-0-0");
cygsid well_known_world_sid ("S-1-1-0");
cygsid well_known_local_sid ("S-1-2-0");
cygsid well_known_creator_owner_sid ("S-1-3-0");
cygsid well_known_dialup_sid ("S-1-5-1");
cygsid well_known_network_sid ("S-1-5-2");
cygsid well_known_batch_sid ("S-1-5-3");
cygsid well_known_interactive_sid ("S-1-5-4");
cygsid well_known_service_sid ("S-1-5-6");
cygsid well_known_authenticated_users_sid ("S-1-5-11");
cygsid well_known_system_sid ("S-1-5-18");
cygsid well_known_admins_sid ("S-1-5-32-544");
@


1.29
log
@	* security.h: Declare internal_getpwsid and internal_getgrsid.
	Undeclare internal_getpwent.  Define DEFAULT_UID_NT.  Change
	DEFAULT_GID.
	* passwd.cc (internal_getpwsid): New function.
	(internal_getpwent): Suppress.
	(read_etc_passwd): Make static.  Rewrite the code for the completion
	line.  Set curr_lines to 0.
	(parse_pwd): Change type to static int.  Return 0 for short lines.
	(add_pwd_line): Pay attention to the value of parse_pwd.
	(search_for): Do not look for nor return the DEFAULT_UID.
	* grp.cc (read_etc_group): Make static.  Free gr_mem and set
	curr_lines to 0.  Always call add_pwd_line.  Rewrite the code for the
	completion line.
	(internal_getgrsid): New function.
	(parse_grp): If grp.gr_mem is empty, set it to &null_ptr.
	Never NULL gr_passwd.
	(getgrgid32): Only return the default if ntsec is off and the gid is
	ILLEGAL_GID.
	* sec_helper.cc (cygsid::get_id): Use getpwsid and getgrsid.
	(cygsid_getfrompw): Clean up last line.
	(cygsid_getfromgr): Ditto.
	(is_grp_member): Use getpwuid32 and getgrgid32.
	* uinfo.cc (internal_getlogin): Set DEFAULT_GID at start.
	Use getpwsid. Move the read of /etc/group after the second access
	to /etc/passwd.  Change some debug_printf.
@
text
@d34 1
a167 1
  extern int getgroups32 (int, __gid32_t *, __gid32_t, const char *);
d179 1
a179 1
      /* Calling getgroups32 only makes sense when reading the access token. */
d183 1
a183 2
	  int cnt = getgroups32 (NGROUPS_MAX, grps, myself->gid,
				 cygheap->user.name ());
d192 1
a192 1
  if ((pw = getpwuid32 (uid)))
d198 1
a198 1
      if ((gr = getgrgid32 (gid)) && gr->gr_mem)
@


1.28
log
@	* grp.cc (getgroups32): Revert previous patch.  Use impersonation
	token if process is in impersonated state.
	* sec_helper.cc (is_grp_member): Rewrite.  Call getgroups32 only
	for current user.  Scan passwd and group info otherwise.
@
text
@d121 1
a121 1
  return (*this = sp ? sp + 1 : "") != NULL;
d128 1
a128 1
  return (*this = sp ?: "") != NULL;
a134 1
  cygsid sid;
d142 2
a143 9
      else
	for (int pidx = 0; (pw = internal_getpwent (pidx)); ++pidx)
          {
	    if (sid.getfrompw (pw) && sid == psid)
	      {
		id = pw->pw_uid;
		break;
	      }
	  }
d149 1
a149 1
	 }
d156 5
a160 15
      else
	for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
	  {
	    if (sid.getfromgr (gr) && sid == psid)
	      {
		id = gr->gr_gid;
		break;
	      }
	  }
      if (id != ILLEGAL_UID)
	{
	  if (type)
	    *type = GROUP;
	}
     }
d193 11
a203 18
  for (int idx = 0; (pw = internal_getpwent (idx)); ++idx)
    if ((__uid32_t) pw->pw_uid == uid)
      {
	/* If gid == primary group of uid, return immediately. */
	if ((__gid32_t) pw->pw_gid == gid)
	  return TRUE;
	/* Otherwise search for supplementary user list of this group. */
	for (idx = 0; (gr = internal_getgrent (idx)); ++idx)
	  if ((__gid32_t) gr->gr_gid == gid)
	    {
	      if (gr->gr_mem)
		for (idx = 0; gr->gr_mem[idx]; ++idx)
		  if (strcasematch (cygheap->user.name (), gr->gr_mem[idx]))
		    return TRUE;
	      return FALSE;
	    }
        return FALSE;
      }
@


1.27
log
@	* syscalls.cc (chmod): Simplify conditional.
	* sec_helper (cygsid::getfromstr): Reorganize to remove
	calls to strcpy and strtok_r.
	(cygsid::getfromgr): Change type to __uid32_t instead of int.
	Keep only the allow_ntsec branch. Never call LookupAccountSid
	which calls PDCs, simply return -1 in case of failure.
	Use cygsid == instead of calling EqualSid and remove test
	for NULL psid.
	* security.h: Declare cygsid::getfromgr as __uid32_t.
@
text
@d186 3
a188 1
  BOOL grp_member = TRUE;
d190 40
a229 11
  struct passwd *pw = getpwuid32 (uid);
  __gid32_t grps[NGROUPS_MAX];
  int cnt = getgroups32 (NGROUPS_MAX, grps,
			 pw ? pw->pw_gid : myself->gid,
			 pw ? pw->pw_name : cygheap->user.name ());
  int i;
  for (i = 0; i < cnt; ++i)
    if (grps[i] == gid)
      break;
  grp_member = (i < cnt);
  return grp_member;
@


1.26
log
@* sec_helper.cc (cygsid::get_id): If the sid matches a sid stored in
cygheap->user, return the uid or gid from myself.
* security.cc (alloc_sd): If gid == myself->gid, return the group sid from
cygheap->user.  Remove the test for uid == original_uid, which is
counter-productive.
@
text
@d102 3
a104 5
  char sid_buf[256];
  char *t, *lasts;
  DWORD cnt = 0;
  DWORD s = 0;
  DWORD i, r[8];
d106 1
a106 1
  if (!nsidstr || strncmp (nsidstr, "S-1-", 4))
d108 5
a112 2
      psid = NO_SID;
      return NULL;
d114 1
a114 12

  strcpy (sid_buf, nsidstr);

  for (t = sid_buf + 4, i = 0;
       cnt < 8 && (t = strtok_r (t, "-", &lasts));
       t = NULL, ++i)
    if (i == 0)
      s = strtoul (t, NULL, 10);
    else
      r[cnt++] = strtoul (t, NULL, 10);

  return get_sid (s, cnt, r);
d131 1
a131 1
int
d134 3
a136 11
  if (!psid)
    {
      set_errno (EINVAL);
      return -1;
    }
  if (!IsValidSid (psid))
    {
      __seterrno ();
      system_printf ("IsValidSid failed with %E");
      return -1;
    }
d138 1
a138 2
  /* First try to get SID from passwd or group entry */
  if (allow_ntsec)
d140 13
a152 25
      cygsid sid;
      int id = -1;

      if (!search_grp)
	{
	  struct passwd *pw;
	 if (EqualSid(psid, cygheap->user.sid ()))
	   id = myself->uid;
	 else
	   for (int pidx = 0; (pw = internal_getpwent (pidx)); ++pidx)
	     {
	       if (sid.getfrompw (pw) && sid == psid)
		 {
		   id = pw->pw_uid;
		   break;
		 }
	     }
	  if (id >= 0)
	    {
	      if (type)
		*type = USER;
	      return id;
	    }
	}
      if (search_grp || type)
d154 4
a157 19
	  struct __group32 *gr;
	 if (cygheap->user.groups.pgsid == psid)
	   id = myself->gid;
	 else
	   for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
	     {
	       if (sid.getfromgr (gr) && sid == psid)
		 {
		   id = gr->gr_gid;
		   break;
		 }
	     }
	  if (id >= 0)
	    {
	      if (type)
		*type = GROUP;
	      return id;
	    }
	}
d159 1
a159 10

  /* We use the RID as default UID/GID */
  int id = *GetSidSubAuthority (psid, *GetSidSubAuthorityCount (psid) - 1);

  /*
   * The RID maybe -1 if accountname == computername.
   * In this case we search for the accountname in the passwd and group files.
   * If type is needed, we search in each case.
   */
  if (id == -1 || type)
d161 7
a167 21
      char account[UNLEN + 1];
      char domain[INTERNET_MAX_HOST_NAME_LENGTH + 1];
      DWORD acc_len = UNLEN + 1;
      DWORD dom_len = INTERNET_MAX_HOST_NAME_LENGTH + 1;
      SID_NAME_USE acc_type;

      if (!LookupAccountSid (NULL, psid, account, &acc_len,
			     domain, &dom_len, &acc_type))
	{
	  __seterrno ();
	  return -1;
	}

      switch (acc_type)
	{
	  case SidTypeGroup:
	  case SidTypeAlias:
	  case SidTypeWellKnownGroup:
	    if (type)
	      *type = GROUP;
	    if (id == -1)
d169 2
a170 3
		struct __group32 *gr = getgrnam32 (account);
		if (gr)
		  id = gr->gr_gid;
d172 5
a176 13
	    break;
	  case SidTypeUser:
	    if (type)
	      *type = USER;
	    if (id == -1)
	      {
		struct passwd *pw = getpwnam (account);
		if (pw)
		  id = pw->pw_uid;
	      }
	    break;
	  default:
	    break;
d178 1
a178 3
    }
  if (id == -1)
    id = getuid32 ();
@


1.25
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d165 11
a175 8
	  for (int pidx = 0; (pw = internal_getpwent (pidx)); ++pidx)
	    {
	      if (sid.getfrompw (pw) && sid == psid)
		{
		  id = pw->pw_uid;
		  break;
		}
	    }
d186 11
a196 8
	  for (int gidx = 0; (gr = internal_getgrent (gidx)); ++gidx)
	    {
	      if (sid.getfromgr (gr) && sid == psid)
		{
		  id = gr->gr_gid;
		  break;
		}
	    }
@


1.24
log
@	Patch by Joe Buehler  <jbuehler@@hekimian.com>:
	* sec_helper.cc (sec_acl): remove extraneous arg to debug_printf.
@
text
@d72 1
a72 1
  __small_sprintf(t, "%u", GetSidIdentifierAuthority (psid)->Value[5]);
d76 1
a76 1
      __small_sprintf(t, "-%lu", *GetSidSubAuthority (psid, i));
d93 1
a93 1
  InitializeSid(psid, &sid_auth[s], cnt);
d201 1
a201 1
  int id = *GetSidSubAuthority(psid, *GetSidSubAuthorityCount(psid) - 1);
d328 1
a328 1
  debug_printf ("LookupAccountName(%s) %E", name);
d333 2
a334 2
  debug_printf ("sid : [%d]", *GetSidSubAuthority((PSID) sid,
			      *GetSidSubAuthorityCount((PSID) sid) - 1));
d379 1
a379 1
     be enabled. GetLastError() returns an correct error code, though. */
@


1.23
log
@* cygheap.cc (init_cheap): Rearrange error message.
(cygheap_fixup_in_child): Ditto.
* dtable.cc: Remove if 0'ed code.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode.
* sec_helper.cc (cygsid::get_id): Use system_printf for error message.
* tty.cc (tty::common_init): Ditto.
@
text
@d435 1
a435 1
      debug_printf ("AddAccessAllowedAce(sid1) %E", sid1);
@


1.22
log
@* syscalls.c (seteuid32): Do not return an error when the token cannot be
created only because of a problem with the gid.
@
text
@d152 1
a152 1
      small_printf ("IsValidSid failed with %E");
@


1.21
log
@	* shared.cc (sec_none): Move to sec_helper.cc.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Ditto.
	(sec_acl): Ditto.
	(__sec_user): Ditto.
	* sec_helper.cc (sec_none): Move from shared.cc to here.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Ditto.
	(sec_acl): Ditto.
	(__sec_user): Ditto.
@
text
@d393 1
a393 1
  syscall_printf ("%d = set_process_privilege (%s, %d)",ret, privilege, enable);
@


1.20
log
@	* sec_helper.cc (lookup_name): Suppress.
	* security.cc (alloc_sd): Remove logsrv argument.
	Remove two calls to lookup_name.
	(set_security_attribute): Remove logsrv argument.
	Remove logsrv argument in call to alloc_sd.
	(set_nt_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_security_attribute.
	(set_file_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_nt_attribute.
	(set_file_attribute): Remove logsrv argument.
	Remove logsrv argument in call to set_file_attribute.
	* syscalls.cc (chown_worker): Remove logserver argument in
	call to set_file_attribute.
	(chmod): Ditto.
	* shm.cc (shmget): Remove logsrv argument in call to alloc_sd.
	* uinfo.cc (internal_getlogin): Replace calls to
	lookup_name by call to LookupAccountName.
	* security.h: Remove logsrv in declarations of set_file_attribute
	and alloc_sd. Remove declaration of lookup_name.
@
text
@d35 6
d395 90
@


1.19
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d269 1
d338 1
@


1.18
log
@	Change internal uid datatype from __uid16_t to __uid32_t
	throughout.
	* cygwin.din: Export new symbols getpwuid32, getpwuid_r32, getuid32,
	geteuid32, setuid32, seteuid32.
	* passwd.cc (getpwuid32): New function.
	(getpwuid_r32): Ditto.
	* syscalls.cc (seteuid32): Ditto.
	(setuid32): Ditto.
	* uinfo.cc (getuid32): Ditto.
	(geteuid32): Ditto.
	* winsup.h (uid16touid32): New macro, correclt casting from __uid16_t
	to __uid32_t.
	(gid16togid32): Ditto fir gids.
	(getuid32): Declare.
	(geteuid32): Ditto.
	(getpwuid32): Ditto.
	* include/sys/cygwin.h (struct external_pinfo): Add members uid32 and
	gid32.
@
text
@a31 1
#include "sigproc.h"
@


1.17
log
@	Change internal gid datatype from __gid16_t to __gid32_t
	throughout.
	* cygwin.din: Export new symbols chown32, fchown32, getegid32,
	getgid32, getgrgid32, getgrnam32, getgroups32, initgroups32, lchown32,
	setgid32, setegid32, getgrent32.
	* grp.cc (grp32togrp16): New static function.
	(getgrgid32): New function.
	(getgrnam32): Ditto.
	(getgrent32): Ditto.
	(getgroups32): Change name of internal function from getgroups.
	(getgroups32): New function.
	(initgroups32): Ditto.
	* syscalls.cc (chown32): Ditto.
	(lchown32): Ditto.
	(fchown32): Ditto.
	(setegid32): Ditto.
	(setgid32): Ditto.
	* uinfo.cc (getgid32): Ditto.
	(getegid32): Ditto.
	* include/cygwin/grp.h: Remove declaration of getgrgid() and getgrnam().
	Declare getgrgid32() and getgrnam32() instead.  Declare getgid32().
@
text
@d247 1
a247 1
    id = getuid ();
d257 1
a257 1
  struct passwd *pw = getpwuid (uid);
@


1.16
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d130 1
a130 1
cygsid::getfromgr (const struct __group16 *gr)
d177 1
a177 1
	  struct __group16 *gr;
d227 1
a227 1
		struct __group16 *gr = getgrnam (account);
d252 1
a252 1
is_grp_member (__uid16_t uid, __gid16_t gid)
d254 1
a254 1
  extern int getgroups (int, __gid16_t *, __gid16_t, const char *);
d258 4
a261 4
  __gid16_t grps[NGROUPS_MAX];
  int cnt = getgroups (NGROUPS_MAX, grps,
		       pw ? pw->pw_gid : myself->gid,
		       pw ? pw->pw_name : cygheap->user.name ());
@


1.15
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@a27 1
#include "perprocess.h"
a31 1
#include "sync.h"
@


1.14
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Red Hat, Inc.
@


1.13
log
@Update copyrights.
@
text
@d132 1
a132 1
cygsid::getfromgr (const struct group *gr)
d179 1
a179 1
	  struct group *gr;
d229 1
a229 1
		struct group *gr = getgrnam (account);
d254 1
a254 1
is_grp_member (uid_t uid, gid_t gid)
d256 1
a256 1
  extern int getgroups (int, gid_t *, gid_t, const char *);
d260 1
a260 1
  gid_t grps[NGROUPS_MAX];
@


1.13.4.1
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Red Hat, Inc.
d132 1
a132 1
cygsid::getfromgr (const struct __group16 *gr)
d179 1
a179 1
	  struct __group16 *gr;
d229 1
a229 1
		struct __group16 *gr = getgrnam (account);
d254 1
a254 1
is_grp_member (__uid16_t uid, __gid16_t gid)
d256 1
a256 1
  extern int getgroups (int, __gid16_t *, __gid16_t, const char *);
d260 1
a260 1
  __gid16_t grps[NGROUPS_MAX];
@


1.13.4.2
log
@Merged changes from HEAD
@
text
@d28 1
d33 2
d132 1
a132 1
cygsid::getfromgr (const struct __group32 *gr)
d179 1
a179 1
	  struct __group32 *gr;
d229 1
a229 1
		struct __group32 *gr = getgrnam32 (account);
d249 1
a249 1
    id = getuid32 ();
d254 1
a254 1
is_grp_member (__uid32_t uid, __gid32_t gid)
d256 1
a256 1
  extern int getgroups32 (int, __gid32_t *, __gid32_t, const char *);
d259 5
a263 5
  struct passwd *pw = getpwuid32 (uid);
  __gid32_t grps[NGROUPS_MAX];
  int cnt = getgroups32 (NGROUPS_MAX, grps,
			 pw ? pw->pw_gid : myself->gid,
			 pw ? pw->pw_name : cygheap->user.name ());
a271 1
#if 0 // unused
a339 1
#endif //unused
@


1.13.4.3
log
@Merged changes from HEAD
@
text
@a34 6
/* General purpose security attribute objects for global use. */
SECURITY_ATTRIBUTES NO_COPY sec_none;
SECURITY_ATTRIBUTES NO_COPY sec_none_nih;
SECURITY_ATTRIBUTES NO_COPY sec_all;
SECURITY_ATTRIBUTES NO_COPY sec_all_nih;

d387 1
a387 1
  syscall_printf ("%d = set_process_privilege (%s, %d)", ret, privilege, enable);
a388 90
}

/*
 * Function to return a common SECURITY_DESCRIPTOR * that
 * allows all access.
 */

static NO_COPY SECURITY_DESCRIPTOR *null_sdp = 0;

SECURITY_DESCRIPTOR *__stdcall
get_null_sd ()
{
  static NO_COPY SECURITY_DESCRIPTOR sd;

  if (null_sdp == 0)
    {
      InitializeSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);
      SetSecurityDescriptorDacl (&sd, TRUE, 0, FALSE);
      null_sdp = &sd;
    }
  return null_sdp;
}

BOOL
sec_acl (PACL acl, BOOL admins, PSID sid1, PSID sid2)
{
  size_t acl_len = MAX_DACL_LEN(5);

  if (!InitializeAcl (acl, acl_len, ACL_REVISION))
    {
      debug_printf ("InitializeAcl %E");
      return FALSE;
    }
  if (sid2)
    if (!AddAccessAllowedAce (acl, ACL_REVISION,
			      GENERIC_ALL, sid2))
      debug_printf ("AddAccessAllowedAce(sid2) %E");
  if (sid1)
    if (!AddAccessAllowedAce (acl, ACL_REVISION,
			      GENERIC_ALL, sid1))
      debug_printf ("AddAccessAllowedAce(sid1) %E", sid1);
  if (admins)
    if (!AddAccessAllowedAce (acl, ACL_REVISION,
			      GENERIC_ALL, well_known_admins_sid))
      debug_printf ("AddAccessAllowedAce(admin) %E");
  if (!AddAccessAllowedAce (acl, ACL_REVISION,
			    GENERIC_ALL, well_known_system_sid))
    debug_printf ("AddAccessAllowedAce(system) %E");
#if 0 /* Does not seem to help */
  if (!AddAccessAllowedAce (acl, ACL_REVISION,
			    GENERIC_ALL, well_known_creator_owner_sid))
    debug_printf ("AddAccessAllowedAce(creator_owner) %E");
#endif
  return TRUE;
}

PSECURITY_ATTRIBUTES __stdcall
__sec_user (PVOID sa_buf, PSID sid2, BOOL inherit)
{
  PSECURITY_ATTRIBUTES psa = (PSECURITY_ATTRIBUTES) sa_buf;
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR)
			     ((char *) sa_buf + sizeof (*psa));
  PACL acl = (PACL) ((char *) sa_buf + sizeof (*psa) + sizeof (*psd));

  cygsid sid;

  if (!(sid = cygheap->user.orig_sid ()) ||
	  (!sec_acl (acl, TRUE, sid, sid2)))
    return inherit ? &sec_none : &sec_none_nih;

  if (!InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION))
    debug_printf ("InitializeSecurityDescriptor %E");

/*
 * Setting the owner lets the created security attribute not work
 * on NT4 SP3 Server. Don't know why, but the function still does
 * what it should do also if the owner isn't set.
*/
#if 0
  if (!SetSecurityDescriptorOwner (psd, sid, FALSE))
    debug_printf ("SetSecurityDescriptorOwner %E");
#endif

  if (!SetSecurityDescriptorDacl (psd, TRUE, acl, FALSE))
    debug_printf ("SetSecurityDescriptorDacl %E");

  psa->nLength = sizeof (SECURITY_ATTRIBUTES);
  psa->lpSecurityDescriptor = psd;
  psa->bInheritHandle = inherit;
  return psa;
@


1.13.4.4
log
@Merged changes from HEAD
@
text
@d152 1
a152 1
      system_printf ("IsValidSid failed with %E");
@


1.13.4.5
log
@Merged changes from HEAD
@
text
@d435 1
a435 1
      debug_printf ("AddAccessAllowedAce(sid1) %E");
@


1.13.4.6
log
@Merged changes from HEAD
@
text
@d72 1
a72 1
  __small_sprintf (t, "%u", GetSidIdentifierAuthority (psid)->Value[5]);
d76 1
a76 1
      __small_sprintf (t, "-%lu", *GetSidSubAuthority (psid, i));
d93 1
a93 1
  InitializeSid (psid, &sid_auth[s], cnt);
d201 1
a201 1
  int id = *GetSidSubAuthority (psid, *GetSidSubAuthorityCount (psid) - 1);
d328 1
a328 1
  debug_printf ("LookupAccountName (%s) %E", name);
d333 2
a334 2
  debug_printf ("sid : [%d]", *GetSidSubAuthority ((PSID) sid,
			      *GetSidSubAuthorityCount ((PSID) sid) - 1));
d379 1
a379 1
     be enabled. GetLastError () returns an correct error code, though. */
@


1.12
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Cygnus Solutions.
@


1.11
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d39 6
a44 6
        {SECURITY_NULL_SID_AUTHORITY},
        {SECURITY_WORLD_SID_AUTHORITY},
        {SECURITY_LOCAL_SID_AUTHORITY},
        {SECURITY_CREATOR_SID_AUTHORITY},
        {SECURITY_NON_UNIQUE_AUTHORITY},
        {SECURITY_NT_AUTHORITY}
d351 1
a351 1
  			 &hToken))
d368 1
a368 1
  			      sizeof orig_priv, &orig_priv, &size))
@


1.10
log
@        Change well_known_admin_sid to well_known_admins_sid throughout.
        * sec_acl.cc (setacl): Never set DELETE permission. Set
        FILE_DELETE_CHILD only on readable and executable directories.
        * sec_helper.cc: Add constructor for `well_known_null_sid'.
        * security.cc (get_nt_attribute): Set S_ISVTX for directories if
        FILE_WRITE_DATA and FILE_EXECUTE but not FILE_DELETE_CHILD is set.
        Add evaluation of S_ISVTX, S_ISGID and S_ISUID from NULL ACE.
        (alloc_sd): Never set DELETE permission. Set FILE_DELETE_CHILD
        only on readable and executable directories.
        Add creation of NULL ACE for S_ISVTX, S_ISGID and S_ISUID permissions.
        * security.h: Add extern declaration for `well_known_null_sid'.
@
text
@d29 1
a36 1
#include "security.h"
@


1.9
log
@forced commit
@
text
@d47 1
d58 1
a58 1
cygsid well_known_admin_sid ("S-1-5-32-544");
@


1.8
log
@        * sec_helper.cc (cygsid::getfrompw): Change parameter to `const'.
        (cygsid::getfromgr): Ditto.
        * security.cc: Use `sys_mbstowcs' and `sys_wcstombs' throughout.
        (extract_nt_dom_user): Try to get user and domain from SID in
        pw->pw_gecos first.
        * security.h (class cygsid): Change parameter of getfrompw() and
        getfromgr() to `const'.
        * uinfo.cc (internal_getlogin): Change order for evaluating user
        information in winNT case. Drop usage of NetWkstaUserGetInfo().
@
text
@@


1.7
log
@        * autoload.cc: Add load statements for `LookupAccountNameW',
        `LsaClose', `LsaEnumerateAccountRights', `LsaFreeMemory',
        `LsaOpenPolicy', `LsaQueryInformationPolicy', `NetLocalGroupEnum',
        `NetLocalGroupGetMembers', `NetServerEnum', `NetUserGetGroups' and
        `NtCreateToken'.
        * ntdll.h: Add declaration for `NtCreateToken'.
        * sec_helper.cc: Add `well_known_local_sid', `well_known_dialup_sid',
        `well_known_network_sid', `well_known_batch_sid',
        `well_known_interactive_sid', `well_known_service_sid' and
        `well_known_authenticated_users_sid'.
        (cygsid::string): Define as const method.
        (cygsid::get_sid): Set psid to NO_SID on error.
        (cygsid::getfromstr): Ditto.
        (cygsid::getfrompw): Simplify.
        (cygsid::getfromgr): Check for gr == NULL.
        (legal_sid_type): Move to security.h.
        (set_process_privilege): Return -1 on error, otherwise 0 or 1 related
        to previous privilege setting.
        * security.cc (extract_nt_dom_user): Remove `static'.
        (lsa2wchar): New function.
        (open_local_policy): Ditto.
        (close_local_policy): Ditto.
        (get_lsa_srv_inf): Ditto.
        (get_logon_server): Ditto.
        (get_logon_server_and_user_domain): Ditto.
        (get_user_groups): Ditto.
        (is_group_member): Ditto.
        (get_user_local_groups): Ditto.
        (sid_in_token_groups): Ditto.
        (get_user_primary_group): Ditto.
        (get_group_sidlist): Ditto.
        (get_system_priv_list): Ditto.
        (get_priv_list): Ditto.
        (get_dacl): Ditto.
        (create_token): Ditto.
        (subauth): Return immediately if SE_TCB_NAME can't be assigned.
        Change all return statements in case of error to jumps to `out'
        label. Add `out' label to support cleanup.
        * security.h: Add extern declarations for `well_known_local_sid',
        `well_known_dialup_sid', `well_known_network_sid',
        `well_known_batch_sid', `well_known_interactive_sid',
        `well_known_service_sid' and `well_known_authenticated_users_sid'.
        Add extern declarations for functions `create_token',
        `extract_nt_dom_user' and `get_logon_server_and_user_domain'.
        (class cygsid): Add method `assign'. Change operator= to call new
        `assign' method. Add `debug_print' method.
        (class cygsidlist): New class.
        (legal_sid_type): Moved from sec_helper.cc to here.
        * spawn.cc (spawn_guts) Revert reversion of previous patch.
        Call `RevertToSelf' and `ImpersonateLoggedOnUser' instead of `seteuid'
        again.
        * syscalls.cc (seteuid): Rearranged. Call `create_token' now when
        needed. Call `subauth' if `create_token' fails. Try setting token
        owner and primary group only if token was not explicitely created
        by `create_token'.
        * uinfo.cc (internal_getlogin): Try harder to generate correct user
        information. Especially don't trust return value of `GetUserName'.
@
text
@d124 1
a124 1
cygsid::getfrompw (struct passwd *pw)
d131 1
a131 1
cygsid::getfromgr (struct group *gr)
@


1.6
log
@        * sec_helper.cc (legal_sid_type): Fix conditional. Change to
        inline function.
@
text
@d47 10
a57 3
cygsid well_known_system_sid ("S-1-5-18");
cygsid well_known_creator_owner_sid ("S-1-3-0");
cygsid well_known_world_sid ("S-1-1-0");
d60 1
a60 1
cygsid::string (char *nsidstr)
d84 4
a87 1
    return NULL;
d105 4
a108 1
    return NULL;
d126 2
a127 5
  char *sp = pw->pw_gecos ? strrchr (pw->pw_gecos, ',') : NULL;

  if (!sp)
    return FALSE;
  return (*this = ++sp) != NULL;
d133 2
a134 1
  return (*this = gr->gr_passwd) != NULL;
a251 7
static inline BOOL
legal_sid_type (SID_NAME_USE type)
{
  return type == SidTypeUser  || type == SidTypeGroup
      || type == SidTypeAlias || type == SidTypeWellKnownGroup;
}

d345 1
a345 1
  TOKEN_PRIVILEGES new_priv;
d347 1
d349 2
a350 1
  if (!OpenProcessToken (hMainProc, TOKEN_ADJUST_PRIVILEGES, &hToken))
d366 9
a374 1
  if (!AdjustTokenPrivileges (hToken, FALSE, &new_priv, 0, NULL, NULL))
d376 1
d381 1
a381 1
  ret = 0;
@


1.5
log
@        * fork.cc (fork): Eliminate superfluous call to getuid().
        * security.h: New define `NO_SID'. Remove declarations of functions
        moved to methods into class cygsid.
        (class cygsid): Declare new methods `getfromstr', `get_sid',
        `getfrompw', `getfromgr', `get_rid', `get_uid', `get_gid', `string'
        and new constructors and operators =, == and !=.
        Declare new global cygsids `well_known_XXX_sid' substituting the
        corresponding `get_XXX_sid' functions. Remove declarations of
        these functions.
        * sec_helper.cc (well_known_admin_sid): New global variable.
        (well_known_system_sid): Ditto
        (well_known_creator_owner_sid): Ditto
        (well_known_world_sid): Ditto
        (cygsid::string): New method, substituting `convert_sid_to_string_sid'.
        (cygsid::get_sid): New method, substituting `get_sid'.
        (cygsid::getfromstr): New method, substituting
        `convert_string_sid_to_sid'.
        (cygsid::getfrompw): New method, substituting `get_pw_sid'.
        (cygsid::getfromgr): New method, substituting `get_gr_sid'.
        (cygsid::get_id): New method, substituting `get_id_from_sid'.
        (get_admin_sid): Eliminated.
        (get_system_sid): Ditto.
        (get_creator_owner_sid): Ditto.
        (get_world_sid): Ditto.
        * grp.cc: Use new cygsid methods and well known sids throughout.
        * registry.cc: Ditto.
        * sec_acl.cc: Ditto.
        * security.cc: Ditto.
        * shared.cc: Ditto.
        * syscalls.cc (seteuid): Ditto. Eliminate redundant conditional.
        * uinfo.cc (internal_getlogin): Ditto.
        * spawn.cc (spawn_guts) Revert previous patch.
@
text
@d241 1
a241 1
static BOOL
d244 2
a245 2
  return type == SidTypeUser || type == SidTypeGroup
		 || SidTypeAlias || SidTypeWellKnownGroup;
@


1.4
log
@        * grp.cc: Eliminate MAX_DOMAIN_NAME define.
        (read_etc_group): Substitute MAX_DOMAIN_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * passwd.cc (parse_pwd): Don't force pw_name to be lower case.
        * sec_helper.cc: Substitute MAX_USER_NAME by UNLEN,
        MAX_COMPUTERNAME_LENGTH by INTERNET_MAX_HOST_NAME_LENGTH throughout.
        (lookup_name): Slight cleanup.
        * security.cc (alloc_sd): Substitute MAX_USER_NAME by UNLEN.
        * security.h: Define DEFAULT_UID as DOMAIN_USER_RID_ADMIN and
        DEFAULT_GID as DOMAIN_ALIAS_RID_ADMINS.
        * shared.cc (memory_init): Substitute MAX_USER_NAME by UNLEN.
        * thread.h: Ditto.
        * uinfo.cc (internal_getlogin): Substitute MAX_USER_NAME by UNLEN.
        Substitute MAX_COMPUTERNAME_LENGTH and MAX_HOST_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * winsup.h: Include lmcons.h. Eliminate MAX_USER_NAME and
        MAX_HOST_NAME. Move DEFAULT_UID and DEFAULT_GID to security.h.
@
text
@d47 5
d53 1
a53 1
convert_sid_to_string_sid (PSID psid, char *sid_str)
d58 1
a58 1
  if (!psid || !sid_str)
d60 1
a60 1
  strcpy (sid_str, "S-1-");
d62 1
a62 1
  strcat (sid_str, t);
d66 1
a66 1
      strcat (sid_str, t);
d68 1
a68 1
  return sid_str;
d72 1
a72 1
get_sid (PSID psid, DWORD s, DWORD cnt, DWORD *r)
d76 1
a76 1
  if (!psid || s > 5 || cnt < 1 || cnt > 8)
d78 1
a78 1

d85 2
a86 2
PSID
convert_string_sid_to_sid (PSID psid, const char *sid_str)
d94 1
a94 1
  if (!sid_str || strncmp (sid_str, "S-1-", 4))
d97 1
a97 1
  strcpy (sid_buf, sid_str);
d107 1
a107 1
  return get_sid (psid, s, cnt, r);
d111 1
a111 1
get_pw_sid (PSID sid, struct passwd *pw)
d117 1
a117 1
  return convert_string_sid_to_sid (sid, ++sp) != NULL;
d121 1
a121 17
get_gr_sid (PSID sid, struct group *gr)
{
  return convert_string_sid_to_sid (sid, gr->gr_passwd) != NULL;
}

PSID
get_admin_sid ()
{
  static NO_COPY cygsid admin_sid (NULL);

  if (!admin_sid)
    convert_string_sid_to_sid (admin_sid.set (), "S-1-5-32-544");
  return admin_sid;
}

PSID
get_system_sid ()
d123 1
a123 25
  static NO_COPY cygsid system_sid (NULL);

  if (!system_sid)
    convert_string_sid_to_sid (system_sid.set (), "S-1-5-18");
  return system_sid;
}

PSID
get_creator_owner_sid ()
{
  static NO_COPY cygsid owner_sid (NULL);

  if (!owner_sid)
    convert_string_sid_to_sid (owner_sid.set (), "S-1-3-0");
  return owner_sid;
}

PSID
get_world_sid ()
{
  static NO_COPY cygsid world_sid (NULL);

  if (!world_sid)
    convert_string_sid_to_sid (world_sid.set (), "S-1-1-0");
  return world_sid;
d127 1
a127 1
get_id_from_sid (PSID psid, BOOL search_grp, int *type)
d129 5
d152 1
a152 1
	      if (get_pw_sid (sid, pw) && sid == psid)
d170 1
a170 1
	      if (get_gr_sid (sid, gr) && sid == psid)
d241 1
a241 7
int
get_id_from_sid (PSID psid, BOOL search_grp)
{
  return get_id_from_sid (psid, search_grp, NULL);
}

BOOL
@


1.3
log
@        * autoload.cc: Add LoadDLLfunc statements for SetTokenInformation@@16.
        * cygheap.cc: Include security.h.
        * grp.cc (internal_getgrent): New function.
        (getgroups): Rearranged using `internal_getgrent' and the new
        `cygsid' class.
        * passwd.cc (internal_getpwent): New function.
        * sec_acl.cc: Use new `cygsid' class throughout.
        (acl_access): Use `internal_getgrent' instead of `getgrent'.
        * sec_helper.cc: Use new `cygsid' class throughout.
        (get_id_from_sid): Use `internal_getgrent' instead of `getgrent'.
        Use `internal_getpwent' instead of `getpwent'.
        * security.cc: Use new `cygsid' class throughout.
        * security.h: Move `MAX_SID_LEN' from winsup.h to here.
        Add extern declarations for `internal_getgrent' and `internal_getpwent'.
        (class cygsid): New class.
        * shared.cc (sec_user): Use new `cygsid' class.
        * syscalls.cc (seteuid): Try to set owner to user and primary group to
        current group in impersonation token before performing impersonation.
        (setegid): Try to set primary group in process token to the new group
        if ntsec is on.
        * uinfo.cc (internal_getlogin): Use new `cygsid' class.
        Try to set owner to user and primary group to current group in process
        token if the process has been started from a non cygwin process.
        (uinfo_init): Set primary group only if the process has been started
        from a non cygwin process.
        * winsup.h: Move define for `MAX_SID_LEN' to security.h.
@
text
@d26 1
d225 4
a228 4
      char account[MAX_USER_NAME];
      char domain[MAX_COMPUTERNAME_LENGTH+1];
      DWORD acc_len = MAX_USER_NAME;
      DWORD dom_len = MAX_COMPUTERNAME_LENGTH+1;
d303 3
d311 2
a312 2
  char domuser[MAX_COMPUTERNAME_LENGTH+MAX_USER_NAME+1];
  char dom[MAX_COMPUTERNAME_LENGTH+1];
d324 1
a324 4
      if (LookupAccountName (NULL, domuser,
			     sid, (sidlen = MAX_SID_LEN, &sidlen),
			     dom, (domlen = MAX_COMPUTERNAME_LENGTH, &domlen),
			     &acc_type)
d328 2
a329 4
	  && LookupAccountName (logsrv, domuser,
				sid, (sidlen = MAX_SID_LEN, &sidlen),
				dom, (domlen = MAX_COMPUTERNAME_LENGTH,&domlen),
				&acc_type)
d335 1
a335 4
      if (LookupAccountName (logsrv, name,
			     sid, (sidlen = MAX_SID_LEN, &sidlen),
			     dom, (domlen = MAX_COMPUTERNAME_LENGTH, &domlen),
			     &acc_type)
d341 2
a342 4
	  if (LookupAccountName (logsrv, domuser,
				 sid,(sidlen = MAX_SID_LEN, &sidlen),
				 dom,(domlen = MAX_COMPUTERNAME_LENGTH,&domlen),
				 &acc_type))
d346 1
a346 4
  if (LookupAccountName (NULL, name,
			 sid, (sidlen = MAX_SID_LEN, &sidlen),
			 dom, (domlen = 100, &domlen),
			 &acc_type)
d352 1
a352 4
      if (LookupAccountName (NULL, domuser,
			     sid, (sidlen = MAX_SID_LEN, &sidlen),
			     dom, (domlen = MAX_COMPUTERNAME_LENGTH, &domlen),
			     &acc_type))
d368 3
@


1.2
log
@        * security.cc (set_process_privileges): Swap out.
        * sec_helper.cc (set_process_privilege): Rename from
        `set_process_privileges'. Takes the privilege to enable or disable
        as parameter now.
        * security.h: Add prototype for `set_process_privileges'.
@
text
@d123 1
a123 2
  static NO_COPY char admin_sid_buf[MAX_SID_LEN];
  static NO_COPY PSID admin_sid = NULL;
d126 1
a126 4
    {
      admin_sid = (PSID) admin_sid_buf;
      convert_string_sid_to_sid (admin_sid, "S-1-5-32-544");
    }
d133 1
a133 2
  static NO_COPY char system_sid_buf[MAX_SID_LEN];
  static NO_COPY PSID system_sid = NULL;
d136 1
a136 4
    {
      system_sid = (PSID) system_sid_buf;
      convert_string_sid_to_sid (system_sid, "S-1-5-18");
    }
d143 1
a143 2
  static NO_COPY char owner_sid_buf[MAX_SID_LEN];
  static NO_COPY PSID owner_sid = NULL;
d146 1
a146 4
    {
      owner_sid = (PSID) owner_sid_buf;
      convert_string_sid_to_sid (owner_sid, "S-1-3-0");
    }
d153 1
a153 2
  static NO_COPY char world_sid_buf[MAX_SID_LEN];
  static NO_COPY PSID world_sid = NULL;
d156 1
a156 4
    {
      world_sid = (PSID) world_sid_buf;
      convert_string_sid_to_sid (world_sid, "S-1-1-0");
    }
d173 1
a173 2
      char sidbuf[MAX_SID_LEN];
      PSID sid = (PSID) sidbuf;
d179 1
a179 1
	  while ((pw = getpwent ()) != NULL)
d181 1
a181 1
	      if (get_pw_sid (sid, pw) && EqualSid (psid, sid))
a186 1
	  endpwent ();
d197 1
a197 1
	  while ((gr = getgrent ()) != NULL)
d199 1
a199 1
	      if (get_gr_sid (sid, gr) && EqualSid (psid, sid))
a204 1
	  endgrent ();
d305 1
a305 2
  char sidbuf[MAX_SID_LEN];
  PSID sid = (PSID) sidbuf;
@


1.1
log
@        * Makefile.in: Add object files `sec_helper.cc' and `sec_acl.cc'.
        * security.cc: Swap out several functions.
        * sec_acl.cc: New file. Move Sun compatibel ACL functions from
        `security.cc' to here.
        * sec_helper.cc: New file. Move security helper functions from
        `security.cc' to here.
        * security.h: Changed to accomodate the above changes.

        * grp.cc: Replace `group_in_memory_p' by `group_state'.
        Eliminate group_sem throughout.
        (enum grp_state): New enumeration type.
        (read_etc_group): Make race safe.
        * security.cc: Eliminate group_sem throughout.
@
text
@d400 40
@

