head	1.13;
access;
symbols
	cygwin-1_7_35-release:1.13
	cygwin-1_7_34-release:1.13
	cygwin-1_7_33-release:1.13
	cygwin-1_7_32-release:1.13
	cygwin-1_7_31-release:1.13
	cygwin-1_7_30-release:1.13
	cygwin-1_7_29-release:1.13
	cygwin-1_7_29-release-branchpoint:1.13.0.12
	cygwin-pre-user-db:1.13
	cygwin-1_7_28-release:1.13
	cygwin-1_7_27-release:1.13
	cygwin-1_7_26-release:1.13
	cygwin-1_7_25-release:1.13
	cygwin-1_7_24-release:1.13
	cygwin-1_7_23-release:1.13
	cygwin-1_7_22-release:1.13
	cygwin-1_7_21-release:1.13
	cygwin-1_7_20-release:1.13
	cygwin-1_7_19-release:1.13
	cygwin-64bit-postmerge:1.13
	cygwin-64bit-premerge-branch:1.13.0.10
	cygwin-64bit-premerge:1.13
	cygwin-1_7_18-release:1.13
	post-ptmalloc3:1.13
	pre-ptmalloc3:1.13
	cygwin-1_7_17-release:1.13
	cygwin-64bit-branch:1.13.0.8
	cygwin-1_7_16-release:1.13
	cygwin-1_7_15-release:1.13
	cygwin-1_7_14_2-release:1.13
	cygwin-1_7_14-release:1.13
	cygwin-1_7_12-release:1.13
	cygwin-1_7_11-release:1.13
	cygwin-1_7_10-release:1.13
	signal-rewrite:1.13.0.6
	pre-notty:1.13
	cygwin-1_7_9-release:1.13
	cv-post-1_7_9:1.13.0.4
	cygwin-1_7_8-release:1.13
	cygwin-1_7_7-release:1.13
	cygwin-1_7_5-release:1.13
	cygwin-1_7_4-release:1.13
	cygwin-1_7_3-release:1.13
	cygwin-1_7_2-release:1.13
	fifo_doover3:1.13.0.2
	cygwin-1_7_1-release:1.12
	prefifo:1.12
	cv-branch-2:1.12.0.2
	pre-ripout-set_console_state_for_spawn:1.9
	EOL_registry_mounts:1.8
	preoverlapped:1.8
	drop_9x_support_start:1.8
	cr-0x5f1:1.8.0.12
	cv-branch:1.8.0.10
	pre-ptymaster-archetype:1.8
	cr-0x3b58:1.8.0.8
	cr-0x5ef:1.8.0.6
	after-mmap-privanon-noreserve:1.8
	after-mmap-revamp:1.8
	before-mmap-revamp:1.8
	cgf-more-exit-sync:1.8
	post_wait_sig_exit:1.8
	pre_wait_sig_exit:1.8
	reparent-point:1.8
	noreparent:1.8.0.4
	cr-0x5e6:1.8.0.2
	cr-0x9e:1.5.0.6
	cr-0x9d:1.5.0.4
	cgf-deleteme:1.5.0.2
	pre-sigrewrite:1.5
	corinna-01:1.5
	cr-0x9c:1.4.4.1.0.2
	cr-0x9b:1.4.0.4
	cgf-dev-branch:1.4.0.2
	pre-cgf-merge:1.5
	cygwin_daemon_merge_HEAD:1.3
	Z-cygwin_daemon_merge-new_HEAD:1.3
	Z-cygwin_daemon_merge_HEAD:1.3
	cygwin_daemon:1.3.0.2
	cygwin-1_1_1:1.1.1.1
	winsup-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2009.12.14.10.47.25;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.13.09.58.43;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.11.06.22.31;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.11.04.34.24;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.08.14.41.47;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.20.23.31.47;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.20.21.30.44;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.14.19.43.52;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.16.03.39.55;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.10.19.13.04;	author corinna;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	2000.07.01.03.51.55;	author cgf;	state dead;
branches;
next	1.2;

1.2
date	2000.05.18.18.32.05;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.4.2.1
date	2003.09.11.04.47.22;	author cgf;	state Exp;
branches;
next	;

1.4.4.1
date	2003.09.19.01.55.54;	author cgf;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.13
log
@	* libc/getopt.c (getopt_internal): Set optreset according to optind
	setting earlier.  Reevaluate POSIXLY_CORRECT if optreset is set to !0.
	Handle a leading '-' in options independently of posixly_correct.
@
text
@/*	$OpenBSD: getopt_long.c,v 1.23 2007/10/31 12:34:57 chl Exp $	*/
/*	$NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $	*/

/*
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */
/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Dieter Baron and Thomas Klausner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <err.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#define __INSIDE_CYGWIN__
#include <getopt.h>

#define	REPLACE_GETOPT		/* use this getopt as the system getopt(3) */

#ifdef REPLACE_GETOPT
int	opterr = 1;		/* if error message should be printed */
int	optind = 1;		/* index into parent argv vector */
int	optopt = '?';		/* character checked for validity */
int	optreset;		/* reset getopt */
char    *optarg;		/* argument associated with option */
#endif

#define PRINT_ERROR	((opterr) && (*options != ':'))

#define FLAG_PERMUTE	0x01	/* permute non-options to the end of argv */
#define FLAG_ALLARGS	0x02	/* treat non-options as args to option "-1" */
#define FLAG_LONGONLY	0x04	/* operate as getopt_long_only */

/* return values */
#define	BADCH		(int)'?'
#define	BADARG		((*options == ':') ? (int)':' : (int)'?')
#define	INORDER 	(int)1

#ifdef __CYGWIN__
static char EMSG[] = "";
#else
#define	EMSG		""
#endif

static int getopt_internal(int, char * const *, const char *,
			   const struct option *, int *, int);
static int parse_long_options(char * const *, const char *,
			      const struct option *, int *, int);
static int gcd(int, int);
static void permute_args(int, int, int, char * const *);

static char *place = EMSG; /* option letter processing */

/* XXX: set optreset to 1 rather than these two */
static int nonopt_start = -1; /* first non option argument (for permute) */
static int nonopt_end = -1;   /* first option after non options (for permute) */

/* Error messages */
static const char recargchar[] = "option requires an argument -- %c";
static const char recargstring[] = "option requires an argument -- %s";
static const char ambig[] = "ambiguous option -- %.*s";
static const char noarg[] = "option doesn't take an argument -- %.*s";
static const char illoptchar[] = "unknown option -- %c";
static const char illoptstring[] = "unknown option -- %s";

/*
 * Compute the greatest common divisor of a and b.
 */
static int
gcd(int a, int b)
{
	int c;

	c = a % b;
	while (c != 0) {
		a = b;
		b = c;
		c = a % b;
	}

	return (b);
}

/*
 * Exchange the block from nonopt_start to nonopt_end with the block
 * from nonopt_end to opt_end (keeping the same order of arguments
 * in each block).
 */
static void
permute_args(int panonopt_start, int panonopt_end, int opt_end,
	char * const *nargv)
{
	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
	char *swap;

	/*
	 * compute lengths of blocks and number and size of cycles
	 */
	nnonopts = panonopt_end - panonopt_start;
	nopts = opt_end - panonopt_end;
	ncycle = gcd(nnonopts, nopts);
	cyclelen = (opt_end - panonopt_start) / ncycle;

	for (i = 0; i < ncycle; i++) {
		cstart = panonopt_end+i;
		pos = cstart;
		for (j = 0; j < cyclelen; j++) {
			if (pos >= panonopt_end)
				pos -= nnonopts;
			else
				pos += nopts;
			swap = nargv[pos];
			/* LINTED const cast */
			((char **) nargv)[pos] = nargv[cstart];
			/* LINTED const cast */
			((char **)nargv)[cstart] = swap;
		}
	}
}

/*
 * parse_long_options --
 *	Parse long options in argc/argv argument vector.
 * Returns -1 if short_too is set and the option does not match long_options.
 */
static int
parse_long_options(char * const *nargv, const char *options,
	const struct option *long_options, int *idx, int short_too)
{
	char *current_argv, *has_equal;
	size_t current_argv_len;
	int i, ambiguous, match;

#define IDENTICAL_INTERPRETATION(_x, _y)                                \
	(long_options[(_x)].has_arg == long_options[(_y)].has_arg &&    \
	 long_options[(_x)].flag == long_options[(_y)].flag &&          \
	 long_options[(_x)].val == long_options[(_y)].val)

	current_argv = place;
	match = -1;
	ambiguous = 0;

	optind++;

	if ((has_equal = strchr(current_argv, '=')) != NULL) {
		/* argument found (--option=arg) */
		current_argv_len = has_equal - current_argv;
		has_equal++;
	} else
		current_argv_len = strlen(current_argv);

	for (i = 0; long_options[i].name; i++) {
		/* find matching long option */
		if (strncmp(current_argv, long_options[i].name,
		    current_argv_len))
			continue;

		if (strlen(long_options[i].name) == current_argv_len) {
			/* exact match */
			match = i;
			ambiguous = 0;
			break;
		}
		/*
		 * If this is a known short option, don't allow
		 * a partial match of a single character.
		 */
		if (short_too && current_argv_len == 1)
			continue;

		if (match == -1)	/* partial match */
			match = i;
		else if (!IDENTICAL_INTERPRETATION(i, match))
			ambiguous = 1;
	}
	if (ambiguous) {
		/* ambiguous abbreviation */
		if (PRINT_ERROR)
			warnx(ambig, (int)current_argv_len,
			     current_argv);
		optopt = 0;
		return (BADCH);
	}
	if (match != -1) {		/* option found */
		if (long_options[match].has_arg == no_argument
		    && has_equal) {
			if (PRINT_ERROR)
				warnx(noarg, (int)current_argv_len,
				     current_argv);
			/*
			 * XXX: GNU sets optopt to val regardless of flag
			 */
			if (long_options[match].flag == NULL)
				optopt = long_options[match].val;
			else
				optopt = 0;
			return (BADARG);
		}
		if (long_options[match].has_arg == required_argument ||
		    long_options[match].has_arg == optional_argument) {
			if (has_equal)
				optarg = has_equal;
			else if (long_options[match].has_arg ==
			    required_argument) {
				/*
				 * optional argument doesn't use next nargv
				 */
				optarg = nargv[optind++];
			}
		}
		if ((long_options[match].has_arg == required_argument)
		    && (optarg == NULL)) {
			/*
			 * Missing argument; leading ':' indicates no error
			 * should be generated.
			 */
			if (PRINT_ERROR)
				warnx(recargstring,
				    current_argv);
			/*
			 * XXX: GNU sets optopt to val regardless of flag
			 */
			if (long_options[match].flag == NULL)
				optopt = long_options[match].val;
			else
				optopt = 0;
			--optind;
			return (BADARG);
		}
	} else {			/* unknown option */
		if (short_too) {
			--optind;
			return (-1);
		}
		if (PRINT_ERROR)
			warnx(illoptstring, current_argv);
		optopt = 0;
		return (BADCH);
	}
	if (idx)
		*idx = match;
	if (long_options[match].flag) {
		*long_options[match].flag = long_options[match].val;
		return (0);
	} else
		return (long_options[match].val);
#undef IDENTICAL_INTERPRETATION
}

/*
 * getopt_internal --
 *	Parse argc/argv argument vector.  Called by user level routines.
 */
static int
getopt_internal(int nargc, char * const *nargv, const char *options,
	const struct option *long_options, int *idx, int flags)
{
	char *oli;				/* option letter list index */
	int optchar, short_too;
	static int posixly_correct = -1;

	if (options == NULL)
		return (-1);

	/*
	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
	 * XXX using optreset.  Work around this braindamage.
	 */
	if (optind == 0)
		optind = optreset = 1;

	/*
	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
	 * string begins with a '+'.
	 *
	 * CV, 2009-12-14: Check POSIXLY_CORRECT anew if optind == 0 or
	 *                 optreset != 0 for GNU compatibility.
	 */
	if (posixly_correct == -1 || optreset != 0)
		posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
	if (*options == '-')
		flags |= FLAG_ALLARGS;
	else if (posixly_correct || *options == '+')
		flags &= ~FLAG_PERMUTE;
	if (*options == '+' || *options == '-')
		options++;

	optarg = NULL;
	if (optreset)
		nonopt_start = nonopt_end = -1;
start:
	if (optreset || !*place) {		/* update scanning pointer */
		optreset = 0;
		if (optind >= nargc) {          /* end of argument vector */
			place = EMSG;
			if (nonopt_end != -1) {
				/* do permutation, if we have to */
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				optind -= nonopt_end - nonopt_start;
			}
			else if (nonopt_start != -1) {
				/*
				 * If we skipped non-options, set optind
				 * to the first of them.
				 */
				optind = nonopt_start;
			}
			nonopt_start = nonopt_end = -1;
			return (-1);
		}
		if (*(place = nargv[optind]) != '-' ||
		    (place[1] == '\0' && strchr(options, '-') == NULL)) {
			place = EMSG;		/* found non-option */
			if (flags & FLAG_ALLARGS) {
				/*
				 * GNU extension:
				 * return non-option as argument to option 1
				 */
				optarg = nargv[optind++];
				return (INORDER);
			}
			if (!(flags & FLAG_PERMUTE)) {
				/*
				 * If no permutation wanted, stop parsing
				 * at first non-option.
				 */
				return (-1);
			}
			/* do permutation */
			if (nonopt_start == -1)
				nonopt_start = optind;
			else if (nonopt_end != -1) {
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				nonopt_start = optind -
				    (nonopt_end - nonopt_start);
				nonopt_end = -1;
			}
			optind++;
			/* process next argument */
			goto start;
		}
		if (nonopt_start != -1 && nonopt_end == -1)
			nonopt_end = optind;

		/*
		 * If we have "-" do nothing, if "--" we are done.
		 */
		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
			optind++;
			place = EMSG;
			/*
			 * We found an option (--), so if we skipped
			 * non-options, we have to permute.
			 */
			if (nonopt_end != -1) {
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				optind -= nonopt_end - nonopt_start;
			}
			nonopt_start = nonopt_end = -1;
			return (-1);
		}
	}

	/*
	 * Check long options if:
	 *  1) we were passed some
	 *  2) the arg is not just "-"
	 *  3) either the arg starts with -- we are getopt_long_only()
	 */
	if (long_options != NULL && place != nargv[optind] &&
	    (*place == '-' || (flags & FLAG_LONGONLY))) {
		short_too = 0;
		if (*place == '-')
			place++;		/* --foo long option */
		else if (*place != ':' && strchr(options, *place) != NULL)
			short_too = 1;		/* could be short option too */

		optchar = parse_long_options(nargv, options, long_options,
		    idx, short_too);
		if (optchar != -1) {
			place = EMSG;
			return (optchar);
		}
	}

	if ((optchar = (int)*place++) == (int)':' ||
	    (optchar == (int)'-' && *place != '\0') ||
	    (oli = strchr(options, optchar)) == NULL) {
		/*
		 * If the user specified "-" and  '-' isn't listed in
		 * options, return -1 (non-option) as per POSIX.
		 * Otherwise, it is an unknown option character (or ':').
		 */
		if (optchar == (int)'-' && *place == '\0')
			return (-1);
		if (!*place)
			++optind;
		if (PRINT_ERROR)
			warnx(illoptchar, optchar);
		optopt = optchar;
		return (BADCH);
	}
	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
		/* -W long-option */
		if (*place)			/* no space */
			/* NOTHING */;
		else if (++optind >= nargc) {	/* no arg */
			place = EMSG;
			if (PRINT_ERROR)
				warnx(recargchar, optchar);
			optopt = optchar;
			return (BADARG);
		} else				/* white space */
			place = nargv[optind];
		optchar = parse_long_options(nargv, options, long_options,
		    idx, 0);
		place = EMSG;
		return (optchar);
	}
	if (*++oli != ':') {			/* doesn't take argument */
		if (!*place)
			++optind;
	} else {				/* takes (optional) argument */
		optarg = NULL;
		if (*place)			/* no white space */
			optarg = place;
		else if (oli[1] != ':') {	/* arg not optional */
			if (++optind >= nargc) {	/* no arg */
				place = EMSG;
				if (PRINT_ERROR)
					warnx(recargchar, optchar);
				optopt = optchar;
				return (BADARG);
			} else
				optarg = nargv[optind];
		}
		place = EMSG;
		++optind;
	}
	/* dump back option letter */
	return (optchar);
}

#ifdef REPLACE_GETOPT
/*
 * getopt --
 *	Parse argc/argv argument vector.
 *
 * [eventually this will replace the BSD getopt]
 */
int
getopt(int nargc, char * const *nargv, const char *options)
{

	/*
	 * We don't pass FLAG_PERMUTE to getopt_internal() since
	 * the BSD getopt(3) (unlike GNU) has never done this.
	 *
	 * Furthermore, since many privileged programs call getopt()
	 * before dropping privileges it makes sense to keep things
	 * as simple (and bug-free) as possible.
	 */
	return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
}
#endif /* REPLACE_GETOPT */

/*
 * getopt_long --
 *	Parse argc/argv argument vector.
 */
int
getopt_long(int nargc, char * const *nargv, const char *options,
    const struct option *long_options, int *idx)
{

	return (getopt_internal(nargc, nargv, options, long_options, idx,
	    FLAG_PERMUTE));
}

/*
 * getopt_long_only --
 *	Parse argc/argv argument vector.
 */
int
getopt_long_only(int nargc, char * const *nargv, const char *options,
    const struct option *long_options, int *idx)
{

	return (getopt_internal(nargc, nargv, options, long_options, idx,
	    FLAG_PERMUTE|FLAG_LONGONLY));
}
@


1.12
log
@	* libc/getopt.c (parse_long_options): Use fix from NetBSD's getopt
	to avoid false ambiguities.
@
text
@d307 7
d316 3
d320 1
a320 1
	if (posixly_correct == -1)
d322 3
a324 1
	if (posixly_correct || *options == '+')
a325 2
	else if (*options == '-')
		flags |= FLAG_ALLARGS;
a328 7
	/*
	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
	 * XXX using optreset.  Work around this braindamage.
	 */
	if (optind == 0)
		optind = optreset = 1;

@


1.11
log
@* cygwin.din (sys_sigabbrev): Add this here.
* dcrt0.cc (__argc,__argv,_check_for_executable): Remove dllexport decoration
since it is already handled in cygwin.din.
* errno.cc (_sys_errlist): Ditto.
* strsig.cc (sys_sigabbrev): Ditto.
* include/cygwin/signal.h: Protect use of dllimport when __INSIDE_CYGWIN__.
* libc/getopt.c: Revert previous changes.  Define __INSIDE_CYGWIN__.
@
text
@d173 6
a178 1
	int i, match;
d182 1
d202 1
d214 10
a223 8
		else {
			/* ambiguous abbreviation */
			if (PRINT_ERROR)
				warnx(ambig, (int)current_argv_len,
				     current_argv);
			optopt = 0;
			return (BADCH);
		}
d288 1
@


1.10
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@a53 1
#include <getopt.h>
d56 2
d62 5
a66 5
int __declspec(dllexport)   opterr = 1;	/* if error message should be printed */
int __declspec(dllexport)   optind = 1; /* index into parent argv vector */
int __declspec(dllexport)   optopt = '?';/* index into parent argv vector *//* character checked for validity */
int __declspec(dllexport)   optreset;	/* reset getopt */
char  __declspec(dllexport) *optarg;	/* argument associated with option */
@


1.9
log
@	* Makefile.in (DLL_OFILES): Add _def_time.o.  Remove timelocal.o.
	* include/sys/localedef.h: New file from NetBSD.
	* libc/_def_time.c: Ditto.
	* libc/getopt.c: Update to latest OpenBSD version 1.23.
	* libc/strptime.cc: Replace FreeBSD version 1.35 with latest NetBSD
	version 1.28.
	* libc/timelocal.cc: Remove.
	* libc/timelocal.h: Remove.
@
text
@d61 5
a65 5
int	opterr = 1;		/* if error message should be printed */
int	optind = 1;		/* index into parent argv vector */
int	optopt = '?';		/* character checked for validity */
int	optreset;		/* reset getopt */
char    *optarg;		/* argument associated with option */
@


1.8
log
@	* getopt.c: Avoid useless compiler warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.16 2004/02/04 18:17:25 millert Exp $	*/
a37 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
a51 4
#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.16 2004/02/04 18:17:25 millert Exp $";
#endif /* LIBC_SCCS and not lint */

a456 1
		/* XXX: disable test for :: if PC? (GNU doesn't) */
a465 7
		} else if (!(flags & FLAG_PERMUTE)) {
			/*
			 * If permutation is disabled, we can accept an
			 * optional arg separated by whitespace.
			 */
			if (optind + 1 < nargc)
				optarg = nargv[++optind];
d486 1
a486 1
	 * We dont' pass FLAG_PERMUTE to getopt_internal() since
d502 2
a503 6
getopt_long(nargc, nargv, options, long_options, idx)
	int nargc;
	char * const *nargv;
	const char *options;
	const struct option *long_options;
	int *idx;
d515 2
a516 6
getopt_long_only(nargc, nargv, options, long_options, idx)
	int nargc;
	char * const *nargv;
	const char *options;
	const struct option *long_options;
	int *idx;
@


1.7
log
@	* getopt.c: Replace with latest vanilla(!) OpenBSD version 1.16.
@
text
@d90 3
d94 1
d428 1
a428 1
	    optchar == (int)'-' && *place != '\0' ||
@


1.6
log
@	* getopt.c: Replace with latest NetBSD version 1.16.  Keep Cygwin
	specific changes as minimal as possible.
@
text
@d1 2
a2 1
/*	$NetBSD: getopt_long.c,v 1.16 2003/10/27 00:12:42 lukem Exp $	*/
d4 19
a58 1
#include <sys/cdefs.h>
d60 1
a60 1
__RCSID("$NetBSD: getopt_long.c,v 1.16 2003/10/27 00:12:42 lukem Exp $");
a62 5
#ifndef __CYGWIN__
#include "namespace.h"
#endif

#include <assert.h>
d69 1
a69 10
#ifdef __CYGWIN__
#define _DIAGASSERT(x) do {} while (0)
#define HAVE_NBTOOL_CONFIG_H 1
#define HAVE_GETOPT_LONG 0
#define HAVE_DECL_OPTIND 0
#endif

#if HAVE_NBTOOL_CONFIG_H && !HAVE_GETOPT_LONG && !HAVE_DECL_OPTIND
#define REPLACE_GETOPT
#endif
a71 3
#ifdef __weak_alias
__weak_alias(getopt,_getopt)
#endif
a76 2
#elif HAVE_NBTOOL_CONFIG_H && !HAVE_DECL_OPTRESET
static int optreset;
d79 1
a79 3
#ifdef __weak_alias
__weak_alias(getopt_long,_getopt_long)
#endif
d81 3
a83 8
#if !HAVE_GETOPT_LONG
#define IGNORE_FIRST	(*options == '-' || *options == '+')
#define PRINT_ERROR	((opterr) && ((*options != ':') \
				      || (IGNORE_FIRST && options[1] != ':')))
#define IS_POSIXLY_CORRECT (getenv("POSIXLY_CORRECT") != NULL)
#define PERMUTE         (!IS_POSIXLY_CORRECT && !IGNORE_FIRST)
/* XXX: GNU ignores PC if *options == '-' */
#define IN_ORDER        (!IS_POSIXLY_CORRECT && *options == '-')
d86 12
a97 14
#define	BADCH	(int)'?'
#define	BADARG		((IGNORE_FIRST && options[1] == ':') \
			 || (*options == ':') ? (int)':' : (int)'?')
#define INORDER (int)1

#ifdef __CYGWIN__
static char EMSG[1];
#else
#define	EMSG	""
#endif

static int getopt_internal __P((int, char * const *, const char *));
static int gcd __P((int, int));
static void permute_args __P((int, int, int, char * const *));
a112 1

d117 1
a117 3
gcd(a, b)
	int a;
	int b;
d127 2
a128 2
	   
	return b;
d137 2
a138 5
permute_args(panonopt_start, panonopt_end, opt_end, nargv)
	int panonopt_start;
	int panonopt_end;
	int opt_end;
	char * const *nargv;
a142 2
	_DIAGASSERT(nargv != NULL);

d169 119
a289 1
 *  Returns -2 if -- is found (can be long option or end of options marker).
d292 2
a293 4
getopt_internal(nargc, nargv, options)
	int nargc;
	char * const *nargv;
	const char *options;
d296 2
a297 1
	int optchar;
d299 2
a300 2
	_DIAGASSERT(nargv != NULL);
	_DIAGASSERT(options != NULL);
d302 12
a313 1
	optarg = NULL;
d316 2
a317 3
	 * XXX Some programs (like rsyncd) expect to be able to
	 * XXX re-initialize optind to 0 and have getopt_long(3)
	 * XXX properly function again.  Work around this braindamage.
d320 1
a320 1
		optind = 1;
d322 1
d344 1
a344 1
			return -1;
d346 4
a349 4
		if ((*(place = nargv[optind]) != '-')
		    || (place[1] == '\0')) {    /* found non-option */
			place = EMSG;
			if (IN_ORDER) {
d351 1
a351 1
				 * GNU extension: 
d355 1
a355 1
				return INORDER;
d357 1
a357 1
			if (!PERMUTE) {
d359 2
a360 2
				 * if no permutation wanted, stop parsing
				 * at first non-option
d362 1
a362 1
				return -1;
d380 40
a419 3
		if (place[1] && *++place == '-') {	/* found "--" */
			place++;
			return -2;
d422 1
d424 9
a432 2
	    (oli = strchr(options + (IGNORE_FIRST ? 1 : 0), optchar)) == NULL) {
		/* option letter unknown or ':' */
d438 1
a438 1
		return BADCH;
d440 5
a444 6
	if (optchar == 'W' && oli[1] == ';') {		/* -W long-option */
		/* XXX: what if no long options provided (called by getopt)? */
		if (*place) 
			return -2;

		if (++optind >= nargc) {	/* no arg */
d449 1
a449 1
			return BADARG;
d452 4
a455 5
		/*
		 * Handle -W arg the same as --arg (which causes getopt to
		 * stop parsing).
		 */
		return -2;
d471 1
a471 1
				return BADARG;
d474 7
d486 1
a486 1
	return optchar;
d494 1
a494 1
 * [eventually this will replace the real getopt]
d497 1
a497 4
getopt(nargc, nargv, options)
	int nargc;
	char * const *nargv;
	const char *options;
a498 1
	int retval;
d500 9
a508 18
	_DIAGASSERT(nargv != NULL);
	_DIAGASSERT(options != NULL);

	if ((retval = getopt_internal(nargc, nargv, options)) == -2) {
		++optind;
		/*
		 * We found an option (--), so if we skipped non-options,
		 * we have to permute.
		 */
		if (nonopt_end != -1) {
			permute_args(nonopt_start, nonopt_end, optind,
				       nargv);
			optind -= nonopt_end - nonopt_start;
		}
		nonopt_start = nonopt_end = -1;
		retval = -1;
	}
	return retval;
d510 1
a510 1
#endif
a523 1
	int retval;
d525 3
a527 9
	_DIAGASSERT(nargv != NULL);
	_DIAGASSERT(options != NULL);
	_DIAGASSERT(long_options != NULL);
	/* idx may be NULL */

	if ((retval = getopt_internal(nargc, nargv, options)) == -2) {
		char *current_argv, *has_equal;
		size_t current_argv_len;
		int i, match;
d529 12
a540 5
		current_argv = place;
		match = -1;

		optind++;
		place = EMSG;
d542 2
a543 106
		if (*current_argv == '\0') {		/* found "--" */
			/*
			 * We found an option (--), so if we skipped
			 * non-options, we have to permute.
			 */
			if (nonopt_end != -1) {
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				optind -= nonopt_end - nonopt_start;
			}
			nonopt_start = nonopt_end = -1;
			return -1;
		}
		if ((has_equal = strchr(current_argv, '=')) != NULL) {
			/* argument found (--option=arg) */
			current_argv_len = has_equal - current_argv;
			has_equal++;
		} else
			current_argv_len = strlen(current_argv);
	    
		for (i = 0; long_options[i].name; i++) {
			/* find matching long option */
			if (strncmp(current_argv, long_options[i].name,
			    current_argv_len))
				continue;

			if (strlen(long_options[i].name) ==
			    (unsigned)current_argv_len) {
				/* exact match */
				match = i;
				break;
			}
			if (match == -1)		/* partial match */
				match = i;
			else {
				/* ambiguous abbreviation */
				if (PRINT_ERROR)
					warnx(ambig, (int)current_argv_len,
					     current_argv);
				optopt = 0;
				return BADCH;
			}
		}
		if (match != -1) {			/* option found */
		        if (long_options[match].has_arg == no_argument
			    && has_equal) {
				if (PRINT_ERROR)
					warnx(noarg, (int)current_argv_len,
					     current_argv);
				/*
				 * XXX: GNU sets optopt to val regardless of
				 * flag
				 */
				if (long_options[match].flag == NULL)
					optopt = long_options[match].val;
				else
					optopt = 0;
				return BADARG;
			}
			if (long_options[match].has_arg == required_argument ||
			    long_options[match].has_arg == optional_argument) {
				if (has_equal)
					optarg = has_equal;
				else if (long_options[match].has_arg ==
				    required_argument) {
					/*
					 * optional argument doesn't use
					 * next nargv
					 */
					optarg = nargv[optind++];
				}
			}
			if ((long_options[match].has_arg == required_argument)
			    && (optarg == NULL)) {
				/*
				 * Missing argument; leading ':'
				 * indicates no error should be generated
				 */
				if (PRINT_ERROR)
					warnx(recargstring, current_argv);
				/*
				 * XXX: GNU sets optopt to val regardless
				 * of flag
				 */
				if (long_options[match].flag == NULL)
					optopt = long_options[match].val;
				else
					optopt = 0;
				--optind;
				return BADARG;
			}
		} else {			/* unknown option */
			if (PRINT_ERROR)
				warnx(illoptstring, current_argv);
			optopt = 0;
			return BADCH;
		}
		if (long_options[match].flag) {
			*long_options[match].flag = long_options[match].val;
			retval = 0;
		} else 
			retval = long_options[match].val;
		if (idx)
			*idx = match;
	}
	return retval;
a544 1
#endif /* !GETOPT_LONG */
@


1.5
log
@* getopt.cc (opterr): Reinstate initialization.
(optind): Ditto.
(optopt): Ditto.
* pinfo.cc: Include cygheap.h or suffer compile error.
* shared.h: Reset magic number.
@
text
@d1 1
a1 1
/*	$NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $	*/
d39 9
a47 1
#include "winsup.h"
d49 1
d51 1
a53 3
#include <getopt.h>
#include <stdarg.h>
#include <stdio.h>
d55 8
d64 1
a64 2

#define _DIAGASSERT(x) do {} while (0)
d70 7
a76 5
int __declspec(dllexport) opterr = 1;	/* if error message should be printed */
int __declspec(dllexport) optind = 1;	/* index into parent argv vector */
int __declspec(dllexport) optopt = '?';	/* character checked for validity */
int __declspec(dllexport) optreset;	/* reset getopt */
char __declspec(dllexport) *optarg;	/* argument associated with option */
d83 1
a83 6
#ifndef __CYGWIN__
#define __progname __argv[0]
#else
extern char *__progname;
#endif

d87 1
a87 3

#define IS_POSIXLY_CORRECT (getenv("POSIXLY_INCORRECT_GETOPT") == NULL)

d98 1
d100 3
d104 3
a106 3
static int getopt_internal (int, char * const *, const char *);
static int gcd (int, int);
static void permute_args (int, int, int, char * const *);
a121 17
static void
_vwarnx(const char *fmt, va_list ap)
{
  (void)fprintf(stderr, "%s: ", __progname);
  if (fmt != NULL)
    (void)vfprintf(stderr, fmt, ap);
  (void)fprintf(stderr, "\n");
}

static void
warnx(const char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  _vwarnx(fmt, ap);
  va_end(ap);
}
d139 1
a139 1

d240 1
a240 1
				 * GNU extension:
d286 1
a286 1
		if (*place)
d413 1
a413 1

d438 1
a438 1
			if (long_options[match].has_arg == no_argument
d494 1
a494 1
		} else
d501 1
@


1.4
log
@	* Makefile.in (DLL_OFILES): Add getopt.o and iruserok.o.
	* cygwin.din: Export __check_rhosts_file, __rcmd_errstr, optarg,
	opterr, optind, optopt, optreset, getopt, getopt_long, iruserok
	and ruserok.
	* getopt.c: Moved from lib to here.  Define opt* variables as
	dllexport.
	* iruserok.c: Moved from lib to here.  Rearrange function order.
	Prefer using 64/32 bit functions.
	* syscalls.cc (shell_fp): Define as struct __sFILE64.
	(getusershell): Use fopen64 instead of fopen.
	* winsup.h: Add declarations for seteuid32, fopen64,
	cygwin_gethostbyname and cygwin_inet_addr.
	* include/getopt.h: Declare opt* variables dllimport.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d56 3
a58 3
int __declspec(dllexport) opterr;	/* if error message should be printed */
int __declspec(dllexport) optind;	/* index into parent argv vector */
int __declspec(dllexport) optopt;	/* character checked for validity */
@


1.4.4.1
log
@* fhandler_disk_file.cc (path_conv::ndisk_links): Fix potential off-by-one
problem when first file in a directory is a directory.
* Makefile.in: Make malloc_wrapper -fomit-frame-pointer.
* cygwin.din: Remove extraneous mallinfo definition.
* dcrt0.cc (quoted): Use strechr for efficiency.
* exceptions.cc (sig_handle_tty_stop): Fix boneheaded mistake by using correct
check for parent state rather than inverted check.
* getopt.c (opterr): Reinstate initialization.
(optind): Ditto.
(optopt): Ditto.
@
text
@d56 3
a58 3
int __declspec(dllexport) opterr = 1;	/* if error message should be printed */
int __declspec(dllexport) optind = 1;	/* index into parent argv vector */
int __declspec(dllexport) optopt = '?';	/* character checked for validity */
@


1.4.2.1
log
@merge from trunk
@
text
@@


1.3
log
@* Makefile.in: Use variables rather than configure constructs where
appropriate.
(LIBCOS): Find additional stub library stuff in their own subdirectory.
* dcrt0.cc: Convert user_data pointer to static __cygwin_user_data area.
(do_global_ctors): Check magic_bisquit for initialization.
(dll_crt0_1): First group of premain functions prior to fd initialization.  Run
second group before calling main.
(dll_crt0 ()): New function, called from new initialization code.
(dll_crt0 (per_process *uptr)): Call new dll_crt0 () function on
initialization.
* debug.cc (thread_stub): Initialize bottom of stack with per-thread info.
* environ.cc (parse_thing): Use binmode global to control CYGWIN=binmode
behavior.
* fhandler.cc (fhandler_base::open): Allow explicit setting of __fmode to
O_BINARY or O_TEXT to override disk mount settings.
* libcmain.cc: Move to lib subdirectory.
* libccrt0.cc: Ditto.
* dll_main.cc: Ditto.
* dll_entry.cc: Ditto.
* getopt.c: Ditto.
* thread.cc (thread_init_wrapper): Call ExitThread explicitly rather than
returning, as a preliminary step towards placing per thread info at the bottom
of the stack.
* winsup.h: Move per_process class to include/sys/cygwin.h.  Declare new
dll_crt0().
* include/cygwin/version.h: Bump API minor version.
* binmode.c: New file.
* textmode.c: Ditto.
* lib/_cygwin_crt0_common.cc: Ditto.
* lib/crt0.h: Ditto.
* lib/cygwin_attach_dll.c: Ditto.
* lib/cygwin_crt0.c: Ditto.
* lib/dll_entry.cc: Ditto.
* lib/dll_main.cc: Ditto.
* lib/getopt.c: Ditto.
* lib/libcmain.c: Ditto.
* lib/premain0.c: Ditto.
* lib/premain1.c: Ditto.
* lib/premain2.c: Ditto.
* lib/premain3.c: Ditto.
@
text
@d1 8
a8 3
/*
 * Copyright (c) 1987, 1993, 1994, 1996
 *	The Regents of the University of California.  All rights reserved.
d20 5
a24 5
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d26 11
a36 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d39 3
a41 1
#include <stdio.h>
d44 64
a107 1
#include "getopt.h"
d109 8
a116 5
int	  opterr = 1;	/* if error message should be printed */
int	  optind = 1;	/* index into parent argv vector */
int	  optopt;	/* character checked for validity */
int	  optreset;	/* reset getopt */
char 	  *optarg;	/* argument associated with option */
d118 8
a125 2
static char * __progname (char *);
int getopt_internal (int, char * const *, const char *);
d127 7
a133 2
static char * __progname(nargv0)
    char * nargv0;
d135 10
a144 3
    char * tmp = strrchr(nargv0, '/');
    if (tmp) tmp++; else tmp = nargv0;
    return(tmp);
d147 41
a187 3
#define	BADCH	(int)'?'
#define	BADARG	(int)':'
#define	EMSG	""
d190 3
a192 2
 * getopt --
 *	Parse argc/argv argument vector.
d194 2
a195 2
int
getopt_internal(nargc, nargv, ostr)
d198 1
a198 1
	const char *ostr;
a199 1
	static const char *place = EMSG;	/* option letter processing */
d201 1
d203 16
d221 20
a240 1
		if (optind >= nargc || *(place = nargv[optind]) != '-') {
d242 28
a269 1
			return (-1);
d271 2
d274 20
a293 1
			/* ++optind; */
d295 6
a300 5
			return (-2);
		}
	}					/* option letter okay? */
	if ((optopt = (int)*place++) == (int)':' ||
	    !(oli = strchr(ostr, optopt))) {
d302 2
a303 2
		 * if the user didn't specify '-' as an option,
		 * assume it means -1.
d305 3
a307 2
		if (optopt == (int)'-')
			return (-1);
d310 1
a310 6
		if (opterr && *ostr != ':')
			(void)fprintf(stderr,
			    "%s: illegal option -- %c\n", __progname(nargv[0]), optopt);
		return (BADCH);
	}
	if (*++oli != ':') {			/* don't need argument */
a311 3
		if (!*place)
			++optind;
	} else {				/* need an argument */
d313 12
a324 10
			optarg = (char *)place;
		else if (nargc <= ++optind) {	/* no arg */
			place = EMSG;
			if ((opterr) && (*ostr != ':'))
				(void)fprintf(stderr,
				    "%s: option requires an argument -- %c\n",
				    __progname(nargv[0]), optopt);
			return (BADARG);
		} else				/* white space */
			optarg = nargv[optind];
d328 2
a329 1
	return (optopt);			/* dump back option letter */
d332 1
d336 2
d340 1
a340 1
getopt(nargc, nargv, ostr)
d343 1
a343 1
	const char *ostr;
d347 15
a361 1
	if ((retval = getopt_internal(nargc, nargv, ostr)) == -2) {
a362 1
		++optind;
d364 1
a364 1
	return(retval);
d366 1
d373 6
a378 6
getopt_long(nargc, nargv, options, long_options, index)
     int nargc;
     char ** nargv;
     char * options;
     struct option * long_options;
     int * index;
d382 5
d388 1
a388 2
		char *current_argv = nargv[optind++] + 2, *has_equal;
		int i, match = -1;
d390 1
d392 18
a409 2
		if (*current_argv == '\0') {
			return(-1);
d411 2
a412 1
		if ((has_equal = strchr(current_argv, '='))) {
d419 3
a421 1
			if (strncmp(current_argv, long_options[i].name, current_argv_len))
d424 3
a426 1
			if (strlen(long_options[i].name) == current_argv_len) {
d430 1
a430 1
			if (match == -1)
d432 8
d441 18
a458 2
		if (match != -1) {
			if (long_options[match].has_arg) {
d461 23
d485 3
a487 1
					optarg = nargv[optind++];
d489 5
a493 13
			if ((long_options[match].has_arg == 1) && (optarg == NULL)) {
				/* Missing option, leading : indecates no error */
				if ((opterr) && (*options != ':'))
					(void)fprintf(stderr,
				      "%s: option requires an argument -- %s\n",
				      __progname(nargv[0]), current_argv);
				return (BADARG);
			}
		} else { /* No matching argument */
			if ((opterr) && (*options != ':'))
				(void)fprintf(stderr,
				    "%s: illegal option -- %s\n", __progname(nargv[0]), current_argv);
			return (BADCH);
d500 2
a501 61
		if (index)
			*index = match;
	}
	return(retval);
}
/*****************************************************************/






#include <stdio.h>
#include "getopt.h"

/* Stuff for getopt */
static struct option long_options[] = {
	{ (char *)"simple", 0, NULL, 's' },
	{ (char *)"t", 0, NULL, 't' },
	{ (char *)"u", 1, NULL, 'u' },
	{ (char *)"v", 0, NULL, 'v' },
	/* Do not reorder the following */
	{ (char *)"yy", 0, NULL, 'Y' },
	{  (char *)"y", 0, NULL, 'y' },
	{ (char *)"zz", 0, NULL, 'z' },
	{ (char *)"zzz", 0, NULL, 'Z' },
	{ NULL, 0, NULL, 0 }
};
extern char * optarg;
extern int optreset;
extern int optind;

int test_getopt_long(args, expected_result)
    char ** args, * expected_result;
{
	char actual_result[256];
	int count, pass, i;

	pass = 0;
	optind = 1;
	optreset = 1;
	for (count = 0; args[count]; count++);
	while ((i = getopt_long(count, args, (char *)"ab:", long_options, NULL)) != EOF) {
		switch(i) {
		case 'u':
			if (strcmp(optarg, "bogus")) {
				printf("--u option does not have bogus optarg.\n");
				return(1);
			}
		case 'Y':
		case 's':
		case 't':
		case 'v':
		case 'y':
		case 'z':
			actual_result[pass++] = i;
			break;
		default:
			actual_result[pass++] = '?';
			break;
		}
d503 1
a503 4

	actual_result[pass] = '\0';
	return(strcmp(actual_result, expected_result));
	
a504 119

#if 0
int usage(value)
	int value;
{
	printf("test_getopt [-d]\n");
	exit(value);
}
#endif

#if 0

/*
 * Static arglists for individual tests
 * This is ugly and maybe I should just use a variable arglist
 */
const char *argv1[] = { "Test simple", "--s", NULL };
const char *argv2[] = { "Test multiple", "--s", "--t", NULL };
const char *argv3[] = { "Test optarg with space", "--u", "bogus", NULL };
const char *argv4[] = { "Test optarg with equal", "--u=bogus", NULL };
const char *argv5[] = { "Test complex", "--s", "--t", "--u", "bogus", "--v", NULL };
const char *argv6[] = { "Test exact", "--y", NULL };
const char *argv7[] = { "Test abbr", "--z", NULL };
const char *argv8[] = { "Test simple termination", "--z", "foo", "--z", NULL };
const char *argv9[] = { "Test -- termination", "--z", "--", "--z", NULL };

int debug = 0;
int main(argc, argv)
    int argc;
    char ** argv;
{
	int i;

	/* Of course if getopt() has a bug this won't work */
	while ((i = getopt(argc, argv, "d")) != EOF) {
		switch(i) {
		case 'd':
			debug++;
			break;
		default:
			usage(1);
			break;
		}
	}

	/* Test getopt_long() */
	{
		if (test_getopt_long(argv1, "s")) {
			printf("Test simple failed.\n");
			exit(1);
		}
	}

	/* Test multiple arguments */
	{
		if (test_getopt_long(argv2, "st")) {
			printf("Test multiple failed.\n");
			exit(1);
		}
	}

	/* Test optarg with space */
	{
		if (test_getopt_long(argv3, "u")) {
			printf("Test optarg with space failed.\n");
			exit(1);
		}
	}

	/* Test optarg with equal */
	{
		if (test_getopt_long(argv4, "u")) {
			printf("Test optarg with equal failed.\n");
			exit(1);
		}
	}

	/* Test complex */
	{
		if (test_getopt_long(argv5, "stuv")) {
			printf("Test complex failed.\n");
			exit(1);
		}
	}

	/* Test that exact matches override abbr matches */
	{
		if (test_getopt_long(argv6, "y")) {
			printf("Test exact failed.\n");
			exit(1);
		}
	}

	/* Test that abbr matches are first match. */
	{
		if (test_getopt_long(argv7, "z")) {
			printf("Test abbr failed.\n");
			exit(1);
		}
	}

	/* Test that option termination succeeds */
	{
		if (test_getopt_long(argv8, "z")) {
			printf("Test simple termination failed.\n");
			exit(1);
		}
	}

	/* Test that "--" termination succeeds */
	{
		if (test_getopt_long(argv9, "z")) {
			printf("Test -- termination failed.\n");
			exit(1);
		}
	}
	exit(0);
}
#endif
@


1.2
log
@* select.cc (thread_pipe): Add paranoid check to ensure thread termination.
* external.cc: Eliminate obsolete include.
* getopt.c (getopt_long): Fix compiler warning.
* shared.h: Moved PID_ definitions to include/sys/cygwin so that they can be
used by external programs.
* include/sys/cygwin.h: Move external definitions here.  Include sys/resource.h
to avoid having to do this everywhere.
@
text
@@


1.1
log
@Initial revision
@
text
@d157 2
a158 1
		int i, current_argv_len, match = -1;
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
