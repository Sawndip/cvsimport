head	1.12;
access;
symbols
	cygwin-1_7_35-release:1.12
	cygwin-1_7_34-release:1.12
	cygwin-1_7_33-release:1.11.2.1
	cygwin-1_7_32-release:1.11.2.1
	cygwin-1_7_31-release:1.11.2.1
	cygwin-1_7_30-release:1.11.2.1
	cygwin-1_7_29-release:1.11.2.1
	cygwin-1_7_29-release-branchpoint:1.11.0.2
	cygwin-pre-user-db:1.11
	cygwin-1_7_28-release:1.11
	cygwin-1_7_27-release:1.11
	cygwin-1_7_26-release:1.11
	cygwin-1_7_25-release:1.10
	cygwin-1_7_24-release:1.10
	cygwin-1_7_23-release:1.10
	cygwin-1_7_22-release:1.10
	cygwin-1_7_21-release:1.10
	cygwin-1_7_20-release:1.10
	cygwin-1_7_19-release:1.10
	cygwin-64bit-postmerge:1.10
	cygwin-64bit-premerge-branch:1.10.0.4
	cygwin-64bit-premerge:1.10
	cygwin-1_7_18-release:1.10
	post-ptmalloc3:1.10
	pre-ptmalloc3:1.10
	cygwin-1_7_17-release:1.10
	cygwin-64bit-branch:1.10.0.2
	cygwin-1_7_16-release:1.10
	cygwin-1_7_15-release:1.10
	cygwin-1_7_14_2-release:1.10
	cygwin-1_7_14-release:1.10
	cygwin-1_7_12-release:1.10
	cygwin-1_7_11-release:1.10
	cygwin-1_7_10-release:1.10
	signal-rewrite:1.9.0.2
	pre-notty:1.9
	cygwin-1_7_9-release:1.7
	cv-post-1_7_9:1.7.0.2
	cygwin-1_7_8-release:1.7
	cygwin-1_7_7-release:1.7
	cygwin-1_7_5-release:1.7
	cygwin-1_7_4-release:1.7
	cygwin-1_7_3-release:1.7
	cygwin-1_7_2-release:1.7
	fifo_doover3:1.5.0.4
	cygwin-1_7_1-release:1.5
	prefifo:1.5
	cv-branch-2:1.5.0.2
	pre-ripout-set_console_state_for_spawn:1.5
	EOL_registry_mounts:1.2
	preoverlapped:1.2
	drop_9x_support_start:1.2
	cr-0x5f1:1.2.0.8
	cv-branch:1.2.0.6
	pre-ptymaster-archetype:1.2
	cr-0x3b58:1.2.0.4
	cr-0x5ef:1.2.0.2
	after-mmap-privanon-noreserve:1.2
	after-mmap-revamp:1.2
	before-mmap-revamp:1.2;
locks; strict;
comment	@// @;


1.12
date	2014.03.05.12.45.49;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.25.11.38.08;	author corinna;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.12.13.44.54;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.01.08.37.10;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.26.17.53.52;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.22.22.31.31;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.10.18.57.10;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.08.14.58.11;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.08.14.41.47;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.18.19.43.02;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.18.17.48.23;	author corinna;	state Exp;
branches;
next	;

1.11.2.1
date	2014.03.09.18.56.21;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.12
log
@	* localtime.cc: Define TM_GMTOFF and TM_ZONE based on __TM_GMTOFF and
	__TM_ZONE being defined.  Throughout, write to these struct tm members
	only if CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS is true.
	* libc/strptime.cc: Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS):
	Define.
	(CYGWIN_VERSION_API_MINOR): Bump to 272.
@
text
@/*	$NetBSD: strptime.c,v 1.28 2008/04/28 20:23:01 martin Exp $	*/

/*-
 * Copyright (c) 1997, 1998, 2005, 2008 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code was contributed to The NetBSD Foundation by Klaus Klein.
 * Heavily optimised by David Laight
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>
#if defined(LIBC_SCCS) && !defined(lint)
__RCSID("$NetBSD: strptime.c,v 1.28 2008/04/28 20:23:01 martin Exp $");
#endif

#ifdef __CYGWIN__
#include "winsup.h"
#else
#include "namespace.h"
#include <sys/localedef.h>
#endif
#include <ctype.h>
#include <stdlib.h>
#include <locale.h>
#include <string.h>
#include <time.h>
#include <tzfile.h>
#include "../locale/timelocal.h"

#ifdef __TM_GMTOFF
# define TM_GMTOFF __TM_GMTOFF
#endif
#ifdef __TM_ZONE
# define TM_ZONE __TM_ZONE
#endif

#ifdef __weak_alias
__weak_alias(strptime,_strptime)
#endif

#define	_ctloc(x)		(_CurrentTimeLocale->x)

#define ALT_E			0x01
#define ALT_O			0x02
#define	LEGAL_ALT(x)		{ if (alt_format & ~(x)) return NULL; }

static _CONST int _DAYS_BEFORE_MONTH[12] =
{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};

#define SET_MDAY 1
#define SET_MON  2
#define SET_YEAR 4
#define SET_WDAY 8
#define SET_YDAY 16
#define SET_YMD  (SET_YEAR | SET_MON | SET_MDAY)

static const char gmt[4] = { "GMT" };

typedef struct _era_info_t {
  size_t num;		/* Only in first entry: Number of entries,
			   1 otherwise. */
  int dir;		/* Direction */
  long offset;		/* Number of year closest to start_date in the era. */
  struct tm start;	/* Start date of era */
  struct tm end;	/* End date of era */
  CHAR *era_C;		/* Era string */
  CHAR *era_Y;		/* Replacement for %EY */
} era_info_t;

static void
free_era_info (era_info_t *era_info)
{
  size_t num = era_info->num;

  for (size_t i = 0; i < num; ++i)
    {
      free (era_info[i].era_C);
      free (era_info[i].era_Y);
    }
  free (era_info);
}

static era_info_t *
get_era_info (const char *era)
{
  char *c;
  era_info_t *ei = NULL;
  size_t num = 0, cur = 0, len;

  while (*era)
    {
      ++num;
      era_info_t *tmp = (era_info_t *) realloc (ei, num * sizeof (era_info_t));
      if (!tmp)
	{
	  ei->num = cur;
	  free_era_info (ei);
	  return NULL;
	}
      ei = tmp;
      ei[cur].num = 1;
      ei[cur].dir = (*era == '+') ? 1 : -1;
      era += 2;
      ei[cur].offset = strtol (era, &c, 10);
      era = c + 1;
      ei[cur].start.tm_year = strtol (era, &c, 10);
      /* Adjust offset for negative gregorian dates. */
      if (ei[cur].start.tm_year < 0)
	++ei[cur].start.tm_year;
      ei[cur].start.tm_mon = strtol (c + 1, &c, 10);
      ei[cur].start.tm_mday = strtol (c + 1, &c, 10);
      ei[cur].start.tm_hour = ei[cur].start.tm_min = ei[cur].start.tm_sec = 0;
      era = c + 1;
      if (era[0] == '-' && era[1] == '*')
	{
	  ei[cur].end = ei[cur].start;
	  ei[cur].start.tm_year = INT_MIN;
	  ei[cur].start.tm_mon = ei[cur].start.tm_mday = ei[cur].start.tm_hour
	  = ei[cur].start.tm_min = ei[cur].start.tm_sec = 0;
	  era += 3;
	}
      else if (era[0] == '+' && era[1] == '*')
	{
	  ei[cur].end.tm_year = INT_MAX;
	  ei[cur].end.tm_mon = 12;
	  ei[cur].end.tm_mday = 31;
	  ei[cur].end.tm_hour = 23;
	  ei[cur].end.tm_min = ei[cur].end.tm_sec = 59;
	  era += 3;
	}
      else
	{
	  ei[cur].end.tm_year = strtol (era, &c, 10);
	  /* Adjust offset for negative gregorian dates. */
	  if (ei[cur].end.tm_year < 0)
	    ++ei[cur].end.tm_year;
	  ei[cur].end.tm_mon = strtol (c + 1, &c, 10);
	  ei[cur].end.tm_mday = strtol (c + 1, &c, 10);
	  ei[cur].end.tm_mday = 31;
	  ei[cur].end.tm_hour = 23;
	  ei[cur].end.tm_min = ei[cur].end.tm_sec = 59;
	  era = c + 1;
	}
      /* era_C */
      c = strchr (era, ':');
      len = c - era;
      ei[cur].era_C = (CHAR *) malloc ((len + 1) * sizeof (CHAR));
      if (!ei[cur].era_C)
	{
	  ei->num = cur;
	  free_era_info (ei);
	  return NULL;
	}
      strncpy (ei[cur].era_C, era, len);
      era += len;
      ei[cur].era_C[len] = '\0';
      /* era_Y */
      ++era;
      c = strchr (era, ';');
      if (!c)
	c = strchr (era, '\0');
      len = c - era;
      ei[cur].era_Y = (CHAR *) malloc ((len + 1) * sizeof (CHAR));
      if (!ei[cur].era_Y)
	{
	  free (ei[cur].era_C);
	  ei->num = cur;
	  free_era_info (ei);
	  return NULL;
	}
      strncpy (ei[cur].era_Y, era, len);
      era += len;
      ei[cur].era_Y[len] = '\0';
      ++cur;
      if (*c)
	era = c + 1;
    }
  ei->num = num;
  return ei;
}

typedef struct _alt_digits_t {
  size_t num;
  char **digit;
  char *buffer;
} alt_digits_t;

static alt_digits_t *
get_alt_digits (const char *alt_digits)
{
  alt_digits_t *adi;
  const char *a, *e;
  char *aa, *ae;
  size_t len;

  adi = (alt_digits_t *) calloc (1, sizeof (alt_digits_t));
  if (!adi)
    return NULL;

  /* Compute number of alt_digits. */
  adi->num = 1;
  for (a = alt_digits; (e = strchr (a, ';')) != NULL; a = e + 1)
      ++adi->num;
  /* Allocate the `digit' array, which is an array of `num' pointers into
     `buffer'. */
  adi->digit = (CHAR **) calloc (adi->num, sizeof (CHAR **));
  if (!adi->digit)
    {
      free (adi);
      return NULL;
    }
  /* Compute memory required for `buffer'. */
  len = strlen (alt_digits);
  /* Allocate it. */
  adi->buffer = (CHAR *) malloc ((len + 1) * sizeof (CHAR));
  if (!adi->buffer)
    {
      free (adi->digit);
      free (adi);
      return NULL;
    }
  /* Store digits in it. */
  strcpy (adi->buffer, alt_digits);
  /* Store the pointers into `buffer' into the appropriate `digit' slot. */
  for (len = 0, aa = adi->buffer; (ae = strchr (aa, ';')) != NULL;
       ++len, aa = ae + 1)
    {
      *ae = '\0';
      adi->digit[len] = aa;
    }
  adi->digit[len] = aa;
  return adi;
}

static void
free_alt_digits (alt_digits_t *adi)
{
  free (adi->digit);
  free (adi->buffer);
  free (adi);
}

static const unsigned char *
find_alt_digits (const unsigned char *bp, alt_digits_t *adi, uint *pval)
{
  /* This is rather error-prone, but the entire idea of alt_digits
     isn't thought out well.  If you start to look for matches at the
     start, there's a high probability that you find short matches but
     the entire translation is wrong.  So we scan the alt_digits array
     from the highest to the lowest digits instead, hoping that it's
     more likely to catch digits consisting of multiple characters. */
  for (int i = (int) adi->num - 1; i >= 0; --i)
    {
      size_t len = strlen (adi->digit[i]);
      if (!strncmp ((const char *) bp, adi->digit[i], len))
	{
	  *pval = i;
	  return bp + len;
	}
    }
  return NULL;
}

static int
is_leap_year (int year)
{
  return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0);
}

static int
first_day (int year)
{
  int ret = 4;

  while (--year >= 1970)
    ret = (ret + 365 + is_leap_year (year)) % 7;
  return ret;
}

/* This simplifies the calls to conv_num enormously. */
#define ALT_DIGITS	((alt_format & ALT_O) ? *alt_digits : NULL)

static const u_char *conv_num(const unsigned char *, int *, uint, uint,
			      alt_digits_t *);
static const u_char *find_string(const u_char *, int *, const char * const *,
	const char * const *, int);

static char *
__strptime(const char *buf, const char *fmt, struct tm *tm,
	   era_info_t **era_info, alt_digits_t **alt_digits)
{
	unsigned char c;
	const unsigned char *bp;
	int alt_format, i, split_year = 0;
	era_info_t *era = NULL;
	int era_offset, got_eoff = 0;
	int saw_padding;
	unsigned long width;
	const char *new_fmt;
	uint ulim;
	int ymd = 0;

	bp = (const u_char *)buf;
	struct lc_time_T *_CurrentTimeLocale = __get_current_time_locale ();

	while (bp != NULL && (c = *fmt++) != '\0') {
		/* Clear `alternate' modifier prior to new conversion. */
		saw_padding = 0;
		width = 0;
		alt_format = 0;
		i = 0;

		/* Eat up white-space. */
		if (isspace(c)) {
			while (isspace(*bp))
				bp++;
			continue;
		}

		if (c != '%')
			goto literal;


again:		switch (c = *fmt++) {
		case '%':	/* "%%" is converted to "%". */
literal:
			if (c != *bp++)
				return NULL;
			LEGAL_ALT(0);
			continue;

		/*
		 * "Alternative" modifiers. Just set the appropriate flag
		 * and start over again.
		 */
		case 'E':	/* "%E?" alternative conversion modifier. */
			LEGAL_ALT(0);
			alt_format |= ALT_E;
			if (!*era_info && *_CurrentTimeLocale->era)
			  *era_info = get_era_info (_CurrentTimeLocale->era);
			goto again;

		case 'O':	/* "%O?" alternative conversion modifier. */
			LEGAL_ALT(0);
			alt_format |= ALT_O;
			if (!*alt_digits && *_CurrentTimeLocale->alt_digits)
			  *alt_digits =
			      get_alt_digits (_CurrentTimeLocale->alt_digits);
			goto again;
		case '0':
		case '+':
			LEGAL_ALT(0);
			if (saw_padding)
			  return NULL;
			saw_padding = 1;
			goto again;
		case '1': case '2': case '3': case '4': case '5':
		case '6': case '7': case '8': case '9':
			/* POSIX-1.2008 maximum field width.  Per POSIX,
			   the width is only defined for the 'C', 'F', and 'Y'
			   conversion specifiers. */
			LEGAL_ALT(0);
			{
			  char *end;
			  width = strtoul (fmt - 1, &end, 10);
			  fmt = (const char *) end;
			  goto again;
			}
		/*
		 * "Complex" conversion rules, implemented through recursion.
		 */
		case 'c':	/* Date and time, using the locale's format. */
			new_fmt = (alt_format & ALT_E)
				  ? _ctloc (era_d_t_fmt) : _ctloc(c_fmt);
			LEGAL_ALT(ALT_E);
			ymd |= SET_WDAY | SET_YMD;
			goto recurse;

		case 'D':	/* The date as "%m/%d/%y". */
			new_fmt = "%m/%d/%y";
			LEGAL_ALT(0);
			ymd |= SET_YMD;
			goto recurse;

		case 'F':	/* The date as "%Y-%m-%d". */
			{
			  LEGAL_ALT(0);
			  ymd |= SET_YMD;
			  char *tmp = __strptime ((const char *) bp, "%Y-%m-%d",
						  tm, era_info, alt_digits);
			  if (tmp && (uint) (tmp - (char *) bp) > width)
			    return NULL;
			  bp = (const unsigned char *) tmp;
			  continue;
			}

		case 'R':	/* The time as "%H:%M". */
			new_fmt = "%H:%M";
			LEGAL_ALT(0);
			goto recurse;

		case 'r':	/* The time in 12-hour clock representation. */
			new_fmt =_ctloc(ampm_fmt);
			LEGAL_ALT(0);
			goto recurse;

		case 'T':	/* The time as "%H:%M:%S". */
			new_fmt = "%H:%M:%S";
			LEGAL_ALT(0);
			goto recurse;

		case 'X':	/* The time, using the locale's format. */
			new_fmt = (alt_format & ALT_E)
				  ? _ctloc (era_t_fmt) : _ctloc(X_fmt);
			LEGAL_ALT(ALT_E);
			goto recurse;

		case 'x':	/* The date, using the locale's format. */
			new_fmt = (alt_format & ALT_E)
				  ? _ctloc (era_d_fmt) : _ctloc(x_fmt);
			LEGAL_ALT(ALT_E);
			ymd |= SET_YMD;
		    recurse:
			bp = (const u_char *)__strptime((const char *)bp,
							new_fmt, tm,
							era_info, alt_digits);
			continue;

		/*
		 * "Elementary" conversion rules.
		 */
		case 'A':	/* The day of week, using the locale's form. */
		case 'a':
			bp = find_string(bp, &tm->tm_wday, _ctloc(weekday),
					_ctloc(wday), 7);
			LEGAL_ALT(0);
			ymd |= SET_WDAY;
			continue;

		case 'B':	/* The month, using the locale's form. */
		case 'b':
		case 'h':
			bp = find_string(bp, &tm->tm_mon, _ctloc(month),
					_ctloc(mon), 12);
			LEGAL_ALT(0);
			ymd |= SET_WDAY;
			continue;

		case 'C':	/* The century number. */
			LEGAL_ALT(ALT_E);
			ymd |= SET_YEAR;
			if ((alt_format & ALT_E) && *era_info)
			  {
			    /* With E modifier, an era.  We potentially
			       don't know the era offset yet, so we have to
			       store the value in a local variable.
			       The final computation of tm_year is only done
			       right before this function returns. */
			    size_t num = (*era_info)->num;
			    for (size_t i = 0; i < num; ++i)
			      if (!strncmp ((const char *) bp,
					    (*era_info)[i].era_C,
					    strlen ((*era_info)[i].era_C)))
				{
				  era = (*era_info) + i;
				  bp += strlen (era->era_C);
				  break;
				}
			    if (!era)
			      return NULL;
			    continue;
			  }
			i = 20;
			for (ulim = 99; width && width < 2; ++width)
			  ulim /= 10;
			bp = conv_num(bp, &i, 0, ulim, NULL);

			i = i * 100 - TM_YEAR_BASE;
			if (split_year)
				i += tm->tm_year % 100;
			split_year = 1;
			tm->tm_year = i;
			era = NULL;
			got_eoff = 0;
			continue;

		case 'd':	/* The day of month. */
		case 'e':
			LEGAL_ALT(ALT_O);
			ymd |= SET_MDAY;
			bp = conv_num(bp, &tm->tm_mday, 1, 31, ALT_DIGITS);
			continue;

		case 'k':	/* The hour (24-hour clock representation). */
			LEGAL_ALT(0);
			/* FALLTHROUGH */
		case 'H':
			LEGAL_ALT(ALT_O);
			bp = conv_num(bp, &tm->tm_hour, 0, 23, ALT_DIGITS);
			continue;

		case 'l':	/* The hour (12-hour clock representation). */
			LEGAL_ALT(0);
			/* FALLTHROUGH */
		case 'I':
			LEGAL_ALT(ALT_O);
			bp = conv_num(bp, &tm->tm_hour, 1, 12, ALT_DIGITS);
			if (tm->tm_hour == 12)
				tm->tm_hour = 0;
			continue;

		case 'j':	/* The day of year. */
			i = 1;
			bp = conv_num(bp, &i, 1, 366, NULL);
			tm->tm_yday = i - 1;
			LEGAL_ALT(0);
			ymd |= SET_YDAY;
			continue;

		case 'M':	/* The minute. */
			LEGAL_ALT(ALT_O);
			bp = conv_num(bp, &tm->tm_min, 0, 59, ALT_DIGITS);
			continue;

		case 'm':	/* The month. */
			LEGAL_ALT(ALT_O);
			ymd |= SET_MON;
			i = 1;
			bp = conv_num(bp, &i, 1, 12, ALT_DIGITS);
			tm->tm_mon = i - 1;
			continue;

		case 'p':	/* The locale's equivalent of AM/PM. */
			bp = find_string(bp, &i, _ctloc(am_pm), NULL, 2);
			if (tm->tm_hour > 11)
				return NULL;
			tm->tm_hour += i * 12;
			LEGAL_ALT(0);
			continue;

		case 'S':	/* The seconds. */
			LEGAL_ALT(ALT_O);
			bp = conv_num(bp, &tm->tm_sec, 0, 61, ALT_DIGITS);
			continue;

		case 'U':	/* The week of year, beginning on sunday. */
		case 'W':	/* The week of year, beginning on monday. */
			/*
			 * XXX This is bogus, as we can not assume any valid
			 * information present in the tm structure at this
			 * point to calculate a real value, so just check the
			 * range for now.
			 */
			 LEGAL_ALT(ALT_O);
			 bp = conv_num(bp, &i, 0, 53, ALT_DIGITS);
			 continue;

		case 'u':	/* The day of week, beginning on monday. */
			LEGAL_ALT(ALT_O);
			ymd |= SET_WDAY;
			bp = conv_num(bp, &i, 1, 7, ALT_DIGITS);
			tm->tm_wday = i % 7;
			continue;
		case 'w':	/* The day of week, beginning on sunday. */
			LEGAL_ALT(ALT_O);
			ymd |= SET_WDAY;
			bp = conv_num(bp, &tm->tm_wday, 0, 6, ALT_DIGITS);
			continue;

		case 'Y':	/* The year. */
			LEGAL_ALT(ALT_E);
			ymd |= SET_YEAR;
			if ((alt_format & ALT_E) && *era_info)
			  {
			    bool gotit = false;
			    size_t num = (*era_info)->num;
			    (*era_info)->num = 1;
			    for (size_t i = 0; i < num; ++i)
			      {
				era_info_t *tmp_ei = (*era_info) + i;
				char *tmp = __strptime ((const char *) bp,
							tmp_ei->era_Y,
							tm, &tmp_ei,
							alt_digits);
				if (tmp)
				  {
				    bp = (const unsigned char *) tmp;
				    gotit = true;
				    break;
				  }
			      }
			    (*era_info)->num = num;
			    if (gotit)
			      continue;
			    return NULL;
			  }
			i = TM_YEAR_BASE;	/* just for data sanity... */
			for (ulim = 9999; width && width < 4; ++width)
			  ulim /= 10;
			bp = conv_num(bp, &i, 0, ulim, NULL);
			tm->tm_year = i - TM_YEAR_BASE;
			era = NULL;
			got_eoff = 0;
			continue;

		case 'y':	/* The year within 100 years of the epoch. */
			/* LEGAL_ALT(ALT_E | ALT_O); */
			ymd |= SET_YEAR;
			if ((alt_format & ALT_E) && *era_info)
			  {
			    /* With E modifier, the offset to the start date
			       of the era specified with %EC.  We potentially
			       don't know the era yet, so we have to store the
			       value in a local variable, just like era itself.
			       The final computation of tm_year is only done
			       right before this function returns. */
			    bp = conv_num(bp, &era_offset, 0, UINT_MAX, NULL);
			    got_eoff = 1;
			    continue;
			  }
			bp = conv_num(bp, &i, 0, 99, ALT_DIGITS);

			if (split_year) /* preserve century */
				i += (tm->tm_year / 100) * 100;
			else {
				split_year = 1;
				if (i <= 68)
					i = i + 2000 - TM_YEAR_BASE;
				else
					i = i + 1900 - TM_YEAR_BASE;
			}
			tm->tm_year = i;
			era = NULL;
			got_eoff = 0;
			continue;

		case 'Z':
			tzset();
			if (strncmp((const char *)bp, gmt, 3) == 0) {
				tm->tm_isdst = 0;
#ifdef TM_GMTOFF
				if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
				  tm->TM_GMTOFF = 0;
#endif
#ifdef TM_ZONE
				if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
				  tm->TM_ZONE = gmt;
#endif
				bp += 3;
			} else {
				const unsigned char *ep;

				ep = find_string(bp, &i,
					       	 (const char * const *)tzname,
					       	  NULL, 2);
				if (ep != NULL) {
					tm->tm_isdst = i;
#ifdef TM_GMTOFF
					if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
					  tm->TM_GMTOFF = -(timezone);
#endif
#ifdef TM_ZONE
					if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
					  tm->TM_ZONE = tzname[i];
#endif
				}
				bp = ep;
			}
			continue;

		/*
		 * Miscellaneous conversions.
		 */
		case 'n':	/* Any kind of white-space. */
		case 't':
			while (isspace(*bp))
				bp++;
			LEGAL_ALT(0);
			continue;


		default:	/* Unknown/unsupported conversion. */
			return NULL;
		}
	}

	if (bp && (era || got_eoff))
	  {
	    /* Default to current era. */
	    if (!era)
	      era = *era_info;
	    /* Default to first year of era if offset is missing */
	    if (!got_eoff)
	      era_offset = era->offset;
	    tm->tm_year = (era->start.tm_year != INT_MIN
			   ? era->start.tm_year : era->end.tm_year)
			   + (era_offset - era->offset) * era->dir;
	    /* Check if year falls into the era.  If not, it's an
	       invalid combination of era and offset. */
	    if (era->start.tm_year > tm->tm_year
	    	|| era->end.tm_year < tm->tm_year)
	      return NULL;
	    tm->tm_year -= TM_YEAR_BASE;
	  }

	if ((ymd & SET_YMD) == SET_YMD)
	  {
	    /* all of tm_year, tm_mon and tm_mday, but... */
	    if (!(ymd & SET_YDAY))
	      {
		/* ...not tm_yday, so fill it in */
		tm->tm_yday = _DAYS_BEFORE_MONTH[tm->tm_mon] + tm->tm_mday;
		if (!is_leap_year (tm->tm_year + TM_YEAR_BASE)
		    || tm->tm_mon < 2)
		  tm->tm_yday--;
		ymd |= SET_YDAY;
	      }
	  }
	else if ((ymd & (SET_YEAR | SET_YDAY)) == (SET_YEAR | SET_YDAY))
	  {
	    /* both of tm_year and tm_yday, but... */
	    if (!(ymd & SET_MON))
	      {
		/* ...not tm_mon, so fill it in, and/or... */
		if (tm->tm_yday < _DAYS_BEFORE_MONTH[1])
		  tm->tm_mon = 0;
		else
		  {
		    int leap = is_leap_year (tm->tm_year + TM_YEAR_BASE);
		    for (i = 2; i < 12; ++i)
		      if (tm->tm_yday < _DAYS_BEFORE_MONTH[i] + leap)
			break;
		    tm->tm_mon = i - 1;
		  }
	      }
	    if (!(ymd & SET_MDAY))
	      {
		/* ...not tm_mday, so fill it in */
		tm->tm_mday = tm->tm_yday - _DAYS_BEFORE_MONTH[tm->tm_mon];
		if (!is_leap_year (tm->tm_year + TM_YEAR_BASE)
		    || tm->tm_mon < 2)
		  tm->tm_mday++;
	      }
	  }

	if ((ymd & (SET_YEAR | SET_YDAY | SET_WDAY)) == (SET_YEAR | SET_YDAY))
	  {
	    /* fill in tm_wday */
	    int fday = first_day (tm->tm_year + TM_YEAR_BASE);
	    tm->tm_wday = (fday + tm->tm_yday) % 7;
	  }
	return (char *) bp;
}

char *
strptime (const char *__restrict buf, const char *__restrict fmt,
	  struct tm *__restrict tm)
{
  era_info_t *era_info = NULL;
  alt_digits_t *alt_digits = NULL;
  char *ret = __strptime (buf, fmt, tm, &era_info, &alt_digits);
  if (era_info)
    free_era_info (era_info);
  if (alt_digits)
    free_alt_digits (alt_digits);
  return ret;
}

static const u_char *
conv_num(const unsigned char *buf, int *dest, uint llim, uint ulim,
	 alt_digits_t *alt_digits)
{
	uint result = 0;
	unsigned char ch;

	if (alt_digits)
	  buf = find_alt_digits (buf, alt_digits, &result);
	else
	  {
	    /* The limit also determines the number of valid digits. */
	    uint rulim = ulim;

	    ch = *buf;
	    if (ch < '0' || ch > '9')
		    return NULL;

	    do {
		    result *= 10;
		    result += ch - '0';
		    rulim /= 10;
		    ch = *++buf;
	    } while ((result * 10 <= ulim) && rulim && ch >= '0' && ch <= '9');
	  }

	if (result < llim || result > ulim)
		return NULL;

	*dest = result;
	return buf;
}

static const u_char *
find_string(const u_char *bp, int *tgt, const char * const *n1,
		const char * const *n2, int c)
{
	int i;
	unsigned int len;

	/* check full name - then abbreviated ones */
	for (; n1 != NULL; n1 = n2, n2 = NULL) {
		for (i = 0; i < c; i++, n1++) {
			len = strlen(*n1);
			if (strncasecmp(*n1, (const char *)bp, len) == 0) {
				*tgt = i;
				return bp + len;
			}
		}
	}

	/* Nothing matched */
	return NULL;
}
@


1.11
log
@	Throughout, keep function definitions and declarations in sync with
	newlib in terms of C99 "restrict" keyword.
@
text
@d51 7
d663 2
a664 1
				tm->TM_GMTOFF = 0;
d667 2
a668 1
				tm->TM_ZONE = gmt;
d680 2
a681 1
					tm->TM_GMTOFF = -(timezone);
d684 2
a685 1
					tm->TM_ZONE = tzname[i];
@


1.11.2.1
log
@* localtime.cc: Define TM_GMTOFF and TM_ZONE based on __TM_GMTOFF and __TM_ZONE
being defined.  Throughout, write to these struct tm members only if
CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS is true.
* libc/strptime.cc: Ditto.
* include/cygwin/version.h (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS): Define.
(CYGWIN_VERSION_API_MINOR): Bump to 272.
@
text
@a50 7
#ifdef __TM_GMTOFF
# define TM_GMTOFF __TM_GMTOFF
#endif
#ifdef __TM_ZONE
# define TM_ZONE __TM_ZONE
#endif

d656 1
a656 2
				if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
				  tm->TM_GMTOFF = 0;
d659 1
a659 2
				if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
				  tm->TM_ZONE = gmt;
d671 1
a671 2
					if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
					  tm->TM_GMTOFF = -(timezone);
d674 1
a674 2
					if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
					  tm->TM_ZONE = tzname[i];
@


1.10
log
@Clean up whitespace.
@
text
@d766 2
a767 1
strptime (const char *buf, const char *fmt, struct tm *tm)
@


1.9
log
@	Based on newlib patch to strptime by Peter Rosin <peda@@lysator.liu.se>:
	* libc/time/strptime.c (is_leap_year): New static function.
	(first_day): Ditto.
	(__strptime): Fill in tm_yday when all of tm_year, tm_mon and tm_mday
	are updated. Fill in tm_mon, tm_mday and tm_wday when both of tm_year
	and tm_yday are updated.
@
text
@d278 1
a278 1
static int              
d280 1
a280 1
{               
d282 1
a282 1
}       
d284 1
a284 1
static int      
d286 1
a286 1
{       
d288 1
a288 1
      
d291 2
a292 2
  return ret; 
}           
@


1.8
log
@	* libc/strptime.c: Remove misleading comment.
@
text
@d61 10
d278 16
d315 1
d390 1
d396 1
d402 1
d436 1
d451 1
d460 1
d465 1
d504 1
d531 1
d541 1
d572 6
d580 1
d586 1
d622 1
d716 46
@


1.7
log
@	* libc/strptime.cc: Implement support for era, alt_digits and POSIX
	padding and width modifiers.
	(era_info_t): New type.
	(free_era_info): New static function to free era_info_t storage.
	(get_era_info): New static function to create era_info_t storage
	from LC_TIME era information.
	(alt_digits_t): New type.
	(get_alt_digits): New static function to create alt_digits_t storage
	from LC_TIME alt_digits information.
	(free_alt_digits): New static function to free alt_digits_t storage.
	(find_alt_digits): New static function to scan input for alternative
	digits and return them, if any.  Return NULL otherwise.
	(__strptime): New static function taking all code from strptime.
	Implement handling for E, O, +, 0, and width modifiers per POSIX-1.2008.
	(strptime): Convert into wrapper function to provide era_info and
	alt_digits pointers and call __strptime.
	(conv_num): Take additional alt_digits_t parameter and if it's not
	NULL, call find_alt_digits to convert.
@
text
@a56 4
/*
 * We do not implement alternate representations. However, we always
 * check whether a given modifier is allowed for a certain conversion.
 */
@


1.6
log
@	* Makefile.in (DLL_OFILES): Add nlsfunc.o and strfmon.o.
	* autoload.cc (LocaleNameToLCID): Define.
	* cygwin.din (strfmon): Export.
	* nlsfuncs.cc: New file.  Define a lot of internal functions called
	from setlocale.
	(wcscoll): Implement locale-aware here, using CompareStringW function.
	(strcoll): Ditto.
	(wcsxfrm): Implement locale-aware here, usingLCMapStringW function.
	(strxfrm): Ditto.
	(__set_charset_from_locale): Replace __set_charset_from_codepage.
	Return Linux-compatible charset.
	* strfuncs.cc (__set_charset_from_codepage): Remove.
	* wchar.h (__set_charset_from_codepage): Drop definition.
	* wincap.h (wincaps::has_localenames): New element.
	* wincap.cc: Implement above element throughout.
	* libc/strfmon.c: New file.
	* libc/strptime.cc: Remove locale constant strings in favor of
	access to locale-specifc data.
	(strptime): Point _CurrentTimeLocale to locale-specific data.
	Throughout use correct locale-specific format fields for all
	locale-specific formats.
	* include/monetary.h: New file.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d44 1
d67 210
a276 1
static const u_char *conv_num(const unsigned char *, int *, uint, uint);
d280 3
a282 3

char *
strptime(const char *buf, const char *fmt, struct tm *tm)
d287 4
d292 1
d299 2
d330 2
d337 3
d341 19
a359 1

d364 3
a366 1
			new_fmt = _ctloc(c_fmt);
d375 9
a383 3
			new_fmt = "%Y-%m-%d";
			LEGAL_ALT(0);
			goto recurse;
d401 3
a403 1
			new_fmt =_ctloc(X_fmt);
d407 3
a409 1
			new_fmt =_ctloc(x_fmt);
d411 3
a413 3
			bp = (const u_char *)strptime((const char *)bp,
							    new_fmt, tm);
			LEGAL_ALT(ALT_E);
d435 22
d458 3
a460 1
			bp = conv_num(bp, &i, 0, 99);
d467 2
a468 1
			LEGAL_ALT(ALT_E);
a472 1
			bp = conv_num(bp, &tm->tm_mday, 1, 31);
d474 1
a480 1
			bp = conv_num(bp, &tm->tm_hour, 0, 23);
d482 1
d489 2
a490 1
			bp = conv_num(bp, &tm->tm_hour, 1, 12);
a492 1
			LEGAL_ALT(ALT_O);
d497 1
a497 1
			bp = conv_num(bp, &i, 1, 366);
a502 1
			bp = conv_num(bp, &tm->tm_min, 0, 59);
d504 1
d508 1
d510 1
a510 1
			bp = conv_num(bp, &i, 1, 12);
a511 1
			LEGAL_ALT(ALT_O);
a522 1
			bp = conv_num(bp, &tm->tm_sec, 0, 61);
d524 1
a534 1
			 bp = conv_num(bp, &i, 0, 53);
d536 1
a539 1
			bp = conv_num(bp, &tm->tm_wday, 0, 6);
d541 1
d545 25
d571 3
a573 1
			bp = conv_num(bp, &i, 0, 9999);
d575 2
a576 1
			LEGAL_ALT(ALT_E);
d581 13
a593 1
			bp = conv_num(bp, &i, 0, 99);
d595 1
a595 2
			if (split_year)
				/* preserve century */
d605 2
d655 19
d677 12
d691 2
a692 1
conv_num(const unsigned char *buf, int *dest, uint llim, uint ulim)
d697 18
a714 13
	/* The limit also determines the number of valid digits. */
	uint rulim = ulim;

	ch = *buf;
	if (ch < '0' || ch > '9')
		return NULL;

	do {
		result *= 10;
		result += ch - '0';
		rulim /= 10;
		ch = *++buf;
	} while ((result * 10 <= ulim) && rulim && ch >= '0' && ch <= '9');
@


1.5
log
@	* Makefile.in (DLL_OFILES): Remove _def_time.o.
	* libc/_def_time.c: Remove.  Move definitions of _DefaultTimeLocale
	and _CurrentTimeLocale ...
	* libc/strptime.cc: ... here.
@
text
@d48 1
a53 42
#ifdef __CYGWIN__
typedef struct {
	const char *abday[7];
	const char *day[7];
	const char *abmon[12];
	const char *mon[12];
	const char *am_pm[2];
	const char *d_t_fmt;
	const char *d_fmt;
	const char *t_fmt;
	const char *t_fmt_ampm;
} _TimeLocale;

_TimeLocale _DefaultTimeLocale = 
{
	{
		"Sun","Mon","Tue","Wed","Thu","Fri","Sat",
	},
	{
		"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
		"Friday", "Saturday"
	},
	{
		"Jan", "Feb", "Mar", "Apr", "May", "Jun",
		"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
	},
	{
		"January", "February", "March", "April", "May", "June", "July",
		"August", "September", "October", "November", "December"
	},
	{
		"AM", "PM"
	},
	"%a %b %e %H:%M:%S %Y",
	"%m/%d/%y",
	"%H:%M:%S",
	"%I:%M:%S %p"
};

_TimeLocale *_CurrentTimeLocale = &_DefaultTimeLocale;
#endif

d80 1
d124 1
a124 1
			new_fmt = _ctloc(d_t_fmt);
d143 1
a143 1
			new_fmt =_ctloc(t_fmt_ampm);
d153 1
a153 1
			new_fmt =_ctloc(t_fmt);
d157 1
a157 1
			new_fmt =_ctloc(d_fmt);
d169 2
a170 2
			bp = find_string(bp, &tm->tm_wday, _ctloc(day),
					_ctloc(abday), 7);
d177 2
a178 2
			bp = find_string(bp, &tm->tm_mon, _ctloc(mon),
					_ctloc(abmon), 12);
@


1.4
log
@	* include/sys/localedef.h: Remove.
	* libc/strptime.cc: Define _TimeLocale and declare _CurrentTimeLocale
	as well as _DefaultTimeLocale locally for Cygwin.
@
text
@d66 27
a92 2
extern _TimeLocale *_CurrentTimeLocale;
extern _TimeLocale  _DefaultTimeLocale;
@


1.3
log
@	* Makefile.in (DLL_OFILES): Add _def_time.o.  Remove timelocal.o.
	* include/sys/localedef.h: New file from NetBSD.
	* libc/_def_time.c: Ditto.
	* libc/getopt.c: Update to latest OpenBSD version 1.23.
	* libc/strptime.cc: Replace FreeBSD version 1.35 with latest NetBSD
	version 1.28.
	* libc/timelocal.cc: Remove.
	* libc/timelocal.h: Remove.
@
text
@d41 1
a42 1
#include <sys/localedef.h>
d53 17
@


1.2
log
@* strptime.cc (_strptime): Fix gcc warnings.
@
text
@d1 5
a5 3
/*
 * Powerdog Industries kindly requests feedback from anyone modifying
 * this function:
d7 2
a8 19
 * Date: Thu, 05 Jun 1997 23:17:17 -0400  
 * From: Kevin Ruddy <kevin.ruddy@@powerdog.com>
 * To: James FitzGibbon <james@@nexis.net>
 * Subject: Re: Use of your strptime(3) code (fwd)
 * 
 * The reason for the "no mod" clause was so that modifications would
 * come back and we could integrate them and reissue so that a wider 
 * audience could use it (thereby spreading the wealth).  This has   
 * made it possible to get strptime to work on many operating systems.
 * I'm not sure why that's "plain unacceptable" to the FreeBSD team.
 * 
 * Anyway, you can change it to "with or without modification" as
 * you see fit.  Enjoy.                                          
 * 
 * Kevin Ruddy
 * Powerdog Industries, Inc.
 */
/*
 * Copyright (c) 1994 Powerdog Industries.  All rights reserved.
d16 2
a17 9
 *    notice, this list of conditions and the following disclaimer
 *    in the documentation and/or other materials provided with the
 *    distribution.
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgement:
 *      This product includes software developed by Powerdog Industries.
 * 4. The name of Powerdog Industries may not be used to endorse or
 *    promote products derived from this software without specific prior
 *    written permission.
d19 5
a23 5
 * THIS SOFTWARE IS PROVIDED BY POWERDOG INDUSTRIES ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE POWERDOG INDUSTRIES BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
d25 5
a29 5
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d33 4
a39 9
#ifndef lint
#ifndef NOID
static char copyright[] __unused =
"@@(#) Copyright (c) 1994 Powerdog Industries.  All rights reserved.";
static char sccsid[] __unused = "@@(#)strptime.c	0.1 (Powerdog) 94/03/27";
#endif /* !defined NOID */
#endif /* not lint */
__FBSDID("$FreeBSD: /repoman/r/ncvs/src/lib/libc/stdtime/strptime.c,v 1.35 2003/11/17 04:19:15 nectar Exp $");

d42 1
a42 1
#include <time.h>
d44 1
a44 2
#include <errno.h>
#include <stdlib.h>
d46 5
a50 4
#ifndef __CYGWIN__
#include <pthread.h>
#include "un-namespace.h"
#include "libc_private.h"
a51 1
#include "timelocal.h"
d53 15
a67 1
static char * _strptime(const char *, const char *, struct tm *, int *);
a68 1
#define asizeof(a)	((int)(sizeof (a) / sizeof ((a)[0])))
d70 2
a71 2
static char *
_strptime(const char *buf, const char *fmt, struct tm *tm, int *GMTp)
d73 16
a88 20
	char	c;
	const char *ptr;
	int	i,
		len;
	int Ealternative, Oalternative;
	struct lc_time_T *tptr = __get_current_time_locale();

	ptr = fmt;
	while (*ptr != 0) {
		if (*buf == 0)
			break;

		c = *ptr++;

		if (c != '%') {
			if (isspace((unsigned char)c))
				while (*buf != 0 && isspace((unsigned char)*buf))
					buf++;
			else if (c != *buf++)
				return 0;
d92 3
a94 30
		Ealternative = 0;
		Oalternative = 0;
label:
		c = *ptr++;
		switch (c) {
		case 0:
		case '%':
			if (*buf++ != '%')
				return 0;
			break;

		case '+':
			buf = _strptime(buf, tptr->date_fmt, tm, GMTp);
			if (buf == 0)
				return 0;
			break;

		case 'C':
			if (!isdigit((unsigned char)*buf))
				return 0;

			/* XXX This will break for 3-digit centuries. */
			len = 2;
			for (i = 0; len && *buf != 0 && isdigit((unsigned char)*buf); buf++) {
				i *= 10;
				i += *buf - '0';
				len--;
			}
			if (i < 19)
				return 0;
d96 7
a102 2
			tm->tm_year = i * 100 - 1900;
			break;
d104 57
a160 72
		case 'c':
			buf = _strptime(buf, tptr->c_fmt, tm, GMTp);
			if (buf == 0)
				return 0;
			break;

		case 'D':
			buf = _strptime(buf, "%m/%d/%y", tm, GMTp);
			if (buf == 0)
				return 0;
			break;

		case 'E':
			if (Ealternative || Oalternative)
				break;
			Ealternative++;
			goto label;

		case 'O':
			if (Ealternative || Oalternative)
				break;
			Oalternative++;
			goto label;

		case 'F':
			buf = _strptime(buf, "%Y-%m-%d", tm, GMTp);
			if (buf == 0)
				return 0;
			break;

		case 'R':
			buf = _strptime(buf, "%H:%M", tm, GMTp);
			if (buf == 0)
				return 0;
			break;

		case 'r':
			buf = _strptime(buf, tptr->ampm_fmt, tm, GMTp);
			if (buf == 0)
				return 0;
			break;

		case 'T':
			buf = _strptime(buf, "%H:%M:%S", tm, GMTp);
			if (buf == 0)
				return 0;
			break;

		case 'X':
			buf = _strptime(buf, tptr->X_fmt, tm, GMTp);
			if (buf == 0)
				return 0;
			break;

		case 'x':
			buf = _strptime(buf, tptr->x_fmt, tm, GMTp);
			if (buf == 0)
				return 0;
			break;

		case 'j':
			if (!isdigit((unsigned char)*buf))
				return 0;

			len = 3;
			for (i = 0; len && *buf != 0 && isdigit((unsigned char)*buf); buf++) {
				i *= 10;
				i += *buf - '0';
				len--;
			}
			if (i < 1 || i > 366)
				return 0;
d162 9
a170 2
			tm->tm_yday = i - 1;
			break;
d172 7
a178 14
		case 'M':
		case 'S':
			if (*buf == 0 || isspace((unsigned char)*buf))
				break;

			if (!isdigit((unsigned char)*buf))
				return 0;

			len = 2;
			for (i = 0; len && *buf != 0 && isdigit((unsigned char)*buf); buf++) {
				i *= 10;
				i += *buf - '0';
				len--;
			}
d180 11
a190 9
			if (c == 'M') {
				if (i > 59)
					return 0;
				tm->tm_min = i;
			} else {
				if (i > 60)
					return 0;
				tm->tm_sec = i;
			}
d192 5
a196 4
			if (*buf != 0 && isspace((unsigned char)*buf))
				while (*ptr != 0 && !isspace((unsigned char)*ptr))
					ptr++;
			break;
d198 3
d202 7
d210 5
a214 12
		case 'k':
		case 'l':
			/*
			 * Of these, %l is the only specifier explicitly
			 * documented as not being zero-padded.  However,
			 * there is no harm in allowing zero-padding.
			 *
			 * XXX The %l specifier may gobble one too many
			 * digits if used incorrectly.
			 */
			if (!isdigit((unsigned char)*buf))
				return 0;
d216 6
a221 18
			len = 2;
			for (i = 0; len && *buf != 0 && isdigit((unsigned char)*buf); buf++) {
				i *= 10;
				i += *buf - '0';
				len--;
			}
			if (c == 'H' || c == 'k') {
				if (i > 23)
					return 0;
			} else if (i > 12)
				return 0;

			tm->tm_hour = i;

			if (*buf != 0 && isspace((unsigned char)*buf))
				while (*ptr != 0 && !isspace((unsigned char)*ptr))
					ptr++;
			break;
d223 4
a226 14
		case 'p':
			/*
			 * XXX This is bogus if parsed before hour-related
			 * specifiers.
			 */
			len = strlen(tptr->am);
			if (strncasecmp(buf, tptr->am, len) == 0) {
				if (tm->tm_hour > 12)
					return 0;
				if (tm->tm_hour == 12)
					tm->tm_hour = 0;
				buf += len;
				break;
			}
d228 6
a233 9
			len = strlen(tptr->pm);
			if (strncasecmp(buf, tptr->pm, len) == 0) {
				if (tm->tm_hour > 12)
					return 0;
				if (tm->tm_hour != 12)
					tm->tm_hour += 12;
				buf += len;
				break;
			}
d235 7
a241 1
			return 0;
d243 4
a246 19
		case 'A':
		case 'a':
			len = 0;
			for (i = 0; i < asizeof(tptr->weekday); i++) {
				len = strlen(tptr->weekday[i]);
				if (strncasecmp(buf, tptr->weekday[i],
						len) == 0)
					break;
				len = strlen(tptr->wday[i]);
				if (strncasecmp(buf, tptr->wday[i],
						len) == 0)
					break;
			}
			if (i == asizeof(tptr->weekday))
				return 0;

			tm->tm_wday = i;
			buf += len;
			break;
d248 2
a249 2
		case 'U':
		case 'W':
d256 15
a270 2
			if (!isdigit((unsigned char)*buf))
				return 0;
d272 13
a284 5
			len = 2;
			for (i = 0; len && *buf != 0 && isdigit((unsigned char)*buf); buf++) {
				i *= 10;
				i += *buf - '0';
				len--;
d286 2
a287 2
			if (i > 53)
				return 0;
d289 13
a301 19
			if (*buf != 0 && isspace((unsigned char)*buf))
				while (*ptr != 0 && !isspace((unsigned char)*ptr))
					ptr++;
			break;

		case 'w':
			if (!isdigit((unsigned char)*buf))
				return 0;

			i = *buf - '0';
			if (i > 6)
				return 0;

			tm->tm_wday = i;

			if (*buf != 0 && isspace((unsigned char)*buf))
				while (*ptr != 0 && !isspace((unsigned char)*ptr))
					ptr++;
			break;
d303 13
a315 18
		case 'd':
		case 'e':
			/*
			 * The %e specifier is explicitly documented as not
			 * being zero-padded but there is no harm in allowing
			 * such padding.
			 *
			 * XXX The %e specifier may gobble one too many
			 * digits if used incorrectly.
			 */
			if (!isdigit((unsigned char)*buf))
				return 0;

			len = 2;
			for (i = 0; len && *buf != 0 && isdigit((unsigned char)*buf); buf++) {
				i *= 10;
				i += *buf - '0';
				len--;
d317 1
a317 2
			if (i > 31)
				return 0;
d319 9
a327 1
			tm->tm_mday = i;
a328 4
			if (*buf != 0 && isspace((unsigned char)*buf))
				while (*ptr != 0 && !isspace((unsigned char)*ptr))
					ptr++;
			break;
d330 4
a333 26
		case 'B':
		case 'b':
		case 'h':
			len = 0;
			for (i = 0; i < asizeof(tptr->month); i++) {
				if (Oalternative) {
					if (c == 'B') {
						len = strlen(tptr->alt_month[i]);
						if (strncasecmp(buf,
								tptr->alt_month[i],
								len) == 0)
							break;
					}
				} else {
					len = strlen(tptr->month[i]);
					if (strncasecmp(buf, tptr->month[i],
							len) == 0)
						break;
					len = strlen(tptr->mon[i]);
					if (strncasecmp(buf, tptr->mon[i],
							len) == 0)
						break;
				}
			}
			if (i == asizeof(tptr->month))
				return 0;
d335 2
a336 16
			tm->tm_mon = i;
			buf += len;
			break;

		case 'm':
			if (!isdigit((unsigned char)*buf))
				return 0;

			len = 2;
			for (i = 0; len && *buf != 0 && isdigit((unsigned char)*buf); buf++) {
				i *= 10;
				i += *buf - '0';
				len--;
			}
			if (i < 1 || i > 12)
				return 0;
a337 1
			tm->tm_mon = i - 1;
d339 5
a343 25
			if (*buf != 0 && isspace((unsigned char)*buf))
				while (*ptr != 0 && !isspace((unsigned char)*ptr))
					ptr++;
			break;

		case 's':
			{
			char *cp;
			int sverrno;
			long n;
			time_t t;

			sverrno = errno;
			errno = 0;
			n = strtol(buf, &cp, 10);
			if (errno == ERANGE || (long)(t = n) != n) {
				errno = sverrno;
				return 0;
			}
			errno = sverrno;
			buf = cp;
			gmtime_r(&t, tm);
			*GMTp = 1;
			}
			break;
d345 2
a346 20
		case 'Y':
		case 'y':
			if (*buf == 0 || isspace((unsigned char)*buf))
				break;

			if (!isdigit((unsigned char)*buf))
				return 0;

			len = (c == 'Y') ? 4 : 2;
			for (i = 0; len && *buf != 0 && isdigit((unsigned char)*buf); buf++) {
				i *= 10;
				i += *buf - '0';
				len--;
			}
			if (c == 'Y')
				i -= 1900;
			if (c == 'y' && i < 69)
				i += 100;
			if (i < 0)
				return 0;
d348 10
a357 1
			tm->tm_year = i;
d359 2
a360 4
			if (*buf != 0 && isspace((unsigned char)*buf))
				while (*ptr != 0 && !isspace((unsigned char)*ptr))
					ptr++;
			break;
d362 2
a363 27
		case 'Z':
			{
			const char *cp;
			char *zonestr;

			for (cp = buf; *cp && isupper((unsigned char)*cp); ++cp) {/*empty*/}
			if (cp - buf) {
				zonestr = (char *) alloca(cp - buf + 1);
				strncpy(zonestr, buf, cp - buf);
				zonestr[cp - buf] = '\0';
				tzset();
				if (0 == strcmp(zonestr, "GMT")) {
				    *GMTp = 1;
				} else if (0 == strcmp(zonestr, tzname[0])) {
				    tm->tm_isdst = 0;
				} else if (0 == strcmp(zonestr, tzname[1])) {
				    tm->tm_isdst = 1;
				} else {
				    return 0;
				}
				buf += cp - buf;
			}
			}
			break;
		}
	}
	return (char *)buf;
d366 3
a368 3
extern "C" char *
strptime(const char * __restrict buf, const char * __restrict fmt,
    struct tm * __restrict tm)
d370 2
a371 2
	char *ret;
	int gmt;
d373 9
a381 5
	gmt = 0;
	ret = _strptime(buf, fmt, tm, &gmt);
	if (ret && gmt) {
		time_t t = timegm(tm);
		localtime_r(&t, tm);
d384 2
a385 1
	return (ret);
@


1.1
log
@	* libc: Add subdirectory.
	* Makefile.in (VPATH): Add libc subdir.
	(DLL_OFILES): Add strptime.o and timelocal.o.
	* cygwin.din: Export timelocal and timegm.
	* localtime.cc: Define STD_INSPIRED unconditionally.
	* include/cygwin/time.h (timelocal): Add declaration.
	(timegm): Ditto.
	* include/cygwin/version.h: Bump API minor version.
	* libc/strptime.cc: New file.
	* libc/timelocal.cc: New file.
	* libc/timelocal.h: New file.
@
text
@d314 1
d404 1
@

