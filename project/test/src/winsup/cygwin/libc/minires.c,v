head	1.15;
access;
symbols
	cygwin-1_7_35-release:1.15
	cygwin-1_7_34-release:1.15
	cygwin-1_7_33-release:1.13.2.2
	cygwin-1_7_32-release:1.13.2.2
	cygwin-1_7_31-release:1.13.2.2
	cygwin-1_7_30-release:1.13
	cygwin-1_7_29-release:1.13
	cygwin-1_7_29-release-branchpoint:1.13.0.2
	cygwin-pre-user-db:1.13
	cygwin-1_7_28-release:1.13
	cygwin-1_7_27-release:1.13
	cygwin-1_7_26-release:1.13
	cygwin-1_7_25-release:1.13
	cygwin-1_7_24-release:1.13
	cygwin-1_7_23-release:1.13
	cygwin-1_7_22-release:1.13
	cygwin-1_7_21-release:1.13
	cygwin-1_7_20-release:1.13
	cygwin-1_7_19-release:1.13
	cygwin-64bit-postmerge:1.13
	cygwin-64bit-premerge-branch:1.12.0.2
	cygwin-64bit-premerge:1.12
	cygwin-1_7_18-release:1.12
	post-ptmalloc3:1.11.2.1
	pre-ptmalloc3:1.11.2.1
	cygwin-1_7_17-release:1.11
	cygwin-64bit-branch:1.11.0.2
	cygwin-1_7_16-release:1.11
	cygwin-1_7_15-release:1.11
	cygwin-1_7_14_2-release:1.11
	cygwin-1_7_14-release:1.11
	cygwin-1_7_12-release:1.11
	cygwin-1_7_11-release:1.11
	cygwin-1_7_10-release:1.11
	signal-rewrite:1.10.0.4
	pre-notty:1.10
	cygwin-1_7_9-release:1.10
	cv-post-1_7_9:1.10.0.2
	cygwin-1_7_8-release:1.10
	cygwin-1_7_7-release:1.8
	cygwin-1_7_5-release:1.8
	cygwin-1_7_4-release:1.8
	cygwin-1_7_3-release:1.8
	cygwin-1_7_2-release:1.8
	fifo_doover3:1.8.0.4
	cygwin-1_7_1-release:1.8
	prefifo:1.8
	cv-branch-2:1.8.0.2
	pre-ripout-set_console_state_for_spawn:1.4
	EOL_registry_mounts:1.4
	preoverlapped:1.2
	drop_9x_support_start:1.2;
locks; strict;
comment	@ * @;


1.15
date	2014.07.07.08.40.31;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2014.05.22.09.45.17;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.23.09.44.35;	author corinna;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2013.01.21.04.38.31;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2011.12.17.23.39.47;	author cgf;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2010.09.24.19.53.18;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.21.21.41.31;	author phumblet;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.06.12.03.32;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.04.04.30.36;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.06.16.31.26;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.03.16.37.53;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.01.10.22.33;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.15.17.53.11;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.12.08.29.37;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.11.19.59.06;	author corinna;	state Exp;
branches;
next	;

1.13.2.1
date	2014.07.15.14.34.39;	author corinna;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2014.07.16.09.54.57;	author corinna;	state Exp;
branches;
next	;

1.11.2.1
date	2013.01.21.13.52.14;	author corinna;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2013.04.08.11.19.07;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.15
log
@	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.
@
text
@/* minires.c.  Stub synchronous resolver for Cygwin.

   Copyright 2006, 2008, 2009, 2010, 2011 Red Hat, Inc.

   Written by Pierre A. Humblet <Pierre.Humblet@@ieee.org>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "minires.h"

/***********************************************************************

Utilities

***********************************************************************/
/***********************************************************************

dprintf
***********************************************************************/
void minires_dprintf(const char * format, ...)
{
  va_list args;

  va_start(args, format);
  fprintf(stderr, "Resolv: ");
  vfprintf(stderr, format, args);
  va_end(args);
}

/***********************************************************************

scanline
Put pointers in list[] to the beginning of each space or comma delimited
word in "in", and put the lengths in sizes[] (counting the final 0).
Return the number of words found
***********************************************************************/
static int scanline(char * in, char **list, int * sizes, int maxnum)
{
  int i;
  char * startp;
  for (i = 0; i < maxnum; i++) {
    while((*in) && (isspace((unsigned char)*in) || *in == ',')) in++;
    if (*in == 0)
      break;
    startp = in++;
    while((*in) && !isspace((unsigned char)*in) && *in != ',') in++;
    list[i] = startp;
    sizes[i] = in - startp + 1;
    if (*in)
      *in++ = 0;
  }
  return i;
}

/***********************************************************************

Read the search string.

***********************************************************************/
void minires_get_search(char * string, res_state statp)
{
  char * words[MAXDNSRCH+1], * ptr;
  int sizes[MAXDNSRCH+1];
  int i, j, debug = statp->options & RES_DEBUG;

  i = scanline(string, words, sizes, MAXDNSRCH+1);
  ptr = statp->defdname;
  for (j = 0; j < i; j++) {
    if (j < MAXDNSRCH
	&& ptr + sizes[j] < &statp->defdname[DIM(statp->defdname)]) {
      statp->dnsrch[j] = strcpy(ptr, words[j]);
      statp->dnsrch[j+1] = NULL;
      ptr += sizes[j];
      DPRINTF(debug, "search \"%s\"\n", words[j]);
    }
    else if (j < MAXDNSRCH + 1)
      DPRINTF(debug, "no space for \"%s\"\n", words[j]);
  }
}

/***********************************************************************

Read options


***********************************************************************/
static void get_options(res_state statp, int i, char **words)
{
  char *ptr;
  int value;

  while (i-- > 0) {
    if (!strcasecmp("debug", words[i])) {
      statp->options |= RES_DEBUG;
      DPRINTF(statp->options & RES_DEBUG, "%s: 1\n", words[i]);
      continue;
    }
    if (!strcasecmp("inet6", words[i])) {
      statp->options |= RES_USE_INET6;
      DPRINTF(statp->options & RES_DEBUG, "%s: 1\n", words[i]);
      continue;
    }
    if (!strcasecmp("osquery", words[i])) {
      statp->use_os = 1;
      DPRINTF(statp->options & RES_DEBUG, "%s: 1\n", words[i]);
      continue;
    }

    if ((ptr = strchr(words[i], ':'))) {
      *ptr++ = 0;
      value = atoi(ptr);
      /* Not supported
	 if (!strcasecmp("ndots", words[i])) {
	 statp->ndots = value;
	 continue;
	 }
      */
      if (!strcasecmp("retry", words[i])
	  || !strcasecmp("attempts", words[i])) {
	if (value < 1)
	  value = 1;
	else if (value > RES_MAXRETRY)
	  value = RES_MAXRETRY;
	statp->retry = value;
	DPRINTF(statp->options & RES_DEBUG, "%s: %d\n", words[i], value);
	continue;
      }
      if (!strcasecmp("retrans", words[i])
	  || !strcasecmp("timeout", words[i])) {
	if (value < 1)
	  value = 1;
	else if (value > RES_MAXRETRANS)
	  value = RES_MAXRETRANS;
	statp->retrans = value;
	DPRINTF(statp->options & RES_DEBUG, "%s: %d\n", words[i], value);
	continue;
      }
    }
    DPRINTF(statp->options & RES_DEBUG, "unknown option: \"%s\"\n", words[i]);
  }
}

/***********************************************************************

Read the resolv.conf file.
We only look for nameserver, domain, search and options

***********************************************************************/
#if MAXNS > MAXDNSRCH + 1
#define MAXSIZE MAXNS
#else
#define MAXSIZE MAXDNSRCH + 1 /* Make unused one visible */
#endif
static void get_resolv(res_state statp)
{
  FILE * fd;
  char *words[MAXSIZE + 1], line[4096], *ptr;
  int sizes[DIM(words)];
  int i, j, ns = 0, have_search, have_address, debug = statp->options & RES_DEBUG;

  fd = fopen(_PATH_RESCONF, "r");
  DPRINTF(debug, _PATH_RESCONF ": %s\n", fd?"OK":strerror(errno));
  if (fd == NULL)
    return;

  statp->use_os = 0; /* Do not use os_query, except if allowed by "options" */
  have_search = (statp->dnsrch[0] != NULL);
  have_address = (statp->nscount != 0);

  while ( fgets(line, sizeof(line), fd) != 0) {
    DPRINTF(debug, "resolv.conf %s", line);
    if ((i = scanline(line, words, sizes, DIM(words))) > 0) {
      if (!have_address
	  && !strncasecmp("nameserver", words[0], sizes[0])) {
	for ( j = 1; j < i ; j++) {
	  in_addr_t address;
	  address = cygwin_inet_addr(words[j]);
	  if (address == INADDR_NONE) {
	    DPRINTF(debug, "invalid server \"%s\"\n", words[j]);
	  }
	  else if (ns >= MAXNS) {
	    DPRINTF(debug, "no space for server \"%s\"\n", words[j]);
	  }
	  else {
	    statp->nsaddr_list[ns++].sin_addr.s_addr = address;
	    statp->nscount++;
	    DPRINTF(debug, "server \"%s\"\n", words[j]);
	  }
	}
      }
      else if (!have_search
	       && (!strncasecmp("search", words[0], sizes[0])
		   || !strncasecmp("domain", words[0], sizes[0]))) {
	ptr = statp->defdname;
	for (j = 0; j + 1 < i; j++) {
	  if (j < MAXDNSRCH
	      && ptr + sizes[j + 1] < &statp->defdname[DIM(statp->defdname)]) {
	    statp->dnsrch[j] = strcpy(ptr, words[j+1]);
	    statp->dnsrch[j+1] = 0;
	    ptr += sizes[j+1];
	    DPRINTF(debug, "domain|search \"%s\"\n", statp->dnsrch[j]);
	  }
	  else {
	    DPRINTF(debug, "no space for \"%s\"\n", words[j+1]);
	  }
	}
      }
      /* Options line */
      else if (!strncasecmp("options", words[0], sizes[0]))
	get_options(statp, i - 1, &words[1]);
    }
  }
  fclose(fd);
  return;
}

/****************************************************************************/
/*
   open_sock()
   Create a datagram socket and call bind.

****************************************************************************/

static int open_sock(struct sockaddr_in *CliAddr, int debug)
{
  int fd;

  DPRINTF(debug, "opening UDP socket\n");

  /* Create a datagram socket */
  if ((fd = cygwin_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
    DPRINTF(debug, "socket(UDP): %s\n", strerror(errno));
    return -1;
  }
  /* Set non-blocking */
  if (fcntl64(fd, F_SETFL, O_NONBLOCK) < 0)  {
    DPRINTF(debug, "fcntl: %s\n", strerror(errno));
    return -1;
  }
  /* Set close on exec flag */
  if (fcntl64(fd, F_SETFD, 1) == -1) {
    DPRINTF(debug, "fcntl: %s\n", strerror(errno));
    return -1;
  }

  CliAddr->sin_family = AF_INET;
  CliAddr->sin_addr.s_addr = htonl(INADDR_ANY);
  CliAddr->sin_port = htons(0);
  bzero(CliAddr->sin_zero, sizeof(CliAddr->sin_zero));
  /* Get a port */
  if (cygwin_bind(fd, (struct sockaddr *) CliAddr, sizeof(*CliAddr)) < 0) {
    DPRINTF(debug, "bind: %s\n", strerror(errno));
    return -1;
  }
  return fd;
}

/*****************************************************************
 *
 __res_state()
 Undocumented but public. Accessed through _res

 *****************************************************************/
static struct __res_state res;
struct __res_state *__res_state(void)
{
  return & res;
}

/*****************************************************************
 *
 res_init()

 *****************************************************************/
int res_ninit(res_state statp)
{
  int i;

  statp->res_h_errno = NETDB_SUCCESS;
   /* Only debug may be set before calling init */
  statp->options &= RES_DEBUG;
  statp->options |= RES_INIT | RES_DEFAULT;
  statp->nscount = 0;
  statp->os_query = NULL;
  statp->retrans = RES_TIMEOUT; /* timeout in seconds */
  statp->retry = RES_MAXRETRY;  /* max number of retries */
  statp->use_os = 1;            /* use os_query if available and allowed by get_resolv */
  statp->mypid = -1;
  statp->sockfd = -1;
  /* Use the pid and the ppid for random seed, from the point of view of an outsider.
     Mix the upper and lower bits as they are not used equally */
  i = getpid();
  statp->id = (ushort) (getppid() ^ (i << 8) ^ (i >> 8));
  for (i = 0; i < (int) DIM(statp->dnsrch); i++)  statp->dnsrch[i] = 0;

  /* resolv.conf (dns servers & search list)*/
  get_resolv(statp);
  /* Get dns servers and search list from an os-specific routine, set os_query */
  get_dns_info(statp);

  if (statp->nscount == 0 && !statp->os_query) {
    errno = ENONET;
    statp->res_h_errno = NETDB_INTERNAL;
    DPRINTF(statp->options & RES_DEBUG, "no dns server found\n");
    return -1;
  }
  for (i = 0; i < statp->nscount; i++) {
    statp->nsaddr_list[i].sin_family = AF_INET;
    statp->nsaddr_list[i].sin_port = htons(NAMESERVER_PORT);
    bzero(statp->nsaddr_list[i].sin_zero, sizeof(statp->nsaddr_list[i].sin_zero));
  }
  return 0;
}

int res_init()
{
  int r = res_ninit(& res);
  h_errno = res.res_h_errno;
  return r;
}

/*****************************************************************
 *
 res_close()

 *****************************************************************/
void res_nclose(res_state statp)
{
  int res;
  if (statp->sockfd != -1) {
    res = close(statp->sockfd);
    DPRINTF(statp->options & RES_DEBUG, "close sockfd %d: %s\n",
	    statp->sockfd, (res == 0)?"OK":strerror(errno));
    statp->sockfd = -1;
  }
}

void res_close()
{
  res_nclose(& res);
}

/*****************************************************************
 *
 get_tcp_buf()

 *****************************************************************/
static int get_tcp_buf(int fd, unsigned char *buf, int size, int debug)
{
  int res;
  while (size > 0) {
    if ((res = read(fd, buf, size)) < 0) {
      DPRINTF(debug, "read: %s\n", strerror(errno));
      return -1;
    }
    DPRINTF(debug, "read %d out of %d\n", res, size);
    size -= res;
    buf += res;
  }
  return 0;
}

/*****************************************************************
 *
 get_tcp()

 *****************************************************************/
static int get_tcp(struct sockaddr_in *CliAddr,
		   const unsigned char * MsgPtr, int MsgLength,
		   unsigned char * AnsPtr, int AnsLength, int debug)
{
  int fd, res = -1;
  unsigned short ans_length;
  union {short len; u_char buf[sizeof(short)];} len_buf;

  DPRINTF(debug, "retrying with TCP\n");

  /* Create a tcp socket */
  if ((fd = cygwin_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
    DPRINTF(debug, "socket(TCP): %s\n", strerror(errno));
    return -1;
  }

  if (cygwin_connect(fd, (struct sockaddr *)  CliAddr, sizeof(* CliAddr)) < 0) {
    DPRINTF(debug, "connect: %s\n", strerror(errno));
    goto done;
  }

  /* Send the length then the message */
  len_buf.len = htons(MsgLength);
  if (write(fd, len_buf.buf, sizeof(len_buf)) != sizeof(len_buf)
      || write(fd, MsgPtr, MsgLength) != MsgLength) {
    DPRINTF(debug, "write: %s\n", strerror(errno));
    goto done;
  }

  /* Read the answer length */
  if (get_tcp_buf(fd, len_buf.buf, sizeof(len_buf), debug))
    goto done;
  ans_length = ntohs(len_buf.len);

  /* Read the answer */
  if (get_tcp_buf(fd, AnsPtr, MIN(ans_length, AnsLength), debug))
    goto done;
  res = ans_length;

 done:
  close (fd);
  return res;
}

/*****************************************************************
 **
 res_send
 Assumes that the message is a query starting with a short id.
 Handles retransmissions until that id is received.

*****************************************************************/
int res_nsend( res_state statp, const unsigned char * MsgPtr,
	       int MsgLength, unsigned char * AnsPtr, int AnsLength)
{
  /* Current server, shared by all tasks */
  static volatile unsigned int SServ = 0XFFFFFFFF;
  int tcp;
  const int debug = statp->options & RES_DEBUG;

  fd_set fdset_read;
  int rslt, addrLen, transNum, wServ;
  struct sockaddr_in mySockAddr, dnsSockAddr;
  struct timeval timeOut;

  statp->res_h_errno = NETDB_SUCCESS;
  if (((statp->options & RES_INIT) == 0) && (res_ninit(statp) != 0))
    return -1;

  /* If a hook exists to a native implementation, use it */
  if (statp->os_query) {
    int len;
    short int Class, Type;
    char DomName[MAXDNAME];
    unsigned char * ptr = (unsigned char *) MsgPtr + HFIXEDSZ;
    len = dn_expand(MsgPtr, MsgPtr + MsgLength, ptr, DomName, sizeof(DomName));
    if (len > 0) {
      ptr += len;
      GETSHORT(Type, ptr);
      GETSHORT(Class, ptr);
      return ((os_query_t *) statp->os_query)(statp, DomName, Class, Type, AnsPtr, AnsLength);
    }
    else {
      /* dn_expand sets errno */
      statp->res_h_errno = NETDB_INTERNAL;
      return -1;
    }
  }

  /* Close the socket if it had been opened before a fork.
     Reuse of pid's cannot hurt */
  if ((statp->sockfd != -1) && ((pid_t) statp->mypid != getpid())) {
    res_nclose(statp);
  }

  /* Open a socket for this process */
  if (statp->sockfd == -1) {
    /* Create a non-blocking, close on exec socket and bind it (to any port) */
    statp->sockfd = open_sock(& mySockAddr, debug);
    if (statp->sockfd  < 0 ) {
      statp->res_h_errno = NETDB_INTERNAL;
      return -1;
    }
    statp->mypid = getpid();
    if (SServ == 0XFFFFFFFF) /* Pseudo random */
      SServ =  statp->id % statp->nscount;
  }

  transNum = 0;
  while ( transNum++ < statp->retry) {
    if ((wServ = SServ + 1) >= statp->nscount)
      wServ = 0;
    SServ = wServ;

    /* There exists attacks on DNS where many wrong answers with guessed id's and
       spoofed source address and port are generated at about the time when the
       program is tricked into resolving a name.
       This routine runs through the retry loop for each incorrect answer.
       It is thus extremely likely that such attacks will cause a TRY_AGAIN return,
       probably causing the calling program to retry after a delay.

       Note that valid late or duplicate answers to a previous questions also cause
       a retry, although this is minimized by flushing the socket before sending the
       new question.
    */

    /* Flush duplicate or late answers */
    while ((rslt = cygwin_recvfrom( statp->sockfd, AnsPtr, AnsLength, 0, NULL, NULL)) >= 0) {
      DPRINTF(debug, "Flushed %d bytes\n", rslt);
    }
    DPRINTF(debug && (errno != EWOULDBLOCK),
	    "Unexpected errno for flushing recvfrom: %s", strerror(errno));

    /* Send the message */
    rslt = cygwin_sendto(statp->sockfd, MsgPtr, MsgLength, 0,
			 (struct sockaddr *) &statp->nsaddr_list[wServ],
			 sizeof(struct sockaddr_in));
    DPRINTF(debug, "sendto: server %08x sockfd %d %s\n",
	    statp->nsaddr_list[wServ].sin_addr.s_addr,
	    statp->sockfd, (rslt == MsgLength)?"OK":strerror(errno));
    if (rslt != MsgLength) {
      statp->res_h_errno = NETDB_INTERNAL;
      return -1;
    };
    /*
      Wait for a reply with select()
    */
    FD_ZERO(&fdset_read);
    FD_SET (statp->sockfd, &fdset_read );
    timeOut.tv_sec = statp->retrans;
    timeOut.tv_usec = 0;
    rslt = cygwin_select(statp->sockfd + 1, &fdset_read, NULL, NULL, &timeOut);
    if ( rslt == 0 ) { /* Timeout */
      DPRINTF(statp->options & RES_DEBUG, "timeout for server %08x\n",
	      statp->nsaddr_list[wServ].sin_addr.s_addr);
      continue;
    }
    else if ((rslt != 1) || (FD_ISSET(statp->sockfd, &fdset_read) == 0)) {
      DPRINTF(debug, "select: %s\n", strerror(errno));
      statp->res_h_errno = NETDB_INTERNAL;
      return -1;
    }

    addrLen = sizeof(dnsSockAddr);
    rslt = cygwin_recvfrom(statp->sockfd, AnsPtr, AnsLength, 0,
			   (struct sockaddr *) & dnsSockAddr, & addrLen);
    if (rslt <= 0) {
      DPRINTF(debug, "recvfrom: %s\n", strerror(errno));
      statp->res_h_errno = NETDB_INTERNAL;
      return -1;
    }
    DPRINTF(debug, "recvfrom: %d bytes from %08x\n", rslt, dnsSockAddr.sin_addr.s_addr);
    /*
       Prepare to retry with tcp
    */
    for (tcp = 0; tcp < 2; tcp++) {
      /* Check if this is the expected message from the expected server */
      if ((memcmp(& dnsSockAddr, & statp->nsaddr_list[wServ],
		  (char *) & dnsSockAddr.sin_zero[0] - (char *) & dnsSockAddr) == 0)
	  && (rslt >= HFIXEDSZ)
	  && (*MsgPtr == *AnsPtr)     /* Ids match */
	  && (*(MsgPtr + 1) == *(AnsPtr + 1))
	  && ((AnsPtr[2] & QR) != 0)
	  && (AnsPtr[4] == 0)
	  /* We check the question if present.
	     Some servers don't return it on error, in particular
	     when the name in the question is not valid. */
	  && (((AnsPtr[5] == 0)
	       && ((AnsPtr[3] & ERR_MASK) != NOERROR))
	      || ((AnsPtr[5] == 1)
		  && (rslt >= MsgLength)
		  && (memcmp(MsgPtr + HFIXEDSZ, AnsPtr + HFIXEDSZ, MsgLength - HFIXEDSZ) == 0)))) {
	if ((AnsPtr[3] & ERR_MASK) == NOERROR) {
	  if ((AnsPtr[2] & TC) && (tcp == 0) && !(statp->options & RES_IGNTC)) {
	    /* Truncated. Try TCP */
	    rslt = get_tcp(&statp->nsaddr_list[wServ], MsgPtr, MsgLength,
			   AnsPtr, AnsLength, statp->options & RES_DEBUG);
	    continue /* Tcp loop */;
	  }
	  else if ((AnsPtr[6] | AnsPtr[7])!= 0)
	    return rslt;
	  else
	    statp->res_h_errno = NO_DATA;
	}
#if 0
 NETDB_INTERNAL -1 /* see errno */
 NETDB_SUCCESS   0 /* no problem */
 HOST_NOT_FOUND  1 /* Authoritative Answer Host not found */
 TRY_AGAIN       2 /* Non-Authoritive Host not found, or SERVERFAIL */
			 Also seen returned by some servers when the name is too long
 NO_RECOVERY     3 /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
 NO_DATA         4 /* Valid name, no data record of requested type */
#endif
	else {
	  switch (AnsPtr[3] & ERR_MASK) {
	  /* return HOST_NOT_FOUND even for non-authoritative answers */
	  case NXDOMAIN:
	  case FORMERR:
	    statp->res_h_errno = HOST_NOT_FOUND;
	    break;
	  case SERVFAIL:
	    statp->res_h_errno = TRY_AGAIN;
	    break;
	  default:
	    statp->res_h_errno = NO_RECOVERY;
	  }
	}
	return -1;
      }
      else {
	DPRINTF(debug, "unexpected answer\n");
	break;
      }
    } /* TCP */
  }
  DPRINTF(debug, "too many retries\n");
  statp->res_h_errno = TRY_AGAIN;
  return -1;
}

int res_send( const unsigned char * MsgPtr, int MsgLength,
	      unsigned char * AnsPtr, int AnsLength)
{
  int r = res_nsend(& res, MsgPtr, MsgLength, AnsPtr, AnsLength);
  h_errno = res.res_h_errno;
  return r;
}

/*****************************************************************
 *
 res_mkquery

 Return: packet size
	-1 name format is incorrect
*****************************************************************/
int res_nmkquery (res_state statp,
		  int op, const char * dnameptr, int qclass, int qtype,
		  const unsigned char * dataptr __attribute__ ((unused)),
		  int datalen __attribute__ ((unused)),
		  const unsigned char * newrr __attribute__ ((unused)),
		  unsigned char * buf, int buflen)
{
  int i, len;
  const char * ptr;
  unsigned int id4;

  if (op == QUERY) {
    /* Write the name and verify buffer length */
    len = dn_comp(dnameptr, buf + HFIXEDSZ, buflen - HFIXEDSZ - QFIXEDSZ, NULL, NULL);
    if (len < 0) {
      DPRINTF(statp->options & RES_DEBUG,
	      "\"%s\" invalid or buffer too short\n", dnameptr);
      statp->res_h_errno = NETDB_INTERNAL;
      return -1;
    }

    /* Fill the header */
    PUTSHORT(statp->id, buf);
    PUTSHORT(RD, buf);
    PUTSHORT(1, buf); /* Number of questions */
    for (i = 0; i < 3; i++)
      PUTSHORT(0, buf); /* Number of answers */

    /* Write qtype and qclass */
    buf += len;
    PUTSHORT(qtype, buf);
    PUTSHORT(qclass, buf);

    /* Update id. The current query adds entropy to the next query id */
    for (id4 = qtype, i = 0, ptr = dnameptr; *ptr; ptr++, i += 3)
      id4 ^= *ptr << (i & 0xF);
    i = 1 + statp->id % 15; /* Between 1 and 16 */
    /* id dependent rotation, also brings MSW to LSW */
    id4 = (id4 << i) ^ (id4 >> (16 - i)) ^ (id4 >> (32 - i));
    if ((short) id4)
      statp->id ^= (short) id4;
    else
      statp->id++; /* Force change */

    return len + (HFIXEDSZ + QFIXEDSZ); /* packet size */
  }
  else { /* Not implemented */
    errno = ENOSYS;
    statp->res_h_errno = NETDB_INTERNAL;
    return -1;
  }
}

int res_mkquery (int op, const char * dnameptr, int qclass, int qtype,
		 const unsigned char * dataptr, int datalen,
		 const unsigned char * newrr, unsigned char * buf, int buflen)
{
  int r = res_nmkquery (& res, op, dnameptr, qclass, qtype,
			dataptr, datalen, newrr, buf, buflen);
  h_errno = res.res_h_errno;
  return r;

}

/*****************************************************************
 * res_query()
 *****************************************************************/

int res_nquery( res_state statp, const char * DomName, int Class, int Type,
		unsigned char * AnsPtr, int AnsLength)
{
  u_char packet[PACKETSZ];
  int len;

  DPRINTF(statp->options & RES_DEBUG, "query \"%s\" type %d\n", DomName, Type);
  statp->res_h_errno = NETDB_SUCCESS;

  /* If a hook exists to a native implementation, use it */
  if (statp->os_query)
    return ((os_query_t *) statp->os_query)(statp, DomName, Class, Type, AnsPtr, AnsLength);

  if ((len = res_nmkquery (statp, QUERY, DomName, Class, Type,
			   0, 0, 0, packet, PACKETSZ)) < 0)
    return -1;
  return res_nsend( statp, packet, len, AnsPtr, AnsLength);
}

int res_query( const char * DomName, int Class, int Type, unsigned char * AnsPtr, int AnsLength)
{
  int r = res_nquery(& res, DomName, Class, Type, AnsPtr, AnsLength);
  h_errno = res.res_h_errno;
  return r;
}

/*****************************************************************
 * res_querydomain()
 *****************************************************************/
int res_nquerydomain( res_state statp, const char * Name, const char * DomName,
		      int Class, int Type, unsigned char * AnsPtr, int AnsLength)
{
  char fqdn[MAXDNAME], *ptr;
  size_t nlen;

  DPRINTF(statp->options & RES_DEBUG, "querydomain \"%s\"  \"%s\" type %d\n",
	  Name, DomName, Type);

  if (!DomName)
    ptr = (char *) Name;
  else if ((nlen = strlen(Name)) >= sizeof(fqdn) - 1)
    goto error;
  else {
    strcpy(fqdn, Name);
    ptr = &fqdn[nlen];
    if (nlen && *(ptr - 1) != '.')
      *ptr++ = '.';
    fqdn[sizeof(fqdn) - 1] = 0;
    strncpy(ptr, DomName, sizeof(fqdn) - (ptr - fqdn));
    if (fqdn[sizeof(fqdn) - 1])
      goto error;
    ptr = fqdn;
  }
  return res_nquery(statp, ptr, Class, Type, AnsPtr, AnsLength);

 error:
  DPRINTF(statp->options & RES_DEBUG, "querydomain: name too long\n");
  errno = EINVAL;
  statp->res_h_errno = NETDB_INTERNAL;;
  return -1;
}

int res_querydomain( const char * Name, const char * DomName, int Class,
		     int Type, unsigned char * AnsPtr, int AnsLength)
{
  int r = res_nquerydomain(& res, Name, DomName, Class, Type, AnsPtr,
			   AnsLength);
  h_errno = res.res_h_errno;
  return r;
}

/*****************************************************************
 *
 res_search()

 *****************************************************************/

int res_nsearch( res_state statp, const char * DomName, int Class, int Type,
		 unsigned char * AnsPtr, int AnsLength)
{
  int len, stat, i;
  char fullDomName[MAXDNAME], *ptr, *sptr;

  DPRINTF(statp->options & RES_DEBUG, "search \"%s\" type %d\n", DomName, Type);

  if (((statp->options & RES_INIT) == 0) && (res_ninit(statp) != 0))
    return -1;

  stat = res_nquery( statp, DomName, Class, Type, AnsPtr, AnsLength);

  /* Check if will skip search */
  if (statp->res_h_errno != HOST_NOT_FOUND               /* Success or hard failure */
      || ((ptr = strrchr(DomName, '.')) && (!*(ptr+1)))  /* Final dot */
      || (((statp->options & RES_DNSRCH) == 0)           /* Or no search */
	  && ((ptr != NULL)                              /*  And some dot */
	      || ((statp->options & RES_DEFNAMES) == 0)))/*    or no def domain */
      || (!(sptr = statp->dnsrch[0])))
    return stat;

  len = strlen(DomName);
  if (len >= MAXDNAME - 1) /* Space for next dot */
    goto error;
  strcpy(fullDomName, DomName);
  fullDomName[len++] = '.';
  fullDomName[MAXDNAME - 1] = 0; /* Overflow indicator */
  i = 0;
  do {
    strncpy(fullDomName + len, sptr, MAXDNAME - len);
    if (fullDomName[MAXDNAME - 1])
      goto error;
    stat = res_nquery(statp, fullDomName, Class, Type, AnsPtr, AnsLength);
  } while ((sptr = statp->dnsrch[++i]) != NULL
	   && statp->res_h_errno == HOST_NOT_FOUND
	   && (statp->options & RES_DNSRCH) != 0);

  /* Return last stat */
  return stat;

 error:
  DPRINTF(statp->options & RES_DEBUG, "name too long during search\n");
  errno = EINVAL;
  statp->res_h_errno = NETDB_INTERNAL;
  return -1;
}

int res_search( const char * DomName, int Class, int Type,
		unsigned char * AnsPtr, int AnsLength)
{
  int r = res_nsearch(& res, DomName, Class, Type, AnsPtr, AnsLength);
  h_errno = res.res_h_errno;
  return r;
}

/*****************************************************************
 * dn_expand
 *****************************************************************/

int dn_expand(const unsigned char *msg, const unsigned char *eomorig,
	      const unsigned char *comp_dn, char *exp_dn, int length)
{
  unsigned int len, complen = 0;
  const unsigned char *comp_dn_orig = comp_dn;

  if (comp_dn >= eomorig)
    goto expand_fail;
  if ((len = *comp_dn++) == 0)       /* Weird case */
    exp_dn++;
  else do {
    if (len <= MAXLABEL) {
      if ((length -= (len + 1)) >= 0 /* Need space for final . */
	  && comp_dn + len <= eomorig) {
	do { *exp_dn++ = *comp_dn++; } while (--len != 0);
	*exp_dn++ = '.';
      }
      else
	goto expand_fail;
    }
    else if (len >= (128+64)) {
      if (!complen)   /* Still in the original field? */
	complen = (comp_dn - comp_dn_orig) + 1;
      comp_dn = msg + (((len & ~(128+64)) << 8) + *comp_dn);
      if (comp_dn >= eomorig)
	goto expand_fail;
    }
    else
      goto expand_fail;
  } while ((len = *comp_dn++) != 0);
  /* Replace last . with a 0 */
  *(--exp_dn) = 0;
  if (!complen)
    complen = comp_dn - comp_dn_orig;
/*  fprintf(stderr, "dn_expand %s\n", exp_start); */
  return complen;

expand_fail:
  errno = EINVAL;
  return -1;
}

/*****************************************************************
 *
 dn_comp

 Return -1 in case of overflow, but still fill buffer correctly.
 We do not check the alphabet of the host names
 nor the length of the compressed name and we
 preserve the letter cases.

 *****************************************************************/
int dn_comp(const char * exp_dn, u_char * comp_dn, int length,
	    u_char ** dnptrs, u_char ** lastdnptr)
{
  u_char *cptr = comp_dn, *dptr, *lptr, *rptr;
  unsigned int i, len;
  u_char * const eptr = comp_dn + length - 1; /* Last valid */

  errno = EINVAL;

  if (*exp_dn == '.' && !*(exp_dn + 1))
    exp_dn++;
  while (1) {
    if (*exp_dn == '.' || cptr > eptr)
      return -1;
    if (*exp_dn == 0) {
      *cptr++ = 0;
      break;
    }
    /* Try to compress */
    if (dnptrs) {
      for (i = 1; dnptrs[i]; i++) {
	dptr = dnptrs[i];
	if (dptr >= comp_dn) /* Handle name.name */
	  continue;
	rptr = (u_char *) exp_dn;
	len = *dptr++;
	while (1) {
	  do {
	    if (*dptr++ != *rptr++)
	      goto next_dn;
	  } while (--len);
	  len = *dptr++;
	  if (len == 0) { /* last label */
	    if (!*rptr || (*rptr == '.' && !*(rptr + 1))) { /* Full match */
	      len = (dnptrs[i] - dnptrs[0]) | 0xC000;
	      /* Write pointer */
	      *cptr++ = len >> 8;
	      if (cptr > eptr)
		return -1;
	      *cptr++ = len;
	      goto done;
	    }
	    goto next_dn;
	  }
	  if (*rptr++ != '.')
	    goto next_dn;
	  if (len >= 128 + 64) {
	    dptr = dnptrs[0] + ((len - 128 - 64) << 8) + *dptr;
	    len = *dptr++;
	  }
	}
      next_dn: ;
      }
      /* Record label if asked and if space is available and if not too far off */
      if (lastdnptr && (lastdnptr != &dnptrs[i]) && (cptr - dnptrs[0]) < 0xC000) {
	dnptrs[i] = cptr;
	dnptrs[i+1] = NULL;
      }
    }
    /* Write label */
    lptr = cptr++; /* Length byte */
    rptr = (u_char *) exp_dn;
    do {
      if (cptr <= eptr)
	*cptr++ = *rptr;
    } while ((*++rptr != '.') && (*rptr != 0));
    len = rptr - (u_char *) exp_dn;
    if (len > MAXLABEL)
      return -1;
    *lptr = len;
    exp_dn = (char *) rptr;
    if (*exp_dn != 0)
      exp_dn++; /* Skip over . */
  }
 done:
  return cptr - comp_dn;
}

/*****************************************************************
 * dn_skipname

 Measures the compressed domain name length and returns it.
 *****************************************************************/
int dn_skipname(const unsigned char *comp_dn, const unsigned char *eom)
{
  int len;
  const unsigned char *comp_dn_orig = comp_dn;

  do {
    len = *comp_dn++;
    if (len >= (128 + 64)) {
      comp_dn++;
      break;
    }
    if (len > MAXLABEL ||
	(comp_dn += len) > eom)
      return -1;
  } while (len != 0);

  return comp_dn - comp_dn_orig;
}

/*****************************************************************
 * dn_length1    For internal use

 Return length of uncompressed name incl final 0.
 *****************************************************************/

int dn_length1(const unsigned char *msg, const unsigned char *eomorig,
	       const unsigned char *comp_dn)
{
  unsigned int len, length = 0;

  errno = EINVAL;
  if (comp_dn >= eomorig)
    goto expand_fail;
  else while ((len = *comp_dn++) != 0) {
    if (len <= MAXLABEL) {
      if ((comp_dn += len) <= eomorig)
	length += len + 1;
      else
	goto expand_fail;
    }
    else if (len >= (128+64)) {
      comp_dn = msg + (((len & ~(128+64)) << 8) + *comp_dn);
      if (comp_dn >= eomorig)
	goto expand_fail;
    }
    else
      goto expand_fail;
  }
  return length;

expand_fail:
  return -1;
}
@


1.14
log
@	* libc/bsdlib.cc (forkpty): Close master and slave if fork fails to
	avoid resource leak (CID 59997).
	* libc/fts.c: Update to FreeBSD version 1.39 (CID 59947).
	* libc/minires.c (minires_get_search): Fix out-of-bounds read from
	words array (CID 59937).
@
text
@d29 1
a29 1
  fprintf(stderr, "Minires: ");
d729 3
d740 1
a740 1
      *(ptr++ - 1) = '.';
@


1.13
log
@	* Merge in cygwin-64bit-branch.
@
text
@d80 1
a80 1
    else
@


1.13.2.1
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@d29 1
a29 1
  fprintf(stderr, "Resolv: ");
a728 3
  DPRINTF(statp->options & RES_DEBUG, "querydomain \"%s\"  \"%s\" type %d\n",
	  Name, DomName, Type);

d737 1
a737 1
      *ptr++ = '.';
@


1.13.2.2
log
@Add more missing patches
@
text
@d80 1
a80 1
    else if (j < MAXDNSRCH + 1)
@


1.12
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d180 1
a180 1
	  unsigned int address;
d182 1
a182 1
	  if (address == -1) {
d298 1
a298 1
  for (i = 0; i < DIM(statp->dnsrch); i++)  statp->dnsrch[i] = 0;
d427 1
a427 1
  volatile static unsigned int SServ = 0XFFFFFFFF;
d462 1
a462 1
  if ((statp->sockfd != -1) && (statp->mypid != getpid())) {
d628 4
a631 2
		  const unsigned char * dataptr, int datalen,
		  const unsigned char * newrr, unsigned char * buf, int buflen)
d727 1
a727 1
  int nlen;
@


1.11
log
@Clean up whitespace.
@
text
@d3 1
a3 1
   Copyright 2006, 2008, 2009 Red Hat, Inc.
@


1.11.2.1
log
@Pull in changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2006, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.11.2.2
log
@	* Throughout fix -Wextra warnings.  Ignore regex files and gmon.c.
@
text
@d180 1
a180 1
	  in_addr_t address;
d182 1
a182 1
	  if (address == INADDR_NONE) {
d298 1
a298 1
  for (i = 0; i < (int) DIM(statp->dnsrch); i++)  statp->dnsrch[i] = 0;
d427 1
a427 1
  static volatile unsigned int SServ = 0XFFFFFFFF;
d462 1
a462 1
  if ((statp->sockfd != -1) && ((pid_t) statp->mypid != getpid())) {
d628 2
a629 4
		  const unsigned char * dataptr __attribute__ ((unused)),
		  int datalen __attribute__ ((unused)),
		  const unsigned char * newrr __attribute__ ((unused)),
		  unsigned char * buf, int buflen)
d725 1
a725 1
  size_t nlen;
@


1.10
log
@* autoload.cc (std_dll_init): Move dll_path closer to its use.  Use dll_path in
fatal error.  Set ret values under lock control.
* lib/minires.c (res_nsend): Fix compilation errors owing to pointer
signedness.
@
text
@d454 1
a454 1
      /* dn_expand sets errno */ 
d458 1
a458 1
  }	  
d491 1
a491 1
       
d501 2
a502 2
    DPRINTF(debug && (errno != EWOULDBLOCK), 
	    "Unexpected errno for flushing recvfrom: %s", strerror(errno)); 
d543 2
a544 2
    /* 
       Prepare to retry with tcp 
d564 1
a564 1
	  if ((AnsPtr[2] & TC) && (tcp == 0) && !(statp->options & RES_IGNTC)) { 
d568 1
a568 1
	    continue /* Tcp loop */; 
d591 1
a591 1
	  case SERVFAIL: 
d647 1
a647 1
    PUTSHORT(RD, buf); 
d658 1
a658 1
    for (id4 = qtype, i = 0, ptr = dnameptr; *ptr; ptr++, i += 3) 
d665 1
a665 1
    else 
@


1.9
log
@

2010-09-21  Pierre Humblet <Pierre.Humblet@@ieee.org>

        * libc/minires.c (res_nsend): Use the Windows resolver if appropriate.
        (dn_expand): Only set errno in case of error. Delete old comments.
        (dn_skipname): Fix typo in comment.
@
text
@d444 2
a445 2
    unsigned char DomName[MAXDNAME];
    unsigned char * ptr = MsgPtr + HFIXEDSZ;
@


1.8
log
@	* libc/minires.c (scanline): Fix type in calls to ctype functions
	to stay in unsigned char range for char values >= 0x80.
	* regex/regcomp.c: Ditto, throughout.
	* regex/regex2.h (ISWORD): Ditto.
@
text
@d440 20
a830 1
/*  char * exp_start = exp_dn; */
a831 1
  errno = EINVAL;
d864 1
a864 1
/*  fprintf(stderr, "dn_expand fails\n"); */
d983 1
a983 1
 Return length of uncompressesed name incl final 0.
@


1.7
log
@* libc/minires.c (scanline): Accommodate ctype changes which disallow use of an
unadorned char argument to is* macros.
* regex/regcomp.c: Ditto, throughout.
* regex/regex2.h (ISWORD): Ditto.
@
text
@d46 1
a46 1
    while((*in) && (isspace((unsigned)*in) || *in == ',')) in++;
d50 1
a50 1
    while((*in) && !isspace((unsigned)*in) && *in != ',') in++;
@


1.6
log
@	* cygwin.din: Export gethostbyname2.
	* net.cc: define _CYGWIN_IN_H and include resolv.h.
	(realloc_ent): New function.
	(dup_ent): Call realloc_ent.
	(memcpy4to6): New function.
	(dn_length1): New function.
	(gethostby_helper): New function.
	(gethostbyname2): New function.
	* posix.sgml: Add gethostbyname2.
	* include/cygwin/version.h: Bump API minor number.
	* libc/minires.c (get_options): Look for "inet6" and apply bounds
	to "retry" and "retrans".
	(res_ninit): Set the default options at the beginning.
	(dn_expand): Fix "off by one".
@
text
@d46 1
a46 1
    while((*in) && (isspace(*in) || *in == ',')) in++;
d50 1
a50 1
    while((*in) && !isspace(*in) && *in != ',') in++;
@


1.5
log
@	* libc/minires.c (open_sock): Set non blocking and close on exec.
	(res_ninit): Set id pseudo-randomly.
	(res_nsend): Do not set close on exec. Initialize server from id.
	Flush socket. Tighten rules for answer acceptance.
	(res_nmkquery): Update id using current data.
@
text
@d3 1
a3 1
   Copyright 2006, 2008 Red Hat, Inc.
d102 5
d122 2
a123 1
      if (!strcasecmp("retry", words[i])) {
d126 2
d132 2
a133 1
      if (!strcasecmp("retrans", words[i])) {
d136 2
d284 3
a315 3
  /* Only debug may be set before calling init */
  statp->options &= RES_DEBUG;
  statp->options |= RES_INIT | RES_DEFAULT;
d820 1
a820 1
      if ((length -= (len + 1)) > 0 /* Need space for final . */
a849 1

d939 1
a939 2
 *
 dn_skipname
d961 35
@


1.4
log
@	Throughout, call fcntl64 instead of fcntl or fcntl_worker.
	* fcntl.cc (fcntl_worker): Remove.
	(fcntl64): Add fault handler.  Move fcntl_worker stuff here.  Add case
	for locking and call fhandler's lock method directly.  Make sure that
	F_FLOCK flag isn't set in lock call.
	(_fcntl): Add fault handler.
	* fhandler.cc (fhandler_base::fcntl): Drop lock cases.
	* flock.cc (flock): Add fault handler.  Simplify code.  Call fhandlers
	lock method directly instead of fcntl_worker.  Add debug output.
	(lockf): Add fault handler.  Call fhandlers lock method directly
	instead of fcntl_worker.  Add debug output.
	* winsup.h (fcntl_worker): Drop declaration.
	(fcntl64): Declare.
@
text
@d3 1
a3 1
   Copyright 2006 Red Hat, Inc.
d228 11
d280 4
a283 1

d437 1
a437 1
    /* Create a socket and bind it (to any port) */
a442 7
    /* Set close on exec flag */
    if (fcntl64(statp->sockfd, F_SETFD, 1) == -1) {
      DPRINTF(debug, "fcntl: %s\n",
	      strerror(errno));
      statp->res_h_errno = NETDB_INTERNAL;
      return -1;
    }
d445 1
a445 1
      SServ =  statp->mypid % statp->nscount;
d453 20
d511 3
a513 2
    /*
       Prepare to retry with tcp
d516 5
a520 2
      /* Check if this is the message we expected */
      if ((*MsgPtr == *AnsPtr)     /* Ids match */
d522 22
a543 11
/* We have stopped checking this because the question may not be present on error,
   in particular when the name in the question is not a valid name.
   Simply check that the header is present. */
	  && (rslt >= HFIXEDSZ)
/*        && (rslt >= MsgLength )
	  && (memcmp(MsgPtr + HFIXEDSZ, AnsPtr + HFIXEDSZ, MsgLength - HFIXEDSZ) == 0) */
	  && ((AnsPtr[2] & QR) != 0)) {

	DPRINTF(debug, "answer %u from %08x. Error %d. Count %d.\n",
		rslt, dnsSockAddr.sin_addr.s_addr,
		AnsPtr[3] & ERR_MASK, AnsPtr[6]*256 + AnsPtr[7]);
a552 11
	if ((AnsPtr[3] & ERR_MASK) == NOERROR) {
	  if ((AnsPtr[2] & TC) && !(statp->options & RES_IGNTC)) { /* Truncated. Try TCP */
	    rslt = get_tcp(&statp->nsaddr_list[wServ], MsgPtr, MsgLength,
			   AnsPtr, AnsLength, statp->options & RES_DEBUG);
	    continue;
	  }
	  else if ((AnsPtr[6] | AnsPtr[7])!= 0)
	    return rslt;
	  else
	    statp->res_h_errno = NO_DATA;
	}
d554 1
d556 2
a557 1
	  if ((AnsPtr[3] & ERR_MASK) == NXDOMAIN)
d559 2
a560 1
	  else if ((AnsPtr[3] & ERR_MASK) == SERVFAIL)
d562 2
a563 1
	  else
d565 1
d570 1
a570 3
	DPRINTF(debug, "unexpected answer %u from %x to query to %x\n",
		rslt, dnsSockAddr.sin_addr.s_addr,
		statp->nsaddr_list[wServ].sin_addr.s_addr);
d601 2
a602 1
  short id;
d613 1
d615 2
a616 3
    id = statp->id;
    PUTSHORT(id, buf);
    PUTSHORT(RD, buf);
d625 13
a637 1
    return len + 16; /* packet size */
@


1.3
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d430 1
a430 1
    if (fcntl(statp->sockfd, F_SETFD, 1) == -1) {
@


1.2
log
@	* libc/minires.c (res_ninit): Drop handling for LOCALDOMAIN environment
	variable.
@
text
@d27 1
a27 1
  
d39 1
a39 1
Return the number of words found  
d47 1
a47 1
    if (*in == 0) 
d52 1
a52 1
    sizes[i] = in - startp + 1; 
d73 1
a73 1
    if (j < MAXDNSRCH 
d111 1
a111 1
      /* Not supported 
d144 1
a144 1
#else 
d166 1
a166 1
      if (!have_address 
d184 1
a184 1
      else if (!have_search 
d211 1
a211 1
/* 
d220 1
a220 1
  
d260 1
a260 1
  
d276 1
a276 1
      
d280 1
a280 1
    DPRINTF(statp->options & RES_DEBUG, "no dns server found\n"); 
d311 1
a311 1
    DPRINTF(statp->options & RES_DEBUG, "close sockfd %d: %s\n", 
d320 1
a320 1
}  
d347 1
a347 1
static int get_tcp(struct sockaddr_in *CliAddr, 
d382 1
a382 1
  if (get_tcp_buf(fd, AnsPtr, MIN(ans_length, AnsLength), debug)) 
d396 1
a396 1
 
d398 1
a398 1
int res_nsend( res_state statp, const unsigned char * MsgPtr, 
d406 1
a406 1
  fd_set fdset_read; 
d410 1
a410 1
  
d412 1
a412 1
  if (((statp->options & RES_INIT) == 0) && (res_ninit(statp) != 0)) 
d431 1
a431 1
      DPRINTF(debug, "fcntl: %s\n", 
d441 1
a441 1
  transNum = 0;  
d443 1
a443 1
    if ((wServ = SServ + 1) >= statp->nscount) 
d447 1
a447 1
    rslt = cygwin_sendto(statp->sockfd, MsgPtr, MsgLength, 0, 
d451 1
a451 1
	    statp->nsaddr_list[wServ].sin_addr.s_addr, 
d477 1
a477 1
    rslt = cygwin_recvfrom(statp->sockfd, AnsPtr, AnsLength, 0, 
d484 2
a485 2
    /* 
       Prepare to retry with tcp 
d500 1
a500 1
		rslt, dnsSockAddr.sin_addr.s_addr, 
d507 1
a507 1
                         Also seen returned by some servers when the name is too long
d515 1
a515 1
	    continue; 
d517 1
a517 1
	  else if ((AnsPtr[6] | AnsPtr[7])!= 0) 
d519 1
a519 1
	  else 
d524 1
a524 1
	  if ((AnsPtr[3] & ERR_MASK) == NXDOMAIN) 
d526 1
a526 1
	  else if ((AnsPtr[3] & ERR_MASK) == SERVFAIL) 
d528 1
a528 1
	  else 
d535 1
a535 1
		rslt, dnsSockAddr.sin_addr.s_addr, 
d546 1
a546 1
int res_send( const unsigned char * MsgPtr, int MsgLength, 
d559 1
a559 1
        -1 name format is incorrect 
d562 1
a562 1
		  int op, const char * dnameptr, int qclass, int qtype, 
d573 1
a573 1
      DPRINTF(statp->options & RES_DEBUG, 
d581 1
a581 1
    PUTSHORT(RD, buf); 
d599 1
a599 1
int res_mkquery (int op, const char * dnameptr, int qclass, int qtype, 
d603 1
a603 1
  int r = res_nmkquery (& res, op, dnameptr, qclass, qtype, 
d611 1
a611 3
 *
 res_query()
                                                                  
d614 1
a614 1
int res_nquery( res_state statp, const char * DomName, int Class, int Type, 
d619 1
a619 1
  
d627 1
a627 1
  if ((len = res_nmkquery (statp, QUERY, DomName, Class, Type, 
d641 1
a641 3
 *
 res_querydomain()
                                                                  
d656 1
a656 1
    if (nlen && *(ptr - 1) != '.') 
d688 1
a688 1
int res_nsearch( res_state statp, const char * DomName, int Class, int Type, 
d696 1
a696 1
  if (((statp->options & RES_INIT) == 0) && (res_ninit(statp) != 0)) 
d703 1
a703 1
      || ((ptr = strrchr(DomName, '.')) && (!*(ptr+1)))  /* Final dot */ 
d707 1
a707 1
      || (!(sptr = statp->dnsrch[0])))                 
d713 1
a713 1
  strcpy(fullDomName, DomName); 
d720 1
a720 1
      goto error;      
d736 1
a736 1
int res_search( const char * DomName, int Class, int Type, 
d745 1
a745 3
 *
 dn_expand
                                                                  
d749 1
a749 1
              const unsigned char *comp_dn, char *exp_dn, int length)
d764 2
a765 2
        do { *exp_dn++ = *comp_dn++; } while (--len != 0);
        *exp_dn++ = '.';
d767 1
a767 1
      else 
d772 1
a772 1
	complen = (comp_dn - comp_dn_orig) + 1; 
d774 1
a774 1
      if (comp_dn >= eomorig) 
d777 1
a777 1
    else 
d782 1
a782 1
  if (!complen) 
d786 1
a786 1
  
d788 1
a788 1
/*  fprintf(stderr, "dn_expand fails\n"); */ 
d803 1
a803 1
int dn_comp(const char * exp_dn, u_char * comp_dn, int length, 
d809 1
a809 1
  
d834 1
a834 1
	  len = *dptr++; 
d900 1
a900 1
      return -1;	
@


1.1
log
@	* Makefile.in (DLL_OFILES): Add minires-os-if.o and minires.o.
	(SUBLIBS): Add libresolv.a.
	Add rule for libresolv.a.
	* autoload.cc: Fix return code handling for IP Helper API in case
	of being unable to load iphlpapi.dll.
	(DnsQuery_A): Define.
	(DnsRecordListFree): Define.
	* cygwin.din: Export resolver functions.
	* include/resolv.h: New header.
	* include/arpa/nameser.h: New header.
	* include/arpa/nameser_compat.h: New header.
	* include/cygwin/version.h: Bump API minor number.
	* libc/minires-os-if.c: New file.
	* libc/minires.c: New file.
	* libc/minires.h: New file.
@
text
@a259 1
  char * ptr;
a271 5
  /* Get search list from LOCALDOMAIN */
  if ((ptr = getenv("LOCALDOMAIN")) != 0 ) {
    DPRINTF(statp->options & RES_DEBUG, "LOCALDOMAIN \"%s\"\n", ptr);
    minires_get_search(ptr, statp); /* domain or dnsrch */
  }
@

