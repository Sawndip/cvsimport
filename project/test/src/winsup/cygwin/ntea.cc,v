head	1.33;
access;
symbols
	cygwin-1_7_35-release:1.33
	cygwin-1_7_34-release:1.33
	cygwin-1_7_33-release:1.28.2.3
	cygwin-1_7_32-release:1.28.2.2
	cygwin-1_7_31-release:1.28.2.2
	cygwin-1_7_30-release:1.28.2.2
	cygwin-1_7_29-release:1.28.2.2
	cygwin-1_7_29-release-branchpoint:1.28.0.2
	cygwin-pre-user-db:1.28
	cygwin-1_7_28-release:1.28
	cygwin-1_7_27-release:1.28
	cygwin-1_7_26-release:1.28
	cygwin-1_7_25-release:1.28
	cygwin-1_7_24-release:1.28
	cygwin-1_7_23-release:1.28
	cygwin-1_7_22-release:1.28
	cygwin-1_7_21-release:1.28
	cygwin-1_7_20-release:1.28
	cygwin-1_7_19-release:1.28
	cygwin-64bit-postmerge:1.27
	cygwin-64bit-premerge-branch:1.27.0.2
	cygwin-64bit-premerge:1.27
	cygwin-1_7_18-release:1.27
	post-ptmalloc3:1.26.2.1
	pre-ptmalloc3:1.26.2.1
	cygwin-1_7_17-release:1.26
	cygwin-64bit-branch:1.26.0.2
	cygwin-1_7_16-release:1.26
	cygwin-1_7_15-release:1.26
	cygwin-1_7_14_2-release:1.26
	cygwin-1_7_14-release:1.26
	cygwin-1_7_12-release:1.26
	cygwin-1_7_11-release:1.26
	cygwin-1_7_10-release:1.26
	signal-rewrite:1.25.0.2
	pre-notty:1.24
	cygwin-1_7_9-release:1.23
	cv-post-1_7_9:1.23.0.2
	cygwin-1_7_8-release:1.23
	cygwin-1_7_7-release:1.23
	cygwin-1_7_5-release:1.23
	cygwin-1_7_4-release:1.23
	cygwin-1_7_3-release:1.23
	cygwin-1_7_2-release:1.23
	fifo_doover3:1.22.0.2
	cygwin-1_7_1-release:1.22
	prefifo:1.19
	cv-branch-2:1.19.0.2
	pre-ripout-set_console_state_for_spawn:1.18
	EOL_registry_mounts:1.17
	preoverlapped:1.15
	drop_9x_support_start:1.15
	cr-0x5f1:1.14.0.4
	cv-branch:1.14.0.2
	pre-ptymaster-archetype:1.13
	cr-0x3b58:1.13.0.4
	cr-0x5ef:1.13.0.2
	after-mmap-privanon-noreserve:1.13
	after-mmap-revamp:1.13
	before-mmap-revamp:1.13
	cgf-more-exit-sync:1.13
	post_wait_sig_exit:1.13
	pre_wait_sig_exit:1.13
	reparent-point:1.12
	noreparent:1.12.0.10
	cr-0x5e6:1.12.0.8
	cr-0x9e:1.12.0.6
	cr-0x9d:1.12.0.4
	cgf-deleteme:1.12.0.2
	pre-sigrewrite:1.11
	corinna-01:1.11
	cr-0x9c:1.11.0.6
	cr-0x9b:1.11.0.4
	cr-0x99:1.11
	Z-emcb-cygwin_daemon:1.11.0.2
	w32api-2_2:1.9
	mingw-runtime-2_4:1.9
	pre-cgf-merge:1.11
	cgf-dev-branch:1.9.0.16
	predaemon:1.8
	cygwin_daemon_merge_HEAD:1.8
	pregp02r1:1.8.0.34
	cygnus_cvs_20020108_pre:1.8
	Z-cygwin_daemon_merge-new_HEAD:1.9
	Z-cygwin_daemon_merge_HEAD:1.9
	cygwin_daemon:1.8.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.33
date	2014.08.27.09.39.44;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2014.08.26.20.47.46;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2014.08.22.09.21.31;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.04.14.26.05;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.04.13.38.42;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2011.12.03.21.43.26;	author cgf;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2011.08.09.09.14.28;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2010.01.12.10.14.59;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.18.15.57.08;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.18.11.57.41;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.16.16.23.51;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.11.05.43.11;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.10.15.43.04;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.20.00.16.17;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.03.18.30.08;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.18.17.23.17;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.02.03.16.00;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.09.20.10.25;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.19.15.12.48;	author cgf;	state Exp;
branches
	1.9.16.1;
next	1.8;

1.8
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.05.10.45.52;	author duda;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.31.05.25.46;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.29.16.24.38;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.28.2.1
date	2014.04.04.13.39.58;	author corinna;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2014.04.04.14.27.32;	author corinna;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2014.11.13.12.53.03;	author corinna;	state Exp;
branches;
next	;

1.26.2.1
date	2013.01.21.13.52.09;	author corinna;	state Exp;
branches;
next	;

1.9.16.1
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.9.16.2;

1.9.16.2
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.8.4.1
date	2002.09.19.21.51.22;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.33
log
@	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.
@
text
@/* ntea.cc: code for manipulating Extended Attributes

   Copyright 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "cygtls.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "ntdll.h"
#include "tls_pbuf.h"
#include <stdlib.h>
#include <attr/xattr.h>

#define MAX_EA_NAME_LEN    256
#define MAX_EA_VALUE_LEN 65536

/* At least one maximum sized entry fits. 
   CV 2014-04-04: NtQueryEaFile function chokes on buffers bigger than 64K
		  with STATUS_INVALID_PARAMETER if the handle points to a file
		  on a remote share, at least on Windows 7 and later.
		  In theory the buffer should have a size of
		  
		    sizeof (FILE_FULL_EA_INFORMATION) + MAX_EA_NAME_LEN
		    + MAX_EA_VALUE_LEN
		  
		  (65804 bytes), but we're opting for simplicity here, and
		  a 64K buffer has the advantage that we can use a tmp_pathbuf
		  buffer, rather than having to alloca 64K from stack. */
#define EA_BUFSIZ MAX_EA_VALUE_LEN

#define NEXT_FEA(p) ((PFILE_FULL_EA_INFORMATION) (p->NextEntryOffset \
		     ? (char *) p + p->NextEntryOffset : NULL))

ssize_t __reg3
read_ea (HANDLE hdl, path_conv &pc, const char *name, char *value, size_t size)
{
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  ssize_t ret = -1;
  HANDLE h = hdl;
  ULONG glen = 0;
  PFILE_GET_EA_INFORMATION gea = NULL;
  PFILE_FULL_EA_INFORMATION fea;
  tmp_pathbuf tp;
  /* We have to store the latest EaName to compare with the next one, since
     NtQueryEaFile has a bug when accessing files on a remote share.  It
     returns the last EA entry of the file infinitely.  Even utilizing the
     optional EaIndex only helps marginally.  If you use that, the last
     EA in the file is returned twice. */
  char lastname[MAX_EA_NAME_LEN];

  __try
    {
      pc.get_object_attr (attr, sec_none_nih);

      debug_printf ("read_ea (%S, %s, %p, %lu)",
		    attr.ObjectName, name, value, size);

      /* Early open if handle is NULL.  This allows to return error codes like
	 ENOENT before we actually check for the correctness of the EA name and
	 stuff like that. */
      if (!hdl)
	{
	  status = NtOpenFile (&h, READ_CONTROL | FILE_READ_EA, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	}

      fea = (PFILE_FULL_EA_INFORMATION) tp.w_get ();

      if (name)
	{
	  size_t nlen;

	  /* For compatibility with Linux, we only allow user xattrs and
	     return ENOTSUP otherwise. */
	  if (ascii_strncasematch (name, "user.", 5))
	    name += 5;
	  else
	    {
	      set_errno (ENOTSUP);
	      __leave;
	    }

	  if ((nlen = strlen (name)) >= MAX_EA_NAME_LEN)
	    {
	      set_errno (EINVAL);
	      __leave;
	    }
	  glen = sizeof (FILE_GET_EA_INFORMATION) + nlen;
	  gea = (PFILE_GET_EA_INFORMATION) alloca (glen);

	  gea->NextEntryOffset = 0;
	  gea->EaNameLength = nlen;
	  strcpy (gea->EaName, name);
	}

      while (true)
	{
	  if (h)
	    {
	      status = NtQueryEaFile (h, &io, fea, EA_BUFSIZ, TRUE, gea, glen,
				      NULL, TRUE);
	      if (status != STATUS_ACCESS_DENIED || !hdl)
		break;
	      pc.init_reopen_attr (attr, h);
	    }
	  status = NtOpenFile (&h, READ_CONTROL | FILE_READ_EA, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
	    break;
	  hdl = NULL;
	}
      if (!NT_SUCCESS (status))
	{
	  switch (status)
	    {
	    case STATUS_NO_EAS_ON_FILE:
	      ret = 0;
	      break;
	    case STATUS_INVALID_DEVICE_REQUEST:
	      set_errno (ENOTSUP);
	      break;
	    case STATUS_NOT_FOUND:
	      /* STATUS_NOT_FOUND is returned when calling NtQueryEaFile on NFS.
		 In theory this should mean that the file just has no EAs, but
		 in fact NFS doesn't support EAs, other than the EAs which are
		 used for NFS requests.  We're playing safe and convert
		 STATUS_NOT_FOUND to ENOATTR, unless we're on NFS, where we
		 convert it to ENOTSUP. */
	      set_errno (pc.fs_is_nfs () ? ENOTSUP : ENOATTR);
	      break;
	    case STATUS_NONEXISTENT_EA_ENTRY:
	      /* Actually STATUS_NONEXISTENT_EA_ENTRY is either never generated,
		 or it was only generated in some old and long forgotton NT
		 version.  See below.  For safty reasons, we handle it here,
		 nevertheless. */
	      set_errno (ENOATTR);
	      break;
	    default:
	      __seterrno_from_nt_status (status);
	      break;
	    }
	  __leave;
	}
      if (name)
	{
	  /* Another weird behaviour of NtQueryEaFile.  If you ask for a
	     specific EA which is not present in the file's EA list, you don't
	     get a useful error code like STATUS_NONEXISTENT_EA_ENTRY.  Rather
	     NtQueryEaFile returns success with the entry's EaValueLength
	     set to 0. */
	  if (!fea->EaValueLength)
	    {
	      set_errno (ENOATTR);
	      __leave;
	    }
	  if (size > 0)
	    {
	      if (size < fea->EaValueLength)
		{
		  set_errno (ERANGE);
		  __leave;
		}
	      memcpy (value, fea->EaName + fea->EaNameLength + 1,
		      fea->EaValueLength);
	    }
	  ret = fea->EaValueLength;
	}
      else
	{
	  ret = 0;
	  do
	    {
	      fea->EaNameLength += 5;	/* "user." */
	      if (size > 0)
		{
		  if ((size_t) ret + fea->EaNameLength + 1 > size)
		    {
		      set_errno (ERANGE);
		      __leave;
		    }
		  /* For compatibility with Linux, we always prepend "user." to
		     the attribute name, so effectively we only support user
		     attributes from a application point of view. */
		  char tmpbuf[MAX_EA_NAME_LEN * 2];
		  char *tp = stpcpy (tmpbuf, "user.");
		  stpcpy (tp, fea->EaName);
		  /* NTFS stores all EA names in uppercase unfortunately.  To
		     keep compatibility with ext/xfs EA namespaces and
		     accompanying tools, which expect the namespaces to be
		     lower case, we return EA names in lowercase if the file
		     is on a native NTFS. */
		  if (pc.fs_is_ntfs ())
		    strlwr (tp);
		  tp = stpcpy (value, tmpbuf) + 1;
		  ret += tp - value;
		  value = tp;
		}
	      else
		ret += fea->EaNameLength + 1;
	      strcpy (lastname, fea->EaName);
	      status = NtQueryEaFile (h, &io, fea, EA_BUFSIZ, TRUE, NULL, 0,
				      NULL, FALSE);
	    }
	  while (NT_SUCCESS (status) && strcmp (lastname, fea->EaName) != 0);
	}
    }
  __except (EFAULT) {}
  __endtry
  if (!hdl && h)
    NtClose (h);
  debug_printf ("%d = read_ea(%S, %s, %p, %lu)",
		ret, attr.ObjectName, name, value, size);
  return ret;
}

int __reg3
write_ea (HANDLE hdl, path_conv &pc, const char *name, const char *value,
	  size_t size, int flags)
{
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  int ret = -1;
  HANDLE h = hdl;
  PFILE_FULL_EA_INFORMATION fea;
  ULONG flen;
  size_t nlen;

  __try
    {
      pc.get_object_attr (attr, sec_none_nih);

      debug_printf ("write_ea (%S, %s, %p, %lu, %d)",
		    attr.ObjectName, name, value, size, flags);

      /* Early open if handle is NULL.  This allows to return error codes like
	 ENOENT before we actually check for the correctness of the EA name and
	 stuff like that. */
      if (!hdl)
	{
	  status = NtOpenFile (&h, READ_CONTROL | FILE_WRITE_EA, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	}

      /* For compatibility with Linux, we only allow user xattrs and
	 return ENOTSUP otherwise. */
      if (!ascii_strncasematch (name, "user.", 5))
	{
	  set_errno (ENOTSUP);
	  __leave;
	}

      /* removexattr is supposed to fail with ENOATTR if the requested EA is
	 not available.  This is equivalent to XATTR_REPLACE for setxattr. */
      if (!value)
	flags = XATTR_REPLACE;

      if (flags)
	{
	  if (flags != XATTR_CREATE && flags != XATTR_REPLACE)
	    {
	      set_errno (EINVAL);
	      __leave;
	    }
	  ssize_t rret = read_ea (hdl, pc, name, NULL, 0);
	  if (flags == XATTR_CREATE && rret > 0)
	    {
	      set_errno (EEXIST);
	      __leave;
	    }
	  if (flags == XATTR_REPLACE && rret < 0)
	    __leave;
	}

      /* Skip "user." prefix. */
      name += 5;

      if ((nlen = strlen (name)) >= MAX_EA_NAME_LEN)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      flen = sizeof (FILE_FULL_EA_INFORMATION) + nlen + 1 + size;
      fea = (PFILE_FULL_EA_INFORMATION) alloca (flen);
      fea->NextEntryOffset = 0;
      fea->Flags = 0;
      fea->EaNameLength = nlen;
      fea->EaValueLength = size;
      strcpy (fea->EaName, name);
      if (value)
	memcpy (fea->EaName + fea->EaNameLength + 1, value, size);

      while (true)
	{
	  if (h)
	    {
	      status = NtSetEaFile (h, &io, fea, flen);
	      if (status != STATUS_ACCESS_DENIED || !hdl)
		break;
	      pc.init_reopen_attr (attr, h);
	    }
	  status = NtOpenFile (&h, READ_CONTROL | FILE_WRITE_EA, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
	    break;
	  hdl = NULL;
	}
      if (!NT_SUCCESS (status))
	{
	  switch (status)
	    {
	    case STATUS_EA_TOO_LARGE:
	      /* STATUS_EA_TOO_LARGE has a matching Win32 error code
		 ERROR_EA_TABLE_FULL.  For some reason RtlNtStatusToDosError
		 does not translate STATUS_EA_TOO_LARGE to ERROR_EA_TABLE_FULL,
		 but instead to ERROR_EA_LIST_INCONSISTENT.  This error code is
		 also returned for STATUS_EA_LIST_INCONSISTENT, which means the
		 incoming EA list is... inconsistent.  For obvious reasons we
		 translate ERROR_EA_LIST_INCONSISTENT to EINVAL, so we have to
		 handle STATUS_EA_TOO_LARGE explicitely here, to get the correct
		 mapping to ENOSPC. */
	      set_errno (ENOSPC);
	      break;
	    case STATUS_INVALID_DEVICE_REQUEST:
	      set_errno (ENOTSUP);
	      break;
	    default:
	      __seterrno_from_nt_status (status);
	      break;
	    }
	}
      else
	ret = 0;
    }
  __except (EFAULT) {}
  __endtry
  if (!hdl && h)
    NtClose (h);
  debug_printf ("%d = write_ea(%S, %s, %p, %lu, %d)",
		ret, attr.ObjectName, name, value, size, flags);
  return ret;
}

static ssize_t __stdcall
getxattr_worker (path_conv &pc, const char *name, void *value, size_t size)
{
  int res = -1;

  if (pc.error)
    {
      debug_printf ("got %d error from path_conv", pc.error);
      set_errno (pc.error);
    }
  else if (pc.exists ())
    {
      fhandler_base *fh;

      if (!(fh = build_fh_pc (pc)))
	return -1;

      res = fh->fgetxattr (name, value, size);
      delete fh;
    }
  else
    set_errno (ENOENT);
  return res;
}

extern "C" ssize_t
getxattr (const char *path, const char *name, void *value, size_t size)
{
  if (!name)
    {
      set_errno (EINVAL);
      return -1;
    }
  path_conv pc (path, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
  return getxattr_worker (pc, name, value, size);
}

extern "C" ssize_t
lgetxattr (const char *path, const char *name, void *value, size_t size)
{
  if (!name)
    {
      set_errno (EINVAL);
      return -1;
    }
  path_conv pc (path, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
  return getxattr_worker (pc, name, value, size);
}

extern "C" ssize_t
fgetxattr (int fd, const char *name, void *value, size_t size)
{
  int res;

  if (!name)
    {
      set_errno (EINVAL);
      return -1;
    }
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    res = -1;
  else
    res = cfd->fgetxattr (name, value, size);
  return res;
}

extern "C" ssize_t
listxattr (const char *path, char *list, size_t size)
{
  path_conv pc (path, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
  return getxattr_worker (pc, NULL, list, size);
}

extern "C" ssize_t
llistxattr (const char *path, char *list, size_t size)
{
  path_conv pc (path, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
  return getxattr_worker (pc, NULL, list, size);
}

extern "C" ssize_t
flistxattr (int fd, char *list, size_t size)
{
  int res;

  cygheap_fdget cfd (fd);
  if (cfd < 0)
    res = -1;
  else
    res = cfd->fgetxattr (NULL, list, size);
  return res;
}

static int __stdcall
setxattr_worker (path_conv &pc, const char *name, const void *value,
		 size_t size, int flags)
{
  int res = -1;

  if (pc.error)
    {
      debug_printf ("got %d error from path_conv", pc.error);
      set_errno (pc.error);
    }
  else if (pc.exists ())
    {
      fhandler_base *fh;

      if (!(fh = build_fh_pc (pc)))
	return -1;

      res = fh->fsetxattr (name, value, size, flags);
      delete fh;
    }
  else
    set_errno (ENOENT);
  return res;
}

extern "C" int
setxattr (const char *path, const char *name, const void *value, size_t size,
	  int flags)
{
  if (!size)
    {
      set_errno (EINVAL);
      return -1;
    }
  path_conv pc (path, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
  return setxattr_worker (pc, name, value, size, flags);
}

extern "C" int
lsetxattr (const char *path, const char *name, const void *value, size_t size,
	   int flags)
{
  if (!size)
    {
      set_errno (EINVAL);
      return -1;
    }
  path_conv pc (path, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
  return setxattr_worker (pc, name, value, size, flags);
}

extern "C" int
fsetxattr (int fd, const char *name, const void *value, size_t size, int flags)
{
  int res;

  if (!size)
    {
      set_errno (EINVAL);
      return -1;
    }
  cygheap_fdget cfd (fd);
  if (cfd < 0)
    res = -1;
  else
    res = cfd->fsetxattr (name, value, size, flags);
  return res;
}

extern "C" int
removexattr (const char *path, const char *name)
{
  path_conv pc (path, PC_SYM_FOLLOW | PC_POSIX, stat_suffixes);
  return setxattr_worker (pc, name, NULL, 0, 0);
}

extern "C" int
lremovexattr (const char *path, const char *name)
{
  path_conv pc (path, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
  return setxattr_worker (pc, name, NULL, 0, 0);
}

extern "C" int
fremovexattr (int fd, const char *name)
{
  int res;

  cygheap_fdget cfd (fd);
  if (cfd < 0)
    res = -1;
  else
    res = cfd->fsetxattr (name, NULL, 0, 0);
  return res;
}
@


1.32
log
@	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.
@
text
@d104 1
a104 1
	      return -1;
d228 2
a229 2
  if (!hdl)
    CloseHandle (h);
d363 2
a364 2
  if (!hdl)
    CloseHandle (h);
@


1.31
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@a82 1
	  hdl = NULL;
d122 1
a267 1
	  hdl = NULL;
d325 1
@


1.30
log
@	* ntea.cc (EA_BUFSIZ): Fix comment.
	(read_ea): Use tmp_pathbuf for local buffer rather than alloca.
	Throughout change ZwQueryEaFile to NtQueryEaFile in comments.
@
text
@d63 1
a63 13
  myfault efault;
  if (efault.faulted (EFAULT))
    goto out;

  pc.get_object_attr (attr, sec_none_nih);

  debug_printf ("read_ea (%S, %s, %p, %lu)",
		attr.ObjectName, name, value, size);

  /* Early open if handle is NULL.  This allows to return error codes like
     ENOENT before we actually check for the correctness of the EA name and
     stuff like that. */
  if (!hdl)
d65 19
a83 6
      status = NtOpenFile (&h, READ_CONTROL | FILE_READ_EA, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  goto out;
a84 2
      hdl = NULL;
    }
d86 5
a90 1
  fea = (PFILE_FULL_EA_INFORMATION) tp.w_get ();
d92 9
a100 3
  if (name)
    {
      size_t nlen;
d102 7
a108 9
      /* For compatibility with Linux, we only allow user xattrs and
	 return ENOTSUP otherwise. */
      if (ascii_strncasematch (name, "user.", 5))
	name += 5;
      else
	{
	  set_errno (ENOTSUP);
	  goto out;
	}
d110 3
a112 4
      if ((nlen = strlen (name)) >= MAX_EA_NAME_LEN)
	{
	  set_errno (EINVAL);
	  return -1;
a113 7
      glen = sizeof (FILE_GET_EA_INFORMATION) + nlen;
      gea = (PFILE_GET_EA_INFORMATION) alloca (glen);

      gea->NextEntryOffset = 0;
      gea->EaNameLength = nlen;
      strcpy (gea->EaName, name);
    }
d115 1
a115 3
  while (true)
    {
      if (h)
d117 11
a127 3
	  status = NtQueryEaFile (h, &io, fea, EA_BUFSIZ, TRUE, gea, glen,
				  NULL, TRUE);
	  if (status != STATUS_ACCESS_DENIED || !hdl)
d129 1
a130 2
      status = NtOpenFile (&h, READ_CONTROL | FILE_READ_EA, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
a131 6
	break;
      hdl = NULL;
    }
  if (!NT_SUCCESS (status))
    {
      switch (status)
d133 1
a133 41
	case STATUS_NO_EAS_ON_FILE:
	  ret = 0;
	  break;
	case STATUS_INVALID_DEVICE_REQUEST:
	  set_errno (ENOTSUP);
	  break;
	case STATUS_NOT_FOUND:
	  /* STATUS_NOT_FOUND is returned when calling NtQueryEaFile on NFS.
	     In theory this should mean that the file just has no EAs, but in
	     fact NFS doesn't support EAs, other than the EAs which are used
	     for NFS requests.  We're playing safe and convert STATUS_NOT_FOUND
	     to ENOATTR, unless we're on NFS, where we convert it to ENOTSUP. */
	  set_errno (pc.fs_is_nfs () ? ENOTSUP : ENOATTR);
	  break;
	case STATUS_NONEXISTENT_EA_ENTRY:
	  /* Actually STATUS_NONEXISTENT_EA_ENTRY is either never generated, or
	     it was only generated in some old and long forgotton NT version.
	     See below.  For safty reasons, we handle it here, nevertheless. */
	  set_errno (ENOATTR);
	  break;
	default:
	  __seterrno_from_nt_status (status);
	  break;
	}
      goto out;
    }
  if (name)
    {
      /* Another weird behaviour of NtQueryEaFile.  If you ask for a
	 specific EA which is not present in the file's EA list, you don't
	 get a useful error code like STATUS_NONEXISTENT_EA_ENTRY.  Rather
	 NtQueryEaFile returns success with the entry's EaValueLength
	 set to 0. */
      if (!fea->EaValueLength)
	{
	  set_errno (ENOATTR);
	  goto out;
	}
      if (size > 0)
	{
	  if (size < fea->EaValueLength)
d135 25
a159 2
	      set_errno (ERANGE);
	      goto out;
d161 1
a161 2
	  memcpy (value, fea->EaName + fea->EaNameLength + 1,
		  fea->EaValueLength);
d163 1
a163 6
      ret = fea->EaValueLength;
    }
  else
    {
      ret = 0;
      do
d165 10
a174 1
	  fea->EaNameLength += 5;	/* "user." */
d177 1
a177 1
	      if ((size_t) ret + fea->EaNameLength + 1 > size)
d180 1
a180 1
		  goto out;
d182 2
a183 15
	      /* For compatibility with Linux, we always prepend "user." to
		 the attribute name, so effectively we only support user
		 attributes from a application point of view. */
	      char tmpbuf[MAX_EA_NAME_LEN * 2];
	      char *tp = stpcpy (tmpbuf, "user.");
	      stpcpy (tp, fea->EaName);
	      /* NTFS stores all EA names in uppercase unfortunately.  To keep
		 compatibility with ext/xfs EA namespaces and accompanying
		 tools, which expect the namespaces to be lower case, we return
		 EA names in lowercase if the file is on a native NTFS. */
	      if (pc.fs_is_ntfs ())
		strlwr (tp);
	      tp = stpcpy (value, tmpbuf) + 1;
	      ret += tp - value;
	      value = tp;
d185 39
a223 5
	  else
	    ret += fea->EaNameLength + 1;
	  strcpy (lastname, fea->EaName);
	  status = NtQueryEaFile (h, &io, fea, EA_BUFSIZ, TRUE, NULL, 0,
				  NULL, FALSE);
a224 1
      while (NT_SUCCESS (status) && strcmp (lastname, fea->EaName) != 0);
d226 2
a227 2

out:
d248 1
a248 13
  myfault efault;
  if (efault.faulted (EFAULT))
    goto out;

  pc.get_object_attr (attr, sec_none_nih);

  debug_printf ("write_ea (%S, %s, %p, %lu, %d)",
		attr.ObjectName, name, value, size, flags);

  /* Early open if handle is NULL.  This allows to return error codes like
     ENOENT before we actually check for the correctness of the EA name and
     stuff like that. */
  if (!hdl)
d250 1
a250 9
      status = NtOpenFile (&h, READ_CONTROL | FILE_WRITE_EA, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  goto out;
	}
      hdl = NULL;
    }
d252 2
a253 7
  /* For compatibility with Linux, we only allow user xattrs and
     return ENOTSUP otherwise. */
  if (!ascii_strncasematch (name, "user.", 5))
    {
      set_errno (ENOTSUP);
      goto out;
    }
d255 15
a269 4
  /* removexattr is supposed to fail with ENOATTR if the requested EA is not
     available.  This is equivalent to the XATTR_REPLACE flag for setxattr. */
  if (!value)
    flags = XATTR_REPLACE;
d271 3
a273 3
  if (flags)
    {
      if (flags != XATTR_CREATE && flags != XATTR_REPLACE)
d275 2
a276 2
	  set_errno (EINVAL);
	  goto out;
d278 7
a284 2
      ssize_t rret = read_ea (hdl, pc, name, NULL, 0);
      if (flags == XATTR_CREATE && rret > 0)
d286 13
a298 2
	  set_errno (EEXIST);
	  goto out;
a299 3
      if (flags == XATTR_REPLACE && rret < 0)
	goto out;
    }
d301 2
a302 2
  /* Skip "user." prefix. */
  name += 5;
d304 14
a317 14
  if ((nlen = strlen (name)) >= MAX_EA_NAME_LEN)
    {
      set_errno (EINVAL);
      goto out;
    }
  flen = sizeof (FILE_FULL_EA_INFORMATION) + nlen + 1 + size;
  fea = (PFILE_FULL_EA_INFORMATION) alloca (flen);
  fea->NextEntryOffset = 0;
  fea->Flags = 0;
  fea->EaNameLength = nlen;
  fea->EaValueLength = size;
  strcpy (fea->EaName, name);
  if (value)
    memcpy (fea->EaName + fea->EaNameLength + 1, value, size);
d319 1
a319 3
  while (true)
    {
      if (h)
d321 10
a330 2
	  status = NtSetEaFile (h, &io, fea, flen);
	  if (status != STATUS_ACCESS_DENIED || !hdl)
d332 1
a333 2
      status = NtOpenFile (&h, READ_CONTROL | FILE_WRITE_EA, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, FILE_OPEN_FOR_BACKUP_INTENT);
a334 6
	break;
      hdl = NULL;
    }
  if (!NT_SUCCESS (status))
    {
      switch (status)
d336 21
a356 18
	case STATUS_EA_TOO_LARGE:
	  /* STATUS_EA_TOO_LARGE has a matching Win32 error ERROR_EA_TABLE_FULL.
	     For some unknown reason RtlNtStatusToDosError does not translate
	     STATUS_EA_TOO_LARGE to ERROR_EA_TABLE_FULL, but instead to
	     ERROR_EA_LIST_INCONSISTENT.  This error code is also returned for
	     STATUS_EA_LIST_INCONSISTENT, which means the incoming EA list is...
	     inconsistent.  For obvious reasons we translate
	     ERROR_EA_LIST_INCONSISTENT to EINVAL, so we have to handle
	     STATUS_EA_TOO_LARGE explicitely here, to get the correct mapping
	     to ENOSPC. */
	  set_errno (ENOSPC);
	  break;
	case STATUS_INVALID_DEVICE_REQUEST:
	  set_errno (ENOTSUP);
	  break;
	default:
	  __seterrno_from_nt_status (status);
	  break;
d358 2
d361 2
a362 4
  else
    ret = 0;

out:
@


1.29
log
@	* ntea (EA_BUFSIZ): Reduce to 64K.  Add comment to explain why.
@
text
@d20 1
d28 4
a31 4
   CV 2014-04-04: I'm really puzzled how it should be possible to have 64K EAs,
		  if the NtQueryEaFile function chokes on buffers bigger than
		  64K with STATUS_INVALID_PARAMETER, at least on Windows 7 and
		  later.  In theory, the buffer size should be
d33 1
a33 1
		    (sizeof (FILE_FULL_EA_INFORMATION) + MAX_EA_NAME_LEN
d36 3
a38 3
		  to read a single 64K EA.  But maybe I just misunderstood and
		  EAs can't be 64K.  I can't find the source I got this
		  information from anymore. */
d55 1
d57 1
a57 1
     ZwQueryEaFile has a bug when accessing files on a remote share.  It
d87 1
a87 1
  fea = (PFILE_FULL_EA_INFORMATION) alloca (EA_BUFSIZ);
d163 1
a163 1
      /* Another weird behaviour of ZwQueryEaFile.  If you ask for a
d166 1
a166 1
	 ZwQueryEaFile returns success with the entry's EaValueLength
@


1.28
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d4 1
a4 1
   2010, 2011 Red Hat, Inc.
d26 13
a38 3
/* At least one maximum sized entry fits. */
#define EA_BUFSIZ (sizeof (FILE_FULL_EA_INFORMATION) + MAX_EA_NAME_LEN \
		   + MAX_EA_VALUE_LEN)
@


1.28.2.1
log
@	* ntea (EA_BUFSIZ): Reduce to 64K.  Add comment to explain why.
@
text
@d4 1
a4 1
   2010, 2011, 2014 Red Hat, Inc.
d26 3
a28 13
/* At least one maximum sized entry fits. 
   CV 2014-04-04: I'm really puzzled how it should be possible to have 64K EAs,
		  if the NtQueryEaFile function chokes on buffers bigger than
		  64K with STATUS_INVALID_PARAMETER, at least on Windows 7 and
		  later.  In theory, the buffer size should be
		  
		    (sizeof (FILE_FULL_EA_INFORMATION) + MAX_EA_NAME_LEN
		    + MAX_EA_VALUE_LEN
		  
		  to read a single 64K EA.  But maybe I just misunderstood and
		  EAs can't be 64K.  I can't find the source I got this
		  information from anymore. */
#define EA_BUFSIZ MAX_EA_VALUE_LEN
@


1.28.2.2
log
@	* ntea.cc (EA_BUFSIZ): Fix comment.
	(read_ea): Use tmp_pathbuf for local buffer rather than alloca.
	Throughout change ZwQueryEaFile to NtQueryEaFile in comments.
@
text
@a19 1
#include "tls_pbuf.h"
d27 4
a30 4
   CV 2014-04-04: NtQueryEaFile function chokes on buffers bigger than 64K
		  with STATUS_INVALID_PARAMETER if the handle points to a file
		  on a remote share, at least on Windows 7 and later.
		  In theory the buffer should have a size of
d32 1
a32 1
		    sizeof (FILE_FULL_EA_INFORMATION) + MAX_EA_NAME_LEN
d35 3
a37 3
		  (65804 bytes), but we're opting for simplicity here, and
		  a 64K buffer has the advantage that we can use a tmp_pathbuf
		  buffer, rather than having to alloca 64K from stack. */
a53 1
  tmp_pathbuf tp;
d55 1
a55 1
     NtQueryEaFile has a bug when accessing files on a remote share.  It
d85 1
a85 1
  fea = (PFILE_FULL_EA_INFORMATION) tp.w_get ();
d161 1
a161 1
      /* Another weird behaviour of NtQueryEaFile.  If you ask for a
d164 1
a164 1
	 NtQueryEaFile returns success with the entry's EaValueLength
@


1.28.2.3
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d63 13
a75 1
  __try
d77 11
a87 1
      pc.get_object_attr (attr, sec_none_nih);
d89 3
a91 2
      debug_printf ("read_ea (%S, %s, %p, %lu)",
		    attr.ObjectName, name, value, size);
d93 8
a100 13
      /* Early open if handle is NULL.  This allows to return error codes like
	 ENOENT before we actually check for the correctness of the EA name and
	 stuff like that. */
      if (!hdl)
	{
	  status = NtOpenFile (&h, READ_CONTROL | FILE_READ_EA, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
d103 1
a103 3
      fea = (PFILE_FULL_EA_INFORMATION) tp.w_get ();

      if (name)
d105 5
a109 1
	  size_t nlen;
d111 4
a114 9
	  /* For compatibility with Linux, we only allow user xattrs and
	     return ENOTSUP otherwise. */
	  if (ascii_strncasematch (name, "user.", 5))
	    name += 5;
	  else
	    {
	      set_errno (ENOTSUP);
	      __leave;
	    }
d116 3
a118 14
	  if ((nlen = strlen (name)) >= MAX_EA_NAME_LEN)
	    {
	      set_errno (EINVAL);
	      __leave;
	    }
	  glen = sizeof (FILE_GET_EA_INFORMATION) + nlen;
	  gea = (PFILE_GET_EA_INFORMATION) alloca (glen);

	  gea->NextEntryOffset = 0;
	  gea->EaNameLength = nlen;
	  strcpy (gea->EaName, name);
	}

      while (true)
d120 3
a122 12
	  if (h)
	    {
	      status = NtQueryEaFile (h, &io, fea, EA_BUFSIZ, TRUE, gea, glen,
				      NULL, TRUE);
	      if (status != STATUS_ACCESS_DENIED || !hdl)
		break;
	      pc.init_reopen_attr (attr, h);
	    }
	  status = NtOpenFile (&h, READ_CONTROL | FILE_READ_EA, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
a123 1
	  hdl = NULL;
d125 2
d128 6
d135 41
a175 1
	  switch (status)
d177 2
a178 25
	    case STATUS_NO_EAS_ON_FILE:
	      ret = 0;
	      break;
	    case STATUS_INVALID_DEVICE_REQUEST:
	      set_errno (ENOTSUP);
	      break;
	    case STATUS_NOT_FOUND:
	      /* STATUS_NOT_FOUND is returned when calling NtQueryEaFile on NFS.
		 In theory this should mean that the file just has no EAs, but
		 in fact NFS doesn't support EAs, other than the EAs which are
		 used for NFS requests.  We're playing safe and convert
		 STATUS_NOT_FOUND to ENOATTR, unless we're on NFS, where we
		 convert it to ENOTSUP. */
	      set_errno (pc.fs_is_nfs () ? ENOTSUP : ENOATTR);
	      break;
	    case STATUS_NONEXISTENT_EA_ENTRY:
	      /* Actually STATUS_NONEXISTENT_EA_ENTRY is either never generated,
		 or it was only generated in some old and long forgotton NT
		 version.  See below.  For safty reasons, we handle it here,
		 nevertheless. */
	      set_errno (ENOATTR);
	      break;
	    default:
	      __seterrno_from_nt_status (status);
	      break;
d180 2
a181 1
	  __leave;
d183 6
a188 1
      if (name)
d190 1
a190 10
	  /* Another weird behaviour of NtQueryEaFile.  If you ask for a
	     specific EA which is not present in the file's EA list, you don't
	     get a useful error code like STATUS_NONEXISTENT_EA_ENTRY.  Rather
	     NtQueryEaFile returns success with the entry's EaValueLength
	     set to 0. */
	  if (!fea->EaValueLength)
	    {
	      set_errno (ENOATTR);
	      __leave;
	    }
d193 1
a193 1
	      if (size < fea->EaValueLength)
d196 1
a196 1
		  __leave;
d198 15
a212 2
	      memcpy (value, fea->EaName + fea->EaNameLength + 1,
		      fea->EaValueLength);
d214 5
a218 39
	  ret = fea->EaValueLength;
	}
      else
	{
	  ret = 0;
	  do
	    {
	      fea->EaNameLength += 5;	/* "user." */
	      if (size > 0)
		{
		  if ((size_t) ret + fea->EaNameLength + 1 > size)
		    {
		      set_errno (ERANGE);
		      __leave;
		    }
		  /* For compatibility with Linux, we always prepend "user." to
		     the attribute name, so effectively we only support user
		     attributes from a application point of view. */
		  char tmpbuf[MAX_EA_NAME_LEN * 2];
		  char *tp = stpcpy (tmpbuf, "user.");
		  stpcpy (tp, fea->EaName);
		  /* NTFS stores all EA names in uppercase unfortunately.  To
		     keep compatibility with ext/xfs EA namespaces and
		     accompanying tools, which expect the namespaces to be
		     lower case, we return EA names in lowercase if the file
		     is on a native NTFS. */
		  if (pc.fs_is_ntfs ())
		    strlwr (tp);
		  tp = stpcpy (value, tmpbuf) + 1;
		  ret += tp - value;
		  value = tp;
		}
	      else
		ret += fea->EaNameLength + 1;
	      strcpy (lastname, fea->EaName);
	      status = NtQueryEaFile (h, &io, fea, EA_BUFSIZ, TRUE, NULL, 0,
				      NULL, FALSE);
	    }
	  while (NT_SUCCESS (status) && strcmp (lastname, fea->EaName) != 0);
d220 1
d222 4
a225 4
  __except (EFAULT) {}
  __endtry
  if (!hdl && h)
    NtClose (h);
d244 13
a256 1
  __try
d258 9
a266 1
      pc.get_object_attr (attr, sec_none_nih);
d268 7
a274 2
      debug_printf ("write_ea (%S, %s, %p, %lu, %d)",
		    attr.ObjectName, name, value, size, flags);
d276 4
a279 14
      /* Early open if handle is NULL.  This allows to return error codes like
	 ENOENT before we actually check for the correctness of the EA name and
	 stuff like that. */
      if (!hdl)
	{
	  status = NtOpenFile (&h, READ_CONTROL | FILE_WRITE_EA, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      __leave;
	    }
	}
d281 3
a283 3
      /* For compatibility with Linux, we only allow user xattrs and
	 return ENOTSUP otherwise. */
      if (!ascii_strncasematch (name, "user.", 5))
d285 2
a286 2
	  set_errno (ENOTSUP);
	  __leave;
d288 2
a289 7

      /* removexattr is supposed to fail with ENOATTR if the requested EA is
	 not available.  This is equivalent to XATTR_REPLACE for setxattr. */
      if (!value)
	flags = XATTR_REPLACE;

      if (flags)
d291 2
a292 13
	  if (flags != XATTR_CREATE && flags != XATTR_REPLACE)
	    {
	      set_errno (EINVAL);
	      __leave;
	    }
	  ssize_t rret = read_ea (hdl, pc, name, NULL, 0);
	  if (flags == XATTR_CREATE && rret > 0)
	    {
	      set_errno (EEXIST);
	      __leave;
	    }
	  if (flags == XATTR_REPLACE && rret < 0)
	    __leave;
d294 3
d298 2
a299 2
      /* Skip "user." prefix. */
      name += 5;
d301 14
a314 14
      if ((nlen = strlen (name)) >= MAX_EA_NAME_LEN)
	{
	  set_errno (EINVAL);
	  __leave;
	}
      flen = sizeof (FILE_FULL_EA_INFORMATION) + nlen + 1 + size;
      fea = (PFILE_FULL_EA_INFORMATION) alloca (flen);
      fea->NextEntryOffset = 0;
      fea->Flags = 0;
      fea->EaNameLength = nlen;
      fea->EaValueLength = size;
      strcpy (fea->EaName, name);
      if (value)
	memcpy (fea->EaName + fea->EaNameLength + 1, value, size);
d316 3
a318 1
      while (true)
d320 2
a321 11
	  if (h)
	    {
	      status = NtSetEaFile (h, &io, fea, flen);
	      if (status != STATUS_ACCESS_DENIED || !hdl)
		break;
	      pc.init_reopen_attr (attr, h);
	    }
	  status = NtOpenFile (&h, READ_CONTROL | FILE_WRITE_EA, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT);
	  if (!NT_SUCCESS (status))
a322 1
	  hdl = NULL;
d324 2
d327 6
d334 18
a351 21
	  switch (status)
	    {
	    case STATUS_EA_TOO_LARGE:
	      /* STATUS_EA_TOO_LARGE has a matching Win32 error code
		 ERROR_EA_TABLE_FULL.  For some reason RtlNtStatusToDosError
		 does not translate STATUS_EA_TOO_LARGE to ERROR_EA_TABLE_FULL,
		 but instead to ERROR_EA_LIST_INCONSISTENT.  This error code is
		 also returned for STATUS_EA_LIST_INCONSISTENT, which means the
		 incoming EA list is... inconsistent.  For obvious reasons we
		 translate ERROR_EA_LIST_INCONSISTENT to EINVAL, so we have to
		 handle STATUS_EA_TOO_LARGE explicitely here, to get the correct
		 mapping to ENOSPC. */
	      set_errno (ENOSPC);
	      break;
	    case STATUS_INVALID_DEVICE_REQUEST:
	      set_errno (ENOTSUP);
	      break;
	    default:
	      __seterrno_from_nt_status (status);
	      break;
	    }
a352 2
      else
	ret = 0;
d354 6
a359 4
  __except (EFAULT) {}
  __endtry
  if (!hdl && h)
    NtClose (h);
@


1.27
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d33 1
a33 1
ssize_t __stdcall
d219 1
a219 1
int __stdcall
@


1.26
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d3 2
a4 1
   Copyright 1997, 1998, 2000, 2001, 2006, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.26.2.1
log
@Pull in changes from HEAD
@
text
@d3 1
a3 2
   Copyright 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009,
   2010, 2011 Red Hat, Inc.
@


1.25
log
@	* ntdll.h (STATUS_NOT_FOUND): Define.
	* ntea.cc (read_ea): Return correct ENOTSUP rather than EOPNOTSUPP.
	Handle STATUS_INVALID_DEVICE_REQUEST and STATUS_NOT_FOUND.  Explain
	why.  Convert conditional to switch statement.
	(write_ea): Return correct ENOTSUP rather than EOPNOTSUPP.  Handle
	STATUS_INVALID_DEVICE_REQUEST.  Convert conditional to switch statement.
@
text
@d213 1
a213 1
  debug_printf ("%d = read_ea (%S, %s, %p, %lu)",
d347 1
a347 1
  debug_printf ("%d = write_ea (%S, %s, %p, %lu, %d)",
@


1.24
log
@whitespace elimination
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001, 2006, 2008, 2009, 2010 Red Hat, Inc.
d81 1
a81 1
	 return EOPNOTSUPP otherwise. */
d86 1
a86 1
	  set_errno (EOPNOTSUPP);
d120 26
a145 8
      if (status == STATUS_NO_EAS_ON_FILE)
	ret = 0;
      else if (status == STATUS_NONEXISTENT_EA_ENTRY)
	/* Actually this error code is either never generated, or it was only
	   generated in some old and long forgotton NT version.  See below. */
	set_errno (ENOATTR);
      else
	__seterrno_from_nt_status (status);
d256 1
a256 1
     return EOPNOTSUPP otherwise. */
d259 1
a259 1
      set_errno (EOPNOTSUPP);
d319 21
a339 12
      /* STATUS_EA_TOO_LARGE has a matching Win32 error ERROR_EA_TABLE_FULL.
	 Too bad RtlNtStatusToDosError does not translate STATUS_EA_TOO_LARGE
	 to ERROR_EA_TABLE_FULL, but to ERROR_EA_LIST_INCONSISTENT.  This
	 error code is also returned for STATUS_EA_LIST_INCONSISTENT, which
	 means the incoming EA list is... inconsistent.  For obvious reasons
	 we translate ERROR_EA_LIST_INCONSISTENT to EINVAL, so we have to
	 handle STATUS_EA_TOO_LARGE explicitely here, to get the correct
	 mapping to ENOSPC. */
      if (status == STATUS_EA_TOO_LARGE)
	set_errno (ENOSPC);
      else
	__seterrno_from_nt_status (status);
@


1.23
log
@	* dtable.cc (build_fh_name_worker): Remove.  Move all functionality
	back into build_fh_name.
	(build_fh_name): Drop unused HANDLE parameter.  Drop call to pc.fillin.
	Remove disabled build_fh_name with UNICODE_STRING name parameter.
	* dtable.h (build_fh_name): Drop HANDLE parameter from declaration.
	Remove declaration for build_fh_name with UNICODE_STRING name parameter.
	* path.cc (path_conv::fillin): Remove.
	(symlink_info::check): Fix comment.
	* path.h (path_conv::fillin): Remove declaration.
	* dir.cc: Accommodate change in build_fh_name parameters throughout.
	* sec_acl.cc: Ditto.
	* syscalls.cc: Ditto.

	* ntea.cc (getxattr_worker): Fix debug output.
	(setxattr_worker): Ditto.
	* times.cc (utimens_worker): Ditto.
@
text
@d81 1
a81 1
         return EOPNOTSUPP otherwise. */
@


1.22
log
@	* ntea.cc (read_ea): Always add length of "user." prefix, not only
	on Samba.  Change comment.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001, 2006, 2008 Red Hat, Inc.
d332 1
a332 1
      debug_printf ("got %d error from build_fh_name", pc.error);
d427 1
a427 1
      debug_printf ("got %d error from build_fh_name", pc.error);
@


1.21
log
@	* ntea.cc (read_ea): Try to open file first to have more sensible
	error codes.  Always refuse non "user." EAs for Linux compatibility
	and return EOPNOTSUPP.  Fix handling of empty (== non-existant) EAs.
	Always prepend "user." prefix to EA names.
	(write_ea): Try to open file first to have more sensible error codes.
	Always refuse non "user." EAs for Linux compatibility and return
	EOPNOTSUPP.  Delay skipping "user." prefix until after potential call
	to read_ea.
@
text
@d159 1
a159 2
	  if (pc.fs_is_samba ())	/* See below. */
	    fea->EaNameLength += 5;
d167 5
a171 5
	      /* Samba hides the user namespace from Windows clients.  We add
		 it in EA listings to keep tools like attr/getfattr/setfattr
		 happy. */
	      char tmpbuf[MAX_EA_NAME_LEN * 2], *tp = tmpbuf;
	      tp = stpcpy (tmpbuf, "user.");
@


1.20
log
@* ntea.c (write_ea): Don't abort if not-samba.
@
text
@d59 15
d80 3
a82 6
      /* Samba hides the user namespace from Windows clients.  If we try to
	 retrieve a user namespace item, we remove the leading namespace from
	 the name, otherwise the search fails. */
      if (!pc.fs_is_samba ())
	/* nothing to do */;
      else if (ascii_strncasematch (name, "user.", 5))
d86 1
a86 1
	  set_errno (ENOATTR);
d132 10
d149 2
a150 13
	  /* Another weird behaviour of ZwQueryEaFile.  If you ask for a
	     specific EA which is not present in the file's EA list, you don't
	     get a useful error code like STATUS_NONEXISTENT_EA_ENTRY.  Rather
	     ZwQueryEaFile returns success with the entry's EaValueLength
	     set to 0. */
	  if (!fea->EaValueLength)
	    {
	      set_errno (ENOATTR);
	      goto out;
	    }
	  else
	    memcpy (value, fea->EaName + fea->EaNameLength + 1,
		    fea->EaValueLength);
d172 1
a172 2
	      if (pc.fs_is_samba ())
		tp = stpcpy (tmpbuf, "user.");
d223 18
a240 12
  /* Samba hides the user namespace from Windows clients.  If we get a
     user namespace item, we remove the leading namespace from the name.
     This keeps tools like attr/getfattr/setfattr happy.  Otherwise
     setting the EA fails as if we don't have the permissions. */
      /* Samba hides the user namespace from Windows clients.  If we try to
	 retrieve a user namespace item, we remove the leading namespace from
	 the name, otherwise the search fails. */
  if (!pc.fs_is_samba ())
    /* nothing to do */;
  else if (ascii_strncasematch (name, "user.", 5))
    name += 5;
  else
d242 1
a242 1
      set_errno (ENOATTR);
d268 3
@


1.19
log
@* localtime.cc (increment_overflow): Mark as non-inline to prevent compiler
from complaining about the very thing we're trying to test.
* ntea.cc (read_ea): Reorganize to avoid a new compiler warning/error.
* sched.cc (sched_rr_get_interval): Ditto.
* select.cc (peek_serial): Ditto.
* libc/rexec.cc (ruserpass): Ditto.
* posix_ipc.cc (ipc_names): Make static to avoid a compiler warning
(and it's the right thing to do anyway).
@
text
@d217 6
a222 1
  if (pc.fs_is_samba () && ascii_strncasematch (name, "user.", 5))
d226 1
a226 1
      set_errno (EOPNOTSUPP);
@


1.18
log
@Remove unneeded header files from source files throughout.
@
text
@d68 9
a76 8
      if (pc.fs_is_samba ())
	if (ascii_strncasematch (name, "user.", 5))
	  name += 5;
	else
	  {
	    set_errno (ENOATTR);
	    goto out;
	  }
@


1.17
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@a12 1
#include "cygerrno.h"
a16 1
#include "pinfo.h"
a17 1
#include <ntdef.h>
@


1.16
log
@	* Makefile.in (DLL_OFILES): Add ntea.o.
	* cygwin.din (getxattr, listxattr, removexattr, setxattr, lgetxattr,
	llistxattr, lremovexattr, lsetxattr, fgetxattr, flistxattr,
	fremovexattr, fsetxattr): Export Linux extended attribute functions.
	Sort.
	* errno.cc (errmap): Add mappings for ERROR_EAS_DIDNT_FIT,
	ERROR_EAS_NOT_SUPPORTED, ERROR_EA_LIST_INCONSISTENT,
	ERROR_EA_TABLE_FULL, ERROR_FILE_CORRUPT, ERROR_INVALID_EA_NAME.
	* fhandler.h (class fhandler_base): Declare new fgetxattr and
	fsetxattr methods.
	(class fhandler_disk_file): Ditto.
	* fhandler.cc (fhandler_base::fgetxattr): New method.
	(fhandler_base::fsetxattr): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::fgetxattr): New method.
	(fhandler_disk_file::fsetxattr): New method.
	* ntdll.h (STATUS_EA_TOO_LARGE): Define.
	(STATUS_NONEXISTENT_EA_ENTRY): Define.
	(STATUS_NO_EAS_ON_FILE): Define.
	* ntea.cc (read_ea): Rewrite for long pathnames and for using with
	Linux extended attribute functions.
	(write_ea): Ditto.
	(getxattr_worker): New static function.
	(getxattr): New function.
	(lgetxattr): New function.
	(fgetxattr): New function.
	(listxattr): New function.
	(llistxattr): New function.
	(flistxattr): New function.
	(setxattr_worker): New static function.
	(setxattr): New function.
	(lsetxattr): New function.
	(fsetxattr): New function.
	(removexattr): New function.
	(lsetxattr): New function.
	(fsetxattr): New function.
	* security.h (read_ea): Change declaration according to above changes.
	(write_ea): Ditto.
	* include/cygwin/version.h: Bump API minor version.
@
text
@d60 1
a60 1
  		attr.ObjectName, name, value, size);
d63 1
a63 1
  
d81 1
a81 1
        {
d115 1
a115 1
        set_errno (ENOATTR);
d149 1
a149 1
        {
d189 1
a189 1
  		ret, attr.ObjectName, name, value, size);
d213 1
a213 1
  		attr.ObjectName, name, value, size, flags);
d241 1
a241 1
        {
d300 1
a300 1
  		ret, attr.ObjectName, name, value, size, flags);
d319 1
a319 1
        return -1;
d414 1
a414 1
        return -1;
@


1.15
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d1 1
a1 1
/* ntea.cc: code for manipulating NTEA information
d3 1
a3 3
   Copyright 1997, 1998, 2000, 2001, 2006 Red Hat, Inc.

   Written by Sergey S. Okhapkin (sos@@prospect.com.ru)
d12 8
a19 1
#include <stdlib.h>
a20 1
#include "security.h"
d22 2
d25 2
a26 2
/* Default to not using NTEA information */
bool allow_ntea;
d28 3
a30 13
/*
 * read_ea - read file's Extended Attribute.
 *
 * Parameters:
 *	file	- pointer to filename
 *	attrname- pointer to EA name (case insensitiv)
 *	attrbuf - pointer to buffer to store EA's value.
 *	len	- length of attrbuf.
 * Return value:
 *	0	- if file or attribute "attrname" not found.
 *	N	- number of bytes stored in attrbuf if success.
 *	-1	- attrbuf too small for EA value.
 */
d32 5
a36 3
int __stdcall
read_ea (HANDLE hdl, const char *file, const char *attrname, char *attrbuf,
	 int len)
d38 2
d41 51
a92 19
  /* Prepare buffer which receives the result. */
  ULONG flen = sizeof (FILE_FULL_EA_INFORMATION) + strlen (attrname)
	       + len + 1;
  PFILE_FULL_EA_INFORMATION fea = (PFILE_FULL_EA_INFORMATION) alloca (flen);
  /* Prepare buffer specifying the EA to search for. */
  ULONG glen = sizeof (FILE_GET_EA_INFORMATION) + strlen (attrname);
  PFILE_GET_EA_INFORMATION gea = (PFILE_GET_EA_INFORMATION) alloca (glen);
  gea->NextEntryOffset = 0;
  gea->EaNameLength = strlen (attrname);
  strcpy (gea->EaName, attrname);

  /* If no incoming hdl is given, the loop only runs once, trying to
     open the file and to query the EA.  If an incoming hdl is given,
     the loop runs twice, first trying to query with the given hdl.
     If this fails it tries to open the file and to query with that
     handle again. */
  HANDLE h = hdl;
  NTSTATUS status = STATUS_SUCCESS;
  int ret = 0;
d95 1
a95 5
      if (!hdl && (h = CreateFile (file, FILE_READ_EA,
				   FILE_SHARE_READ | FILE_SHARE_WRITE,
				   &sec_none_nih, OPEN_EXISTING,
				   FILE_FLAG_BACKUP_SEMANTICS, NULL))
		  == INVALID_HANDLE_VALUE)
d97 4
a100 3
	  debug_printf ("Opening %s for querying EA %s failed, %E",
			file, attrname);
	  goto out;
d102 3
a104 2
      status = NtQueryEaFile (h, &io, fea, flen, FALSE, gea, glen, NULL, TRUE);
      if (NT_SUCCESS (status) || !hdl)
a105 2
      debug_printf ("1. chance, %x = NtQueryEaFile (%s, %s), Win32 error %d",
		    status, file, attrname, RtlNtStatusToDosError (status));
a107 2
  if (!hdl)
    CloseHandle (h);
d110 34
a143 3
      ret = -1;
      debug_printf ("%x = NtQueryEaFile (%s, %s), Win32 error %d",
		    status, file, attrname, RtlNtStatusToDosError (status));
a144 2
  if (!fea->EaValueLength)
    ret = 0;
d147 36
a182 3
      memcpy (attrbuf, fea->EaName + fea->EaNameLength + 1,
	      fea->EaValueLength);
      ret = fea->EaValueLength;
d186 4
a189 2
  debug_printf ("%d = read_ea (%x, %s, %s, %x, %d)", ret, hdl, file, attrname,
		attrbuf, len);
d193 3
a195 16
/*
 * write_ea - write file's Extended Attribute.
 *
 * Parameters:
 *	file	- pointer to filename
 *	attrname- pointer to EA name (case insensitiv)
 *	attrbuf	- pointer to buffer with EA value.
 *	len	- length of attrbuf.
 * Return value:
 *	true if success, false otherwice.
 * Note: if len=0 given EA will be deleted.
 */

BOOL __stdcall
write_ea (HANDLE hdl, const char *file, const char *attrname,
	  const char *attrbuf, int len)
d197 2
d200 31
d232 24
a255 4
  /* Prepare buffer specifying the EA to write back. */
  ULONG flen = sizeof (FILE_FULL_EA_INFORMATION) + strlen (attrname)
	       + len + 1;
  PFILE_FULL_EA_INFORMATION fea = (PFILE_FULL_EA_INFORMATION) alloca (flen);
d258 6
a263 13
  fea->EaNameLength = strlen (attrname);
  fea->EaValueLength = len;
  strcpy (fea->EaName, attrname);
  memcpy (fea->EaName + fea->EaNameLength + 1, attrbuf, len);

  /* If no incoming hdl is given, the loop only runs once, trying to
     open the file and to set the EA.  If an incoming hdl is given,
     the loop runs twice, first trying to set the EA with the given hdl.
     If this fails it tries to open the file and to set the EA with that
     handle again. */
  HANDLE h = hdl;
  NTSTATUS status = STATUS_SUCCESS;
  bool ret = false;
d266 1
a266 5
      if (!hdl && (h = CreateFile (file, FILE_READ_EA,
				   FILE_SHARE_READ | FILE_SHARE_WRITE,
				   &sec_none_nih, OPEN_EXISTING,
				   FILE_FLAG_BACKUP_SEMANTICS, NULL))
		  == INVALID_HANDLE_VALUE)
d268 3
a270 3
	  debug_printf ("Opening %s for setting EA %s failed, %E",
			file, attrname);
	  goto out;
d272 3
a274 2
      status = NtSetEaFile (h, &io, fea, flen);
      if (NT_SUCCESS (status) || !hdl)
a275 2
      debug_printf ("1. chance, %x = NtQueryEaFile (%s, %s), Win32 error %d",
		    status, file, attrname, RtlNtStatusToDosError (status));
a277 2
  if (!hdl)
    CloseHandle (h);
d279 14
a292 2
    debug_printf ("%x = NtQueryEaFile (%s, %s), Win32 error %d",
		  status, file, attrname, RtlNtStatusToDosError (status));
d294 1
a294 1
    ret = true;
d297 4
a300 2
  debug_printf ("%d = write_ea (%x, %s, %s, %x, %d)", ret, hdl, file, attrname,
		attrbuf, len);
d303 191
@


1.14
log
@	* autoload.cc (NtQueryEaFile): Define.
	(NtSetEaFile): Define.
	* fhandler.cc (fhandler_base::open): Use appropriate open flags
	in query case when allow_ntea is set.
	* ntdll.h (struct _FILE_GET_EA_INFORMATION): Define.
	(struct _FILE_FULL_EA_INFORMATION): Define.
	(NtQueryEaFile): Declare.
	(NtSetEaFile): Declare.
	* ntea.cc (read_ea): Rename from NTReadEA and rewrite using
	NtQueryEaFile.
	(write_ea): Rename from NTWriteEA and rewrite using NtSetEaFile.
	* path.cc (get_symlink_ea): Make static.  Add handle parameter to
	accomodate new read_ea call.
	(set_symlink_ea): Make static.  Add handle parameter to accomodate new
	write_ea call.
	(symlink_worker): Call set_symlink_ea while file is still open.
	(symlink_info::check): Call get_symlink_ea after file has been opened.
	* security.cc (get_file_attribute): Accomodate new read_ea call.
	(set_file_attribute): Accomodate new write_ea call.
	* security.h (read_ea): Change declaration accordingly.
	(write_ea): Ditto.
@
text
@d70 1
a70 1
	  		file, attrname);
d75 1
a75 1
        break;
d99 1
a99 1
  		attrbuf, len);
d150 1
a150 1
	  		file, attrname);
d155 1
a155 1
        break;
d170 1
a170 1
  		attrbuf, len);
@


1.13
log
@	* mmap.cc (mmap64): Avoid compiler warning.
	* ntea.cc (NTReadEA): Ditto.
	* hires.h (hires_base): Remove useless usecs function.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000, 2001 Red Hat, Inc.
a13 1
#include <stdio.h>
d15 1
d17 1
d23 1
a23 50
From Windows NT DDK:

FILE_FULL_EA_INFORMATION provides extended attribute information.
This structure is used primarily by network drivers.

Members

NextEntryOffset
The offset of the next FILE_FULL_EA_INFORMATION-type entry. This member is
zero if no other entries follow this one.

Flags
Can be zero or can be set with FILE_NEED_EA, indicating that the file to which
the EA belongs cannot be interpreted without understanding the associated
extended attributes.

EaNameLength
The length in bytes of the EaName array. This value does not include a
zero-terminator to EaName.

EaValueLength
The length in bytes of each EA value in the array.

EaName
An array of characters naming the EA for this entry.

Comments
This structure is longword-aligned. If a set of FILE_FULL_EA_INFORMATION
entries is buffered, NextEntryOffset value in each entry, except the last,
falls on a longword boundary.
The value(s) associated with each entry follows the EaName array. That is, an
EA's values are located at EaName + (EaNameLength + 1).
*/

typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

/* Functions prototypes */

int NTReadEA (const char *file, const char *attrname, char *buf, int len);
static PFILE_FULL_EA_INFORMATION NTReadEARaw (HANDLE file, int *len);
BOOL NTWriteEA(const char *file, const char *attrname, char *buf, int len);

/*
 * NTReadEA - read file's Extended Attribute.
d27 1
a27 2
 *	attrname- pointer to EA name (case insensitivy. EAs are sored in upper
 *		  case).
d32 1
a32 1
 *	N	- number of bytes stored in attrbuf if succes.
d37 2
a38 1
NTReadEA (const char *file, const char *attrname, char *attrbuf, int len)
d40 1
a40 44
    HANDLE hFileSource;
    int eafound = 0;
    PFILE_FULL_EA_INFORMATION ea, sea;
    int easize = 0;

    hFileSource = CreateFile (file, FILE_READ_EA,
			      FILE_SHARE_READ | FILE_SHARE_WRITE,
			      &sec_none_nih, // sa
			      OPEN_EXISTING,
			      FILE_FLAG_BACKUP_SEMANTICS,
			      NULL);

    if (hFileSource == INVALID_HANDLE_VALUE)
	return 0;

    /* Read in raw array of EAs */
    ea = sea = NTReadEARaw (hFileSource, &easize);

    /* Search for requested attribute */
    while (sea)
      {
	if (strcasematch (ea->EaName, attrname)) /* EA found */
	  {
	    if (ea->EaValueLength > len)
	      {
		eafound = -1;		/* buffer too small */
		break;
	      }
	    memcpy (attrbuf, ea->EaName + (ea->EaNameLength + 1),
		    ea->EaValueLength);
	    eafound = ea->EaValueLength;
	    break;
	  }
	if ((ea->NextEntryOffset == 0) || ((int) ea->NextEntryOffset > easize))
	  break;
	ea = (PFILE_FULL_EA_INFORMATION) ((char *) ea + ea->NextEntryOffset);
      }

    if (sea)
      free (sea);
    CloseHandle (hFileSource);

    return eafound;
}
d42 20
a61 31
/*
 * NTReadEARaw - internal routine to read EAs array to malloced buffer. The
 *		 caller should free this buffer after usage.
 * Parameters:
 *	hFileSource - handle to file. This handle should have FILE_READ_EA
 *		      rights.
 *	len	    - pointer to int variable where length of buffer will
 *		      be stored.
 * Return value:
 *	pointer to buffer with file's EAs, or NULL if any error occured.
 */

static PFILE_FULL_EA_INFORMATION
NTReadEARaw (HANDLE hFileSource, int *len)
{
  WIN32_STREAM_ID StreamId;
  DWORD dwBytesWritten;
  LPVOID lpContext;
  DWORD StreamSize;
  PFILE_FULL_EA_INFORMATION eafound = NULL;

  lpContext = NULL;
  StreamSize = sizeof (WIN32_STREAM_ID) - sizeof (WCHAR**);

  /* Read the WIN32_STREAM_ID in */

  while (BackupRead (hFileSource, (LPBYTE) &StreamId, StreamSize,
		     &dwBytesWritten,
		     FALSE,		// don't abort yet
		     FALSE,		// don't process security
		     &lpContext))
d63 5
a67 6
      DWORD sl,sh;

      if (dwBytesWritten == 0) /* No more Stream IDs */
	break;
      /* skip StreamName */
      if (StreamId.dwStreamNameSize)
d69 3
a71 17
	  unsigned char *buf;
	  buf = (unsigned char *) malloc (StreamId.dwStreamNameSize);

	  if (buf == NULL)
	    break;

	  if (!BackupRead (hFileSource, buf,  // buffer to read
			   StreamId.dwStreamNameSize,   // num bytes to read
			   &dwBytesWritten,
			   FALSE,		// don't abort yet
			   FALSE,		// don't process security
			   &lpContext))		// Stream name read error
	    {
	      free (buf);
	      break;
	    }
	  free (buf);
d73 22
a94 31

	/* Is it EA stream? */
	if (StreamId.dwStreamId == BACKUP_EA_DATA)
	  {
	    unsigned char *buf;
	    buf = (unsigned char *) malloc (StreamId.Size.LowPart);

	    if (buf == NULL)
	      break;
	    if (!BackupRead (hFileSource, buf,	// buffer to read
			     StreamId.Size.LowPart, // num bytes to write
			     &dwBytesWritten,
			     FALSE,		// don't abort yet
			     FALSE,		// don't process security
			     &lpContext))
	      {
		free (buf);	/* EA read error */
		break;
	      }
	    eafound = (PFILE_FULL_EA_INFORMATION) buf;
	    *len = StreamId.Size.LowPart;
	    break;
	}
	/* Skip current stream */
	if (!BackupSeek (hFileSource,
			 StreamId.Size.LowPart,
			 StreamId.Size.HighPart,
			 &sl,
			 &sh,
			 &lpContext))
	  break;
d97 4
a100 11
  /* free context */
  BackupRead (
      hFileSource,
      NULL,		// buffer to write
      0,		// number of bytes to write
      &dwBytesWritten,
      TRUE,		// abort
      FALSE,		// don't process security
      &lpContext);

  return eafound;
d104 1
a104 1
 * NTWriteEA - write file's Extended Attribute.
d108 3
a110 4
 *	attrname- pointer to EA name (case insensitivy. EAs are sored in upper
 *		  case).
 *	buf	- pointer to buffer with EA value.
 *	len	- length of buf.
d117 2
a118 1
NTWriteEA (const char *file, const char *attrname, const char *buf, int len)
d120 1
a120 70
  HANDLE hFileSource;
  WIN32_STREAM_ID StreamId;
  DWORD dwBytesWritten;
  LPVOID lpContext;
  DWORD StreamSize, easize;
  bool bSuccess = false;
  PFILE_FULL_EA_INFORMATION ea;

  hFileSource = CreateFile (file, FILE_WRITE_EA,
			    FILE_SHARE_READ | FILE_SHARE_WRITE,
			    &sec_none_nih, // sa
			    OPEN_EXISTING,
			    FILE_FLAG_BACKUP_SEMANTICS,
			    NULL);

  if (hFileSource == INVALID_HANDLE_VALUE)
    return FALSE;

  lpContext = NULL;
  StreamSize = sizeof (WIN32_STREAM_ID) - sizeof (WCHAR**);

  /* FILE_FULL_EA_INFORMATION structure is longword-aligned */
  easize = sizeof (*ea) - sizeof (WCHAR**) + strlen (attrname) + 1 + len
      + (sizeof (DWORD) - 1);
  easize &= ~(sizeof (DWORD) - 1);

  if ((ea = (PFILE_FULL_EA_INFORMATION) malloc (easize)) == NULL)
    goto cleanup;

  memset (ea, 0, easize);
  ea->EaNameLength = strlen (attrname);
  ea->EaValueLength = len;
  strcpy (ea->EaName, attrname);
  memcpy (ea->EaName + (ea->EaNameLength + 1), buf, len);

  StreamId.dwStreamId = BACKUP_EA_DATA;
  StreamId.dwStreamAttributes = 0;
  StreamId.Size.HighPart = 0;
  StreamId.Size.LowPart = easize;
  StreamId.dwStreamNameSize = 0;

  if (!BackupWrite (hFileSource, (LPBYTE) &StreamId, StreamSize,
		    &dwBytesWritten,
		    FALSE,		// don't abort yet
		    FALSE,		// don't process security
		    &lpContext))
    goto cleanup;

  if (!BackupWrite (hFileSource, (LPBYTE) ea, easize,
		    &dwBytesWritten,
		    FALSE,		// don't abort yet
		    FALSE,		// don't process security
		    &lpContext))
    goto cleanup;

  bSuccess = true;
  /* free context */

cleanup:
  BackupRead (hFileSource,
	      NULL,			// buffer to write
	      0,			// number of bytes to write
	      &dwBytesWritten,
	      TRUE,			// abort
	      FALSE,			// don't process security
	      &lpContext);

  CloseHandle (hFileSource);
  if (ea)
    free (ea);
d122 50
a171 1
  return bSuccess;
@


1.12
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d91 1
a91 1
    int easize;
@


1.11
log
@* Makefile.in: Remove cygserver stuff.
* acconfig.h: Add USE_CYGSERVER define.
* config.h.in: Regenerate.
* configure.in: Add --enable-server setting.
* configure: Regenerate.
* fhandler_tty.cc (fhandler_tty_slave::open): Conditionalize compilation of
cygserver stuff.
* fork.cc (fork_child): Ditto.
* shm.cc: Ditto.
* tty.cc (tty::common_init): Ditto.
* dcrt0.cc: Use bool rather than BOOL for CYGWIN environment variable
definitions.
* environ.cc: Ditto.
* ntea.cc: Ditto.
* security.cc: Ditto.
* security.h: Ditto.
* syscalls.cc (check_posix_perm): Remove externs that were already declared in
a header.
* winsup.h: Ditto.  Declare _MT_SAFE here.  Delete it someday since cygwin
should always be _MT_SAFE.
@
text
@d246 1
a246 1
 *	TRUE if success, FALSE otherwice.
d258 1
a258 1
  BOOL bSuccess=FALSE;
d308 1
a308 1
  bSuccess = TRUE;
@


1.10
log
@Do some minor reformatting of 'extern "C"' use throughout.
* autoload.cc (GetSystemTimes): Define new autoload function.
* fhandler_proc.cc (proc_listing): Add cpuinfo and partitions entries.
(fhandler_proc::fill_filebuf): Add PROC_CPUINFO and PROC_PARTITIONS cases.
(format_proc_uptime): Use GetSystemTimes if available.
(read_value): New macro.
(print): New macro.
(cpuid): New function.
(can_set_flag): New function.
(format_proc_cpuinfo): New function.
(format_proc_partitions): New function.
@
text
@d19 1
a19 1
BOOL allow_ntea;
@


1.9
log
@Cleanup calls to CreateFile throughout.
* dcrt0.cc (__api_fatal): Correctly check for failing return from CreateFile.
* assert.cc (__assert): Don't check return value from CreateFile for NULL.
* fhandler_console.cc (set_console_state_for_spawn): Ditto.
* fork.cc (fork_parent): Ditto.
@
text
@d145 1
a145 2
static
PFILE_FULL_EA_INFORMATION
@


1.9.16.1
log
@merge from trunk
@
text
@d145 2
a146 1
static PFILE_FULL_EA_INFORMATION
@


1.9.16.2
log
@merge from trunk
@
text
@d19 1
a19 1
bool allow_ntea;
@


1.8
log
@Update copyrights.
@
text
@d94 5
a98 6
	FILE_SHARE_READ | FILE_SHARE_WRITE,
	&sec_none_nih, // sa
	OPEN_EXISTING,
	FILE_FLAG_BACKUP_SEMANTICS,
	NULL
	);
@


1.8.4.1
log
@Merged changes from HEAD
@
text
@d94 6
a99 5
			      FILE_SHARE_READ | FILE_SHARE_WRITE,
			      &sec_none_nih, // sa
			      OPEN_EXISTING,
			      FILE_FLAG_BACKUP_SEMANTICS,
			      NULL);
@


1.7
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d3 1
a3 1
   Copyright 1997, 1998, 2000 Cygnus Solutions.
@


1.6
log
@forced commit
@
text
@d19 1
a19 1
BOOL allow_ntea = FALSE;
@


1.5
log
@* security.h (NTWriteEA): Change prototype.
* ntea.cc (NTReadEA): Don't check for global ntea setting, now
it's caller responsibility.
(NTWriteEA): Ditto.
* security.cc (get_file_attribute): Read attribute from EA only
if 'ntea' is enabled.
(set_file_attribute): Ditto.
* path.h: (class path_conv): Add members to store file system
information.
(path_conv::get_drive_type): New function.
* syscalls.cc (stat_worker): Use it.
* path.cc (path_conv::update_fs_info): New functions.
(path_conv::check): Get file system information from device where
file resides. On NTFS, try to read symlink contents from EA.
(get_symlink_ea): New function.
(set_symlink_ea): Ditto.
(symlink): Store symlink in extended attribute, if possible.
@
text
@@


1.4
log
@* path.cc (chdir): Always send unsigned chars to isspace since newlib's isspace
doesn't deal well with "negative" chars.
* fhandler.cc (fhandler_disk_file::open): Propagate remote status of file
garnered from path_conv.  Move #! checking to fstat.
(fhandler_disk_file::fstat): Reorganize st_mode setting to eliminate
duplication.  Move check for #! here from fhandler::open.
* fhandler.h (fhandler_base::isremote): New method.
(fhandler_base::set_isremote): Ditto.
(fhandler_base::set_execable_p): Also record "don't care if executable state".
(fhandler_base::dont_care_if_execable): New method.
* path.cc (path_conv::check): Clear new flags.  Appropriately set vol_flags,
drive_type, and is_remote_drive.
* path.h: Add new flags and methods for manipulating them.
* syscalls.cc (_unlink): Use isremote() to determine if a path is remote rather
than calling GetDriveType.
(stat_worker): Ditto.
* security.cc (get_file_attribute): Or attribute with result of NTReadEA to be
consistent with get_nt_attribute.
@
text
@a87 4
    /* return immediately if NTEA usage is turned off */
    if (!allow_ntea)
      return FALSE;

d253 1
a253 1
NTWriteEA (const char *file, const char *attrname, char *buf, int len)
a254 4
  /* return immediately if NTEA usage is turned off */
  if (!allow_ntea)
    return TRUE;

@


1.3
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d89 1
a89 1
    if (! allow_ntea)
d260 1
a260 1
  if (! allow_ntea)
@


1.2
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d13 1
a13 1
#include <winsup.h>
d16 1
@


1.1
log
@Initial revision
@
text
@a15 1
#include <string.h>
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
