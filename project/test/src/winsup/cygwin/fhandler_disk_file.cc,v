head	1.405;
access;
symbols
	cygwin-1_7_35-release:1.405
	cygwin-1_7_34-release:1.404
	cygwin-1_7_33-release:1.394.2.2
	cygwin-1_7_32-release:1.394.2.1
	cygwin-1_7_31-release:1.394.2.1
	cygwin-1_7_30-release:1.394
	cygwin-1_7_29-release:1.394
	cygwin-1_7_29-release-branchpoint:1.394.0.2
	cygwin-pre-user-db:1.394
	cygwin-1_7_28-release:1.393
	cygwin-1_7_27-release:1.393
	cygwin-1_7_26-release:1.393
	cygwin-1_7_25-release:1.389
	cygwin-1_7_24-release:1.389
	cygwin-1_7_23-release:1.389
	cygwin-1_7_22-release:1.388
	cygwin-1_7_21-release:1.388
	cygwin-1_7_20-release:1.387
	cygwin-1_7_19-release:1.386
	cygwin-64bit-postmerge:1.383
	cygwin-64bit-premerge-branch:1.382.0.2
	cygwin-64bit-premerge:1.382
	cygwin-1_7_18-release:1.382
	post-ptmalloc3:1.379.2.9
	pre-ptmalloc3:1.379.2.9
	cygwin-1_7_17-release:1.379
	cygwin-64bit-branch:1.379.0.2
	cygwin-1_7_16-release:1.379
	cygwin-1_7_15-release:1.376
	cygwin-1_7_14_2-release:1.376
	cygwin-1_7_14-release:1.376
	cygwin-1_7_12-release:1.376
	cygwin-1_7_11-release:1.373
	cygwin-1_7_10-release:1.371
	signal-rewrite:1.364.0.2
	pre-notty:1.359
	cygwin-1_7_9-release:1.352
	cv-post-1_7_9:1.351.0.2
	cygwin-1_7_8-release:1.350
	cygwin-1_7_7-release:1.334
	cygwin-1_7_5-release:1.325
	cygwin-1_7_4-release:1.325
	cygwin-1_7_3-release:1.325
	cygwin-1_7_2-release:1.325
	fifo_doover3:1.318.0.2
	cygwin-1_7_1-release:1.318
	prefifo:1.303
	cv-branch-2:1.299.0.2
	pre-ripout-set_console_state_for_spawn:1.281
	EOL_registry_mounts:1.267
	preoverlapped:1.220
	drop_9x_support_start:1.205
	cr-0x5f1:1.185.0.4
	cv-branch:1.185.0.2
	pre-ptymaster-archetype:1.185
	cr-0x3b58:1.153.0.4
	cr-0x5ef:1.153.0.2
	after-mmap-privanon-noreserve:1.148
	after-mmap-revamp:1.148
	before-mmap-revamp:1.148
	cgf-more-exit-sync:1.146
	post_wait_sig_exit:1.142
	pre_wait_sig_exit:1.139
	reparent-point:1.93
	noreparent:1.93.0.2
	cr-0x5e6:1.90.0.2
	cr-0x9e:1.75.0.6
	cr-0x9d:1.75.0.4
	cgf-deleteme:1.75.0.2
	pre-sigrewrite:1.70
	corinna-01:1.68
	cr-0x9c:1.63.2.1.0.2
	cr-0x9b:1.63.0.2
	cr-0x99:1.59
	Z-emcb-cygwin_daemon:1.59.0.2
	w32api-2_2:1.39
	mingw-runtime-2_4:1.39
	pre-cgf-merge:1.64
	cgf-dev-branch:1.38.0.2
	predaemon:1.7
	cygwin_daemon_merge_HEAD:1.7
	pregp02r1:1.6.0.2
	cygnus_cvs_20020108_pre:1.4
	Z-cygwin_daemon_merge_HEAD:1.32
	cygwin_daemon:1.4.0.16
	Z-cygwin_daemon_merge-new_HEAD:1.32;
locks; strict;
comment	@// @;


1.405
date	2015.02.15.08.59.55;	author corinna;	state Exp;
branches;
next	1.404;

1.404
date	2014.10.09.13.32.59;	author corinna;	state Exp;
branches;
next	1.403;

1.403
date	2014.08.28.12.38.51;	author corinna;	state Exp;
branches;
next	1.402;

1.402
date	2014.08.28.12.29.42;	author corinna;	state Exp;
branches;
next	1.401;

1.401
date	2014.08.27.11.42.17;	author corinna;	state Exp;
branches;
next	1.400;

1.400
date	2014.08.26.20.47.46;	author corinna;	state Exp;
branches;
next	1.399;

1.399
date	2014.07.03.16.48.21;	author corinna;	state Exp;
branches;
next	1.398;

1.398
date	2014.06.25.09.10.50;	author corinna;	state Exp;
branches;
next	1.397;

1.397
date	2014.03.12.17.36.55;	author corinna;	state Exp;
branches;
next	1.396;

1.396
date	2014.02.11.11.51.29;	author corinna;	state Exp;
branches;
next	1.395;

1.395
date	2014.02.09.19.44.54;	author corinna;	state Exp;
branches;
next	1.394;

1.394
date	2014.02.06.20.38.34;	author corinna;	state Exp;
branches
	1.394.2.1;
next	1.393;

1.393
date	2013.10.31.14.26.42;	author corinna;	state Exp;
branches;
next	1.392;

1.392
date	2013.10.30.09.44.47;	author corinna;	state Exp;
branches;
next	1.391;

1.391
date	2013.10.25.15.33.51;	author corinna;	state Exp;
branches;
next	1.390;

1.390
date	2013.10.24.09.41.17;	author corinna;	state Exp;
branches;
next	1.389;

1.389
date	2013.08.07.09.04.39;	author corinna;	state Exp;
branches;
next	1.388;

1.388
date	2013.06.14.09.09.41;	author corinna;	state Exp;
branches;
next	1.387;

1.387
date	2013.06.07.08.28.25;	author corinna;	state Exp;
branches;
next	1.386;

1.386
date	2013.06.04.10.24.42;	author corinna;	state Exp;
branches;
next	1.385;

1.385
date	2013.06.02.10.22.14;	author corinna;	state Exp;
branches;
next	1.384;

1.384
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.383;

1.383
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.382;

1.382
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.381;

1.381
date	2012.12.14.10.45.27;	author corinna;	state Exp;
branches;
next	1.380;

1.380
date	2012.10.31.15.02.13;	author corinna;	state Exp;
branches;
next	1.379;

1.379
date	2012.07.02.02.24.24;	author cgf;	state Exp;
branches
	1.379.2.1;
next	1.378;

1.378
date	2012.06.04.08.49.13;	author corinna;	state Exp;
branches;
next	1.377;

1.377
date	2012.05.21.12.00.09;	author corinna;	state Exp;
branches;
next	1.376;

1.376
date	2012.04.02.11.08.07;	author corinna;	state Exp;
branches;
next	1.375;

1.375
date	2012.03.31.17.38.00;	author cgf;	state Exp;
branches;
next	1.374;

1.374
date	2012.03.29.18.02.54;	author corinna;	state Exp;
branches;
next	1.373;

1.373
date	2012.02.16.11.02.05;	author corinna;	state Exp;
branches;
next	1.372;

1.372
date	2012.02.14.15.22.13;	author corinna;	state Exp;
branches;
next	1.371;

1.371
date	2012.02.02.13.58.20;	author corinna;	state Exp;
branches;
next	1.370;

1.370
date	2011.12.17.23.39.46;	author cgf;	state Exp;
branches;
next	1.369;

1.369
date	2011.12.13.11.54.27;	author corinna;	state Exp;
branches;
next	1.368;

1.368
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.367;

1.367
date	2011.10.21.17.43.00;	author corinna;	state Exp;
branches;
next	1.366;

1.366
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.365;

1.365
date	2011.08.27.20.01.29;	author corinna;	state Exp;
branches;
next	1.364;

1.364
date	2011.08.01.17.01.37;	author corinna;	state Exp;
branches;
next	1.363;

1.363
date	2011.07.26.13.30.41;	author corinna;	state Exp;
branches;
next	1.362;

1.362
date	2011.07.05.12.02.10;	author corinna;	state Exp;
branches;
next	1.361;

1.361
date	2011.07.05.09.59.34;	author corinna;	state Exp;
branches;
next	1.360;

1.360
date	2011.06.17.11.04.44;	author corinna;	state Exp;
branches;
next	1.359;

1.359
date	2011.06.06.05.02.09;	author cgf;	state Exp;
branches;
next	1.358;

1.358
date	2011.06.06.00.25.44;	author cgf;	state Exp;
branches;
next	1.357;

1.357
date	2011.05.05.13.45.06;	author corinna;	state Exp;
branches;
next	1.356;

1.356
date	2011.05.05.09.05.04;	author corinna;	state Exp;
branches;
next	1.355;

1.355
date	2011.04.28.08.34.49;	author corinna;	state Exp;
branches;
next	1.354;

1.354
date	2011.04.28.08.15.56;	author corinna;	state Exp;
branches;
next	1.353;

1.353
date	2011.04.04.12.23.35;	author corinna;	state Exp;
branches;
next	1.352;

1.352
date	2011.03.14.09.14.17;	author corinna;	state Exp;
branches;
next	1.351;

1.351
date	2011.03.08.14.26.14;	author corinna;	state Exp;
branches
	1.351.2.1;
next	1.350;

1.350
date	2011.02.15.10.47.24;	author corinna;	state Exp;
branches;
next	1.349;

1.349
date	2011.02.15.10.31.54;	author corinna;	state Exp;
branches;
next	1.348;

1.348
date	2011.01.26.10.55.13;	author corinna;	state Exp;
branches;
next	1.347;

1.347
date	2011.01.13.14.00.00;	author corinna;	state Exp;
branches;
next	1.346;

1.346
date	2011.01.13.13.50.02;	author corinna;	state Exp;
branches;
next	1.345;

1.345
date	2010.10.07.14.03.26;	author corinna;	state Exp;
branches;
next	1.344;

1.344
date	2010.10.02.19.03.44;	author corinna;	state Exp;
branches;
next	1.343;

1.343
date	2010.09.30.13.52.33;	author corinna;	state Exp;
branches;
next	1.342;

1.342
date	2010.09.24.16.22.53;	author corinna;	state Exp;
branches;
next	1.341;

1.341
date	2010.09.24.12.41.33;	author corinna;	state Exp;
branches;
next	1.340;

1.340
date	2010.09.21.16.32.22;	author corinna;	state Exp;
branches;
next	1.339;

1.339
date	2010.09.21.16.07.19;	author corinna;	state Exp;
branches;
next	1.338;

1.338
date	2010.09.15.11.26.10;	author corinna;	state Exp;
branches;
next	1.337;

1.337
date	2010.09.13.11.17.35;	author corinna;	state Exp;
branches;
next	1.336;

1.336
date	2010.09.11.10.58.42;	author corinna;	state Exp;
branches;
next	1.335;

1.335
date	2010.09.06.09.47.01;	author corinna;	state Exp;
branches;
next	1.334;

1.334
date	2010.08.20.11.18.58;	author corinna;	state Exp;
branches;
next	1.333;

1.333
date	2010.08.20.08.52.25;	author corinna;	state Exp;
branches;
next	1.332;

1.332
date	2010.08.18.10.10.14;	author corinna;	state Exp;
branches;
next	1.331;

1.331
date	2010.07.05.16.59.55;	author corinna;	state Exp;
branches;
next	1.330;

1.330
date	2010.06.17.10.25.15;	author corinna;	state Exp;
branches;
next	1.329;

1.329
date	2010.06.15.15.10.42;	author corinna;	state Exp;
branches;
next	1.328;

1.328
date	2010.06.15.12.05.14;	author corinna;	state Exp;
branches;
next	1.327;

1.327
date	2010.06.15.09.58.56;	author corinna;	state Exp;
branches;
next	1.326;

1.326
date	2010.06.15.08.51.55;	author corinna;	state Exp;
branches;
next	1.325;

1.325
date	2010.03.19.10.59.49;	author corinna;	state Exp;
branches;
next	1.324;

1.324
date	2010.02.19.13.28.49;	author corinna;	state Exp;
branches;
next	1.323;

1.323
date	2010.02.19.12.37.37;	author corinna;	state Exp;
branches;
next	1.322;

1.322
date	2010.02.03.16.05.33;	author corinna;	state Exp;
branches;
next	1.321;

1.321
date	2010.01.29.11.20.06;	author corinna;	state Exp;
branches;
next	1.320;

1.320
date	2010.01.12.14.47.46;	author corinna;	state Exp;
branches;
next	1.319;

1.319
date	2010.01.10.11.12.52;	author corinna;	state Exp;
branches;
next	1.318;

1.318
date	2009.11.27.14.27.22;	author corinna;	state Exp;
branches;
next	1.317;

1.317
date	2009.11.10.08.54.24;	author corinna;	state Exp;
branches;
next	1.316;

1.316
date	2009.11.08.10.22.28;	author corinna;	state Exp;
branches;
next	1.315;

1.315
date	2009.10.30.19.58.52;	author corinna;	state Exp;
branches;
next	1.314;

1.314
date	2009.10.30.09.02.30;	author corinna;	state Exp;
branches;
next	1.313;

1.313
date	2009.10.20.10.12.05;	author corinna;	state Exp;
branches;
next	1.312;

1.312
date	2009.10.13.02.26.33;	author ericb;	state Exp;
branches;
next	1.311;

1.311
date	2009.10.12.11.57.29;	author corinna;	state Exp;
branches;
next	1.310;

1.310
date	2009.10.08.11.13.45;	author ericb;	state Exp;
branches;
next	1.309;

1.309
date	2009.09.26.15.51.53;	author ericb;	state Exp;
branches;
next	1.308;

1.308
date	2009.09.21.10.56.50;	author corinna;	state Exp;
branches;
next	1.307;

1.307
date	2009.08.14.18.27.18;	author corinna;	state Exp;
branches;
next	1.306;

1.306
date	2009.08.14.14.10.31;	author corinna;	state Exp;
branches;
next	1.305;

1.305
date	2009.08.14.13.39.07;	author corinna;	state Exp;
branches;
next	1.304;

1.304
date	2009.08.04.04.20.36;	author cgf;	state Exp;
branches;
next	1.303;

1.303
date	2009.07.21.08.10.36;	author corinna;	state Exp;
branches;
next	1.302;

1.302
date	2009.07.16.15.28.57;	author corinna;	state Exp;
branches;
next	1.301;

1.301
date	2009.07.14.17.37.42;	author corinna;	state Exp;
branches;
next	1.300;

1.300
date	2009.07.12.13.00.36;	author corinna;	state Exp;
branches;
next	1.299;

1.299
date	2009.04.09.09.19.03;	author corinna;	state Exp;
branches;
next	1.298;

1.298
date	2009.03.12.22.03.28;	author corinna;	state Exp;
branches;
next	1.297;

1.297
date	2009.01.29.20.32.08;	author corinna;	state Exp;
branches;
next	1.296;

1.296
date	2009.01.16.12.17.27;	author corinna;	state Exp;
branches;
next	1.295;

1.295
date	2009.01.07.14.12.40;	author corinna;	state Exp;
branches;
next	1.294;

1.294
date	2008.12.18.18.54.25;	author corinna;	state Exp;
branches;
next	1.293;

1.293
date	2008.12.14.06.01.46;	author cgf;	state Exp;
branches;
next	1.292;

1.292
date	2008.11.28.09.04.35;	author corinna;	state Exp;
branches;
next	1.291;

1.291
date	2008.11.26.17.21.03;	author cgf;	state Exp;
branches;
next	1.290;

1.290
date	2008.10.20.19.30.06;	author corinna;	state Exp;
branches;
next	1.289;

1.289
date	2008.10.09.14.23.09;	author corinna;	state Exp;
branches;
next	1.288;

1.288
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.287;

1.287
date	2008.08.19.09.46.31;	author corinna;	state Exp;
branches;
next	1.286;

1.286
date	2008.08.14.15.00.52;	author corinna;	state Exp;
branches;
next	1.285;

1.285
date	2008.08.14.14.05.04;	author corinna;	state Exp;
branches;
next	1.284;

1.284
date	2008.07.30.14.41.59;	author corinna;	state Exp;
branches;
next	1.283;

1.283
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.282;

1.282
date	2008.07.14.20.22.02;	author corinna;	state Exp;
branches;
next	1.281;

1.281
date	2008.05.23.17.22.18;	author corinna;	state Exp;
branches;
next	1.280;

1.280
date	2008.05.23.10.01.34;	author corinna;	state Exp;
branches;
next	1.279;

1.279
date	2008.05.21.10.23.19;	author corinna;	state Exp;
branches;
next	1.278;

1.278
date	2008.05.21.09.02.42;	author corinna;	state Exp;
branches;
next	1.277;

1.277
date	2008.05.20.21.08.39;	author corinna;	state Exp;
branches;
next	1.276;

1.276
date	2008.05.20.16.24.06;	author corinna;	state Exp;
branches;
next	1.275;

1.275
date	2008.05.20.15.11.20;	author corinna;	state Exp;
branches;
next	1.274;

1.274
date	2008.05.14.10.21.22;	author corinna;	state Exp;
branches;
next	1.273;

1.273
date	2008.04.24.17.15.17;	author corinna;	state Exp;
branches;
next	1.272;

1.272
date	2008.04.24.12.37.05;	author corinna;	state Exp;
branches;
next	1.271;

1.271
date	2008.04.24.09.59.54;	author corinna;	state Exp;
branches;
next	1.270;

1.270
date	2008.04.14.09.15.35;	author corinna;	state Exp;
branches;
next	1.269;

1.269
date	2008.04.13.16.47.21;	author corinna;	state Exp;
branches;
next	1.268;

1.268
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.267;

1.267
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.266;

1.266
date	2008.03.31.18.03.25;	author corinna;	state Exp;
branches;
next	1.265;

1.265
date	2008.03.24.14.48.58;	author corinna;	state Exp;
branches;
next	1.264;

1.264
date	2008.03.12.16.07.04;	author corinna;	state Exp;
branches;
next	1.263;

1.263
date	2008.03.12.15.04.06;	author corinna;	state Exp;
branches;
next	1.262;

1.262
date	2008.03.08.17.28.40;	author corinna;	state Exp;
branches;
next	1.261;

1.261
date	2008.02.29.16.38.51;	author corinna;	state Exp;
branches;
next	1.260;

1.260
date	2008.02.27.17.52.33;	author corinna;	state Exp;
branches;
next	1.259;

1.259
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.258;

1.258
date	2008.02.11.19.03.36;	author corinna;	state Exp;
branches;
next	1.257;

1.257
date	2008.02.10.15.43.04;	author corinna;	state Exp;
branches;
next	1.256;

1.256
date	2008.01.21.14.51.55;	author corinna;	state Exp;
branches;
next	1.255;

1.255
date	2007.12.11.18.57.44;	author corinna;	state Exp;
branches;
next	1.254;

1.254
date	2007.10.30.12.32.16;	author corinna;	state Exp;
branches;
next	1.253;

1.253
date	2007.10.19.12.22.49;	author corinna;	state Exp;
branches;
next	1.252;

1.252
date	2007.10.15.08.25.38;	author corinna;	state Exp;
branches;
next	1.251;

1.251
date	2007.09.27.09.35.06;	author corinna;	state Exp;
branches;
next	1.250;

1.250
date	2007.08.21.15.37.10;	author corinna;	state Exp;
branches;
next	1.249;

1.249
date	2007.08.21.12.09.38;	author corinna;	state Exp;
branches;
next	1.248;

1.248
date	2007.08.16.16.59.25;	author corinna;	state Exp;
branches;
next	1.247;

1.247
date	2007.08.16.14.10.06;	author corinna;	state Exp;
branches;
next	1.246;

1.246
date	2007.08.15.15.31.18;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2007.08.14.14.48.52;	author corinna;	state Exp;
branches;
next	1.244;

1.244
date	2007.08.13.19.15.47;	author corinna;	state Exp;
branches;
next	1.243;

1.243
date	2007.08.13.17.16.04;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2007.08.12.15.42.02;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2007.08.02.15.13.56;	author corinna;	state Exp;
branches;
next	1.240;

1.240
date	2007.08.02.10.22.30;	author corinna;	state Exp;
branches;
next	1.239;

1.239
date	2007.08.01.12.55.25;	author corinna;	state Exp;
branches;
next	1.238;

1.238
date	2007.07.31.15.19.59;	author corinna;	state Exp;
branches;
next	1.237;

1.237
date	2007.07.30.10.58.16;	author corinna;	state Exp;
branches;
next	1.236;

1.236
date	2007.07.29.15.57.41;	author corinna;	state Exp;
branches;
next	1.235;

1.235
date	2007.07.29.12.27.22;	author corinna;	state Exp;
branches;
next	1.234;

1.234
date	2007.07.29.08.23.04;	author corinna;	state Exp;
branches;
next	1.233;

1.233
date	2007.07.28.16.08.45;	author corinna;	state Exp;
branches;
next	1.232;

1.232
date	2007.07.28.16.00.35;	author corinna;	state Exp;
branches;
next	1.231;

1.231
date	2007.07.27.16.24.07;	author corinna;	state Exp;
branches;
next	1.230;

1.230
date	2007.07.27.13.19.41;	author corinna;	state Exp;
branches;
next	1.229;

1.229
date	2007.07.27.10.10.57;	author corinna;	state Exp;
branches;
next	1.228;

1.228
date	2007.07.27.09.00.12;	author corinna;	state Exp;
branches;
next	1.227;

1.227
date	2007.07.27.08.38.00;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2007.07.26.17.30.54;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2007.07.20.14.29.43;	author corinna;	state Exp;
branches;
next	1.224;

1.224
date	2007.07.19.17.22.34;	author corinna;	state Exp;
branches;
next	1.223;

1.223
date	2007.07.19.11.41.16;	author corinna;	state Exp;
branches;
next	1.222;

1.222
date	2007.07.17.13.22.21;	author corinna;	state Exp;
branches;
next	1.221;

1.221
date	2007.07.09.17.02.37;	author corinna;	state Exp;
branches;
next	1.220;

1.220
date	2007.07.07.16.46.35;	author cgf;	state Exp;
branches;
next	1.219;

1.219
date	2007.07.05.09.35.36;	author corinna;	state Exp;
branches;
next	1.218;

1.218
date	2007.06.29.15.13.00;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2007.05.29.17.25.36;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2007.03.06.14.48.24;	author corinna;	state Exp;
branches;
next	1.215;

1.215
date	2007.03.01.15.13.47;	author cgf;	state Exp;
branches;
next	1.214;

1.214
date	2007.02.27.12.58.55;	author corinna;	state Exp;
branches;
next	1.213;

1.213
date	2007.02.26.12.22.41;	author corinna;	state Exp;
branches;
next	1.212;

1.212
date	2007.02.23.09.49.49;	author corinna;	state Exp;
branches;
next	1.211;

1.211
date	2007.02.22.18.01.11;	author corinna;	state Exp;
branches;
next	1.210;

1.210
date	2007.02.22.17.09.46;	author corinna;	state Exp;
branches;
next	1.209;

1.209
date	2007.02.22.16.04.19;	author corinna;	state Exp;
branches;
next	1.208;

1.208
date	2007.02.22.15.07.21;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2007.02.22.11.17.01;	author corinna;	state Exp;
branches;
next	1.206;

1.206
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.205;

1.205
date	2007.02.20.00.16.16;	author cgf;	state Exp;
branches;
next	1.204;

1.204
date	2007.01.31.10.55.59;	author corinna;	state Exp;
branches;
next	1.203;

1.203
date	2007.01.26.12.25.23;	author corinna;	state Exp;
branches;
next	1.202;

1.202
date	2007.01.07.12.44.10;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2007.01.04.09.17.55;	author corinna;	state Exp;
branches;
next	1.200;

1.200
date	2006.12.21.10.59.47;	author corinna;	state Exp;
branches;
next	1.199;

1.199
date	2006.12.06.14.05.59;	author corinna;	state Exp;
branches;
next	1.198;

1.198
date	2006.11.30.10.17.24;	author corinna;	state Exp;
branches;
next	1.197;

1.197
date	2006.10.31.11.40.47;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2006.10.23.16.41.10;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2006.10.23.15.13.55;	author corinna;	state Exp;
branches;
next	1.194;

1.194
date	2006.10.22.19.31.33;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2006.10.16.13.11.29;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2006.10.16.12.26.59;	author corinna;	state Exp;
branches;
next	1.191;

1.191
date	2006.10.09.14.01.52;	author corinna;	state Exp;
branches;
next	1.190;

1.190
date	2006.08.20.12.31.07;	author corinna;	state Exp;
branches;
next	1.189;

1.189
date	2006.08.20.12.18.12;	author corinna;	state Exp;
branches;
next	1.188;

1.188
date	2006.08.19.21.44.58;	author cgf;	state Exp;
branches;
next	1.187;

1.187
date	2006.08.10.08.44.43;	author corinna;	state Exp;
branches;
next	1.186;

1.186
date	2006.08.07.19.29.14;	author corinna;	state Exp;
branches;
next	1.185;

1.185
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches
	1.185.4.1;
next	1.184;

1.184
date	2006.05.08.15.20.04;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2006.04.26.16.51.09;	author corinna;	state Exp;
branches;
next	1.182;

1.182
date	2006.04.14.14.34.39;	author corinna;	state Exp;
branches;
next	1.181;

1.181
date	2006.04.14.14.20.58;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2006.03.31.20.07.13;	author corinna;	state Exp;
branches;
next	1.179;

1.179
date	2006.03.03.20.19.26;	author corinna;	state Exp;
branches;
next	1.178;

1.178
date	2006.03.02.09.48.42;	author corinna;	state Exp;
branches;
next	1.177;

1.177
date	2006.03.01.22.37.25;	author corinna;	state Exp;
branches;
next	1.176;

1.176
date	2006.03.01.13.47.49;	author corinna;	state Exp;
branches;
next	1.175;

1.175
date	2006.02.28.20.26.51;	author corinna;	state Exp;
branches;
next	1.174;

1.174
date	2006.02.28.04.23.17;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2006.02.19.21.18.36;	author cgf;	state Exp;
branches;
next	1.172;

1.172
date	2006.02.19.08.34.25;	author corinna;	state Exp;
branches;
next	1.171;

1.171
date	2006.02.18.10.46.53;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2006.02.09.14.42.48;	author corinna;	state Exp;
branches;
next	1.169;

1.169
date	2006.02.07.15.49.08;	author corinna;	state Exp;
branches;
next	1.168;

1.168
date	2006.02.05.18.18.02;	author corinna;	state Exp;
branches;
next	1.167;

1.167
date	2006.02.05.18.11.03;	author corinna;	state Exp;
branches;
next	1.166;

1.166
date	2006.02.05.11.17.03;	author corinna;	state Exp;
branches;
next	1.165;

1.165
date	2006.02.05.07.03.24;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2006.02.04.04.31.34;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2006.01.30.13.44.16;	author corinna;	state Exp;
branches;
next	1.162;

1.162
date	2006.01.30.10.30.58;	author corinna;	state Exp;
branches;
next	1.161;

1.161
date	2006.01.29.17.29.35;	author corinna;	state Exp;
branches;
next	1.160;

1.160
date	2006.01.28.13.59.39;	author corinna;	state Exp;
branches;
next	1.159;

1.159
date	2006.01.28.13.41.22;	author corinna;	state Exp;
branches;
next	1.158;

1.158
date	2006.01.27.21.50.40;	author corinna;	state Exp;
branches;
next	1.157;

1.157
date	2006.01.26.02.54.54;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2006.01.24.12.32.33;	author corinna;	state Exp;
branches;
next	1.155;

1.155
date	2006.01.21.02.24.16;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2006.01.19.18.55.07;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2005.12.22.05.57.54;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2005.12.21.13.37.28;	author corinna;	state Exp;
branches;
next	1.151;

1.151
date	2005.12.21.13.01.27;	author corinna;	state Exp;
branches;
next	1.150;

1.150
date	2005.12.14.16.38.22;	author corinna;	state Exp;
branches;
next	1.149;

1.149
date	2005.12.01.17.33.59;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2005.11.28.10.06.33;	author corinna;	state Exp;
branches;
next	1.147;

1.147
date	2005.10.19.16.50.43;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2005.10.12.12.54.34;	author corinna;	state Exp;
branches;
next	1.145;

1.145
date	2005.09.30.11.02.47;	author corinna;	state Exp;
branches;
next	1.144;

1.144
date	2005.09.30.10.27.14;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2005.09.30.08.05.42;	author corinna;	state Exp;
branches;
next	1.142;

1.142
date	2005.09.22.17.53.38;	author corinna;	state Exp;
branches;
next	1.141;

1.141
date	2005.09.22.15.52.02;	author corinna;	state Exp;
branches;
next	1.140;

1.140
date	2005.09.14.14.27.54;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2005.09.12.21.19.07;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2005.08.23.22.22.52;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2005.08.23.03.58.09;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2005.08.20.06.19.54;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2005.08.19.16.29.43;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2005.08.19.16.18.42;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2005.07.29.17.26.10;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2005.07.29.17.04.46;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2005.07.06.20.05.00;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2005.06.27.14.18.13;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2005.06.02.01.50.23;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2005.05.25.04.32.59;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2005.05.19.05.43.55;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2005.05.14.21.12.10;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2005.05.13.15.46.05;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2005.05.03.19.03.20;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2005.05.02.03.50.06;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2005.04.17.00.12.13;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2005.04.16.17.17.33;	author corinna;	state Exp;
branches;
next	1.119;

1.119
date	2005.04.16.12.53.48;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2005.04.14.17.34.03;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2005.04.13.16.41.30;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2005.04.13.16.17.37;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2005.04.13.11.07.44;	author corinna;	state Exp;
branches;
next	1.114;

1.114
date	2005.04.12.14.26.31;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2005.04.04.10.26.35;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2005.04.03.13.06.41;	author corinna;	state Exp;
branches;
next	1.111;

1.111
date	2005.04.03.08.45.18;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2005.03.22.19.00.29;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2005.03.17.12.53.47;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2005.03.16.21.21.18;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2005.03.02.08.28.54;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2005.02.23.02.00.48;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2005.02.20.16.14.53;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2005.02.20.11.44.32;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2005.02.19.21.53.36;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2005.02.17.12.41.49;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2005.02.11.15.37.26;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2005.02.09.19.28.06;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2005.02.02.22.42.06;	author corinna;	state Exp;
branches;
next	1.98;

1.98
date	2005.01.14.22.03.40;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2005.01.13.22.56.20;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2005.01.10.13.09.56;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2005.01.06.17.43.55;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2004.12.26.02.10.30;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2004.08.29.09.32.49;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2004.05.29.00.51.16;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2004.05.28.19.50.05;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2004.04.20.15.51.24;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2004.04.16.21.22.13;	author corinna;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.15.15.56.52;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.14.16.36.26;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2004.04.14.13.40.07;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2004.04.14.10.20.25;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2004.04.14.03.08.00;	author phumblet;	state Exp;
branches;
next	1.83;

1.83
date	2004.04.13.20.36.58;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2004.04.09.08.43.28;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2004.04.08.07.57.28;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2004.04.06.10.19.31;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2004.03.23.11.26.54;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2004.02.09.04.04.22;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2004.01.24.03.40.33;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2003.12.15.04.16.42;	author cgf;	state Exp;
branches
	1.75.6.1;
next	1.74;

1.74
date	2003.12.15.03.59.32;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2003.12.03.11.22.49;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2003.12.03.09.58.23;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2003.12.01.17.26.28;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2003.11.27.23.27.23;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.68;

1.68
date	2003.11.07.18.21.05;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2003.11.05.16.53.55;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2003.09.25.02.29.05;	author phumblet;	state Exp;
branches;
next	1.65;

1.65
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.14.00.07.50;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.12.20.17.28;	author cgf;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2003.09.11.23.30.26;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2003.09.10.20.16.00;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2003.09.08.04.04.18;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2003.08.05.03.04.28;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2003.07.04.03.07.01;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.04.01.57.44;	author phumblet;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.01.19.37.13;	author phumblet;	state Exp;
branches;
next	1.53;

1.53
date	2003.05.27.07.44.26;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.26.09.54.01;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.25.09.18.43;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.11.21.52.09;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.11.00.10.10;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2003.04.11.09.38.07;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.19.21.34.38;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.09.20.31.07;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2003.02.21.04.33.53;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2003.02.20.14.14.36;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.20.11.12.44;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.20.10.14.52;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.10.22.43.29;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.04.03.01.17;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2003.01.09.17.15.44;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.09.08.22.04;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2002.10.23.02.32.34;	author cgf;	state Exp;
branches
	1.35.12.1;
next	1.34;

1.34
date	2002.10.22.21.35.21;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2002.10.22.20.41.31;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.30.14.17.17;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.24.05.37.46;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.11.14.05.17;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.27.03.06.44;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.27.02.29.57;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.10.01.25.47;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.06.15.35.06;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.04.01.40.53;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.02.16.53.29;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.01.02.45.38;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.31.22.53.25;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.31.00.15.22;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.29.15.04.26;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.29.03.06.37;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.28.14.10.51;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.28.02.00.55;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.24.05.44.10;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.18.21.07.18;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.12.19.20.01;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.22.04.27.52;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.25.17.47.46;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.14.20.39.59;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.25.03.28.16;	author cgf;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	2001.11.24.03.11.39;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.22.05.59.07;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.21.06.47.57;	author cgf;	state Exp;
branches;
next	;

1.394.2.1
date	2014.07.16.09.54.55;	author corinna;	state Exp;
branches;
next	1.394.2.2;

1.394.2.2
date	2014.11.13.12.53.00;	author corinna;	state Exp;
branches;
next	;

1.379.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.379.2.2;

1.379.2.2
date	2012.10.31.17.00.08;	author corinna;	state Exp;
branches;
next	1.379.2.3;

1.379.2.3
date	2012.11.14.14.40.30;	author corinna;	state Exp;
branches;
next	1.379.2.4;

1.379.2.4
date	2012.11.16.09.41.12;	author corinna;	state Exp;
branches;
next	1.379.2.5;

1.379.2.5
date	2012.12.10.11.45.46;	author corinna;	state Exp;
branches;
next	1.379.2.6;

1.379.2.6
date	2012.12.14.10.45.37;	author corinna;	state Exp;
branches;
next	1.379.2.7;

1.379.2.7
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.379.2.8;

1.379.2.8
date	2013.02.16.12.25.40;	author corinna;	state Exp;
branches;
next	1.379.2.9;

1.379.2.9
date	2013.02.18.11.38.27;	author corinna;	state Exp;
branches;
next	1.379.2.10;

1.379.2.10
date	2013.03.01.16.32.32;	author corinna;	state Exp;
branches;
next	1.379.2.11;

1.379.2.11
date	2013.03.14.12.09.51;	author corinna;	state Exp;
branches;
next	1.379.2.12;

1.379.2.12
date	2013.04.02.09.08.17;	author corinna;	state Exp;
branches;
next	;

1.351.2.1
date	2011.03.14.09.34.57;	author corinna;	state Exp;
branches;
next	;

1.185.4.1
date	2006.08.10.12.51.25;	author corinna;	state Exp;
branches;
next	1.185.4.2;

1.185.4.2
date	2006.08.20.11.51.01;	author corinna;	state Exp;
branches;
next	1.185.4.3;

1.185.4.3
date	2006.10.16.12.46.34;	author corinna;	state Exp;
branches;
next	1.185.4.4;

1.185.4.4
date	2006.10.16.13.11.46;	author corinna;	state Exp;
branches;
next	1.185.4.5;

1.185.4.5
date	2006.10.23.15.14.04;	author corinna;	state Exp;
branches;
next	1.185.4.6;

1.185.4.6
date	2006.10.23.16.41.18;	author corinna;	state Exp;
branches;
next	1.185.4.7;

1.185.4.7
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	1.185.4.8;

1.185.4.8
date	2007.12.11.18.57.58;	author corinna;	state Exp;
branches;
next	1.185.4.9;

1.185.4.9
date	2008.02.29.16.38.02;	author corinna;	state Exp;
branches;
next	;

1.75.6.1
date	2004.01.24.03.41.29;	author cgf;	state Exp;
branches;
next	;

1.63.2.1
date	2003.09.19.01.55.54;	author cgf;	state Exp;
branches;
next	;

1.38.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2003.02.05.14.25.07;	author cgf;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2003.02.11.03.13.08;	author cgf;	state Exp;
branches;
next	1.38.2.4;

1.38.2.4
date	2003.02.14.03.03.27;	author cgf;	state Exp;
branches;
next	1.38.2.5;

1.38.2.5
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.38.2.6;

1.38.2.6
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.38.2.7;

1.38.2.7
date	2003.03.21.15.15.18;	author cgf;	state Exp;
branches;
next	1.38.2.8;

1.38.2.8
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.38.2.9;

1.38.2.9
date	2003.05.10.17.20.53;	author cgf;	state Exp;
branches;
next	1.38.2.10;

1.38.2.10
date	2003.05.26.19.39.06;	author cgf;	state Exp;
branches;
next	1.38.2.11;

1.38.2.11
date	2003.06.06.00.27.50;	author cgf;	state Exp;
branches;
next	1.38.2.12;

1.38.2.12
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.38.2.13;

1.38.2.13
date	2003.07.10.01.06.23;	author cgf;	state Exp;
branches;
next	1.38.2.14;

1.38.2.14
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	1.38.2.15;

1.38.2.15
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	1.38.2.16;

1.38.2.16
date	2003.09.11.04.47.22;	author cgf;	state Exp;
branches;
next	1.38.2.17;

1.38.2.17
date	2003.09.14.01.35.37;	author cgf;	state Exp;
branches;
next	;

1.35.12.1
date	2002.12.28.07.10.26;	author cgf;	state Exp;
branches;
next	1.35.12.2;

1.35.12.2
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	1.35.12.3;

1.35.12.3
date	2002.12.29.06.14.14;	author cgf;	state Exp;
branches;
next	1.35.12.4;

1.35.12.4
date	2003.01.01.18.16.37;	author cgf;	state Exp;
branches;
next	1.35.12.5;

1.35.12.5
date	2003.01.02.06.16.17;	author cgf;	state Exp;
branches;
next	1.35.12.6;

1.35.12.6
date	2003.01.05.03.01.16;	author cgf;	state Exp;
branches;
next	1.35.12.7;

1.35.12.7
date	2003.01.09.08.22.51;	author cgf;	state Exp;
branches;
next	;

1.4.16.1
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2002.01.15.12.52.50;	author rbcollins;	state Exp;
branches;
next	1.4.16.3;

1.4.16.3
date	2002.02.28.12.53.24;	author rbcollins;	state Exp;
branches;
next	1.4.16.4;

1.4.16.4
date	2002.06.13.14.34.04;	author rbcollins;	state Exp;
branches;
next	1.4.16.5;

1.4.16.5
date	2002.06.27.11.30.14;	author scottc;	state Exp;
branches;
next	1.4.16.6;

1.4.16.6
date	2002.07.12.09.53.19;	author scottc;	state Exp;
branches;
next	1.4.16.7;

1.4.16.7
date	2002.07.26.19.03.36;	author scottc;	state Exp;
branches;
next	1.4.16.8;

1.4.16.8
date	2002.07.31.16.49.37;	author scottc;	state Exp;
branches;
next	1.4.16.9;

1.4.16.9
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	1.4.16.10;

1.4.16.10
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.405
log
@	* path.h (path_conv): Make path_flags private.  Rename known_suffix to
	suffix and make private.  Rename normalized_path to posix_path and
	make privtae.  Accommodate name changes throughout in path_conv
	methods.
	(path_conv::known_suffix): New method.  Use throughout instead of
	accessing suffix directly.
	(path_conv::get_win32): Constify.
	(path_conv::get_posix): New method to read posix_path.  Use throughout
	instead of accessing normalized_path directly.
	(path_conv::set_posix): Rename from set_normalized_path.  Accommodate
	name change throughout.
	* spawn.cc (find_exec): Return POSIX path, not Win32 path.
@
text
@/* fhandler_disk_file.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <winioctl.h>
#include <lm.h>
#include <stdlib.h>
#include <sys/acl.h>
#include <sys/statvfs.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "shared_info.h"
#include "pinfo.h"
#include "ntdll.h"
#include "tls_pbuf.h"
#include "devices.h"
#include "ldap.h"

#define _COMPILING_NEWLIB
#include <dirent.h>

class __DIR_mounts
{
  int		 count;
  const char	*parent_dir;
  int		 parent_dir_len;
  UNICODE_STRING mounts[MAX_MOUNTS];
  bool		 found[MAX_MOUNTS + 3];
  UNICODE_STRING cygdrive;

#define __DIR_PROC	(MAX_MOUNTS)
#define __DIR_CYGDRIVE	(MAX_MOUNTS+1)
#define __DIR_DEV	(MAX_MOUNTS+2)

  ino_t eval_ino (int idx)
    {
      ino_t ino = 0;
      char fname[parent_dir_len + mounts[idx].Length + 2];
      struct stat st;

      char *c = stpcpy (fname, parent_dir);
      if (c[- 1] != '/')
	*c++ = '/';
      sys_wcstombs (c, mounts[idx].Length + 1,
		    mounts[idx].Buffer, mounts[idx].Length / sizeof (WCHAR));
      path_conv pc (fname, PC_SYM_NOFOLLOW | PC_POSIX | PC_KEEP_HANDLE);
      if (!stat_worker (pc, &st))
	ino = st.st_ino;
      return ino;
    }

public:
  __DIR_mounts (const char *posix_path)
  : parent_dir (posix_path)
    {
      parent_dir_len = strlen (parent_dir);
      count = mount_table->get_mounts_here (parent_dir, parent_dir_len, mounts,
					    &cygdrive);
      rewind ();
    }
  ~__DIR_mounts ()
    {
      for (int i = 0; i < count; ++i)
	RtlFreeUnicodeString (&mounts[i]);
      RtlFreeUnicodeString (&cygdrive);
    }
  ino_t check_mount (PUNICODE_STRING fname, ino_t ino,
			 bool eval = true)
    {
      if (parent_dir_len == 1)	/* root dir */
	{
	  if (RtlEqualUnicodeString (fname, &ro_u_proc, FALSE))
	    {
	      found[__DIR_PROC] = true;
	      return 2;
	    }
	  if (RtlEqualUnicodeString (fname, &ro_u_dev, FALSE))
	    {
	      found[__DIR_DEV] = true;
	      return 2;
	    }
	  if (fname->Length / sizeof (WCHAR) == mount_table->cygdrive_len - 2
	      && RtlEqualUnicodeString (fname, &cygdrive, FALSE))
	    {
	      found[__DIR_CYGDRIVE] = true;
	      return 2;
	    }
	}
      for (int i = 0; i < count; ++i)
	if (RtlEqualUnicodeString (fname, &mounts[i], FALSE))
	  {
	    found[i] = true;
	    return eval ? eval_ino (i) : 1;
	  }
      return ino;
    }
  ino_t check_missing_mount (PUNICODE_STRING retname = NULL)
    {
      for (int i = 0; i < count; ++i)
	if (!found[i])
	  {
	    found[i] = true;
	    if (retname)
	      {
		*retname = mounts[i];
		return eval_ino (i);
	      }
	    return 1;
	  }
      if (parent_dir_len == 1)  /* root dir */
	{
	  if (!found[__DIR_PROC])
	    {
	      found[__DIR_PROC] = true;
	      if (retname)
		*retname = ro_u_proc;
	      return 2;
	    }
	  if (!found[__DIR_DEV])
	    {
	      found[__DIR_DEV] = true;
	      if (retname)
		*retname = ro_u_dev;
	      return 2;
	    }
	  if (!found[__DIR_CYGDRIVE])
	    {
	      found[__DIR_CYGDRIVE] = true;
	      if (cygdrive.Length > 0)
		{
		  if (retname)
		    *retname = cygdrive;
		  return 2;
		}
	    }
	}
      return 0;
    }
    void rewind () { memset (found, 0, sizeof found); }
};

inline bool
path_conv::isgood_inode (ino_t ino) const
{
  /* If the FS doesn't support nonambiguous inode numbers anyway, bail out
     immediately. */
  if (!hasgood_inode ())
    return false;
  /* If the inode numbers are 64 bit numbers or if it's a local FS, they
     are to be trusted. */
  if (ino > UINT32_MAX || !isremote ())
    return true;
  /* The inode numbers returned from a remote NT4 NTFS are ephemeral
     32 bit numbers. */
  if (fs_is_ntfs ())
    return false;
  /* Starting with version 3.5.4, Samba returns the real inode numbers, if
     the file is on the same device as the root of the share (Samba function
     get_FileIndex).  32 bit inode numbers returned by older versions (likely
     < 3.0) are ephemeral. */
  if (fs_is_samba () && fs.samba_version () < 0x03050400)
    return false;
  /* Otherwise, trust the inode numbers unless proved otherwise. */
  return true;
}

/* Check reparse point for type.  IO_REPARSE_TAG_MOUNT_POINT types are
   either volume mount points, which are treated as directories, or they
   are directory mount points, which are treated as symlinks.
   IO_REPARSE_TAG_SYMLINK types are always symlinks.  We don't know
   anything about other reparse points, so they are treated as unknown.  */
static inline int
readdir_check_reparse_point (POBJECT_ATTRIBUTES attr)
{
  DWORD ret = DT_UNKNOWN;
  IO_STATUS_BLOCK io;
  HANDLE reph;
  UNICODE_STRING subst;

  if (NT_SUCCESS (NtOpenFile (&reph, READ_CONTROL, attr, &io,
			      FILE_SHARE_VALID_FLAGS,
			      FILE_OPEN_FOR_BACKUP_INTENT
			      | FILE_OPEN_REPARSE_POINT)))
    {
      PREPARSE_DATA_BUFFER rp = (PREPARSE_DATA_BUFFER)
		  alloca (MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
      if (NT_SUCCESS (NtFsControlFile (reph, NULL, NULL, NULL,
		      &io, FSCTL_GET_REPARSE_POINT, NULL, 0,
		      (LPVOID) rp, MAXIMUM_REPARSE_DATA_BUFFER_SIZE)))
	{
	  if (rp->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
	    {
	      RtlInitCountedUnicodeString (&subst,
		  (WCHAR *)((char *)rp->MountPointReparseBuffer.PathBuffer
			    + rp->MountPointReparseBuffer.SubstituteNameOffset),
		  rp->MountPointReparseBuffer.SubstituteNameLength);
	      /* Only volume mountpoints are treated as directories. */
	      if (RtlEqualUnicodePathPrefix (&subst, &ro_u_volume, TRUE))
		ret = DT_DIR;
	      else
		ret = DT_LNK;
	    }
	  else if (rp->ReparseTag == IO_REPARSE_TAG_SYMLINK)
	    ret = DT_LNK;
	  NtClose (reph);
	}
    }
  return ret;
}

inline ino_t
path_conv::get_ino_by_handle (HANDLE hdl)
{
  IO_STATUS_BLOCK io;
  FILE_INTERNAL_INFORMATION fai;

  if (NT_SUCCESS (NtQueryInformationFile (hdl, &io, &fai, sizeof fai,
					  FileInternalInformation))
      && isgood_inode (fai.FileId.QuadPart))
    return fai.FileId.QuadPart;
  return 0;
}

#if 0
/* This function is obsolete.  We're keeping it in so we don't forget
   that we already did all that at one point. */
unsigned __stdcall
path_conv::ndisk_links (DWORD nNumberOfLinks)
{
  if (!isdir () || isremote ())
    return nNumberOfLinks;

  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  HANDLE fh;

  if (!NT_SUCCESS (NtOpenFile (&fh, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			       get_object_attr (attr, sec_none_nih),
			       &io, FILE_SHARE_VALID_FLAGS,
			       FILE_SYNCHRONOUS_IO_NONALERT
			       | FILE_OPEN_FOR_BACKUP_INTENT
			       | FILE_DIRECTORY_FILE)))
    return nNumberOfLinks;

  unsigned count = 0;
  bool first = true;
  PFILE_BOTH_DIR_INFORMATION fdibuf = (PFILE_BOTH_DIR_INFORMATION)
				       alloca (65536);
  __DIR_mounts *dir = new __DIR_mounts (get_posix ());
  while (NT_SUCCESS (NtQueryDirectoryFile (fh, NULL, NULL, NULL, &io, fdibuf,
					   65536, FileBothDirectoryInformation,
					   FALSE, NULL, first)))
    {
      if (first)
	{
	  first = false;
	  /* All directories have . and .. as their first entries.
	     If . is not present as first entry, we're on a drive's
	     root direcotry, which doesn't have these entries. */
	  if (fdibuf->FileNameLength != 2 || fdibuf->FileName[0] != L'.')
	    count = 2;
	}
      for (PFILE_BOTH_DIR_INFORMATION pfdi = fdibuf;
	   pfdi;
	   pfdi = (PFILE_BOTH_DIR_INFORMATION)
		  (pfdi->NextEntryOffset ? (PBYTE) pfdi + pfdi->NextEntryOffset
					 : NULL))
	{
	  switch (pfdi->FileAttributes
		  & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT))
	    {
	    case FILE_ATTRIBUTE_DIRECTORY:
	      /* Just a directory */
	      ++count;
	      break;
	    case FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT:
	      /* Volume mount point or symlink to directory */
	      {
		UNICODE_STRING fname;

		RtlInitCountedUnicodeString (&fname, pfdi->FileName,
					     pfdi->FileNameLength);
		InitializeObjectAttributes (&attr, &fname,
					    objcaseinsensitive (), fh, NULL);
		if (is_volume_mountpoint (&attr))
		  ++count;
	      }
	      break;
	    default:
	      break;
	    }
	  UNICODE_STRING fname;
	  RtlInitCountedUnicodeString (&fname, pfdi->FileName,
				       pfdi->FileNameLength);
	  dir->check_mount (&fname, 0, false);
	}
    }
  while (dir->check_missing_mount ())
    ++count;
  NtClose (fh);
  delete dir;
  return count;
}
#endif

/* For files on NFS shares, we request an EA of type NfsV3Attributes.
   This returns the content of a struct fattr3 as defined in RFC 1813.
   The content is the NFS equivalent of struct stat. so there's not much
   to do here except for copying. */
int __reg2
fhandler_base::fstat_by_nfs_ea (struct stat *buf)
{
  fattr3 *nfs_attr = pc.nfsattr ();
  PWCHAR domain;
  cyg_ldap cldap;
  bool ldap_open = false;

  if (get_io_handle ())
    {
      /* NFS stumbles over its own caching.  If you write to the file,
	 a subsequent fstat does not return the actual size of the file,
	 but the size at the time the handle has been opened.  Unless
	 access through another handle invalidates the caching within the
	 NFS client. */
      if (get_access () & GENERIC_WRITE)
	FlushFileBuffers (get_io_handle ());
      nfs_fetch_fattr3 (get_io_handle (), nfs_attr);
    }
  buf->st_dev = nfs_attr->fsid;
  buf->st_ino = nfs_attr->fileid;
  buf->st_mode = (nfs_attr->mode & 0xfff)
		 | nfs_type_mapping[nfs_attr->type & 7];
  buf->st_nlink = nfs_attr->nlink;
  /* Try to map UNIX uid/gid to Cygwin uid/gid.  If there's no mapping in
     the cache, try to fetch it from the configured RFC 2307 domain (see
     last comment in cygheap_domain_info::init() for more information) and
     add it to the mapping cache. */
  buf->st_uid = cygheap->ugid_cache.get_uid (nfs_attr->uid);
  buf->st_gid = cygheap->ugid_cache.get_gid (nfs_attr->gid);
  if (buf->st_uid == ILLEGAL_UID)
    {
      uid_t map_uid = ILLEGAL_UID;

      domain = cygheap->dom.get_rfc2307_domain ();
      if ((ldap_open = (cldap.open (domain) == NO_ERROR)))
	map_uid = cldap.remap_uid (nfs_attr->uid);
      if (map_uid == ILLEGAL_UID)
	map_uid = MAP_UNIX_TO_CYGWIN_ID (nfs_attr->uid);
      cygheap->ugid_cache.add_uid (nfs_attr->uid, map_uid);
      buf->st_uid = map_uid;
    }
  if (buf->st_gid == ILLEGAL_GID)
    {
      gid_t map_gid = ILLEGAL_GID;

      domain = cygheap->dom.get_rfc2307_domain ();
      if ((ldap_open || cldap.open (domain) == NO_ERROR))
	map_gid = cldap.remap_gid (nfs_attr->gid);
      if (map_gid == ILLEGAL_GID)
	map_gid = MAP_UNIX_TO_CYGWIN_ID (nfs_attr->gid);
      cygheap->ugid_cache.add_gid (nfs_attr->gid, map_gid);
      buf->st_gid = map_gid;
    }
  buf->st_rdev = makedev (nfs_attr->rdev.specdata1,
			  nfs_attr->rdev.specdata2);
  buf->st_size = nfs_attr->size;
  buf->st_blksize = PREFERRED_IO_BLKSIZE;
  buf->st_blocks = (nfs_attr->used + S_BLKSIZE - 1) / S_BLKSIZE;
  buf->st_atim.tv_sec = nfs_attr->atime.tv_sec;
  buf->st_atim.tv_nsec = nfs_attr->atime.tv_nsec;
  buf->st_mtim.tv_sec = nfs_attr->mtime.tv_sec;
  buf->st_mtim.tv_nsec = nfs_attr->mtime.tv_nsec;
  buf->st_ctim.tv_sec = nfs_attr->ctime.tv_sec;
  buf->st_ctim.tv_nsec = nfs_attr->ctime.tv_nsec;
  return 0;
}

int __reg2
fhandler_base::fstat_by_handle (struct stat *buf)
{
  /* Don't use FileAllInformation info class.  It returns a pathname rather
     than a filename, so it needs a really big buffer for no good reason
     since we don't need the name anyway.  So we just call the three info
     classes necessary to get all information required by stat(2). */
  FILE_STANDARD_INFORMATION fsi;
  FILE_INTERNAL_INFORMATION fii;

  HANDLE h = get_stat_handle ();
  NTSTATUS status = 0;
  IO_STATUS_BLOCK io;

  /* If the file has been opened for other purposes than stat, we can't rely
     on the information stored in pc.fnoi.  So we overwrite them here. */
  if (get_io_handle ())
    {
      status = file_get_fnoi (h, pc.fs_is_netapp (), pc.fnoi ());
      if (!NT_SUCCESS (status))
       {
	 debug_printf ("%y = NtQueryInformationFile(%S, "
		       "FileNetworkOpenInformation)",
		       status, pc.get_nt_native_path ());
	 return -1;
       }
    }
  if (!pc.hasgood_inode ())
    fsi.NumberOfLinks = 1;
  else
    {
      status = NtQueryInformationFile (h, &io, &fsi, sizeof fsi,
				       FileStandardInformation);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("%y = NtQueryInformationFile(%S, "
			"FileStandardInformation)",
			status, pc.get_nt_native_path ());
	  return -1;
	}
      if (!ino)
	{
	  status = NtQueryInformationFile (h, &io, &fii, sizeof fii,
					   FileInternalInformation);
	  if (!NT_SUCCESS (status))
	    {
	      debug_printf ("%y = NtQueryInformationFile(%S, "
			    "FileInternalInformation)",
			    status, pc.get_nt_native_path ());
	      return -1;
	    }
	  else if (pc.isgood_inode (fii.FileId.QuadPart))
	    ino = fii.FileId.QuadPart;
	}
    }
  return fstat_helper (buf, fsi.NumberOfLinks);
}

int __reg2
fhandler_base::fstat_by_name (struct stat *buf)
{
  NTSTATUS status;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  UNICODE_STRING dirname;
  UNICODE_STRING basename;
  HANDLE dir;
  struct {
    FILE_ID_BOTH_DIR_INFORMATION fdi;
    WCHAR buf[NAME_MAX + 1];
  } fdi_buf;

  if (!ino && pc.hasgood_inode () && !pc.has_buggy_fileid_dirinfo ())
    {
      RtlSplitUnicodePath (pc.get_nt_native_path (), &dirname, &basename);
      InitializeObjectAttributes (&attr, &dirname, pc.objcaseinsensitive (),
				  NULL, NULL);
      status = NtOpenFile (&dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			   &attr, &io, FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT
			   | FILE_DIRECTORY_FILE);
      if (!NT_SUCCESS (status))
	debug_printf ("%y = NtOpenFile(%S)", status,
		      pc.get_nt_native_path ());
      else
	{
	  status = NtQueryDirectoryFile (dir, NULL, NULL, NULL, &io,
					 &fdi_buf.fdi, sizeof fdi_buf,
					 FileIdBothDirectoryInformation,
					 TRUE, &basename, TRUE);
	  NtClose (dir);
	  if (!NT_SUCCESS (status))
	    debug_printf ("%y = NtQueryDirectoryFile(%S)", status,
			  pc.get_nt_native_path ());
	  else
	    ino = fdi_buf.fdi.FileId.QuadPart;
	}
    }
  return fstat_helper (buf, 1);
}

int __reg2
fhandler_base::fstat_fs (struct stat *buf)
{
  int res = -1;
  int oret;
  int open_flags = O_RDONLY | O_BINARY;

  if (get_stat_handle ())
    {
      if (!nohandle () && !is_fs_special ())
	res = pc.fs_is_nfs () ? fstat_by_nfs_ea (buf) : fstat_by_handle (buf);
      if (res)
	res = fstat_by_name (buf);
      return res;
    }
  /* First try to open with generic read access.  This allows to read the file
     in fstat_helper (when checking for executability) without having to
     re-open it.  Opening a file can take a lot of time on network drives
     so we try to avoid that. */
  oret = open_fs (open_flags, 0);
  if (!oret)
    {
      query_open (query_read_attributes);
      oret = open_fs (open_flags, 0);
    }
  if (oret)
    {
      /* We now have a valid handle, regardless of the "nohandle" state.
	 Since fhandler_base::close only calls CloseHandle if !nohandle,
	 we have to set it to false before calling close and restore
	 the state afterwards. */
      res = pc.fs_is_nfs () ? fstat_by_nfs_ea (buf) : fstat_by_handle (buf);
      bool no_handle = nohandle ();
      nohandle (false);
      close_fs ();
      nohandle (no_handle);
      set_io_handle (NULL);
    }
  if (res)
    res = fstat_by_name (buf);

  return res;
}

int __reg3
fhandler_base::fstat_helper (struct stat *buf, DWORD nNumberOfLinks)
{
  IO_STATUS_BLOCK st;
  FILE_COMPRESSION_INFORMATION fci;
  HANDLE h = get_stat_handle ();
  PFILE_NETWORK_OPEN_INFORMATION pfnoi = pc.fnoi ();
  ULONG attributes = pc.file_attributes ();

  to_timestruc_t (&pfnoi->LastAccessTime, &buf->st_atim);
  to_timestruc_t (&pfnoi->LastWriteTime, &buf->st_mtim);
  /* If the ChangeTime is 0, the underlying FS doesn't support this timestamp
     (FAT for instance).  If so, it's faked using LastWriteTime. */
  to_timestruc_t (pfnoi->ChangeTime.QuadPart ? &pfnoi->ChangeTime
					     : &pfnoi->LastWriteTime,
		  &buf->st_ctim);
  to_timestruc_t (&pfnoi->CreationTime, &buf->st_birthtim);
  buf->st_dev = get_dev ();
  /* CV 2011-01-13: Observations on the Cygwin mailing list point to an
     interesting behaviour in some Windows versions.  Apparently the size of
     a directory is computed at the time the directory is first scanned.  This
     can result in two subsequent NtQueryInformationFile calls to return size
     0 in the first call and size > 0 in the second call.  This in turn can
     affect applications like newer tar.
     FIXME: Is the allocation size affected as well? */
  buf->st_size = pc.isdir () ? 0 : (off_t) pfnoi->EndOfFile.QuadPart;
  /* The number of links to a directory includes the number of subdirectories
     in the directory, since all those subdirectories point to it.  However,
     this is painfully slow, so we do without it. */
#if 0
  buf->st_nlink = pc.ndisk_links (nNumberOfLinks);
#else
  buf->st_nlink = nNumberOfLinks;
#endif

  /* Enforce namehash as inode number on untrusted file systems. */
  if (ino && pc.isgood_inode (ino))
    buf->st_ino = (ino_t) ino;
  else
    buf->st_ino = get_ino ();

  buf->st_blksize = PREFERRED_IO_BLKSIZE;

  if (pfnoi->AllocationSize.QuadPart >= 0LL)
    /* A successful NtQueryInformationFile returns the allocation size
       correctly for compressed and sparse files as well. */
    buf->st_blocks = (pfnoi->AllocationSize.QuadPart + S_BLKSIZE - 1)
		     / S_BLKSIZE;
  else if (::has_attribute (attributes, FILE_ATTRIBUTE_COMPRESSED
					| FILE_ATTRIBUTE_SPARSE_FILE)
	   && h && !is_fs_special ()
	   && !NtQueryInformationFile (h, &st, (PVOID) &fci, sizeof fci,
				       FileCompressionInformation))
    /* Otherwise we request the actual amount of bytes allocated for
       compressed and sparsed files. */
    buf->st_blocks = (fci.CompressedFileSize.QuadPart + S_BLKSIZE - 1)
		     / S_BLKSIZE;
  else
    /* Otherwise compute no. of blocks from file size. */
    buf->st_blocks = (buf->st_size + S_BLKSIZE - 1) / S_BLKSIZE;

  buf->st_mode = 0;
  /* Using a side effect: get_file_attributes checks for directory.
     This is used, to set S_ISVTX, if needed.  */
  if (pc.isdir ())
    buf->st_mode = S_IFDIR;
  else if (pc.issymlink ())
    {
      buf->st_size = pc.get_symlink_length ();
      /* symlinks are everything for everyone! */
      buf->st_mode = S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;
      get_file_attribute (h, pc, NULL,
			  &buf->st_uid, &buf->st_gid);
      goto done;
    }
  else if (pc.issocket ())
    buf->st_mode = S_IFSOCK;

  if (!get_file_attribute (is_fs_special () && !pc.issocket () ? NULL : h, pc,
			   &buf->st_mode, &buf->st_uid, &buf->st_gid))
    {
      /* If read-only attribute is set, modify ntsec return value */
      if (::has_attribute (attributes, FILE_ATTRIBUTE_READONLY)
	  && !pc.isdir () && !pc.issymlink ())
	buf->st_mode &= ~(S_IWUSR | S_IWGRP | S_IWOTH);

      if (buf->st_mode & S_IFMT)
	/* nothing */;
      else if (!is_fs_special ())
	buf->st_mode |= S_IFREG;
      else
	{
	  buf->st_dev = buf->st_rdev = dev ();
	  buf->st_mode = dev ().mode;
	  buf->st_size = 0;
	}
    }
  else
    {
      buf->st_mode |= STD_RBITS;

      if (!::has_attribute (attributes, FILE_ATTRIBUTE_READONLY))
	buf->st_mode |= STD_WBITS;
      /* | S_IWGRP | S_IWOTH; we don't give write to group etc */

      if (pc.isdir ())
	buf->st_mode |= S_IFDIR | STD_WBITS | STD_XBITS;
      else if (buf->st_mode & S_IFMT)
	/* nothing */;
      else if (is_fs_special ())
	{
	  buf->st_dev = buf->st_rdev = dev ();
	  buf->st_mode = dev ().mode;
	  buf->st_size = 0;
	}
      else
	{
	  buf->st_mode |= S_IFREG;
	  /* Check suffix for executable file. */
	  if (pc.exec_state () != is_executable)
	    {
	      PUNICODE_STRING path = pc.get_nt_native_path ();

	      if (RtlEqualUnicodePathSuffix (path, &ro_u_exe, TRUE)
		  || RtlEqualUnicodePathSuffix (path, &ro_u_lnk, TRUE)
		  || RtlEqualUnicodePathSuffix (path, &ro_u_com, TRUE))
		pc.set_exec ();
	    }
	  /* No known suffix, check file header.  This catches binaries and
	     shebang scripts. */
	  if (pc.exec_state () == dont_know_if_executable)
	    {
	      OBJECT_ATTRIBUTES attr;
	      NTSTATUS status = 0;
	      IO_STATUS_BLOCK io;

	      /* We have to re-open the file.  Either the file is not opened
		 for reading, or the read will change the file position of the
		 original handle. */
	      status = NtOpenFile (&h, SYNCHRONIZE | FILE_READ_DATA,
				   pc.init_reopen_attr (attr, h), &io,
				   FILE_SHARE_VALID_FLAGS,
				   FILE_OPEN_FOR_BACKUP_INTENT
				   | FILE_SYNCHRONOUS_IO_NONALERT);
	      if (!NT_SUCCESS (status))
		debug_printf ("%y = NtOpenFile(%S)", status,
			      pc.get_nt_native_path ());
	      else
		{
		  LARGE_INTEGER off = { QuadPart:0LL };
		  char magic[3];

		  status = NtReadFile (h, NULL, NULL, NULL,
				       &io, magic, 3, &off, NULL);
		  if (!NT_SUCCESS (status))
		    debug_printf ("%y = NtReadFile(%S)", status,
				  pc.get_nt_native_path ());
		  else if (has_exec_chars (magic, io.Information))
		    {
		      /* Heureka, it's an executable */
		      pc.set_exec ();
		      buf->st_mode |= STD_XBITS;
		    }
		  NtClose (h);
		}
	    }
	}
      if (pc.exec_state () == is_executable)
	buf->st_mode |= STD_XBITS;

      /* This fakes the permissions of all files to match the current umask. */
      buf->st_mode &= ~(cygheap->umask);
      /* If the FS supports ACLs, we're here because we couldn't even open
	 the file for READ_CONTROL access.  Chances are high that the file's
	 security descriptor has no ACE for "Everyone", so we should not fake
	 any access for "others". */
      if (has_acls ())
	buf->st_mode &= ~(S_IROTH | S_IWOTH | S_IXOTH);
    }

 done:
  syscall_printf ("0 = fstat (%S, %p) st_size=%D, st_mode=0%o, st_ino=%D"
		  "st_atim=%lx.%lx st_ctim=%lx.%lx "
		  "st_mtim=%lx.%lx st_birthtim=%lx.%lx",
		  pc.get_nt_native_path (), buf,
		  buf->st_size, buf->st_mode, buf->st_ino,
		  buf->st_atim.tv_sec, buf->st_atim.tv_nsec,
		  buf->st_ctim.tv_sec, buf->st_ctim.tv_nsec,
		  buf->st_mtim.tv_sec, buf->st_mtim.tv_nsec,
		  buf->st_birthtim.tv_sec, buf->st_birthtim.tv_nsec);
  return 0;
}

int __reg2
fhandler_disk_file::fstat (struct stat *buf)
{
  return fstat_fs (buf);
}

int __reg2
fhandler_disk_file::fstatvfs (struct statvfs *sfs)
{
  int ret = -1, opened = 0;
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  FILE_FS_FULL_SIZE_INFORMATION full_fsi;
  /* We must not use the stat handle here, even if it exists.  The handle
     has been opened with FILE_OPEN_REPARSE_POINT, thus, in case of a volume
     mount point, it points to the FS of the mount point, rather than to the
     mounted FS. */
  HANDLE fh = get_handle ();

  if (!fh)
    {
      OBJECT_ATTRIBUTES attr;
      opened = NT_SUCCESS (NtOpenFile (&fh, READ_CONTROL,
				       pc.get_object_attr (attr, sec_none_nih),
				       &io, FILE_SHARE_VALID_FLAGS,
				       FILE_OPEN_FOR_BACKUP_INTENT));
      if (!opened)
	{
	  /* Can't open file.  Try again with parent dir. */
	  UNICODE_STRING dirname;
	  RtlSplitUnicodePath (pc.get_nt_native_path (), &dirname, NULL);
	  attr.ObjectName = &dirname;
	  opened = NT_SUCCESS (NtOpenFile (&fh, READ_CONTROL, &attr, &io,
					   FILE_SHARE_VALID_FLAGS,
					   FILE_OPEN_FOR_BACKUP_INTENT));
	  if (!opened)
	    goto out;
	}
    }

  sfs->f_files = ULONG_MAX;
  sfs->f_ffree = ULONG_MAX;
  sfs->f_favail = ULONG_MAX;
  sfs->f_fsid = pc.fs_serial_number ();
  sfs->f_flag = pc.fs_flags ();
  sfs->f_namemax = pc.fs_name_len ();
  /* Get allocation related information. */
  status = NtQueryVolumeInformationFile (fh, &io, &full_fsi, sizeof full_fsi,
					 FileFsFullSizeInformation);
  if (NT_SUCCESS (status))
    {
      sfs->f_bsize = full_fsi.BytesPerSector * full_fsi.SectorsPerAllocationUnit;
      sfs->f_frsize = sfs->f_bsize;
      sfs->f_blocks = (fsblkcnt_t) full_fsi.TotalAllocationUnits.QuadPart;
      sfs->f_bfree = (fsblkcnt_t)
		     full_fsi.ActualAvailableAllocationUnits.QuadPart;
      sfs->f_bavail = (fsblkcnt_t)
		      full_fsi.CallerAvailableAllocationUnits.QuadPart;
      if (sfs->f_bfree > sfs->f_bavail)
	{
	  /* Quotas active.  We can't trust TotalAllocationUnits. */
	  NTFS_VOLUME_DATA_BUFFER nvdb;

	  status = NtFsControlFile (fh, NULL, NULL, NULL, &io,
				    FSCTL_GET_NTFS_VOLUME_DATA,
				    NULL, 0, &nvdb, sizeof nvdb);
	  if (!NT_SUCCESS (status))
	    debug_printf ("%y = NtFsControlFile(%S, FSCTL_GET_NTFS_VOLUME_DATA)",
			  status, pc.get_nt_native_path ());
	  else
	    sfs->f_blocks = (fsblkcnt_t) nvdb.TotalClusters.QuadPart;
	}
      ret = 0;
    }
  else if (status == STATUS_INVALID_PARAMETER /* Netapp */
	   || status == STATUS_INVALID_INFO_CLASS)
    {
      FILE_FS_SIZE_INFORMATION fsi;
      status = NtQueryVolumeInformationFile (fh, &io, &fsi, sizeof fsi,
					     FileFsSizeInformation);
      if (NT_SUCCESS (status))
	{
	  sfs->f_bsize = fsi.BytesPerSector * fsi.SectorsPerAllocationUnit;
	  sfs->f_frsize = sfs->f_bsize;
	  sfs->f_blocks = (fsblkcnt_t) fsi.TotalAllocationUnits.QuadPart;
	  sfs->f_bfree = sfs->f_bavail =
	    (fsblkcnt_t) fsi.AvailableAllocationUnits.QuadPart;
	  ret = 0;
	}
      else
	debug_printf ("%y = NtQueryVolumeInformationFile"
		      "(%S, FileFsSizeInformation)", 
		      status, pc.get_nt_native_path ());
    }
  else
    debug_printf ("%y = NtQueryVolumeInformationFile"
		  "(%S, FileFsFullSizeInformation)", 
		  status, pc.get_nt_native_path ());
out:
  if (opened)
    NtClose (fh);
  syscall_printf ("%d = fstatvfs(%s, %p)", ret, get_name (), sfs);
  return ret;
}

int __reg1
fhandler_disk_file::fchmod (mode_t mode)
{
  extern int chmod_device (path_conv& pc, mode_t mode);
  int res = -1;
  int oret = 0;
  NTSTATUS status;
  IO_STATUS_BLOCK io;

  if (pc.is_fs_special ())
    return chmod_device (pc, mode);

  if (!get_handle ())
    {
      query_open (query_write_dac);
      if (!(oret = open (O_BINARY, 0)))
	{
	  /* Need WRITE_DAC|WRITE_OWNER to write ACLs. */
	  if (pc.has_acls ())
	    return -1;
	  /* Otherwise FILE_WRITE_ATTRIBUTES is sufficient. */
	  query_open (query_write_attributes);
	  if (!(oret = open (O_BINARY, 0)))
	    return -1;
	}
    }

  if (pc.fs_is_nfs ())
    {
      /* chmod on NFS shares works by writing an EA of type NfsV3Attributes.
	 Only type and mode have to be set.  Apparently type isn't checked
	 for consistency, so it's sufficent to set it to NF3REG all the time. */
      struct {
	FILE_FULL_EA_INFORMATION ffei;
	char buf[sizeof (NFS_V3_ATTR) + sizeof (fattr3)];
      } ffei_buf;
      ffei_buf.ffei.NextEntryOffset = 0;
      ffei_buf.ffei.Flags = 0;
      ffei_buf.ffei.EaNameLength = sizeof (NFS_V3_ATTR) - 1;
      ffei_buf.ffei.EaValueLength = sizeof (fattr3);
      strcpy (ffei_buf.ffei.EaName, NFS_V3_ATTR);
      fattr3 *nfs_attr = (fattr3 *) (ffei_buf.ffei.EaName
				     + ffei_buf.ffei.EaNameLength + 1);
      memset (nfs_attr, 0, sizeof (fattr3));
      nfs_attr->type = NF3REG;
      nfs_attr->mode = mode;
      status = NtSetEaFile (get_handle (), &io,
			    &ffei_buf.ffei, sizeof ffei_buf);
      if (!NT_SUCCESS (status))
	__seterrno_from_nt_status (status);
      else
	res = 0;
      goto out;
    }

  if (pc.has_acls ())
    {
      if (pc.isdir ())
	mode |= S_IFDIR;
      if (!set_file_attribute (get_handle (), pc,
			       ILLEGAL_UID, ILLEGAL_GID, mode))
	res = 0;
    }

  /* If the mode has any write bits set, the DOS R/O flag is in the way. */
  if (mode & (S_IWUSR | S_IWGRP | S_IWOTH))
    pc &= (DWORD) ~FILE_ATTRIBUTE_READONLY;
  else if (!pc.has_acls ())	/* Never set DOS R/O if security is used. */
    pc |= (DWORD) FILE_ATTRIBUTE_READONLY;
  if (S_ISSOCK (mode))
    pc |= (DWORD) FILE_ATTRIBUTE_SYSTEM;

  status = NtSetAttributesFile (get_handle (), pc.file_attributes ());
  /* MVFS needs a good amount of kicking to be convinced that it has to write
     back metadata changes and to invalidate the cached metadata information
     stored for the given handle.  This method to open a second handle to
     the file and write the same metadata information twice has been found
     experimentally: http://cygwin.com/ml/cygwin/2009-07/msg00533.html */
  if (pc.fs_is_mvfs () && NT_SUCCESS (status) && !oret)
    {
      OBJECT_ATTRIBUTES attr;
      HANDLE fh;

      if (NT_SUCCESS (NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES,
      				  pc.init_reopen_attr (attr, get_handle ()),
				  &io, FILE_SHARE_VALID_FLAGS,
				  FILE_OPEN_FOR_BACKUP_INTENT)))
	{
	  NtSetAttributesFile (fh, pc.file_attributes ());
	  NtClose (fh);
	}
    }
  /* Correct NTFS security attributes have higher priority */
  if (!pc.has_acls ())
    {
      if (!NT_SUCCESS (status))
	__seterrno_from_nt_status (status);
      else
	res = 0;
    }

out:
  if (oret)
    close_fs ();

  return res;
}

int __reg2
fhandler_disk_file::fchown (uid_t uid, gid_t gid)
{
  int oret = 0;

  if (!pc.has_acls ())
    {
      /* fake - if not supported, pretend we're like win95
	 where it just works */
      /* FIXME: Could be supported on NFS when user->uid mapping is in place. */
      return 0;
    }

  if (!get_handle ())
    {
      query_open (query_write_control);
      if (!(oret = fhandler_disk_file::open (O_BINARY, 0)))
	return -1;
    }

  mode_t attrib = 0;
  if (pc.isdir ())
    attrib |= S_IFDIR;
  uid_t old_uid;
  int res = get_file_attribute (get_handle (), pc, &attrib, &old_uid, NULL);
  if (!res)
    {
      /* Typical Windows default ACLs can contain permissions for one
	 group, while being owned by another user/group.  The permission
	 bits returned above are pretty much useless then.  Creating a
	 new ACL with these useless permissions results in a potentially
	 broken symlink.  So what we do here is to set the underlying
	 permissions of symlinks to a sensible value which allows the
	 world to read the symlink and only the new owner to change it. */
      if (pc.issymlink ())
	attrib = S_IFLNK | STD_RBITS | STD_WBITS;
      res = set_file_attribute (get_handle (), pc, uid, gid, attrib);
      /* If you're running a Samba server which has no winbind running, the
	 uid<->SID mapping is disfunctional.  Even trying to chown to your
	 own account fails since the account used on the server is the UNIX
	 account which gets used for the standard user mapping.  This is a
	 default mechanism which doesn't know your real Windows SID.
	 There are two possible error codes in different Samba releases for
	 this situation, one of them is unfortunately the not very significant
	 STATUS_ACCESS_DENIED.  Instead of relying on the error codes, we're
	 using the below very simple heuristic.  If set_file_attribute failed,
	 and the original user account was either already unknown, or one of
	 the standard UNIX accounts, we're faking success. */
      if (res == -1 && pc.fs_is_samba ())
	{
	  cygsid sid;

	  if (old_uid == ILLEGAL_UID
	      || (sid.getfrompw (internal_getpwuid (old_uid))
		  && RtlEqualPrefixSid (sid,
					well_known_samba_unix_user_fake_sid)))
	    {
	      debug_printf ("Faking chown worked on standalone Samba");
	      res = 0;
	    }
	}
    }
  if (oret)
    close_fs ();

  return res;
}

int __reg3
fhandler_disk_file::facl (int cmd, int nentries, aclent_t *aclbufp)
{
  int res = -1;
  int oret = 0;

  if (!pc.has_acls ())
    {
cant_access_acl:
      switch (cmd)
	{

	  case SETACL:
	    /* Open for writing required to be able to set ctime
	       (even though setting the ACL is just pretended). */
	    if (!get_handle ())
	      oret = open (O_WRONLY | O_BINARY, 0);
	    res = 0;
	    break;
	  case GETACL:
	    if (!aclbufp)
	      set_errno (EFAULT);
	    else if (nentries < MIN_ACL_ENTRIES)
	      set_errno (ENOSPC);
	    else
	      {
		struct stat st;
		if (!fstat (&st))
		  {
		    aclbufp[0].a_type = USER_OBJ;
		    aclbufp[0].a_id = st.st_uid;
		    aclbufp[0].a_perm = (st.st_mode & S_IRWXU) >> 6;
		    aclbufp[1].a_type = GROUP_OBJ;
		    aclbufp[1].a_id = st.st_gid;
		    aclbufp[1].a_perm = (st.st_mode & S_IRWXG) >> 3;
		    aclbufp[2].a_type = OTHER_OBJ;
		    aclbufp[2].a_id = ILLEGAL_GID;
		    aclbufp[2].a_perm = st.st_mode & S_IRWXO;
		    res = MIN_ACL_ENTRIES;
		  }
	      }
	    break;
	  case GETACLCNT:
	    res = MIN_ACL_ENTRIES;
	    break;
	  default:
	    set_errno (EINVAL);
	    break;
	}
    }
  else
    {
      if ((cmd == SETACL && !get_handle ())
	  || (cmd != SETACL && !get_stat_handle ()))
	{
	  query_open (cmd == SETACL ? query_write_control : query_read_control);
	  if (!(oret = open (O_BINARY, 0)))
	    {
	      if (cmd == GETACL || cmd == GETACLCNT)
		goto cant_access_acl;
	      return -1;
	    }
	}
      switch (cmd)
	{
	  case SETACL:
	    if (!aclsort32 (nentries, 0, aclbufp))
	      {
		bool rw = false;
		res = setacl (get_handle (), pc, nentries, aclbufp, rw);
		if (rw)
		  {
		    IO_STATUS_BLOCK io;
		    FILE_BASIC_INFORMATION fbi;
		    fbi.CreationTime.QuadPart
		    = fbi.LastAccessTime.QuadPart
		    = fbi.LastWriteTime.QuadPart
		    = fbi.ChangeTime.QuadPart = 0LL;
		    fbi.FileAttributes = (pc.file_attributes ()
					  & ~FILE_ATTRIBUTE_READONLY)
					 ?: FILE_ATTRIBUTE_NORMAL;
		    NtSetInformationFile (get_handle (), &io, &fbi, sizeof fbi,
					  FileBasicInformation);
		  }
	      }
	    break;
	  case GETACL:
	    if (!aclbufp)
	      set_errno(EFAULT);
	    else
	      res = getacl (get_stat_handle (), pc, nentries, aclbufp);
	      /* For this ENOSYS case, see security.cc:get_file_attribute(). */
	      if (res == -1 && get_errno () == ENOSYS)
		goto cant_access_acl;
	    break;
	  case GETACLCNT:
	    res = getacl (get_stat_handle (), pc, 0, NULL);
	    /* Ditto. */
	    if (res == -1 && get_errno () == ENOSYS)
	      goto cant_access_acl;
	    break;
	  default:
	    set_errno (EINVAL);
	    break;
	}
    }

  if (oret)
    close_fs ();

  return res;
}

ssize_t
fhandler_disk_file::fgetxattr (const char *name, void *value, size_t size)
{
  if (pc.is_fs_special ())
    {
      set_errno (ENOTSUP);
      return -1;
    }
  return read_ea (get_handle (), pc, name, (char *) value, size);
}

int
fhandler_disk_file::fsetxattr (const char *name, const void *value, size_t size,
			       int flags)
{
  if (pc.is_fs_special ())
    {
      set_errno (ENOTSUP);
      return -1;
    }
  return write_ea (get_handle (), pc, name, (const char *) value, size, flags);
}

int
fhandler_disk_file::fadvise (off_t offset, off_t length, int advice)
{
  if (advice < POSIX_FADV_NORMAL || advice > POSIX_FADV_NOREUSE)
    {
      set_errno (EINVAL);
      return -1;
    }

  /* Windows only supports advice flags for the whole file.  We're using
     a simplified test here so that we don't have to ask for the actual
     file size.  Length == 0 means all bytes starting at offset anyway.
     So we only actually follow the advice, if it's given for offset == 0. */
  if (offset != 0)
    return 0;

  /* We only support normal and sequential mode for now.  Everything which
     is not POSIX_FADV_SEQUENTIAL is treated like POSIX_FADV_NORMAL. */
  if (advice != POSIX_FADV_SEQUENTIAL)
    advice = POSIX_FADV_NORMAL;

  IO_STATUS_BLOCK io;
  FILE_MODE_INFORMATION fmi;
  NTSTATUS status = NtQueryInformationFile (get_handle (), &io,
					    &fmi, sizeof fmi,
					    FileModeInformation);
  if (!NT_SUCCESS (status))
    __seterrno_from_nt_status (status);
  else
    {
      fmi.Mode &= ~FILE_SEQUENTIAL_ONLY;
      if (advice == POSIX_FADV_SEQUENTIAL)
	fmi.Mode |= FILE_SEQUENTIAL_ONLY;
      status = NtSetInformationFile (get_handle (), &io, &fmi, sizeof fmi,
				     FileModeInformation);
      if (NT_SUCCESS (status))
	return 0;
      __seterrno_from_nt_status (status);
    }

  return -1;
}

int
fhandler_disk_file::ftruncate (off_t length, bool allow_truncate)
{
  int res = -1;

  if (length < 0 || !get_handle ())
    set_errno (EINVAL);
  else if (pc.isdir ())
    set_errno (EISDIR);
  else if (!(get_access () & GENERIC_WRITE))
    set_errno (EBADF);
  else
    {
      NTSTATUS status;
      IO_STATUS_BLOCK io;
      FILE_STANDARD_INFORMATION fsi;
      FILE_END_OF_FILE_INFORMATION feofi;

      status = NtQueryInformationFile (get_handle (), &io, &fsi, sizeof fsi,
				       FileStandardInformation);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  return -1;
	}

      /* If called through posix_fallocate, silently succeed if length
	 is less than the file's actual length. */
      if (!allow_truncate && length < fsi.EndOfFile.QuadPart)
	return 0;

      feofi.EndOfFile.QuadPart = length;
      /* Create sparse files only when called through ftruncate, not when
	 called through posix_fallocate. */
      if (allow_truncate && pc.support_sparse ()
	  && !has_attribute (FILE_ATTRIBUTE_SPARSE_FILE)
	  && length >= fsi.EndOfFile.QuadPart + (128 * 1024))
	{
	  status = NtFsControlFile (get_handle (), NULL, NULL, NULL, &io,
				    FSCTL_SET_SPARSE, NULL, 0, NULL, 0);
	  if (NT_SUCCESS (status))
	    pc.file_attributes (pc.file_attributes ()
			        | FILE_ATTRIBUTE_SPARSE_FILE);
	  syscall_printf ("%y = NtFsControlFile(%S, FSCTL_SET_SPARSE)",
			  status, pc.get_nt_native_path ());
	}
      status = NtSetInformationFile (get_handle (), &io,
				     &feofi, sizeof feofi,
				     FileEndOfFileInformation);
      if (!NT_SUCCESS (status))
	__seterrno_from_nt_status (status);
      else
	res = 0;
    }
  return res;
}

int
fhandler_disk_file::link (const char *newpath)
{
  size_t nlen = strlen (newpath);
  path_conv newpc (newpath, PC_SYM_NOFOLLOW | PC_POSIX | PC_NULLEMPTY, stat_suffixes);
  if (newpc.error)
    {
      set_errno (newpc.error);
      return -1;
    }

  if (newpc.exists ())
    {
      syscall_printf ("file '%S' exists?", newpc.get_nt_native_path ());
      set_errno (EEXIST);
      return -1;
    }

  if (isdirsep (newpath[nlen - 1]) || has_dot_last_component (newpath, false))
    {
      set_errno (ENOENT);
      return -1;
    }

  char new_buf[nlen + 5];
  if (!newpc.error)
    {
      /* If the original file is a lnk special file (except for sockets),
	 and if the original file has a .lnk suffix, add one to the hardlink
	 as well. */
      if (pc.is_lnk_special () && !pc.issocket ()
	  && RtlEqualUnicodePathSuffix (pc.get_nt_native_path (),
					&ro_u_lnk, TRUE))
	{
	  /* Shortcut hack. */
	  stpcpy (stpcpy (new_buf, newpath), ".lnk");
	  newpath = new_buf;
	  newpc.check (newpath, PC_SYM_NOFOLLOW);
	}
      else if (!pc.isdir ()
	       && pc.is_binary ()
	       && RtlEqualUnicodePathSuffix (pc.get_nt_native_path (),
					     &ro_u_exe, TRUE)
	       && !RtlEqualUnicodePathSuffix (newpc.get_nt_native_path (),
					      &ro_u_exe, TRUE))
	{
	  /* Executable hack. */
	  stpcpy (stpcpy (new_buf, newpath), ".exe");
	  newpath = new_buf;
	  newpc.check (newpath, PC_SYM_NOFOLLOW);
	}
    }

  /* We only need READ_CONTROL access so the handle returned in pc is
     sufficient.  And if the file couldn't be opened with READ_CONTROL
     access in path_conv, we won't be able to do it here anyway. */
  HANDLE fh = get_stat_handle ();
  if (!fh)
    {
      set_errno (EACCES);
      return -1;
    }
  PUNICODE_STRING tgt = newpc.get_nt_native_path ();
  ULONG size = sizeof (FILE_LINK_INFORMATION) + tgt->Length;
  PFILE_LINK_INFORMATION pfli = (PFILE_LINK_INFORMATION) alloca (size);
  pfli->ReplaceIfExists = FALSE;
  pfli->RootDirectory = NULL;
  memcpy (pfli->FileName, tgt->Buffer, pfli->FileNameLength = tgt->Length);

  NTSTATUS status;
  IO_STATUS_BLOCK io;
  status = NtSetInformationFile (fh, &io, pfli, size, FileLinkInformation);
  if (!NT_SUCCESS (status))
    {
      if (status == STATUS_INVALID_DEVICE_REQUEST
	  || status == STATUS_NOT_SUPPORTED)
	{
	  /* FS doesn't support hard links.  Linux returns EPERM. */
	  set_errno (EPERM);
	  return -1;
	}
      else
	{
	  __seterrno_from_nt_status (status);
	  return -1;
	}
    }
  return 0;
}

int
fhandler_disk_file::utimens (const struct timespec *tvp)
{
  return utimens_fs (tvp);
}

int
fhandler_base::utimens_fs (const struct timespec *tvp)
{
  struct timespec timeofday;
  struct timespec tmp[2];
  bool closeit = false;

  if (!get_handle ())
    {
      query_open (query_write_attributes);
      if (!open_fs (O_BINARY, 0))
	{
	  /* It's documented in MSDN that FILE_WRITE_ATTRIBUTES is sufficient
	     to change the timestamps.  Unfortunately it's not sufficient for a
	     remote HPFS which requires GENERIC_WRITE, so we just retry to open
	     for writing, though this fails for R/O files of course. */
	  query_open (no_query);
	  if (!open_fs (O_WRONLY | O_BINARY, 0))
	    {
	      syscall_printf ("Opening file failed");
	      return -1;
	    }
	}
      closeit = true;
    }

  clock_gettime (CLOCK_REALTIME, &timeofday);
  if (!tvp)
    tmp[1] = tmp[0] = timeofday;
  else
    {
      if ((tvp[0].tv_nsec < UTIME_NOW || tvp[0].tv_nsec > 999999999L)
	  || (tvp[1].tv_nsec < UTIME_NOW || tvp[1].tv_nsec > 999999999L))
	{
	  if (closeit)
	    close_fs ();
	  set_errno (EINVAL);
	  return -1;
	}
      tmp[0] = (tvp[0].tv_nsec == UTIME_NOW) ? timeofday : tvp[0];
      tmp[1] = (tvp[1].tv_nsec == UTIME_NOW) ? timeofday : tvp[1];
    }
  debug_printf ("incoming lastaccess %ly %ly", tmp[0].tv_sec, tmp[0].tv_nsec);

  IO_STATUS_BLOCK io;
  FILE_BASIC_INFORMATION fbi;

  fbi.CreationTime.QuadPart = 0LL;
  /* UTIME_OMIT is handled in timespec_to_filetime by setting FILETIME to 0. */
  timespec_to_filetime (&tmp[0], &fbi.LastAccessTime);
  timespec_to_filetime (&tmp[1], &fbi.LastWriteTime);
  fbi.ChangeTime.QuadPart = 0LL;
  fbi.FileAttributes = 0;
  NTSTATUS status = NtSetInformationFile (get_handle (), &io, &fbi, sizeof fbi,
					  FileBasicInformation);
  /* For this special case for MVFS see the comment in
     fhandler_disk_file::fchmod. */
  if (pc.fs_is_mvfs () && NT_SUCCESS (status) && !closeit)
    {
      OBJECT_ATTRIBUTES attr;
      HANDLE fh;

      if (NT_SUCCESS (NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES,
				  pc.init_reopen_attr (attr, get_handle ()),
				  &io, FILE_SHARE_VALID_FLAGS,
				  FILE_OPEN_FOR_BACKUP_INTENT)))
	{
	  NtSetInformationFile (fh, &io, &fbi, sizeof fbi,
				FileBasicInformation);
	  NtClose (fh);
	}
    }
  if (closeit)
    close_fs ();
  /* Opening a directory on a 9x share from a NT machine works(!), but
     then NtSetInformationFile fails with STATUS_NOT_SUPPORTED.  Oh well... */
  if (!NT_SUCCESS (status) && status != STATUS_NOT_SUPPORTED)
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  return 0;
}

fhandler_disk_file::fhandler_disk_file () :
  fhandler_base (), prw_handle (NULL)
{
}

fhandler_disk_file::fhandler_disk_file (path_conv &pc) :
  fhandler_base (), prw_handle (NULL)
{
  set_name (pc);
}

int
fhandler_disk_file::open (int flags, mode_t mode)
{
  return open_fs (flags, mode);
}

int
fhandler_disk_file::close ()
{
  /* Close extra pread/pwrite handle, if it exists. */
  if (prw_handle)
    NtClose (prw_handle);
  return fhandler_base::close ();
}

int
fhandler_disk_file::fcntl (int cmd, intptr_t arg)
{
  int res;

  switch (cmd)
    {
    case F_LCK_MANDATORY:	/* Mandatory locking only works on files. */
      mandatory_locking (!!arg);
      need_fork_fixup (true);
      res = 0;
      break;
    default:
      res = fhandler_base::fcntl (cmd, arg);
      break;
    }
  return res;
}

int
fhandler_disk_file::dup (fhandler_base *child, int flags)
{
  fhandler_disk_file *fhc = (fhandler_disk_file *) child;

  int ret = fhandler_base::dup (child, flags);
  if (!ret && prw_handle
      && !DuplicateHandle (GetCurrentProcess (), prw_handle,
			   GetCurrentProcess (), &fhc->prw_handle,
			   0, TRUE, DUPLICATE_SAME_ACCESS))
    fhc->prw_handle = NULL;
  return ret;
}

void
fhandler_disk_file::fixup_after_fork (HANDLE parent)
{
  prw_handle = NULL;
  mandatory_locking (false);
  fhandler_base::fixup_after_fork (parent);
}

int
fhandler_base::open_fs (int flags, mode_t mode)
{
  /* Unfortunately NT allows to open directories for writing, but that's
     disallowed according to SUSv3. */
  if (pc.isdir () && (flags & O_ACCMODE) != O_RDONLY)
    {
      set_errno (EISDIR);
      return 0;
    }

  int res = fhandler_base::open (flags | O_DIROPEN, mode);
  if (!res)
    goto out;

  /* This is for file systems known for having a buggy CreateFile call
     which might return a valid HANDLE without having actually opened
     the file.
     The only known file system to date is the SUN NFS Solstice Client 3.1
     which returns a valid handle when trying to open a file in a nonexistent
     directory. */
  if (pc.has_buggy_open () && !pc.exists ())
    {
      debug_printf ("Buggy open detected.");
      close_fs ();
      set_errno (ENOENT);
      return 0;
    }

  ino = pc.get_ino_by_handle (get_handle ());

out:
  syscall_printf ("%d = fhandler_disk_file::open(%S, %y)", res,
		  pc.get_nt_native_path (), flags);
  return res;
}

/* POSIX demands that pread/pwrite don't change the current file position.
   While NtReadFile/NtWriteFile support atomic seek-and-io, both change the
   file pointer if the file handle has been opened for synchonous I/O.
   Using this handle for pread/pwrite would break atomicity, because the
   read/write operation would have to be followed by a seek back to the old
   file position.  What we do is to open another handle to the file on the
   first call to either pread or pwrite.  This is used for any subsequent
   pread/pwrite.  Thus the current file position of the "normal" file
   handle is not touched.

   FIXME:

   Note that this is just a hack.  The problem with this approach is that
   a change to the file permissions might disallow to open the file with
   the required permissions to read or write.  This appears to be a border case,
   but that's exactly what git does.  It creates the file for reading and
   writing and after writing it, it chmods the file to read-only.  Then it
   calls pread on the file to examine the content.  This works, but if git
   would use the original handle to pwrite to the file, it would be broken
   with our approach.

   One way to implement this is to open the pread/pwrite handle right at
   file open time.  We would simply maintain two handles, which wouldn't
   be much of a problem given how we do that for other fhandler types as
   well.

   However, ultimately fhandler_disk_file should become a derived class of
   fhandler_base_overlapped.  Each raw_read or raw_write would fetch the
   actual file position, read/write from there, and then set the file
   position again.  Fortunately, while the file position is not maintained
   by the I/O manager, it can be fetched and set to a new value by all
   processes holding a handle to that file object.  Pread and pwrite differ
   from raw_read and raw_write just by not touching the current file pos.
   Actually they could be merged with raw_read/raw_write if we add a position
   parameter to the latter. */

int
fhandler_disk_file::prw_open (bool write)
{
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  OBJECT_ATTRIBUTES attr;

  /* First try to open with the original access mask */
  ACCESS_MASK access = get_access ();
  status = NtOpenFile (&prw_handle, access,
		       pc.init_reopen_attr (attr, get_handle ()), &io,
		       FILE_SHARE_VALID_FLAGS, get_options ());
  if (status == STATUS_ACCESS_DENIED)
    {
      /* If we get an access denied, chmod has been called.  Try again
	 with just the required rights to perform the called function. */
      access &= write ? ~GENERIC_READ : ~GENERIC_WRITE;
      status = NtOpenFile (&prw_handle, access, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, get_options ());
    }
  debug_printf ("%y = NtOpenFile (%p, %y, %S, io, %y, %y)",
		status, prw_handle, access, pc.get_nt_native_path (),
		FILE_SHARE_VALID_FLAGS, get_options ());
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  return 0;
}

ssize_t __reg3
fhandler_disk_file::pread (void *buf, size_t count, off_t offset)
{
  ssize_t res;

  if ((get_flags () & O_ACCMODE) == O_WRONLY)
    {
      set_errno (EBADF);
      return -1;
    }

  /* In binary mode, we can use an atomic NtReadFile call.
     Windows mandatory locking semantics disallow to use another HANDLE. */
  if (rbinary () && !mandatory_locking ())
    {
      extern int __stdcall is_at_eof (HANDLE h);
      NTSTATUS status;
      IO_STATUS_BLOCK io;
      LARGE_INTEGER off = { QuadPart:offset };

      if (!prw_handle && prw_open (false))
	goto non_atomic;
      status = NtReadFile (prw_handle, NULL, NULL, NULL, &io, buf, count,
			   &off, NULL);
      if (!NT_SUCCESS (status) && status != STATUS_END_OF_FILE)
	{
	  if (pc.isdir ())
	    {
	      set_errno (EISDIR);
	      return -1;
	    }
	  if (status == (NTSTATUS) STATUS_ACCESS_VIOLATION)
	    {
	      if (is_at_eof (prw_handle))
		return 0;
	      switch (mmap_is_attached_or_noreserve (buf, count))
		{
		case MMAP_NORESERVE_COMMITED:
		  status = NtReadFile (prw_handle, NULL, NULL, NULL, &io,
				       buf, count, &off, NULL);
		  if (NT_SUCCESS (status))
		    return io.Information;
		  break;
		case MMAP_RAISE_SIGBUS:
		  raise (SIGBUS);
		default:
		  break;
		}
	    }
	  __seterrno_from_nt_status (status);
	  return -1;
	}
      res = io.Information;	/* Valid on EOF. */
    }
  else
    {
non_atomic:
      /* Text mode stays slow and non-atomic. */
      off_t curpos = lseek (0, SEEK_CUR);
      if (curpos < 0 || lseek (offset, SEEK_SET) < 0)
	res = -1;
      else
	{
	  size_t tmp_count = count;
	  read (buf, tmp_count);
	  if (lseek (curpos, SEEK_SET) >= 0)
	    res = (ssize_t) tmp_count;
	  else
	    res = -1;
	}
    }
  debug_printf ("%d = pread(%p, %ld, %D)\n", res, buf, count, offset);
  return res;
}

ssize_t __reg3
fhandler_disk_file::pwrite (void *buf, size_t count, off_t offset)
{
  if ((get_flags () & O_ACCMODE) == O_RDONLY)
    {
      set_errno (EBADF);
      return -1;
    }

  /* In binary mode, we can use an atomic NtWriteFile call.
     Windows mandatory locking semantics disallow to use another HANDLE. */
  if (wbinary () && !mandatory_locking ())
    {
      NTSTATUS status;
      IO_STATUS_BLOCK io;
      LARGE_INTEGER off = { QuadPart:offset };

      if (!prw_handle && prw_open (true))
	goto non_atomic;
      status = NtWriteFile (prw_handle, NULL, NULL, NULL, &io, buf, count,
			    &off, NULL);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  return -1;
	}
      return io.Information;
    }

non_atomic:
  /* Text mode stays slow and non-atomic. */
  int res;
  off_t curpos = lseek (0, SEEK_CUR);
  if (curpos < 0 || lseek (offset, SEEK_SET) < 0)
    res = curpos;
  else
    {
      res = (ssize_t) write (buf, count);
      if (lseek (curpos, SEEK_SET) < 0)
	res = -1;
    }
  debug_printf ("%d = pwrite(%p, %ld, %D)\n", res, buf, count, offset);
  return res;
}

int
fhandler_disk_file::mkdir (mode_t mode)
{
  int res = -1;
  SECURITY_ATTRIBUTES sa = sec_none_nih;
  NTSTATUS status;
  HANDLE dir;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  PFILE_FULL_EA_INFORMATION p = NULL;
  ULONG plen = 0;
  ULONG access = FILE_LIST_DIRECTORY | SYNCHRONIZE;

  if (pc.fs_is_nfs ())
    {
      /* When creating a dir on an NFS share, we have to set the
	 file mode by writing a NFS fattr3 structure with the
	 correct mode bits set. */
      plen = sizeof (FILE_FULL_EA_INFORMATION) + sizeof (NFS_V3_ATTR)
	     + sizeof (fattr3);
      p = (PFILE_FULL_EA_INFORMATION) alloca (plen);
      p->NextEntryOffset = 0;
      p->Flags = 0;
      p->EaNameLength = sizeof (NFS_V3_ATTR) - 1;
      p->EaValueLength = sizeof (fattr3);
      strcpy (p->EaName, NFS_V3_ATTR);
      fattr3 *nfs_attr = (fattr3 *) (p->EaName + p->EaNameLength + 1);
      memset (nfs_attr, 0, sizeof (fattr3));
      nfs_attr->type = NF3DIR;
      nfs_attr->mode = (mode & 07777) & ~cygheap->umask;
    }
  else if (has_acls () && !isremote ())
    /* If the filesystem supports ACLs, we will overwrite the DACL after the
       call to NtCreateFile.  This requires a handle with READ_CONTROL and
       WRITE_DAC access, otherwise get_file_sd and set_file_sd both have to
       open the file again.
       FIXME: On remote NTFS shares open sometimes fails because even the
       creator of the file doesn't have the right to change the DACL.
       I don't know what setting that is or how to recognize such a share,
       so for now we don't request WRITE_DAC on remote drives. */
    access |= READ_CONTROL | WRITE_DAC;
  status = NtCreateFile (&dir, access, pc.get_object_attr (attr, sa), &io, NULL,
			 FILE_ATTRIBUTE_DIRECTORY, FILE_SHARE_VALID_FLAGS,
			 FILE_CREATE,
			 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
			 | FILE_OPEN_FOR_BACKUP_INTENT,
			 p, plen);
  if (NT_SUCCESS (status))
    {
      if (has_acls ())
	set_file_attribute (dir, pc, ILLEGAL_UID, ILLEGAL_GID,
			    S_JUSTCREATED | S_IFDIR
			    | ((mode & 07777) & ~cygheap->umask));
      NtClose (dir);
      res = 0;
    }
  else
    __seterrno_from_nt_status (status);

  return res;
}

int
fhandler_disk_file::rmdir ()
{
  extern NTSTATUS unlink_nt (path_conv &pc);

  if (!pc.isdir ())
    {
      set_errno (ENOTDIR);
      return -1;
    }
  if (!pc.exists ())
    {
      set_errno (ENOENT);
      return -1;
    }

  NTSTATUS status = unlink_nt (pc);

  /* Check for existence of remote dirs after trying to delete them.
     Two reasons:
     - Sometimes SMB indicates failure when it really succeeds.
     - Removing a directory on a Samba drive using an old Samba version
       sometimes doesn't return an error, if the directory can't be removed
       because it's not empty. */
  if (isremote ())
    {
      OBJECT_ATTRIBUTES attr;
      FILE_BASIC_INFORMATION fbi;
      NTSTATUS q_status;

      q_status = NtQueryAttributesFile (pc.get_object_attr (attr, sec_none_nih),
					&fbi);
      if (!NT_SUCCESS (status) && q_status == STATUS_OBJECT_NAME_NOT_FOUND)
	status = STATUS_SUCCESS;
      else if (pc.fs_is_samba ()
	       && NT_SUCCESS (status) && NT_SUCCESS (q_status))
	status = STATUS_DIRECTORY_NOT_EMPTY;
    }
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  return 0;
}

/* This is the minimal number of entries which fit into the readdir cache.
   The number of bytes allocated by the cache is determined by this number,
   To tune caching, just tweak this number.  To get a feeling for the size,
   the size of the readdir cache is DIR_NUM_ENTRIES * 624 + 4 bytes.  */

#define DIR_NUM_ENTRIES	100		/* Cache size 62404 bytes */

#define DIR_BUF_SIZE	(DIR_NUM_ENTRIES \
			 * (sizeof (FILE_ID_BOTH_DIR_INFORMATION) \
			    + (NAME_MAX + 1) * sizeof (WCHAR)))

struct __DIR_cache
{
  char  __cache[DIR_BUF_SIZE];
  ULONG __pos;
};

#define d_cachepos(d)	(((__DIR_cache *) (d)->__d_dirname)->__pos)
#define d_cache(d)	(((__DIR_cache *) (d)->__d_dirname)->__cache)

#define d_mounts(d)	((__DIR_mounts *) (d)->__d_internal)

DIR *
fhandler_disk_file::opendir (int fd)
{
  DIR *dir;
  DIR *res = NULL;

  if (!pc.isdir ())
    set_errno (ENOTDIR);
  else if ((dir = (DIR *) malloc (sizeof (DIR))) == NULL)
    set_errno (ENOMEM);
  else if ((dir->__d_dirname = (char *) malloc ( sizeof (struct __DIR_cache)))
	   == NULL)
    {
      set_errno (ENOMEM);
      goto free_dir;
    }
  else if ((dir->__d_dirent =
	    (struct dirent *) malloc (sizeof (struct dirent))) == NULL)
    {
      set_errno (ENOMEM);
      goto free_dirname;
    }
  else
    {
      cygheap_fdnew cfd;
      if (cfd < 0 && fd < 0)
	goto free_dirent;

      dir->__d_dirent->__d_version = __DIRENT_VERSION;
      dir->__d_cookie = __DIRENT_COOKIE;
      dir->__handle = INVALID_HANDLE_VALUE;
      dir->__d_position = 0;
      dir->__flags = (get_name ()[0] == '/' && get_name ()[1] == '\0')
		     ? dirent_isroot : 0;
      dir->__d_internal = 0;

      if (pc.iscygdrive ())
	{
	  if (fd < 0 && !open (O_RDONLY, 0))
	    goto free_mounts;
	}
      else
	{
	  dir->__d_internal = (uintptr_t) new __DIR_mounts (get_name ());
	  d_cachepos (dir) = 0;
	  if (fd < 0)
	    {
	      /* opendir() case.  Initialize with given directory name and
		 NULL directory handle. */
	      OBJECT_ATTRIBUTES attr;
	      NTSTATUS status;
	      IO_STATUS_BLOCK io;
	      /* Tools like ls(1) call dirfd() to fetch the directory
		 descriptor for calls to facl or fstat.  The tight access mask
		 used so far is not sufficient to reuse the handle for these
		 calls, instead the facl/fstat calls find the handle to be
		 unusable and have to re-open the file for reading attributes
		 and control data.  So, what we do here is to try to open the
		 directory with more relaxed access mask which enables to use
		 the handle for the aforementioned purpose.  This should work
		 in almost all cases.  Only if it doesn't work due to
		 permission problems, we drop the additional access bits and
		 try again. */
	      ACCESS_MASK fstat_mask = READ_CONTROL | FILE_READ_ATTRIBUTES;

	      do
		{
		  status = NtOpenFile (&get_handle (),
				       SYNCHRONIZE | FILE_LIST_DIRECTORY
				       | fstat_mask,
				       pc.get_object_attr (attr, sec_none_nih),
				       &io, FILE_SHARE_VALID_FLAGS,
				       FILE_SYNCHRONOUS_IO_NONALERT
				       | FILE_OPEN_FOR_BACKUP_INTENT
				       | FILE_DIRECTORY_FILE);
		  if (!NT_SUCCESS (status))
		    {
		      if (status == STATUS_ACCESS_DENIED && fstat_mask)
			fstat_mask = 0;
		      else
			{
			  __seterrno_from_nt_status (status);
			  goto free_mounts;
			}
		    }
		}
	      while (!NT_SUCCESS (status));
	    }

	  /* FileIdBothDirectoryInformation is apparently unsupported on
	     XP when accessing directories on UDF.  When trying to use it
	     so, NtQueryDirectoryFile returns with STATUS_ACCESS_VIOLATION.
	     It's not clear if the call isn't also unsupported on other
	     OS/FS combinations.  Instead of testing for yet another error
	     code, let's use FileIdBothDirectoryInformation only on FSes
	     supporting persistent ACLs, FileBothDirectoryInformation otherwise.

	     NFS clients hide dangling symlinks from directory queries,
	     unless you use the FileNamesInformation info class.
	     On newer NFS clients (>=Vista) FileIdBothDirectoryInformation
	     works fine, but only if the NFS share is mounted to a drive
	     letter.  TODO: We don't test that here for now, but it might
	     be worth to test if there's a speed gain in using
	     FileIdBothDirectoryInformation, because it doesn't require to
	     open the file to read the inode number. */
	  if (pc.hasgood_inode ())
	    {
	      dir->__flags |= dirent_set_d_ino;
	      if (pc.fs_is_nfs ())
		dir->__flags |= dirent_nfs_d_ino;
	      else if (!pc.has_buggy_fileid_dirinfo ())
		dir->__flags |= dirent_get_d_ino;
	    }
	}
      if (fd >= 0)
	dir->__d_fd = fd;
      else
	{
	  /* Filling cfd with `this' (aka storing this in the file
	     descriptor table should only happen after it's clear that
	     opendir doesn't fail, otherwise we end up cfree'ing the
	     fhandler twice, once in opendir() in dir.cc, the second
	     time on exit.  Nasty, nasty... */
	  cfd = this;
	  dir->__d_fd = cfd;
	}
      set_close_on_exec (true);
      dir->__fh = this;
      res = dir;
    }

  syscall_printf ("%p = opendir (%s)", res, get_name ());
  return res;

free_mounts:
  delete d_mounts (dir);
free_dirent:
  free (dir->__d_dirent);
free_dirname:
  free (dir->__d_dirname);
free_dir:
  free (dir);
  return res;
}

ino_t __reg2
readdir_get_ino (const char *path, bool dot_dot)
{
  char *fname;
  struct stat st;
  HANDLE hdl;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  ino_t ino = 0;

  if (dot_dot)
    {
      fname = (char *) alloca (strlen (path) + 4);
      char *c = stpcpy (fname, path);
      if (c[-1] != '/')
	*c++ = '/';
      strcpy (c, "..");
      path = fname;
    }
  path_conv pc (path, PC_SYM_NOFOLLOW | PC_POSIX | PC_NOWARN | PC_KEEP_HANDLE);
  if (pc.isspecial ())
    {
      if (!stat_worker (pc, &st))
	ino = st.st_ino;
    }
  else if (!pc.hasgood_inode ())
    ino = hash_path_name (0, pc.get_nt_native_path ());
  else if ((hdl = pc.handle ()) != NULL
	   || NT_SUCCESS (NtOpenFile (&hdl, READ_CONTROL,
				      pc.get_object_attr (attr, sec_none_nih),
				      &io, FILE_SHARE_VALID_FLAGS,
				      FILE_OPEN_FOR_BACKUP_INTENT
				      | (pc.is_rep_symlink ()
				      ? FILE_OPEN_REPARSE_POINT : 0)))
	  )
    {
      ino = pc.get_ino_by_handle (hdl);
      if (!ino)
	ino = hash_path_name (0, pc.get_nt_native_path ());
    }
  return ino;
}

int
fhandler_disk_file::readdir_helper (DIR *dir, dirent *de, DWORD w32_err,
				    DWORD attr, PUNICODE_STRING fname)
{
  if (w32_err)
    {
      bool added = false;
      if ((de->d_ino = d_mounts (dir)->check_missing_mount (fname)))
	added = true;
      if (!added)
	{
	  fname->Length = 0;
	  return geterrno_from_win_error (w32_err);
	}
      if (de->d_ino == 2)	/* Inode number for virtual dirs. */
	de->d_type = DT_DIR;
      attr = 0;
      dir->__flags &= ~dirent_set_d_ino;
    }

  /* Set d_type if type can be determined from file attributes.  For .lnk
     symlinks, d_type will be reset below.  Reparse points can be NTFS
     symlinks, even if they have the FILE_ATTRIBUTE_DIRECTORY flag set. */
  if (attr &&
      !(attr & (~FILE_ATTRIBUTE_VALID_FLAGS | FILE_ATTRIBUTE_REPARSE_POINT)))
    {
      if (attr & FILE_ATTRIBUTE_DIRECTORY)
	de->d_type = DT_DIR;
      /* FILE_ATTRIBUTE_SYSTEM might denote system-bit type symlinks. */
      else if (!(attr & FILE_ATTRIBUTE_SYSTEM))
	de->d_type = DT_REG;
    }

  /* Check for directory reparse point.  These are potential volume mount
     points which have another inode than the underlying directory. */
  if ((attr & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT))
      == (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT))
    {
      HANDLE reph;
      OBJECT_ATTRIBUTES attr;
      IO_STATUS_BLOCK io;

      InitializeObjectAttributes (&attr, fname, pc.objcaseinsensitive (),
				  get_handle (), NULL);
      de->d_type = readdir_check_reparse_point (&attr);
      if (de->d_type == DT_DIR)
	{
	  /* Volume mountpoints are treated as directories.  We have to fix
	     the inode number, otherwise we have the inode number of the
	     mount point, rather than the inode number of the toplevel
	     directory of the mounted drive. */
	  if (NT_SUCCESS (NtOpenFile (&reph, READ_CONTROL, &attr, &io,
				      FILE_SHARE_VALID_FLAGS,
				      FILE_OPEN_FOR_BACKUP_INTENT)))
	    {
	      de->d_ino = pc.get_ino_by_handle (reph);
	      NtClose (reph);
	    }
	}
    }

  /* Check for Windows shortcut. If it's a Cygwin or U/WIN symlink, drop the
     .lnk suffix and set d_type accordingly. */
  if ((attr & (FILE_ATTRIBUTE_DIRECTORY
	       | FILE_ATTRIBUTE_REPARSE_POINT
	       | FILE_ATTRIBUTE_READONLY)) == FILE_ATTRIBUTE_READONLY
      && fname->Length > 4 * sizeof (WCHAR))
    {
      UNICODE_STRING uname;

      RtlInitCountedUnicodeString (&uname,
				   fname->Buffer
				   + fname->Length / sizeof (WCHAR) - 4,
				   4 * sizeof (WCHAR));
      if (RtlEqualUnicodeString (&uname, &ro_u_lnk, TRUE))
	{
	  tmp_pathbuf tp;
	  char *file = tp.c_get ();
	  char *p = stpcpy (file, pc.get_posix ());
	  if (p[-1] != '/')
	    *p++ = '/';
	  sys_wcstombs (p, NT_MAX_PATH - (p - file),
			fname->Buffer, fname->Length / sizeof (WCHAR));
	  path_conv fpath (file, PC_SYM_NOFOLLOW);
	  if (fpath.issymlink ())
	    {
	      fname->Length -= 4 * sizeof (WCHAR);
	      de->d_type = DT_LNK;
	    }
	  else if (fpath.isfifo ())
	    {
	      fname->Length -= 4 * sizeof (WCHAR);
	      de->d_type = DT_FIFO;
	    }
	  else if (fpath.is_fs_special ())
	    {
	      fname->Length -= 4 * sizeof (WCHAR);
	      de->d_type = S_ISCHR (fpath.dev.mode) ? DT_CHR : DT_BLK;
	    }
	}
    }

  sys_wcstombs (de->d_name, NAME_MAX + 1, fname->Buffer,
		fname->Length / sizeof (WCHAR));

  /* Don't try to optimize relative to dir->__d_position.  On several
     filesystems it's no safe bet that "." and ".." entries always
     come first. */
  if (de->d_name[0] == '.')
    {
      if (de->d_name[1] == '\0')
	dir->__flags |= dirent_saw_dot;
      else if (de->d_name[1] == '.' && de->d_name[2] == '\0')
	dir->__flags |= dirent_saw_dot_dot;
    }
  return 0;
}

int
fhandler_disk_file::readdir (DIR *dir, dirent *de)
{
  int res = 0;
  NTSTATUS status = STATUS_SUCCESS;
  PFILE_ID_BOTH_DIR_INFORMATION buf = NULL;
  PWCHAR FileName;
  ULONG FileNameLength;
  ULONG FileAttributes = 0;
  IO_STATUS_BLOCK io;
  UNICODE_STRING fname;

  /* d_cachepos always refers to the next cache entry to use.  If it's 0
     we must reload the cache. */
  if (d_cachepos (dir) == 0)
    {
      if ((dir->__flags & dirent_get_d_ino))
	{
	  status = NtQueryDirectoryFile (get_handle (), NULL, NULL, NULL, &io,
					 d_cache (dir), DIR_BUF_SIZE,
					 FileIdBothDirectoryInformation,
					 FALSE, NULL, dir->__d_position == 0);
	  /* FileIdBothDirectoryInformation isn't supported for remote drives
	     on NT4 and 2K systems.  There are also hacked versions of
	     Samba 3.0.x out there (Debian-based it seems), which return
	     STATUS_NOT_SUPPORTED rather than handling this info class.
	     We just fall back to using a standard directory query in
	     this case and note this case using the dirent_get_d_ino flag. */
	  if (!NT_SUCCESS (status) && status != STATUS_NO_MORE_FILES
	      && (status == STATUS_INVALID_LEVEL
		  || status == STATUS_NOT_SUPPORTED
		  || status == STATUS_INVALID_PARAMETER
		  || status == STATUS_INVALID_NETWORK_RESPONSE
		  || status == STATUS_INVALID_INFO_CLASS))
	    dir->__flags &= ~dirent_get_d_ino;
	  /* Something weird happens on Samba up to version 3.0.21c, which is
	     fixed in 3.0.22.  FileIdBothDirectoryInformation seems to work
	     nicely, but only up to the 128th entry in the directory.  After
	     reaching this entry, the next call to NtQueryDirectoryFile
	     (FileIdBothDirectoryInformation) returns STATUS_INVALID_LEVEL.
	     Why should we care, we can just switch to
	     FileBothDirectoryInformation, isn't it?  Nope!  The next call to
	     NtQueryDirectoryFile(FileBothDirectoryInformation) actually
	     returns STATUS_NO_MORE_FILES, regardless how many files are left
	     unread in the directory.  This does not happen when using
	     FileBothDirectoryInformation right from the start, but since
	     we can't decide whether the server we're talking with has this
	     bug or not, we end up serving Samba shares always in the slow
	     mode using FileBothDirectoryInformation.  So, what we do here is
	     to implement the solution suggested by Andrew Tridgell,  we just
	     reread all entries up to dir->d_position using
	     FileBothDirectoryInformation.
	     However, We do *not* mark this server as broken and fall back to
	     using FileBothDirectoryInformation further on.  This would slow
	     down every access to such a server, even for directories under
	     128 entries.  Also, bigger dirs only suffer from one additional
	     call per full directory scan, which shouldn't be too big a hit.
	     This can easily be changed if necessary. */
	  if (status == STATUS_INVALID_LEVEL && dir->__d_position)
	    {
	      d_cachepos (dir) = 0;
	      for (int cnt = 0; cnt < dir->__d_position; ++cnt)
		{
		  if (d_cachepos (dir) == 0)
		    {
		      status = NtQueryDirectoryFile (get_handle (), NULL, NULL,
					   NULL, &io, d_cache (dir),
					   DIR_BUF_SIZE,
					   FileBothDirectoryInformation,
					   FALSE, NULL, cnt == 0);
		      if (!NT_SUCCESS (status))
			goto go_ahead;
		    }
		  buf = (PFILE_ID_BOTH_DIR_INFORMATION) (d_cache (dir)
							 + d_cachepos (dir));
		  if (buf->NextEntryOffset == 0)
		    d_cachepos (dir) = 0;
		  else
		    d_cachepos (dir) += buf->NextEntryOffset;
		}
	      goto go_ahead;
	    }
	}
      if (!(dir->__flags & dirent_get_d_ino))
	status = NtQueryDirectoryFile (get_handle (), NULL, NULL, NULL, &io,
				       d_cache (dir), DIR_BUF_SIZE,
				       (dir->__flags & dirent_nfs_d_ino)
				       ? FileNamesInformation
				       : FileBothDirectoryInformation,
				       FALSE, NULL, dir->__d_position == 0);
    }

go_ahead:

  if (status == STATUS_NO_MORE_FILES)
    /*nothing*/;
  else if (!NT_SUCCESS (status))
    debug_printf ("NtQueryDirectoryFile failed, status %y, win32 error %u",
		  status, RtlNtStatusToDosError (status));
  else
    {
      buf = (PFILE_ID_BOTH_DIR_INFORMATION) (d_cache (dir) + d_cachepos (dir));
      if (buf->NextEntryOffset == 0)
	d_cachepos (dir) = 0;
      else
	d_cachepos (dir) += buf->NextEntryOffset;
      if ((dir->__flags & dirent_get_d_ino))
	{
	  FileName = buf->FileName;
	  FileNameLength = buf->FileNameLength;
	  FileAttributes = buf->FileAttributes;
	  if ((dir->__flags & dirent_set_d_ino))
	    de->d_ino = buf->FileId.QuadPart;
	}
      else if ((dir->__flags & dirent_nfs_d_ino))
	{
	  FileName = ((PFILE_NAMES_INFORMATION) buf)->FileName;
	  FileNameLength = ((PFILE_NAMES_INFORMATION) buf)->FileNameLength;
	}
      else
	{
	  FileName = ((PFILE_BOTH_DIR_INFORMATION) buf)->FileName;
	  FileNameLength =
		((PFILE_BOTH_DIR_INFORMATION) buf)->FileNameLength;
	  FileAttributes =
		((PFILE_BOTH_DIR_INFORMATION) buf)->FileAttributes;
	}
      RtlInitCountedUnicodeString (&fname, FileName, FileNameLength);
      de->d_ino = d_mounts (dir)->check_mount (&fname, de->d_ino);
      if (de->d_ino == 0 && (dir->__flags & dirent_set_d_ino))
	{
	  /* Don't try to optimize relative to dir->__d_position.  On several
	     filesystems it's no safe bet that "." and ".." entries always
	     come first. */
	  if (FileNameLength == sizeof (WCHAR) && FileName[0] == '.')
	    de->d_ino = pc.get_ino_by_handle (get_handle ());
	  else if (FileNameLength == 2 * sizeof (WCHAR)
		   && FileName[0] == L'.' && FileName[1] == L'.')
	    {
	      if (!(dir->__flags & dirent_isroot))
		de->d_ino = readdir_get_ino (get_name (), true);
	      else
		de->d_ino = pc.get_ino_by_handle (get_handle ());
	    }
	  else
	    {
	      OBJECT_ATTRIBUTES attr;
	      HANDLE hdl;
	      NTSTATUS f_status;

	      InitializeObjectAttributes (&attr, &fname,
					  pc.objcaseinsensitive (),
					  get_handle (), NULL);
	      /* FILE_OPEN_REPARSE_POINT on NFS is a no-op, so the normal
		 NtOpenFile here returns the inode number of the symlink target,
		 rather than the inode number of the symlink itself.

		 Worse, trying to open a symlink without setting the special
		 "ActOnSymlink" EA triggers a bug in Windows 7 which results
		 in a timeout of up to 20 seconds, followed by two exceptions
		 in the NT kernel.

		 Since both results are far from desirable, we open symlinks
		 on NFS so that we get the right inode and a happy W7.
		 And, since some filesystems choke on the EAs, we don't
		 use them unconditionally. */
	      f_status = (dir->__flags & dirent_nfs_d_ino)
			 ? NtCreateFile (&hdl, READ_CONTROL, &attr, &io,
					 NULL, 0, FILE_SHARE_VALID_FLAGS,
					 FILE_OPEN, FILE_OPEN_FOR_BACKUP_INTENT,
					 &nfs_aol_ffei, sizeof nfs_aol_ffei)
			 : NtOpenFile (&hdl, READ_CONTROL, &attr, &io,
				       FILE_SHARE_VALID_FLAGS,
				       FILE_OPEN_FOR_BACKUP_INTENT
				       | FILE_OPEN_REPARSE_POINT);
	      if (NT_SUCCESS (f_status))
		{
		  /* We call NtQueryInformationFile here, rather than
		     pc.get_ino_by_handle(), otherwise we can't short-circuit
		     dirent_set_d_ino correctly. */
		  FILE_INTERNAL_INFORMATION fai;
		  f_status = NtQueryInformationFile (hdl, &io, &fai, sizeof fai,
						     FileInternalInformation);
		  NtClose (hdl);
		  if (NT_SUCCESS (f_status))
		    {
		      if (pc.isgood_inode (fai.FileId.QuadPart))
			de->d_ino = fai.FileId.QuadPart;
		      else
			/* Untrusted file system.  Don't try to fetch inode
			   number again. */
			dir->__flags &= ~dirent_set_d_ino;
		    }
		}
	    }
	}
    }

  if (!(res = readdir_helper (dir, de, RtlNtStatusToDosError (status),
			      FileAttributes, &fname)))
    dir->__d_position++;
  else if (!(dir->__flags & dirent_saw_dot))
    {
      strcpy (de->d_name , ".");
      de->d_ino = pc.get_ino_by_handle (get_handle ());
      de->d_type = DT_DIR;
      dir->__d_position++;
      dir->__flags |= dirent_saw_dot;
      res = 0;
    }
  else if (!(dir->__flags & dirent_saw_dot_dot))
    {
      strcpy (de->d_name , "..");
      if (!(dir->__flags & dirent_isroot))
	de->d_ino = readdir_get_ino (get_name (), true);
      else
	de->d_ino = pc.get_ino_by_handle (get_handle ());
      de->d_type = DT_DIR;
      dir->__d_position++;
      dir->__flags |= dirent_saw_dot_dot;
      res = 0;
    }

  syscall_printf ("%d = readdir(%p, %p) (L\"%lS\" > \"%ls\") (attr %y > type %d)",
		  res, dir, &de, res ? NULL : &fname, res ? "***" : de->d_name,
		  FileAttributes, de->d_type);
  return res;
}

long
fhandler_disk_file::telldir (DIR *dir)
{
  return dir->__d_position;
}

void
fhandler_disk_file::seekdir (DIR *dir, long loc)
{
  rewinddir (dir);
  while (loc > dir->__d_position)
    if (!::readdir (dir))
      break;
}

void
fhandler_disk_file::rewinddir (DIR *dir)
{
  d_cachepos (dir) = 0;
  dir->__d_position = 0;
  d_mounts (dir)->rewind ();
}

int
fhandler_disk_file::closedir (DIR *dir)
{
  int res = 0;

  delete d_mounts (dir);
  syscall_printf ("%d = closedir(%p, %s)", res, dir, get_name ());
  return res;
}

fhandler_cygdrive::fhandler_cygdrive () :
  fhandler_disk_file (), ndrives (0), pdrive (NULL)
{
}

int
fhandler_cygdrive::open (int flags, mode_t mode)
{
  if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
    {
      set_errno (EEXIST);
      return 0;
    }
  if (flags & O_WRONLY)
    {
      set_errno (EISDIR);
      return 0;
    }
  /* Open a fake handle to \\Device\\Null */
  return open_null (flags);
}

void
fhandler_cygdrive::set_drives ()
{
  pdrive = pdrive_buf;
  ndrives = GetLogicalDriveStrings (sizeof pdrive_buf, pdrive_buf) / DRVSZ;
}

int
fhandler_cygdrive::fstat (struct stat *buf)
{
  fhandler_base::fstat (buf);
  buf->st_ino = 2;
  buf->st_mode = S_IFDIR | STD_RBITS | STD_XBITS;
  buf->st_nlink = 1;
  return 0;
}

int __reg2
fhandler_cygdrive::fstatvfs (struct statvfs *sfs)
{
  /* Virtual file system.  Just return an empty buffer with a few values
     set to something useful.  Just as on Linux. */
  memset (sfs, 0, sizeof (*sfs));
  sfs->f_bsize = sfs->f_frsize = 4096;
  sfs->f_flag = ST_RDONLY;
  sfs->f_namemax = NAME_MAX;
  return 0;
}

DIR *
fhandler_cygdrive::opendir (int fd)
{
  DIR *dir;

  dir = fhandler_disk_file::opendir (fd);
  if (dir && !ndrives)
    set_drives ();

  return dir;
}

int
fhandler_cygdrive::readdir (DIR *dir, dirent *de)
{
  WCHAR drive[] = L"X:";

  while (true)
    {
      if (!pdrive || !*pdrive)
	{
	  if (!(dir->__flags & dirent_saw_dot))
	    {
	      de->d_name[0] = '.';
	      de->d_name[1] = '\0';
	      de->d_ino = 2;
	    }
	  return ENMFILE;
	}
      disk_type dt = get_disk_type ((drive[0] = *pdrive, drive));
      if (dt == DT_SHARE_SMB)
	{
	  /* Calling NetUseGetInfo on SMB drives allows to fetch the
	     current state of the drive without trying to open a file
	     descriptor on the share (GetFileAttributes).  This avoids
	     waiting for SMB timeouts.  Of course, there's a downside:
	     If a drive becomes availabe again, it can take a couple of
	     minutes to recognize it. As long as this didn't happen,
	     the drive will not show up in the cygdrive dir. */
	  PUSE_INFO_1 pui1;
	  DWORD status;

	  if (NetUseGetInfo (NULL, drive, 1, (PBYTE *) &pui1) == NERR_Success)
	    {
	      status = pui1->ui1_status;
	      NetApiBufferFree (pui1);
	      if (status == USE_OK)
		break;
	    }
	}
      else if (dt != DT_FLOPPY
	       && GetFileAttributes (pdrive) != INVALID_FILE_ATTRIBUTES)
	break;
      pdrive = strchr (pdrive, '\0') + 1;
    }
  *de->d_name = cyg_tolower (*pdrive);
  de->d_name[1] = '\0';
  user_shared->warned_msdos = true;
  de->d_ino = readdir_get_ino (pdrive, false);
  dir->__d_position++;
  pdrive = strchr (pdrive, '\0') + 1;
  syscall_printf ("%p = readdir (%p) (%s)", &de, dir, de->d_name);
  return 0;
}

void
fhandler_cygdrive::rewinddir (DIR *dir)
{
  pdrive = pdrive_buf;
  dir->__d_position = 0;
}

int
fhandler_cygdrive::closedir (DIR *dir)
{
  pdrive = pdrive_buf;
  return 0;
}
@


1.404
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Set d_type
	for virtual directories.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d261 1
a261 1
  __DIR_mounts *dir = new __DIR_mounts (normalized_path);
d2113 1
a2113 1
	  char *p = stpcpy (file, pc.normalized_path);
@


1.403
log
@	* fhandler.cc (fhandler_base::facl): Drop CLASS_OBJ entry.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Ditto in noacl case.
	* sec_acl.cc (getacl): Compute useful fake CLASS_OBJ and DEF_CLASS_OBJ
	permission bits based on how these values are generated on Linux.
	Add commants to explain what the code is doing.
	* security.cc (get_attribute_from_acl): Compute group permission based
	on the actual primary group permissions and all secondary user and group
	ACCESS_ALLOWED_ACEs to emulate Linux' behaviour more closely.
	(check_access): Fix typos im comment.
	* include/cygwin/acl.h (MIN_ACL_ENTRIES): Redefine as 3.
@
text
@d2049 2
a2050 1

@


1.402
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)
@
text
@a1047 3
		    aclbufp[3].a_type = CLASS_OBJ;
		    aclbufp[3].a_id = ILLEGAL_GID;
		    aclbufp[3].a_perm = S_IRWXU | S_IRWXG | S_IRWXO;
@


1.401
log
@	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.
@
text
@d803 20
@


1.400
log
@	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.
@
text
@d717 1
a717 1
  syscall_printf ("0 = fstat (%S, %p) st_size=%D, st_mode=%y, st_ino=%D"
@


1.399
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Add debug
	output.
@
text
@a674 1
	      pc.init_reopen_attr (&attr, h);
d676 2
a677 1
				   &attr, &io, FILE_SHARE_VALID_FLAGS,
d897 3
a899 3
      pc.init_reopen_attr (&attr, get_handle ());
      if (NT_SUCCESS (NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES, &attr, &io,
				  FILE_SHARE_VALID_FLAGS,
d1387 3
a1389 3
      pc.init_reopen_attr (&attr, get_handle ());
      if (NT_SUCCESS (NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES, &attr, &io,
				  FILE_SHARE_VALID_FLAGS,
d1558 2
a1559 2
  pc.init_reopen_attr (&attr, get_handle ());
  status = NtOpenFile (&prw_handle, access, &attr, &io,
@


1.398
log
@	* autoload.cc (ldap_search_sW): Replace ldap_search_stW.
	(LdapMapErrorToWin32): Import.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Accommodate
	change to cyg_ldap::open.
	* ldap.cc (CYG_LDAP_TIMEOUT): Remove.
	(CYG_LDAP_ENUM_TIMEOUT): Remove.
	(def_tv): Remove.
	(enum_tv): Remove.
	(cyg_ldap::map_ldaperr_to_errno): New method to map LDAP error codes to
	POSIX errno codes.  Explicitly map LDAP_NO_RESULTS_RETURNED to ENMFILE.
	(cyg_ldap::wait): Ditto.
	(struct cyg_ldap_init): New struct.
	(cyg_ldap::connect_ssl): Return ULONG.  Drop setting LDAP_OPT_TIMELIMIT.
	Add call to ldap_search_sW to fetch root DSE.
	(cyg_ldap::connect_non_ssl): Ditto.
	(ldap_init_thr): New static thread function.
	(cyg_ldap::connect): New method to call connect_ssl/connect_non_ssl in
	an interruptible cygthread.
	(struct cyg_ldap_search): New struct.
	(cyg_ldap::search_s): New method to perform generic synchronous search.
	(ldap_search_thr): New static thread function.
	(cyg_ldap::search): New method to call search_s in an interruptible
	cygthread.
	(struct cyg_ldap_next_page): New struct.
	(cyg_ldap::next_page_s): New method to perform generic synchronous
	paged search.
	(ldap_next_page_thr): New static thread function.
	(cyg_ldap::next_page): New method to call next_page_s in an
	interruptible cygthread.
	(cyg_ldap::open): Return POSIX errno.  Call connect method.
	(cyg_ldap::fetch_ad_account): Call search method rather than
	ldap_search_stW.
	(cyg_ldap::enumerate_ad_accounts): Return POSIX errno.  Use infinite
	timeout in call to ldap_search_init_pageW.
	(cyg_ldap::next_account): Return POSIX errno.  Call next_page method
	rather than ldap_get_next_page_s.
	(cyg_ldap::fetch_posix_offset_for_domain): Call search method rather
	than ldap_search_stW.
	(cyg_ldap::fetch_unix_sid_from_ad): Ditto.
	(cyg_ldap::fetch_unix_name_from_rfc2307): Ditto.
	* ldap.h (class cyg_ldap): Accommodate aforementioned changes.
	* passwd.cc (pg_ent::enumerate_ad): Ditto.  Break search if one of
	cyg_ldap::enumerate_ad_accounts or cldap.next_account returns with
	an error code other than ENMFILE.
	* sec_helper.cc (cygpsid::get_id): Accommodate change to cyg_ldap::open.
	* uinfo.cc (fetch_posix_offset): Ditto.
@
text
@d803 4
@


1.397
log
@	* cygheap.h (enum cygheap_pwdgrp::cache_t): Remove.
	(cygheap_pwdgrp::caching): Convert to bool.
	(cygheap_pwdgrp::pwd_cache): Add cygserver member.
	(cygheap_pwdgrp::grp_cache): Ditto.
	(cygheap_pwdgrp::nss_db_caching): Drop.
	(cygheap_pwdgrp::nss_db_full_caching): Drop.
	(cygheap_pwdgrp::nss_cygserver_caching): New method.
	(cygheap_pwdgrp::nss_disable_cygserver_caching): New method.
	* cygserver.h (client_request::request_code_t): Add
	CYGSERVER_REQUEST_PWDGRP.
	* cygserver_pwdgrp.h: New file.
	* cygtls.h (struct _local_storage): Remove pwbuf and grbuf members.
	* grp.cc (pwdgrp::prep_tls_grbuf): Drop.
	(internal_getgrsid): Handle cygserver caching and rearrange to check
	the caches first.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(gr_ent::enumerate_caches): Handle cygserver cache.
	* passwd.cc (pwdgrp::prep_tls_pwbuf): Drop.
	(internal_getpwsid): Handle cygserver caching and rearrange to check
	the caches first.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(pw_ent::enumerate_caches): Handle cygserver cache.
	* pwdgrp.h (pwdgrp::add_account_from_cygserver): New method declaration.
	(pwdgrp::fetch_account_from_cygserver): New method declaration.
	(pwdgrp::prep_tls_pwbuf): Drop declaration.
	(pwdgrp::prep_tls_grbuf): Drop declaration.
	(pwdgrp::add_user_from_cygserver): New inline methods.
	(pwdgrp::add_group_from_cygserver): New inline methods.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
	* uinfo.cc (internal_getlogin): Call internal_getgroups if cygserver
	caching is not available.
	(cygheap_pwdgrp::init): Initialize pwd_cache.cygserver and
	grp_cache.cygserver.  Set caching to true.
	(cygheap_pwdgrp::nss_init_line): Drop db_cache handling entirely.
	(pwdgrp::add_account_from_windows): Drop no caching handling.
	(client_request_pwdgrp::client_request_pwdgrp): New method.
	(pwdgrp::fetch_account_from_cygserver): New method.
	(pwdgrp::add_account_from_cygserver): New method.

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Fix formatting.
	* include/sys/cygwin.h: Ditto.
@
text
@d357 1
a357 1
      if ((ldap_open = cldap.open (domain)))
d369 1
a369 1
      if ((ldap_open || cldap.open (domain)))
@


1.396
log
@	* autoload.cc (NetLocalGroupGetInfo): Replace NetGroupGetInfo.
	* cygheap.h (class cygheap_ugid_cache): Move ugid_cache_t type here
	and rename.
	(struct init_cygheap): Add cygheap_ugid_cache member "ugid_cache".
	* pwdgrp.h (class ugid_cache_t): Remove here.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Accommodate
	move of ugid_cache to cygheap.
	* sec_helper.cc (get_sids_info): Ditto.
	* uinfo.cc (ugid_cache): Remove.
	(pwdgrp::fetch_account_from_windows): Define id_val globally.
	Move SidTypeAlias handling into SidTypeUser/SidTypeGroup branch since
	aliases are handled like groups in SAM.  Accommodate move of ugid_cache
	to cygheap.  Consolidate code reading SAM comments into a single branch
	for both, SidTypeUser and SidTypeAlias.  For SidTypeAlias, fix thinko
	and call NetLocalGroupGetInfo rather than NetGroupGetInfo.  Simplify
	code setting Cygwin primary group for SAM accounts.  Add code to handle
	UNIX uid/gid from SAM comment.
@
text
@d537 1
a537 2
fhandler_base::fstat_helper (struct stat *buf,
			     DWORD nNumberOfLinks)
@


1.395
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d350 2
a351 2
  buf->st_uid = ugid_cache.get_uid (nfs_attr->uid);
  buf->st_gid = ugid_cache.get_gid (nfs_attr->gid);
d361 1
a361 1
      ugid_cache.add_uid (nfs_attr->uid, map_uid);
d373 1
a373 1
      ugid_cache.add_gid (nfs_attr->gid, map_gid);
@


1.394
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchown): Fix typo in
	comment.
	* mount.cc (mount_info::from_fstab): Use tmp_pathbuf rather than
	stack for big local buffer.
	* net.cc (cygwin_gethostname): Call GetComputerNameExA rather than
	GetComputerNameA if gethostname failed.
	* shared.cc (user_info::initialize): Fix formatting.
	* include/sys/file.h: Define flock and accompanying macros if not
	already defined in sys/_default_fcntl.h.
@
text
@d13 2
a27 3
#include "pwdgrp.h"
#include <winioctl.h>
#include <lm.h>
d29 1
d326 3
d346 30
a375 8
  /* FIXME: How to convert UNIX uid/gid to Windows SIDs? */
#if 0
  buf->st_uid = nfs_attr->uid;
  buf->st_gid = nfs_attr->gid;
#else
  buf->st_uid = myself->uid;
  buf->st_gid = myself->gid;
#endif
@


1.394.2.1
log
@Add more missing patches
@
text
@a778 4
  else
    debug_printf ("%y = NtQueryVolumeInformationFile"
		  "(%S, FileFsFullSizeInformation)",
		  status, pc.get_nt_native_path ());
@


1.394.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d651 1
d653 1
a653 2
				   pc.init_reopen_attr (attr, h), &io,
				   FILE_SHARE_VALID_FLAGS,
d693 1
a693 1
  syscall_printf ("0 = fstat (%S, %p) st_size=%D, st_mode=0%o, st_ino=%D"
a778 20
  else if (status == STATUS_INVALID_PARAMETER /* Netapp */
	   || status == STATUS_INVALID_INFO_CLASS)
    {
      FILE_FS_SIZE_INFORMATION fsi;
      status = NtQueryVolumeInformationFile (fh, &io, &fsi, sizeof fsi,
					     FileFsSizeInformation);
      if (NT_SUCCESS (status))
	{
	  sfs->f_bsize = fsi.BytesPerSector * fsi.SectorsPerAllocationUnit;
	  sfs->f_frsize = sfs->f_bsize;
	  sfs->f_blocks = (fsblkcnt_t) fsi.TotalAllocationUnits.QuadPart;
	  sfs->f_bfree = sfs->f_bavail =
	    (fsblkcnt_t) fsi.AvailableAllocationUnits.QuadPart;
	  ret = 0;
	}
      else
	debug_printf ("%y = NtQueryVolumeInformationFile"
		      "(%S, FileFsSizeInformation)", 
		      status, pc.get_nt_native_path ());
    }
d873 3
a875 3
      if (NT_SUCCESS (NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES,
      				  pc.init_reopen_attr (attr, get_handle ()),
				  &io, FILE_SHARE_VALID_FLAGS,
d1363 3
a1365 3
      if (NT_SUCCESS (NtOpenFile (&fh, FILE_WRITE_ATTRIBUTES,
				  pc.init_reopen_attr (attr, get_handle ()),
				  &io, FILE_SHARE_VALID_FLAGS,
d1534 2
a1535 2
  status = NtOpenFile (&prw_handle, access,
		       pc.init_reopen_attr (attr, get_handle ()), &io,
@


1.393
log
@	* devices.in (dev_cygdrive_storage): Revert mapping to \Device\Null.
	(dev_storage): Ditto for /dev.
	* devices.cc: Regenerate.
	* fhandler.cc (fhandler_base::open_null): New method to open a fake
	\Device\Null handler.
	(fhandler_base::open): Fix formatting.  Change O_ACCMODE test to a
	switch statement.  Simplify a test which still tested for a now unused
	create_disposition.
	* fhandler.h (fhandler_base::open_null): Declare.
	(fhandler_netdrive::close): Declare.
	* fhandler_dev.cc (fhandler_dev::open): Open fake \Device\Null handle
	by just calling new open_null method.
	* fhandler_disk_file.cc (fhandler_cygdrive::open): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::open): Call open_null
	rather than setting nohandle.
	(fhandler_netdrive::close): New method.
	* fhandler_registry.cc (fetch_hkey): Fix token in RegOpenUserClassesRoot
	call.  Create valid key for HKEY_CURRENT_CONFIG by mapping to real key
	HKEY_LOCAL_MACHINE\System\CurrentControlSet\Hardware Profiles\Current.
	(fhandler_registry::open): Set nohandle only when using pseudo registry
	handle.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Call open rather
	than just setting nohandle here.
	* fhandler_virtual::fstatvfs): Set ST_RDONLY fs flag.
	* globals.cc (ro_u_null): New readonly UNICODE_STRING for \Device\Null.
	* path.h (path_conv::set_path): Revert previous change caring for
	wide_path.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d931 1
a931 1
      /* If you're running a Samba server which has no winbidd running, the
@


1.392
log
@	* devices.in (dev_cygdrive_storage): Map to \Device\Null.
	(dev_storage): Map /dev and /dev/windows to \Device\Null.
	* devices.cc: Regenerate.
	* dir.cc (opendir): Create unique id.  Explain why.
	* fhandler.h (fhandler_dev::get_dev): Implement inline.
	(fhandler_cygdrive::close): Drop declaration.
	(fhandler_cygdrive::get_dev): Implement inline.
	(fhandler_windows::get_hwnd): Ditto.
	(fhandler_windows::set_close_on_exec): Drop declaration.
	(fhandler_windows::fixup_after_fork): Ditto.
	* fhandler_dev.cc (fhandler_dev::open): Call fhandler_disk_file::open
	without O_CREAT flag.  Explain why.  Create \Device\Null handle if
	/dev/ doesn't actually exist.
	(fhandler_dev::close): Drop nohandle case.
	(fhandler_dev::fstatvfs): Drop nohandle check.  Test for fs_got_fs
	instead.  Set ST_RDONLY fs flag for simulated /dev.
	(fhandler_dev::opendir): If /dev doesn't exist, call open() to create
	fake \Device\Null handle.  Don't set nohandle.  Set dir_exists
	correctly.
	(fhandler_dev::rewinddir): Call fhandler_disk_file::rewinddir only if
	/dev is a real directory.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): If called for
	the cygdrive dir, call open() to create fake \Device\Null handle.
	Only attach __DIR_mounts buffer to dir if not called for cygdrive dir.
	Don't set nohandle.
	(fhandler_cygdrive::open): Create \Device\Null handle.
	(fhandler_cygdrive::close): Remove.
	(fhandler_cygdrive::fstatvfs): Set ST_RDONLY fs flag.
	* fhandler_windows.cc (fhandler_windows::open): Create \Device\Null
	handle.
	(fhandler_windows::read): Don't add io_handle to WFMO handle array.
	Change subsequent test for return value accordingly.  Fix test for
	"message arrived".
	(fhandler_windows::set_close_on_exec): Remove.
	(fhandler_windows::fixup_after_fork): Remove.
	* path.h (path_conv::set_path): Make sure wide_path is NULL when
	setting a new path.
	* select.cc (peek_windows): Use correct hWnd value, not io_handle.
	(fhandler_windows::select_read): Don't use io_handle as wait object.
	(fhandler_windows::select_write): Ditto.
	(fhandler_windows::select_except): Ditto.
@
text
@d2387 2
a2388 10
  /* Open a fake handle to \\Device\\Null, but revert to the old path
     string afterwards, otherwise readdir will return with an EFAULT
     when trying to fetch the inode number of ".." */
  tmp_pathbuf tp;
  char *orig_path = tp.c_get ();
  stpcpy (orig_path, get_win32_name ());
  pc.set_path (dev ().native);
  int ret = fhandler_base::open (flags, mode);
  pc.set_path (orig_path);
  return ret;
@


1.391
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Fix comment.
@
text
@d1836 1
a1836 2
      dir->__d_internal = (uintptr_t) new __DIR_mounts (get_name ());
      d_cachepos (dir) = 0;
d1838 1
a1838 1
      if (!pc.iscygdrive ())
d1840 7
a1926 2
	  if (pc.iscygdrive ())
	    cfd->nohandle (true);
d2387 10
a2396 10
  flags |= O_DIROPEN;
  set_flags (flags);
  nohandle (true);
  return 1;
}

int
fhandler_cygdrive::close ()
{
  return 0;
d2423 1
@


1.390
log
@	* devices.in (dev_storage): Map /dev/zero and /dev/full to \Device\Null.
	* devices.cc: Regenerate.
	* dtable.h (struct dtable): Make fhandler_base friend, rather
	than fhandler_disk_file.
	* fhandler.cc (fhandler_base::open_with_arch): Create unique id.
	(fhandler_base::cleanup): Call del_my_locks.
	(fhandler_base::fcntl): Handle F_GETLK, F_SETLK and F_SETLKW.
	* fhandler.h (fhandler_base::get_dev): Return real device number.
	(fhandler_base::set_unique_id): New inline method.
	(fhandler_disk_file::lock): Drop declaration.
	(fhandler_disk_file::get_dev): New method, return pc.fs_serial_number.
	(fhandler_dev_zero::open): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::close): Move
	del_my_locks call to fhandler_base::open_with_arch.
	(fhandler_disk_file::fcntl): Move handling of locking commands to
	fhandler_base::fcntl.
	(fhandler_base::open_fs): Drop call to NtAllocateLocallyUniqueId.
	* fhandler_zero.cc (fhandler_dev_zero::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	* flock.cc (fixup_lockf_after_exec): Finding a single fhandler is
	enough here.
	(fhandler_base::lock): Replace fhandler_disk_file::lock.  Refuse to lock
	nohandle devices.  Handle read/write test using POSIX flags.  Explain
	why.  Never fail on SEEK_CUR or SEEK_END, rather assume position 0,
	just as Linux.
	* net.cc (fdsock): Create unique id.
@
text
@d495 1
a495 1
	 Since fhandler_base::open only calls CloseHandle if !nohandle,
@


1.389
log
@	* fhandler_disk_file.cc (fhandler_base::open_fs): Fix indentation.
@
text
@a1403 3
  /* Delete all POSIX locks on the file.  Delete all flock locks on the
     file if this is the last reference to this file. */
  del_my_locks (on_close);
d1414 1
a1414 1
    case F_LCK_MANDATORY:
a1418 9
    case F_GETLK:
    case F_SETLK:
    case F_SETLKW:
      {
	struct flock *fl = (struct flock *) arg;
	fl->l_type &= F_RDLCK | F_WRLCK | F_UNLCK;
	res = mandatory_locking () ? mand_lock (cmd, fl) : lock (cmd, fl);
      }
      break;
a1477 3
  /* A unique ID is necessary to recognize fhandler entries which are
     duplicated by dup(2) or fork(2). */
  NtAllocateLocallyUniqueId ((PLUID) &unique_id);
@


1.388
log
@	Streamline time/times functionality.  Remove last remains of former
	Windows 9x compatibility.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Drop now unneeded
	casts in calls to_timestruc_t.
	(fhandler_base::utimens_fs): Ditto for timespec_to_filetime.
	* fhandler_proc.cc (format_proc_stat): Ditto for to_time_t.
	* hires.h (class hires_ms): Remove unused member initime_ns.
	Remove declarations for timeGetTime_ns and prime.
	(hires_ms::uptime): Remove.
	* posix_ipc.cc (ipc_cond_timedwait): Ditto for timespec_to_filetime.
	* fhandler_registry.cc (fhandler_registry::fstat): Add cast.
	* resource.cc (fill_rusage): Call NtQueryInformationProcess rather than
	GetProcessTimes to deal with LARGE_INTEGER rather than FILETIME.
	* times.cc: Simplify time handling.  Throughout, use LARGE_INTEGER
	rather than FILETIME to simplify computations.  Throughout use
	{u}int64_t rather than {unsigned} long long.  Drop unneeded casts since
	NSPERSEC is 64 bit anyway.
	(systime_ns): Remove.
	(times): Call NtQuerySystemInformation to fetch boot time.  Call
	NtQueryInformationProcess rather than GetProcessTimes to deal with
	LARGE_INTEGER rather than FILETIME.  Call GetSystemTimeAsFileTime.
	(totimeval): Use constant 1000000 as in other functions.
	(time_t_to_filetime): Remove.
	(to_time_t): Change return type to time_t.
	(time_as_timestruc_t): Rename filetime to systime.
	(time): Ditto. Add cast.
	(hires_ns::nsecs): Fix return type cast.
	(hires_ms::timeGetTime_ns): Remove.
	(hires_ns::prime): Remove.
	(hires_ms::nsecs): Drop call to prime.  Call GetSystemTimeAsFileTime
	directly.  Subtract FACTOR here since it's the only function needing
	to do so.
	(minperiod): Cosmetically change to ULONG.
	(hires_ns::resolution): Fix return type cast.
	(hires_ms::resolution): Simplify, rely on NtQueryTimerResolution.
	* winsup.h: Align time related prototypes to above changes.
@
text
@d1489 4
a1492 4
    ino = pc.get_ino_by_handle (get_handle ());
    /* A unique ID is necessary to recognize fhandler entries which are
       duplicated by dup(2) or fork(2). */
    NtAllocateLocallyUniqueId ((PLUID) &unique_id);
@


1.387
log
@	* fhandler_disk_file.cc (fhandler_disk_file::pread): Skip to non-atomic
	code if mandatory locking is used on this descriptor.  Explain why.
	(fhandler_disk_file::pwrite): Ditto.
	* posix.sgml (std-notes): Extend description of file locking.
@
text
@d521 2
a522 2
  to_timestruc_t ((PFILETIME) &pfnoi->LastAccessTime, &buf->st_atim);
  to_timestruc_t ((PFILETIME) &pfnoi->LastWriteTime, &buf->st_mtim);
d525 2
a526 2
  to_timestruc_t (pfnoi->ChangeTime.QuadPart ? (PFILETIME) &pfnoi->ChangeTime
					    : (PFILETIME) &pfnoi->LastWriteTime,
d528 1
a528 1
  to_timestruc_t ((PFILETIME) &pfnoi->CreationTime, &buf->st_birthtim);
d1346 2
a1347 2
  timespec_to_filetime (&tmp[0], (LPFILETIME) &fbi.LastAccessTime);
  timespec_to_filetime (&tmp[1], (LPFILETIME) &fbi.LastWriteTime);
@


1.386
log
@	* fhandler.cc (fhandler_base::lock): Move to flock.cc.
	(fhandler_base::fixup_after_exec): Reset mandatory_locking.
	* fhandler.h (class fhandler_base): Add mandatory_locking status flag.
	Add mandatory_locking accessor methods.  Accommodate change throughout.
	(fhandler_base::mand_lock): Declare.
	(class fhandler_disk_file): Drop in favor of new status flag.
	* (fhandler_disk_file::fcntl): Call need_fork_fixup if mandatory_locking
	flag gets set.
	* flock.cc (fhandler_base::lock): Define here.
	(flock): Handle mandatory_locking.
	(lockf): Ditto.
	(fhandler_base::mand_lock): Define.
@
text
@d1578 3
a1580 2
  /* In binary mode, we can use an atomic NtReadFile call. */
  if (rbinary ())
d1651 3
a1653 2
  /* In binary mode, we can use an atomic NtWriteFile call. */
  if (wbinary ())
@


1.385
log
@	* autoload.cc (CancelSynchronousIo): Define.
	* fcntl.cc (fcntl64): Drop handling of locking commands.
	* fhandler.h (class fhandler_disk_file): Add mandatory_locking.
	(fhandler_disk_file::fcntl): Declare.
	(fhandler_disk_file::mand_lock): Declare.
	* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file):
	Initialize mandatory_locking.
	(fhandler_disk_file::fcntl): New method.  Handle F_LCK_MANDATORY and
	locking commands.
	(fhandler_disk_file::dup): Duplicate mandatory_locking.  Fix a bug
	when duplicating prw_handle failed.
	(fhandler_disk_file::fixup_after_fork): Reset mandatory_locking.
	* flock.cc (fhandler_disk_file::lock): Add comment.
	(struct lock_parms): New struct to pass parameters to blocking_lock_thr
	thread function.
	(blocking_lock_thr): New thread function.
	(fhandler_disk_file::mand_lock): New methof implementing mandatory
	locking with Windows semantics.
	* ntdll.h (NtLockFile): Declare.
	(NtUnlockFile): Declare.
	* include/fcntl.h: Fix a comment.
	(F_LCK_MANDATORY): Define.  Add lengthy comment to explain.
@
text
@d1382 1
a1382 1
  fhandler_base (), prw_handle (NULL), mandatory_locking (false)
d1387 1
a1387 1
  fhandler_base (), prw_handle (NULL), mandatory_locking (false)
d1418 2
a1419 1
      mandatory_locking = !!arg;
d1428 1
a1428 1
	res = mandatory_locking ? mand_lock (cmd, fl) : lock (cmd, fl);
a1448 1
  fhc->mandatory_locking = mandatory_locking;
d1456 1
a1456 1
  mandatory_locking = false;
@


1.384
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d1382 1
a1382 1
  fhandler_base (), prw_handle (NULL)
d1387 1
a1387 1
  fhandler_base (), prw_handle (NULL)
d1411 27
d1447 2
a1448 1
    prw_handle = NULL;
d1456 1
@


1.383
log
@	* Merge in cygwin-64bit-branch.
@
text
@d322 1
a322 1
int __stdcall
d365 1
a365 1
int __stdcall
d423 1
a423 1
int __stdcall
d467 1
a467 1
int __stdcall
d511 1
a511 1
int __stdcall
d711 1
a711 1
int __stdcall
d786 1
a786 1
int __stdcall
d894 1
a894 1
int __stdcall
d962 1
a962 1
int _stdcall
d1538 1
a1538 1
ssize_t __stdcall
d1612 1
a1612 1
ssize_t __stdcall
d1927 1
a1927 1
ino_t __stdcall
d2396 1
a2396 1
int __stdcall
@


1.382
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d47 1
a47 1
  __ino64_t eval_ino (int idx)
d49 1
a49 1
      __ino64_t ino = 0;
d51 1
a51 1
      struct __stat64 st;
d79 1
a79 1
  __ino64_t check_mount (PUNICODE_STRING fname, __ino64_t ino,
d109 1
a109 1
  __ino64_t check_missing_mount (PUNICODE_STRING retname = NULL)
d155 1
a155 1
path_conv::isgood_inode (__ino64_t ino) const
d223 1
a223 1
inline __ino64_t
d259 1
a259 1
  PFILE_BOTH_DIRECTORY_INFORMATION fdibuf = (PFILE_BOTH_DIRECTORY_INFORMATION)
d275 1
a275 1
      for (PFILE_BOTH_DIRECTORY_INFORMATION pfdi = fdibuf;
d277 1
a277 1
	   pfdi = (PFILE_BOTH_DIRECTORY_INFORMATION)
d323 1
a323 1
fhandler_base::fstat_by_nfs_ea (struct __stat64 *buf)
d356 6
a361 3
  buf->st_atim = nfs_attr->atime;
  buf->st_mtim = nfs_attr->mtime;
  buf->st_ctim = nfs_attr->ctime;
d366 1
a366 1
fhandler_base::fstat_by_handle (struct __stat64 *buf)
d386 1
a386 1
	 debug_printf ("%p = NtQueryInformationFile(%S, "
d400 1
a400 1
	  debug_printf ("%p = NtQueryInformationFile(%S, "
d411 1
a411 1
	      debug_printf ("%p = NtQueryInformationFile(%S, "
d424 1
a424 1
fhandler_base::fstat_by_name (struct __stat64 *buf)
d448 1
a448 1
	debug_printf ("%p = NtOpenFile(%S)", status,
d458 1
a458 1
	    debug_printf ("%p = NtQueryDirectoryFile(%S)", status,
d468 1
a468 1
fhandler_base::fstat_fs (struct __stat64 *buf)
d512 1
a512 1
fhandler_base::fstat_helper (struct __stat64 *buf,
d537 1
a537 1
  buf->st_size = pc.isdir () ? 0 : (_off64_t) pfnoi->EndOfFile.QuadPart;
d549 1
a549 1
    buf->st_ino = (__ino64_t) ino;
d657 1
a657 1
		debug_printf ("%p = NtOpenFile(%S)", status,
d667 1
a667 1
		    debug_printf ("%p = NtReadFile(%S)", status,
d693 3
a695 3
  syscall_printf ("0 = fstat (%S, %p) st_size=%D, st_mode=%p, st_ino=%D"
		  "st_atim=%x.%x st_ctim=%x.%x "
		  "st_mtim=%x.%x st_birthtim=%x.%x",
d706 1
a706 1
fhandler_disk_file::fstat (struct __stat64 *buf)
a717 1
  FILE_FS_SIZE_INFORMATION fsi;
d751 1
a751 3
  /* Get allocation related information.  Try to get "full" information
     first, which is only available since W2K.  If that fails, try to
     retrieve normal allocation information. */
d758 5
a762 3
      sfs->f_blocks = full_fsi.TotalAllocationUnits.LowPart;
      sfs->f_bfree = full_fsi.ActualAvailableAllocationUnits.LowPart;
      sfs->f_bavail = full_fsi.CallerAvailableAllocationUnits.LowPart;
d772 1
a772 1
	    debug_printf ("%p = NtFsControlFile(%S, FSCTL_GET_NTFS_VOLUME_DATA)",
d775 1
a775 1
	    sfs->f_blocks = nvdb.TotalClusters.QuadPart;
a778 16
  else
    {
      status = NtQueryVolumeInformationFile (fh, &io, &fsi, sizeof fsi,
					     FileFsSizeInformation);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  goto out;
	}
      sfs->f_bsize = fsi.BytesPerSector * fsi.SectorsPerAllocationUnit;
      sfs->f_frsize = sfs->f_bsize;
      sfs->f_blocks = fsi.TotalAllocationUnits.LowPart;
      sfs->f_bfree = fsi.AvailableAllocationUnits.LowPart;
      sfs->f_bavail = sfs->f_bfree;
      ret = 0;
    }
d895 1
a895 1
fhandler_disk_file::fchown (__uid32_t uid, __gid32_t gid)
d917 1
a917 1
  __uid32_t old_uid;
d963 1
a963 1
fhandler_disk_file::facl (int cmd, int nentries, __aclent32_t *aclbufp)
d988 1
a988 1
		struct __stat64 st;
d1102 1
a1102 1
fhandler_disk_file::fadvise (_off64_t offset, _off64_t length, int advice)
d1145 1
a1145 1
fhandler_disk_file::ftruncate (_off64_t length, bool allow_truncate)
d1186 2
a1187 2
				| FILE_ATTRIBUTE_SPARSE_FILE);
	  syscall_printf ("%p = NtFsControlFile(%S, FSCTL_SET_SPARSE)",
d1339 1
a1339 1
  debug_printf ("incoming lastaccess %08x %08x", tmp[0].tv_sec, tmp[0].tv_nsec);
d1466 1
a1466 1
  syscall_printf ("%d = fhandler_disk_file::open(%S, %p)", res,
d1527 1
a1527 1
  debug_printf ("%x = NtOpenFile (%p, %x, %S, io, %x, %x)",
d1539 1
a1539 1
fhandler_disk_file::pread (void *buf, size_t count, _off64_t offset)
d1541 2
d1561 1
a1561 1
      if (!NT_SUCCESS (status))
d1589 1
a1590 7

non_atomic:
  /* Text mode stays slow and non-atomic. */
  ssize_t res;
  _off64_t curpos = lseek (0, SEEK_CUR);
  if (curpos < 0 || lseek (offset, SEEK_SET) < 0)
    res = -1;
d1593 5
a1597 4
      size_t tmp_count = count;
      read (buf, tmp_count);
      if (lseek (curpos, SEEK_SET) >= 0)
	res = (ssize_t) tmp_count;
d1599 8
a1606 1
	res = -1;
d1608 1
a1608 1
  debug_printf ("%d = pread(%p, %d, %d)\n", res, buf, count, offset);
d1613 1
a1613 1
fhandler_disk_file::pwrite (void *buf, size_t count, _off64_t offset)
d1643 1
a1643 1
  _off64_t curpos = lseek (0, SEEK_CUR);
d1652 1
a1652 1
  debug_printf ("%d = pwrite(%p, %d, %d)\n", res, buf, count, offset);
d1777 1
a1777 1
  char  __cache[DIR_BUF_SIZE];	/* W2K needs this buffer 8 byte aligned. */
d1820 1
a1820 1
      dir->__d_internal = (unsigned) new __DIR_mounts (get_name ());
d1873 3
a1875 4
	     OS/FS combinations (say, Win2K/CDFS or so).  Instead of
	     testing in readdir for yet another error code, let's use
	     FileIdBothDirectoryInformation only on filesystems supporting
	     persistent ACLs, FileBothDirectoryInformation otherwise.
d1927 1
a1927 1
__ino64_t __stdcall
d1931 1
a1931 1
  struct __stat64 st;
d1935 1
a1935 1
  __ino64_t ino = 0;
d2110 4
a2113 5
	     on NT4 and 2K systems, and it's also not supported on 2K at all,
	     when accessing network drives on any remote OS.  There are also
	     hacked versions of Samba 3.0.x out there (Debian-based it seems),
	     which return STATUS_NOT_SUPPORTED rather than handling this info
	     class.  We just fall back to using a standard directory query in
d2184 1
a2184 1
    debug_printf ("NtQueryDirectoryFile failed, status %p, win32 error %lu",
d2208 1
a2208 1
	  FileName = ((PFILE_BOTH_DIRECTORY_INFORMATION) buf)->FileName;
d2210 1
a2210 1
		((PFILE_BOTH_DIRECTORY_INFORMATION) buf)->FileNameLength;
d2212 1
a2212 1
		((PFILE_BOTH_DIRECTORY_INFORMATION) buf)->FileAttributes;
d2310 1
a2310 1
  syscall_printf ("%d = readdir(%p, %p) (L\"%lS\" > \"%ls\") (attr %p > type %d)",
a2334 26
  if (wincap.has_buggy_restart_scan () && isremote ())
    {
      /* This works around a W2K bug.  The RestartScan parameter in calls
	 to NtQueryDirectoryFile on remote shares is ignored, thus
	 resulting in not being able to rewind on remote shares.  By
	 reopening the directory, we get a fresh new directory pointer. */
      OBJECT_ATTRIBUTES attr;
      NTSTATUS status;
      IO_STATUS_BLOCK io;
      HANDLE new_dir;

      pc.init_reopen_attr (&attr, get_handle ());
      status = NtOpenFile (&new_dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			   &attr, &io, FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT
			   | FILE_OPEN_FOR_BACKUP_INTENT
			   | FILE_DIRECTORY_FILE);
      if (!NT_SUCCESS (status))
	debug_printf ("Unable to reopen dir %s, NT error: %p",
		      get_name (), status);
      else
	{
	  NtClose (get_handle ());
	  set_io_handle (new_dir);
	}
    }
d2387 1
a2387 1
fhandler_cygdrive::fstat (struct __stat64 *buf)
@


1.381
log
@	* fhandler.cc (fhandler_base::write): Don't attempt to sparsify
	an already sparse file.  Drop check for FILE_SUPPORTS_SPARSE_FILES
	flag.  Explicitely set FILE_ATTRIBUTE_SPARSE_FILE attribute in
	cached attributes.
	(fhandler_base::lseek): Only set did_lseek if sparseness is supported.
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Don't attempt
	to sparsify an already sparse file.  Explicitely set
	FILE_ATTRIBUTE_SPARSE_FILE attribute in cached attributes.
	* mount.cc (oopt): Add "sparse" flag.
	(fillout_mntent): Ditto.
	* path.h (enum path_types): Add PATH_SPARSE.
	(path_conv::support_sparse): New method.
	(path_conv::fs_flags): Constify.
	(path_conv::fs_name_len): Ditto.
	include/sys/mount.h: Replace unused MOUNT_MIXED flag with MOUNT_SPARSE.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d702 1
a702 1
int __stdcall
@


1.380
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rewinddir): Fix using
	wrong value in condition.
@
text
@d1192 2
a1193 2
      if (allow_truncate
	  && (pc.fs_flags () & FILE_SUPPORTS_SPARSE_FILES)
d1198 3
@


1.379
log
@* Makefile.in: Add some more optimization flags for cygwait, malloc and path.  Explain
why -fomit-frame-pointer doesn't work right for passwd.o and path.o.  Add
-static to link command line for cygwin0.dll.
* fhandler_disk_file.cc (fhandler_disk_file::facl): Reorganize slightly to
silence compiler warning when compiling with -fstack-check.
* net.cc (inet_ntop6): Initialize structure members to silence compiler warning
when compiling with -fstack-check.
* pseudo-reloc.cc (_pei386_runtime_relocator): Make this a C function.  Detect
NULL u.
* winsup.h (_pei386_runtime_relocator): Declare this as extern "C".
* lib/_cygwin_crt0_common.cc (_pei386_runtime_relocator): Call with NULL
argument.
* signal.cc (sigaction_worker): Eliminate last argument.  Let callers report
their own strace info.  Regparmize.
(sigaction): Reflect sigaction_worker changes.
(siginterrupt): Ditto.
* exceptions.cc: Update copyright.
@
text
@d2361 1
a2361 1
      if (!NT_SUCCESS (stat))
@


1.379.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d47 1
a47 1
  ino_t eval_ino (int idx)
d49 1
a49 1
      ino_t ino = 0;
d51 1
a51 1
      struct stat st;
d79 1
a79 1
  ino_t check_mount (PUNICODE_STRING fname, ino_t ino,
d109 1
a109 1
  ino_t check_missing_mount (PUNICODE_STRING retname = NULL)
d155 1
a155 1
path_conv::isgood_inode (ino_t ino) const
d223 1
a223 1
inline ino_t
d323 1
a323 1
fhandler_base::fstat_by_nfs_ea (struct stat *buf)
d363 1
a363 1
fhandler_base::fstat_by_handle (struct stat *buf)
d421 1
a421 1
fhandler_base::fstat_by_name (struct stat *buf)
d465 1
a465 1
fhandler_base::fstat_fs (struct stat *buf)
d509 1
a509 1
fhandler_base::fstat_helper (struct stat *buf,
d534 1
a534 1
  buf->st_size = pc.isdir () ? 0 : (off_t) pfnoi->EndOfFile.QuadPart;
d546 1
a546 1
    buf->st_ino = (ino_t) ino;
d703 1
a703 1
fhandler_disk_file::fstat (struct stat *buf)
d758 3
a760 5
      sfs->f_blocks = (fsblkcnt_t) full_fsi.TotalAllocationUnits.QuadPart;
      sfs->f_bfree = (fsblkcnt_t)
		     full_fsi.ActualAvailableAllocationUnits.QuadPart;
      sfs->f_bavail = (fsblkcnt_t)
		      full_fsi.CallerAvailableAllocationUnits.QuadPart;
d773 1
a773 1
	    sfs->f_blocks = (fsblkcnt_t) nvdb.TotalClusters.QuadPart;
d788 2
a789 2
      sfs->f_blocks = (fsblkcnt_t) fsi.TotalAllocationUnits.QuadPart;
      sfs->f_bfree = (fsblkcnt_t) fsi.AvailableAllocationUnits.QuadPart;
d909 1
a909 1
fhandler_disk_file::fchown (uid_t uid, gid_t gid)
d931 1
a931 1
  uid_t old_uid;
d1002 1
a1002 1
		struct stat st;
d1116 1
a1116 1
fhandler_disk_file::fadvise (off_t offset, off_t length, int advice)
d1159 1
a1159 1
fhandler_disk_file::ftruncate (off_t length, bool allow_truncate)
d1550 1
a1550 1
fhandler_disk_file::pread (void *buf, size_t count, off_t offset)
d1603 1
a1603 1
  off_t curpos = lseek (0, SEEK_CUR);
d1620 1
a1620 1
fhandler_disk_file::pwrite (void *buf, size_t count, off_t offset)
d1650 1
a1650 1
  off_t curpos = lseek (0, SEEK_CUR);
d1935 1
a1935 1
ino_t __stdcall
d1939 1
a1939 1
  struct stat st;
d1943 1
a1943 1
  ino_t ino = 0;
d2422 1
a2422 1
fhandler_cygdrive::fstat (struct stat *buf)
@


1.379.2.2
log
@	* cygthread.cc: Fix usage of %p in debug printfs, throughout.
	* dcrt0.cc: Ditto.
	* dtable.cc: Ditto.
	* errno.cc: Ditto.
	* exceptions.cc: Ditto.
	* fhandler.cc: Ditto.
	* fhandler_console.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.

	* fhandler_clipboard.cc (cygnativeformat): Define as UINT.
	(fhandler_dev_clipboard::read): Ditto for local format variable.
	Use casts to compare off_t with size_t value.
	* fhandler_console.cc (fhandler_console::ioctl): Avoid compiler
	warnings.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Fix cast.
	* include/sys/dirent.h (struct __DIR): Define __d_internal as uintptr_t,
	rather than unsigned int.

	And pull in changes from HEAD.
@
text
@d383 1
a383 1
	 debug_printf ("%y = NtQueryInformationFile(%S, "
d397 1
a397 1
	  debug_printf ("%y = NtQueryInformationFile(%S, "
d408 1
a408 1
	      debug_printf ("%y = NtQueryInformationFile(%S, "
d445 1
a445 1
	debug_printf ("%y = NtOpenFile(%S)", status,
d455 1
a455 1
	    debug_printf ("%y = NtQueryDirectoryFile(%S)", status,
d654 1
a654 1
		debug_printf ("%y = NtOpenFile(%S)", status,
d664 1
a664 1
		    debug_printf ("%y = NtReadFile(%S)", status,
d690 1
a690 1
  syscall_printf ("0 = fstat (%S, %p) st_size=%D, st_mode=%y, st_ino=%D"
d772 1
a772 1
	    debug_printf ("%y = NtFsControlFile(%S, FSCTL_GET_NTFS_VOLUME_DATA)",
d1200 1
a1200 1
	  syscall_printf ("%y = NtFsControlFile(%S, FSCTL_SET_SPARSE)",
d1479 1
a1479 1
  syscall_printf ("%d = fhandler_disk_file::open(%S, %y)", res,
d1540 1
a1540 1
  debug_printf ("%y = NtOpenFile (%p, %x, %S, io, %x, %x)",
d1617 1
a1617 1
  debug_printf ("%d = pread(%p, %ld, %D)\n", res, buf, count, offset);
d1661 1
a1661 1
  debug_printf ("%d = pwrite(%p, %ld, %D)\n", res, buf, count, offset);
d1829 1
a1829 1
      dir->__d_internal = (uintptr_t) new __DIR_mounts (get_name ());
d2195 1
a2195 1
    debug_printf ("NtQueryDirectoryFile failed, status %y, win32 error %lu",
d2321 1
a2321 1
  syscall_printf ("%d = readdir(%p, %p) (L\"%lS\" > \"%ls\") (attr %y > type %d)",
d2363 2
a2364 2
      if (!NT_SUCCESS (status))
	debug_printf ("Unable to reopen dir %s, NT error: %y",
@


1.379.2.3
log
@	* ntdll.h: Mark more native structures as tested on 64 bit.
	(struct _FILE_BOTH_DIR_INFORMATION): Rename from
	_FILE_BOTH_DIRECTORY_INFORMATION as per WDK documentation.
	* fhandler_disk_file.cc: Accommodate aforementioned structure name
	change.
	* path.cc: Ditto.
@
text
@d259 1
a259 1
  PFILE_BOTH_DIR_INFORMATION fdibuf = (PFILE_BOTH_DIR_INFORMATION)
d275 1
a275 1
      for (PFILE_BOTH_DIR_INFORMATION pfdi = fdibuf;
d277 1
a277 1
	   pfdi = (PFILE_BOTH_DIR_INFORMATION)
d2219 1
a2219 1
	  FileName = ((PFILE_BOTH_DIR_INFORMATION) buf)->FileName;
d2221 1
a2221 1
		((PFILE_BOTH_DIR_INFORMATION) buf)->FileNameLength;
d2223 1
a2223 1
		((PFILE_BOTH_DIR_INFORMATION) buf)->FileAttributes;
@


1.379.2.4
log
@	* include/cygwin/acl.h (struct __acl32): Drop.  Use struct acl or
	aclent_t throughout instead.
	* sec_acl.cc (aclcheck32): Mark currently unused variables as unused.
	(lacl32): Disable on x86_64.
	(acl): Alias to acl32 on x86_64.
	(facl): Alias to facl32 on x86_64.
	(aclcheck): Alias to aclcheck32 on x86_64.
	(aclsort): Alias to aclsort32 on x86_64.
	(acltomode): Alias to acltomode32 on x86_64.
	(aclfrommode): Alias to aclfrommode32 on x86_64.
	(acltopbits): Alias to acltopbits32 on x86_64.
	(aclfrompbits): Alias to aclfrompbits32 on x86_64.
	(acltotext): Alias to acltotext32 on x86_64.
	(aclfromtext): Alias to aclfromtext32 on x86_64.
	* resource.cc (getrlimit): Use correct cast to rlim_t rather than DWORD.
	* sched.cc (sched_setparam): Drop ThreadPriority and all code setting
	it.
@
text
@d979 1
a979 1
fhandler_disk_file::facl (int cmd, int nentries, aclent_t *aclbufp)
@


1.379.2.5
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d691 2
a692 2
		  "st_atim=%lx.%lx st_ctim=%lx.%lx "
		  "st_mtim=%lx.%lx st_birthtim=%lx.%lx",
d1352 1
a1352 1
  debug_printf ("incoming lastaccess %ly %ly", tmp[0].tv_sec, tmp[0].tv_nsec);
d1540 1
a1540 1
  debug_printf ("%y = NtOpenFile (%p, %y, %S, io, %y, %y)",
d2195 1
a2195 1
    debug_printf ("NtQueryDirectoryFile failed, status %y, win32 error %u",
@


1.379.2.6
log
@Pull in changes from HEAD
@
text
@d1194 2
a1195 2
      if (allow_truncate && pc.support_sparse ()
	  & !has_attribute (FILE_ATTRIBUTE_SPARSE_FILE)
a1199 3
	  if (NT_SUCCESS (status))
	    pc.file_attributes (pc.file_attributes ()
			        | FILE_ATTRIBUTE_SPARSE_FILE);
@


1.379.2.7
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d702 1
a702 1
int __reg2
@


1.379.2.8
log
@	* nfs.h: Make sure packing of NFS fattr3 struct is 4 byte.
	(struct nfs_timestruc_t): Define.
	(struct fattr3): Define timestamps as type struct nfs_timestruc_t.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Copy
	each timestruc_t component separately to accommodate different size.
@
text
@d356 3
a358 6
  buf->st_atim.tv_sec = nfs_attr->atime.tv_sec;
  buf->st_atim.tv_nsec = nfs_attr->atime.tv_nsec;
  buf->st_mtim.tv_sec = nfs_attr->mtime.tv_sec;
  buf->st_mtim.tv_nsec = nfs_attr->mtime.tv_nsec;
  buf->st_ctim.tv_sec = nfs_attr->ctime.tv_sec;
  buf->st_ctim.tv_nsec = nfs_attr->ctime.tv_nsec;
@


1.379.2.9
log
@	* fhandler.cc (fhandler_base::raw_read): Rearrange code to use
	NtReadFile and to fix problem using pointer to wrongly sized variable
	on x86_64.
	(fhandler_base::read): Drop redundant code.
	* fhandler_disk_file.cc (fhandler_disk_file::pread): Fix function
	to not read the information twice.  Handle STATUS_END_OF_FILE.
@
text
@a1559 2
  ssize_t res;

d1578 1
a1578 1
      if (!NT_SUCCESS (status) && status != STATUS_END_OF_FILE)
a1605 1
      res = io.Information;	/* Valid on EOF. */
d1607 7
d1616 5
a1620 4
non_atomic:
      /* Text mode stays slow and non-atomic. */
      off_t curpos = lseek (0, SEEK_CUR);
      if (curpos < 0 || lseek (offset, SEEK_SET) < 0)
a1621 9
      else
	{
	  size_t tmp_count = count;
	  read (buf, tmp_count);
	  if (lseek (curpos, SEEK_SET) >= 0)
	    res = (ssize_t) tmp_count;
	  else
	    res = -1;
	}
@


1.379.2.10
log
@	* autoload.cc (AttachConsole): Remove.
	(GetModuleHandleExW): Remove.
	(GetSystemWow64DirectoryW): Remove.
	(GetVolumePathNamesForVolumeNameW): Remove.
	* exceptions.cc (cygwin_stackdump): Always call RtlCaptureContext.
	(exception::handle): Drop accidentally left in debugging statement.
	Always call RtlCaptureContext.
	(sigpacket::process): Always call RtlCaptureContext for current thread.
	* fhandler_disk_file.cc (fstatvfs): Drop code using
	FileFsSizeInformation.
	(struct __DIR_cache): Remove comment.
	(fhandler_disk_file::rewinddir): Drop W2K-only code.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Don't
	check for old OS.  Extend a comment.
	* fhandler_mem.cc (fhandler_dev_mem::open): Drop NT4 and W2K from
	debug output.
	* fhandler_proc.cc (format_proc_partitions): Drop Pre-XP considerations.
	* fhandler_procnet.cc (fhandler_procnet::exists): Ditto.
	(fhandler_procnet::readdir): Ditto.
	(format_procnet_ifinet6): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvmsg): Ditto.
	* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
	* init.cc (dll_entry): Drop W2K-only code.
	* net.cc (get_ifs): Rename from get_xp_ifs.
	(get_2k_ifs): Remove.
	(getifaddrs): Always call get_ifs.
	(get_ifconf): Ditto.
	(if_nametoindex): Drop Pre-XP considerations.
	(load_ipv6_funcs): Ditto.  Fix preceeding comment.
	* sec_auth.cc (lsaauth): Drop code handling fake_login_sid.
	* sec_helper.cc (fake_logon_sid): Remove.
	(set_cygwin_privileges): Fix uncommented statement to drop pre-XP
	considerations.
	* security.h (fake_logon_sid): Drop declaration.
	* shared.cc (shared_info::init_obcaseinsensitive): Drop W2K-only code.
	* wincap.cc: Throughout, remove setting all deprecated wincapc members.
	(wincap_minimal): Set to wincap_xpsp2.
	(wincap_2000): Remove.
	(wincap_2000sp4): Remove.
	(wincap_xp): Remove.
	(wincap_xpsp1): Remove.
	(wincapc::init): Drop OS 5.0 and pre-SP2 XP.
	* wincap.h (struct wincaps): Remove the following members:
	has_create_global_privilege, has_ioctl_storage_get_media_types_ex,
	has_disk_ex_ioctls, has_buggy_restart_scan, needs_logon_sid_in_sid_list,
	has_gaa_prefixes, has_recvmsg, has_stack_size_param_is_a_reservation,
	kernel_is_always_casesensitive, has_rtl_capture_context.
@
text
@d718 1
d752 3
a754 1
  /* Get allocation related information. */
d782 16
d1796 1
a1796 1
  char  __cache[DIR_BUF_SIZE];
d2356 26
@


1.379.2.11
log
@	Remove more old cruft.  Remove Windows NT4 and 2000 from comments
	throughout, unless it still makes sense.
	* dlfcn.cc (dlopen): Drop W2K-only code to make loaded DLL persistent.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Drop code
	trying to use information from NtQueryVolumeInformationFile.
	* fhandler_socket.cc (fhandler_socket::close): Drop code snippet
	disabled since 2008.
	* mount.cc (MINIMAL_WIN_NTFS_FLAGS): Add flag values set on all
	NTFS since Windows XP.
	(get_volume_path_names_for_volume_name): Remove.
	(dos_drive_mappings::dos_drive_mappings): Call Win32 function
	GetVolumePathNamesForVolumeNameW directly.
	* path.cc (file_get_fnoi): Drop test for NT4-only return code.
	* sched.cc: Add FIXME to global comment.  Reformat comments throughout.
	* spawn.cc (child_info_spawn::worker): Just call official IsProcessInJob
	function rather than to test undocumented TEB member.
	* winlean.h: Drop Mingw32-related defines.
	* include/limits.h (PTHREAD_KEYS_MAX): Raise value to reflect minimum
	value available on XP and later.

2013-03-13  Corinna Vinschen  <corinna@@vinschen.de>
@
text
@d1873 4
a1876 3
	     OS/FS combinations.  Instead of testing for yet another error
	     code, let's use FileIdBothDirectoryInformation only on FSes
	     supporting persistent ACLs, FileBothDirectoryInformation otherwise.
d2111 5
a2115 4
	     on NT4 and 2K systems.  There are also hacked versions of
	     Samba 3.0.x out there (Debian-based it seems), which return
	     STATUS_NOT_SUPPORTED rather than handling this info class.
	     We just fall back to using a standard directory query in
@


1.379.2.12
log
@	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Add missed
	ampersand.
@
text
@d1179 1
a1179 1
	  && !has_attribute (FILE_ATTRIBUTE_SPARSE_FILE)
@


1.378
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link ): Translate
	STATUS_NOT_SUPPORTED to EPERM as well.
@
text
@a986 1
	  struct __stat64 st;
d1002 1
@


1.377
log
@	* fhandler_disk_file.cc (path_conv::isgood_inode): Rearrange, take
	Samba versions >= 3.5.4 into account, add comments.
@
text
@d1286 2
a1287 1
      if (status == STATUS_INVALID_DEVICE_REQUEST)
@


1.376
log
@	* fhandler.h (fhandler_dev::open): Declare.
	(fhandler_dev::close): Declare.
	(fhandler_dev::fstat): Declare.
	(fhandler_dev::fstatvfs): Declare.
	(fhandler_cygdrive::fstatvfs): Declare.
	* fhandler_dev.cc (fhandler_dev::open): New method.
	(fhandler_dev::close): Ditto.
	(fhandler_dev::fstat): Ditto.
	(fhandler_dev::fstatvfs): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't fill
	st_rdev.
	(fhandler_cygdrive::fstatvfs): New method.
	* path.h (path_conv::fs_got_fs): New method.
	* mount.h (fs_info::got_fs): Change type to bool, make public.
@
text
@d157 20
a176 5
  /* We can't trust remote inode numbers of only 32 bit.  That means,
     remote NT4 NTFS, as well as shares of Samba version < 3.0.
     The known exception are SFU NFS shares, which return the valid 32 bit
     inode number from the remote file system unchanged. */
  return hasgood_inode () && (ino > UINT32_MAX || !isremote () || fs_is_nfs ());
@


1.375
log
@(Interim checkin while we work on this)
* devices.cc: Regenerate.
* devices.h (device::noexpose): New field.
(device::dev_on_fs): Make a bit field.
(get_major): Use proper type for declaration.
(expose): New field.
(ext_dev_storage): Delete declaration.
(dev_storage_size): Ditto.
(dev_storage): New declaration.
(dev_storage_end): Ditto.
* devices.in: Mark /dev/ptym*, /dev/com*, /dev/pipe, /dev/fifo, and "/dev" as
"no expose".
* fhandler.h (fhandler_dev::lastrealpos): Delete declaration.
(fhandler_dev::devidx): Declare new field.
* fhandler_disk_file.cc: Move fhandler_dev functions into fhandler_dev.cc.
* fhandler_dev.cc: Add includes needed for functions moved from
fhandler_disk_file.cc.
(dev_storage_scan_start): Define place to start listing devices.
(dev_storage_size): Define size of array to scan.
(fhandler_dev::fhandler_dev): Move here from fhandler_disk_file.cc.
(fhandler_dev::opendir): Ditto.
(fhandler_dev::readdir): Just check devidx for non-NULL to determine when to go
to disk for /dev content.  Use dev_storage rather than ext_dev_storage.
Iterate over dev_storage using devidx pointer.  Use accessor functions rather
than raw references to the device struct.  Only increment dir->__d_position
when we are actually going to be returning something.  Add debug_printf for
exit.
(fhandler_dev::rewinddir): Set devidx as appropriate depending on whether
there's a /dev on disk or not.
* gendevices: Don't mark dev_storage static but do put it in the _RDATA
section.
* path.cc (path_conv::check): Use new "device::expose()" function to decide to
forbid programs from referencing internal device types.
@
text
@d511 1
a511 1
  buf->st_rdev = buf->st_dev = get_dev ();
d2415 11
@


1.374
log
@	* Makefile.in (DLL_OFILES): Add fhandler_dev.o.
	* devices.h (DEV_DEV_MAJOR): Define.
	(FH_DEV): Redefine in terms of DEV_DEV_MAJOR.
	(ext_dev_storage): Declare.
	(dev_storage_size): Declare.
	(dev_dev_storage): Declare.
	(dev_dev): Define.
	(isdev_dev): Define.
	* devices.in (dev_dev_storage): Activate.
	(ext_dev_storage): Define as externally available pointer to
	dev_storage.
	(dev_storage_size): Define to contain number of dev_storage elements.
	* dir.cc (rmdir): Handle /dev as always not empty.
	* dtable.cc (fh_alloc): Handle DEV_DEV_MAJOR.
	* fhandler.h (fhandler_dev): New class, derived from fhandler_disk_file.
	(fhandler_union): Add fhandler_dev member.
	* fhandler_disk_file.cc (class __DIR_mounts): Handle /dev directory
	to make sure it always exists.
	* fhandler_dev.cc: New file implementing /dev.
	* globals.cc (ro_u_dev): New R/O unicode string.
	* path.cc (path_conv::check): Handle FH_DEV device.
@
text
@a2367 60
fhandler_dev::fhandler_dev () :
  fhandler_disk_file (), lastrealpos (0), dir_exists (true)
{
}

DIR *
fhandler_dev::opendir (int fd)
{
  DIR *dir;
  DIR *res = NULL;

  dir = fhandler_disk_file::opendir (fd);
  if (dir)
    return dir;
  if ((dir = (DIR *) malloc (sizeof (DIR))) == NULL)
    set_errno (ENOMEM);
  else if ((dir->__d_dirent =
	    (struct dirent *) malloc (sizeof (struct dirent))) == NULL)
    {
      set_errno (ENOMEM);
      goto free_dir;
    }
  else
    {
      cygheap_fdnew cfd;
      if (cfd < 0 && fd < 0)
	goto free_dirent;

      dir->__d_dirname = NULL;
      dir->__d_dirent->__d_version = __DIRENT_VERSION;
      dir->__d_cookie = __DIRENT_COOKIE;
      dir->__handle = INVALID_HANDLE_VALUE;
      dir->__d_position = 0;
      dir->__flags = 0;
      dir->__d_internal = 0;

      if (fd >= 0)
	dir->__d_fd = fd;
      else
	{
	  cfd = this;
	  dir->__d_fd = cfd;
	  cfd->nohandle (true);
	}
      set_close_on_exec (true);
      dir->__fh = this;
      dir_exists = false;
      res = dir;
    }

  syscall_printf ("%p = opendir (%s)", res, get_name ());
  return res;

free_dirent:
  free (dir->__d_dirent);
free_dir:
  free (dir);
  return res;
}

@


1.373
log
@	* autoload.cc (NetUseGetInfo): Define.
	* fhandler_disk_file.cc (fhandler_cygdrive::opendir): Rename flptst
	to drive.  Call new get_disk_type function rather than is_floppy and
	check SMB drives with the NetUseGetInfo function.  Explain why.
	* mount.cc (get_disk_type): New function to evaluate disk type from
	native NT device name.
	(is_floppy): Remove.
	* mount.h (enum disk_type): Define.
	(get_disk_type): Declare.
	* path.h (is_floppy): Drop declaration.
@
text
@d29 1
d40 1
a40 1
  bool		 found[MAX_MOUNTS + 2];
d45 1
d89 5
d131 7
d2368 60
@


1.372
log
@	* fhandler_disk_file.cc (fhandler_cygdrive::fstat): Don't bother to
	set st_nlink correctly, just set it to 1 to avoid potential network
	timeouts.
@
text
@d28 1
d2416 1
a2416 1
  char flptst[] = "X:";
d2430 23
a2452 2
      if (!is_floppy ((flptst[0] = *pdrive, flptst))
	  && GetFileAttributes (pdrive) != INVALID_FILE_ATTRIBUTES)
@


1.371
log
@	Fix memory and handle leaks due to fdopendir:
	* dir.cc (closedir): Call global close instead of just releasing the
	fhandler.
	* fhandler_disk_file.cc (fhandler_disk_file::closedir): Don't close
	fhandler handle here, rely on global closedir doing the right thing.
	* fhandler_registry.cc (fhandler_registry::readdir): Also delete
	d_hash when closing registry key.
	(fhandler_registry::rewinddir): Ditto.

	Avoid infinite recursion in VirtualStore under UAC:
	* fhandler_registry.cc (VIRT_CLASSES_KEY_PREFIX): Define.
	(VIRT_CLASSES_KEY_SUFFIX): Ditto.
	(VIRT_CLASSES_KEY): Ditto.
	(VIRT_CLASSES_LINKTGT): Ditto.
	(fhandler_registry::exists): Return virt_symlink as file type if
	this is a Classes key under the VirtualStore.
	(fhandler_registry::fstat): Handle virt_symlink.
	(fhandler_registry::readdir): Return DT_LNK as d_type if this is a
	Classes key under the VirtualStore.
	(fhandler_registry::fill_filebuf): Handle Classes symlink.

	Handle user impersonation in /proc/registry access:
	* autoload.cc (RegOpenUserClassesRoot): Define.
	(RegOpenCurrentUser): Define.
	* fhandler_registry.cc (RegOpenUserClassesRoot): Declare function
	missing in w32api.
	(RegOpenCurrentUser): Ditto.
	(fetch_hkey): New function.
	(fhandler_registry::open): Call fetch_hkey to get root registry key.
	(open_key): Ditto.
@
text
@d2396 1
a2396 9
  if (!ndrives)
    set_drives ();
  char flptst[] = "X:";
  int n = ndrives;
  for (const char *p = pdrive; p && *p; p = strchr (p, '\0') + 1)
    if (is_floppy ((flptst[0] = *p, flptst))
	|| GetFileAttributes (p) == INVALID_FILE_ATTRIBUTES)
      n--;
  buf->st_nlink = n + 2;
@


1.370
log
@Clean up whitespace.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
a2346 1
  NTSTATUS status;
a2348 12
  if (!get_handle ())
    /* ignore */;
  else if (get_handle () == INVALID_HANDLE_VALUE)
    {
      set_errno (EBADF);
      res = -1;
    }
  else if (!NT_SUCCESS (status = NtClose (get_handle ())))
    {
      __seterrno_from_nt_status (status);
      res = -1;
    }
@


1.369
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Call
	file_get_fnoi instead of NtQueryInformationFile.
	* path.cc (file_get_fnoi): New helper function to collect a
	FILE_NETWORK_OPEN_INFORMATION block.
	(symlink_info::check): Call file_get_fnoi rather than
	NtQueryInformationFile to collect a FILE_NETWORK_OPEN_INFORMATION block.
	* path.h (file_get_fnoi): Declare.
@
text
@d1460 1
a1460 1
   
@


1.368
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d350 1
a350 3
      PFILE_NETWORK_OPEN_INFORMATION pfnoi = pc.fnoi ();
      status = NtQueryInformationFile (h, &io, pfnoi, sizeof *pfnoi,
				      FileNetworkOpenInformation);
@


1.367
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Check invalid
	success only on Samba shares.
	* mount.cc (fs_info::update): Drop has_buggy_basic_info flag for
	NcFsd.
	* syscalls.cc (unlink_nt): Fix typo in comment.
@
text
@d768 1
a768 1
  syscall_printf ("%d = fstatvfs (%s, %p)", ret, get_name (), sfs);
d1448 1
a1448 1
  syscall_printf ("%d = fhandler_disk_file::open (%S, %p)", res,
d1586 1
a1586 1
  debug_printf ("%d = pread (%p, %d, %d)\n", res, buf, count, offset);
d1630 1
a1630 1
  debug_printf ("%d = pwrite (%p, %d, %d)\n", res, buf, count, offset);
d2290 1
a2290 1
  syscall_printf ("%d = readdir (%p, %p) (L\"%lS\" > \"%ls\") (attr %p > type %d)",
d2364 1
a2364 1
  syscall_printf ("%d = closedir (%p, %s)", res, dir, get_name ());
@


1.366
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d1730 2
a1731 1
      else if (NT_SUCCESS (status) && NT_SUCCESS (q_status))
@


1.365
log
@	* fhandler.cc (fhandler_base::open): Fix typo in comment.
	(fhandler_base::close): Move call to del_my_locks from here...
	* fhandler_disk_file.cc (fhandler_disk_file::open): ...to here.
	* flock.cc (struct lockfattr_t): New type.
	(lockf_t::close_lock_obj): New method, use throughout.
	(lockf_t::create_lock_obj_attr): New method.
	(lockf_t::create_lock_obj): Use create_lock_obj_attr method.  Handle
	STATUS_OBJECT_NAME_COLLISION in F_FLOCK case gracefully.  Add lengthy
	comments to explain why and how.
	(lockf_t::open_lock_obj): Use create_lock_obj_attr method.
	(lockf_t::del_lock_obj): Call NtSetEvent rather than SetEvent for
	symmetry.
	(fhandler_disk_file::lock): Define n only where it's used.  Call
	need_fork_fixup only if call was successful.  Handle EINTR and
	ECANCELED return values from lf_setlock.
	(lf_setlock): Drop WAIT_UNLOCKED and WAIT_PROC_EXITED.  Don't wait
	for event object handle count to become <= 1 in F_LOCK case.
	Simplify WFMO return value handling.  Don't handle signal and cancel
	events here; just return with appropriate error code instead.
	(lf_getblock): Ignore locks for which the handle can't be opened.
	Use IsEventSignalled.
	* ntdll.h (STATUS_INVALID_INFO_CLASS): Undef if defined elsewhere to
	make sure the definition is casted to NTSTATUS.
	(STATUS_INVALID_HANDLE): Define and ditto.
	(STATUS_OBJECT_NAME_COLLISION): Define.
	(NtSetEvent): Declare.
@
text
@d1393 1
a1393 1
fhandler_disk_file::dup (fhandler_base *child)
d1397 1
a1397 1
  int ret = fhandler_base::dup (child);
@


1.364
log
@	* syscalls.cc (faccessat): Fix parens in flag expression when calling
	build_fh_name.

	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Fix typo in
	comment.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
@
text
@d1383 1
d1386 3
@


1.363
log
@	* fhandler_disk_file.cc (__DIR_mounts::eval_ino): Create path_conv
	with PC_KEEP_HANDLE flag.
	* path.h (path_conv::operator =): Duplicate UNICODE path as well.
	* security.cc (check_file_access): Use path_conv handle if available.
	* syscalls.cc (access): Create fhandler with PC_KEEP_HANDLE flag set.
	(euidaccess): Ditto.
	(faccessat): Ditto.
@
text
@d1668 1
a1668 1
       I don't know what setting that is or howq to recognize such a share,
@


1.362
log
@	* fhandler.cc (fhandler_base::open): Never create files with WRITE_DAC
	access.  Explain why.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Improve debug
	output.
@
text
@d55 1
a55 1
      path_conv pc (fname, PC_SYM_NOFOLLOW | PC_POSIX);
@


1.361
log
@	* fhandler.cc (fhandler_base::open): Don't open file with WRITE_DAC
	access on remote filesystem.  Explain why.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto for
	directories.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for sockets.
	* path.cc (symlink_worker): Ditto for symlinks.
@
text
@d662 9
a670 4
  syscall_printf ("0 = fstat (%S, %p) st_atime=%x st_size=%D, st_mode=%p, "
		  "st_ino=%D, sizeof=%d",
		  pc.get_nt_native_path (), buf, buf->st_atime, buf->st_size,
		  buf->st_mode, buf->st_ino, sizeof (*buf));
@


1.360
log
@	* fhandler.cc (fhandler_base::open): Drop local create_options variable.
	Use options member instead.
	* fhandler.h (class fhandler_base): Change type of access member to
	ACCESS_MASK.  Change get_access and set_access methods accordingly.
	Add options member.  Add get_options and set_options methods.
	(class fhandler_disk_file): Add prw_handle.
	(fhandler_disk_file::prw_open): Declare.
	(fhandler_disk_file::close): Declare.
	(fhandler_disk_file::dup): Declare.
	(fhandler_disk_file::fixup_after_fork): Declare.
	* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file):
	Initialize prw_handle to NULL.
	(fhandler_disk_file::close): Close prw_handle.
	(fhandler_disk_file::dup): New method.
	(fhandler_disk_file::fixup_after_fork): Set prw_handle to NULL since
	prw_handle is not inherited.
	(fhandler_disk_file::prw_open): New method.  Add long comment to
	explain current behaviour.
	(fhandler_disk_file::pread): Revert previous change.  Change to use
	prw_handle if possible.
	(fhandler_disk_file::pwrite): Change to use prw_handle if possible.
@
text
@d1656 1
a1656 1
  else if (has_acls ())
d1660 5
a1664 1
       open the file again. */
@


1.359
log
@whitespace elimination
@
text
@d1359 1
a1359 1
  fhandler_base ()
d1364 1
a1364 1
  fhandler_base ()
d1376 29
d1444 67
d1528 3
a1530 1
      status = NtReadFile (get_handle (), NULL, NULL, NULL, &io, buf, count,
d1541 1
a1541 1
	      if (is_at_eof (get_handle ()))
d1546 1
a1546 1
		  status = NtReadFile (get_handle (), NULL, NULL, NULL, &io,
d1549 1
a1549 1
		    goto success;
a1559 4

success:
      lseek (-io.Information, SEEK_CUR);
      return io.Information;
d1562 1
d1597 3
a1599 1
      status = NtWriteFile (get_handle (), NULL, NULL, NULL, &io, buf, count,
d1608 2
@


1.358
log
@* fhandler_disk_file.cc (fhandler_disk_file::pread): Reset windows file
position pointer back to previous location after successful read.
@
text
@d175 1
a175 1
	      RtlInitCountedUnicodeString (&subst, 
d183 1
a183 1
	      	ret = DT_LNK;
d352 1
a352 1
                                      FileNetworkOpenInformation);
d618 1
a618 1
	      	 for reading, or the read will change the file position of the
d913 1
a913 1
         uid<->SID mapping is disfunctional.  Even trying to chown to your
d1039 1
a1039 1
	      	goto cant_access_acl;
d1614 2
a1615 1
      q_status = NtQueryAttributesFile (pc.get_object_attr (attr, sec_none_nih),                                        &fbi);
d2108 1
a2108 1
	         NtOpenFile here returns the inode number of the symlink target,
d2110 1
a2110 1
		 
@


1.357
log
@	* fhandler_disk_file.cc (fhandler_disk_file::pread): Correctly return
	with errno set to EBADF if file open mode is incorrect.
	(fhandler_disk_file::pwrite): Ditto.
@
text
@d1451 1
a1451 1
		    return io.Information;
d1462 3
d1467 1
@


1.356
log
@	* fhandler.cc (is_at_eof): Drop static storage class.  Drop err
	parameter since we don't change the Win32 error here anymore.
	(fhandler_base::raw_read): Accommodate change to is_at_eof.

	* fhandler_disk_file.cc (fhandler_disk_file::pread): In binary mode use
	direct call to NtReadFile, rather than lseek/read.
	(fhandler_disk_file::pwrite): In binary mode use direct call to
	NtWriteFile, rather than lseek/write.
@
text
@d1418 6
d1485 6
@


1.355
log
@	* advapi32.cc (InitializeSid): Remove.
	(EqualPrefixSid): Remove.
	(GetLengthSid): Remove.
	(GetSidSubAuthority): Remove.
	(GetSidSubAuthorityCount): Remove.
	(GetSidIdentifierAuthority): Remove.
	* fhandler_disk_file.cc: Remove above functions throughout with their
	ntdll.dll equivalent.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d1418 41
d1479 17
@


1.354
log
@	* advapi32.cc (AllocateLocallyUniqueId): Remove.
	* fhandler_disk_file.cc (fhandler_base::open_fs): Replace call to
	AllocateLocallyUniqueId with call to NtAllocateLocallyUniqueId;
	* posix_ipc.cc (mq_open): Ditto.  Drop error handling for that call.
	(sem_open): Ditto.
@
text
@d929 2
a930 1
		  && EqualPrefixSid (sid, well_known_samba_unix_user_fake_sid)))
@


1.353
log
@	Drop NT4 support.
	* autoload.cc (DnsQuery_A): Fatal if not available.
	(DnsRecordListFree): Ditto.
	(DsGetDcNameW): Ditto.
	(NetGetAnyDCName): Remove.
	(NetGetDCName): Remove.
	(EnumProcessModules): Fatal if not available.
	(GetModuleFileNameExW): Ditto.
	(GetModuleInformation): Ditto.
	(GetProcessMemoryInfo): Ditto.
	(QueryWorkingSet): Ditto.
	(LsaRegisterLogonProcess): Ditto.
	* fenv.cc (_feinitialise): Drop supports_sse condition.
	* fhandler_disk_file.cc (path_conv::isgood_inode): Fix comment.
	(fhandler_base::fstat_by_name): Drop has_fileid_dirinfo condition.
	(fhandler_disk_file::opendir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Fix comment.
	* fhandler_proc.cc (format_proc_partitions): Drop NT4-only code.
	* fhandler_process.cc (get_process_state): Ditto.
	* kernel32.cc (GetWindowsDirectoryW): Remove.
	(GetWindowsDirectoryA): Remove.
	* miscfuncs.cc (nice_to_winprio): Drop NT4-only code.
	* mount.cc (fs_info::update): Fix comments.
	* net.cc (get_2k_ifs): Drop NT4-only code.
	* sec_auth.cc (get_logon_server): Ditto.
	(lsaauth): Drop NT4-specific error handling.
	* security.cc (alloc_sd): Set SE_DACL_PROTECTED unconditionally.
	* select.cc (select_stuff::wait): Always use MWMO_INPUTAVAILABLE.
	(peek_windows): Drop NT4-only condition in call to PeekMessage.
	* syscalls.cc (gethostid): Remove NT4-only workaround.
	* wincap.cc: Througout, drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse from
	wincaps.
	(wincap_nt4sp4): Remove.
	(wincap_minimal): Set to wincap_2000.
	(wincapc::init): Rely on availability of OSVERSIONINFOEX structure.
	Treat error from GetVersionEx as fatal.  Treat NT4 as fatal.
	* wincap.h (struct wincaps): Drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse flags
	and methods.
	* winlean.h (GetWindowsDirectoryW) Define as GetSystemWindowsDirectoryW.
	(GetWindowsDirectoryA): Define as GetSystemWindowsDirectoryA.
@
text
@d1406 1
a1406 1
    AllocateLocallyUniqueId ((PLUID) &unique_id);
@


1.352
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Only use
	file id as inode number if it masters the isgood_inode check.
@
text
@d143 1
a143 2
     all remote inode numbers when running under NT4, as well as remote NT4
     NTFS, as well as shares of Samba version < 3.0.
d406 1
a406 2
  if (!ino && pc.hasgood_inode ()
      && wincap.has_fileid_dirinfo () && !pc.has_buggy_fileid_dirinfo ())
d1680 1
a1680 2
	      else if (wincap.has_fileid_dirinfo ()
		       && !pc.has_buggy_fileid_dirinfo ())
@


1.351
log
@	* fhandler.cc (fhandler_base::open): When creating a file on a
	filesystem supporting ACLs, create the file with WRITE_DAC access.
	Explain why.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto for
	directories.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for sockets.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Always call GetSecurityInfo for directories
	on XP and Server 2003.  Improve comment to explain why.
	(set_file_attribute): Explicitely cast mode_t value to bool in call to
	get_file_sd.
	* wincap.h (wincaps::use_get_sec_info_on_dirs): New element.
	* wincap.cc: Implement above element throughout.
@
text
@d386 2
a387 1
	  ino = fii.FileId.QuadPart;
@


1.351.2.1
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Only use
	file id as inode number if it masters the isgood_inode check.
@
text
@d386 1
a386 2
	  else if (pc.isgood_inode (fii.FileId.QuadPart))
	    ino = fii.FileId.QuadPart;
@


1.350
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Don't
	append slash if there is one already.
@
text
@d1463 1
d1483 7
a1489 2
  status = NtCreateFile (&dir, FILE_LIST_DIRECTORY | SYNCHRONIZE,
			 pc.get_object_attr (attr, sa), &io, NULL,
@


1.349
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Use POSIX
	path to check for symlink.
@
text
@d1834 2
a1835 1
	  *p++ = '/';
@


1.348
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Fix
	computation of st_blocks.
	(fhandler_base::fstat_helper): Fix formatting.
@
text
@d1832 6
a1837 14
	  UNICODE_STRING fbuf;

	  tp.u_get (&fbuf);
	  RtlCopyUnicodeString (&fbuf, pc.get_nt_native_path ());
	  RtlAppendUnicodeToString (&fbuf, L"\\");
	  RtlAppendUnicodeStringToString (&fbuf, fname);
	  fbuf.Buffer += 4; /* Skip leading \??\ */
	  fbuf.Length -= 4 * sizeof (WCHAR);
	  if (fbuf.Buffer[1] != L':') /* UNC path */
	    {
	      *(fbuf.Buffer += 2) = L'\\';
	      fbuf.Length -= 2 * sizeof (WCHAR);
	    }
	  path_conv fpath (&fbuf, PC_SYM_NOFOLLOW);
@


1.347
log
@Fix typo, fix copyright
@
text
@d326 1
a326 1
  buf->st_blocks = nfs_attr->used / 512;
d541 1
a541 1
    buf->st_blocks  = (buf->st_size + S_BLKSIZE - 1) / S_BLKSIZE;
@


1.346
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Alwasy set
	st_size of directories to 0.  Explain why.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
@


1.345
log
@	* fhandler.h (fhandler_base::get_stat_access): Delete.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Always check
	executable suffix to get x-bits for .exe files also in notexec case.
	Always reopen file when checking for file header.
	* ntdll.h (wait_pending): Delete.
	* path.cc (symlink_info::check_shortcut): Drop call to wait_pending
	since file is always opened for sync IO.
	(symlink_info::check_sysfile): Ditto.
	(MIN_STAT_ACCESS): Remove.
	(FULL_STAT_ACCESS): Remove.
	(symlink_info::check): Drop access flag.  Revert to open file with
	just read attributes access.  Reorder symlink check to check for
	reparse points first.  Don't check reparse points for anything else,
	even on remote drives.  Open file for GENERIC_READ when trying to
	read shortcuts or system-bit symlinks. Accommodate dropped access
	flag in call to path_conv_handle::set.
	* path.h (class path_conv_handle): Drop access flag and accommodate
	all related methods.
@
text
@d500 8
a507 1
  buf->st_size = (_off64_t) pfnoi->EndOfFile.QuadPart;
@


1.344
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Simplify.
	Just call nfs_fetch_fattr3 if called via fstat.
	* nfs.cc (nfs_fetch_fattr3): New function to fetch NFS fattr3 info from
	file handle.
	* nfs.h (nfs_fetch_fattr3): Declare.
	* path.cc (symlink_info::check): Simplify NFS case.  Just call
	nfs_fetch_fattr3.
@
text
@d594 1
a594 1
	  if (pc.exec_state () == dont_know_if_executable)
d607 1
a607 2
	      LARGE_INTEGER off = { QuadPart:0LL };
	      char magic[3];
a609 1
	      bool opened = false;
d611 12
a622 18
	      if (h == get_handle ())
		{
		  /* We have been opened via fstat.  We have to re-open the
		     file.  Either the file is not opened for reading, or the
		     read will change the file position. */
		  OBJECT_ATTRIBUTES attr;
		  pc.init_reopen_attr (&attr, h);
		  status = NtOpenFile (&h, SYNCHRONIZE | FILE_READ_DATA,
				       &attr, &io, FILE_SHARE_VALID_FLAGS,
				       FILE_OPEN_FOR_BACKUP_INTENT
				       | FILE_OPEN_REPARSE_POINT);
		  if (!NT_SUCCESS (status))
		    debug_printf ("%p = NtOpenFile(%S)", status,
				  pc.get_nt_native_path ());
		  else
		    opened = true;
		}
	      if (NT_SUCCESS (status))
d624 3
a628 1
		  status = wait_pending (status, h, io);
d638 1
a639 2
	      if (opened)
		NtClose (h);
@


1.343
log
@	* fhandler.cc: Drop including nfs.h.
	* fhandler_disk_file.cc: Ditto.
	(fhandler_base::fstat_by_nfs_ea): Use fattr3 from path_conv member,
	unless called from fstat.
	* path.cc: Drop including nfs.h.
	(symlink_info::check): Rearrange definition of file info buffers.
	Fetch fattr3 info for files on NFS and store in conv_hdl for later
	use in fhandler_base::fstat_by_nfs_ea.  Use fattr3 file type to
	recognize symlink on NFS and try to fetch symlink target only for
	actual symlinks.
	* path.h: Include nfs.h.
	(class path_conv_handle): Change file info storage to union of
	FILE_NETWORK_OPEN_INFORMATION and fattr3 structures.
	(path_conv_handle::fnoi): Align to aforementioned change.
	(path_conv_handle::nfsattr): New method.
	(path_conv::nfsattr): New method.
@
text
@a295 10
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  struct {
    FILE_FULL_EA_INFORMATION ffei;
    char buf[sizeof (NFS_V3_ATTR) + sizeof (fattr3)];
  } ffei_buf;
  struct {
     FILE_GET_EA_INFORMATION fgei;
     char buf[sizeof (NFS_V3_ATTR)];
  } fgei_buf;
d307 1
a307 10

      fgei_buf.fgei.NextEntryOffset = 0;
      fgei_buf.fgei.EaNameLength = sizeof (NFS_V3_ATTR) - 1;
      stpcpy (fgei_buf.fgei.EaName, NFS_V3_ATTR);
      status = NtQueryEaFile (get_io_handle (), &io,
			      &ffei_buf.ffei, sizeof ffei_buf, TRUE,
			      &fgei_buf.fgei, sizeof fgei_buf, NULL, TRUE);
      if (NT_SUCCESS (status))
	nfs_attr = (fattr3 *) (ffei_buf.ffei.EaName
			       + ffei_buf.ffei.EaNameLength + 1);
@


1.342
log
@	* fhandler.cc (fhandler_base::open): Handle query_write_dac flag.
	* fhandler.h (enum query_state): Add query_write_dac flag.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Open file
	with query_write_dac instead of query_write_control.
@
text
@a25 1
#include "nfs.h"
d305 2
a306 1
   } fgei_buf;
d308 1
a308 15
  /* NFS stumbles over its own caching.  If you write to the file,
     a subsequent fstat does not return the actual size of the file,
     but the size at the time the handle has been opened.  Unless
     access through another handle invalidates the caching within the
     NFS client. */
  if (get_io_handle () && (get_access () & GENERIC_WRITE))
    FlushFileBuffers (get_io_handle ());

  fgei_buf.fgei.NextEntryOffset = 0;
  fgei_buf.fgei.EaNameLength = sizeof (NFS_V3_ATTR) - 1;
  stpcpy (fgei_buf.fgei.EaName, NFS_V3_ATTR);
  status = NtQueryEaFile (get_stat_handle (), &io,
			  &ffei_buf.ffei, sizeof ffei_buf, TRUE,
			  &fgei_buf.fgei, sizeof fgei_buf, NULL, TRUE);
  if (NT_SUCCESS (status))
d310 24
a333 8
      fattr3 *nfs_attr = (fattr3 *) (ffei_buf.ffei.EaName
				     + ffei_buf.ffei.EaNameLength + 1);
      buf->st_dev = nfs_attr->fsid;
      buf->st_ino = nfs_attr->fileid;
      buf->st_mode = (nfs_attr->mode & 0xfff)
		     | nfs_type_mapping[nfs_attr->type & 7];
      buf->st_nlink = nfs_attr->nlink;
      /* FIXME: How to convert UNIX uid/gid to Windows SIDs? */
d335 2
a336 2
      buf->st_uid = nfs_attr->uid;
      buf->st_gid = nfs_attr->gid;
d338 2
a339 2
      buf->st_uid = myself->uid;
      buf->st_gid = myself->gid;
d341 9
a349 12
      buf->st_rdev = makedev (nfs_attr->rdev.specdata1,
			      nfs_attr->rdev.specdata2);
      buf->st_size = nfs_attr->size;
      buf->st_blksize = PREFERRED_IO_BLKSIZE;
      buf->st_blocks = nfs_attr->used / 512;
      buf->st_atim = nfs_attr->atime;
      buf->st_mtim = nfs_attr->mtime;
      buf->st_ctim = nfs_attr->ctime;
      return 0;
    }
  debug_printf ("%p = NtQueryEaFile(%S)", status, pc.get_nt_native_path ());
  return -1;
@


1.341
log
@	* errno.cc (errmap): Map ERROR_BAD_NET_RESP to ENOSYS.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Handle ENOSYS and
	point to  the explanation.
	* ntdll.h (STATUS_NOT_IMPLEMENTED): Define.
	* path.cc (symlink_info::check): Handle the inability of NT4 to use
	FileNetworkOpenInformation on share root dirs in either direction.
	* path.h (slash_unc_prefix_p): Remove unused declaration.
	* security.cc (get_info_from_sd): Handle ENOSYS from get_file_sd.
	Explain when this happens.
@
text
@d802 1
a802 1
      query_open (query_write_control);
@


1.340
log
@	* mount.h (class fs_info): Add has_buggy_reopen flag and accessor
	methods.
	* mount.cc (fs_info::update): Set has_buggy_reopen flag for NWFS.
	Add comment.
	* path.h (path_conv::get_object_attr) Make inline method.
	(path_conv::init_reopen_attr): New inline method.
	* path.cc (path_conv::get_object_attr): Remove.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Use
	path_conv::init_reopen_attr method to initialize OBJECT_ATTRIBUTE for
	reopening file.
	(fhandler_disk_file::fchmod): Ditto.
	(fhandler_base::utimens_fs): Ditto.
	(fhandler_disk_file::rewinddir): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
@
text
@d1057 3
d1063 3
@


1.339
log
@	* fhandler.cc (fhandler_base::open): Always open NFS files with
	FILE_READ_EA, even when opening with O_WRONLY to allow fstat.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Call
	FlushFileBuffers if file has been opened for writing.  Explain why.
	(fhandler_base::fstat_by_handle): Renew content of pc.fnoi if called
	via fstat.  Explain why.  Fix formatting.
	* path.cc (symlink_info::check): Try to open file the second time with
	FILE_READ_EA permissions since it's needed in later calls to
	fhandler_base::fstat_by_nfs_ea.
@
text
@d639 1
a639 7
		  if (pc.fs_is_nwfs ())
		    InitializeObjectAttributes (&attr, pc.get_nt_native_path (),
						OBJ_CASE_INSENSITIVE,
						NULL, NULL)
		  else
		    InitializeObjectAttributes (&attr, &ro_u_empty, 0,
						get_handle (), NULL);
d871 1
a871 1
      InitializeObjectAttributes (&attr, &ro_u_empty, 0, get_handle (), NULL);
d1350 1
a1350 1
      InitializeObjectAttributes (&attr, &ro_u_empty, 0, get_handle (), NULL);
d2154 1
a2154 2
      InitializeObjectAttributes (&attr, &ro_u_empty, pc.objcaseinsensitive (),
				  get_handle (), NULL);
@


1.338
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Fetch number
	of links and inode number only if path has good inodes.
	(fhandler_base::fstat_by_name): Fetch inode number only if path has
	good inodes.
@
text
@d308 8
d367 15
d390 2
a391 1
	  debug_printf ("%p = NtQueryInformationFile(%S, FileStandardInformation)",
d401 2
a402 1
	      debug_printf ("%p = NtQueryInformationFile(%S, FileInternalInformation)",
@


1.337
log
@	* fhandler.h (class fhandler_base): Change inheritance of fstat_helper
	and fstat_by_...  methods to private.
	(fhandler_base::fstat_helper): Drop all redundant arguments.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call
	to fstat_by_nfs_ea here.  Drop fetching basic file information.
	Drop setting file attributes.  Accommodate change in fstat_helper call.
	(fhandler_base::fstat_by_name): Simplify.  Only fetch directory
	information to get the inode number.  Drop setting file attributes.
	Accommodate change in fstat_helper call.
	(fhandler_base::fstat_fs): Call fstat_by_nfs_ea if on NFS.
	(fhandler_base::fstat_helper): Drop all redundant arguments.  Use
	information already collected in the fhandler.  Move heading comment
	into code and drop dwFileAttributes comment.
	* mmap.cc (mmap64): Call fstat_fs rather than fstat_by_handle.
	* mount.cc (fs_info::update): Note that has_buggy_basic_info is unused.
	* path.cc (symlink_info::check_reparse_point): Add comment.
	(symlink_info::check): Fetch FileNetworkOpenInformation rather than
	FileBasicInformation throughout, except on NFS.  Explain why.  Store
	FILE_NETWORK_OPEN_INFORMATION in conv_hdl.  Remove
	FILE_ATTRIBUTE_DIRECTORY attribute in conv_hdl for reparse point
	symlinks.
	* path.h (class path_conv_handle): Add FILE_NETWORK_OPEN_INFORMATION
	member _fnoi.
	(path_conv_handle::fnoi): New accessor method for _fnoi.
	(path_conv::fnoi): New accessor method for cubv_hdl._fnoi.

	* fhandler_tty.cc (fhandler_tty_slave::init): Use tty::setpgid method.
@
text
@d359 3
a361 3
  status = NtQueryInformationFile (h, &io, &fsi, sizeof fsi,
				   FileStandardInformation);
  if (!NT_SUCCESS (status))
d363 2
a364 8
      debug_printf ("%p = NtQueryInformationFile(%S, FileStandardInformation)",
		    status, pc.get_nt_native_path ());
      return -1;
    }
  if (!ino && pc.hasgood_inode ())
    {
      status = NtQueryInformationFile (h, &io, &fii, sizeof fii,
				       FileInternalInformation);
d367 1
a367 1
	  debug_printf ("%p = NtQueryInformationFile(%S, FileInternalInformation)",
d371 12
a382 1
      ino = fii.FileId.QuadPart;
d401 2
a402 1
  if (!ino && wincap.has_fileid_dirinfo () && !pc.has_buggy_fileid_dirinfo ())
@


1.336
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): More thoroughly
	check the existence condition on remote drives.  Enhance comment.
@
text
@a347 6
  NTSTATUS status;
  IO_STATUS_BLOCK io;

  if (pc.fs_is_nfs ())
    return fstat_by_nfs_ea (buf);

a351 5

  union {
    FILE_BASIC_INFORMATION fbi;
    FILE_NETWORK_OPEN_INFORMATION fnoi;
  } fi;
d356 2
a358 17
  if (pc.has_buggy_basic_info ())
    {
      status = NtQueryInformationFile (h, &io, &fi, sizeof fi,
				       FileNetworkOpenInformation);
      /* The timestamps are in the same relative memory location, only
	 the DOS attributes have to be moved. */
      fi.fbi.FileAttributes = fi.fnoi.FileAttributes;
    }
  else
    status = NtQueryInformationFile (h, &io, &fi.fbi,
				     sizeof fi.fbi, FileBasicInformation);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("%p = NtQueryInformationFile(%S, FileBasicInformation)",
		    status, pc.get_nt_native_path ());
      return -1;
    }
d379 1
a379 20
  /* If the change time is 0, it's a file system which doesn't
     support a change timestamp.  In that case use the LastWriteTime
     entry, as in other calls to fstat_helper. */
  if (pc.is_rep_symlink ())
    fi.fbi.FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
  /* Only copy attributes if not a device root dir. */
  if (!(pc.file_attributes () & FILE_ATTRIBUTE_DEVICE))
    pc.file_attributes (fi.fbi.FileAttributes);
  return fstat_helper (buf,
		       fi.fbi.ChangeTime.QuadPart ? &fi.fbi.ChangeTime
						  : &fi.fbi.LastWriteTime,
		       &fi.fbi.LastAccessTime,
		       &fi.fbi.LastWriteTime,
		       &fi.fbi.CreationTime,
		       get_dev (),
		       fsi.EndOfFile.QuadPart,
		       fsi.AllocationSize.QuadPart,
		       ino,
		       fsi.NumberOfLinks,
		       fi.fbi.FileAttributes);
a394 1
  LARGE_INTEGER FileId;
d396 1
a396 8
  RtlSplitUnicodePath (pc.get_nt_native_path (), &dirname, &basename);
  InitializeObjectAttributes (&attr, &dirname, pc.objcaseinsensitive (),
			      NULL, NULL);
  if (!NT_SUCCESS (status = NtOpenFile (&dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
				       &attr, &io, FILE_SHARE_VALID_FLAGS,
				       FILE_SYNCHRONOUS_IO_NONALERT
				       | FILE_OPEN_FOR_BACKUP_INTENT
				       | FILE_DIRECTORY_FILE)))
d398 24
a421 21
      debug_printf ("%p = NtOpenFile(%S)", status, pc.get_nt_native_path ());
      goto too_bad;
    }
  if (wincap.has_fileid_dirinfo () && !pc.has_buggy_fileid_dirinfo ()
      && NT_SUCCESS (status = NtQueryDirectoryFile (dir, NULL, NULL, NULL, &io,
						 &fdi_buf.fdi, sizeof fdi_buf,
						 FileIdBothDirectoryInformation,
						 TRUE, &basename, TRUE)))
    FileId = fdi_buf.fdi.FileId;
  else if (NT_SUCCESS (status = NtQueryDirectoryFile (dir, NULL, NULL, NULL,
						 &io, &fdi_buf.fdi,
						 sizeof fdi_buf,
						 FileBothDirectoryInformation,
						 TRUE, &basename, TRUE)))
    FileId.QuadPart = 0; /* get_ino is called in fstat_helper. */
  if (!NT_SUCCESS (status))
    {
      debug_printf ("%p = NtQueryDirectoryFile(%S)", status,
		    pc.get_nt_native_path ());
      NtClose (dir);
      goto too_bad;
d423 1
a423 37
  NtClose (dir);
  /* If the change time is 0, it's a file system which doesn't
     support a change timestamp.  In that case use the LastWriteTime
     entry, as in other calls to fstat_helper. */
  if (pc.is_rep_symlink ())
    fdi_buf.fdi.FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
  /* Only copy attributes if not a device root dir. */
  if (!(pc.file_attributes () & FILE_ATTRIBUTE_DEVICE))
    pc.file_attributes (fdi_buf.fdi.FileAttributes);
  return fstat_helper (buf,
		       fdi_buf.fdi.ChangeTime.QuadPart
		       ? &fdi_buf.fdi.ChangeTime : &fdi_buf.fdi.LastWriteTime,
		       &fdi_buf.fdi.LastAccessTime,
		       &fdi_buf.fdi.LastWriteTime,
		       &fdi_buf.fdi.CreationTime,
		       pc.fs_serial_number (),
		       fdi_buf.fdi.EndOfFile.QuadPart,
		       fdi_buf.fdi.AllocationSize.QuadPart,
		       FileId.QuadPart,
		       1,
		       fdi_buf.fdi.FileAttributes);

too_bad:
  LARGE_INTEGER ft;
  /* Arbitrary value: 2006-12-01 */
  RtlSecondsSince1970ToTime (1164931200L, &ft);
  return fstat_helper (buf,
		       &ft,
		       &ft,
		       &ft,
		       &ft,
		       0,
		       0ULL,
		       -1LL,
		       0ULL,
		       1,
		       pc.file_attributes ());
d436 1
a436 1
	res = fstat_by_handle (buf);
d457 1
a457 1
      res = fstat_by_handle (buf);
a469 10
/* The ChangeTime is taken from the NTFS ChangeTime entry, if reading
   the file information using NtQueryInformationFile succeeded.  If not,
   it's faked using the LastWriteTime entry from GetFileInformationByHandle
   or FindFirstFile.  We're deliberatly not using the creation time anymore
   to simplify interaction with native Windows applications which choke on
   creation times >= access or write times.

   Note that the dwFileAttributes member of the file information evaluated
   in the calling function is used here, not the pc.fileattr member, since
   the latter might be old and not reflect the actual state of the file. */
d472 1
a472 10
			     PLARGE_INTEGER ChangeTime,
			     PLARGE_INTEGER LastAccessTime,
			     PLARGE_INTEGER LastWriteTime,
			     PLARGE_INTEGER CreationTime,
			     DWORD dwVolumeSerialNumber,
			     ULONGLONG nFileSize,
			     LONGLONG nAllocSize,
			     ULONGLONG nFileIndex,
			     DWORD nNumberOfLinks,
			     DWORD dwFileAttributes)
d477 2
d480 10
a489 6
  to_timestruc_t ((PFILETIME) LastAccessTime, &buf->st_atim);
  to_timestruc_t ((PFILETIME) LastWriteTime, &buf->st_mtim);
  to_timestruc_t ((PFILETIME) ChangeTime, &buf->st_ctim);
  to_timestruc_t ((PFILETIME) CreationTime, &buf->st_birthtim);
  buf->st_rdev = buf->st_dev = dwVolumeSerialNumber;
  buf->st_size = (_off64_t) nFileSize;
d500 2
a501 2
  if (nFileIndex && pc.isgood_inode (nFileIndex))
    buf->st_ino = (__ino64_t) nFileIndex;
d507 1
a507 1
  if (nAllocSize >= 0LL)
d510 4
a513 3
    buf->st_blocks = (nAllocSize + S_BLKSIZE - 1) / S_BLKSIZE;
  else if (::has_attribute (dwFileAttributes, FILE_ATTRIBUTE_COMPRESSED
					      | FILE_ATTRIBUTE_SPARSE_FILE)
d546 1
a546 1
      if (::has_attribute (dwFileAttributes, FILE_ATTRIBUTE_READONLY)
d565 1
a565 1
      if (!::has_attribute (dwFileAttributes, FILE_ATTRIBUTE_READONLY))
@


1.335
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procsys.o.
	* devices.h (enum fh_devices): Add FH_PROCSYS.
	* devices.in (dev_procsys_storage): New device.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add code to allocate fhandler_procsys.
	* fhandler.h (proc_len): Convert to size_t.
	(procsys): Declare.
	(procsys_len): Declare.
	(enum virtual_ftype_t): Move here from fhandler_virtual.h.
	Add members supported by fhandler_procsys.
	(fhandler_virtual::exists): Return virtual_ftype_t.  Change
	in all derived classes.
	(class fhandler_procsys): New class.
	(fhandler_union): Add fhandler_procnet and fhandler_procsys members.
	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Use
	ro_u_proc.
	(fhandler_base::fstat_by_handle): Don't copy attributes if file is an
	NT device.
	(fhandler_base::fstat_by_name): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::exists): Return
	virtual_ftype_t.
	* fhandler_proc.cc (proc_tab): Sort alphabetically.  Use _VN macro
	to store length.
	(proc_len): Change to size_t.
	(proc_tab_cmp): New static function.
	(virt_tab_search): New function to search entry in virt_tab_t
	arrays.  Use throughout in /proc and sibling classes instead of
	loop.
	(fhandler_proc::exists): Return virtual_ftype_t.
	* fhandler_process.cc (process_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_process::exists): Return virtual_ftype_t.
	(fhandler_process::open): Simplify code.
	* fhandler_procnet.cc (procnet_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_procnet::exists): Return virtual_ftype_t.
	(fhandler_procnet::open): Simplify.
	* fhandler_procsys.cc: New file.
	* fhandler_registry.cc (fhandler_registry::exists): Return
	virtual_ftype_t.
	* fhandler_virtual.cc (fhandler_virtual::exists): Ditto.
	* fhandler_virtual.h (enum virtual_ftype_t): Move to fhandler.h.
	(virt_tab_t): Add name_len member.
	(_VN): New macro.
	(virt_tab_search): Declare.
	* mount.cc (mount_info::conv_to_win32_path): Fix comment.  Backslashify
	isprocsys_dev paths.
	* ntdll.h (STATUS_OBJECT_TYPE_MISMATCH): Define
	(STATUS_INSTANCE_NOT_AVAILABLE): Define.
	(STATUS_PIPE_NOT_AVAILABLE): Define.
	(STATUS_INVALID_PIPE_STATE): Define.
	(STATUS_PIPE_BUSY): Define.
	(SYMBOLIC_LINK_QUERY): Define.
	(NtOpenSymbolicLinkObject): Declare.
	(NtQuerySymbolicLinkObject): Declare.
	* path.cc (path_conv::check): Accommodate fact that exists method
	returns virtual_ftype_t now.  Add cases for new virtual_ftype_t
	types.
	(cygwin_conv_path): Add GLOBALROOT prefix to native device paths.
	Make sure to strip \\?\ prefix only for actual filesystem-based
	paths, not for all paths.
	* path.h (isproc_dev): Add FH_PROCSYS.
	(isprocsys_dev): Define.
@
text
@d1612 3
a1614 2
     - Removeing a directory on a samba drive doesn't return an error if the
       directory can't be removed because it's not empty.  */
d1619 1
d1621 4
a1624 2
      if (NT_SUCCESS (NtQueryAttributesFile
			    (pc.get_object_attr (attr, sec_none_nih), &fbi)))
a1625 2
      else
	status = STATUS_SUCCESS;
@


1.334
log
@	* fhandler_disk_file.cc (readdir_check_reparse_point): Rename from
	is_volume_mountpoint.  Return valid d_type value for underlying
	reparse point type.
	(readdir_get_ino): Don't rely on the handle set in pc.check.  Open
	file here if pc.handle() is NULL.
	(fhandler_disk_file::readdir_helper): Try to set a correct d_type value
	more diligent.
	(fhandler_disk_file::readdir): Don't reset dirent_set_d_ino unless
	we're really sure it's due to an untrusted FS.  Simplify usage of
	FileAttributes, which is 0 if buf is NULL, anyway.  Set d_type
	correctly for faked "." and ".." entries.  Improve debug output.
	* path.cc (symlink_info::check): Don't keep handle to volume mount
	point open.  Explain why.
@
text
@d121 1
a121 1
		RtlInitUnicodeString (retname, L"proc");
d410 3
a412 1
  pc.file_attributes (fi.fbi.FileAttributes);
d479 3
a481 1
  pc.file_attributes (fdi_buf.fdi.FileAttributes);
@


1.333
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Revert usage
	of get_stat_handle () to get_handle ().  Add comment to explain why.
	* syscalls.cc (statvfs): Drop using PC_KEEP_HANDLE.
@
text
@d151 7
a157 2
static inline bool
is_volume_mountpoint (POBJECT_ATTRIBUTES attr)
d159 1
a159 1
  bool ret = false;
d173 18
a190 9
		      (LPVOID) rp, MAXIMUM_REPARSE_DATA_BUFFER_SIZE))
	  && rp->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT
	  && (RtlInitCountedUnicodeString (&subst, 
		(WCHAR *)((char *)rp->MountPointReparseBuffer.PathBuffer
			  + rp->MountPointReparseBuffer.SubstituteNameOffset),
		rp->MountPointReparseBuffer.SubstituteNameLength),
	      RtlEqualUnicodePathPrefix (&subst, &ro_u_volume, TRUE)))
	ret = true;
      NtClose (reph);
d1800 2
d1821 8
a1828 1
  else if ((hdl = pc.handle ()) != NULL)
d1856 3
a1858 3
  /* Set d_type if type can be determined from file attributes.
     FILE_ATTRIBUTE_SYSTEM ommitted to leave DT_UNKNOWN for old symlinks.
     For new symlinks, d_type will be reset to DT_UNKNOWN below.  */
d1860 1
a1860 3
      !(attr & (  ~FILE_ATTRIBUTE_VALID_FLAGS
		| FILE_ATTRIBUTE_SYSTEM
		| FILE_ATTRIBUTE_REPARSE_POINT)))
d1864 2
a1865 1
      else
d1880 8
a1887 2
      if (is_volume_mountpoint (&attr)
	  && (NT_SUCCESS (NtOpenFile (&reph, READ_CONTROL, &attr, &io,
d1889 5
a1893 4
				      FILE_OPEN_FOR_BACKUP_INTENT))))
	{
	  de->d_ino = pc.get_ino_by_handle (reph);
	  NtClose (reph);
d1897 6
a1902 3
  /* Check for Windows shortcut. If it's a Cygwin or U/WIN
     symlink, drop the .lnk suffix. */
  if ((attr & FILE_ATTRIBUTE_READONLY) && fname->Length > 4 * sizeof (WCHAR))
d1927 6
a1932 1
	  if (fpath.issymlink () || fpath.is_fs_special ())
d1935 6
a1940 1
	      de->d_type = DT_UNKNOWN;
d2139 6
a2144 1
		  de->d_ino = pc.get_ino_by_handle (hdl);
d2146 9
a2156 3
	  /* Untrusted file system.  Don't try to fetch inode number again. */
	  if (de->d_ino == 0)
	    dir->__flags &= ~dirent_set_d_ino;
d2161 1
a2161 1
			      buf ? FileAttributes : 0, &fname)))
d2167 1
d2179 1
d2185 3
a2187 2
  syscall_printf ("%d = readdir (%p, %p) (L\"%lS\" > \"%ls\")", res, dir, &de,
		  res ? NULL : &fname, res ? "***" : de->d_name);
@


1.332
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Set st_rdev
	to correct device number for fs_special devices.
@
text
@d759 5
a763 1
  HANDLE fh = get_stat_handle ();
@


1.331
log
@	Align seekdir and telldir API to POSIX definition.
	* Makefile.in (NEW_FUNCTIONS): Remove seekdir and telldir mappings.
	* dir.cc (telldir): Move functionality from telldir64 here.  Use
	long, rather than _off_t.
	(telldir64): Just call telldir.  Only keep for backward compatibility.
	(seekdir): Move functionality from seekdir64 here.  Use long, rather
	than _off_t.
	(seekdir64): Just call seekdir.  Only keep for backward compatibility.
	* fhandler.h: Throughout, change prototypes of seekdir and telldir
	methods to use long, rather than _off64_t.
	* fhandler_disk_file.cc: Change aforementioned methods accordingly.
	* fhandler_netdrive.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* include/sys/dirent.h (struct __DIR): Change __d_position from
	_off_t to long to reflect API change.
	(telldir): Change prototype to use long, rather than off_t.
	(seekdir): Ditto.
@
text
@d636 1
a636 1
	  buf->st_dev = dev ();
d655 1
a655 1
	  buf->st_dev = dev ();
@


1.330
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Fetch stat
	handle only after checking for NFS.
@
text
@d2131 1
a2131 1
_off64_t
d2138 1
a2138 1
fhandler_disk_file::seekdir (DIR *dir, _off64_t loc)
@


1.329
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Use handle
	returned by get_stat_handle.
	(fhandler_base::fstat_helper): Reinstatiate code to re-open the file
	when checking for executability if called via fstat.  Explain why.
@
text
@a335 1
  HANDLE h = get_stat_handle ();
d352 2
@


1.328
log
@	* dtable.cc (dtable::dup_worker): Reset path_conv handle in duplicated
	fhandler.
	* fhandler.cc (fhandler_base::fstatvfs): Keep handle in created
	path_conv.
	* fhandler.h (fhandler_base::get_stat_access): New method.
	(fhandler_base::get_stat_handle): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Use handle
	returned by get_stat_handle.  Only request inode from system if it
	isn't already set in the fhandler, and only for filesystems supporting
	them.
	(fhandler_base::fstat_fs): Use handle returned by get_stat_handle.
	Change the way open_fs is called.  Explain why.
	(fhandler_base::fstat_helper): Use handle returned by get_stat_handle.
	Never use 0 inode number.  Simplify executable recognition by re-using
	get_stat_handle if file could be opened with sufficient rights.
	(fhandler_disk_file::fstatvfs): Use handle returned by get_stat_handle.
	(fhandler_disk_file::facl): Use handle returned by get_stat_handle in
	GETACL and GETACLCNT cases.
	(fhandler_disk_file::link): Use handle returned by get_stat_handle
	instead of opening file here again.  Add comment.
	(readdir_get_ino): Keep handle in created path_conv and drop
	opening file.
	* ntdll.h (wait_pending): New helper function.
	* path.cc (symlink_info::check): Drop unused 'opt' parameter from
	declaration.  Add path_conv_handle argument.
	(path_conv::check): Make sure conv_handle is closed.  Keep
	PC_KEEP_HANDLE flag in pflags_or.  Accommodate call to sym.check to
	new args.
	(path_conv::~path_conv): Close conv_handle.
	(symlink_info::check_shortcut): Don't re-open file here, just use
	incoming handle.  Drop goto's and label out.
	(symlink_info::check_sysfile): Don't re-open file here, just use
	incoming handle.  Keep track of file position to accommodate the fact
	that file has been opened asynchronously in calling function.
	(symlink_info::check_nfs_symlink): Don't re-open file here, just use
	incoming handle.
	(symlink_info::check): Drop unused 'opt' parameter.  Add
	path_conv_handle argument.  Always try to open file with GENERIC_READ
	rights first to allow reading file content w/o having to re-open the
	file.  Drop back to READ_CONTROL | FILE_READ_ATTRIBUTES otherwise.
	Call symlink test functions (except for check_reparse_point) only if
	file could be opened with GENERIC_READ.  Keep file handle open if
	PC_KEEP_HANDLE is set in pflags.
	* path.h (enum pathconv_arg): Add PC_KEEP_HANDLE flag.
	(class path_conv_handle): New class.
	(class path_conv): Add conv_handle member.
	(path_conv::operator =): Duplicate conv_handle.
	(path_conv::handle): New method.
	(path_conv::access): New method.
	(path_conv::reset_conv_handle): New method.
	(path_conv::close_conv_handle): New method.
@
text
@d297 1
a297 1
  status = NtQueryEaFile (get_handle (), &io,
d677 1
a677 1
	      NTSTATUS status;
d679 1
d681 24
a704 1
	      if (get_stat_access () & (GENERIC_READ | FILE_READ_DATA))
d719 2
@


1.327
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Fix indentation.
@
text
@d336 1
d355 1
a355 1
      status = NtQueryInformationFile (get_handle (), &io, &fi, sizeof fi,
d362 2
a363 2
    status = NtQueryInformationFile (get_handle (), &io, &fi.fbi, sizeof fi.fbi,
				     FileBasicInformation);
d370 1
a370 1
  status = NtQueryInformationFile (get_handle (), &io, &fsi, sizeof fsi,
d378 1
a378 3
  status = NtQueryInformationFile (get_handle (), &io, &fii, sizeof fii,
				   FileInternalInformation);
  if (!NT_SUCCESS (status))
d380 9
a388 3
      debug_printf ("%p = NtQueryInformationFile(%S, FileInternalInformation)",
		    status, pc.get_nt_native_path ());
      return -1;
d405 1
a405 1
		       fii.FileId.QuadPart,
d500 1
a500 1
  if (get_handle ())
d508 4
a511 1
  query_open (query_read_attributes);
d513 5
d562 1
d580 1
a580 1
  if (pc.isgood_inode (nFileIndex))
d593 3
a595 3
	   && get_handle () && !is_fs_special ()
	   && !NtQueryInformationFile (get_handle (), &st, (PVOID) &fci,
				      sizeof fci, FileCompressionInformation))
d614 1
a614 1
      get_file_attribute (get_handle (), pc, NULL,
d621 1
a621 2
  if (!get_file_attribute (is_fs_special () && !pc.issocket ()
			   ? NULL : get_handle (), pc,
d675 2
a676 1
	      OBJECT_ATTRIBUTES attr;
a677 1
	      HANDLE h;
d680 1
a680 16
	      /* The NWFS implementation is frighteningly incomplete.  When
	         re-opening a file by handle, the subsequent NtReadFile
		 returns with the weird status STATUS_FILE_IS_A_DIRECTORY.
		 We're still using the re-open by handle method for all
		 other filesystems since it's 8-10% faster than opening
		 by name. */
	      if (pc.fs_is_nwfs ())
		InitializeObjectAttributes (&attr, pc.get_nt_native_path (),
					    OBJ_CASE_INSENSITIVE, NULL, NULL)
	      else
		InitializeObjectAttributes (&attr, &ro_u_empty, 0,
					    get_handle (), NULL);
	      status = NtOpenFile (&h, SYNCHRONIZE | FILE_READ_DATA,
				   &attr, &io, FILE_SHARE_VALID_FLAGS,
				   FILE_SYNCHRONOUS_IO_NONALERT);
	      if (NT_SUCCESS (status))
d682 7
a688 6
		  LARGE_INTEGER off = { QuadPart:0LL };
		  char magic[3];

		  status = NtReadFile (h, NULL, NULL, NULL, &io, magic,
				       3, &off, NULL);
		  if (NT_SUCCESS (status))
d690 3
a692 6
		      if (has_exec_chars (magic, io.Information))
			{
			  /* Heureka, it's an executable */
			  pc.set_exec ();
			  buf->st_mode |= STD_XBITS;
			}
a693 4
		  else
		    debug_printf ("%p = NtReadFile(%S)", status,
				  pc.get_nt_native_path ());
		  NtClose (h);
a694 3
	      else
		debug_printf ("%p = NtOpenFile(%S)", status,
			      pc.get_nt_native_path ());
d732 1
a732 1
  HANDLE fh = get_handle ();
d1042 2
a1043 1
      if (!get_handle ())
d1080 1
a1080 1
	      res = getacl (get_handle (), pc, nentries, aclbufp);
d1083 1
a1083 1
	    res = getacl (get_handle (), pc, 0, NULL);
d1270 5
a1274 9
  HANDLE fh;
  NTSTATUS status;
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  status = NtOpenFile (&fh, READ_CONTROL,
		       pc.get_object_attr (attr, sec_none_nih), &io,
		       FILE_SHARE_VALID_FLAGS,
		       FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT);
  if (!NT_SUCCESS (status))
d1276 1
a1276 1
      __seterrno_from_nt_status (status);
d1285 3
a1288 1
  NtClose (fh);
a1754 2
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
d1766 1
a1766 1
  path_conv pc (path, PC_SYM_NOFOLLOW | PC_POSIX | PC_NOWARN);
d1774 1
a1774 6
  else if (NT_SUCCESS (NtOpenFile (&hdl, READ_CONTROL,
				   pc.get_object_attr (attr, sec_none_nih),
				   &io, FILE_SHARE_VALID_FLAGS,
				   FILE_OPEN_FOR_BACKUP_INTENT
				   | (pc.is_rep_symlink ()
				      ? FILE_OPEN_REPARSE_POINT : 0))))
a1778 1
      NtClose (hdl);
@


1.326
log
@	* fhandler_disk_file.cc (path_conv::get_ino_by_handle): Convert from
	static function to path_conv method.  Accommodate throughout.
	(path_conv::ndisk_links): Unused, comment out.
	* path.h (path_conv::get_ino_by_handle): Declare.
	(path_conv::ndisk_links): Comment out declaration.
@
text
@d749 3
a751 3
				     pc.get_object_attr (attr, sec_none_nih),
				     &io, FILE_SHARE_VALID_FLAGS,
				     FILE_OPEN_FOR_BACKUP_INTENT));
d759 2
a760 2
					 FILE_SHARE_VALID_FLAGS,
					 FILE_OPEN_FOR_BACKUP_INTENT));
@


1.325
log
@	* fhandler_disk_file.cc (fhandler_cygdrive::fstat): Add standard read
	permissions again.
@
text
@d181 2
a182 2
static inline __ino64_t
get_ino_by_handle (path_conv &pc, HANDLE hdl)
d189 1
a189 1
      && pc.isgood_inode (fai.FileId.QuadPart))
d194 3
d274 1
d556 3
a558 6
  /* The number of links to a directory includes the
     number of subdirectories in the directory, since all
     those subdirectories point to it.
     This is too slow on remote drives, so we do without it.
     Setting the count to 2 confuses `find (1)' command. So
     let's try it with `1' as link count. */
d1454 1
a1454 1
    ino = get_ino_by_handle (pc, get_handle ());
d1795 1
a1795 1
      ino = get_ino_by_handle (pc, hdl);
d1852 1
a1852 1
	  de->d_ino = get_ino_by_handle (pc, reph);
d2044 1
a2044 1
	    de->d_ino = get_ino_by_handle (pc, get_handle ());
d2051 1
a2051 1
		de->d_ino = get_ino_by_handle (pc, get_handle ());
d2086 1
a2086 1
		  de->d_ino = get_ino_by_handle (pc, hdl);
d2102 1
a2102 1
      de->d_ino = get_ino_by_handle (pc, get_handle ());
d2113 1
a2113 1
	de->d_ino = get_ino_by_handle (pc, get_handle ());
@


1.324
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Try to open
	directory with stat()-friendly access mask first.  Explain why.
@
text
@d2238 1
a2238 1
  buf->st_mode = S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
@


1.323
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper):  Set st_rdev
	to same value as st_dev.  Avoid useless debug output in executable
	check.  Add filename to debug output.
	(fhandler_disk_file::facl): Simplify code calling fstat methods to
	just call fstat to avoid errors with the cygdrive directory.
@
text
@d1663 12
d1676 1
a1676 8
	      status = NtOpenFile (&get_handle (),
				   SYNCHRONIZE | FILE_LIST_DIRECTORY,
				   pc.get_object_attr (attr, sec_none_nih),
				   &io, FILE_SHARE_VALID_FLAGS,
				   FILE_SYNCHRONOUS_IO_NONALERT
				   | FILE_OPEN_FOR_BACKUP_INTENT
				   | FILE_DIRECTORY_FILE);
	      if (!NT_SUCCESS (status))
d1678 18
a1695 2
		  __seterrno_from_nt_status (status);
		  goto free_mounts;
d1697 1
@


1.322
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Workaround
	another bug in NWFS.  Add comment to explain why.  Improve debug output
	in case the NT calls to test for binary fail.
	* path.h (path_conv::fs_is_cifs): New method.
	(path_conv::fs_is_nwfs): New method.
@
text
@d550 1
a550 1
  buf->st_dev = dwVolumeSerialNumber;
d688 1
a688 2
		  if (NT_SUCCESS (status)
		      && has_exec_chars (magic, io.Information))
d690 6
a695 2
		      pc.set_exec ();
		      buf->st_mode |= STD_XBITS;
d721 4
a724 3
  syscall_printf ("0 = fstat (, %p) st_atime=%x st_size=%D, st_mode=%p, st_ino=%D, sizeof=%d",
		  buf, buf->st_atime, buf->st_size, buf->st_mode,
		  buf->st_ino, sizeof (*buf));
d1024 1
a1024 7
		if (!get_handle ())
		  {
		    query_open (query_read_attributes);
		    oret = open (O_BINARY, 0);
		  }
		if ((oret && !fstat_by_handle (&st))
		    || !fstat_by_name (&st))
@


1.321
log
@	Throughout, use FileBothDirectoryInformation info class rather than
	FileDirectoryInformation info class to avoid problems with incomplete
	filesystem implementations.  Fix comments accordingly.
	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Set
	fname->Length to 0 in error case to avoid potential crash in debug
	output.
	(fhandler_disk_file::readdir): Try to speed up the working default case.
	Check for STATUS_INVALID_NETWORK_RESPONSE as potential status value
	returned by filesystems not implementing FileIdBothDirectoryInformation.
	* ntdll.h (STATUS_INVALID_NETWORK_RESPONSE): Define.
	(FILE_BOTH_DIRECTORY_INFORMATION): Rename to official name.
	* path.cc (symlink_info::check): Don't request FILE_READ_EA access, it's
	not required for NFS.  Try to speed up the working default case.  Check
	for STATUS_INVALID_NETWORK_RESPONSE as potential status value returned
	by filesystems not supporting non-NULL EA parameters.  Fix the way
	fs.update is called.  Improve debug output.
@
text
@d662 1
d666 16
a681 5
	      InitializeObjectAttributes (&attr, &ro_u_empty, 0, get_handle (),
					  NULL);
	      if (NT_SUCCESS (NtOpenFile (&h, SYNCHRONIZE | FILE_READ_DATA,
					  &attr, &io, FILE_SHARE_VALID_FLAGS,
					  FILE_SYNCHRONOUS_IO_NONALERT)))
d686 3
a688 2
		  if (NT_SUCCESS (NtReadFile (h, NULL, NULL, NULL, &io, magic,
					      3, &off, NULL))
d694 3
d699 3
@


1.320
log
@	* globals.cc (ro_u_nwfs): New R/O unicode string.
	* mount.cc (fs_info::update): Check for NWFS filesystem.  Set
	has_buggy_basic_info, if so.  Add comment to explain why.
	(fillout_mntent): Add "nwfs" string to fs_names array.
	* mount.h (enum fs_info_type): Add nwfs.
	(class fs_info): Add has_buggy_basic_info status flag.  Add accessors
	for has_buggy_basic_info and is_nwfs.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Accommodate
	filesystems with broken FileBasicInformation handling.
	* path.cc (symlink_info::check): Ditto.
	* path.h (path_conv::has_buggy_basic_info): Add method.
@
text
@d214 1
a214 1
  PFILE_DIRECTORY_INFORMATION fdibuf = (PFILE_DIRECTORY_INFORMATION)
d218 1
a218 1
					   65536, FileDirectoryInformation,
d230 1
a230 1
      for (PFILE_DIRECTORY_INFORMATION pfdi = fdibuf;
d232 1
a232 1
	   pfdi = (PFILE_DIRECTORY_INFORMATION)
d437 1
a437 1
						 FileDirectoryInformation,
d1668 1
a1668 1
	     persistent ACLs, FileDirectoryInformation otherwise.
d1773 4
a1776 1
	return geterrno_from_win_error (w32_err);
d1897 6
a1902 4
	  if (status == STATUS_INVALID_LEVEL
	      || status == STATUS_NOT_SUPPORTED
	      || status == STATUS_INVALID_PARAMETER
	      || status == STATUS_INVALID_INFO_CLASS)
d1909 6
a1914 6
	     Why should we care, we can just switch to FileDirectoryInformation,
	     isn't it?  Nope!  The next call to
	       NtQueryDirectoryFile(FileDirectoryInformation)
	     actually returns STATUS_NO_MORE_FILES, regardless how many files
	     are left unread in the directory.  This does not happen when using
	     FileDirectoryInformation right from the start, but since
d1917 1
a1917 1
	     mode using FileDirectoryInformation.  So, what we do here is
d1920 1
a1920 1
	     FileDirectoryInformation.
d1922 1
a1922 1
	     using FileDirectoryInformation further on.  This would slow
d1937 1
a1937 1
					   FileDirectoryInformation,
d1957 1
a1957 1
				       : FileDirectoryInformation,
d1990 5
a1994 3
	  FileName = ((PFILE_DIRECTORY_INFORMATION) buf)->FileName;
	  FileNameLength = ((PFILE_DIRECTORY_INFORMATION) buf)->FileNameLength;
	  FileAttributes = ((PFILE_DIRECTORY_INFORMATION) buf)->FileAttributes;
@


1.319
log
@	* fhandler.h (fhandler_base::fstat_helper): Declare timestamps as
	PLARGE_INTEGER.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle):
	Accommodate fstat_helper change of timestamp arguments.
	(fhandler_base::fstat_by_name): Ditto.
	(fhandler_base::fstat_helper): Define with timestamps as PLARGE_INTEGER.
	Accommodate in call to to_timestruc_t.
@
text
@d340 5
a344 1
  FILE_BASIC_INFORMATION fbi;
d348 11
a358 2
  status = NtQueryInformationFile (get_handle (), &io, &fbi, sizeof fbi,
				   FileBasicInformation);
d385 2
a386 2
    fbi.FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
  pc.file_attributes (fbi.FileAttributes);
d388 11
a398 11
		   fbi.ChangeTime.QuadPart ? &fbi.ChangeTime
					   : &fbi.LastWriteTime,
		   &fbi.LastAccessTime,
		   &fbi.LastWriteTime,
		   &fbi.CreationTime,
		   get_dev (),
		   fsi.EndOfFile.QuadPart,
		   fsi.AllocationSize.QuadPart,
		   fii.FileId.QuadPart,
		   fsi.NumberOfLinks,
		   fbi.FileAttributes);
@


1.318
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Fix typos in
	comments.  Always open file synchronized when reading header bytes,
	otherwise suffer stack corruption.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d375 5
a379 6
		   fbi.ChangeTime.QuadPart
		   ? *(FILETIME *) (void *) &fbi.ChangeTime
		   : *(FILETIME *) (void *) &fbi.LastWriteTime,
		   *(FILETIME *) (void *) &fbi.LastAccessTime,
		   *(FILETIME *) (void *) &fbi.LastWriteTime,
		   *(FILETIME *) (void *) &fbi.CreationTime,
d442 5
a446 6
		       fdi_buf.fdi.ChangeTime.QuadPart ?
		       *(FILETIME *) (void *) &fdi_buf.fdi.ChangeTime :
		       *(FILETIME *) (void *) &fdi_buf.fdi.LastWriteTime,
		       *(FILETIME *) (void *) &fdi_buf.fdi.LastAccessTime,
		       *(FILETIME *) (void *) &fdi_buf.fdi.LastWriteTime,
		       *(FILETIME *) (void *) &fdi_buf.fdi.CreationTime,
d459 4
a462 4
		       *(FILETIME *) (void *) &ft,
		       *(FILETIME *) (void *) &ft,
		       *(FILETIME *) (void *) &ft,
		       *(FILETIME *) (void *) &ft,
d507 1
a507 1
/* The ftChangeTime is taken from the NTFS ChangeTime entry, if reading
d519 4
a522 4
			     FILETIME ftChangeTime,
			     FILETIME ftLastAccessTime,
			     FILETIME ftLastWriteTime,
			     FILETIME ftCreationTime,
d533 4
a536 4
  to_timestruc_t (&ftLastAccessTime, &buf->st_atim);
  to_timestruc_t (&ftLastWriteTime, &buf->st_mtim);
  to_timestruc_t (&ftChangeTime, &buf->st_ctim);
  to_timestruc_t (&ftCreationTime, &buf->st_birthtim);
@


1.317
log
@	* fhandler_disk_file.cc (is_volume_mountpoint): Align check with
	symlink_info::check_reparse_point().
	* path.cc (symlink_info::check_reparse_point): Rearrange slightly.
	Add code path for unrecognized repare point types.  Add comment.
@
text
@d579 2
a580 2
  /* Using a side effect: get_file_attibutes checks for
     directory. This is used, to set S_ISVTX, if needed.  */
d646 1
a646 1
	  /* No known sufix, check file header.  This catches binaries and
d656 3
a658 2
	      if (NT_SUCCESS (NtOpenFile (&h, FILE_READ_DATA, &attr, &io,
					  FILE_SHARE_VALID_FLAGS, 0)))
@


1.316
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Drop all "other"
	permissions from st_mode, if the reading the file's security descriptor
	failed.  Explain why.
@
text
@d157 1
d170 5
a174 1
	  && rp->SymbolicLinkReparseBuffer.PrintNameLength == 0)
@


1.315
log
@	* sec_helper.cc (security_descriptor::free): If sd_size is 0, call
	LocalFree instead of ::free.

	* sec_acl.cc: Throughout replace old ACE flag definitions with current
	definitions as used in MSDN man pages.
	* security.cc: Ditto.

	* fhandler.cc (fhandler_base::open): Make sure file has really been
	just created before fixing file permissions.  Add S_JUSTCREATED
	attribute to set_file_attribute call.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Always create dir
	with default security descriptor and fix descriptor afterwards.
	Add S_JUSTCREATED flag to set_file_attribute call.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto for symlinks.
	* security.cc (get_file_sd): Call GetSecurityInfo rather than
	NtQuerySecurityObject.  Explain why.  Change error handling accordingly.
	(alloc_sd): Skip non-inherited, non-standard entries in ACL if
	S_JUSTCREATED attribute is set.  Explain why.  Minor format fixes.
	* security.h (S_JUSTCREATED): New define.
	(security_descriptor::operator=): New operator.
@
text
@d673 6
@


1.314
log
@	* smallprint.cc (hex_str): New const string.
	(__rn): Drop str and use hex_str instead.
	(__small_vsprintf): If 'l' modifier has been found, print subsequent
	multibyte or wide char string using the s, S, or W options in extended
	hex value layout.

	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Print WCHAR
	and resulting multibyte filename in extended hex value layout in
	debug output.
@
text
@a1465 8
  security_descriptor sd;

  /* See comments in fhander_base::open () for an explanation why we defer
     setting security attributes on remote files. */
  if (has_acls () && !pc.isremote ())
    set_security_attribute (pc, S_IFDIR | ((mode & 07777) & ~cygheap->umask),
			    &sa, sd);

d1500 1
a1500 1
      if (has_acls () && pc.isremote ())
d1502 2
a1503 1
			    S_IFDIR | ((mode & 07777) & ~cygheap->umask));
@


1.313
log
@	* fhandler_disk_file.cc (fhander_disk_file::readdir): Handle a status
	code STATUS_NOT_SUPPORTED.  Add matching comment.
@
text
@d2056 2
a2057 1
  syscall_printf ("%d = readdir (%p, %p) (%s)", res, dir, &de, res ? "***" : de->d_name);
@


1.312
log
@Improve clock_gettime and utimensat resolution.

* hires.h (hires_ms): Change initime_us to initime_ns, with 10x
more resolution.
(hires_ms::nsecs): New prototype.
(hires_ms::usecs, hires_ms::msecs, hires_ms::uptime): Adjust.
* times.cc (systime_ns): New helper function.
(hires_ms::prime): Use it for more resolution.
(hires_ms::usecs): Change to...
(hires_ms::nsecs): ...with more resolution.
(clock_gettime): Use more resolution.
(systime): Rewrite in terms of systime_ns.
(timespec_to_filetime): Rewrite math to reflect true operation.
* fhandler_disk_file.cc (utimens_fs): Use higher resolution.
@
text
@d1873 5
a1877 3
	     when accessing network drives on any remote OS.  We just fall
	     back to using a standard directory query in this case and note
	     this case using the dirent_get_d_ino flag. */
d1879 1
@


1.311
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Only append .lnk
	if the original device had one, too.  Add comment.

	* fhandler_socket.cc (fhandler_socket::fstat): Always return a size of
	0 on sockets.
@
text
@d1309 1
a1309 2
  gettimeofday (reinterpret_cast<struct timeval *> (&timeofday), 0);
  timeofday.tv_nsec *= 1000;
@


1.310
log
@* fhandler_disk_file.cc (utimens_fs): Plug fd leak on EINVAL.
@
text
@d1213 6
a1218 1
      if (pc.is_lnk_special ())
@


1.309
log
@Fix some POSIX-compliance bugs in link, rename, mkdir.

* syscalls.cc (link): Delete obsolete comment.  Reject directories
and missing source up front.
(rename): Use correct errno for trailing '.'.  Detect empty
strings.  Allow trailing slash to newpath iff oldpath is
directory.
* dir.cc (mkdir): Reject dangling symlink with trailing slash.
* fhandler_disk_file.cc (fhandler_disk_file::link): Reject
trailing slash.
* fhandler.cc (fhandler_base::link): Match Linux errno.
@
text
@d1313 2
@


1.308
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Drop faking hardlink
	creation on filesystems not supporting hardlinks.
@
text
@d1189 2
a1190 1
  path_conv newpc (newpath, PC_SYM_NOFOLLOW | PC_POSIX, stat_suffixes);
d1204 7
a1210 1
  char new_buf[strlen (newpath) + 5];
@


1.307
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Fix length
	check for ".." dir.
@
text
@d1252 3
a1254 11
	  /* FS doesn't support hard links.  Try to copy file. */
	  WCHAR pcw[(pc.get_nt_native_path ()->Length / sizeof (WCHAR)) + 1];
	  WCHAR newpcw[(newpc.get_nt_native_path ()->Length / sizeof (WCHAR))
		       + 1];
	  if (!CopyFileW (pc.get_wide_win32_path (pcw),
			  newpc.get_wide_win32_path (newpcw), TRUE))
	    {
	      __seterrno ();
	      return -1;
	    }
	  SetFileAttributesW (newpcw, pc.file_attributes ());
@


1.306
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Change comment
	to be fair.
@
text
@d1974 1
a1974 1
	  else if (FileNameLength == sizeof (WCHAR)
@


1.305
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Remove
	ill-advised attempt to optimize "." and ".." handling by checking for
	specific position in directory listing.  Explain why.
	(fhandler_disk_file.cc (fhandler_disk_file::readdir): Ditto.
	Special-case opening file on NFS to fetch inode number and add longish
	comment to explain why.
@
text
@d1997 1
a1997 1
		 in a timeout of about 20 seconds, followed by two exceptions
@


1.304
log
@* fhandler.h (fhandler_cygdrive:DRVSZ): New enum.
(pdrive_buf): New place to hold information about cygdrive.
* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Store drive info in
pdrive_buf since get_win32_name() could now be too small to hold everything.
(fhandler_cygdrive::rewinddir): Reset pdrive to pdrive_buf.
(fhandler_cygdrive::closedir): Ditto.
* pipe.cc (fhandler_pipe::init): Be more defensive when referencing
get_win32_name().  Rework logic which made a copy of the POSIX path and then
never used it.
@
text
@d1831 10
a1840 4
  if (dir->__d_position == 0 && !strcmp (de->d_name, "."))
    dir->__flags |= dirent_saw_dot;
  else if (dir->__d_position == 1 && !strcmp (de->d_name, ".."))
    dir->__flags |= dirent_saw_dot_dot;
d1969 4
a1972 4
	  OBJECT_ATTRIBUTES attr;

	  if (dir->__d_position == 0 && FileNameLength == 2
	      && FileName[0] == '.')
d1974 1
a1974 1
	  else if (dir->__d_position == 1 && FileNameLength == 4
d1976 6
a1981 4
	    if (!(dir->__flags & dirent_isroot))
	      de->d_ino = readdir_get_ino (get_name (), true);
	    else
	      de->d_ino = get_ino_by_handle (pc, get_handle ());
d1984 1
d1986 1
d1991 23
a2013 4
	      if (NT_SUCCESS (NtOpenFile (&hdl, READ_CONTROL, &attr, &io,
					  FILE_SHARE_VALID_FLAGS,
					  FILE_OPEN_FOR_BACKUP_INTENT
					  | FILE_OPEN_REPARSE_POINT)))
@


1.303
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Add special case
	for MVFS.  Explain why.
	(fhandler_disk_file::utimens): Drop local variables lastaccess and
	lastwrite.  Copy timestamps right into FILE_BASIC_INFORMATION structure
	to avoid copying them twice.
@
text
@a2125 1
#define DRVSZ sizeof ("x:\\")
d2129 2
a2130 4
  const int len = 2 + 26 * DRVSZ;
  char *p = const_cast<char *> (get_win32_name ());
  pdrive = p;
  ndrives = GetLogicalDriveStrings (len, p) / DRVSZ;
d2146 1
a2146 1
      --n;
d2198 1
a2198 1
  pdrive = get_win32_name ();
d2205 1
a2205 1
  pdrive = get_win32_name ();
@


1.302
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Remove file
	attribute check already done in NtSetAttributesFile.
@
text
@d849 19
a1281 1
  LARGE_INTEGER lastaccess, lastwrite;
a1319 3
  /* UTIME_OMIT is handled in timespec_to_filetime by setting FILETIME to 0. */
  timespec_to_filetime (&tmp[0], (FILETIME *) &lastaccess);
  timespec_to_filetime (&tmp[1], (FILETIME *) &lastwrite);
d1324 1
d1326 3
a1328 2
  fbi.LastAccessTime = lastaccess;
  fbi.LastWriteTime = lastwrite;
d1333 17
@


1.301
log
@	Throughout avoid having to initialize constant UNICODE_STRINGs.
	* globals.cc: Define constant UNICODE_STRINGs and store in .rdata
	section.
	* fhandler_disk_file.cc: Throughout, use readonly UNICODE_STRINGs
	rather then initializing local UNICODE_STRING variable where
	applicable.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* flock.cc (inode_t::inode_t): Ditto.
	* mmap.cc: Ditto.
	* syscalls.cc: Ditto.
	* mount.cc (fs_info::update): Ditto.
	* path.cc: Ditto.

	* ntdll.h (RtlEqualUnicodePathPrefix): Redefine to take prefix as
	UNICODE_STRING.
	(RtlEqualUnicodePathSuffix): Redefine to take suffix as UNICODE_STRING.
	* fhandler_disk_file.cc: Accommodate throughout.
	* mount.cc (fs_info::update): Ditto.
	* path.cc (cwdstuff::set): Ditto.
	* syscalls.cc: Ditto.
@
text
@d848 1
a848 2
  status = NtSetAttributesFile (get_handle (), pc.file_attributes ()
					       ?: FILE_ATTRIBUTE_NORMAL);
@


1.300
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Don't use
	FileAllInformation info class since it needs a big buffer.  Add a
	comment.
@
text
@d82 1
a82 4
	  UNICODE_STRING proc;

	  RtlInitUnicodeString (&proc, L"proc");
	  if (RtlEqualUnicodeString (fname, &proc, FALSE))
d636 3
a638 3
	      if (RtlEqualUnicodePathSuffix (path, L".exe", TRUE)
		  || RtlEqualUnicodePathSuffix (path, L".bat", TRUE)
		  || RtlEqualUnicodePathSuffix (path, L".com", TRUE))
a644 1
	      UNICODE_STRING same;
d649 2
a650 2
	      RtlInitUnicodeString (&same, L"");
	      InitializeObjectAttributes (&attr, &same, 0, get_handle (), NULL);
d1198 1
a1198 1
					     L".exe", TRUE)
d1200 1
a1200 1
					      L".exe", TRUE))
a1764 1
      UNICODE_STRING lname;
d1770 1
a1770 2
      RtlInitUnicodeString (&lname, (PWCHAR) L".lnk");
      if (RtlEqualUnicodeString (&uname, &lname, TRUE))
a2014 1
      UNICODE_STRING fname;
d2020 1
a2020 2
      RtlInitUnicodeString (&fname, L"");
      InitializeObjectAttributes (&attr, &fname, pc.objcaseinsensitive (),
@


1.299
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchown): Catch an
	error when changing the user account on a standalone Samba server.
	Explain why.
	* sec_acl.cc (setacl): Accommodate additional parameter to set_file_sd.
	* sec_helper.cc (SECURITY_SAMBA_UNIX_AUTHORITY): Define.
	(well_known_samba_unix_user_fake_sid): Define.
	* security.cc (set_file_sd): Take additional parameter if ownership
	should be changed.  Restrict requested permissions accordingly.
	(set_file_attribute): Accommodate additional parameter to set_file_sd.
	* security.h (well_known_samba_unix_user_fake_sid): Declare.
	(set_file_sd): Align declaration to above change.
@
text
@d334 7
a340 4
  struct {
    FILE_ALL_INFORMATION fai;
    WCHAR buf[NAME_MAX + 1];
  } fai_buf;
d342 18
a359 2
  status = NtQueryInformationFile (get_handle (), &io, &fai_buf.fai,
				   sizeof fai_buf, FileAllInformation);
d362 1
a362 1
      debug_printf ("%p = NtQueryInformationFile(%S)",
d370 2
a371 2
    fai_buf.fai.BasicInformation.FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
  pc.file_attributes (fai_buf.fai.BasicInformation.FileAttributes);
d373 6
a378 6
		   fai_buf.fai.BasicInformation.ChangeTime.QuadPart
		   ? *(FILETIME *) (void *) &fai_buf.fai.BasicInformation.ChangeTime
		   : *(FILETIME *) (void *) &fai_buf.fai.BasicInformation.LastWriteTime,
		   *(FILETIME *) (void *) &fai_buf.fai.BasicInformation.LastAccessTime,
		   *(FILETIME *) (void *) &fai_buf.fai.BasicInformation.LastWriteTime,
		   *(FILETIME *) (void *) &fai_buf.fai.BasicInformation.CreationTime,
d380 5
a384 5
		   fai_buf.fai.StandardInformation.EndOfFile.QuadPart,
		   fai_buf.fai.StandardInformation.AllocationSize.QuadPart,
		   fai_buf.fai.InternalInformation.FileId.QuadPart,
		   fai_buf.fai.StandardInformation.NumberOfLinks,
		   fai_buf.fai.BasicInformation.FileAttributes);
@


1.298
log
@	* fhandler_disk_file.cc (path_conv::isgood_inode): Move to be defined
	earlier.
	(get_ino_by_handle): Take additional path_conv argument, accommodate
	throughout.  Only use FileId if isgood_inode check is true.
	(fhandler_base::open_fs): Simplify setting ino due to above change.
	(readdir_get_ino): Make sure to return always a non-zero inode number.
	(fhandler_disk_file::readdir): Always open file in dir with
	FILE_OPEN_REPARSE_POINT so as not to open wrong file.
	Drop call to isgood_inode here.
	* path.cc (symlink_info::check): Call fs.update in case we're fetching
	file information from call to NtQueryDirectoryFile.
@
text
@d27 1
d874 2
a875 1
  int res = get_file_attribute (get_handle (), pc, &attrib, NULL, NULL);
d888 23
@


1.297
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Fix inode number
	evaluation for faked "." entry.

	* mount.cc (fs_info::update): Move setting of is_cdrom after checking
	for caseinsensitivity.  Recognize UDF in is_cdrom case and set
	caseinsensitive flag according to UDF brokenness determined by OS.
	Add comment to explain why.
	* mount.h (class fs_info): Add is_udf status flag.
	* path.cc (symlink_info::check): Add workaround for UDF bug in
	terms of casesensitivity on certain OSes.
	* wincap.h (wincaps::has_broken_udf): New element.
	(wincaps::has_broken_udf): New element
@
text
@d142 11
d179 1
a179 1
get_ino_by_handle (HANDLE hdl)
d185 2
a186 1
					  FileInternalInformation)))
a268 11
inline bool
path_conv::isgood_inode (__ino64_t ino) const
{
  /* We can't trust remote inode numbers of only 32 bit.  That means,
     all remote inode numbers when running under NT4, as well as remote NT4
     NTFS, as well as shares of Samba version < 3.0.
     The known exception are SFU NFS shares, which return the valid 32 bit
     inode number from the remote file system unchanged. */
  return hasgood_inode () && (ino > UINT32_MAX || !isremote () || fs_is_nfs ());
}

d1335 1
a1335 2
    if (pc.hasgood_inode ())
      ino = get_ino_by_handle (get_handle ());
d1661 3
a1663 1
      ino = get_ino_by_handle (hdl);
d1715 1
a1715 1
	  de->d_ino = get_ino_by_handle (reph);
d1896 1
a1896 1
	    de->d_ino = get_ino_by_handle (get_handle ());
d1902 1
a1902 1
	      de->d_ino = get_ino_by_handle (get_handle ());
d1912 2
a1913 1
					  FILE_OPEN_FOR_BACKUP_INTENT)))
d1915 1
a1915 1
		  de->d_ino = get_ino_by_handle (hdl);
d1919 3
a1921 6
	  /* Enforce namehash as inode number on untrusted file systems. */
	  if (!pc.isgood_inode (de->d_ino))
	    {
	      dir->__flags &= ~dirent_set_d_ino;
	      de->d_ino = 0;
	    }
d1931 1
a1931 2
      if (pc.isgood_inode (de->d_ino))
	de->d_ino = get_ino_by_handle (get_handle ());
d1942 1
a1942 1
	de->d_ino = get_ino_by_handle (get_handle ());
@


1.296
log
@	* Fix copyright dates.
@
text
@d1931 2
a1932 1
      de->d_ino = get_ino_by_handle (get_handle ());
@


1.295
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Only add .exe if
	original file has .exe as well.
	* path.cc (path_conv::is_binary): Only recognize Windows 32 and 64 bit
	apps as binaries.
@
text
@d4 1
a4 1
   2005, 2006, 2007, 2008 Red Hat, Inc.
@


1.294
log
@	* fhandler_disk_file.cc: Set 4th parameter of NtQueryDirectoryFile to
	NULL throughout.
	(fhandler_disk_file::facl): Fix a condition so that fstat_by_handle
	is actually used.
	(fhandler_disk_file::readdir): Don't print debug message on a simple
	STATUS_NO_MORE_FILES status code.
@
text
@d1156 2
@


1.293
log
@* fhandler_disk_file.cc (readdir_get_ino): Don't complain about MS-DOS paths
since the function could be fed one by an internal call.
@
text
@d202 1
a202 1
  while (NT_SUCCESS (NtQueryDirectoryFile (fh, NULL, NULL, 0, &io, fdibuf,
d394 1
a394 1
      && NT_SUCCESS (status = NtQueryDirectoryFile (dir, NULL, NULL, 0, &io,
d399 3
a401 2
  else if (NT_SUCCESS (status = NtQueryDirectoryFile (dir, NULL, NULL, 0, &io,
						 &fdi_buf.fdi, sizeof fdi_buf,
d924 1
a924 1
		if ((!oret && !fstat_by_handle (&st))
d1781 1
a1781 1
	  status = NtQueryDirectoryFile (get_handle (), NULL, NULL, 0, &io,
d1825 2
a1826 1
					   0, &io, d_cache (dir), DIR_BUF_SIZE,
d1843 1
a1843 1
	status = NtQueryDirectoryFile (get_handle (), NULL, NULL, 0, &io,
d1853 3
a1855 1
  if (!NT_SUCCESS (status))
@


1.292
log
@	* dir.cc (readdir_worker): Initialize dirent.d_type and __d_unused1.
	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper):
	Set dirent.d_type based on FILE_ATTRIBUTE_*.
	* include/sys/dirent.h: Define _DIRENT_HAVE_D_TYPE (enables DT_*
	declarations).
	(struct dirent): Add d_type. Adjust __d_unused1 size to preserve layout.
@
text
@d1643 1
a1643 1
  path_conv pc (path, PC_SYM_NOFOLLOW | PC_POSIX);
@


1.291
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d1680 14
d1745 4
a1748 1
	    fname->Length -= 4 * sizeof (WCHAR);
@


1.290
log
@	* ntdll.h (NtSetAttributesFile): New inline function.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Use
	NtSetAttributesFile.
	* path.cc (symlink_worker): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
	(rename): Omit FILE_SHARE_DELETE when opening files on Samba.  Add
	comment to explain why.
@
text
@d788 1
a788 1
         Only type and mode have to be set.  Apparently type isn't checked
d809 1
a809 1
 	res = 0;
d1574 1
a1574 1
	     unless you use the FileNamesInformation info class.  
d1585 1
a1585 1
	      	dir->__flags |= dirent_nfs_d_ino;
d1717 1
a1717 1
	  
d1856 1
a1856 1
      	}
@


1.289
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Check
	for executable suffixes here in case we're on a file system
	not supporting permission.
	* path.cc (path_conv::check): Drop check for executable suffixes.
@
text
@d830 2
a831 6
  FILE_BASIC_INFORMATION fbi;
  fbi.CreationTime.QuadPart = fbi.LastAccessTime.QuadPart
  = fbi.LastWriteTime.QuadPart = fbi.ChangeTime.QuadPart = 0LL;
  fbi.FileAttributes = pc.file_attributes () ?: FILE_ATTRIBUTE_NORMAL;
  status = NtSetInformationFile (get_handle (), &io, &fbi, sizeof fbi,
				 FileBasicInformation);
@


1.288
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d612 12
@


1.287
log
@	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Drop fattr variable
	and use FILE_ATTRIBUTE_DIRECTORY directly in call to NtCreateFile.
	* posix_ipc.cc (ipc_mutex_init): Fix format string when creating IPC
	object name.
	(ipc_cond_init): Ditto.
	* security.cc (alloc_sd): Add parentheses to fix setting initial
	owner_allow value.
@
text
@d353 5
a357 5
		   ? *(FILETIME *) &fai_buf.fai.BasicInformation.ChangeTime
		   : *(FILETIME *) &fai_buf.fai.BasicInformation.LastWriteTime,
		   *(FILETIME *) &fai_buf.fai.BasicInformation.LastAccessTime,
		   *(FILETIME *) &fai_buf.fai.BasicInformation.LastWriteTime,
		   *(FILETIME *) &fai_buf.fai.BasicInformation.CreationTime,
d420 5
a424 5
		       *(FILETIME *) &fdi_buf.fdi.ChangeTime :
		       *(FILETIME *) &fdi_buf.fdi.LastWriteTime,
		       *(FILETIME *) &fdi_buf.fdi.LastAccessTime,
		       *(FILETIME *) &fdi_buf.fdi.LastWriteTime,
		       *(FILETIME *) &fdi_buf.fdi.CreationTime,
d437 4
a440 4
		       *(FILETIME *) &ft,
		       *(FILETIME *) &ft,
		       *(FILETIME *) &ft,
		       *(FILETIME *) &ft,
@


1.286
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Fix linking
	against symlinks.
@
text
@a1388 1
  ULONG fattr = FILE_ATTRIBUTE_DIRECTORY;
d1412 2
a1413 1
			 fattr, FILE_SHARE_VALID_FLAGS, FILE_CREATE,
@


1.285
log
@	* external.cc (cygwin_internal): Call set_security_attribute with
	additional path_conv argument.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Never set DOS
	R/O attribute when using ACLs.
	(fhandler_disk_file::mkdir): Ditto.  Set
	security descriptor on remote dirs after creating the dir, same as in
	fhandler_base::open.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto for remote AF_LOCAL
	socket files.
	* path.cc (symlink_worker): Ditto. for remote symlinks.
	* security.cc (alloc_sd): Take additional path_conv argument.
	Accommodate throughout.  Drop setting FILE_WRITE_EA/FILE_READ_EA
	flags unconditionally (was only necessary for "ntea"). Don't set
	FILE_READ_ATTRIBUTES and FILE_WRITE_ATTRIBUTES unconditionally on
	Samba.  Add comment to explain.  Drop useless setting of
	STANDARD_RIGHTS_WRITE, it's in FILE_GENERIC_WRITE anyway.
	Remove FILE_READ_ATTRIBUTES bit from FILE_GENERIC_EXECUTE so as not
	to enforce read permissions on Samba.
	(set_security_attribute): Take additional path_conv argument.
	* security.h (set_security_attribute): Change prototype accordingly.
@
text
@a1120 2
  extern bool allow_winsymlinks;

d1138 1
a1138 1
      if (allow_winsymlinks && pc.is_lnk_special ())
d1183 3
a1185 2
	  WCHAR pcw[pc.get_nt_native_path ()->Length + 1];
	  WCHAR newpcw[newpc.get_nt_native_path ()->Length + 1];
d1192 1
a1192 4
	  if (!allow_winsymlinks && pc.is_lnk_special ())
	    SetFileAttributesW (newpcw, pc.file_attributes ()
					| FILE_ATTRIBUTE_SYSTEM
					| FILE_ATTRIBUTE_READONLY);
@


1.284
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_name): Check for
	file systems incapable of handling FileIdBothDirectoryInformation
	correctly.
	(fhandler_disk_file::opendir): Ditto.
	* path.cc (fs_info::update): Always clear at the start.
	Rearrange to make certain tests only on non-Samba, non-NFS remote
	drives.
	Add test for file systems known to be incapable of handling
	FileIdBothDirectoryInformation correctly.  Right now that's just
	"UNIXFS".
	* path.h (struct fs_info): Add has_buggy_fileid_dirinfo flag and
	accessor methods.
	(class path_conv): Add has_buggy_fileid_dirinfo method.
@
text
@d810 1
a810 1
  /* if the mode we want has any write bits set, we can't be read only. */
d813 1
a813 1
  else
d1383 4
a1386 2
  if (has_acls ())
    set_security_attribute (S_IFDIR | ((mode & 07777) & ~cygheap->umask),
d1423 3
@


1.283
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@d393 1
a393 1
  if (wincap.has_fileid_dirinfo ()
d1577 2
a1578 1
	      else if (wincap.has_fileid_dirinfo ())
@


1.282
log
@	Throughout drop allow_ntsec and allow_smbntsec handling.
	* environ.cc (set_ntsec): Remove.
	(set_smbntsec): Remove.
	(known): Remove ntsec and smbntsec options.
	* external.cc (check_ntsec): Return true if no filename is given.
	* mount.cc (oopts): Add "acl" and "noacl" options.  Set MOUNT_NOACL
	flag accordingly.
	(fillout_mntent): Handle MOUNT_NOACL flag.
	* path.h (enum path_types): Add PATH_NOACL.
	* security.cc (allow_ntsec): Remove.
	(allow_smbntsec): Remove.
	* security.h (allow_ntsec): Drop declaration.
	(allow_smbntsec): Drop declaration.
	* include/sys/mount.h (MOUNT_NOACL): Define.
@
text
@d84 1
a84 1
	  if (RtlEqualUnicodeString (fname, &proc, TRUE))
d90 1
a90 1
	      && RtlEqualUnicodeString (fname, &cygdrive, TRUE))
d97 1
a97 1
	if (RtlEqualUnicodeString (fname, &mounts[i], TRUE))
d236 1
a236 1
					    OBJ_CASE_INSENSITIVE, fh, NULL);
d382 1
a382 1
  InitializeObjectAttributes (&attr, &dirname, OBJ_CASE_INSENSITIVE,
d1126 1
a1126 1
      set_errno (newpc.case_clash ? ECASECLASH : newpc.error);
d1138 1
a1138 1
  if (!newpc.error && !newpc.case_clash)
a1300 7
  if (pc.case_clash && flags & O_CREAT)
    {
      debug_printf ("case clash detected");
      set_errno (ECASECLASH);
      return 0;
    }

d1679 1
a1679 1
      InitializeObjectAttributes (&attr, fname, OBJ_CASE_INSENSITIVE,
d1725 2
a1726 12
#if 0
  if (pc.isencoded ())
    {
      char tmp[NAME_MAX + 1];
      sys_wcstombs (tmp, NAME_MAX + 1, fname->Buffer,
		    fname->Length / sizeof (WCHAR));
      fnunmunge (de->d_name, tmp);
    }
  else
#endif
    sys_wcstombs (de->d_name, NAME_MAX + 1, fname->Buffer,
		  fname->Length / sizeof (WCHAR));
d1872 2
a1873 1
	      InitializeObjectAttributes (&attr, &fname, OBJ_CASE_INSENSITIVE,
d1951 1
a1951 1
      InitializeObjectAttributes (&attr, &fname, OBJ_CASE_INSENSITIVE,
@


1.281
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Don't try to
	use FileIdBothDirectoryInformation on NFS shares.  Fix comment to
	explain why.
	* path.cc (symlink_info::check): Reinstantiate no_ea.  Use in
	erroneously changed condition.
@
text
@d764 1
a764 1
	  if (allow_ntsec && pc.has_acls ())
d801 1
a801 1
  if (allow_ntsec && pc.has_acls ())
d806 1
a806 2
			       ILLEGAL_UID, ILLEGAL_GID, mode)
	  && allow_ntsec)
d825 1
a825 1
  if (!allow_ntsec || !pc.has_acls ())
d845 1
a845 1
  if (!pc.has_acls () || !allow_ntsec)
d889 1
a889 1
  if (!pc.has_acls () || !allow_ntsec)
d1390 1
a1390 1
  if (allow_ntsec && has_acls ())
@


1.280
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Eliminate
	compiler warning.
@
text
@d1572 8
a1579 6
	     On older NFS clients (up to SFU 3.5), dangling symlinks
	     are hidden from directory queries, unless you use the
	     FileNamesInformation info class.  Nevertheless, we try
	     FileIdBothDirectoryInformation first.  On newer NFS clients
	     it works fine, on the older ones it returns "invalid info
	     class".  So we can stick to the above explained mechanism. */
a1582 2
	      if (wincap.has_fileid_dirinfo ())
		dir->__flags |= dirent_get_d_ino;
d1585 2
@


1.279
log
@	* fhandler_disk_file.cc (get_ino_by_handle): Rename pfai to fai.
	(fhandler_base::fstat_by_handle): Drop fai_size and pfai in favor of
	static struct fai_buf.  Restructure.
	(fhandler_base::fstat_by_name): Drop fvi_size and pfvi.  Drop fdi_size
	and pfdi in favor of static struct fdi_buf.  Drop redundant test for
	existance.  Use FileDirectoryInformation class instead of
	FileBothDirectoryInformation.  Drop call to NtQueryVolumeInformationFile
	in favor of using pc.fs_serial_number ().  Fix FileId information given
	to fstat_helper.
	(fhandler_disk_file::fstatvfs): Drop fvi_size, pfvi, fai_size and pfai.
	Drop getting FileFsVolumeInformation and FileFsAttributeInformation in
	favor of using the related path_conv info.
	(fhandler_disk_file::opendir): Fix comment.
	(fhandler_disk_file::readdir): Ditto.  Use FileDirectoryInformation
	class instead of FileBothDirectoryInformation.
	* path.cc (fs_info::update): Store MaximumComponentNameLength in new
	member name_len.
	* path.h (struct fs_info): Use ULONG rather than DWORD.  Add member
	name_len to store MaximumComponentNameLength.  Add accessor methods.
	(path_conv::fs_name_len): New method.
@
text
@d1759 1
a1759 1
  ULONG FileAttributes;
a1861 1
	  FileAttributes = 0;
@


1.278
log
@	* fhandler.h (dirent_states): Add dirent_nfs_d_ino state and add it to
	dirent_info_mask.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set
	dirent_nfs_d_ino flag for NFS shares.  Explain why.
	(fhandler_disk_file::readdir): Use FileNamesInformation instead of
	FileBothDirectoryInformation info class on NFS clients not supporting
	the FileIdBothDirectoryInformation info class.  Use local pointers to
	accommodate different offsets.
	* path.cc (symlink_info::check): Don't test directories for symlinks
	on NFS shares.  Enhance comment.
@
text
@d171 1
a171 1
  FILE_INTERNAL_INFORMATION pfai;
d173 1
a173 1
  if (NT_SUCCESS (NtQueryInformationFile (hdl, &io, &pfai, sizeof pfai,
d175 1
a175 1
    return pfai.FileId.QuadPart;
d332 4
a335 4
  /* The entries potentially contain a name of MAX_PATH wide characters. */
  const DWORD fai_size = (NAME_MAX + 1) * sizeof (WCHAR)
			 + sizeof (FILE_ALL_INFORMATION);
  PFILE_ALL_INFORMATION pfai = (PFILE_ALL_INFORMATION) alloca (fai_size);
d337 3
a339 3
  status = NtQueryInformationFile (get_handle (), &io, pfai, fai_size,
				   FileAllInformation);
  if (NT_SUCCESS (status))
d341 3
a343 19
      /* If the change time is 0, it's a file system which doesn't
	 support a change timestamp.  In that case use the LastWriteTime
	 entry, as in other calls to fstat_helper. */
      if (pc.is_rep_symlink ())
	pfai->BasicInformation.FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
      pc.file_attributes (pfai->BasicInformation.FileAttributes);
      return fstat_helper (buf,
		       pfai->BasicInformation.ChangeTime.QuadPart
		       ? *(FILETIME *) &pfai->BasicInformation.ChangeTime
		       : *(FILETIME *) &pfai->BasicInformation.LastWriteTime,
		       *(FILETIME *) &pfai->BasicInformation.LastAccessTime,
		       *(FILETIME *) &pfai->BasicInformation.LastWriteTime,
		       *(FILETIME *) &pfai->BasicInformation.CreationTime,
		       get_dev (),
		       pfai->StandardInformation.EndOfFile.QuadPart,
		       pfai->StandardInformation.AllocationSize.QuadPart,
		       pfai->InternalInformation.FileId.QuadPart,
		       pfai->StandardInformation.NumberOfLinks,
		       pfai->BasicInformation.FileAttributes);
d345 19
a363 3
  debug_printf ("%p = NtQueryInformationFile(%S)",
		status, pc.get_nt_native_path ());
  return -1;
d375 4
a378 8
  const DWORD fdi_size = (NAME_MAX + 1) * sizeof (WCHAR)
			 + sizeof (FILE_ID_BOTH_DIR_INFORMATION);
  const DWORD fvi_size = (NAME_MAX + 1) * sizeof (WCHAR)
			 + sizeof (FILE_FS_VOLUME_INFORMATION);
  PFILE_ID_BOTH_DIR_INFORMATION pfdi = (PFILE_ID_BOTH_DIR_INFORMATION)
				       alloca (fdi_size);
  PFILE_FS_VOLUME_INFORMATION pfvi = (PFILE_FS_VOLUME_INFORMATION)
				     alloca (fvi_size);
a380 6
  if (!pc.exists ())
    {
      debug_printf ("already determined that pc does not exist");
      set_errno (ENOENT);
      return -1;
    }
d395 1
a395 1
						 pfdi, fdi_size,
d398 1
a398 1
    FileId = pfdi->FileId;
d400 2
a401 2
						 pfdi, fdi_size,
						 FileBothDirectoryInformation,
a410 8
  status = NtQueryVolumeInformationFile (dir, &io, pfvi, fvi_size,
					 FileFsVolumeInformation);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("%p = NtQueryVolumeInformationFile(%S)",
		    status, pc.get_nt_native_path ());
      pfvi->VolumeSerialNumber = 0;
    }
d416 2
a417 2
    pfdi->FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
  pc.file_attributes (pfdi->FileAttributes);
d419 10
a428 10
		       pfdi->ChangeTime.QuadPart ?
		       *(FILETIME *) &pfdi->ChangeTime :
		       *(FILETIME *) &pfdi->LastWriteTime,
		       *(FILETIME *) &pfdi->LastAccessTime,
		       *(FILETIME *) &pfdi->LastWriteTime,
		       *(FILETIME *) &pfdi->CreationTime,
		       pfvi->VolumeSerialNumber,
		       pfdi->EndOfFile.QuadPart,
		       pfdi->AllocationSize.QuadPart,
		       pfdi->FileId.QuadPart,
d430 1
a430 1
		       pfdi->FileAttributes);
a663 8
  const size_t fvi_size = sizeof (FILE_FS_VOLUME_INFORMATION)
			  + (NAME_MAX + 1) * sizeof (WCHAR);
  PFILE_FS_VOLUME_INFORMATION pfvi = (PFILE_FS_VOLUME_INFORMATION)
				     alloca (fvi_size);
  const size_t fai_size = sizeof (FILE_FS_ATTRIBUTE_INFORMATION)
			  + (NAME_MAX + 1) * sizeof (WCHAR);
  PFILE_FS_ATTRIBUTE_INFORMATION pfai = (PFILE_FS_ATTRIBUTE_INFORMATION)
					alloca (fai_size);
a688 15
  /* Get basic volume information. */
  status = NtQueryVolumeInformationFile (fh, &io, pfvi, fvi_size,
					 FileFsVolumeInformation);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      goto out;
    }
  status = NtQueryVolumeInformationFile (fh, &io, pfai, fai_size,
					 FileFsAttributeInformation);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      goto out;
    }
d692 3
a694 3
  sfs->f_fsid = pfvi->VolumeSerialNumber;
  sfs->f_flag = pfai->FileSystemAttributes;
  sfs->f_namemax = pfai->MaximumComponentNameLength;
d1570 1
a1570 1
	     persistent ACLs, FileBothDirectoryInformation otherwise.
d1787 6
a1792 6
	     Why should we care, we can just switch to
	     FileBothDirectoryInformation, isn't it?  Nope!  The next call to
	     NtQueryDirectoryFile(FileBothDirectoryInformation) actually
	     returns STATUS_NO_MORE_FILES, regardless how many files are left
	     unread in the directory.  This does not happen when using
	     FileBothDirectoryInformation right from the start, but since
d1795 1
a1795 1
	     mode using FileBothDirectoryInformation.  So, what we do here is
d1798 1
a1798 1
	     FileBothDirectoryInformation.
d1800 1
a1800 1
	     using FileBothDirectoryInformation further on.  This would slow
d1814 1
a1814 1
					   FileBothDirectoryInformation,
d1834 1
a1834 1
				       : FileBothDirectoryInformation,
d1866 3
a1868 3
	  FileName = ((PFILE_BOTH_DIR_INFORMATION) buf)->FileName;
	  FileNameLength = ((PFILE_BOTH_DIR_INFORMATION) buf)->FileNameLength;
	  FileAttributes = ((PFILE_BOTH_DIR_INFORMATION) buf)->FileAttributes;
@


1.277
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Fix test for
	S_IFSOCK in mode bits.
@
text
@d1611 8
a1618 1
	     persistent ACLs, FileBothDirectoryInformation otherwise. */
d1624 2
d1799 2
d1873 3
a1875 1
				       FileBothDirectoryInformation,
d1894 2
d1899 6
d1906 6
a1911 2
	FileName = ((PFILE_BOTH_DIR_INFORMATION) buf)->FileName;
      RtlInitCountedUnicodeString (&fname, FileName, buf->FileNameLength);
d1917 1
a1917 1
	  if (dir->__d_position == 0 && buf->FileNameLength == 2
d1920 1
a1920 1
	  else if (dir->__d_position == 1 && buf->FileNameLength == 4
d1950 1
a1950 1
			      buf ? buf->FileAttributes : 0, &fname)))
@


1.276
log
@	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Create directories
	on NFS shares with correct mode bits.
@
text
@d857 1
a857 1
  if (mode & S_IFSOCK)
@


1.275
log
@	* Makefile.in (DLL_OFILES): Add nfs.o.
	* fhandler.cc (fhandler_base::open): Open files on NFS shares with
	correct access flags and EAs.
	* fhandler.h (fhandler_base::fstat_by_nfs_ea): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): New method.
	(fhandler_base::fstat_by_handle): Call fstat_by_nfs_ea for files on
	NFS shares.
	(fhandler_disk_file::fchmod): Use NFS specific method to set mode for
	files on NFS shares.  Don't overrule errno from call to
	set_file_attribute with errno from NtSetInformationFile call.
	(fhandler_disk_file::fchown): Add comment.
	* mount.cc (fillout_mntent): Accommodate change in second parameter
	to fs_info::update.
	* nfs.cc: New file.
	* nfs.h: New file.
	* path.cc (fs_info::update): Take handle instead of bool as second
	parameter.  Use that handle if it's not NULL.  Only close handle if
	it has been opened here.  Use static defined buffers instead of
	alloca'd buffers.
	(path_conv::check): Call symlink_info::check with reference to fs.
	Don't call fs.update here if file exists.
	(conv_path_list): Prefer tmp_pathbuf buffer over using alloca.
	(symlink_worker): Use NFS specific method to create symlinks on NFS
	shares.  Prefer tmp_pathbuf buffer over using alloca.
	(symlink_info::check_shortcut): Reopen file from incoming handle
	with necessary FILE_GENERIC_READ flag.  Prefer tmp_pathbuf buffer over
	using alloca.
	(symlink_info::check_sysfile): Ditto.
	(symlink_info::check_reparse_point): Use tmp_pathbuf buffer to
	allocate REPARSE_DATA_BUFFER.
	(symlink_info::check_nfs_symlink): New method.
	(enum symlink_t): Remove.
	(symlink_info::check): Don't use NtQueryAttributesFile.  Rather, open
	file with necessary access flags and call NtQueryInformationFile.  Fix
	error handling in case file can't be opened.  For existing files, call
	fs_info::update here.  Restructure symlink checking to accommodate the
	fact that the file is already open.  Add case for NFS symlinks.
	* path.h (fs_info::update): Take handle instead of bool as second
	parameter.
@
text
@d1441 21
d1467 1
a1467 1
			 NULL, 0);
@


1.274
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Drop
	explicit transformation of special DOS chars.
	* strfuncs.cc (sys_wcstombs): Always transform UNICODE private use area
	back to ASCII.
@
text
@d26 1
d268 55
d328 4
d793 2
d814 28
a859 1
  IO_STATUS_BLOCK io;
d864 10
a873 7
  NTSTATUS status = NtSetInformationFile (get_handle (), &io, &fbi, sizeof fbi,
					  FileBasicInformation);
  if (!NT_SUCCESS (status))
    __seterrno_from_nt_status (status);
  else if (!allow_ntsec || !pc.has_acls ())
    /* Correct NTFS security attributes have higher priority */
    res = 0;
d875 1
d891 1
@


1.273
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Disable calling
	pc.ndisk_links.  Just use nNumberOfLinks instead.
@
text
@a1647 4
  /* Transform special DOS chars back to normal. */
  for (USHORT i = 0; i < fname->Length / sizeof (WCHAR); ++i)
    if ((fname->Buffer[i] & 0xff00) == 0xf000)
      fname->Buffer[i] &= 0xff;
@


1.272
log
@	* fhandler_disk_file.cc (fhandler_base::utimens_fs): Fix typo in
	input range check.
@
text
@d481 1
d483 3
@


1.271
log
@	* cygwin.din (futimens): Export.
	(utimensat): Export.
	* fhandler.cc (fhandler_base::utimens): Replace fhandler_base::utimes.
	Call utimens_fs.
	* fhandler.h (class fhandler_base): Declare utimens_fs instead of
	utimes_fs, utimens instead of utimes.
	(class fhandler_disk_file): Declare utimens instead of utimes.
	* fhandler_disk_file.cc (fhandler_disk_file::utimens): Replace
	fhandler_disk_file::utimes.
	(fhandler_base::utimens_fs): Replace fhandler_base::utimes_fs.
	Implement tv_nsec handling according to SUSv4.
	* syscalls.cc (utimensat): New function.
	* times.cc (timespec_to_filetime): New function.
	(timeval_to_timespec): New function.
	(utimens_worker): Replace utimes_worker.
	(utimes): Convert timeval to timespec and call utimens_worker.
	(lutimes): Ditto.
	(futimens): Take over implementation from futimes.
	(futimes): Convert timeval to timespec and call futimens.
	* winsup.h (timespec_to_filetime): Declare.
	* include/cygwin/version.h: Bump API minor number.
	* posix.sgml: Add SUSv4 section.  Add futimens and utimensat to it.
@
text
@d1190 2
a1191 2
      if ((tmp[0].tv_nsec < UTIME_NOW || tmp[0].tv_nsec > 999999999L)
	  || (tmp[1].tv_nsec < UTIME_NOW || tmp[1].tv_nsec > 999999999L))
@


1.270
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Fix
	thinko in UNC path handling.
	* path.cc (symlink_worker): Fix typo in comment.  Fix UNC path handling.
@
text
@d1152 1
a1152 1
fhandler_disk_file::utimes (const struct timeval *tvp)
d1154 1
a1154 1
  return utimes_fs (tvp);
d1158 1
a1158 1
fhandler_base::utimes_fs (const struct timeval *tvp)
d1161 2
a1162 1
  struct timeval tmp[2];
d1184 2
a1185 1
  gettimeofday (&tmp[0], 0);
d1187 2
d1190 8
a1197 2
      tmp[1] = tmp[0];
      tvp = tmp;
d1199 4
a1202 3
  timeval_to_filetime (&tvp[0], (FILETIME *) &lastaccess);
  timeval_to_filetime (&tvp[1], (FILETIME *) &lastwrite);
  debug_printf ("incoming lastaccess %08x %08x", tvp[0].tv_sec, tvp[0].tv_usec);
@


1.269
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Simplify
	code which checks for symlinks.  Fix problem with UNC paths.

	* environ.cc (struct parse_thing): Remove transparent_exe option.
	* syscalls.cc (transparent_exe): Remove.
	(unlink): Always add stat_suffixes, drop transparent_exe check.
	(open): Ditto.
	(link): Ditto.
	(pathconf): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Ditto.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Always remove
	.exe suffix.
	* path.cc (realpath): Never attach known_suffix.
@
text
@d1622 1
a1622 1
	  if (*fbuf.Buffer == L'U') /* UNC path */
@


1.268
log
@Remove unneeded header files from source files throughout.
@
text
@d25 1
d1067 1
a1067 2
  path_conv newpc (newpath, PC_SYM_NOFOLLOW | PC_POSIX,
		   transparent_exe ? stat_suffixes : NULL);
d1610 1
a1610 3
      RtlInitCountedUnicodeString (&lname, (PWCHAR) L".lnk",
				   4 * sizeof (WCHAR));

d1613 1
a1613 3
	  UNICODE_STRING dirname = *pc.get_nt_native_path ();
	  dirname.Buffer += 4; /* Skip leading \??\ */
	  dirname.Length -= 4 * sizeof (WCHAR);
d1615 3
a1617 4
	  ULONG len = dirname.Length + fname->Length + 2 * sizeof (WCHAR);

	  RtlInitEmptyUnicodeString (&fbuf, (PCWSTR) alloca (len), len);
	  RtlCopyUnicodeString (&fbuf, &dirname);
d1620 7
@


1.267
log
@	* Fix copyright dates.
@
text
@a12 1
#include <unistd.h>
a13 1
#include <sys/cygwin.h>
a15 1
#include <signal.h>
a16 1
#include "perprocess.h"
a17 1
#include "cygwin/version.h"
a24 2
#include <assert.h>
#include <ctype.h>
@


1.266
log
@	* smallprint.cc (__small_vswprintf): Fix uninitialized usage of `w'.

	Revamp advisory file locking to avoid cross reference pointers as well
	as to allow BSD flock semantics.  More agressively delete unused nodes
	and sync objects.
	* fhandler.h (fhandler_base::ino): Rename from namehash.  Fix comment.
	(fhandler_base::node): Remove.
	(fhandler_base::unique_id): Add.
	(fhandler_base::del_my_locks): New method.
	(get_ino): Rename from get_namehash.  Change usage throughout Cygwin.
	(get_unique_id): New method.
	* fhandler.cc (fhandler_base::close): Call own del_my_locks method.
	Fix comment.
	(fhandler_base::fhandler_base): Accommodate new and changed members.
	(fhandler_base::fixup_after_fork): Call del_my_locks.
	(fhandler_base::fixup_after_exec): Ditto for files with close-on-exec
	flag set.
	* fhandler_disk_file.cc (get_ino_by_handle): Rename from
	readdir_get_ino_by_handle.  Accommodate throughout.
	(fhandler_base::open_fs): Fill ino with inode number if FS has good
	inodes.  Allocate a LUID and store in unique_id to recognize file
	descriptors referencing the same file object.
	* flock.cc: Drop flock TODO comments.  Use explicit types __dev32_t
	and __ino64_t instead of dev_t and ino_t.
	(LOCK_OBJ_NAME_LEN): Change to reflect longer lf_id length.
	(get_obj_handle_count): New method.
	(lockf_t::lf_id): Change type to long long.
	(inode_t::get_lock_obj_handle_count): Drop in favor of static function
	get_obj_handle_count.
	(inode_t::del_locks): Remove.
	(inode_t::get): Add create_if_missing flag argument.
	(inode_t::del_my_locks): Reimplement to handle POSIX and BSD flock
	locks.  Return if node can be deleted or not.
	(inode_t::~inode_t): Ditto.  Close handles to i_dir and i_mtx.
	(fixup_lockf_after_fork): Remove.
	(fhandler_base::del_my_locks): New method.
	(fixup_lockf_after_exec): Check if node can be deleted.
	(inode_t::get): Only create node if create_if_missing is set.  Lock
	the returned node here before unlocking the node list.
	(inode_t::get_all_locks_list): Accommodate new lf_id length.
	(inode_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.  Change return type to bool.  De-const.
	Set lf_obj instead of returning a handle.
	(lockf_t::del_lock_obj): Call SetEvent only if new incoming parameters
	allow it.  Explain how it's supposed to work.
	(fhandler_disk_file::lock): Only fetch file length in SEEK_END case.
	Use NtQueryInformationFile(FileStandardInformation) instead of
	calling fstat_by_handle.  Always unlock node before returning.
	Use fhandler's unique id to create lf_id for BSD flock locks.
	Rely on node lock from inode_t::get.  Call del_lock_obj on removed
	locks here to allow explicit unlocking.  Delete node if no lock exists
	on the file anymore.
	(lf_setlock): Get file handle as additional parameter.  Handle the fact
	that lf_getblock now always opens the attached event object.  Reactivate
	erroneously applied patch which deactivates setting thread priority.
	Additionally handle blocking on BSD flock locks.
	(lf_clearlock): Get file handle as additional parameter.
	(lf_getlock): Close event handle opened by lf_getblock.
	(lf_getblock): Open potentially blocking event object here and check
	its signal state if it's a BSD flock lock.
	(lf_wakelock): Get file handle as additional parameter.
	* fork.cc (frok::child): Drop call to fixup_lockf_after_fork.
	* ntdll.h (struct _EVENT_BASIC_INFORMATION): Define.
	(enum _EVENT_INFORMATION_CLASS): Define.
	(NtQueryEvent): Declare.

	* fhandler.h (fhandler_base::fs_flags): Remove.
	(fhandler_base::set_fs_flags): Remove.
	(fhandler_base::get_fs_flags): Remove.
	* fhandler.cc (fhandler_base::write): Check for sparse file using
	pc.fs_flags().
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.

	The return of the volume serial number in fs_info.
	* fhandler.h (get_dev): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call to
	NtQueryVolumeInformationFile(FileFsVolumeInformation).  Just use
	get_dev() method.
	* fhandler_fifo.cc (fhandler_fifo::open) Use device ID and inode number
	to generate fifo name.
	* path.h (fs_info::sernum): New member.
	(fs_info::serial_number): New method.
	(path_conv::fs_serial_number): New method.
	* path.cc (fs_info::update): Fetch volume serial number and store in
	sernum.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
@


1.265
log
@	* fhandler.cc (fhandler_base::dup): Drop setting flags in the parent.

	Implement advisory file locking.
	* cygheap.h (struct init_cygheap): Add inode_list member.
	* cygwin.din (lockf): Export.
	* dcrt0.cc (child_info_spawn::handle_spawn): Call
	fixup_lockf_after_exec.
	* dtable.h (class dtable): Add fhandler_disk_file as friend class.
	* fhandler.cc (fhandler_base::close): Call del_my_locks if node is set.
	(fhandler_base::fhandler_base): Initialize node to NULL.
	(fhandler_base::fixup_after_fork): Ditto.
	* fhandler.h (class fhandler_base): Add member node.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Delete.
	* flock.cc: Implement all advisory file locking here.
	(fhandler_disk_file::lock): Implement here.
	(flock): Call fcntl with F_FLOCK bit set.  Remove test main function.
	(lockf): New function.
	* fork.cc (frok::child): Call fixup_lockf_after_fork.
	* ntdll.h (DIRECTORY_ALL_ACCESS): Define.
	(struct _OBJECT_BASIC_INFORMATION): Define.
	(enum _EVENT_TYPE): Define.
	(NtCreateDirectoryObject): Declare.
	(NtCreateEvent): Declare.
	(NtCreateMutant): Declare.
	(NtOpenEvent): Declare.
	(NtOpenMutant): Declare.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d172 12
a278 2
  const DWORD fvi_size = (NAME_MAX + 1) * sizeof (WCHAR)
			 + sizeof (FILE_FS_VOLUME_INFORMATION);
a280 3

  PFILE_FS_VOLUME_INFORMATION pfvi = (PFILE_FS_VOLUME_INFORMATION)
				     alloca (fvi_size);
a282 8
  status = NtQueryVolumeInformationFile (get_handle (), &io, pfvi, fvi_size,
					 FileFsVolumeInformation);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("%p = NtQueryVolumeInformationFile(%S)", status,
		    pc.get_nt_native_path ());
      pfvi->VolumeSerialNumber = 0;
    }
d300 1
a300 1
		       pfvi->VolumeSerialNumber,
d359 1
a359 1
    FileId.QuadPart = 0; /* get_namehash is called in fstat_helper. */
d493 1
a493 1
    buf->st_ino = get_namehash ();
d1049 1
a1049 1
	  && get_fs_flags (FILE_SUPPORTS_SPARSE_FILES)
d1274 5
a1278 1
  set_fs_flags (pc.fs_flags ());
a1528 12
static inline __ino64_t
readdir_get_ino_by_handle (HANDLE hdl)
{
  IO_STATUS_BLOCK io;
  FILE_INTERNAL_INFORMATION pfai;

  if (!NtQueryInformationFile (hdl, &io, &pfai, sizeof pfai,
			       FileInternalInformation))
    return pfai.FileId.QuadPart;
  return 0;
}

d1563 1
a1563 1
      ino = readdir_get_ino_by_handle (hdl);
d1601 1
a1601 1
	  de->d_ino = readdir_get_ino_by_handle (reph);
d1773 1
a1773 1
	    de->d_ino = readdir_get_ino_by_handle (get_handle ());
d1779 1
a1779 1
	      de->d_ino = readdir_get_ino_by_handle (get_handle ());
d1790 1
a1790 1
		  de->d_ino = readdir_get_ino_by_handle (hdl);
d1809 1
a1809 1
      de->d_ino = readdir_get_ino_by_handle (get_handle ());
d1820 1
a1820 1
	de->d_ino = readdir_get_ino_by_handle (get_handle ());
@


1.264
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Disable
	munging.  Convert all chars in the 0xf0xx area to it's ascii equivalent.
	* path.cc (normalize_posix_path): Don't treat "X:foo" as windows path,
	only "a:\foo".
	(tfx_chars): New transformation table for special DOS chars.
	(tfx_chars_managed): Ditto, plus transformation of uppercase ASCII
	chars.
	(transform_chars): New function.
	(get_nt_native_path): Make static.  Call transform_chars for all valid
	FS paths.  Get additional flag if file is managed or not.  Accommodate
	throughout.
	(getfileattr): Get additional flag if file is managed or not.
	Accommodate throughout.
	(path_conv::check): Disable special handling for trailing dots and
	spaces.
	(mount_item::build_win32): Disable code for managed paths.
	(mount_info::conv_to_posix_path): Ditto.
	* path.h (get_nt_native_path): Remove declaration.
@
text
@a1319 141
/* FIXME: The correct way to do this to get POSIX locking semantics is to
   keep a linked list of posix lock requests and map them into Win32 locks.
   he problem is that Win32 does not deal correctly with overlapping lock
   requests. */

int
fhandler_disk_file::lock (int cmd, struct __flock64 *fl)
{
  _off64_t win32_start;
  _off64_t win32_len;
  _off64_t startpos;

  /*
   * We don't do getlck calls yet.
   */

  if (cmd == F_GETLK)
    {
      set_errno (ENOSYS);
      return -1;
    }

  /*
   * Calculate where in the file to start from,
   * then adjust this by fl->l_start.
   */

  switch (fl->l_whence)
    {
      case SEEK_SET:
	startpos = 0;
	break;
      case SEEK_CUR:
	if ((startpos = lseek (0, SEEK_CUR)) == ILLEGAL_SEEK)
	  return -1;
	break;
      case SEEK_END:
	{
	  BY_HANDLE_FILE_INFORMATION finfo;
	  if (GetFileInformationByHandle (get_handle (), &finfo) == 0)
	    {
	      __seterrno ();
	      return -1;
	    }
	  startpos = ((_off64_t)finfo.nFileSizeHigh << 32)
		     + finfo.nFileSizeLow;
	  break;
	}
      default:
	set_errno (EINVAL);
	return -1;
    }

  /*
   * Now the fun starts. Adjust the start and length
   *  fields until they make sense.
   */

  win32_start = startpos + fl->l_start;
  if (fl->l_len < 0)
    {
      win32_start -= fl->l_len;
      win32_len = -fl->l_len;
    }
  else
    win32_len = fl->l_len;

  if (win32_start < 0)
    {
      /* watch the signs! */
      win32_len -= -win32_start;
      if (win32_len <= 0)
	{
	  /* Failure ! */
	  set_errno (EINVAL);
	  return -1;
	}
      win32_start = 0;
    }

  DWORD off_high, off_low, len_high, len_low;

  off_low = (DWORD)(win32_start & UINT32_MAX);
  off_high = (DWORD)(win32_start >> 32);
  if (win32_len == 0)
    {
      /* Special case if len == 0 for POSIX means lock to the end of
	 the entire file (and all future extensions).  */
      len_low = len_high = UINT32_MAX;
    }
  else
    {
      len_low = (DWORD)(win32_len & UINT32_MAX);
      len_high = (DWORD)(win32_len >> 32);
    }

  BOOL res;

  DWORD lock_flags = (cmd == F_SETLK) ? LOCKFILE_FAIL_IMMEDIATELY : 0;
  lock_flags |= (fl->l_type == F_WRLCK) ? LOCKFILE_EXCLUSIVE_LOCK : 0;

  OVERLAPPED ov;

  ov.Internal = 0;
  ov.InternalHigh = 0;
  ov.Offset = off_low;
  ov.OffsetHigh = off_high;
  ov.hEvent = (HANDLE) 0;

  if (fl->l_type == F_UNLCK)
    {
      res = UnlockFileEx (get_handle (), 0, len_low, len_high, &ov);
      if (res == 0 && GetLastError () == ERROR_NOT_LOCKED)
	res = 1;
    }
  else
    {
      res = LockFileEx (get_handle (), lock_flags, 0,
			len_low, len_high, &ov);
      /* Deal with the fail immediately case. */
      /*
       * FIXME !! I think this is the right error to check for
       * but I must admit I haven't checked....
       */
      if ((res == 0) && (lock_flags & LOCKFILE_FAIL_IMMEDIATELY) &&
			(GetLastError () == ERROR_LOCK_FAILED))
	{
	  set_errno (EAGAIN);
	  return -1;
	}
    }

  if (res == 0)
    {
      __seterrno ();
      return -1;
    }

  return 0;
}

@


1.263
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Don't
	copy filename twice in the non-managed case.
@
text
@d1788 5
d1801 1
@


1.262
log
@	* fhandler_disk_file.cc (DIR_BUF_SIZE): Define required space for file
	name in terms of sizeof(WCHAR).
	(fhandler_disk_file::readdir_helper): Convert *all* of fname.
	* path.cc (fillout_mntent): Use tmp_pathbuf for path buffer.
	(symlink_worker): Ditto.
	(SCAN_JUSTCHECKTHIS): New state for suffix_scan to define
	that only the actual name gets cheked and a suffix is never attached.
	(suffix_scan::has): If filename + suffix would be > NAME_MAX, start
	in SCAN_JUSTCHECKTHIS state.
	(suffix_scan::next): Add case for SCAN_JUSTCHECKTHIS.
	(symlink_info::check): Use tmp_pathbuf for path buffer.  Goto
	file_not_symlink in case of invalid file name.
	(realpath): Use tmp_pathbuf for path buffer.
@
text
@a1787 3
  char tmp[NAME_MAX + 1];
  sys_wcstombs (tmp, NAME_MAX + 1, fname->Buffer,
  		fname->Length / sizeof (WCHAR));
d1789 6
a1794 1
    fnunmunge (de->d_name, tmp);
d1796 4
a1799 2
    strcpy (de->d_name, tmp);
  if (dir->__d_position == 0 && !strcmp (tmp, "."))
d1801 1
a1801 1
  else if (dir->__d_position == 1 && !strcmp (tmp, ".."))
@


1.261
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Call close_fs
	instead of close to avoid calling close from wrong class when changing
	a file system based device node.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
@
text
@d1545 1
a1545 1
			    + 2 * (NAME_MAX + 1)))
d1789 2
a1790 1
  sys_wcstombs (tmp, NAME_MAX, fname->Buffer, fname->Length / sizeof (WCHAR));
@


1.260
log
@	* (struct __DIR_cache): Switch order of members so that the buffer
	given to NtQueryDirectoryFile is 8 byte aligned.
@
text
@d787 1
a787 1
    close ();
d829 1
a829 1
    close ();
d944 1
a944 1
    close ();
@


1.259
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d1549 1
a1550 1
  char  __cache[DIR_BUF_SIZE];
@


1.258
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fgetxattr): Remove unused
	attr.
	(fhandler_disk_file::fsetxattr): Ditto.
	* include/attr/xattr.h: New file.
@
text
@d78 1
a78 1
        RtlFreeUnicodeString (&mounts[i]);
d309 1
a309 1
  		status, pc.get_nt_native_path ());
d357 1
a357 1
  						 pfdi, fdi_size,
d424 1
a424 1
        res = fstat_by_handle (buf);
d584 1
a584 1
	        {
d1135 1
a1135 1
        {
d1151 1
a1151 1
        {
d1526 1
a1526 1
        status = STATUS_SUCCESS;
d1694 1
a1694 1
        *c++ = '/';
d1789 1
a1789 1
  sys_wcstombs (tmp, NAME_MAX, fname->Buffer, fname->Length / sizeof (WCHAR)); 
@


1.257
log
@	* Makefile.in (DLL_OFILES): Add ntea.o.
	* cygwin.din (getxattr, listxattr, removexattr, setxattr, lgetxattr,
	llistxattr, lremovexattr, lsetxattr, fgetxattr, flistxattr,
	fremovexattr, fsetxattr): Export Linux extended attribute functions.
	Sort.
	* errno.cc (errmap): Add mappings for ERROR_EAS_DIDNT_FIT,
	ERROR_EAS_NOT_SUPPORTED, ERROR_EA_LIST_INCONSISTENT,
	ERROR_EA_TABLE_FULL, ERROR_FILE_CORRUPT, ERROR_INVALID_EA_NAME.
	* fhandler.h (class fhandler_base): Declare new fgetxattr and
	fsetxattr methods.
	(class fhandler_disk_file): Ditto.
	* fhandler.cc (fhandler_base::fgetxattr): New method.
	(fhandler_base::fsetxattr): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::fgetxattr): New method.
	(fhandler_disk_file::fsetxattr): New method.
	* ntdll.h (STATUS_EA_TOO_LARGE): Define.
	(STATUS_NONEXISTENT_EA_ENTRY): Define.
	(STATUS_NO_EAS_ON_FILE): Define.
	* ntea.cc (read_ea): Rewrite for long pathnames and for using with
	Linux extended attribute functions.
	(write_ea): Ditto.
	(getxattr_worker): New static function.
	(getxattr): New function.
	(lgetxattr): New function.
	(fgetxattr): New function.
	(listxattr): New function.
	(llistxattr): New function.
	(flistxattr): New function.
	(setxattr_worker): New static function.
	(setxattr): New function.
	(lsetxattr): New function.
	(fsetxattr): New function.
	(removexattr): New function.
	(lsetxattr): New function.
	(fsetxattr): New function.
	* security.h (read_ea): Change declaration according to above changes.
	(write_ea): Ditto.
	* include/cygwin/version.h: Bump API minor version.
@
text
@a951 2
  OBJECT_ATTRIBUTES attr;

a963 2
  OBJECT_ATTRIBUTES attr;

@


1.256
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Open file with
	READ_CONTROL for Vista/Longhorn's sake.
@
text
@d949 27
@


1.255
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Fix R/O bit
	handling on filesystems without ACL support.
@
text
@d1092 1
a1092 1
  status = NtOpenFile (&fh, FILE_ANY_ACCESS,
@


1.254
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.
@
text
@d556 1
a556 2
      if (!::has_attribute (dwFileAttributes, FILE_ATTRIBUTE_READONLY)
	  && !pc.isdir () && !pc.issymlink ())
d560 2
a561 2
      if (S_ISDIR (buf->st_mode))
	buf->st_mode |= S_IFDIR | STD_XBITS;
@


1.253
log
@	* fhandler_disk_file.cc (__DIR_mounts::eval_ino): Make fname big enough
	to allow multibyte chars.
@
text
@d538 1
a538 1
	  && !pc.issymlink ())
d557 1
a557 1
	  && !pc.issymlink ())
@


1.252
log
@	* fhandler.cc (is_at_eof): Rewrite using NT functions.
	(off_current): New static variable.
	(off_append): Ditto.
	(fhandler_base::raw_write): Use NtWriteFile.  Accommodate O_APPEND here.
	(fhandler_base::write): Drop O_APPEND hack.  Use NT functions.
	(fhandler_base::lseek): Rewrite using NT functions.
	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Add space in
	debug output.
	(fhandler_disk_file::ftruncate): Ditto.
	* ntdll.h (STATUS_DISK_FULL): Define.
	(FILE_USE_FILE_POINTER_POSITION): Define.
	(FILE_WRITE_TO_END_OF_FILE): Define.
@
text
@d52 1
a52 1
      char fname[parent_dir_len + mounts[idx].Length / sizeof (WCHAR) + 2];
d58 1
a58 1
      sys_wcstombs (c, mounts[idx].Length / sizeof (WCHAR) + 1,
@


1.251
log
@	* ntdll.h (struct _FILE_COMPRESSION_INFORMATION): Align with definition
	in w32api / MSDN.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Accommodate
	change to struct _FILE_COMPRESSION_INFORMATION.
@
text
@d701 1
a701 1
	    debug_printf ("%p = NtFsControlFile(%S,FSCTL_GET_NTFS_VOLUME_DATA)",
d1033 1
a1033 1
	  syscall_printf ("%p = NtFsControlFile(%S,FSCTL_SET_SPARSE)",
@


1.250
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Rewrite checking
	for executable file magic using a thread safe method and re-enable this
	code.
@
text
@d509 2
a510 1
    buf->st_blocks = (fci.CompressedSize.QuadPart + S_BLKSIZE - 1) / S_BLKSIZE;
@


1.249
log
@	* fhandler_disk_file.cc: Change debugging output througout to print
	the NT status consistently.  Use UNICODE path information if available.
@
text
@a572 6
#if 0
	  /* FIXME: Is this code really necessary?  There are already
	     two places in path_conv which look for executability.
	     Also, by using the fhandler's io HANDLE, a stat call might
	     change the file position for a short period of time in
	     a not thread-safe way. */
d575 16
a590 15
	      DWORD cur, done;
	      LONG curhigh = 0;
	      char magic[3];

	      /* First retrieve current position, set to beginning
		 of file if not already there. */
	      cur = SetFilePointer (get_handle (), 0, &curhigh, FILE_CURRENT);
	      if ((cur != INVALID_SET_FILE_POINTER || GetLastError () == NO_ERROR)
		  && ((!cur && !curhigh) || SetFilePointer (get_handle (), 0, NULL, FILE_BEGIN)
		      != INVALID_SET_FILE_POINTER))
		{
		  /* FIXME should we use /etc/magic ? */
		  magic[0] = magic[1] = magic[2] = '\0';
		  if (ReadFile (get_handle (), magic, 3, &done, NULL)
		      && has_exec_chars (magic, done))
d595 1
a595 1
		  SetFilePointer (get_handle (), cur, &curhigh, FILE_BEGIN);
a597 1
#endif
@


1.248
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Handle S_IFSOCK
	mode bit by setting the SYSTEM attribute.
	* fhandler_socket.cc (fhandler_socket::fchmod): Add S_IFSOCK mode bit
	when calling fhandler_disk_file::fchmod.  Don't set attributes here.
@
text
@d280 2
a281 2
      debug_printf ("%u = NtQueryVolumeInformationFile)",
		    RtlNtStatusToDosError (status));
d308 2
a309 2
  debug_printf ("%u = NtQueryInformationFile)",
		RtlNtStatusToDosError (status));
d347 1
a347 1
      debug_printf ("%u = NtOpenFile)", RtlNtStatusToDosError (status));
d363 2
a364 2
      debug_printf ("%u = NtQueryDirectoryFile)",
		    RtlNtStatusToDosError (status));
d372 2
a373 2
      debug_printf ("%u = NtQueryVolumeInformationFile)",
		    RtlNtStatusToDosError (status));
d706 2
a707 1
	    debug_printf ("NtFsControlFile (%s) failed, status %lx", status);
d1038 2
a1039 2
	  syscall_printf ("0x%08X = NtFsControlFile (%p, FSCTL_SET_SPARSE)",
			  status, get_handle ());
d1992 2
a1993 3
	debug_printf ("Unable to reopen dir %s, NT error: 0x%08x, "
		      "win32: %lu", get_name (), status,
		      RtlNtStatusToDosError (status));
@


1.247
log
@	* fhandler.h (fhandler_base::get_namehash): Use NT native path.
	* fhandler_disk_file.cc (readdir_get_ino): Ditto in call to
	hash_path_name.
@
text
@d775 2
@


1.246
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Drop superfluous
	test for trailing dot.
	* path.h (path_conv::operator []): Remove.
@
text
@d1685 1
a1685 1
    ino = hash_path_name (0, pc);
@


1.245
log
@	* fhandler.h (fhandler_base::pc): Make public.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Drop extern
	declaration of stat_suffixes.  Use NT native path in debug output.
	(fhandler_base::utimes_fs): Simplify closeit case.  Use close_fs
	to close newly opened file handle.
	(fhandler_base::open_fs): Use NT native path in debug output.
	* path.cc: Throughout drop extern declaration of stat_suffixes.
	* path.h (stat_suffixes): Declare.
	* sec_acl.cc (acl_worker): Drop extern declaration of stat_suffixes.
	* times.cc (utimes_worker): Take path_conv as parameter instead of
	single-byte pathnam, drop nofollow argument, accommodate throughout.
	Compare UNICODE paths when enumerating file descriptors.  Fix
	formatting.  Use NT native path in debug output.
@
text
@a1068 7
  if (newpc[strlen (newpc) - 1] == '.')
    {
      syscall_printf ("trailing dot, bailing out");
      set_errno (EINVAL);
      return -1;
    }

@


1.244
log
@	* fhandler.h (fhandler_base::close_fs): Reintroduce (as inline function)
	for clearness.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Revert previous
	change.
	(fhandler_base::open_fs): Ditto.
	* fhandler_socket.cc (fhandler_socket::close): Ditto.
@
text
@a1052 1
  extern suffix_info stat_suffixes[];
d1064 1
a1064 1
      syscall_printf ("file '%s' exists?", newpc.get_win32 ());
d1197 2
a1202 2
      if (closeit)
	close ();
a1205 2
  if (closeit)
    close ();
d1265 2
a1266 2
  syscall_printf ("%d = fhandler_disk_file::open (%s, %p)", res,
		  get_win32_name (), flags);
@


1.243
log
@	* Makefile.in (DLL_OFILES): Remove delqueue.o.
	* delqueue.cc: Delete.
	* fhandler.h (fhandler_base::close_fs): Drop declaration.
	(fhandler_disk_file::close): Drop declaration.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Call close instead of
	close_fs.
	(fhandler_base::fstat_helper): Use open FH_UNIX handle in call to
	get_file_attribute.
	(fhandler_base::open_fs): Call close instead of get_file_attribute.
	(fhandler_disk_file::close): Remove.
	(fhandler_base::close_fs): Remove.
	* fhandler_socket.cc (fhandler_socket::close): Just call
	fhandler_base::close for FH_UNIX sockets.
	* shared.cc (user_shared_initialize): Drop call to
	user_shared->delqueue.init.
	* shared_info.h (CURR_USER_MAGIC): Change according to below change.
	(MAX_DELQUEUES_PENDING): Remove.
	(class delqueue_list): Remove.
	(class user_info): Remove delqueue.
	* syscalls.cc (close_all_files): Drop call to
	user_shared->delqueue.process_queue.
	(unlink): Drop delqueue handling.
@
text
@d440 1
a440 1
      close ();
d1260 1
a1260 1
      close ();
@


1.242
log
@	* fhandler.cc (fhandler_base::open): Remove HIDDEN_DOT_FILES code.
	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Ditto.
	* path.cc (symlink_worker): Ditto.
@
text
@d435 1
a435 1
	 we have to set it to false before calling close_fs and restore
d440 1
a440 1
      close_fs ();
d531 2
a532 1
  if (!get_file_attribute (is_fs_special () ? NULL: get_handle (), pc,
d1260 1
a1260 1
      close_fs ();
a1272 15
int
fhandler_disk_file::close ()
{
  return close_fs ();
}

int
fhandler_base::close_fs ()
{
  int res = fhandler_base::close ();
  if (!res)
    user_shared->delqueue.process_queue ();
  return res;
}

@


1.241
log
@	* fhandler_disk_file.cc (readdir_get_ino): Accommodate native symlinks.
	* syscalls.cc (rename): Ditto.
@
text
@a1480 7
#ifdef HIDDEN_DOT_FILES
  UNICODE_STRING basename;

  RtlSplitUnicodePath (pc.get_nt_native_path (), NULL, &basename);
  if (basename.Buffer[0] == L'.')
    fattr |= FILE_ATTRIBUTE_HIDDEN;
#endif
@


1.240
log
@	* fhandler_disk_file.cc (path_conv::ndisk_links): Fix typo in call to
	NtClose.
@
text
@d1720 3
a1722 1
				   FILE_OPEN_FOR_BACKUP_INTENT)))
@


1.239
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop
	usage of path_conv::volser().
	(fhandler_base::fstat_by_name): Ditto.
	* ntdll.h (STATUS_NO_MEDIA_IN_DEVICE): Define.
	(STATUS_OBJECT_NAME_NOT_FOUND): Define.
	(FILE_REMOVABLE_MEDIA, FILE_READ_ONLY_DEVICE, FILE_FLOPPY_DISKETTE)
	(FILE_WRITE_ONCE_MEDIA, FILE_REMOTE_DEVICE, FILE_DEVICE_IS_MOUNTED)
	(FILE_VIRTUAL_VOLUME, FILE_AUTOGENERATED_DEVICE_NAME)
	FILE_DEVICE_SECURE_OPEN): Define Device Characteristics.
	(struct _FILE_FS_DEVICE_INFORMATION): Define.
	* path.cc (MAX_FS_INFO_CNT): Remove.
	(fsinfo): Remove.
	(fsinfo_cnt): Remove.
	(fs_info::update): Rewrite using native NT functions.  Drop fs_info
	cashing since it's incorrect.
	(path_conv::fillin): Use NtQueryInformationFile.  Drop setting serial
	number.
	(path_conv::check): Accommodate new fs_info::update parameters.
	(fillout_mntent): Ditto.
	* path.h (fs_info): Drop serial, has_ea and drive_type status
	flags.
	(fs_info::update): Declare with new parameters.
	(path_conf::drive_type): Remove.
	(path_conf::fs_has_ea): Remove.
	(path_conf::volser): Remove.
@
text
@d245 1
a245 1
  NtClose (dir);
@


1.238
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Revert to checking
	for binary in case of .exe files.
	* ntdll.h (RtlPrefixUnicodeString): Declare.
	* path.cc (path_conv::is_binary): New method.
	* path.h (path_conv::is_binary): Declare.
	* syscalls.cc (rename_append_suffix): New static helper function for
	rename.
	(rename): Rewrite.  New suffix tests.  Use native NT functions.
@
text
@d282 1
a282 1
      pfvi->VolumeSerialNumber = pc.volser ();
d374 1
a374 1
      pfvi->VolumeSerialNumber = pc.volser ();
d406 1
a406 1
		       pc.volser (),
@


1.237
log
@	* fhandler_disk_file.cc (fhandler_disk_file::facl): If file can't be
	opened for reading the ACLs, fall back to faking them.
	* sec_acl.cc (acl_worker): Handle non-existing files.
	* security.cc (get_file_attribute): Return ILLEGAL_UID/ILLEGAL_GID
	as owner/group for non-readable ACLs on file systems supporting them.
@
text
@d1087 1
a1087 2
	       && RtlEqualUnicodePathSuffix (pc.get_nt_native_path (),
					     L".exe", TRUE)
@


1.236
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Don't allow
	FileAttributes set to 0 when calling NtSetInformationFile since it has
	a special meaning.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::link): Only set attributes after copying files.
	Use SetFileAttributesW.
	* syscalls.cc (unlink_nt): Only care for actual FILE_ATTRIBUTE_READONLY.
	Don't allow FileAttributes set to 0 when calling NtSetInformationFile.
	After marking for deletion, restore R/O attribute on files to
	accommodate hardlinks.
@
text
@d844 1
d899 1
a899 1
	  query_open (cmd == SETACL ? query_write_control : query_read_attributes);
d901 5
a905 1
	    return -1;
@


1.235
log
@	* fhandler_disk_file.cc (fhandler_disk_file::link): Use FILE_ANY_ACCESS.
	(fhandler_base::utimes_fs): Fix white space.
	(fhandler_disk_file::lock): Remove 9x blurb from comment.
	(fhandler_disk_file::mkdir): Use NtCreateFile/NtClose instead of
	CreateDirectoryA.
	(fhandler_disk_file::rmdir): Accommodate changes to unlink_nt.
	Simplify post-delete SMB-related tests.  Use NtQueryAttributesFile
	instead of GetFileAttributes.
	* ntdll.h (STATUS_DIRECTORY_NOT_EMPTY): Define.
	(NtQueryAttributesFile): Declare.
	* syscalls.cc (unlink_nt): Return NTSTATUS.  Drop setattrs parameter.
	Never use FILE_DELETE_ON_CLOSE, always use
	NtSetInformationFile(FileDispositionInformation) instead.
	Check for R/O attributes and open file with FILE_WRITE_ATTRIBUTES
	access if any of them are set.  Remove R/O attributes before
	marking for delete if necessary.  Revert them afterwards if necessary.
	(unlink): Accommodate changes to unlink_nt.
@
text
@d779 1
a779 1
  fbi.FileAttributes = pc.file_attributes ();
d917 3
a919 2
		    fbi.FileAttributes = pc.file_attributes ()
		    			 & ~FILE_ATTRIBUTE_READONLY;
d1128 4
a1138 4
  if (!allow_winsymlinks && pc.is_lnk_special ())
    SetFileAttributes (newpc, (DWORD) pc
			       | FILE_ATTRIBUTE_SYSTEM
			       | FILE_ATTRIBUTE_READONLY);
@


1.234
log
@	* fhandler_disk_file.cc: Use get_handle throughout.
	(fhandler_disk_file::fchmod): Always try to open file with required
	access rights.  Use NtSetInformationFile instead of SetFileAttributes.
	(fhandler_disk_file::facl): Use NtSetInformationFile instead of
	SetFileAttributes.
	(fhandler_base::utimes_fs): Change lastaccess and lastwrite to
	LARGE_INTEGER.  Drop 9x directory case.  Use NtSetInformationFile
	instead of SetFileAttributes.  Drop temporarily changing R/O attribute
	since NtSetInformationFile(FileBasicInformation) also works on R/O
	files.
	* ntdll.h (STATUS_NOT_SUPPORTED): Define.
@
text
@d1097 2
a1098 1
  status = NtOpenFile (&fh, 0, pc.get_object_attr (attr, sec_none_nih), &io,
d1186 1
a1186 1
  fbi.LastAccessTime= lastaccess;
d1322 1
a1322 5
   requests. Also another pain is that Win95 doesn't do non-blocking or
   non-exclusive locks at all. For '95 just convert all lock requests into
   blocking,exclusive locks.  This shouldn't break many apps but denying all
   locking would.  For now just convert to Win32 locks and hope for
   the best.  */
d1471 5
a1475 2
  if (CreateDirectoryA (get_win32_name (), &sa))
    {
d1477 5
a1481 3
      char *c = strrchr (real_dir.get_win32 (), '\\');
      if ((c && c[1] == '.') || *get_win32_name () == '.')
	SetFileAttributes (get_win32_name (), FILE_ATTRIBUTE_HIDDEN);
d1483 9
d1495 1
a1495 1
    __seterrno ();
d1503 1
a1503 3
  extern DWORD unlink_nt (path_conv &win32_name, bool setattrs);

  int res = -1;
d1510 5
a1514 23
  /* Even own directories can't be removed if R/O attribute is set. */
  if (pc.has_attribute (FILE_ATTRIBUTE_READONLY))
    SetFileAttributes (get_win32_name (),
		       (DWORD) pc & ~FILE_ATTRIBUTE_READONLY);

  DWORD err, att = 0;

  int rc = !(err = unlink_nt (pc, pc.has_attribute (FILE_ATTRIBUTE_READONLY)));
  if (err)
    SetLastError (err);

  if (isremote () && exists ())
    att = GetFileAttributes (get_win32_name ());

  /* Sometimes smb indicates failure when it really succeeds, so check for
     this case specifically. */
  if (rc || att == INVALID_FILE_ATTRIBUTES)
    {
      /* RemoveDirectory on a samba drive doesn't return an error if the
	 directory can't be removed because it's not empty. Checking for
	 existence afterwards keeps us informed about success. */
      if (!isremote () || att == INVALID_FILE_ATTRIBUTES)
	return 0;
d1516 1
a1516 4
      err = ERROR_DIR_NOT_EMPTY;
    }
  else
    err = GetLastError ();
d1518 9
a1526 1
  __seterrno_from_win_error (err);
d1528 12
a1539 1
  return res;
@


1.233
log
@	* ntdll.h (RtlEqualUnicodePathPrefix): Rename from RtlEqualPathPrefix.
	(RtlEqualUnicodePathSuffix): Rename from RtlEqualPathSuffix.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Accommodate above
	change.
@
text
@d421 1
a421 1
  if (get_io_handle ())
d504 2
a505 2
	   && get_io_handle () && !is_fs_special ()
	   && !NtQueryInformationFile (get_io_handle (), &st, (PVOID) &fci,
d524 1
a524 1
      get_file_attribute (get_io_handle (), pc, NULL,
d531 1
a531 1
  if (!get_file_attribute (is_fs_special () ? NULL: get_io_handle (), pc,
d572 6
d602 1
a603 1

d744 1
a744 1
  if (!get_io_handle ())
d749 1
a749 2
	  /* If the file couldn't be opened, that's really only a problem if
	     ACLs or EAs should get written. */
d752 4
d763 1
a763 1
      if (!set_file_attribute (get_io_handle (), pc,
d775 9
a783 2
  if (!SetFileAttributes (pc, pc))
    __seterrno ();
d806 1
a806 1
  if (!get_io_handle ())
d816 1
a816 1
  int res = get_file_attribute (get_io_handle (), pc, &attrib, NULL, NULL);
d828 1
a828 1
      res = set_file_attribute (get_io_handle (), pc, uid, gid, attrib);
d851 1
a851 1
	    if (!get_io_handle ())
d862 1
a862 1
		if (!get_io_handle ())
d896 1
a896 1
      if (!get_io_handle ())
d908 1
a908 1
		res = setacl (get_io_handle (), pc, nentries, aclbufp, rw);
d910 12
a921 1
		  SetFileAttributes (pc, (DWORD) pc & ~FILE_ATTRIBUTE_READONLY);
d928 1
a928 1
	      res = getacl (get_io_handle (), pc, nentries, aclbufp);
d931 1
a931 1
	    res = getacl (get_io_handle (), pc, 0, NULL);
d1149 1
a1149 1
  FILETIME lastaccess, lastwrite;
d1151 1
a1151 1
  bool closeit;
d1153 1
a1153 3
  if (get_handle ())
    closeit = false;
  else
a1171 3
  if (nohandle ())	/* Directory query_open on 9x. */
    return 0;

d1178 2
a1179 2
  timeval_to_filetime (&tvp[0], &lastaccess);
  timeval_to_filetime (&tvp[1], &lastwrite);
d1182 9
a1190 6
  if (is_fs_special ())
    SetFileAttributes (pc, (DWORD) pc & ~FILE_ATTRIBUTE_READONLY);
  BOOL res = SetFileTime (get_handle (), NULL, &lastaccess, &lastwrite);
  DWORD errcode = GetLastError ();
  if (is_fs_special ())
    SetFileAttributes (pc, pc);
d1192 2
a1193 2
     then the SetFileTimes fails with ERROR_NOT_SUPPORTED.  Oh well... */
  if (!res && errcode != ERROR_NOT_SUPPORTED)
d1195 3
a1197 2
      close ();
      __seterrno_from_win_error (errcode);
a1199 1

@


1.232
log
@	* ntdll.h (RtlInitCountedUnicodeString): Swap order of string and length
	parameters to be the same as for RtlInitEmptyUnicodeString.
	(RtlEqualPathPrefix): New inline function.
	(RtlEqualPathSuffix): New inline function.
	* fhandler_disk_file.cc: Accommodate parameter order change of
	RtlInitEmptyUnicodeString throughout.
	(fhandler_disk_file::link): Do path checking in unicode.  Call
	CopyFileW instead of CopyFileA.
@
text
@d1054 4
a1057 3
	       && RtlEqualPathSuffix (pc.get_nt_native_path (), L".exe", TRUE)
	       && !RtlEqualPathSuffix (newpc.get_nt_native_path (), L".exe",
				       TRUE))
d1070 1
a1070 2
  status = NtOpenFile (&fh, 0,
		       pc.get_object_attr (attr, sec_none_nih), &io,
@


1.231
log
@	* autoload.cc (CreateHardLinkA): Remove.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Drop GetBinaryType
	test.  Just check exe suffix instead.  Tune creating new file name.
	Implement creating hard link using native NT functions which works
	on all platforms.
	* ntdll.h (STATUS_INVALID_DEVICE_REQUEST): Define.
	(struct _FILE_LINK_INFORMATION): Define.
@
text
@d226 2
a227 2
		RtlInitCountedUnicodeString (&fname, pfdi->FileNameLength,
					     pfdi->FileName);
d238 2
a239 2
	  RtlInitCountedUnicodeString (&fname, pfdi->FileNameLength,
				       pfdi->FileName);
a1045 2
      int len;

d1054 3
a1056 4
	       && (len = strlen (pc.get_win32 ())) > 4
	       && strcasematch (pc.get_win32 () + len - 4, ".exe")
	       && (len = strlen (newpc.get_win32 ())) > 4
	       && !strcasematch (newpc.get_win32 () + len - 4, ".exe"))
d1091 4
a1094 1
	  if (!CopyFileA (pc, newpc, TRUE))
d1735 6
a1740 5
      RtlInitCountedUnicodeString (&uname, 4 * sizeof (WCHAR),
				   fname->Buffer +
				   fname->Length / sizeof (WCHAR) - 4);
      RtlInitCountedUnicodeString (&lname, 4 * sizeof (WCHAR),
				   (PWCHAR) L".lnk");
d1876 1
a1876 1
      RtlInitCountedUnicodeString (&fname, buf->FileNameLength, FileName);
@


1.230
log
@	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Use
	NtQueryInformationFile instead of GetFileSize, NtFsControlFile instead
	of DeviceIoControl.
@
text
@d1031 1
a1031 1
      syscall_printf ("file '%s' exists?", (char *) newpc);
d1043 1
a1043 1
  char new_buf[CYG_MAX_PATH + 5];
a1045 1
      DWORD bintype;
d1051 1
a1051 2
	  strcpy (new_buf, newpath);
	  strcat (new_buf, ".lnk");
d1055 5
a1059 5
      else if (transparent_exe
	       && !pc.isdir ()
	       && GetBinaryType (pc, &bintype)
	       && (len = strlen (newpc)) > 4
	       && !strcasematch ((const char *) newpc + len - 4, ".exe"))
d1062 1
a1062 2
	  strcpy (new_buf, newpath);
	  strcat (new_buf, ".exe");
d1068 9
a1076 2
  query_open (query_write_attributes);
  if (!open (O_BINARY, 0))
d1078 1
a1078 2
      syscall_printf ("Opening file failed");
      __seterrno ();
d1081 9
a1089 11

  if (CreateHardLinkA (newpc, pc, NULL))
    goto success;

  /* There are two cases to consider:
     - The FS doesn't support hard links ==> ERROR_INVALID_FUNCTION
       We copy the file.
     - CreateHardLinkA is not supported  ==> ERROR_PROC_NOT_FOUND
       In that case (<= NT4) we try the old-style method.
     Any other error should be taken seriously. */
  if (GetLastError () == ERROR_INVALID_FUNCTION)
d1091 8
a1098 42
      syscall_printf ("FS doesn't support hard links: Copy file");
      goto docopy;
    }
  if (GetLastError () != ERROR_PROC_NOT_FOUND)
    {
      syscall_printf ("CreateHardLinkA failed");
      __seterrno ();
      close ();
      return -1;
    }

  WIN32_STREAM_ID stream_id;
  LPVOID context;
  WCHAR wbuf[CYG_MAX_PATH];
  BOOL ret;
  DWORD written, write_err, path_len, size;

  path_len = sys_mbstowcs (wbuf, newpc, CYG_MAX_PATH) * sizeof (WCHAR);

  stream_id.dwStreamId = BACKUP_LINK;
  stream_id.dwStreamAttributes = 0;
  stream_id.dwStreamNameSize = 0;
  stream_id.Size.HighPart = 0;
  stream_id.Size.LowPart = path_len;
  size = sizeof (WIN32_STREAM_ID) - sizeof (WCHAR**)
	 + stream_id.dwStreamNameSize;
  context = NULL;
  write_err = 0;
  /* Write WIN32_STREAM_ID */
  ret = BackupWrite (get_handle (), (LPBYTE) &stream_id, size,
		     &written, FALSE, FALSE, &context);
  if (ret)
    {
      /* write the buffer containing the path */
      /* FIXME: BackupWrite sometimes traps if linkname is invalid.
	 Need to handle. */
      ret = BackupWrite (get_handle (), (LPBYTE) wbuf, path_len,
			 &written, FALSE, FALSE, &context);
      if (!ret)
	{
	  write_err = GetLastError ();
	  syscall_printf ("cannot write linkname, %E");
d1100 4
a1103 17
      /* Free context */
      BackupWrite (get_handle (), NULL, 0, &written,
		   TRUE, FALSE, &context);
    }
  else
    {
      write_err = GetLastError ();
      syscall_printf ("cannot write stream_id, %E");
    }

  if (!ret)
    {
      /* Only copy file if FS doesn't support hard links */
      if (write_err == ERROR_INVALID_FUNCTION)
	{
	  syscall_printf ("FS doesn't support hard links: Copy file");
	  goto docopy;
a1104 4

      close ();
      __seterrno_from_win_error (write_err);
      return -1;
a1105 3

success:
  close ();
a1110 14

docopy:
  /* do this with a copy */
  if (!CopyFileA (pc, newpc, 1))
    {
      __seterrno ();
      return -1;
    }
  close ();
  fhandler_disk_file fh (newpc);
  fh.query_open (query_write_attributes);
  if (fh.open (O_BINARY, 0))
    fh.close ();
  return 0;
@


1.229
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_name): Use
	RtlSplitUnicodePath.
	(fhandler_disk_file::fstat): Rename oret to opened.  Open file using NT
	functions right here.  Try to open parent dir instead of root directory
	to avoid call to rootdir.  Use NtFsControlFile.
	* ntdll.h (RtlSplitUnicodePath): Define.
@
text
@a973 2
      _off64_t actual_length;
      DWORD size_high = 0;
d976 1
d979 7
a985 2
      actual_length = GetFileSize (get_handle (), &size_high);
      actual_length += ((_off64_t) size_high) << 32;
d989 1
a989 1
      if (!allow_truncate && length < actual_length)
d997 1
a997 1
	  && length >= actual_length + (128 * 1024))
d999 4
a1002 6
	  DWORD dw;
	  BOOL r = DeviceIoControl (get_handle (),
				    FSCTL_SET_SPARSE, NULL, 0, NULL,
				    0, &dw, NULL);
	  syscall_printf ("%d = DeviceIoControl(%p, FSCTL_SET_SPARSE)",
			      r, get_handle ());
@


1.228
log
@	* fhandler_disk_file.cc (is_volume_mountpoint): New static inline
	function.
	(path_conv::ndisk_links): Call is_volume_mountpoint.
	(fhandler_disk_file::readdir_helper): Ditto.
@
text
@d338 1
a338 10
  /* Split path in dirname and basename */
  dirname = *pc.get_nt_native_path ();
  USHORT len = dirname.Length / sizeof (WCHAR);
  while (len > 0 && dirname.Buffer[--len] != L'\\')
    ;
  ++len;
  RtlInitCountedUnicodeString (&basename,
			       dirname.Length - len * sizeof (WCHAR),
			       &dirname.Buffer[len]);
  dirname.Length = len * sizeof (WCHAR);
d621 1
a621 1
  int ret = -1, oret = 0;
d625 1
a625 1
			  + 256 * sizeof (WCHAR);
d629 1
a629 1
			  + 256 * sizeof (WCHAR);
d634 1
d636 1
a636 1
  if (!get_io_handle ())
d638 15
a652 11
      query_open (query_read_control);
      oret = open_fs (O_RDONLY | O_BINARY, 0);
      if (!oret)
	{
	  /* Can't open file.  Try again with rootdir. */
	  char root[CYG_MAX_PATH];
	  if (!rootdir (get_win32_name (), root))
	    goto out;
	  pc.check (root, PC_SYM_NOFOLLOW);
	  oret = open_fs (O_RDONLY | O_BINARY, 0);
	  if (!oret)
d658 1
a658 1
  status = NtQueryVolumeInformationFile (get_handle (), &io, pfvi, fvi_size,
d665 1
a665 1
  status = NtQueryVolumeInformationFile (get_handle (), &io, pfai, fai_size,
d681 1
a681 2
  status = NtQueryVolumeInformationFile (get_handle (), &io, &full_fsi,
					 sizeof full_fsi,
a693 1
	  DWORD bytes;
d695 5
a699 3
	  if (!DeviceIoControl (get_handle (), FSCTL_GET_NTFS_VOLUME_DATA, NULL,
				0, &nvdb, sizeof nvdb, &bytes, NULL))
	    debug_printf ("DeviceIoControl (%s) failed, %E", get_name ());
d707 2
a708 2
      status = NtQueryVolumeInformationFile (get_handle (), &io, &fsi,
					     sizeof fsi, FileFsSizeInformation);
d722 2
a723 2
  if (oret)
    close_fs ();
@


1.227
log
@	* fhandler.h (enum query_state): Drop redundant query_stat_control.
	* fhandler.cc (fhandler_base::open): Ditto.  Add READ_CONTROL to
	access and FILE_OPEN_FOR_BACKUP_INTENT to create_options when opening
	for writing.  Always set security attributes to avoid calling
	has_acls.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Don't try to
	open file twice.
@
text
@d147 25
a191 1
		NTSTATUS status;
a223 1
		HANDLE reph;
d230 2
a231 15
		if (NT_SUCCESS (status = NtOpenFile (&reph, READ_CONTROL, &attr, &io,
					    FILE_SHARE_VALID_FLAGS,
					    FILE_OPEN_FOR_BACKUP_INTENT
					    | FILE_OPEN_REPARSE_POINT)))
		  {
		    PREPARSE_DATA_BUFFER rp = (PREPARSE_DATA_BUFFER)
				alloca (MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
		    if (NT_SUCCESS (NtFsControlFile (reph, NULL, NULL, NULL,
				&io, FSCTL_GET_REPARSE_POINT, NULL, 0,
				(LPVOID) rp, MAXIMUM_REPARSE_DATA_BUFFER_SIZE))
			&& rp->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT
			&& rp->SymbolicLinkReparseBuffer.PrintNameLength == 0)
		      ++count;
		    NtClose (reph);
		  }
d1787 7
a1793 24
      if (NT_SUCCESS (NtOpenFile (&reph, READ_CONTROL, &attr, &io,
				  FILE_SHARE_VALID_FLAGS,
				  FILE_OPEN_FOR_BACKUP_INTENT
				  | FILE_OPEN_REPARSE_POINT)))
	{
	  PREPARSE_DATA_BUFFER rp = (PREPARSE_DATA_BUFFER)
		      alloca (MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
	  if (NT_SUCCESS (NtFsControlFile (reph, NULL, NULL, NULL,
		      &io, FSCTL_GET_REPARSE_POINT, NULL, 0,
		      (LPVOID) rp, MAXIMUM_REPARSE_DATA_BUFFER_SIZE))
	      && rp->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT
	      && rp->SymbolicLinkReparseBuffer.PrintNameLength == 0)
	    {
	      NtClose (reph);
	      if (NT_SUCCESS (NtOpenFile (&reph, READ_CONTROL, &attr, &io,
					  FILE_SHARE_VALID_FLAGS,
					  FILE_OPEN_FOR_BACKUP_INTENT)))
		{
		  de->d_ino = readdir_get_ino_by_handle (reph);
		  NtClose (reph);
		}
	    }
	  else
	    NtClose (reph);
@


1.226
log
@	* dir.cc (readdir_worker): Drop dir parameter from call to
	readdir_get_ino.
	* fhandler.h (fhandler_disk_file::readdir_helper): Switch file name
	parameter to PUNICODE_STRING.
	* fhandler_disk_file.cc: Drop including ntdef.h.
	(class __DIR_mounts): Store mount points in UNICODE.  Additionally
	store cygdrive prefix in unicode here.  Change methods accordingly.
	(__DIR_mounts::eval_ino): Call new stat_worker instead of lstat64.
	(__DIR_mounts::~__DIR_mounts): New destructor to free UNICODE buffers.
	(path_conv::ndisk_links): Rewrite using native NT functions.
	(fhandler_base::fstat_by_handle): Use NAME_MAX instead of CYG_MAX_PATH.
	Always set pfvi->VolumeSerialNumber to non-0.  Remove last resort
	code.
	(fhandler_base::fstat_by_name): Rewrite using native NT functions.
	(fhandler_base::fstat_fs): Always call fstat_by_name if fstat_by_handle
	fails.
	(fhandler_base::fstat_helper): Rely on dwVolumeSerialNumber.
	(fhandler_disk_file::facl): Call fstat_by_name if fstat_by_handle fails.
	(DIR_BUF_SIZE): Define using NAME_MAX instead of CYG_MAX_PATH.
	(__DIR_cache): Remove __name.
	(d_dirname): Remove.
	(fhandler_disk_file::opendir): Drop pathname length check.
	Remove outdated comment.  Use get_name method instead of accessing
	pc.normalized_path directly.
	(readdir_get_ino): Drop unused dir parameter.  Accomodate throughout.
	Allocate fname dynamically.  Call new stat_worker instead of lstat64.
	Call NtOpenFile instead of CreateFile.  Call NtClose instead of
	CloseHandle.
	(fhandler_disk_file::readdir_helper): Use native NT functions.
	Check for volume mount points and use correct inode number.
	(fhandler_disk_file::readdir): Simplify slightly.
	Use get_name instead of pc.normalized_path.
	(fhandler_disk_file::rewinddir): Use RtlInitUnicodeString.
	(fhandler_cygdrive::fstat): Ignore floppy drives.  Set st_nlink
	correctly.
	(fhandler_cygdrive::readdir): Ignore floppy drives.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Accommodate
	change to readdir_get_ino.
	* fhandler_proc.cc (PROC_DIR_COUNT): Define.
	(fhandler_proc::fstat): Evaluate correct link count for /proc.
	* ntdll.h (struct _FILE_DIRECTORY_INFORMATION): Define.
	(NtFsControlFile): Declare.
	(RtlAppendUnicodeToString): Declare.
	(RtlAppendUnicodeStringToString): Declare.
	(RtlCompareUnicodeString): Declare.
	(RtlCopyUnicodeString): Declare.
	(RtlCreateUnicodeStringFromAsciiz): Declare.
	(RtlEqualUnicodeString): Declare.
	(RtlFreeUnicodeString): Declare.
	(RtlInitEmptyUnicodeString): Declare.
	(RtlSecondsSince1970ToTime): Declare.
	(RtlInitEmptyUnicodeString): Define as inline function.
	(RtlInitCountedUnicodeString): Define as inline function.
	* path.cc (path_conv::check): New method with PUNICODE_STRING as path,
	preliminary implementation.
	(mount_info::get_mounts_here): Change to create UNICODE_STRINGs.
	Also copy cygpath prefix into UNICODE_STRING.
	(is_floppy): Drop 9x consideration.
	* path.h: Drop including ntdef.h.
	(path_conv::check): Add declaration.
	(path_conv::path_conv): Add constructor for UNICODE_STRING paths.
	* shared_info.h (mount_info::get_mounts_here): Change declaration.
	* syscalls.cc: Drop forward declaration of stat_worker.
	(stat_worke): Take path_conv as parameter.  Drop nofollow flag.
	(stat64): Create matching path_conv and call stat_worker with it.
	(lstat64): Ditto.
	* winsup.h: Include ntdef.h.
	(stat_worker): Declare.
	(readdir_get_ino): Change declaration.
@
text
@d428 2
a429 10
  query_open (query_stat_control);
  if (!(oret = open_fs (open_flags, 0)) && get_errno () == EACCES)
    {
      /* If we couldn't open the file, try a query open with no permissions.
	 This allows us to determine *some* things about the file, at least. */
      pc.set_exec (0);
      query_open (query_read_attributes);
      oret = open_fs (open_flags, 0);
    }

@


1.225
log
@	* fhandler.cc (fhandler_base::fhaccess): Accommodate interface changes
	of access control functions throughout.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* sec_acl.cc: Drop unnecessary includes.
	(setacl): Take path_conv instead of file name as parameter.
	Accommodate interface changes of access control functions.
	(getacl): Ditto.
	* sec_auth.cc: New file, taking over all authentication related
	functions from security.cc.
	* sec_helper.cc: Drop unnecessary includes.
	* security.cc: Ditto.  Move all authentication related functions to
	sec_auth.cc.
	(ALL_SECURITY_INFORMATION): New define.  Use throughout.
	(set_file_sd): New function, replacing read_sd and the file related
	part of get_nt_object_security.
	(get_reg_sd): Rename from get_reg_security.  Drop type parameter.
	(get_reg_attribute): New function, replacing the registry related part
	of get_nt_object_security.
	(get_file_attribute): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(set_file_attribute): Ditto plus new set_file_sd.  Drop unnecessary
	implementation without uid/gid parameters.
	(check_file_access): Take path_conv instead of file name as parameter.
	Use new get_file_sd call.
	(check_registry_access): Use new get_reg_sd call.
	* security.h: Accommodate above interface changes.
@
text
@a28 1
#include <ntdef.h>
d39 6
a44 5
  int	      count;
  const char *parent_dir;
  int	      parent_dir_len;
  char	     *mounts[MAX_MOUNTS];
  bool	      found[MAX_MOUNTS + 2];
d52 1
a52 1
      char fname[CYG_MAX_PATH];
a53 1
      int len = parent_dir_len;
d55 7
a61 5
      strcpy (fname, parent_dir);
      if (fname[len - 1] != '/')
	fname[len++] = '/';
      strcpy (fname + len, mounts[idx]);
      if (!lstat64 (fname, &st))
d71 2
a72 1
      count = mount_table->get_mounts_here (parent_dir, parent_dir_len, mounts);
d75 8
a82 1
  __ino64_t check_mount (const char *name, __ino64_t ino, bool eval = true)
d86 4
a89 1
	  if (strcasematch (name, "proc"))
d92 1
a92 1
	      return hash_path_name (0, "/proc");
d94 2
a95 3
	  if (strlen (name) == mount_table->cygdrive_len - 2
	      && strncasematch (name, mount_table->cygdrive + 1,
				mount_table->cygdrive_len - 2))
d102 1
a102 1
	if (strcasematch (name, mounts[i]))
d109 1
a109 1
  __ino64_t check_missing_mount (char *ret_name, bool eval = true)
d115 6
a120 2
	    strcpy (ret_name, mounts[i]);
	    return eval ? eval_ino (i) : 1;
d127 3
a129 2
	      strcpy (ret_name, "proc");
	      return hash_path_name (0, "/proc");
d134 1
a134 1
	      if (mount_table->cygdrive_len > 1)
d136 2
a137 3
		  strncpy (ret_name, mount_table->cygdrive + 1,
			   mount_table->cygdrive_len - 2);
		  ret_name[mount_table->cygdrive_len - 2] = '\0';
d153 11
a163 3
  int len = strlen (*this);
  char fn[len + 3];
  strcpy (fn, *this);
d165 5
a169 2
  const char *s;
  unsigned count;
d171 31
a201 10
  if (nNumberOfLinks <= 1)
    {
      s = "\\*";
      count = 0;
    }
  else
    {
      s = "\\..";
      count = nNumberOfLinks;
    }
d203 29
a231 35
  if (len == 0 || isdirsep (fn[len - 1]))
    strcpy (fn + len, s + 1);
  else
    strcpy (fn + len, s);

  WIN32_FIND_DATA buf;
  HANDLE h = FindFirstFile (fn, &buf);

  int saw_dot = 2;
  if (h != INVALID_HANDLE_VALUE)
    {
      if (nNumberOfLinks > 1)
	saw_dot--;
      else
	do
	  {
	    if (buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	      count++;
	    if (buf.cFileName[0] == '.'
		&& (buf.cFileName[1] == '\0'
		    || (buf.cFileName[1] == '.' && buf.cFileName[2] == '\0')))
	      saw_dot--;
	    dir->check_mount (buf.cFileName, 0, false);
	  }
	while (FindNextFileA (h, &buf));
      FindClose (h);
    }

  if (nNumberOfLinks > 1)
    {
      fn[len + 2] = '\0';
      h = FindFirstFile (fn, &buf);
      if (h)
	saw_dot--;
      FindClose (h);
d233 1
a233 1
  while (dir->check_missing_mount (buf.cFileName, false))
d235 1
a235 1

d237 1
a237 2

  return count + saw_dot;
d257 1
a257 1
  const DWORD fvi_size = 2 * CYG_MAX_PATH
d259 2
a260 1
  const DWORD fai_size = 2 * CYG_MAX_PATH + sizeof (FILE_ALL_INFORMATION);
d272 1
a272 1
      pfvi->VolumeSerialNumber = 0; /* Set to pc.volser () in helper. */
d285 3
a287 3
		       pfai->BasicInformation.ChangeTime.QuadPart ?
		       *(FILETIME *) &pfai->BasicInformation.ChangeTime :
		       *(FILETIME *) &pfai->BasicInformation.LastWriteTime,
a297 1

d300 1
a300 10

  /* Last resort */
  FILETIME ft = { 0, 0 };
  DWORD lowfs, highfs;

  lowfs = GetFileSize (get_handle (), &highfs);
  if (lowfs == 0xffffffff && GetLastError ())
    lowfs = highfs = 0;
  return fstat_helper (buf, ft, ft, ft, ft, 0, (ULONGLONG) highfs << 32 | lowfs,
		       -1LL, 0ULL, 1, DWORD (pc));
a305 1
  int res = -1;
d308 13
a320 1
  FILE_NETWORK_OPEN_INFORMATION fnoi;
d326 40
d367 3
a369 2
  else if (NT_SUCCESS (status = NtQueryFullAttributesFile (
			      pc.get_object_attr (attr, sec_none_nih), &fnoi)))
d371 34
a404 10
      if (pc.is_rep_symlink ())
	fnoi.FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
      pc.file_attributes (fnoi.FileAttributes);
      res = fstat_helper (buf,
			  *(FILETIME *) (fnoi.ChangeTime.QuadPart
					 ?  &fnoi.ChangeTime
					 : &fnoi.LastWriteTime),
		       *(FILETIME *) &fnoi.LastAccessTime,
		       *(FILETIME *) &fnoi.LastWriteTime,
		       *(FILETIME *) &fnoi.CreationTime,
d406 2
a407 2
		       fnoi.EndOfFile.QuadPart,
		       fnoi.AllocationSize.QuadPart,
d410 1
a410 14
		       fnoi.FileAttributes);
    }
  else if (pc.isdir ())
    {
      FILETIME ft = {};
      res = fstat_helper (buf, ft, ft, ft, ft, pc.volser (), 0ULL, -1LL, 0ULL,
			  1, FILE_ATTRIBUTE_DIRECTORY);
    }
  else
    {
      __seterrno_from_nt_status (status);
      res = -1;
    }
  return res;
d422 5
a426 4
      if (nohandle () || is_fs_special ())
	return fstat_by_name (buf);
      else
	return fstat_by_handle (buf);
d451 1
a451 1
  else
d487 1
a487 1
  buf->st_dev = dwVolumeSerialNumber ?: pc.volser ();
d851 1
a851 2
		    if (!(oret = open (O_BINARY, 0)))
		      return -1;
d853 2
a854 1
		if (!fstat_by_handle (&st))
d1580 1
a1580 1
   the size of the readdir cache is DIR_NUM_ENTRIES * 632 + 264 bytes.  */
d1582 1
a1582 1
#define DIR_NUM_ENTRIES	100		/* Cache size 63464 bytes */
d1586 1
a1586 1
			    + 2 * CYG_MAX_PATH))
a1589 1
  char  __name[CYG_MAX_PATH];
a1593 1
#define d_dirname(d)	(((__DIR_cache *) (d)->__d_dirname)->__name)
a1603 1
  size_t len;
a1606 2
  else if ((len = strlen (pc)) > CYG_MAX_PATH - 3)
    set_errno (ENAMETOOLONG);
a1622 2
      strcpy (d_dirname (dir), get_win32_name ());
      dir->__d_dirent->__d_version = __DIRENT_VERSION;
a1623 1

d1627 1
a1627 9
      /* FindFirstFile doesn't seem to like duplicate /'s.
	 The dirname is generated with trailing backslash here which
	 simplifies later usage of dirname for checking symlinks.
	 Appending a "*" is moved right before calling FindFirstFile.
	 Since FindFirstFile is only called once, this should even be a
	 teeny little bit faster. */
      len = strlen (d_dirname (dir));
      if (len && !isdirsep (d_dirname (dir)[len - 1]))
	strcpy (d_dirname (dir) + len, "\\");
d1631 1
a1631 3

      dir->__flags = (pc.normalized_path[0] == '/'
		      && pc.normalized_path[1] == '\0')
d1633 1
a1633 1
      dir->__d_internal = (unsigned) new __DIR_mounts (pc.normalized_path);
a1707 44
int
fhandler_disk_file::readdir_helper (DIR *dir, dirent *de, DWORD w32_err,
				    DWORD attr, char *fname)
{
  if (w32_err)
    {
      bool added = false;
      if ((de->d_ino = d_mounts (dir)->check_missing_mount (fname)))
	added = true;
      if (!added)
	return geterrno_from_win_error (w32_err);

      attr = 0;
      dir->__flags &= ~dirent_set_d_ino;
    }

  /* Check for Windows shortcut. If it's a Cygwin or U/WIN
     symlink, drop the .lnk suffix. */
  if (attr & FILE_ATTRIBUTE_READONLY)
    {
      char *c = fname;
      char *e = strchr (fname, '\0') - 4;
      if (e > c && strcasematch (e, ".lnk"))
	{
	  char fbuf[CYG_MAX_PATH];
	  strcpy (fbuf, d_dirname (dir));
	  strcat (fbuf, c);
	  path_conv fpath (fbuf, PC_SYM_NOFOLLOW);
	  if (fpath.issymlink () || fpath.is_fs_special ())
	    *e = '\0';
	}
    }

  if (pc.isencoded ())
    fnunmunge (de->d_name, fname);
  else
    strcpy (de->d_name, fname);
  if (dir->__d_position == 0 && !strcmp (fname, "."))
    dir->__flags |= dirent_saw_dot;
  else if (dir->__d_position == 1 && !strcmp (fname, ".."))
    dir->__flags |= dirent_saw_dot_dot;
  return 0;
}

d1721 1
a1721 1
readdir_get_ino (DIR *dir, const char *path, bool dot_dot)
d1723 1
a1723 1
  char fname[CYG_MAX_PATH];
d1726 2
a1729 1
  strcpy (fname, path);
d1731 9
a1739 3
    strcat (fname, (*fname && fname[strlen (fname) - 1] == '/')
		   ? ".." : "/..");
  path_conv pc (fname, PC_SYM_NOFOLLOW);
d1742 1
a1742 1
      if (!lstat64 (fname, &st))
d1747 4
a1750 4
  else if ((hdl = CreateFile (pc, GENERIC_READ, FILE_SHARE_VALID_FLAGS,
			      NULL, OPEN_EXISTING,
			      FILE_FLAG_BACKUP_SEMANTICS, NULL))
	   != INVALID_HANDLE_VALUE)
d1753 1
a1753 1
      CloseHandle (hdl);
d1759 98
d1862 1
a1862 2
  wchar_t *FileName;
  char fname[CYG_MAX_PATH];
d1864 1
d1959 2
a1960 3
      sys_wcstombs (fname, CYG_MAX_PATH - 1, FileName, buf->FileNameLength / 2);

      de->d_ino = d_mounts (dir)->check_mount (fname, de->d_ino);
d1969 1
a1969 1
		   && FileName[0] == '.' && FileName[1] == '.')
d1971 1
a1971 1
	      de->d_ino = readdir_get_ino (dir, pc.normalized_path, true);
d1977 6
a1982 7
	      UNICODE_STRING upath = {buf->FileNameLength, CYG_MAX_PATH * 2,
				      FileName};
	      InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE,
					  get_handle () , NULL);
	      if (!NtOpenFile (&hdl, READ_CONTROL, &attr, &io,
			       FILE_SHARE_VALID_FLAGS,
			       FILE_OPEN_FOR_BACKUP_INTENT))
d1985 1
a1985 1
		  CloseHandle (hdl);
d1998 1
a1998 1
			      buf ? buf->FileAttributes : 0, fname)))
d2012 1
a2012 1
	de->d_ino = readdir_get_ino (dir, pc.normalized_path, true);
d2049 1
a2049 1
      UNICODE_STRING fname = {0, CYG_MAX_PATH * 2, (WCHAR *) L""};
d2055 1
d2143 1
a2143 1
  buf->st_mode = S_IFDIR | 0555;
d2145 10
a2154 1
  buf->st_nlink = 1;
d2173 2
d2187 2
a2188 1
      if (GetFileAttributes (pdrive) != INVALID_FILE_ATTRIBUTES)
d2194 2
a2195 1
  de->d_ino = readdir_get_ino (dir, pdrive, false);
@


1.224
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_name): Use
	NtQueryFullAttributesFile instead of FindFirstFile.
	(fhandler_base::fstat_fs): Drop check for exec_state.  Drop check for
	invalid characters.
	* ntdll.h (struct _FILE_NETWORK_OPEN_INFORMATION): Define.
	(NtQueryFullAttributesFile): Declare.
@
text
@d436 2
a437 2
      get_file_attribute (pc.has_acls (), get_io_handle (), get_win32_name (),
			  NULL, &buf->st_uid, &buf->st_gid);
d443 2
a444 4
  if (!get_file_attribute (pc.has_acls (),
			   is_fs_special () ? NULL: get_io_handle (),
			   get_win32_name (), &buf->st_mode,
			   &buf->st_uid, &buf->st_gid))
d661 1
a661 1
      if (!set_file_attribute (pc.has_acls (), get_io_handle (), pc,
d707 1
a707 1
  int res = get_file_attribute (pc.has_acls (), get_io_handle (), pc, &attrib);
d719 1
a719 2
      res = set_file_attribute (pc.has_acls (), get_io_handle (), pc,
				uid, gid, attrib);
d808 1
a808 1
	      res = getacl (get_io_handle (), pc, pc, nentries, aclbufp);
d811 1
a811 1
	    res = getacl (get_io_handle (), pc, pc, 0, NULL);
@


1.223
log
@	* fhandler.cc (fhandler_base::open): Drop local wpath and upath
	variables.  Call pc.get_object_attr to create object attributes.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
	* syscalls.cc (unlink_nt): Ditto.
	* path.cc (path_conv::set_normalized_path): Set wide_path to NULL.
	(path_conv::get_nt_native_path): Drop parameter.  Create path in
	wide_path/uni_path members.
	(path_conv::get_object_attr): New method to create object attributes.
	(path_conv::get_wide_win32_path): New method to create Win32 wide path.
	(path_conv::check): Initialize wide_path to NULL.
	(path_conv::~path_conv): cfree wide_path.
	* path.h (class path_conv): New members wide_path and uni_path.
	Add declarations of get_object_attr and get_wide_win32_path.
	(path_conv::path_conv): Initialize wide_path to NULL.
	(path_conv::get_nt_native_path): Drop parameter.
@
text
@d275 4
a278 3
  int res;
  HANDLE handle;
  WIN32_FIND_DATA local;
a283 1
      res = -1;
d285 2
a286 1
  else if ((handle = FindFirstFile (pc, &local)) != INVALID_HANDLE_VALUE)
a287 1
      FindClose (handle);
d289 2
a290 2
	local.dwFileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
      pc.file_attributes (local.dwFileAttributes);
d292 12
a303 11
			  local.ftLastWriteTime, /* see fstat_helper comment */
			  local.ftLastAccessTime,
			  local.ftLastWriteTime,
			  local.ftCreationTime,
			  pc.volser (),
			  (ULONGLONG) local.nFileSizeHigh << 32
				      | local.nFileSizeLow,
			  -1LL,
			  0ULL,
			  1,
			  local.dwFileAttributes);
d313 1
a313 2
      debug_printf ("FindFirstFile failed for '%s', %E", (char *) pc);
      __seterrno ();
d333 1
a333 8
  /* If we don't care if the file is executable or we already know if it is,
     then just do a "query open" as it is apparently much faster. */
  if (pc.exec_state () != dont_know_if_executable)
    {
      if (pc.fs_is_fat () && !strpbrk (get_win32_name (), "?*|<>"))
	return fstat_by_name (buf);
      query_open (query_stat_control);
    }
@


1.222
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Move setting
	cfd->nohandle where it won't crash.
@
text
@a1577 3
	      WCHAR wpath[CYG_MAX_PATH + 10] = { 0 };
	      UNICODE_STRING upath = {0, sizeof (wpath), wpath};
	      SECURITY_ATTRIBUTES sa = sec_none;
a1578 3
	      pc.get_nt_native_path (upath);
	      InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE,
					  NULL, sa.lpSecurityDescriptor);
d1581 2
a1582 1
				   &attr, &io, FILE_SHARE_VALID_FLAGS,
@


1.221
log
@	* dir.cc (closedir): Revert change from 2007-06-29.
	* fhandler.h (dirent_valid_fd): Drop.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): If opening a
	real dir, use the underlying fhandler to keep track of the directory
	handle.  In fdopendir case use original io_handle from fhandler.  Use
	fhandler's io_handle in subsequent directory functions throughout.
	Create handle non-inheritable and set close-on-exec flag.
	(readdir_get_ino): Drop dirent_isroot case.
	(fhandler_disk_file::readdir): Handle dirent_isroot case here.
	(fhandler_disk_file::rewinddir): Revert change from 2007-07-05.  Use
	NtClose instead of CloseHandle.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Drop adding
	dirent_valid_fd flag.  Set close-on-exec flag.
@
text
@d1569 1
a1569 3
      if (pc.iscygdrive ())
        cfd->nohandle (true);
      else
d1624 2
@


1.220
log
@* fhandler_disk_file.cc: White space.
* fhandler_proc.cc: Ditto.
* fhandler_virtual.cc: Ditto.
@
text
@d1569 3
a1571 1
      if (!pc.iscygdrive ())
d1573 1
a1573 16
	  OBJECT_ATTRIBUTES attr;
	  NTSTATUS status;
	  IO_STATUS_BLOCK io;
	  WCHAR wpath[CYG_MAX_PATH + 10] = { 0 };
	  UNICODE_STRING upath = {0, sizeof (wpath), wpath};
	  SECURITY_ATTRIBUTES sa = sec_none;

	  if (fd >= 0 && get_handle ())
	    {
	      /* fdopendir() case.  Just initialize with the emtpy upath
		 and reuse the exisiting handle. */
	      InitializeObjectAttributes (&attr, &upath,
					  OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
					  get_handle (), NULL);
	    }
	  else
d1577 7
d1585 1
a1585 2
	      InitializeObjectAttributes (&attr, &upath,
					  OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
d1587 11
a1597 11
	    }
	  status = NtOpenFile (&dir->__handle,
			       SYNCHRONIZE | FILE_LIST_DIRECTORY,
			       &attr, &io, FILE_SHARE_VALID_FLAGS,
			       FILE_SYNCHRONOUS_IO_NONALERT
			       | FILE_OPEN_FOR_BACKUP_INTENT
			       | FILE_DIRECTORY_FILE);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      goto free_mounts;
d1616 1
a1616 4
	{
	  dir->__flags |= dirent_valid_fd;
	  dir->__d_fd = fd;
	}
a1624 1
	  cfd->nohandle (true);
d1627 1
d1710 16
a1725 1
  if (!(dir->__flags & dirent_isroot))
d1727 2
a1728 20
      strcpy (fname, path);
      if (dot_dot)
	strcat (fname, (*fname && fname[strlen (fname) - 1] == '/')
		       ? ".." : "/..");
      path_conv pc (fname, PC_SYM_NOFOLLOW);
      if (pc.isspecial ())
	{
	  if (!lstat64 (fname, &st))
	    ino = st.st_ino;
	}
      else if (!pc.hasgood_inode ())
	ino = hash_path_name (0, pc);
      else if ((hdl = CreateFile (pc, GENERIC_READ, FILE_SHARE_VALID_FLAGS,
				  NULL, OPEN_EXISTING,
				  FILE_FLAG_BACKUP_SEMANTICS, NULL))
	       != INVALID_HANDLE_VALUE)
	{
	  ino = readdir_get_ino_by_handle (hdl);
	  CloseHandle (hdl);
	}
a1729 2
  else
    ino = readdir_get_ino_by_handle (dir->__handle);
d1749 1
a1749 1
	  status = NtQueryDirectoryFile (dir->__handle, NULL, NULL, 0, &io,
d1792 1
a1792 1
		      status = NtQueryDirectoryFile (dir->__handle, NULL, NULL,
d1810 1
a1810 1
	status = NtQueryDirectoryFile (dir->__handle, NULL, NULL, 0, &io,
d1845 1
a1845 1
	    de->d_ino = readdir_get_ino_by_handle (dir->__handle);
d1848 4
a1851 1
	    de->d_ino = readdir_get_ino (dir, pc.normalized_path, true);
d1858 1
a1858 1
					  dir->__handle , NULL);
d1882 1
a1882 1
      de->d_ino = readdir_get_ino_by_handle (dir->__handle);
d1890 4
a1893 1
      de->d_ino = readdir_get_ino (dir, pc.normalized_path, true);
d1934 2
a1935 3
      InitializeObjectAttributes (&attr, &fname,
				  OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
				  dir->__handle, NULL);
d1947 2
a1948 2
	  CloseHandle (dir->__handle);
	  dir->__handle = new_dir;
d1962 1
a1962 1
  if (!dir->__handle)
d1964 1
a1964 1
  else if (dir->__handle == INVALID_HANDLE_VALUE)
d1969 1
a1969 1
  else if (!NT_SUCCESS (status = NtClose (dir->__handle)))
@


1.219
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Add missing
	OBJ_INHERIT flag when creating OBJECT_ATTRIBUTES.
	(fhandler_disk_file::rewinddir): Ditto.
@
text
@d561 2
a562 2
        {
          /* Can't open file.  Try again with rootdir. */
d598 1
a598 1
  					 sizeof full_fsi,
d608 1
a608 1
        {
d1589 1
a1589 1
	         NULL directory handle. */
d1623 1
a1623 1
        {
d1628 1
a1628 1
        {
@


1.218
log
@	* cygwin.din: Export fdopendir.
	* dir.cc (opendir): Call fhandler's opendir with fd set to -1.
	(fdopendir): New function.
	(seekdir64): Use dirent_info_mask.
	(rewinddir): Ditto.
	(closedir): Only release underlying file descriptor if it has been
	reserved by opendir itself.
	* fhandler.cc (fhandler_base::opendir): Accommodate new parameter.
	* fhandler.h (dirent_states): Add dirent_valid_fd and dirent_info_mask.
	(fhander_XXX::opendir): Add file descriptor parameter.  Use regparms.
	(fhandler_procnet::opendir): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
	If called from fdopendir, use existing handle to re-open directory
	with valid flags.  Rename fd to cfd.  Use only if no valid incoming fd.
	(fhandler_cygdrive::opendir): Accommodate new parameter.
	* fhandler_process.cc (fhandler_process::opendir): Ditto.
	* fhandler_procnet.cc (fhandler_procnet::opendir): Drop definition.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Accommodate new
	parameter.  Only create new file descriptor entry if called from
	opendir.  Remove duplicated setting of dir->__flags.
	* posix.sgml: Add fdopendir to list of implemented Solaris functions.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/dirent.h: Declare fdopendir.
@
text
@d1582 2
a1583 1
	      InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE,
d1943 2
a1944 1
      InitializeObjectAttributes (&attr, &fname, OBJ_CASE_INSENSITIVE,
@


1.217
log
@	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.
@
text
@d1517 1
a1517 1
fhandler_disk_file::opendir ()
d1545 1
a1545 1
      cygheap_fdnew fd;
d1547 1
a1547 1
      if (fd < 0)
d1572 3
a1574 1
	  WCHAR wpath[CYG_MAX_PATH + 10];
a1575 2
	  IO_STATUS_BLOCK io;
	  NTSTATUS status;
d1577 17
a1593 4
	  pc.get_nt_native_path (upath);
	  InitializeObjectAttributes (&attr, &upath,
				      OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
				      NULL, sa.lpSecurityDescriptor);
d1621 16
a1636 7
      /* Filling fd with `this' (aka storing this in the file descriptor table
	 should only happen after it's clear that opendir doesn't fail,
	 otherwise we end up cfree'ing the fhandler twice, once in opendir()
	 in dir.cc, the second time on exit.  Nasty, nasty... */
      fd = this;
      fd->nohandle (true);
      dir->__d_fd = fd;
d2036 1
a2036 1
fhandler_cygdrive::opendir ()
d2040 1
a2040 1
  dir = fhandler_disk_file::opendir ();
@


1.216
log
@	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Set new stat member
	st_birthtim to useful value.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Take
	additional parameter for creation time.  Fill st_birthtim with it.
	Accomodate additional creation time parameter throughout.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Set new stat member
	st_birthtim to useful value.
	* fhandler.cc (fhandler_base::fstat): Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Ditto.
	* include/cygwin/version.h: Bump API minor number.
	* include/cygwin/stat.h (struct __stat64): Replace st_spare4 with
	timestruc_t st_birthtim.
	(struct stat): Ditto if __CYGWIN_USE_BIG_TYPES__ is defined.
	(st_birthtime): Define if __CYGWIN_USE_BIG_TYPES__ is defined.
@
text
@d496 1
d501 3
a503 3
	      cur = SetFilePointer (get_handle (), 0, NULL, FILE_CURRENT);
	      if (cur != INVALID_SET_FILE_POINTER
		  && (!cur || SetFilePointer (get_handle (), 0, NULL, FILE_BEGIN)
d514 1
a514 1
		  SetFilePointer (get_handle (), cur, NULL, FILE_BEGIN);
@


1.215
log
@* Makefile (DLL_OFILES): Remove ntea.o
* environ.cc (set_ntea): Delete.
(parse_thing): Delete "ntea" setting.
* fhandler.cc (fhandler_base::open): Remove allow_ntea considerations.
(check_posix_perm): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Ditto.
(fhandler_base::open_fs): Ditto.
(fhandler_disk_file::mkdir): Ditto.
* path.cc (symlink_worker): Ditto.
* security.cc (get_file_attribute): Ditto.
(set_file_attribute): Ditto.
* security.h: Remove allow_ntea declaration.
@
text
@d249 1
d268 1
a268 1
  return fstat_helper (buf, ft, ft, ft, 0, (ULONGLONG) highfs << 32 | lowfs,
d295 1
d307 2
a308 2
      res = fstat_helper (buf, ft, ft, ft, pc.volser (), 0ULL, -1LL, 0ULL, 1,
			  FILE_ATTRIBUTE_DIRECTORY);
d384 1
d398 1
@


1.214
log
@	* fhandler.cc(fhandler_base::open): Open with READ_CONTROL only in
	case of query_open flag set to query_read_control.  Add case for
	new query_read_attributes flag.
	(fhandler_base::fstatvfs): New method.
	* fhandler.h (enum query_state): Add query_read_attributes flag.
	(class fhandler_base): Declare new virtual fstatvfs method.
	(class fhandler_socket): Ditto.
	(class fhandler_pipe): Ditto.
	(class fhandler_fifo): Ditto.
	(class fhandler_disk_file): Ditto.
	(class fhandler_virtual): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Open with
	query_read_attributes instead of query_read_control.
	(fhandler_disk_file::fstatvfs): New method.
	(fhandler_disk_file::facl): Open with query_read_attributes instead of
	query_read_control.
	* fhandler_fifo.cc (fhandler_fifo::fstatvfs): New method.
	* fhandler_socket.cc (fhandler_socket::fstatvfs): New method.
	(fhandler_socket::fchmod): Return with EBADF in the default case.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::fstatvfs): Ditto.
	* ntdll.h (struct _FILE_FS_ATTRIBUTE_INFORMATION): Define.
	(struct _FILE_FS_FULL_SIZE_INFORMATION): Define.
	* pipe.cc (fhandler_pipe::fstatvfs): New method.
	* syscalls.cc (fstatvfs): Just call the fhandler's fstatvfs.
	(statvfs): Ditto.
	(fstatfs): Call fstatvfs.
	(statfs): Drop EFAULT handling.
@
text
@d656 1
a656 1
	  if ((allow_ntsec && pc.has_acls ()) || allow_ntea)
d661 1
a661 1
  if ((allow_ntsec && pc.has_acls ()) || allow_ntea)
a662 2
      if (!allow_ntsec && allow_ntea) /* Not necessary when manipulating SD. */
	SetFileAttributes (pc, (DWORD) pc & ~FILE_ATTRIBUTE_READONLY);
a1209 8
  /* Attributes may be set only if a file is _really_ created.
     This code is now only used for ntea here since the files
     security attributes are set in CreateFile () now. */
  if (flags & O_CREAT
      && GetLastError () != ERROR_ALREADY_EXISTS
      && !allow_ntsec && allow_ntea)
    set_file_attribute (false, NULL, get_win32_name (), mode);

a1427 3
      if (!allow_ntsec && allow_ntea)
	set_file_attribute (false, NULL, get_win32_name (),
			    S_IFDIR | ((mode & 07777) & ~cygheap->umask));
@


1.213
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop comment.
	* mmap.cc (gen_access): Remove.
	(mmap_record::gen_access): Remove.
	(mmap64): Don't mention 9x any longer.
	* syscalls.cc (statvfs): Drop status code consideration for 9x.
	* libc/minires-os-if.c (get_registry_dns_items): Don't mention 9x any
	longer.
	(get_registry_dns): Drop getting registry key on 9x.  Drop is9x
	variable.
@
text
@d17 1
d344 1
a344 1
      query_open (query_read_control);
d535 105
d762 1
a762 1
		    query_open (query_read_control);
d796 1
a796 1
	  query_open (cmd == SETACL ? query_write_control : query_read_control);
@


1.212
log
@	* fhandler.cc (fhandler_base::lseek): Drop 9x considerations.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Ditto.
	* wincap.cc: Remove lock_file_highword and has_64bit_file_access
	throughout.
	* wincap.h: Ditto.
@
text
@a542 1
  /* Also open on 9x, otherwise we can't touch ctime. */
@


1.211
log
@	* cygheap.h (struct cwdstuff): Remove sync member and keep_in_sync
	accessors.
	* external.cc (cygwin_internal): Drop call to cygheap->cwd.keep_in_sync.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Always presume
	ability to create hard links.
	* path.cc (cwdstuff::init): Drop 9x considerations.
	(cwdstuff::keep_in_sync): Remove.
	(cwdstuff::set): Take NT for granted.
	* pinfo.h (cygwin_pid): Just return pid.
	* wincap.cc: Remove has_hard_links, can_open_directories,
	has_negative_pids, has_named_pipes, has_try_enter_critical_section,
	cant_debug_dll_entry and detect_win16_exe throughout.
	* wincap.h: Ditto.
@
text
@d1267 1
a1267 5
      /* CV, 2003-12-03: And yet another Win 9x bugginess.  For some reason
	 offset + length must be <= 0x100000000.  I'm using 0xffffffff as
	 upper border here, this should be sufficient. */
      len_low = UINT32_MAX - (wincap.lock_file_highword () ? 0 : off_low);
      len_high = wincap.lock_file_highword ();
@


1.210
log
@	* fhandler.cc (fhandler_base::set_no_inheritance): Always use
	SetHandleInformation.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Always use
	UnlockFileEx/LockFileEx functions.
	* net.cc (fdsock): Don't bother to duplicate socket for inheritance.
	* sysconf.cc (get_nproc_values): Take NT for granted.
	(get_avphys): Ditto.
	* syslog.cc (WIN95_EVENT_LOG_PATH): Remove define.
	(get_win95_event_log_path): Remove.
	(vsyslog): Fix formatting.  Take NT for granted.
	* wincap.cc: Remove has_lock_file_ex, has_signal_object_and_wait,
	has_eventlog, has_set_handle_information,
	has_set_handle_information_on_console_handles and supports_smp
	throughout.
	* wincap.h: Ditto.
@
text
@d886 15
a900 2
  /* Try to make hard link first on Windows NT */
  if (wincap.has_hard_links ())
d902 5
a906 21
      if (CreateHardLinkA (newpc, pc, NULL))
	goto success;

      /* There are two cases to consider:
	 - The FS doesn't support hard links ==> ERROR_INVALID_FUNCTION
	   We copy the file.
	 - CreateHardLinkA is not supported  ==> ERROR_PROC_NOT_FOUND
	   In that case (<= NT4) we try the old-style method.
	 Any other error should be taken seriously. */
      if (GetLastError () == ERROR_INVALID_FUNCTION)
	{
	  syscall_printf ("FS doesn't support hard links: Copy file");
	  goto docopy;
	}
      if (GetLastError () != ERROR_PROC_NOT_FOUND)
	{
	  syscall_printf ("CreateHardLinkA failed");
	  __seterrno ();
	  close ();
	  return -1;
	}
d908 26
a933 19
      WIN32_STREAM_ID stream_id;
      LPVOID context;
      WCHAR wbuf[CYG_MAX_PATH];
      BOOL ret;
      DWORD written, write_err, path_len, size;

      path_len = sys_mbstowcs (wbuf, newpc, CYG_MAX_PATH) * sizeof (WCHAR);

      stream_id.dwStreamId = BACKUP_LINK;
      stream_id.dwStreamAttributes = 0;
      stream_id.dwStreamNameSize = 0;
      stream_id.Size.HighPart = 0;
      stream_id.Size.LowPart = path_len;
      size = sizeof (WIN32_STREAM_ID) - sizeof (WCHAR**)
	     + stream_id.dwStreamNameSize;
      context = NULL;
      write_err = 0;
      /* Write WIN32_STREAM_ID */
      ret = BackupWrite (get_handle (), (LPBYTE) &stream_id, size,
d935 1
a935 17
      if (ret)
	{
	  /* write the buffer containing the path */
	  /* FIXME: BackupWrite sometimes traps if linkname is invalid.
	     Need to handle. */
	  ret = BackupWrite (get_handle (), (LPBYTE) wbuf, path_len,
			     &written, FALSE, FALSE, &context);
	  if (!ret)
	    {
	      write_err = GetLastError ();
	      syscall_printf ("cannot write linkname, %E");
	    }
	  /* Free context */
	  BackupWrite (get_handle (), NULL, 0, &written,
		       TRUE, FALSE, &context);
	}
      else
d938 1
a938 1
	  syscall_printf ("cannot write stream_id, %E");
d940 9
d950 4
a953 1
      if (!ret)
d955 2
a956 10
	  /* Only copy file if FS doesn't support hard links */
	  if (write_err == ERROR_INVALID_FUNCTION)
	    {
	      syscall_printf ("FS doesn't support hard links: Copy file");
	      goto docopy;
	    }

	  close ();
	  __seterrno_from_win_error (write_err);
	  return -1;
a958 1
    success:
d960 2
a961 5
      if (!allow_winsymlinks && pc.is_lnk_special ())
	SetFileAttributes (newpc, (DWORD) pc
				   | FILE_ATTRIBUTE_SYSTEM
				   | FILE_ATTRIBUTE_READONLY);
      return 0;
d963 9
@


1.209
log
@	Throughout remove all usage of wincap.access_denied_on_delete.
	* dir.cc (rmdir): Add existance check to be errno-compatible with Linux.
	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Drop test for
	non-existent dir on 9x share.
	* syscalls.cc (unlink): Add comment.
	* wincap.cc: Remove access_denied_on_delete flag throughout.
	* wincap.h: Ditto.
@
text
@d1284 2
a1285 6
  if (wincap.has_lock_file_ex ())
    {
      DWORD lock_flags = (cmd == F_SETLK) ? LOCKFILE_FAIL_IMMEDIATELY : 0;
      lock_flags |= (fl->l_type == F_WRLCK) ? LOCKFILE_EXCLUSIVE_LOCK : 0;

      OVERLAPPED ov;
d1287 1
a1287 5
      ov.Internal = 0;
      ov.InternalHigh = 0;
      ov.Offset = off_low;
      ov.OffsetHigh = off_high;
      ov.hEvent = (HANDLE) 0;
d1289 11
a1299 22
      if (fl->l_type == F_UNLCK)
	{
	  res = UnlockFileEx (get_handle (), 0, len_low, len_high, &ov);
	  if (res == 0 && GetLastError () == ERROR_NOT_LOCKED)
	    res = 1;
	}
      else
	{
	  res = LockFileEx (get_handle (), lock_flags, 0,
			    len_low, len_high, &ov);
	  /* Deal with the fail immediately case. */
	  /*
	   * FIXME !! I think this is the right error to check for
	   * but I must admit I haven't checked....
	   */
	  if ((res == 0) && (lock_flags & LOCKFILE_FAIL_IMMEDIATELY) &&
			    (GetLastError () == ERROR_LOCK_FAILED))
	    {
	      set_errno (EAGAIN);
	      return -1;
	    }
	}
d1303 13
a1315 5
      /* Windows 95 -- use primitive lock call */
      if (fl->l_type == F_UNLCK)
	res = UnlockFile (get_handle (), off_low, off_high, len_low, len_high);
      else
	res = LockFile (get_handle (), off_low, off_high, len_low, len_high);
@


1.208
log
@	* fhandler_disk_file.cc (fhandler_disk_file::closedir): Fix bug
	introduced by switching to NtClose.
@
text
@a1406 10
  /* On 9X ERROR_ACCESS_DENIED is returned if you try to remove a
     non-empty directory. */
  if (err == ERROR_ACCESS_DENIED
      && wincap.access_denied_on_delete ())
    err = ERROR_DIR_NOT_EMPTY;
  /* ...and, that's *not* funny, when trying to remove a non-existing
     directory on a share, which is hosted by a 9x machine, the error
     code ERROR_INVALID_FUNCTION is returned.  */
  else if (err == ERROR_INVALID_FUNCTION)
    err = ERROR_FILE_NOT_FOUND;
@


1.207
log
@	Throughout replace all usage of wincap.shared with the constant
	FILE_SHARE_VALID_FLAGS.
	* fhandler.cc (fhandler_base::open_9x): Drop local variable shared.
	* wincap.cc: Remove shared member throughout.
	* wincap.h: Ditto.
@
text
@d1876 2
d1886 1
a1886 1
  else if (!NtClose (dir->__handle))
d1888 1
a1888 1
      __seterrno ();
@


1.206
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@d1514 1
a1514 1
			       &attr, &io, wincap.shared (),
d1642 4
a1645 3
      else if ((hdl = CreateFile (pc, GENERIC_READ, wincap.shared (), NULL,
				  OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS,
				  NULL)) != INVALID_HANDLE_VALUE)
d1780 2
a1781 1
			       wincap.shared (), FILE_OPEN_FOR_BACKUP_INTENT))
d1854 1
a1854 1
			   &attr, &io, wincap.shared (),
@


1.205
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d213 10
a222 1
  BY_HANDLE_FILE_INFORMATION local;
d224 3
a226 1
  if (wincap.is_winnt ())
d228 1
a228 44
      NTSTATUS status;
      IO_STATUS_BLOCK io;
      /* The entries potentially contain a name of MAX_PATH wide characters. */
      const DWORD fvi_size = 2 * CYG_MAX_PATH
			     + sizeof (FILE_FS_VOLUME_INFORMATION);
      const DWORD fai_size = 2 * CYG_MAX_PATH + sizeof (FILE_ALL_INFORMATION);

      PFILE_FS_VOLUME_INFORMATION pfvi = (PFILE_FS_VOLUME_INFORMATION)
					 alloca (fvi_size);
      PFILE_ALL_INFORMATION pfai = (PFILE_ALL_INFORMATION) alloca (fai_size);

      status = NtQueryVolumeInformationFile (get_handle (), &io, pfvi, fvi_size,
					     FileFsVolumeInformation);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("%u = NtQueryVolumeInformationFile)",
			RtlNtStatusToDosError (status));
	  pfvi->VolumeSerialNumber = 0; /* Set to pc.volser () in helper. */
	}
      status = NtQueryInformationFile (get_handle (), &io, pfai, fai_size,
				       FileAllInformation);
      if (NT_SUCCESS (status))
	{
	  /* If the change time is 0, it's a file system which doesn't
	     support a change timestamp.  In that case use the LastWriteTime
	     entry, as in other calls to fstat_helper. */
	  if (pc.is_rep_symlink ())
	    pfai->BasicInformation.FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
	  pc.file_attributes (pfai->BasicInformation.FileAttributes);
	  return fstat_helper (buf,
			   pfai->BasicInformation.ChangeTime.QuadPart ?
			   *(FILETIME *) &pfai->BasicInformation.ChangeTime :
			   *(FILETIME *) &pfai->BasicInformation.LastWriteTime,
			   *(FILETIME *) &pfai->BasicInformation.LastAccessTime,
			   *(FILETIME *) &pfai->BasicInformation.LastWriteTime,
			   pfvi->VolumeSerialNumber,
			   pfai->StandardInformation.EndOfFile.QuadPart,
			   pfai->StandardInformation.AllocationSize.QuadPart,
			   pfai->InternalInformation.FileId.QuadPart,
			   pfai->StandardInformation.NumberOfLinks,
			   pfai->BasicInformation.FileAttributes);
	}

      debug_printf ("%u = NtQueryInformationFile)",
d230 1
d232 7
a238 18

  BOOL res = GetFileInformationByHandle (get_handle (), &local);
  debug_printf ("%d = GetFileInformationByHandle (%s, %d)",
		res, get_win32_name (), get_handle ());
  /* GetFileInformationByHandle will fail if it's given stdio handle or pipe.
     It also fails on 9x when trying to access directories on shares. */
  if (!res)
    {
      memset (&local, 0, sizeof (local));
      local.nFileSizeLow = GetFileSize (get_handle (), &local.nFileSizeHigh);
      /* Even GetFileSize fails on 9x when trying to access directories
	 on shares. In this case reset filesize to 0. */
      if (local.nFileSizeLow == 0xffffffff && GetLastError ())
	local.nFileSizeLow = 0;
      local.dwFileAttributes = DWORD (pc);
    }
  else
    {
d240 28
a267 15
	local.dwFileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
      pc.file_attributes (local.dwFileAttributes);
    }
  return fstat_helper (buf,
		       local.ftLastWriteTime, /* see fstat_helper comment */
		       local.ftLastAccessTime,
		       local.ftLastWriteTime,
		       local.dwVolumeSerialNumber,
		       (ULONGLONG) local.nFileSizeHigh << 32
				   | local.nFileSizeLow,
		       -1LL,
		       (ULONGLONG) local.nFileIndexHigh << 32
				   | local.nFileIndexLow,
		       local.nNumberOfLinks,
		       local.dwFileAttributes);
a529 3
  /* Changing inode data requires setting ctime (only 9x). */
  if (has_changed ())
    touch_ctime ();
a532 14
void
fhandler_disk_file::touch_ctime ()
{
  FILETIME ft;

  GetSystemTimeAsFileTime (&ft);
  /* Modification time is touched if the file data has changed as well.
     This happens for instance on write() or ftruncate(). */
  if (!SetFileTime (get_io_handle (), NULL, NULL, &ft))
    debug_printf ("SetFileTime (%s) failed, %E", get_win32_name ());
  else
    has_changed (false);
}

a579 4
  /* Set ctime on success. */
  if (!res && !wincap.is_winnt ())
    has_changed (true);

a735 3
  if (!wincap.is_winnt ())
    return 0;

d785 4
d797 19
a815 28
      if (wincap.is_winnt ())
	{
	  NTSTATUS status;
	  IO_STATUS_BLOCK io;
	  FILE_END_OF_FILE_INFORMATION feofi;

	  feofi.EndOfFile.QuadPart = length;
	  /* Create sparse files only when called through ftruncate, not when
	     called through posix_fallocate. */
	  if (allow_truncate
	      && get_fs_flags (FILE_SUPPORTS_SPARSE_FILES)
	      && length >= actual_length + (128 * 1024))
	    {
	      DWORD dw;
	      BOOL r = DeviceIoControl (get_handle (),
					FSCTL_SET_SPARSE, NULL, 0, NULL,
					0, &dw, NULL);
	      syscall_printf ("%d = DeviceIoControl(%p, FSCTL_SET_SPARSE)",
				  r, get_handle ());
	    }
	  status = NtSetInformationFile (get_handle (), &io,
					 &feofi, sizeof feofi,
					 FileEndOfFileInformation);
	  if (!NT_SUCCESS (status))
	    __seterrno_from_nt_status (status);
	  else
	    res = 0;
	}
d817 1
a817 14
	{
	  _off64_t prev_loc = lseek (0, SEEK_CUR);
	  if (lseek (length, SEEK_SET) >= 0)
	    {
	      int res_bug = write (&res, 0);
	      if (!SetEndOfFile (get_handle ()))
		__seterrno ();
	      else
		res = res_bug;
	      /* restore original file pointer location */
	      lseek (prev_loc, SEEK_SET);
	    }

	}
a981 3
  /* Set ctime on success (copy gets it automatically). */
  if (!wincap.is_winnt ())
    has_changed (true);
a1128 6
  if (!hExeced)
    {
      /* Changing inode data requires setting ctime (only 9x). */
      if (has_changed ())
	touch_ctime ();
    }
a1384 1
  int rc;
d1386 3
a1388 8
  if (wincap.is_winnt ())
    {
      rc = !(err = unlink_nt (pc, pc.has_attribute (FILE_ATTRIBUTE_READONLY)));
      if (err)
	SetLastError (err);
    }
  else
    rc = RemoveDirectory (get_win32_name ());
a1419 4
  /* Directory still exists, restore its characteristics. */
  if (!wincap.is_winnt () && pc.has_attribute (FILE_ATTRIBUTE_READONLY))
    SetFileAttributes (get_win32_name (), (DWORD) pc);

d1460 2
a1461 3
  else if ((dir->__d_dirname = (char *) malloc (wincap.is_winnt ()
						? sizeof (struct __DIR_cache)
						: len + 3)) == NULL)
d1498 3
a1500 1
      if (wincap.is_winnt ())
d1502 17
a1518 2
	  d_cachepos (dir) = 0;
	  if (!pc.iscygdrive ())
d1520 3
a1522 21
	      OBJECT_ATTRIBUTES attr;
	      WCHAR wpath[CYG_MAX_PATH + 10];
	      UNICODE_STRING upath = {0, sizeof (wpath), wpath};
	      IO_STATUS_BLOCK io;
	      NTSTATUS status;
	      SECURITY_ATTRIBUTES sa = sec_none;
	      pc.get_nt_native_path (upath);
	      InitializeObjectAttributes (&attr, &upath,
					  OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
					  NULL, sa.lpSecurityDescriptor);
	      status = NtOpenFile (&dir->__handle,
				   SYNCHRONIZE | FILE_LIST_DIRECTORY,
				   &attr, &io, wincap.shared (),
				   FILE_SYNCHRONOUS_IO_NONALERT
				   | FILE_OPEN_FOR_BACKUP_INTENT
				   | FILE_DIRECTORY_FILE);
	      if (!NT_SUCCESS (status))
		{
		  __seterrno_from_nt_status (status);
		  goto free_mounts;
		}
d1524 13
a1536 14
	      /* FileIdBothDirectoryInformation is apparently unsupported on
		 XP when accessing directories on UDF.  When trying to use it
		 so, NtQueryDirectoryFile returns with STATUS_ACCESS_VIOLATION.
		 It's not clear if the call isn't also unsupported on other
		 OS/FS combinations (say, Win2K/CDFS or so).  Instead of
		 testing in readdir for yet another error code, let's use
		 FileIdBothDirectoryInformation only on filesystems supporting
		 persistent ACLs, FileBothDirectoryInformation otherwise. */
	      if (pc.hasgood_inode ())
		{
		  dir->__flags |= dirent_set_d_ino;
		  if (wincap.has_fileid_dirinfo ())
		    dir->__flags |= dirent_get_d_ino;
		}
a1664 3
  if (!wincap.is_winnt ())
    return readdir_9x (dir, de);

a1817 49
int
fhandler_disk_file::readdir_9x (DIR *dir, dirent *de)
{
  WIN32_FIND_DATA buf;
  int res = 0;

  if (!dir->__handle)
    {
      res = ENMFILE;
      goto out;
    }
  DWORD lasterr;
  if (dir->__d_position != 0)
    lasterr = FindNextFileA (dir->__handle, &buf) ? 0 : GetLastError ();
  else if (dir->__handle != INVALID_HANDLE_VALUE)
    {
      res = EBADF;
      goto out;
    }
  else
    {
      int len = strlen (dir->__d_dirname);
      strcpy (dir->__d_dirname + len, "*");
      dir->__handle = FindFirstFile (dir->__d_dirname, &buf);
      dir->__d_dirname[len] = '\0';
      if (dir->__handle != INVALID_HANDLE_VALUE)
	lasterr = 0;
      else if ((lasterr = GetLastError ()) != ERROR_NO_MORE_FILES)
	{
	  res = geterrno_from_win_error (lasterr);
	  goto out;
	}
    }
  if (!lasterr)
    de->d_ino = d_mounts (dir)->check_mount (buf.cFileName, de->d_ino);
  if (!(res = readdir_helper (dir, de, lasterr, buf.dwFileAttributes,
			      buf.cFileName)))
    dir->__d_position++;
  else
    {
      FindClose (dir->__handle);
      dir->__handle = NULL;
    }

out:
  syscall_printf ("%d = readdir (%p, %p) (%s)", res, dir, &de, res ? "***" : de->d_name);
  return res;
}

d1836 2
a1837 1
  if (wincap.is_winnt ())
d1839 22
a1860 2
      d_cachepos (dir) = 0;
      if (wincap.has_buggy_restart_scan () && isremote ())
d1862 2
a1863 26
	  /* This works around a W2K bug.  The RestartScan parameter in calls
	     to NtQueryDirectoryFile on remote shares is ignored, thus
	     resulting in not being able to rewind on remote shares.  By
	     reopening the directory, we get a fresh new directory pointer. */
	  UNICODE_STRING fname = {0, CYG_MAX_PATH * 2, (WCHAR *) L""};
	  OBJECT_ATTRIBUTES attr;
	  NTSTATUS status;
	  IO_STATUS_BLOCK io;
	  HANDLE new_dir;

	  InitializeObjectAttributes (&attr, &fname, OBJ_CASE_INSENSITIVE,
				      dir->__handle, NULL);
	  status = NtOpenFile (&new_dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			       &attr, &io, wincap.shared (),
			       FILE_SYNCHRONOUS_IO_NONALERT
			       | FILE_OPEN_FOR_BACKUP_INTENT
			       | FILE_DIRECTORY_FILE);
	  if (!NT_SUCCESS (stat))
	    debug_printf ("Unable to reopen dir %s, NT error: 0x%08x, "
			  "win32: %lu", get_name (), status,
			  RtlNtStatusToDosError (status));
	  else
	    {
	      CloseHandle (dir->__handle);
	      dir->__handle = new_dir;
	    }
a1865 6
  else if (dir->__handle != INVALID_HANDLE_VALUE)
    {
      if (dir->__handle)
	FindClose (dir->__handle);
      dir->__handle = INVALID_HANDLE_VALUE;
    }
d1882 1
a1882 1
  else
d1884 2
a1885 10
      BOOL winres;
      if (wincap.is_winnt ())
	winres = CloseHandle (dir->__handle);
      else
	winres = FindClose (dir->__handle);
      if (!winres)
	{
	  __seterrno ();
	  res = -1;
	}
@


1.204
log
@	* fhandler_disk_file.cc (fhandler_disk_file::closedir): Add dir name
	to debug output.
	* syscalls.cc (try_to_bin): Enable code to move file to user specific
	recycler dir to eliminate Vista problem.
	(unlink_nt): Add comment that rename after opening for delete on close
	only fails on XP.
@
text
@d812 1
a812 1
        fmi.Mode |= FILE_SEQUENTIAL_ONLY;
d842 1
a842 1
         is less than the file's actual length. */
d847 1
a847 1
        {
d875 1
a875 1
        {
d1471 1
a1471 1
        SetLastError (err);
d1602 1
a1602 1
	      				  OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
d1796 1
a1796 1
	     FileBothDirectoryInformation. 
d1807 1
a1807 1
	        {
d1815 1
a1815 1
		        goto go_ahead;
d1818 1
a1818 1
		  					 + d_cachepos (dir));
d1985 1
a1985 1
        {
@


1.203
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Implement rmdir
	on NT by calling unlink_nt.  Check for directory here.
	* syscalls.cc (try_to_bin): Fix buggy debug_printf statement.
	(unlink_nt): Make non-static.  Don't use delete-on-close semantics on
	directoires.  Explain why.
@
text
@d2049 1
a2049 1
  syscall_printf ("%d = closedir (%p)", res, dir);
@


1.202
log
@	* security.h (setacl): Add parameter for writability flag.
	* sec_acl.cc (setacl): Ditto.  Set to true if any ACE with write
	permissions is created.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Reset
	FILE_ATTRIBUTE_READONLY if ACL contains an ACE with write permissions.
@
text
@d1450 2
d1454 5
d1465 10
a1474 1
  int rc = RemoveDirectory (get_win32_name ());
d1507 1
a1507 1
  if (pc.has_attribute (FILE_ATTRIBUTE_READONLY))
@


1.201
log
@	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.
@
text
@d749 6
a754 1
	      res = setacl (get_io_handle (), pc, nentries, aclbufp);
@


1.200
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Improve debug
	output.
@
text
@d4 1
a4 1
   2005, 2006 Red Hat, Inc.
d439 1
a439 1
  buf->st_blksize = S_BLKSIZE;
@


1.199
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Fix typo.
@
text
@d1815 4
a1818 1
  if (NT_SUCCESS (status))
@


1.198
log
@	* dir.cc (mkdir): Check last path component for "..".
	(rmdir): Don't check last path component for "..".
	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Drop kludge
	which tries to allow deleting the current working directory.
	* path.cc (has_dot_last_component): Add parameter to indicate testing
	for "..".  Take trailing slash into account.
	(symlink_info::posixify): Rely on cygheap->cwd.win32 having a
	useful value.
	(cwdstuff::init): Initialize cygheap->cwd with current working
	directory.  Change to windows_system_directory afterwards.
	(cwdstuff::set): Never call SetCurrentDirectory here.  Just check
	if changing into target directory would be allowed.  Add comment to
	explain why.
	* path.h (has_dot_last_component): Declare with second parameter.
	* pinfo.cc (pinfo::zap_cwd): Remove.
	(pinfo::exit): Drop call to zap_cwd.
	* pinfo.h (class pinfo): Remove declaration of zap_cwd.
	* spawn.cc (spawn_guts): Set current working directory for non-Cygwin
	child applications.  Drop call to zap_cwd.
@
text
@d1466 1
a1466 1
	return res;
@


1.197
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop
	directory attribute for reparse points to avoid mistreating.
	(fhandler_base::fstat_by_name): Ditto.
	* path.cc (symlink_info::check_reparse_point): New method testing
	reparse points for symbolic links.
	(symlink_info::check_shortcut): Move file attribute tesat to calling
	function.
	(symlink_info::check): Add handling for reparse points.
	* path.h (enum path_types): Add PATH_REP to denote reparse point based
	symlinks.
	(path_conv::is_rep_symlink): New method.
	* syscalls.cc (unlink): Handle reparse points.
@
text
@d1452 2
a1453 4
  for (bool is_cwd = false; ; is_cwd = true)
    {
      DWORD err, att = 0;
      int rc = RemoveDirectory (get_win32_name ());
d1455 2
a1456 2
      if (isremote () && exists ())
	att = GetFileAttributes (get_win32_name ());
d1458 9
a1466 16
      /* Sometimes smb indicates failure when it really succeeds, so check for
	 this case specifically. */
      if (rc || att == INVALID_FILE_ATTRIBUTES)
	{
	  /* RemoveDirectory on a samba drive doesn't return an error if the
	     directory can't be removed because it's not empty. Checking for
	     existence afterwards keeps us informed about success. */
	  if (!isremote () || att == INVALID_FILE_ATTRIBUTES)
	    {
	      res = 0;
	      break;
	    }
	  err = ERROR_DIR_NOT_EMPTY;
	}
      else
	err = GetLastError ();
d1468 1
a1468 38
      /* This kludge detects if we are attempting to remove the current working
	 directory.  If so, we will move elsewhere to potentially allow the
	 rmdir to succeed.  This means that cygwin's concept of the current
	 working directory != Windows concept but, hey, whaddaregonnado?
	 Note that this will not cause something like the following to work:
	 $ cd foo
	 $ rmdir .
	 since the shell will have foo "open" in the above case and so Windows
	 will not allow the deletion. (Actually it does on 9X.)
	 FIXME: A potential workaround for this is for cygwin apps to *never*
	 call SetCurrentDirectory. */

      extern char windows_system_directory[];
      if (strcasematch (get_win32_name (), cygheap->cwd.win32)
	  && !strcasematch (windows_system_directory, cygheap->cwd.win32)
	  && !is_cwd
	  && SetCurrentDirectory (windows_system_directory))
	continue;

      /* On 9X ERROR_ACCESS_DENIED is returned if you try to remove a
	 non-empty directory. */
      if (err == ERROR_ACCESS_DENIED
	  && wincap.access_denied_on_delete ())
	err = ERROR_DIR_NOT_EMPTY;
      /* ...and, that's *not* funny, when trying to remove a non-existing
	 directory on a share, which is hosted by a 9x machine, the error
	 code ERROR_INVALID_FUNCTION is returned.  */
      else if (err == ERROR_INVALID_FUNCTION)
	err = ERROR_FILE_NOT_FOUND;

      __seterrno_from_win_error (err);

      /* Directory still exists, restore its characteristics. */
      if (pc.has_attribute (FILE_ATTRIBUTE_READONLY))
	SetFileAttributes (get_win32_name (), (DWORD) pc);
      if (is_cwd)
	SetCurrentDirectory (get_win32_name ());
      break;
d1470 18
@


1.196
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rewinddir): Fix comment.
@
text
@d243 2
d280 5
a284 1
    pc.file_attributes (local.dwFileAttributes);
d315 2
@


1.195
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rewinddir): Accomodate
	buggy RestartScan behaviour of Windows 2000.
	* wincap.h: Define has_buggy_restart_scan throughout.
	* wincap.cc: Ditto.
@
text
@d1983 3
a1985 3
	     to NtQueryDiretoryFile on remote shares is ignored, thus resulting
	     in not being able to rewind on remote shares.  By reopening the
	     directory, we get a fresh new directory pointers. w*/
@


1.194
log
@	* fhandler_disk_file.cc (fhandler_disk_file::facl): Fix whitespace.
	* external.cc: Update copyright.
	* fhandler.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.h: Ditto.
	* security.cc: Ditto.
	(check_registry_access): Return -1 if W_OK is requested.
@
text
@d1978 32
a2009 1
    d_cachepos (dir) = 0;
@


1.193
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Drop redundant
	access check.
@
text
@d692 1
a692 1
	      set_errno(EFAULT);
@


1.192
log
@	* autoload.cc (PrivilegeCheck): Define.
	* fhandler.cc (fhandler_base::open): Always try opening with backup
	resp. restore intent.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Always try
	opening with backup intent.
	(fhandler_disk_file::readdir): Ditto when trying to retrieve file id
	explicitely.
	* security.cc (check_file_access): Replace pbuf with correctly
	PPRIVILEGE_SET typed pset.  Check explicitely for backup and/or restore
	privileges when AccessCheck fails, to circumvent AccessCheck
	shortcoming.  Add comment to explain.
@
text
@a1561 2
  else if (!pc.iscygdrive () && fhaccess (R_OK) != 0)
    goto free_dirent;
@


1.191
log
@	* path.cc (path_conv::get_nt_native_path): Properly detect \\?\ paths.
	(mount_info::conv_to_win32_path): Update comment.
	* fhandler_disk_file.cc (path_conv::ndisk_links): Use backslashes
	to make NT kernel functions work for \\?\GLOBALROOT paths.
@
text
@d1609 1
d1873 1
a1873 1
			       wincap.shared (), 0))
@


1.190
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Fix formatting.
@
text
@d146 1
a146 1
      s = "/*";
d151 1
a151 1
      s = "/..";
@


1.189
log
@	* fhandler_disk_file.cc (DIR_NUM_ENTRIES): Set to 100 to maximize
	performance on remote shares.
	(fhandler_disk_file::opendir): Move comment about Samba weirdness into
	fhandler_disk_file::readdir.  Don't disallow
	FileIdBothDirectoryInformation on Samba.
	(fhandler_disk_file::readdir): Workaround Samba problem with
	FileIdBothDirectoryInformation by rereading already read entries
	using FileBothDirectoryInformation.  Change comment about Samba
	weirdness explaining this change.
@
text
@d1586 3
a1588 1
      dir->__flags = (pc.normalized_path[0] == '/' && pc.normalized_path[1] == '\0') ? dirent_isroot : 0;
d1602 2
a1603 1
	      InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
a1604 1

d1608 2
a1609 1
				   FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE);
@


1.188
log
@* fhandler_disk_file.cc (fhandler_disk_file::pread): Properly check for
non-error return from lseek.
@
text
@d1471 2
a1472 2
	 rmdir to succeed.  This means that cygwin's concept of the current working
	 directory != Windows concept but, hey, whaddaregonnado?
d1476 4
a1479 4
	 since the shell will have foo "open" in the above case and so Windows will
	 not allow the deletion. (Actually it does on 9X.)
	 FIXME: A potential workaround for this is for cygwin apps to *never* call
	 SetCurrentDirectory. */
d1517 1
a1517 1
#define DIR_NUM_ENTRIES	25		/* Cache size 16064 bytes */
d1624 1
a1624 17
		  /* Something weird happens on Samba up to version 3.0.21c,
		     which is fixed in 3.0.22.  FileIdBothDirectoryInformation
		     seems to work nicely, but only up to the 128th entry in
		     the directory.  After reaching this entry, the next call
		     to NtQueryDirectoryFile(FileIdBothDirectoryInformation)
		     returns STATUS_INVALID_LEVEL.  Why should we care, we can
		     just switch to FileBothDirectoryInformation, isn't it?
		     Nope!  The next call to
		     NtQueryDirectoryFile(FileBothDirectoryInformation)
		     actually returns STATUS_NO_MORE_FILES, regardless how
		     many files are left unread in the directory.  This does
		     not happen when using FileBothDirectoryInformation right
		     from the start.  In that case we can read the whole
		     directory unmolested.  So we have to excempt Samba from
		     the usage of FileIdBothDirectoryInformation entirely,
		     even though Samba returns valid File IDs. */
		  if (wincap.has_fileid_dirinfo () && !pc.fs_is_samba ())
d1777 46
d1831 2
@


1.187
log
@	* fhandler_disk_file.cc (fhandler_disk_file::lock): Handle
	ERROR_NOT_LOCKED returned from UnlockFileEx.
@
text
@d1219 1
a1219 1
      if (lseek (curpos, SEEK_SET) == 0)
@


1.186
log
@	* autoload.cc (NtSetInformationFile): Define.
	* cygwin.din: Export posix_fadvise and posix_fallocate.
	* fhandler.cc (fhandler_base::fadvise): New method.
	(fhandler_base::ftruncate): Add allow_truncate parameter.
	* fhandler.h (class fhandler_base): Add fadvise method.  Accomodate
	new parameter to ftruncate.
	(class fhandler_pipe): Add fadvise and ftruncate methods.
	(class fhandler_disk_file): Add fadvise method.  Accomodate new
	parameter to ftruncate.
	* fhandler_disk_file.cc (fhandler_disk_file::fadvise): New method.
	(fhandler_disk_file::ftruncate): Accomodate new allow_truncate
	parameter.  Set EOF using NtSetInformationFile on NT.
	* ntdll.h (struct _FILE_END_OF_FILE_INFORMATION): Define.
	(NtSetInformationFile): Declare.
	* pipe.cc (fhandler_pipe::fadvise): New method.
	(fhandler_pipe::ftruncate): Ditto.
	* syscalls.cc (posix_fadvise): New function.
	(posix_fallocate): Ditto.
	(ftruncate64): Accomodate second parameter to fhandler's ftruncate
	method.
	* include/fcntl.h: Add POSIX_FADV_* flags.  Add declarations of
	posix_fadvise and posix_fallocate.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d1367 2
@


1.185
log
@white space
@
text
@d765 1
a765 1
fhandler_disk_file::ftruncate (_off64_t length)
d767 39
a805 1
  int res = -1, res_bug = 0;
d807 9
a815 1
  if (length < 0 || !get_output_handle ())
d823 22
a844 4
      _off64_t prev_loc = lseek (0, SEEK_CUR);
      if (lseek (length, SEEK_SET) >= 0)
	{
	  if (get_fs_flags (FILE_SUPPORTS_SPARSE_FILES))
d846 6
a851 13
	      _off64_t actual_length;
	      DWORD size_high = 0;
	      actual_length = GetFileSize (get_output_handle (), &size_high);
	      actual_length += ((_off64_t) size_high) << 32;
	      if (length >= actual_length + (128 * 1024))
		{
		  DWORD dw;
		  BOOL r = DeviceIoControl (get_output_handle (),
					    FSCTL_SET_SPARSE, NULL, 0, NULL,
					    0, &dw, NULL);
		  syscall_printf ("%d = DeviceIoControl(%p, FSCTL_SET_SPARSE)",
				  r, get_output_handle ());
		}
d853 5
a857 4
	  else if (wincap.has_lseek_bug ())
	    res_bug = write (&res, 0);
	  if (!SetEndOfFile (get_output_handle ()))
	    __seterrno ();
d859 16
a874 3
	    res = res_bug;
	  /* restore original file pointer location */
	  lseek (prev_loc, SEEK_SET);
@


1.185.4.1
log
@	* fhandler_disk_file.cc (fhandler_disk_file::lock): Handle
	ERROR_NOT_LOCKED returned from UnlockFileEx.
@
text
@a1295 2
	  if (res == 0 && GetLastError () == ERROR_NOT_LOCKED)
	    res = 1;
@


1.185.4.2
log
@	* fhandler_disk_file.cc (fhandler_disk_file::pread): Fix comparison
	of return value of lseek.
@
text
@d1148 1
a1148 1
      if (lseek (curpos, SEEK_SET) >= 0)
@


1.185.4.3
log
@	* include/asm/byteorder.h: Fix copyright dates.

	* autoload.cc (PrivilegeCheck): Define.
	* fhandler.cc (fhandler_base::open): Always try opening with backup
	resp. restore intent.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Always try
	opening with backup intent.
	(fhandler_disk_file::readdir): Ditto when trying to retrieve file id
	explicitely.
	* security.cc (check_file_access): Replace pbuf with correctly
	PPRIVILEGE_SET typed pset.  Check explicitely for backup and/or restore
	privileges when AccessCheck fails, to circumvent AccessCheck
	shortcoming.  Add comment to explain.

	* include/asm/byteorder.h: Correct typo.

	* include/asm/byteorder.h: Don't #define n* macros if -fnoinline is
	specified.

	* environ.cc (build_env): Don't put an empty environment variable into
	the environment.  Optimize use of "len".
	* errno.cc (ERROR_MORE_DATA): Translate to EMSGSIZE rather than EAGAIN.
@
text
@d1535 1
a1535 3
				   FILE_SYNCHRONOUS_IO_NONALERT
				   | FILE_OPEN_FOR_BACKUP_INTENT
				   | FILE_DIRECTORY_FILE);
d1766 1
a1766 1
			       wincap.shared (), FILE_OPEN_FOR_BACKUP_INTENT))
@


1.185.4.4
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Drop redundant
	access check.
@
text
@d1491 2
@


1.185.4.5
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rewinddir): Accomodate
	buggy RestartScan behaviour of Windows 2000.
	* wincap.h: Define has_buggy_restart_scan throughout.
	* wincap.cc: Ditto.
@
text
@d1873 1
a1873 32
    {
      d_cachepos (dir) = 0;
      if (wincap.has_buggy_restart_scan () && isremote ())
        {
	  /* This works around a W2K bug.  The RestartScan parameter in calls
	     to NtQueryDiretoryFile on remote shares is ignored, thus resulting
	     in not being able to rewind on remote shares.  By reopening the
	     directory, we get a fresh new directory pointers. w*/
	  UNICODE_STRING fname = {0, CYG_MAX_PATH * 2, (WCHAR *) L""};
	  OBJECT_ATTRIBUTES attr;
	  NTSTATUS status;
	  IO_STATUS_BLOCK io;
	  HANDLE new_dir;

	  InitializeObjectAttributes (&attr, &fname, OBJ_CASE_INSENSITIVE,
				      dir->__handle, NULL);
	  status = NtOpenFile (&new_dir, SYNCHRONIZE | FILE_LIST_DIRECTORY,
			       &attr, &io, wincap.shared (),
			       FILE_SYNCHRONOUS_IO_NONALERT
			       | FILE_OPEN_FOR_BACKUP_INTENT
			       | FILE_DIRECTORY_FILE);
	  if (!NT_SUCCESS (stat))
	    debug_printf ("Unable to reopen dir %s, NT error: 0x%08x, "
			  "win32: %lu", get_name (), status,
			  RtlNtStatusToDosError (status));
	  else
	    {
	      CloseHandle (dir->__handle);
	      dir->__handle = new_dir;
	    }
	}
    }
@


1.185.4.6
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rewinddir): Fix comment.
@
text
@d1878 3
a1880 3
	     to NtQueryDirectoryFile on remote shares is ignored, thus
	     resulting in not being able to rewind on remote shares.  By
	     reopening the directory, we get a fresh new directory pointer. */
@


1.185.4.7
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d4 1
a4 1
   2005, 2006, 2007 Red Hat, Inc.
d431 1
a431 1
  buf->st_blksize = PREFERRED_IO_BLKSIZE;
d473 1
a473 1
	  && !pc.isdir () && !pc.issymlink ())
d492 1
a492 1
	  && !pc.isdir () && !pc.issymlink ())
a511 1
	      LONG curhigh = 0;
d516 3
a518 3
	      cur = SetFilePointer (get_handle (), 0, &curhigh, FILE_CURRENT);
	      if ((cur != INVALID_SET_FILE_POINTER || GetLastError () == NO_ERROR)
		  && ((!cur && !curhigh) || SetFilePointer (get_handle (), 0, NULL, FILE_BEGIN)
d529 1
a529 1
		  SetFilePointer (get_handle (), cur, &curhigh, FILE_BEGIN);
@


1.185.4.8
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Fix R/O bit
	handling on filesystems without ACL support.
@
text
@d491 2
a492 1
      if (!::has_attribute (dwFileAttributes, FILE_ATTRIBUTE_READONLY))
d496 2
a497 2
      if (pc.isdir ())
	buf->st_mode |= S_IFDIR | STD_WBITS | STD_XBITS;
@


1.185.4.9
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Call close_fs
	instead of close to avoid calling close from wrong class when changing
	a file system based device node.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_base::utimes_fs): Ditto.
@
text
@d623 1
a623 1
    close_fs ();
d666 1
a666 1
    close_fs ();
d759 1
a759 1
    close_fs ();
d1043 1
a1043 1
    close_fs ();
@


1.184
log
@* fhandler_disk_file.cc (fhandler_disk_file::readdir): Fix typo which caused
test for ".." to be skipped.
@
text
@d75 1
a75 1
        {
d100 1
a100 1
        if (!found[i])
d107 1
a107 1
        {
d118 1
a118 1
	        {
d205 1
a205 1
     The known exception are SFU NFS shares, which return the valid 32 bit 
d225 1
a225 1
      					 alloca (fvi_size);
d852 11
a862 11
               && !pc.isdir ()
               && GetBinaryType (pc, &bintype)
               && (len = strlen (newpc)) > 4
               && !strcasematch ((const char *) newpc + len - 4, ".exe"))
        {
          /* Executable hack. */
          strcpy (new_buf, newpath);
          strcat (new_buf, ".exe");
          newpath = new_buf;
          newpc.check (newpath, PC_SYM_NOFOLLOW);
        }
d1477 1
a1477 1
  						? sizeof (struct __DIR_cache)
d1508 1
a1508 1
        strcpy (d_dirname (dir) + len, "\\");
d1541 1
a1541 1
	         XP when accessing directories on UDF.  When trying to use it
d1605 1
a1605 1
        added = true;
d1732 1
a1732 1
        d_cachepos (dir) = 0;
d1740 1
a1740 1
        }
d1742 1
a1742 1
        FileName = ((PFILE_BOTH_DIR_INFORMATION) buf)->FileName;
d1978 1
a1978 1
        {
d1986 1
a1986 1
        }
d1988 1
a1988 1
        break;
@


1.183
log
@	* fhandler.h (fhandler_base): Change fstat_helper prototype
	to take file size and inode number as 64 bit values.
	* fhandler_disk_file.cc (FS_IS_SAMBA): Move to path.cc
	(FS_IS_SAMBA_WITH_QUOTA): Ditto.
	(path_conv::hasgood_inode): Delete.
	(path_conv::is_samba): Delete.
	(path_conv::isgood_inode): Centralized function to recognize
	a good inode number.
	(fhandler_base::fstat_by_handle): Constify fvi_size and fai_size.
	Accomodate argument change in fstat_helper.
	(fhandler_base::fstat_by_name): Ditto.
	(fhandler_base::fstat_helper): Accomodate argument change.  Call
	path_conv::isgood_inode to recognize good inodes.
	(fhandler_disk_file::opendir): Explain Samba weirdness here.
	Call path_conv::fs_is_samba instead of path_conv::is_samba.
	(fhandler_disk_file::readdir): Add STATUS_INVALID_INFO_CLASS
	as valid return code from NtQueryDirectoryFile to indicate that
	FileIdBothDirectoryInformation is not supported.
	Call path_conv::isgood_inode to recognize good inodes.
	* ntdll.h (STATUS_INVALID_INFO_CLASS): Define.
	* path.cc (fs_info::update): Rework file system recognition
	and set appropriate flags.
	* path.h (struct fs_info): Add is_ntfs, is_samba and is_nfs flags.
	Constify pure read accessors.
@
text
@d1790 1
a1790 1
  else if (!(dir->__flags & dirent_saw_dot))
@


1.182
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Use UINT32_MAX
	instead of UINT_MAX.
@
text
@a198 10
#define FS_IS_SAMBA (FILE_CASE_SENSITIVE_SEARCH \
		     | FILE_CASE_PRESERVED_NAMES \
		     | FILE_PERSISTENT_ACLS)

#define FS_IS_SAMBA_WITH_QUOTA \
		    (FILE_CASE_SENSITIVE_SEARCH \
		     | FILE_CASE_PRESERVED_NAMES \
		     | FILE_PERSISTENT_ACLS \
		     | FILE_VOLUME_QUOTAS)

d200 1
a200 1
path_conv::hasgood_inode ()
d202 6
a207 27
  /* Assume that if a drive has ACL support it MAY have valid "inodes".
     It definitely does not have valid inodes if it does not have ACL
     support.  Decouple from has_acls() which follows smbntsec setting. */
  return ((fs_flags () & FILE_PERSISTENT_ACLS)
	  && drive_type () != DRIVE_UNKNOWN);
}

inline bool
path_conv::is_samba ()
{
  /* Something weird happens on Samba up to version 3.0.21c, which is
     fixed in 3.0.22.  FileIdBothDirectoryInformation seems to work
     nicely, but only up to the 128th entry in the directory.  After
     reaching this entry, the next call to
     NtQueryDirectoryFile(FileIdBothDirectoryInformation) returns
     STATUS_INVAILD_LEVEL.  Why should we care, we can just switch to
     FileBothDirectoryInformation, isn't it?  Nope!  The next call to
     NtQueryDirectoryFile(FileBothDirectoryInformation) actually returns
     STATUS_NO_MORE_FILES, regardless how many files are left unread in
     the directory.  This does not happen when using
     FileBothDirectoryInformation right from the start.  In that case we
     can read the whole directory unmolested.  So we have to excempt
     Samba from the usage of FileIdBothDirectoryInformation entirely,
     even though Samba returns valid File IDs. */
  return drive_type () == DRIVE_REMOTE
	 && (fs_flags () == FS_IS_SAMBA
	     || fs_flags () == FS_IS_SAMBA_WITH_QUOTA);
d220 3
a222 2
      DWORD fvi_size = 2 * CYG_MAX_PATH + sizeof (FILE_FS_VOLUME_INFORMATION);
      DWORD fai_size = 2 * CYG_MAX_PATH + sizeof (FILE_ALL_INFORMATION);
d251 1
a251 2
			   pfai->StandardInformation.EndOfFile.HighPart,
			   pfai->StandardInformation.EndOfFile.LowPart,
d253 1
a253 2
			   pfai->InternalInformation.FileId.HighPart,
			   pfai->InternalInformation.FileId.LowPart,
d284 2
a285 2
		       local.nFileSizeHigh,
		       local.nFileSizeLow,
d287 2
a288 2
		       local.nFileIndexHigh,
		       local.nFileIndexLow,
d315 2
a316 2
			  local.nFileSizeHigh,
			  local.nFileSizeLow,
d318 1
a318 2
			  0,
			  0,
d325 1
a325 1
      res = fstat_helper (buf, ft, ft, ft, pc.volser (), 0, 0, -1LL, 0, 0, 1,
d403 1
a403 2
			     DWORD nFileSizeHigh,
			     DWORD nFileSizeLow,
d405 1
a405 2
			     DWORD nFileIndexHigh,
			     DWORD nFileIndexLow,
d416 1
a416 1
  buf->st_size = ((_off64_t) nFileSizeHigh << 32) + nFileSizeLow;
d425 3
a427 6
  /* We can't trust remote inode numbers of only 32 bit.  That means,
     all remote inode numbers when running under NT4, as well as remote NT4
     NTFS, as well as shares of Samba version < 3.0. */
  if (pc.hasgood_inode () && (nFileIndexHigh || !pc.isremote ()))
    buf->st_ino = (((__ino64_t) nFileIndexHigh) << 32)
		  | (__ino64_t) nFileIndexLow;
d1551 17
a1567 1
		  if (wincap.has_fileid_dirinfo () && !pc.is_samba ())
d1717 2
a1718 1
	      || status == STATUS_INVALID_PARAMETER)
d1770 2
a1771 4
	  /* We can't trust remote inode numbers of only 32 bit.  That means,
	     all remote inode numbers when running under NT4, as well as
	     remote NT4 NTFS, as well as shares of Samba version < 3.0. */
	  if (de->d_ino <= UINT32_MAX && pc.isremote ())
@


1.181
log
@	* fhandler_disk_file.cc (path_conv::hasgood_inode): Make inline.
	Drop remote fs handling entirely since unreliable inode numbers
	are now recognized differently.
	(path_conv::is_samba): Make inline.
	(fhandler_disk_file::opendir): Reformat comment.
	(fhandler_base::fstat_helper): Special case remote file systems
	returning (unreliable) 32 bit inode numbers.
	(fhandler_base::readdir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Ditto.
@
text
@d1794 1
a1794 1
	  if (de->d_ino <= UINT_MAX && pc.isremote ())
@


1.180
log
@	* fhandler_disk_file.cc (FS_IS_SAMBA_WITH_QUOTA): New define.
	(path_conv::hasgood_inode): Recognize Samba with quota support
	compiled in.
	(path_conv::is_samba): Ditto.  Fix comment to include Samba version
	numbers for later reference.
@
text
@d209 1
a209 1
bool
d215 2
a216 22
  if (!(fs_flags () & FILE_PERSISTENT_ACLS) || drive_type () == DRIVE_UNKNOWN)
    return false;
  if (drive_type () == DRIVE_REMOTE)
    {
      /* From own experiments and replies from the Cygwin mailing list,
	 we're now trying to figure out how to determine remote file
	 systems which are capable of returning persistent inode
	 numbers.  It seems that NT4 NTFS, when accessed remotly, and
	 some other remote file systems return unreliable values in
	 nFileIndex.  The common factor of these unreliable remote FS
	 seem to be that FILE_SUPPORTS_OBJECT_IDS isn't set, even though
	 this should have nothing to do with inode numbers.
	 An exception is Samba, which seems to return valid inode numbers
	 without having the FILE_SUPPORTS_OBJECT_IDS flag set.  So we're
	 testing for the flag values returned by a 3.x Samba explicitely
	 for now.  But note the comment in the below "is_samba" function. */
      if (!(fs_flags () & FILE_SUPPORTS_OBJECT_IDS)
      	  && fs_flags () != FS_IS_SAMBA
      	  && fs_flags () != FS_IS_SAMBA_WITH_QUOTA)
	return false;
    }
  return true;
d219 1
a219 1
bool
d460 4
a463 1
  if (pc.hasgood_inode ())
d1578 6
a1583 6
	      /* FileIdBothDirectoryInformation is apparently unsupported on XP
		 when accessing directories on UDF.  When trying to use it so,
		 NtQueryDirectoryFile returns with STATUS_ACCESS_VIOLATION.  It's
		 not clear if the call isn't also unsupported on other OS/FS
		 combinations (say, Win2K/CDFS or so).  Instead of testing in
		 readdir for yet another error code, let's use
d1791 8
@


1.179
log
@	* dir.cc (opendir): Fix indentation.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Move storing
	fhandler in file descriptor table to some point very late in function
	to avoid double free'ing.  Add comment to explain what happens.
	Add label free_mounts and don't forget to delete __DIR_mounts structure
	if NtOpenFile fails.
@
text
@d203 6
d232 2
a233 1
      	  && fs_flags () != FS_IS_SAMBA)
d242 4
a245 3
  /* Something weird happens on Samba.  FileIdBothDirectoryInformation
     seems to work nicely, but only up to the 128th entry in the
     directory.  After reaching this entry, the next call to
d256 3
a258 1
  return drive_type () == DRIVE_REMOTE && fs_flags () == FS_IS_SAMBA;
@


1.178
log
@	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Check
	cygdrive string length for those who have cygdrive mapped to "/".
@
text
@a1544 4
      fd = this;
      fd->nohandle (true);
      dir->__d_fd = fd;
      dir->__fh = this;
d1582 1
a1582 1
		  goto free_dirent;
d1601 8
d1615 2
@


1.177
log
@	* fhandler.h (enum dirent_states): Remove dirent_saw_cygdrive,
	dirent_saw_dev and dirent_saw_proc.
	(fhandler_cygdrive::open): Declare.
	(fhandler_cygdrive::close): Declare.
	* fhandler_disk_file.cc (class __DIR_mounts): Move to beginning of file.
	(__DIR_mounts::check_mount): New parameter to indicate if inode number
	is needed in calling function or not. Add /proc and /cygdrive handling.
	(__DIR_mounts::check_missing_mount): Ditto.
	(path_conv::ndisk_links): Use __DIR_mounts class to create correct
	hardlink count for directories with mount points in them.
	(fhandler_disk_file::readdir_helper): Remove /dev, /proc and /cygdrive
	handling.
	(fhandler_cygdrive::open): New method.
	(fhandler_cygdrive::close): New method.
	(fhandler_cygdrive::fstat): Always return fixed inode number 2 and
	fixed link count of 1. Drop call to set_drives.
	(fhandler_cygdrive::opendir): Drop call to get_namehash.
	(fhandler_cygdrive::readdir): Handle "." entry to return fixed inode
	number 2.
@
text
@d117 7
a123 4
	      strncpy (ret_name, mount_table->cygdrive + 1,
		       mount_table->cygdrive_len - 2);
	      ret_name[mount_table->cygdrive_len - 2] = '\0';
	      return 2;
@


1.176
log
@	* include/sys/dirent.h (struct __DIR): Rename __d_unused to
	__d_internal.
	* fhandler_disk_file.cc (struct __DIR_cache): Remove useless "typedef".
	(d_dirname): Remove useless "struct".
	(d_cachepos): Ditto.
	(d_cache): Ditto.
	(class __DIR_mounts): New class, implementing mount point tracking
	for readdir.
	(d_mounts): New macro for easy access to __DIR_mounts structure.
	(fhandler_disk_file::opendir): Allocate __DIR_mounts structure and
	let __d_internal element of dir point to it.
	(fhandler_disk_file::readdir_helper): Add mount points in the current
	directory, which don't have a real directory backing them.
	Don't generate an inode number for /dev.  Add comment, why.
	(fhandler_disk_file::readdir): Move filling fname to an earlier point.
	Check if current entry is a mount point and evaluate correct inode
	number for it.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::rewinddir): Set all mount points in this directory
	to "not found" so that they are listed again after calling rewinddir().
	(fhandler_disk_file::closedir): Deallocate __DIR_mounts structure.
	* path.cc (mount_info::get_mounts_here): New method to evaluate a list
	of mount points in a given parent directory.
	* shared_info.h (class mount_info): Declare get_mounts_here.
@
text
@d37 91
d140 1
d174 1
d188 4
a1502 56
class __DIR_mounts
{
  int	      count;
  const char *parent_dir;
  int	      parent_dir_len;
  char	     *mounts[MAX_MOUNTS];
  bool	      found[MAX_MOUNTS];

  __ino64_t eval_ino (int idx)
    {
      __ino64_t ino = 0;
      char fname[CYG_MAX_PATH];
      struct __stat64 st;
      int len = parent_dir_len;

      strcpy (fname, parent_dir);
      if (fname[len - 1] != '/')
	fname[len++] = '/';
      strcpy (fname + len, mounts[idx]);
      if (!lstat64 (fname, &st))
	ino = st.st_ino;
      return ino;
    }

public:
  __DIR_mounts (const char *posix_path)
  : parent_dir (posix_path)
    {
      parent_dir_len = strlen (parent_dir);
      count = mount_table->get_mounts_here (parent_dir, parent_dir_len, mounts);
      rewind ();
    }
  __ino64_t check_mount (const char *name, __ino64_t ino)
    {
      for (int i = 0; i < count; ++i)
	if (strcasematch (name, mounts[i]))
	  {
	    found[i] = true;
	    return eval_ino (i);
	  }
      return ino;
    }
  __ino64_t check_missing_mount (char *ret_name)
    {
      for (int i = 0; i < count; ++i)
        if (!found[i])
	  {
	    found[i] = true;
	    strcpy (ret_name, mounts[i]);
	    return eval_ino (i);
	  }
      return 0;
    }
    void rewind () { memset (found, 0, sizeof found); }
};

a1625 20
      else if (!(dir->__flags & dirent_isroot))
	/* nothing */;
      else if (0 && !(dir->__flags & dirent_saw_dev))
	{
	  strcpy (fname, "dev");
	  added = true;
	}
      else if (!(dir->__flags & dirent_saw_proc))
	{
	  strcpy (fname, "proc");
	  added = true;
	}
      else if (!(dir->__flags & dirent_saw_cygdrive)
	       && mount_table->cygdrive_len > 1)
	{
	  strcpy (fname, mount_table->cygdrive + 1);
	  fname[mount_table->cygdrive_len - 2] = '\0';
	  added = true;
	}

a1653 26
  if (dir->__flags & dirent_isroot)
    {
      if (strcasematch (de->d_name, "dev"))
	{
	  dir->__flags |= dirent_saw_dev;
	  /* In contrast to /proc, /dev has no own fhandler which cares
	     for inode numbers.  So, if the directory exists physically,
	     its "real" inode number should be used.  Otherwise it must
	     not be faked until we add a /dev fhandler to Cygwin. */
#if 0
	  de->d_ino = hash_path_name (0, "/dev");
#endif
	}
      else if (strcasematch (de->d_name, "proc"))
        {
	  dir->__flags |= dirent_saw_proc;
	  de->d_ino = hash_path_name (0, "/proc");
	}
      if (strlen (de->d_name) == mount_table->cygdrive_len - 2
	  && strncasematch (de->d_name, mount_table->cygdrive + 1,
			    mount_table->cygdrive_len - 2))
	{
	  dir->__flags |= dirent_saw_cygdrive;
	  de->d_ino = 0;
	}
    }
d1929 25
d1968 2
a1969 6
  /* Call get_namehash before calling set_drives, otherwise the namehash
     is broken due to overwriting the win32 path in set_drives. */
  buf->st_ino = get_namehash ();
  if (!ndrives)
    set_drives ();
  buf->st_nlink = ndrives + 2;
a1978 3
  /* Call get_namehash before calling set_drives, otherwise the namehash
     is broken due to overwriting the win32 path in set_drives. */
  get_namehash ();
d1991 9
a1999 1
	return ENMFILE;
@


1.175
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Use iscygdrive
	instead of isspecial.
	* path.h (path_conv::iscygdrive): New method.
@
text
@d1395 1
a1395 1
typedef struct __DIR_cache
d1402 61
a1462 3
#define d_dirname(d)	(((struct __DIR_cache *) (d)->__d_dirname)->__name)
#define d_cachepos(d)	(((struct __DIR_cache *) (d)->__d_dirname)->__pos)
#define d_cache(d)	(((struct __DIR_cache *) (d)->__d_dirname)->__cache)
d1519 1
d1583 3
a1585 1
      if (!(dir->__flags & dirent_isroot))
d1638 5
d1644 1
d1767 1
d1769 1
a1794 1
      sys_wcstombs (fname, CYG_MAX_PATH - 1, FileName, buf->FileNameLength / 2);
d1854 2
a1855 1
  
d1897 1
d1904 1
@


1.174
log
@* fhandler_disk_file.cc (fhandler_disk_file::opendir): Only set d_cachepos
under NT or suffer memory corruption.
(fhandler_disk_file::readdir_helper): Avoid else with a return.  Just calculate
extension location once when doing symlink checks.
(fhandler_disk_file::readdir): Make debug output more useful.
(fhandler_disk_file::readdir_9x): Ditto.  Eliminate redundant variable.
@
text
@d1432 1
a1432 1
  else if (!pc.isspecial () && fhaccess (R_OK) != 0)
d1464 1
a1464 1
	  if (!pc.isspecial ())
@


1.173
log
@* fhandler_disk_file.cc (fhandler_disk_file::opendir): Use NtOpenFile to open
the directory.
(fhandler_disk_file::readdir): Use NT_SUCCESS to determine if status represents
success.
@
text
@a1436 1
      d_cachepos (dir) = 0;
d1461 4
a1464 17
      if (!pc.isspecial () && wincap.is_winnt ())
        {
	  OBJECT_ATTRIBUTES attr;
	  WCHAR wpath[CYG_MAX_PATH + 10];
	  UNICODE_STRING upath = {0, sizeof (wpath), wpath};
	  IO_STATUS_BLOCK io;
	  NTSTATUS status;
	  SECURITY_ATTRIBUTES sa = sec_none;
	  pc.get_nt_native_path (upath);
	  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE | OBJ_INHERIT,
				      NULL, sa.lpSecurityDescriptor);

	  status = NtOpenFile (&dir->__handle,
			       SYNCHRONIZE | FILE_LIST_DIRECTORY,
			       &attr, &io, wincap.shared (),
			       FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE);
	  if (!NT_SUCCESS (status))
d1466 19
a1484 3
	      __seterrno_from_nt_status (status);
	      goto free_dirent;
	    }
d1486 14
a1499 13
	  /* FileIdBothDirectoryInformation is apparently unsupported on XP
	     when accessing directories on UDF.  When trying to use it so,
	     NtQueryDirectoryFile returns with STATUS_ACCESS_VIOLATION.  It's
	     not clear if the call isn't also unsupported on other OS/FS
	     combinations (say, Win2K/CDFS or so).  Instead of testing in
	     readdir for yet another error code, let's use
	     FileIdBothDirectoryInformation only on filesystems supporting
	     persistent ACLs, FileBothDirectoryInformation otherwise. */
	  if (pc.hasgood_inode ())
	    {
	      dir->__flags |= dirent_set_d_ino;
	      if (wincap.has_fileid_dirinfo () && !pc.is_samba ())
		dir->__flags |= dirent_get_d_ino;
d1544 1
a1544 6
      if (added)
	{
	  attr = 0;
	  dir->__flags &= ~dirent_set_d_ino;
        }
      else
d1546 3
d1556 2
a1557 2
      int len = strlen (c);
      if (strcasematch (c + len - 4, ".lnk"))
d1564 1
a1564 1
	    c[len - 4] = '\0';
d1749 1
a1749 1
  syscall_printf ("%d = readdir (%p) (%s)", dir, &de, de->d_name);
a1757 1
  BOOL ret = TRUE;
d1764 9
a1772 2

  if (dir->__handle == INVALID_HANDLE_VALUE && dir->__d_position == 0)
d1778 3
a1780 2
      DWORD lasterr = GetLastError ();
      if (dir->__handle == INVALID_HANDLE_VALUE && (lasterr != ERROR_NO_MORE_FILES))
d1782 1
a1782 1
	  res = geterrno_from_win_error ();
a1785 2
  else
    ret = FindNextFileA (dir->__handle, &buf);
d1787 2
a1788 2
  if (!(res = readdir_helper (dir, de, ret ? 0 : GetLastError (),
			      buf.dwFileAttributes, buf.cFileName)))
d1797 1
a1797 1
  syscall_printf ("%d = readdir (%p) (%s)", dir, &de, de->d_name);
@


1.172
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Drop generating
	path_conv for root.
@
text
@d1464 15
a1478 4
	  dir->__handle = CreateFile (get_win32_name (), GENERIC_READ,
				      wincap.shared (), NULL, OPEN_EXISTING,
				      FILE_FLAG_BACKUP_SEMANTICS, NULL);
	  if (dir->__handle == INVALID_HANDLE_VALUE)
d1480 1
a1480 1
	      __seterrno ();
d1483 1
d1684 1
a1684 1
  if (!status)
@


1.171
log
@	* fhandler_disk_file.cc (FS_IS_SAMBA): Move out of
	path_conv::hasgood_inode.
	(path_conv::is_samba): New method.
	(fhandler_base::fstat_by_handle): Don't even try to use
	FileIdBothDirectoryInformation on Samba.
	* path.h (class path_conv): Declare is_samba method.
@
text
@a1411 1
  path_conv rootdir ("/", PC_POSIX);
@


1.170
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Only set
	the dirent_get_d_ino flag on filesystems having useful File IDs.
	Add comment explaining why.
@
text
@d99 4
d124 1
a124 4
	 for now. */
#define FS_IS_SAMBA (FILE_CASE_SENSITIVE_SEARCH \
		     | FILE_CASE_PRESERVED_NAMES \
		     | FILE_PERSISTENT_ACLS)
d132 19
d1484 1
a1484 1
	      if (wincap.has_fileid_dirinfo ())
@


1.169
log
@	* dtable.cc (handle_to_fn): Accomodate new argument order in call to
	sys_wcstombs.
	* fhandler_disk_file.cc (fhandler_disk_file::readdir): Call sys_wcstombs
	instead of just wcstombs to accomodate OEM codepages.
	* miscfuncs.cc (sys_wcstombs): Split len argument in source and target
	length.  Always 0-terminate result in target string.
	* security.cc (lsa2wchar): Remove unused function.
	(lsa2str): Ditto.
	(get_lsa_srv_inf): Ditto.
	(get_logon_server): Accomodate new argument order in call to
	sys_wcstombs.
	(get_user_groups): Ditto.
	(get_user_local_groups): Ditto.
	(get_priv_list): Call sys_wcstombs directly instead of lsa2str.
	* uinfo.cc (cygheap_user::ontherange): Accomodate new argument order
	in call to sys_wcstombs.
	* winsup.h (sys_wcstombs): Change prototype to match new argument order.
@
text
@d1453 8
a1460 2
	  if (wincap.has_fileid_dirinfo ())
	    dir->__flags |= dirent_get_d_ino;
d1462 5
a1466 1
	    dir->__flags |= dirent_set_d_ino;
@


1.168
log
@	* environ.cc (struct parse_thing): Add transparent_exe option.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Accomodate
	transparent_exe option.  Add .exe suffix for links to executable files,
	if transparent_exe is set.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Remove .exe
	suffix if transparent_exe option is set.
	* path.cc (symlink_worker): Accomodate transparent_exe option.
	(realpath): Don't tack on .exe suffix if transparent_exe is set.
	* syscalls.cc (transparent_exe): New global variable.
	(unlink): Accomodate transparent_exe option.
	(open): Ditto.
	(link): Ditto.
	(rename): Ditto. Maybe add .exe suffix when renaming executable files.
	(pathconf): Accomodate transparent_exe option.
	* winsup.h: Declare transparent_exe.
@
text
@d1684 1
a1684 2
      wcstombs (fname, FileName, buf->FileNameLength / 2);
      fname[buf->FileNameLength / 2] = '\0';
@


1.167
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_9x): Remove
	useless code.
@
text
@a736 1
  path_conv newpc (newpath, PC_SYM_NOFOLLOW | PC_POSIX);
d738 1
d740 2
d762 26
a787 8
  /* Shortcut hack. */
  char new_lnk_buf[CYG_MAX_PATH + 5];
  if (allow_winsymlinks && pc.is_lnk_special () && !newpc.case_clash)
    {
      strcpy (new_lnk_buf, newpath);
      strcat (new_lnk_buf, ".lnk");
      newpath = new_lnk_buf;
      newpc.check (newpath, PC_SYM_NOFOLLOW);
@


1.166
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rewinddir): Remove label
	"out".  Move test for NULL __handle ...
	(fhandler_disk_file::rewinddir_9x): ... here.
@
text
@a1717 5
  else if (dir->__handle == INVALID_HANDLE_VALUE)
    {
      res = EBADF;		/* FIXME: Isn't this just a case of repeated reading beyond EOF? */
      goto out;
    }
@


1.165
log
@* fhandler_disk_file.cc (fhandler_disk_file::readdir): Don't close dir handle
when we hit EOF since rewwindir may reactivate it.
(fhandler_disk_file::readdir_9x): Eliminate superfluous temporary variable.
(fhandler_disk_file::closedir): Return EBADF when trying to close unopened DIR.
Reorganize slightly.  Return actual derived error value rather than always
returning 0.
@
text
@a1593 6
  if (!dir->__handle)
    {
      res = ENMFILE;
      goto out;
    }

a1687 1
out:
d1699 6
@


1.164
log
@* dir.cc (mkdir): Reorganize check for trailing dot to return correct error
when directory exists.
* fhandler_disk_file.cc (fhandler_disk_file::mkdir): Remove special test for
path ending in '.'.
@
text
@a1692 5
  else
    {
      CloseHandle (dir->__handle);
      dir->__handle = NULL;
    }
a1702 1
  HANDLE handle;
d1710 1
a1710 1
      handle = FindFirstFileA (dir->__d_dirname, &buf);
d1713 1
a1713 2
      dir->__handle = handle;
      if (handle == INVALID_HANDLE_VALUE && (lasterr != ERROR_NO_MORE_FILES))
d1721 1
a1721 1
      res = EBADF;
d1774 3
a1776 3
  if (dir->__handle && dir->__handle != INVALID_HANDLE_VALUE
      && ((wincap.is_winnt () && !CloseHandle (dir->__handle))
          || (!wincap.is_winnt () && !FindClose (dir->__handle))))
d1778 1
a1778 1
      __seterrno ();
d1781 13
d1795 1
a1795 1
  return 0;
@


1.163
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rewinddir): Simplify
	conditional.
@
text
@a1259 2
  else if (pc.exists ())
    set_errno (EEXIST);
@


1.162
log
@	* fhandler_disk_file.cc (d_cachepos): Rename from d_pos to distinct
	clearly from __d_position.  Change throughout.
	(fhandler_disk_file::rewinddir): Reset readdir cache on NT.
@
text
@d1770 1
a1770 1
  if (!wincap.is_winnt () && dir->__handle != INVALID_HANDLE_VALUE)
@


1.161
log
@	* fhandler_disk_file.cc (readdir_get_ino): Don't follow symlinks.
@
text
@d1365 1
a1365 1
#define d_pos(d)	(((struct __DIR_cache *) (d)->__d_dirname)->__pos)
d1400 1
a1400 1
      d_pos (dir) = 0;
d1605 1
a1605 1
  /* d_pos always refers to the next cache entry to use.  If it's 0, this means
d1607 1
a1607 1
  if (d_pos (dir) == 0)
d1633 1
a1633 1
      buf = (PFILE_ID_BOTH_DIR_INFORMATION) (d_cache (dir) + d_pos (dir));
d1635 1
a1635 1
        d_pos (dir) = 0;
d1637 1
a1637 1
	d_pos (dir) += buf->NextEntryOffset;
d1768 2
@


1.160
log
@	* fhandler_disk_file.cc (fhandler_disk_file::mkdir): In case or error,
	check for existance explicitely and set errno to EEXIST.
@
text
@d1565 1
a1565 1
      path_conv pc (fname);
@


1.159
log
@	* fhandler_disk_file.cc (DIR_NUM_ENTRIES): New define determining
	minimum number of dir entries which fit into the readdir cache.
	(DIR_BUF_SIZE): Define globally as size of readdir cache.
	(struct __DIR_cache): New structure used for readdir caching on NT.
	(d_dirname): Accessor for struct __DIR_cache, use throughout.
	(d_pos): Ditto.
	(d_cache): Ditto.
	(fhandler_disk_file::opendir): Allocate __d_dirname to contain readdir
	cache on NT.
	(fhandler_disk_file::readdir): Use buf as pointer into readdir cache.
	Implement readdir caching.
@
text
@d1260 2
@


1.158
log
@	* autoload.cc (NtQueryDirectoryFile): Define.
	* dir.cc (__opendir_with_d_ino): Just call opendir.
	(opendir): Remove CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO handling.
	(readdir_worker): Only try generating d_ino if it's 0.
	Utilize namehash of directories fhandler.  Call readdir_get_ino to
	generate d_ino for "..".
	(seekdir64): Keep dirent_set_d_ino flag.
	* fhandler.h (enum dirent_states): Add dirent_get_d_ino.
	(class fhandler_disk_file): Declare new private methods readdir_helper
	and readdir_9x.
	* fhandler_disk_file.cc (path_conv::hasgood_inode): New method to
	evaluate if a filesystem has reliable inode numbers.
	(fhandler_base::fstat_by_handle): Accomodate structure member name
	change from IndexNumber to FileId.
	(fhandler_base::fstat_helper): Call hasgood_inode here.
	(fhandler_disk_file::opendir): Call fhaccess only for real files.
	Don't append '*' to __d_dirname here, move to readdir_9x.  On NT,
	open directory handle here.  Set dirent_get_d_ino and dirent_set_d_ino
	flags according to wincap and filesystem.
	(fhandler_disk_file::readdir_helper): New method to implement readdir
	postprocessing only once.
	(readdir_get_ino_by_handle): New static function.
	(readdir_get_ino): New function to centralize inode number evaluation
	in case inode number hasn't been returned by NtQueryDirectoryFile.
	(fhandler_disk_file::readdir): Move old functionality to readdir_9x.
	Call readdir_9x when on 9x/Me.  Implement NT specific readdir here.
	(fhandler_disk_file::readdir_9x): Move 9x specific readdir here.
	(fhandler_disk_file::seekdir): Accomodate new NT readdir method.
	(fhandler_disk_file::closedir): Ditto.
	(fhandler_cygdrive::fstat): Set d_ino to namehash. Add comment.
	(fhandler_cygdrive::opendir): Call get_namehash to prepare later
	correct evaluation of d_ino.
	(fhandler_cygdrive::readdir): Replace recursion with loop. Evaluate
	drive's d_ino by calling readdir_get_ino.
	* fhandler_proc.cc (fhandler_proc::readdir): Set dirent_saw_dot and
	dirent_saw_dot_dot to avoid seeing . and .. entries twice.
	* fhandler_process.cc (fhandler_process::readdir): Ditto.
	* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
	* ntdll.h (STATUS_INVALID_PARAMETER): New define.
	(STATUS_INVALID_LEVEL): New define.
	(struct _FILE_INTERNAL_INFORMATION): Rename member IndexNumber to
	FileId (as in Nebbitt).
	* path.h (path_conv::hasgood_inode): Now implemented in
	fhandler_disk_file.cc.
	* wincap.h (wincaps::has_fileid_dirinfo): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (readdir_get_ino): Add declaration.
	* include/sys/dirent.h (struct dirent): Slightly rename structure
	members to accomodate changes.
	Remove __USE_EXPENSIVE_CYGWIN_D_INO handling and declaration of
	__opendir_with_d_ino.
@
text
@d1344 22
d1380 3
a1382 1
  else if ((dir->__d_dirname = (char *) malloc (len + 3)) == NULL)
d1397 2
a1398 1
      strcpy (dir->__d_dirname, get_win32_name ());
d1415 3
a1417 3
      len = strlen (dir->__d_dirname);
      if (len && !isdirsep (dir->__d_dirname[len - 1]))
        strcpy (dir->__d_dirname + len, "\\");
d1498 1
a1498 1
	  strcpy (fbuf, dir->__d_dirname);
d1589 4
d1603 25
a1627 6
#define DIR_BUF_SIZE (sizeof (FILE_ID_BOTH_DIR_INFORMATION) + 2 * CYG_MAX_PATH)
  PFILE_ID_BOTH_DIR_INFORMATION buf = (PFILE_ID_BOTH_DIR_INFORMATION)
				      alloca (DIR_BUF_SIZE);
  IO_STATUS_BLOCK io;
  wchar_t *FileName = buf->FileName;
  char fname[CYG_MAX_PATH];
d1629 1
a1629 1
  if ((dir->__flags & dirent_get_d_ino))
d1631 8
a1638 11
      status = NtQueryDirectoryFile (dir->__handle, NULL, NULL, 0, &io,
				     buf, DIR_BUF_SIZE,
				     FileIdBothDirectoryInformation,
				     TRUE, NULL, dir->__d_position == 0);
      /* FileIdBothDirectoryInformation isn't supported for remote drives
         on NT4 and 2K systems, and it's also not supported on 2K at all,
	 when accessing network drives on any remote OS.  We just fall
	 back to using a standard directory query in this case and note
	 this case using the dirent_get_d_ino flag. */
      if (!status)
        {
a1641 21
      else if (status == STATUS_INVALID_LEVEL
	       || status == STATUS_INVALID_PARAMETER)
	dir->__flags &= ~dirent_get_d_ino;
    }
  if (!(dir->__flags & dirent_get_d_ino))
    {
      status = NtQueryDirectoryFile (dir->__handle, NULL, NULL, 0, &io, buf,
				     DIR_BUF_SIZE, FileBothDirectoryInformation,
				     TRUE, NULL, dir->__d_position == 0);
      FileName = ((PFILE_BOTH_DIR_INFORMATION) buf)->FileName;
    }
  if (!status && de->d_ino == 0 && (dir->__flags & dirent_set_d_ino))
    {
      OBJECT_ATTRIBUTES attr;

      if (dir->__d_position == 0 && buf->FileNameLength == 2
          && FileName[0] == '.')
	de->d_ino = readdir_get_ino_by_handle (dir->__handle);
      else if (dir->__d_position == 1 && buf->FileNameLength == 4
	       && FileName[0] == '.' && FileName[1] == '.')
	de->d_ino = readdir_get_ino (dir, pc.normalized_path, true);
d1643 3
d1647 9
a1655 7
	  HANDLE hdl;
	  UNICODE_STRING upath = {buf->FileNameLength, CYG_MAX_PATH * 2,
	  			  FileName};
	  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE,
				      dir->__handle , NULL);
	  if (!NtOpenFile (&hdl, READ_CONTROL, &attr, &io,
			   wincap.shared (), 0))
d1657 11
a1667 2
	      de->d_ino = readdir_get_ino_by_handle (hdl);
	      CloseHandle (hdl);
a1669 4
    }

  if (!status)
    {
d1675 1
a1675 1
			      buf->FileAttributes, fname)))
@


1.157
log
@* fhandler_disk_file.cc (fhandler_disk_file::readdir): Fix test for
dirent_isroot to use the correct boolean operator.
@
text
@d4 1
a4 1
   2005 Red Hat, Inc.
d99 32
d174 2
a175 2
			   pfai->InternalInformation.IndexNumber.HighPart,
			   pfai->InternalInformation.IndexNumber.LowPart,
d350 5
a354 47
  /* Assume that if a drive has ACL support it MAY have valid "inodes".
     It definitely does not have valid inodes if it does not have ACL
     support.  Decouple from has_acls() which follows smbntsec setting. */
  switch ((pc.fs_flags () & FILE_PERSISTENT_ACLS)
	  && (nFileIndexHigh || nFileIndexLow)
	  ? pc.drive_type () : DRIVE_UNKNOWN)
    {
    case DRIVE_FIXED:
    case DRIVE_REMOVABLE:
    case DRIVE_CDROM:
    case DRIVE_RAMDISK:
      /* Although the documentation indicates otherwise, it seems like
	 "inodes" on these devices are persistent, at least across reboots. */
      buf->st_ino = (((__ino64_t) nFileIndexHigh) << 32)
		    | (__ino64_t) nFileIndexLow;
      break;

    case DRIVE_REMOTE:
      /* From own experiments and replies from the Cygwin mailing list,
	 we're now trying to figure out how to determine remote file
	 systems which are capable of returning persistent inode
	 numbers.  It seems that NT4 NTFS, when accessed remotly, and
	 some other remote file systems return unreliable values in
	 nFileIndex.  The common factor of these unreliable remote FS
	 seem to be that FILE_SUPPORTS_OBJECT_IDS isn't set, even though
	 this should have nothing to do with inode numbers.
	 An exception is Samba, which seems to return valid inode numbers
	 without having the FILE_SUPPORTS_OBJECT_IDS flag set.  So we're
	 testing for the flag values returned by a 3.x Samba explicitely
	 for now. */
#define FS_IS_SAMBA (FILE_CASE_SENSITIVE_SEARCH \
		     | FILE_CASE_PRESERVED_NAMES \
		     | FILE_PERSISTENT_ACLS)
      if ((pc.fs_flags () & FILE_SUPPORTS_OBJECT_IDS)
      	  || pc.fs_flags  () == FS_IS_SAMBA)
	{
	  buf->st_ino = (((__ino64_t) nFileIndexHigh) << 32)
	  		| (__ino64_t) nFileIndexLow;
	  break;
	}
      /*FALLTHRU*/
    default:
      /* Either the nFileIndex* fields are unreliable or unavailable.  Use the
	 next best alternative. */
      buf->st_ino = get_namehash ();
      break;
    }
d1369 1
a1369 1
  else if (fhaccess (R_OK) != 0)
d1384 6
a1389 1
      /* FindFirstFile doesn't seem to like duplicate /'s. */
d1391 2
a1392 4
      if (len == 0 || isdirsep (dir->__d_dirname[len - 1]))
	strcat (dir->__d_dirname, "*");
      else
	strcat (dir->__d_dirname, "\\*");  /**/
d1397 16
a1413 1
      dir->__flags = (pc.normalized_path[0] == '/' && pc.normalized_path[1] == '\0') ? dirent_isroot : 0;
d1429 2
a1430 1
fhandler_disk_file::readdir (DIR *dir, dirent *de)
d1432 1
a1432 26
  WIN32_FIND_DATA buf;
  HANDLE handle;
  int res;

  if (!dir->__handle)
    {
      res = ENMFILE;
      goto out;
    }
  if (dir->__handle == INVALID_HANDLE_VALUE && dir->__d_position == 0)
    {
      handle = FindFirstFileA (dir->__d_dirname, &buf);
      DWORD lasterr = GetLastError ();
      dir->__handle = handle;
      if (handle == INVALID_HANDLE_VALUE && (lasterr != ERROR_NO_MORE_FILES))
	{
	  res = geterrno_from_win_error ();
	  goto out;
	}
    }
  else if (dir->__handle == INVALID_HANDLE_VALUE)
    {
      res = EBADF;
      goto out;
    }
  else if (!FindNextFileA (dir->__handle, &buf))
d1439 1
a1439 1
	  strcpy (buf.cFileName, "dev");
d1444 1
a1444 1
	  strcpy (buf.cFileName, "proc");
d1450 2
a1451 2
	  strcpy (buf.cFileName, mount_table->cygdrive + 1);
	  buf.cFileName[mount_table->cygdrive_len - 2] = '\0';
d1456 4
a1459 1
	buf.dwFileAttributes = 0;
d1461 1
a1461 6
	{
	  res = geterrno_from_win_error ();
	  FindClose (dir->__handle);
	  dir->__handle = NULL;
	  goto out;
	}
d1466 1
a1466 1
  if (buf.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
d1468 1
a1468 1
      char *c = buf.cFileName;
d1474 1
a1474 1
	  strcpy (fbuf + strlen (fbuf) - 1, c);
a1480 1
  /* We get here if `buf' contains valid data.  */
d1482 1
a1482 1
    fnunmunge (de->d_name, buf.cFileName);
d1484 1
a1484 1
    strcpy (de->d_name, buf.cFileName);
d1488 4
a1491 1
	dir->__flags |= dirent_saw_dev;
d1493 4
a1496 1
	dir->__flags |= dirent_saw_proc;
d1500 207
a1706 1
	dir->__flags |= dirent_saw_cygdrive;
a1708 2
  dir->__d_position++;
  res = 0;
d1732 1
a1732 1
  if (dir->__handle != INVALID_HANDLE_VALUE)
d1746 2
a1747 1
      && FindClose (dir->__handle) == 0)
d1775 3
d1790 3
d1802 1
a1802 3
  if (!pdrive || !*pdrive)
    return ENMFILE;
  if (GetFileAttributes (pdrive) == INVALID_FILE_ATTRIBUTES)
d1804 4
a1808 1
      return readdir (dir, de);
a1809 1

d1812 1
@


1.156
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Try harder
	to determine remote file systems with reliable inode numbers.  Add
	longish comment.
@
text
@d1504 1
a1504 1
  if (dir->__flags && dirent_isroot)
@


1.155
log
@* include/cygwin/version.h: Bump API minor number to 151.
* dir.cc (__opendir_with_d_ino): New function.
(opendir): Set flag if we should be calculating inodes.
(readdir_worker): Calculate d_ino by calling stat if the user has asked for it.
(seekdir64): Maintain all persistent flag settings.
* fhandler.h (dirent_states): Add dirent_set_d_ino.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Reflect changes to
dirent structure.
* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
* include/sys/dirent.h (struct dirent): Coalesce two similar structures.
Remove all threads of the apparently highly confusing references to inodes.
Add support for calculating a real inode if __USE_EXPENSIVE_CYGWIN_D_INO is
defined.
@
text
@a328 3
    /* Temporarily enable remote drives until we find out why we disabled them
       in the first place. When we find out don't forget to write a comment! */
    case DRIVE_REMOTE:
d334 25
@


1.154
log
@* fhandler_disk_file.cc (fhandler_disk_file::opendir): Check posix path for
root rather than windows path.
@
text
@d1362 1
a1362 1
      dir->__d_dirent->d_version = __DIRENT_VERSION;
d1370 1
a1370 1
      dir->__d_dirent->d_fd = fd;
a1380 1
      dir->__d_dirhash = get_namehash ();
@


1.153
log
@whitespace cleanup to force snapshot.
@
text
@d1338 1
a1338 1
  path_conv rootdir ("/");
d1384 1
a1384 1
      dir->__flags = strcasematch (pc, rootdir) ? dirent_isroot : 0;
@


1.152
log
@	* (fhandler_disk_file::fchown): Remove execute bits from "sensible"
	permissions.  Use same setting as in symlink.
@
text
@d574 1
a574 1
        attrib = S_IFLNK | STD_RBITS | STD_WBITS;
d1309 1
a1309 1
         non-empty directory. */
d1314 1
a1314 1
         directory on a share, which is hosted by a 9x machine, the error
d1317 1
a1317 1
        err = ERROR_FILE_NOT_FOUND;
@


1.151
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Fix inode number
	debug output.
	(fhandler_disk_file::fchown): Always set sensible permission values
	when creating the ACL for symlinks.
@
text
@d572 1
a572 5
	 world to read the symlink and only the new owner to change it.
	 As for the execute permissions... they *seem* to be not
	 necessary, but for the sake of comleteness and to avoid
	 struggling with yet another Windows weirdness, the execute bits
	 are added as well.  */
d574 1
a574 1
        attrib = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;
@


1.150
log
@	* fhandler.cc (ACCFLAGS): Remove macro.
	(fhandler_base::get_default_fmode): Use O_ACCMODE instead of ACCFLAGS
	and or'ed read/write flags.
	(fhandler_base::open_9x): Use O_ACCMODE instead of or'ed read/write
	flags.
	(fhandler_base::open): Ditto.
	* fhandler_disk_file.cc (fhandler_base::open_fs): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
@
text
@d455 1
a455 1
  syscall_printf ("0 = fstat (, %p) st_atime=%x st_size=%D, st_mode=%p, st_ino=%d, sizeof=%d",
d457 1
a457 1
		  (int) buf->st_ino, sizeof (*buf));
d565 17
a581 3
    res = set_file_attribute (pc.has_acls (), get_io_handle (), pc,
			      uid, gid, attrib);

@


1.149
log
@* devices.h (_minor): Coerce argument to proper type before manipulating.
(_major): Ditto.
(device::is_fs_special): New function.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Set the size to 0 for
devices rather than reporting the size of the symlink.
(fhandler_disk_file::readdir): Use is_fs_special to determine if .lnk should be
stripped.
* path.cc: Rename symlink_info::is_symlink to symlink_info::issymlink
throughout.
(symlink_info::isdevice): New field.
(path_conv::check): Use 'isdevice' to determine if just-parsed entity is a
device rather than relying on non-zero major/minor.
(symlink_info::parse_device): Set isdevice to true if we've discovered a
device.
(symlink_info::check): Clear isdevice field prior to processing.  Use isdevice
to control debugging output.
(symlink_info::set): Set isdevice to false.
* path.h (path_conv::is_fs_special): New function.
* devices.cc: Regenerate.
@
text
@d959 1
a959 1
  if (pc.isdir () && (flags & (O_WRONLY | O_RDWR)))
@


1.148
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't rely on
	has_acl() state for evaluating inodes.  Temporarily(?) enable "real"
	inodes for remote drives.
@
text
@d397 1
d417 1
d1463 1
a1463 1
	  if (fpath.issymlink () || fpath.isspecial ())
@


1.147
log
@* fhandler_disk_file.cc (fhandler_base::utimes_fs): Use existing handle if
fhandler has one.
* times.cc (utimes): Scan open fds for matching paths and use existing fhandler
if one exists.
@
text
@d320 3
a322 2
     support. */
  switch (pc.has_acls () && (nFileIndexHigh || nFileIndexLow)
d329 3
@


1.146
log
@	* fhandler_disk_file.cc (fhandler_disk_file::rmdir): Convert an
	ERROR_INVALID_FUNCTION into an ERROR_FILE_NOT_FOUND.  Add comment
	to explain why.
@
text
@d868 1
d870 3
a872 2
  query_open (query_write_attributes);
  if (!open_fs (O_BINARY, 0))
d874 2
a875 6
      /* It's documented in MSDN that FILE_WRITE_ATTRIBUTES is sufficient
	 to change the timestamps.  Unfortunately it's not sufficient for a
	 remote HPFS which requires GENERIC_WRITE, so we just retry to open
	 for writing, though this fails for R/O files of course. */
      query_open (no_query);
      if (!open_fs (O_WRONLY | O_BINARY, 0))
d877 10
a886 2
	  syscall_printf ("Opening file failed");
	  return -1;
d888 1
d919 2
a920 1
  close ();
@


1.145
log
@	* fhandler_disk_file.cc: Change calls to pc.set_attributes into
	calls to pc.file_attributes throughout.
	* path.h (class path_conv): Remove superfluous set_attributes method.
@
text
@d1284 2
a1285 2
      /* On 9X ERROR_ACCESS_DENIED is returned
	 if you try to remove a non-empty directory. */
d1289 5
@


1.144
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Also use
	attributes stored in this->pc if call to GetFileInformationByHandle
	failed.
@
text
@d131 1
a131 1
	  pc.set_attributes (pfai->BasicInformation.FileAttributes);
d168 1
a168 1
    pc.set_attributes (local.dwFileAttributes);
d199 1
a199 1
      pc.set_attributes (local.dwFileAttributes);
@


1.143
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Only write
	attributes if call to GetFileInformationByHandle was successful.
@
text
@d165 1
@


1.142
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Fix copy/paste
	bug.
@
text
@d166 2
a167 2

  pc.set_attributes (local.dwFileAttributes);
@


1.141
log
@	* fhandler.h (fhandler_base::fstat_helper): Declare with additional
	file attributes argument.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Use
	file attributes evaluated from NtQueryFileInformation or
	FileInformationByHandle in call to fstat_helper.
	Set pc.fileattr from just evaluated file attributes here.
	(fhandler_base::fstat_by_name): Use file attributes evaluated from
	FindFileFirst or default attribute in call to fstat_helper.
	Set pc.fileattr from just evaluated file attributes here.
	(fhandler_base::fstat_helper): Use file attributes given as argument,
	not file attributes stored in this fhandler, since this information
	is potentially wrong.  Add comment to explain this.
	* path.h (has_attribute): New global inline function.
	(path_conv::set_attributes): New method to change fileattr.
@
text
@d398 1
a398 1
      if (::has_attribute (dwFileAttributes, FILE_ATTRIBUTE_READONLY)
@


1.140
log
@Remove some more unneeded 'return;'s throughout.
@
text
@d127 20
a146 16
	/* If the change time is 0, it's a file system which doesn't
	   support a change timestamp.  In that case use the LastWriteTime
	   entry, as in other calls to fstat_helper. */
	return fstat_helper (buf,
			 pfai->BasicInformation.ChangeTime.QuadPart ?
			 *(FILETIME *) &pfai->BasicInformation.ChangeTime :
			 *(FILETIME *) &pfai->BasicInformation.LastWriteTime,
			 *(FILETIME *) &pfai->BasicInformation.LastAccessTime,
			 *(FILETIME *) &pfai->BasicInformation.LastWriteTime,
			 pfvi->VolumeSerialNumber,
			 pfai->StandardInformation.EndOfFile.HighPart,
			 pfai->StandardInformation.EndOfFile.LowPart,
			 pfai->StandardInformation.AllocationSize.QuadPart,
			 pfai->InternalInformation.IndexNumber.HighPart,
			 pfai->InternalInformation.IndexNumber.LowPart,
			 pfai->StandardInformation.NumberOfLinks);
d167 1
d178 2
a179 1
		       local.nNumberOfLinks);
d198 1
d209 2
a210 1
			  1);
d215 2
a216 1
      res = fstat_helper (buf, ft, ft, ft, pc.volser (), 0, 0, -1LL, 0, 0, 1);
d282 5
a286 1
   creation times >= access or write times. */
d298 2
a299 1
			     DWORD nNumberOfLinks)
d345 5
a349 5
  else if (pc.has_attribute (FILE_ATTRIBUTE_COMPRESSED
			     | FILE_ATTRIBUTE_SPARSE_FILE)
      && get_io_handle () && !is_fs_special ()
      && !NtQueryInformationFile (get_io_handle (), &st, (PVOID) &fci,
				  sizeof fci, FileCompressionInformation))
d374 4
a377 2
  if (!get_file_attribute (pc.has_acls (), is_fs_special () ? NULL: get_io_handle (),
			   get_win32_name (), &buf->st_mode, &buf->st_uid, &buf->st_gid))
d380 2
a381 1
      if (pc.has_attribute (FILE_ATTRIBUTE_READONLY) && !pc.issymlink ())
d398 2
a399 1
      if (!pc.has_attribute (FILE_ATTRIBUTE_READONLY) && !pc.issymlink ())
@


1.139
log
@* cygthread.cc (cygthread::cygthread): Add more info to fatal error.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Temporarily remove
insertion of /dev into root directory.
* path.cc (path_conv::check): Ditto.
@
text
@a1555 1
  return;
@


1.138
log
@* sigproc.h (set_signal_mask): Remove default on second parameter and make pass
by reference.
* signal.cc (abort): Accommodate change to set_signal_mask.
* select.cc (pselect): Ditto.
* exceptions.cc (handle_sigsuspend): Ditto.
(ctrl_c_handler): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Return ENMFILE if
__handle is not set.  Set __handle to NULL when out of files.
(fhandler_disk_file::rewinddir): Don't close handle if it's NULL.
(fhandler_disk_file::closedir): Ditto.
@
text
@d1384 1
a1384 1
      else if (!(dir->__flags & dirent_saw_dev))
@


1.137
log
@* dir.cc (readdir_worker): Make static.  Only add '.' and '..' when readdir
fails due to ENMFILE.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Only close handle on
error != ENMFILE.
@
text
@d1358 5
d1407 2
a1408 5
	  if (res != ENMFILE)
	    {
	      FindClose (dir->__handle);
	      dir->__handle = INVALID_HANDLE_VALUE;
	    }
d1474 2
a1475 1
      FindClose (dir->__handle);
d1485 2
a1486 2
  if (dir->__handle != INVALID_HANDLE_VALUE &&
      FindClose (dir->__handle) == 0)
@


1.136
log
@* cygerrno.h (geterrno_from_win_error): Change declaration to default to using
GetLastError and EACCESS.
* cygwin.din: Export readdir_r.
* include/cygwin/version.h: Bump API version number to 138.
* syscalls.cc (readdir_worker): New function, renamed from old readdir()
function.
(readdir): Use readdir_worker.
(readdir_r): New function.
* fhandler.h (fhandler_base::readdir): Accommodate second argument indicating
dirent buffer.
(fhandler_disk_file::readdir): Ditto.
(fhandler_cygdrive::readdir): Ditto.
(fhandler_proc::readdir): Ditto.
(fhandler_netdrive::readdir): Ditto.
(fhandler_registry::readdir): Ditto.
(fhandler_process::readdir): Ditto.
* fhandler.cc (fhandler_base::readdir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Ditto.
* fhandler_cygdrive.cc (fhandler_cygdrive::readdir): Ditto.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_netdrive.cc (fhandler_netdrive::readdir): Ditto.
* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
* fhandler_process.cc (fhandler_process::readdir): Ditto.
@
text
@d1402 5
a1406 2
	  FindClose (dir->__handle);
	  dir->__handle = INVALID_HANDLE_VALUE;
@


1.135
log
@* fhandler.h (dirent_states): Add dirent_saw_proc.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Fill in "proc" if it is
the root dir and it is missing.
@
text
@d1351 2
a1352 2
struct dirent *
fhandler_disk_file::readdir (DIR *dir)
d1356 1
a1356 1
  struct dirent *res = NULL;
d1358 1
a1358 2
  if (dir->__handle == INVALID_HANDLE_VALUE
      && dir->__d_position == 0)
d1365 2
a1366 2
	  seterrno_from_win_error (__FILE__, __LINE__, lasterr);
	  return res;
d1370 4
a1373 1
    return res;
d1401 1
a1401 1
	  DWORD lasterr = GetLastError ();
d1404 1
a1404 6
	  /* POSIX says you shouldn't set errno when readdir can't
	     find any more files; so, if another error we leave it set. */
	  if (lasterr != ERROR_NO_MORE_FILES)
	      seterrno_from_win_error (__FILE__, __LINE__, lasterr);
	  syscall_printf ("%p = readdir (%p)", res, dir);
	  return res;
d1427 1
a1427 1
    fnunmunge (dir->__d_dirent->d_name, buf.cFileName);
d1429 1
a1429 1
    strcpy (dir->__d_dirent->d_name, buf.cFileName);
d1432 1
a1432 1
      if (strcasematch (dir->__d_dirent->d_name, "dev"))
d1434 1
a1434 1
      else if (strcasematch (dir->__d_dirent->d_name, "proc"))
d1436 2
a1437 2
      if (strlen (dir->__d_dirent->d_name) == mount_table->cygdrive_len - 2
	  && strncasematch (dir->__d_dirent->d_name, mount_table->cygdrive + 1,
d1443 3
a1445 3
  res = dir->__d_dirent;
  syscall_printf ("%p = readdir (%p) (%s)", &dir->__d_dirent, dir,
		  buf.cFileName);
d1526 2
a1527 2
struct dirent *
fhandler_cygdrive::readdir (DIR *dir)
d1530 1
a1530 1
    return NULL;
d1534 1
a1534 1
      return readdir (dir);
d1537 2
a1538 2
  *dir->__d_dirent->d_name = cyg_tolower (*pdrive);
  dir->__d_dirent->d_name[1] = '\0';
d1541 2
a1542 3
  syscall_printf ("%p = readdir (%p) (%s)", &dir->__d_dirent, dir,
		  dir->__d_dirent->d_name);
  return dir->__d_dirent;
@


1.134
log
@* fhandler.h (dirent_states): Add dirent_isroot, dirent_saw_cygdrive,
dirent_saw_dev.
* dir.cc (opendir): Don't zero __flags here.  Push that responsibility to
opendir methods.
(seekdir): Preserve dirent_isrrot in __flags.
(rewinddir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set dirent_isroot
appropriately.
(fhandler_disk_file::readdir): Fill in "cygdrive" and "dev" if it is the root
dir and they are missing.
* fhandler_process.cc (fhandler_process::opendir): Set __flags here.
* fhandler_virtual.cc (fhandler_virtual::opendir): Set __flags here.
@
text
@d1382 5
d1433 1
a1433 3
  if (!(dir->__flags && dirent_isroot))
    /* nothing */;
  else
d1437 2
@


1.133
log
@* fhandler_disk_file.cc (fhandler_base::pread): Don't move file offset pointer
after I/O.
(fhandler_base::pwrite): Ditto.
@
text
@d1290 1
d1336 1
a1336 1

d1374 30
a1403 9
      DWORD lasterr = GetLastError ();
      FindClose (dir->__handle);
      dir->__handle = INVALID_HANDLE_VALUE;
      /* POSIX says you shouldn't set errno when readdir can't
	 find any more files; so, if another error we leave it set. */
      if (lasterr != ERROR_NO_MORE_FILES)
	  seterrno_from_win_error (__FILE__, __LINE__, lasterr);
      syscall_printf ("%p = readdir (%p)", res, dir);
      return res;
d1428 11
d1442 2
a1443 2
  syscall_printf ("%p = readdir (%p) (%s)",
		  &dir->__d_dirent, dir, buf.cFileName);
@


1.132
log
@* fhandler.h (fhandler_base::pread): Declare new function.
(fhandler_base::pwrite): Ditto.
(fhandler_disk_file::pread): Ditto.
(fhandler_disk_file::pwrite): Ditto.
* fhandler.cc (fhandler_base::pread): Define new function.
(fhandler_base::pwrite): Ditto.
* fhandler_disk_file.cc (fhandler_base::pread): Ditto.
(fhandler_base::pwrite): Ditto.
* syscalls.cc (pread): Define new function.
(pwrite): Ditto.
* cygwin.din: Export pread, pwrite.
* include/sys/ioctl.h: Guard some _IO* declarations to avoid conflict with
socket.h.
@
text
@d990 5
a994 2
  ssize_t res = lseek (offset, SEEK_SET);
  if (res >= 0)
d998 4
a1001 1
      res = (ssize_t) tmp_count;
d1010 10
a1019 3
  ssize_t res = lseek (offset, SEEK_SET);
  if (res >= 0)
    res = write (buf, count);
@


1.131
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d987 24
@


1.130
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d417 1
a417 1
		  (void) SetFilePointer (get_handle (), cur, NULL, FILE_BEGIN);
d1337 1
a1337 1
      (void) FindClose (dir->__handle);
d1366 1
a1366 1
    (void) fnunmunge (dir->__d_dirent->d_name, buf.cFileName);
d1397 1
a1397 1
      (void) FindClose (dir->__handle);
@


1.129
log
@	* fhandler_disk_file.cc (fhandler_disk_file::facl): Add missing break.
@
text
@d446 1
a446 1
fhandler_disk_file::touch_ctime (void)
d969 6
a974 3
  /* Changing inode data requires setting ctime (only 9x). */
  if (has_changed ())
    touch_ctime ();
@


1.128
log
@* fhandler_disk_file.cc (fhandler_disk_file::fchown): Make sure that disk open
is called in case we're passed in a non-existent device.
@
text
@d629 1
@


1.127
log
@* fhandler.h (fhandler_base::mkdir): New virtual method.
(fhandler_base::rmdir): Ditto.
(fhandler_disk_file:mkdir): New method.
(fhandler_disk_file:rmdir): Ditto.
* dir.cc (mkdir): Implement with fhandlers.
(rmdir): Ditto.
* fhandler.cc (fhandler_base::mkdir): New virtual method.
(fhandler_base::rmdir): Ditto.
(fhandler_disk_file::mkdir): New method.
(fhandler_disk_file::rmdir): Ditto.

fhandler_random.cc: white space.
@
text
@d531 1
a531 1
      if (!(oret = open (O_BINARY, 0)))
@


1.126
log
@* fhandler.h (fhandler_cygdrive::seekdir): Delete declaration.
(fhandler_cygdrive::seekdir): Delete.
* fhandler.h (fhandler_cygdrive::iscygdrive_root): Delete method.
(fhandler_cygdrive::telldir): Delete declaration.
* fhandler_disk_file.cc: Remove all uses of fhandler_cygdrive::iscygdrive_root.
(fhandler_disk_file::mkdir): New method.
(fhandler_disk_file::rmdir): Ditto.
(fhandler_cygdrive::telldir): Delete.
@
text
@d1141 102
@


1.125
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Check
	return code from GetFileSize and set file size to 0 if necessary.
	* fhandler_netdrive.cc (fhandler_netdrive::fstat): Set permissions
	to read/execute for all.
@
text
@a1328 2
  if (!iscygdrive_root ())
    return fhandler_disk_file::fstat (buf);
d1342 1
a1342 1
  if (dir && iscygdrive_root () && !ndrives)
a1350 2
  if (!iscygdrive_root ())
    return fhandler_disk_file::readdir (dir);
a1367 12
_off64_t
fhandler_cygdrive::telldir (DIR *dir)
{
  return fhandler_disk_file::telldir (dir);
}

void
fhandler_cygdrive::seekdir (DIR *dir, _off64_t loc)
{
  return fhandler_disk_file::seekdir (dir, loc);
}

a1370 2
  if (!iscygdrive_root ())
    return fhandler_disk_file::rewinddir (dir);
a1378 2
  if (!iscygdrive_root ())
    return fhandler_disk_file::closedir (dir);
@


1.124
log
@Remove PC_FULL from path_conv usage throughout.
* path.h (enum pathconv_arg): Change PC_FULL to PC_NOUILL.
* path.cc (path_conv::check): Test for PC_NOFULL rather than !PC_FULL.
(cygwin_conv_to_win32_path): Use PC_NOFULL to force non-absolute path.
@
text
@d151 2
a152 1
  /* GetFileInformationByHandle will fail if it's given stdio handle or pipe*/
d157 4
@


1.123
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Don't treat
	inability to open file as failure if only SetFileAttributes is
	going to be called.  Only call set_file_attribute if really necessary.
@
text
@d684 1
a684 1
  path_conv newpc (newpath, PC_SYM_NOFOLLOW | PC_FULL | PC_POSIX);
d714 1
a714 1
      newpc.check (newpath, PC_SYM_NOFOLLOW | PC_FULL);
@


1.122
log
@white space and minor comment cleanup.
@
text
@d469 6
a474 1
	return -1;
d477 1
a477 1
  if (wincap.has_security ())
@


1.121
log
@Actually check in files.
@
text
@d123 1
a123 1
        }
d763 1
a763 1
      ret = BackupWrite (get_handle (), (LPBYTE) &stream_id, size,	
@


1.120
log
@	* fhandler_disk_file.cc (fhandler_base::utimes_fs): Ignore
	ERROR_NOT_SUPPORTED to workaround Win9x weirdness.
	* path.cc (symlink_info::check): Remap ERROR_INVALID_FUNTION to
	ERROR_FILE_NOT_FOUND for the same reason.
@
text
@d222 1
a222 1
      if (nohandle ())
d328 1
a328 1
      && get_io_handle ()
d355 2
a356 2
  if (!get_file_attribute (pc.has_acls (), get_io_handle (), get_win32_name (),
			   &buf->st_mode, &buf->st_uid, &buf->st_gid))
d376 1
a376 1
      if (!pc.has_attribute (FILE_ATTRIBUTE_READONLY))
@


1.119
log
@	* fhandler_disk_file.cc (fhandler_base::utimes_fs): Drop touching
	ChangeTime.
@
text
@d873 3
a875 1
  if (!res)
@


1.118
log
@* dcrt0.cc (do_global_dtors): Run DLL dtors.
(__main): Don't rely on atexit to run dtors.
(do_exit): Specifically call do_global_dtors here.
(cygwin_exit): Ditto.
* dll_init.cc (dll_global_dtors): Make global.  Only run dtors once.
(dll_list::init): Just set flag that dtors should be run.  Don't rely on
atexit.
* dll_init.h (dll_global_dtors): Declare.
* exceptions.cc (sigrelse): Define.
* path.h (is_fs_device): New method.
(is_lnk_special): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::link): Use "is_lnk_special" rather
than "is_lnk_symlink".
* syscalls.cc (rename): Ditto.
* hookapi.cc (ld_preload): Use colon as a separator rather than space.
@
text
@d836 1
a836 1
  FILETIME lastaccess, lastwrite, lastchange;
a864 2
  /* Update ctime */
  timeval_to_filetime (&tmp[0], &lastchange);
d869 1
a869 1
  BOOL res = SetFileTime (get_handle (), &lastchange, &lastaccess, &lastwrite);
@


1.117
log
@	* cygerrno.h (__seterrno_from_nt_status): Define. Always set Win32
	error code as well as errno. Use throughout where errno is set from
	NT status.
	(set_errno): Evaluate val only once.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Fix typo in
	debug output.
	* fhandler_mem.cc (fhandler_dev_mem::open): Rely on
	__seterrno_from_nt_status setting Win32 error code in debug output.
	* fhandler_proc.cc (format_proc_uptime): Ditto.
	(format_proc_stat): Ditto.
	* fhandler_process.cc (format_process_stat): Ditto.
	* sysconf.cc (sysconf): Ditto.
@
text
@d704 1
a704 1
  if (allow_winsymlinks && pc.is_lnk_symlink () && !newpc.case_clash)
d803 1
a803 1
      if (!allow_winsymlinks && pc.is_lnk_symlink ())
@


1.116
log
@* fhandler.h (fhandler_base::utimes_fs): New method.
* fhandler.cc (fhandler_base::utimes): Call utimes_fs if on-disk special file.
* fhandler_disk_file.cc (fhandler_disk_file::utimes): Use utimes_fs.
(fhandler_base::utimes_fs): Handle on-disk device files.
@
text
@d144 1
a144 1
      debug_printf ("%u = NtQuerynformationFile)",
@


1.115
log
@	* fhandler_disk_file.cc (fhandler_disk_file::utimes): Don't set errno
	if open fails, it has already been set by open.
@
text
@d830 6
d840 1
a840 1
  if (!open (O_BINARY, 0))
d847 1
a847 1
      if (!open (O_WRONLY | O_BINARY, 0))
d868 8
a875 1
  if (!SetFileTime (get_handle (), &lastchange, &lastaccess, &lastwrite))
a876 1
      DWORD errcode = GetLastError ();
d881 1
@


1.114
log
@	* autoload.cc (NtQueryVolumeInformationFile): Add.
	* fhandler.cc (fhandler_base::raw_write): Don't touch has_changed flag.
	* fhandler.h (enum change_state): Remove.
	(fhandler_base::status): Revert has_changed to a simple bit.
	(fhandler_base::fstat_helper): Add nAllocSize parameter.  Rename
	ftCreationTime to ftChangeTime.
	* fhandler_disk_file.cc:
	Call fstat_helper with additional
	allocation size throughout.
	(fhandler_base::fstat_by_handle): Use NT native functions to get
	full file information on NT.  Call fstat_helper with LastWriteTime
	as ctime, if ChangeTime is not available.
	(fhandler_base::fstat_by_name): Call fstat_helper with LastWriteTime
	as ctime.
	(fhandler_base::fstat_helper): Add comment. Drop special FAT
	handling since it's useless. Use nAllocSize for st_blocks if available.
	(fhandler_disk_file::touch_ctime): Only touch LastWriteTime.
	(fhandler_disk_file::fchmod): Set has_changed on 9x only.
	(fhandler_disk_file::fchown): Don't set has_changed.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::ftruncate): Ditto.
	(fhandler_disk_file::link): Set has_changed on 9x only and on original
	file only.
	(fhandler_base::open_fs): Don't set has_changed in O_TRUNC case.
	* ntdll.h (FILE_BASIC_INFORMATION): Define.
	(FILE_STANDARD_INFORMATION): Define.
	(FILE_INTERNAL_INFORMATION): Define.
	(FILE_EA_INFORMATION): Define.
	(FILE_ACCESS_INFORMATION): Define.
	(FILE_POSITION_INFORMATION): Define.
	(FILE_MODE_INFORMATION): Define.
	(FILE_ALIGNMENT_INFORMATION): Define.
	(FILE_NAME_INFORMATION): Don't define with arbitrary FileName size.
	(FILE_ALL_INFORMATION): Define.
	(FILE_INFORMATION_CLASS): Add FileAllInformation.
	(FILE_FS_VOLUME_INFORMATION): Define.
	(FS_INFORMATION_CLASS): Define.
	(NtQueryVolumeInformationFile): Define.
@
text
@a843 1
	  __seterrno ();
@


1.113
log
@	* dcrt0.cc (dll_crt0_1): Don't call set_cygwin_privileges on 9x.

	* fhandler.h (enum change_state): Add.
	(fhandler_base::status): Add a bit to has_changed flag.
	(fhandler_base::has_changed): Implement with type change_state.
	* fhandler.cc (fhandler_base::raw_write): Accomodate type change
	of has_changed.
	* fhandler_disk_file.cc )fhandler_disk_file::touch_ctime): Also
	touch modification time if has_changed == data_changed.
	(fhandler_disk_file::fchmod): Also open on 9x, otherwise we can't
	touch ctime.  Accomodate type change of has_changed.
	(fhandler_disk_file::fchown): Accomodate type change of has_changed.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::ftruncate): Ditto.
	(fhandler_disk_file::link): Ditto.
	(fhandler_base::open_fs): Ditto.
@
text
@d103 45
d159 1
a159 1
		       local.ftCreationTime,
d165 1
d188 1
a188 1
			  local.ftCreationTime,
d194 1
d202 1
a202 1
      res = fstat_helper (buf, ft, ft, ft, pc.volser (), 0, 0, 0, 0, 1);
d263 6
d271 1
a271 1
			     FILETIME ftCreationTime,
d277 1
a284 8
  /* This is for FAT filesystems, which don't support atime/ctime */
  if (ftLastAccessTime.dwLowDateTime == 0
      && ftLastAccessTime.dwHighDateTime == 0)
    ftLastAccessTime = ftLastWriteTime;
  if (ftCreationTime.dwLowDateTime == 0
      && ftCreationTime.dwHighDateTime == 0)
    ftCreationTime = ftLastWriteTime;

d287 1
a287 1
  to_timestruc_t (&ftCreationTime, &buf->st_ctim);
d322 6
a327 3
  /* On compressed and sparsed files, we request the actual amount of bytes
     allocated on disk.  */
  if (pc.has_attribute (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE)
d331 2
d335 1
a335 1
    /* Just compute no. of blocks from file size. */
d434 1
d448 1
a448 2
  if (!SetFileTime (get_io_handle (), &ft, NULL,
		    has_changed () == data_changed ? &ft : NULL))
d451 1
a451 1
    has_changed (no_change);
d497 2
a498 2
  if (!res)
    has_changed (inode_changed);
d530 2
a531 7
    {
      res = set_file_attribute (pc.has_acls (), get_io_handle (), pc,
				uid, gid, attrib);
      /* Set ctime on success. */
      if (!res)
	has_changed (inode_changed);
    }
a624 4
  /* Set ctime on success. */
  if (!res && cmd == SETACL)
    has_changed (inode_changed);

a670 3
	  /* Set ctime on success. */
	  if (!res)
	    has_changed (data_changed);
a801 2
      /* Set ctime on success. */
      has_changed (inode_changed);
d816 3
a818 2
  /* Set ctime on success, also on the copy. */
  has_changed (inode_changed);
d823 1
a823 4
    {
      fh.has_changed (inode_changed);
      fh.close ();
    }
a934 4
  /* O_TRUNC on existing file requires setting ctime. */
  if ((flags & (O_CREAT | O_TRUNC)) == O_TRUNC)
    has_changed (data_changed);

d946 1
a946 1
  /* Changing file data requires setting ctime. */
@


1.112
log
@	* cygheap.cc (cygheap_init): Accomodate set_process_privilege change.
	* cygheap.h (cygheap_user::curr_primary_token): New member.
	(cygheap_user::primary_token): New method.
	(cygheap_user::deimpersonate): Always revert to processes'
	impersonation token.
	(cygheap_user::reimpersonate): Set processes' or setuid token as
	necessary.
	(cygheap_user::has_impersonation_tokens): Look for curr_primary_token
	value.
	(cygheap_user::close_impersonation_tokens): Close curr_primary_token
	here if necessary.  Don't reset token values to NO_IMPERSONATION since
	that's done in uinfo_init anyway.
	(init_cygheap::luid): New LUID array keeping privilege LUIDs.
	* cygtls.cc (_cygtls::init_thread): Call cygheap->user.reimpersonate.
	* dcrt0.cc (hProcToken): New global variable to keep process token.
	(hProcImpToken): Ditto for process impersonation token.
	(dll_crt0_0): Open process token here once.  Duplicate to create
	hProcImpToken.
	(dll_crt0_1): Call set_cygwin_privileges.
	* environ.cc (allow_ntea): Drop duplicate declaration.
	(allow_smbntsec): Ditto.
	(set_traverse): Only set allow_traverse here.
	(environ_init): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Drop call to
	enable_restore_privilege.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	* fork.cc (fork_child): Move call to cygheap->user.reimpersonate after
	syn with parent. Call set_cygwin_privileges.
	* grp.cc (internal_getgroups): Use hProcImpToken instead of opening
	process token.
	* path.cc (fs_info::update): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges.
	* registry.cc (load_registry_hive): Drop setting restore privilege
	since it's already set if available.
	* sec_helper.cc: Include cygtls.h.
	(cygpriv): Privilege string array.
	(privilege_luid): New function, evaluate LUID from cygpriv_idx.
	(privilege_luid_by_name): New function, evaluate LUID from privilege
	string.
	(privilege_name): New function, evaluate privilege string from
	cygpriv_idx.
	(set_privilege): New static function called by set_process_privilege
	and set_thread_privilege.  Call privilege_luid to get privilege LUID.
	Fix bug in return value evaluation. Improve debug output.
	(set_cygwin_privileges): New function.
	(set_process_privilege): Remove.
	(enable_restore_privilege): Remove.
	* security.cc (allow_traverse): New global variable.
	(sys_privs): Change type to cygpriv_idx and store privilege indices
	instead of strings.
	(SYSTEM_PRIVILEGES_COUNT): Renamed from SYSTEM_PERMISSION_COUNT.
	(get_system_priv_list): Don't use numerical constant in malloc call.
	Use privilege_luid to get privilege LUIDs.
	(get_priv_list): Call privilege_luid_by_name to get LUIDs. Improve
	inner privilege LUID comparison loop.
	(create_token): Enable create token privilege using
	push/pop_self_privileges. Use hProcToken instead of opening process
	token. Use default DACL when duplicating token.
	(subauth): Enable tcb privilege using push/pop_self_privileges.
	Use sec_none instead of homw made security attributes when duplicating
	token.
	(check_file_access): Don't duplicate access token, use active
	impersonation token as is.
	* security.h (enum cygpriv_idx): New enumeration type enumerating
	possible privileges.
	(privilege_luid): Declare new function.
	(privilege_luid_by_name): Ditto.
	(privilege_name): Ditto.
	(allow_traverse): Declare.
	(set_privilege): Declare function.
	(set_process_privilege): Define as macro.
	(enable_restore_privilege): Remove declaration.
	(_push_thread_privilege): Define macro.
	(push_thread_privilege): Ditto.
	(pop_thread_privilege): Ditto.
	(pop_self_privilege): Ditto.
	* spawn.cc (spawn_guts): Use cygheap->user.primary_token instead of
	cygheap->user.token.
	* syscalls.cc (statvfs): Bypass traverse checking when retrieving
	volume information using push/pop_thread_privileges. Rearrange code
	to simplify push/pop bracketing.
	(seteuid32): Use hProcToken instead of opening process token. Call
	cygheap->user.deimpersonate instead of RevertToSelf.  Create
	impersonation token from primary internal or external token.  Set
	cygheap->user.curr_primary_token and cygheap->user.current_token
	privileges once here.  Drop "failed" and "failed_ptok" labels.
	Drop setting DefaultDacl of process token.
	(setegid32): Use hProcToken and hProcImpToken instead of opening
	process token. Always reimpersonate afterwards.
	* uinfo.cc (cygheap_user::init): Use hProcToken instead of opening
	process token.
	(internal_getlogin): Ditto. Set hProcImpToken, too.
	(uinfo_init): Initialize cygheap->user.curr_primary_token.
	* winsup.h (hProcToken): Declare.
	(hProcImpToken): Declare.
@
text
@d394 4
a397 1
  if (!SetFileTime (get_io_handle (), &ft, NULL, NULL))
d400 1
a400 1
    has_changed (false);
d413 8
a422 7
      if (!get_io_handle () && pc.has_acls ())
	{
	  query_open (query_write_control);
	  if (!(oret = open (O_BINARY, 0)))
	    return -1;
	}

d447 1
a447 1
    has_changed (true);
d484 1
a484 1
	has_changed (true);
d581 1
a581 1
    has_changed (true);
d631 1
a631 1
	    has_changed (true);
d764 1
a764 1
      has_changed (true);
d780 1
a780 1
  has_changed (true);
d786 1
a786 1
      fh.has_changed (true);
d902 1
a902 1
    has_changed (true);
@


1.111
log
@	Unify usage of CYG_MAX_PATH throughout.  Change buffers from
	size CYG_MAX_PATH + 1 to CYG_MAX_PATH.  Change length tests
	accordingly.
@
text
@a411 1
      enable_restore_privilege ();
a462 1
  enable_restore_privilege ();
a548 2
      if (cmd == SETACL)
	enable_restore_privilege ();
@


1.110
log
@* Makefile.in (DLL_OFILES): Add hookapi.o.  Eliminate some cruft.
* cygheap.h (cygheap_types): Add new enum: HEAP_1_HOOK.
(hook_chain): New struct.
(init_cygheap::hooks): Define new element.
* cygheap.cc (cygheap_fixup_in_child): Zero hook chain on exec.
* dcrt0.cc (dll_crt0_1): Call ld_preload just before calling main function.
* external.cc (cygwin_internal): Implement CW_HOOK.
* fork.cc (fork_child): Call fixup_hooks_after_fork.
* init.cc (cygwin_hmodule): Reinstate after a long absence.
* include/sys/cygwin.h: Define CW_HOOK.
* hookapi.cc: New file.
* select.cc (start_thread_socket): Add debugging output.
* fhandler_disk_file.cc (fhandler_disk_file::fchmod): gcc 4.x accommodation.
* fhandler_socket.cc (fhandler_socket::connect): Make sure that err is
initialized.
@
text
@d1196 1
a1196 1
	  char fbuf[CYG_MAX_PATH + 1];
@


1.109
log
@	* fhandler_disk_file.cc (fhandler_disk_file::utimes): Handle opening
	directories under 9x gracefully.
@
text
@d432 1
a432 1
    (DWORD) pc &= ~FILE_ATTRIBUTE_READONLY;
d434 1
a434 1
    (DWORD) pc |= FILE_ATTRIBUTE_READONLY;
@


1.108
log
@missing file from previous checkin.
@
text
@a809 4
	  if (pc.isdir ()) /* What we can do with directories more? */
	    return 0;
	    
	  __seterrno ();
d814 3
@


1.107
log
@	* fhandler_disk_file.cc (fhandler_disk_file::touch_ctime): Replace
	GetSystemTime/SystemTimeToFileTime with GetSystemTimeAsFileTime.
	* times.cc (time_as_timestruc_t): Ditto.
	(time): Ditto.
@
text
@d604 1
a604 1
        {
d612 1
a612 1
	        {
d618 2
a619 2
		  		  r, get_output_handle ());
	        }
d802 1
a802 1
         to change the timestamps.  Unfortunately it's not sufficient for a
d807 1
a807 1
        {
d815 1
a815 1
        }
d1228 4
a1231 4
    rewinddir (dir);
    while (loc > dir->__d_position)
      if (!readdir (dir))
	break;
d1329 1
a1329 9
  if (!iscygdrive_root ())
    return fhandler_disk_file::seekdir (dir, loc);

  for (pdrive = get_win32_name (), dir->__d_position = -1; *pdrive;
       pdrive = strchr (pdrive, '\0') + 1)
    if (++dir->__d_position >= loc)
      break;

  return;
@


1.106
log
@* fhandler_disk_file.cc (fhandler_cygdrive::closedir): Return 0 when closing
cygdrive_root.
@
text
@a390 1
  SYSTEMTIME st;
d393 1
a393 2
  GetSystemTime (&st);
  SystemTimeToFileTime (&st, &ft);
@


1.105
log
@	* fhandler.h (fhandler_base::fstat_helper): Declare with additional
	dwVolumeSerialNumber argument.  Drop default values for last three
	arguments.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Pass
	dwVolumeSerialNumber from GetFileInformationByHandle to fstat_helper.
	(fhandler_base::fstat_by_name): Pass pc.volser () to fstat_helper.
	Accomodate dropping default values for last three arguments of
	fstat_helper.
	(fhandler_base::fstat_helper): Add dwVolumeSerialNumber argument.
	Use for st_dev member unless 0 in which case pc.volser () is used.
@
text
@d1358 1
a1358 1
  return -1;
@


1.104
log
@	* fhandler.h (enum query_state): Add query_write_attributes state.
	(fhandler_base::status.query_open): Add a bit to make room for more
	states.
	(class fhandler_base): Declare new method utimes.
	(class fhandler_socket): Ditto.
	(class fhandler_disk_file): Ditto.
	(fhandler_disk_file::fhandler_disk_file): Add constructor with
	path_conv parameter.
	* fhandler.cc (fhandler_base::open): Add query_write_attributes
	handling.
	(fhandler_base::utimes): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Simplify.
	Open file with query_write_attributes instead of query_write_control.
	(fhandler_disk_file::utimes): New method.
	(fhandler_disk_file::fhandler_disk_file): Add constructor with
	path_conv parameter setting pc member immediately.
	* fhandler_socket.cc (fhandler_socket::fchmod): Use new
	fhandler_disk_file constructor.
	(fhandler_socket::fchown): Ditto.
	(fhandler_socket::facl): Ditto.
	(fhandler_socket::link): Ditto.
	(fhandler_socket::utimes): New method.
	* times.cc: Include dtable.h.
	(timeval_to_filetime): Make non-static.
	(utimes): Move functionality into fhandler method utimes. Just call
	this method from here.
	* winsup.h: Simplify declarations of time helper functions.
	(timeval_to_filetime): Add extern declaration.
@
text
@d117 1
d145 1
d147 4
a150 1
			  local.nFileSizeLow);
d155 1
a155 1
      res = fstat_helper (buf, ft, ft, ft, 0, 0);
d221 1
d242 1
a242 1
  buf->st_dev = pc.volser ();
@


1.103
log
@	* fhandler.h (class fhandler_base): Declare new method link.
	(class fhandler_socket): Ditto.
	(class fhandler_disk_file): Ditto.
	* fhandler.cc (fhandler_base::open): Add FILE_WRITE_ATTRIBUTES
	to query_write_control access flags.
	(fhandler_base::link): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Don't try to
	open with O_WRONLY since query_write_control includes
	FILE_WRITE_ATTRIBUTES.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::link): New method.  Touch st_ctime on successful
	link.
	* fhandler_socket.cc (fhandler_socket::link): New method.
	* syscalls.cc (link): Move functionality into fhandler method link.
	Just call this method from here.
@
text
@a635 1
  int res = -1;
d642 1
a642 1
      goto done;
d649 1
a649 1
      goto done;
d656 1
a656 1
      goto done;
d669 1
a669 1
  query_open (query_write_control);
d674 1
a674 1
      goto done;
d699 1
a699 1
	  goto done;
a702 1
      DWORD written;
a703 2
      DWORD path_len;
      DWORD size;
d706 1
a706 1
      DWORD write_err;
d755 1
a755 1
	  goto done;
d759 1
a759 2
      res = 0;
      /* touch st_ctime */
d766 1
a766 2

      goto done;
d770 26
a795 1
  if (CopyFileA (pc, newpc, 1))
d797 31
a827 3
      res = 0;
      /* touch st_ctime */
      has_changed (true);
d829 2
a830 8
      fhandler_disk_file fh;
      fh.set_name (newpc);
      fh.query_open (query_write_control);
      if (fh.open (O_BINARY, 0))
	{
	  fh.has_changed (true);
	  fh.close ();
	}
d832 3
a834 2
  else
    __seterrno ();
d836 3
a838 3
done:
  syscall_printf ("%d = link (%s, %s)", res, get_name (), newpath);
  return res;
d841 1
a841 2

fhandler_disk_file::fhandler_disk_file () :
d844 1
@


1.102
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fstat): Set st_ctime if
	has_changed flag is set.
	(fhandler_disk_file::touch_ctime): Reset has_changed flag on success.
@
text
@d411 3
a413 7
	  /* Open for writing required to be able to set ctime. */
	  if (!(oret = open (O_WRONLY | O_BINARY, 0)))
	    {
	      query_open (query_write_control);
	      if (!(oret = open (O_BINARY, 0)))
		return -1;
	    }
d439 1
a439 1
  if (!res && !query_open ())
d463 3
a465 7
      /* Open for writing required to be able to set ctime. */
      if (!(oret = open (O_WRONLY | O_BINARY, 0)))
        {
	  query_open (query_write_control);
	  if (!(oret = open (O_BINARY, 0)))
	    return -1;
      	}
d477 1
a477 1
      if (!res && !query_open ())
d551 3
a553 10
	  /* Open for writing required to be able to set ctime. */
	  if (cmd == SETACL)
	    oret = open (O_WRONLY | O_BINARY, 0);
	  if (!oret)
	    {
	      query_open (cmd == SETACL ? query_write_control
	      				: query_read_control);
	      if (!(oret = open (O_BINARY, 0)))
		return -1;
	    }
d576 1
a576 1
  if (!res && cmd == SETACL && !query_open ())
d633 167
@


1.101
log
@	* fhandler.cc (fhandler_base::raw_write): Mark as changed on
	successful write.
	* fhandler.h (fhandler_base::status_flags): Add 'has_changed' flag.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Call
	fhandler_disk_file's own open and close instead of open_fs and
	close_fs.  Mark as changed on success.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
	(fhandler_disk_file::ftruncate): Ditto.
	(fhandler_base::open_fs): Mark as changed when O_TRUNC flag on existing
	file is set.
	(fhandler_disk_file::close): Set st_ctime if has_changed flag is set.
@
text
@d377 2
d392 2
@


1.100
log
@	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Fix checking
	lseek return code.
@
text
@d408 1
a408 1
	  if (!(oret = open_fs (O_WRONLY | O_BINARY, 0)))
d411 1
a411 1
	      if (!(oret = open_fs (O_BINARY, 0)))
d438 1
d440 1
a440 1
    touch_ctime ();
d443 1
a443 1
    close_fs ();
d464 1
a464 1
      if (!(oret = open_fs (O_WRONLY | O_BINARY, 0)))
d467 1
a467 1
	  if (!(oret = open_fs (O_BINARY, 0)))
d480 1
d482 1
a482 1
	touch_ctime ();
d486 1
a486 1
    close_fs ();
d507 1
a507 1
	      oret = open_fs (O_WRONLY | O_BINARY, 0);
d520 1
a520 1
		    if (!(oret = open_fs (O_BINARY, 0)))
d557 1
a557 1
	    oret = open_fs (O_WRONLY | O_BINARY, 0);
d562 1
a562 1
	      if (!(oret = open_fs (O_BINARY, 0)))
d586 1
d588 1
a588 1
    touch_ctime ();
d591 1
a591 1
    close_fs ();
d636 1
d638 1
a638 1
	    touch_ctime ();
d699 4
d714 3
@


1.99
log
@	* fhandler.h (fhandler_base::ftruncate): Define new virtual method.
	(fhandler_disk_file::ftruncate): Ditto.
	* fhandler.cc (fhandler_base::ftruncate): New method.
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.
	* syscalls.cc (ftruncate64): Move functionality into fhandlers.
	Call fhandler method from here.
@
text
@d607 1
a607 1
      if (lseek (length, SEEK_SET) > 0)
@


1.98
log
@	* fhandler_disk_file.cc (fhandler_disk_file::facl): Pretend successful
	SETACL if no acls are available.
	* fhandler.cc (fhandler_base::facl): Implement to return sensible
	values on GETACL and GETACLCNT.  Pretend successful SETACL.
	* fhandler_virtual.cc (fhandler_virtual::facl): Ditto.
@
text
@d32 1
d593 47
@


1.97
log
@	* fhandler.h (fhandler_disk_file::touch_ctime): Declare.
	* fhandler_disk_file.cc (fhandler_disk_file::touch_ctime): New method
	to set file's ctime.
	(fhandler_disk_file::fchmod): Try opening file for writing first.
	Set file's ctime on success.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl): Ditto.
@
text
@d501 5
a505 1
	    set_errno (ENOSYS);
@


1.96
log
@	* fhandler_disk_file.cc: Fix copyright date.
@
text
@d379 12
d406 7
a412 3
	  query_open (query_write_control);
	  if (!(oret = open_fs (O_BINARY, 0)))
	    return -1;
a422 3

      if (oret)
	close_fs ();
d437 6
d461 7
a467 3
      query_open (query_write_control);
      if (!(oret = open_fs (O_BINARY, 0)))
	return -1;
d475 6
a480 2
    res = set_file_attribute (pc.has_acls (), get_io_handle (), pc,
			      uid, gid, attrib);
d548 10
a557 3
	  query_open (cmd == SETACL ? query_write_control : query_read_control);
	  if (!(oret = open_fs (O_BINARY, 0)))
	    return -1;
d579 3
@


1.95
log
@	* fhandler_disk_file.cc (fhandler_base::open_fs): Don't allow
	opening directories for writing.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.94
log
@* fhandler.cc (fhandler_base::fchmod): Do the right thing when changing an "on
disk" device or fifo.
(fhandler_base::fchown): Ditto for changing ownership.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Accommodate device files
on ntfs partitions.
* path.cc (path_conv::check): Use isfs function to figure out if a path exists
on a filesystem to make sure that device files are caught.
@
text
@d571 8
@


1.93
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Allow to report
	success on systems with ntsec and ntea set.
@
text
@d303 3
a305 1
      if (!(buf->st_mode & S_IFMT))
d307 5
@


1.92
log
@* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Only try to open the file
if it uses an acl.
@
text
@d412 1
a412 1
  else if (!allow_ntsec)
@


1.91
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d384 1
a384 1
      if (!get_io_handle ())
@


1.90
log
@	* fhandler_disk_file.cc (fhandler_base::open_fs): Change
	set_file_attribute call to indicate that NT security isn't used.
	(fhandler_disk_file::fchmod): Rearrange to isolate 9x related
	statements.
	Do not set FILE_ATTRIBUTE_SYSTEM.
	(fhandler_disk_file::fchown): Check noop case first.
	* fhandler.cc (fhandler_base::open9x): Remove ntsec related statements.
	(fhandler_base::set_name): Do not set namehash.
	* fhandler.h (fhandler_base::get_namehash): Compute and set namehash if
	needed.
	* syscalls.cc (access): Verify that fh is not NULL. Do not set PC_FULL.
	(chmod): Ditto.
	(chown_worker): Ditto.
	(stat_worker): Ditto. Verify if the path exists.
@
text
@d193 1
a193 1
         Since fhandler_base::open only calls CloseHandle if !nohandle,
d273 1
a273 1
      				  sizeof fci, FileCompressionInformation))
d290 1
a290 1
      			  NULL, &buf->st_uid, &buf->st_gid);
d297 1
a297 1
  			   &buf->st_mode, &buf->st_uid, &buf->st_gid))
d399 1
a399 1
      
d427 1
a427 1
         where it just works */
d462 1
a462 1
        {
d481 1
a481 1
	        if (!fstat_by_handle (&st))
d492 1
a492 1
		    aclbufp[3].a_type = CLASS_OBJ; 
d704 1
a704 1
         the entire file (and all future extensions).  */
@


1.89
log
@	* autoload.cc (NtCreateFile): Add.
	* dir.cc (mkdir): Change set_file_attribute call to indicate that
	NT security isn't used.
	* fhandler.cc (fhandler_base::open_9x): New method, created from
	fhandler_base::open.
	(fhandler_base::open): Rearrange to use NtCreateFile instead of
	CreateFile.
	* fhandler.h (enum query_state): Redefine query_null_access to
	query_stat_control.  query_null_access isn't allowed in NtCreateFile.
	(fhandler_base::open_9x): Declare.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use
	query_stat_control first, query_read_control if that fails.
	(fhandler_disk_file::fchmod): Call enable_restore_privilege before
	trying to open for query_write_control.  Don't fall back to
	opening for query_read_control.
	(fhandler_disk_file::fchown): Ditto.
	(fhandler_disk_file::facl):  Only request restore privilege and query
	access necessary for given cmd.
	* fhandler_raw.cc (fhandler_dev_raw::open): Call fhandler_base::open
	instead of opening device here.
	* ntdll.h (NtCreateFile): Declare.
	* path.cc (symlink_worker): Change set_file_attribute call to indicate
	that NT security isn't used.
	* sec_acl.cc (getacl): Fix bracketing.
	* sec_helper.cc (enable_restore_privilege): New function.
	* security.cc (str2buf2uni_cat): New function.
	(write_sd): Don't request restore permission here.
	* security.h (set_process_privileges): Drop stale declaration.
	(str2buf2uni): Declare.
	(str2buf2uni_cat): Declare.
	(enable_restore_privilege): Declare.
	* syscalls.cc (fchown32): Return immediate success on 9x.
@
text
@d390 12
a403 9
  if (!allow_ntsec && allow_ntea) /* Not necessary when manipulating SD. */
    SetFileAttributes (pc, (DWORD) pc & ~FILE_ATTRIBUTE_READONLY);
  if (pc.isdir ())
    mode |= S_IFDIR;
  if (!set_file_attribute (pc.has_acls (), get_io_handle (), pc,
			   ILLEGAL_UID, ILLEGAL_GID, mode)
      && allow_ntsec)
    res = 0;

a409 3
  if (!pc.is_lnk_symlink () && S_ISLNK (mode) || S_ISSOCK (mode))
    (DWORD) pc |= FILE_ATTRIBUTE_SYSTEM;

a415 3
  if (oret)
    close_fs ();

d424 7
a445 6
  if (res && (!pc.has_acls () || !allow_ntsec))
    {
      /* fake - if not supported, pretend we're like win95
         where it just works */
      res = 0;
    }
d588 1
a588 1
    set_file_attribute (has_acls (), NULL, get_win32_name (), mode);
@


1.88
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fchmo): Try opening
	in query_read mode if query_write fails.
	* fhandler_disk_file.cc (fhandler_disk_file::fchown): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): Ditto.
@
text
@a176 1
      query_open (query_read_control);
d179 1
d186 1
a186 1
      query_open (query_null_access);
d381 1
a381 1
  if (!get_io_handle ())
d383 4
a386 4
      query_open (query_write_control);
      if (!(oret = open_fs (O_BINARY, 0)))
        {
	  query_open (query_read_control);
d389 1
a389 1
        }
d426 2
d432 1
a432 5
        {
	  query_open (query_read_control);
	  if (!(oret = open_fs (O_BINARY, 0)))
	    return -1;
        }
a460 11
  if (!get_io_handle ())
    {
      query_open (query_write_control);
      if (!(oret = open_fs (O_BINARY, 0)))
        {
	  query_open (query_read_control);
	  if (!(oret = open_fs (O_BINARY, 0)))
	    return -1;
        }
    }

d475 1
a475 1
	    else if (!fstat_by_handle (&st))
d477 22
a498 13
		aclbufp[0].a_type = USER_OBJ;
		aclbufp[0].a_id = st.st_uid;
		aclbufp[0].a_perm = (st.st_mode & S_IRWXU) >> 6;
		aclbufp[1].a_type = GROUP_OBJ;
		aclbufp[1].a_id = st.st_gid;
		aclbufp[1].a_perm = (st.st_mode & S_IRWXG) >> 3;
		aclbufp[2].a_type = OTHER_OBJ;
		aclbufp[2].a_id = ILLEGAL_GID;
		aclbufp[2].a_perm = st.st_mode & S_IRWXO;
		aclbufp[3].a_type = CLASS_OBJ; 
		aclbufp[3].a_id = ILLEGAL_GID;
		aclbufp[3].a_perm = S_IRWXU | S_IRWXG | S_IRWXO;
		res = MIN_ACL_ENTRIES;
d504 3
d511 8
@


1.87
log
@	* fhandler.cc (fhandler_base::open): Simplify access evaluation
	expression.
	(fhandler_base::facl): New method.
	* fhandler.h: Declare facl method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::facl): New method.
	* fhandler_virtual.cc (fhandler_virtual::facl): New method.
	* sec_acl.cc: Remove forward declaration for aclsort32 and acl32.
	(setacl): Remove static.  Add and use handle parameter.
	(getacl): Ditto.
	(acl_worker): Reorganize to call fhandler's facl method eventually.
	(facl32): Ditto.
	* security.cc (get_nt_object_security): Remove static.
	* security.h: Add extern declarations for get_nt_object_security,
	aclsort32, acl32, getacl and setacl.


	Apply missing syscalls.cc patch and ChangeLog of previous check in.
	* syscalls.cc (chown_worker): Reorganize to call fhandler's fchown
	method eventually.
	(fchown): Ditto.
@
text
@d385 5
a389 1
	return -1;
d430 5
a434 1
	return -1;
d467 5
a471 1
        return -1;
@


1.86
log
@	* fhandler.cc (fhandler_base::open): Accomodate query_write_control
	query_state.
	(fhandler_base::fchown): New method.
	* fhandler.h: Declare fchown method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	(enum query_state): Add query_write_control.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Set query_state
	to query_write_control.  Only remove FILE_ATTRIBUTE_READONLY if not
	setting security descriptor.
	(fhandler_disk_file::fchown): New method.
	* fhandler_virtual.cc (fhandler_virtual::fchown): New method.
	* sec_acl.cc (setacl): Call write_sd with additional handle attribute.
	* security.cc (write_sd): Take handle argument.  Only request owner
	if getting SE_RESTORE_NAME privilege failed.  Only open file if
	NtSetSecurityObject failed or handle is NULL.
	(set_nt_attribute): Call write_sd with additional handle attribute.
	* security.h (write_sd): Declare with additional handle argument.
@
text
@d15 1
d441 77
@


1.85
log
@	* autoload.cc (NtSetSecurityObject): Add.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): Only request
	READ_CONTROL rights when opening the file.
	* ntdll.h (NtSetSecurityObject): Add declaration.
	* security.cc (write_sd): Call NtSetSecurityObject instead of
	BackupWrite.
	(get_nt_object_security): Don't free security descriptor here.

	* syscalls.cc (ttyname): Use buffer of length TTY_NAME_MAX + 1.
	* sysconf.cc (sysconf): Handle _SC_TTY_NAME_MAX request.
	* include/limits.h: Define TTY_NAME_MAX and _POSIX_TTY_NAME_MAX.
@
text
@d380 6
a385 3
  query_open (query_read_control);
  if (!get_io_handle () && !(oret = open_fs (O_BINARY, 0)))
    return -1;
d387 2
a388 1
  SetFileAttributes (get_win32_name (), (DWORD) pc & ~FILE_ATTRIBUTE_READONLY);
d391 1
a391 1
  if (!set_file_attribute (pc.has_acls (), get_io_handle (), get_win32_name (),
d410 31
@


1.84
log
@2004-04-14  Pierre Humblet <pierre.humblet@@ieee.org>

        * path.h (path_conv::set_symlink): Add argument.
        (path_conv::get_symlink_length): New method.
        (path_conv::symlink_length): New member.
        * path.cc (path_conv::check): Pass symlen to set_symlink.
        * fhandler_disk_file.cc (fhandler_base::fstat_helper): For symlinks
        set st_size from get_symlink_length.
@
text
@d380 2
a381 1
  if (!get_io_handle () && !(oret = open_fs (O_RDONLY | O_BINARY, 0)))
@


1.83
log
@	* dir.cc (mkdir): Call set_file_attribute with additional handle
	argument.
	* fhandler.cc (fhandler_base::fchmod): New method.
	* fhandler.h: Declare fchmod method in fhandler_base,
	fhandler_disk_file and fhandler_virtual.
	* fhandler_disk_file.cc (fhandler_disk_file::fchmod): New method.
	(fhandler_base::open_fs): Call set_file_attribute with additional
	handle argument.
	* fhandler_virtual.cc (fhandler_virtual::fchmod): New method.
	* path.cc (symlink_worker): Call set_file_attribute with additional
	handle argument.
	* security.cc (get_nt_object_security): New function.
	(get_nt_object_attribute): Call get_nt_object_security.
	(set_nt_attribute): Add handle argument.  Call get_nt_object_security
	first, read_sd only if that fails.
	(set_file_attribute): Add handle argument.
	* security.h (set_file_attribute): Declare with additional handle
	argument.
	* syscalls.cc (stat_suffixes): Move to beginning of file.
	(chown_worker): Call set_file_attribute with additional handle argument.
	(chmod): Reorganize to call fhandler's fchmod method eventually.
	(fchmod): Ditto.
@
text
@d285 1
@


1.82
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d369 42
d456 1
a456 1
    set_file_attribute (has_acls (), get_win32_name (), mode);
@


1.81
log
@	* fhandler.cc (fhandler_base::write): Use bool parameter in calls to
	set_did_lseek.
	(fhandler_base::fhandler_base): Accomodate new status and open_status
	constructor.
	* fhandler.h: Remove status bit enumerator.
	(FHDEVN): Remove.
	(FHISSETF): Remove.
	(FHSETF): Remove.
	(FHCLEARF): Remove.
	(FHCONDSETF): Remove.
	(FHSTATOFF): Remove.
	(UNCONNECTED, CONNECT_PENDING, CONNECTED): Substitute by enum
	connect_state.
	(fhandler_base::status): Define as bitfield struct type status_flags.
	Remove unused flags entirely.  Accomodate all status access methods.
	(open_status): Define as bitfield struct type status_flags.
	(fhandler_socket): Move socket related status bits to here.  Redefine
	had_connect_or_listen to be part of these status bits.  Accomodate
	related access methods.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Use pc.issymlink
	instead of dropped method get_symlink_p.
	(fhandler_base::open_fs): Remove setting dropped status flags.
	* fhandler_socket.cc: Use values from enum connect_state throughout.
	(fhandler_socket::fhandler_socket): Initialize status bits.
	* fhandler_virtual.cc (fhandler_virtual::open): Remove setting dropped
	status flags.
	* net.cc: Use values from enum connect_state throughout.
	* select.cc: Ditto.
	* shared_info.h: Protect struct console_state using _FHANDLER_H_
	instead of FHDEVN.
@
text
@d167 1
a167 1
      if (get_nohandle ())
d176 2
a177 3
      set_query_open (query_read_control);
      if (strncasematch (pc.volname (), "FAT", 3)
	  && !strpbrk (get_win32_name (), "?*|<>"))
d185 1
a185 1
      set_query_open (query_null_access);
d192 1
a192 1
         Since fhandler_base::open only calls CloseHandle if !get_nohandle,
d196 2
a197 2
      bool nohandle = get_nohandle ();
      set_nohandle (false);
d199 1
a199 1
      set_nohandle (nohandle);
d633 1
a633 1
      fd->set_nohandle (true);
a648 2
      if (pc.isencoded ())
	set_encoded ();
d715 1
a715 1
  if (get_encoded ())
@


1.80
log
@	* fhandler.cc (fhandler_base::open): Set query access mode according
	to query_open setting.
	(fhandler_base::fhandler_base): Initialize query_open.
	* fhandler.h (FH_QUERYOPEN): Drop.
	(enum query_state): Add.
	(class fhandler_base): Add query_open member.
	(fhandler_base::get_query_open): Redefine to use query_open.
	(fhandler_base::set_query_open): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Remove O_DIROPEN
	from open_flags since it's added in open_fs anyway.  Remove
	query_open_already.  Use new query_open settings.  Rearrange slightly.
	(fhandler_base::fstat_helper): Add get_io_handle as parameter to
	get_file_attribute.
	* security.cc (get_nt_object_attribute): Make returning an int.
	Return -1 on error, 0 otherwise.
	(get_file_attribute): Take an object handle as argument. Move down
	to allow calling get_nt_object_attribute in case a non-NULL handle
	is given.
	* security.h (get_file_attribute): Add handle to argument list.
	* syscalls.cc (chown_worker): Accomodate new definition of
	get_file_attribute.
@
text
@d299 1
a299 1
      if (pc.has_attribute (FILE_ATTRIBUTE_READONLY) && !get_symlink_p ())
a341 1
		      set_execable_p ();
a417 3
  set_symlink_p (pc.issymlink ());
  set_execable_p (pc.exec_state ());
  set_socket_p (pc.issocket ());
@


1.79
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Request
	compressed size only if the matching attributes are set.  Use
	NtQueryInformationFile instead of GetCompressedFileSize.
	(fhandler_base::fstat_by_handle): Remove NT 3.5 cruft since
	local.dwVolumeSerialNumber isn't used subsequently.
	* ntdll.h: Add typedefs for FILE_COMPRESSION_INFORMATION and
	FILE_INFORMATION_CLASS.
@
text
@d163 1
a163 2
  int open_flags = O_RDONLY | O_BINARY | O_DIROPEN;
  bool query_open_already;
a174 10
    set_query_open (query_open_already = true);
  else
    query_open_already = false;

  if (query_open_already && strncasematch (pc.volname (), "FAT", 3)
      && !strpbrk (get_win32_name (), "?*|<>"))
    oret = 0;
  else if (!(oret = open_fs (open_flags, 0))
	   && !query_open_already
	   && get_errno () == EACCES)
d176 9
a184 2
      /* If we couldn't open the file, try a "query open" with no permissions.
	 This will allow us to determine *some* things about the file, at least. */
d186 1
a186 1
      set_query_open (true);
d288 2
a289 2
      get_file_attribute (pc.has_acls (), get_win32_name (), NULL,
			  &buf->st_uid, &buf->st_gid);
d295 2
a296 2
  if (get_file_attribute (pc.has_acls (), get_win32_name (), &buf->st_mode,
			  &buf->st_uid, &buf->st_gid) == 0)
@


1.78
log
@	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use created
	handle regardless of nohandle state.  Clean up afterwards.
@
text
@d26 2
a98 1
  int res = 0;
d100 1
a100 11

  /* NT 3.51 seems to have a bug when attempting to get vol serial
     numbers.  This loop gets around this. */
  for (int i = 0; i < 2; i++)
    {
      if (!(res = GetFileInformationByHandle (get_handle (), &local)))
	break;
      if (local.dwVolumeSerialNumber && (long) local.dwVolumeSerialNumber != -1)
	break;
    }

d103 2
a104 3
  if (res == 0)
    /* GetFileInformationByHandle will fail if it's given stdin/out/err
       or a pipe*/
d224 3
d272 7
a278 10
  /* GetCompressedFileSize() gets autoloaded.  It returns INVALID_FILE_SIZE
     if it doesn't exist.  Since that's also a valid return value on 64bit
     capable file systems, we must additionally check for the win32 error. */
  nFileSizeLow = GetCompressedFileSizeA (pc, &nFileSizeHigh);
  if (nFileSizeLow != INVALID_FILE_SIZE || GetLastError () == NO_ERROR)
    /* On systems supporting compressed (and sparsed) files,
       GetCompressedFileSize() returns the actual amount of
       bytes allocated on disk.  */
    buf->st_blocks = (((_off64_t)nFileSizeHigh << 32)
		     + nFileSizeLow + S_BLKSIZE - 1) / S_BLKSIZE;
@


1.77
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d204 1
a204 3
  if (!oret || get_nohandle ())
    res = fstat_by_name (buf);
  else
d206 4
d211 2
d214 2
d217 2
@


1.76
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.75
log
@* winsup.h (access_worker): Declare with added fhandler_base parameter.
* syscalls.cc (access_worker): Accommodate extra fhandler_base argument.  Use
it instead of stat_worker to determine stat information, when appropriate.
* fhandler.cc (fhandler_base::device_access_denied): Pass fhandler pointer to
access_worker so that it can use the proper method for determining stat
information.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
@
text
@a397 3
  set_has_acls (pc.has_acls ());
  set_isremote (pc.isremote ());

d632 1
a632 1
  else if (access_worker (pc, R_OK, this) != 0)
@


1.75.6.1
log
@* cygheap.cc (init_cygheap::close_ctty): Protect YA vforkism.
* fhandler.h (fhandler_base::has_acls): Make pass through for path_conv method.
(fhandler_base::isremote): Ditto.
(fhandler_base::is_fs_special): Ditto.
(fhandler_base::has_attribute): Ditto.  Define new function.
(fhandler_base::fhaccess): Declare new function based on access_worker.
(fhandler_base::set_has_acls): Eliminate obsolete function.
(fhandler_base::set_isremote): Ditto.
* fhandler.cc (fhandler_base::fhaccess): Move from syscalls.cc and into
fhandler_base class.  Use fhandler methods to access data rather than path_conv
stuff.
(fhandler_base::device_access_denied): Use fhaccess method.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
(fhandler_base::open_fs): Remove calls to obsolete functions.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* winsup.h (access_worker): Remove obsolete access_worker declaration.
*syscalls.cc (access_worker): Move function to fhandler.cc.
(access): Use fhaccess method.
* pinfo.cc (_pinfo::set_ctty): Clarify debugging output.
* sigproc.cc (sig_dispatch_pending): Ditto.
* syscalls.cc (setsid): Perform minor rearrangement.
@
text
@d398 3
d635 1
a635 1
  else if (fhaccess (R_OK) != 0)
@


1.74
log
@white space
@
text
@d635 1
a635 1
  else if (access_worker (pc, R_OK) != 0)
@


1.73
log
@	* fhandler_disk_file.cc (fhandler_disk_file::lock): Use UINT32_MAX
	instead of 0xffffffff.  Accomodate Win 9x bug in evaluating length
	of area to lock when given length is 0.
@
text
@d620 1
a620 1
  else if ((len = strlen (pc))> CYG_MAX_PATH - 3)
@


1.72
log
@	* fhandler_disk_file.cc (fhandler_disk_file::lock): Interchange
	values of off_low and off_high.
@
text
@d539 1
a539 1
  off_low = (DWORD)(win32_start & 0xffffffff);
d545 4
a548 1
      len_low = 0xffffffff;
d553 1
a553 1
      len_low = (DWORD)(win32_len & 0xffffffff);
@


1.71
log
@	* Makefile.in (OBSOLETE_FUNCTIONS): Add fcntl.
	(NEW_FUNCTIONS): Add fcntl64.
	* cygwin.din: Export fcntl64.  Make fcntl being SIGFE.
	* fcntl.cc (fcntl_worker): New function.
	(fcntl64): New function.
	(_fcntl): Call fcntl_worker.  Convert 32 bit flock structure into
	64 bit flock structure and vice versa.
	* fhandler.cc (fhandler_base::lock): Change 2nd parameter to
	struct __flock64 *.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Ditto.  Rework
	to be 64 bit aware.
	* fhandler.h: Accomodate above method argument changes.
	* include/cygwin/types.h: Add struct __flock32 and __flock64.
	Define struct flock according to setting of __CYGWIN_USE_BIG_TYPES__.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d539 2
a540 2
  off_high = (DWORD)(win32_start & 0xffffffff);
  off_low = (DWORD)(win32_start >> 32);
@


1.70
log
@* fhandler_disk_file.cc (fhandler_disk_file::readdir): Reorganize to avoid
inappropriate .lnk extensions with munged filenames under managed mode.
@
text
@d463 1
a463 1
fhandler_disk_file::lock (int cmd, struct flock *fl)
d466 1
a466 2
  int win32_len;
  DWORD win32_upper;
d537 4
a540 4
  /*
   * Special case if len == 0 for POSIX means lock
   * to the end of the entire file (and all future extensions).
   */
d543 4
a546 2
      win32_len = 0xffffffff;
      win32_upper = wincap.lock_file_highword ();
d549 4
a552 1
    win32_upper = 0;
d565 2
a566 2
      ov.Offset = (DWORD)win32_start;
      ov.OffsetHigh = 0;
d571 1
a571 1
	  res = UnlockFileEx (get_handle (), 0, (DWORD)win32_len, win32_upper, &ov);
d575 2
a576 2
	  res = LockFileEx (get_handle (), lock_flags, 0, (DWORD)win32_len,
							win32_upper, &ov);
d594 1
a594 2
	res = UnlockFile (get_handle (), (DWORD)win32_start, 0, (DWORD)win32_len,
							win32_upper);
d596 1
a596 1
	res = LockFile (get_handle (), (DWORD)win32_start, 0, (DWORD)win32_len, win32_upper);
@


1.69
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@a706 6
  /* We get here if `buf' contains valid data.  */
  if (get_encoded ())
    (void) fnunmunge (dir->__d_dirent->d_name, buf.cFileName);
  else
    strcpy (dir->__d_dirent->d_name, buf.cFileName);

d711 1
a711 1
      char *c = dir->__d_dirent->d_name;
d717 1
a717 1
	  strcpy (fbuf + strlen (fbuf) - 1, dir->__d_dirent->d_name);
d723 6
@


1.68
log
@* cygthread.cc (cygthread::freerange): Set inuse count.  Avoid setting ev from
h as h would be NULL at this point.
(cygthread::operator new): Issue debugging info when overflowing the thread
pool.
(cygthread::cygthread): Set ev from h here after h has been initialized.
@
text
@d614 1
a614 1
  else if ((len = strlen (pc))> MAX_PATH - 3)
d721 1
a721 1
	  char fbuf[MAX_PATH + 1];
@


1.67
log
@* fhandler_disk_file.cc (fhandler_disk_file::opendir): Detect attempt to open a
directory which lacks read privileges.
@
text
@d621 1
a621 1
      free (dir);
d627 1
a627 2
      free (dir);
      free (dir->__d_dirname);
d630 1
a630 4
    {
      free (dir);
      free (dir->__d_dirname);
    }
a635 16
      if (fd >= 0)
	{
	  fd = this;
	  fd->set_nohandle (true);
	  dir->__d_dirent->d_fd = fd;
	  dir->__fh = this;
	  /* FindFirstFile doesn't seem to like duplicate /'s. */
	  len = strlen (dir->__d_dirname);
	  if (len == 0 || isdirsep (dir->__d_dirname[len - 1]))
	    strcat (dir->__d_dirname, "*");
	  else
	    strcat (dir->__d_dirname, "\\*");  /**/
	  dir->__d_cookie = __DIRENT_COOKIE;
	  dir->__handle = INVALID_HANDLE_VALUE;
	  dir->__d_position = 0;
	  dir->__d_dirhash = get_namehash ();
d637 20
a656 2
	  res = dir;
	}
d662 8
@


1.66
log
@2003-09-24  Pierre Humblet <pierre.humblet@@ieee.org>

	* shared_info.h (class user_info): New.
	(cygwin_user_h): New.
	(user_shared): New.
	(enum shared_locations): Replace SH_MOUNT_TABLE by SH_USER_SHARED;
	(mount_table): Change from variable to macro.
	* shared.cc: Use sizeof(user_info) in "offsets".
	(user_shared_initialize): Add "reinit" argument to indicate need
	to reinitialize the mapping. Replace "mount_table" by "user_shared"
	throughout. Call user_shared->mountinfo.init and
	user_shared->delqueue.init.
	(shared_info::initialize): Do not call delqueue.init.
	(memory_init): Add argument to user_shared_initialize.
	* child_info.h (child_info::mount_h): Delete.
	(child_info::user_h): New.
	* sigpproc.cc (init_child_info): Use user_h instead of mount_h.
	* dcrt0.cc (_dll_crt0): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::close): Use
	user_shared->delqueue instead of cygwin_shared->delqueue.
	* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
	* syscalls.cc (close_all_files): Ditto.
	(unlink): Ditto.
	(seteuid32): Add argument to user_shared_initialize.
@
text
@d620 1
a621 1
      set_errno (ENOMEM);
d626 2
d629 3
d633 1
a633 1
      set_errno (ENOMEM);
@


1.65
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d449 1
a449 1
    cygwin_shared->delqueue.process_queue ();
@


1.64
log
@* fhandler_disk_file.cc (path_conv::ndisk_links): Fix potential off-by-one
problem when first file in a directory is a directory.
@
text
@d20 1
a21 1
#include "path.h"
d95 1
a95 1
fhandler_disk_file::fstat_by_handle (struct __stat64 *buf, path_conv *pc)
d109 1
d120 1
a120 1
  return fstat_helper (buf, pc,
d132 1
a132 1
fhandler_disk_file::fstat_by_name (struct __stat64 *buf, path_conv *pc)
d138 1
a138 1
  if (!pc->exists ())
d144 1
a144 1
  else if ((handle = FindFirstFile (*pc, &local)) != INVALID_HANDLE_VALUE)
d147 1
a147 1
      res = fstat_helper (buf, pc,
d154 1
a154 1
  else if (pc->isdir ())
d157 1
a157 1
      res = fstat_helper (buf, pc, ft, ft, ft, 0, 0);
d161 1
a161 1
      debug_printf ("FindFirstFile failed for '%s', %E", (char *) *pc);
d169 1
a169 1
fhandler_disk_file::fstat (struct __stat64 *buf, path_conv *pc)
d179 1
a179 1
	return fstat_by_name (buf, pc);
d181 1
a181 1
	return fstat_by_handle (buf, pc);
d185 1
a185 1
  if (pc->exec_state () != dont_know_if_executable)
d190 1
a190 1
  if (query_open_already && strncasematch (pc->volname (), "FAT", 3)
d193 1
a193 1
  else if (!(oret = open (pc, open_flags, 0))
d199 1
a199 1
      pc->set_exec (0);
d201 1
a201 1
      oret = open (pc, open_flags, 0);
d205 1
a205 1
    res = fstat_by_name (buf, pc);
d208 2
a209 2
      res = fstat_by_handle (buf, pc);
      close ();
d216 9
a224 9
fhandler_disk_file::fstat_helper (struct __stat64 *buf, path_conv *pc,
				  FILETIME ftCreationTime,
				  FILETIME ftLastAccessTime,
				  FILETIME ftLastWriteTime,
				  DWORD nFileSizeHigh,
				  DWORD nFileSizeLow,
				  DWORD nFileIndexHigh,
				  DWORD nFileIndexLow,
				  DWORD nNumberOfLinks)
d237 2
a238 2
  buf->st_dev = pc->volser ();
  buf->st_size = ((_off64_t)nFileSizeHigh << 32) + nFileSizeLow;
d245 1
a245 1
  buf->st_nlink = pc->ndisk_links (nNumberOfLinks);
d250 2
a251 2
  switch (pc->has_acls () && (nFileIndexHigh || nFileIndexLow)
	  ? pc->drive_type () : DRIVE_UNKNOWN)
d274 1
a274 1
  nFileSizeLow = GetCompressedFileSizeA (pc->get_win32 (), &nFileSizeHigh);
d288 1
a288 1
  if (pc->isdir ())
d290 1
a290 1
  else if (pc->issymlink ())
d294 1
a294 1
      get_file_attribute (pc->has_acls (), get_win32_name (), NULL,
d298 1
a298 1
  else if (pc->issocket ())
d301 1
a301 1
  if (get_file_attribute (pc->has_acls (), get_win32_name (), &buf->st_mode,
d305 1
a305 1
      if (pc->has_attribute (FILE_ATTRIBUTE_READONLY) && !get_symlink_p ())
d315 1
a315 1
      if (!pc->has_attribute (FILE_ATTRIBUTE_READONLY))
d323 5
d331 1
a331 1
	  if (pc->exec_state () == dont_know_if_executable)
d349 1
a349 1
		      pc->set_exec ();
d357 1
a357 1
      if (pc->exec_state () == is_executable)
d371 2
a372 2
fhandler_disk_file::fhandler_disk_file (DWORD devtype) :
  fhandler_base (devtype)
d374 1
d378 1
a378 1
  fhandler_base (FH_DISK)
d383 1
a383 1
fhandler_disk_file::open (path_conv *real_path, int flags, mode_t mode)
d385 7
a391 1
  if (real_path->case_clash && flags & O_CREAT)
d398 2
a399 2
  set_has_acls (real_path->has_acls ());
  set_isremote (real_path->isremote ());
d401 1
a401 1
  int res = fhandler_base::open (real_path, flags | O_DIROPEN, mode);
d411 1
a411 1
  if (real_path->has_buggy_open () && !real_path->exists ())
d414 1
a414 1
      close ();
d427 4
a430 4
  set_fs_flags (real_path->fs_flags ());
  set_symlink_p (real_path->issymlink ());
  set_execable_p (real_path->exec_state ());
  set_socket_p (real_path->issocket ());
d441 6
d453 8
a460 13
/*
 * FIXME !!!
 * The correct way to do this to get POSIX locking
 * semantics is to keep a linked list of posix lock
 * requests and map them into Win32 locks. The problem
 * is that Win32 does not deal correctly with overlapping
 * lock requests. Also another pain is that Win95 doesn't do
 * non-blocking or non exclusive locks at all. For '95 just
 * convert all lock requests into blocking,exclusive locks.
 * This shouldn't break many apps but denying all locking
 * would.
 * For now just convert to Win32 locks and hope for the best.
 */
d606 1
a606 1
fhandler_disk_file::opendir (path_conv& real_name)
d612 1
a612 1
  if (!real_name.isdir ())
d614 1
a614 1
  else if ((len = strlen (real_name))> MAX_PATH - 3)
d632 1
a632 1
      strcpy (dir->__d_dirname, real_name.get_win32 ());
d654 1
a654 1
      if (real_name.isencoded ())
d714 1
a714 1
	  if (fpath.issymlink ())
d766 2
a767 2
fhandler_cygdrive::fhandler_cygdrive (int unit) :
  fhandler_disk_file (FH_CYGDRIVE), unit (unit), ndrives (0), pdrive (NULL)
d776 2
a777 3
  char *p = (char *) crealloc ((void *) win32_path_name, len);

  win32_path_name = pdrive = p;
d782 1
a782 1
fhandler_cygdrive::fstat (struct __stat64 *buf, path_conv *pc)
d785 1
a785 1
    return fhandler_disk_file::fstat (buf, pc);
d794 1
a794 1
fhandler_cygdrive::opendir (path_conv& real_name)
d798 1
a798 1
  dir = fhandler_disk_file::opendir (real_name);
d839 1
a839 1
  for (pdrive = win32_path_name, dir->__d_position = -1; *pdrive;
d852 1
a852 1
  pdrive = win32_path_name;
d862 1
a862 1
  pdrive = win32_path_name;
@


1.63
log
@* fhandler_disk_file.cc (path_conv::ndisk_links): Fix problem where search
characters overwrote the path instead of being tacked on the end.
@
text
@d69 1
a69 1
	while (FindNextFileA (h, &buf))
d78 1
@


1.63.2.1
log
@* fhandler_disk_file.cc (path_conv::ndisk_links): Fix potential off-by-one
problem when first file in a directory is a directory.
* Makefile.in: Make malloc_wrapper -fomit-frame-pointer.
* cygwin.din: Remove extraneous mallinfo definition.
* dcrt0.cc (quoted): Use strechr for efficiency.
* exceptions.cc (sig_handle_tty_stop): Fix boneheaded mistake by using correct
check for parent state rather than inverted check.
* getopt.c (opterr): Reinstate initialization.
(optind): Ditto.
(optopt): Ditto.
@
text
@d69 1
a69 1
	do
a77 1
	while (FindNextFileA (h, &buf));
@


1.62
log
@* fhandler_disk_file.cc (path_conv::ndisk_links): Rename from num_entries.
Accept an argument and calculate any extra links needed based on missing .  and
..  entries.
(fhandler_disk_file::fstat_helper): Always call pc->ndisks_links() to calculate
the number of links.
* path.h (path_conv::ndisk_links): Declare.
@
text
@d56 1
a56 1
    strcpy (fn, s + 1);
d58 1
a58 1
    strcat (fn, s);
@


1.61
log
@* fhandler_disk_file.cc (num_entries): Take .  and ..  into account if they do
not exist since cygwin simulates them.
(fhandler_cygdrive::fstat): Ditto.
(fhandler_cygdrive::readdir): Don't do any specific tests on __d_position when
seeing if a drive exists.
@
text
@d32 2
a33 2
static int __stdcall
num_entries (const char *win32_name)
d35 19
a53 4
  WIN32_FIND_DATA buf;
  HANDLE handle;
  char buf1[MAX_PATH];
  int count = 0;
d55 2
a56 4
  strcpy (buf1, win32_name);
  int len = strlen (buf1);
  if (len == 0 || isdirsep (buf1[len - 1]))
    strcat (buf1, "*");
d58 1
a58 1
    strcat (buf1, "/*");	/* */
d60 2
a61 1
  handle = FindFirstFileA (buf1, &buf);
a62 2
  if (handle == INVALID_HANDLE_VALUE)
    return 2; /* 2 is the minimum number of links to a dir, so... */
d64 1
a64 1
  while (FindNextFileA (handle, &buf))
d66 20
a85 5
      if (buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	count++;
      if (buf.cFileName[0] == '.'
	  && (buf.cFileName[1] == '\0'
	      || (buf.cFileName[1] == '.' && buf.cFileName[2] == '\0')))
d87 1
d89 1
a89 1
  FindClose (handle);
d243 1
a243 4
  if (pc->isdir () && !pc->isremote () && nNumberOfLinks == 1)
    buf->st_nlink = num_entries (pc->get_win32 ());
  else
    buf->st_nlink = nNumberOfLinks;
@


1.60
log
@Throughout, remove __d_u.__d_data fields from DIR structure.
* include/sys/dirent.h (dirent): Remvoe old_d_ino.
(DIR): Make __d_dirhash a 64 bit value.  Remove __d_data and __d_u.  Add
__flags.
* dir.cc (opendir_states): New enum.
(opendir): Clear new DIR __flags field.
(readdir): Fill in '.' and '..' entries if we hit EOF and we haven't seen them
already.  Nuke setting of old_d_ino.
(rewinddir): Reset DIR __flags field.
(seekdir64): Ditto.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove special
handling of "." and ".." since they are now handled automatically.
@
text
@d51 1
a51 1
  count ++;
d54 6
a59 2
      if ((buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	count ++;
d62 1
a62 1
  return count;
d750 1
a750 1
  buf->st_nlink = ndrives;
d773 1
a773 2
  else if (dir->__d_position > 1
	   && GetFileAttributes (pdrive) == INVALID_FILE_ATTRIBUTES)
d778 3
a780 7
  else if (*pdrive == '.')
    strcpy (dir->__d_dirent->d_name, pdrive);
  else
    {
      *dir->__d_dirent->d_name = cyg_tolower (*pdrive);
      dir->__d_dirent->d_name[1] = '\0';
    }
@


1.59
log
@* fhandler_disk_file.cc (fhandler_cygdrive::readdir): Do not change 'errno' if
end of directory condition is encountered as per SUSv2.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_process (fhandler_process::readdir): Ditto.
* fhandler_registry (fhandler_registry::readdir): Ditto.
@
text
@d596 1
a596 1
	  dir->__d_u.__d_data.__fh = this;
d604 1
a604 1
	  dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
d625 1
a625 1
  if (dir->__d_u.__d_data.__handle == INVALID_HANDLE_VALUE
d630 1
a630 1
      dir->__d_u.__d_data.__handle = handle;
d637 1
a637 1
  else if (dir->__d_u.__d_data.__handle == INVALID_HANDLE_VALUE)
d639 1
a639 1
  else if (!FindNextFileA (dir->__d_u.__d_data.__handle, &buf))
d642 2
a643 2
      (void) FindClose (dir->__d_u.__d_data.__handle);
      dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
d700 1
a700 1
  if (dir->__d_u.__d_data.__handle != INVALID_HANDLE_VALUE)
d702 2
a703 2
      (void) FindClose (dir->__d_u.__d_data.__handle);
      dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
d712 2
a713 2
  if (dir->__d_u.__d_data.__handle != INVALID_HANDLE_VALUE &&
      FindClose (dir->__d_u.__d_data.__handle) == 0)
d731 2
a732 3
  const int len = 1 + 26 * DRVSZ;
  char *p = (char *) crealloc ((void *) win32_path_name,
				sizeof (".") + sizeof ("..") + len);
a734 3
  strcpy (p, ".");
  strcpy (p + sizeof ("."), "..");
  p += sizeof (".") + sizeof ("..");
@


1.58
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@d772 1
a772 4
    {
      set_errno (ENMFILE);
      return NULL;
    }
@


1.57
log
@* fhandler.h (FH_ENC): New enum.
(fhandler_base::get_encoded): New function.
(fhandler_base::set_encoded): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set encoded flag in
fhandler, as appropriate.
(fhandler_disk_file::readdir): Unmunge filename as appropriate based on new
encoding flag.
* path.cc (normalize_posix_path): Don't punt on files with colons.
(special_char): New function.
(mount_item::fnmunge): Ditto.
(fnunmunge): Ditto.
(special_name): Ditto.
(mount_item::build_win32): Avoid drive considerations when file is encoded.
(mount_info::conv_to_win32_path): Handle encoded filenames.
(mount_info::conv_to_posix_path): Ditto.
(fillout_mntent): Add posix string when directory is encoded.
* path.h (fnunmunge): Declare.
(path_conv::is_encoded): Declare.
@
text
@d125 1
a125 1
  else 
d229 1
a229 1
                    | (__ino64_t) nFileIndexLow;
@


1.56
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d610 2
d638 1
a638 3
    {
      return res;
    }
d653 4
a656 1
  strcpy (dir->__d_dirent->d_name, buf.cFileName);
@


1.55
log
@
2003-06-03  Pierre Humblet  <pierre.humblet@@ieee.org>

        * fhandler_disk_file.cc (fhandler_disk_file::fstat): Mark the pc
        as non-executable if the file cannot be opened for read. Retry query
        open only if errno is EACCES. Never change the mode, even if it is 000
        when query open() fails.
@
text
@a11 1
#include <errno.h>
@


1.54
log
@
2003-06-01  Pierre Humblet  <pierre.humblet@@ieee.org>

        * fhandler_disk_file.cc (fhandler_disk_file::fstat_by_name): Assume
        an existing directory is a root if FindFirstFile fails.
@
text
@a139 2
  __uid32_t uid;
  __gid32_t gid;
d160 3
a162 1
  else if (!(oret = open (pc, open_flags, 0)))
a163 1
      mode_t ntsec_atts = 0;
d166 1
d168 1
a168 15
      if (!query_open_already && (oret = open (pc, open_flags, 0)))
	/* ok */;
      else if (allow_ntsec && pc->has_acls () && get_errno () == EACCES
		&& !get_file_attribute (TRUE, get_win32_name (), &ntsec_atts, &uid, &gid)
		&& !ntsec_atts && uid == myself->uid && gid == myself->gid)
	{
	  /* Check a special case here. If ntsec is ON it happens
	     that a process creates a file using mode 000 to disallow
	     other processes access. In contrast to UNIX, this results
	     in a failing open call in the same process. Check that
	     case. */
	  set_file_attribute (TRUE, get_win32_name (), 0400);
	  oret = open (pc, open_flags, 0);
	  set_file_attribute (TRUE, get_win32_name (), ntsec_atts);
	}
d206 5
a210 1
  /* Unfortunately the count of 2 confuses `find (1)' command. So
a328 5
  /* The number of links to a directory includes the
     number of subdirectories in the directory, since all
     those subdirectories point to it.
     This is too slow on remote drives, so we do without it and
     set the number of links to 2. */
@


1.53
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Filter
	permissions throug umask on FAT or if ntsec is off.
@
text
@d111 11
a121 1
  else if (pc->isdir () && strlen (*pc) <= strlen (pc->root_dir ()))
d126 1
a126 1
  else if ((handle = FindFirstFile (*pc, &local)) == INVALID_HANDLE_VALUE)
a130 10
    }
  else
    {
      FindClose (handle);
      res = fstat_helper (buf, pc,
			  local.ftCreationTime,
			  local.ftLastAccessTime,
			  local.ftLastWriteTime,
			  local.nFileSizeHigh,
			  local.nFileSizeLow);
@


1.52
log
@	* fhandler.h: Rename FH_W95LSBUG flag to FH_LSEEKED.
	(fhandler_base::set_did_lseek): Rename from set_check_win95_lseek_bug.
	(fhandler_base::get_did_lseek): Rename from get_check_win95_lseek_bug.
	(fhandler_base::set_fs_flags): New method.
	(fhandler_base::get_fs_flags): Ditto.
	* fhandler.cc (fhandler_base::write): Make 64 bit clean.  Convert file
	to a "sparse" file when writing after a long lseek (>64K) beyond EOF.
	(fhandler_base::lseek): Call set_did_lseek() instead of
	set_check_win95_lseek_bug().
	(fhandler_base::fhandler_base): Initialize fs_flags to 0.
	* fhandler_disk_file.cc (fhandler_disk_file::open): Don't create files
	as "sparse" unconditionally.  Set fs_flags member.
@
text
@d334 3
@


1.51
log
@	* autoload.cc (GetDiskFreeSpaceEx): Add.
	* syscalls.cc (statfs): Call full_path.root_dir() instead of
	rootdir(full_path). Use GetDiskFreeSpaceEx when available and
	report space available in addition to free space.
	* fhandler_disk_file.cc (fhandler_disk_file::fstat_by_name):
	Do not call FindFirstFile for disk root directories.
@
text
@a28 1
#include <winioctl.h>
d397 1
a397 13
  /* Set newly created and truncated files as sparse files. */
  if ((real_path->fs_flags () & FILE_SUPPORTS_SPARSE_FILES)
      && (get_access () & GENERIC_WRITE) == GENERIC_WRITE
      && (get_flags () & (O_CREAT | O_TRUNC)))
    {
      DWORD dw;
      HANDLE h = get_handle ();
      BOOL r = DeviceIoControl (h , FSCTL_SET_SPARSE, NULL, 0, 	NULL, 0, &dw,
				NULL);
      syscall_printf ("%d = DeviceIoControl(0x%x, FSCTL_SET_SPARSE, NULL, 0, "
		      "NULL, 0, &dw, NULL)", r, h);
    }

@


1.50
log
@	Replace ino_t by __ino64_t throughout.
@
text
@d112 11
d125 7
a131 31
      char drivebuf[5];
      char *name;
      if ((*pc)[3] != '\0' || !isalpha ((*pc)[0]) || (*pc)[1] != ':' || (*pc)[2] != '\\')
	name = *pc;
      else
	{
	  /* FIXME: Does this work on empty disks? */
	  drivebuf[0] = (*pc)[0];
	  drivebuf[1] = (*pc)[1];
	  drivebuf[2] = (*pc)[2];
	  drivebuf[3] = '*';
	  drivebuf[4] = '\0';
	  name = drivebuf;
	}

      if ((handle = FindFirstFile (name, &local)) == INVALID_HANDLE_VALUE)
      {
	debug_printf ("FindFirstFile failed for '%s', %E", name);
	__seterrno ();
	res = -1;
      }
    else
      {
	FindClose (handle);
	res = fstat_helper (buf, pc,
			    local.ftCreationTime,
			    local.ftLastAccessTime,
			    local.ftLastWriteTime,
			    local.nFileSizeHigh,
			    local.nFileSizeLow);
      }
@


1.49
log
@* dir.cc (readdir): Fill out new old_d_ino field.
* fhandler.h (fhandler_base::namehash): Define as ino_t.
(fhandler_base::get_namehash): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Accommodate new 64
bit st_ino.
* fhandler_socket.cc (fhandler_socket::fstat): Ditto.
* path.cc (hash_path_name): Return ino_t.
* syscalls.cc (stat64_to_stat32): Convert 64 bit inode to 32 bit.
* winsup.h (hash_path_name): Declare as returning ino_t.
* include/cygwin/stat.h (__stat32): Use 32 bit st_ino.
(__stat64): Use 64 bit st_ino.
* include/cygwin/types.h (__ino64_t): Define.
(__ino32_t): Ditto.
(ino_t): Define appropriately.
@
text
@d253 2
a254 1
      buf->st_ino = (((ino_t) nFileIndexHigh) << 32) | (ino_t) nFileIndexLow;
@


1.48
log
@	* security.cc (get_info_from_sd): New function.
	(get_nt_attribute): Only call read_sd and get_info_from_sd.
	Return void.
	(get_file_attribute): Move sd error handling to get_info_from_sd.
	and symlink handling to fhandler_disk_file::fstat_helper.
	(get_nt_object_attribute): Only call read_sd and get_info_from_sd.
	Return void.
	(get_object_attribute): Remove symlink handling and simply return -1
	when ntsec is off.
	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): For
	symlinks set the attribute, call get_file_attribute to get the ids
	and return.  In the normal case call get_file_attribute with the
	addresses of the buffer ids and do not recheck if the file is a socket.
@
text
@d253 1
a253 1
      buf->st_ino = nFileIndexHigh | nFileIndexLow;
@


1.47
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@d284 7
a290 1
    buf->st_mode = S_IFLNK;
a293 2
  __uid32_t uid;
  __gid32_t gid;
d295 1
a295 1
			  &uid, &gid) == 0)
a315 2
      else if (pc->issocket ())
	buf->st_mode |= S_IFSOCK;
a348 3
  buf->st_uid = uid;
  buf->st_gid = gid;

d354 1
a354 1

@


1.46
log
@	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Fix
	wrong usage of S_IFDIR.
	* security.cc (get_attribute_from_acl): Ditto.
	(get_file_attribute): Fix wrong usage of S_IFLNK.
	(get_object_attribute): Ditto.
	(alloc_sd): Fix wrong usage of S_IFDIR.
	* syscalls.cc (chmod): Allow chmod'ing of socket files.
@
text
@d233 1
a233 1
  buf->st_size = ((__off64_t)nFileSizeHigh << 32) + nFileSizeLow;
d272 1
a272 1
    buf->st_blocks = (((__off64_t)nFileSizeHigh << 32)
d460 1
a460 1
  __off64_t win32_start;
d463 1
a463 1
  __off64_t startpos;
d497 1
a497 1
	  startpos = ((__off64_t)finfo.nFileSizeHigh << 32)
d718 1
a718 1
__off64_t
d725 1
a725 1
fhandler_disk_file::seekdir (DIR *dir, __off64_t loc)
d832 1
a832 1
__off64_t
d839 1
a839 1
fhandler_cygdrive::seekdir (DIR *dir, __off64_t loc)
@


1.45
log
@whitespace cleanup
@
text
@d308 1
a308 1
      if (buf->st_mode & S_IFDIR)
@


1.44
log
@* fhandler.cc (fhandler_base::open): Move some filesystem specific stuff.
(fhandler_disk_file::open): Accept some filesystem specific stuff.
* sigproc.cc (wait_for_sigthread): Become slightly more thread safe.
(sig_send): Don't assume that signal thread is ready.
@
text
@d631 1
a631 1
        {
@


1.43
log
@	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Check descriptor
	created by cygheap_fdnew constructor.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
	* fhandler_socket.cc (fhandler_socket::accept): Ditto and move
	creation of file descriptor behind blocking OS call.
	* net.cc (cygwin_socket): Ditto.
	(cygwin_rcmd): Ditto.
	(cygwin_rresvport): Ditto.
	(cygwin_rexec): Ditto.
	(socketpair): Ditto.
@
text
@d403 8
@


1.42
log
@	* autoload.cc (GetCompressedFileSize): Add.
	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Compute
	st_blocks value from GetCompressedFileSize() if available.
@
text
@d622 16
a637 14
      fd = this;
      fd->set_nohandle (true);
      dir->__d_dirent->d_fd = fd;
      dir->__d_u.__d_data.__fh = this;
      /* FindFirstFile doesn't seem to like duplicate /'s. */
      len = strlen (dir->__d_dirname);
      if (len == 0 || isdirsep (dir->__d_dirname[len - 1]))
	strcat (dir->__d_dirname, "*");
      else
	strcat (dir->__d_dirname, "\\*");  /**/
      dir->__d_cookie = __DIRENT_COOKIE;
      dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
      dir->__d_position = 0;
      dir->__d_dirhash = get_namehash ();
d639 2
a640 1
      res = dir;
@


1.41
log
@w32api:

        * include/winioctl.h (FSCTL_SET_SPARSE): Define.

cygwin:

        * wincap.h (wincaps::supports_sparse_files): New flag.
        (wincapc::supports_sparse_files): New method.
        * wincap.cc (wincap_unknown): Define value for the new flag.
        (wincap_95): Ditto.
        (wincap_95osr2): Ditto.
        (wincap_98): Ditto.
        (wincap_98se): Ditto.
        (wincap_me): Ditto.
        (wincap_nt3): Ditto.
        (wincap_nt4): Ditto.
        (wincap_nt4sp4): Ditto.
        (wincap_2000): Ditto.
        (wincap_xp): Ditto.
        * path.h (path_conv::fs_flags): New method.
        * fhandler_disk_file.cc: Include winioctl.h for DeviceIoControl.
        (fhandler_disk_file::open): Set newly created and truncated files as
        sparse on platforms that support it.
@
text
@d263 14
a276 1
  buf->st_blocks  = (buf->st_size + S_BLKSIZE - 1) / S_BLKSIZE;
@


1.40
log
@* include/cygwin/in.h (in_attr_t): Define new type.
* include/arpa/inet.h (inet_addr): Change return type to in_addr_t.
(inet_lnaof): Ditto.
(inet_netof): Ditto.
(inet_network): Ditto.
* include/cygwin/types.h: Move many *_t typedefs here.  Protect them with
ifdefs.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Change ntsec_atts to
mode_t.
* security.cc (get_attribute_from_acl): Accept mode_t attribute.
(get_nt_attribute): Ditto.
(get_file_attribute): Ditto.
(get_nt_object_attribute): Ditto.
(get_object_attribute): Ditto.
* security.h: Reflect above changes.
* syscalls.cc (chown_worker): Change attrib to mode_t.
@
text
@d29 1
d388 13
@


1.39
log
@Eliminate most unneeded this-> pointers throughout.
@
text
@d177 1
a177 1
      int ntsec_atts = 0;
@


1.38
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d371 1
a371 1
  int res = this->fhandler_base::open (real_path, flags | O_DIROPEN, mode);
d402 1
a402 1
  int res = this->fhandler_base::close ();
@


1.38.2.1
log
@merge from trunk
@
text
@a32 5
/* The fhandler_base stat calls and helpers are actually only
   applicable to files on disk.  However, they are part of the
   base class so that on-disk device files can also access them
   as appropriate.  */

d63 1
a63 1
fhandler_base::fstat_by_handle (struct __stat64 *buf, path_conv *pc)
a76 1

d99 1
a99 1
fhandler_base::fstat_by_name (struct __stat64 *buf, path_conv *pc)
d102 2
d128 16
a143 18
      HANDLE h;
      WIN32_FIND_DATA local;
      if ((h = FindFirstFile (name, &local)) == INVALID_HANDLE_VALUE)
	{
	  debug_printf ("FindFirstFile failed for '%s', %E", name);
	  __seterrno ();
	  res = -1;
	}
      else
	{
	  FindClose (h);
	  res = fstat_helper (buf, pc,
			      local.ftCreationTime,
			      local.ftLastAccessTime,
			      local.ftLastWriteTime,
			      local.nFileSizeHigh,
			      local.nFileSizeLow);
	}
d149 1
a149 1
fhandler_base::fstat_fs (struct __stat64 *buf, path_conv *pc)
d175 1
a175 1
  else if (!(oret = open_fs (pc, open_flags, 0)))
d203 1
a203 1
      close_fs ();
d210 9
a218 9
fhandler_base::fstat_helper (struct __stat64 *buf, path_conv *pc,
			     FILETIME ftCreationTime,
			     FILETIME ftLastAccessTime,
			     FILETIME ftLastWriteTime,
			     DWORD nFileSizeHigh,
			     DWORD nFileSizeLow,
			     DWORD nFileIndexHigh,
			     DWORD nFileIndexLow,
			     DWORD nNumberOfLinks)
a299 5
      else if (is_fs_special ())
	{
	  buf->st_dev = dev;
	  buf->st_mode = dev.mode;
	}
d348 2
a349 2
int __stdcall
fhandler_disk_file::fstat (struct __stat64 *buf, path_conv *pc)
a350 1
  return fstat_fs (buf, pc);
d354 1
a354 1
  fhandler_base ()
a360 6
  return open_fs (real_path, flags, mode);
}

int
fhandler_base::open_fs (path_conv *real_path, int flags, mode_t mode)
{
d384 1
a384 1
      close_fs ();
a401 6
  return close_fs ();
}

int
fhandler_base::close_fs ()
{
d408 13
a420 8
/* FIXME: The correct way to do this to get POSIX locking semantics is to
   keep a linked list of posix lock requests and map them into Win32 locks.
   he problem is that Win32 does not deal correctly with overlapping lock
   requests. Also another pain is that Win95 doesn't do non-blocking or
   non-exclusive locks at all. For '95 just convert all lock requests into
   blocking,exclusive locks.  This shouldn't break many apps but denying all
   locking would.  For now just convert to Win32 locks and hope for
   the best.  */
d668 1
a668 1
	  if (fpath.issymlink () || fpath.isspecial ())
d720 2
a721 2
fhandler_cygdrive::fhandler_cygdrive () :
  fhandler_disk_file (), ndrives (0), pdrive (NULL)
@


1.38.2.2
log
@merge from trunk
@
text
@d389 1
a389 1
  int res = fhandler_base::open (real_path, flags | O_DIROPEN, mode);
d426 1
a426 1
  int res = fhandler_base::close ();
@


1.38.2.3
log
@merge from trunk
@
text
@d183 1
a183 1
      mode_t ntsec_atts = 0;
@


1.38.2.4
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d21 1
a22 1
#include "fhandler.h"
d68 1
a68 1
fhandler_base::fstat_by_handle (struct __stat64 *buf)
d93 1
a93 1
  return fstat_helper (buf,
d105 1
a105 1
fhandler_base::fstat_by_name (struct __stat64 *buf)
d109 1
a109 1
  if (!pc.exists ())
d119 2
a120 2
      if ((pc)[3] != '\0' || !isalpha ((pc)[0]) || (pc)[1] != ':' || (pc)[2] != '\\')
	name = pc;
d124 3
a126 3
	  drivebuf[0] = pc[0];
	  drivebuf[1] = pc[1];
	  drivebuf[2] = pc[2];
d143 1
a143 1
	  res = fstat_helper (buf,
d155 1
a155 1
fhandler_base::fstat_fs (struct __stat64 *buf)
d167 1
a167 1
	return fstat_by_name (buf);
d169 1
a169 1
	return fstat_by_handle (buf);
d173 1
a173 1
  if (pc.exec_state () != dont_know_if_executable)
d178 1
a178 1
  if (query_open_already && strncasematch (pc.volname (), "FAT", 3)
d181 1
a181 1
  else if (!(oret = open_fs (open_flags, 0)))
d187 1
a187 1
      if (!query_open_already && (oret = open (open_flags, 0)))
d189 1
a189 1
      else if (allow_ntsec && pc.has_acls () && get_errno () == EACCES
d199 1
a199 1
	  oret = open (open_flags, 0);
d205 1
a205 1
    res = fstat_by_name (buf);
d208 1
a208 1
      res = fstat_by_handle (buf);
d216 1
a216 1
fhandler_base::fstat_helper (struct __stat64 *buf,
d237 1
a237 1
  buf->st_dev = pc.volser ();
d241 2
a242 2
  if (pc.isdir () && !pc.isremote () && nNumberOfLinks == 1)
    buf->st_nlink = num_entries (pc.get_win32 ());
d249 2
a250 2
  switch (pc.has_acls () && (nFileIndexHigh || nFileIndexLow)
	  ? pc.drive_type () : DRIVE_UNKNOWN)
d273 1
a273 1
  if (pc.isdir ())
d275 1
a275 1
  else if (pc.issymlink ())
d277 1
a277 1
  else if (pc.issocket ())
d282 1
a282 1
  if (get_file_attribute (pc.has_acls (), get_win32_name (), &buf->st_mode,
d286 1
a286 1
      if (pc.has_attribute (FILE_ATTRIBUTE_READONLY) && !get_symlink_p ())
d296 1
a296 1
      if (!pc.has_attribute (FILE_ATTRIBUTE_READONLY))
d304 1
a304 1
      else if (pc.issocket ())
d308 2
a309 2
	  buf->st_dev = dev ();
	  buf->st_mode = dev ().mode;
d314 1
a314 1
	  if (pc.exec_state () == dont_know_if_executable)
d332 1
a332 1
		      pc.set_exec ();
d340 1
a340 1
      if (pc.exec_state () == is_executable)
d360 1
a360 1
fhandler_disk_file::fstat (struct __stat64 *buf)
d362 1
a362 1
  return fstat_fs (buf);
d371 1
a371 1
fhandler_disk_file::open (int flags, mode_t mode)
d373 1
a373 1
  return open_fs (flags, mode);
d377 1
a377 1
fhandler_base::open_fs (int flags, mode_t mode)
d379 1
a379 1
  if (pc.case_clash && flags & O_CREAT)
d386 2
a387 2
  set_has_acls (pc.has_acls ());
  set_isremote (pc.isremote ());
d389 1
a389 1
  int res = fhandler_base::open (flags | O_DIROPEN, mode);
d399 1
a399 1
  if (pc.has_buggy_open () && !pc.exists ())
d407 3
a409 3
  set_symlink_p (pc.issymlink ());
  set_execable_p (pc.exec_state ());
  set_socket_p (pc.issocket ());
d585 1
a585 1
fhandler_disk_file::opendir ()
d591 1
a591 1
  if (!pc.isdir ())
d593 1
a593 1
  else if ((len = strlen (pc))> MAX_PATH - 3)
d611 1
a611 1
      strcpy (dir->__d_dirname, get_win32_name ());
d749 4
a752 2
  char *p = const_cast<char *> (get_win32_name ());
  pdrive = p;
d760 1
a760 1
fhandler_cygdrive::fstat (struct __stat64 *buf)
d763 1
a763 1
    return fhandler_disk_file::fstat (buf);
d772 1
a772 1
fhandler_cygdrive::opendir ()
d776 1
a776 1
  dir = fhandler_disk_file::opendir ();
d825 1
a825 1
  for (pdrive = get_win32_name (), dir->__d_position = -1; *pdrive;
d838 1
a838 1
  pdrive = get_win32_name ();
d848 1
a848 1
  pdrive = get_win32_name ();
@


1.38.2.5
log
@merge from trunk
@
text
@a28 1
#include <winioctl.h>
d268 1
a268 14

  /* GetCompressedFileSize() gets autoloaded.  It returns INVALID_FILE_SIZE
     if it doesn't exist.  Since that's also a valid return value on 64bit
     capable file systems, we must additionally check for the win32 error. */
  nFileSizeLow = GetCompressedFileSizeA (pc, &nFileSizeHigh);
  if (nFileSizeLow != INVALID_FILE_SIZE || GetLastError () == NO_ERROR)
    /* On systems supporting compressed (and sparsed) files,
       GetCompressedFileSize() returns the actual amount of
       bytes allocated on disk.  */
    buf->st_blocks = (((__off64_t)nFileSizeHigh << 32)
		     + nFileSizeLow + S_BLKSIZE - 1) / S_BLKSIZE;
  else
    /* Just compute no. of blocks from file size. */
    buf->st_blocks  = (buf->st_size + S_BLKSIZE - 1) / S_BLKSIZE;
a406 20
  /* Attributes may be set only if a file is _really_ created.
     This code is now only used for ntea here since the files
     security attributes are set in CreateFile () now. */
  if (flags & O_CREAT
      && GetLastError () != ERROR_ALREADY_EXISTS
      && !allow_ntsec && allow_ntea)
    set_file_attribute (has_acls (), get_win32_name (), mode);

  /* Set newly created and truncated files as sparse files. */
  if ((pc.fs_flags () & FILE_SUPPORTS_SPARSE_FILES)
      && (get_access () & GENERIC_WRITE) == GENERIC_WRITE)
    {
      DWORD dw;
      HANDLE h = get_handle ();
      BOOL r = DeviceIoControl (h , FSCTL_SET_SPARSE, NULL, 0, 	NULL, 0, &dw,
				NULL);
      syscall_printf ("%d = DeviceIoControl(0x%x, FSCTL_SET_SPARSE, NULL, 0, "
		      "NULL, 0, &dw, NULL)", r, h);
    }

d614 14
a627 16
      if (fd >= 0)
        {
	  fd = this;
	  fd->set_nohandle (true);
	  dir->__d_dirent->d_fd = fd;
	  dir->__d_u.__d_data.__fh = this;
	  /* FindFirstFile doesn't seem to like duplicate /'s. */
	  len = strlen (dir->__d_dirname);
	  if (len == 0 || isdirsep (dir->__d_dirname[len - 1]))
	    strcat (dir->__d_dirname, "*");
	  else
	    strcat (dir->__d_dirname, "\\*");  /**/
	  dir->__d_cookie = __DIRENT_COOKIE;
	  dir->__d_u.__d_data.__handle = INVALID_HANDLE_VALUE;
	  dir->__d_position = 0;
	  dir->__d_dirhash = get_namehash ();
d629 1
a629 2
	  res = dir;
	}
@


1.38.2.6
log
@merge from trunk
@
text
@d649 1
a649 1
	{
@


1.38.2.7
log
@merge from trunk
@
text
@d314 1
a314 1
      if (S_ISDIR (buf->st_mode))
@


1.38.2.8
log
@merge from trunk
@
text
@d239 1
a239 1
  buf->st_size = ((_off64_t )nFileSizeHigh << 32) + nFileSizeLow;
d278 1
a278 1
    buf->st_blocks = (((_off64_t)nFileSizeHigh << 32)
d478 1
a478 1
  _off64_t win32_start;
d481 1
a481 1
  _off64_t startpos;
d515 1
a515 1
	  startpos = ((_off64_t)finfo.nFileSizeHigh << 32)
d736 1
a736 1
_off64_t
d743 1
a743 1
fhandler_disk_file::seekdir (DIR *dir, _off64_t loc)
d848 1
a848 1
_off64_t
d855 1
a855 1
fhandler_cygdrive::seekdir (DIR *dir, _off64_t loc)
@


1.38.2.9
log
@merge from trunk
@
text
@d290 1
a290 7
    {
      /* symlinks are everything for everyone! */
      buf->st_mode = S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;
      get_file_attribute (pc->has_acls (), get_win32_name (), NULL,
			  &buf->st_uid, &buf->st_gid);
      goto done;
    }
d294 2
d297 1
a297 1
			  &buf->st_uid, &buf->st_gid) == 0)
d318 2
d358 3
d366 1
a366 1
 done:
@


1.38.2.10
log
@merge from trunk
@
text
@d29 1
a108 2
  HANDLE handle;
  WIN32_FIND_DATA local;
a115 11
  else if (pc.isdir () && strlen (pc) <= strlen (pc.root_dir ()))
    {
      FILETIME ft = {};
      res = fstat_helper (buf, ft, ft, ft, 0, 0);
    }
  else if ((handle = FindFirstFile (pc, &local)) == INVALID_HANDLE_VALUE)
    {
      debug_printf ("FindFirstFile failed for '%s', %E", (char *) pc);
      __seterrno ();
      res = -1;
    }
d118 33
a150 7
      FindClose (handle);
      res = fstat_helper (buf,
			  local.ftCreationTime,
			  local.ftLastAccessTime,
			  local.ftLastWriteTime,
			  local.nFileSizeHigh,
			  local.nFileSizeLow);
d259 1
a259 2
      buf->st_ino = (((__ino64_t) nFileIndexHigh) << 32)
                    | (__ino64_t) nFileIndexLow;
d293 1
a293 1
      get_file_attribute (pc.has_acls (), get_win32_name (), NULL,
d428 12
a439 1
  set_fs_flags (pc.fs_flags ());
@


1.38.2.11
log
@merge from trunk
@
text
@d117 12
a128 1
  else if ((handle = FindFirstFile (pc, &local)) != INVALID_HANDLE_VALUE)
a137 11
  else if (pc.isdir ())
    {
      FILETIME ft = {};
      res = fstat_helper (buf, ft, ft, ft, 0, 0);
    }
  else 
    {
      debug_printf ("FindFirstFile failed for '%s', %E", (char *) pc);
      __seterrno ();
      res = -1;
    }
d146 2
d168 1
a168 3
  else if (!(oret = open_fs (open_flags, 0))
	   && !query_open_already
	   && get_errno () == EACCES)
d170 1
a172 1
      pc.set_exec (0);
d174 15
a188 1
      oret = open_fs (open_flags, 0);
d225 2
a226 6
  buf->st_size = ((_off64_t) nFileSizeHigh << 32) + nFileSizeLow;
  /* The number of links to a directory includes the
     number of subdirectories in the directory, since all
     those subdirectories point to it.
     This is too slow on remote drives, so we do without it.
     Setting the count to 2 confuses `find (1)' command. So
a344 3

      /* This fakes the permissions of all files to match the current umask. */
      buf->st_mode &= ~(cygheap->umask);
d347 5
@


1.38.2.12
log
@merge from trunk
@
text
@d12 1
a629 2
      if (real_name.isencoded ())
	set_encoded ();
d656 3
a658 1
    return res;
d673 1
a673 4
  if (get_encoded ())
    (void) fnunmunge (dir->__d_dirent->d_name, buf.cFileName);
  else
    strcpy (dir->__d_dirent->d_name, buf.cFileName);
@


1.38.2.13
log
@merge from trunk
@
text
@d629 1
a629 1
      if (pc.isencoded ())
@


1.38.2.14
log
@merge from trunk
@
text
@d131 1
a131 1
  else
d235 1
a235 1
		    | (__ino64_t) nFileIndexLow;
d789 4
a792 1
    return NULL;
@


1.38.2.15
log
@merge from trunk
@
text
@d615 1
a615 1
	  dir->__fh = this;
d623 1
a623 1
	  dir->__handle = INVALID_HANDLE_VALUE;
d644 1
a644 1
  if (dir->__handle == INVALID_HANDLE_VALUE
d649 1
a649 1
      dir->__handle = handle;
d656 1
a656 1
  else if (dir->__handle == INVALID_HANDLE_VALUE)
d658 1
a658 1
  else if (!FindNextFileA (dir->__handle, &buf))
d661 2
a662 2
      (void) FindClose (dir->__handle);
      dir->__handle = INVALID_HANDLE_VALUE;
d719 1
a719 1
  if (dir->__handle != INVALID_HANDLE_VALUE)
d721 2
a722 2
      (void) FindClose (dir->__handle);
      dir->__handle = INVALID_HANDLE_VALUE;
d731 2
a732 2
  if (dir->__handle != INVALID_HANDLE_VALUE &&
      FindClose (dir->__handle) == 0)
d750 1
a750 1
  const int len = 2 + 26 * DRVSZ;
d753 3
@


1.38.2.16
log
@merge from trunk
@
text
@d56 1
a56 1
  int saw_dot = 2;
d59 2
a60 6
      if (buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	count++;
      if (buf.cFileName[0] == '.'
	  && (buf.cFileName[1] == '\0'
	      || (buf.cFileName[1] == '.' && buf.cFileName[2] == '\0')))
	saw_dot--;
d63 1
a63 1
  return count + saw_dot;
d764 1
a764 1
  buf->st_nlink = ndrives + 2;
d787 2
a788 1
  if (GetFileAttributes (pdrive) == INVALID_FILE_ATTRIBUTES)
d793 7
a799 3

  *dir->__d_dirent->d_name = cyg_tolower (*pdrive);
  dir->__d_dirent->d_name[1] = '\0';
@


1.38.2.17
log
@merge from trunk
@
text
@d32 7
a38 2
unsigned __stdcall
path_conv::ndisk_links (DWORD nNumberOfLinks)
d40 4
a43 19
  if (!isdir () || isremote ())
    return nNumberOfLinks;

  int len = strlen (*this);
  char fn[len + 3];
  strcpy (fn, *this);

  const char *s;
  unsigned count;
  if (nNumberOfLinks <= 1)
    {
      s = "/*";
      count = 0;
    }
  else
    {
      s = "/..";
      count = nNumberOfLinks;
    }
d45 4
a48 2
  if (len == 0 || isdirsep (fn[len - 1]))
    strcpy (fn + len, s + 1);
d50 1
a50 1
    strcpy (fn + len, s);
d52 1
a52 2
  WIN32_FIND_DATA buf;
  HANDLE h = FindFirstFile (fn, &buf);
d54 2
d57 1
a57 1
  if (h != INVALID_HANDLE_VALUE)
d59 5
a63 1
      if (nNumberOfLinks > 1)
a64 21
      else
	do
	  {
	    if (buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	      count++;
	    if (buf.cFileName[0] == '.'
		&& (buf.cFileName[1] == '\0'
		    || (buf.cFileName[1] == '.' && buf.cFileName[2] == '\0')))
	      saw_dot--;
	  }
	while (FindNextFileA (h, &buf));
      FindClose (h);
    }

  if (nNumberOfLinks > 1)
    {
      fn[len + 2] = '\0';
      h = FindFirstFile (fn, &buf);
      if (h)
	saw_dot--;
      FindClose (h);
d66 1
a66 1

d221 4
a224 1
  buf->st_nlink = pc.ndisk_links (nNumberOfLinks);
@


1.37
log
@	* fhandler_disk_file.cc (num_entries): Return 2 as link count if
	directory unreadable.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.36
log
@Use isdirsep rather than SLASH_P throughout.
* path.cc (iscygdrive): Disallow /cygdrive\x.
(normalize_posix_path): "Normalize" a windows path, if detected, rather than
converting to posix.
* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support and capability
checking for B230400 bitrate.
(fhandler_serial::tcgetattr): Add support for B230400 bitrate.
* include/sys/termios.h: Add B230400 definition for Posix support of 230.4Kbps.
@
text
@d51 1
a51 1
    return 0;
@


1.35
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Nevermind.  Revert
everything to previous state wrt ntsec and exec bits.
@
text
@d601 1
a601 1
      if (len == 0 || SLASH_P (dir->__d_dirname[len - 1]))
@


1.35.12.1
log
@Introduce device class to cygwin throughout.  Rename FH_DISK to FH_FS
throughout.
* dcrt0.cc (dll_crt0_1): Initialize device globals via device::init.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
names when they are known.  Should speed up process startup slightly.
(dtable::build_fhandler_from_name): Pass path_conv device to build_fhandler.
(dtable::build_fhandler): Accept device argument rather than separate
device/unit arguments.
(dtable::build_fhandler): Ditto.  Separate switch statement by devices which
take units and those which don't.  Build unix/win32 names from device if
required.
(dtable::dup_worker): Reflect changes to build_fhandler arguments.
* dtable.h (dtable::build_fhandler): Ditto.
* fhandler.cc (fhandler_base::set_name): Eliminate unit argument.  Use get_unit
to derive unit.
* fhandler.h: Separate FH device defines into devices.h include.  Define
is_slow as appropriate for each fhandler_class.
(fhandler_base::dev): New element.
(fhandler_base::fhandler_base): Eliminate unit argument.
(fhandler_base::get_device): Return device number.
(fhandler_base::get_major): Return device major number.
(fhandler_base::get_minor): Return device minor number.
(fhandler_base::get_unit): Ditto.
(fhandler_base::get_native_name): Return device format field.
(fhandler_fifo): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_cygdrive::fhandler_cygdrive): Remove unit
initialization.
* fhandler_tty.cc (fhandler_tty_master::init_console): Use "console_dev" global
to initialize captive console used by tty master.
* mmap.cc (mmap_record::devtype_): Remove.
(mmap_record::dev): New.
(mmap_record::mmap_record): Use dev.
(mmap_record::get_device): Implement via dev.
* net.cc (fdsock): Use socket_dev global to initialize socket fhandler.
* path.cc (path_conv::check): Accommodate new path_conv::dev element.
(get_devn): Eliminate.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Accept dev argument.  Use it.  Use device::parse to derive
potential device name.
(mount_info::conv_to_win32_path): Accept dev argument.  Use it.
* path.h (path_conv::devn): Eliminate.
(path_conv::unit): Ditto.
(path_conv::dev): Declare.
(path_conv::path_conv): Don't initialize deleted members.
(path_conv::is_device): Implement via dev element.
(path_conv::get_devn): Ditto.
(path_conv::get_unitn): Ditto.
* pipe.cc (make_pipe): Use pipe[rw]_dev in fhandler construction.
* select.cc: Use new device_specific_* select class elements
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(mount_info::conv_to_win32_path): Reflect new arguments.
* syscalls.cc (fstat64): Just use get_device() without interpretation for
st_dev element.
(stat_worker): Ditto.
* tty.cc (create_tty_master): Use ttym_dev in fhandler constructor.
(tty::common_init): Check for tty major device number rather than FH_TTYM.
@
text
@d354 1
a354 1
  fhandler_base (FH_FS)
d720 2
a721 2
fhandler_cygdrive::fhandler_cygdrive () :
  fhandler_disk_file (FH_CYGDRIVE), ndrives (0), pdrive (NULL)
@


1.35.12.2
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d348 5
d354 1
a354 1
  fhandler_base ()
d721 1
a721 1
  fhandler_disk_file (), ndrives (0), pdrive (NULL)
@


1.35.12.3
log
@* cygwin-gperf: New file.
* Makefile.in: Use cygwin-gperf script to build devices.cc.
* configure.in: Remove some comments.
* configure: Regenerate.
* devices.gperf: Remove max unit determination from FH_TTY.  Add /dev/kmem.
Add /dev/fifo.  Add /dev/rawdrive.  Remove specific "const device *"
declarations since they are now autogenerated.
(device::parse): Treat FH_TTY specially.  Move logic for determining real tty
device to separate function.
(device::init): Reduce to nothing.
(device::parse): New function taking different arguments.
(device::parse): Ditto.
(device::tty_to_real_device): New function.
* devices.h (struct device): Define above new functions.
(device::dev_on_fs): New element.
(device::setfs): New function.
(device::isfs): Ditto.
* dtable.cc (dtable::build_fhandler): Treat FH_TTY specially.
* fhandler.cc (fhandler_base::set_name): Make special determination for
non-disk-resident devices.
* fhandler.h (fhandler_base::isdevice): Renamed from 'is_device'.
(fhandler_disk_file::isdevice): Ditto.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_device): New function.
(fhandler_tty_slave::get_unit): Declare.
(fhandler_disk_file::readdir): Take special .lnk consideration for devices as
well as symlinks.
* fhandler_tty.cc: Use get_unit () rather than dev.minor throughout.
(fhandler_tty_slave::get_unit): Define new function.
* path.cc (symlink_info::major): New element.
(symlink_info::major): Ditto.
(symlink_info::devtype): Ditto.
(path_conv::check): Handle devices detected by symlink_info::check.
(win32_device_name): Eliminate special FH_TTY handling.
(symlink): Move bulk of procesing to symlink_worker.
(symlink_worker): New function.  Handles devices.
(symlink_info::parse_device): Parse info from potential device file into
symlink_info elements.
(symlink_info::check): If contents of .lnk file begin with a ':' then treat the
file as a device file.
* path.h (isdevice): Renamed from is_device.
(is_auto_device): New function.
(is_fs_device): Ditto.
* syscalls.cc (chown_worker): Allow setting of ownership for on-disk devices.
(chmod): Ditto.
(mknod): Implement.
* winsup.h (symlink_worker): Declare.
@
text
@d663 1
a663 1
	  if (fpath.issymlink () || fpath.isdevice ())
@


1.35.12.4
log
@* sysconf.cc (sysconf): Return arbitrary values for _SC_GETGR_R_SIZE_MAX,
_SC_LOGIN_NAME_MAX, _SC_GETPW_R_SIZE_MAX.
* passwd.cc (getpwuid_r32): Add uid/gid fields to size check calculation.
* exceptions.cc (events_init): Display name of mutex on failure.
* windows.cc (setitimer): Return ENOSYS on invalid argument.
@
text
@a32 5
/* The fhandler_base stat calls and helpers are actually only
   applicable to files on disk.  However, they are part of the
   base class so that on-disk device files can also access them
   as appropriate.  */

d63 1
a63 1
fhandler_base::fstat_by_handle (struct __stat64 *buf, path_conv *pc)
a76 1

d99 1
a99 1
fhandler_base::fstat_by_name (struct __stat64 *buf, path_conv *pc)
d102 2
d128 16
a143 18
      HANDLE h;
      WIN32_FIND_DATA local;
      if ((h = FindFirstFile (name, &local)) == INVALID_HANDLE_VALUE)
	{
	  debug_printf ("FindFirstFile failed for '%s', %E", name);
	  __seterrno ();
	  res = -1;
	}
      else
	{
	  FindClose (h);
	  res = fstat_helper (buf, pc,
			      local.ftCreationTime,
			      local.ftLastAccessTime,
			      local.ftLastWriteTime,
			      local.nFileSizeHigh,
			      local.nFileSizeLow);
	}
d149 1
a149 1
fhandler_base::fstat_fs (struct __stat64 *buf, path_conv *pc)
d175 1
a175 1
  else if (!(oret = open_fs (pc, open_flags, 0)))
d203 1
a203 1
      close_fs ();
d210 9
a218 9
fhandler_base::fstat_helper (struct __stat64 *buf, path_conv *pc,
			     FILETIME ftCreationTime,
			     FILETIME ftLastAccessTime,
			     FILETIME ftLastWriteTime,
			     DWORD nFileSizeHigh,
			     DWORD nFileSizeLow,
			     DWORD nFileIndexHigh,
			     DWORD nFileIndexLow,
			     DWORD nNumberOfLinks)
a299 7
      else if (pc->isfifo ())
	buf->st_mode |= S_IFIFO;
      else if (pc->isdevice ())
	{
	  buf->st_mode |= dev.type == 'b' ? S_IFBLK : S_IFCHR;
	  buf->st_dev = dev;
	}
a347 6
int __stdcall
fhandler_disk_file::fstat (struct __stat64 *buf, path_conv *pc)
{
  return fstat_fs (buf, pc);
}

a355 6
  return open_fs (real_path, flags, mode);
}

int
fhandler_base::open_fs (path_conv *real_path, int flags, mode_t mode)
{
d379 1
a379 1
      close_fs ();
a396 6
  return close_fs ();
}

int
fhandler_base::close_fs ()
{
d403 13
a415 8
/* FIXME: The correct way to do this to get POSIX locking semantics is to
   keep a linked list of posix lock requests and map them into Win32 locks.
   he problem is that Win32 does not deal correctly with overlapping lock
   requests. Also another pain is that Win95 doesn't do non-blocking or
   non-exclusive locks at all. For '95 just convert all lock requests into
   blocking,exclusive locks.  This shouldn't break many apps but denying all
   locking would.  For now just convert to Win32 locks and hope for
   the best.  */
@


1.35.12.5
log
@* devices.h (_devtype_t): Eliminate.
(_mode_t): New typedef.
(device::mode): Replace type.
* fhandler.h (fhandler_base::device_access_denied): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Define new function.
* fhandler_disk_file.cc (fhandler_base::fstat_helper): Just copy mode directly
from dev.mode to st_mode if it is a disk device.
* path.cc (path_conv::check): Set device mode from sym mode.
(symlink_worker): Let "exists" check happen when file is attempted to be
opened, or not, in the case of creating a device.
(symlink_info::parse_device): Change device type argument to device mode
argument.
(mknod_worker): New function.
(chmod_device): Ditto.
(chmod): Use chmod_device to set protection if it is an fs device.
(mknod): Use mknod_worker to actually create the device.  Don't take any
special action with the protection since it is now implicit.
@
text
@d310 1
a311 1
	  buf->st_mode = dev.mode;
@


1.35.12.6
log
@Replace is_fs_device with is_fs_special throughout.
* Makefile.in (DLL_OFILES): Add fhandler_fifo.o.
* devices.h (fh_devices): Renumber some minor numbers to fit in 8 bits.
* dtable.cc (dtable::build_fhandler): Handle FH_FIFO.  Set errno to ENODEV if
device not found.
* dtable::find_fifo: Define new function.
* dtable.h (dtable::find_fifo): Declare new function.
* fhandler.cc (fhandler_base::device_access_denied): Fix O_RDONLY test.
(fhandler_base::write): Use output file handle for writing.
(fhandler_base::fstat): Use is_fs_special rather than is_fs_device.
* fhandler.h (fhandler_base::is_fs_special): Rename from is_fs_device.
(fhandler_pipe): Make private elements protected so that fhandler_fifo can use
them too.
(fhandler_pipe::create): New function derived from make_pipe.
(fhandler_fifo): Add more needed elements.
(fhandler_pty_master::slave): Add to track slave device.
(fhandler_pty_master::get_unit): Define.
* fhandler_tty.cc (fhandler_tty_master::init): Register slave device.
(fhandler_pty_master::open): Ditto.
(symlink_info::parse_device): Handle fifo specially.
* pinfo.cc (_pinfo::commune_recv): Initial fifo implementation.
(_pinfo::commune_send): Ditto.
* pinfo.h (picom): Add PICOM_FIFO.
* pipe.cc (fhandler_pipe::close): Close input handle here specifically.
(fhandler_pipe::create): Rename from make_pipe.  Create fhandlers rather than
fds.
(pipe): Use fhandler_pipe::create to create pipe.
(_pipe): Ditto.
* syscalls.cc (mknod): Accommodate fifos.
@
text
@d306 3
a308 1
      else if (is_fs_special ())
d689 1
a689 1
	  if (fpath.issymlink () || fpath.isspecial ())
@


1.35.12.7
log
@.
@
text
@d620 1
a620 1
      if (len == 0 || isdirsep (dir->__d_dirname[len - 1]))
@


1.34
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Oops.  Only do the
executable thing for #! scripts since .exe files wouldn't be executable in
ntsec case regardless.
@
text
@d303 24
d328 1
a330 27
    }

  if (buf->st_mode & STD_XBITS)
    /* already derived */;
  else if (pc->exec_state () == dont_know_if_executable)
    {
      DWORD cur, done;
      char magic[3];

      /* First retrieve current position, set to beginning
	 of file if not already there. */
      cur = SetFilePointer (get_handle (), 0, NULL, FILE_CURRENT);
      if (cur != INVALID_SET_FILE_POINTER
	  && (!cur || SetFilePointer (get_handle (), 0, NULL, FILE_BEGIN)
	      != INVALID_SET_FILE_POINTER))
	{
	  /* FIXME should we use /etc/magic ? */
	  magic[0] = magic[1] = magic[2] = '\0';
	  if (ReadFile (get_handle (), magic, 3, &done, NULL) &&
	      has_exec_chars (magic, done))
	    {
	      set_execable_p ();
	      pc->set_exec ();
	      buf->st_mode |= STD_XBITS;
	    }
	  SetFilePointer (get_handle (), cur, NULL, FILE_BEGIN);
	}
@


1.33
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Always consider
.exe files and '#!' shell scripts to be executable.
@
text
@d304 2
d308 6
a313 8
    if (buf->st_mode & STD_XBITS)
      /* already derived */;
    else if (pc->exec_state () == is_executable)
      buf->st_mode |= STD_XBITS;
    else if (pc->exec_state () == dont_know_if_executable)
      {
	DWORD cur, done;
	char magic[3];
d315 19
a333 19
	/* First retrieve current position, set to beginning
	   of file if not already there. */
	cur = SetFilePointer (get_handle (), 0, NULL, FILE_CURRENT);
	if (cur != INVALID_SET_FILE_POINTER
	    && (!cur || SetFilePointer (get_handle (), 0, NULL, FILE_BEGIN)
		!= INVALID_SET_FILE_POINTER))
	  {
	    /* FIXME should we use /etc/magic ? */
	    magic[0] = magic[1] = magic[2] = '\0';
	    if (ReadFile (get_handle (), magic, 3, &done, NULL) &&
		has_exec_chars (magic, done))
	      {
		set_execable_p ();
		pc->set_exec ();
		buf->st_mode |= STD_XBITS;
	      }
	    SetFilePointer (get_handle (), cur, NULL, FILE_BEGIN);
	  }
      }
@


1.32
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@a302 26
	  if (pc->exec_state () == dont_know_if_executable)
	    {
	      DWORD cur, done;
	      char magic[3];

	      /* First retrieve current position, set to beginning
		 of file if not already there. */
	      cur = SetFilePointer (get_handle (), 0, NULL, FILE_CURRENT);
	      if (cur != INVALID_SET_FILE_POINTER &&
		  (!cur ||
		   SetFilePointer (get_handle (), 0, NULL, FILE_BEGIN)
		   != INVALID_SET_FILE_POINTER))
		{
		  /* FIXME should we use /etc/magic ? */
		  magic[0] = magic[1] = magic[2] = '\0';
		  if (ReadFile (get_handle (), magic, 3, &done, NULL) &&
		      has_exec_chars (magic, done))
		    {
		      set_execable_p ();
		      pc->set_exec ();
		    }
		  SetFilePointer (get_handle (), cur, NULL, FILE_BEGIN);
		}
	    }
	  if (pc->exec_state () == is_executable)
	    buf->st_mode |= STD_XBITS;
d305 29
@


1.31
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d310 1
a310 1
	      cur = SetFilePointer (get_handle(), 0, NULL, FILE_CURRENT);
d313 1
a313 1
		   SetFilePointer (get_handle(), 0, NULL, FILE_BEGIN)
d324 1
a324 1
		  SetFilePointer (get_handle(), cur, NULL, FILE_BEGIN);
d456 1
a456 1
	  if (GetFileInformationByHandle (get_handle(), &finfo) == 0)
@


1.30
log
@* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Incorporate .  and ..
processing here.
(fhandler_cygdrive::readdir): Assume .  and ..  are already in pdrive.
(fhandler_cygdrive::seekdir): Ditto.
@
text
@d159 6
a164 2
    return fstat_by_handle (buf, pc);

d173 1
a173 1
      && !strpbrk (get_win32_name (), "?*|<>|"))
d198 1
a198 1
  if (!oret)
d370 1
a370 9
  int res;
  if (!real_path->isdir () || wincap.can_open_directories ())
    res = this->fhandler_base::open (real_path, flags | O_DIROPEN, mode);
  else
    {
      set_errno (EISDIR);
      res = 0;
    }

d789 1
a789 1
      		  dir->__d_dirent->d_name);
@


1.29
log
@* path.cc (path_conv::check): Always set fileattr when component == 0.
(readlink): Use path_conv method rather than field.
* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Ditto, throughout.
* path.h (path_conv): Make fileattr private.
* exceptions.cc (try_to_debug): Default to idle priority when looping.
@
text
@d733 2
a734 1
  char *p = (char *) crealloc ((void *) win32_path_name, len);
d737 3
d777 2
a778 1
  if (dir->__d_position == 0)
d780 1
a780 11
      *dir->__d_dirent->d_name = '.';
      dir->__d_dirent->d_name[1] = '\0';
    }
  else if (dir->__d_position == 1)
    {
      dir->__d_dirent->d_name[0] = dir->__d_dirent->d_name[1] = '.';
      dir->__d_dirent->d_name[2] = '\0';
    }
  else if (GetFileAttributes (pdrive) == INVALID_FILE_ATTRIBUTES)
    {
      pdrive += DRVSZ;
d783 2
d791 1
a791 1
  pdrive += DRVSZ;
d809 2
a810 1
  for (pdrive = win32_path_name, dir->__d_position = -1; *pdrive; pdrive += DRVSZ)
@


1.28
log
@	* fhandler_disk_file.cc (fhandler_disk_file::open): Don't
	move the file pointer to the end of file if O_APPEND is
	specified in the open flags.
@
text
@d263 1
a263 1
  if (pc->fileattr & FILE_ATTRIBUTE_DIRECTORY)
d276 1
a276 1
      if ((pc->fileattr & FILE_ATTRIBUTE_READONLY) && !get_symlink_p ())
d286 1
a286 1
      if (!(pc->fileattr & FILE_ATTRIBUTE_READONLY))
@


1.27
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat_by_name): Force
FindFirstFile on first file of directory when asking for x:\ .
@
text
@a391 3
  if (flags & O_APPEND)
    SetFilePointer (get_handle(), 0, 0, FILE_END);

@


1.26
log
@* cygheap.cc (cygheap_user::set_name): Correct thinko in below change.
@
text
@d28 1
a110 6
  else if ((handle = FindFirstFile ((char *) pc, &local)) == INVALID_HANDLE_VALUE)
    {
      debug_printf ("FindFirstFile failed, %E");
      __seterrno ();
      res = -1;
    }
d113 31
a143 7
      FindClose (handle);
      res = fstat_helper (buf, pc,
			  local.ftCreationTime,
			  local.ftLastAccessTime,
			  local.ftLastWriteTime,
			  local.nFileSizeHigh,
			  local.nFileSizeLow);
@


1.25
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Correctly set
number of links for directory, if appropriate.
@
text
@d106 1
d110 1
a110 1
  else if ((handle = FindFirstFile (pc->get_win32 (), &local)) == INVALID_HANDLE_VALUE)
d112 1
@


1.24
log
@	* fhandler.cc (fhandler_base::fstat): Initialise tv_nsec member of
	st_atim, st_mtim, and st_ctim fields.
	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Ditto.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	* glob.c (stat32_to_STAT): Copy across the whole st_atim,
	st_mtime, and st_ctim fields.
	* syscalls.cc (stat64_to_stat32): Ditto.
	* times.cc (to_timestruc_t): New function.
	(time_as_timestruc_t): New function.
	* winsup.h: Add to_timestruc_t and time_as_timestruc_t functions.
	* include/cygwin/stat.h: Replace time_t with timestruc_t
	throughout for all file times, removing the st_spare1, st_spare2,
	and st_spare3 fields in the process. Add macros to access tv_sec
	fields by old names.
	* include/cygwin/types.h: Typedef timespec_t and timestruc_t as
	struct timespec.
@
text
@d206 8
a213 3
  buf->st_nlink   = nNumberOfLinks;
  buf->st_dev     = pc->volser ();
  buf->st_size    = ((__off64_t)nFileSizeHigh << 32) + nFileSizeLow;
a314 4
  /* Unfortunately the count of 2 confuses `find (1)' command. So
     let's try it with `1' as link count. */
  if (pc->isdir () && !buf->st_nlink)
    buf->st_nlink = pc->isremote () ? 1 : num_entries (pc->get_win32 ());
@


1.23
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d203 3
a205 3
  buf->st_atime   = to_time_t (&ftLastAccessTime);
  buf->st_mtime   = to_time_t (&ftLastWriteTime);
  buf->st_ctime   = to_time_t (&ftCreationTime);
@


1.22
log
@* fhandler.cc (fhandler_base::open): Don't set binmode if already set.  Don't
check for file.  Files should already be set.  Report on binary mode for
debugging.
(fhandler_base::fhandler_base): Don't set default binmode here.  That's for
later.
* fhandler_console.cc (fhandler_console::output_tcsetattr): Don't set binmode,
ever, for console.
* fhandler_disk_file.cc (fhandler_disk_file::open): Always set the binary mode
to the value derived from mount table.
* path.cc (mount_info::conv_to_win32_path): Default to binmode if path does not
translate into anything in the mount table.
@
text
@a11 1
#include <sys/fcntl.h>
a339 3

  set_r_binary (real_path->isbinary ());
  set_w_binary (real_path->isbinary ());
@


1.21
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat_by_name): Check specifically
for non-existent file, first.
(fhandler_disk_file::fstat): Perform fd open on files with funny characters.
@
text
@d342 2
a343 5
  if (real_path->isbinary ())
    {
      set_r_binary (1);
      set_w_binary (1);
    }
@


1.20
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d105 6
a110 1
  if ((handle = FindFirstFile (pc->get_win32 (), &local)) == INVALID_HANDLE_VALUE)
d148 2
a149 1
  if (query_open_already && strncasematch (pc->volname (), "FAT", 3))
@


1.19
log
@* fhandler_disk_file.cc (readdir): Move inode calculation into caller.
(fhandler_cygdrive::readdir): Add "." and "..".
* dir.cc (readdir): Move inode calculation here so that fhandler readdirs can
benefit.
@
text
@a26 1
#include "sigproc.h"
@


1.18
log
@* fhandler_console.cc (fhandler_console::open): Reinstate setting of flags.
@
text
@a658 31
  /* Compute d_ino by combining filename hash with the directory hash
     (which was stored in dir->__d_dirhash when opendir was called). */
  if (buf.cFileName[0] == '.')
    {
      if (buf.cFileName[1] == '\0')
	dir->__d_dirent->d_ino = dir->__d_dirhash;
      else if (buf.cFileName[1] != '.' || buf.cFileName[2] != '\0')
	goto hashit;
      else
	{
	  char *p, up[strlen (dir->__d_dirname) + 1];
	  strcpy (up, dir->__d_dirname);
	  if (!(p = strrchr (up, '\\')))
	    goto hashit;
	  *p = '\0';
	  if (!(p = strrchr (up, '\\')))
	    dir->__d_dirent->d_ino = hash_path_name (0, ".");
	  else
	    {
	      *p = '\0';
	      dir->__d_dirent->d_ino = hash_path_name (0, up);
	    }
	}
    }
  else
    {
  hashit:
      ino_t dino = hash_path_name (dir->__d_dirhash, "\\");
      dir->__d_dirent->d_ino = hash_path_name (dino, buf.cFileName);
    }

d756 11
a766 1
  if (GetFileAttributes (pdrive) == INVALID_FILE_ATTRIBUTES)
d771 5
a775 2
  *dir->__d_dirent->d_name = cyg_tolower (*pdrive);
  dir->__d_dirent->d_name[1] = '\0';
@


1.17
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat): Always call fstat_by_name
if fd is not opened to allow fstat_by_name to properly set errno.
* fhandler.cc (binmode): Default to binmode when mode is not known.
@
text
@d66 1
a66 1
  int res;
@


1.16
log
@	Change internal uid datatype from __uid16_t to __uid32_t
	throughout.
	* cygwin.din: Export new symbols getpwuid32, getpwuid_r32, getuid32,
	geteuid32, setuid32, seteuid32.
	* passwd.cc (getpwuid32): New function.
	(getpwuid_r32): Ditto.
	* syscalls.cc (seteuid32): Ditto.
	(setuid32): Ditto.
	* uinfo.cc (getuid32): Ditto.
	(geteuid32): Ditto.
	* winsup.h (uid16touid32): New macro, correclt casting from __uid16_t
	to __uid32_t.
	(gid16togid32): Ditto fir gids.
	(getuid32): Declare.
	(geteuid32): Ditto.
	(getpwuid32): Ditto.
	* include/sys/cygwin.h (struct external_pinfo): Add members uid32 and
	gid32.
@
text
@d169 3
a171 1
  if (oret)
a175 2
  else if (pc->exists ())
    res = fstat_by_name (buf, pc);
@


1.15
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Properly check for
whether we should be opening the file to search for #! characters.  Set
path_conv structure execability, too, if found.
@
text
@d129 1
a129 1
  __uid16_t uid;
d240 1
a240 1
  __uid16_t uid;
@


1.14
log
@	Change internal gid datatype from __gid16_t to __gid32_t
	throughout.
	* cygwin.din: Export new symbols chown32, fchown32, getegid32,
	getgid32, getgrgid32, getgrnam32, getgroups32, initgroups32, lchown32,
	setgid32, setegid32, getgrent32.
	* grp.cc (grp32togrp16): New static function.
	(getgrgid32): New function.
	(getgrnam32): Ditto.
	(getgrent32): Ditto.
	(getgroups32): Change name of internal function from getgroups.
	(getgroups32): New function.
	(initgroups32): Ditto.
	* syscalls.cc (chown32): Ditto.
	(lchown32): Ditto.
	(fchown32): Ditto.
	(setegid32): Ditto.
	(setgid32): Ditto.
	* uinfo.cc (getgid32): Ditto.
	(getegid32): Ditto.
	* include/cygwin/grp.h: Remove declaration of getgrgid() and getgrnam().
	Declare getgrgid32() and getgrnam32() instead.  Declare getgid32().
@
text
@d269 1
a269 1
	  if (!pc->exec_state () == dont_know_if_executable)
d286 1
d288 2
@


1.13
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat): Minor logic cleanup.
@
text
@d130 1
a130 1
  __gid16_t gid;
d241 1
a241 1
  __gid16_t gid;
@


1.12
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d146 1
a146 3
  else if ((oret = open (pc, open_flags, 0)))
    /* ok */;
  else
@


1.11
log
@* dtable.cc (dtable::build_fhandler_from_name): Just pass posix path along to
set_name via return_and_clear_normalized_path.
(dtable::build_fhandler): New method with const char * argument.
(dtable::reset_unix_path_name): Eliminate.
(dtable::dup_worker): Use correct build_fhandler method.
* mmap.cc (mmap_record::alloc_fh): Ditto.
* dtable.h (dtable::build_fhandler): New method.
(dtable::reset_unix_path_name): Eliminate.
* fhandler.cc (fhandler_base::set_name): Assume that unix_name has already been
cmalloced.
(fhandler_base::reset_unix_path_name): Eliminate.
(fhandler_base::~fhandler_base): Coercion for cfree.
* fhandler.h (fhandler_base::unix_path_name): Make const char *.
(fhandler_base::win32_path_name): Ditto.
(fhandler_base::reset_unix_path_name): Eliminate.
* fhandler_disk_file.cc (fhandler_cygdrive::set_drives): Accommodate const char
*ness of win32_path_name.
* fhandler_socket.cc (fhandler_socket::fstat): Accommodate new set_name
requirements.
* path.cc (path_conv::return_and_clear_normalized_path): New method.
(path_conv::clear_normalized_path): Eliminate.
(path_conv::~path_conv): Ditto.
(path_conv::check): Accommodate new build_fhandler method.
* path.h (path_conv::~path_conv): Eliminate.
(path_conv::clear_normalized_path): Ditto.
(path_conv::return_and_clear_normalized_path): Declare new method.
@
text
@d34 1
a34 1
static int
d63 62
a124 1
int
d132 1
d134 2
a135 2
  if (!pc)
    return fstat_helper (buf);
d137 10
a146 1
  if ((oret = open (pc, open_flags, 0)))
d153 2
a154 2
      set_query_open (TRUE);
      if ((oret = open (pc, open_flags, 0)))
d170 1
d173 1
a173 10
      res = fstat_helper (buf);
      /* The number of links to a directory includes the
	 number of subdirectories in the directory, since all
	 those subdirectories point to it.
	 This is too slow on remote drives, so we do without it and
	 set the number of links to 2. */
      /* Unfortunately the count of 2 confuses `find (1)' command. So
	 let's try it with `1' as link count. */
      if (pc->isdir ())
	buf->st_nlink = pc->isremote () ? 1 : num_entries (pc->get_win32 ());
d177 1
a177 54
    {
      /* Unfortunately, the above open may fail if the file exists, though.
	 So we have to care for this case here, too. */
      WIN32_FIND_DATA wfd;
      HANDLE handle;
      buf->st_nlink = 1;
      if (pc->isdir ())
	buf->st_nlink = pc->isremote () ? 1 : num_entries (pc->get_win32 ());
      buf->st_dev = FHDEVN (FH_DISK) << 8;
      buf->st_ino = hash_path_name (0, pc->get_win32 ());
      if (pc->isdir ())
	buf->st_mode = S_IFDIR;
      else if (pc->issymlink ())
	buf->st_mode = S_IFLNK;
      else if (pc->issocket ())
	buf->st_mode = S_IFSOCK;
      else
	buf->st_mode = S_IFREG;
      if (!pc->has_acls ()
	  || get_file_attribute (TRUE, pc->get_win32 (),
				 &buf->st_mode, &uid, &gid))
	{
	  buf->st_mode |= STD_RBITS | STD_XBITS;
	  if (!(pc->has_attribute (FILE_ATTRIBUTE_READONLY)))
	    buf->st_mode |= STD_WBITS;
	  if (pc->issymlink ())
	    buf->st_mode |= S_IRWXU | S_IRWXG | S_IRWXO;
	  get_file_attribute (FALSE, pc->get_win32 (), NULL, &uid, &gid);
	}
      buf->st_uid = uid;
      buf->st_gid = gid;
      if ((handle = FindFirstFile (pc->get_win32 (), &wfd))
	  != INVALID_HANDLE_VALUE)
	{
	  /* This is for FAT filesystems, which don't support atime/ctime */
	  if (wfd.ftLastAccessTime.dwLowDateTime == 0
	      && wfd.ftLastAccessTime.dwHighDateTime == 0)
	    wfd.ftLastAccessTime = wfd.ftLastWriteTime;
	  if (wfd.ftCreationTime.dwLowDateTime == 0
	      && wfd.ftCreationTime.dwHighDateTime == 0)
	    wfd.ftCreationTime = wfd.ftLastWriteTime;

	  buf->st_atime   = to_time_t (&wfd.ftLastAccessTime);
	  buf->st_mtime   = to_time_t (&wfd.ftLastWriteTime);
	  buf->st_ctime   = to_time_t (&wfd.ftCreationTime);
	  buf->st_size    = wfd.nFileSizeLow;
	  buf->st_size    = ((__off64_t)wfd.nFileSizeHigh << 32)
			    + wfd.nFileSizeLow;
	  buf->st_blksize = S_BLKSIZE;
	  buf->st_blocks  = (buf->st_size + S_BLKSIZE-1) / S_BLKSIZE;
	  FindClose (handle);
	}
      res = 0;
    }
d182 10
a191 2
int
fhandler_disk_file::fstat_helper (struct __stat64 *buf)
a192 43
  int res = 0;	// avoid a compiler warning
  BY_HANDLE_FILE_INFORMATION local;
  save_errno saved_errno;

  /* NT 3.51 seems to have a bug when attempting to get vol serial
     numbers.  This loop gets around this. */
  for (int i = 0; i < 2; i++)
    {
      if (!(res = GetFileInformationByHandle (get_handle (), &local)))
	break;
      if (local.dwVolumeSerialNumber && (long) local.dwVolumeSerialNumber != -1)
	break;
    }
  debug_printf ("%d = GetFileInformationByHandle (%s, %d)",
		res, get_win32_name (), get_handle ());
  if (res == 0)
    {
      /* GetFileInformationByHandle will fail if it's given stdin/out/err
	 or a pipe*/
      DWORD lsize, hsize;

      if (GetFileType (get_handle ()) != FILE_TYPE_DISK)
	buf->st_mode = S_IFCHR;

      lsize = GetFileSize (get_handle (), &hsize);
      if (lsize == 0xffffffff && GetLastError () != NO_ERROR)
	buf->st_mode = S_IFCHR;
      else
	buf->st_size = ((__off64_t)hsize << 32) + lsize;
      /* We expect these to fail! */
      buf->st_mode |= STD_RBITS | STD_WBITS;
      buf->st_blksize = S_BLKSIZE;
      buf->st_ino = get_namehash ();
      syscall_printf ("0 = fstat (, %p)",  buf);
      return 0;
    }

  if (!get_win32_name ())
    {
      saved_errno.set (ENOENT);
      return -1;
    }

d194 13
a206 19
  if (local.ftLastAccessTime.dwLowDateTime == 0
      && local.ftLastAccessTime.dwHighDateTime == 0)
    local.ftLastAccessTime = local.ftLastWriteTime;
  if (local.ftCreationTime.dwLowDateTime == 0
      && local.ftCreationTime.dwHighDateTime == 0)
    local.ftCreationTime = local.ftLastWriteTime;

  buf->st_atime   = to_time_t (&local.ftLastAccessTime);
  buf->st_mtime   = to_time_t (&local.ftLastWriteTime);
  buf->st_ctime   = to_time_t (&local.ftCreationTime);
  buf->st_nlink   = local.nNumberOfLinks;
  buf->st_dev     = local.dwVolumeSerialNumber;
  buf->st_size    = ((__off64_t)local.nFileSizeHigh << 32)
		    + local.nFileSizeLow;

  /* Allocate some place to determine the root directory. Need to allocate
     enough so that rootdir can add a trailing slash if path starts with \\. */
  char root[strlen (get_win32_name ()) + 3];
  strcpy (root, get_win32_name ());
d211 2
a212 1
  switch (has_acls () ? GetDriveType (rootdir (root)) : DRIVE_UNKNOWN)
d220 1
a220 1
      buf->st_ino = local.nFileIndexHigh | local.nFileIndexLow;
d230 1
a230 1
  buf->st_blocks  = (buf->st_size + S_BLKSIZE-1) / S_BLKSIZE;
d235 1
a235 1
  if (local.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
d237 1
a237 1
  else if (get_symlink_p ())
d239 1
a239 1
  else if (get_socket_p ())
d241 1
d244 1
a244 1
  if (get_file_attribute (has_acls (), get_win32_name (), &buf->st_mode,
d248 1
a248 2
      if ((local.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
	  && !get_symlink_p ())
d258 1
a258 1
      if (!(local.dwFileAttributes & FILE_ATTRIBUTE_READONLY))
d266 1
a266 1
      else if (get_socket_p ())
d269 26
a294 36
	switch (GetFileType (get_handle ()))
	  {
	  case FILE_TYPE_CHAR:
	  case FILE_TYPE_UNKNOWN:
	    buf->st_mode |= S_IFCHR;
	    break;
	  case FILE_TYPE_DISK:
	    buf->st_mode |= S_IFREG;
	    if (!dont_care_if_execable () && !get_execable_p ())
	      {
		DWORD cur, done;
		char magic[3];

		/* First retrieve current position, set to beginning
		   of file if not already there. */
		cur = SetFilePointer (get_handle(), 0, NULL, FILE_CURRENT);
		if (cur != INVALID_SET_FILE_POINTER &&
		    (!cur ||
		     SetFilePointer (get_handle(), 0, NULL, FILE_BEGIN)
		     != INVALID_SET_FILE_POINTER))
		  {
		    /* FIXME should we use /etc/magic ? */
		    magic[0] = magic[1] = magic[2] = '\0';
		    if (ReadFile (get_handle (), magic, 3, &done, NULL) &&
			has_exec_chars (magic, done))
			set_execable_p ();
		    SetFilePointer (get_handle(), cur, NULL, FILE_BEGIN);
		  }
	      }
	    if (get_execable_p ())
	      buf->st_mode |= STD_XBITS;
	    break;
	  case FILE_TYPE_PIPE:
	    buf->st_mode |= S_IFSOCK;
	    break;
	  }
d300 10
d311 2
a312 3
		 buf, buf->st_atime, buf->st_size, buf->st_mode,
		 (int) buf->st_ino, sizeof (*buf));

d363 1
a363 2
  if (real_path->has_buggy_open ()
      && GetFileAttributes (win32_path_name) == INVALID_FILE_ATTRIBUTES)
@


1.10
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat): Make handling of nlink
consistent for remote files.
@
text
@d778 1
a778 1
  win32_path_name = (char *) crealloc (win32_path_name, len);
d780 2
a781 2
  ndrives = GetLogicalDriveStrings (len, win32_path_name) / DRVSZ;
  pdrive = win32_path_name;
@


1.9
log
@* fhandler_disk_file.cc (fhandler_disk_file::open): Avoid using O_DIROPEN when
OS doesn't support it.  Return proper errno in that case.
@
text
@d110 1
a110 2
	buf->st_nlink = (pc->isremote ()
			 ? 1 : num_entries (pc->get_win32 ()));
d120 2
a121 2
      if (pc->isdir () && pc->isremote ())
	buf->st_nlink = num_entries (pc->get_win32 ());
@


1.8
log
@* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Always set
st_[ug]id to value derived from get_file_attributes.
@
text
@d377 8
a384 4
  if (real_path->isdir ())
    flags |= O_DIROPEN;

  int res = this->fhandler_base::open (real_path, flags, mode);
@


1.7
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@a283 3

      buf->st_uid = uid;
      buf->st_gid = gid;
d337 3
@


1.6
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d64 1
a64 1
fhandler_disk_file::fstat (struct stat *buf, path_conv *pc)
d135 1
a135 2
				 &buf->st_mode,
				 &buf->st_uid, &buf->st_gid))
d142 1
a142 2
	  get_file_attribute (FALSE, pc->get_win32 (),
			      NULL, &buf->st_uid, &buf->st_gid);
d144 2
d161 2
d164 1
a164 2
	  buf->st_blocks  = ((unsigned long) buf->st_size +
			    S_BLKSIZE-1) / S_BLKSIZE;
d174 1
a174 1
fhandler_disk_file::fstat_helper (struct stat *buf)
d204 1
a204 1
	buf->st_size = lsize;
d232 2
a233 1
  buf->st_size    = local.nFileSizeLow;
d261 1
a261 1
  buf->st_blocks  = ((unsigned long) buf->st_size + S_BLKSIZE-1) / S_BLKSIZE;
d272 2
d275 1
a275 1
			  &buf->st_uid, &buf->st_gid) == 0)
d284 3
d341 1
a341 1
  syscall_printf ("0 = fstat (, %p) st_atime=%x st_size=%d, st_mode=%p, st_ino=%d, sizeof=%d",
d439 1
a439 1
  int win32_start;
d442 1
a442 1
  DWORD startpos;
d465 1
a465 1
	if ((__off32_t) (startpos = lseek (0, SEEK_CUR)) == ILLEGAL_SEEK)
d476 2
a477 1
	  startpos = finfo.nFileSizeLow; /* Nowhere to keep high word */
d725 1
a725 1
__off32_t
d732 1
a732 1
fhandler_disk_file::seekdir (DIR *dir, __off32_t loc)
d782 1
a782 1
fhandler_cygdrive::fstat (struct stat *buf, path_conv *pc)
d829 1
a829 1
__off32_t
d836 1
a836 1
fhandler_cygdrive::seekdir (DIR *dir, __off32_t loc)
@


1.5
log
@	* dir.cc: Use INVALID_FILE_ATTRIBUTES instead of "(DWORD) -1"
	for file attributes throughout.
	* fhandler.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* syscalls.cc: Ditto.
	* times.cc (utimes): Use path_conv::isdir() instead of explicit
	GetFileAttributes() call.
@
text
@d68 2
a69 2
  uid_t uid;
  gid_t gid;
d458 1
a458 1
	if ((off_t) (startpos = lseek (0, SEEK_CUR)) == (off_t)-1)
d717 1
a717 1
off_t
d724 1
a724 1
fhandler_disk_file::seekdir (DIR *dir, off_t loc)
d821 1
a821 1
off_t
d828 1
a828 1
fhandler_cygdrive::seekdir (DIR *dir, off_t loc)
@


1.4
log
@* fhandler_disk_file.cc (fhandler_cygdrive::readdir): Avoid reporting
inaccessible drives.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
d385 1
a385 1
      && GetFileAttributes (win32_path_name) == (DWORD) -1)
d807 1
a807 1
  if (GetFileAttributes (pdrive) == (DWORD) -1)
@


1.4.16.1
log
@Merged changes from HEAD
@
text
@@


1.4.16.2
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d385 1
a385 1
      && GetFileAttributes (win32_path_name) == INVALID_FILE_ATTRIBUTES)
d807 1
a807 1
  if (GetFileAttributes (pdrive) == INVALID_FILE_ATTRIBUTES)
@


1.4.16.3
log
@Merged changes from HEAD
@
text
@d64 1
a64 1
fhandler_disk_file::fstat (struct __stat64 *buf, path_conv *pc)
d68 2
a69 2
  __uid16_t uid;
  __gid16_t gid;
d135 2
a136 1
				 &buf->st_mode, &uid, &gid))
d143 2
a144 1
	  get_file_attribute (FALSE, pc->get_win32 (), NULL, &uid, &gid);
a145 2
      buf->st_uid = uid;
      buf->st_gid = gid;
a160 2
	  buf->st_size    = ((__off64_t)wfd.nFileSizeHigh << 32)
			    + wfd.nFileSizeLow;
d162 2
a163 1
	  buf->st_blocks  = (buf->st_size + S_BLKSIZE-1) / S_BLKSIZE;
d173 1
a173 1
fhandler_disk_file::fstat_helper (struct __stat64 *buf)
d203 1
a203 1
	buf->st_size = ((__off64_t)hsize << 32) + lsize;
d231 1
a231 2
  buf->st_size    = ((__off64_t)local.nFileSizeHigh << 32)
		    + local.nFileSizeLow;
d259 1
a259 1
  buf->st_blocks  = (buf->st_size + S_BLKSIZE-1) / S_BLKSIZE;
a269 2
  __uid16_t uid;
  __gid16_t gid;
d271 1
a271 1
			  &uid, &gid) == 0)
a279 3

      buf->st_uid = uid;
      buf->st_gid = gid;
d334 1
a334 1
  syscall_printf ("0 = fstat (, %p) st_atime=%x st_size=%D, st_mode=%p, st_ino=%d, sizeof=%d",
d432 1
a432 1
  __off64_t win32_start;
d435 1
a435 1
  __off64_t startpos;
d458 1
a458 1
	if ((startpos = lseek (0, SEEK_CUR)) == ILLEGAL_SEEK)
d469 1
a469 2
	  startpos = ((__off64_t)finfo.nFileSizeHigh << 32)
		     + finfo.nFileSizeLow;
d717 1
a717 1
__off64_t
d724 1
a724 1
fhandler_disk_file::seekdir (DIR *dir, __off64_t loc)
d774 1
a774 1
fhandler_cygdrive::fstat (struct __stat64 *buf, path_conv *pc)
d821 1
a821 1
__off64_t
d828 1
a828 1
fhandler_cygdrive::seekdir (DIR *dir, __off64_t loc)
@


1.4.16.4
log
@Merged changes from HEAD
@
text
@d12 1
d27 1
d34 1
a34 1
static int __stdcall
d63 1
a63 67
int __stdcall
fhandler_disk_file::fstat_by_handle (struct __stat64 *buf, path_conv *pc)
{
  int res = 0;
  BY_HANDLE_FILE_INFORMATION local;

  /* NT 3.51 seems to have a bug when attempting to get vol serial
     numbers.  This loop gets around this. */
  for (int i = 0; i < 2; i++)
    {
      if (!(res = GetFileInformationByHandle (get_handle (), &local)))
	break;
      if (local.dwVolumeSerialNumber && (long) local.dwVolumeSerialNumber != -1)
	break;
    }
  debug_printf ("%d = GetFileInformationByHandle (%s, %d)",
		res, get_win32_name (), get_handle ());
  if (res == 0)
    /* GetFileInformationByHandle will fail if it's given stdin/out/err
       or a pipe*/
    {
      memset (&local, 0, sizeof (local));
      local.nFileSizeLow = GetFileSize (get_handle (), &local.nFileSizeHigh);
    }

  return fstat_helper (buf, pc,
		       local.ftCreationTime,
		       local.ftLastAccessTime,
		       local.ftLastWriteTime,
		       local.nFileSizeHigh,
		       local.nFileSizeLow,
		       local.nFileIndexHigh,
		       local.nFileIndexLow,
		       local.nNumberOfLinks);
}

int __stdcall
fhandler_disk_file::fstat_by_name (struct __stat64 *buf, path_conv *pc)
{
  int res;
  HANDLE handle;
  WIN32_FIND_DATA local;

  if (!pc->exists ())
    {
      set_errno (ENOENT);
      res = -1;
    }
  else if ((handle = FindFirstFile (pc->get_win32 (), &local)) == INVALID_HANDLE_VALUE)
    {
      __seterrno ();
      res = -1;
    }
  else
    {
      FindClose (handle);
      res = fstat_helper (buf, pc,
			  local.ftCreationTime,
			  local.ftLastAccessTime,
			  local.ftLastWriteTime,
			  local.nFileSizeHigh,
			  local.nFileSizeLow);
    }
  return res;
}

int __stdcall
d68 2
a69 2
  __uid32_t uid;
  __gid32_t gid;
a70 1
  bool query_open_already;
d72 2
a73 2
  if (get_io_handle ())
    return fstat_by_handle (buf, pc);
d75 2
a76 4
  /* If we don't care if the file is executable or we already know if it is,
     then just do a "query open" as it is apparently much faster. */
  if (pc->exec_state () != dont_know_if_executable)
    set_query_open (query_open_already = true);
a77 6
    query_open_already = false;

  if (query_open_already && strncasematch (pc->volname (), "FAT", 3)
      && !strpbrk (get_win32_name (), "?*|<>|"))
    oret = 0;
  else if (!(oret = open (pc, open_flags, 0)))
d82 2
a83 2
      set_query_open (true);
      if (!query_open_already && (oret = open (pc, open_flags, 0)))
d99 1
a99 4

  if (!oret)
    res = fstat_by_name (buf, pc);
  else
d101 11
a111 1
      res = fstat_by_handle (buf, pc);
d114 55
d173 2
a174 10
int __stdcall
fhandler_disk_file::fstat_helper (struct __stat64 *buf, path_conv *pc,
				  FILETIME ftCreationTime,
				  FILETIME ftLastAccessTime,
				  FILETIME ftLastWriteTime,
				  DWORD nFileSizeHigh,
				  DWORD nFileSizeLow,
				  DWORD nFileIndexHigh,
				  DWORD nFileIndexLow,
				  DWORD nNumberOfLinks)
d176 43
d220 19
a238 18
  if (ftLastAccessTime.dwLowDateTime == 0
      && ftLastAccessTime.dwHighDateTime == 0)
    ftLastAccessTime = ftLastWriteTime;
  if (ftCreationTime.dwLowDateTime == 0
      && ftCreationTime.dwHighDateTime == 0)
    ftCreationTime = ftLastWriteTime;

  to_timestruc_t (&ftLastAccessTime, &buf->st_atim);
  to_timestruc_t (&ftLastWriteTime, &buf->st_mtim);
  to_timestruc_t (&ftCreationTime, &buf->st_ctim);
  buf->st_dev = pc->volser ();
  buf->st_size = ((__off64_t)nFileSizeHigh << 32) + nFileSizeLow;
  /* Unfortunately the count of 2 confuses `find (1)' command. So
     let's try it with `1' as link count. */
  if (pc->isdir () && !pc->isremote () && nNumberOfLinks == 1)
    buf->st_nlink = num_entries (pc->get_win32 ());
  else
    buf->st_nlink = nNumberOfLinks;
d243 1
a243 2
  switch (pc->has_acls () && (nFileIndexHigh || nFileIndexLow)
	  ? pc->drive_type () : DRIVE_UNKNOWN)
d251 1
a251 1
      buf->st_ino = nFileIndexHigh | nFileIndexLow;
d261 1
a261 1
  buf->st_blocks  = (buf->st_size + S_BLKSIZE - 1) / S_BLKSIZE;
d266 1
a266 1
  if (pc->fileattr & FILE_ATTRIBUTE_DIRECTORY)
d268 1
a268 1
  else if (pc->issymlink ())
d270 1
a270 1
  else if (pc->issocket ())
d272 3
a274 4

  __uid32_t uid;
  __gid32_t gid;
  if (get_file_attribute (pc->has_acls (), get_win32_name (), &buf->st_mode,
d278 2
a279 1
      if ((pc->fileattr & FILE_ATTRIBUTE_READONLY) && !get_symlink_p ())
d284 3
d292 1
a292 1
      if (!(pc->fileattr & FILE_ATTRIBUTE_READONLY))
d300 1
a300 1
      else if (pc->issocket ())
d303 36
a338 29
	{
	  buf->st_mode |= S_IFREG;
	  if (pc->exec_state () == dont_know_if_executable)
	    {
	      DWORD cur, done;
	      char magic[3];

	      /* First retrieve current position, set to beginning
		 of file if not already there. */
	      cur = SetFilePointer (get_handle(), 0, NULL, FILE_CURRENT);
	      if (cur != INVALID_SET_FILE_POINTER &&
		  (!cur ||
		   SetFilePointer (get_handle(), 0, NULL, FILE_BEGIN)
		   != INVALID_SET_FILE_POINTER))
		{
		  /* FIXME should we use /etc/magic ? */
		  magic[0] = magic[1] = magic[2] = '\0';
		  if (ReadFile (get_handle (), magic, 3, &done, NULL) &&
		      has_exec_chars (magic, done))
		    {
		      set_execable_p ();
		      pc->set_exec ();
		    }
		  SetFilePointer (get_handle(), cur, NULL, FILE_BEGIN);
		}
	    }
	  if (pc->exec_state () == is_executable)
	    buf->st_mode |= STD_XBITS;
	}
d341 3
a343 8
  buf->st_uid = uid;
  buf->st_gid = gid;

  /* The number of links to a directory includes the
     number of subdirectories in the directory, since all
     those subdirectories point to it.
     This is too slow on remote drives, so we do without it and
     set the number of links to 2. */
a344 3
  syscall_printf ("0 = fstat (, %p) st_atime=%x st_size=%D, st_mode=%p, st_ino=%d, sizeof=%d",
		  buf, buf->st_atime, buf->st_size, buf->st_mode,
		  (int) buf->st_ino, sizeof (*buf));
d368 6
d377 4
a380 8
  int res;
  if (!real_path->isdir () || wincap.can_open_directories ())
    res = this->fhandler_base::open (real_path, flags | O_DIROPEN, mode);
  else
    {
      set_errno (EISDIR);
      res = 0;
    }
d391 2
a392 1
  if (real_path->has_buggy_open () && !real_path->exists ())
d687 31
d775 1
a775 1
  char *p = (char *) crealloc ((void *) win32_path_name, len);
d777 2
a778 2
  win32_path_name = pdrive = p;
  ndrives = GetLogicalDriveStrings (len, p) / DRVSZ;
d815 1
a815 11
  if (dir->__d_position == 0)
    {
      *dir->__d_dirent->d_name = '.';
      dir->__d_dirent->d_name[1] = '\0';
    }
  else if (dir->__d_position == 1)
    {
      dir->__d_dirent->d_name[0] = dir->__d_dirent->d_name[1] = '.';
      dir->__d_dirent->d_name[2] = '\0';
    }
  else if (GetFileAttributes (pdrive) == INVALID_FILE_ATTRIBUTES)
d820 2
a821 5
  else
    {
      *dir->__d_dirent->d_name = cyg_tolower (*pdrive);
      dir->__d_dirent->d_name[1] = '\0';
    }
@


1.4.16.5
log
@Merged changes from HEAD
@
text
@a27 1
#include <ctype.h>
a105 1
      debug_printf ("already determined that pc does not exist");
d109 5
d116 7
a122 31
      char drivebuf[5];
      char *name;
      if ((*pc)[3] != '\0' || !isalpha ((*pc)[0]) || (*pc)[1] != ':' || (*pc)[2] != '\\')
	name = *pc;
      else
	{
	  /* FIXME: Does this work on empty disks? */
	  drivebuf[0] = (*pc)[0];
	  drivebuf[1] = (*pc)[1];
	  drivebuf[2] = (*pc)[2];
	  drivebuf[3] = '*';
	  drivebuf[4] = '\0';
	  name = drivebuf;
	}

      if ((handle = FindFirstFile (name, &local)) == INVALID_HANDLE_VALUE)
      {
	debug_printf ("FindFirstFile failed for '%s', %E", name);
	__seterrno ();
	res = -1;
      }
    else
      {
	FindClose (handle);
	res = fstat_helper (buf, pc,
			    local.ftCreationTime,
			    local.ftLastAccessTime,
			    local.ftLastWriteTime,
			    local.nFileSizeHigh,
			    local.nFileSizeLow);
      }
@


1.4.16.6
log
@Merged changes from HEAD
@
text
@d392 3
@


1.4.16.7
log
@Merged changes from HEAD
@
text
@d263 1
a263 1
  if (pc->isdir ())
d276 1
a276 1
      if (pc->has_attribute (FILE_ATTRIBUTE_READONLY) && !get_symlink_p ())
d286 1
a286 1
      if (!pc->has_attribute (FILE_ATTRIBUTE_READONLY))
@


1.4.16.8
log
@Merged changes from HEAD
@
text
@d733 1
a733 2
  char *p = (char *) crealloc ((void *) win32_path_name,
				sizeof (".") + sizeof ("..") + len);
a735 3
  strcpy (p, ".");
  strcpy (p + sizeof ("."), "..");
  p += sizeof (".") + sizeof ("..");
d773 1
a773 2
  else if (dir->__d_position > 1
	   && GetFileAttributes (pdrive) == INVALID_FILE_ATTRIBUTES)
d775 11
a785 1
      pdrive = strchr (pdrive, '\0') + 1;
a787 2
  else if (*pdrive == '.')
    strcpy (dir->__d_dirent->d_name, pdrive);
d794 1
a794 1
  pdrive = strchr (pdrive, '\0') + 1;
d812 1
a812 2
  for (pdrive = win32_path_name, dir->__d_position = -1; *pdrive;
       pdrive = strchr (pdrive, '\0') + 1)
@


1.4.16.9
log
@Merged changes from HEAD
@
text
@d159 2
a160 6
    {
      if (get_nohandle ())
	return fstat_by_name (buf, pc);
      else
	return fstat_by_handle (buf, pc);
    }
d169 1
a169 1
      && !strpbrk (get_win32_name (), "?*|<>"))
d194 1
a194 1
  if (!oret || get_nohandle ())
d366 9
a374 1
  int res = this->fhandler_base::open (real_path, flags | O_DIROPEN, mode);
d793 1
a793 1
		  dir->__d_dirent->d_name);
@


1.4.16.10
log
@Merged changes from HEAD
@
text
@d310 1
a310 1
	      cur = SetFilePointer (get_handle (), 0, NULL, FILE_CURRENT);
d313 1
a313 1
		   SetFilePointer (get_handle (), 0, NULL, FILE_BEGIN)
d324 1
a324 1
		  SetFilePointer (get_handle (), cur, NULL, FILE_BEGIN);
d456 1
a456 1
	  if (GetFileInformationByHandle (get_handle (), &finfo) == 0)
@


1.3
log
@* dtable.cc (dtable::vfork_parent_restore): Add debugging statement.
* exceptions.cc (try_to_debug): Spin only as long as we don't have a debugger
attached.
* fhandler.h (fhandler_base::set_nohandle): New method.
(fhandler_base::get_nohandle): New method.
* fhandler.cc (fhandler_base::dup): Avoid duplicating handle if there is no
handle.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set nohandle flag on
dummy fd.
* Makefile.in: Make intermediate library for eventual inclusion in libcygwin.a
* fhandler.h (fhandler_pipe::fhandler_pipe): Remove default argument setting
since it is no longer used.
* miscfuncs.cc (check_null_str): New function.
(+check_null_str_errno): Ditto.
* net.cc: Add defensive buffer checking throughout.
(cygwin_sendto): Protect against invalid fd.
(cygwin_recvfrom): Ditto.
(cygwin_getpeername): Ditto.
(cygwin_recv): Ditto.
(cygwin_send): Ditto.
* winsup.h: Declare a new function.
* select.cc (set_bits): Fix conditional for setting fd in exceptfds.
* dtable.cc (dtable::build_fhandler): Create fhandler_pipe using correct device
type.
* path.cc (get_devn): Set correct pipe device type from device name.
@
text
@d807 5
@


1.2
log
@* path.cc (conv_path_list): Fix wild indexing into path due to conflicting
methods for setting src pointer.
* dir.cc (opendir): Only pass path_conv argument to opendir, since name is
already part of the fhandler.
* dtable.cc (dtable::build_fhandler): Accomodate new FH_CYGDRIVE type.
* fhandler.cc (fhandler_base::opendir): Nuke name argument.
* fhandler.h: Add FH_CYGDRIVE to "device" enum.
(fhandler_base::opendir): Nuke name argument.
(fhandler_disk_file::opendir): Ditto.
(fhandler_disk_file::fhandler_disk_file): Declare new method which passes
devtype through.
(fhandler_cygdrive): Add elements for tracking drives.
(fhandler_cygdrive::set_drives): Declare new method.
(fhandler_cygdrive::iscygdrive_root): Declare new method.
(fhandler_cygdrive::opendir): Declare new method.
(fhandler_cygdrive::readdir): Declare new method.
(fhandler_cygdrive::telldir): Declare new method.
(fhandler_cygdrive::seekdir): Declare new method.
(fhandler_cygdrive::rewinddir): Declare new method.
(fhandler_cygdrive::closedir): Declare new method.
(fhandler_cygdrive::fstat): Declare new method.
* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file): Define new
method which passes devtype through.
(fhandler_disk_file::open): Tweak debug output.
(fhandler_disk_file::opendir): Nuke first argument.  Use info from path_conv
and class rather than calling fstat.
(fhandler_cygdrive::set_drives): New method.
(fhandler_cygdrive::iscygdrive_root): New method.
(fhandler_cygdrive::opendir): New method.
(fhandler_cygdrive::readdir): New method.
(fhandler_cygdrive::telldir): New method.
(fhandler_cygdrive::seekdir): New method.
(fhandler_cygdrive::rewinddir): New method.
(fhandler_cygdrive::closedir): New method.
(fhandler_cygdrive::fstat): New method.
* path.cc (iscygdrive_device): Assume cygdriveness is already verified.
(path_conv::check): Treat FH_CYGDRIVE "method" as a special case, setting file
attributes as needed.
(mount_info::conv_to_win32_path): Allow stand-alone /cygdrive, meaning "the
directory which contains all of the drives on the system".
(fillout_mntent): Use cyg_tolower for conversions.
(mount_info::cygdrive_win32_path): Replace unused argument with unit number.
* shared_info.h (mount_info::cygdrive_win32_path): Reflect argument change.
@
text
@d602 1
@


1.1
log
@* Makefile.in (DLL_OFILES): Add fhandler_disk_file.o.
* cygheap.h (cygheap_fdnew::operator =): New operator.
* dir.cc: Add invalid struct checking throughout.  Use methods for all
directory manipulation throughout.
* fhandler.cc: Move fhandler_disk_file stuff to own file.
(fhandler_base::opendir): New method.
(fhandler_base::readdir): New method.
(fhandler_base::telldir): New method.
(fhandler_base::seekdir): New method.
(fhandler_base::rewinddir): New method.
(fhandler_base::closedir): New method.
* fhandler_disk_file.cc: New file.
* fhandler.h (fhandler_base): Declare new virtual methods.
(fhandler_disk_file): Ditto.
(fhandler_cygdrive): New class.
* path.cc (conv_path_list): Use strccpy to break apart path.
@
text
@d341 5
d347 1
a347 1
	fhandler_base (FH_DISK)
d356 1
a356 1
      debug_printf ("Caseclash detected.");
d572 1
a572 1
fhandler_disk_file::opendir (const char *name, path_conv& real_name)
a573 1
  struct stat statbuf;
d578 1
a578 1
  if (fstat (&statbuf, &real_name) ||!(statbuf.st_mode & S_IFDIR))
d613 1
a613 1
      dir->__d_dirhash = statbuf.st_ino;
d618 1
a618 1
  syscall_printf ("%p = opendir (%s)", res, name);
d709 1
a709 1
  ++dir->__d_position;
d727 1
a727 1
      if (! readdir (dir))
d754 97
@

