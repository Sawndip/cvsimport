head	1.298;
access;
symbols
	cygwin-1_7_35-release:1.298
	cygwin-1_7_34-release:1.296
	cygwin-1_7_33-release:1.287.2.4
	cygwin-1_7_32-release:1.287.2.3
	cygwin-1_7_31-release:1.287.2.3
	cygwin-1_7_30-release:1.287
	cygwin-1_7_29-release:1.287
	cygwin-1_7_29-release-branchpoint:1.287.0.2
	cygwin-pre-user-db:1.287
	cygwin-1_7_28-release:1.287
	cygwin-1_7_27-release:1.287
	cygwin-1_7_26-release:1.286
	cygwin-1_7_25-release:1.285
	cygwin-1_7_24-release:1.285
	cygwin-1_7_23-release:1.285
	cygwin-1_7_22-release:1.284
	cygwin-1_7_21-release:1.284
	cygwin-1_7_20-release:1.283
	cygwin-1_7_19-release:1.283
	cygwin-64bit-postmerge:1.282
	cygwin-64bit-premerge-branch:1.281.0.2
	cygwin-64bit-premerge:1.281
	cygwin-1_7_18-release:1.281
	post-ptmalloc3:1.270.2.9
	pre-ptmalloc3:1.270.2.9
	cygwin-1_7_17-release:1.273
	cygwin-64bit-branch:1.270.0.2
	cygwin-1_7_16-release:1.269
	cygwin-1_7_15-release:1.257
	cygwin-1_7_14_2-release:1.257
	cygwin-1_7_14-release:1.257
	cygwin-1_7_12-release:1.257
	cygwin-1_7_11-release:1.256
	cygwin-1_7_10-release:1.253
	signal-rewrite:1.246.0.2
	pre-notty:1.243
	cygwin-1_7_9-release:1.226
	cv-post-1_7_9:1.225.0.2
	cygwin-1_7_8-release:1.225
	cygwin-1_7_7-release:1.225
	cygwin-1_7_5-release:1.225
	cygwin-1_7_4-release:1.225
	cygwin-1_7_3-release:1.224
	cygwin-1_7_2-release:1.224
	fifo_doover3:1.217.0.2
	cygwin-1_7_1-release:1.216
	prefifo:1.216
	cv-branch-2:1.216.0.2
	pre-ripout-set_console_state_for_spawn:1.211
	EOL_registry_mounts:1.208
	preoverlapped:1.202
	drop_9x_support_start:1.200
	cr-0x5f1:1.199.0.4
	cv-branch:1.199.0.2
	pre-ptymaster-archetype:1.199
	cr-0x3b58:1.195.0.4
	cr-0x5ef:1.195.0.2
	after-mmap-privanon-noreserve:1.194
	after-mmap-revamp:1.194
	before-mmap-revamp:1.194
	cgf-more-exit-sync:1.194
	post_wait_sig_exit:1.194
	pre_wait_sig_exit:1.194
	reparent-point:1.175
	noreparent:1.175.0.2
	cr-0x5e6:1.171.0.2
	cr-0x9e:1.157.0.4
	cr-0x9d:1.157.0.2
	cgf-deleteme:1.156.0.2
	pre-sigrewrite:1.147
	corinna-01:1.140
	cr-0x9c:1.132.2.1.0.2
	cr-0x9b:1.132.0.2
	cr-0x99:1.131
	Z-emcb-cygwin_daemon:1.131.0.2
	w32api-2_2:1.114
	mingw-runtime-2_4:1.114
	pre-cgf-merge:1.133
	cgf-dev-branch:1.114.0.2
	predaemon:1.65
	cygwin_daemon_merge_HEAD:1.64
	pregp02r1:1.64.0.8
	cygnus_cvs_20020108_pre:1.64
	Z-cygwin_daemon_merge-new_HEAD:1.87
	Z-cygwin_daemon_merge_HEAD:1.87
	cygwin_daemon:1.49.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.298
date	2015.02.25.17.50.13;	author corinna;	state Exp;
branches;
next	1.297;

1.297
date	2015.02.23.13.56.01;	author corinna;	state Exp;
branches;
next	1.296;

1.296
date	2014.11.28.20.46.13;	author corinna;	state Exp;
branches;
next	1.295;

1.295
date	2014.11.28.12.10.12;	author corinna;	state Exp;
branches;
next	1.294;

1.294
date	2014.08.25.14.53.49;	author corinna;	state Exp;
branches;
next	1.293;

1.293
date	2014.08.22.09.21.32;	author corinna;	state Exp;
branches;
next	1.292;

1.292
date	2014.07.21.16.32.09;	author corinna;	state Exp;
branches;
next	1.291;

1.291
date	2014.07.16.10.21.18;	author corinna;	state Exp;
branches;
next	1.290;

1.290
date	2014.07.14.09.42.15;	author corinna;	state Exp;
branches;
next	1.289;

1.289
date	2014.07.09.12.06.08;	author corinna;	state Exp;
branches;
next	1.288;

1.288
date	2014.06.23.19.05.15;	author corinna;	state Exp;
branches;
next	1.287;

1.287
date	2013.12.01.10.27.16;	author corinna;	state Exp;
branches
	1.287.2.1;
next	1.286;

1.286
date	2013.09.25.14.44.45;	author cgf;	state Exp;
branches;
next	1.285;

1.285
date	2013.07.23.14.15.20;	author corinna;	state Exp;
branches;
next	1.284;

1.284
date	2013.07.10.20.58.33;	author cgf;	state Exp;
branches;
next	1.283;

1.283
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.282;

1.282
date	2013.04.23.09.44.34;	author corinna;	state Exp;
branches;
next	1.281;

1.281
date	2013.04.07.23.53.00;	author cgf;	state Exp;
branches;
next	1.280;

1.280
date	2013.03.31.12.35.44;	author cgf;	state Exp;
branches;
next	1.279;

1.279
date	2013.01.21.04.38.29;	author cgf;	state Exp;
branches;
next	1.278;

1.278
date	2013.01.07.19.34.44;	author cgf;	state Exp;
branches;
next	1.277;

1.277
date	2013.01.07.16.01.10;	author cgf;	state Exp;
branches;
next	1.276;

1.276
date	2012.12.22.19.35.40;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2012.12.21.19.32.43;	author cgf;	state Exp;
branches;
next	1.274;

1.274
date	2012.12.21.18.52.00;	author cgf;	state Exp;
branches;
next	1.273;

1.273
date	2012.08.16.23.34.45;	author cgf;	state Exp;
branches;
next	1.272;

1.272
date	2012.08.15.19.07.42;	author cgf;	state Exp;
branches;
next	1.271;

1.271
date	2012.08.14.15.05.13;	author corinna;	state Exp;
branches;
next	1.270;

1.270
date	2012.07.21.22.58.20;	author cgf;	state Exp;
branches
	1.270.2.1;
next	1.269;

1.269
date	2012.06.19.00.52.59;	author cgf;	state Exp;
branches;
next	1.268;

1.268
date	2012.06.17.20.50.24;	author cgf;	state Exp;
branches;
next	1.267;

1.267
date	2012.05.30.09.15.38;	author corinna;	state Exp;
branches;
next	1.266;

1.266
date	2012.05.24.14.17.51;	author corinna;	state Exp;
branches;
next	1.265;

1.265
date	2012.05.23.19.49.39;	author corinna;	state Exp;
branches;
next	1.264;

1.264
date	2012.05.23.17.39.39;	author corinna;	state Exp;
branches;
next	1.263;

1.263
date	2012.05.23.16.26.34;	author corinna;	state Exp;
branches;
next	1.262;

1.262
date	2012.05.23.13.30.26;	author corinna;	state Exp;
branches;
next	1.261;

1.261
date	2012.05.23.13.24.57;	author corinna;	state Exp;
branches;
next	1.260;

1.260
date	2012.05.23.13.18.34;	author corinna;	state Exp;
branches;
next	1.259;

1.259
date	2012.05.22.10.28.05;	author corinna;	state Exp;
branches;
next	1.258;

1.258
date	2012.05.12.20.26.43;	author cgf;	state Exp;
branches;
next	1.257;

1.257
date	2012.03.19.17.34.23;	author corinna;	state Exp;
branches;
next	1.256;

1.256
date	2012.02.14.09.45.21;	author corinna;	state Exp;
branches;
next	1.255;

1.255
date	2012.02.11.17.37.02;	author corinna;	state Exp;
branches;
next	1.254;

1.254
date	2012.02.08.19.58.37;	author corinna;	state Exp;
branches;
next	1.253;

1.253
date	2012.01.11.19.07.10;	author cgf;	state Exp;
branches;
next	1.252;

1.252
date	2012.01.06.07.12.17;	author yselkowitz;	state Exp;
branches;
next	1.251;

1.251
date	2011.12.30.06.47.13;	author yselkowitz;	state Exp;
branches;
next	1.250;

1.250
date	2011.12.22.11.02.36;	author corinna;	state Exp;
branches;
next	1.249;

1.249
date	2011.12.13.20.06.31;	author cgf;	state Exp;
branches;
next	1.248;

1.248
date	2011.08.24.15.18.17;	author corinna;	state Exp;
branches;
next	1.247;

1.247
date	2011.08.24.14.23.38;	author cgf;	state Exp;
branches;
next	1.246;

1.246
date	2011.08.03.19.17.02;	author yselkowitz;	state Exp;
branches;
next	1.245;

1.245
date	2011.08.03.16.40.47;	author yselkowitz;	state Exp;
branches;
next	1.244;

1.244
date	2011.07.21.09.39.21;	author yselkowitz;	state Exp;
branches;
next	1.243;

1.243
date	2011.06.06.05.02.13;	author cgf;	state Exp;
branches;
next	1.242;

1.242
date	2011.05.20.07.23.11;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2011.05.19.23.44.55;	author yselkowitz;	state Exp;
branches;
next	1.240;

1.240
date	2011.05.17.17.08.09;	author yselkowitz;	state Exp;
branches;
next	1.239;

1.239
date	2011.05.15.18.49.40;	author corinna;	state Exp;
branches;
next	1.238;

1.238
date	2011.05.04.06.16.59;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2011.05.03.15.58.52;	author corinna;	state Exp;
branches;
next	1.236;

1.236
date	2011.05.03.01.13.37;	author yselkowitz;	state Exp;
branches;
next	1.235;

1.235
date	2011.05.02.18.48.11;	author corinna;	state Exp;
branches;
next	1.234;

1.234
date	2011.05.01.17.42.41;	author corinna;	state Exp;
branches;
next	1.233;

1.233
date	2011.04.30.16.34.48;	author corinna;	state Exp;
branches;
next	1.232;

1.232
date	2011.04.30.10.20.25;	author corinna;	state Exp;
branches;
next	1.231;

1.231
date	2011.04.29.18.29.26;	author corinna;	state Exp;
branches;
next	1.230;

1.230
date	2011.04.29.08.27.11;	author corinna;	state Exp;
branches;
next	1.229;

1.229
date	2011.04.19.18.51.20;	author jturney;	state Exp;
branches;
next	1.228;

1.228
date	2011.04.15.09.22.14;	author yselkowitz;	state Exp;
branches;
next	1.227;

1.227
date	2011.03.29.10.32.40;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2011.03.29.07.49.25;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2010.04.06.15.27.34;	author corinna;	state Exp;
branches
	1.225.2.1;
next	1.224;

1.224
date	2010.03.12.23.13.48;	author cgf;	state Exp;
branches;
next	1.223;

1.223
date	2010.02.26.21.36.31;	author cgf;	state Exp;
branches;
next	1.222;

1.222
date	2010.02.23.07.12.38;	author cgf;	state Exp;
branches;
next	1.221;

1.221
date	2010.02.22.20.36.03;	author cgf;	state Exp;
branches;
next	1.220;

1.220
date	2010.02.12.20.07.13;	author cgf;	state Exp;
branches;
next	1.219;

1.219
date	2010.02.10.07.25.25;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2010.02.10.03.17.32;	author cgf;	state Exp;
branches;
next	1.217;

1.217
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.216;

1.216
date	2009.06.04.01.45.05;	author davek;	state Exp;
branches;
next	1.215;

1.215
date	2009.01.20.12.40.31;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2008.11.07.18.32.41;	author cgf;	state Exp;
branches;
next	1.213;

1.213
date	2008.09.30.02.39.07;	author cgf;	state Exp;
branches;
next	1.212;

1.212
date	2008.09.30.02.22.39;	author cgf;	state Exp;
branches;
next	1.211;

1.211
date	2008.04.21.12.46.57;	author corinna;	state Exp;
branches;
next	1.210;

1.210
date	2008.04.07.18.45.59;	author cgf;	state Exp;
branches;
next	1.209;

1.209
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.208;

1.208
date	2008.04.01.13.22.47;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2008.02.15.17.53.11;	author cgf;	state Exp;
branches;
next	1.206;

1.206
date	2008.02.13.17.21.05;	author cgf;	state Exp;
branches;
next	1.205;

1.205
date	2007.12.05.15.10.19;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2007.11.27.14.45.14;	author corinna;	state Exp;
branches;
next	1.203;

1.203
date	2007.11.06.15.48.34;	author corinna;	state Exp;
branches;
next	1.202;

1.202
date	2007.03.29.16.37.36;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2007.02.22.12.34.55;	author cgf;	state Exp;
branches;
next	1.200;

1.200
date	2007.02.20.15.48.04;	author corinna;	state Exp;
branches;
next	1.199;

1.199
date	2006.05.27.19.00.36;	author cgf;	state Exp;
branches
	1.199.4.1;
next	1.198;

1.198
date	2006.03.22.20.38.26;	author corinna;	state Exp;
branches;
next	1.197;

1.197
date	2006.03.22.12.52.26;	author corinna;	state Exp;
branches;
next	1.196;

1.196
date	2006.02.06.18.24.06;	author cgf;	state Exp;
branches;
next	1.195;

1.195
date	2005.12.03.04.23.35;	author cgf;	state Exp;
branches;
next	1.194;

1.194
date	2005.09.06.19.22.53;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2005.08.12.02.39.13;	author cgf;	state Exp;
branches;
next	1.192;

1.192
date	2005.08.05.16.14.41;	author corinna;	state Exp;
branches;
next	1.191;

1.191
date	2005.08.05.11.31.33;	author corinna;	state Exp;
branches;
next	1.190;

1.190
date	2005.07.06.20.05.03;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2005.07.05.03.16.46;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2005.07.05.02.02.23;	author cgf;	state Exp;
branches;
next	1.187;

1.187
date	2005.07.03.03.25.19;	author cgf;	state Exp;
branches;
next	1.186;

1.186
date	2005.07.03.02.40.30;	author cgf;	state Exp;
branches;
next	1.185;

1.185
date	2005.06.30.02.51.31;	author cgf;	state Exp;
branches;
next	1.184;

1.184
date	2005.06.29.23.05.41;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2005.06.11.04.56.35;	author cgf;	state Exp;
branches;
next	1.182;

1.182
date	2005.06.09.22.33.56;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2005.06.09.20.59.59;	author cgf;	state Exp;
branches;
next	1.180;

1.180
date	2005.06.09.05.14.02;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2005.06.09.05.11.51;	author cgf;	state Exp;
branches;
next	1.178;

1.178
date	2005.05.29.02.42.36;	author cgf;	state Exp;
branches;
next	1.177;

1.177
date	2005.02.20.04.25.32;	author cgf;	state Exp;
branches;
next	1.176;

1.176
date	2005.01.29.05.39.07;	author cgf;	state Exp;
branches;
next	1.175;

1.175
date	2004.09.07.04.05.14;	author cgf;	state Exp;
branches;
next	1.174;

1.174
date	2004.06.27.19.16.48;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2004.06.07.04.26.32;	author cgf;	state Exp;
branches;
next	1.172;

1.172
date	2004.05.28.19.50.07;	author cgf;	state Exp;
branches;
next	1.171;

1.171
date	2004.05.17.16.06.01;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2004.05.07.03.27.37;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2004.04.13.03.25.50;	author cgf;	state Exp;
branches;
next	1.168;

1.168
date	2004.04.13.02.59.19;	author cgf;	state Exp;
branches;
next	1.167;

1.167
date	2004.04.10.00.53.25;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2004.03.30.21.27.50;	author cgf;	state Exp;
branches;
next	1.165;

1.165
date	2004.03.29.15.14.07;	author cgf;	state Exp;
branches;
next	1.164;

1.164
date	2004.03.26.20.02.01;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2004.03.04.21.04.13;	author tpfaff;	state Exp;
branches;
next	1.162;

1.162
date	2004.02.26.05.10.48;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2004.02.24.11.33.15;	author corinna;	state Exp;
branches;
next	1.160;

1.160
date	2004.02.09.04.04.24;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2004.01.23.23.05.33;	author cgf;	state Exp;
branches;
next	1.158;

1.158
date	2004.01.19.05.46.54;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2004.01.14.15.45.37;	author cgf;	state Exp;
branches
	1.157.4.1;
next	1.156;

1.156
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches
	1.156.2.1;
next	1.155;

1.155
date	2003.12.15.14.38.12;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2003.12.14.07.09.22;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2003.12.12.04.15.31;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2003.12.08.06.32.46;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2003.12.06.18.08.38;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2003.12.03.05.21.55;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2003.12.01.22.10.57;	author tpfaff;	state Exp;
branches;
next	1.148;

1.148
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.147;

1.147
date	2003.11.26.13.23.27;	author corinna;	state Exp;
branches;
next	1.146;

1.146
date	2003.11.25.22.59.37;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2003.11.25.22.58.32;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2003.11.25.22.57.22;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2003.11.25.22.56.58;	author cgf;	state Exp;
branches;
next	1.142;

1.142
date	2003.11.25.22.55.31;	author cgf;	state Exp;
branches;
next	1.141;

1.141
date	2003.11.11.19.10.47;	author tpfaff;	state Exp;
branches;
next	1.140;

1.140
date	2003.11.10.19.44.53;	author tpfaff;	state Exp;
branches;
next	1.139;

1.139
date	2003.10.31.20.47.14;	author tpfaff;	state Exp;
branches;
next	1.138;

1.138
date	2003.10.31.20.42.55;	author tpfaff;	state Exp;
branches;
next	1.137;

1.137
date	2003.10.27.11.48.29;	author corinna;	state Exp;
branches;
next	1.136;

1.136
date	2003.10.24.19.34.47;	author tpfaff;	state Exp;
branches;
next	1.135;

1.135
date	2003.09.25.03.51.51;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2003.09.20.02.43.18;	author cgf;	state Exp;
branches;
next	1.132;

1.132
date	2003.09.13.01.21.32;	author cgf;	state Exp;
branches
	1.132.2.1;
next	1.131;

1.131
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.130;

1.130
date	2003.07.02.03.50.05;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2003.06.24.20.14.01;	author tpfaff;	state Exp;
branches;
next	1.128;

1.128
date	2003.06.16.03.24.12;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2003.06.12.18.15.33;	author tpfaff;	state Exp;
branches;
next	1.126;

1.126
date	2003.06.11.19.08.40;	author tpfaff;	state Exp;
branches;
next	1.125;

1.125
date	2003.05.15.19.42.51;	author tpfaff;	state Exp;
branches;
next	1.124;

1.124
date	2003.04.17.19.57.00;	author tpfaff;	state Exp;
branches;
next	1.123;

1.123
date	2003.04.15.20.14.12;	author tpfaff;	state Exp;
branches;
next	1.122;

1.122
date	2003.03.27.19.57.06;	author tpfaff;	state Exp;
branches;
next	1.121;

1.121
date	2003.03.27.19.52.20;	author tpfaff;	state Exp;
branches;
next	1.120;

1.120
date	2003.03.23.10.52.02;	author tpfaff;	state Exp;
branches;
next	1.119;

1.119
date	2003.03.18.20.12.05;	author tpfaff;	state Exp;
branches;
next	1.118;

1.118
date	2003.03.18.20.01.06;	author tpfaff;	state Exp;
branches;
next	1.117;

1.117
date	2003.03.18.19.49.38;	author tpfaff;	state Exp;
branches;
next	1.116;

1.116
date	2003.03.18.19.39.21;	author tpfaff;	state Exp;
branches;
next	1.115;

1.115
date	2003.03.04.20.16.49;	author tpfaff;	state Exp;
branches;
next	1.114;

1.114
date	2003.01.14.20.31.47;	author cgf;	state Exp;
branches
	1.114.2.1;
next	1.113;

1.113
date	2003.01.14.20.19.27;	author tpfaff;	state Exp;
branches;
next	1.112;

1.112
date	2003.01.14.20.13.08;	author tpfaff;	state Exp;
branches;
next	1.111;

1.111
date	2003.01.14.19.55.42;	author tpfaff;	state Exp;
branches;
next	1.110;

1.110
date	2003.01.10.12.32.47;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2003.01.09.20.57.53;	author tpfaff;	state Exp;
branches;
next	1.108;

1.108
date	2003.01.09.20.50.22;	author tpfaff;	state Exp;
branches;
next	1.107;

1.107
date	2003.01.09.20.40.44;	author tpfaff;	state Exp;
branches;
next	1.106;

1.106
date	2002.11.24.13.54.14;	author rbcollins;	state Exp;
branches;
next	1.105;

1.105
date	2002.11.13.19.36.12;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2002.10.20.04.15.50;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2002.10.18.14.02.40;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2002.10.17.08.44.18;	author rbcollins;	state Exp;
branches;
next	1.101;

1.101
date	2002.10.17.08.31.30;	author rbcollins;	state Exp;
branches;
next	1.100;

1.100
date	2002.10.05.17.47.25;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2002.09.30.21.06.05;	author rbcollins;	state Exp;
branches;
next	1.98;

1.98
date	2002.09.30.15.11.55;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2002.09.30.15.05.00;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2002.09.30.15.00.52;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2002.09.30.11.43.43;	author rbcollins;	state Exp;
branches;
next	1.94;

1.94
date	2002.09.30.04.27.32;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2002.09.30.04.26.52;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2002.09.30.01.19.45;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2002.09.29.23.56.57;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2002.09.29.23.47.45;	author rbcollins;	state Exp;
branches;
next	1.89;

1.89
date	2002.09.27.15.08.50;	author rbcollins;	state Exp;
branches;
next	1.88;

1.88
date	2002.09.22.21.39.03;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2002.09.21.03.59.58;	author rbcollins;	state Exp;
branches;
next	1.85;

1.85
date	2002.09.21.03.20.27;	author rbcollins;	state Exp;
branches;
next	1.84;

1.84
date	2002.09.21.01.59.46;	author rbcollins;	state Exp;
branches;
next	1.83;

1.83
date	2002.09.20.23.46.12;	author rbcollins;	state Exp;
branches;
next	1.82;

1.82
date	2002.09.20.22.34.05;	author rbcollins;	state Exp;
branches;
next	1.81;

1.81
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2002.09.17.10.01.49;	author rbcollins;	state Exp;
branches;
next	1.79;

1.79
date	2002.09.17.09.12.36;	author rbcollins;	state Exp;
branches;
next	1.78;

1.78
date	2002.09.16.16.09.54;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2002.09.16.10.53.29;	author rbcollins;	state Exp;
branches;
next	1.76;

1.76
date	2002.07.04.14.17.29;	author rbcollins;	state Exp;
branches;
next	1.75;

1.75
date	2002.06.27.14.19.30;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2002.06.23.07.36.21;	author rbcollins;	state Exp;
branches;
next	1.73;

1.73
date	2002.06.21.05.01.17;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2002.06.10.02.40.13;	author rbcollins;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.10.01.10.44;	author rbcollins;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.05.12.39.54;	author rbcollins;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.05.04.01.43;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.02.06.07.01;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2002.05.02.11.26.22;	author rbcollins;	state Exp;
branches;
next	1.65;

1.65
date	2002.02.28.13.50.41;	author rbcollins;	state Exp;
branches;
next	1.64;

1.64
date	2001.12.26.12.46.26;	author rbcollins;	state Exp;
branches;
next	1.63;

1.63
date	2001.12.02.07.17.33;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2001.12.02.07.07.53;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2001.12.02.06.41.58;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2001.12.02.06.21.17;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2001.12.02.06.13.48;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2001.12.02.06.01.16;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2001.12.02.05.48.24;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2001.12.02.05.23.26;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2001.11.28.00.06.35;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2001.11.15.11.10.38;	author duda;	state Exp;
branches;
next	1.53;

1.53
date	2001.11.05.06.09.09;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2001.09.30.14.39.55;	author rbcollins;	state Exp;
branches;
next	1.51;

1.51
date	2001.09.29.09.01.01;	author rbcollins;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.25.11.45.25;	author rbcollins;	state Exp;
branches;
next	1.49;

1.49
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2001.09.12.04.47.47;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2001.09.12.03.18.05;	author rbcollins;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.11.11.23.41;	author rbcollins;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.11.08.15.39;	author rbcollins;	state Exp;
branches;
next	1.44;

1.44
date	2001.09.09.22.39.35;	author rbcollins;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.04.20.48.45;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.26.20.47.05;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.25.23.46.25;	author rbcollins;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.28.02.19.57;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.26.14.57.33;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.26.14.47.48;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.24.22.26.53;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.21.22.27.20;	author rbcollins;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.14.23.53.27;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.07.19.55.06;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.06.22.23.43;	author rbcollins;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.04.21.02.15;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.04.20.39.38;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.27.18.50.58;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.23.02.56.19;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.22.23.59.15;	author rbcollins;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.21.23.26.14;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2001.04.21.14.23.47;	author rbcollins;	state Exp;
branches;
next	1.24;

1.24
date	2001.04.14.07.06.02;	author rbcollins;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.13.15.28.20;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.12.04.04.53;	author rbcollins;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.09.00.44.25;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.21.02.17.57;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.18.21.11.25;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.17.04.49.13;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.17.01.14.57;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.20.02.53.55;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.08.04.02.01;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.04.18.33.39;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.03.18.50.25;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.08.02.56.55;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.04.17.52.42;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.04.04.04.46;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.01.03.51.55;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.17.05.49.51;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.24.03.53.22;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.287.2.1
date	2014.07.15.14.34.38;	author corinna;	state Exp;
branches;
next	1.287.2.2;

1.287.2.2
date	2014.07.16.10.28.48;	author corinna;	state Exp;
branches;
next	1.287.2.3;

1.287.2.3
date	2014.07.21.16.32.15;	author corinna;	state Exp;
branches;
next	1.287.2.4;

1.287.2.4
date	2014.11.13.12.53.07;	author corinna;	state Exp;
branches;
next	;

1.270.2.1
date	2012.08.14.17.16.55;	author corinna;	state Exp;
branches;
next	1.270.2.2;

1.270.2.2
date	2012.08.14.19.29.32;	author corinna;	state Exp;
branches;
next	1.270.2.3;

1.270.2.3
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.270.2.4;

1.270.2.4
date	2012.10.16.15.18.39;	author corinna;	state Exp;
branches;
next	1.270.2.5;

1.270.2.5
date	2012.11.16.13.48.24;	author corinna;	state Exp;
branches;
next	1.270.2.6;

1.270.2.6
date	2012.11.16.14.51.21;	author corinna;	state Exp;
branches;
next	1.270.2.7;

1.270.2.7
date	2012.12.10.11.45.51;	author corinna;	state Exp;
branches;
next	1.270.2.8;

1.270.2.8
date	2013.01.09.16.27.22;	author corinna;	state Exp;
branches;
next	1.270.2.9;

1.270.2.9
date	2013.01.21.13.52.11;	author corinna;	state Exp;
branches;
next	1.270.2.10;

1.270.2.10
date	2013.04.11.12.13.01;	author corinna;	state Exp;
branches;
next	;

1.225.2.1
date	2011.03.11.11.37.49;	author corinna;	state Exp;
branches;
next	;

1.199.4.1
date	2007.11.12.15.30.20;	author corinna;	state Exp;
branches;
next	1.199.4.2;

1.199.4.2
date	2007.11.29.11.14.52;	author corinna;	state Exp;
branches;
next	1.199.4.3;

1.199.4.3
date	2008.02.14.14.23.51;	author corinna;	state Exp;
branches;
next	1.199.4.4;

1.199.4.4
date	2008.02.18.14.08.37;	author corinna;	state Exp;
branches;
next	;

1.157.4.1
date	2004.01.24.01.53.58;	author cgf;	state Exp;
branches;
next	;

1.156.2.1
date	2004.01.11.18.13.52;	author cgf;	state Exp;
branches;
next	1.156.2.2;

1.156.2.2
date	2004.01.15.18.29.37;	author cgf;	state Exp;
branches;
next	1.156.2.3;

1.156.2.3
date	2004.01.17.04.13.20;	author cgf;	state Exp;
branches;
next	;

1.132.2.1
date	2003.09.20.02.48.14;	author cgf;	state Exp;
branches;
next	;

1.114.2.1
date	2003.03.09.16.22.59;	author cgf;	state Exp;
branches;
next	1.114.2.2;

1.114.2.2
date	2003.03.19.19.59.56;	author cgf;	state Exp;
branches;
next	1.114.2.3;

1.114.2.3
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.114.2.4;

1.114.2.4
date	2003.05.10.17.20.54;	author cgf;	state Exp;
branches;
next	1.114.2.5;

1.114.2.5
date	2003.05.26.19.39.07;	author cgf;	state Exp;
branches;
next	1.114.2.6;

1.114.2.6
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.114.2.7;

1.114.2.7
date	2003.08.06.03.58.58;	author cgf;	state Exp;
branches;
next	1.114.2.8;

1.114.2.8
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	1.114.2.9;

1.114.2.9
date	2003.09.14.01.35.38;	author cgf;	state Exp;
branches;
next	;

1.49.2.1
date	2001.09.27.12.33.43;	author rbcollins;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2001.09.29.09.35.31;	author rbcollins;	state Exp;
branches;
next	1.49.2.3;

1.49.2.3
date	2001.09.30.14.47.21;	author rbcollins;	state Exp;
branches;
next	1.49.2.4;

1.49.2.4
date	2002.01.04.03.56.11;	author rbcollins;	state Exp;
branches;
next	1.49.2.5;

1.49.2.5
date	2002.03.03.12.42.03;	author rbcollins;	state Exp;
branches;
next	1.49.2.6;

1.49.2.6
date	2002.06.13.14.34.13;	author rbcollins;	state Exp;
branches;
next	1.49.2.7;

1.49.2.7
date	2002.06.21.12.18.52;	author scottc;	state Exp;
branches;
next	1.49.2.8;

1.49.2.8
date	2002.06.23.08.05.45;	author rbcollins;	state Exp;
branches;
next	1.49.2.9;

1.49.2.9
date	2002.06.28.18.15.48;	author scottc;	state Exp;
branches;
next	1.49.2.10;

1.49.2.10
date	2002.07.04.20.09.47;	author scottc;	state Exp;
branches;
next	1.49.2.11;

1.49.2.11
date	2002.09.16.17.24.16;	author scottc;	state Exp;
branches;
next	1.49.2.12;

1.49.2.12
date	2002.09.17.09.54.50;	author scottc;	state Exp;
branches;
next	1.49.2.13;

1.49.2.13
date	2002.09.17.15.38.48;	author scottc;	state Exp;
branches;
next	1.49.2.14;

1.49.2.14
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	1.49.2.15;

1.49.2.15
date	2002.09.20.22.53.14;	author scottc;	state Exp;
branches;
next	1.49.2.16;

1.49.2.16
date	2002.09.21.08.13.47;	author scottc;	state Exp;
branches;
next	1.49.2.17;

1.49.2.17
date	2002.09.22.10.01.29;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.298
log
@	* fhandler_tape.cc (fhandler_dev_tape::_lock): Add cw_sig_restart to
	cygwait call.
	* thread.cc (pthread_mutex::lock): Ditto.
	(semaphore::_timedwait): Fix formatting.
	(semaphore::_wait): Ditto.
	* thread.h (fast_mutex::lock): Ditto.

	...and fix ChangeLog accordingly.
@
text
@/* thread.cc: Locking and threading module functions

   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

/* Implementation overview and caveats:

   Win32 puts some contraints on what can and cannot be implemented.  Where
   possible we work around those contrainsts.  Where we cannot work around
   the constraints we either pretend to be conformant, or return an error
   code.

   Some caveats: PROCESS_SHARED objects, while they pretend to be process
   shared, may not actually work.  Some test cases are needed to determine
   win32's behaviour.  My suspicion is that the win32 handle needs to be
   opened with different flags for proper operation.

   R.Collins, April 2001.  */

#include "winsup.h"
#include "miscfuncs.h"
#include "path.h"
#include <stdlib.h>
#include "sigproc.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "ntdll.h"
#include "cygwait.h"

extern "C" void __fp_lock_all ();
extern "C" void __fp_unlock_all ();
extern "C" int valid_sched_parameters(const struct sched_param *);
extern "C" int sched_set_thread_priority(HANDLE thread, int priority);
static inline verifyable_object_state
  verifyable_object_isvalid (void const * objectptr, thread_magic_t magic,
			     void *static_ptr1 = NULL,
			     void *static_ptr2 = NULL,
			     void *static_ptr3 = NULL);

extern int threadsafe;

const pthread_t pthread_mutex::_new_mutex = (pthread_t) 1;
const pthread_t pthread_mutex::_unlocked_mutex = (pthread_t) 2;
const pthread_t pthread_mutex::_destroyed_mutex = (pthread_t) 3;

inline bool
pthread_mutex::no_owner()
{
    int res;
    if (!owner)
      {
	debug_printf ("NULL owner value");
	res = 1;
      }
    else if (owner == _destroyed_mutex)
      {
	paranoid_printf ("attempt to use destroyed mutex");
	res = 1;
      }
    else if (owner == _new_mutex || owner == _unlocked_mutex)
      res = 1;
    else
      res = 0;
    return res;
}

#undef __getreent
extern "C" struct _reent *
__getreent ()
{
  return &_my_tls.local_clib;
}

extern "C" void
__cygwin_lock_init (_LOCK_T *lock)
{
  *lock = _LOCK_T_INITIALIZER;
}

extern "C" void
__cygwin_lock_init_recursive (_LOCK_T *lock)
{
  *lock = _LOCK_T_RECURSIVE_INITIALIZER;
}

extern "C" void
__cygwin_lock_fini (_LOCK_T *lock)
{
  pthread_mutex_destroy ((pthread_mutex_t*) lock);
}

extern "C" void
__cygwin_lock_lock (_LOCK_T *lock)
{
  paranoid_printf ("threadcount %d.  locking", MT_INTERFACE->threadcount);
  pthread_mutex_lock ((pthread_mutex_t*) lock);
}

extern "C" int
__cygwin_lock_trylock (_LOCK_T *lock)
{
  return pthread_mutex_trylock ((pthread_mutex_t*) lock);
}


extern "C" void
__cygwin_lock_unlock (_LOCK_T *lock)
{
  pthread_mutex_unlock ((pthread_mutex_t*) lock);
  paranoid_printf ("threadcount %d.  unlocked", MT_INTERFACE->threadcount);
}

static inline verifyable_object_state
verifyable_object_isvalid (void const *objectptr, thread_magic_t magic, void *static_ptr1,
			   void *static_ptr2, void *static_ptr3)
{
  verifyable_object_state state = INVALID_OBJECT;

  __try
    {
      if (!objectptr || !(*(const char **) objectptr))
	__leave;

      verifyable_object **object = (verifyable_object **) objectptr;

      if ((static_ptr1 && *object == static_ptr1) ||
	  (static_ptr2 && *object == static_ptr2) ||
	  (static_ptr3 && *object == static_ptr3))
	state = VALID_STATIC_OBJECT;
      else if ((*object)->magic == magic)
	state = VALID_OBJECT;
    }
  __except (NO_ERROR) {}
  __endtry
  return state;
}

/* static members */
inline bool
pthread_attr::is_good_object (pthread_attr_t const *attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

inline bool
pthread_condattr::is_good_object (pthread_condattr_t const *attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

inline bool
pthread_rwlockattr::is_good_object (pthread_rwlockattr_t const *attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_RWLOCKATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

inline bool
pthread_key::is_good_object (pthread_key_t const *key)
{
  if (verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

inline bool
pthread_spinlock::is_good_object (pthread_spinlock_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_SPINLOCK_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

inline bool
pthread_mutex::is_good_object (pthread_mutex_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

inline bool
pthread_mutex::is_initializer (pthread_mutex_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC,
				 PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,
				 PTHREAD_NORMAL_MUTEX_INITIALIZER_NP,
				 PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP) != VALID_STATIC_OBJECT)
    return false;
  return true;
}

inline bool
pthread_mutex::is_initializer_or_object (pthread_mutex_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC,
				 PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,
				 PTHREAD_NORMAL_MUTEX_INITIALIZER_NP,
				 PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP) == INVALID_OBJECT)
    return false;
  return true;
}

/* FIXME: Accommodate PTHREAD_MUTEX_ERRORCHECK */
inline bool
pthread_mutex::can_be_unlocked ()
{
  pthread_t self = pthread::self ();
  /* Check if the mutex is owned by the current thread and can be unlocked.
   * Also check for the ANONYMOUS owner to cover NORMAL mutexes as well. */
  bool res = type == PTHREAD_MUTEX_NORMAL || no_owner ()
	     || (recursion_counter == 1 && pthread::equal (owner, self));
  pthread_printf ("recursion_counter %u res %d", recursion_counter, res);
  return res;
}

inline bool
pthread_mutexattr::is_good_object (pthread_mutexattr_t const * attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

inline bool __attribute__ ((used))
pthread::is_good_object (pthread_t const *thread)
{
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

/* Thread synchronisation */
inline bool
pthread_cond::is_good_object (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

inline bool
pthread_cond::is_initializer (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER) != VALID_STATIC_OBJECT)
    return false;
  return true;
}

inline bool
pthread_cond::is_initializer_or_object (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER) == INVALID_OBJECT)
    return false;
  return true;
}

/* RW locks */
inline bool
pthread_rwlock::is_good_object (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

inline bool
pthread_rwlock::is_initializer (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC, PTHREAD_RWLOCK_INITIALIZER) != VALID_STATIC_OBJECT)
    return false;
  return true;
}

inline bool
pthread_rwlock::is_initializer_or_object (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC, PTHREAD_RWLOCK_INITIALIZER) == INVALID_OBJECT)
    return false;
  return true;
}

inline bool
semaphore::is_good_object (sem_t const * sem)
{
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

void
MTinterface::Init ()
{
  pthread_mutex::init_mutex ();
  pthread_cond::init_mutex ();
  pthread_rwlock::init_mutex ();
}

void
MTinterface::fixup_before_fork ()
{
  pthread_key::fixup_before_fork ();
  semaphore::fixup_before_fork ();
}

/* This function is called from a single threaded process */
void
MTinterface::fixup_after_fork ()
{
  pthread_key::fixup_after_fork ();

  threadcount = 0;
  pthread::init_mainthread ();

  pthread::fixup_after_fork ();
  pthread_mutex::fixup_after_fork ();
  pthread_cond::fixup_after_fork ();
  pthread_rwlock::fixup_after_fork ();
  semaphore::fixup_after_fork ();
}

/* pthread calls */

/* static methods */
void
pthread::init_mainthread ()
{
  pthread *thread = _my_tls.tid;
  if (!thread)
    {
      thread = new pthread ();
      if (!thread)
	api_fatal ("failed to create mainthread object");
    }

  thread->set_tls_self_pointer ();
  thread->thread_id = GetCurrentThreadId ();
  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),
			GetCurrentProcess (), &thread->win32_obj_id,
			0, FALSE, DUPLICATE_SAME_ACCESS))
    api_fatal ("failed to create mainthread handle");
  if (!thread->create_cancel_event ())
    api_fatal ("couldn't create cancel event for main thread");
  VerifyHandle (thread->win32_obj_id);
  /* Make sure the pthread mutex is recursive.  See comment in
     pthread::precreate (called only for subsequent pthreads)
     for a description. */
  thread->mutex.set_type (PTHREAD_MUTEX_RECURSIVE);
  thread->postcreate ();
}

pthread *
pthread::self ()
{
  pthread *thread = _my_tls.tid;
  if (!thread)
    {
      thread = pthread_null::get_null_pthread ();
      thread->set_tls_self_pointer ();
    }
  return thread;
}

void
pthread::set_tls_self_pointer ()
{
  cygtls = &_my_tls;
  _my_tls.tid = this;
}

List<pthread> pthread::threads;

/* member methods */
pthread::pthread ():verifyable_object (PTHREAD_MAGIC), win32_obj_id (0),
		    valid (false), suspended (false), canceled (false),
		    cancelstate (0), canceltype (0), cancel_event (0),
		    joiner (NULL), next (NULL), cleanup_stack (NULL)
{
  if (this != pthread_null::get_null_pthread ())
    threads.insert (this);
  sigprocmask (SIG_SETMASK, NULL, &parent_sigmask);
}

pthread::~pthread ()
{
  if (win32_obj_id)
    CloseHandle (win32_obj_id);
  if (cancel_event)
    CloseHandle (cancel_event);

  if (this != pthread_null::get_null_pthread ())
    threads.remove (this);
}

bool
pthread::create_cancel_event ()
{
  cancel_event = ::CreateEvent (&sec_none_nih, true, false, NULL);
  if (!cancel_event)
    {
      system_printf ("couldn't create cancel event, %E");
      /* we need the event for correct behaviour */
      return false;
    }
  return true;
}

void
pthread::precreate (pthread_attr *newattr)
{
  pthread_mutex *verifyable_mutex_obj = &mutex;

  /* already running ? */
  if (win32_obj_id)
    return;

  if (newattr)
    {
      attr.joinable = newattr->joinable;
      attr.contentionscope = newattr->contentionscope;
      attr.inheritsched = newattr->inheritsched;
      attr.stackaddr = newattr->stackaddr;
      attr.stacksize = newattr->stacksize;
      attr.guardsize = newattr->guardsize;
    }

  if (!pthread_mutex::is_good_object (&verifyable_mutex_obj))
    {
      thread_printf ("New thread object access mutex is not valid. this %p",
		     this);
      magic = 0;
      return;
    }
  /* This mutex MUST be recursive.  Consider the following scenario:
     - The thread installs a cleanup handler.
     - The cleanup handler calls a function which itself installs a
       cleanup handler.
     - pthread_cancel is called for this thread.
     - The thread's cleanup handler is called under mutex lock condition.
     - The cleanup handler calls the subsequent function with cleanup handler.
     - The function runs to completion, so it calls pthread_cleanup_pop.
     - pthread_cleanup_pop calls pthread::pop_cleanup_handler which will again
       try to lock the mutex.
     - Deadlock. */
  mutex.set_type (PTHREAD_MUTEX_RECURSIVE);
  if (!create_cancel_event ())
    magic = 0;
}

bool
pthread::create (void *(*func) (void *), pthread_attr *newattr,
		 void *threadarg)
{
  bool retval;

  precreate (newattr);
  if (!magic)
    return false;

  function = func;
  arg = threadarg;

  mutex.lock ();
  /* stackaddr holds the uppermost stack address.  See the comments in
     pthread_attr_setstack and pthread_attr_setstackaddr for a description. */
  ULONG stacksize = attr.stacksize ?: PTHREAD_DEFAULT_STACKSIZE;
  PVOID stackaddr = attr.stackaddr ? ((caddr_t) attr.stackaddr - stacksize)
				   : NULL;
  win32_obj_id = CygwinCreateThread (thread_init_wrapper, this, stackaddr,
				     stacksize, attr.guardsize, 0, &thread_id);

  if (!win32_obj_id)
    {
      thread_printf ("CreateThread failed: this %p, %E", this);
      magic = 0;
    }
  else
    {
      postcreate ();
      while (!cygtls)
	yield ();
    }
  retval = magic;
  mutex.unlock ();
  return retval;
}

void
pthread::postcreate ()
{
  valid = true;

  InterlockedIncrement (&MT_INTERFACE->threadcount);
  /* FIXME: set the priority appropriately for system contention scope */
  if (attr.inheritsched == PTHREAD_EXPLICIT_SCHED)
    {
      /* FIXME: set the scheduling settings for the new thread */
      /* sched_thread_setparam (win32_obj_id, attr.schedparam); */
    }
}

void
pthread::exit (void *value_ptr)
{
  class pthread *thread = this;
  _cygtls *tls = cygtls;	/* Save cygtls before deleting this. */

  // run cleanup handlers
  pop_all_cleanup_handlers ();

  pthread_key::run_all_destructors ();

  mutex.lock ();
  // cleanup if thread is in detached state and not joined
  if (equal (joiner, thread))
    delete this;
  else
    {
      valid = false;
      return_ptr = value_ptr;
      mutex.unlock ();
    }

  if (_my_tls.local_clib.__sdidinit < 0)
    _my_tls.local_clib.__sdidinit = 0;
  (_reclaim_reent) (_REENT);

  if (InterlockedDecrement (&MT_INTERFACE->threadcount) == 0)
    ::exit (0);
  else
    {
      if (tls == _main_tls)
	{
	  cygheap->find_tls (tls); /* Lock _main_tls mutex. */
	  _cygtls *dummy = (_cygtls *) malloc (sizeof (_cygtls));
	  *dummy = *_main_tls;
	  _main_tls = dummy;
	  _main_tls->initialized = 0;
	}
      /* This also unlocks and closes the _main_tls mutex. */
      tls->remove (INFINITE);
      ExitThread (0);
    }
}

int
pthread::cancel ()
{
  class pthread *thread = this;
  class pthread *self = pthread::self ();

  mutex.lock ();

  if (!valid)
    {
      mutex.unlock ();
      return 0;
    }

  if (canceltype == PTHREAD_CANCEL_DEFERRED ||
      cancelstate == PTHREAD_CANCEL_DISABLE)
    {
      // cancel deferred
      mutex.unlock ();
      canceled = true;
      SetEvent (cancel_event);
      return 0;
    }
  else if (equal (thread, self))
    {
      mutex.unlock ();
      cancel_self ();
      return 0; // Never reached
    }

  // cancel asynchronous
  SuspendThread (win32_obj_id);
  if (WaitForSingleObject (win32_obj_id, 0) == WAIT_TIMEOUT)
    {
      CONTEXT context;
      context.ContextFlags = CONTEXT_CONTROL;
      GetThreadContext (win32_obj_id, &context);
      /* The OS is not foolproof in terms of asynchronous thread cancellation
	 and tends to hang infinitely if we change the instruction pointer.
	 So just don't cancel asynchronously if the thread is currently
	 executing Windows code.  Rely on deferred cancellation in this case. */
      threadlist_t *tl_entry = cygheap->find_tls (cygtls);
      if (!cygtls->inside_kernel (&context))
	{
#ifdef __x86_64__
	  context.Rip = (ULONG_PTR) pthread::static_cancel_self;
#else
	  context.Eip = (DWORD) pthread::static_cancel_self;
#endif
	  SetThreadContext (win32_obj_id, &context);
	}
      cygheap->unlock_tls (tl_entry);
    }
  mutex.unlock ();
  /* See above.  For instance, a thread which waits for a semaphore in sem_wait
     will call cygwait which in turn calls WFMO.  While this WFMO call
     is cancelable by setting the thread's cancel_event object, the OS
     apparently refuses to set the thread's context and continues to wait for
     the WFMO conditions.  This is *not* reflected in the return value of
     SetThreadContext or ResumeThread, btw.
     So, what we do here is to set the cancel_event as well to allow at least
     a deferred cancel. */
  canceled = true;
  SetEvent (cancel_event);
  ResumeThread (win32_obj_id);

  return 0;
}

/* TODO: Insert pthread_testcancel into the required functions.

   Here are the lists of required and optional functions per POSIX.1-2001
   and POSIX.1-2008. A star (*) indicates that the Cygwin function already
   is a cancellation point (aka "calls pthread_testcancel"), an o (o)
   indicates that the function is not implemented in Cygwin.

   Required cancellation points:

    * accept ()
    o aio_suspend ()
    * clock_nanosleep ()
    * close ()
    * connect ()
    * creat ()
    * fcntl () F_SETLKW
    * fdatasync ()
    * fsync ()
    o getmsg ()
    o getpmsg ()
    * lockf () F_LOCK
    * mq_receive ()
    * mq_send ()
    * mq_timedreceive ()
    * mq_timedsend ()
      msgrcv ()
      msgsnd ()
    * msync ()
    * nanosleep ()
    * open ()
    * openat ()
    * pause ()
    * poll ()
    * pread ()
    * pselect ()
    * pthread_cond_timedwait ()
    * pthread_cond_wait ()
    * pthread_join ()
    * pthread_testcancel ()
    o putmsg ()
    o putpmsg ()
    * pwrite ()
    * read ()
    * readv ()
    * recv ()
    * recvfrom ()
    * recvmsg ()
    * select ()
    * sem_timedwait ()
    * sem_wait ()
    * send ()
    * sendmsg ()
    * sendto ()
    * sigpause ()
    * sigsuspend ()
    o sigtimedwait ()
    * sigwait ()
    * sigwaitinfo ()
    * sleep ()
    * system ()
    * tcdrain ()
    * usleep ()
    * wait ()
    * wait3()
    o waitid ()
    * waitpid ()
    * write ()
    * writev ()

   Optional cancellation points:

      access ()
      asctime ()
      asctime_r ()
      catclose ()	Implemented externally: libcatgets
      catgets ()	Implemented externally: libcatgets
      catopen ()	Implemented externally: libcatgets
      chmod ()
      chown ()
      closedir ()
      closelog ()
      ctermid ()
      ctime ()
      ctime_r ()
      dbm_close ()	Implemented externally: libgdbm
      dbm_delete ()	Implemented externally: libgdbm
      dbm_fetch ()	Implemented externally: libgdbm
      dbm_nextkey ()	Implemented externally: libgdbm
      dbm_open ()	Implemented externally: libgdbm
      dbm_store ()	Implemented externally: libgdbm
      dlclose ()
      dlopen ()
      dprintf ()
      endgrent ()
      endhostent ()
    o endnetent ()
      endprotoent ()
      endpwent ()
      endservent ()
      endutxent ()
      faccessat ()
      fchmod ()
      fchmodat ()
      fchown ()
      fchownat ()
    * fclose ()
    * fcntl () (any value)
      fflush ()
      fgetc ()
      fgetpos ()
      fgets ()
      fgetwc ()
      fgetws ()
    o fmtmsg ()
      fopen ()
      fpathconf ()
      fprintf ()
      fputc ()
      fputs ()
      fputwc ()
      fputws ()
      fread ()
      freopen ()
      fscanf ()
      fseek ()
      fseeko ()
      fsetpos ()
      fstat ()
      fstatat ()
      ftell ()
      ftello ()
      ftw ()
      futimens ()
      fwprintf ()
      fwrite ()
      fwscanf ()
      getaddrinfo ()
      getc ()
      getc_unlocked ()
      getchar ()
      getchar_unlocked ()
      getcwd ()
    o getdate ()
      getdelim ()
      getgrent ()
      getgrgid ()
      getgrgid_r ()
      getgrnam ()
      getgrnam_r ()
      gethostbyaddr ()
      gethostbyname ()
      gethostent ()
      gethostid ()
      gethostname ()
      getline ()
      getlogin ()
      getlogin_r ()
      getnameinfo ()
    o getnetbyaddr ()
    o getnetbyname ()
    o getnetent ()
      getopt () (if opterr is nonzero)
      getprotobyname ()
      getprotobynumber ()
      getprotoent ()
      getpwent ()
    * getpwnam ()
    * getpwnam_r ()
    * getpwuid ()
    * getpwuid_r ()
      gets ()
      getservbyname ()
      getservbyport ()
      getservent ()
      getutxent ()
      getutxid ()
      getutxline ()
      getwc ()
      getwchar ()
      getwd ()
      glob ()
      iconv_close ()	Implemented externally: libiconv
      iconv_open ()	Implemented externally: libiconv
      ioctl ()
      link ()
      linkat ()
    o lio_listio ()
      localtime ()
      localtime_r ()
    * lockf ()
      lseek ()
      lstat ()
      mkdir ()
      mkdirat ()
      mkdtemp ()
      mkfifo ()
      mkfifoat ()
      mknod ()
      mknodat ()
      mkstemp ()
      mktime ()
      nftw ()
      opendir ()
      openlog ()
      pathconf ()
      pclose ()
      perror ()
      popen ()
      posix_fadvise ()
      posix_fallocate ()
      posix_madvise ()
      posix_openpt ()
      posix_spawn ()
      posix_spawnp ()
    o posix_trace_clear ()
    o posix_trace_close ()
    o posix_trace_create ()
    o posix_trace_create_withlog ()
    o posix_trace_eventtypelist_getnext_id ()
    o posix_trace_eventtypelist_rewind ()
    o posix_trace_flush ()
    o posix_trace_get_attr ()
    o posix_trace_get_filter ()
    o posix_trace_get_status ()
    o posix_trace_getnext_event ()
    o posix_trace_open ()
    o posix_trace_rewind ()
    o posix_trace_set_filter ()
    o posix_trace_shutdown ()
    o posix_trace_timedgetnext_event ()
    o posix_typed_mem_open ()
      printf ()
      psiginfo ()
      psignal ()
      pthread_rwlock_rdlock ()
    o pthread_rwlock_timedrdlock ()
    o pthread_rwlock_timedwrlock ()
      pthread_rwlock_wrlock ()
      putc ()
      putc_unlocked ()
      putchar ()
      putchar_unlocked ()
      puts ()
      pututxline ()
      putwc ()
      putwchar ()
      readdir ()
      readdir_r ()
      readlink ()
      readlinkat ()
      remove ()
      rename ()
      renameat ()
      rewind ()
      rewinddir ()
      scandir ()
      scanf ()
      seekdir ()
      semop ()
      setgrent ()
      sethostent ()
    o setnetent ()
      setprotoent ()
      setpwent ()
      setservent ()
      setutxent ()
      sigpause ()
      stat ()
      strerror ()
      strerror_r ()
      strftime ()
      symlink ()
      symlinkat ()
      sync ()
      syslog ()
      tmpfile ()
      tmpnam ()
      ttyname ()
      ttyname_r ()
      tzset ()
      ungetc ()
      ungetwc ()
      unlink ()
      unlinkat ()
      utime ()
      utimensat ()
      utimes ()
      vdprintf ()
      vfprintf ()
      vfwprintf ()
      vprintf ()
      vwprintf ()
      wcsftime ()
      wordexp ()
      wprintf ()
      wscanf ()

   An implementation may also mark other functions not specified in the
   standard as cancellation points.  In particular, an implementation is
   likely to mark any nonstandard function that may block as a
   cancellation point. */

void
pthread::testcancel ()
{
  if (cancelstate == PTHREAD_CANCEL_DISABLE)
    return;

  /* We check for the canceled flag first.  This allows to use the
     pthread_testcancel function a lot without adding the overhead of
     an OS call.  Only if the thread is marked as canceled, we wait for
     cancel_event being really set, on the off-chance that pthread_cancel
     gets interrupted before calling SetEvent. */
  if (canceled)
    {
      WaitForSingleObject (cancel_event, INFINITE);
      cancel_self ();
    }
}

/* Return cancel event handle if it exists *and* cancel is not disabled.
   This function is supposed to be used from other functions which are
   cancelable and need the cancel event in a WFMO call. */
HANDLE
pthread::get_cancel_event ()
{
  pthread_t thread = pthread::self ();

  return (thread && thread->cancel_event
	  && thread->cancelstate != PTHREAD_CANCEL_DISABLE)
	  ? thread->cancel_event : NULL;
}

void
pthread::static_cancel_self ()
{
  pthread::self ()->cancel_self ();
}

int
pthread::setcancelstate (int state, int *oldstate)
{
  int result = 0;

  mutex.lock ();

  if (state != PTHREAD_CANCEL_ENABLE && state != PTHREAD_CANCEL_DISABLE)
    result = EINVAL;
  else
    {
      if (oldstate)
	*oldstate = cancelstate;
      cancelstate = state;
    }

  mutex.unlock ();

  return result;
}

int
pthread::setcanceltype (int type, int *oldtype)
{
  int result = 0;

  mutex.lock ();

  if (type != PTHREAD_CANCEL_DEFERRED && type != PTHREAD_CANCEL_ASYNCHRONOUS)
    result = EINVAL;
  else
    {
      if (oldtype)
	*oldtype = canceltype;
      canceltype = type;
    }

  mutex.unlock ();

  return result;
}

void
pthread::push_cleanup_handler (__pthread_cleanup_handler *handler)
{
  if (this != self ())
    // TODO: do it?
    api_fatal ("Attempt to push a cleanup handler across threads");
  handler->next = cleanup_stack;
  cleanup_stack = handler;
}

void
pthread::pop_cleanup_handler (int const execute)
{
  if (this != self ())
    // TODO: send a signal or something to the thread ?
    api_fatal ("Attempt to execute a cleanup handler across threads");

  mutex.lock ();

  if (cleanup_stack != NULL)
    {
      __pthread_cleanup_handler *handler = cleanup_stack;

      if (execute)
	(*handler->function) (handler->arg);
      cleanup_stack = handler->next;
    }

  mutex.unlock ();
}

void
pthread::pop_all_cleanup_handlers ()
{
  /* We will no honor cancels since the thread is exiting.  */
  cancelstate = PTHREAD_CANCEL_DISABLE;

  while (cleanup_stack != NULL)
    pop_cleanup_handler (1);
}

void
pthread::cancel_self ()
{
  /* Can someone explain why the pthread:: is needed here?  g++ complains
     without it. */
  pthread::exit (PTHREAD_CANCELED);
}

DWORD
pthread::get_thread_id ()
{
  return thread_id;
}

void
pthread::_fixup_after_fork ()
{
  /* set thread to not running if it is not the forking thread */
  if (this != pthread::self ())
    {
      magic = 0;
      valid = false;
      win32_obj_id = NULL;
      canceled = false;
      cancel_event = NULL;
    }
}

void
pthread::suspend_except_self ()
{
  if (valid && this != pthread::self ())
    SuspendThread (win32_obj_id);
}

void
pthread::resume ()
{
  if (valid)
    ResumeThread (win32_obj_id);
}

/* instance members */

pthread_attr::pthread_attr ():verifyable_object (PTHREAD_ATTR_MAGIC),
joinable (PTHREAD_CREATE_JOINABLE), contentionscope (PTHREAD_SCOPE_PROCESS),
inheritsched (PTHREAD_INHERIT_SCHED), stackaddr (NULL), stacksize (0),
guardsize (PTHREAD_DEFAULT_GUARDSIZE)
{
  schedparam.sched_priority = 0;
}

pthread_attr::~pthread_attr ()
{
}

pthread_condattr::pthread_condattr ():verifyable_object
  (PTHREAD_CONDATTR_MAGIC), shared (PTHREAD_PROCESS_PRIVATE),
  clock_id (CLOCK_REALTIME)
{
}

pthread_condattr::~pthread_condattr ()
{
}

List<pthread_cond> pthread_cond::conds;

/* This is used for cond creation protection within a single process only */
fast_mutex NO_COPY pthread_cond::cond_initialization_lock;

/* We can only be called once.
   TODO: (no rush) use a non copied memory section to
   hold an initialization flag.  */
void
pthread_cond::init_mutex ()
{
  if (!cond_initialization_lock.init ())
    api_fatal ("Could not create win32 Mutex for pthread cond static initializer support.");
}

pthread_cond::pthread_cond (pthread_condattr *attr) :
  verifyable_object (PTHREAD_COND_MAGIC),
  shared (0), clock_id (CLOCK_REALTIME), waiting (0), pending (0),
  sem_wait (NULL), mtx_cond(NULL), next (NULL)
{
  pthread_mutex *verifyable_mutex_obj;

  if (attr)
    {
      clock_id = attr->clock_id;

      if (attr->shared != PTHREAD_PROCESS_PRIVATE)
	{
	  magic = 0;
	  return;
	}
    }

  verifyable_mutex_obj = &mtx_in;
  if (!pthread_mutex::is_good_object (&verifyable_mutex_obj))
    {
      thread_printf ("Internal cond mutex is not valid. this %p", this);
      magic = 0;
      return;
    }
  /*
   * Change the mutex type to NORMAL.
   * This mutex MUST be of type normal
  */
  mtx_in.set_type (PTHREAD_MUTEX_NORMAL);

  verifyable_mutex_obj = &mtx_out;
  if (!pthread_mutex::is_good_object (&verifyable_mutex_obj))
    {
      thread_printf ("Internal cond mutex is not valid. this %p", this);
      magic = 0;
      return;
    }
  /* Change the mutex type to NORMAL to speed up mutex operations */
  mtx_out.set_type (PTHREAD_MUTEX_NORMAL);

  sem_wait = ::CreateSemaphore (&sec_none_nih, 0, INT32_MAX, NULL);
  if (!sem_wait)
    {
      pthread_printf ("CreateSemaphore failed. %E");
      magic = 0;
      return;
    }

  conds.insert (this);
}

pthread_cond::~pthread_cond ()
{
  if (sem_wait)
    CloseHandle (sem_wait);

  conds.remove (this);
}

void
pthread_cond::unblock (const bool all)
{
  LONG releaseable;

  /*
   * Block outgoing threads (and avoid simultanous unblocks)
   */
  mtx_out.lock ();

  releaseable = waiting - pending;
  if (releaseable)
    {
      LONG released;

      if (!pending)
	{
	  /*
	   * Block incoming threads until all waiting threads are released.
	   */
	  mtx_in.lock ();

	  /*
	   * Calculate releaseable again because threads can enter until
	   * the semaphore has been taken, but they can not leave, therefore pending
	   * is unchanged and releaseable can only get higher
	   */
	  releaseable = waiting - pending;
	}

      released = all ? releaseable : 1;
      pending += released;
      /*
       * Signal threads
       */
      ::ReleaseSemaphore (sem_wait, released, NULL);
    }

  /*
   * And let the threads release.
   */
  mtx_out.unlock ();
}

int
pthread_cond::wait (pthread_mutex_t mutex, PLARGE_INTEGER timeout)
{
  DWORD rv;

  mtx_in.lock ();
  if (InterlockedIncrement (&waiting) == 1)
    mtx_cond = mutex;
  else if (mtx_cond != mutex)
    {
      InterlockedDecrement (&waiting);
      mtx_in.unlock ();
      return EINVAL;
    }
  mtx_in.unlock ();

  /*
   * Release the mutex and wait on semaphore
   */
  ++mutex->condwaits;
  mutex->unlock ();

  rv = cygwait (sem_wait, timeout, cw_cancel | cw_sig_eintr);

  mtx_out.lock ();

  if (rv != WAIT_OBJECT_0)
    {
      /*
       * It might happen that a signal is sent while the thread got canceled
       * or timed out. Try to take one.
       * If the thread gets one than a signal|broadcast is in progress.
       */
      if (WaitForSingleObject (sem_wait, 0) == WAIT_OBJECT_0)
	/*
	 * thread got cancelled ot timed out while a signalling is in progress.
	 * Set wait result back to signaled
	 */
	rv = WAIT_OBJECT_0;
    }

  InterlockedDecrement (&waiting);

  if (rv == WAIT_OBJECT_0 && --pending == 0)
    /*
     * All signaled threads are released,
     * new threads can enter Wait
     */
    mtx_in.unlock ();

  mtx_out.unlock ();

  mutex->lock ();
  --mutex->condwaits;

  if (rv == WAIT_CANCELED)
    pthread::static_cancel_self ();
  else if (rv == WAIT_SIGNALED)
    /* SUSv3 states:  If a signal is delivered to a thread waiting for a
       condition variable, upon return from the signal handler the thread
       resumes waiting for the condition variable as if it was not
       interrupted, or it shall return zero due to spurious wakeup.
       We opt for the latter choice here. */
    return 0;
  else if (rv == WAIT_TIMEOUT)
    return ETIMEDOUT;

  return 0;
}

void
pthread_cond::_fixup_after_fork ()
{
  waiting = pending = 0;
  mtx_cond = NULL;

  /* Unlock eventually locked mutexes */
  mtx_in.unlock ();
  mtx_out.unlock ();

  sem_wait = ::CreateSemaphore (&sec_none_nih, 0, INT32_MAX, NULL);
  if (!sem_wait)
    api_fatal ("pthread_cond::_fixup_after_fork () failed to recreate win32 semaphore");
}

pthread_rwlockattr::pthread_rwlockattr ():verifyable_object
  (PTHREAD_RWLOCKATTR_MAGIC), shared (PTHREAD_PROCESS_PRIVATE)
{
}

pthread_rwlockattr::~pthread_rwlockattr ()
{
}

List<pthread_rwlock> pthread_rwlock::rwlocks;

/* This is used for rwlock creation protection within a single process only */
fast_mutex NO_COPY pthread_rwlock::rwlock_initialization_lock;

/* We can only be called once.
   TODO: (no rush) use a non copied memory section to
   hold an initialization flag.  */
void
pthread_rwlock::init_mutex ()
{
  if (!rwlock_initialization_lock.init ())
    api_fatal ("Could not create win32 Mutex for pthread rwlock static initializer support.");
}

pthread_rwlock::pthread_rwlock (pthread_rwlockattr *attr) :
  verifyable_object (PTHREAD_RWLOCK_MAGIC),
  shared (0), waiting_readers (0), waiting_writers (0), writer (NULL),
  readers (NULL), readers_mx (), mtx (NULL), cond_readers (NULL), cond_writers (NULL),
  next (NULL)
{
  pthread_mutex *verifyable_mutex_obj = &mtx;
  pthread_cond *verifyable_cond_obj;

  if (!readers_mx.init ())
    {
      thread_printf ("Internal rwlock synchronisation mutex is not valid. this %p", this);
      magic = 0;
      return;
    }

  if (attr)
    if (attr->shared != PTHREAD_PROCESS_PRIVATE)
      {
	magic = 0;
	return;
      }

  if (!pthread_mutex::is_good_object (&verifyable_mutex_obj))
    {
      thread_printf ("Internal rwlock mutex is not valid. this %p", this);
      magic = 0;
      return;
    }
  /* Change the mutex type to NORMAL to speed up mutex operations */
  mtx.set_type (PTHREAD_MUTEX_NORMAL);

  verifyable_cond_obj = &cond_readers;
  if (!pthread_cond::is_good_object (&verifyable_cond_obj))
    {
      thread_printf ("Internal rwlock readers cond is not valid. this %p", this);
      magic = 0;
      return;
    }

  verifyable_cond_obj = &cond_writers;
  if (!pthread_cond::is_good_object (&verifyable_cond_obj))
    {
      thread_printf ("Internal rwlock writers cond is not valid. this %p", this);
      magic = 0;
      return;
    }


  rwlocks.insert (this);
}

pthread_rwlock::~pthread_rwlock ()
{
  rwlocks.remove (this);
}

int
pthread_rwlock::rdlock ()
{
  int result = 0;
  struct RWLOCK_READER *reader;

  mtx.lock ();

  reader = lookup_reader ();
  if (reader)
    {
      if (reader->n < UINT32_MAX)
	++reader->n;
      else
	errno = EAGAIN;
      goto DONE;
    }

  while (writer || waiting_writers)
    {
      pthread_cleanup_push (pthread_rwlock::rdlock_cleanup, this);

      ++waiting_readers;
      cond_readers.wait (&mtx);
      --waiting_readers;

      pthread_cleanup_pop (0);
    }

  if ((reader = add_reader ()))
    ++reader->n;
  else
    {
      result = EAGAIN;
      goto DONE;
    }

 DONE:
  mtx.unlock ();

  return result;
}

int
pthread_rwlock::tryrdlock ()
{
  int result = 0;

  mtx.lock ();

  if (writer || waiting_writers)
    result = EBUSY;
  else
    {
      RWLOCK_READER *reader = lookup_reader ();
      if (!reader)
	reader = add_reader ();
      if (reader && reader->n < UINT32_MAX)
	++reader->n;
      else
	result = EAGAIN;
    }

  mtx.unlock ();

  return result;
}

int
pthread_rwlock::wrlock ()
{
  int result = 0;
  pthread_t self = pthread::self ();

  mtx.lock ();

  if (writer == self || lookup_reader ())
    {
      result = EDEADLK;
      goto DONE;
    }

  while (writer || readers)
    {
      pthread_cleanup_push (pthread_rwlock::wrlock_cleanup, this);

      ++waiting_writers;
      cond_writers.wait (&mtx);
      --waiting_writers;

      pthread_cleanup_pop (0);
    }

  writer = self;

 DONE:
  mtx.unlock ();

  return result;
}

int
pthread_rwlock::trywrlock ()
{
  int result = 0;
  pthread_t self = pthread::self ();

  mtx.lock ();

  if (writer || readers)
    result = EBUSY;
  else
    writer = self;

  mtx.unlock ();

  return result;
}

int
pthread_rwlock::unlock ()
{
  int result = 0;

  mtx.lock ();

  if (writer)
    {
      if (writer != pthread::self ())
	{
	  result = EPERM;
	  goto DONE;
	}

      writer = NULL;
    }
  else
    {
      struct RWLOCK_READER *reader = lookup_reader ();

      if (!reader)
	{
	  result = EPERM;
	  goto DONE;
	}
      if (--reader->n > 0)
	goto DONE;

      remove_reader (reader);
      delete reader;
    }

  release ();

 DONE:
  mtx.unlock ();

  return result;
}

pthread_rwlock::RWLOCK_READER *
pthread_rwlock::add_reader ()
{
  RWLOCK_READER *rd = new RWLOCK_READER;
  if (rd)
    List_insert (readers, rd);
  return rd;
}

void
pthread_rwlock::remove_reader (struct RWLOCK_READER *rd)
{
  List_remove (readers_mx, readers, rd);
}

struct pthread_rwlock::RWLOCK_READER *
pthread_rwlock::lookup_reader ()
{
  readers_mx.lock ();
  pthread_t thread = pthread::self ();

  struct RWLOCK_READER *cur = readers;

  while (cur && cur->thread != thread)
    cur = cur->next;

  readers_mx.unlock ();

  return cur;
}

void
pthread_rwlock::rdlock_cleanup (void *arg)
{
  pthread_rwlock *rwlock = (pthread_rwlock *) arg;

  --(rwlock->waiting_readers);
  rwlock->release ();
  rwlock->mtx.unlock ();
}

void
pthread_rwlock::wrlock_cleanup (void *arg)
{
  pthread_rwlock *rwlock = (pthread_rwlock *) arg;

  --(rwlock->waiting_writers);
  rwlock->release ();
  rwlock->mtx.unlock ();
}

void
pthread_rwlock::_fixup_after_fork ()
{
  pthread_t self = pthread::self ();
  struct RWLOCK_READER **temp = &readers;

  waiting_readers = 0;
  waiting_writers = 0;

  if (!readers_mx.init ())
    api_fatal ("pthread_rwlock::_fixup_after_fork () failed to recreate mutex");

  /* Unlock eventually locked mutex */
  mtx.unlock ();
  /*
   * Remove all readers except self
   */
  while (*temp)
    {
      if ((*temp)->thread == self)
	temp = &((*temp)->next);
      else
	{
	  struct RWLOCK_READER *cur = *temp;
	  *temp = (*temp)->next;
	  delete cur;
	}
    }
}

/* pthread_key */
/* static members */
/* This stores pthread_key information across fork() boundaries */
List<pthread_key> pthread_key::keys;

/* non-static members */

pthread_key::pthread_key (void (*aDestructor) (void *)):verifyable_object (PTHREAD_KEY_MAGIC), destructor (aDestructor)
{
  tls_index = TlsAlloc ();
  if (tls_index == TLS_OUT_OF_INDEXES)
    magic = 0;
  else
    keys.insert (this);
}

pthread_key::~pthread_key ()
{
  /* We may need to make the list code lock the list during operations
   */
  if (magic != 0)
    {
      keys.remove (this);
      TlsFree (tls_index);
    }
}

void
pthread_key::_fixup_before_fork ()
{
  fork_buf = get ();
}

void
pthread_key::_fixup_after_fork ()
{
  tls_index = TlsAlloc ();
  if (tls_index == TLS_OUT_OF_INDEXES)
    api_fatal ("pthread_key::recreate_key_from_buffer () failed to reallocate Tls storage");
  set (fork_buf);
}

void
pthread_key::run_destructor ()
{
  if (destructor)
    {
      void *oldValue = get ();
      if (oldValue)
	{
	  set (NULL);
	  destructor (oldValue);
	}
    }
}

/* pshared mutexs */

/* static members */

List<pthread_mutex> pthread_mutex::mutexes;

/* This is used for mutex creation protection within a single process only */
fast_mutex NO_COPY pthread_mutex::mutex_initialization_lock;

void
pthread_mutex::init_mutex ()
{
  if (!mutex_initialization_lock.init ())
    api_fatal ("Could not create win32 Mutex for pthread mutex static initializer support.");
}

pthread_mutex::pthread_mutex (pthread_mutexattr *attr) :
  verifyable_object (0),	/* set magic to zero initially */
  lock_counter (0),
  win32_obj_id (NULL), owner (_new_mutex),
#ifdef DEBUGGING
  tid (0),
#endif
  recursion_counter (0), condwaits (0),
  type (PTHREAD_MUTEX_NORMAL),
  pshared (PTHREAD_PROCESS_PRIVATE)
{
  win32_obj_id = ::CreateEvent (&sec_none_nih, false, false, NULL);
  if (!win32_obj_id)
    return;
  /*attr checked in the C call */
  if (!attr)
    /* handled in the caller */;
  else if (attr->pshared != PTHREAD_PROCESS_SHARED)
    type = attr->mutextype;
  else
    return;		/* Not implemented */

  magic = PTHREAD_MUTEX_MAGIC;
  mutexes.insert (this);
}

pthread_mutex::~pthread_mutex ()
{
  if (win32_obj_id)
    {
      CloseHandle (win32_obj_id);
      win32_obj_id = NULL;
    }

  mutexes.remove (this);
  owner = _destroyed_mutex;
  magic = 0;
}

int
pthread_mutex::lock ()
{
  pthread_t self = ::pthread_self ();
  int result = 0;

  if (InterlockedIncrement (&lock_counter) == 1)
    set_owner (self);
  else if (type == PTHREAD_MUTEX_NORMAL /* potentially causes deadlock */
	   || !pthread::equal (owner, self))
    {
      cygwait (win32_obj_id, cw_infinite, cw_sig | cw_sig_restart);
      set_owner (self);
    }
  else
    {
      InterlockedDecrement (&lock_counter);
      if (type == PTHREAD_MUTEX_RECURSIVE)
	result = lock_recursive ();
      else
	result = EDEADLK;
    }

  pthread_printf ("mutex %p, self %p, owner %p, lock_counter %d, recursion_counter %u",
		  this, self, owner, lock_counter, recursion_counter);
  return result;
}

int
pthread_mutex::unlock ()
{
  int res = 0;
  pthread_t self = ::pthread_self ();
  if (type == PTHREAD_MUTEX_NORMAL)
    /* no error checking */;
  else if (no_owner ())
    res = type == PTHREAD_MUTEX_ERRORCHECK ? EPERM : 0;
  else if (!pthread::equal (owner, self))
    res = EPERM;
  if (!res && recursion_counter > 0 && --recursion_counter == 0)
    /* Don't try to unlock anything if recursion_counter == 0.
       This means the mutex was never locked or that we've forked. */
    {
      owner = (pthread_t) _unlocked_mutex;
#ifdef DEBUGGING
      tid = 0;		// thread-id
#endif
      if (InterlockedDecrement (&lock_counter))
	::SetEvent (win32_obj_id); // Another thread is waiting
      res = 0;
    }

  pthread_printf ("mutex %p, owner %p, self %p, lock_counter %d, recursion_counter %u, type %d, res %d",
		  this, owner, self, lock_counter, recursion_counter, type, res);
  return res;
}

int
pthread_mutex::trylock ()
{
  pthread_t self = ::pthread_self ();
  int result = 0;

  if (InterlockedCompareExchange (&lock_counter, 1, 0) == 0)
    set_owner (self);
  else if (type == PTHREAD_MUTEX_RECURSIVE && pthread::equal (owner, self))
    result = lock_recursive ();
  else
    result = EBUSY;

  return result;
}

int
pthread_mutex::destroy ()
{
  if (condwaits || trylock ())
    // Do not destroy a condwaited or locked mutex
    return EBUSY;
  else if (recursion_counter > 1)
    {
      // Do not destroy a recursive locked mutex
      recursion_counter--;
      return EBUSY;
    }

  delete this;
  return 0;
}

void
pthread_mutex::_fixup_after_fork ()
{
  pthread_printf ("mutex %p", this);
  if (pshared != PTHREAD_PROCESS_PRIVATE)
    api_fatal ("pthread_mutex::_fixup_after_fork () doesn't understand PROCESS_SHARED mutex's");

  /* All waiting threads are gone after a fork */
  recursion_counter = 0;
  lock_counter = 0;
  condwaits = 0;
#ifdef DEBUGGING
  tid = 0xffffffff;	/* Don't know the tid after a fork */
#endif
  win32_obj_id = ::CreateEvent (&sec_none_nih, false, false, NULL);
  if (!win32_obj_id)
    api_fatal ("pthread_mutex::_fixup_after_fork () failed to recreate win32 event for mutex");
}

pthread_mutexattr::pthread_mutexattr ():verifyable_object (PTHREAD_MUTEXATTR_MAGIC),
pshared (PTHREAD_PROCESS_PRIVATE), mutextype (PTHREAD_MUTEX_NORMAL)
{
}

pthread_mutexattr::~pthread_mutexattr ()
{
}

/* pshared spinlocks

   The infrastructure is provided by the underlying pthread_mutex class.
   The rest is a simplification implementing spin locking. */

pthread_spinlock::pthread_spinlock (int pshared) :
  pthread_mutex (NULL)
{
  magic = PTHREAD_SPINLOCK_MAGIC;
  set_type (PTHREAD_MUTEX_NORMAL);
  set_shared (pshared);
}

int
pthread_spinlock::lock ()
{
  pthread_t self = ::pthread_self ();
  int result = -1;

  do
    {
      if (InterlockedExchange (&lock_counter, 1) == 0)
	{
	  set_owner (self);
	  result = 0;
	}
      else if (pthread::equal (owner, self))
	result = EDEADLK;
      else
	{
	  /* Minimal timeout to minimize CPU usage while still spinning. */
	  LARGE_INTEGER timeout;
	  timeout.QuadPart = -10000LL;
	  /* FIXME: no cancel? */
	  cygwait (win32_obj_id, &timeout, cw_sig);
	}
    }
  while (result == -1);
  pthread_printf ("spinlock %p, self %p, owner %p", this, self, owner);
  return result;
}

int
pthread_spinlock::unlock ()
{
  pthread_t self = ::pthread_self ();
  int result = 0;

  if (!pthread::equal (owner, self))
    result = EPERM;
  else
    {
      owner = (pthread_t) _unlocked_mutex;
#ifdef DEBUGGING
      tid = 0;		// thread-id
#endif
      InterlockedExchange (&lock_counter, 0);
      ::SetEvent (win32_obj_id);
      result = 0;
    }
  pthread_printf ("spinlock %p, owner %p, self %p, res %d",
		  this, owner, self, result);
  return result;
}

DWORD WINAPI
pthread::thread_init_wrapper (void *arg)
{
  pthread *thread = (pthread *) arg;
  /* This *must* be set prior to calling set_tls_self_pointer or there is
     a race with the signal processing code which may miss the signal mask
     settings. */
  _my_tls.sigmask = thread->parent_sigmask;
  thread->set_tls_self_pointer ();

  thread->mutex.lock ();

  // if thread is detached force cleanup on exit
  if (thread->attr.joinable == PTHREAD_CREATE_DETACHED && thread->joiner == NULL)
    thread->joiner = thread;
  thread->mutex.unlock ();

  debug_printf ("tid %p", &_my_tls);
  thread_printf ("started thread %p %p %p %p %p %p", arg, &_my_tls.local_clib,
		 _impure_ptr, thread, thread->function, thread->arg);

  // call the user's thread
  void *ret = thread->function (thread->arg);

  thread->exit (ret);

  return 0;	// just for show.  Never returns.
}

unsigned long
pthread::getsequence_np ()
{
  return get_thread_id ();
}

int
pthread::create (pthread_t *thread, const pthread_attr_t *attr,
		  void *(*start_routine) (void *), void *arg)
{
  if (attr && !pthread_attr::is_good_object (attr))
    return EINVAL;

  *thread = new pthread ();
  if (!(*thread)->create (start_routine, attr ? *attr : NULL, arg))
    {
      delete (*thread);
      *thread = NULL;
      return EAGAIN;
    }

  return 0;
}

int
pthread::once (pthread_once_t *once_control, void (*init_routine) (void))
{
  // already done ?
  if (once_control->state)
    return 0;

  pthread_mutex_lock (&once_control->mutex);
  /* Here we must set a cancellation handler to unlock the mutex if needed */
  /* but a cancellation handler is not the right thing. We need this in the thread
   *cleanup routine. Assumption: a thread can only be in one pthread_once routine
   *at a time. Stote a mutex_t *in the pthread_structure. if that's non null unlock
   *on pthread_exit ();
   */
  if (!once_control->state)
    {
      init_routine ();
      once_control->state = 1;
    }
  /* Here we must remove our cancellation handler */
  pthread_mutex_unlock (&once_control->mutex);
  return 0;
}

int
pthread::cancel (pthread_t thread)
{
  if (!is_good_object (&thread))
    return ESRCH;

  return thread->cancel ();
}

void
pthread::atforkprepare ()
{
  callback *cb = MT_INTERFACE->pthread_prepare;
  while (cb)
    {
      cb->cb ();
      cb = cb->next;
    }

  __fp_lock_all ();

  MT_INTERFACE->fixup_before_fork ();
}

void
pthread::atforkparent ()
{
  __fp_unlock_all ();

  callback *cb = MT_INTERFACE->pthread_parent;
  while (cb)
    {
      cb->cb ();
      cb = cb->next;
    }
}

void
pthread::atforkchild ()
{
  MT_INTERFACE->fixup_after_fork ();

  __fp_unlock_all ();

  callback *cb = MT_INTERFACE->pthread_child;
  while (cb)
    {
      cb->cb ();
      cb = cb->next;
    }
}

/* Register a set of functions to run before and after fork.
   prepare calls are called in LI-FC order.
   parent and child calls are called in FI-FC order.  */
int
pthread::atfork (void (*prepare)(void), void (*parent)(void), void (*child)(void))
{
  callback *prepcb = NULL, *parentcb = NULL, *childcb = NULL;
  if (prepare)
    {
      prepcb = new callback;
      if (!prepcb)
	return ENOMEM;
    }
  if (parent)
    {
      parentcb = new callback;
      if (!parentcb)
	{
	  if (prepcb)
	    delete prepcb;
	  return ENOMEM;
	}
    }
  if (child)
    {
      childcb = new callback;
      if (!childcb)
	{
	  if (prepcb)
	    delete prepcb;
	  if (parentcb)
	    delete parentcb;
	  return ENOMEM;
	}
    }

  if (prepcb)
  {
    prepcb->cb = prepare;
    List_insert (MT_INTERFACE->pthread_prepare, prepcb);
  }
  if (parentcb)
  {
    parentcb->cb = parent;
    callback **t = &MT_INTERFACE->pthread_parent;
    while (*t)
      t = &(*t)->next;
    /* t = pointer to last next in the list */
    List_insert (*t, parentcb);
  }
  if (childcb)
  {
    childcb->cb = child;
    callback **t = &MT_INTERFACE->pthread_child;
    while (*t)
      t = &(*t)->next;
    /* t = pointer to last next in the list */
    List_insert (*t, childcb);
  }
  return 0;
}

extern "C" int
pthread_attr_init (pthread_attr_t *attr)
{
  if (pthread_attr::is_good_object (attr))
    return EBUSY;

  *attr = new pthread_attr;
  if (!pthread_attr::is_good_object (attr))
    {
      delete (*attr);
      *attr = NULL;
      return ENOMEM;
    }
  return 0;
}

extern "C" int
pthread_attr_getinheritsched (const pthread_attr_t *attr,
				int *inheritsched)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  *inheritsched = (*attr)->inheritsched;
  return 0;
}

extern "C" int
pthread_attr_getschedparam (const pthread_attr_t *attr,
			      struct sched_param *param)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  *param = (*attr)->schedparam;
  return 0;
}

/* From a pure code point of view, this should call a helper in sched.cc,
   to allow for someone adding scheduler policy changes to win32 in the future.
   However that's extremely unlikely, so short and sweet will do us */
extern "C" int
pthread_attr_getschedpolicy (const pthread_attr_t *attr, int *policy)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  *policy = SCHED_FIFO;
  return 0;
}


extern "C" int
pthread_attr_getscope (const pthread_attr_t *attr, int *contentionscope)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  *contentionscope = (*attr)->contentionscope;
  return 0;
}

extern "C" int
pthread_attr_setdetachstate (pthread_attr_t *attr, int detachstate)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  if (detachstate < 0 || detachstate > 1)
    return EINVAL;
  (*attr)->joinable = detachstate;
  return 0;
}

extern "C" int
pthread_attr_getdetachstate (const pthread_attr_t *attr, int *detachstate)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  *detachstate = (*attr)->joinable;
  return 0;
}

extern "C" int
pthread_attr_setinheritsched (pthread_attr_t *attr, int inheritsched)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  if (inheritsched != PTHREAD_INHERIT_SCHED
      && inheritsched != PTHREAD_EXPLICIT_SCHED)
    return ENOTSUP;
  (*attr)->inheritsched = inheritsched;
  return 0;
}

extern "C" int
pthread_attr_setschedparam (pthread_attr_t *attr,
			      const struct sched_param *param)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  if (!valid_sched_parameters (param))
    return ENOTSUP;
  (*attr)->schedparam = *param;
  return 0;
}

/* See __pthread_attr_getschedpolicy for some notes */
extern "C" int
pthread_attr_setschedpolicy (pthread_attr_t *attr, int policy)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  if (policy != SCHED_FIFO)
    return ENOTSUP;
  return 0;
}

extern "C" int
pthread_attr_setscope (pthread_attr_t *attr, int contentionscope)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  if (contentionscope != PTHREAD_SCOPE_SYSTEM
      && contentionscope != PTHREAD_SCOPE_PROCESS)
    return EINVAL;
  /* In future, we may be able to support system scope by escalating the thread
     priority to exceed the priority class. For now we only support PROCESS scope. */
  if (contentionscope != PTHREAD_SCOPE_PROCESS)
    return ENOTSUP;
  (*attr)->contentionscope = contentionscope;
  return 0;
}

extern "C" int
pthread_attr_setstack (pthread_attr_t *attr, void *addr, size_t size)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  if (addr == NULL)
    return EINVAL;
  if (size < PTHREAD_STACK_MIN)
    return EINVAL;
  /* The incoming address addr points to the lowest addressable byte of a
     buffer of size bytes.  Due to the way pthread_attr_setstackaddr is defined
     on Linux, the lowest address ot the stack can't be reliably computed when
     using pthread_attr_setstackaddr/pthread_attr_setstacksize.  Therefore we
     store the uppermost address of the stack in stackaddr.  See also the
     comment in pthread_attr_setstackaddr. */
  (*attr)->stackaddr = (caddr_t) addr + size;
  (*attr)->stacksize = size;
  return 0;
}

extern "C" int
pthread_attr_getstack (const pthread_attr_t *attr, void **addr, size_t *size)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  /* stackaddr holds the uppermost stack address.  See the comment in
     pthread_attr_setstack. */
  *addr = (caddr_t) (*attr)->stackaddr - (*attr)->stacksize;
  *size = (*attr)->stacksize;
  return 0;
}

extern "C" int
pthread_attr_setstackaddr (pthread_attr_t *attr, void *addr)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  if (addr == NULL)
    return EINVAL;
  /* This function is deprecated in SUSv4, but SUSv3 didn't define
     if the incoming stack address is the lowest address of the memory
     area defined as stack, or if it's the start address of the stack
     at which it begins its growth.  On Linux it's the latter which
     means the uppermost stack address on x86 based systems.  See comment
     in pthread_attr_setstack as well. */
  (*attr)->stackaddr = addr;
  return 0;
}

extern "C" int
pthread_attr_getstackaddr (const pthread_attr_t *attr, void **addr)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  /* See comment in pthread_attr_setstackaddr. */
  *addr = (*attr)->stackaddr;
  return 0;
}

extern "C" int
pthread_attr_setstacksize (pthread_attr_t *attr, size_t size)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  if (size < PTHREAD_STACK_MIN)
    return EINVAL;
  (*attr)->stacksize = size;
  return 0;
}

extern "C" int
pthread_attr_getstacksize (const pthread_attr_t *attr, size_t *size)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  /* If the stacksize has not been set by the application, return the
     default stacksize.  Note that this is different from what
     pthread_attr_getstack returns. */
  *size = (*attr)->stacksize ?: PTHREAD_DEFAULT_STACKSIZE;
  return 0;
}

extern "C" int
pthread_attr_setguardsize (pthread_attr_t *attr, size_t size)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  /* We don't support a guardsize of more than 1 Meg. */
  if (size > 1024 * 1024)
    return EINVAL;
  (*attr)->guardsize = size;
  return 0;
}

extern "C" int
pthread_attr_getguardsize (const pthread_attr_t *attr, size_t *size)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  *size = (*attr)->guardsize;
  return 0;
}

extern "C" int
pthread_attr_destroy (pthread_attr_t *attr)
{
  if (!pthread_attr::is_good_object (attr))
    return EINVAL;
  delete (*attr);
  *attr = NULL;
  return 0;
}

int
pthread::join (pthread_t *thread, void **return_val)
{
   pthread_t joiner = self ();

   joiner->testcancel ();

   // Initialize return val with NULL
   if (return_val)
     *return_val = NULL;

   if (!is_good_object (&joiner))
     return EINVAL;

  if (!is_good_object (thread))
    return ESRCH;

  if (equal (*thread,joiner))
    return EDEADLK;

  (*thread)->mutex.lock ();

  if ((*thread)->attr.joinable == PTHREAD_CREATE_DETACHED)
    {
      (*thread)->mutex.unlock ();
      return EINVAL;
    }
  else
    {
      (*thread)->joiner = joiner;
      (*thread)->attr.joinable = PTHREAD_CREATE_DETACHED;
      (*thread)->mutex.unlock ();

      switch (cygwait ((*thread)->win32_obj_id, cw_infinite,
		       cw_sig | cw_sig_restart | cw_cancel))
	{
	case WAIT_OBJECT_0:
	  if (return_val)
	    *return_val = (*thread)->return_ptr;
	  delete (*thread);
	  break;
	case WAIT_CANCELED:
	  // set joined thread back to joinable since we got canceled
	  (*thread)->joiner = NULL;
	  (*thread)->attr.joinable = PTHREAD_CREATE_JOINABLE;
	  joiner->cancel_self ();
	  // never reached
	  break;
	default:
	  // should never happen
	  return EINVAL;
	}
    }

  return 0;
}

int
pthread::detach (pthread_t *thread)
{
  if (!is_good_object (thread))
    return ESRCH;

  (*thread)->mutex.lock ();
  if ((*thread)->attr.joinable == PTHREAD_CREATE_DETACHED)
    {
      (*thread)->mutex.unlock ();
      return EINVAL;
    }

  // check if thread is still alive
  if ((*thread)->valid && WaitForSingleObject ((*thread)->win32_obj_id, 0) == WAIT_TIMEOUT)
    {
      // force cleanup on exit
      (*thread)->joiner = *thread;
      (*thread)->attr.joinable = PTHREAD_CREATE_DETACHED;
      (*thread)->mutex.unlock ();
    }
  else
    {
      // thread has already terminated.
      (*thread)->mutex.unlock ();
      delete (*thread);
    }

  return 0;
}

int
pthread::suspend (pthread_t *thread)
{
  if (!is_good_object (thread))
    return ESRCH;

  if ((*thread)->suspended == false)
    {
      (*thread)->suspended = true;
      SuspendThread ((*thread)->win32_obj_id);
    }

  return 0;
}


int
pthread::resume (pthread_t *thread)
{
  if (!is_good_object (thread))
    return ESRCH;

  if ((*thread)->suspended == true)
    ResumeThread ((*thread)->win32_obj_id);
  (*thread)->suspended = false;

  return 0;
}

extern "C" int
pthread_getattr_np (pthread_t thread, pthread_attr_t *attr)
{
  const size_t sizeof_tbi = sizeof (THREAD_BASIC_INFORMATION);
  PTHREAD_BASIC_INFORMATION tbi;
  NTSTATUS status;

  if (!pthread::is_good_object (&thread))
    return ESRCH;

  /* attr may not be pre-initialized */
  if (!pthread_attr::is_good_object (attr))
  {
    int rv = pthread_attr_init (attr);
    if (rv != 0)
      return rv;
  }

  (*attr)->joinable = thread->attr.joinable;
  (*attr)->contentionscope = thread->attr.contentionscope;
  (*attr)->inheritsched = thread->attr.inheritsched;
  (*attr)->schedparam = thread->attr.schedparam;
  (*attr)->guardsize = thread->attr.guardsize;

  tbi = (PTHREAD_BASIC_INFORMATION) malloc (sizeof_tbi);
  status = NtQueryInformationThread (thread->win32_obj_id,
				     ThreadBasicInformation,
				     tbi, sizeof_tbi, NULL);
  if (NT_SUCCESS (status))
    {
      PTEB teb = (PTEB) tbi->TebBaseAddress;
      /* stackaddr holds the uppermost stack address.  See the comments
	 in pthread_attr_setstack and pthread_attr_setstackaddr for a
	 description. */
      (*attr)->stackaddr = teb->Tib.StackBase;
      (*attr)->stacksize = (uintptr_t) teb->Tib.StackBase
	       - (uintptr_t) (teb->DeallocationStack ?: teb->Tib.StackLimit);
    }
  else
    {
      debug_printf ("NtQueryInformationThread(ThreadBasicInformation), "
		    "status %y", status);
      (*attr)->stackaddr = thread->attr.stackaddr;
      (*attr)->stacksize = thread->attr.stacksize;
    }

  return 0;
}

/* provided for source level compatability.
   See http://www.opengroup.org/onlinepubs/007908799/xsh/pthread_getconcurrency.html
*/
extern "C" int
pthread_getconcurrency ()
{
  return MT_INTERFACE->concurrency;
}

extern "C" int
pthread_getcpuclockid (pthread_t thread, clockid_t *clk_id)
{
  if (!pthread::is_good_object (&thread))
    return (ESRCH);
  *clk_id = (clockid_t) THREADID_TO_CLOCKID (thread->getsequence_np ());
  return 0;
}

/* keep this in sync with sched.cc */
extern "C" int
pthread_getschedparam (pthread_t thread, int *policy,
			 struct sched_param *param)
{
  if (!pthread::is_good_object (&thread))
    return ESRCH;
  *policy = SCHED_FIFO;
  /* we don't return the current effective priority, we return the current
     requested priority */
  *param = thread->attr.schedparam;
  return 0;
}

/* Thread Specific Data */
extern "C" int
pthread_key_create (pthread_key_t *key, void (*destructor) (void *))
{
  *key = new pthread_key (destructor);

  if (!pthread_key::is_good_object (key))
    {
      delete (*key);
      *key = NULL;
      return EAGAIN;
    }
  return 0;
}

extern "C" int
pthread_key_delete (pthread_key_t key)
{
  if (!pthread_key::is_good_object (&key))
    return EINVAL;

  delete (key);
  return 0;
}

/* provided for source level compatability.  See
http://www.opengroup.org/onlinepubs/007908799/xsh/pthread_getconcurrency.html
*/
extern "C" int
pthread_setconcurrency (int new_level)
{
  if (new_level < 0)
    return EINVAL;
  MT_INTERFACE->concurrency = new_level;
  return 0;
}

/* keep syncronised with sched.cc */
extern "C" int
pthread_setschedparam (pthread_t thread, int policy,
			 const struct sched_param *param)
{
  if (!pthread::is_good_object (&thread))
    return ESRCH;
  if (policy != SCHED_FIFO)
    return ENOTSUP;
  if (!param)
    return EINVAL;
  int rv =
    sched_set_thread_priority (thread->win32_obj_id, param->sched_priority);
  if (!rv)
    thread->attr.schedparam.sched_priority = param->sched_priority;
  return rv;
}

extern "C" int
pthread_setschedprio (pthread_t thread, int priority)
{
  if (!pthread::is_good_object (&thread))
    return ESRCH;
  int rv =
    sched_set_thread_priority (thread->win32_obj_id, priority);
  if (!rv)
    thread->attr.schedparam.sched_priority = priority;
  return rv;
}

extern "C" int
pthread_setspecific (pthread_key_t key, const void *value)
{
  if (!pthread_key::is_good_object (&key))
    return EINVAL;
  (key)->set (value);
  return 0;
}

extern "C" void *
pthread_getspecific (pthread_key_t key)
{
  if (!pthread_key::is_good_object (&key))
    return NULL;

  return (key)->get ();

}

extern "C" int
pthread_cond_destroy (pthread_cond_t *cond)
{
  if (pthread_cond::is_initializer (cond))
    return 0;
  if (!pthread_cond::is_good_object (cond))
    return EINVAL;

  /* reads are atomic */
  if ((*cond)->waiting)
    return EBUSY;

  delete (*cond);
  *cond = NULL;

  return 0;
}

int
pthread_cond::init (pthread_cond_t *cond, const pthread_condattr_t *attr)
{
  pthread_cond_t new_cond;

  if (attr && !pthread_condattr::is_good_object (attr))
    return EINVAL;

  cond_initialization_lock.lock ();

  new_cond = new pthread_cond (attr ? (*attr) : NULL);
  if (!is_good_object (&new_cond))
    {
      delete new_cond;
      cond_initialization_lock.unlock ();
      return EAGAIN;
    }

  int ret = 0;

  __try
    {
      *cond = new_cond;
    }
  __except (NO_ERROR)
    {
      delete new_cond;
      ret = EINVAL;
    }
  __endtry
  cond_initialization_lock.unlock ();
  return ret;
}

extern "C" int
pthread_cond_broadcast (pthread_cond_t *cond)
{
  if (pthread_cond::is_initializer (cond))
    return 0;
  if (!pthread_cond::is_good_object (cond))
    return EINVAL;

  (*cond)->unblock (true);

  return 0;
}

extern "C" int
pthread_cond_signal (pthread_cond_t *cond)
{
  if (pthread_cond::is_initializer (cond))
    return 0;
  if (!pthread_cond::is_good_object (cond))
    return EINVAL;

  (*cond)->unblock (false);

  return 0;
}

static int
__pthread_cond_wait_init (pthread_cond_t *cond, pthread_mutex_t *mutex)
{
  if (!pthread_mutex::is_good_object (mutex))
    return EINVAL;
  if (!(*mutex)->can_be_unlocked ())
    return EPERM;

  if (pthread_cond::is_initializer (cond))
    pthread_cond::init (cond, NULL);
  if (!pthread_cond::is_good_object (cond))
    return EINVAL;

  return 0;
}

extern "C" int
pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex,
			const struct timespec *abstime)
{
  struct timespec tp;
  LARGE_INTEGER timeout;

  pthread_testcancel ();

  __try
    {
      int err = __pthread_cond_wait_init (cond, mutex);
      if (err)
	return err;

      /* According to SUSv3, the abstime value must be checked for validity. */
      if (abstime->tv_sec < 0
	  || abstime->tv_nsec < 0
	  || abstime->tv_nsec > 999999999)
	__leave;

      clock_gettime ((*cond)->clock_id, &tp);

      /* Check for immediate timeout before converting */
      if (tp.tv_sec > abstime->tv_sec
	  || (tp.tv_sec == abstime->tv_sec
	      && tp.tv_nsec > abstime->tv_nsec))
	return ETIMEDOUT;

      timeout.QuadPart = abstime->tv_sec * NSPERSEC
			  + (abstime->tv_nsec + 99LL) / 100LL;

      switch ((*cond)->clock_id)
	{
	case CLOCK_REALTIME:
	  timeout.QuadPart += FACTOR;
	  break;
	default:
	  /* other clocks must be handled as relative timeout */
	  timeout.QuadPart -= tp.tv_sec * NSPERSEC + tp.tv_nsec / 100LL;
	  timeout.QuadPart *= -1LL;
	  break;
	}
      return (*cond)->wait (*mutex, &timeout);
    }
  __except (NO_ERROR) {}
  __endtry
  return EINVAL;
}

extern "C" int
pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex)
{
  pthread_testcancel ();

  int err = __pthread_cond_wait_init (cond, mutex);
  if (err)
    return err;
  return (*cond)->wait (*mutex, NULL);
}

extern "C" int
pthread_condattr_init (pthread_condattr_t *condattr)
{
  if (pthread_condattr::is_good_object (condattr))
    return EBUSY;

  *condattr = new pthread_condattr;
  if (!pthread_condattr::is_good_object (condattr))
    {
      delete (*condattr);
      *condattr = NULL;
      return ENOMEM;
    }
  return 0;
}

extern "C" int
pthread_condattr_getpshared (const pthread_condattr_t *attr, int *pshared)
{
  if (!pthread_condattr::is_good_object (attr))
    return EINVAL;
  *pshared = (*attr)->shared;
  return 0;
}

extern "C" int
pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared)
{
  if (!pthread_condattr::is_good_object (attr))
    return EINVAL;
  if ((pshared < 0) || (pshared > 1))
    return EINVAL;
  /* shared cond vars not currently supported */
  if (pshared != PTHREAD_PROCESS_PRIVATE)
    return EINVAL;
  (*attr)->shared = pshared;
  return 0;
}

extern "C" int
pthread_condattr_getclock (const pthread_condattr_t *attr, clockid_t *clock_id)
{
  if (!pthread_condattr::is_good_object (attr))
    return EINVAL;
  *clock_id = (*attr)->clock_id;
  return 0;
}

extern "C" int
pthread_condattr_setclock (pthread_condattr_t *attr, clockid_t clock_id)
{
  if (!pthread_condattr::is_good_object (attr))
    return EINVAL;
  switch (clock_id)
    {
    case CLOCK_REALTIME:
    case CLOCK_MONOTONIC:
      break;
    default:
      return EINVAL;
    }
  (*attr)->clock_id = clock_id;
  return 0;
}

extern "C" int
pthread_condattr_destroy (pthread_condattr_t *condattr)
{
  if (!pthread_condattr::is_good_object (condattr))
    return EINVAL;
  delete (*condattr);
  *condattr = NULL;
  return 0;
}

extern "C" int
pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
{
  if (pthread_rwlock::is_initializer (rwlock))
    return 0;
  if (!pthread_rwlock::is_good_object (rwlock))
    return EINVAL;

  if ((*rwlock)->writer || (*rwlock)->readers ||
      (*rwlock)->waiting_readers || (*rwlock)->waiting_writers)
    return EBUSY;

  delete (*rwlock);
  *rwlock = NULL;

  return 0;
}

int
pthread_rwlock::init (pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr)
{
  pthread_rwlock_t new_rwlock;

  if (attr && !pthread_rwlockattr::is_good_object (attr))
    return EINVAL;

  rwlock_initialization_lock.lock ();

  new_rwlock = new pthread_rwlock (attr ? (*attr) : NULL);
  if (!is_good_object (&new_rwlock))
    {
      delete new_rwlock;
      rwlock_initialization_lock.unlock ();
      return EAGAIN;
    }

  int ret = 0;

  __try
    {
      *rwlock = new_rwlock;
    }
  __except (NO_ERROR)
    {
      delete new_rwlock;
      ret = EINVAL;
    }
  __endtry
  rwlock_initialization_lock.unlock ();
  return ret;
}

extern "C" int
pthread_rwlock_rdlock (pthread_rwlock_t *rwlock)
{
  pthread_testcancel ();

  if (pthread_rwlock::is_initializer (rwlock))
    pthread_rwlock::init (rwlock, NULL);
  if (!pthread_rwlock::is_good_object (rwlock))
    return EINVAL;

  return (*rwlock)->rdlock ();
}

extern "C" int
pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock)
{
  if (pthread_rwlock::is_initializer (rwlock))
    pthread_rwlock::init (rwlock, NULL);
  if (!pthread_rwlock::is_good_object (rwlock))
    return EINVAL;

  return (*rwlock)->tryrdlock ();
}

extern "C" int
pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
{
  pthread_testcancel ();

  if (pthread_rwlock::is_initializer (rwlock))
    pthread_rwlock::init (rwlock, NULL);
  if (!pthread_rwlock::is_good_object (rwlock))
    return EINVAL;

  return (*rwlock)->wrlock ();
}

extern "C" int
pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock)
{
  if (pthread_rwlock::is_initializer (rwlock))
    pthread_rwlock::init (rwlock, NULL);
  if (!pthread_rwlock::is_good_object (rwlock))
    return EINVAL;

  return (*rwlock)->trywrlock ();
}

extern "C" int
pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
{
  if (pthread_rwlock::is_initializer (rwlock))
    return 0;
  if (!pthread_rwlock::is_good_object (rwlock))
    return EINVAL;

  return (*rwlock)->unlock ();
}

extern "C" int
pthread_rwlockattr_init (pthread_rwlockattr_t *rwlockattr)
{
  if (pthread_rwlockattr::is_good_object (rwlockattr))
    return EBUSY;

  *rwlockattr = new pthread_rwlockattr;
  if (!pthread_rwlockattr::is_good_object (rwlockattr))
    {
      delete (*rwlockattr);
      *rwlockattr = NULL;
      return ENOMEM;
    }
  return 0;
}

extern "C" int
pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr, int *pshared)
{
  if (!pthread_rwlockattr::is_good_object (attr))
    return EINVAL;
  *pshared = (*attr)->shared;
  return 0;
}

extern "C" int
pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared)
{
  if (!pthread_rwlockattr::is_good_object (attr))
    return EINVAL;
  if ((pshared < 0) || (pshared > 1))
    return EINVAL;
  /* shared rwlock vars not currently supported */
  if (pshared != PTHREAD_PROCESS_PRIVATE)
    return EINVAL;
  (*attr)->shared = pshared;
  return 0;
}

extern "C" int
pthread_rwlockattr_destroy (pthread_rwlockattr_t *rwlockattr)
{
  if (!pthread_rwlockattr::is_good_object (rwlockattr))
    return EINVAL;
  delete (*rwlockattr);
  *rwlockattr = NULL;
  return 0;
}

/* Thread signal */
extern "C" int
pthread_kill (pthread_t thread, int sig)
{
  // lock myself, for the use of thread2signal
  // two different kills might clash: FIXME

  if (!pthread::is_good_object (&thread))
    return EINVAL;

  siginfo_t si = {0};
  si.si_signo = sig;
  si.si_code = SI_USER;
  si.si_pid = myself->pid;
  si.si_uid = myself->uid;
  int rval;
  if (!thread->valid)
    rval = ESRCH;
  else if (sig)
    rval = sig_send (NULL, si, thread->cygtls);
  else
    switch (WaitForSingleObject (thread->win32_obj_id, 0))
      {
      case WAIT_TIMEOUT:
	rval = 0;
	break;
      default:
	rval = ESRCH;
	break;
      }

  // unlock myself
  return rval;
}

extern "C" int
pthread_sigmask (int operation, const sigset_t *set, sigset_t *old_set)
{
  int res = handle_sigprocmask (operation, set, old_set, _my_tls.sigmask);
  syscall_printf ("%d = pthread_sigmask(%d, %p, %p)",
		  res, operation, set, old_set);
  return res;
}

extern "C" int
pthread_sigqueue (pthread_t *thread, int sig, const union sigval value)
{
  siginfo_t si = {0};

  if (!pthread::is_good_object (thread))
    return EINVAL;
  if (!(*thread)->valid)
    return ESRCH;

  si.si_signo = sig;
  si.si_code = SI_QUEUE;
  si.si_value = value;
  si.si_pid = myself->pid;
  si.si_uid = myself->uid;
  return sig_send (NULL, si, (*thread)->cygtls);
}

/* ID */

extern "C" int
pthread_equal (pthread_t t1, pthread_t t2)
{
  return pthread::equal (t1, t2);
}

/* Mutexes  */

int
pthread_mutex::init (pthread_mutex_t *mutex,
		     const pthread_mutexattr_t *attr,
		     const pthread_mutex_t initializer)
{
  if (attr && !pthread_mutexattr::is_good_object (attr))
    return EINVAL;

  mutex_initialization_lock.lock ();
  if (initializer == NULL || pthread_mutex::is_initializer (mutex))
    {
      pthread_mutex_t new_mutex = new pthread_mutex (attr ? (*attr) : NULL);
      if (!is_good_object (&new_mutex))
	{
	  delete new_mutex;
	  mutex_initialization_lock.unlock ();
	  return EAGAIN;
	}

      if (!attr && initializer)
	{
	  if (initializer == PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)
	    new_mutex->type = PTHREAD_MUTEX_RECURSIVE;
	  else if (initializer == PTHREAD_NORMAL_MUTEX_INITIALIZER_NP)
	    new_mutex->type = PTHREAD_MUTEX_NORMAL;
	  else if (initializer == PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP)
	    new_mutex->type = PTHREAD_MUTEX_ERRORCHECK;
	}

      __try
	{
	  *mutex = new_mutex;
	}
      __except (NO_ERROR)
	{
	  delete new_mutex;
	  mutex_initialization_lock.unlock ();
	  return EINVAL;
	}
      __endtry
    }
  mutex_initialization_lock.unlock ();
  pthread_printf ("*mutex %p, attr %p, initializer %p", *mutex, attr, initializer);

  return 0;
}

extern "C" int
pthread_mutex_getprioceiling (const pthread_mutex_t *mutex,
				int *prioceiling)
{
  /* We don't define _POSIX_THREAD_PRIO_PROTECT because we do't currently support
     mutex priorities.

     We can support mutex priorities in the future though:
     Store a priority with each mutex.
     When the mutex is optained, set the thread priority as appropriate
     When the mutex is released, reset the thread priority.  */
  return ENOSYS;
}

extern "C" int
pthread_mutex_lock (pthread_mutex_t *mutex)
{
  if (pthread_mutex::is_initializer (mutex))
    pthread_mutex::init (mutex, NULL, *mutex);
  if (!pthread_mutex::is_good_object (mutex))
    return EINVAL;
  return (*mutex)->lock ();
}

extern "C" int
pthread_mutex_trylock (pthread_mutex_t *mutex)
{
  if (pthread_mutex::is_initializer (mutex))
    pthread_mutex::init (mutex, NULL, *mutex);
  if (!pthread_mutex::is_good_object (mutex))
    return EINVAL;
  return (*mutex)->trylock ();
}

extern "C" int
pthread_mutex_unlock (pthread_mutex_t *mutex)
{
  if (pthread_mutex::is_initializer (mutex))
    pthread_mutex::init (mutex, NULL, *mutex);
  if (!pthread_mutex::is_good_object (mutex))
    return EINVAL;
  return (*mutex)->unlock ();
}

extern "C" int
pthread_mutex_destroy (pthread_mutex_t *mutex)
{
  int rv;

  if (pthread_mutex::is_initializer (mutex))
    return 0;
  if (!pthread_mutex::is_good_object (mutex))
    return EINVAL;

  rv = (*mutex)->destroy ();
  if (rv)
    return rv;

  *mutex = NULL;
  return 0;
}

extern "C" int
pthread_mutex_setprioceiling (pthread_mutex_t *mutex, int prioceiling,
				int *old_ceiling)
{
  return ENOSYS;
}

/* Spinlocks  */

int
pthread_spinlock::init (pthread_spinlock_t *spinlock, int pshared)
{
  pthread_spinlock_t new_spinlock = new pthread_spinlock (pshared);
  if (!is_good_object (&new_spinlock))
    {
      delete new_spinlock;
      return EAGAIN;
    }

  __try
    {
      *spinlock = new_spinlock;
    }
  __except (NO_ERROR)
    {
      delete new_spinlock;
      return EINVAL;
    }
  __endtry
  pthread_printf ("*spinlock %p, pshared %d", *spinlock, pshared);
  return 0;
}

extern "C" int
pthread_spin_lock (pthread_spinlock_t *spinlock)
{
  if (!pthread_spinlock::is_good_object (spinlock))
    return EINVAL;
  return (*spinlock)->lock ();
}

extern "C" int
pthread_spin_trylock (pthread_spinlock_t *spinlock)
{
  if (!pthread_spinlock::is_good_object (spinlock))
    return EINVAL;
  return (*spinlock)->trylock ();
}

extern "C" int
pthread_spin_unlock (pthread_spinlock_t *spinlock)
{
  if (!pthread_spinlock::is_good_object (spinlock))
    return EINVAL;
  return (*spinlock)->unlock ();
}

extern "C" int
pthread_spin_destroy (pthread_spinlock_t *spinlock)
{
  if (!pthread_spinlock::is_good_object (spinlock))
    return EINVAL;
  return (*spinlock)->destroy ();
}

/* Win32 doesn't support mutex priorities - see __pthread_mutex_getprioceiling
   for more detail */
extern "C" int
pthread_mutexattr_getprotocol (const pthread_mutexattr_t *attr,
				 int *protocol)
{
  if (!pthread_mutexattr::is_good_object (attr))
    return EINVAL;
  return ENOSYS;
}

extern "C" int
pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr,
				int *pshared)
{
  if (!pthread_mutexattr::is_good_object (attr))
    return EINVAL;
  *pshared = (*attr)->pshared;
  return 0;
}

extern "C" int
pthread_mutexattr_gettype (const pthread_mutexattr_t *attr, int *type)
{
  if (!pthread_mutexattr::is_good_object (attr))
    return EINVAL;
  *type = (*attr)->mutextype;
  return 0;
}

/* FIXME: write and test process shared mutex's.  */
extern "C" int
pthread_mutexattr_init (pthread_mutexattr_t *attr)
{
  if (pthread_mutexattr::is_good_object (attr))
    return EBUSY;

  *attr = new pthread_mutexattr ();
  if (!pthread_mutexattr::is_good_object (attr))
    {
      delete (*attr);
      *attr = NULL;
      return ENOMEM;
    }
  return 0;
}

extern "C" int
pthread_mutexattr_destroy (pthread_mutexattr_t *attr)
{
  if (!pthread_mutexattr::is_good_object (attr))
    return EINVAL;
  delete (*attr);
  *attr = NULL;
  return 0;
}


/* Win32 doesn't support mutex priorities */
extern "C" int
pthread_mutexattr_setprotocol (pthread_mutexattr_t *attr, int protocol)
{
  if (!pthread_mutexattr::is_good_object (attr))
    return EINVAL;
  return ENOSYS;
}

/* Win32 doesn't support mutex priorities */
extern "C" int
pthread_mutexattr_setprioceiling (pthread_mutexattr_t *attr,
				    int prioceiling)
{
  if (!pthread_mutexattr::is_good_object (attr))
    return EINVAL;
  return ENOSYS;
}

extern "C" int
pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *attr,
				    int *prioceiling)
{
  if (!pthread_mutexattr::is_good_object (attr))
    return EINVAL;
  return ENOSYS;
}

extern "C" int
pthread_mutexattr_setpshared (pthread_mutexattr_t *attr, int pshared)
{
  if (!pthread_mutexattr::is_good_object (attr))
    return EINVAL;
  /* we don't use pshared for anything as yet. We need to test PROCESS_SHARED
   *functionality
   */
  if (pshared != PTHREAD_PROCESS_PRIVATE)
    return EINVAL;
  (*attr)->pshared = pshared;
  return 0;
}

/* see pthread_mutex_gettype */
extern "C" int
pthread_mutexattr_settype (pthread_mutexattr_t *attr, int type)
{
  if (!pthread_mutexattr::is_good_object (attr))
    return EINVAL;

  switch (type)
    {
    case PTHREAD_MUTEX_ERRORCHECK:
    case PTHREAD_MUTEX_RECURSIVE:
    case PTHREAD_MUTEX_NORMAL:
      (*attr)->mutextype = type;
      break;
    default:
      return EINVAL;
    }

  return 0;
}

/* Semaphores */

List<semaphore> semaphore::semaphores;

semaphore::semaphore (int pshared, unsigned int value)
: verifyable_object (SEM_MAGIC),
  shared (pshared),
  currentvalue (-1),
  startvalue (value),
  fd (-1),
  hash (0ULL),
  sem (NULL)
{
  SECURITY_ATTRIBUTES sa = (pshared != PTHREAD_PROCESS_PRIVATE)
			   ? sec_all : sec_none_nih;
  this->win32_obj_id = ::CreateSemaphore (&sa, value, INT32_MAX, NULL);
  if (!this->win32_obj_id)
    magic = 0;

  semaphores.insert (this);
}

semaphore::semaphore (unsigned long long shash, LUID sluid, int sfd,
		      sem_t *ssem, int oflag, mode_t mode, unsigned int value)
: verifyable_object (SEM_MAGIC),
  shared (PTHREAD_PROCESS_SHARED),
  currentvalue (-1),		/* Unused for named semaphores. */
  startvalue (value),
  fd (sfd),
  hash (shash),
  luid (sluid),
  sem (ssem)
{
  char name[MAX_PATH];

  __small_sprintf (name, "semaphore/%016X%08x%08x",
		   hash, luid.HighPart, luid.LowPart);
  this->win32_obj_id = ::CreateSemaphore (&sec_all, value, INT32_MAX, name);
  if (!this->win32_obj_id)
    magic = 0;
  if (GetLastError () == ERROR_ALREADY_EXISTS && (oflag & O_EXCL))
    {
      __seterrno ();
      CloseHandle (this->win32_obj_id);
      magic = 0;
    }

  semaphores.insert (this);
}

semaphore::~semaphore ()
{
  if (win32_obj_id)
    CloseHandle (win32_obj_id);

  semaphores.remove (this);
}

void
semaphore::_post ()
{
  LONG dummy;
  ReleaseSemaphore (win32_obj_id, 1, &dummy);
}

int
semaphore::_getvalue (int *sval)
{
  NTSTATUS status;
  SEMAPHORE_BASIC_INFORMATION sbi;

  status = NtQuerySemaphore (win32_obj_id, SemaphoreBasicInformation, &sbi,
			     sizeof sbi, NULL);
  int res;
  if (NT_SUCCESS (status))
    {
      *sval = sbi.CurrentCount;
      res = 0;
    }
  else
    {
      *sval = startvalue;
      __seterrno_from_nt_status (status);
      res = -1;
    }
  return res;
}

int
semaphore::_trywait ()
{
  /* FIXME: signals should be able to interrupt semaphores...
    We probably need WaitForMultipleObjects here.  */
  if (WaitForSingleObject (win32_obj_id, 0) == WAIT_TIMEOUT)
    {
      set_errno (EAGAIN);
      return -1;
    }
  return 0;
}

int
semaphore::_timedwait (const struct timespec *abstime)
{
  LARGE_INTEGER timeout;

  __try
    {
      timeout.QuadPart = abstime->tv_sec * NSPERSEC
			 + (abstime->tv_nsec + 99) / 100 + FACTOR;

      switch (cygwait (win32_obj_id, &timeout,
		       cw_cancel | cw_cancel_self | cw_sig_eintr))
	{
	case WAIT_OBJECT_0:
	  break;
	case WAIT_SIGNALED:
	  set_errno (EINTR);
	  return -1;
	case WAIT_TIMEOUT:
	  set_errno (ETIMEDOUT);
	  return -1;
	default:
	  pthread_printf ("cygwait failed. %E");
	  __seterrno ();
	  return -1;
	}
    }
  __except (NO_ERROR)
    {
      /* According to SUSv3, abstime need not be checked for validity,
	 if the semaphore can be locked immediately. */
      if (_trywait ())
	{
	  set_errno (EINVAL);
	  return -1;
	}
    }
  __endtry
  return 0;
}

int
semaphore::_wait ()
{
  switch (cygwait (win32_obj_id, cw_infinite,
		   cw_cancel | cw_cancel_self | cw_sig_eintr))
    {
    case WAIT_OBJECT_0:
      break;
    case WAIT_SIGNALED:
      set_errno (EINTR);
      return -1;
    default:
      pthread_printf ("cygwait failed. %E");
      break;
    }
  return 0;
}

void
semaphore::_fixup_before_fork ()
{
  NTSTATUS status;
  SEMAPHORE_BASIC_INFORMATION sbi;

  status = NtQuerySemaphore (win32_obj_id, SemaphoreBasicInformation, &sbi,
			     sizeof sbi, NULL);
  if (NT_SUCCESS (status))
    currentvalue = sbi.CurrentCount;
  else
    currentvalue = startvalue;
}

void
semaphore::_fixup_after_fork ()
{
  if (shared == PTHREAD_PROCESS_PRIVATE)
    {
      pthread_printf ("sem %p", this);
      win32_obj_id = ::CreateSemaphore (&sec_none_nih, currentvalue,
					INT32_MAX, NULL);
      if (!win32_obj_id)
	api_fatal ("failed to create new win32 semaphore, "
		   "currentvalue %ld, %E", currentvalue);
    }
}

void
semaphore::_terminate ()
{
  int _sem_close (sem_t *, bool);

  if (sem)
    _sem_close (sem, false);
}

/* static members */

int
semaphore::init (sem_t *sem, int pshared, unsigned int value)
{
  /*
     We can't tell the difference between reinitialising an
     existing semaphore and initialising a semaphore who's
     contents happen to be a valid pointer
   */
  if (is_good_object (sem))
    paranoid_printf ("potential attempt to reinitialise a semaphore");

  if (value > SEM_VALUE_MAX)
    {
      set_errno(EINVAL);
      return -1;
    }

  *sem = new semaphore (pshared, value);

  if (!is_good_object (sem))
    {
      delete (*sem);
      *sem = NULL;
      set_errno(EAGAIN);
      return -1;
    }
  return 0;
}

int
semaphore::destroy (sem_t *sem)
{
  if (!is_good_object (sem))
    {
      set_errno(EINVAL);
      return -1;
    }

  /* It's invalid to destroy a semaphore not opened with sem_init. */
  if ((*sem)->fd != -1)
    {
      set_errno(EINVAL);
      return -1;
    }

  /* FIXME - new feature - test for busy against threads... */

  delete (*sem);
  *sem = NULL;
  return 0;
}

int
semaphore::close (sem_t *sem)
{
  if (!is_good_object (sem))
    {
      set_errno(EINVAL);
      return -1;
    }

  /* It's invalid to close a semaphore not opened with sem_open. */
  if ((*sem)->fd == -1)
    {
      set_errno(EINVAL);
      return -1;
    }

  delete (*sem);
  delete sem;
  return 0;
}

sem_t *
semaphore::open (unsigned long long hash, LUID luid, int fd, int oflag,
		 mode_t mode, unsigned int value, bool &wasopen)
{
  if (value > SEM_VALUE_MAX)
    {
      set_errno (EINVAL);
      return NULL;
    }

  /* sem_open is supposed to return the same pointer, if the same named
     semaphore is opened multiple times in the same process, as long as
     the semaphore hasn't been closed or unlinked in the meantime. */
  semaphores.mx.lock ();
  for (semaphore *sema = semaphores.head; sema; sema = sema->next)
    if (sema->fd >= 0 && sema->hash == hash
	&& sema->luid.HighPart == luid.HighPart
	&& sema->luid.LowPart == sema->luid.LowPart)
      {
	wasopen = true;
	semaphores.mx.unlock ();
	return sema->sem;
      }
  semaphores.mx.unlock ();

  wasopen = false;
  sem_t *sem = new sem_t;
  if (!sem)
    {
      set_errno (ENOMEM);
      return NULL;
    }

  *sem = new semaphore (hash, luid, fd, sem, oflag, mode, value);

  if (!is_good_object (sem))
    {
      delete *sem;
      delete sem;
      return NULL;
    }
  return sem;
}

int
semaphore::wait (sem_t *sem)
{
  pthread_testcancel ();

  if (!is_good_object (sem))
    {
      set_errno (EINVAL);
      return -1;
    }

  return (*sem)->_wait ();
}

int
semaphore::trywait (sem_t *sem)
{
  if (!is_good_object (sem))
    {
      set_errno (EINVAL);
      return -1;
    }

  return (*sem)->_trywait ();
}

int
semaphore::timedwait (sem_t *sem, const struct timespec *abstime)
{
  if (!is_good_object (sem))
    {
      set_errno (EINVAL);
      return -1;
    }

  return (*sem)->_timedwait (abstime);
}

int
semaphore::post (sem_t *sem)
{
  if (!is_good_object (sem))
    {
      set_errno (EINVAL);
      return -1;
    }

  (*sem)->_post ();
  return 0;
}

int
semaphore::getvalue (sem_t *sem, int *sval)
{
  __try
    {
      if (is_good_object (sem))
	return (*sem)->_getvalue (sval);
    }
  __except (NO_ERROR) {}
  __endtry
  set_errno (EINVAL);
  return -1;
}

int
semaphore::getinternal (sem_t *sem, int *sfd, unsigned long long *shash,
			LUID *sluid, unsigned int *sval)
{
  __try
    {
      if (!is_good_object (sem))
	__leave;
      if ((*sfd = (*sem)->fd) < 0)
	__leave;
      *shash = (*sem)->hash;
      *sluid = (*sem)->luid;
      /* POSIX defines the value in calls to sem_init/sem_open as unsigned,
	 but the sem_getvalue gets a pointer to int to return the value.
	 Go figure! */
      return (*sem)->_getvalue ((int *)sval);
    }
  __except (NO_ERROR) {}
  __endtry
  set_errno (EINVAL);
  return -1;
}

/* pthread_null */
pthread *
pthread_null::get_null_pthread ()
{
  /* because of weird entry points */
  _instance.magic = 0;
  return &_instance;
}

pthread_null::pthread_null ()
{
  attr.joinable = PTHREAD_CREATE_DETACHED;
  /* Mark ourselves as invalid */
  magic = 0;
}

pthread_null::~pthread_null ()
{
}

bool
pthread_null::create (void *(*)(void *), pthread_attr *, void *)
{
  return true;
}

void
pthread_null::exit (void *value_ptr)
{
  _my_tls.remove (INFINITE);
  ExitThread (0);
}

int
pthread_null::cancel ()
{
  return 0;
}

void
pthread_null::testcancel ()
{
}

int
pthread_null::setcancelstate (int state, int *oldstate)
{
  return EINVAL;
}

int
pthread_null::setcanceltype (int type, int *oldtype)
{
  return EINVAL;
}

void
pthread_null::push_cleanup_handler (__pthread_cleanup_handler *handler)
{
}

void
pthread_null::pop_cleanup_handler (int const execute)
{
}

unsigned long
pthread_null::getsequence_np ()
{
  return 0;
}

pthread_null pthread_null::_instance;
@


1.297
log
@	* cygwait.h (enum cw_wait_mask): Add cw_sig_restart.  Add comments
	to explain the meaning of the possible values.
	* cygwait.cc (is_cw_sig_restart): Define.
	(is_cw_sig_handle): Check for cw_sig_restart as well.
	(cygwait): Restart always if cw_sig_restart is set.
	* thread.cc (pthread::join): Call cygwait with cw_sig_restart flag
	to avoid having to handle signals at all.
@
text
@d1763 1
a1763 2
      /* FIXME: no cancel? */
      cygwait (win32_obj_id, cw_infinite, cw_sig);
d3520 2
a3521 1
      switch (cygwait (win32_obj_id, &timeout, cw_cancel | cw_cancel_self | cw_sig_eintr))
d3554 2
a3555 1
  switch (cygwait (win32_obj_id, cw_infinite, cw_cancel | cw_cancel_self | cw_sig_eintr))
@


1.296
log
@	* cygheap.cc (init_cygheap::init_tls_list): Accommodate threadlist
	having a new type threadlist_t *.  Convert commented out code into an
	#if 0.  Create thread mutex.  Explain why.
	(init_cygheap::remove_tls): Drop timeout value.  Always wait infinitely
	for tls_sentry.  Return mutex HANDLE of just deleted threadlist entry.
	(init_cygheap::find_tls): New implementation taking tls pointer as
	search parameter.  Return threadlist_t *.
	(init_cygheap::find_tls): Return threadlist_t *.  Define ix as auto
	variable.  Drop exception handling since crash must be made impossible
	due to correct synchronization.  Return with locked mutex.
	* cygheap.h (struct threadlist_t): Define.
	(struct init_cygheap): Convert threadlist to threadlist_t type.
	(init_cygheap::remove_tls): Align declaration to above change.
	(init_cygheap::find_tls): Ditto.
	(init_cygheap::unlock_tls): Define.
	* cygtls.cc (_cygtls::remove): Unlock and close mutex when finishing.
	* exceptions.cc (sigpacket::process): Lock _cygtls area of thread before
	accessing it.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* sigproc.cc (sig_send): Ditto.
	* thread.cc (pthread::exit): Ditto.  Add comment.
	(pthread::cancel): Ditto.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d2402 2
a2403 1
      switch (cygwait ((*thread)->win32_obj_id, cw_infinite, cw_sig | cw_cancel))
@


1.295
log
@	* cygheap.cc (init_cygheap::find_tls): Add comment.
	* cygtls.cc (well_known_dlls): Rephrase comment.
	(bloda_detect): New function.
	(_cygtls::call2): Call init_thread and bloda_detect for non-pthread
	threads only.
	(_cygtls::remove): Move remove_tls and remove_wq calls up to run first.
	* miscfuncs.cc (struct pthread_wrapper_arg): Rename from struct
	thread_wrapper_arg.
	(pthread_wrapper): Rename from thread_wrapper and drop "static".  Fix
	comment.  Drop call to _cygtls::remove.  Call api_fatal rather than
	ExitThread.  Explain why.
	* miscfuncs.h (pthread_wrapper): Declare pthread_wrapper.
	* thread.cc (pthread::exit): Add a FIXME comment.  Call _cygtls::remove
	before calling ExitThread.
@
text
@d518 1
a518 1
  bool is_main_tls = (cygtls == _main_tls); // Check cygtls before deleting this
d544 1
a544 1
      if (is_main_tls)
d546 1
a546 1
	  /* FIXME: Needs locking. */
d552 2
a553 1
      cygtls->remove (INFINITE);
d599 1
d609 1
@


1.294
log
@	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d546 1
d550 1
a550 1
	  _main_tls->initialized = false;
d552 1
@


1.293
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@a40 4
#if __GNUC__ == 4 && __GNUC_MINOR__ >= 7
/* FIXME: Temporarily workaround gcc 4.7+ bug. */
static verifyable_object_state
#else
a41 1
#endif
@


1.292
log
@	* thread.cc (pthread::init_mainthread): Initialize thread mutex to
	type PTHREAD_MUTEX_RECURSIVE, just as for any other thread.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
a124 4
#if __GNUC__ == 4 && __GNUC_MINOR__ >= 7
/* FIXME: Temporarily workaround gcc 4.7+ bug. */
static verifyable_object_state
#else
a125 1
#endif
d129 19
a147 13
  myfault efault;
  if (efault.faulted (objectptr))
    return INVALID_OBJECT;

  verifyable_object **object = (verifyable_object **) objectptr;

  if ((static_ptr1 && *object == static_ptr1) ||
      (static_ptr2 && *object == static_ptr2) ||
      (static_ptr3 && *object == static_ptr3))
    return VALID_STATIC_OBJECT;
  if ((*object)->magic != magic)
    return INVALID_OBJECT;
  return VALID_OBJECT;
d2688 7
a2694 2
  myfault efault;
  if (efault.faulted ())
d2697 1
a2697 2
      cond_initialization_lock.unlock ();
      return EINVAL;
d2699 1
a2699 2

  *cond = new_cond;
d2701 1
a2701 2

  return 0;
a2752 4
  myfault efault;
  if (efault.faulted ())
    return EINVAL;

d2755 19
a2773 3
  int err = __pthread_cond_wait_init (cond, mutex);
  if (err)
    return err;
d2775 2
a2776 5
  /* According to SUSv3, the abstime value must be checked for validity. */
  if (abstime->tv_sec < 0
      || abstime->tv_nsec < 0
      || abstime->tv_nsec > 999999999)
    return EINVAL;
d2778 12
a2789 21
  clock_gettime ((*cond)->clock_id, &tp);

  /* Check for immediate timeout before converting */
  if (tp.tv_sec > abstime->tv_sec
      || (tp.tv_sec == abstime->tv_sec
	  && tp.tv_nsec > abstime->tv_nsec))
    return ETIMEDOUT;

  timeout.QuadPart = abstime->tv_sec * NSPERSEC
		      + (abstime->tv_nsec + 99LL) / 100LL;

  switch ((*cond)->clock_id)
    {
    case CLOCK_REALTIME:
      timeout.QuadPart += FACTOR;
      break;
    default:
      /* other clocks must be handled as relative timeout */
      timeout.QuadPart -= tp.tv_sec * NSPERSEC + tp.tv_nsec / 100LL;
      timeout.QuadPart *= -1LL;
      break;
d2791 3
a2793 1
  return (*cond)->wait (*mutex, &timeout);
d2918 7
a2924 2
  myfault efault;
  if (efault.faulted ())
d2927 1
a2927 2
      rwlock_initialization_lock.unlock ();
      return EINVAL;
d2929 1
a2929 2

  *rwlock = new_rwlock;
d2931 1
a2931 2

  return 0;
d3143 5
a3147 2
      myfault efault;
      if (efault.faulted ())
d3153 1
a3153 2

      *mutex = new_mutex;
d3242 5
a3246 2
  myfault efault;
  if (efault.faulted ())
d3251 1
a3251 2

  *spinlock = new_spinlock;
a3252 1

d3515 22
a3536 2
  myfault efault;
  if (efault.faulted ())
d3540 5
a3544 23
      if (!_trywait ())
	return 0;
      set_errno (EINVAL);
      return -1;
    }

  timeout.QuadPart = abstime->tv_sec * NSPERSEC
		     + (abstime->tv_nsec + 99) / 100 + FACTOR;

  switch (cygwait (win32_obj_id, &timeout, cw_cancel | cw_cancel_self | cw_sig_eintr))
    {
    case WAIT_OBJECT_0:
      break;
    case WAIT_SIGNALED:
      set_errno (EINTR);
      return -1;
    case WAIT_TIMEOUT:
      set_errno (ETIMEDOUT);
      return -1;
    default:
      pthread_printf ("cygwait failed. %E");
      __seterrno ();
      return -1;
d3546 1
d3777 1
a3777 2
  myfault efault;
  if (efault.faulted () || !is_good_object (sem))
d3779 2
a3780 2
      set_errno (EINVAL);
      return -1;
d3782 4
a3785 2

  return (*sem)->_getvalue (sval);
d3792 1
a3792 2
  myfault efault;
  if (efault.faulted () || !is_good_object (sem))
d3794 15
a3808 13
      set_errno (EINVAL);
      return -1;
    }
  if ((*sfd = (*sem)->fd) < 0)
    {
      set_errno (EINVAL);
      return -1;
    }
  *shash = (*sem)->hash;
  *sluid = (*sem)->luid;
  /* POSIX defines the value in calls to sem_init/sem_open as unsigned, but
     the sem_getvalue gets a pointer to int to return the value.  Go figure! */
  return (*sem)->_getvalue ((int *)sval);
@


1.291
log
@	* thread.cc (pthread::create): Handle stackaddr as upper bound address.
	Add comment.
	(pthread_attr_setstack): Store upper bound address in stackaddr.
	Explain why.
	(pthread_attr_getstack): Handle stackaddr as upper bound address.
	Add comment.
	(pthread_attr_setstackaddr): Add comment.
	(pthread_attr_getstackaddr): Add comment.
	(pthread_attr_getstacksize): Return default stacksize if stacksize has
	not been set by the application, just as on Linux.  Add comment.
	(pthread_getattr_np): Store upper bound address in stackaddr.  Explain
	why.
	* include/pthread.h: Remove outdated comment.
	(pthread_attr_getstackaddr): Mark as deprecated, as on Linux.
	(pthread_attr_setstackaddr): Ditto.
@
text
@d361 4
@


1.290
log
@	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.
@
text
@d476 7
a482 3
  win32_obj_id = CygwinCreateThread (thread_init_wrapper, this, attr.stackaddr,
				   attr.stacksize ?: PTHREAD_DEFAULT_STACKSIZE,
				   attr.guardsize, 0, &thread_id);
d2260 7
a2266 1
  (*attr)->stackaddr = addr;
d2276 3
a2278 1
  *addr = (*attr)->stackaddr;
d2290 6
d2305 1
d2326 4
a2329 1
  *size = (*attr)->stacksize;
d2511 4
a2514 2
      (*attr)->stackaddr = teb->DeallocationStack ?: teb->Tib.StackLimit;
      /* stack grows downwards on x86 systems */
d2516 1
a2516 1
			   - (uintptr_t) (*attr)->stackaddr;
@


1.289
log
@	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.
@
text
@d1712 1
a1712 1
  type (PTHREAD_MUTEX_ERRORCHECK),
d1780 1
a1780 1
    res = type == PTHREAD_MUTEX_ERRORCHECK ? EINVAL : 0;
d1854 1
a1854 1
pshared (PTHREAD_PROCESS_PRIVATE), mutextype (PTHREAD_MUTEX_ERRORCHECK)
d3162 1
a3162 1
    return EPERM;
@


1.288
log
@	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).
@
text
@d476 3
a478 3
  win32_obj_id = CygwinCreateThread (thread_init_wrapper, this,
				     attr.stackaddr, attr.stacksize,
				     attr.guardsize, 0, &thread_id);
d1086 2
a1087 2
inheritsched (PTHREAD_INHERIT_SCHED), stackaddr (NULL),
stacksize (PTHREAD_DEFAULT_STACKSIZE), guardsize (PTHREAD_DEFAULT_GUARDSIZE)
d2266 1
a2266 2
  /* uses lowest address of stack on all platforms */
  *addr = (void *)((ptrdiff_t)(*attr)->stackaddr - (*attr)->stacksize);
a2286 2
  /* uses stack address, which is the higher address on platforms
     where the stack grows downwards, such as x86 */
d2488 2
a2489 2
      PNT_TIB tib = tbi->TebBaseAddress;
      (*attr)->stackaddr = tib->StackBase;
d2491 2
a2492 2
      (*attr)->stacksize = (uintptr_t) tib->StackBase
			   - (uintptr_t) tib->StackLimit;
@


1.287
log
@	* dtable.cc (dtable::extend): Change local variable new_size to size_t
	as well.

	* thread.cc: Fix comment.
@
text
@d514 1
d540 1
a540 1
      if (cygtls == _main_tls)
@


1.287.2.1
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@d476 3
a478 3
  win32_obj_id = CygwinCreateThread (thread_init_wrapper, this, attr.stackaddr,
				   attr.stacksize ?: PTHREAD_DEFAULT_STACKSIZE,
				   attr.guardsize, 0, &thread_id);
a513 1
  bool is_main_tls = (cygtls == _main_tls); // Check cygtls before deleting this
d539 1
a539 1
      if (is_main_tls)
d1085 2
a1086 2
inheritsched (PTHREAD_INHERIT_SCHED), stackaddr (NULL), stacksize (0),
guardsize (PTHREAD_DEFAULT_GUARDSIZE)
d1711 1
a1711 1
  type (PTHREAD_MUTEX_NORMAL),
d1779 1
a1779 1
    res = type == PTHREAD_MUTEX_ERRORCHECK ? EPERM : 0;
d1853 1
a1853 1
pshared (PTHREAD_PROCESS_PRIVATE), mutextype (PTHREAD_MUTEX_NORMAL)
d2265 2
a2266 1
  *addr = (*attr)->stackaddr;
d2287 2
d2490 2
a2491 2
      PTEB teb = (PTEB) tbi->TebBaseAddress;
      (*attr)->stackaddr = teb->DeallocationStack ?: teb->Tib.StackLimit;
d2493 2
a2494 2
      (*attr)->stacksize = (uintptr_t) teb->Tib.StackBase
			   - (uintptr_t) (*attr)->stackaddr;
d3164 1
a3164 1
    pthread_mutex::init (mutex, NULL, *mutex);
@


1.287.2.2
log
@2014-07-16  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Handle stackaddr as upper bound address.
	Add comment.
	(pthread_attr_setstack): Store upper bound address in stackaddr.
	Explain why.
	(pthread_attr_getstack): Handle stackaddr as upper bound address.
	Add comment.
	(pthread_attr_setstackaddr): Add comment.
	(pthread_attr_getstackaddr): Add comment.
	(pthread_attr_getstacksize): Return default stacksize if stacksize has
	not been set by the application, just as on Linux.  Add comment.
	(pthread_getattr_np): Store upper bound address in stackaddr.  Explain
	why.
	* include/pthread.h: Remove outdated comment.
	(pthread_attr_getstackaddr): Mark as deprecated, as on Linux.
	(pthread_attr_setstackaddr): Ditto.

2014-07-15  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (sigproc_init): Set aside more buffer space for signal
	pipes.
	(sig_send): Retry WriteFiles which fail when there is no error but
	packbytes have not been sent.
@
text
@d476 3
a478 7
  /* stackaddr holds the uppermost stack address.  See the comments in
     pthread_attr_setstack and pthread_attr_setstackaddr for a description. */
  ULONG stacksize = attr.stacksize ?: PTHREAD_DEFAULT_STACKSIZE;
  PVOID stackaddr = attr.stackaddr ? ((caddr_t) attr.stackaddr - stacksize)
				   : NULL;
  win32_obj_id = CygwinCreateThread (thread_init_wrapper, this, stackaddr,
				     stacksize, attr.guardsize, 0, &thread_id);
d2256 1
a2256 7
  /* The incoming address addr points to the lowest addressable byte of a
     buffer of size bytes.  Due to the way pthread_attr_setstackaddr is defined
     on Linux, the lowest address ot the stack can't be reliably computed when
     using pthread_attr_setstackaddr/pthread_attr_setstacksize.  Therefore we
     store the uppermost address of the stack in stackaddr.  See also the
     comment in pthread_attr_setstackaddr. */
  (*attr)->stackaddr = (caddr_t) addr + size;
d2266 1
a2266 3
  /* stackaddr holds the uppermost stack address.  See the comment in
     pthread_attr_setstack. */
  *addr = (caddr_t) (*attr)->stackaddr - (*attr)->stacksize;
a2277 6
  /* This function is deprecated in SUSv4, but SUSv3 didn't define
     if the incoming stack address is the lowest address of the memory
     area defined as stack, or if it's the start address of the stack
     at which it begins its growth.  On Linux it's the latter which
     means the uppermost stack address on x86 based systems.  See comment
     in pthread_attr_setstack as well. */
a2286 1
  /* See comment in pthread_attr_setstackaddr. */
d2307 1
a2307 4
  /* If the stacksize has not been set by the application, return the
     default stacksize.  Note that this is different from what
     pthread_attr_getstack returns. */
  *size = (*attr)->stacksize ?: PTHREAD_DEFAULT_STACKSIZE;
d2489 2
a2490 4
      /* stackaddr holds the uppermost stack address.  See the comments
	 in pthread_attr_setstack and pthread_attr_setstackaddr for a
	 description. */
      (*attr)->stackaddr = teb->Tib.StackBase;
d2492 1
a2492 1
	       - (uintptr_t) (teb->DeallocationStack ?: teb->Tib.StackLimit);
@


1.287.2.3
log
@	* thread.cc (pthread::init_mainthread): Initialize thread mutex to
	type PTHREAD_MUTEX_RECURSIVE, just as for any other thread.
@
text
@a360 4
  /* Make sure the pthread mutex is recursive.  See comment in
     pthread::precreate (called only for subsequent pthreads)
     for a description. */
  thread->mutex.set_type (PTHREAD_MUTEX_RECURSIVE);
@


1.287.2.4
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d41 4
d46 1
d125 4
d130 1
d134 13
a146 19
  verifyable_object_state state = INVALID_OBJECT;

  __try
    {
      if (!objectptr || !(*(const char **) objectptr))
	__leave;

      verifyable_object **object = (verifyable_object **) objectptr;

      if ((static_ptr1 && *object == static_ptr1) ||
	  (static_ptr2 && *object == static_ptr2) ||
	  (static_ptr3 && *object == static_ptr3))
	state = VALID_STATIC_OBJECT;
      else if ((*object)->magic == magic)
	state = VALID_OBJECT;
    }
  __except (NO_ERROR) {}
  __endtry
  return state;
d2687 2
a2688 7
  int ret = 0;

  __try
    {
      *cond = new_cond;
    }
  __except (NO_ERROR)
d2691 2
a2692 1
      ret = EINVAL;
d2694 2
a2695 1
  __endtry
d2697 2
a2698 1
  return ret;
d2750 4
d2756 17
a2772 19
  __try
    {
      int err = __pthread_cond_wait_init (cond, mutex);
      if (err)
	return err;

      /* According to SUSv3, the abstime value must be checked for validity. */
      if (abstime->tv_sec < 0
	  || abstime->tv_nsec < 0
	  || abstime->tv_nsec > 999999999)
	__leave;

      clock_gettime ((*cond)->clock_id, &tp);

      /* Check for immediate timeout before converting */
      if (tp.tv_sec > abstime->tv_sec
	  || (tp.tv_sec == abstime->tv_sec
	      && tp.tv_nsec > abstime->tv_nsec))
	return ETIMEDOUT;
d2774 2
a2775 2
      timeout.QuadPart = abstime->tv_sec * NSPERSEC
			  + (abstime->tv_nsec + 99LL) / 100LL;
d2777 10
a2786 12
      switch ((*cond)->clock_id)
	{
	case CLOCK_REALTIME:
	  timeout.QuadPart += FACTOR;
	  break;
	default:
	  /* other clocks must be handled as relative timeout */
	  timeout.QuadPart -= tp.tv_sec * NSPERSEC + tp.tv_nsec / 100LL;
	  timeout.QuadPart *= -1LL;
	  break;
	}
      return (*cond)->wait (*mutex, &timeout);
d2788 1
a2788 3
  __except (NO_ERROR) {}
  __endtry
  return EINVAL;
d2913 2
a2914 7
  int ret = 0;

  __try
    {
      *rwlock = new_rwlock;
    }
  __except (NO_ERROR)
d2917 2
a2918 1
      ret = EINVAL;
d2920 2
a2921 1
  __endtry
d2923 2
a2924 1
  return ret;
d3136 2
a3137 5
      __try
	{
	  *mutex = new_mutex;
	}
      __except (NO_ERROR)
d3143 2
a3144 1
      __endtry
d3233 2
a3234 5
  __try
    {
      *spinlock = new_spinlock;
    }
  __except (NO_ERROR)
d3239 2
a3240 1
  __endtry
d3242 1
d3505 2
a3506 1
  __try
d3508 10
a3517 2
      timeout.QuadPart = abstime->tv_sec * NSPERSEC
			 + (abstime->tv_nsec + 99) / 100 + FACTOR;
d3519 1
a3519 17
      switch (cygwait (win32_obj_id, &timeout, cw_cancel | cw_cancel_self | cw_sig_eintr))
	{
	case WAIT_OBJECT_0:
	  break;
	case WAIT_SIGNALED:
	  set_errno (EINTR);
	  return -1;
	case WAIT_TIMEOUT:
	  set_errno (ETIMEDOUT);
	  return -1;
	default:
	  pthread_printf ("cygwait failed. %E");
	  __seterrno ();
	  return -1;
	}
    }
  __except (NO_ERROR)
d3521 12
a3532 7
      /* According to SUSv3, abstime need not be checked for validity,
	 if the semaphore can be locked immediately. */
      if (_trywait ())
	{
	  set_errno (EINVAL);
	  return -1;
	}
a3533 1
  __endtry
d3764 2
a3765 1
  __try
d3767 2
a3768 2
      if (is_good_object (sem))
	return (*sem)->_getvalue (sval);
d3770 2
a3771 4
  __except (NO_ERROR) {}
  __endtry
  set_errno (EINVAL);
  return -1;
d3778 2
a3779 1
  __try
d3781 13
a3793 15
      if (!is_good_object (sem))
	__leave;
      if ((*sfd = (*sem)->fd) < 0)
	__leave;
      *shash = (*sem)->hash;
      *sluid = (*sem)->luid;
      /* POSIX defines the value in calls to sem_init/sem_open as unsigned,
	 but the sem_getvalue gets a pointer to int to return the value.
	 Go figure! */
      return (*sem)->_getvalue ((int *)sval);
    }
  __except (NO_ERROR) {}
  __endtry
  set_errno (EINVAL);
  return -1;
@


1.286
log
@* thread.cc (semaphore::_getvalue): Set *sval as appropriate.  Set errno and
return -1 on error.
@
text
@d829 2
a830 2
    o posix_spawn ()
    o posix_spawnp ()
@


1.285
log
@	* ntdll.h (struct _SEMAPHORE_BASIC_INFORMATION): Define.
	(enum _SEMAPHORE_INFORMATION_CLASS): Define.
	(NtQuerySemaphore): Declare.
	* thread.h (class semaphore): Add member startvalue.
	(semaphore::fixup_before_fork): New inline method.
	(semaphore::_fixup_before_fork): Declare.
	* thread.cc (MTinterface::fixup_before_fork): Additionally call
	semaphore::fixup_before_fork.
	(semaphore::semaphore): Set currentvalue to -1.  Set startvalue to
	incoming initializer value.
	(semaphore::_getvalue): Just query semaphore using NtQuerySemaphore
	rather then using WFSO/Release.
	(semaphore::_post): Drop setting currentvalue.  It's not thread-safe.
	(semaphore::_trywait): Ditto.
	(semaphore::_timedwait): Ditto.
	(semaphore::_wait): Ditto.
	(semaphore::_fixup_before_fork): New method, setting currentvalue from
	actual windows semaphore right before fork.
	(semaphore::_fixup_after_fork): Drop kludge from 2013-07-10.  Drop
	FIXME comment.
@
text
@d3446 1
d3448 11
a3458 2
    return sbi.CurrentCount;
  return startvalue;
@


1.284
log
@* gentlsoffsets: Clean up a little.
* thread.cc (semaphore::_fixup_after_fork): Report on potential problem
parameter.  Make sure that currentvalue is never zero.
(semaphore::init): Make cosmetic change.
@
text
@d319 1
d3380 2
a3381 1
  currentvalue (value),
d3399 2
a3400 1
  currentvalue (value),		/* Unused for named semaphores. */
d3434 2
a3435 2
  if (ReleaseSemaphore (win32_obj_id, 1, &currentvalue))
    currentvalue++;
d3441 2
a3442 1
  LONG val;
d3444 5
a3448 14
  switch (WaitForSingleObject (win32_obj_id, 0))
    {
      case WAIT_OBJECT_0:
	ReleaseSemaphore (win32_obj_id, 1, &val);
	*sval = val + 1;
	break;
      case WAIT_TIMEOUT:
	*sval = 0;
	break;
      default:
	set_errno (EAGAIN);
	return -1;
    }
  return 0;
a3460 1
  currentvalue--;
a3485 1
      currentvalue--;
a3506 1
      currentvalue--;
d3519 14
a3537 3
      if (!currentvalue)
	currentvalue = 1;
      /* FIXME: duplicate code here and in the constructor. */
d3539 1
a3539 1
					      INT32_MAX, NULL);
d3541 2
a3542 1
	api_fatal ("failed to create new win32 semaphore, currentvalue %ld, %E", currentvalue);
@


1.283
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d3532 2
d3535 1
a3535 1
      this->win32_obj_id = ::CreateSemaphore (&sec_none_nih, currentvalue,
d3538 1
a3538 1
	api_fatal ("failed to create new win32 semaphore, %E");
d3562 1
a3562 3
    {
      paranoid_printf ("potential attempt to reinitialise a semaphore");
    }
@


1.282
log
@	* Merge in cygwin-64bit-branch.
@
text
@d41 2
a42 2
#ifdef __x86_64__
/* FIXME: Temporarily workaround gcc 4.8 bug. */
d125 2
a126 2
#ifdef __x86_64__
/* FIXME: Temporarily workaround gcc 4.8 bug. */
@


1.281
log
@* cygheap.cc (init_cygheap::find_tls): Add a comment.
* dcrt0.cc (parent_sigmask): Delete.
(dll_crt0_1): Use spawn_info->moreinfo->sigmask rather than saved parent signal
mask.
* thread.cc (pthread::thread_init_wrapper): Add comment stressing the
importance of maintaining ordering of statements.
@
text
@d41 4
d46 1
d125 4
d130 1
d229 1
a229 1
  pthread_printf ("recursion_counter %d res %d", recursion_counter, res);
d592 3
d596 1
d1160 1
a1160 1
  sem_wait = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
d1182 1
a1182 1
  unsigned long releaseable;
d1192 1
a1192 1
      unsigned long released;
d1229 1
a1229 1
  if (InterlockedIncrement ((long *)&waiting) == 1)
d1233 1
a1233 1
      InterlockedDecrement ((long *)&waiting);
d1264 1
a1264 1
  InterlockedDecrement ((long *)&waiting);
d1303 1
a1303 1
  sem_wait = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
d1400 1
a1400 1
      if (reader->n < ULONG_MAX)
d1446 1
a1446 1
      if (reader && reader->n < ULONG_MAX)
d1465 1
a1465 1
  if (writer ==  self || lookup_reader ())
d1747 1
a1747 1
  if (InterlockedIncrement ((long *) &lock_counter) == 1)
d1758 1
a1758 1
      InterlockedDecrement ((long *) &lock_counter);
d1765 1
a1765 1
  pthread_printf ("mutex %p, self %p, owner %p, lock_counter %d, recursion_counter %d",
d1789 1
a1789 1
      if (InterlockedDecrement ((long *) &lock_counter))
d1794 1
a1794 1
  pthread_printf ("mutex %p, owner %p, self %p, lock_counter %d, recursion_counter %d, type %d, res %d",
d1805 1
a1805 1
  if (InterlockedCompareExchange ((long *) &lock_counter, 1, 0) == 0)
d1881 1
a1881 1
      if (InterlockedExchange ((long *) &lock_counter, 1) == 0)
d1916 1
a1916 1
      InterlockedExchange ((long *) &lock_counter, 0);
d2265 1
a2265 1
  *addr = (void *)((int)(*attr)->stackaddr - (*attr)->stacksize);
d2498 1
a2498 1
		    "status %p", status);
d3047 2
a3048 1
  syscall_printf ("%d = pthread_sigmask(%d, %p, %p)", operation, set, old_set);
d3386 1
a3386 1
  this->win32_obj_id = ::CreateSemaphore (&sa, value, LONG_MAX, NULL);
d3407 1
a3407 1
  this->win32_obj_id = ::CreateSemaphore (&sec_all, value, LONG_MAX, name);
d3438 1
a3438 1
  long val;
d3531 1
a3531 1
      pthread_printf ("sem %x", this);
d3534 1
a3534 1
					      LONG_MAX, NULL);
@


1.280
log
@* child_info.h (cygheap_exec_info::sigmask): Declare new field.
* cygheap.cc (init_cygheap::find_tls): Rename threadlist_ix -> ix.  Only take
one pass through thread list, looking for eligible threads to signal.  Set a
new param indicating that function has found a sigwait* mask.
* cygheap.h (init_cygheap::find_tls): Reflect new parameter.
* dcrt0.cc (parent_sigmask): New variable.
(child_info_spawn::handle_spawn): Save parent's signal mask here.
(dll_crt0_1): Restore parent's signal mask to tls sigmask as appropriate.  Call
sig_dispatch_pending to flush signal queue when we can finally do something
with signals.
* exceptions.cc (sigpacket::process): Avoid attempting to handle signals if we
haven't finished initializing.  Rely on the fact that find_tls will do mask
checking and don't do it again.  Delete ill-named 'dummy' variable.
* sigproc.cc (cygheap_exec_info::alloc): Save calling thread's signal mask in
new sigmask field.
(wait_sig): Try to debug when WFSO fails and DEBUGGING is defined.
* thread.cc (pthread::set_tls_self_pointer): Make this a true automatic method
rather than inexplicably relying on a thread parameter.
(pthread::thread_init_wrapper): Accommodate set_tls_self_pointer change to
non-static.  Initialize sigmask before setting tid or suffer signal races.
* ehread.h (pthread::set_tls_self_pointer): Make non-static, delete parameter.
@
text
@d1915 3
@


1.279
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d341 1
a341 1
  set_tls_self_pointer (thread);
d360 1
a360 1
      set_tls_self_pointer (thread);
d366 1
a366 1
pthread::set_tls_self_pointer (pthread *thread)
d368 2
a369 2
  thread->cygtls = &_my_tls;
  _my_tls.tid = thread;
d1915 2
a1916 1
  set_tls_self_pointer (thread);
a1922 1
  _my_tls.sigmask = thread->parent_sigmask;
@


1.278
log
@* thread.cc (pthread_rwlock::lookup_reader): Remove parameter: always assume
that we're looking for the current thread.
(pthread_rwlock::tryrdlock): Eliminate self variable.  Accommodate change in
lookup_reader().
(pthread_rwlock::unlock): Ditto.
(pthread_rwlock::rdlock): Ditto.  Move add_reader call after writer tests to
more closely mimic old behavior.
(pthread_rwlock::wrlock): Accommodate change in lookup_reader().
* thread.h ((pthread_rwlock::lookup_reader): Eliminate argument.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.277
log
@* thread.cc (pthread_rwlock::add_reader): Perform new operation here and return
pointer to allocated RWLOCK_READER structure.
(pthread_rwlock::rdlock): Reorganize to reflect new add_reader functionality.
(pthread_rwlock::tryrdlock): Ditto.  Remove unneeded call to lookup_reader().
* thread.h (pthread_rwlock::RWLOCK_READER::RWLOCK_READER): New constructor.
(pthread_rwlock::add_reader): Reflect new functionality.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
a1379 1
  pthread_t self = pthread::self ();
d1383 1
a1383 1
  reader = lookup_reader (self);
a1392 8
  if ((reader = add_reader ()))
    ++reader->n;
  else
    {
      result = EAGAIN;
      goto DONE;
    }

d1404 7
a1421 1
  pthread_t self = pthread::self ();
d1429 1
a1429 1
      RWLOCK_READER *reader = lookup_reader (self);
d1451 1
a1451 1
  if (writer == self || lookup_reader (self))
a1497 1
  pthread_t self = pthread::self ();
d1503 1
a1503 1
      if (writer != self)
d1513 1
a1513 1
      struct RWLOCK_READER *reader = lookup_reader (self);
d1551 1
a1551 1
pthread_rwlock::lookup_reader (pthread_t thread)
d1554 1
@


1.276
log
@* select.h (select_stuff): Remove variable names from parameter declarations.
(select_info): Ditto.
(select_record::dump_select_record): Declare new debugging-only function.
(select_info): Zero all fields.
(select_pipe_info): Ditto.
(select_socket_info): Ditto.
(select_serial_info): Ditto.
(select_mailslot_info): Ditto.
* select.cc (select_record::dump_select_record): Define new debugging-only
function.
(select_stuff::test_and_set): Call dump_select_record when debugging.
* thread.cc (pthread_mutex::unlock): Revert setting of tid to NULL since, in
this context, it is a number, not a pointer.
(pthread_spinlock::unlock): Ditto.
@
text
@d1394 3
a1396 2
  reader = new struct RWLOCK_READER;
  if (!reader)
a1412 3
  reader->thread = self;
  reader->n = 1;
  add_reader (reader);
d1428 1
a1428 1
  if (writer || waiting_writers || lookup_reader (self))
d1432 3
a1434 3
      struct RWLOCK_READER *reader;

      reader = lookup_reader (self);
a1436 6
      else if ((reader = new struct RWLOCK_READER))
	{
	  reader->thread = self;
	  reader->n = 1;
	  add_reader (reader);
	}
d1539 2
a1540 2
void
pthread_rwlock::add_reader (struct RWLOCK_READER *rd)
d1542 4
a1545 1
  List_insert (readers, rd);
@


1.275
log
@* DevNotes: Add entry cgf-000018.
* init.cc (dll_entry): Grab process lock before exiting to ensure that thread
doesn't exit before parent if parent is exiting.
* _cygtls.cc (_cygtls::call2): Revert previous 2012-12-21 change.
* miscfuncs.cc (thread_wrapper): Ditto.
* thread.cc (pthread::exit): Ditto.
* sigproc.cc (exit_thread): Ditto.
(wait_sig): Ditto.
* sync.cc (muto::release): Ditto.
* sync.h (muto::release): Ditto.
* sigproc.h (__SIGTHREADEXIT): Delete enum.
(exit_thread): Delete declaration.
@
text
@d1781 1
a1781 1
      tid = NULL;
d1908 1
a1908 1
      tid = NULL;
@


1.274
log
@* DevNotes: Add entry cgf-000017.
* _cygtls.cc (_cygtls::call2): Use new exit_thread function in place of
ExitThread.
* miscfuncs.cc (thread_wrapper): Ditto.
* thread.cc (pthread::exit): Ditto.
(pthread_mutex::unlock): Set tid to NULL rather than 0.
(pthread_spinlock::unlock): Ditto.
* pinfo.cc (commune_process): Actually call lock_process constructor.
* sigproc.cc (exit_thread): New function.
(wait_sig): Handle __SIGTHREADEXIT case.  Don't just block rather than
returning from this function.
* sigproc.h (__SIGTHREADEXIT): New enum.
(exit_thread): Declare.
* sync.cc (muto::release): Accept a tls command-line argument.
* sync.h (muto::release): Accept a tls command-line parameter.  Default to
&_my_tls.
@
text
@d535 1
a535 1
      exit_thread (0);
@


1.273
log
@whitespace cleanup
@
text
@d535 1
a535 1
      ExitThread (0);
d1781 1
a1781 1
      tid = 0;
d1908 1
a1908 1
      tid = 0;
@


1.272
log
@Rename cancelable_wait -> cygwait throughout.
* DevNotes: Add entry cgf-000015.
* cygwait.h (cygwait): Don't allow an optional PLARGE_INTERGER argument.
@
text
@d578 1
a578 1
         So just don't cancel asynchronously if the thread is currently
d581 4
a584 4
        {
          context.Eip = (DWORD) pthread::static_cancel_self;
          SetThreadContext (win32_obj_id, &context);
        }
@


1.271
log
@	* thread.cc (semaphore::_fixup_after_fork): Fix Win32 error output in
	api_fatal call.
@
text
@d588 1
a588 1
     will call cancelable_wait which in turn calls WFMO.  While this WFMO call
d1231 1
a1231 1
  rv = cancelable_wait (sem_wait, timeout, cw_cancel | cw_sig_eintr);
d1747 1
a1747 1
      cancelable_wait (win32_obj_id, cw_infinite, cw_sig);
d1888 1
a1888 1
	  cancelable_wait (win32_obj_id, &timeout, cw_sig);
d2367 1
a2367 1
      switch (cancelable_wait ((*thread)->win32_obj_id, cw_infinite, cw_sig | cw_cancel))
d3479 1
a3479 1
  switch (cancelable_wait (win32_obj_id, &timeout, cw_cancel | cw_cancel_self | cw_sig_eintr))
d3491 1
a3491 1
      pthread_printf ("cancelable_wait failed. %E");
d3501 1
a3501 1
  switch (cancelable_wait (win32_obj_id, cw_infinite, cw_cancel | cw_cancel_self | cw_sig_eintr))
d3510 1
a3510 1
      pthread_printf ("cancelable_wait failed. %E");
@


1.270
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d3526 1
a3526 1
	api_fatal ("failed to create new win32 semaphore, error %d");
@


1.270.2.1
log
@Pull in changes from HEAD
@
text
@d3526 1
a3526 1
	api_fatal ("failed to create new win32 semaphore, %E");
@


1.270.2.2
log
@	* advapi32.cc (DuplicateTokenEx): Make ?: expression type-safe.
	* ntdll.h (KAFFINITY): Don't define if building with Mingw64 headers.
	* thread.cc: Throughout drop casts in calls to Interlocked functions.
	* thread.h (class fast_mutex): Ditto.  Define lock_counter as LONG.
	(class pthread_mutex): Define lock_counter as LONG.
	(struct MTinterface): Define threadcount as LONG.
@
text
@d1741 1
a1741 1
  if (InterlockedIncrement (&lock_counter) == 1)
d1752 1
a1752 1
      InterlockedDecrement (&lock_counter);
d1783 1
a1783 1
      if (InterlockedDecrement (&lock_counter))
d1799 1
a1799 1
  if (InterlockedCompareExchange (&lock_counter, 1, 0) == 0)
d1875 1
a1875 1
      if (InterlockedExchange (&lock_counter, 1) == 0)
d1910 1
a1910 1
      InterlockedExchange (&lock_counter, 0);
@


1.270.2.3
log
@Pull in changes from HEAD
@
text
@d588 1
a588 1
     will call cygwait which in turn calls WFMO.  While this WFMO call
d1231 1
a1231 1
  rv = cygwait (sem_wait, timeout, cw_cancel | cw_sig_eintr);
d1747 1
a1747 1
      cygwait (win32_obj_id, cw_infinite, cw_sig);
d1888 1
a1888 1
	  cygwait (win32_obj_id, &timeout, cw_sig);
d2367 1
a2367 1
      switch (cygwait ((*thread)->win32_obj_id, cw_infinite, cw_sig | cw_cancel))
d3479 1
a3479 1
  switch (cygwait (win32_obj_id, &timeout, cw_cancel | cw_cancel_self | cw_sig_eintr))
d3491 1
a3491 1
      pthread_printf ("cygwait failed. %E");
d3501 1
a3501 1
  switch (cygwait (win32_obj_id, cw_infinite, cw_cancel | cw_cancel_self | cw_sig_eintr))
d3510 1
a3510 1
      pthread_printf ("cygwait failed. %E");
@


1.270.2.4
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d578 1
a578 1
	 So just don't cancel asynchronously if the thread is currently
d581 4
a584 4
	{
	  context.Eip = (DWORD) pthread::static_cancel_self;
	  SetThreadContext (win32_obj_id, &context);
	}
@


1.270.2.5
log
@	* fhandler_netdrive.cc: Use UINT32_MAX rather than UINT_MAX to make
	absolutely clear that we mean the 32 bit maximum.
	* fhandler_socket.cc: Ditto.
	* pinfo.cc: Ditto with INT32_MAX.
	* select.cc (fd_mask): Drop gratuitious definition.
	(sizeof_fd_set): Cast to size_t.
	* shared.cc (pround): Cast to ptrdiff_t.
	* strace.cc (strace::activate): Fix format string.
	(strace::write_childpid): Take pid_t as parameter.
	* include/sys/strace.h (strace::write_childpid): Change declaration
	accordingly.
	* sync.cc (muto::init): Cast in call to InterlockedExchangePointer to
	make compiler happy.
	* sync.h (class muto): De-const name.
	* syslog.cc (try_connect_syslogd): Take size_t as third argument.
	(vsyslog): Convert len to size_t.
	* thread.cc: Use {U}INT32_MAX rather than {U}LONG_MAX.  Througout change
	types used in Windows calls to matching Windows types.
	(pthread::cancel): Fix access to instruction pointer for x86_64.
	(pthread_attr_getstack): Cast to ptrdiff_t for pointer arithmetic.
	* thread.h: Throughout convert 'long' types to uint32_t or LONG.
@
text
@a581 3
#ifdef __x86_64__
	  context.Rip = (ULONG_PTR) pthread::static_cancel_self;
#else
a582 1
#endif
d1146 1
a1146 1
  sem_wait = ::CreateSemaphore (&sec_none_nih, 0, INT32_MAX, NULL);
d1168 1
a1168 1
  LONG releaseable;
d1178 1
a1178 1
      LONG released;
d1215 1
a1215 1
  if (InterlockedIncrement (&waiting) == 1)
d1219 1
a1219 1
      InterlockedDecrement (&waiting);
d1250 1
a1250 1
  InterlockedDecrement (&waiting);
d1289 1
a1289 1
  sem_wait = ::CreateSemaphore (&sec_none_nih, 0, INT32_MAX, NULL);
d1387 1
a1387 1
      if (reader->n < UINT32_MAX)
d1437 1
a1437 1
      if (reader && reader->n < UINT32_MAX)
d2256 1
a2256 1
  *addr = (void *)((ptrdiff_t)(*attr)->stackaddr - (*attr)->stacksize);
d3376 1
a3376 1
  this->win32_obj_id = ::CreateSemaphore (&sa, value, INT32_MAX, NULL);
d3397 1
a3397 1
  this->win32_obj_id = ::CreateSemaphore (&sec_all, value, INT32_MAX, name);
d3428 1
a3428 1
  LONG val;
d3524 1
a3524 1
					      INT32_MAX, NULL);
@


1.270.2.6
log
@	* thread.cc (verifyable_object_isvalid): Temporarily define as
	non-inline on x86_64 to workaround compiler bug.
@
text
@a40 4
#ifdef __x86_64__
/* FIXME: Temporarily workaround gcc 4.8 bug. */
static verifyable_object_state
#else
a41 1
#endif
a119 4
#ifdef __x86_64__
/* FIXME: Temporarily workaround gcc 4.8 bug. */
static verifyable_object_state
#else
a120 1
#endif
@


1.270.2.7
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d229 1
a229 1
  pthread_printf ("recursion_counter %u res %d", recursion_counter, res);
d1773 1
a1773 1
  pthread_printf ("mutex %p, self %p, owner %p, lock_counter %d, recursion_counter %u",
d1802 1
a1802 1
  pthread_printf ("mutex %p, owner %p, self %p, lock_counter %d, recursion_counter %u, type %d, res %d",
d2503 1
a2503 1
		    "status %y", status);
d3052 1
a3052 2
  syscall_printf ("%d = pthread_sigmask(%d, %p, %p)",
		  res, operation, set, old_set);
d3535 1
a3535 1
      pthread_printf ("sem %p", this);
@


1.270.2.8
log
@Pull in changes from HEAD
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d1394 1
d1398 1
a1398 1
  reader = lookup_reader ();
d1408 7
d1426 3
a1428 7
  if ((reader = add_reader ()))
    ++reader->n;
  else
    {
      result = EAGAIN;
      goto DONE;
    }
d1440 1
d1444 1
a1444 1
  if (writer || waiting_writers)
d1448 3
a1450 3
      RWLOCK_READER *reader = lookup_reader ();
      if (!reader)
	reader = add_reader ();
d1453 6
d1476 1
a1476 1
  if (writer == self || lookup_reader ())
d1523 1
d1529 1
a1529 1
      if (writer != pthread::self ())
d1539 1
a1539 1
      struct RWLOCK_READER *reader = lookup_reader ();
d1561 2
a1562 2
pthread_rwlock::RWLOCK_READER *
pthread_rwlock::add_reader ()
d1564 1
a1564 4
  RWLOCK_READER *rd = new RWLOCK_READER;
  if (rd)
    List_insert (readers, rd);
  return rd;
d1574 1
a1574 1
pthread_rwlock::lookup_reader ()
a1576 1
  pthread_t thread = pthread::self ();
d1795 1
a1795 1
      tid = 0;		// thread-id
d1922 1
a1922 1
      tid = 0;		// thread-id
@


1.270.2.9
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.270.2.10
log
@Pull in changes from HEAD
@
text
@d351 1
a351 1
  thread->set_tls_self_pointer ();
d370 1
a370 1
      thread->set_tls_self_pointer ();
d376 1
a376 1
pthread::set_tls_self_pointer ()
d378 2
a379 2
  cygtls = &_my_tls;
  _my_tls.tid = this;
d1929 1
a1929 5
  /* This *must* be set prior to calling set_tls_self_pointer or there is
     a race with the signal processing code which may miss the signal mask
     settings. */
  _my_tls.sigmask = thread->parent_sigmask;
  thread->set_tls_self_pointer ();
d1936 1
@


1.269
log
@* cygwait.h (LARGE_NULL): Define.
(cancelable_wait): Define variant which accepts DWORD time argument.
(cygwait): Use cancelable_wait with DWORD argument.
(cygwait): Use cancelable_wait with DWORD argument and cw_sig_eintr for
timeout-only case.
* exceptions.cc (handle_sigsuspend): Use LARGE_NULL as second argument to
distinguish between cancelable_wait variants.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_timedwait): Ditto.
* thread.h (fast_mutex::lock): Ditto.
* wait.cc (wait4): Ditto.
@
text
@d1747 1
a1747 1
      cancelable_wait (win32_obj_id, LARGE_NULL, cw_sig);
d2367 1
a2367 1
      switch (cancelable_wait ((*thread)->win32_obj_id, LARGE_NULL, cw_sig | cw_cancel))
d3018 1
a3018 4
    {
      thread->cygtls->set_threadkill ();
      rval = sig_send (NULL, si, thread->cygtls);
    }
d3501 1
a3501 1
  switch (cancelable_wait (win32_obj_id, LARGE_NULL, cw_cancel | cw_cancel_self | cw_sig_eintr))
@


1.268
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d1747 1
a1747 1
      cancelable_wait (win32_obj_id, NULL, cw_sig);
d2367 1
a2367 1
      switch (cancelable_wait ((*thread)->win32_obj_id, NULL, cw_sig | cw_cancel))
d3504 1
a3504 1
  switch (cancelable_wait (win32_obj_id, NULL, cw_cancel | cw_cancel_self | cw_sig_eintr))
@


1.267
log
@	* thread.cc: Remove temporary newlib workaround, now that newlib
	handles thread cancellation by itself.
	(class __cygwin_lock_handler): Remove.
	(__cygwin_lock_cleanup): Remove.
	(__cygwin_lock_lock): Revert newlib workaround,
	(__cygwin_lock_trylock): Ditto.
	(__cygwin_lock_unlock): Ditto.
	(pthread::pop_cleanup_handler): Ditto.
@
text
@d35 1
a940 86
DWORD
cancelable_wait (HANDLE object, PLARGE_INTEGER timeout,
		 const cw_cancel_action cancel_action,
		 const enum cw_sig_wait sig_wait)
{
  DWORD res;
  DWORD num = 0;
  HANDLE wait_objects[4];
  pthread_t thread = pthread::self ();

  /* Do not change the wait order.
     The object must have higher priority than the cancel event,
     because WaitForMultipleObjects will return the smallest index
     if both objects are signaled. */
  wait_objects[num++] = object;
  DWORD cancel_n;
  if (cancel_action == cw_no_cancel || !pthread::is_good_object (&thread) ||
      thread->cancelstate == PTHREAD_CANCEL_DISABLE)
    cancel_n = WAIT_TIMEOUT + 1;
  else
    {
      cancel_n = WAIT_OBJECT_0 + num++;
      wait_objects[cancel_n] = thread->cancel_event;
    }

  DWORD sig_n;
  if (sig_wait == cw_sig_nosig)
    sig_n = WAIT_TIMEOUT + 1;
  else
    {
      sig_n = WAIT_OBJECT_0 + num++;
      wait_objects[sig_n] = signal_arrived;
    }

  DWORD timeout_n;
  if (!timeout)
    timeout_n = WAIT_TIMEOUT + 1;
  else
    {
      timeout_n = WAIT_OBJECT_0 + num++;
      if (!_my_tls.locals.cw_timer)
	NtCreateTimer (&_my_tls.locals.cw_timer, TIMER_ALL_ACCESS, NULL,
		       NotificationTimer);
      NtSetTimer (_my_tls.locals.cw_timer, timeout, NULL, NULL, FALSE, 0, NULL);
      wait_objects[timeout_n] = _my_tls.locals.cw_timer;
    }

  while (1)
    {
      res = WaitForMultipleObjects (num, wait_objects, FALSE, INFINITE);
      if (res == cancel_n)
	{
	  if (cancel_action == cw_cancel_self)
	    pthread::static_cancel_self ();
	  res = WAIT_CANCELED;
	}
      else if (res == timeout_n)
	res = WAIT_TIMEOUT;
      else if (res != sig_n)
	/* all set */;
      else if (sig_wait == cw_sig_eintr)
	res = WAIT_SIGNALED;
      else
	{
	  _my_tls.call_signal_handler ();
	  continue;
	}
      break;
    }

  if (timeout)
    {
      TIMER_BASIC_INFORMATION tbi;

      NtQueryTimer (_my_tls.locals.cw_timer, TimerBasicInformation, &tbi,
		    sizeof tbi, NULL);
      /* if timer expired, TimeRemaining is negative and represents the
	  system uptime when signalled */
      if (timeout->QuadPart < 0LL)
	timeout->QuadPart = tbi.SignalState ? 0LL : tbi.TimeRemaining.QuadPart;
      NtCancelTimer (_my_tls.locals.cw_timer, NULL);
    }

  return res;
}

d1231 1
a1231 1
  rv = cancelable_wait (sem_wait, timeout, cw_no_cancel_self, cw_sig_eintr);
d1746 2
a1747 1
      cancelable_wait (win32_obj_id, NULL, cw_no_cancel, cw_sig_resume);
d1887 2
a1888 1
	  cancelable_wait (win32_obj_id, &timeout, cw_no_cancel, cw_sig_resume);
d1933 1
d2367 1
a2367 1
      switch (cancelable_wait ((*thread)->win32_obj_id, NULL, cw_no_cancel_self, cw_sig_resume))
d3482 1
a3482 1
  switch (cancelable_wait (win32_obj_id, &timeout, cw_cancel_self, cw_sig_eintr))
d3504 1
a3504 1
  switch (cancelable_wait (win32_obj_id, NULL, cw_cancel_self, cw_sig_eintr))
@


1.266
log
@	* thread.cc (__cygwin_lock_lock): Replace null thread check with test
	for cygwin_finished_initializing to handle process startup.
	(__cygwin_lock_trylock): Ditto.
	(__cygwin_lock_unlock): Ditto.
@
text
@a97 44
#define WORKAROUND_NEWLIB

#ifdef WORKAROUND_NEWLIB
/* FIXME:

   This cleanup stuff is necessary to harden Cygwin against thread
   cancellation.  In theory, installing a cleanup handler is the task of
   the calling function.

   The problem here is that a lot of calling functions are in newlib's
   stdio implementation.  So, the right thing to do would be to change
   newlib's stdio functions to install the required pthread cleanup
   handlers.

   This is a bigger task than it sounds, so, as a temporary workaround,
   what we do here is to install a cleanup handler in the lock function
   itself and to cleanup in the unlock function.  This works around the
   problem for the time being. */
class __cygwin_lock_handler : public __pthread_cleanup_handler
{
public:
  pthread_mutex_t *lock;

  __cygwin_lock_handler (__cleanup_routine_type _fn, _LOCK_T *_lock)
  {
    function = _fn;
    arg = this;
    next = NULL;
    lock = (pthread_mutex_t *) _lock;
  }
  void *operator new (size_t) __attribute__ ((nothrow))
  {return cmalloc (HEAP_BUF, sizeof (__cygwin_lock_handler));}
  void operator delete (void *p) { cfree (p); }
};

static void
__cygwin_lock_cleanup (void *hdl)
{
  __cygwin_lock_handler *cleanup = (__cygwin_lock_handler *) hdl;
  pthread_mutex_unlock (cleanup->lock);
  delete cleanup;
}
#endif /* WORKAROUND_NEWLIB */

a101 8
#ifdef WORKAROUND_NEWLIB
  if (cygwin_finished_initializing)
    {
      __cygwin_lock_handler *cleanup
	= new __cygwin_lock_handler (__cygwin_lock_cleanup, lock);
      pthread::self ()->push_cleanup_handler (cleanup);
    }
#endif /* WORKAROUND_NEWLIB */
a107 16
#ifdef WORKAROUND_NEWLIB
  if (cygwin_finished_initializing)
    {
      __cygwin_lock_handler *cleanup
      	= new __cygwin_lock_handler (__cygwin_lock_cleanup, lock);
      pthread::self ()->push_cleanup_handler (cleanup);
      int ret = pthread_mutex_trylock ((pthread_mutex_t*) lock);
      if (ret)
	{
	  pthread::self ()->pop_cleanup_handler (0);
	  delete cleanup;
	}
      return ret;
    }
  else
#endif /* WORKAROUND_NEWLIB */
d111 1
a114 5
#ifdef WORKAROUND_NEWLIB
  if (cygwin_finished_initializing)
    pthread::self ()->pop_cleanup_handler (1);
  else
#endif /* WORKAROUND_NEWLIB */
a1089 7
#ifdef WORKAROUND_NEWLIB
      /* We split out handler->next so we can set cleanup_stack to handler->next
	 without relying on handler still existing.  This allows to delete the
	 handler in the handler function.  For a description why we need that,
	 at least temporarly, see the comment preceeding the definition of
	 __cygwin_lock_handler earlier in this file. */
      __pthread_cleanup_handler *next = handler->next;
a1092 4
      cleanup_stack = next;
#else
      if (execute)
	(*handler->function) (handler->arg);
a1093 1
#endif /* WORKAROUND_NEWLIB */
@


1.265
log
@	* thread.cc (__cygwin_lock_lock): Take null thread at process startup
	into account.
	(__cygwin_lock_trylock): Ditto.
	(__cygwin_lock_unlock): Ditto.
@
text
@d147 1
a147 1
  if (pthread::self () != pthread_null::get_null_pthread ())
d161 1
a161 2
  __cygwin_lock_handler *cleanup = NULL;
  if (pthread::self () != pthread_null::get_null_pthread ())
d163 2
a164 1
      cleanup = new __cygwin_lock_handler (__cygwin_lock_cleanup, lock);
d166 7
d174 2
a175 8
  int ret = pthread_mutex_trylock ((pthread_mutex_t*) lock);
  if (ret && pthread::self () != pthread_null::get_null_pthread ())
    {
      pthread::self ()->pop_cleanup_handler (0);
      delete cleanup;
    }
  return ret;
#else
a176 1
#endif /* WORKAROUND_NEWLIB */
d183 1
a183 1
  if (pthread::self () != pthread_null::get_null_pthread ())
@


1.264
log
@	* thread.cc (pthread::cancel): Re-allow asynchronous cancellation from
	Cygwin code since it looks like the problem is Windows only.
@
text
@d147 6
a152 3
  __cygwin_lock_handler *cleanup
    = new __cygwin_lock_handler (__cygwin_lock_cleanup, lock);
  pthread::self ()->push_cleanup_handler (cleanup);
d161 6
a166 3
  __cygwin_lock_handler *cleanup
    = new __cygwin_lock_handler (__cygwin_lock_cleanup, lock);
  pthread::self ()->push_cleanup_handler (cleanup);
d168 5
a172 2
  if (ret)
    pthread::self ()->pop_cleanup_handler (0);
d183 4
a186 2
  pthread::self ()->pop_cleanup_handler (1);
#else
a187 1
#endif /* WORKAROUND_NEWLIB */
@


1.263
log
@	* thread.cc: Add a temporary workaround to help Cygwin along while
	newlib doesn't install cleanup handlers.  Explain the problem.
	(class __cygwin_lock_handler): New class.
	(__cygwin_lock_cleanup): New function.
	(__cygwin_lock_lock): Push __cygwin_lock_cleanup thread cleanup
	handler.
	(__cygwin_lock_trylock): Ditto.
	(__cygwin_lock_unlock): Pop thread cleanup handler.
	(pthread::pop_cleanup_handler): Temporarily allow cleanup function to
	destroy cleanup handler so we can pop in another function than we
	pushed in.
@
text
@a633 1
      static uintptr_t cyg_addr;
d637 5
a641 16
      /* FIXME:
      
         File access (and probably more) in Cygwin is not foolproof in terms of
         asynchronous thread cancellation.  For instance, the cleanup of the
         tmp_buf pointers needs to be changed to use pthread_cleanup_push/pop,
         rather than being hidden in the myfault class.  We have to inspect
         all Cygwin functions so that none of them is left in a wrong or
         undefined state on thread cancellation.

         For the time being, just disable asynchronous cancellation if the
         thread is currently executing Cygwin or Windows code.  Rely on
         deferred cancellation in this case. */
      if (!cyg_addr)
        cyg_addr = (uintptr_t) GetModuleHandle ("cygwin1.dll");
      if ((context.Eip < cyg_addr || context.Eip >= (uintptr_t) cygheap)
          && !cygtls->inside_kernel (&context))
d648 5
a652 6
  /* Setting the context to another function does not work if the thread is
     waiting in WFMO.  For instance, a thread which waits for a semaphore in
     sem_wait will call cancelable_wait which in turn calls WFMO.  While this
     WFMO call is cancelable by setting the thread's cancel_event object, the
     OS apparently refuses to set the thread's context and continues to wait
     for the WFMO conditions.  This is *not* reflected in the return value of
d654 2
a655 3
     So, what we do here is to set the cancel_event as well.  This allows the
     WFMO call in cancelable_wait and elsewhere to return and to handle the
     cancel request by itself. */
@


1.262
log
@	* thread.cc (pthread::cancel): Only allow asynchronous cancellation
	if the thread is not executing Cygwin or Windows code.  Explain why.
@
text
@d98 44
d146 5
d157 9
d167 1
a169 1

d173 3
d177 1
d1166 7
d1176 4
d1181 1
@


1.261
log
@	* thread.cc (pthread::precreate): Make sure mutex is recursive.
	Explain why.
@
text
@d572 1
d576 20
a595 2
      context.Eip = (DWORD) pthread::static_cancel_self;
      SetThreadContext (win32_obj_id, &context);
@


1.260
log
@	* thread.cc (pthread::pop_cleanup_handler): Move setting the cancelstate
	to PTHREAD_CANCEL_DISABLE from here...
	(pthread::pop_all_cleanup_handlers): ...to here, otherwise any explicit
	call to pthread_cleanup_pop disables cancellation for this thread.
@
text
@d434 12
a445 2
  /* Change the mutex type to NORMAL to speed up mutex operations */
  mutex.set_type (PTHREAD_MUTEX_NORMAL);
@


1.259
log
@	* thread.cc (pthread::cancel): Set thread's cancel_event in
	PTHREAD_CANCEL_ASYNCHRONOUS case, too.  Explain why.
@
text
@a1071 3
  /* We will no honor cancels since the thread is exiting.  */
  cancelstate = PTHREAD_CANCEL_DISABLE;

d1087 3
@


1.258
log
@* DevNotes: Add entry cgf-000006.
* thread.cc (pthread::pop_cleanup_handler): Set cancel state to disabled to
avoid recursively waiting for cancel.
@
text
@d569 12
@


1.257
log
@	* thread.cc (cancelable_wait): Don't malloc tbi, just make it a struct
	on the stack to avoid memory leak.
@
text
@d1060 3
@


1.256
log
@	* thread.cc: Drop including unused headers.
@
text
@d985 1
a985 2
      const size_t sizeof_tbi = sizeof (TIMER_BASIC_INFORMATION);
      PTIMER_BASIC_INFORMATION tbi = (PTIMER_BASIC_INFORMATION) malloc (sizeof_tbi);
d987 2
a988 2
      NtQueryTimer (_my_tls.locals.cw_timer, TimerBasicInformation, tbi,
		    sizeof_tbi, NULL);
d992 1
a992 1
	timeout->QuadPart = tbi->SignalState ? 0LL : tbi->TimeRemaining.QuadPart;
@


1.255
log
@	* miscfuncs.cc (DEFAULT_STACKSIZE): Remove.
	(CygwinCreateThread): Simplify code by assuming that now stack-related
	input values are undefined.  Set stack protection to PAGE_READWRITE,
	as is default on Windows.  Add lengthy comment to explain POSIX
	guardpage.
	* thread.cc (pthread_attr::pthread_attr): Initialize stacksize as
	PTHREAD_DEFAULT_STACKSIZE.  Initialize guardsize as
	PTHREAD_DEFAULT_GUARDSIZE.
	* thread.h (PTHREAD_DEFAULT_STACKSIZE): Define.  Add comment to explain.
	(PTHREAD_DEFAULT_GUARDSIZE): Define.
@
text
@a29 1
#include "pinfo.h"
a30 2
#include "perprocess.h"
#include "cygtls.h"
a34 1
#include "miscfuncs.h"
@


1.254
log
@	* thread.cc (__pthread_cond_wait_init): New static function replacing
	__pthread_cond_dowait.  Only check and potentially initialize cond and
	mutex, drop call to (*cond)->wait.
	(pthread_cond_timedwait): Replace call to __pthread_cond_dowait with
	separate calls to __pthread_cond_wait_init and (*cond)->wait to be
	able to initialize cond before accessing its clock_id member.
	(pthread_cond_wait): Ditto (more or less).
@
text
@d1130 2
a1131 2
inheritsched (PTHREAD_INHERIT_SCHED), stackaddr (NULL), stacksize (0),
guardsize ((size_t) -1)
@


1.253
log
@Update copyright on all files checked in so far this year.
* fhandler.h: Use #pragma once rather than ifdef guards.
(fhandler_console::tc_getpgid): Return our pgid if we have never opened a
console.
* fork.cc: Rearrange includes to accommodate fhandler.h use of pinfo.h.
* sigproc.cc: Ditto.
* spawn.cc: Ditto.
(child_info_spawn::worker): Query myself->pgid rather than calling expensive
function.
* thread.h: Use #pragma once rather than ifdef guards.
* pinfo.h: Use #pragma once rather than ifdef guards.
(pinfo::remember): Don't define if sigproc.h has not been included.
(pinfo::reattach): Ditto.
* sigproc.h: Use #pragma once rather than ifdef guards.  Use different test to
see if pinfo.h has been included.
@
text
@d2749 1
a2749 2
__pthread_cond_dowait (pthread_cond_t *cond, pthread_mutex_t *mutex,
		       PLARGE_INTEGER waitlength)
d2761 1
a2761 1
  return (*cond)->wait (*mutex, waitlength);
d2777 4
d2809 1
a2809 1
  return __pthread_cond_dowait (cond, mutex, &timeout);
d2817 4
a2820 1
  return __pthread_cond_dowait (cond, mutex, NULL);
@


1.252
log
@	* cygwin.din (pthread_sigqueue): Export.
	* posix.sgml (std-gnu): Add pthread_sigqueue.
	* thread.cc (pthread_sigqueue): New function.
	* include/thread.h (pthread_sigqueue): New function.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
@


1.251
log
@	* thread.cc: Mark pthread_rwlock_timedrdlock and
	pthread_rwlock_timedwrlock as not yet implemented in the list of
	cancellation points.
@
text
@d3096 18
@


1.250
log
@	Throughout use wincap.allocation_granularity instead of getpagesize.
	Throughout use wincap.page_size instead of getsystempagesize.
	Throughout use "status" as variable name to hold NTSTATUS values.
	* fhandler_mem.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	Fix debug_printf output.  Rectify long statements.  Fix comment
	formatting.
	* fhandler_proc.cc: Ditto.
	(format_proc_swaps): Drop useless test for ERROR_PROC_NOT_FOUND.
	* fhandler_process.cc: Ditto as in fhandler_mem.cc.
	(get_process_state): Rearrange allocation loop.  Use malloc/realloc.
	(get_mem_values): Fix potential NULL pointer usage.  Drop unused
	variable.
	* pinfo.cc (winpids::enum_processes): Handle low memory gracefully.
	* sec_auth.cc (get_priv_list): Drop local variable ret.
	* shared.cc (memory_init): Drop outdated call to getpagesize.
	* syscalls.cc (getsystempagesize): Remove.
	* sysconf.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	(sysinfo): Constify sizeof_stodi.  Drop useless test for
	ERROR_PROC_NOT_FOUND.
	* thread.cc (pthread_getattr_np): Cast pointers to uintptr_t rather
	than to int for pointer arithmetic.
	* winsup.h (getsystempagesize): Drop declaration.
@
text
@d813 2
a814 2
      pthread_rwlock_timedrdlock ()
      pthread_rwlock_timedwrlock ()
@


1.249
log
@* dcrt0.cc (init_windows_system_directory): Record system_wow64_directory
information.
* exceptions.cc (_cygtls::inside_kernel): Modernize comment.  Consider
executing a DLL from the Wow64 directory as being "in the kernel".
(_cygtls::call_signal_handler): For now, only deal with main_tls signals if
main_tls is known to be executing in the cygwin DLL.  To more closely emulate
linux, consider the operation to be restartable if not executing in the main
thread.
* globals.cc (windows_system_directory): Remove NO_COPY.
(windows_system_directory_length): Ditto.
(system_wow64_directory): New variable.
(system_wow64_directory_length): Ditto.
* select.cc (cygwin_select): Don't issue a EINTR on non-main threads since that
seems to be what Linux does.  Add missing break to signal case/switch.
(select_stuff::wait): Don't issue a EINTR on non-main threads since that seems
to be what Linux does.  Remove now-unneeded accommodation for
WAIT_IO_COMPLETION.  Add a comment.
* sigproc.h (cygwait): Ditto.  Don't return if signal_received noticed and it's
not the main thread.
* signal.cc (sigprocmask): Add standard syscall debug stuff.
* thread.cc (pthread_sigmask): Ditto.
@
text
@d2512 1
a2512 1
  NTSTATUS ret;
d2532 4
a2535 4
  ret = NtQueryInformationThread (thread->win32_obj_id, ThreadBasicInformation,
				  tbi, sizeof_tbi, NULL);

  if (NT_SUCCESS (ret))
d2540 2
a2541 1
      (*attr)->stacksize = (int)tib->StackBase - (int)tib->StackLimit;
d2546 1
a2546 1
		    "status %p", ret);
@


1.248
log
@	* thread.cc (pthread::pthread): Drop setting parent_tls.  Call
	sigprocmask to copy parent thread signal mask into new parent_sigmask
	member.
	(pthread::thread_init_wrapper): Copy _my_tls.sigmask from new
	parent_sigmask member.
	* thread.h (class pthread): Drop parent_tls.  Add parent_sigmask.
@
text
@d3090 3
a3092 1
  return handle_sigprocmask (operation, set, old_set, _my_tls.sigmask);
@


1.247
log
@* thread.cc (pthread::exit): Create dummy tls structure to hold _main_tls
contents if we've asked _main_tls to exit.
@
text
@d385 1
a385 1
  parent_tls = &_my_tls;
d1988 1
a1988 1
  _my_tls.sigmask = thread->parent_tls->sigmask;
@


1.246
log
@* cygwin.din (clock_nanosleep): Export.
* posix.sgml (std-notimpl): Move clock_nanosleep from here...
(std-susv4): ... to here.
(std-notes): Note limitations of clock_nanosleep.
* signal.cc (clock_nanosleep): Renamed from nanosleep, adding clock_id
and flags arguments and changing return values throughout.
Improve checks for illegal rqtp values.  Add support for
CLOCK_MONOTONIC and TIMER_ABSTIME.
(nanosleep): Rewrite in terms of clock_nanosleep.
(sleep): Ditto.
(usleep): Ditto.
* thread.cc: Mark clock_nanosleep in list of cancellation points.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d520 10
a529 1
    ExitThread (0);
@


1.245
log
@* cygtls.h (struct _local_storage): Add cw_timer member.
* cygtls.cc (_cygtls::init_thread): Initialize locals.cw_timer.
(_cygtls::fixup_after_fork): Ditto.
* tlsoffsets.h: Regenerate.
* ntdll.h (enum _TIMER_INFORMATION_CLASS): Define.
(struct _TIMER_BASIC_INFORMATION): Define.
(NtQueryTimer): Declare function.
* thread.h (cancelable_wait): Change timeout argument to
PLARGE_INTEGER and provide NULL default.
(fast_mutex::lock): Adjust accordingly.
(pthread_cond::wait): Change timeout argument to PLARGE_INTEGER
and default to NULL.
* thread.cc (cancelable_wait): Change timeout argument to
PLARGE_INTEGER.  Initialize _cygtls.locals.cw_timer if needed.
Use NT waitable timers for handling timeout.  Return remaining time
to timeout argument if timeout was relative.
(pthread_cond::wait): Change timeout argument to PLARGE_INTEGER.
Adjust to change in cancelable_wait.
(pthread_mutex::lock): Adjust to change in cancelable_wait.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(__pthread_cond_dowait): Change waitlength argument to PLARGE_INTEGER.
Adjust to changes in cancelable_wait and pthread_cond::wait.
(pthread_cond_timedwait): Adjust to change in __pthread_cond_dowait.
(pthread_cond_wait): Ditto.
(semaphore::_timedwait): Adjust to change in cancelable_wait.
(semaphore::_wait): Ditto.
* exceptions.cc (handle_sigsuspend): Ditto.
* signal.cc (nanosleep): Ditto.
* wait.cc (wait4): Ditto. Fix copyright dates.
* times.cc (FACTOR, NSPERSEC): Move from here...
* hires.h (FACTOR, NSPERSEC): ...to here.
@
text
@d580 1
a580 1
    o clock_nanosleep ()
@


1.244
log
@* cygwin.din (pthread_condattr_getclock): Export.
(pthread_condattr_setclock): Export.
* posix.sgml (std-notimpl): Move pthread_condattr_getclock and
pthread_condattr_setclock from here...
(std-susv4): ... to here.
* sysconf.cc (sca): Set _SC_CLOCK_SELECTION to _POSIX_CLOCK_SELECTION.
* thread.cc: (pthread_condattr::pthread_condattr): Initialize clock_id.
(pthread_cond::pthread_cond): Initialize clock_id.
(pthread_cond_timedwait): Use clock_gettime() instead of gettimeofday()
in order to support all allowed clocks.
(pthread_condattr_getclock): New function.
(pthread_condattr_setclock): New function.
* thread.h (class pthread_condattr): Add clock_id member.
(class pthread_cond): Ditto.
* include/pthread.h: Remove obsolete comment.
(pthread_condattr_getclock): Declare.
(pthread_condattr_setclock): Declare.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d909 1
a909 1
cancelable_wait (HANDLE object, DWORD timeout,
d915 1
a915 1
  HANDLE wait_objects[3];
d942 13
d957 1
a957 1
      res = WaitForMultipleObjects (num, wait_objects, FALSE, timeout);
d964 2
d977 15
d1261 1
a1261 1
pthread_cond::wait (pthread_mutex_t mutex, DWORD dwMilliseconds)
d1282 1
a1282 1
  rv = cancelable_wait (sem_wait, dwMilliseconds, cw_no_cancel_self, cw_sig_eintr);
d1797 1
a1797 1
      cancelable_wait (win32_obj_id, INFINITE, cw_no_cancel, cw_sig_resume);
d1932 7
a1938 2
      else /* Minimal timeout to minimize CPU usage while still spinning. */
	cancelable_wait (win32_obj_id, 1L, cw_no_cancel, cw_sig_resume);
d2415 1
a2415 1
      switch (cancelable_wait ((*thread)->win32_obj_id, INFINITE, cw_no_cancel_self, cw_sig_resume))
d2740 1
a2740 1
		       DWORD waitlength)
d2760 1
a2760 1
  DWORD waitlength;
d2776 1
a2776 3
  /* Check for immediate timeout before converting to microseconds, since
     the resulting value can easily overflow long.  This also allows to
     evaluate microseconds directly in DWORD. */
d2782 15
a2796 3
  waitlength = (abstime->tv_sec - tp.tv_sec) * 1000;
  waitlength += (abstime->tv_nsec - tp.tv_nsec) / 1000000;
  return __pthread_cond_dowait (cond, mutex, waitlength);
d2804 1
a2804 1
  return __pthread_cond_dowait (cond, mutex, INFINITE);
d3487 1
a3487 2
  struct timeval tv;
  long waitlength;
d3500 4
a3503 6
  gettimeofday (&tv, NULL);
  waitlength = abstime->tv_sec * 1000 + abstime->tv_nsec / (1000 * 1000);
  waitlength -= tv.tv_sec * 1000 + tv.tv_usec / 1000;
  if (waitlength < 0)
    waitlength = 0;
  switch (cancelable_wait (win32_obj_id, waitlength, cw_cancel_self, cw_sig_eintr))
d3525 1
a3525 1
  switch (cancelable_wait (win32_obj_id, INFINITE, cw_cancel_self, cw_sig_eintr))
@


1.243
log
@whitespace elimination
@
text
@d1102 2
a1103 1
  (PTHREAD_CONDATTR_MAGIC), shared (PTHREAD_PROCESS_PRIVATE)
d1128 2
a1129 2
  shared (0), waiting (0), pending (0), sem_wait (NULL),
  mtx_cond(NULL), next (NULL)
d1134 9
a1142 5
    if (attr->shared != PTHREAD_PROCESS_PRIVATE)
      {
	magic = 0;
	return;
      }
d2724 1
a2724 1
  struct timeval tv;
d2739 2
a2740 1
  gettimeofday (&tv, NULL);
d2744 3
a2746 3
  if (tv.tv_sec > abstime->tv_sec
      || (tv.tv_sec == abstime->tv_sec
	  && tv.tv_usec > abstime->tv_nsec / 1000))
d2749 2
a2750 2
  waitlength = (abstime->tv_sec - tv.tv_sec) * 1000;
  waitlength += (abstime->tv_nsec / 1000 - tv.tv_usec) / 1000;
d2802 26
@


1.242
log
@	* child_info.h (CURR_CHILD_INFO_MAGIC): Update.
	(class child_info_fork): Remove stacksize, add stackaddr and guardsize
	members.
	* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Partial rewrite
	to regenerate the stack exactly as in the parent.
	(child_info_fork::alloc_stack): Set stackaddr to 0, rather than
	stacksize.
	(dll_crt0_1): Check for stackaddr before changing the stack addresses
	in the TEB.
	* fork.cc (frok::child): Check for stackaddr here.
	(frok::parent): Set ch.stackaddr and ch.guardsize if not called from
	the main thread.
	* init.cc (dll_entry): Replace pointer to NT_TIB with pointer to TEB.
	Fix incorrectly changed address test before removing _my_tls.
	Set StackLimit to NULL on Windows 2000.  Explain why.
	* miscfuncs.cc (struct thread_wrapper_arg): Store stackbase rather
	than stacksize, store commitaddr, remove guardsize.  Store all pointers
	as char * for easier address arithmetic.
	(thread_wrapper): Rewrite to remove OS stack before calling thread
	function.  Add lots of comments to explain what we do.
	(CygwinCreateThread): Reserve our own stack in case we got no
	application stack.  Add comments.
	* ntdll.h (struct _TEB): Extend defintion up to DeallocationStack
	member.
	* thread.cc (pthread_attr::pthread_attr): Use "(size_t) -1"
	rather then 0xffffffff.
	* wincap.h (wincaps::has_stack_size_param_is_a_reservation): New
	element.
	* wincap.cc: Implement above element throughout.
@
text
@d1406 1
a1406 1
      	errno = EAGAIN;
d1549 1
a1549 1
      	goto DONE;
d2250 1
a2250 1
    return EINVAL;    
d2252 1
a2252 1
    return EINVAL;    
d2275 1
a2275 1
    return EINVAL;    
d2297 1
a2297 1
    return EINVAL;    
d2484 1
a2484 1
                                  tbi, sizeof_tbi, NULL);
d2496 1
a2496 1
                    "status %p", ret);
d3582 1
a3582 1
    	&& sema->luid.HighPart == luid.HighPart
@


1.241
log
@* thread.cc: Mark psiginfo and psignal as available in list of
optional cancellation points.
@
text
@d1092 1
a1092 1
guardsize (0xffffffff)
@


1.240
log
@* cygwin.din (clock_getcpuclockid): Export.
(pthread_getcpuclockid): Export.
* hires.h (PID_TO_CLOCKID): New macro.
(CLOCKID_TO_PID): New macro.
(CLOCKID_IS_PROCESS): New macro.
(THREADID_TO_CLOCKID): New macro.
(CLOCKID_TO_THREADID): New macro.
(CLOCKID_IS_THREAD): New macro.
* ntdll.h (enum _THREAD_INFORMATION_CLASS): Add ThreadTimes.
* posix.sgml (std-notimpl): Add clock_getcpuclockid and
pthread_getcpuclockid from here...
(std-susv4): ... to here.
(std-notes): Remove limitations of clock_getres and clock_gettime.
Note limitation of timer_create to CLOCK_REALTIME.
* sysconf.cc (sca): Set _SC_CPUTIME to _POSIX_CPUTIME, and
_SC_THREAD_CPUTIME to _POSIX_THREAD_CPUTIME.
* thread.cc (pthread_getcpuclockid): New function.
* timer.cc (timer_create): Set errno to ENOTSUP for CPU-time clocks.
* times.cc (clock_gettime): Handle CLOCK_PROCESS_CPUTIME_ID and
CLOCK_THREAD_CPUTIME_ID.
(clock_getres): Ditto.
(clock_settime): Set errno to EPERM for CPU-time clocks.
(clock_getcpuclockid): New function.
* include/pthread.h (pthread_getcpuclockid): Declare.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d801 2
a802 2
    o psiginfo ()
    o psignal ()
@


1.239
log
@	* cygwin.din (pthread_attr_getguardsize): Export.
	(pthread_attr_setguardsize): Export.
	(pthread_attr_setstack): Export.
	(pthread_attr_setstackaddr): Export.
	* init.cc (dll_entry): Remove wow64_test_stack_marker.  Check for
	unusual stack address by testing stack addresses from current TEB.
	Check validity of _my_tls by testing if it's within the stack as
	given in current TEB.
	* miscfuncs.cc (struct thread_wrapper_arg): New structure used to
	push all required information to thread_wrapper function.
	(thread_wrapper): Wrapper function for actual thread function.
	If an application stack has been given, change %ebp and %esp so that
	the thread function runs on that stack.  If the thread has been created
	by CygwinCreateThread, set up the POSIX guard pages if necessary.
	(CygwinCreateThread): New function.
	* miscfuncs.h (CygwinCreateThread): Declare.
	* ntdll.h (struct _TEB): Define all members up to Peb.
	* posix.sgml (std-susv4): Move pthread_attr_getguardsize,
	pthread_attr_setguardsize and pthread_attr_setstack here.
	(std-deprec): Add pthread_attr_setstackaddr.
	* sysconf.cc (sca): Set _SC_THREAD_ATTR_STACKADDR to
	_POSIX_THREAD_ATTR_STACKADDR.
	* thread.cc (pthread::precreate): Copy pthread_attr stackaddr and
	guardsize members.
	(pthread::create): Call CygwinCreateThread.
	(pthread_attr::pthread_attr): Initialize guardsize.
	(pthread_attr_setstack): New function.
	(pthread_attr_setstackaddr): New function.
	(pthread_attr_setguardsize): New function.
	(pthread_attr_getguardsize): New function.
	(pthread_getattr_np): Copy attr.guardsize.
	* thread.h (pthread_attr): Add member guardsize.
	* include/pthread.h (pthread_attr_getguardsize): Declare.
	(pthread_attr_setguardsize): Declare.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d2513 9
@


1.238
log
@* thread.h (pthread::static_cancel_self): Mark as noreturn.
(pthread::cancel_self): Ditto.
* thread.cc (pthread::cancel_self): Explicitly use pthread::exit to avoid a
"function returns" error.
@
text
@a25 3
#ifdef HAVE_CONFIG_H
#endif

d38 1
d426 1
d428 1
d458 3
a460 2
  win32_obj_id = ::CreateThread (&sec_none_nih, attr.stacksize,
				thread_init_wrapper, this, 0, &thread_id);
d1091 2
a1092 1
inheritsched (PTHREAD_INHERIT_SCHED), stackaddr (NULL), stacksize (0)
d2245 14
d2270 11
d2312 21
d2480 1
@


1.237
log
@	* select.cc (cygwin_select): Make degenerate case cancelable.
	(select_stuff::destroy): New inline method to delete memory taken
	by select_stuff.
	(select_stuff::~select_stuff): Call destroy.
	(select_stuff::wait): Add case to allow canceling select.
	* select.h (select_stuff::destroy): Declare.
	* thread.cc: Mark poll, pselect and poll as cancelable.
@
text
@d1047 3
a1049 1
  exit (PTHREAD_CANCELED);
@


1.236
log
@* cygwin.din (pthread_attr_getstack): Export.
(pthread_attr_getstackaddr): Export.
(pthread_getattr_np): Export.
* ntdll.h (enum _THREAD_INFORMATION_CLASS): Add ThreadBasicInformation.
(struct _THREAD_BASIC_INFORMATION): Define.
(NtQueryInformationThread): Declare.
* posix.sgml (std-susv4): Add pthread_attr_getstack.
(std-gnu): Add pthread_getattr_np.
(std-deprec): Add pthread_attr_getstackaddr.
(std-notimpl): Remove pthread_attr_[gs]etstackaddr, as they were
removed from SUSv4.
* thread.cc (pthread_attr::pthread_attr): Initialize stackaddr.
(pthread_attr_getstack): New function.
(pthread_attr_getstackaddr): New function.
(pthread_attr_setstacksize): Return EINVAL if passed size less than
PTHREAD_STACK_MIN, as required by POSIX.
(pthread_getattr_np): New function.
* thread.h (class pthread_attr): Add stackaddr member.
* include/pthread.h (pthread_attr_getstack): Declare.
(pthread_attr_getstackaddr): Declare unconditionally.
(pthread_attr_setstack): Declare inside false conditional for reference.
(pthread_getattr_np): Declare.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d600 1
a600 1
      poll ()
d602 1
a602 1
      pselect ()
d615 1
a615 1
      select ()
@


1.235
log
@	* thread.cc (cancelable_wait): Remove test for main thread.
	* fhandler_fifo.cc (fhandler_fifo::open_nonserver): Ditto.
@
text
@d1088 1
a1088 1
inheritsched (PTHREAD_INHERIT_SCHED), stacksize (0)
d2241 22
d2267 2
d2408 45
@


1.234
log
@	* fhandler_windows.cc (fhandler_windows::read): Use
	pthread::get_cancel_event to fetch thread's cancel event.
	* flock.cc (lf_setlock): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Ditto.
	* thread.cc (pthread::get_cancel_event): New static method.
	* thread.h (pthread::get_cancel_event): Declare.
@
text
@d933 1
a933 1
  if (sig_wait == cw_sig_nosig || &_my_tls != _main_tls)
@


1.233
log
@	* fcntl.cc (fcntl64): Call pthread_testcancel.
	* fhandler_socket.cc (fhandler_socket::connect): Ditto.
	(fhandler_socket::accept4): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* flock.cc (lf_setlock): Allow to cancel thread running blocking
	file lock.  Try to make code more readable.
	(lockf): Call pthread_testcancel.
	* mmap.cc (msync): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Call pthread::static_cancel_self
	rather than pthread_testcancel.
	* select.cc (cygwin_select): Call pthread_testcancel.
	* syscalls.cc (pread): Ditto.
	(pwrite): Ditto.
	(readv): Ditto.
	(writev): Ditto.
	(open): Ditto.
	(close): Ditto.
	(fsync): Ditto.
	* termios.cc (tcdrain): Ditto.
	* thread.cc: Align list of cancellation points with above changes.
	Mark not-implemented functions, too.
	(cancelable_wait): Don't set unused object indices to WAIT_FAILED
	since that could result in wrong behaviour.  Set them to the invalid
	value WAIT_TIMEOUT + 1 instead.
@
text
@d888 13
@


1.232
log
@	* thread.h (class pthread): Add bool member canceled.
	* thread.cc (pthread::pthread): Initialize canceled to false.
	(pthread::cancel): Set canceled before setting cancel_event.
	(pthread::testcancel): Check for canceled.  Only wait for cancel_event
	if canceled is true.  Explain why.
	(pthread::_fixup_after_fork): Set canceled to false.
@
text
@d571 3
a573 2
   and POSIX.1-2008. A start (*) indicates that the Cygwin function already
   is a cancellation point (aka "calls pthread_testcancel").
d577 3
a579 3
      accept ()
      aio_suspend ()
      clock_nanosleep ()
d581 1
a581 1
      connect ()
d583 6
a588 6
      fcntl () F_SETLKW
      fdatasync ()
      fsync ()
      getmsg ()
      getpmsg ()
      lockf () F_LOCK
d595 4
a598 4
      msync ()
      nanosleep ()
      open ()
      openat ()
d601 1
a601 1
      pread ()
d607 8
a614 8
      putmsg ()
      putpmsg ()
      pwrite ()
      read ()
      readv ()
      recv ()
      recvfrom ()
      recvmsg ()
d618 3
a620 3
      send ()
      sendmsg ()
      sendto ()
d623 3
a625 3
      sigtimedwait ()
      sigwait ()
      sigwaitinfo ()
d628 1
a628 1
      tcdrain ()
d632 1
a632 1
      waitid ()
d634 2
a635 2
      write ()
      writev ()
d642 3
a644 3
      catclose ()
      catgets ()
      catopen ()
d652 6
a657 6
      dbm_close ()
      dbm_delete ()
      dbm_fetch ()
      dbm_nextkey ()
      dbm_open ()
      dbm_store ()
d663 1
a663 1
      endnetent ()
d673 2
a674 2
      fclose ()
      fcntl () (any value)
d681 1
a681 1
      fmtmsg ()
d710 1
a710 1
      getdate ()
d726 3
a728 3
      getnetbyaddr ()
      getnetbyname ()
      getnetent ()
d749 2
a750 2
      iconv_close ()
      iconv_open ()
d754 1
a754 1
      lio_listio ()
d757 1
a757 1
      lockf ()
d780 19
a798 19
      posix_spawn ()
      posix_spawnp ()
      posix_trace_clear ()
      posix_trace_close ()
      posix_trace_create ()
      posix_trace_create_withlog ()
      posix_trace_eventtypelist_getnext_id ()
      posix_trace_eventtypelist_rewind ()
      posix_trace_flush ()
      posix_trace_get_attr ()
      posix_trace_get_filter ()
      posix_trace_get_status ()
      posix_trace_getnext_event ()
      posix_trace_open ()
      posix_trace_rewind ()
      posix_trace_set_filter ()
      posix_trace_shutdown ()
      posix_trace_timedgetnext_event ()
      posix_typed_mem_open ()
d800 2
a801 2
      psiginfo ()
      psignal ()
d829 1
a829 1
      setnetent ()
d912 1
a912 1
    cancel_n = (DWORD) -1;
d921 1
a921 1
    sig_n = (DWORD) -1;
@


1.231
log
@	* thread.cc: Update comment listing cancellation points per POSIX.
@
text
@d381 1
a381 1
		    valid (false), suspended (false),
d541 1
d875 10
a884 2
  if (IsEventSignalled (cancel_event))
    cancel_self ();
d1051 1
@


1.230
log
@	* ntdll.h (IsEventSignalled): New inline function.
	* cygthread.cc (cygthread::terminate_thread): Use IsEventSignalled in
	place of WaitForSingleObject on event with 0 timeout.
	* fhandler.cc (fhandler_base_overlapped::has_ongoing_io): Ditto.
	* fhandler_fifo.cc (fhandler_fifo::open_nonserver): Ditto.
	(fhandler_fifo::wait): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* select.cc (verify_tty_slave): Ditto.
	* thread.cc (pthread::testcancel): Ditto.
@
text
@a564 173
/*
  TODO: insert  pthread_testcancel into the required functions
  the required function list is: *indicates done, X indicates not present in cygwin.
aio_suspend ()
*close ()
*creat ()
fcntl ()
fsync ()
getmsg ()
getpmsg ()
lockf ()
mq_receive ()
mq_send ()
msgrcv ()
msgsnd ()
msync ()
nanosleep ()
open ()
*pause ()
poll ()
pread ()
*pthread_cond_timedwait ()
*pthread_cond_wait ()
*pthread_join ()
*pthread_testcancel ()
putmsg ()
putpmsg ()
pwrite ()
read ()
readv ()
select ()
*sem_wait ()
*sigpause ()
*sigsuspend ()
sigtimedwait ()
sigwait ()
sigwaitinfo ()
*sleep ()
*system ()
tcdrain ()
*usleep ()
*wait ()
*wait3()
waitid ()
*waitpid ()
write ()
writev ()

the optional list is:
catclose ()
catgets ()
catopen ()
closedir ()
closelog ()
ctermid ()
dbm_close ()
dbm_delete ()
dbm_fetch ()
dbm_nextkey ()
dbm_open ()
dbm_store ()
dlclose ()
dlopen ()
endgrent ()
endpwent ()
endutxent ()
fclose ()
fcntl ()
fflush ()
fgetc ()
fgetpos ()
fgets ()
fgetwc ()
fgetws ()
fopen ()
fprintf ()
fputc ()
fputs ()
fputwc ()
fputws ()
fread ()
freopen ()
fscanf ()
fseek ()
fseeko ()
fsetpos ()
ftell ()
ftello ()
ftw ()
fwprintf ()
fwrite ()
fwscanf ()
getc ()
getc_unlocked ()
getchar ()
getchar_unlocked ()
getcwd ()
getdate ()
getgrent ()
getgrgid ()
getgrgid_r ()
getgrnam ()
getgrnam_r ()
getlogin ()
getlogin_r ()
getpwent ()
*getpwnam ()
*getpwnam_r ()
*getpwuid ()
*getpwuid_r ()
gets ()
getutxent ()
getutxid ()
getutxline ()
getw ()
getwc ()
getwchar ()
getwd ()
glob ()
iconv_close ()
iconv_open ()
ioctl ()
lseek ()
mkstemp ()
nftw ()
opendir ()
openlog ()
pclose ()
perror ()
popen ()
printf ()
putc ()
putc_unlocked ()
putchar ()
putchar_unlocked ()
puts ()
pututxline ()
putw ()
putwc ()
putwchar ()
readdir ()
readdir_r ()
remove ()
rename ()
rewind ()
rewinddir ()
scanf ()
seekdir ()
semop ()
setgrent ()
setpwent ()
setutxent ()
strerror ()
syslog ()
tmpfile ()
tmpnam ()
ttyname ()
ttyname_r ()
ungetc ()
ungetwc ()
unlink ()
vfprintf ()
vfwprintf ()
vprintf ()
vwprintf ()
wprintf ()
wscanf ()

Note, that for fcntl (), for any value of the cmd argument.

And we must not introduce cancellation points anywhere else that's part of the posix or
opengroup specs.
 */
d567 301
@


1.229
log
@2011-04-02  Jon TURNEY  <jon.turney@@dronecode.org.uk>

        * thread.cc (semaphore::init): We cannot reliably infer anything from
        the existing contents of sem, so merely warn rather than return EBUSY
        if it looks like we are reinitialising a semaphore.
@
text
@d40 1
d746 1
a746 1
  if (WaitForSingleObject (cancel_event, 0) == WAIT_OBJECT_0)
@


1.228
log
@* thread.cc (pthread_setschedprio): New function.
* include/pthread.h (pthread_setschedprio): Declare.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
* cygwin.din (pthread_setschedprio): Export.
* posix.sgml (std-notimpl) Move pthread_setschedprio from here...
(std-susv4) ...to here.
@
text
@d3212 5
a3216 1
  /* opengroup calls this undefined */
d3219 1
a3219 2
      set_errno(EBUSY);
      return -1;
@


1.227
log
@	* cygwin.din (pthread_spin_destroy): Export.
	(pthread_spin_init): Export.
	(pthread_spin_lock): Export.
	(pthread_spin_trylock): Export.
	(pthread_spin_unlock): Export.
	* posix.sgml (std-susv4): Add pthread_spin_destroy, pthread_spin_init,
	pthread_spin_lock, pthread_spin_trylock, pthread_spin_unlock.
	(std-notimpl): Remove pthread_spin_[...].
	* pthread.cc (pthread_spin_init): New function.
	* thread.cc (pthread_spinlock::is_good_object): New function.
	(pthread_mutex::pthread_mutex): Rearrange initializers to accommodate
	protected data in pthread_mutex.
	(pthread_spinlock::pthread_spinlock): New constructor.
	(pthread_spinlock::lock): New method.
	(pthread_spinlock::unlock): New method.
	(pthread_spinlock::init): New method.
	(pthread_spin_lock): New function.
	(pthread_spin_trylock): New function.
	(pthread_spin_unlock): New function.
	(pthread_spin_destroy): New function.
	* thread.h (PTHREAD_SPINLOCK_MAGIC): Define.
	(class pthread_mutex): Change access level of members shared with
	derived classes to protected.
	(pthread_mutex::set_shared): New protected method.
	(class pthread_spinlock): New class, derived class of pthread_mutex.
	* include/pthread.h (pthread_spin_destroy): Declare.
	(pthread_spin_init): Declare.
	(pthread_spin_lock): Declare.
	(pthread_spin_trylock): Declare.
	(pthread_spin_unlock): Declare.
	* include/cygwin/types.h (pthread_spinlock_t): New typedef.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d2309 11
@


1.226
log
@	* thread.cc (semaphore::init, destroy, close): Standards conformance
	fix.  On a failure, return -1 and set errno.
	* thread.h (semaphore::terminate): Save errno since semaphore::close()
	may now modify it.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010 Red Hat, Inc.
d177 8
d1558 1
a1558 2
  win32_obj_id (NULL), recursion_counter (0),
  condwaits (0), owner (_new_mutex),
d1562 1
d1712 59
d2838 57
@


1.225
log
@	* thread.cc (valid_sched_parameters): Declare extern here.
	(sched_set_thread_priority): Ditto.
@
text
@d3079 4
a3082 1
    return EBUSY;
d3085 4
a3088 1
    return EINVAL;
d3096 2
a3097 1
      return EAGAIN;
d3106 4
a3109 1
    return EINVAL;
d3113 4
a3116 1
    return EINVAL;
d3129 4
a3132 1
    return EINVAL;
d3136 4
a3139 1
    return EINVAL;
@


1.225.2.1
log
@	* cygwin.din (pthread_spin_destroy): Export.
	(pthread_spin_init): Export.
	(pthread_spin_lock): Export.
	(pthread_spin_trylock): Export.
	(pthread_spin_unlock): Export.
	* posix.sgml (std-susv4): Add pthread_spin_destroy, pthread_spin_init,
	pthread_spin_lock, pthread_spin_trylock, pthread_spin_unlock.
	(std-notimpl): Remove pthread_spin_[...].
	* pthread.cc (pthread_spin_init): New function.
	* thread.cc (pthread_spinlock::is_good_object): New function.
	(pthread_mutex::pthread_mutex): Rearrange initializers to accommodate
	protected data in pthread_mutex.
	(pthread_spinlock::pthread_spinlock): New constructor.
	(pthread_spinlock::lock): New method.
	(pthread_spinlock::unlock): New method.
	(pthread_spinlock::init): New method.
	(pthread_spin_lock): New function.
	(pthread_spin_trylock): New function.
	(pthread_spin_unlock): New function.
	(pthread_spin_destroy): New function.
	* thread.h (PTHREAD_SPINLOCK_MAGIC): Define.
	(class pthread_mutex): Change access level of members shared with
	derived classes to protected.
	(pthread_mutex::set_shared): New protected method.
	(class pthread_spinlock): New class, derived class of pthread_mutex.
	* include/pthread.h (pthread_spin_destroy): Declare.
	(pthread_spin_init): Declare.
	(pthread_spin_lock): Declare.
	(pthread_spin_trylock): Declare.
	(pthread_spin_unlock): Declare.
	* include/cygwin/types.h (pthread_spinlock_t): New typedef.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d4 1
a4 1
   2006, 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
a176 8
pthread_spinlock::is_good_object (pthread_spinlock_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_SPINLOCK_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

inline bool
d1550 2
a1551 1
  win32_obj_id (NULL), owner (_new_mutex),
a1554 1
  recursion_counter (0), condwaits (0),
a1703 59
/* pshared spinlocks

   The infrastructure is provided by the underlying pthread_mutex class.
   The rest is a simplification implementing spin locking. */

pthread_spinlock::pthread_spinlock (int pshared) :
  pthread_mutex (NULL)
{
  magic = PTHREAD_SPINLOCK_MAGIC;
  set_type (PTHREAD_MUTEX_NORMAL);
  set_shared (pshared);
}

int
pthread_spinlock::lock ()
{
  pthread_t self = ::pthread_self ();
  int result = -1;

  do
    {
      if (InterlockedExchange ((long *) &lock_counter, 1) == 0)
	{
	  set_owner (self);
	  result = 0;
	}
      else if (pthread::equal (owner, self))
	result = EDEADLK;
      else /* Minimal timeout to minimize CPU usage while still spinning. */
	cancelable_wait (win32_obj_id, 1L, cw_no_cancel, cw_sig_resume);
    }
  while (result == -1);
  pthread_printf ("spinlock %p, self %p, owner %p", this, self, owner);
  return result;
}

int
pthread_spinlock::unlock ()
{
  pthread_t self = ::pthread_self ();
  int result = 0;

  if (!pthread::equal (owner, self))
    result = EPERM;
  else
    {
      owner = (pthread_t) _unlocked_mutex;
#ifdef DEBUGGING
      tid = 0;
#endif
      InterlockedExchange ((long *) &lock_counter, 0);
      ::SetEvent (win32_obj_id);
      result = 0;
    }
  pthread_printf ("spinlock %p, owner %p, self %p, res %d",
		  this, owner, self, result);
  return result;
}

a2770 57
/* Spinlocks  */

int
pthread_spinlock::init (pthread_spinlock_t *spinlock, int pshared)
{
  pthread_spinlock_t new_spinlock = new pthread_spinlock (pshared);
  if (!is_good_object (&new_spinlock))
    {
      delete new_spinlock;
      return EAGAIN;
    }

  myfault efault;
  if (efault.faulted ())
    {
      delete new_spinlock;
      return EINVAL;
    }

  *spinlock = new_spinlock;
  pthread_printf ("*spinlock %p, pshared %d", *spinlock, pshared);

  return 0;
}

extern "C" int
pthread_spin_lock (pthread_spinlock_t *spinlock)
{
  if (!pthread_spinlock::is_good_object (spinlock))
    return EINVAL;
  return (*spinlock)->lock ();
}

extern "C" int
pthread_spin_trylock (pthread_spinlock_t *spinlock)
{
  if (!pthread_spinlock::is_good_object (spinlock))
    return EINVAL;
  return (*spinlock)->trylock ();
}

extern "C" int
pthread_spin_unlock (pthread_spinlock_t *spinlock)
{
  if (!pthread_spinlock::is_good_object (spinlock))
    return EINVAL;
  return (*spinlock)->unlock ();
}

extern "C" int
pthread_spin_destroy (pthread_spinlock_t *spinlock)
{
  if (!pthread_spinlock::is_good_object (spinlock))
    return EINVAL;
  return (*spinlock)->destroy ();
}

@


1.224
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@d43 2
@


1.223
log
@* cygtls.h (_cygtls::init_exception_handler): Eliminate argument.
(_cygtls::andreas): Convert to a pointer.
(san): Convert to a real class with methods.  Use a linked list to keep track
of previous handlers on the "stack".
(myfault): Rewrite to use new san class rather than calling directly into
_cygtls.
* cygtls.cc (_cygtls::init_exception_handler): Just assume that we're always
using the standard exception handler.
(_cygtls::init_thread): Reflect loss of argument to init_exception_handler.
* dcrt0.cc (dll_crt0_1): Ditto.
* dfcn.cc (dlopen): Ditto.
(dlclose): Reset the exception handler after FreeLibrary.
* dll_init.cc (dll_list::detach): Make sure that the exception handler is
initialized before calling destructors.
* exceptions.cc (_cygtls::handle_exceptions): Accommodate new andreas pointer.
* thread.cc (verifyable_object_isvalid): Pass objectptr to faulted for explicit
NULL pointer checking.
* tlsoffsets.h: Regenerate.
@
text
@d459 1
a459 1
	low_priority_sleep (0);
@


1.222
log
@* thread.cc (pthread_mutex::unlock): Don't attempt to unlock if there is an
error.
@
text
@d127 1
a127 3
  /* Check for NULL pointer specifically since it is a cheap test and avoids the
     overhead of setting up the fault handler.  */
  if (!objectptr || efault.faulted ())
@


1.221
log
@* include/sys/strace.h: Define _STRACE_SPECIAL.
(strace_printf_wrap): Fix NOSTRACE definitions.
(strace_printf_wrap1): Fix NOSTRACE definitions.
(special_printf): Define.
* thread.cc: Perform minor syntax fix in a comment.  Rename
"is_good_initialzer*" to "is_initializer*" throughout.  Use pthread_printf
rather than debug_printf throughout.  Add extra pthread_printf debugging
throughout.
(pthread_mutex::_new_mutex): New constant value.
(pthread_mutex::_unlocked_mutex): Ditto.
(pthread_mutex::_destroyed_mutex): Ditto.
(pthread_mutex::no_owner): Define new function.
(pthread_mutex::can_be_unlocked): Detect no_owner situation.  Handle
PTHREAD_MUTEX_NORMAL as a special case.
(pthread::create_cancel_event): Use C++ boolean values.
(pthread::precreate): Use method to set mutex type.
(pthread_cond::pthread_cond): Ditto.
(pthread_rwlock::pthread_rwlock): Ditto.
(pthread_mutex::pthread_mutex): Set owner to _new_mutex initially.
(pthread_mutex::~pthread_mutex): Reset various elements to make it clearer if
they are incorrectly reused.
(pthread_mutex::lock): Add clarifying comment.
(pthread_mutex::unlock): Attempt to handle various mutex types correctly.  In
particular, reinstate ability to have one thread unlock another thread's mutex
if type == PTHREAD_MUTEX_NORMAL.
(semaphore::_fixup_after_fork): Avoid redundancy.
(pthread_mutex::_fixup_after_fork): Ditto.  Fix debugging statement.
(__pthread_cond_dowait): Accommodate changes to remove previously inexplicable
use can_be_unblocked() as a static function.
* thread.h: Rename "is_good_initialzer*" to "is_initializer*" throughout.
(pthread_mutex): Reorganize.  Make many things private.
(pthread_mutex::no_owner): Define new method.
(pthread_mutex::_new_mutex): Define new constant.
(pthread_mutex::_unlocked_mutex): Ditto.
(pthread_mutex::_destroyed_mutex): Ditto.
@
text
@d1617 1
a1617 1
  int res;
d1622 1
a1622 1
    return type == PTHREAD_MUTEX_ERRORCHECK ? EINVAL : 0;
d1625 1
a1625 1
  if (recursion_counter > 0 && --recursion_counter == 0)
d1638 2
a1639 2
  pthread_printf ("mutex %p, owner %p, self %p, lock_counter %d, recursion_counter %d, res %d",
		  this, owner, self, lock_counter, recursion_counter, res);
@


1.220
log
@* pthread.cc (pthread_mutex_init): Explicitly fill out third arg to
pthread_mutex::init.
* thread.cc: Remov some obsolete comments.
(verifyable_object_isvalid): Reflect change to use thread_magic_t for magic
numbers.
(pthread_mutex::pthread_mutex): Set magic number to invalid initially until
we've verified that everything is valid.
(pthread_mutex::unlock): Fix a comment.
(verifyable_object::verifyable_object): Delete here.
(~verifyable_object::~verifyable_object): Ditto.
(pthread_mutex::init): Don't run is_good_initializer for non-static objects.
* thread.h (thread_magic_t): New typedef.
(verifyable_object::verifyable_object): Use thread_magic_t;
(verifyable_object::magic): Ditto.
(pthread_mutex::is_good_initializer_or_bad_object): Remove unneeded variable
names.
(pthread_mutex::can_be_unlocked): Ditto.
(pthread_mutex::init): Ditto.  Remove default for third argument.
@
text
@d19 1
a19 1
   Some caveats: PROCESS_SHARED objects while they pretend to be process
d51 25
d185 1
a185 1
pthread_mutex::is_good_initializer (pthread_mutex_t const *mutex)
d196 1
a196 1
pthread_mutex::is_good_initializer_or_object (pthread_mutex_t const *mutex)
d206 1
d208 1
a208 1
pthread_mutex::can_be_unlocked (pthread_mutex_t const *mutex)
a210 3

  if (!is_good_object (mutex))
    return false;
d213 4
a216 2
  return (*mutex)->recursion_counter == 1
	 && pthread::equal ((*mutex)->owner, self);
d245 1
a245 1
pthread_cond::is_good_initializer (pthread_cond_t const *cond)
d253 1
a253 1
pthread_cond::is_good_initializer_or_object (pthread_cond_t const *cond)
d270 1
a270 1
pthread_rwlock::is_good_initializer (pthread_rwlock_t const *rwlock)
d278 1
a278 1
pthread_rwlock::is_good_initializer_or_object (pthread_rwlock_t const *rwlock)
d395 1
a395 1
  cancel_event = ::CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
d430 1
a430 1
  mutex.type = PTHREAD_MUTEX_NORMAL;
d985 1
a985 1
  mtx_in.type = PTHREAD_MUTEX_NORMAL;
d995 1
a995 1
  mtx_out.type = PTHREAD_MUTEX_NORMAL;
d1000 1
a1000 1
      debug_printf ("CreateSemaphore failed. %E");
d1199 1
a1199 1
  mtx.type = PTHREAD_MUTEX_NORMAL;
d1551 1
a1551 1
  condwaits (0), owner (NULL),
d1576 4
a1579 1
    CloseHandle (win32_obj_id);
d1582 2
d1592 1
a1592 1
  if (InterlockedIncrement ((long *)&lock_counter) == 1)
d1594 2
a1595 1
  else if (type == PTHREAD_MUTEX_NORMAL || !pthread::equal (owner, self))
d1609 2
d1617 1
d1619 6
a1624 5
  if (!pthread::equal (owner, self))
    return EPERM;

  /* Don't try to unlock anything if recursion_counter == 0 initially.
     That means that we've forked. */
d1626 2
d1629 1
a1629 1
      owner = NULL;
d1635 1
d1638 3
a1640 1
  return 0;
d1679 1
a1679 1
  debug_printf ("mutex %p in _fixup_after_fork", this);
d1692 1
a1692 1
    api_fatal ("pthread_mutex::_fixup_after_fork () failed to recreate win32 semaphore for mutex");
d2265 1
a2265 1
  if (pthread_cond::is_good_initializer (cond))
d2315 1
a2315 1
  if (pthread_cond::is_good_initializer (cond))
d2328 1
a2328 1
  if (pthread_cond::is_good_initializer (cond))
d2344 1
a2344 1
  if (!pthread_mutex::can_be_unlocked (mutex))
d2347 1
a2347 1
  if (pthread_cond::is_good_initializer (cond))
d2448 1
a2448 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2500 1
a2500 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2511 1
a2511 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2524 1
a2524 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2535 1
a2535 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2546 1
a2546 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2666 1
a2666 1
  if (initializer == NULL || pthread_mutex::is_good_initializer (mutex))
d2697 1
d2719 1
a2719 1
  if (pthread_mutex::is_good_initializer (mutex))
d2729 1
a2729 1
  if (pthread_mutex::is_good_initializer (mutex))
d2739 1
a2739 1
  if (pthread_mutex::is_good_initializer (mutex))
d2751 1
a2751 1
  if (pthread_mutex::is_good_initializer (mutex))
d3024 1
a3024 1
      debug_printf ("cancelable_wait failed. %E");
d3043 1
a3043 1
      debug_printf ("cancelable_wait failed. %E");
d3054 1
a3054 1
      debug_printf ("sem %x in _fixup_after_fork", this);
@


1.219
log
@* dcrt0.cc (_dll_crt0): Set _main_tls as early as possible.
* thread.cc (pthread_mutex::can_be_unlocked): Remove check for
MUTEX_OWNER_ANONYMOUS since it is racy and unsafe.
(pthread::init_mainthread): Initialize thread directly from _my_tls.
(pthread::self): Ditto.
(pthread::get_tls_self_pointer): Delete.
(pthread_mutex::pthread_mutex): Use an event rather than a semaphore.
(pthread_mutex::lock): Rename from _<func>.  Derive self directly.
(pthread_mutex::tryunlock): Ditto.
(pthread_mutex::destroy): Ditto.
(pthread_mutex::unlock): Ditto.  Accommodate change from semaphore to event.
(pthread_mutex::_fixup_after_fork): Accommodate change from semaphore to event.
(pthread_mutex::init): Don't attempt to initialize a semaphore unless it is in
an initialized state.  Do this check under mutex_initialization_lock.lock
* thread.h (fast_mutex::init): Use event rather than semaphore.
(fast_mutex::lock): Ditto.
(pthread_mutex::_lock): Delete.
(pthread_mutex::_unlock): Ditto.
(pthread_mutex::_trylock): Ditto.
(pthread_mutex::_destroy): Ditto.
(pthread_mutex::get_pthread_self): Ditto.
(pthread_mutex::get_tls_self_pointer): Ditto.
(pthread_mutex::lock): Un-inline.
(pthread_mutex::unlock): Ditto.
(pthread_mutex::trylock): Ditto.
(pthread_mutex::destroy): Ditto.
@
text
@d44 1
a44 1
  verifyable_object_isvalid (void const * objectptr, long magic,
d98 1
a98 1
verifyable_object_isvalid (void const *objectptr, long magic, void *static_ptr1,
d1506 1
a1506 22
/* pshared mutexs:

   REMOVED FROM CURRENT. These can be reinstated with the daemon, when all the
   gymnastics can be a lot easier.

   the mutex_t (size 4) is not used as a verifyable object because we cannot
   guarantee the same address space for all processes.
   we use the following:
   high bit set (never a valid address).
   second byte is reserved for the priority.
   third byte is reserved
   fourth byte is the mutex id. (max 255 cygwin mutexs system wide).
   creating mutex's does get slower and slower, but as creation is a one time
   job, it should never become an issue

   And if you're looking at this and thinking, why not an array in cygwin for all mutexs,
   - you incur a penalty on _every_ mutex call and you have toserialise them all.
   ... Bad karma.

   option 2? put everything in userspace and update the ABI?
   - bad karma as well - the HANDLE, while identical across process's,
   Isn't duplicated, it's reopened. */
a1514 3
/* We can only be called once.
   TODO: (no rush) use a non copied memory section to
   hold an initialization flag.  */
d1523 1
a1523 1
  verifyable_object (PTHREAD_MUTEX_MAGIC),
d1535 1
a1535 4
    {
      magic = 0;
      return;
    }
d1537 6
a1542 11
  if (attr)
    {
      if (attr->pshared == PTHREAD_PROCESS_SHARED)
	{
	  // fail
	  magic = 0;
	  return;
	}

      type = attr->mutextype;
    }
d1544 1
d1597 1
a1597 1
	::SetEvent (win32_obj_id); // Another thread may be waiting
a1663 10
verifyable_object::verifyable_object (long verifyer):
magic (verifyer)
{
}

verifyable_object::~verifyable_object ()
{
  magic = 0;
}

d2626 1
a2626 1
  if (pthread_mutex::is_good_initializer (mutex))
@


1.218
log
@* cygtls.h (struct _cygtls): Remove unneeded elements.
* thread.cc (pthread::exit): Avoid potential double call to _my_tls.remove.
* tlsoffsets.h: Regenerate.
@
text
@d4 1
a4 1
   2006, 2007, 2008 Red Hat, Inc.
d190 2
a191 3
  return ((*mutex)->recursion_counter == 1
	  && ((*mutex)->owner == MUTEX_OWNER_ANONYMOUS
	      || pthread::equal ((*mutex)->owner, self)));
d304 1
a304 1
  pthread *thread = get_tls_self_pointer ();
d327 1
a327 1
  pthread *thread = get_tls_self_pointer ();
a335 6
pthread *
pthread::get_tls_self_pointer ()
{
  return _my_tls.tid;
}

d1557 1
a1557 1
  win32_obj_id = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
d1588 1
a1588 1
pthread_mutex::_lock (pthread_t self)
d1590 1
d1613 1
a1613 16
pthread_mutex::_trylock (pthread_t self)
{
  int result = 0;

  if (InterlockedCompareExchange ((long *) &lock_counter, 1, 0) == 0)
    set_owner (self);
  else if (type == PTHREAD_MUTEX_RECURSIVE && pthread::equal (owner, self))
    result = lock_recursive ();
  else
    result = EBUSY;

  return result;
}

int
pthread_mutex::_unlock (pthread_t self)
d1615 1
d1628 1
a1628 2
	// Another thread is waiting
	::ReleaseSemaphore (win32_obj_id, 1, NULL);
d1635 17
a1651 1
pthread_mutex::_destroy (pthread_t self)
d1653 1
a1653 1
  if (condwaits || _trylock (self))
d1681 1
a1681 1
  win32_obj_id = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
a2662 2
  pthread_mutex_t new_mutex;

d2667 9
d2677 9
a2685 7
  new_mutex = new pthread_mutex (attr ? (*attr) : NULL);
  if (!is_good_object (&new_mutex))
    {
      delete new_mutex;
      mutex_initialization_lock.unlock ();
      return EAGAIN;
    }
d2687 7
a2693 9
  if (!attr && initializer)
    {
      if (initializer == PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)
	new_mutex->type = PTHREAD_MUTEX_RECURSIVE;
      else if (initializer == PTHREAD_NORMAL_MUTEX_INITIALIZER_NP)
	new_mutex->type = PTHREAD_MUTEX_NORMAL;
      else if (initializer == PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP)
	new_mutex->type = PTHREAD_MUTEX_ERRORCHECK;
    }
d2695 1
a2695 6
  myfault efault;
  if (efault.faulted ())
    {
      delete new_mutex;
      mutex_initialization_lock.unlock ();
      return EINVAL;
a2696 2

  *mutex = new_mutex;
@


1.217
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@a488 1

d492 1
a492 4
    {
      _my_tls.remove (INFINITE);
      ExitThread (0);
    }
@


1.216
log
@	* thread.cc (__cygwin_lock_lock):  Delete racy optimisation.
	(__cygwin_lock_unlock):  Likewise.
@
text
@d315 3
a317 2
  if (!DuplicateHandle (hMainProc, GetCurrentThread (), hMainProc,
			&thread->win32_obj_id, 0, FALSE, DUPLICATE_SAME_ACCESS))
@


1.215
log
@	* thread.h (struct pthread_rwlock::RWLOCK_READER): Add counter n.
	* thread.cc (pthread_rwlock::rdlock): If a thread already owns a
	read lock, just count the number of locks for it, per SUSv4.
	(pthread_rwlock::tryrdlock): Ditto.
	(pthread_rwlock::unlock): If a thread has more than one concurrent
	read locks, just count down.
@
text
@d79 2
a80 7
  if (MT_INTERFACE->threadcount <= 1)
    paranoid_printf ("threadcount %d.  not locking", MT_INTERFACE->threadcount);
  else
    {
      paranoid_printf ("threadcount %d.  locking", MT_INTERFACE->threadcount);
      pthread_mutex_lock ((pthread_mutex_t*) lock);
    }
d93 2
a94 7
  if (MT_INTERFACE->threadcount <= 1)
    paranoid_printf ("threadcount %d.  not unlocking", MT_INTERFACE->threadcount);
  else
    {
      pthread_mutex_unlock ((pthread_mutex_t*) lock);
      paranoid_printf ("threadcount %d.  unlocked", MT_INTERFACE->threadcount);
    }
@


1.214
log
@* pthread.cc (pthread_mutex::_unlock): Avoid unlocking a mutex if the
recursion_counter is already 0.
(pthread_mutex::_destroy): Don't consider a mutex busy if its recursion_counter
== 0.
(pthread_mutex::_fixup_after_fork): Set recursion_counter to 0 to flag that
we've just forked.  Don't reset the owner of this mutex since the forkee may
think it still owns the mutex.  Reinstate initialization of win32_obj_id.
* fhandler_floppy.cc (fhandler_dev_floppy::raw_read): Initialize a variable to
bypass a C++ warning.
@
text
@d1230 2
a1231 1
  if (lookup_reader (self))
d1233 4
a1236 1
      result = EDEADLK;
d1259 1
d1280 6
a1285 2
      struct RWLOCK_READER *reader = new struct RWLOCK_READER;
      if (reader)
d1288 1
d1378 2
@


1.213
log
@* thread.cc (pthread_mutex::_fixup_after_fork): Reinstate DEBUGGING
conditional.
@
text
@d1640 3
a1642 1
  if (--recursion_counter == 0)
d1648 1
a1648 1
      if (InterlockedDecrement ((long *)&lock_counter))
d1662 1
a1662 1
  else if (recursion_counter != 1)
d1665 1
a1665 1
      --recursion_counter;
d1676 1
a1676 1
  debug_printf ("mutex %x in _fixup_after_fork", this);
d1681 1
a1682 2
  owner = NULL;
  win32_obj_id = NULL;
d1685 1
a1685 1
  tid = 0xffffffff;        /* Don't know the tid after a fork */
d1687 3
a1689 1

d2931 1
a2931 1
  __small_sprintf (name, "semaphore/%016X%08x%08x", 
@


1.212
log
@* thread.cc (pthread_mutex::_fixup_after_fork): Just reset lock to pristine
state after fork.  Don't recreate a mutex since it may not actually be needed.
@
text
@d1683 4
a1686 1
  tid = 0;	/* Don't know the tid after a fork */
@


1.211
log
@	* Makefile.in (DLL_OFILES): Add kernel32.o.
	* autoload.cc (WSACloseEvent): Remove.
	(WSACreateEvent): Remove.
	* cygheap.cc (cygheap_init): Drop initializing shared_prefix.
	* cygheap.h (struct init_cygheap): Drop shared_prefix and
	shared_prefix_buf members.
	* fhandler_socket.cc (sock_shared_name): New static function.
	(search_wsa_event_slot): Convert name buffers to WCHAR.  Call
	NtCreateMutant/NtOpenMutant to create mutexes in session local
	namespace.
	(fhandler_socket::init_events): Ditto.  Fix debug output.
	(fhandler_socket::release_events): Close mutexes using NtClose.
	(fhandler_socket::dup): Ditto.
	* kernel32.cc: New file, implementing Win32 calls in a Cygwin-specific
	way.
	* mmap.cc (MapView): Make static.
	* ntdll.h: Fix status code sorting.
	(STATUS_OBJECT_NAME_EXISTS): Define.
	(SEMAPHORE_QUERY_STATE): Define.
	(CYG_SHARED_DIR_ACCESS): Define.
	(CYG_MUTANT_ACCESS): Define.
	(CYG_EVENT_ACCESS): Define.
	(CYG_SEMAPHORE_ACCESS): Define.
	(enum _PROCESSINFOCLASS): Define ProcessSessionInformation.
	(struct _PROCESS_SESSION_INFORMATION): Define.
	(NtCreateSemaphore): Declare.
	(NtOpenSemaphore): Declare.
	* flock.cc: Use CYG_xxx_ACCESS access masks where appropriate.
	* posix_ipc.cc (ipc_mutex_init): Use native functions to create mutex.
	Create in cygwin-shared subdir.
	(ipc_cond_init): Ditto for event.
	(ipc_mutex_close): Use NtClose.
	(ipc_cond_close): Ditto.
	(mq_open): Drop "cyg" prefix from mqh_uname.
	* shared.cc (CYG_SHARED_DIR_ACCESS): Drop definition here.
	(_cygwin_testing): Declare extern on file level.
	(get_shared_parent_dir): Change name of shared directory.  Add name
	to api_fatal output.
	(get_session_parent_dir): New function.
	(shared_name): Simplify.
	(shared_info::initialize): Call get_session_parent_dir.
	* shared_info.h (get_session_parent_dir): Declare.
	* smallprint.cc (__small_vswprintf): Fix bug in multibyte string
	conversion.
	* thread.cc (semaphore::semaphore): Align semaphore name to object
	names in posix IPC functions.
	* include/cygwin/version.h (CYGWIN_VERSION_SHARED_DATA): Bump.
@
text
@d1676 1
a1676 22
    api_fatal ("pthread_mutex::_fixup_after_fork () doesn'tunderstand PROCESS_SHARED mutex's");

  if (owner == NULL)
    {
      /* mutex has no owner, reset to initial */
      lock_counter = 0;
#ifdef DEBUGGING
      tid = 0;
#endif
    }
  else if (lock_counter != 0)
    {
      /* All waiting threads are gone after a fork */
      lock_counter = 1;
#ifdef DEBUGGING
      tid = 0xffffffff;	/* Don't know the tid after a fork */
#endif
    }

  win32_obj_id = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
  if (!win32_obj_id)
    api_fatal ("pthread_mutex::_fixup_after_fork () failed to recreate win32 semaphore for mutex");
d1678 4
d1683 1
@


1.210
log
@Remove unneeded header files from source files throughout.
@
text
@d2941 1
a2941 1
  __small_sprintf (name, "%scyg_psem/cyg%016X%08x%08x", cygheap->shared_prefix,
@


1.209
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a26 1
# include "config.h"
a30 1
#include <limits.h>
a31 2
#include "cygerrno.h"
#include <assert.h>
a35 1
#include "security.h"
a39 6
#include <semaphore.h>
#include <stdio.h>
#include <sys/timeb.h>
#include <exceptions.h>
#include <sys/fcntl.h>
#include <sys/lock.h>
@


1.208
log
@	* Fix copyright dates.
@
text
@d31 1
@


1.207
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
@


1.206
log
@* syscalls.cc (_isatty): Define as an alias to isatty to override newlib
version.
* thread.cc (pthread_kill): Deal with signal 0 as per POSIX and also avoid
manipulating an invalid thread.
@
text
@d379 1
d1742 1
@


1.205
log
@	* fhandler_registry.cc: Use NAME_MAX + 1 instead of CYG_MAX_PATH
	throughout for subkey name buffer size.
	* fhandler_socket.cc (search_wsa_event_slot): Use MAX_PATH instead of
	CYG_MAX_PATH for mutext name buffer size.
	(fhandler_socket::init_events): Ditto.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Check path length
	against PATH_MAX instead of against CYG_MAX_PATH.
	* registry.cc (get_registry_hive_path): Use PATH_MAX instead of
	CYG_MAX_PATH for registry value path buffer size.
	* shared.cc (open_shared): Use MAX_PATH instead of CYG_MAX_PATH
	for shared memory name buffer size.
	* thread.cc (semaphore::semaphore): Use MAX_PATH instead of CYG_MAX_PATH
	for semaphore name buffer size.
	* uinfo.cc (cygheap_user::env_userprofile): Use PATH_MAX instead of
	CYG_MAX_PATH for temporary path name buffer size.
	* winf.h (LINE_BUF_CHUNK): Define as MAX_PATH * 2.
	* include/sys/dirent.h: Include sys/limits.h.  Define name buffer sizes
	using NAME_MAX.
@
text
@d2643 18
a2660 2
  thread->cygtls->set_threadkill ();
  int rval = sig ? sig_send (NULL, si, thread->cygtls) : 0;
@


1.204
log
@	Drop old SetResourceLock stuff in favor of mutos.
	* dcrt0.cc (_reslock): Remove.
	(__cygwin_user_data): Accommodate removal of resourcelocks member.
	(dll_crt0_0): Don't initialize resourcelocks.
	* exceptions.cc (_cygtls::signal_exit): Drop resourcelocks handling.
	* mmap.cc (mmap_guard): New muto.
	(LIST_LOCK): Define.
	(LIST_UNLOCK): Define.
	(mmap_list::search_record): Remove.
	(mmap_list::try_map): Include code for anonymous case from
	mmap_list::search_record.
	(mmap_is_attached_or_noreserve): Access bookkeeping lists in a thread
	safe way.
	(mmap64): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.  Lock at the latest possible point.
	(munmap): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.
	(msync): Ditto.
	(mprotect): Ditto.
	* thread.cc (ResourceLocks::Lock): Remove.
	(SetResourceLock): Remove.
	(ReleaseResourceLock): Remove.
	(ResourceLocks::Init): Remove.
	(ResourceLocks::Delete): Remove.
	* thread.h (SetResourceLock): Drop declaration.
	(ReleaseResourceLock): Ditto.
	(class ResourceLocks): Drop definition.
	* include/sys/cygwin.h (class ResourceLocks): Drop forward declaration.
	(struct per_process): Replace resourcelocks with additional unused2
	element.
	(per_process_overwrite): Accommodate above change.
@
text
@d2931 1
a2931 1
  char name[CYG_MAX_PATH];
@


1.203
log
@	* thread.cc (pthread_key_create): Drop check for incoming valid object.
@
text
@a288 37
LPCRITICAL_SECTION
ResourceLocks::Lock (int _resid)
{
  return &lock;
}

void
SetResourceLock (int _res_id, int _mode, const char *_function)
{
  EnterCriticalSection (user_data->resourcelocks->Lock (_res_id));
}

void
ReleaseResourceLock (int _res_id, int _mode, const char *_function)
{
  LeaveCriticalSection (user_data->resourcelocks->Lock (_res_id));
}

void
ResourceLocks::Init ()
{
  InitializeCriticalSection (&lock);
  inited = true;
  thread_printf ("lock %p inited by %p , %d", &lock, user_data, myself->pid);
}

void
ResourceLocks::Delete ()
{
  if (inited)
    {
      thread_printf ("Close Resource Locks %p ", &lock);
      DeleteCriticalSection (&lock);
      inited = false;
    }
}

@


1.202
log
@	* cygheap.cc (cygheap_init): Fix formatting.  Remove comment.  Set
	shared_prefix depending only on terminal service capability.
	* dcrt0.cc (dll_crt0_1): Don't call set_cygwin_privileges here.
	* fhandler_fifo.cc (fhandler_fifo::open): Create the mutex as global
	object.
	* posix_ipc.cc (ipc_mutex_init): Use cygheap->shared_prefix.
	(ipc_cond_init): Ditto.
	* sec_helper.cc (privilege_name): Make static.  Use LookupPrivilegeName
	directly to be independent of the state of cygheap.
	(set_privilege): Take a LUID as parameter instead of an index value.
	Only print debug output in case of failure.
	(set_cygwin_privileges): Add comment.  Use LookupPrivilegeValue to
	get privilege LUIDs.
	(init_global_security): Call set_cygwin_privileges here.
	* security.h (privilege_name): Drop declaration.
	(set_privilege): Declare according to above change.
	(set_process_privilege): Call privilege_luid to get LUID.
	(_push_thread_privilege): Ditto.
	* shared.cc (open_shared): Add comment.  On systems supporting the
	SeCreateGlobalPrivilege, try to create/open global shared memory first.
	Fall back to local shared memory if that fails.
	* thread.cc (semaphore::semaphore): Use cygheap->shared_prefix.
	* wincap.h (wincapc::has_create_global_privilege): New element.
	* wincap.cc: Implement above element throughout.
@
text
@a2252 5
  /* The opengroup docs don't define if we should check this or not,
     but creation is relatively rare.  */
  if (pthread_key::is_good_object (key))
    return EBUSY;

@


1.201
log
@* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Change sense of guard test.
Increase size of stack reserved and increase size before the current stack
pointer.  Use pointers when doing arithmetic.
(dll_crt0_1): Initialize exception handler when we notice we're the child of a
fork from non-main thread.
* fork.cc (frok::parent): Make argument volatile.
(frok::child): Ditto.
(lock_signals): New class.
(lock_pthread): Ditto.
(hold_everhthing): Ditto.
(frok::parent): Move atforkprepare and atforkparent to lock_pthread class.
(fork): Make ischild boolean.  Use hold_everything variable within limited
scope to set various mutexes in such a way as to avoid deadlocks.
* thread.h (pthread_mutex::tid): New variable, active when debugging for
tracking thread id of owner.
(pthread_mutex::set_owner): Set tid when debugging.
* thread.cc (pthread_mutex::pthread_mutex): Clear tid.
(pthread_mutex::_unlock): Ditto when unlocking.
(pthread_mutex::fixup_after_fork): Set tid to special value after forking since
owner is unknown.
@
text
@d32 1
d41 3
d2975 1
a2975 2
  __small_sprintf (name, "%scyg_psem/cyg%016X%08x%08x",
		   wincap.has_terminal_services () ? "Global\\" : "",
@


1.200
log
@	* cygwin.din (sem_unlink): Export.
	* posix_ipc.cc: Include thread.h and semaphore.h.  Remove TODO
	comment.
	(ipc_names): Add max_len member.  Set to maximum length of the path
	before tacking on the prefix path.  Set prefix path for named semaphors
	to /dev/shm, as on Linux.
	(enum ipc_type_t): Change sem to semaphore to avoid name conflicts.
	(check_path): Detect empty paths.  Use ipc_names's max_len member.
	Use __small_sprintf to create full object path name.  Special case
	semaphores.
	(ipc_cond_init): Drop superfluous strcpy.
	(class ipc_flock): New class to simplify file locking in subsequent
	code.
	(struct mq_hdr): Raise size of mqh_uname to allow adding a unique
	LUID to the name.
	(mq_open): Fix formatting.  Create unique synchronization object names
	using AllocateLocallyUniqueId.
	(struct sem_finfo): New structure defining named semaphore file content.
	(sem_open): Move here.  Rework implementation to allow kernel
	persistent implementation of POSIX named semaphores.
	(_sem_close): Implement sem_close.
	(sem_close): Move here.  Just call _sem_close with do_close parameter
	set to true.
	(sem_unlink): New function.
	* pthread.cc (mangle_sem_name): Remove.
	(sem_open): Move to posix_ipc.cc.
	(sem_close): Ditto.
	* syscalls.cc (close_all_files): Call semaphore::terminate here.
	* thread.cc: Fix formatting.  Rearrange semaphore functions so that
	they are close together.
	(semaphore::semaphore): Rework to play nicely with new named semaphore
	implementation.
	(semaphore::_terminate): Call _sem_close if semaphore is a named
	semaphore.
	(semaphore::destroy): Don't destroy named semaphores.  Return EINVAL
	instead.
	(semaphore::close): Only destroy named semaphores.  Return EINVAL
	otherwise.
	(semaphore::open): Rework to play nicely with new named semaphore
	implementation.  Loop through existing semaphores to be able to
	return same sem_t pointer as a former call on the same named semaphore.
	(semaphore::getinternal): New function called from _sem_close.
	* thread.h (class List): Make mx and head public.
	(class semaphore): Fix formatting.  Align method declarations with
	implementation in thread.cc.  Add members used for named semaphores.
	(semaphore::terminate): New static method.
	* include/semaphore.h: Redefine SEM_FAILED.  Fix formatting.
	(sem_unlink): Add declaration.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d3 2
a4 4
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007 Red Hat, Inc.

   Originally written by Marco Fuykschot <marco@@ddi.nl>
   Substantialy enhanced by Robert Collins <rbtcollins@@hotmail.com>
d1600 5
a1604 1
  condwaits (0), owner (NULL), type (PTHREAD_MUTEX_ERRORCHECK),
d1685 3
d1721 7
a1727 2
    /* mutex has no owner, reset to initial */
    lock_counter = 0;
d1729 7
a1735 2
    /* All waiting threads are gone after a fork */
    lock_counter = 1;
@


1.199
log
@* thread.cc (verifyable_object_isvalid): Check for NULL specifically.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
d787 2
a788 1
cancelable_wait (HANDLE object, DWORD timeout, const cw_cancel_action cancel_action,
a1737 191
List<semaphore> semaphore::semaphores;

semaphore::semaphore (int pshared, unsigned int value)
: verifyable_object (SEM_MAGIC),
  shared (pshared),
  currentvalue (value),
  name (NULL)
{
  SECURITY_ATTRIBUTES sa = (pshared != PTHREAD_PROCESS_PRIVATE)
			   ? sec_all : sec_none_nih;
  this->win32_obj_id = ::CreateSemaphore (&sa, value, LONG_MAX, NULL);
  if (!this->win32_obj_id)
    magic = 0;

  semaphores.insert (this);
}

semaphore::semaphore (const char *sem_name, int oflag, mode_t mode,
				  unsigned int value)
: verifyable_object (SEM_MAGIC),
  shared (PTHREAD_PROCESS_SHARED),
  currentvalue (value),		/* Unused for named semaphores. */
  name (NULL)
{
  if (oflag & O_CREAT)
    {
      SECURITY_ATTRIBUTES sa = sec_all;
      security_descriptor sd;
      if (allow_ntsec)
	set_security_attribute (mode, &sa, sd);
      this->win32_obj_id = ::CreateSemaphore (&sa, value, LONG_MAX, sem_name);
      if (!this->win32_obj_id)
	magic = 0;
      if (GetLastError () == ERROR_ALREADY_EXISTS && (oflag & O_EXCL))
	{
	  __seterrno ();
	  CloseHandle (this->win32_obj_id);
	  magic = 0;
	}
    }
  else
    {
      this->win32_obj_id = ::OpenSemaphore (SEMAPHORE_ALL_ACCESS, FALSE,
					    sem_name);
      if (!this->win32_obj_id)
	{
	  __seterrno ();
	  magic = 0;
	}
    }
  if (magic)
    {
      name = new char [strlen (sem_name + 1)];
      if (!name)
	{
	  set_errno (ENOSPC);
	  CloseHandle (this->win32_obj_id);
	  magic = 0;
	}
      else
	strcpy (name, sem_name);
    }

  semaphores.insert (this);
}

semaphore::~semaphore ()
{
  if (win32_obj_id)
    CloseHandle (win32_obj_id);

  delete [] name;

  semaphores.remove (this);
}

void
semaphore::_post ()
{
  if (ReleaseSemaphore (win32_obj_id, 1, &currentvalue))
    currentvalue++;
}

int
semaphore::_getvalue (int *sval)
{
  long val;

  switch (WaitForSingleObject (win32_obj_id, 0))
    {
      case WAIT_OBJECT_0:
	ReleaseSemaphore (win32_obj_id, 1, &val);
	*sval = val + 1;
	break;
      case WAIT_TIMEOUT:
	*sval = 0;
	break;
      default:
	set_errno (EAGAIN);
	return -1;
    }
  return 0;
}

int
semaphore::_trywait ()
{
  /* FIXME: signals should be able to interrupt semaphores...
    We probably need WaitForMultipleObjects here.  */
  if (WaitForSingleObject (win32_obj_id, 0) == WAIT_TIMEOUT)
    {
      set_errno (EAGAIN);
      return -1;
    }
  currentvalue--;
  return 0;
}

int
semaphore::_timedwait (const struct timespec *abstime)
{
  struct timeval tv;
  long waitlength;

  myfault efault;
  if (efault.faulted ())
    {
      /* According to SUSv3, abstime need not be checked for validity,
	 if the semaphore can be locked immediately. */
      if (!_trywait ())
	return 0;
      set_errno (EINVAL);
      return -1;
    }

  gettimeofday (&tv, NULL);
  waitlength = abstime->tv_sec * 1000 + abstime->tv_nsec / (1000 * 1000);
  waitlength -= tv.tv_sec * 1000 + tv.tv_usec / 1000;
  if (waitlength < 0)
    waitlength = 0;
  switch (cancelable_wait (win32_obj_id, waitlength, cw_cancel_self, cw_sig_eintr))
    {
    case WAIT_OBJECT_0:
      currentvalue--;
      break;
    case WAIT_SIGNALED:
      set_errno (EINTR);
      return -1;
    case WAIT_TIMEOUT:
      set_errno (ETIMEDOUT);
      return -1;
    default:
      debug_printf ("cancelable_wait failed. %E");
      __seterrno ();
      return -1;
    }
  return 0;
}

int
semaphore::_wait ()
{
  switch (cancelable_wait (win32_obj_id, INFINITE, cw_cancel_self, cw_sig_eintr))
    {
    case WAIT_OBJECT_0:
      currentvalue--;
      break;
    case WAIT_SIGNALED:
      set_errno (EINTR);
      return -1;
    default:
      debug_printf ("cancelable_wait failed. %E");
      break;
    }
  return 0;
}

void
semaphore::_fixup_after_fork ()
{
  if (shared == PTHREAD_PROCESS_PRIVATE)
    {
      debug_printf ("sem %x in _fixup_after_fork", this);
      /* FIXME: duplicate code here and in the constructor. */
      this->win32_obj_id = ::CreateSemaphore (&sec_none_nih, currentvalue,
					      LONG_MAX, NULL);
      if (!win32_obj_id)
	api_fatal ("failed to create new win32 semaphore, error %d");
    }
}

d2925 179
d3133 4
d3144 15
d3160 2
a3161 1
semaphore::open (const char *name, int oflag, mode_t mode, unsigned int value)
d3169 16
d3192 1
a3192 1
  *sem = new semaphore (name, oflag, mode, value);
d3267 22
@


1.199.4.1
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@d2424 5
@


1.199.4.2
log
@	Drop old SetResourceLock stuff in favor of mutos.
	* dcrt0.cc (_reslock): Remove.
	(__cygwin_user_data): Accommodate removal of resourcelocks member.
	(dll_crt0_0): Don't initialize resourcelocks.
	* exceptions.cc (_cygtls::signal_exit): Drop resourcelocks handling.
	* mmap.cc (mmap_guard): New muto.
	(LIST_LOCK): Define.
	(LIST_UNLOCK): Define.
	(mmap_list::search_record): Remove.
	(mmap_list::try_map): Include code for anonymous case from
	mmap_list::search_record.
	(mmap_is_attached_or_noreserve): Access bookkeeping lists in a thread
	safe way.
	(mmap64): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.  Lock at the latest possible point.
	(munmap): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.
	(msync): Ditto.
	(mprotect): Ditto.
	* thread.cc (ResourceLocks::Lock): Remove.
	(SetResourceLock): Remove.
	(ReleaseResourceLock): Remove.
	(ResourceLocks::Init): Remove.
	(ResourceLocks::Delete): Remove.
	* thread.h (SetResourceLock): Drop declaration.
	(ReleaseResourceLock): Ditto.
	(class ResourceLocks): Drop definition.
	* include/sys/cygwin.h (class ResourceLocks): Drop forward declaration.
	(struct per_process): Replace resourcelocks with additional unused2
	element.
	(per_process_overwrite): Accommodate above change.

	* mmap.cc: Convert usage of dynamically growing cmalloced arrays to
	cmalloced linked lists throughout.
	(class mmap_record): Add LIST_ENTRY element.
	(mmap_record::match): New method, taking over match algorithm from
	list::search_record.
	(class mmap_list): Rename from class list.  Add LIST_ENTRY.  Convert
	recs to a LIST_HEAD.  Drop nrecs and maxrecs members.
	(mmap_list::get_record): Drop entirely.
	(mmap_list::free_recs): Drop entirely.
	(mmap_list::del_record): Take mmap_record to delete as parameter.
	(mmap_list::search_record): Convert to mmap_record::match.
	(class mmap_areas): Rename from class map.  Convert lists to LIST_HEAD.
	(mmap_areas::get_list): Drop entirely.
	(mmap_areas::del_list): Take mmap_list to delete as parameter.
	(mprotect): Fix indentation.
@
text
@d287 37
@


1.199.4.3
log
@	* thread.cc (pthread_kill): Deal with signal 0 as per POSIX and also
	avoid manipulating an invalid thread.
@
text
@d2814 2
a2815 18
  int rval;
  if (!thread->valid)
    rval = ESRCH;
  else if (sig)
    {
      thread->cygtls->set_threadkill ();
      rval = sig_send (NULL, si, thread->cygtls);
    }
  else
    switch (WaitForSingleObject (thread->win32_obj_id, 0))
      {
      case WAIT_TIMEOUT:
	rval = 0;
	break;
      default:
	rval = ESRCH;
	break;
      }
@


1.199.4.4
log
@	* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and
	use either main sigmask or current thread sigmask.
	(set_process_mask): Ditto.
	(sighold): Ditto.
	(sigrelse): Ditto.
	(sigset): Ditto.
	(set_process_mask_delta): Ditto.
	(_cygtls::call_signal_handler): Ditto.
	* fhandler_process.cc (format_process_status): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* pinfo.h (class pinfo): Ditto.
	* select.cc (pselect): Ditto.
	* signal.cc (sigprocmask): Ditto.
	(abort): Ditto.
	(sigpause): Ditto.
	(sigsend): Ditto.
	(wait_sig): Ditto.
	* sigproc.cc (sig_send): Ditto.
	(pending_signals::add): Ditto.
	(wait_sig): Ditto.
	* thread.h (pthread::parent_tls): New member.
	* thread.cc (pthread::pthread): Record parent_tls here.
	(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@a376 1
  parent_tls = &_my_tls;
a1911 1
  _my_tls.sigmask = thread->parent_tls->sigmask;
@


1.198
log
@	* thread.cc (pthread_mutex::is_good_initializer_or_bad_object): Delete.
	(pthread_cond::is_good_initializer_or_bad_object): Delete.
	(pthread_rwlock::is_good_initializer_or_bad_object): Delete.
	(pthread_cond::init): Remove disabled code.  Guard assignment to
	object to initialize against access violation.
	(pthread_rwlock::init): Ditto.
	(pthread_mutex::init): Ditto.
@
text
@d116 1
a116 1
verifyable_object_isvalid (void const * objectptr, long magic, void *static_ptr1,
a118 2
  verifyable_object **object = (verifyable_object **) objectptr;

d120 3
a122 1
  if (efault.faulted ())
d125 2
@


1.197
log
@	* thread.cc (pthread_cond::init): Disable validity test of object
	to initialize since test of uninitialized content is unreliable.
	(pthread_rwlock::init): Ditto.
	(pthread_mutex::init): Ditto.
@
text
@a197 11
pthread_mutex::is_good_initializer_or_bad_object (pthread_mutex_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC,
				 PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,
				 PTHREAD_NORMAL_MUTEX_INITIALIZER_NP,
				 PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP) == VALID_OBJECT)
    return false;
  return true;
}

inline bool
a251 8
inline bool
pthread_cond::is_good_initializer_or_bad_object (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER) == VALID_OBJECT)
    return false;
  return true;
}

a277 8
pthread_rwlock::is_good_initializer_or_bad_object (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC, PTHREAD_RWLOCK_INITIALIZER) == VALID_OBJECT)
    return false;
  return true;
}

inline bool
a2518 1

d2525 3
a2527 4
#if 0
  /* Disabled since recognition of a valid object doesn't work reliably
     if the object is uninitialized. */
  if (!is_good_initializer_or_bad_object (cond))
d2529 1
d2531 1
a2531 1
      return EBUSY;
d2533 3
a2535 3
#endif
  new_cond = new pthread_cond (attr ? (*attr) : NULL);
  if (!is_good_object (&new_cond))
d2539 1
a2539 1
      return EAGAIN;
d2708 3
a2710 4
#if 0
  /* Disabled since recognition of a valid object doesn't work reliably
     if the object is uninitialized. */
  if (!is_good_initializer_or_bad_object (rwlock))
d2712 1
d2714 1
a2714 1
      return EBUSY;
d2716 3
a2718 3
#endif
  new_rwlock = new pthread_rwlock (attr ? (*attr) : NULL);
  if (!is_good_object (&new_rwlock))
d2722 1
a2722 1
      return EAGAIN;
d2888 1
a2888 9
#if 0
  /* Disabled since recognition of a valid object doesn't work reliably
     if the object is uninitialized. */
  if (!is_good_initializer_or_bad_object (mutex))
    {
      mutex_initialization_lock.unlock ();
      return EBUSY;
    }
#endif
d2907 8
@


1.196
log
@Always zero all elements of siginfo_t throughout.
* cygtls.h (_cygtls::thread_context): Declare new field.
(_cygtls::thread_id): Ditto.
(_cygtls::signal_exit): Move into this class.
(_cygtls::copy_context): Declare new function.
(_cygtls::signal_debugger): Ditto.
* cygtls.cc (_cygtls::init_thread): Fill out thread id field.
* exceptions.cc (exception): Change message when exception info is unknown.
Copy context to thread local storage.
(_cygtls::handle_exceptions): Avoid double test for fault_guarded.  Reflect
move of signal_exit to _cygtls class.
(sigpacket::process): Copy context to thread local storage.
(_cygtls::signal_exit): Move to _cygtls class.  Call signal_debugger to notify
debugger of exiting signal (WIP).  Call stackdump here (WIP).
(_cygtls::copy_context): Define new function.
(_cygtls::signal_debugger): Ditto.
* tlsoffsets.h: Regenerate.
* include/cygwin.h (_fpstate): New internal structure.
(ucontext): Declare new structure (WIP).
(__COPY_CONTEXT_SIZE): New define.
* exceptions.cc (_cygtls::interrupt_setup): Clear "threadkill" field when there
is no sigwaiting thread.
(setup_handler): Move event handling into interrupt_setup.
@
text
@d2553 3
a2555 1

d2561 1
a2561 1

d2736 3
a2738 1

d2744 1
a2744 1

d2916 3
a2918 1

d2924 1
a2924 1

@


1.195
log
@* cygtls.h (_cygtls::el): New field.
(_cygtls::handle_exceptions): New function declaration.
(_cygtls::handle_threadlist_exception): Ditto.
(_cygtls::init_exception_handler): Ditto.
(_cygtls::init_threadlist_exceptions): Remove arg from declaration.
* cygtls.cc (_cygtls::call2): Don't initialize exceptions here.
(_cygtls::init_thread): Do it here instead and use member function.
(_cygtls::handle_threadlist_exception): Move into _cygtls class.
(_cygtls::init_exception_handler): Ditto.  Rely on existence of 'el' memmber in
_cygtls.
(_cygtls::init_threadlist_exceptions): Ditto.
* dcrt0.cc (dll_crt0_1): Remove exception_list definition and setting since it
now commonly resides in the tls.
* exceptions.cc (init_exception_handler): Move to cygtls.cc.
(init_exceptions): Ditto.
(rtl_unwind): New, safe wrapper function for RtlUnwind.
(_cygtls::handle_exceptions): Move to _cygtls.  Call rtl_unwind to unwind
frames and eliminate copying of structures.  Put address of failing instruction
in si_addr, not the address on the stack.  Return 0 to indicate that we've
handled this exception.
* external.cc (cygwin_internal): Make CW_INIT_EXCEPTIONS a no-op.
* sigproc.cc (wait_sig): Accommodate argument change to
_cygtls::init_threadlist_exceptions.
* tlsoffsets.h: Regenerate.
* include/exceptions.h (exception_list): Add more stuff to the exception list.
Apparently windows needs this?
(init_exceptions): Remove bogus declaration.
* include/cygwin/signal.h (SI_USER): Redefine as zero as per SUSv3.
* thread.cc (pthread_kill): Set si_pid and si_uid.
* timer.cc (timer_thread): Set si_code to SI_TIMER.
@
text
@d2873 1
a2873 1
  siginfo_t si;
a2877 1
  si.si_errno = 0;
@


1.194
log
@	* thread.h: Revert patch from 2005-09-05.
	* thread.cc (pthread_mutex::can_be_unlocked): Return true also if
	mutex is owned by MUTEX_OWNER_ANONYMOUS.
@
text
@d2876 3
a2878 1
  si.si_pid = si.si_uid = si.si_errno = 0;
@


1.193
log
@white space
@
text
@d215 5
a219 4
  /*
   * Check if the mutex is owned by the current thread and can be unlocked
   */
  return ((*mutex)->recursion_counter == 1 && pthread::equal ((*mutex)->owner, self));
@


1.192
log
@	* thread.cc (pthread::create(3 args)): Make bool.
	(pthread_null::create): Ditto.
	(pthread::create(4 args)): Check return of inner create rather than
	calling is_good_object().
	* thread.h: Ditto.
@
text
@d2641 1
a2641 1
          && tv.tv_usec > abstime->tv_nsec / 1000))
@


1.191
log
@	* thread.cc (pthread_cond_timedwait): Check abstime for validity
	according to SUSv3.  Rewrite timeout check and waitlength calculation
	to avoid overflow problems.
@
text
@d494 1
a494 1
void
d498 2
d502 1
a502 1
    return;
d522 1
d524 1
d2000 1
a2000 2
  (*thread)->create (start_routine, attr ? *attr : NULL, arg);
  if (!is_good_object (thread))
d3280 1
a3280 1
void
d3283 1
@


1.190
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d2618 1
a2618 1
  long waitlength;
d2626 6
d2633 6
a2638 3
  waitlength = abstime->tv_sec * 1000 + abstime->tv_nsec / (1000 * 1000);
  waitlength -= tv.tv_sec * 1000 + tv.tv_usec / 1000;
  if (waitlength < 0)
d2640 3
@


1.189
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d1663 1
a1663 1
      (void) cancelable_wait (win32_obj_id, INFINITE, cw_no_cancel, cw_sig_resume);
@


1.188
log
@ARGH.  Check in previous uncommitted-but-ChangeLog'ed entry.
@
text
@d357 1
a357 1
MTinterface::fixup_before_fork (void)
d364 1
a364 1
MTinterface::fixup_after_fork (void)
d573 1
a573 1
pthread::cancel (void)
d791 1
a791 1
pthread::testcancel (void)
d801 1
a801 1
pthread::static_cancel_self (void)
d2041 1
a2041 1
pthread::atforkprepare (void)
d2056 1
a2056 1
pthread::atforkparent (void)
d2069 1
a2069 1
pthread::atforkchild (void)
d2422 1
a2422 1
pthread_getconcurrency (void)
@


1.187
log
@* thread.h (verifyable_object_state verifyable_object_isvalid): Delete function
declaration that should have been static.
* thread.cc (verifyable_object_state verifyable_object_isvalid): Make inline
static.
(pthread*::is_good_object): Move to directly after verifyable_object_state
verifyable_object_isvalid and make inline.
@
text
@d120 1
d124 1
d2619 1
a2620 1

d2891 1
a2891 2
  myfault efault;
  if (attr && !pthread_mutexattr::is_good_object (attr) || efault.faulted ())
@


1.186
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@d51 5
d115 195
a309 1
inline LPCRITICAL_SECTION
a978 9
/* static members */
bool
pthread_attr::is_good_object (pthread_attr_t const *attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

a991 8
bool
pthread_condattr::is_good_object (pthread_condattr_t const *attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

a1200 8
bool
pthread_rwlockattr::is_good_object (pthread_rwlockattr_t const *attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_RWLOCKATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

a1523 8
bool
pthread_key::is_good_object (pthread_key_t const *key)
{
  if (verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

a1598 53
bool
pthread_mutex::is_good_object (pthread_mutex_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

bool
pthread_mutex::is_good_initializer (pthread_mutex_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC,
				 PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,
				 PTHREAD_NORMAL_MUTEX_INITIALIZER_NP,
				 PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP) != VALID_STATIC_OBJECT)
    return false;
  return true;
}

bool
pthread_mutex::is_good_initializer_or_object (pthread_mutex_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC,
				 PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,
				 PTHREAD_NORMAL_MUTEX_INITIALIZER_NP,
				 PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP) == INVALID_OBJECT)
    return false;
  return true;
}

bool
pthread_mutex::is_good_initializer_or_bad_object (pthread_mutex_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC,
				 PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,
				 PTHREAD_NORMAL_MUTEX_INITIALIZER_NP,
				 PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP) == VALID_OBJECT)
    return false;
  return true;
}

bool
pthread_mutex::can_be_unlocked (pthread_mutex_t const *mutex)
{
  pthread_t self = pthread::self ();

  if (!is_good_object (mutex))
    return false;
  /*
   * Check if the mutex is owned by the current thread and can be unlocked
   */
  return ((*mutex)->recursion_counter == 1 && pthread::equal ((*mutex)->owner, self));
}
a1745 8
bool
pthread_mutexattr::is_good_object (pthread_mutexattr_t const * attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

a1955 29
/* Generic memory acccess routine - where should it live ? */
int __stdcall
check_valid_pointer (void const *pointer)
{
  if (!pointer || IsBadWritePtr ((void *) pointer, sizeof (verifyable_object)))
    return EFAULT;
  return 0;
}

verifyable_object_state
verifyable_object_isvalid (void const * objectptr, long magic, void *static_ptr1,
			   void *static_ptr2, void *static_ptr3)
{
  verifyable_object **object = (verifyable_object **)objectptr;
  if (check_valid_pointer (object))
    return INVALID_OBJECT;
  if ((static_ptr1 && *object == static_ptr1) ||
      (static_ptr2 && *object == static_ptr2) ||
      (static_ptr3 && *object == static_ptr3))
    return VALID_STATIC_OBJECT;
  if (!*object)
    return INVALID_OBJECT;
  if (check_valid_pointer (*object))
    return INVALID_OBJECT;
  if ((*object)->magic != magic)
    return INVALID_OBJECT;
  return VALID_OBJECT;
}

a1979 8
bool
pthread::is_good_object (pthread_t const *thread)
{
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

a2518 33
/* Thread synchronisation */
bool
pthread_cond::is_good_object (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

bool
pthread_cond::is_good_initializer (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER) != VALID_STATIC_OBJECT)
    return false;
  return true;
}

bool
pthread_cond::is_good_initializer_or_object (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER) == INVALID_OBJECT)
    return false;
  return true;
}

bool
pthread_cond::is_good_initializer_or_bad_object (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER) == VALID_OBJECT)
    return false;
  return true;
}

d2617 4
a2623 3
  if (check_valid_pointer (abstime))
    return EINVAL;

a2688 33
/* RW locks */
bool
pthread_rwlock::is_good_object (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

bool
pthread_rwlock::is_good_initializer (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC, PTHREAD_RWLOCK_INITIALIZER) != VALID_STATIC_OBJECT)
    return false;
  return true;
}

bool
pthread_rwlock::is_good_initializer_or_object (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC, PTHREAD_RWLOCK_INITIALIZER) == INVALID_OBJECT)
    return false;
  return true;
}

bool
pthread_rwlock::is_good_initializer_or_bad_object (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC, PTHREAD_RWLOCK_INITIALIZER) == VALID_OBJECT)
    return false;
  return true;
}

d2889 2
a2890 1
  if (attr && !pthread_mutexattr::is_good_object (attr) || check_valid_pointer (mutex))
a3117 7
bool
semaphore::is_good_object (sem_t const * sem)
{
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}
@


1.185
log
@revert erroneous checkin
@
text
@d1774 2
a1775 1
  if (__check_invalid_read_ptr (abstime, sizeof *abstime))
d3237 2
a3238 3

  if (!is_good_object (sem)
      || __check_null_invalid_struct (sval, sizeof (int)))
@


1.184
log
@* autoload.cc (LoadDLLprime): Use a more descriptive name for autoload text
sections.
* cygwin.sc: Ditto.
@
text
@d1774 1
a1774 2
  myfault efault;
  if (efault.faulted ())
d3236 3
a3238 2
  myfault efault;
  if (efault.faulted () || !is_good_object (sem))
@


1.183
log
@* include/pthread.h: Change PTHREAD_MUTEX_DEFAULT to PTHREAD_MUTEX_NORMAL.
Revert PTHREAD_MUTEX_INITIALIZER to PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
since that is actually closer to what linux does.
* thread.h (cw_cancel_action): New enum.
(cancelable_wait): Use cw_cancel_action as third argument.
* thread.cc (cancelable_wait): Ditto.  Don't wait for cancel if cancel_action
== cw_no_cancel.
(pthread::create): Don't wait for cancel event since that is racy.
(pthread_mutex::pthread_mutex): Set default to PTHREAD_MUTEX_ERRORCHECK.
(pthread_mutexattr::pthread_mutexattr): Ditto.
(pthread_mutex::_lock): Tell cancelable_wait not to wait for cancellation
event.
(semaphore::_timedwait): Accommodate change in cancelable_wait args.
(pthread::join): Ditto.
@
text
@d1774 2
a1775 1
  if (__check_invalid_read_ptr (abstime, sizeof *abstime))
d3237 2
a3238 3

  if (!is_good_object (sem)
      || __check_null_invalid_struct (sval, sizeof (int)))
@


1.182
log
@* cygtls.h (_local_storage::setmode_file): New element.
(_local_storage::setmode_mode): New element.
* tlsoffsets.h: Regenerate.
* cygwin.din (setmode): Define as cygwin_getmode.
* syscalls.cc (setmode_helper): Use setmode_* variables from tls rather than
using unthreadsafe static.
(setmode): Break out fwalk stuff.
(cygwin_setmode): New function.  Put fwalk stdio stuff here.
@
text
@d316 2
a317 3
      if (WaitForSingleObject (cancel_event, 5000) != WAIT_OBJECT_0)
	thread_printf ("event never arrived after CreateThread");
      ResetEvent (cancel_event);
d606 1
a606 1
cancelable_wait (HANDLE object, DWORD timeout, const bool do_cancel,
d620 1
a620 1
  if (!pthread::is_good_object (&thread) ||
d643 1
a643 1
	  if (do_cancel)
d956 1
a956 1
  rv = cancelable_wait (sem_wait, dwMilliseconds, false, cw_sig_eintr);
d1506 1
a1506 1
  condwaits (0), owner (NULL), type (PTHREAD_MUTEX_DEFAULT),
d1546 6
a1551 1
  else if (type != PTHREAD_MUTEX_NORMAL && pthread::equal (owner, self))
a1558 5
  else
    {
      cancelable_wait (win32_obj_id, INFINITE, false, cw_sig_resume);
      set_owner (self);
    }
d1642 1
a1642 1
pshared (PTHREAD_PROCESS_PRIVATE), mutextype (PTHREAD_MUTEX_DEFAULT)
d1789 1
a1789 1
  switch (cancelable_wait (win32_obj_id, waitlength, true, cw_sig_eintr))
d1811 1
a1811 1
  switch (cancelable_wait (win32_obj_id, INFINITE, true, cw_sig_eintr))
a1883 1
  SetEvent (thread->cancel_event);
d2264 1
a2264 1
      switch (cancelable_wait ((*thread)->win32_obj_id, INFINITE, false, cw_sig_resume))
@


1.181
log
@* thread.cc (pthread_mutex::_lock): Use cancelable_wait rather than
WaitForSingleObject.
@
text
@d1759 1
a1759 2
   *We probably need WaitForMultipleObjects here.
   */
@


1.180
log
@* thread.cc (cancelable_wait): No-op change to make sure that res is always a
valid WFMO return.
@
text
@d1557 1
a1557 1
      WaitForSingleObject (win32_obj_id, INFINITE);
@


1.179
log
@Change pthread::cancelable_wait to just cancelable_wait, throughout.
* thread.h (cw_sig_wait): New enum.
(fast_mutex::lock): Use cancelable_wait with resumable signal.
(cancelable_wait): Change fourth argument to cw_sig_wait enum.
* thread.cc (cancelable_wait): Ditto.  Loop on signal detection if fourth
argument == cw_sig_resume.
@
text
@d626 1
a626 1
      cancel_n = num++;
d635 1
a635 1
      sig_n = num++;
a641 1
      res -= WAIT_OBJECT_0;
@


1.178
log
@* thread.h (pthread_key::set): Inline.
(pthread_key::get): Ditto.
* thread.cc (pthread::set): Delete.
(pthread::get): Ditto.
@
text
@d607 2
a608 2
pthread::cancelable_wait (HANDLE object, DWORD timeout, const bool do_cancel,
			  const bool do_sig_wait)
d613 1
a613 1
  pthread_t thread = self ();
d621 1
a621 1
  if (!is_good_object (&thread) ||
d631 1
a631 1
  if (!do_sig_wait || &_my_tls != _main_tls)
d639 20
a658 8
  res = WaitForMultipleObjects (num, wait_objects, FALSE, timeout);
  if (res == sig_n - WAIT_OBJECT_0)
    res = WAIT_SIGNALED;
  else if (res == cancel_n - WAIT_OBJECT_0)
    {
      if (do_cancel)
	pthread::static_cancel_self ();
      res = WAIT_CANCELED;
d958 1
a958 1
  rv = pthread::cancelable_wait (sem_wait, dwMilliseconds, false, true);
d1792 1
a1792 1
  switch (pthread::cancelable_wait (win32_obj_id, waitlength, true, true))
d1814 1
a1814 1
  switch (pthread::cancelable_wait (win32_obj_id, INFINITE, true, true))
d2268 18
a2285 25
      bool loop = false;
      do
	switch (cancelable_wait ((*thread)->win32_obj_id, INFINITE, false, true))
	  {
	  case WAIT_OBJECT_0:
	    if (return_val)
	      *return_val = (*thread)->return_ptr;
	    delete (*thread);
	    break;
	  case WAIT_SIGNALED:
	    _my_tls.call_signal_handler ();
	    loop = true;
	    break;
	  case WAIT_CANCELED:
	    // set joined thread back to joinable since we got canceled
	    (*thread)->joiner = NULL;
	    (*thread)->attr.joinable = PTHREAD_CREATE_JOINABLE;
	    joiner->cancel_self ();
	    // never reached
	    break;
	  default:
	    // should never happen
	    return EINVAL;
	  }
      while (loop);
@


1.177
log
@copyright
@
text
@a1369 17
int
pthread_key::set (const void *value)
{
  /* the OS function doesn't perform error checking */
  TlsSetValue (tls_index, (void *) value);
  return 0;
}

void *
pthread_key::get () const
{
  int saved_error = ::GetLastError ();
  void *result = TlsGetValue (tls_index);
  ::SetLastError (saved_error);
  return result;
}

@


1.176
log
@* cygthread.cc (new): Add a little more debugging.
* thread.cc (pthread_null::exit): Add a _my_tls.remove() for safety.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
@


1.175
log
@* cygtls.cc (_cygtls::init_thread): Set __sdidinit to negative value to
indicate that it is "special".
* thread.cc (pthread::exit): If __sdidinit is < 0, it was never really
initialized so reset it to 0 before calling _reclaim_reent.
@
text
@d3291 1
@


1.174
log
@* thread.cc (__cygwin_lock_lock): Don't bother locking when there is only one
known thread.
(__cygwin_lock_unlock): Ditto for unlocking.
@
text
@d358 2
@


1.173
log
@* dtable.cc (dtable::find_fifo): Release lock after fifo found (still racy).
* fhandler.h (fhandler_fifo::get_io_handle): New fifo-specific method.
* fhandler_fifo.cc (fhandler_fifo::close): Close output_handle only if it is
open.
(fhandler_fifo::open_not_mine): Reorganize slightly.  Don't call _pinfo methods
when the fifo is owned by me or suffer dtable lock_cs deadlock.
(fhandler_fifo::open): Call open_not_mine first, otherwise open myself
(racy).
* pinfo.cc (_pinfo::commune_recv): Duplicate fifo handles here in requesting
processes arena to avoid one potential race (of many).
(_pinfo::commune_send): Move all PICOM_FIFO code under one case statement.
* thread.cc (pthread::init_mainthread) Use existing hMainProc handle rather
than calling GetCurrentProcess.
@
text
@d82 7
a88 1
  pthread_mutex_lock ((pthread_mutex_t*) lock);
d101 7
a107 1
  pthread_mutex_unlock ((pthread_mutex_t*) lock);
@


1.172
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d181 2
a182 3
  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),
			GetCurrentProcess (), &thread->win32_obj_id,
			0, FALSE, DUPLICATE_SAME_ACCESS))
@


1.171
log
@	* cygwin.din: Add symbols flockfile, ftrylockfile, funlockfile,
	getgrgid_r, getgrnam_r and getlogin_r.
	* grp.cc (getgrgid_r): New function.
	(getgrnam_r): Ditto.
	* syscalls.cc (flockfile): Ditto.
	(ftrylockfile): Ditto.
	(funlockfile): Ditto.
	* sysconf.cc (sysconf): Return LOGIN_NAME_MAX in case of
	_SC_LOGIN_NAME_MAX.
	* thread.cc (__cygwin_lock_trylock): Define int.  Return value from
	call to pthread_mutex_trylock.
	* uinfo.cc (getlogin_r): New function.
	* include/limits.h: Define LOGIN_NAME_MAX.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/lock.h: Add declarations for __cygwin_lock_xxx functions.
	* include/sys/stdio.h: Add define for _ftrylockfile.
@
text
@d176 1
a176 1
        api_fatal ("failed to create mainthread object");
d1439 3
a1441 3
                                 PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,
                                 PTHREAD_NORMAL_MUTEX_INITIALIZER_NP,
                                 PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP) != VALID_STATIC_OBJECT)
d1450 3
a1452 3
                                 PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,
                                 PTHREAD_NORMAL_MUTEX_INITIALIZER_NP,
                                 PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP) == INVALID_OBJECT)
d1461 3
a1463 3
                                 PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,
                                 PTHREAD_NORMAL_MUTEX_INITIALIZER_NP,
                                 PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP) == VALID_OBJECT)
d1665 1
a1665 1
  currentvalue (value), 		/* Unused for named semaphores. */
d1856 1
a1856 1
                           void *static_ptr2, void *static_ptr3)
d2883 2
a2884 2
                     const pthread_mutexattr_t *attr,
                     const pthread_mutex_t initializer)
d2910 1
a2910 1
        new_mutex->type = PTHREAD_MUTEX_RECURSIVE;
d2912 1
a2912 1
        new_mutex->type = PTHREAD_MUTEX_NORMAL;
d2914 1
a2914 1
        new_mutex->type = PTHREAD_MUTEX_ERRORCHECK;
@


1.170
log
@Christopher Faylor <cgf@@timesys.com>
* path.cc (mount_info::conv_to_posix_path): Add return.
@
text
@d85 1
a85 1
extern "C" void
d88 1
a88 1
  pthread_mutex_trylock ((pthread_mutex_t*) lock);
@


1.169
log
@* thread.cc (pthread::thread_init_wrapper): Wait later to get more parallel
behavior.
@
text
@d607 18
a624 5
  if (is_good_object (&thread) &&
      thread->cancelstate != PTHREAD_CANCEL_DISABLE)
    wait_objects[num++] = thread->cancel_event;
  if (do_sig_wait)
    wait_objects[num++] = signal_arrived;
d627 3
a629 1
  if (res == WAIT_CANCELED)
d631 3
a633 7
      if (num == 3 || !do_sig_wait)
        {
	  if (do_cancel)
	    pthread::static_cancel_self ();
        }
      else
        res = WAIT_SIGNALED;
@


1.168
log
@* thread.cc (pthread::create): Use thread mutex to control synchronization
rather than creating a suspended thread.  Wait for "cancellation event" to
indicate that started thread has been properly initialized.
(pthread::thread_init_wrapper): Use set_tls_self_pointer() to set tid and
cygtls.  Signal with cancel_event when done.
@
text
@d304 1
a307 1
      postcreate ();
@


1.167
log
@* thread.h (pthread::init_mainthread): Remove parameter forked.
(pthread::set_tls_self_pointer): New static function.
* thread.cc (MTinterface::fixup_after_fork): Change call to
pthread::init_mainthread.
(pthread::init_mainthread): Remove parameter forked.  Simplify thread self
pointer handling.
(pthread::self): Set thread self pointer to null_pthread if thread has not been
initialized.
(pthread::set_tls_self_pointer): New static function.
@
text
@d293 1
d295 1
a295 2
				thread_init_wrapper, this, CREATE_SUSPENDED,
				&thread_id);
d304 3
a307 1
      ResumeThread (win32_obj_id);
d309 1
d1867 2
a1868 1
  _my_tls.tid = thread;
@


1.166
log
@* thread.h (pthread::init_mainthread): Add parameter forked.  Set forked
default to false..
* thread.cc (MTinterface::fixup_after_fork): Call pthread::init_mainthread with
forked = true.
(pthread::init_mainthread): Add parameter forked.  Do not change thread self
pointer when forked.
@
text
@d156 1
a156 1
  pthread::init_mainthread (true);
d169 1
a169 1
pthread::init_mainthread (const bool forked)
d174 3
a176 8
      if (forked)
        thread = pthread_null::get_null_pthread ();
      else
        {
          thread = new pthread ();
          if (!thread)
            api_fatal ("failed to create mainthread object");
        }
d179 1
a179 2
  thread->cygtls = &_my_tls;
  _my_tls.tid = thread;
d195 6
a200 3
  if (thread)
    return thread;
  return pthread_null::get_null_pthread ();
d207 7
@


1.165
log
@* thread.cc (pthread::atforkprepare): Call MT_INTERFACE->fixup_before_fork at
the end of atforkprepare.
@
text
@d156 1
a156 1
  pthread::init_mainthread ();
d169 1
a169 1
pthread::init_mainthread ()
d174 8
a181 3
      thread = new pthread ();
      if (!thread)
	api_fatal ("failed to create mainthread object");
@


1.164
log
@* path.cc (path_conv::check): Use 'strchr' rather than 'strrchr' to find end of
string, for efficiency.
* include/cygwin/_types.h: New file.
* include/sys/lock.h: Ditto.
* include/sys/stdio.h: Ditto.
* thread.cc: Include sys/lock.h
(__cygwin_lock_init): New function.
(__cygwin_lock_init_recursive): Ditto.
(__cygwin_lock_fini): Ditto.
(__cygwin_lock_lock): Ditto.
(__cygwin_lock_trylock): Ditto.
(__cygwin_lock_unlock): Ditto.
(pthread::atforkprepare): Lock file pointer before fork.
(pthread::atforkparent): Unlock file pointer after fork.
(pthread::atforkchild): Ditto.
@
text
@a1943 2
  MT_INTERFACE->fixup_before_fork ();

d1952 2
@


1.163
log
@* include/pthread.h (PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP):
New define.
(PTHREAD_NORMAL_MUTEX_INITIALIZER_NP): Ditto.
(PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP): Ditto.
* thread.cc (pthread_mutex::is_good_initializer):
Check for all posssible initializers
(pthread_mutex::is_good_initializer_or_object): Ditto.
(pthread_mutex::is_good_initializer_or_bad_object): Ditto.
(verifyable_object_isvalid): Support up to three static
initializers.
(verifyable_object_isvalid (void const *,long)): Remove.
(pthread_cond::is_good_initializer_or_bad_object): Remove
unneeded objectState var.
(pthread_cond::init): Condition remains unchanged when creation
has failed.
(pthread_rwlock::is_good_initializer_or_bad_object): Remove
unneeded objectState var.
(pthread_rwlock::init): Rwlock remains unchanged when creation
has failed.
(pthread_mutex::init): Remove obsolete comment.
Mutex remains unchanged when creation has failed. Add support
for new initializers.
(pthread_mutex_getprioceiling): Do not create mutex,
just return ENOSYS.
(pthread_mutex_lock): Simplify.
(pthread_mutex_trylock): Remove unneeded local themutex.
(pthread_mutex_unlock): Just return EPERM if mutex is not
initialized.
(pthread_mutex_setprioceiling): Do not create mutex,
just return ENOSYS.
* thread.h (verifyable_object_isvalid): Support up to three
static initializers.
(verifyable_object_isvalid (void const *,long)): Remove
prototype.
(pthread_mutex::init): Add optional initializer to parameter
list.
@
text
@d47 4
d61 37
d1952 2
d1959 2
d1973 2
@


1.162
log
@* exceptions.cc (setup_handler): Signal event for any sigwaitinfo if it exists
to force signal to be handled.  Zero event here to prevent races.
* signal.cc (sigwaitinfo): Use local handle value for everything since signal
thread could zero event element at any time.  Detect when awaking due to thread
not in mask and set return value and errno accordingly.  Don't set signal
number to zero unless we've recognized the signal.
* sigproc.cc (sigq): Rename from sigqueue throughout.
* thread.cc (pthread::join): Handle signals received while waiting for thread
to terminate.
* cygwin.din: Export sighold, sigqueue.
* exceptions.cc (sighold): Define new function.
* signal.cc (handle_sigprocmask): Set correct errno for invalid signal.
Simplify debugging output.
(sigqueue): Define new function.
* include/cygwin/signal.h (sighold): Declare new function.
(sigqueue): Ditto.
* include/cygwin/version.h: Bump API minor version number.
* include/limits.h (TIMER_MAX): Define.
(_POSIX_TIMER_MAX): Ditto.
@
text
@d1374 4
a1377 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER) != VALID_STATIC_OBJECT)
d1385 4
a1388 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER) == INVALID_OBJECT)
d1396 5
a1400 3
  verifyable_object_state objectState = verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER);
  if (objectState == VALID_OBJECT)
	return false;
d1791 2
a1792 1
verifyable_object_isvalid (void const * objectptr, long magic, void *static_ptr)
d1797 3
a1799 1
  if (static_ptr && *object == static_ptr)
a1809 6
verifyable_object_state
verifyable_object_isvalid (void const * objectptr, long magic)
{
  return verifyable_object_isvalid (objectptr, magic, NULL);
}

d2410 2
a2411 3
  verifyable_object_state objectState = verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER);
  if (objectState == VALID_OBJECT)
	return false;
d2436 3
d2450 2
a2451 2
  *cond = new pthread_cond (attr ? (*attr) : NULL);
  if (!is_good_object (cond))
d2453 1
a2453 2
      delete (*cond);
      *cond = NULL;
d2457 2
d2460 1
d2612 2
a2613 3
  verifyable_object_state objectState = verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC, PTHREAD_RWLOCK_INITIALIZER);
  if (objectState == VALID_OBJECT)
	return false;
d2638 2
d2651 2
a2652 2
  *rwlock = new pthread_rwlock (attr ? (*attr) : NULL);
  if (!is_good_object (rwlock))
d2654 1
a2654 2
      delete (*rwlock);
      *rwlock = NULL;
d2658 2
d2661 1
a2809 8
/* FIXME: there's a potential race with PTHREAD_MUTEX_INITALIZER:
   the mutex is not actually inited until the first use.
   So two threads trying to lock/trylock may collide.
   Solution: we need a global mutex on mutex creation, or possibly simply
   on all constructors that allow INITIALIZER macros.
   the lock should be very small: only around the init routine, not
   every test, or all mutex access will be synchronised.  */

d2812 2
a2813 1
		      const pthread_mutexattr_t *attr)
d2815 2
d2828 2
a2829 2
  *mutex = new pthread_mutex (attr ? (*attr) : NULL);
  if (!is_good_object (mutex))
d2831 1
a2831 2
      delete (*mutex);
      *mutex = NULL;
d2835 12
d2848 1
a2855 5
  pthread_mutex_t *themutex = (pthread_mutex_t *) mutex;
  if (pthread_mutex::is_good_initializer (mutex))
    pthread_mutex::init ((pthread_mutex_t *) mutex, NULL);
  if (!pthread_mutex::is_good_object (themutex))
    return EINVAL;
d2869 5
a2873 23
  pthread_mutex_t *themutex = mutex;
  /* This could be simplified via is_good_initializer_or_object
     and is_good_initializer, but in a performance critical call like this....
     no.  */
  switch (verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER))
    {
    case INVALID_OBJECT:
      return EINVAL;
      break;
    case VALID_STATIC_OBJECT:
      if (pthread_mutex::is_good_initializer (mutex))
	{
	  int rv = pthread_mutex::init (mutex, NULL);
	  if (rv && rv != EBUSY)
	    return rv;
	}
      /* No else needed. If it's been initialized while we waited,
	 we can just attempt to lock it */
      break;
    case VALID_OBJECT:
      break;
    }
  return (*themutex)->lock ();
a2878 1
  pthread_mutex_t *themutex = mutex;
d2880 2
a2881 2
    pthread_mutex::init (mutex, NULL);
  if (!pthread_mutex::is_good_object (themutex))
d2883 1
a2883 1
  return (*themutex)->trylock ();
d2890 1
a2890 1
    pthread_mutex::init (mutex, NULL);
a2917 5
  pthread_mutex_t *themutex = mutex;
  if (pthread_mutex::is_good_initializer (mutex))
    pthread_mutex::init (mutex, NULL);
  if (!pthread_mutex::is_good_object (themutex))
    return EINVAL;
@


1.161
log
@	* thread.cc (pthread::cancelable_wait): Rearrange slightly.
	Add do_sig_wait parameter.  Wait for signal_arrived if set to true.
	Return WAIT_SIGNALED if signal arrived.
	(pthread_cond::wait): Accomodate change to pthread::cancelable_wait.
	(pthread::join): Ditto.
	(semaphore::_timedwait): Ditto.
	(semaphore::_wait): Ditto.  Change to return int to allow status
	feedback.
	(semaphore::wait): Return return value from semaphore::_wait.
	* thread.h (WAIT_SIGNALED): New definition.
	(pthread::cancelable_wait): Change declaration.  Define do_sig_wait
	as false by default to not interfere with existing calls accidentally.
	(semaphore::_wait): Declare int.
@
text
@d2184 25
a2208 18
      switch (cancelable_wait ((*thread)->win32_obj_id, INFINITE, false, false))
	{
	case WAIT_OBJECT_0:
	  if (return_val)
	    *return_val = (*thread)->return_ptr;
	  delete (*thread);
	  break;
	case WAIT_CANCELED:
	  // set joined thread back to joinable since we got canceled
	  (*thread)->joiner = NULL;
	  (*thread)->attr.joinable = PTHREAD_CREATE_JOINABLE;
	  joiner->cancel_self ();
	  // never reached
	  break;
	default:
	  // should never happen
	  return EINVAL;
	}
@


1.160
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@a539 1

d541 2
a542 1
pthread::cancelable_wait (HANDLE object, DWORD timeout, const bool do_cancel)
d545 2
a546 1
  HANDLE wait_objects[2];
d549 22
a570 13
  if (!is_good_object (&thread) || thread->cancelstate == PTHREAD_CANCEL_DISABLE)
    return WaitForSingleObject (object, timeout);

  // Do not change the wait order
  // The object must have higher priority than the cancel event,
  // because WaitForMultipleObjects will return the smallest index
  // if both objects are signaled
  wait_objects[0] = object;
  wait_objects[1] = thread->cancel_event;

  res = WaitForMultipleObjects (2, wait_objects, FALSE, timeout);
  if (do_cancel && res == WAIT_CANCELED)
    pthread::static_cancel_self ();
d869 1
a869 1
  rv = pthread::cancelable_wait (sem_wait, dwMilliseconds, false);
d904 7
d1712 1
a1712 1
  switch (pthread::cancelable_wait (win32_obj_id, waitlength))
d1717 3
d1731 1
a1731 1
void
d1734 1
a1734 1
  switch (pthread::cancelable_wait (win32_obj_id, INFINITE))
d1739 3
d1744 1
a1744 1
      return;
d1746 1
d2184 1
a2184 1
      switch (cancelable_wait ((*thread)->win32_obj_id, INFINITE, false))
d3128 1
a3128 2
  (*sem)->_wait ();
  return 0;
@


1.159
log
@* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.158
log
@* cygwin/include/signal.h: Add copyright notice.
* cygwin.din: Make clock SIGFE.  Add clock_gettime, sigwaitinfo, timer_create,
timer_delete, timer_settime.
* include/cygwin/version.h: Reflect above additions.
* fork.cc (fork_child): Call fixup_timers_after_fork.
* signal.cc (sigwait): Remove unused variable.
* timer.cc: New file.
(clock_gettime): Define new function.
(timer_tracker): Define new struct used by timer functions.
(timer_tracker::timer_tracker): New function.
(to_us): New function.
(timer_thread): New function.
(timer_tracker::settime): New function.
(timer_create): New function.
(timer_settime): New function.
(timer_delete): New function.
(fixup_timers_after_fork): New function.
* cygthread.cc: Bump thread count.
* signal.cc (sigwaitinfo): Define new function.
(sigwait): Redefine based on sigwaitinfo.
* include/cygwin/signal.h (sigwaitinfo): Declare.
(sigwait): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Avoid double close of ctty when
ctty == ctty_on_hold.
* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
@
text
@d147 1
@


1.157
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d2739 6
a2744 1
  int rval = sig ? sig_send (NULL, sig, thread->cygtls) : 0;
@


1.157.4.1
log
@* fhandler_socket.cc (fhandler_socket::create_secret_event): Avoid creating
multiple handles.  Always allow event inheritance but set the handle
inheritance appropriately.  Improve error handling.
(fhandler_socket::check_peer_secret_event): Improve error handling.
(fhandler_socket::close_secret_event): Simply call CloseHandle.
(fhandler_socket::set_close_on_exec): Set secret event inheritance.
* configure.in: Remove NEWVFORK default.
* configure: Regenerate.
* dcrt0.cc: Conditionalize vfork stuff throughout.
* dtable.cc: Ditto.
* perthread.h: Ditto.
* pipe.cc (fhandler_pipe::close): Ditto.
* spawn.cc (spawnve): Ditto.
* syscalls.cc (setsid): Ditto.
* exceptions.cc (sigpacket::process): Use macro to refer to vfork pid.
* debug.cc (verify_handle): Define new function.
* debug.h (VerifyHandle): Define new macro.
(verify_handle): Declare new function
* fhandler.cc (fhandler_base::dup): Verify that dup'ed handle is not supposed
to be in use.
(fhandler_base::set_inheritance): Ditto.
(fhandler_base::fork_fixup): Ditto.
* fhandler_socket.cc (fhandler_socket::dup): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* net.cc (set_socket_inheritance): Ditto.
* pinfo.cc (pinfo_fixup_after_exec): Ditto.
* sigproc.cc (proc_subproc): Ditto.
(sig_send): Ditto.
* spawn.cc (spawn_guts): Ditto.
* thread.cc (pthread::init_mainthread): Ditto.
* pipe.cc (fhandler_pipe::close): Close read_state with ForceCloseHandle since
it was protected.
(fhandler_pipe::fixup_after_exec): Protect read_state handle.
(fhandler_pipe::dup): Correctly close open handles on error condition.  Verify
that dup'ed handle is not supposed to be in use.
(fhandler_pipe::create): Protect read_state.
@
text
@a146 1
  VerifyHandle (thread->win32_obj_id);
@


1.156
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d300 1
a300 1
      _my_tls.remove ();
a1784 3

  exception_list cygwin_except_entry;
  init_exceptions (&cygwin_except_entry); /* Initialize SIGSEGV handling, etc. */
@


1.156.2.1
log
@* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d300 1
a300 1
      _my_tls.remove (INFINITE);
d1785 3
@


1.156.2.2
log
@* gentls_offsets: Reinstate unlink of temp files.
@
text
@d2739 1
a2739 5
  siginfo_t si;
  si.si_signo = sig;
  si.si_code = SI_USER;
  si.si_pid = si.si_uid = si.si_errno = 0;
  int rval = sig ? sig_send (NULL, si, thread->cygtls) : 0;
@


1.156.2.3
log
@* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
* cygheap.cc (init_cygheap::close_ctty): Don't NULL ctty if it is still active.
* dtable.cc (dtable::vfork_parent_restore): Store ctty_on_hold prior to calling
close_all_files since it will be zeroed.
@
text
@a2742 1
  thread->cygtls->set_threadkill ();
@


1.155
log
@* thread.cc (pthread::init_main_thread): Make sure that the main thread has
valid handles.
(pthread::create_cancel_event): Fix error message.
@
text
@a36 1
#include <syslog.h>
d50 1
d54 1
a54 30
  struct __reent_t *_r =
    (struct __reent_t *) MT_INTERFACE->reent_key.get ();

  if (_r == 0)
    {
#ifdef _CYG_THREAD_FAILSAFE
      system_printf ("local thread storage not inited");
#endif
      /* Return _impure_ptr as long as MTinterface is not initialized */
      return _impure_ptr;
    }

  return _r->_clib;
}

struct _winsup_t *
_reent_winsup ()
{
  struct __reent_t *_r =
    (struct __reent_t *) MT_INTERFACE->reent_key.get ();

  if (_r == 0)
    {
#ifdef _CYG_THREAD_FAILSAFE
      system_printf ("local thread storage not inited");
#endif
      return NULL;
    }

  return _r->_winsup;
a59 8
#ifdef _CYG_THREAD_FAILSAFE
  if (!inited)
    system_printf ("lock called before initialization");

  thread_printf
    ("Get Resource lock %d ==> %p for %p , real : %d , threadid %d ", _resid,
     &lock, user_data, myself->pid, GetCurrentThreadId ());
#endif
a65 4
#ifdef _CYG_THREAD_FAILSAFE
  thread_printf ("Set resource lock %d mode %d for %s start",
		 _res_id, _mode, _function);
#endif
a66 5

#ifdef _CYG_THREAD_FAILSAFE
  user_data->resourcelocks->owner = GetCurrentThreadId ();
  user_data->resourcelocks->count++;
#endif
a71 10
#ifdef _CYG_THREAD_FAILSAFE
  thread_printf ("Release resource lock %d mode %d for %s done", _res_id,
		 _mode, _function);

  AssertResourceOwner (_res_id, _mode);
  user_data->resourcelocks->count--;
  if (user_data->resourcelocks->count == 0)
    user_data->resourcelocks->owner = 0;
#endif

a74 15
#ifdef _CYG_THREAD_FAILSAFE
void
AssertResourceOwner (int _res_id, int _mode)
{

  thread_printf
    ("Assert Resource lock %d ==> for %p , real : %d , threadid %d count %d owner %d",
     _res_id, user_data, myself->pid, GetCurrentThreadId (),
     user_data->resourcelocks->count, user_data->resourcelocks->owner);
  if (user_data && (user_data->resourcelocks->owner != GetCurrentThreadId ()))
    system_printf ("assertion failed, not the resource owner");
}

#endif

a79 6

#ifdef _CYG_THREAD_FAILSAFE
  owner = 0;
  count = 0;
#endif

a96 5
  reents._clib = _impure_ptr;
  reents._winsup = &winsup_reent;
  winsup_reent._process_logmask = LOG_UPTO (LOG_DEBUG);
  reent_key.set (&reents);

a113 8
  /* As long as the signal handling not multithreaded
     switch reents storage back to _impure_ptr for the mainthread
     to support fork from threads other than the mainthread */
  reents._clib = _impure_ptr;
  reents._winsup = &winsup_reent;
  winsup_reent._process_logmask = LOG_UPTO (LOG_DEBUG);
  reent_key.set (&reents);

a144 1
  thread->set_tls_self_pointer ();
a158 6
void
pthread::set_tls_self_pointer ()
{
  MT_INTERFACE->thread_self_key.set (this);
}

d162 1
a162 1
  return (pthread *) MT_INTERFACE->thread_self_key.get ();
a164 2


a1779 12
inline void
__reent_t::init_clib (struct _reent& var)
{
  var = ((struct _reent) _REENT_INIT (var));
  var._stdin = _GLOBAL_REENT->_stdin;
  var._stdout = _GLOBAL_REENT->_stdout;
  var._stderr = _GLOBAL_REENT->_stderr;
  var.__sdidinit = _GLOBAL_REENT->__sdidinit;
  var.__cleanup = _GLOBAL_REENT->__cleanup;
  _clib = &var;
};

d1789 1
a1789 9
  thread->set_tls_self_pointer ();
  struct __reent_t local_reent;
  struct _winsup_t local_winsup;
  struct _reent local_clib;

  memset (&local_winsup, 0, sizeof (struct _winsup_t));

  local_reent.init_clib (local_clib);
  local_reent._winsup = &local_winsup;
a1790 5
  local_winsup._process_logmask = LOG_UPTO (LOG_DEBUG);

  MT_INTERFACE->reent_key.set (&local_reent);

  thread->mutex.lock ();
d1796 1
a1796 6
#ifdef _CYG_THREAD_FAILSAFE
  if (_REENT == _impure_ptr)
    system_printf ("local storage for thread isn't setup correctly");
#endif

  thread_printf ("started thread %p %p %p %p %p %p", arg, &local_clib,
d2268 1
a2268 1
/* Thread SpecificData */
@


1.154
log
@* cygthread.cc (cygthread::stub): Revert previous change and again subsume
cygthread::stub2.  Just return from function now since ExitThread is guaranteed
by automatic _threadinfo wrapper.  Define as per ThreadProc convention.
(cygthread::stub2): Remove.
(cygthread::simplestub): Perform similar operations to cygthread::stub.
(cygthread::simplestub2): Remove.
* cygthread.h (cygthread::stub): Declare as per ThreadProc convention.
(cygthread::stub2): Remove declaration.
(cygthread::simplestub): Declare as per ThreadProc convention.
(cygthread::simplestub2): Remove declaration.
* cygtls.h (_threadinfo::call): Define first argument as per ThreadProc
convention.
(_threadinfo::call2): Ditto.
(_tlsbase): Define as char * pointer.
(_tlstop): New definition.
(_main_tls): Define here.
* dcrt0.cc (alloc_stack): Revert previous change which called init_thread since
information would be overwritten by fork later anyway.
(dll_crt0_1): Use _tlsbase and _tlstop for setting stack bottom, top.
* exceptions.cc: Move _main_tls declaration to cygtls.h.
(_threadinfo::call): Define first argument as per ThreadProc convention.
(_threadinfo::call2): Call ExitThread with thread function return value.
(_threadinfo::init_thread): Don't initialize cygtls to zero if input arg is
NULL.
* fork.cc (fork_child): Reset _main_tls here.  Reinitialize parts of _my_tls
after copying data from parent.
* init.cc (threadfunc_fe): New function.  Front-end for all threads created in
cygwin processes.
(munge_threadfunc): New function.
(dll_entry): Call munge_threadfunc to force the call of a thread wrapper.
* thread.cc (pthread::thread_init_wrapper): Perform similar operations to
cygthread::stub.
(pthread::thread_init_wrapper2): Remove.
* thread.h (pthread::thread_init_wrapper): Declare as per ThreadProc
convention.
(pthread::thread_init_wrapper2): Remove declaration.
* window.cc (Winmain): Just return from function now since ExitThread is
guaranteed by automatic _threadinfo wrapper.
@
text
@d234 1
a234 1
    thread->win32_obj_id = NULL;
d236 2
a237 1
  (void) thread->create_cancel_event ();
d293 1
a293 1
      system_printf ("couldn't create cancel event for main thread, %E");
@


1.153
log
@* miscfuncs.cc (low_priority_sleep): Correct thinko which caused SetPriority to
be called unnecessarily.
* thread.cc (pthread::init_main_thread): Call new create_cancel_event function.
(pthread::precreate): Ditto.
(pthread::postcreate): Remove cancel_event creation.
(pthread::create_cancel_event): Define new function.
* thread.h (pthread::create_cancel_event): Declare new function.
@
text
@d341 2
a342 2
				(LPTHREAD_START_ROUTINE) thread_init_wrapper,
				this, CREATE_SUSPENDED, &thread_id);
d1890 2
a1891 2
void
pthread::thread_init_wrapper2 (void *arg, void *)
a1930 1
}
d1932 1
a1932 6
/* Pthreads */
void
pthread::thread_init_wrapper (void *arg)
{
  // calls thread_init_wrapper2.  Never returns.
  _threadinfo::call (thread_init_wrapper2, arg);
@


1.152
log
@* thread.cc (pthread::precreate): Delete duplicate setting of cancel_event.
@
text
@d236 1
d286 13
d325 2
a358 9
  cancel_event = ::CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
  if (!cancel_event)
    {
      system_printf ("couldn't create cancel event for main thread, %E");
      /* we need the event for correct behaviour */
      magic = 0;
      return;
    }

@


1.151
log
@* cygtls.h: Add more "don't parse this" guards.
(_threadinfo::init_thread): Rename from 'init'.
(_threadinfo::init): Declare new function.
(_threadinfo::protect_linked_list): Declare new critical section.
* dcrt0.cc (dll_crt0_1): Call init_thread to initialize thread stuff.
(_dll_crt0): Call _threadinfo::init prior to invoking dll_crt0_1.
* exceptions.cc (_threadinfo::init_thread): Rename from 'init'.
(_threadinfo::init): Define new function.  Protect linked list manipulation
with new critical section.
(_threadinfo::call): Reflect function name change.
(_threadinfo::remove): Protect linked list manipulation with new critical
section
* gentls_offsets: Rework to allow multi-line "don't parse this" protection.
* init.cc (dll_entry): Don't remove threads info stuff here since the remove
function uses a critical section which can't be used during thread creation or
destruction.
* thread.cc (pthread::exit): Call _threadinfo remove function here.
@
text
@a310 9

  cancel_event = ::CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
  if (!cancel_event)
    {
      system_printf ("couldn't create cancel event, this %p LastError %E", this);
      /* we need the event for correct behaviour */
      magic = 0;
      return;
    }
@


1.150
log
@* cygthread.cc (cygthread::stub): Properly establish _threadinfo environment.
(cygthread::stub2): New function.
(cygthread::simplestub): Ditto.
(cygthread::simplestub2): New function.
* cygthread.h (cygthread::stub2): Declare new function.
(cygthread::simplestub2): Ditto.
* cygtls.h (_threadinfo::call): Declare new function.
(_threadinfo::call2): Ditto.
* dcrt0.cc (dll_crt0_1): Accommodate new _threadinfo::init which doesn't return
pointer to tls.
(_dll_crt0): Remove obsolete DECLARE_TLS_STORAGE.
(dll_crt0): Ditto.
* exceptions.cc (_threadinfo::call): New function.
(_threadinfo::call2): Ditto.
(_threadinfo::init): Don't return pointer.
* thread.cc (pthread::thread_init_wrapper): Properly establish _threadinfo
environment.
(pthread::thread_init_wrapper2): New function.
* thread.h (pthread::thread_init_wrapper): Remove noreturn attribute
(pthread::thread_init_wrapper2): Declare new function.
* winbase.h: Remove obsolete code.
@
text
@d395 1
d399 4
a402 1
    ExitThread (0);
@


1.149
log
@
* thread.cc (pthread_rwlock::add_reader): Remove mx parameter for
List_insert call.
(pthread::prepare): Ensure race safeness when adding function
pointers to atfork lists by using List_insert.
* thread.h (List_insert): Use InterlockedCompareExchangePointer to
ensure race safeness without using a mutex.
(List_remove): Use InterlockedCompareExchangePointer to
ensure race safeness with List_insert.
(List::insert): Remove mx parameter for	List_insert call.
@
text
@d1888 2
a1889 3
/* Pthreads */
void *
pthread::thread_init_wrapper (void *_arg)
d1891 1
a1891 4
  // Setup the local/global storage of this thread
  __uint64_t padding[CYGTLS_PADSIZE];
  pthread *thread = (pthread *) _arg;
  thread->cygtls = _my_tls.init (padding, &thread);
d1922 1
a1922 1
  thread_printf ("started thread %p %p %p %p %p %p", _arg, &local_clib,
d1929 8
@


1.148
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d1262 1
a1262 1
  List_insert (readers_mx, readers, rd);
a2000 16
/* Races in pthread_atfork:
   We are race safe in that any additions to the lists are made via
   InterlockedExchangePointer.
   However, if the user application doesn't perform syncronisation of some sort
   It's not guaranteed that a near simultaneous call to pthread_atfork and fork
   will result in the new atfork handlers being calls.
   More rigorous internal syncronisation isn't needed as the user program isn't
   guaranteeing their own state.

   as far as multiple calls to pthread_atfork, the worst case is simultaneous calls
   will result in an indeterminate order for parent and child calls (what gets inserted
   first isn't guaranteed.)

   There is one potential race... Does the result of InterlockedExchangePointer
   get committed to the return location _before_ any context switches can occur?
   If yes, we're safe, if no, we're not.  */
d2077 1
a2077 1
    prepcb->next = (callback *) InterlockedExchangePointer ((LONG *) &MT_INTERFACE->pthread_prepare, (long int) prepcb);
d2086 1
a2086 1
    parentcb->next = (callback *) InterlockedExchangePointer ((LONG *) t, (long int) parentcb);
d2095 1
a2095 1
    childcb->next = (callback *) InterlockedExchangePointer ((LONG *) t, (long int) childcb);
@


1.147
log
@	* dir.cc (mkdir): Use local security_descriptor. Call
	set_security_attribute appropriately.
	* external.cc (cygwin_internal): Ditto.
	* fhandler.cc (fhandler_base::open): Ditto.
	* fhandler_socket.cc (fhandler_socket::bind): Ditto.
	* path.cc (symlink_worker): Ditto.
	* sec_acl.cc (setacl): Ditto. Call read_sd appropriately.
	(getace): Ditto.
	* sec_helper.cc (security_descriptor::malloc): New method.
	(security_descriptor::realloc): New method.
	(security_descriptor::free): New method.
	* security.cc (read_sd): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	Allocate the security_descriptor buffer according to size returned by
	a call to GetFileSecurity. Return buffer size on success.
	(write_sd): Get security_descriptor as parameter instead of
	PSECURITY_DESCRIPTOR and a size.
	(get_nt_attribute): Use local security_descriptor.
	(get_nt_object_attribute): Ditto in case of type == SE_REGISTRY_KEY.
	Allocate security_descriptor buffer according to size returned by
	a call to RegGetKeySecurity.
	(alloc_sd): Make static. Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size. Drop unnecessary parameter check.
	(set_security_attribute): Get security_descriptor as parameter instead
	of PSECURITY_DESCRIPTOR and a size.
	(set_nt_attribute): Use local security_descriptor.
	(check_file_access): Ditto.
	* security.h: Add class security_descriptor.
	(read_sd): Change declaration to get security_descriptor as parameter
	instead of PSECURITY_DESCRIPTOR and a size.
	(write_sd): Ditto.
	(set_security_attribute): Ditto.
	(alloc_sd): Remove declaration.
	* thread.cc (semaphore::semaphore): Use local security_descriptor. Call
	set_security_attribute appropriately.
@
text
@d39 1
d42 1
a42 1
#include "exceptions.h"
d46 1
a195 1
#ifndef __SIGNALS_ARE_MULTITHREADED__
a202 1
#endif
d204 1
a204 1
  threadcount = 1;
d228 9
a236 1
  thread->init_current_thread ();
d249 1
a249 1
pthread::set_tls_self_pointer (pthread *thisThread)
d251 1
a251 1
  MT_INTERFACE->thread_self_key.set (thisThread);
a285 6
pthread::set_thread_id_to_current ()
{
  thread_id = GetCurrentThreadId ();
}

void
d339 1
a339 1
      thread_printf ("CreateThread failed: this %p LastError %E", this);
d352 9
a751 13
pthread::init_current_thread ()
{
  cancel_event = ::CreateEvent (&sec_none_nih, TRUE, FALSE, NULL);
  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),
			GetCurrentProcess (), &win32_obj_id,
			0, FALSE, DUPLICATE_SAME_ACCESS))
    win32_obj_id = NULL;
  set_thread_id_to_current ();
  set_tls_self_pointer (this);
  valid = true;
}

void
d1893 7
d1901 1
a1901 1
  pthread *thread = (pthread *) _arg;
a1905 15
  struct sigaction _sigs[NSIG];
  sigset_t _sig_mask;		/* one set for everything to ignore. */

  /* According to onno@@stack.urc.tue.nl, the exception handler record must
     be on the stack.  */
  exception_list cygwin_except_entry;

  /* Initialize SIGSEGV handling, etc. */
  init_exceptions (&cygwin_except_entry);

  // setup signal structures
  thread->sigs = _sigs;
  thread->sigmask = &_sig_mask;
  thread->sigtodo = NULL;

a1914 3
  thread->set_thread_id_to_current ();
  set_tls_self_pointer (thread);

a1932 7

#if 0
// ??? This code only runs if the thread exits by returning.
// it's all now in __pthread_exit ();
#endif
  /* never reached */
  return 0;
a1952 1
  DECLARE_TLS_STORAGE;
d2886 1
a2886 1
  int rval = raise (sig);
d2895 1
a2895 5
  int rval = sigprocmask (operation, set, old_set);

  // unlock this myself

  return rval;
@


1.146
log
@more white space
@
text
@d1679 1
d1681 1
a1681 1
	set_security_attribute (mode, &sa, alloca (4096), 4096);
@


1.145
log
@more white space
@
text
@d1683 1
a1683 1
        magic = 0;
d1711 1
a1711 1
        strcpy (name, sem_name);
d1749 1
a1749 1
        set_errno (EAGAIN);
d1779 1
a1779 1
         if the semaphore can be locked immediately. */
d1781 1
a1781 1
        return 0;
@


1.144
log
@more white space
@
text
@d327 3
a329 2
   function = func;
   arg = threadarg;
@


1.143
log
@more white space
@
text
@a410 1

d769 1
a769 1
    SuspendThread (win32_obj_id); 
d776 1
a776 1
    ResumeThread (win32_obj_id); 
d3312 1
a3312 1
  
@


1.142
log
@* thread.cc: Minor whitespace cleanup.  Remove some obsolete code.
@
text
@d326 1
a326 1
      return;
@


1.141
log
@
* thread.cc (pthread::exit): Cleanup on thread exit.
(__reent_t::init_clib): Set thread local clib __cleanup var
appropriately.
@
text
@d339 2
a340 1
  else {
d343 1
a343 1
  }
a2905 5
#if 0
  if (thread->sigs)
    myself->setthread2signal (thread);
#endif

a2914 10
#if 0
  pthread *thread = pthread::self ();

  // lock this myself, for the use of thread2signal
  // two differt kills might clash: FIXME

  if (thread->sigs)
    myself->setthread2signal (thread);
#endif

@


1.140
log
@
* thread.cc (__reent_t::init_clib): Set thread local clib
__sdidinit var appropriately.
@
text
@d380 2
d1884 1
@


1.139
log
@
* thread.cc (pthread::thread_init_wrapper): Initialize exception handling.
@
text
@d1881 1
@


1.138
log
@
Rename pthread::running to pthread::valid throughout.

* thread.h: (pthread::suspend_all_except_self): New static method.
(pthread::resume_all): Ditto.
(pthread::suspend_except_self): New method.
(pthread::resume): Ditto.
* thread.cc (pthread::suspend_except_self): Implement.
(pthread::resume): Ditto.
@
text
@d41 1
d1897 7
@


1.137
log
@	* cygwin.din: Add sem_close, sem_getvalue, sem_open and sem_timedwait.
	* pthread.cc (+mangle_sem_name): New function.
	(sem_open): Ditto.
	(sem_close: Ditto.
	(sem_timedwait): Ditto.
	(sem_getvalue): Ditto.
	* thread.cc (semaphore::semaphore): Rearrange member initialization.
	Use appropriate security attribute for process shared semaphores.
	(semaphore::semaphore): New constructor for named semaphores.
	(semaphore::~semaphore): Care for semaphore name.
	(semaphore::_post): Accomodate failing ReleaseSemaphore. Use value
	returned by ReleaseSemaphore vor currentvalue.
	(semaphore::_getvalue): New method.
	(semaphore::_timedwait): Ditto.
	(semaphore::_fixup_after_fork): Rearrange. Don't fail for process
	shared semaphores.
	(semaphore::open): New method.
	(semaphore::timedwait): Ditto.
	(semaphore::post): Fix return value.  Set errno appropriately.
	(semaphore::getvalue): New method.
	* thread.h (class semaphore): Add prototypes for open, getvalue,
	timedwait, _getvalue, _timedwait.  Add prototypes for new constructor.
	Add name member.
	* include/semaphore.h: Add prototypes for sem_open, sem_close,
	sem_timedwait and sem_getvalue.
	include/cygwin/version.h: Bump API minor number.
@
text
@d257 1
a257 1
		    running (false), suspended (false),
d347 1
a347 1
  running = true;
d374 1
a374 1
      running = false;
d393 1
a393 1
  if (!running)
d746 1
d756 1
a756 1
      running = false;
d762 14
d2350 1
a2350 1
  if ((*thread)->running && WaitForSingleObject ((*thread)->win32_obj_id, 0) == WAIT_TIMEOUT)
@


1.136
log
@Rename native_mutex to fast_mutex throughout.
Rename pthread_key::save_key_to_buffer to
pthread_key::_fixup_before_fork throughout.
Rename pthread_key::recreate_key_from_buffer to
pthread_key::_fixup_after_fork throughout.

* thread.cc (native_mutex::init): Remove.
(native_mutex::lock): Ditto.
(native_mutex::unlock): Ditto.
(pthread::push_cleanup_handler): InterlockedExchangePointer
is not needed here.
(pthread_rwlock::pthread_rwlock): Initialize readers list mutex.
(pthread_rwlock::add_reader): Add reader via List_insert.
(pthread_rwlock::lookup_reader): Lock list while walking through.
(pthread_cond::init): Locking the init mutex is now void.
(pthread_rwlock::init): Ditto.
(pthread_mutex::init): Ditto.
* thread.h: Include security.h.
(fast_mutex): New class. Replacement for native_mutex.
(List_insert): New template function.
(List_remove): Ditto.
(List::List): Initialize synchronising mutex.
(List::fixup_after_fork): New method.
(List::insert): Add node via List_insert.
(List::remove): Remove node via List_remove.
(List::pop): Remove.
(List::for_each): Lock list while walking through.
(List::mx_init): New method.
(pthread_mutex::fixup_after_fork): Fixup mutex list after fork.
(pthread::fixup_after_fork): Ditto.
(pthread_conds::fixup_after_fork): Ditto.
(pthread_rwlock::fixup_after_fork): Ditto.
(semaphore::fixup_after_fork): Ditto.
(pthread_rwlock::readers_mx): New member.
@
text
@d44 1
d1635 9
a1643 4
semaphore::semaphore (int pshared, unsigned int value):verifyable_object (SEM_MAGIC)
{
  this->win32_obj_id = ::CreateSemaphore (&sec_none_nih, value, LONG_MAX,
					  NULL);
d1646 48
a1693 2
  this->shared = pshared;
  currentvalue = value;
d1703 2
d1711 23
a1733 3
  /* we can't use the currentvalue, because the wait functions don't let us access it */
  ReleaseSemaphore (win32_obj_id, 1, NULL);
  currentvalue++;
d1751 37
d1805 9
a1813 7
  debug_printf ("sem %x in _fixup_after_fork", this);
  if (shared != PTHREAD_PROCESS_PRIVATE)
    api_fatal ("doesn't understand PROCESS_SHARED semaphores variables");
  /* FIXME: duplicate code here and in the constructor. */
  this->win32_obj_id = ::CreateSemaphore (&sec_none_nih, currentvalue, LONG_MAX, NULL);
  if (!win32_obj_id)
    api_fatal ("failed to create new win32 semaphore");
d3218 27
d3273 12
d3288 4
a3291 1
    return EINVAL;
d3295 14
@


1.135
log
@* include/tzfile.h: Add some missing entries.
@
text
@a81 31
bool
native_mutex::init ()
{
  theHandle = CreateMutex (&sec_none_nih, FALSE, NULL);
  if (!theHandle)
    {
      debug_printf ("CreateMutex failed. %E");
      return false;
    }
  return true;
}

bool
native_mutex::lock ()
{
  DWORD waitResult = WaitForSingleObject (theHandle, INFINITE);
  if (waitResult != WAIT_OBJECT_0)
    {
      system_printf ("Received unexpected wait result %d on handle %p, %E", waitResult, theHandle);
      return false;
    }
  return true;
}

void
native_mutex::unlock ()
{
  if (!ReleaseMutex (theHandle))
    system_printf ("Received a unexpected result releasing mutex. %E");
}

d692 1
a692 1
  InterlockedExchangePointer (&cleanup_stack, handler);
d802 1
a802 1
native_mutex NO_COPY pthread_cond::cond_initialization_lock;
d1012 1
a1012 1
native_mutex NO_COPY pthread_rwlock::rwlock_initialization_lock;
d1027 1
a1027 1
  readers (NULL), mtx (NULL), cond_readers (NULL), cond_writers (NULL),
d1033 7
d1244 1
a1244 2
  rd->next = (struct RWLOCK_READER *)
    InterlockedExchangePointer (&readers, rd);
d1250 1
a1250 10
  if (readers == rd)
    InterlockedExchangePointer (&readers, rd->next);
  else
    {
      struct RWLOCK_READER *temp = readers;
      while (temp->next && temp->next != rd)
	temp = temp->next;
      /* but there may be a race between the loop above and this statement */
      InterlockedExchangePointer (&temp->next, rd->next);
    }
d1256 3
a1258 1
  struct RWLOCK_READER *temp = readers;
d1260 2
a1261 2
  while (temp && temp->thread != thread)
    temp = temp->next;
d1263 3
a1265 1
  return temp;
d1297 3
d1371 1
a1371 1
pthread_key::save_key_to_buffer ()
d1377 1
a1377 1
pthread_key::recreate_key_from_buffer ()
d1472 1
a1472 1
native_mutex NO_COPY pthread_mutex::mutex_initialization_lock;
d2428 2
a2429 2
  if (!cond_initialization_lock.lock ())
    return EINVAL;
d2626 2
a2627 2
  if (!rwlock_initialization_lock.lock ())
    return EINVAL;
d2820 2
a2821 2
  if (!mutex_initialization_lock.lock ())
    return EINVAL;
@


1.134
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d1577 1
a1577 1
  if (InterlockedCompareExchange ((long *)&lock_counter, 1, 0 ) == 0)
@


1.133
log
@* thread.h (__reent_t::init_clib): Declare new function.
* thread.cc (__reent_t::init_clib): Define new function.
(pthread::thread_init_wrapper): Use __reent_t::init_clib to init local clib
storage and set std{in,out,err} appropriately.
@
text
@a1794 1
  LONG _sigtodo[NSIG + __SIGOFFSET];
d1799 1
a1799 1
  thread->sigtodo = _sigtodo;
d2792 1
d2795 1
d2806 1
d2814 1
@


1.132
log
@* thread.cc (MTinterface::fixup_after_fork): Remove code which potentially
overwrote _impure pointer with contents of thread which invoked fork since this
eliminates important information like the pointer to the atexit queue.
@
text
@d1772 10
d1791 1
a1791 1
  struct _reent local_clib = _REENT_INIT (local_clib);
d1804 1
a1804 1
  local_reent._clib = &local_clib;
@


1.132.2.1
log
@* thread.h (__reent_t::init_clib): Declare new function.
* thread.cc (__reent_t::init_clib): Define new function.
(pthread::thread_init_wrapper): Use __reent_t::init_clib to init local clib
storage and set std{in,out,err} appropriately.
* syscalls.cc (system): Strip signal considerations from here so that they are
not inherited by a child process.
* spawn.cc (spawn_guts): Handle system() signal stuff here.
* winsup.h (_P_SYSTEM): Define.
@
text
@a1771 10
inline void
__reent_t::init_clib (struct _reent& var)
{
  var = ((struct _reent) _REENT_INIT (var));
  var._stdin = _GLOBAL_REENT->_stdin;
  var._stdout = _GLOBAL_REENT->_stdout;
  var._stderr = _GLOBAL_REENT->_stderr;
  _clib = &var;
};

d1781 1
a1781 1
  struct _reent local_clib;
d1794 1
a1794 1
  local_reent.init_clib (local_clib);
@


1.131
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@a226 4
  struct _reent *reent_old = __getreent ();

  if (reent_old && _impure_ptr != reent_old)
    *_impure_ptr = *reent_old;
@


1.130
log
@* thread.cc: Remove _MT_SAFE conditional.
@
text
@d291 1
a291 1
		    running (false), suspended (false), 
d859 2
a860 2
        magic = 0;
        return;
d910 1
a910 1
  /* 
d921 13
a933 13
        {
          /* 
           * Block incoming threads until all waiting threads are released.
           */
          mtx_in.lock ();

          /* 
           * Calculate releaseable again because threads can enter until
           * the semaphore has been taken, but they can not leave, therefore pending
           * is unchanged and releaseable can only get higher
           */
          releaseable = waiting - pending;
        }
d974 1
a974 1
  
d981 1
a981 1
       */ 
d983 5
a987 5
        /*
         * thread got cancelled ot timed out while a signalling is in progress.
         * Set wait result back to signaled
         */
        rv = WAIT_OBJECT_0;
d1000 1
a1000 1
 
d1071 2
a1072 2
        magic = 0;
        return;
d1132 1
a1132 1
    {  
d1165 4
a1168 4
        {
          reader->thread = self;
          add_reader (reader);
        }
d1170 1
a1170 1
        result = EAGAIN;
d1172 1
a1172 1
    
d1193 1
a1193 1
    {  
d1223 1
a1223 1
    
d1240 4
a1243 4
        {
          result = EPERM;
          goto DONE;
        }
d1252 4
a1255 4
        {
          result = EPERM;
          goto DONE;
        }
d1339 1
a1339 1
        temp = &((*temp)->next);
d1341 5
a1345 5
        {
          struct RWLOCK_READER *cur = *temp;
          *temp = (*temp)->next;
          delete cur;
        }
@


1.129
log
@
* thread.cc (MTinterface::fixup_after_fork): Fix thread list after fork.
(pthread::threads): Instantiate.
(pthread::pthread): Initialize running and suspendend.
Initialize next with NULL.
Add thread to thread list if it is not the null_pthread.
(pthread::~pthread): Remove thread from thread list if it is not the null_pthread.
(pthread::postcreate): Set running flag.
(pthread::exit): Reset running flag.
(pthread::cancel): Try to cancel thread only if still running.
(pthread::_fixup_after_fork): Implement.
(pthread::detach): Check if thread is still running before detach.
* thread.h (pthread::running): New member.
(pthread::next): Ditto.
(pthread::fixup_after_fork): New static method.
(pthread::threads): New static method.
(pthread::_fixup_after_fork): New method.
@
text
@a31 1
#ifdef _MT_SAFE
a3230 2

#endif // MT_SAFE
@


1.128
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d241 1
d288 2
d292 1
d294 1
a294 1
		    joiner (NULL), cleanup_stack (NULL)
d296 2
d306 3
d382 9
a390 7
    InterlockedIncrement (&MT_INTERFACE->threadcount);
    /* FIXME: set the priority appropriately for system contention scope */
    if (attr.inheritsched == PTHREAD_EXPLICIT_SCHED)
      {
	/* FIXME: set the scheduling settings for the new thread */
	/* sched_thread_setparam (win32_obj_id, attr.schedparam); */
      }
d409 1
d428 6
d783 13
d2245 1
a2245 1
  if (WaitForSingleObject ((*thread)->win32_obj_id, 0) == WAIT_TIMEOUT)
@


1.127
log
@
* thread.cc (pthread_attr_init): Revert change from 2003-06-11
to return 0 if attribute is already initialized back to EBUSY.
(pthread_condattr_init): Ditto.
(pthread_rwlockattr_init): Ditto.
(pthread_mutexattr_init): Ditto.
@
text
@d48 2
a49 2
struct _reent *
_reent_clib ()
d54 2
d57 1
a57 2
  if (_r == 0)
    system_printf ("local thread storage not inited");
d59 4
d72 2
d75 1
a75 2
  if (_r == 0)
    system_printf ("local thread storage not inited");
d77 3
d223 14
@


1.126
log
@
* thread.cc (pthread_attr_init): Return 0 if attribute is already initialized.
Fix return code if out of memory.
(pthread_condattr_init): Ditto.
(pthread_rwlockattr_init): Ditto.
(pthread_mutexattr_init): Return 0 if attribute is already initialized.
@
text
@d1968 1
a1968 1
    return 0;
d2493 1
a2493 1
    return 0;
d2679 1
a2679 1
    return 0;
d2939 1
a2939 1
    return 0;
@


1.125
log
@
* thread.h (pthread::init_mainthread): Remove function parameter.
(MTinterface::Init): Ditto.
* thread.cc (MTinterface::Init): Remove function parameter.
Always initialize reent_key.
(pthread::init_mainthread): Remove function parameter.
(MTinterface::fixup_after_fork): Fix pthread::init_mainthread call.
* dcrt0.cc (dll_crt_0_1) Fix calls to MTinterface::Init and
pthread::init_mainthread.
Call pthread::init_mainthread only when not forked.
@
text
@d1967 3
a1969 2
  if (check_valid_pointer (attr))
    return EINVAL;
d1975 1
a1975 1
      return EAGAIN;
d2492 3
a2494 2
  if (check_valid_pointer (condattr))
    return EINVAL;
d2500 1
a2500 1
      return EAGAIN;
d2678 3
a2680 2
  if (check_valid_pointer (rwlockattr))
    return EINVAL;
d2686 1
a2686 1
      return EAGAIN;
d2939 1
a2939 1
    return EBUSY;
@


1.124
log
@
* thread.h (pthread::equal): New static method.
* thread.cc: Rename pthread_equal to pthread::equal throughout.
(pthread_equal): Use pthread::equal to compare threads ids.
@
text
@d191 1
a191 1
MTinterface::Init (int forked)
d196 1
a196 3

  if (!forked)
    reent_key.set (&reents);
d216 1
a216 1
  pthread::init_mainthread (true);
d228 1
a228 1
pthread::init_mainthread (bool do_init)
a229 3
  if (!do_init)
    return;

@


1.123
log
@
Fix a race in pthread_rwlock caused by simultanoues unlock and cancelation.

* thread.h (pthread_rwlock::release): New method.
* thread.cc (pthread_rwlock::unlock): Use release to signal
waiting threads.
(pthread_rwlock::rdlock_cleanup): Signal waiting threads after a
cancelation.
(pthread_rwlock::wrlock_cleanup): Ditto.
@
text
@d376 1
a376 1
  if (pthread_equal (joiner, thread))
d407 1
a407 1
  else if (pthread_equal (thread, self))
d1449 1
a1449 1
  return ((*mutex)->recursion_counter == 1 && pthread_equal ((*mutex)->owner, self));
d1511 1
a1511 1
  else if (type != PTHREAD_MUTEX_NORMAL && pthread_equal (owner, self))
d1535 1
a1535 1
  else if (type == PTHREAD_MUTEX_RECURSIVE && pthread_equal (owner, self))
d1546 1
a1546 1
  if (!pthread_equal (owner, self))
d2142 1
a2142 1
  if (pthread_equal (*thread,joiner))
d2768 1
a2768 1
  return t1 == t2;
@


1.122
log
@
* thread.cc: Change 1==foo equations to foo==1 throughout.
@
text
@d1213 1
a1213 7
  if (waiting_writers)
    {
      if (!readers)
        cond_writers.unblock (false);
    }
  else if (waiting_readers)
    cond_readers.unblock (true);
d1260 1
d1270 1
@


1.121
log
@
* thread.h: Change class names, methods, members and local vars
according to the GNU coding style.
* thread.cc: Ditto.
* dcrt0.cc (dll_crt0_1): Rename pthread::initMainThread call to
pthread::init_mainthread.
* pthread.cc (pthead_getsequence_np): Rename pthread::isGoodObject
call to pthread::is_good_object.
@
text
@d609 1
a609 1
  if (WAIT_OBJECT_0 == WaitForSingleObject (cancel_event, 0))
d907 1
a907 1
  if (1 == InterlockedIncrement ((long *)&waiting))
d934 1
a934 1
      if (WAIT_OBJECT_0 == WaitForSingleObject (sem_wait, 0))
d944 1
a944 1
  if (rv == WAIT_OBJECT_0 && 0 == --pending)
d1453 1
a1453 1
  return (pthread_equal ((*mutex)->owner, self)) && 1 == (*mutex)->recursion_counter;
d1513 1
a1513 1
  if (1 == InterlockedIncrement ((long *)&lock_counter))
d1515 1
a1515 1
  else if (PTHREAD_MUTEX_NORMAL != type && pthread_equal (owner, self))
d1518 1
a1518 1
      if (PTHREAD_MUTEX_RECURSIVE == type)
d1537 1
a1537 1
  if (0 == InterlockedCompareExchange ((long *)&lock_counter, 1, 0 ))
d1539 1
a1539 1
  else if (PTHREAD_MUTEX_RECURSIVE == type && pthread_equal (owner, self))
d1553 1
a1553 1
  if (0 == --recursion_counter)
d1588 1
a1588 1
  if (NULL == owner)
d2199 1
a2199 1
  if (WAIT_TIMEOUT == WaitForSingleObject ((*thread)->win32_obj_id, 0))
@


1.120
log
@
* thread.h (class List): Move inline code inside class
declaration.
(List::forEach): Change callback parameter to template class
member functionpointer.
(pthread_keys::fixup_before_fork): Change to inline. Use
List::forEach to fixup keys.
(pthread_keys::fixup_after_fork): Ditto.
(pthread_keys::runAllDestructors): Ditto.
(pthread_key::saveAKey): Remove.
(pthread_key::restoreAKey): Ditto.
(pthread_key::destroyAKey): Ditto.
(pthread_key::run_destructor): Rename to runDestructor.
(pthread_mutex::fixup_after_fork): Change to inline. Use
List::forEach to fixup mutexes after a fork.
(pthread_mutex::FixupAfterFork): New method.
(pthread_mutex::mutexes): New member.
(pthread_cond::fixup_after_fork): Change to inline. Use
List::forEach to fixup conds after a fork.
(pthread_cond::FixupAfterFork): New method.
(pthread_cond::conds): New member.
(pthread_rwlock::fixup_after_fork): Change to inline. Use
List::forEach to fixup rwlocks after a fork.
(pthread_rwlock::FixupAfterFork): New method.
(pthread_rwlock::rwlocks): New member.
(semaphore::fixup_after_fork): Change to inline. Use
List::forEach to fixup mutexes after a fork.
(semaphore::FixupAfterFork): New method.
(semaphore::semaphores): New member.
(MTinterface::mutexs): Remove.
(MTinterface::conds): Ditto.
(MTinterface::rwlocks): Ditto.
(MTinterface::semaphores): Ditto.
(pthread_equal): Add extern "C".
(pthread_mutex_lock): Ditto.

* thread.cc (MTinterface::fixup_after_fork): Change
fixup_after_fork calls for pthread objects.
(semaphore::conds): Instantiate.
(pthread_cond::pthread_cond): Use List::Insert rather than
custom list code.
(pthread_cond::~pthread_cond): Use List::Remove rather than
custom list code.
(pthread_cond::fixup_after_fork): Rename to FixupAfterFork.
(pthread_rwlock::rwlocks): Instantiate.
(pthread_rwlock::pthread_crwlock): Use List::Insert rather than
custom list code.
(pthread_rwlock::~pthread_rwlock): Use List::Remove rather than
custom list code.
(pthread_rwlock::fixup_after_fork): Rename to FixupAfterFork.
(pthread_key::saveAKey): Remove.
(pthread_key::fixup_before_fork): Ditto.
(pthread_key::restoreAKey): Ditto.
(pthread_key::fixup_after_fork): Ditto.
(pthread_key::destroyAKey): Ditto.
(pthread_key::runAllDestructors): Ditto.
(pthread_key::run_destructor): Rename to runDestructor.
(pthread_mutex::mutexes): Instantiate.
(pthread_mutex::pthread_mutex): Use List::Insert rather than
custom list code.
(pthread_mutex::~pthread_mutex): Use List::Remove rather than
custom list code.
(pthread_mutex::fixup_after_fork): Rename to FixupAfterFork.
(semaphore::conds): Instantiate.
(semaphore::semaphore): Use List::Insert rather than custom list
code.
(semaphores::~semaphore): Use List::Remove rather than custom
list code.
(semaphore::fixup_after_fork): Rename to FixupAfterFork.
@
text
@d75 1
a75 1
nativeMutex::init ()
d87 1
a87 1
nativeMutex::lock ()
d99 1
a99 1
nativeMutex::unlock ()
d200 3
a202 3
  pthread_mutex::initMutex ();
  pthread_cond::initMutex ();
  pthread_rwlock::initMutex ();
d218 1
a218 1
  pthread::initMainThread (true);
d230 1
a230 1
pthread::initMainThread (bool do_init)
d235 1
a235 1
  pthread *thread = getTlsSelfPointer ();
d243 1
a243 1
  thread->initCurrentThread ();
d249 1
a249 1
  pthread *thread = getTlsSelfPointer ();
d252 1
a252 1
  return pthreadNull::getNullpthread ();
d256 1
a256 1
pthread::setTlsSelfPointer (pthread *thisThread)
d262 1
a262 1
pthread::getTlsSelfPointer ()
d285 1
a285 1
pthread::setThreadIdtoCurrent ()
d307 1
a307 1
  if (!pthread_mutex::isGoodObject (&verifyable_mutex_obj))
d372 1
a372 1
  pthread_key::runAllDestructors ();
d374 1
a374 1
  mutex.Lock ();
d381 1
a381 1
      mutex.UnLock ();
d396 1
a396 1
  mutex.Lock ();
d402 1
a402 1
      mutex.UnLock ();
d409 1
a409 1
      mutex.UnLock ();
d424 1
a424 1
  mutex.UnLock ();
d627 1
a627 1
  if (!isGoodObject (&thread) || thread->cancelstate == PTHREAD_CANCEL_DISABLE)
d648 1
a648 1
  mutex.Lock ();
d659 1
a659 1
  mutex.UnLock ();
d669 1
a669 1
  mutex.Lock ();
d680 1
a680 1
  mutex.UnLock ();
d702 1
a702 1
  mutex.Lock ();
d713 1
a713 1
  mutex.UnLock ();
d730 1
a730 1
pthread::getThreadId ()
d736 1
a736 1
pthread::initCurrentThread ()
d743 2
a744 2
  setThreadIdtoCurrent ();
  setTlsSelfPointer (this);
d749 1
a749 1
pthread_attr::isGoodObject (pthread_attr_t const *attr)
d770 1
a770 1
pthread_condattr::isGoodObject (pthread_condattr_t const *attr)
d789 1
a789 1
nativeMutex NO_COPY pthread_cond::condInitializationLock;
d795 1
a795 1
pthread_cond::initMutex ()
d797 1
a797 1
  if (!condInitializationLock.init ())
d803 2
a804 2
  shared (0), waiting (0), pending (0), semWait (NULL),
  mtxCond(NULL), next (NULL)
d815 2
a816 2
  verifyable_mutex_obj = &mtxIn;
  if (!pthread_mutex::isGoodObject (&verifyable_mutex_obj))
d822 5
a826 2
  /* Change the mutex type to NORMAL to speed up mutex operations */
  mtxIn.type = PTHREAD_MUTEX_NORMAL;
d828 2
a829 2
  verifyable_mutex_obj = &mtxOut;
  if (!pthread_mutex::isGoodObject (&verifyable_mutex_obj))
d836 1
a836 1
  mtxOut.type = PTHREAD_MUTEX_NORMAL;
d838 2
a839 2
  semWait = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
  if (!semWait)
d846 1
a846 1
  conds.Insert (this);
d851 2
a852 2
  if (semWait)
    CloseHandle (semWait);
d854 1
a854 1
  conds.Remove (this);
d858 1
a858 1
pthread_cond::UnBlock (const bool all)
d865 1
a865 1
  mtxOut.Lock ();
d877 1
a877 1
          mtxIn.Lock ();
d892 1
a892 1
      ::ReleaseSemaphore (semWait, released, NULL);
d898 1
a898 1
  mtxOut.UnLock ();
d902 1
a902 1
pthread_cond::Wait (pthread_mutex_t mutex, DWORD dwMilliseconds)
d906 1
a906 1
  mtxIn.Lock ();
d908 2
a909 2
    mtxCond = mutex;
  else if (mtxCond != mutex)
d912 1
a912 1
      mtxIn.UnLock ();
d915 1
a915 1
  mtxIn.UnLock ();
d921 1
a921 1
  mutex->UnLock ();
d923 1
a923 1
  rv = pthread::cancelable_wait (semWait, dwMilliseconds, false);
d925 1
a925 1
  mtxOut.Lock ();
d934 1
a934 1
      if (WAIT_OBJECT_0 == WaitForSingleObject (semWait, 0))
d949 1
a949 1
    mtxIn.UnLock ();
d951 1
a951 1
  mtxOut.UnLock ();
d953 1
a953 1
  mutex->Lock ();
d965 1
a965 1
pthread_cond::FixupAfterFork ()
d968 1
a968 1
  mtxCond = NULL;
d971 2
a972 2
  mtxIn.UnLock ();
  mtxOut.UnLock ();
d974 3
a976 3
  semWait = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
  if (!semWait)
    api_fatal ("pthread_cond::FixupAfterFork () failed to recreate win32 semaphore");
d980 1
a980 1
pthread_rwlockattr::isGoodObject (pthread_rwlockattr_t const *attr)
d999 1
a999 1
nativeMutex NO_COPY pthread_rwlock::rwlockInitializationLock;
d1005 1
a1005 1
pthread_rwlock::initMutex ()
d1007 1
a1007 1
  if (!rwlockInitializationLock.init ())
d1013 2
a1014 2
  shared (0), waitingReaders (0), waitingWriters (0), writer (NULL),
  readers (NULL), mtx (NULL), condReaders (NULL), condWriters (NULL),
d1027 1
a1027 1
  if (!pthread_mutex::isGoodObject (&verifyable_mutex_obj))
d1036 2
a1037 2
  verifyable_cond_obj = &condReaders;
  if (!pthread_cond::isGoodObject (&verifyable_cond_obj))
d1044 2
a1045 2
  verifyable_cond_obj = &condWriters;
  if (!pthread_cond::isGoodObject (&verifyable_cond_obj))
d1053 1
a1053 1
  rwlocks.Insert (this);
d1058 1
a1058 1
  rwlocks.Remove (this);
d1062 1
a1062 1
pthread_rwlock::RdLock ()
d1068 1
a1068 1
  mtx.Lock ();
d1070 1
a1070 1
  if (lookupReader (self))
d1083 1
a1083 1
  while (writer || waitingWriters)
d1085 1
a1085 1
      pthread_cleanup_push (pthread_rwlock::RdLockCleanup, this);
d1087 3
a1089 3
      ++waitingReaders;
      condReaders.Wait (&mtx);
      --waitingReaders;
d1095 1
a1095 1
  addReader (reader);
d1098 1
a1098 1
  mtx.UnLock ();
d1104 1
a1104 1
pthread_rwlock::TryRdLock ()
d1109 1
a1109 1
  mtx.Lock ();
d1111 1
a1111 1
  if (writer || waitingWriters || lookupReader (self))
d1119 1
a1119 1
          addReader (reader);
d1125 1
a1125 1
  mtx.UnLock ();
d1131 1
a1131 1
pthread_rwlock::WrLock ()
d1136 1
a1136 1
  mtx.Lock ();
d1138 1
a1138 1
  if (writer == self || lookupReader (self))
d1146 1
a1146 1
      pthread_cleanup_push (pthread_rwlock::WrLockCleanup, this);
d1148 3
a1150 3
      ++waitingWriters;
      condWriters.Wait (&mtx);
      --waitingWriters;
d1158 1
a1158 1
  mtx.UnLock ();
d1164 1
a1164 1
pthread_rwlock::TryWrLock ()
d1169 1
a1169 1
  mtx.Lock ();
d1176 1
a1176 1
  mtx.UnLock ();
d1182 1
a1182 1
pthread_rwlock::UnLock ()
d1187 1
a1187 1
  mtx.Lock ();
d1201 1
a1201 1
      struct RWLOCK_READER *reader = lookupReader (self);
d1209 1
a1209 1
      removeReader (reader);
d1213 1
a1213 1
  if (waitingWriters)
d1216 1
a1216 1
        condWriters.UnBlock (false);
d1218 2
a1219 2
  else if (waitingReaders)
    condReaders.UnBlock (true);
d1222 1
a1222 1
  mtx.UnLock ();
d1228 1
a1228 1
pthread_rwlock::addReader (struct RWLOCK_READER *rd)
d1235 1
a1235 1
pthread_rwlock::removeReader (struct RWLOCK_READER *rd)
d1250 1
a1250 1
pthread_rwlock::lookupReader (pthread_t thread)
d1261 1
a1261 1
pthread_rwlock::RdLockCleanup (void *arg)
d1265 2
a1266 2
  --(rwlock->waitingReaders);
  rwlock->mtx.UnLock ();
d1270 1
a1270 1
pthread_rwlock::WrLockCleanup (void *arg)
d1274 2
a1275 2
  --(rwlock->waitingWriters);
  rwlock->mtx.UnLock ();
d1279 1
a1279 1
pthread_rwlock::FixupAfterFork ()
d1284 2
a1285 2
  waitingReaders = 0;
  waitingWriters = 0;
d1288 1
a1288 1
  mtx.UnLock ();
d1311 1
a1311 1
pthread_key::isGoodObject (pthread_key_t const *key)
d1322 2
a1323 2
  dwTlsIndex = TlsAlloc ();
  if (dwTlsIndex == TLS_OUT_OF_INDEXES)
d1326 1
a1326 1
    keys.Insert (this);
d1335 2
a1336 2
      keys.Remove (this);
      TlsFree (dwTlsIndex);
d1344 1
a1344 1
  TlsSetValue (dwTlsIndex, (void *) value);
d1351 3
a1353 3
  int savedError = ::GetLastError ();
  void *result = TlsGetValue (dwTlsIndex);
  ::SetLastError (savedError);
d1358 1
a1358 1
pthread_key::saveKeyToBuffer ()
d1364 1
a1364 1
pthread_key::recreateKeyFromBuffer ()
d1366 3
a1368 3
  dwTlsIndex = TlsAlloc ();
  if (dwTlsIndex == TLS_OUT_OF_INDEXES)
    api_fatal ("pthread_key::recreateKeyFromBuffer () failed to reallocate Tls storage");
d1373 1
a1373 1
pthread_key::runDestructor ()
d1411 1
a1411 1
pthread_mutex::isGoodObject (pthread_mutex_t const *mutex)
d1419 1
a1419 1
pthread_mutex::isGoodInitializer (pthread_mutex_t const *mutex)
d1427 1
a1427 1
pthread_mutex::isGoodInitializerOrObject (pthread_mutex_t const *mutex)
d1435 1
a1435 1
pthread_mutex::isGoodInitializerOrBadObject (pthread_mutex_t const *mutex)
d1444 1
a1444 1
pthread_mutex::canBeUnlocked (pthread_mutex_t const *mutex)
d1448 1
a1448 1
  if (!isGoodObject (mutex))
d1459 1
a1459 1
nativeMutex NO_COPY pthread_mutex::mutexInitializationLock;
d1465 1
a1465 1
pthread_mutex::initMutex ()
d1467 1
a1467 1
  if (!mutexInitializationLock.init ())
d1497 1
a1497 1
  mutexes.Insert (this);
d1505 1
a1505 1
  mutexes.Remove (this);
d1509 1
a1509 1
pthread_mutex::_Lock (pthread_t self)
d1514 1
a1514 1
    SetOwner (self);
d1519 1
a1519 1
	result = LockRecursive ();
d1526 1
a1526 1
      SetOwner (self);
d1533 1
a1533 1
pthread_mutex::_TryLock (pthread_t self)
d1538 1
a1538 1
    SetOwner (self);
d1540 1
a1540 1
    result = LockRecursive ();
d1548 1
a1548 1
pthread_mutex::_UnLock (pthread_t self)
d1565 1
a1565 1
pthread_mutex::_Destroy (pthread_t self)
d1567 1
a1567 1
  if (condwaits || _TryLock (self))
d1582 1
a1582 1
pthread_mutex::FixupAfterFork ()
d1584 1
a1584 1
  debug_printf ("mutex %x in FixupAfterFork", this);
d1586 1
a1586 1
    api_fatal ("pthread_mutex::FixupAfterFork () doesn'tunderstand PROCESS_SHARED mutex's");
d1597 1
a1597 1
    api_fatal ("pthread_mutex::FixupAfterFork () failed to recreate win32 semaphore for mutex");
d1603 1
a1603 1
pthread_mutexattr::isGoodObject (pthread_mutexattr_t const * attr)
d1630 1
a1630 1
  semaphores.Insert (this);
d1638 1
a1638 1
  semaphores.Remove (this);
d1642 1
a1642 1
semaphore::Post ()
d1650 1
a1650 1
semaphore::TryWait ()
d1665 1
a1665 1
semaphore::Wait ()
d1679 1
a1679 1
semaphore::FixupAfterFork ()
d1681 1
a1681 1
  debug_printf ("sem %x in FixupAfterFork", this);
d1761 2
a1762 2
  thread->setThreadIdtoCurrent ();
  setTlsSelfPointer (thread);
d1764 1
a1764 1
  thread->mutex.Lock ();
d1768 1
a1768 1
  thread->mutex.UnLock ();
d1792 1
a1792 1
pthread::isGoodObject (pthread_t const *thread)
d1802 1
a1802 1
  return getThreadId ();
d1810 1
a1810 1
  if (attr && !pthread_attr::isGoodObject (attr))
d1815 1
a1815 1
  if (!isGoodObject (thread))
d1852 1
a1852 1
  if (!isGoodObject (&thread))
d1979 1
a1979 1
  if (!pthread_attr::isGoodObject (attr))
d1992 1
a1992 1
  if (!pthread_attr::isGoodObject (attr))
d2002 1
a2002 1
  if (!pthread_attr::isGoodObject (attr))
d2014 1
a2014 1
  if (!pthread_attr::isGoodObject (attr))
d2024 1
a2024 1
  if (!pthread_attr::isGoodObject (attr))
d2033 1
a2033 1
  if (!pthread_attr::isGoodObject (attr))
d2044 1
a2044 1
  if (!pthread_attr::isGoodObject (attr))
d2053 1
a2053 1
  if (!pthread_attr::isGoodObject (attr))
d2066 1
a2066 1
  if (!pthread_attr::isGoodObject (attr))
d2078 1
a2078 1
  if (!pthread_attr::isGoodObject (attr))
d2088 1
a2088 1
  if (!pthread_attr::isGoodObject (attr))
d2104 1
a2104 1
  if (!pthread_attr::isGoodObject (attr))
d2113 1
a2113 1
  if (!pthread_attr::isGoodObject (attr))
d2122 1
a2122 1
  if (!pthread_attr::isGoodObject (attr))
d2140 1
a2140 1
   if (!isGoodObject (&joiner))
d2143 1
a2143 1
  if (!isGoodObject (thread))
d2149 1
a2149 1
  (*thread)->mutex.Lock ();
d2153 1
a2153 1
      (*thread)->mutex.UnLock ();
d2160 1
a2160 1
      (*thread)->mutex.UnLock ();
d2188 1
a2188 1
  if (!isGoodObject (thread))
d2191 1
a2191 1
  (*thread)->mutex.Lock ();
d2194 1
a2194 1
      (*thread)->mutex.UnLock ();
d2204 1
a2204 1
      (*thread)->mutex.UnLock ();
d2209 1
a2209 1
      (*thread)->mutex.UnLock ();
d2219 1
a2219 1
  if (!isGoodObject (thread))
d2235 1
a2235 1
  if (!isGoodObject (thread))
d2259 1
a2259 1
  if (!pthread::isGoodObject (&thread))
d2274 1
a2274 1
  if (pthread_key::isGoodObject (key))
d2279 1
a2279 1
  if (!pthread_key::isGoodObject (key))
d2291 1
a2291 1
  if (!pthread_key::isGoodObject (&key))
d2315 1
a2315 1
  if (!pthread::isGoodObject (&thread))
d2332 1
a2332 1
  if (!pthread_key::isGoodObject (&key))
d2341 1
a2341 1
  if (!pthread_key::isGoodObject (&key))
d2350 1
a2350 1
pthread_cond::isGoodObject (pthread_cond_t const *cond)
d2358 1
a2358 1
pthread_cond::isGoodInitializer (pthread_cond_t const *cond)
d2366 1
a2366 1
pthread_cond::isGoodInitializerOrObject (pthread_cond_t const *cond)
d2374 1
a2374 1
pthread_cond::isGoodInitializerOrBadObject (pthread_cond_t const *cond)
d2385 1
a2385 1
  if (pthread_cond::isGoodInitializer (cond))
d2387 1
a2387 1
  if (!pthread_cond::isGoodObject (cond))
d2403 1
a2403 1
  if (attr && !pthread_condattr::isGoodObject (attr))
d2405 1
a2405 1
  if (!condInitializationLock.lock ())
d2408 1
a2408 1
  if (!isGoodInitializerOrBadObject (cond))
d2410 1
a2410 1
      condInitializationLock.unlock ();
d2415 1
a2415 1
  if (!isGoodObject (cond))
d2419 1
a2419 1
      condInitializationLock.unlock ();
d2422 1
a2422 1
  condInitializationLock.unlock ();
d2429 1
a2429 1
  if (pthread_cond::isGoodInitializer (cond))
d2431 1
a2431 1
  if (!pthread_cond::isGoodObject (cond))
d2434 1
a2434 1
  (*cond)->UnBlock (true);
d2442 1
a2442 1
  if (pthread_cond::isGoodInitializer (cond))
d2444 1
a2444 1
  if (!pthread_cond::isGoodObject (cond))
d2447 1
a2447 1
  (*cond)->UnBlock (false);
d2456 1
a2456 1
  if (!pthread_mutex::isGoodObject (mutex))
d2458 1
a2458 1
  if (!pthread_mutex::canBeUnlocked (mutex))
d2461 1
a2461 1
  if (pthread_cond::isGoodInitializer (cond))
d2463 1
a2463 1
  if (!pthread_cond::isGoodObject (cond))
d2466 1
a2466 1
  return (*cond)->Wait (*mutex, waitlength);
d2503 1
a2503 1
  if (!pthread_condattr::isGoodObject (condattr))
d2515 1
a2515 1
  if (!pthread_condattr::isGoodObject (attr))
d2524 1
a2524 1
  if (!pthread_condattr::isGoodObject (attr))
d2538 1
a2538 1
  if (!pthread_condattr::isGoodObject (condattr))
d2547 1
a2547 1
pthread_rwlock::isGoodObject (pthread_rwlock_t const *rwlock)
d2555 1
a2555 1
pthread_rwlock::isGoodInitializer (pthread_rwlock_t const *rwlock)
d2563 1
a2563 1
pthread_rwlock::isGoodInitializerOrObject (pthread_rwlock_t const *rwlock)
d2571 1
a2571 1
pthread_rwlock::isGoodInitializerOrBadObject (pthread_rwlock_t const *rwlock)
d2582 1
a2582 1
  if (pthread_rwlock::isGoodInitializer (rwlock))
d2584 1
a2584 1
  if (!pthread_rwlock::isGoodObject (rwlock))
d2588 1
a2588 1
      (*rwlock)->waitingReaders || (*rwlock)->waitingWriters)
d2600 1
a2600 1
  if (attr && !pthread_rwlockattr::isGoodObject (attr))
d2602 1
a2602 1
  if (!rwlockInitializationLock.lock ())
d2605 1
a2605 1
  if (!isGoodInitializerOrBadObject (rwlock))
d2607 1
a2607 1
      rwlockInitializationLock.unlock ();
d2612 1
a2612 1
  if (!isGoodObject (rwlock))
d2616 1
a2616 1
      rwlockInitializationLock.unlock ();
d2619 1
a2619 1
  rwlockInitializationLock.unlock ();
d2628 1
a2628 1
  if (pthread_rwlock::isGoodInitializer (rwlock))
d2630 1
a2630 1
  if (!pthread_rwlock::isGoodObject (rwlock))
d2633 1
a2633 1
  return (*rwlock)->RdLock ();
d2639 1
a2639 1
  if (pthread_rwlock::isGoodInitializer (rwlock))
d2641 1
a2641 1
  if (!pthread_rwlock::isGoodObject (rwlock))
d2644 1
a2644 1
  return (*rwlock)->TryRdLock ();
d2652 1
a2652 1
  if (pthread_rwlock::isGoodInitializer (rwlock))
d2654 1
a2654 1
  if (!pthread_rwlock::isGoodObject (rwlock))
d2657 1
a2657 1
  return (*rwlock)->WrLock ();
d2663 1
a2663 1
  if (pthread_rwlock::isGoodInitializer (rwlock))
d2665 1
a2665 1
  if (!pthread_rwlock::isGoodObject (rwlock))
d2668 1
a2668 1
  return (*rwlock)->TryWrLock ();
d2674 1
a2674 1
  if (pthread_rwlock::isGoodInitializer (rwlock))
d2676 1
a2676 1
  if (!pthread_rwlock::isGoodObject (rwlock))
d2679 1
a2679 1
  return (*rwlock)->UnLock ();
d2688 1
a2688 1
  if (!pthread_rwlockattr::isGoodObject (rwlockattr))
d2700 1
a2700 1
  if (!pthread_rwlockattr::isGoodObject (attr))
d2709 1
a2709 1
  if (!pthread_rwlockattr::isGoodObject (attr))
d2723 1
a2723 1
  if (!pthread_rwlockattr::isGoodObject (rwlockattr))
d2737 1
a2737 1
  if (!pthread::isGoodObject (&thread))
d2789 1
a2789 1
  if (attr && !pthread_mutexattr::isGoodObject (attr) || check_valid_pointer (mutex))
d2791 1
a2791 1
  if (!mutexInitializationLock.lock ())
d2794 1
a2794 1
  if (!isGoodInitializerOrBadObject (mutex))
d2796 1
a2796 1
      mutexInitializationLock.unlock ();
d2801 1
a2801 1
  if (!isGoodObject (mutex))
d2805 1
a2805 1
      mutexInitializationLock.unlock ();
d2808 1
a2808 1
  mutexInitializationLock.unlock ();
d2817 1
a2817 1
  if (pthread_mutex::isGoodInitializer (mutex))
d2819 1
a2819 1
  if (!pthread_mutex::isGoodObject (themutex))
d2835 2
a2836 2
  /* This could be simplified via isGoodInitializerOrObject
     and isGoodInitializer, but in a performance critical call like this....
d2844 1
a2844 1
      if (pthread_mutex::isGoodInitializer (mutex))
d2856 1
a2856 1
  return (*themutex)->Lock ();
d2863 1
a2863 1
  if (pthread_mutex::isGoodInitializer (mutex))
d2865 1
a2865 1
  if (!pthread_mutex::isGoodObject (themutex))
d2867 1
a2867 1
  return (*themutex)->TryLock ();
d2873 1
a2873 1
  if (pthread_mutex::isGoodInitializer (mutex))
d2875 1
a2875 1
  if (!pthread_mutex::isGoodObject (mutex))
d2877 1
a2877 1
  return (*mutex)->UnLock ();
d2885 1
a2885 1
  if (pthread_mutex::isGoodInitializer (mutex))
d2887 1
a2887 1
  if (!pthread_mutex::isGoodObject (mutex))
d2890 1
a2890 1
  rv = (*mutex)->Destroy ();
d2903 1
a2903 1
  if (pthread_mutex::isGoodInitializer (mutex))
d2905 1
a2905 1
  if (!pthread_mutex::isGoodObject (themutex))
d2916 1
a2916 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2925 1
a2925 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2934 1
a2934 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2944 1
a2944 1
  if (pthread_mutexattr::isGoodObject (attr))
d2948 1
a2948 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2960 1
a2960 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2972 1
a2972 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2982 1
a2982 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2991 1
a2991 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2999 1
a2999 1
  if (!pthread_mutexattr::isGoodObject (attr))
d3014 1
a3014 1
  if (!pthread_mutexattr::isGoodObject (attr))
d3035 1
a3035 1
semaphore::isGoodObject (sem_t const * sem)
d3046 1
a3046 1
  if (isGoodObject (sem))
d3054 1
a3054 1
  if (!isGoodObject (sem))
d3066 1
a3066 1
  if (!isGoodObject (sem))
d3081 1
a3081 1
  if (!isGoodObject (sem))
d3087 1
a3087 1
  (*sem)->Wait ();
d3094 1
a3094 1
  if (!isGoodObject (sem))
d3100 1
a3100 1
  return (*sem)->TryWait ();
d3106 1
a3106 1
  if (!isGoodObject (sem))
d3109 1
a3109 1
  (*sem)->Post ();
d3113 1
a3113 1
/* pthreadNull */
d3115 1
a3115 1
pthreadNull::getNullpthread ()
d3122 1
a3122 1
pthreadNull::pthreadNull ()
d3129 1
a3129 1
pthreadNull::~pthreadNull ()
d3134 1
a3134 1
pthreadNull::create (void *(*)(void *), pthread_attr *, void *)
d3139 1
a3139 1
pthreadNull::exit (void *value_ptr)
d3145 1
a3145 1
pthreadNull::cancel ()
d3151 1
a3151 1
pthreadNull::testcancel ()
d3156 1
a3156 1
pthreadNull::setcancelstate (int state, int *oldstate)
d3162 1
a3162 1
pthreadNull::setcanceltype (int type, int *oldtype)
d3168 1
a3168 1
pthreadNull::push_cleanup_handler (__pthread_cleanup_handler *handler)
d3173 1
a3173 1
pthreadNull::pop_cleanup_handler (int const execute)
d3178 1
a3178 1
pthreadNull::getsequence_np ()
d3183 1
a3183 1
pthreadNull pthreadNull::_instance;
@


1.119
log
@
* pthread.cc (pthread_attr_init): Remove
(pthread_attr_destroy): Ditto.
(pthread_attr_setdetachstate): Ditto.
(pthread_attr_getdetachstate): Ditto.
(pthread_attr_setstacksize): Ditto.
(pthread_attr_getstacksize): Ditto.
(pthread_attr_setinheritsched): Ditto.
(pthread_attr_getinheritsched): Ditto.
(pthread_attr_setschedparam): Ditto.
(pthread_attr_getschedparam): Ditto.
(pthread_attr_setschedpolicy): Ditto.
(pthread_attr_getschedpolicy): Ditto.
(pthread_attr_setscope): Ditto.
(pthread_attr_getscope): Ditto.
(pthread_attr_setstackaddr): Ditto.
(pthread_attr_getstackaddr): Ditto.
(pthread_key_create): Ditto.
(pthread_key_delete): Ditto.
(pthread_setspecific): Ditto.
(pthread_getspecific): Ditto.
(pthread_kill): Ditto.
(pthread_sigmask): Ditto.
(pthread_equal): Ditto.
(pthread_mutex_lock): Ditto.
(pthread_mutex_trylock): Ditto.
(pthread_mutex_unlock): Ditto.
(pthread_mutex_destroy): Ditto.
(pthread_mutex_setprioceiling): Ditto.
(pthread_mutex_getprioceiling): Ditto.
(pthread_mutexattr_destroy): Ditto.
(pthread_mutexattr_getprioceiling): Ditto.
(pthread_mutexattr_getprotocol): Ditto.
(pthread_mutexattr_getpshared): Ditto.
(pthread_mutexattr_gettype): Ditto.
(pthread_mutexattr_init): Ditto.
(pthread_mutexattr_setprioceiling): Ditto.
(pthread_mutexattr_setprotocol): Ditto.
(pthread_mutexattr_setpshared): Ditto.
(pthread_mutexattr_settype): Ditto.
(pthread_cond_destroy): Ditto.
(pthread_cond_signal): Ditto.
(pthread_cond_broadcast): Ditto.
(pthread_condattr_init): Ditto.
(pthread_condattr_destroy): Ditto.
(pthread_condattr_getpshared): Ditto.
(pthread_condattr_setpshared): Ditto.
(pthread_rwlock_destroy): Ditto.
(pthread_rwlock_rdlock): Ditto.
(pthread_rwlock_tryrdlock): Ditto.
(pthread_rwlock_wrlock): Ditto.
(pthread_rwlock_trywrlock): Ditto.
(pthread_rwlock_unlock): Ditto.
(pthread_rwlockattr_init): Ditto.
(pthread_rwlockattr_getpshared): Ditto.
(pthread_rwlockattr_setpshared): Ditto.
(pthread_rwlockattr_destroy): Ditto.
(pthread_getconcurrency): Ditto.
(pthread_setconcurrency): Ditto.
(pthread_getschedparam): Ditto.
(pthread_setschedparam): Ditto.

* thread.h (__pthread_attr_init): Remove prototype.
(__pthread_attr_destroy): Ditto.
(__pthread_attr_setdetachstate): Ditto.
(__pthread_attr_getdetachstate): Ditto.
(__pthread_attr_setstacksize): Ditto.
(__pthread_attr_getstacksize): Ditto.
(__pthread_attr_setinheritsched): Ditto.
(__pthread_attr_getinheritsched): Ditto.
(__pthread_attr_setschedparam): Ditto.
(__pthread_attr_getschedparam): Ditto.
(__pthread_attr_setschedpolicy): Ditto.
(__pthread_attr_getschedpolicy): Ditto.
(__pthread_attr_setscope): Ditto.
(__pthread_attr_getscope): Ditto.
(__pthread_attr_setstackaddr): Ditto.
(__pthread_attr_getstackaddr): Ditto.
(__pthread_key_create): Ditto.
(__pthread_key_delete): Ditto.
(__pthread_setspecific): Ditto.
(__pthread_getspecific): Ditto.
(__pthread_kill): Ditto.
(__pthread_sigmask): Ditto.
(__pthread_equal): Ditto.
(__pthread_mutex_lock): Ditto.
(__pthread_mutex_trylock): Ditto.
(__pthread_mutex_unlock): Ditto.
(__pthread_mutex_destroy): Ditto.
(__pthread_mutex_setprioceiling): Ditto.
(__pthread_mutex_getprioceiling): Ditto.
(__pthread_mutexattr_destroy): Ditto.
(__pthread_mutexattr_getprioceiling): Ditto.
(__pthread_mutexattr_getprotocol): Ditto.
(__pthread_mutexattr_getpshared): Ditto.
(__pthread_mutexattr_gettype): Ditto.
(__pthread_mutexattr_init): Ditto.
(__pthread_mutexattr_setprioceiling): Ditto.
(__pthread_mutexattr_setprotocol): Ditto.
(__pthread_mutexattr_setpshared): Ditto.
(__pthread_mutexattr_settype): Ditto.
(__pthread_cond_destroy): Ditto.
(__pthread_cond_signal): Ditto.
(__pthread_cond_broadcast): Ditto.
(__pthread_condattr_init): Ditto.
(__pthread_condattr_destroy): Ditto.
(__pthread_condattr_getpshared): Ditto.
(__pthread_condattr_setpshared): Ditto.
(__pthread_rwlock_destroy): Ditto.
(__pthread_rwlock_rdlock): Ditto.
(__pthread_rwlock_tryrdlock): Ditto.
(__pthread_rwlock_wrlock): Ditto.
(__pthread_rwlock_trywrlock): Ditto.
(__pthread_rwlock_unlock): Ditto.
(__pthread_rwlockattr_init): Ditto.
(__pthread_rwlockattr_getpshared): Ditto.
(__pthread_rwlockattr_setpshared): Ditto.
(__pthread_rwlockattr_destroy): Ditto.
(__pthread_getconcurrency): Ditto.
(__pthread_setconcurrency): Ditto.
(__pthread_getschedparam): Ditto.
(__pthread_setschedparam): Ditto.

* thread.cc: Rename __pthread_equal to pthread_equal throughout.
Change pthread_self parameter appropriate.
(__pthread_attr_init): Remove __ prefix. Change to extern "C".
(__pthread_attr_destroy): Ditto.
(__pthread_attr_setdetachstate): Ditto.
(__pthread_attr_getdetachstate): Ditto.
(__pthread_attr_setstacksize): Ditto.
(__pthread_attr_getstacksize): Ditto.
(__pthread_attr_setinheritsched): Ditto.
(__pthread_attr_getinheritsched): Ditto.
(__pthread_attr_setschedparam): Ditto.
(__pthread_attr_getschedparam): Ditto.
(__pthread_attr_setschedpolicy): Ditto.
(__pthread_attr_getschedpolicy): Ditto.
(__pthread_attr_setscope): Ditto.
(__pthread_attr_getscope): Ditto.
(__pthread_attr_setstackaddr): Ditto.
(__pthread_attr_getstackaddr): Ditto.
(__pthread_key_create): Ditto.
(__pthread_key_delete): Ditto.
(__pthread_setspecific): Ditto.
(__pthread_getspecific): Ditto.
(__pthread_kill): Ditto.
(__pthread_sigmask): Ditto.
(__pthread_equal): Ditto.
(__pthread_mutex_lock): Ditto.
(__pthread_mutex_trylock): Ditto.
(__pthread_mutex_unlock): Ditto.
(__pthread_mutex_destroy): Ditto.
(__pthread_mutex_setprioceiling): Ditto.
(__pthread_mutex_getprioceiling): Ditto.
(__pthread_mutexattr_destroy): Ditto.
(__pthread_mutexattr_getprioceiling): Ditto.
(__pthread_mutexattr_getprotocol): Ditto.
(__pthread_mutexattr_getpshared): Ditto.
(__pthread_mutexattr_gettype): Ditto.
(__pthread_mutexattr_init): Ditto.
(__pthread_mutexattr_setprioceiling): Ditto.
(__pthread_mutexattr_setprotocol): Ditto.
(__pthread_mutexattr_setpshared): Ditto.
(__pthread_mutexattr_settype): Ditto.
(__pthread_cond_destroy): Ditto.
(__pthread_cond_signal): Ditto.
(__pthread_cond_broadcast): Ditto.
(__pthread_condattr_init): Ditto.
(__pthread_condattr_destroy): Ditto.
(__pthread_condattr_getpshared): Ditto.
(__pthread_condattr_setpshared): Ditto.
(__pthread_rwlock_destroy): Ditto.
(__pthread_rwlock_rdlock): Ditto.
(__pthread_rwlock_tryrdlock): Ditto.
(__pthread_rwlock_wrlock): Ditto.
(__pthread_rwlock_trywrlock): Ditto.
(__pthread_rwlock_unlock): Ditto.
(__pthread_rwlockattr_init): Ditto.
(__pthread_rwlockattr_getpshared): Ditto.
(__pthread_rwlockattr_setpshared): Ditto.
(__pthread_rwlockattr_destroy): Ditto.
(__pthread_getconcurrency): Ditto.
(__pthread_setconcurrency): Ditto.
(__pthread_getschedparam): Ditto.
(__pthread_setschedparam): Ditto.
@
text
@d220 4
a223 28
  pthread_mutex *mutex = mutexs;
  debug_printf ("mutexs is %x",mutexs);
  while (mutex)
    {
      mutex->fixup_after_fork ();
      mutex = mutex->next;
    }
  pthread_cond *cond = conds;
  debug_printf ("conds is %x",conds);
  while (cond)
    {
      cond->fixup_after_fork ();
      cond = cond->next;
    }
  pthread_rwlock *rwlock = rwlocks;
  debug_printf ("rwlocks is %x",rwlocks);
  while (rwlock)
    {
      rwlock->fixup_after_fork ();
      rwlock = rwlock->next;
    }
  semaphore *sem = semaphores;
  debug_printf ("semaphores is %x",semaphores);
  while (sem)
    {
      sem->fixup_after_fork ();
      sem = sem->next;
    }
d786 2
d843 1
a843 2
  /* threadsafe addition is easy */
  next = (pthread_cond *) InterlockedExchangePointer (&MT_INTERFACE->conds, this);
d851 1
a851 11
  /* I'm not 100% sure the next bit is threadsafe. I think it is... */
  if (MT_INTERFACE->conds == this)
    InterlockedExchangePointer (&MT_INTERFACE->conds, this->next);
  else
    {
      pthread_cond *tempcond = MT_INTERFACE->conds;
      while (tempcond->next && tempcond->next != this)
	tempcond = tempcond->next;
      /* but there may be a race between the loop above and this statement */
      InterlockedExchangePointer (&tempcond->next, this->next);
    }
d962 1
a962 1
pthread_cond::fixup_after_fork ()
d973 1
a973 1
    api_fatal ("pthread_cond::fixup_after_fork () failed to recreate win32 semaphore");
d993 2
d1050 1
a1050 2
  /* threadsafe addition is easy */
  next = (pthread_rwlock *) InterlockedExchangePointer (&MT_INTERFACE->rwlocks, this);
d1055 1
a1055 11
  /* I'm not 100% sure the next bit is threadsafe. I think it is... */
  if (MT_INTERFACE->rwlocks == this)
    InterlockedExchangePointer (&MT_INTERFACE->rwlocks, this->next);
  else
    {
      pthread_rwlock *temprwlock = MT_INTERFACE->rwlocks;
      while (temprwlock->next && temprwlock->next != this)
	temprwlock = temprwlock->next;
      /* but there may be a race between the loop above and this statement */
      InterlockedExchangePointer (&temprwlock->next, this->next);
    }
d1276 1
a1276 1
pthread_rwlock::fixup_after_fork ()
a1306 36
void
pthread_key::saveAKey (pthread_key *key)
{
  key->saveKeyToBuffer ();
}

void
pthread_key::fixup_before_fork ()
{
  keys.forEach (saveAKey);
}

void
pthread_key::restoreAKey (pthread_key *key)
{
  key->recreateKeyFromBuffer ();
}

void
pthread_key::fixup_after_fork ()
{
  keys.forEach (restoreAKey);
}

void
pthread_key::destroyAKey (pthread_key *key)
{
  key->run_destructor ();
}

void
pthread_key::runAllDestructors ()
{
  keys.forEach (destroyAKey);
}

d1370 1
a1370 1
pthread_key::run_destructor ()
d1453 2
d1494 1
a1494 2
  /* threadsafe addition is easy */
  next = (pthread_mutex *) InterlockedExchangePointer (&MT_INTERFACE->mutexs, this);
d1502 1
a1502 13
  /* I'm not 100% sure the next bit is threadsafe. I think it is... */
  if (MT_INTERFACE->mutexs == this)
    /* TODO: printf an error if the return value != this */
    InterlockedExchangePointer (&MT_INTERFACE->mutexs, next);
  else
    {
      pthread_mutex *tempmutex = MT_INTERFACE->mutexs;
      while (tempmutex->next && tempmutex->next != this)
	tempmutex = tempmutex->next;
      /* but there may be a race between the loop above and this statement */
      /* TODO: printf an error if the return value != this */
      InterlockedExchangePointer (&tempmutex->next, this->next);
    }
d1579 1
a1579 1
pthread_mutex::fixup_after_fork ()
d1581 1
a1581 1
  debug_printf ("mutex %x in fixup_after_fork", this);
d1583 1
a1583 1
    api_fatal ("pthread_mutex::fixup_after_fork () doesn'tunderstand PROCESS_SHARED mutex's");
d1594 1
a1594 1
    api_fatal ("pthread_mutex::fixup_after_fork () failed to recreate win32 semaphore for mutex");
d1616 2
d1626 2
a1627 2
  /* threadsafe addition is easy */
  next = (semaphore *) InterlockedExchangePointer (&MT_INTERFACE->semaphores, this);
d1634 2
a1635 11
  /* I'm not 100% sure the next bit is threadsafe. I think it is... */
  if (MT_INTERFACE->semaphores == this)
    InterlockedExchangePointer (&MT_INTERFACE->semaphores, this->next);
  else
    {
      semaphore *tempsem = MT_INTERFACE->semaphores;
      while (tempsem->next && tempsem->next != this)
	tempsem = tempsem->next;
      /* but there may be a race between the loop above and this statement */
      InterlockedExchangePointer (&tempsem->next, this->next);
    }
d1676 1
a1676 1
semaphore::fixup_after_fork ()
d1678 1
a1678 1
  debug_printf ("sem %x in fixup_after_fork", this);
d2766 1
a2766 1
int
d2828 1
a2828 1
int
@


1.118
log
@
* cygwin.din: Add pthread_rwlock_destroy, pthread_rwlock_init,
pthread_rwlock_rdlock, pthread_rwlock_tryrdlock,
pthread_rwlock_wrlock, pthread_rwlock_trywrlock,
pthread_rwlock_unlock, pthread_rwlockattr_init,
pthread_rwlockattr_getpshared, pthread_rwlockattr_setpshared,
and pthread_rwlockattr_destroy.
* include/cygwin/version.h: Bump API minor number.
* include/pthread.h (PTHREAD_RWLOCK_INITIALIZER): Define a
reasonable value.
Add prototypes for pthread_rwlock_destroy, pthread_rwlock_init,
pthread_rwlock_rdlock, pthread_rwlock_tryrdlock,
pthread_rwlock_wrlock, pthread_rwlock_trywrlock,
pthread_rwlock_unlock, pthread_rwlockattr_init,
pthread_rwlockattr_getpshared, pthread_rwlockattr_setpshared,
and pthread_rwlockattr_destroy.
* thread.h (PTHREAD_ONCE_MAGIC): Remove superflous semicolon.
(PTHREAD_RWLOCK_MAGIC): New define.
(PTHREAD_RWLOCKATTR_MAGIC): Ditto.
(pthread_rwlockattr): New class.
(pthread_rwlock): Ditto.
(MTinterface::rwlocks): New member.
(MTinterface::MTinterface): Initialize rwlocks.
Add prototypes for __pthread_rwlock_destroy,
__pthread_rwlock_wrlock, __pthread_rwlock_trywrlock,
__pthread_rwlock_unlock, __pthread_rwlockattr_init,
__pthread_rwlockattr_getpshared, __pthread_rwlockattr_setpshared,
and __pthread_rwlockattr_destroy.
* thread.cc (MTinterface::Init): Initialize rwlock internal mutex.
(MTinterface::fixup_after_fork): Fixup rwlocks after fork.
(pthread_rwlockattr::isGoodObject): Implement.
(pthread_rwlockattr::pthread_rwlockattr): Ditto.
(pthread_rwlockattr::~pthread_rwlockattr): Ditto.
(pthread_rwlock::initMutex): Ditto.
(pthread_rwlock::pthread_rwlock): Ditto.
(pthread_rwlock::~pthread_rwlock): Ditto.
(pthread_rwlock::RdLock): Ditto.
(pthread_rwlock::TryRdLock): Ditto.
(pthread_rwlock::WrLock): Ditto.
(pthread_rwlock::TryWrLock): Ditto.
(pthread_rwlock::UnLock): Ditto.
(pthread_rwlock::addReader): Ditto.
(pthread_rwlock::removeReader): Ditto.
(pthread_rwlock::lookupReader): Ditto.
(pthread_rwlock::RdLockCleanup): Ditto.
(pthread_rwlock::WrLockCleanup): Ditto.
(pthread_rwlock::fixup_after_fork): Ditto.
(pthread_rwlock::isGoodObject): Ditto.
(pthread_rwlock::isGoodInitializer): Ditto.
(pthread_rwlock::isGoodInitializerOrObject): Ditto.
(pthread_rwlock::isGoodInitializerOrBadObject): Ditto.
(__pthread_rwlock_destroy): Ditto.
(pthread_rwlock::init): Ditto.
(__pthread_rwlock_rdlock): Ditto.
(__pthread_rwlock_tryrdlock): Ditto.
(__pthread_rwlock_wrlock): Ditto.
(__pthread_rwlock_trywrlock): Ditto.
@
text
@d400 1
a400 1
  if (__pthread_equal (&joiner, &thread))
d431 1
a431 1
  else if (__pthread_equal (&thread, &self))
d1528 1
a1528 1
  return (__pthread_equal (&(*mutex)->owner, &self)) && 1 == (*mutex)->recursion_counter;
d1601 1
a1601 1
  else if (PTHREAD_MUTEX_NORMAL != type && __pthread_equal (&owner, &self))
d1625 1
a1625 1
  else if (PTHREAD_MUTEX_RECURSIVE == type && __pthread_equal (&owner, &self))
d1636 1
a1636 1
  if (!__pthread_equal (&owner, &self))
d2066 2
a2067 2
int
__pthread_attr_init (pthread_attr_t *attr)
d2081 2
a2082 2
int
__pthread_attr_getinheritsched (const pthread_attr_t *attr,
d2091 2
a2092 2
int
__pthread_attr_getschedparam (const pthread_attr_t *attr,
d2104 2
a2105 2
int
__pthread_attr_getschedpolicy (const pthread_attr_t *attr, int *policy)
d2114 2
a2115 2
int
__pthread_attr_getscope (const pthread_attr_t *attr, int *contentionscope)
d2123 2
a2124 2
int
__pthread_attr_setdetachstate (pthread_attr_t *attr, int detachstate)
d2134 2
a2135 2
int
__pthread_attr_getdetachstate (const pthread_attr_t *attr, int *detachstate)
d2143 2
a2144 2
int
__pthread_attr_setinheritsched (pthread_attr_t *attr, int inheritsched)
d2155 2
a2156 2
int
__pthread_attr_setschedparam (pthread_attr_t *attr,
d2168 2
a2169 2
int
__pthread_attr_setschedpolicy (pthread_attr_t *attr, int policy)
d2178 2
a2179 2
int
__pthread_attr_setscope (pthread_attr_t *attr, int contentionscope)
d2194 2
a2195 2
int
__pthread_attr_setstacksize (pthread_attr_t *attr, size_t size)
d2203 2
a2204 2
int
__pthread_attr_getstacksize (const pthread_attr_t *attr, size_t *size)
d2212 2
a2213 2
int
__pthread_attr_destroy (pthread_attr_t *attr)
d2239 1
a2239 1
  if (__pthread_equal (thread,&joiner))
d2341 2
a2342 2
int
__pthread_getconcurrency (void)
d2348 2
a2349 2
int
__pthread_getschedparam (pthread_t thread, int *policy,
d2362 2
a2363 2
int
__pthread_key_create (pthread_key_t *key, void (*destructor) (void *))
d2381 2
a2382 2
int
__pthread_key_delete (pthread_key_t key)
d2394 2
a2395 2
int
__pthread_setconcurrency (int new_level)
d2404 2
a2405 2
int
__pthread_setschedparam (pthread_t thread, int policy,
d2422 2
a2423 2
int
__pthread_setspecific (pthread_key_t key, const void *value)
d2431 2
a2432 2
void *
__pthread_getspecific (pthread_key_t key)
d2475 2
a2476 2
int
__pthread_cond_destroy (pthread_cond_t *cond)
d2519 2
a2520 2
int
__pthread_cond_broadcast (pthread_cond_t *cond)
d2532 2
a2533 2
int
__pthread_cond_signal (pthread_cond_t *cond)
d2590 2
a2591 2
int
__pthread_condattr_init (pthread_condattr_t *condattr)
d2605 2
a2606 2
int
__pthread_condattr_getpshared (const pthread_condattr_t *attr, int *pshared)
d2614 2
a2615 2
int
__pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared)
d2628 2
a2629 2
int
__pthread_condattr_destroy (pthread_condattr_t *condattr)
d2672 2
a2673 2
int
__pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
d2716 2
a2717 2
int
__pthread_rwlock_rdlock (pthread_rwlock_t *rwlock)
d2729 2
a2730 2
int
__pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock)
d2740 2
a2741 2
int
__pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
d2753 2
a2754 2
int
__pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock)
d2764 2
a2765 2
int
__pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
d2775 2
a2776 2
int
__pthread_rwlockattr_init (pthread_rwlockattr_t *rwlockattr)
d2790 2
a2791 2
int
__pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr, int *pshared)
d2799 2
a2800 2
int
__pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared)
d2813 2
a2814 2
int
__pthread_rwlockattr_destroy (pthread_rwlockattr_t *rwlockattr)
d2824 2
a2825 2
int
__pthread_kill (pthread_t thread, int sig)
d2842 2
a2843 2
int
__pthread_sigmask (int operation, const sigset_t *set, sigset_t *old_set)
d2863 1
a2863 1
__pthread_equal (pthread_t *t1, pthread_t *t2)
d2865 1
a2865 1
  return (*t1 == *t2);
d2905 2
a2906 2
int
__pthread_mutex_getprioceiling (const pthread_mutex_t *mutex,
d2925 1
a2925 1
__pthread_mutex_lock (pthread_mutex_t *mutex)
d2952 2
a2953 2
int
__pthread_mutex_trylock (pthread_mutex_t *mutex)
d2963 2
a2964 2
int
__pthread_mutex_unlock (pthread_mutex_t *mutex)
d2973 2
a2974 2
int
__pthread_mutex_destroy (pthread_mutex_t *mutex)
d2991 2
a2992 2
int
__pthread_mutex_setprioceiling (pthread_mutex_t *mutex, int prioceiling,
d3005 2
a3006 2
int
__pthread_mutexattr_getprotocol (const pthread_mutexattr_t *attr,
d3014 2
a3015 2
int
__pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr,
d3024 2
a3025 2
int
__pthread_mutexattr_gettype (const pthread_mutexattr_t *attr, int *type)
d3034 2
a3035 2
int
__pthread_mutexattr_init (pthread_mutexattr_t *attr)
d3050 2
a3051 2
int
__pthread_mutexattr_destroy (pthread_mutexattr_t *attr)
d3062 2
a3063 2
int
__pthread_mutexattr_setprotocol (pthread_mutexattr_t *attr, int protocol)
d3071 2
a3072 2
int
__pthread_mutexattr_setprioceiling (pthread_mutexattr_t *attr,
d3080 2
a3081 2
int
__pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *attr,
d3089 2
a3090 2
int
__pthread_mutexattr_setpshared (pthread_mutexattr_t *attr, int pshared)
d3103 3
a3105 3
/* see __pthread_mutex_gettype */
int
__pthread_mutexattr_settype (pthread_mutexattr_t *attr, int type)
@


1.117
log
@
* thread.h (pthread_cond::ExitingWait): Remove.
(pthread_cond::mutex): Ditto.
(pthread_cond::cond_access): Ditto.
(pthread_cond::win32_obj_id): Ditto.
(pthread_cond::TimedWait): Ditto.
(pthread_cond::BroadCast): Ditto.
(pthread_cond::Signal): Ditto.
(pthread_cond::waiting): Change type to unsigned long.
(pthread_cond::pending): New member.
(pthread_cond::semWait): Ditto.
(pthread_cond::mtxIn): Ditto.
(pthread_cond::mtxOut): Ditto.
(pthread_cond::mtxCond): Ditto.
(pthread_cond::UnBlock): New method.
(pthread_cond::Wait): Ditto.
* thread.cc: Update list of cancellation points.
(pthread_cond::pthread_cond): Rewrite.
(pthread_cond::~pthread_cond): Ditto.
(pthread_cond::TimedWait): Remove.
(pthread_cond::BroadCast): Ditto.
(pthread_cond::Signal): Ditto.
(pthread_cond::UnBlock): Implement.
(pthread_cond::Wait): Ditto.
(pthread_cond::fixup_after_fork): Rewrite.
(pthread_mutex::fixup_after_fork): Remove DETECT_BAD_APP
conditional.
(__pthread_cond_broadcast): Just return 0 if the condition is
not initialized. Call pthread_cond::UnBlock to release blocked
threads.
(__pthread_cond_signal): Ditto.
(__pthread_cond__dowait): Rewrite.
(pthread_cond_timedwait): Add pthread_testcancel call. Fix
waitlength calculation.
(pthread_cond_wait): Add pthread_testcancel call.
@
text
@d202 1
d234 7
d1009 335
d2635 185
@


1.116
log
@

* include/pthread.h (PTHREAD_MUTEX_NORMAL): New define.
* thread.cc: Remove errno.h include.
(pthread::precreate): Change internal mutex type to normal.
(pthread_mutex::canBeUnlocked): Implement.
(pthread_mutex::pthread_mutex): Initialize lock_counter with 0.
(pthread_mutex::Lock): Rename to _Lock. Add self parameter.
Change lock_counter logic. Update SetOwner call.
(pthread_mutex::TryLock): Rename to _TryLock. Add self parameter.
Change lock_counter logic. Update SetOwner call.
(pthread_mutex::UnLock): Rename to _UnLock. Add self parameter.
Change lock_counter logic.
(pthread_mutex::Destroy): Rename to _Destroy. Update TryLock call.
(pthread_mutex::SetOwner): Move to thread.h as inline.
(pthread_mutex::LockRecursive): Ditto.
(pthread_mutex::fixup_after_fork): Change lock_counter logic.
(__pthread_mutexattr_settype): Add PTHREAD_MUTEX_NORMAL to valid
types check.
* thread.h: Include errno.h and limits.h.
(MUTEX_LOCK_COUNTER_INITIAL): Remove.
(MUTEX_OWNER_ANONYMOUS): New define.
(pthread_mutex::canBeUnlocked): New static method.
(pthread_mutex::lock_counter): Change type to unsigned long.
(pthread_mutex::GetPthreadSelf): New method.
(pthread_mutex::Lock): Call _Lock with pthread_self pointer.
(pthread_mutex::TryLock): Call _TryLock with pthread_self pointer.
(pthread_mutex::UnLock): Call _UnLock with pthread_self pointer.
(pthread_mutex::Destroy): Call _Destroy with pthread_self pointer.
(pthread_mutex::SetOwner): Moved from thread.cc as inline.
(pthread_mutex::LockRecursive): Ditto.
(pthread_mutex::_Lock): New method.
(pthread_mutex::_TryLock): New method.
(pthread_mutex::_UnLock): New method.
(pthread_mutex::_Destroy): New method.
@
text
@d465 2
a466 2
pthread_cond_timedwait ()
pthread_cond_wait ()
d815 4
a818 1
pthread_cond::pthread_cond (pthread_condattr *attr):verifyable_object (PTHREAD_COND_MAGIC)
d820 31
a850 11
  int temperr;
  this->shared = attr ? attr->shared : PTHREAD_PROCESS_PRIVATE;
  this->mutex = NULL;
  this->waiting = 0;

  this->win32_obj_id = ::CreateEvent (&sec_none_nih, false,	/* auto signal reset - which I think is pthreads like ? */
				      false,	/* start non signaled */
				      NULL /* no name */);
  /* TODO: make a shared mem mutex if out attributes request shared mem cond */
  cond_access = NULL;
  if ((temperr = pthread_mutex_init (&this->cond_access, NULL)))
d852 1
a852 2
      system_printf ("couldn't init mutex, this %p errno %d", this, temperr);
      /* we need the mutex for correct behaviour */
d854 1
a856 2
  if (!this->win32_obj_id)
    magic = 0;
d863 3
a865 3
  if (win32_obj_id)
    CloseHandle (win32_obj_id);
  pthread_mutex_destroy (&cond_access);
d880 1
a880 1
pthread_cond::BroadCast ()
d882 6
a887 19
  /* TODO: implement the same race fix as Signal has */
  if (pthread_mutex_lock (&cond_access))
    system_printf ("Failed to lock condition variable access mutex, this %p", this);
  int count = waiting;
  if (!pthread_mutex::isGoodObject (&mutex))
    {
      if (pthread_mutex_unlock (&cond_access))
	system_printf ("Failed to unlock condition variable access mutex, this %p", this);
      /* This isn't and API error - users are allowed to call this when no threads
	 are waiting
	 system_printf ("Broadcast called with invalid mutex");
      */
      return;
    }
  while (count--)
    PulseEvent (win32_obj_id);
  if (pthread_mutex_unlock (&cond_access))
    system_printf ("Failed to unlock condition variable access mutex, this %p", this);
}
d889 2
a890 6
void
pthread_cond::Signal ()
{
  if (pthread_mutex_lock (&cond_access))
    system_printf ("Failed to lock condition variable access mutex, this %p", this);
  if (!pthread_mutex::isGoodObject (&mutex))
d892 23
a914 4
      if (pthread_mutex_unlock (&cond_access))
	system_printf ("Failed to unlock condition variable access mutex, this %p",
		       this);
      return;
d916 3
a918 25
  int temp = waiting;
  if (!temp)
    /* nothing to signal */
    {
      if (pthread_mutex_unlock (&cond_access))
	system_printf ("Failed to unlock condition variable access mutex, this %p", this);
      return;
    }
  /* Prime the detection flag */
  ExitingWait = 1;
  /* Signal any waiting thread */
  PulseEvent (win32_obj_id);
  /* No one can start waiting until we release the condition access mutex */
  /* The released thread will decrement waiting when it gets a time slice...
     without waiting for the access mutex
   * InterLockedIncrement on 98 +, NT4 + returns the incremented value.
   * On 95, nt 3.51 < it returns a sign correct number - 0=0, + for greater than 0, -
   * for less than 0.
   * Because of this we cannot spin on the waiting count, but rather we need a
   * dedicated flag for a thread exiting the Wait function.
   * Also not that Interlocked* sync CPU caches with memory.
   */
  int spins = 10;
  /* When ExitingWait is nonzero after a decrement, the leaving thread has
   * done it's thing
d920 1
a920 15
  while (InterlockedDecrement (&ExitingWait) == 0 && spins)
    {
      InterlockedIncrement (&ExitingWait);
      /* give up the cpu to force a context switch. */
      low_priority_sleep (0);
      if (spins == 5)
	/* we've had 5 timeslices, and the woken thread still hasn't done it's
	 * thing - maybe we raced it with the event? */
	PulseEvent (win32_obj_id);
      spins--;
    }
  if (waiting + 1 != temp)
    system_printf ("Released too many threads - %d now %d originally", waiting, temp);
  if (pthread_mutex_unlock (&cond_access))
    system_printf ("Failed to unlock condition variable access mutex, this %p", this);
d924 1
a924 1
pthread_cond::TimedWait (DWORD dwMilliseconds)
d928 15
a942 2
  // FIXME: race condition (potentially drop events
  // Possible solution (single process only) - place this in a critical section.
a943 6
  rv = WaitForSingleObject (win32_obj_id, dwMilliseconds);
#if 0
  /* we need to use native win32 mutex's here, because the cygwin ones now use
   * critical sections, which are faster, but introduce a race _here_. Until then
   * The NT variant of the code is redundant.
   */
d945 39
a983 15
  rv = SignalObjectAndWait (mutex->win32_obj_id, win32_obj_id, dwMilliseconds,
			    false);
#endif
  switch (rv)
    {
    case WAIT_FAILED:
      return 0;			/* POSIX doesn't allow errors after we modify the mutex state */
    case WAIT_ABANDONED:
    case WAIT_TIMEOUT:
      return ETIMEDOUT;
    case WAIT_OBJECT_0:
      return 0;			/* we have been signaled */
    default:
      return 0;
    }
d989 10
a998 14
  debug_printf ("cond %x in fixup_after_fork", this);
  if (shared != PTHREAD_PROCESS_PRIVATE)
    api_fatal ("doesn't understand PROCESS_SHARED condition variables");
  /* FIXME: duplicate code here and in the constructor. */
  this->win32_obj_id = ::CreateEvent (&sec_none_nih, false, false, NULL);
  if (!win32_obj_id)
    api_fatal ("failed to create new win32 mutex");
#if DETECT_BAD_APPS
  if (waiting)
    api_fatal ("Forked () while a condition variable has waiting threads.\nReport to cygwin@@cygwin.com");
#else
  waiting = 0;
  mutex = NULL;
#endif
a1341 4
#if DETECT_BAD_APPS
  if (condwaits)
    api_fatal ("Forked () while a mutex has condition variables waiting on it.\nReport to cygwin@@cygwin.com");
#else
a1342 1
#endif
d2180 1
a2180 1
    pthread_cond::init (cond, NULL);
d2184 1
a2184 1
  (*cond)->BroadCast ();
d2193 1
a2193 1
    pthread_cond::init (cond, NULL);
d2197 1
a2197 1
  (*cond)->Signal ();
d2202 1
a2202 1
int
d2204 1
a2204 1
		       long waitlength)
d2206 5
a2210 7
// and yes cond_access here is still open to a race. (we increment, context swap,
// broadcast occurs -  we miss the broadcast. the functions aren't split properly.
  int rv;
  pthread_mutex **themutex = NULL;
  if (pthread_mutex::isGoodInitializer (mutex))
    pthread_mutex::init (mutex, NULL);
  themutex = mutex;
a2212 3

  if (!pthread_mutex::isGoodObject (themutex))
    return EINVAL;
d2216 1
a2216 36
  /* if the cond variable is blocked, then the above timer test maybe wrong. *shrug**/
  if (pthread_mutex_lock (&(*cond)->cond_access))
    system_printf ("Failed to lock condition variable access mutex, this %p", *cond);

  if ((*cond)->waiting)
    if ((*cond)->mutex && ((*cond)->mutex != (*themutex)))
      {
	if (pthread_mutex_unlock (&(*cond)->cond_access))
	  system_printf ("Failed to unlock condition variable access mutex, this %p", *cond);
	return EINVAL;
      }
  InterlockedIncrement (&((*cond)->waiting));

  (*cond)->mutex = (*themutex);
  InterlockedIncrement (&((*themutex)->condwaits));
  if (pthread_mutex_unlock (&(*cond)->cond_access))
    system_printf ("Failed to unlock condition variable access mutex, this %p", *cond);
  /* At this point calls to Signal will progress evebn if we aren' yet waiting
     However, the loop there should allow us to get scheduled and call wait,
     and have them call PulseEvent again if we dont' respond.  */
  rv = (*cond)->TimedWait (waitlength);
  /* this may allow a race on the mutex acquisition and waits.
     But doing this within the cond access mutex creates a different race */
  InterlockedDecrement (&((*cond)->waiting));
  /* Tell Signal that we have been released */
  InterlockedDecrement (&((*cond)->ExitingWait));
  (*themutex)->Lock ();
  if (pthread_mutex_lock (&(*cond)->cond_access))
    system_printf ("Failed to lock condition variable access mutex, this %p", *cond);
  if ((*cond)->waiting == 0)
    (*cond)->mutex = NULL;
  InterlockedDecrement (&((*themutex)->condwaits));
  if (pthread_mutex_unlock (&(*cond)->cond_access))
    system_printf ("Failed to unlock condition variable access mutex, this %p", *cond);

  return rv;
d2223 5
d2230 4
a2233 4
  struct timeb currSysTime;
  long waitlength;
  ftime (&currSysTime);
  waitlength = (abstime->tv_sec - currSysTime.time) * 1000;
d2242 2
@


1.115
log
@
* thread.cc (MTinterface::fixup_after_fork): Initialize mainthread
prior to pthread objects.
@
text
@a34 1
#include <errno.h>
d330 2
d1161 13
d1189 1
a1189 1
  lock_counter (MUTEX_LOCK_COUNTER_INITIAL),
d1238 1
a1238 1
pthread_mutex::Lock ()
a1240 1
  pthread_t self = pthread::self ();
d1242 3
a1244 3
  if (0 == InterlockedIncrement (&lock_counter))
    SetOwner ();
  else if (__pthread_equal (&owner, &self))
d1246 1
a1246 1
      InterlockedDecrement (&lock_counter);
d1255 1
a1255 1
      SetOwner ();
a1260 1
/* returns non-zero on failure */
d1262 1
a1262 1
pthread_mutex::TryLock ()
a1264 1
  pthread_t self = pthread::self ();
d1266 3
a1268 4
  if (MUTEX_LOCK_COUNTER_INITIAL ==
      InterlockedCompareExchange (&lock_counter, 0, MUTEX_LOCK_COUNTER_INITIAL ))
    SetOwner ();
  else if (__pthread_equal (&owner, &self) && PTHREAD_MUTEX_RECURSIVE == type)
d1277 1
a1277 1
pthread_mutex::UnLock ()
a1278 2
  pthread_t self = pthread::self ();

d1285 1
a1285 1
      if (MUTEX_LOCK_COUNTER_INITIAL != InterlockedDecrement (&lock_counter))
d1294 1
a1294 1
pthread_mutex::Destroy ()
d1296 1
a1296 1
  if (condwaits || TryLock ())
a1310 16
pthread_mutex::SetOwner ()
{
  recursion_counter = 1;
  owner = pthread::self ();
}

int
pthread_mutex::LockRecursive ()
{
  if (UINT_MAX == recursion_counter)
    return EAGAIN;
  ++recursion_counter;
  return 0;
}

void
d1319 2
a1320 2
    lock_counter = MUTEX_LOCK_COUNTER_INITIAL;
  else if (lock_counter != MUTEX_LOCK_COUNTER_INITIAL)
d1322 1
a1322 1
    lock_counter = 0;
d2610 1
@


1.114
log
@spacing cleanup
@
text
@d216 4
a240 4

  pthread::initMainThread (true);

  threadcount = 1;
@


1.114.2.1
log
@merge from trunk
@
text
@a215 4

  threadcount = 1;
  pthread::initMainThread (true);

d237 4
@


1.114.2.2
log
@merge from trunk
@
text
@d35 1
a202 1
  pthread_rwlock::initMutex ();
a233 7
  pthread_rwlock *rwlock = rwlocks;
  debug_printf ("rwlocks is %x",rwlocks);
  while (rwlock)
    {
      rwlock->fixup_after_fork ();
      rwlock = rwlock->next;
    }
a330 2
  /* Change the mutex type to NORMAL to speed up mutex operations */
  mutex.type = PTHREAD_MUTEX_NORMAL;
d391 1
a391 1
  if (pthread_equal (joiner, thread))
d422 1
a422 1
  else if (pthread_equal (thread, self))
d464 2
a465 2
*pthread_cond_timedwait ()
*pthread_cond_wait ()
d814 1
a814 4
pthread_cond::pthread_cond (pthread_condattr *attr) :
  verifyable_object (PTHREAD_COND_MAGIC),
  shared (0), waiting (0), pending (0), semWait (NULL),
  mtxCond(NULL), next (NULL)
d816 11
a826 11
  pthread_mutex *verifyable_mutex_obj;

  if (attr)
    if (attr->shared != PTHREAD_PROCESS_PRIVATE)
      {
        magic = 0;
        return;
      }

  verifyable_mutex_obj = &mtxIn;
  if (!pthread_mutex::isGoodObject (&verifyable_mutex_obj))
d828 2
a829 1
      thread_printf ("Internal cond mutex is not valid. this %p", this);
a830 21
      return;
    }
  /* Change the mutex type to NORMAL to speed up mutex operations */
  mtxIn.type = PTHREAD_MUTEX_NORMAL;

  verifyable_mutex_obj = &mtxOut;
  if (!pthread_mutex::isGoodObject (&verifyable_mutex_obj))
    {
      thread_printf ("Internal cond mutex is not valid. this %p", this);
      magic = 0;
      return;
    }
  /* Change the mutex type to NORMAL to speed up mutex operations */
  mtxOut.type = PTHREAD_MUTEX_NORMAL;

  semWait = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
  if (!semWait)
    {
      debug_printf ("CreateSemaphore failed. %E");
      magic = 0;
      return;
d833 2
d841 3
a843 3
  if (semWait)
    CloseHandle (semWait);

d858 1
a858 1
pthread_cond::UnBlock (const bool all)
d860 13
a872 33
  unsigned long releaseable;

  /* 
   * Block outgoing threads (and avoid simultanous unblocks)
   */
  mtxOut.Lock ();

  releaseable = waiting - pending;
  if (releaseable)
    {
      unsigned long released;

      if (!pending)
        {
          /* 
           * Block incoming threads until all waiting threads are released.
           */
          mtxIn.Lock ();

          /* 
           * Calculate releaseable again because threads can enter until
           * the semaphore has been taken, but they can not leave, therefore pending
           * is unchanged and releaseable can only get higher
           */
          releaseable = waiting - pending;
        }

      released = all ? releaseable : 1;
      pending += released;
      /*
       * Signal threads
       */
      ::ReleaseSemaphore (semWait, released, NULL);
d874 4
a877 68

  /*
   * And let the threads release.
   */
  mtxOut.UnLock ();
}

int
pthread_cond::Wait (pthread_mutex_t mutex, DWORD dwMilliseconds)
{
  DWORD rv;

  mtxIn.Lock ();
  if (1 == InterlockedIncrement ((long *)&waiting))
    mtxCond = mutex;
  else if (mtxCond != mutex)
    {
      InterlockedDecrement ((long *)&waiting);
      mtxIn.UnLock ();
      return EINVAL;
    }
  mtxIn.UnLock ();

  /*
   * Release the mutex and wait on semaphore
   */
  ++mutex->condwaits;
  mutex->UnLock ();

  rv = pthread::cancelable_wait (semWait, dwMilliseconds, false);

  mtxOut.Lock ();
  
  if (rv != WAIT_OBJECT_0)
    {
      /*
       * It might happen that a signal is sent while the thread got canceled
       * or timed out. Try to take one.
       * If the thread gets one than a signal|broadcast is in progress.
       */ 
      if (WAIT_OBJECT_0 == WaitForSingleObject (semWait, 0))
        /*
         * thread got cancelled ot timed out while a signalling is in progress.
         * Set wait result back to signaled
         */
        rv = WAIT_OBJECT_0;
    }

  InterlockedDecrement ((long *)&waiting);

  if (rv == WAIT_OBJECT_0 && 0 == --pending)
    /*
     * All signaled threads are released,
     * new threads can enter Wait
     */
    mtxIn.UnLock ();

  mtxOut.UnLock ();
 
  mutex->Lock ();
  --mutex->condwaits;

  if (rv == WAIT_CANCELED)
    pthread::static_cancel_self ();
  else if (rv == WAIT_TIMEOUT)
    return ETIMEDOUT;

  return 0;
d881 1
a881 1
pthread_cond::fixup_after_fork ()
d883 3
a885 59
  waiting = pending = 0;
  mtxCond = NULL;

  /* Unlock eventually locked mutexes */
  mtxIn.UnLock ();
  mtxOut.UnLock ();

  semWait = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
  if (!semWait)
    api_fatal ("pthread_cond::fixup_after_fork () failed to recreate win32 semaphore");
}

bool
pthread_rwlockattr::isGoodObject (pthread_rwlockattr_t const *attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_RWLOCKATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

pthread_rwlockattr::pthread_rwlockattr ():verifyable_object
  (PTHREAD_RWLOCKATTR_MAGIC), shared (PTHREAD_PROCESS_PRIVATE)
{
}

pthread_rwlockattr::~pthread_rwlockattr ()
{
}

/* This is used for rwlock creation protection within a single process only */
nativeMutex NO_COPY pthread_rwlock::rwlockInitializationLock;

/* We can only be called once.
   TODO: (no rush) use a non copied memory section to
   hold an initialization flag.  */
void
pthread_rwlock::initMutex ()
{
  if (!rwlockInitializationLock.init ())
    api_fatal ("Could not create win32 Mutex for pthread rwlock static initializer support.");
}

pthread_rwlock::pthread_rwlock (pthread_rwlockattr *attr) :
  verifyable_object (PTHREAD_RWLOCK_MAGIC),
  shared (0), waitingReaders (0), waitingWriters (0), writer (NULL),
  readers (NULL), mtx (NULL), condReaders (NULL), condWriters (NULL),
  next (NULL)
{
  pthread_mutex *verifyable_mutex_obj = &mtx;
  pthread_cond *verifyable_cond_obj;

  if (attr)
    if (attr->shared != PTHREAD_PROCESS_PRIVATE)
      {
        magic = 0;
        return;
      }

  if (!pthread_mutex::isGoodObject (&verifyable_mutex_obj))
d887 3
a889 2
      thread_printf ("Internal rwlock mutex is not valid. this %p", this);
      magic = 0;
d892 3
a894 5
  /* Change the mutex type to NORMAL to speed up mutex operations */
  mtx.type = PTHREAD_MUTEX_NORMAL;

  verifyable_cond_obj = &condReaders;
  if (!pthread_cond::isGoodObject (&verifyable_cond_obj))
d896 2
a897 2
      thread_printf ("Internal rwlock readers cond is not valid. this %p", this);
      magic = 0;
d900 19
a918 3

  verifyable_cond_obj = &condWriters;
  if (!pthread_cond::isGoodObject (&verifyable_cond_obj))
d920 8
a927 22
      thread_printf ("Internal rwlock writers cond is not valid. this %p", this);
      magic = 0;
      return;
    }


  /* threadsafe addition is easy */
  next = (pthread_rwlock *) InterlockedExchangePointer (&MT_INTERFACE->rwlocks, this);
}

pthread_rwlock::~pthread_rwlock ()
{
  /* I'm not 100% sure the next bit is threadsafe. I think it is... */
  if (MT_INTERFACE->rwlocks == this)
    InterlockedExchangePointer (&MT_INTERFACE->rwlocks, this->next);
  else
    {
      pthread_rwlock *temprwlock = MT_INTERFACE->rwlocks;
      while (temprwlock->next && temprwlock->next != this)
	temprwlock = temprwlock->next;
      /* but there may be a race between the loop above and this statement */
      InterlockedExchangePointer (&temprwlock->next, this->next);
d929 4
d936 1
a936 1
pthread_rwlock::RdLock ()
d938 1
a938 3
  int result = 0;
  struct RWLOCK_READER *reader;
  pthread_t self = pthread::self ();
d940 9
a948 1
  mtx.Lock ();
d950 4
a953 1
  if (lookupReader (self))
d955 9
a963 2
      result = EDEADLK;
      goto DONE;
a964 150

  reader = new struct RWLOCK_READER;
  if (!reader)
    {
      result = EAGAIN;
      goto DONE;
    }

  while (writer || waitingWriters)
    {  
      pthread_cleanup_push (pthread_rwlock::RdLockCleanup, this);

      ++waitingReaders;
      condReaders.Wait (&mtx);
      --waitingReaders;

      pthread_cleanup_pop (0);
    }

  reader->thread = self;
  addReader (reader);

 DONE:
  mtx.UnLock ();

  return result;
}

int
pthread_rwlock::TryRdLock ()
{
  int result = 0;
  pthread_t self = pthread::self ();

  mtx.Lock ();

  if (writer || waitingWriters || lookupReader (self))
    result = EBUSY;
  else
    {
      struct RWLOCK_READER *reader = new struct RWLOCK_READER;
      if (reader)
        {
          reader->thread = self;
          addReader (reader);
        }
      else
        result = EAGAIN;
    }
    
  mtx.UnLock ();

  return result;
}

int
pthread_rwlock::WrLock ()
{
  int result = 0;
  pthread_t self = pthread::self ();

  mtx.Lock ();

  if (writer == self || lookupReader (self))
    {
      result = EDEADLK;
      goto DONE;
    }

  while (writer || readers)
    {  
      pthread_cleanup_push (pthread_rwlock::WrLockCleanup, this);

      ++waitingWriters;
      condWriters.Wait (&mtx);
      --waitingWriters;

      pthread_cleanup_pop (0);
    }

  writer = self;

 DONE:
  mtx.UnLock ();

  return result;
}

int
pthread_rwlock::TryWrLock ()
{
  int result = 0;
  pthread_t self = pthread::self ();

  mtx.Lock ();

  if (writer || readers)
    result = EBUSY;
  else
    writer = self;
    
  mtx.UnLock ();

  return result;
}

int
pthread_rwlock::UnLock ()
{
  int result = 0;
  pthread_t self = pthread::self ();

  mtx.Lock ();

  if (writer)
    {
      if (writer != self)
        {
          result = EPERM;
          goto DONE;
        }

      writer = NULL;
    }
  else
    {
      struct RWLOCK_READER *reader = lookupReader (self);

      if (!reader)
        {
          result = EPERM;
          goto DONE;
        }

      removeReader (reader);
      delete reader;
    }

  if (waitingWriters)
    {
      if (!readers)
        condWriters.UnBlock (false);
    }
  else if (waitingReaders)
    condReaders.UnBlock (true);

 DONE:
  mtx.UnLock ();

  return result;
d968 1
a968 1
pthread_rwlock::addReader (struct RWLOCK_READER *rd)
d970 14
a983 73
  rd->next = (struct RWLOCK_READER *)
    InterlockedExchangePointer (&readers, rd);
}

void
pthread_rwlock::removeReader (struct RWLOCK_READER *rd)
{
  if (readers == rd)
    InterlockedExchangePointer (&readers, rd->next);
  else
    {
      struct RWLOCK_READER *temp = readers;
      while (temp->next && temp->next != rd)
	temp = temp->next;
      /* but there may be a race between the loop above and this statement */
      InterlockedExchangePointer (&temp->next, rd->next);
    }
}

struct pthread_rwlock::RWLOCK_READER *
pthread_rwlock::lookupReader (pthread_t thread)
{
  struct RWLOCK_READER *temp = readers;

  while (temp && temp->thread != thread)
    temp = temp->next;

  return temp;
}

void
pthread_rwlock::RdLockCleanup (void *arg)
{
  pthread_rwlock *rwlock = (pthread_rwlock *) arg;

  --(rwlock->waitingReaders);
  rwlock->mtx.UnLock ();
}

void
pthread_rwlock::WrLockCleanup (void *arg)
{
  pthread_rwlock *rwlock = (pthread_rwlock *) arg;

  --(rwlock->waitingWriters);
  rwlock->mtx.UnLock ();
}

void
pthread_rwlock::fixup_after_fork ()
{
  pthread_t self = pthread::self ();
  struct RWLOCK_READER **temp = &readers;

  waitingReaders = 0;
  waitingWriters = 0;

  /* Unlock eventually locked mutex */
  mtx.UnLock ();
  /*
   * Remove all readers except self
   */
  while (*temp)
    {
      if ((*temp)->thread == self)
        temp = &((*temp)->next);
      else
        {
          struct RWLOCK_READER *cur = *temp;
          *temp = (*temp)->next;
          delete cur;
        }
    }
a1159 13
bool
pthread_mutex::canBeUnlocked (pthread_mutex_t const *mutex)
{
  pthread_t self = pthread::self ();

  if (!isGoodObject (mutex))
    return false;
  /*
   * Check if the mutex is owned by the current thread and can be unlocked
   */
  return (pthread_equal ((*mutex)->owner, self)) && 1 == (*mutex)->recursion_counter;
}

d1175 1
a1175 1
  lock_counter (0),
d1224 1
a1224 1
pthread_mutex::_Lock (pthread_t self)
d1227 1
d1229 3
a1231 3
  if (1 == InterlockedIncrement ((long *)&lock_counter))
    SetOwner (self);
  else if (PTHREAD_MUTEX_NORMAL != type && pthread_equal (owner, self))
d1233 1
a1233 1
      InterlockedDecrement ((long *) &lock_counter);
d1242 1
a1242 1
      SetOwner (self);
d1248 1
d1250 1
a1250 1
pthread_mutex::_TryLock (pthread_t self)
d1253 1
d1255 4
a1258 3
  if (0 == InterlockedCompareExchange ((long *)&lock_counter, 1, 0 ))
    SetOwner (self);
  else if (PTHREAD_MUTEX_RECURSIVE == type && pthread_equal (owner, self))
d1267 1
a1267 1
pthread_mutex::_UnLock (pthread_t self)
d1269 3
a1271 1
  if (!pthread_equal (owner, self))
d1277 1
a1277 1
      if (InterlockedDecrement ((long *)&lock_counter))
d1286 1
a1286 1
pthread_mutex::_Destroy (pthread_t self)
d1288 1
a1288 1
  if (condwaits || _TryLock (self))
d1303 16
d1327 3
a1330 3
  else if (lock_counter != 0)
    /* All waiting threads are gone after a fork */
    lock_counter = 1;
d1336 4
d1341 1
d1722 2
a1723 2
extern "C" int
pthread_attr_init (pthread_attr_t *attr)
d1737 2
a1738 2
extern "C" int
pthread_attr_getinheritsched (const pthread_attr_t *attr,
d1747 2
a1748 2
extern "C" int
pthread_attr_getschedparam (const pthread_attr_t *attr,
d1760 2
a1761 2
extern "C" int
pthread_attr_getschedpolicy (const pthread_attr_t *attr, int *policy)
d1770 2
a1771 2
extern "C" int
pthread_attr_getscope (const pthread_attr_t *attr, int *contentionscope)
d1779 2
a1780 2
extern "C" int
pthread_attr_setdetachstate (pthread_attr_t *attr, int detachstate)
d1790 2
a1791 2
extern "C" int
pthread_attr_getdetachstate (const pthread_attr_t *attr, int *detachstate)
d1799 2
a1800 2
extern "C" int
pthread_attr_setinheritsched (pthread_attr_t *attr, int inheritsched)
d1811 2
a1812 2
extern "C" int
pthread_attr_setschedparam (pthread_attr_t *attr,
d1824 2
a1825 2
extern "C" int
pthread_attr_setschedpolicy (pthread_attr_t *attr, int policy)
d1834 2
a1835 2
extern "C" int
pthread_attr_setscope (pthread_attr_t *attr, int contentionscope)
d1850 2
a1851 2
extern "C" int
pthread_attr_setstacksize (pthread_attr_t *attr, size_t size)
d1859 2
a1860 2
extern "C" int
pthread_attr_getstacksize (const pthread_attr_t *attr, size_t *size)
d1868 2
a1869 2
extern "C" int
pthread_attr_destroy (pthread_attr_t *attr)
d1895 1
a1895 1
  if (pthread_equal (*thread,joiner))
d1997 2
a1998 2
extern "C" int
pthread_getconcurrency (void)
d2004 2
a2005 2
extern "C" int
pthread_getschedparam (pthread_t thread, int *policy,
d2018 2
a2019 2
extern "C" int
pthread_key_create (pthread_key_t *key, void (*destructor) (void *))
d2037 2
a2038 2
extern "C" int
pthread_key_delete (pthread_key_t key)
d2050 2
a2051 2
extern "C" int
pthread_setconcurrency (int new_level)
d2060 2
a2061 2
extern "C" int
pthread_setschedparam (pthread_t thread, int policy,
d2078 2
a2079 2
extern "C" int
pthread_setspecific (pthread_key_t key, const void *value)
d2087 2
a2088 2
extern "C" void *
pthread_getspecific (pthread_key_t key)
d2131 2
a2132 2
extern "C" int
pthread_cond_destroy (pthread_cond_t *cond)
d2175 2
a2176 2
extern "C" int
pthread_cond_broadcast (pthread_cond_t *cond)
d2179 1
a2179 1
    return 0;
d2183 1
a2183 1
  (*cond)->UnBlock (true);
d2188 2
a2189 2
extern "C" int
pthread_cond_signal (pthread_cond_t *cond)
d2192 1
a2192 1
    return 0;
d2196 1
a2196 1
  (*cond)->UnBlock (false);
d2201 1
a2201 1
static int
d2203 1
a2203 1
		       DWORD waitlength)
d2205 7
a2211 5
  if (!pthread_mutex::isGoodObject (mutex))
    return EINVAL;
  if (!pthread_mutex::canBeUnlocked (mutex))
    return EPERM;

d2214 3
d2220 36
a2255 1
  return (*cond)->Wait (*mutex, waitlength);
a2261 5
  struct timeval tv;
  long waitlength;

  pthread_testcancel ();

d2264 4
a2267 4

  gettimeofday (&tv, NULL);
  waitlength = abstime->tv_sec * 1000 + abstime->tv_nsec / (1000 * 1000);
  waitlength -= tv.tv_sec * 1000 + tv.tv_usec / 1000;
a2275 2
  pthread_testcancel ();

d2279 2
a2280 2
extern "C" int
pthread_condattr_init (pthread_condattr_t *condattr)
d2294 2
a2295 2
extern "C" int
pthread_condattr_getpshared (const pthread_condattr_t *attr, int *pshared)
d2303 2
a2304 2
extern "C" int
pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared)
d2317 2
a2318 2
extern "C" int
pthread_condattr_destroy (pthread_condattr_t *condattr)
d2327 1
a2327 52
/* RW locks */
bool
pthread_rwlock::isGoodObject (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

bool
pthread_rwlock::isGoodInitializer (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC, PTHREAD_RWLOCK_INITIALIZER) != VALID_STATIC_OBJECT)
    return false;
  return true;
}

bool
pthread_rwlock::isGoodInitializerOrObject (pthread_rwlock_t const *rwlock)
{
  if (verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC, PTHREAD_RWLOCK_INITIALIZER) == INVALID_OBJECT)
    return false;
  return true;
}

bool
pthread_rwlock::isGoodInitializerOrBadObject (pthread_rwlock_t const *rwlock)
{
  verifyable_object_state objectState = verifyable_object_isvalid (rwlock, PTHREAD_RWLOCK_MAGIC, PTHREAD_RWLOCK_INITIALIZER);
  if (objectState == VALID_OBJECT)
	return false;
  return true;
}

extern "C" int
pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
{
  if (pthread_rwlock::isGoodInitializer (rwlock))
    return 0;
  if (!pthread_rwlock::isGoodObject (rwlock))
    return EINVAL;

  if ((*rwlock)->writer || (*rwlock)->readers ||
      (*rwlock)->waitingReaders || (*rwlock)->waitingWriters)
    return EBUSY;

  delete (*rwlock);
  *rwlock = NULL;

  return 0;
}

d2329 1
a2329 135
pthread_rwlock::init (pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr)
{
  if (attr && !pthread_rwlockattr::isGoodObject (attr))
    return EINVAL;
  if (!rwlockInitializationLock.lock ())
    return EINVAL;

  if (!isGoodInitializerOrBadObject (rwlock))
    {
      rwlockInitializationLock.unlock ();
      return EBUSY;
    }

  *rwlock = new pthread_rwlock (attr ? (*attr) : NULL);
  if (!isGoodObject (rwlock))
    {
      delete (*rwlock);
      *rwlock = NULL;
      rwlockInitializationLock.unlock ();
      return EAGAIN;
    }
  rwlockInitializationLock.unlock ();
  return 0;
}

extern "C" int
pthread_rwlock_rdlock (pthread_rwlock_t *rwlock)
{
  pthread_testcancel ();

  if (pthread_rwlock::isGoodInitializer (rwlock))
    pthread_rwlock::init (rwlock, NULL);
  if (!pthread_rwlock::isGoodObject (rwlock))
    return EINVAL;

  return (*rwlock)->RdLock ();
}

extern "C" int
pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock)
{
  if (pthread_rwlock::isGoodInitializer (rwlock))
    pthread_rwlock::init (rwlock, NULL);
  if (!pthread_rwlock::isGoodObject (rwlock))
    return EINVAL;

  return (*rwlock)->TryRdLock ();
}

extern "C" int
pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
{
  pthread_testcancel ();

  if (pthread_rwlock::isGoodInitializer (rwlock))
    pthread_rwlock::init (rwlock, NULL);
  if (!pthread_rwlock::isGoodObject (rwlock))
    return EINVAL;

  return (*rwlock)->WrLock ();
}

extern "C" int
pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock)
{
  if (pthread_rwlock::isGoodInitializer (rwlock))
    pthread_rwlock::init (rwlock, NULL);
  if (!pthread_rwlock::isGoodObject (rwlock))
    return EINVAL;

  return (*rwlock)->TryWrLock ();
}

extern "C" int
pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
{
  if (pthread_rwlock::isGoodInitializer (rwlock))
    return 0;
  if (!pthread_rwlock::isGoodObject (rwlock))
    return EINVAL;

  return (*rwlock)->UnLock ();
}

extern "C" int
pthread_rwlockattr_init (pthread_rwlockattr_t *rwlockattr)
{
  if (check_valid_pointer (rwlockattr))
    return EINVAL;
  *rwlockattr = new pthread_rwlockattr;
  if (!pthread_rwlockattr::isGoodObject (rwlockattr))
    {
      delete (*rwlockattr);
      *rwlockattr = NULL;
      return EAGAIN;
    }
  return 0;
}

extern "C" int
pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr, int *pshared)
{
  if (!pthread_rwlockattr::isGoodObject (attr))
    return EINVAL;
  *pshared = (*attr)->shared;
  return 0;
}

extern "C" int
pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared)
{
  if (!pthread_rwlockattr::isGoodObject (attr))
    return EINVAL;
  if ((pshared < 0) || (pshared > 1))
    return EINVAL;
  /* shared rwlock vars not currently supported */
  if (pshared != PTHREAD_PROCESS_PRIVATE)
    return EINVAL;
  (*attr)->shared = pshared;
  return 0;
}

extern "C" int
pthread_rwlockattr_destroy (pthread_rwlockattr_t *rwlockattr)
{
  if (!pthread_rwlockattr::isGoodObject (rwlockattr))
    return EINVAL;
  delete (*rwlockattr);
  *rwlockattr = NULL;
  return 0;
}

/* Thread signal */
extern "C" int
pthread_kill (pthread_t thread, int sig)
d2346 2
a2347 2
extern "C" int
pthread_sigmask (int operation, const sigset_t *set, sigset_t *old_set)
d2367 1
a2367 1
pthread_equal (pthread_t t1, pthread_t t2)
d2369 1
a2369 1
  return t1 == t2;
d2409 2
a2410 2
extern "C" int
pthread_mutex_getprioceiling (const pthread_mutex_t *mutex,
d2429 1
a2429 1
pthread_mutex_lock (pthread_mutex_t *mutex)
d2456 2
a2457 2
extern "C" int
pthread_mutex_trylock (pthread_mutex_t *mutex)
d2467 2
a2468 2
extern "C" int
pthread_mutex_unlock (pthread_mutex_t *mutex)
d2477 2
a2478 2
extern "C" int
pthread_mutex_destroy (pthread_mutex_t *mutex)
d2495 2
a2496 2
extern "C" int
pthread_mutex_setprioceiling (pthread_mutex_t *mutex, int prioceiling,
d2509 2
a2510 2
extern "C" int
pthread_mutexattr_getprotocol (const pthread_mutexattr_t *attr,
d2518 2
a2519 2
extern "C" int
pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr,
d2528 2
a2529 2
extern "C" int
pthread_mutexattr_gettype (const pthread_mutexattr_t *attr, int *type)
d2538 2
a2539 2
extern "C" int
pthread_mutexattr_init (pthread_mutexattr_t *attr)
d2554 2
a2555 2
extern "C" int
pthread_mutexattr_destroy (pthread_mutexattr_t *attr)
d2566 2
a2567 2
extern "C" int
pthread_mutexattr_setprotocol (pthread_mutexattr_t *attr, int protocol)
d2575 2
a2576 2
extern "C" int
pthread_mutexattr_setprioceiling (pthread_mutexattr_t *attr,
d2584 2
a2585 2
extern "C" int
pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *attr,
d2593 2
a2594 2
extern "C" int
pthread_mutexattr_setpshared (pthread_mutexattr_t *attr, int pshared)
d2607 3
a2609 3
/* see pthread_mutex_gettype */
extern "C" int
pthread_mutexattr_settype (pthread_mutexattr_t *attr, int type)
a2617 1
    case PTHREAD_MUTEX_NORMAL:
@


1.114.2.3
log
@merge from trunk
@
text
@d75 1
a75 1
native_mutex::init ()
d87 1
a87 1
native_mutex::lock ()
d99 1
a99 1
native_mutex::unlock ()
d200 3
a202 3
  pthread_mutex::init_mutex ();
  pthread_cond::init_mutex ();
  pthread_rwlock::init_mutex ();
d218 1
a218 1
  pthread::init_mainthread (true);
d220 28
a247 4
  pthread_mutex::fixup_after_fork ();
  pthread_cond::fixup_after_fork ();
  pthread_rwlock::fixup_after_fork ();
  semaphore::fixup_after_fork ();
d254 1
a254 1
pthread::init_mainthread (bool do_init)
d259 1
a259 1
  pthread *thread = get_tls_self_pointer ();
d267 1
a267 1
  thread->init_current_thread ();
d273 1
a273 1
  pthread *thread = get_tls_self_pointer ();
d276 1
a276 1
  return pthread_null::get_null_pthread ();
d280 1
a280 1
pthread::set_tls_self_pointer (pthread *thisThread)
d286 1
a286 1
pthread::get_tls_self_pointer ()
d309 1
a309 1
pthread::set_thread_id_to_current ()
d331 1
a331 1
  if (!pthread_mutex::is_good_object (&verifyable_mutex_obj))
d396 1
a396 1
  pthread_key::run_all_destructors ();
d398 1
a398 1
  mutex.lock ();
d405 1
a405 1
      mutex.unlock ();
d420 1
a420 1
  mutex.lock ();
d426 1
a426 1
      mutex.unlock ();
d433 1
a433 1
      mutex.unlock ();
d448 1
a448 1
  mutex.unlock ();
d633 1
a633 1
  if (WaitForSingleObject (cancel_event, 0) == WAIT_OBJECT_0)
d651 1
a651 1
  if (!is_good_object (&thread) || thread->cancelstate == PTHREAD_CANCEL_DISABLE)
d672 1
a672 1
  mutex.lock ();
d683 1
a683 1
  mutex.unlock ();
d693 1
a693 1
  mutex.lock ();
d704 1
a704 1
  mutex.unlock ();
d726 1
a726 1
  mutex.lock ();
d737 1
a737 1
  mutex.unlock ();
d754 1
a754 1
pthread::get_thread_id ()
d760 1
a760 1
pthread::init_current_thread ()
d767 2
a768 2
  set_thread_id_to_current ();
  set_tls_self_pointer (this);
d773 1
a773 1
pthread_attr::is_good_object (pthread_attr_t const *attr)
d794 1
a794 1
pthread_condattr::is_good_object (pthread_condattr_t const *attr)
a809 2
List<pthread_cond> pthread_cond::conds;

d811 1
a811 1
native_mutex NO_COPY pthread_cond::cond_initialization_lock;
d817 1
a817 1
pthread_cond::init_mutex ()
d819 1
a819 1
  if (!cond_initialization_lock.init ())
d825 2
a826 2
  shared (0), waiting (0), pending (0), sem_wait (NULL),
  mtx_cond(NULL), next (NULL)
d837 2
a838 2
  verifyable_mutex_obj = &mtx_in;
  if (!pthread_mutex::is_good_object (&verifyable_mutex_obj))
d844 2
a845 5
  /*
   * Change the mutex type to NORMAL.
   * This mutex MUST be of type normal
  */
  mtx_in.type = PTHREAD_MUTEX_NORMAL;
d847 2
a848 2
  verifyable_mutex_obj = &mtx_out;
  if (!pthread_mutex::is_good_object (&verifyable_mutex_obj))
d855 1
a855 1
  mtx_out.type = PTHREAD_MUTEX_NORMAL;
d857 2
a858 2
  sem_wait = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
  if (!sem_wait)
d865 2
a866 1
  conds.insert (this);
d871 2
a872 2
  if (sem_wait)
    CloseHandle (sem_wait);
d874 11
a884 1
  conds.remove (this);
d888 1
a888 1
pthread_cond::unblock (const bool all)
d895 1
a895 1
  mtx_out.lock ();
d907 1
a907 1
          mtx_in.lock ();
d922 1
a922 1
      ::ReleaseSemaphore (sem_wait, released, NULL);
d928 1
a928 1
  mtx_out.unlock ();
d932 1
a932 1
pthread_cond::wait (pthread_mutex_t mutex, DWORD dwMilliseconds)
d936 4
a939 4
  mtx_in.lock ();
  if (InterlockedIncrement ((long *)&waiting) == 1)
    mtx_cond = mutex;
  else if (mtx_cond != mutex)
d942 1
a942 1
      mtx_in.unlock ();
d945 1
a945 1
  mtx_in.unlock ();
d951 1
a951 1
  mutex->unlock ();
d953 1
a953 1
  rv = pthread::cancelable_wait (sem_wait, dwMilliseconds, false);
d955 1
a955 1
  mtx_out.lock ();
d964 1
a964 1
      if (WaitForSingleObject (sem_wait, 0) == WAIT_OBJECT_0)
d974 1
a974 1
  if (rv == WAIT_OBJECT_0 && --pending == 0)
d979 1
a979 1
    mtx_in.unlock ();
d981 1
a981 1
  mtx_out.unlock ();
d983 1
a983 1
  mutex->lock ();
d995 1
a995 1
pthread_cond::_fixup_after_fork ()
d998 1
a998 1
  mtx_cond = NULL;
d1001 2
a1002 2
  mtx_in.unlock ();
  mtx_out.unlock ();
d1004 3
a1006 3
  sem_wait = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
  if (!sem_wait)
    api_fatal ("pthread_cond::_fixup_after_fork () failed to recreate win32 semaphore");
d1010 1
a1010 1
pthread_rwlockattr::is_good_object (pthread_rwlockattr_t const *attr)
a1025 2
List<pthread_rwlock> pthread_rwlock::rwlocks;

d1027 1
a1027 1
native_mutex NO_COPY pthread_rwlock::rwlock_initialization_lock;
d1033 1
a1033 1
pthread_rwlock::init_mutex ()
d1035 1
a1035 1
  if (!rwlock_initialization_lock.init ())
d1041 2
a1042 2
  shared (0), waiting_readers (0), waiting_writers (0), writer (NULL),
  readers (NULL), mtx (NULL), cond_readers (NULL), cond_writers (NULL),
d1055 1
a1055 1
  if (!pthread_mutex::is_good_object (&verifyable_mutex_obj))
d1064 2
a1065 2
  verifyable_cond_obj = &cond_readers;
  if (!pthread_cond::is_good_object (&verifyable_cond_obj))
d1072 2
a1073 2
  verifyable_cond_obj = &cond_writers;
  if (!pthread_cond::is_good_object (&verifyable_cond_obj))
d1081 2
a1082 1
  rwlocks.insert (this);
d1087 11
a1097 1
  rwlocks.remove (this);
d1101 1
a1101 1
pthread_rwlock::rdlock ()
d1107 1
a1107 1
  mtx.lock ();
d1109 1
a1109 1
  if (lookup_reader (self))
d1122 1
a1122 1
  while (writer || waiting_writers)
d1124 1
a1124 1
      pthread_cleanup_push (pthread_rwlock::rdlock_cleanup, this);
d1126 3
a1128 3
      ++waiting_readers;
      cond_readers.wait (&mtx);
      --waiting_readers;
d1134 1
a1134 1
  add_reader (reader);
d1137 1
a1137 1
  mtx.unlock ();
d1143 1
a1143 1
pthread_rwlock::tryrdlock ()
d1148 1
a1148 1
  mtx.lock ();
d1150 1
a1150 1
  if (writer || waiting_writers || lookup_reader (self))
d1158 1
a1158 1
          add_reader (reader);
d1164 1
a1164 1
  mtx.unlock ();
d1170 1
a1170 1
pthread_rwlock::wrlock ()
d1175 1
a1175 1
  mtx.lock ();
d1177 1
a1177 1
  if (writer == self || lookup_reader (self))
d1185 1
a1185 1
      pthread_cleanup_push (pthread_rwlock::wrlock_cleanup, this);
d1187 3
a1189 3
      ++waiting_writers;
      cond_writers.wait (&mtx);
      --waiting_writers;
d1197 1
a1197 1
  mtx.unlock ();
d1203 1
a1203 1
pthread_rwlock::trywrlock ()
d1208 1
a1208 1
  mtx.lock ();
d1215 1
a1215 1
  mtx.unlock ();
d1221 1
a1221 1
pthread_rwlock::unlock ()
d1226 1
a1226 1
  mtx.lock ();
d1240 1
a1240 1
      struct RWLOCK_READER *reader = lookup_reader (self);
d1248 1
a1248 1
      remove_reader (reader);
d1252 1
a1252 1
  if (waiting_writers)
d1255 1
a1255 1
        cond_writers.unblock (false);
d1257 2
a1258 2
  else if (waiting_readers)
    cond_readers.unblock (true);
d1261 1
a1261 1
  mtx.unlock ();
d1267 1
a1267 1
pthread_rwlock::add_reader (struct RWLOCK_READER *rd)
d1274 1
a1274 1
pthread_rwlock::remove_reader (struct RWLOCK_READER *rd)
d1289 1
a1289 1
pthread_rwlock::lookup_reader (pthread_t thread)
d1300 1
a1300 1
pthread_rwlock::rdlock_cleanup (void *arg)
d1304 2
a1305 2
  --(rwlock->waiting_readers);
  rwlock->mtx.unlock ();
d1309 1
a1309 1
pthread_rwlock::wrlock_cleanup (void *arg)
d1313 2
a1314 2
  --(rwlock->waiting_writers);
  rwlock->mtx.unlock ();
d1318 1
a1318 1
pthread_rwlock::_fixup_after_fork ()
d1323 2
a1324 2
  waiting_readers = 0;
  waiting_writers = 0;
d1327 1
a1327 1
  mtx.unlock ();
d1349 36
d1386 1
a1386 1
pthread_key::is_good_object (pthread_key_t const *key)
d1397 2
a1398 2
  tls_index = TlsAlloc ();
  if (tls_index == TLS_OUT_OF_INDEXES)
d1401 1
a1401 1
    keys.insert (this);
d1410 2
a1411 2
      keys.remove (this);
      TlsFree (tls_index);
d1419 1
a1419 1
  TlsSetValue (tls_index, (void *) value);
d1426 3
a1428 3
  int saved_error = ::GetLastError ();
  void *result = TlsGetValue (tls_index);
  ::SetLastError (saved_error);
d1433 1
a1433 1
pthread_key::save_key_to_buffer ()
d1439 1
a1439 1
pthread_key::recreate_key_from_buffer ()
d1441 3
a1443 3
  tls_index = TlsAlloc ();
  if (tls_index == TLS_OUT_OF_INDEXES)
    api_fatal ("pthread_key::recreate_key_from_buffer () failed to reallocate Tls storage");
d1486 1
a1486 1
pthread_mutex::is_good_object (pthread_mutex_t const *mutex)
d1494 1
a1494 1
pthread_mutex::is_good_initializer (pthread_mutex_t const *mutex)
d1502 1
a1502 1
pthread_mutex::is_good_initializer_or_object (pthread_mutex_t const *mutex)
d1510 1
a1510 1
pthread_mutex::is_good_initializer_or_bad_object (pthread_mutex_t const *mutex)
d1519 1
a1519 1
pthread_mutex::can_be_unlocked (pthread_mutex_t const *mutex)
d1523 1
a1523 1
  if (!is_good_object (mutex))
d1528 1
a1528 1
  return ((*mutex)->recursion_counter == 1 && pthread_equal ((*mutex)->owner, self));
a1530 2
List<pthread_mutex> pthread_mutex::mutexes;

d1532 1
a1532 1
native_mutex NO_COPY pthread_mutex::mutex_initialization_lock;
d1538 1
a1538 1
pthread_mutex::init_mutex ()
d1540 1
a1540 1
  if (!mutex_initialization_lock.init ())
d1570 2
a1571 1
  mutexes.insert (this);
d1579 13
a1591 1
  mutexes.remove (this);
d1595 1
a1595 1
pthread_mutex::_lock (pthread_t self)
d1599 3
a1601 3
  if (InterlockedIncrement ((long *)&lock_counter) == 1)
    set_owner (self);
  else if (type != PTHREAD_MUTEX_NORMAL && pthread_equal (owner, self))
d1604 2
a1605 2
      if (type == PTHREAD_MUTEX_RECURSIVE)
	result = lock_recursive ();
d1612 1
a1612 1
      set_owner (self);
d1619 1
a1619 1
pthread_mutex::_trylock (pthread_t self)
d1623 4
a1626 4
  if (InterlockedCompareExchange ((long *)&lock_counter, 1, 0 ) == 0)
    set_owner (self);
  else if (type == PTHREAD_MUTEX_RECURSIVE && pthread_equal (owner, self))
    result = lock_recursive ();
d1634 1
a1634 1
pthread_mutex::_unlock (pthread_t self)
d1639 1
a1639 1
  if (--recursion_counter == 0)
d1651 1
a1651 1
pthread_mutex::_destroy (pthread_t self)
d1653 1
a1653 1
  if (condwaits || _trylock (self))
d1668 1
a1668 1
pthread_mutex::_fixup_after_fork ()
d1670 1
a1670 1
  debug_printf ("mutex %x in _fixup_after_fork", this);
d1672 1
a1672 1
    api_fatal ("pthread_mutex::_fixup_after_fork () doesn'tunderstand PROCESS_SHARED mutex's");
d1674 1
a1674 1
  if (owner == NULL)
d1683 1
a1683 1
    api_fatal ("pthread_mutex::_fixup_after_fork () failed to recreate win32 semaphore for mutex");
d1689 1
a1689 1
pthread_mutexattr::is_good_object (pthread_mutexattr_t const * attr)
a1704 2
List<semaphore> semaphore::semaphores;

d1713 2
a1714 2

  semaphores.insert (this);
d1721 11
a1731 2

  semaphores.remove (this);
d1735 1
a1735 1
semaphore::_post ()
d1743 1
a1743 1
semaphore::_trywait ()
d1758 1
a1758 1
semaphore::_wait ()
d1772 1
a1772 1
semaphore::_fixup_after_fork ()
d1774 1
a1774 1
  debug_printf ("sem %x in _fixup_after_fork", this);
d1854 2
a1855 2
  thread->set_thread_id_to_current ();
  set_tls_self_pointer (thread);
d1857 1
a1857 1
  thread->mutex.lock ();
d1861 1
a1861 1
  thread->mutex.unlock ();
d1885 1
a1885 1
pthread::is_good_object (pthread_t const *thread)
d1895 1
a1895 1
  return get_thread_id ();
d1903 1
a1903 1
  if (attr && !pthread_attr::is_good_object (attr))
d1908 1
a1908 1
  if (!is_good_object (thread))
d1945 1
a1945 1
  if (!is_good_object (&thread))
d2072 1
a2072 1
  if (!pthread_attr::is_good_object (attr))
d2085 1
a2085 1
  if (!pthread_attr::is_good_object (attr))
d2095 1
a2095 1
  if (!pthread_attr::is_good_object (attr))
d2107 1
a2107 1
  if (!pthread_attr::is_good_object (attr))
d2117 1
a2117 1
  if (!pthread_attr::is_good_object (attr))
d2126 1
a2126 1
  if (!pthread_attr::is_good_object (attr))
d2137 1
a2137 1
  if (!pthread_attr::is_good_object (attr))
d2146 1
a2146 1
  if (!pthread_attr::is_good_object (attr))
d2159 1
a2159 1
  if (!pthread_attr::is_good_object (attr))
d2171 1
a2171 1
  if (!pthread_attr::is_good_object (attr))
d2181 1
a2181 1
  if (!pthread_attr::is_good_object (attr))
d2197 1
a2197 1
  if (!pthread_attr::is_good_object (attr))
d2206 1
a2206 1
  if (!pthread_attr::is_good_object (attr))
d2215 1
a2215 1
  if (!pthread_attr::is_good_object (attr))
d2233 1
a2233 1
   if (!is_good_object (&joiner))
d2236 1
a2236 1
  if (!is_good_object (thread))
d2242 1
a2242 1
  (*thread)->mutex.lock ();
d2246 1
a2246 1
      (*thread)->mutex.unlock ();
d2253 1
a2253 1
      (*thread)->mutex.unlock ();
d2281 1
a2281 1
  if (!is_good_object (thread))
d2284 1
a2284 1
  (*thread)->mutex.lock ();
d2287 1
a2287 1
      (*thread)->mutex.unlock ();
d2292 1
a2292 1
  if (WaitForSingleObject ((*thread)->win32_obj_id, 0) == WAIT_TIMEOUT)
d2297 1
a2297 1
      (*thread)->mutex.unlock ();
d2302 1
a2302 1
      (*thread)->mutex.unlock ();
d2312 1
a2312 1
  if (!is_good_object (thread))
d2328 1
a2328 1
  if (!is_good_object (thread))
d2352 1
a2352 1
  if (!pthread::is_good_object (&thread))
d2367 1
a2367 1
  if (pthread_key::is_good_object (key))
d2372 1
a2372 1
  if (!pthread_key::is_good_object (key))
d2384 1
a2384 1
  if (!pthread_key::is_good_object (&key))
d2408 1
a2408 1
  if (!pthread::is_good_object (&thread))
d2425 1
a2425 1
  if (!pthread_key::is_good_object (&key))
d2434 1
a2434 1
  if (!pthread_key::is_good_object (&key))
d2443 1
a2443 1
pthread_cond::is_good_object (pthread_cond_t const *cond)
d2451 1
a2451 1
pthread_cond::is_good_initializer (pthread_cond_t const *cond)
d2459 1
a2459 1
pthread_cond::is_good_initializer_or_object (pthread_cond_t const *cond)
d2467 1
a2467 1
pthread_cond::is_good_initializer_or_bad_object (pthread_cond_t const *cond)
d2478 1
a2478 1
  if (pthread_cond::is_good_initializer (cond))
d2480 1
a2480 1
  if (!pthread_cond::is_good_object (cond))
d2496 1
a2496 1
  if (attr && !pthread_condattr::is_good_object (attr))
d2498 1
a2498 1
  if (!cond_initialization_lock.lock ())
d2501 1
a2501 1
  if (!is_good_initializer_or_bad_object (cond))
d2503 1
a2503 1
      cond_initialization_lock.unlock ();
d2508 1
a2508 1
  if (!is_good_object (cond))
d2512 1
a2512 1
      cond_initialization_lock.unlock ();
d2515 1
a2515 1
  cond_initialization_lock.unlock ();
d2522 1
a2522 1
  if (pthread_cond::is_good_initializer (cond))
d2524 1
a2524 1
  if (!pthread_cond::is_good_object (cond))
d2527 1
a2527 1
  (*cond)->unblock (true);
d2535 1
a2535 1
  if (pthread_cond::is_good_initializer (cond))
d2537 1
a2537 1
  if (!pthread_cond::is_good_object (cond))
d2540 1
a2540 1
  (*cond)->unblock (false);
d2549 1
a2549 1
  if (!pthread_mutex::is_good_object (mutex))
d2551 1
a2551 1
  if (!pthread_mutex::can_be_unlocked (mutex))
d2554 1
a2554 1
  if (pthread_cond::is_good_initializer (cond))
d2556 1
a2556 1
  if (!pthread_cond::is_good_object (cond))
d2559 1
a2559 1
  return (*cond)->wait (*mutex, waitlength);
d2596 1
a2596 1
  if (!pthread_condattr::is_good_object (condattr))
d2608 1
a2608 1
  if (!pthread_condattr::is_good_object (attr))
d2617 1
a2617 1
  if (!pthread_condattr::is_good_object (attr))
d2631 1
a2631 1
  if (!pthread_condattr::is_good_object (condattr))
d2640 1
a2640 1
pthread_rwlock::is_good_object (pthread_rwlock_t const *rwlock)
d2648 1
a2648 1
pthread_rwlock::is_good_initializer (pthread_rwlock_t const *rwlock)
d2656 1
a2656 1
pthread_rwlock::is_good_initializer_or_object (pthread_rwlock_t const *rwlock)
d2664 1
a2664 1
pthread_rwlock::is_good_initializer_or_bad_object (pthread_rwlock_t const *rwlock)
d2675 1
a2675 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2677 1
a2677 1
  if (!pthread_rwlock::is_good_object (rwlock))
d2681 1
a2681 1
      (*rwlock)->waiting_readers || (*rwlock)->waiting_writers)
d2693 1
a2693 1
  if (attr && !pthread_rwlockattr::is_good_object (attr))
d2695 1
a2695 1
  if (!rwlock_initialization_lock.lock ())
d2698 1
a2698 1
  if (!is_good_initializer_or_bad_object (rwlock))
d2700 1
a2700 1
      rwlock_initialization_lock.unlock ();
d2705 1
a2705 1
  if (!is_good_object (rwlock))
d2709 1
a2709 1
      rwlock_initialization_lock.unlock ();
d2712 1
a2712 1
  rwlock_initialization_lock.unlock ();
d2721 1
a2721 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2723 1
a2723 1
  if (!pthread_rwlock::is_good_object (rwlock))
d2726 1
a2726 1
  return (*rwlock)->rdlock ();
d2732 1
a2732 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2734 1
a2734 1
  if (!pthread_rwlock::is_good_object (rwlock))
d2737 1
a2737 1
  return (*rwlock)->tryrdlock ();
d2745 1
a2745 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2747 1
a2747 1
  if (!pthread_rwlock::is_good_object (rwlock))
d2750 1
a2750 1
  return (*rwlock)->wrlock ();
d2756 1
a2756 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2758 1
a2758 1
  if (!pthread_rwlock::is_good_object (rwlock))
d2761 1
a2761 1
  return (*rwlock)->trywrlock ();
d2767 1
a2767 1
  if (pthread_rwlock::is_good_initializer (rwlock))
d2769 1
a2769 1
  if (!pthread_rwlock::is_good_object (rwlock))
d2772 1
a2772 1
  return (*rwlock)->unlock ();
d2781 1
a2781 1
  if (!pthread_rwlockattr::is_good_object (rwlockattr))
d2793 1
a2793 1
  if (!pthread_rwlockattr::is_good_object (attr))
d2802 1
a2802 1
  if (!pthread_rwlockattr::is_good_object (attr))
d2816 1
a2816 1
  if (!pthread_rwlockattr::is_good_object (rwlockattr))
d2830 1
a2830 1
  if (!pthread::is_good_object (&thread))
d2862 1
a2862 1
extern "C" int
d2882 1
a2882 1
  if (attr && !pthread_mutexattr::is_good_object (attr) || check_valid_pointer (mutex))
d2884 1
a2884 1
  if (!mutex_initialization_lock.lock ())
d2887 1
a2887 1
  if (!is_good_initializer_or_bad_object (mutex))
d2889 1
a2889 1
      mutex_initialization_lock.unlock ();
d2894 1
a2894 1
  if (!is_good_object (mutex))
d2898 1
a2898 1
      mutex_initialization_lock.unlock ();
d2901 1
a2901 1
  mutex_initialization_lock.unlock ();
d2910 1
a2910 1
  if (pthread_mutex::is_good_initializer (mutex))
d2912 1
a2912 1
  if (!pthread_mutex::is_good_object (themutex))
d2924 1
a2924 1
extern "C" int
d2928 2
a2929 2
  /* This could be simplified via is_good_initializer_or_object
     and is_good_initializer, but in a performance critical call like this....
d2937 1
a2937 1
      if (pthread_mutex::is_good_initializer (mutex))
d2949 1
a2949 1
  return (*themutex)->lock ();
d2956 1
a2956 1
  if (pthread_mutex::is_good_initializer (mutex))
d2958 1
a2958 1
  if (!pthread_mutex::is_good_object (themutex))
d2960 1
a2960 1
  return (*themutex)->trylock ();
d2966 1
a2966 1
  if (pthread_mutex::is_good_initializer (mutex))
d2968 1
a2968 1
  if (!pthread_mutex::is_good_object (mutex))
d2970 1
a2970 1
  return (*mutex)->unlock ();
d2978 1
a2978 1
  if (pthread_mutex::is_good_initializer (mutex))
d2980 1
a2980 1
  if (!pthread_mutex::is_good_object (mutex))
d2983 1
a2983 1
  rv = (*mutex)->destroy ();
d2996 1
a2996 1
  if (pthread_mutex::is_good_initializer (mutex))
d2998 1
a2998 1
  if (!pthread_mutex::is_good_object (themutex))
d3009 1
a3009 1
  if (!pthread_mutexattr::is_good_object (attr))
d3018 1
a3018 1
  if (!pthread_mutexattr::is_good_object (attr))
d3027 1
a3027 1
  if (!pthread_mutexattr::is_good_object (attr))
d3037 1
a3037 1
  if (pthread_mutexattr::is_good_object (attr))
d3041 1
a3041 1
  if (!pthread_mutexattr::is_good_object (attr))
d3053 1
a3053 1
  if (!pthread_mutexattr::is_good_object (attr))
d3065 1
a3065 1
  if (!pthread_mutexattr::is_good_object (attr))
d3075 1
a3075 1
  if (!pthread_mutexattr::is_good_object (attr))
d3084 1
a3084 1
  if (!pthread_mutexattr::is_good_object (attr))
d3092 1
a3092 1
  if (!pthread_mutexattr::is_good_object (attr))
d3107 1
a3107 1
  if (!pthread_mutexattr::is_good_object (attr))
d3128 1
a3128 1
semaphore::is_good_object (sem_t const * sem)
d3139 1
a3139 1
  if (is_good_object (sem))
d3147 1
a3147 1
  if (!is_good_object (sem))
d3159 1
a3159 1
  if (!is_good_object (sem))
d3174 1
a3174 1
  if (!is_good_object (sem))
d3180 1
a3180 1
  (*sem)->_wait ();
d3187 1
a3187 1
  if (!is_good_object (sem))
d3193 1
a3193 1
  return (*sem)->_trywait ();
d3199 1
a3199 1
  if (!is_good_object (sem))
d3202 1
a3202 1
  (*sem)->_post ();
d3206 1
a3206 1
/* pthread_null */
d3208 1
a3208 1
pthread_null::get_null_pthread ()
d3215 1
a3215 1
pthread_null::pthread_null ()
d3222 1
a3222 1
pthread_null::~pthread_null ()
d3227 1
a3227 1
pthread_null::create (void *(*)(void *), pthread_attr *, void *)
d3232 1
a3232 1
pthread_null::exit (void *value_ptr)
d3238 1
a3238 1
pthread_null::cancel ()
d3244 1
a3244 1
pthread_null::testcancel ()
d3249 1
a3249 1
pthread_null::setcancelstate (int state, int *oldstate)
d3255 1
a3255 1
pthread_null::setcanceltype (int type, int *oldtype)
d3261 1
a3261 1
pthread_null::push_cleanup_handler (__pthread_cleanup_handler *handler)
d3266 1
a3266 1
pthread_null::pop_cleanup_handler (int const execute)
d3271 1
a3271 1
pthread_null::getsequence_np ()
d3276 1
a3276 1
pthread_null pthread_null::_instance;
@


1.114.2.4
log
@merge from trunk
@
text
@d376 1
a376 1
  if (equal (joiner, thread))
d407 1
a407 1
  else if (equal (thread, self))
d1213 7
a1219 1
  release ();
a1265 1
  rwlock->release ();
a1274 1
  rwlock->release ();
d1453 1
a1453 1
  return ((*mutex)->recursion_counter == 1 && pthread::equal ((*mutex)->owner, self));
d1515 1
a1515 1
  else if (type != PTHREAD_MUTEX_NORMAL && pthread::equal (owner, self))
d1539 1
a1539 1
  else if (type == PTHREAD_MUTEX_RECURSIVE && pthread::equal (owner, self))
d1550 1
a1550 1
  if (!pthread::equal (owner, self))
d2146 1
a2146 1
  if (equal (*thread,joiner))
d2772 1
a2772 1
  return pthread::equal (t1, t2);
@


1.114.2.5
log
@merge from trunk
@
text
@d191 1
a191 1
MTinterface::Init ()
d196 3
a198 1
  reent_key.set (&reents);
d218 1
a218 1
  pthread::init_mainthread ();
d230 1
a230 1
pthread::init_mainthread ()
d232 3
@


1.114.2.6
log
@merge from trunk
@
text
@d32 1
d48 2
a49 2
extern "C" struct _reent *
__getreent ()
d54 1
d56 1
a56 3
    {
#ifdef _CYG_THREAD_FAILSAFE
      system_printf ("local thread storage not inited");
a57 4
      /* Return _impure_ptr as long as MTinterface is not initialized */
      return _impure_ptr;
    }

d67 1
d69 1
a69 3
    {
#ifdef _CYG_THREAD_FAILSAFE
      system_printf ("local thread storage not inited");
a70 3
      return NULL;
    }

a214 14
#ifndef __SIGNALS_ARE_MULTITHREADED__
  /* As long as the signal handling not multithreaded
     switch reents storage back to _impure_ptr for the mainthread
     to support fork from threads other than the mainthread */
  struct _reent *reent_old = __getreent ();

  if (reent_old && _impure_ptr != reent_old)
    *_impure_ptr = *reent_old;
  reents._clib = _impure_ptr;
  reents._winsup = &winsup_reent;
  winsup_reent._process_logmask = LOG_UPTO (LOG_DEBUG);
  reent_key.set (&reents);
#endif

a217 1
  pthread::fixup_after_fork ();
a263 2
List<pthread> pthread::threads;

a265 1
		    running (false), suspended (false), 
d267 1
a267 1
		    joiner (NULL), next (NULL), cleanup_stack (NULL)
a268 2
  if (this != pthread_null::get_null_pthread ())
    threads.insert (this);
a276 3

  if (this != pthread_null::get_null_pthread ())
    threads.remove (this);
d350 7
a356 9
  running = true;

  InterlockedIncrement (&MT_INTERFACE->threadcount);
  /* FIXME: set the priority appropriately for system contention scope */
  if (attr.inheritsched == PTHREAD_EXPLICIT_SCHED)
    {
      /* FIXME: set the scheduling settings for the new thread */
      /* sched_thread_setparam (win32_obj_id, attr.schedparam); */
    }
a374 1
      running = false;
a392 6
  if (!running)
    {
      mutex.unlock ();
      return 0;
    }

a741 13
void
pthread::_fixup_after_fork ()
{
  /* set thread to not running if it is not the forking thread */
  if (this != pthread::self ())
    {
      magic = 0;
      running = false;
      win32_obj_id = NULL;
      cancel_event = NULL;
    }
}

d1967 2
a1968 3
  if (pthread_attr::is_good_object (attr))
    return EBUSY;

d1974 1
a1974 1
      return ENOMEM;
d2190 1
a2190 1
  if ((*thread)->running && WaitForSingleObject ((*thread)->win32_obj_id, 0) == WAIT_TIMEOUT)
d2491 2
a2492 3
  if (pthread_condattr::is_good_object (condattr))
    return EBUSY;

d2498 1
a2498 1
      return ENOMEM;
d2676 2
a2677 3
  if (pthread_rwlockattr::is_good_object (rwlockattr))
    return EBUSY;

d2683 1
a2683 1
      return ENOMEM;
d3175 2
@


1.114.2.7
log
@merge from trunk
@
text
@d291 1
a291 1
		    running (false), suspended (false),
d859 2
a860 2
	magic = 0;
	return;
d910 1
a910 1
  /*
d921 13
a933 13
	{
	  /*
	   * Block incoming threads until all waiting threads are released.
	   */
	  mtx_in.lock ();

	  /*
	   * Calculate releaseable again because threads can enter until
	   * the semaphore has been taken, but they can not leave, therefore pending
	   * is unchanged and releaseable can only get higher
	   */
	  releaseable = waiting - pending;
	}
d974 1
a974 1

d981 1
a981 1
       */
d983 5
a987 5
	/*
	 * thread got cancelled ot timed out while a signalling is in progress.
	 * Set wait result back to signaled
	 */
	rv = WAIT_OBJECT_0;
d1000 1
a1000 1

d1071 2
a1072 2
	magic = 0;
	return;
d1132 1
a1132 1
    {
d1165 4
a1168 4
	{
	  reader->thread = self;
	  add_reader (reader);
	}
d1170 1
a1170 1
	result = EAGAIN;
d1172 1
a1172 1

d1193 1
a1193 1
    {
d1223 1
a1223 1

d1240 4
a1243 4
	{
	  result = EPERM;
	  goto DONE;
	}
d1252 4
a1255 4
	{
	  result = EPERM;
	  goto DONE;
	}
d1339 1
a1339 1
	temp = &((*temp)->next);
d1341 5
a1345 5
	{
	  struct RWLOCK_READER *cur = *temp;
	  *temp = (*temp)->next;
	  delete cur;
	}
@


1.114.2.8
log
@merge from trunk
@
text
@d1789 1
d1794 1
a1794 1
  thread->sigtodo = NULL;
a2786 1
#if 0
a2788 1
#endif
a2798 1
#if 0
a2805 1
#endif
@


1.114.2.9
log
@merge from trunk
@
text
@d227 4
@


1.113
log
@Apply system_cancel patch
@
text
@d257 1
a257 1
        api_fatal ("failed to create mainthread object");
d635 2
a636 1
DWORD pthread::cancelable_wait (HANDLE object, DWORD timeout, const bool do_cancel)
d755 2
a756 2
                        GetCurrentProcess (), &win32_obj_id,
                        0, FALSE, DUPLICATE_SAME_ACCESS))
d951 1
a951 1
                            false);
d1097 2
a1098 2
    	  set (NULL);
    	  destructor (oldValue);
d1178 1
a1178 1
  pshared(PTHREAD_PROCESS_PRIVATE)
d1190 6
a1195 6
        {
          // fail
          magic = 0;
          return;
        }
      
d1216 1
a1216 1
        tempmutex = tempmutex->next;
d1228 1
a1228 1
 
d1235 1
a1235 1
        result = LockRecursive ();
d1237 1
a1237 1
        result = EDEADLK;
d1244 1
a1244 1
 
d1254 1
a1254 1
 
d1262 1
a1262 1
 
d1270 1
a1270 1
 
d1273 1
a1273 1
 
d1278 2
a1279 2
        // Another thread is waiting
        ::ReleaseSemaphore (win32_obj_id, 1, NULL);
d1281 1
a1281 1
 
d1297 1
a1297 1
 
d1301 1
a1301 1
 
d1912 17
a1928 17
        {
        case WAIT_OBJECT_0:
          if (return_val)
            *return_val = (*thread)->return_ptr;
          delete (*thread);
          break;
        case WAIT_CANCELED:
          // set joined thread back to joinable since we got canceled
          (*thread)->joiner = NULL;
          (*thread)->attr.joinable = PTHREAD_CREATE_JOINABLE;
          joiner->cancel_self ();
          // never reached
          break;
        default:
          // should never happen
          return EINVAL;
        }
d2613 1
a2613 1
 
d2772 1
@


1.112
log
@Apply wait_cancel patch
@
text
@d467 1
a467 1
pthread_testcancel ()
d481 1
a481 1
system ()
@


1.111
log
@Apply handle_sigsuspend patch
@
text
@d484 2
a485 2
wait ()
wait3()
d487 1
a487 1
waitpid ()
@


1.110
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d461 1
a461 1
pause ()
d475 2
a476 2
sigpause ()
sigsuspend ()
@


1.109
log
@Apply pthread_cancel_patch
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.108
log
@Applied pthread_mutex patch
@
text
@d474 1
a474 1
sem_wait ()
d635 22
d1415 9
a1423 2
  WaitForSingleObject (win32_obj_id, INFINITE);
  currentvalue--;
d1882 1
a1882 2
   if (!isGoodObject (&joiner))
     return EINVAL;
d1888 3
a1890 1
  /* FIXME: wait on the thread cancellation event as well - we are a cancellation point*/
a1908 6
      WaitForSingleObject ((*thread)->win32_obj_id, INFINITE);
      if (return_val)
	 *return_val = (*thread)->return_ptr;
      // cleanup
      delete (*thread);
    }	/* End if */
d1910 19
a1928 1
  pthread_testcancel ();
d2674 2
@


1.107
log
@Applied cond_init patch
@
text
@d916 5
a920 11
  if (!wincap.has_signal_object_and_wait ())
    {
      // FIXME: race condition (potentially drop events
      // Possible solution (single process only) - place this in a critical section.
      ReleaseMutex (mutex->win32_obj_id);
      rv = WaitForSingleObject (win32_obj_id, dwMilliseconds);
    }
  else
    {
      LeaveCriticalSection (&mutex->criticalsection);
      rv = WaitForSingleObject (win32_obj_id, dwMilliseconds);
d922 4
a925 4
    /* we need to use native win32 mutex's here, because the cygwin ones now use
     * critical sections, which are faster, but introduce a race _here_. Until then
     * The NT variant of the code is redundant.
     */
d927 2
a928 2
    rv = SignalObjectAndWait (mutex->win32_obj_id, win32_obj_id, dwMilliseconds,
			 false);
a929 1
    }
d1150 6
a1155 1
pthread_mutex::pthread_mutex (pthread_mutexattr *attr):verifyable_object (PTHREAD_MUTEX_MAGIC)
d1157 2
a1158 2
  /* attr checked in the C call */
  if (attr && attr->pshared == PTHREAD_PROCESS_SHARED)
a1159 1
      // fail
d1163 2
a1164 3
  if (wincap.has_try_enter_critical_section ())
    InitializeCriticalSection (&criticalsection);
  else
d1166 8
a1173 3
      this->win32_obj_id = ::CreateMutex (&sec_none_nih, false, NULL);
      if (!win32_obj_id)
	magic = 0;
d1175 1
a1175 2
  condwaits = 0;
  pshared = PTHREAD_PROCESS_PRIVATE;
d1182 3
a1184 8
  if (wincap.has_try_enter_critical_section ())
    DeleteCriticalSection (&criticalsection);
  else
    {
      if (win32_obj_id)
	CloseHandle (win32_obj_id);
      win32_obj_id = NULL;
    }
d1193 1
a1193 1
	tempmutex = tempmutex->next;
d1203 14
a1216 1
  if (wincap.has_try_enter_critical_section ())
d1218 2
a1219 2
      EnterCriticalSection (&criticalsection);
      return 0;
d1221 2
a1222 2
  /* FIXME: Return 0 on success */
  return WaitForSingleObject (win32_obj_id, INFINITE);
d1229 12
a1240 3
  if (wincap.has_try_enter_critical_section ())
    return (!TryEnterCriticalSection (&criticalsection));
  return (WaitForSingleObject (win32_obj_id, 0) == WAIT_TIMEOUT);
d1246 23
a1268 1
  if (wincap.has_try_enter_critical_section ())
d1270 3
a1272 2
      LeaveCriticalSection (&criticalsection);
      return 0;
d1274 19
a1292 1
  return (!ReleaseMutex (win32_obj_id));
d1301 12
a1312 9
  /* FIXME: duplicate code here and in the constructor. */
  if (wincap.has_try_enter_critical_section ())
    InitializeCriticalSection (&criticalsection);
  else
    {
      win32_obj_id = ::CreateMutex (&sec_none_nih, false, NULL);
      if (!win32_obj_id)
	api_fatal ("pthread_mutex::fixup_after_fork () failed to create new win32 mutex");
    }
d2410 1
a2410 2
  (*themutex)->Lock ();
  return 0;
d2421 1
a2421 3
  if ((*themutex)->TryLock ())
    return EBUSY;
  return 0;
d2431 1
a2431 2
  (*mutex)->UnLock ();
  return 0;
d2437 2
d2444 3
a2446 3
  /* reading a word is atomic */
  if ((*mutex)->condwaits)
    return EBUSY;
a2447 1
  delete (*mutex);
a2484 4
/* Win32 mutex's are equivalent to posix RECURSIVE mutexs.
   We need to put glue in place to support other types of mutex's. We map
   PTHREAD_MUTEX_DEFAULT to PTHREAD_MUTEX_RECURSIVE and return EINVAL for
   other types.  */
d2494 1
a2494 4
/* Currently pthread_mutex_init ignores the attr variable, this is because
   none of the variables have any impact on it's behaviour.

   FIXME: write and test process shared mutex's.  */
d2570 11
a2580 3
  if (type != PTHREAD_MUTEX_RECURSIVE)
    return EINVAL;
  (*attr)->mutextype = type;
@


1.106
log
@2002-11-05  Thomas Pfaff  <tpfaff@@gmx.net>

        * dcrt0.cc (dll_crt0_1): Add call to pthread::initMainThread to
        initialize mainthread when it is safe to call new.
        * init.cc (dll_entry): Change call to store reents in tls key.
        * thread.cc (_reent_clib) : Change call to get reents from tls
        key.
        (_reent_winsup): Ditto.
        (MTinterface::Init): Key handling changed. Remove initialization
        of member variables.
        (MTinterface::fixup_after_fork): Reinitialize mainthread object
        after fork. Reset threadount to 1.
        (pthread::initMainThread): Create mainthread object dynamically.
        and initialize with valid handles.
        (pthread::self): Remove calls to create thread objects.
        (pthread::setTlsSelfPointer): Change call to store thread self
        handle in tls key.
        (pthread::getTlsSelfPointer): New static method.
        (pthread::exit): Remove setTlsSelfPointer call.
        (pthread::initCurrentThread): New method.
        (pthread::thread_init_wrapper): Change call to store thread self
        handle in tls key.
        (pthread::join): Check for a valid joiner.
        (pthreadNull::pthreadNull): Mark Null object as detached.
        (pthreadNull::exit): Terminate thread via ExitThread.
        * thread.h (pthread::initMainThread): Change parameter in function
        call.
        (pthread::getTlsSelfPointer): New static method.
        (pthread::initCurrentThread): New method.
        (MTinterface::reent_key): Remove.
        (MTinterface::thread_self_dwTlsIndex): Ditto..
        (MTinterface::indexallocated): Ditto.
        (MTinterface::mainthread): Ditto.
        (MTinterface::reent_key): New member.
        (MTinterface::thread_self_key): Ditto.
        (MTinterface::MTinterface): Initialize all members.
@
text
@d75 31
d202 1
d778 13
d1138 2
a1139 2
    verifyable_object_state objectState = verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER);
    if (objectState == VALID_OBJECT)
d1141 1
a1141 1
    return true;
d1145 1
a1145 1
pthread_mutex::nativeMutex pthread_mutex::mutexInitializationLock NO_COPY;
a1260 31
pthread_mutex::nativeMutex::init ()
{
  theHandle = CreateMutex (&sec_none_nih, FALSE, NULL);
  if (!theHandle)
    {
      debug_printf ("CreateMutex failed. %E");
      return false;
    }
  return true;
}

bool
pthread_mutex::nativeMutex::lock ()
{
  DWORD waitResult = WaitForSingleObject (theHandle, INFINITE);
  if (waitResult != WAIT_OBJECT_0)
    {
      system_printf ("Received unexpected wait result %d on handle %p, %E", waitResult, theHandle);
      return false;
    }
  return true;
}

void
pthread_mutex::nativeMutex::unlock ()
{
  if (!ReleaseMutex (theHandle))
    system_printf ("Received a unexpected result releasing mutex. %E");
}

bool
d2018 9
d2046 1
a2046 1
__pthread_cond_init (pthread_cond_t *cond, const pthread_condattr_t *attr)
d2050 2
d2053 5
a2057 2
  if (pthread_cond::isGoodObject (cond))
    return EBUSY;
d2060 1
a2060 2

  if (!pthread_cond::isGoodObject (cond))
d2064 1
d2067 1
a2067 1

d2075 1
a2075 1
    __pthread_cond_init (cond, NULL);
d2088 1
a2088 1
    __pthread_cond_init (cond, NULL);
d2109 1
a2109 1
    __pthread_cond_init (cond, NULL);
@


1.105
log
@* miscfuncs.cc (low_priority_sleep): New function.  Use throughout where code
is supposed to be giving up time slice.
* fhandler_console.cc (fhandler_console::read): Switch button 2/3 output escape
sequences to be consistent with xterm.
@
text
@a48 2
#define MT_INTERFACE user_data->threadinterface

a51 1
  int tmp = GetLastError ();
d53 1
a53 1
    (struct __reent_t *) TlsGetValue (MT_INTERFACE->reent_index);
a58 2

  SetLastError (tmp);
d65 3
a67 3
  int tmp = GetLastError ();
  struct __reent_t *_r;
  _r = (struct __reent_t *) TlsGetValue (MT_INTERFACE->reent_index);
a71 1
  SetLastError (tmp);
a162 2

  reent_index = TlsAlloc ();
a164 1

d167 2
a168 12
  TlsSetValue (reent_index, &reents);
  // the static reent_data will be used in the main thread

  if (!indexallocated)
    {
      thread_self_dwTlsIndex = TlsAlloc ();
      if (thread_self_dwTlsIndex == TLS_OUT_OF_INDEXES)
	system_printf
	  ("local storage for thread couldn't be set\nThis means that we are not thread safe!");
      else
	indexallocated = (-1);
    }
a169 4
  concurrency = 0;
  threadcount = 1; /* 1 current thread when Init occurs.*/

  pthread::initMainThread (&mainthread, myself->hProcess);
a170 8

  if (forked)
    return;

  mutexs = NULL;
  conds  = NULL;
  semaphores = NULL;

d205 4
d215 1
a215 1
pthread::initMainThread (pthread *mainThread, HANDLE win32_obj_id)
d217 12
a228 3
  mainThread->win32_obj_id = win32_obj_id;
  mainThread->setThreadIdtoCurrent ();
  setTlsSelfPointer (mainThread);
d234 4
a237 11
  pthread *temp = (pthread *) TlsGetValue (MT_INTERFACE->thread_self_dwTlsIndex);
  if (temp)
      return temp;
  temp = new pthread ();
  temp->precreate (NULL);
  if (!temp->magic) {
      delete temp;
      return pthreadNull::getNullpthread ();
  }
  temp->postcreate ();
  return temp;
d243 7
a249 2
  /* the OS doesn't check this for <= 64 Tls entries (pre win2k) */
  TlsSetValue (MT_INTERFACE->thread_self_dwTlsIndex, thisThread);
a366 3
  /* Prevent DLL_THREAD_DETACH Attempting to clean us up */
  setTlsSelfPointer (0);

d695 12
d1403 1
a1403 3
  /* This is not checked by the OS !! */
  if (!TlsSetValue (MT_INTERFACE->reent_index, &local_reent))
    system_printf ("local storage for thread couldn't be set");
d1405 1
d1411 1
a1411 1
    thread->joiner = pthread::self ();
d1778 3
d2588 1
d2605 1
@


1.104
log
@Rename _kill() to kill() throughout.  Rename _raise() to raise() throughout.
Rename _pid() to pid() throughout.
* Makefile.in: Compile some objects with -fomit-frame-pointer.
* cygwin.din: Reverse aliasing for _kill.
* syscalls.cc (_getpid_r): New function, implemented for newlib compatibility.
* shared.cc (open_shared): Remove reserving of memory since previous change
eliminate the need for this hack.
@
text
@d865 1
a865 1
      Sleep (0);
@


1.103
log
@* thread.cc (verifyable_object_isvalid): Test for a valid object pointer before
testing for static ptr.
@
text
@d2217 1
a2217 1
  int rval = _kill (myself->pid, sig);
@


1.102
log
@2002-10-17  Robert Collins  <rbtcollins@@hotmail.com>

        * thread.h (pthread_mutex::isGoodInitializerOrBadObject): Declare.
        * thread.cc (pthread_mutex::isGoodInitializerOrBadObject): Implement.
        (pthread_mutex::init): Use isGoodInitializerOrBadObject to avoid
        unneeded SEGV's during debugging.
@
text
@d1101 1
a1101 1
bool 
d1368 2
a1371 2
  if (check_valid_pointer (object))
    return INVALID_OBJECT;
@


1.101
log
@2002-10-17  Thomas Pfaff  <tpfaff@@gmx.net>

	* thread.cc (verifyable_object_isvalid): Test for static object first.
@
text
@d1101 9
d2268 1
a2268 2
  /* FIXME: bugfix: we should check *mutex being a valid address */
  if (isGoodObject (mutex))
@


1.100
log
@whitespace
@
text
@d1359 2
a1364 2
  if (static_ptr && *object == static_ptr)
    return VALID_STATIC_OBJECT;
@


1.99
log
@2002-10-01  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc (pthread_key::keys): Copy on fork. Add a comment explaining
        why.
        (pthreadNull::_instance): Copy on fork. Absolutely no state exists
        in pthreadNull.
@
text
@d193 1
a193 1
  pthread_mutex::initMutex ();  
@


1.98
log
@* thread.cc (pthread_mutex::initMutex): Remove \n from api_fatal.
@
text
@d193 1
a193 1
  pthread_mutex::initMutex ();
d938 2
a939 1
List<pthread_key> pthread_key::keys NO_COPY;
d1101 1
d2645 1
a2645 1
pthreadNull NO_COPY pthreadNull::_instance;
@


1.97
log
@* thread.cc (pthread::precreate): Use explicit "no inherit" option when
creating mutex.
(pthread_mutex::nativeMutex::init): Ditto.
(semaphore::semaphore): Ditto.
@
text
@d1109 1
a1109 1
    api_fatal ("Could not create win32 Mutex for pthread mutex static initializer support.\n");
@


1.96
log
@* thread.cc (pthread_key::keys): Do not copy on fork.
(pthread_mutex::mutexInitializationLock): Ditto.
(pthreadNull::_instance): Ditto.
@
text
@d320 1
a320 1
  cancel_event = ::CreateEvent (NULL,TRUE,FALSE,NULL);
d765 2
a766 2
				     false,	/* start non signaled */
				     NULL /* no name */);
d1108 1
a1108 1
  if (!mutexInitializationLock.init())
d1216 1
a1216 1
pthread_mutex::nativeMutex::init()
d1218 1
a1218 1
  theHandle = CreateMutex (NULL, FALSE, NULL);
d1228 1
a1228 1
pthread_mutex::nativeMutex::lock()
d1240 1
a1240 1
pthread_mutex::nativeMutex::unlock()
d1266 1
a1266 1
					 NULL);
d2254 1
a2254 1
  if (!mutexInitializationLock.lock())
d2260 1
a2260 1
      mutexInitializationLock.unlock();
d2269 1
a2269 1
      mutexInitializationLock.unlock();
d2272 1
a2272 1
  mutexInitializationLock.unlock();
d2315 1
a2315 1
         we can just attempt to lock it */
@


1.95
log
@2002-09-30  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc (pthread_mutex::initMutex): Use the wrapper init call.
        (pthread_mutex::nativeMutex::init): Implement.
        (pthread_mutex::nativeMutex::lock): Ditto.
        (pthread_mutex::nativeMutex::unlock): Ditto.
        (pthread_mutex::init): Use the wrapper lock and unlockcalls.
        * thread.h (pthread_mutex): Move mutexInitializationLock into a
        nativeMutex wrapper class.
@
text
@d938 1
a938 1
List<pthread_key> pthread_key::keys;
d1100 1
a1100 1
pthread_mutex::nativeMutex pthread_mutex::mutexInitializationLock;
d2643 1
a2643 1
pthreadNull pthreadNull::_instance = pthreadNull ();
@


1.94
log
@remove newline
@
text
@d1100 1
a1100 1
HANDLE pthread_mutex::mutexInitializationLock;
d1108 2
a1109 4
  mutexInitializationLock = CreateMutex (NULL, FALSE, NULL);
  if (!mutexInitializationLock)
    api_fatal ("Could not create win32 Mutex for pthread mutex static initializer support. The error code was %E");

d1216 31
d2254 2
a2255 6
  DWORD waitResult = WaitForSingleObject (mutexInitializationLock, INFINITE);
  if (waitResult != WAIT_OBJECT_0)
    {
      system_printf ("Received a unexpected wait result on mutexInitializationLock %d, %E", waitResult);
      return EINVAL;
    }
d2260 1
a2260 2
      if (!ReleaseMutex (mutexInitializationLock))
	  system_printf ("Received a unexpected result releasing mutexInitializationLock %E");
d2269 1
a2269 2
      if (!ReleaseMutex (mutexInitializationLock))
	  system_printf ("Received a unexpected result releasing mutexInitializationLock %E");
d2272 1
a2272 2
  if (!ReleaseMutex (mutexInitializationLock))
      system_printf ("Received a unexpected result releasing mutexInitializationLock %E");
@


1.93
log
@* exceptions.cc (unused_sig_wrapper): Accommodate newer compilers.
@
text
@d2228 1
a2228 1
      system_printf ("Received a unexpected wait result on mutexInitializationLock %d, %E\n", waitResult);
@


1.92
log
@* thread.cc: Use "%E" in *_printf throughout rather than calling GetLastError.
GNUify comments.
(__pthread_mutex_lock): Don't return error on EBUSY since that just means that
the mutex has already been initialized.
@
text
@d2228 1
a2228 1
      system_printf ("Received a unexpected wait result on mutexInitializationLock %d\n", waitResult);
@


1.91
log
@GNUify slightly.
@
text
@d268 1
a268 1
  /*the OS doesn't check this for <= 64 Tls entries (pre win2k) */
d300 1
a300 1
  /*already running ? */
d323 2
a324 2
      system_printf ("couldn't create cancel event, this %p LastError %d", this, GetLastError () );
      /*we need the event for correct behaviour */
d359 1
a359 1
    /*FIXME: set the priority appropriately for system contention scope */
d362 2
a363 2
	/*FIXME: set the scheduling settings for the new thread */
	/*sched_thread_setparam (win32_obj_id, attr.schedparam); */
d379 1
a379 1
  if (__pthread_equal (&joiner, &thread ) )
d615 1
a615 1
  if (WAIT_OBJECT_0 == WaitForSingleObject (cancel_event, 0 ) )
d675 1
a675 1
  InterlockedExchangePointer (&cleanup_stack, handler );
d764 4
a767 4
  this->win32_obj_id = ::CreateEvent (&sec_none_nih, false,	/*auto signal reset - which I think is pthreads like ? */
				     false,	/*start non signaled */
				     NULL /*no name */);
  /*TODO: make a shared mem mutex if out attributes request shared mem cond */
d772 1
a772 1
      /*we need the mutex for correct behaviour */
d811 1
a811 1
      /*This isn't and API error - users are allowed to call this when no threads
d906 1
a906 1
      return 0;			/*POSIX doesn't allow errors after we modify the mutex state */
d911 1
a911 1
      return 0;			/*we have been signaled */
d1009 1
a1009 1
  /*the OS function doesn't perform error checking */
d1041 1
a1041 1
  if (destructor) 
d1043 1
a1043 1
      void *oldValue = get();
d1052 1
a1052 1
/*pshared mutexs:
d1054 2
a1055 2
 * REMOVED FROM CURRENT. These can be reinstated with the daemon, when all the
 gymnastics can be a lot easier.
d1057 17
a1073 18
 *the mutex_t (size 4) is not used as a verifyable object because we cannot
 *guarantee the same address space for all processes.
 *we use the following:
 *high bit set (never a valid address).
 *second byte is reserved for the priority.
 *third byte is reserved
 *fourth byte is the mutex id. (max 255 cygwin mutexs system wide).
 *creating mutex's does get slower and slower, but as creation is a one time
 *job, it should never become an issue
 *
 *And if you're looking at this and thinking, why not an array in cygwin for all mutexs,
 *- you incur a penalty on _every_ mutex call and you have toserialise them all.
 *... Bad karma.
 *
 *option 2? put everything in userspace and update the ABI?
 *- bad karma as well - the HANDLE, while identical across process's,
 *Isn't duplicated, it's reopened.
 */
d1103 2
a1104 3
 * TODO: (no rush) use a non copied memory section to 
 * hold an initialization flag.
 */
d1110 2
a1111 2
    api_fatal ("Could not create win32 Mutex for pthread mutex static initializer support. The error code was %d\n", GetLastError());
  
d1116 1
a1116 1
  /*attr checked in the C call */
d1274 1
a1274 1
  /*FIXME: signals should be able to interrupt semaphores...
d1315 1
a1315 1
/*Generic memory acccess routine - where should it live ? */
d1359 1
a1359 1
  sigset_t _sig_mask;		/*one set for everything to ignore. */
d1374 1
a1374 1
  /*This is not checked by the OS !! */
d1403 1
a1403 1
  /*never reached */
d1449 2
a1450 2
  /*Here we must set a cancellation handler to unlock the mutex if needed */
  /*but a cancellation handler is not the right thing. We need this in the thread
d1460 1
a1460 1
  /*Here we must remove our cancellation handler */
d1474 16
a1489 18
/*
 *Races in pthread_atfork:
 *We are race safe in that any additions to the lists are made via
 *InterlockedExchangePointer.
 *However, if the user application doesn't perform syncronisation of some sort
 *It's not guaranteed that a near simultaneous call to pthread_atfork and fork
 *will result in the new atfork handlers being calls.
 *More rigorous internal syncronisation isn't needed as the user program isn't
 *guaranteeing their own state.
 *
 *as far as multiple calls to pthread_atfork, the worst case is simultaneous calls
 *will result in an indeterminate order for parent and child calls (what gets inserted
 *first isn't guaranteed.)
 *
 *There is one potential race... Does the result of InterlockedExchangePointer
 *get committed to the return location _before_ any context switches can occur?
 *If yes, we're safe, if no, we're not.
 */
d1527 3
a1529 4
/*Register a set of functions to run before and after fork.
 *prepare calls are called in LI-FC order.
 *parent and child calls are called in FI-FC order.
 */
d1574 1
a1574 1
    /*t = pointer to last next in the list */
d1583 1
a1583 1
    /*t = pointer to last next in the list */
d1624 3
a1626 4
/*From a pure code point of view, this should call a helper in sched.cc,
 *to allow for someone adding scheduler policy changes to win32 in the future.
 *However that's extremely unlikely, so short and sweet will do us
 */
d1690 1
a1690 1
/*See __pthread_attr_getschedpolicy for some notes */
d1709 2
a1710 2
  /*In future, we may be able to support system scope by escalating the thread
   *priority to exceed the priority class. For now we only support PROCESS scope. */
d1754 1
a1754 1
  /*FIXME: wait on the thread cancellation event as well - we are a cancellation point*/
d1778 1
a1778 1
    }	/*End if */
d1799 1
a1799 1
  if (WAIT_TIMEOUT == WaitForSingleObject ((*thread)->win32_obj_id, 0) )
d1845 3
a1847 3
/*provided for source level compatability.
 *See http://www.opengroup.org/onlinepubs/007908799/xsh/pthread_getconcurrency.html
 */
d1854 1
a1854 1
/*keep this in sync with sched.cc */
d1862 2
a1863 2
  /*we don't return the current effective priority, we return the current requested
   *priority */
d1868 1
a1868 1
/*Thread SpecificData */
d1872 2
a1873 3
  /*The opengroup docs don't define if we should check this or not,
   *but creation is relatively rare..
   */
d1898 3
a1900 3
/*provided for source level compatability.
 *See http://www.opengroup.org/onlinepubs/007908799/xsh/pthread_getconcurrency.html
 */
d1910 1
a1910 1
/*keep syncronised with sched.cc */
d1948 1
a1948 1
/*Thread synchronisation */
d1981 1
a1981 1
  /*reads are atomic */
d2057 1
a2057 1
  /*if the cond variable is blocked, then the above timer test maybe wrong. *shrug**/
d2075 2
a2076 3
   * However, the loop there should allow us to get scheduled and call wait,
   * and have them call PulseEvent again if we dont' respond.
   */
d2078 2
a2079 3
  /* this may allow a race on the mutex acquisition and waits..
   * But doing this within the cond access mutex creates a different race
   */
d2147 1
a2147 1
  /*shared cond vars not currently supported */
d2164 1
a2164 1
/*Thread signal */
d2168 1
a2168 1
// lock myself, for the use of thread2signal
d2209 1
a2209 1
/*Mutexes  */
d2228 1
a2228 1
      system_printf ("Recieved a unexpected wait result on mutexInitializationLock %d\n", waitResult);
d2235 2
a2236 2
      if (! ReleaseMutex(mutexInitializationLock))
	  system_printf ("Recieved a unexpected result releasing mutexInitializationLock %d\n", GetLastError());
d2245 2
a2246 2
      if (! ReleaseMutex(mutexInitializationLock))
	  system_printf ("Recieved a unexpected result releasing mutexInitializationLock %d\n", GetLastError());
d2249 2
a2250 2
  if (! ReleaseMutex(mutexInitializationLock))
      system_printf ("Recieved a unexpected result releasing mutexInitializationLock %d\n", GetLastError());
d2263 7
a2269 8
  /*We don't define _POSIX_THREAD_PRIO_PROTECT because we do't currently support
   *mutex priorities.
   *
   *We can support mutex priorities in the future though:
   *Store a priority with each mutex.
   *When the mutex is optained, set the thread priority as appropriate
   *When the mutex is released, reset the thread priority.
   */
d2279 1
a2279 2
     no.
     */
d2289 1
a2289 1
	  if (rv)
d2293 1
a2293 2
       * we can just attempt to lock it
       */
d2334 1
a2334 1
  /*reading a word is atomic */
d2355 2
a2356 2
/*Win32 doesn't support mutex priorities - see __pthread_mutex_getprioceiling
 *for more detail */
d2376 4
a2379 4
/*Win32 mutex's are equivalent to posix RECURSIVE mutexs.
 *We need to put glue in place to support other types of mutex's. We map
 *PTHREAD_MUTEX_DEFAULT to PTHREAD_MUTEX_RECURSIVE and return EINVAL for other types.
 */
d2389 4
a2392 5
/*Currently pthread_mutex_init ignores the attr variable, this is because
 *none of the variables have any impact on it's behaviour.
 *
 *FIXME: write and test process shared mutex's.
 */
d2420 1
a2420 1
/*Win32 doesn't support mutex priorities */
d2429 1
a2429 1
/*Win32 doesn't support mutex priorities */
d2453 1
a2453 1
  /*we don't use pshared for anything as yet. We need to test PROCESS_SHARED
d2462 1
a2462 1
/*see __pthread_mutex_gettype */
d2474 1
a2474 1
/*Semaphores */
d2488 1
a2488 1
  /*opengroup calls this undefined */
d2512 1
a2512 1
  /*FIXME - new feature - test for busy against threads... */
@


1.90
log
@2002-09-30  Robert Collins <rbtcollins@@hotmail.com>

        * pthread.cc (pthread_mutex_init): Use new pthread_mutex::init.
        * thread.cc: Change __pthread_mutex_init to pthread_mutex::init
        throughout.
        (MTinterface::Init): Initialise pthread_mutex support.
        (pthread_mutex::mutexInitializationLock): Instantiate.
        (pthread_mutex::initMutex): New method.
        (__pthread_cond_dowait): Don't dereference untrusted pointers.
        Use the new pthread_mutex::init method.
        (__pthread_condattr_init): Don't dereference untrusted pointers.
        (__pthread_mutex_init): Rename to pthread_mutex::init.
        Lock and release mutexInitializationLock to prevent races on
        mutex initialisation.
        * thread.h (pthread_mutex::initMutex): New method, initialise
        pthread_mutex supporting state on process initialisation.
        (pthread_mutex::init): Initialise a single mutex.
        (pthread_mutex::mutexInitializationLock): A win32 mutex for
        syncronising pthread mutex initialisation.
        (__pthread_mutex_init): Remove this.
@
text
@d190 1
a190 1
  threadcount = 1; /*1 current thread when Init occurs.*/
d2113 1
a2113 1
  waitlength = (abstime->tv_sec - currSysTime.time) *1000;
d2220 7
a2226 8
/*FIXME: there's a potential race with PTHREAD_MUTEX_INITALIZER:
 *the mutex is not actually inited until the first use.
 *So two threads trying to lock/trylock may collide.
 *Solution: we need a global mutex on mutex creation, or possibly simply
 *on all constructors that allow INITIALIZER macros.
 *the lock should be very small: only around the init routine, not
 *every test, or all mutex access will be synchronised.
 */
@


1.89
log
@2002-09-27  Robert Collins <rbtcollins@@hotmail.com>

       * thread.cc (pthread_key::run_destructor): Run_destructor is not
       const as it needs to set the key value.
       * thread.h (pthread_key::run_destructor): Ditto.

2002-09-27  Robert Collins <rbtcollins@@hotmail.com>

       * thread.cc (pthread_key::run_destructor): Follow opengroup algorithm.
       I.e. only run the destructor NON-NULL key values, and reset the key
       to NULL before running the destructor. Reported by Thomas Pfaff.
@
text
@d193 1
d1101 15
d2053 2
a2054 2
  if (*mutex == PTHREAD_MUTEX_INITIALIZER)
    __pthread_mutex_init (mutex, NULL);
d2128 2
a2129 1
  /* FIXME: we dereference blindly! */
d2230 1
a2230 1
__pthread_mutex_init (pthread_mutex_t *mutex,
d2235 6
d2243 6
a2248 2
  if (pthread_mutex::isGoodObject (mutex))
    return EBUSY;
d2251 1
a2251 1
  if (!pthread_mutex::isGoodObject (mutex))
d2255 2
d2259 2
d2270 1
a2270 1
    __pthread_mutex_init ((pthread_mutex_t *) mutex, NULL);
d2300 1
a2300 1
	  int rv = __pthread_mutex_init (mutex, NULL);
d2304 3
d2320 1
a2320 1
    __pthread_mutex_init (mutex, NULL);
d2332 1
a2332 1
    __pthread_mutex_init (mutex, NULL);
d2362 1
a2362 1
    __pthread_mutex_init (mutex, NULL);
@


1.88
log
@white space.
@
text
@d1038 1
a1038 1
pthread_key::run_destructor () const
d1040 9
a1048 2
  if (destructor)
    destructor (get ());
@


1.87
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d275 2
a276 2
                    cancelstate (0), canceltype (0), cancel_event (0),
                    joiner (NULL), cleanup_stack (NULL)
d998 1
a998 1
  if (magic != 0) 
d2250 1
a2250 1
  /* This could be simplified via isGoodInitializerOrObject 
d2303 1
a2303 1
  if (!pthread_mutex::isGoodObject (mutex)) 
@


1.86
log
@2002-09-21  Robert Collins <rbtcollins@@hotmail.com>

        * pthread.cc: Use class::call for converted pthread and semaphore
        calls.
        * thread.cc: Convert various __pthread_call and __sem_call to
        pthread::call and sem::call throughout.
        * pthread.h (__pthread_cancel): Convert to pthread::cancel.
        (__pthread_join): Convert to pthread::join.
        (__pthread_detach): Convert to pthread::detach.
        (__pthread_create): Convert to pthread::create.
        (__pthread_once): Convert to pthread::once.
        (__pthread_atfork): Convert to pthread::atfork.
        (__pthread_suspend): Convert to pthread::suspend.
        (__pthread_continue): Convert to pthread::resume.
        (__sem_init): Convert to semaphore::init.
        (__sem_destroy): Convert to semaphore::destroy.
        (__sem_wait): Convert to semaphore::wait.
        (__sem_trywait): Convert to semaphore::trywait.
        (__sem_post): Convert to semaphore::post.
@
text
@d311 1
a311 1
  if (!pthread_mutex::isGoodObject(&verifyable_mutex_obj))
d1016 1
a1016 1
  int savedError = ::GetLastError();
d1041 1
a1041 1
    destructor (get());
@


1.85
log
@2002-09-21  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc: Finish the removal of the separate pthread_key
        destructor list.
        Remove all pthread_key_destructor and pthread_key_destructor_list
        references throughout.
        (pthread::exit): Call the new pthread_key interface to activate
        destructors.
        (pthread_key::keys): Change into a list.
        (pthread_key::saveAKey): New method, used via forEach.
        (pthread_key::restoreAKey): Ditto.
        (pthread_key::destroyAKey): Ditto.
        (pthread_key::fixup_before_fork): Use the List::forEach functionality.
        (pthread_key::fixup_after_fork): Ditto.
        (pthread_key::runAllDestructors): New method implementation.
        (pthread_key::pthread_key): Use List::Insert rather than custom list
        code.
        (pthread_key::~pthread_key): Use List::Remove for the same reason.
        * thread.h: Remove all pthread_key_destructor and
        pthread_key_destructor_list references throughout.
        (List): Move the interface above pthread_key in the header.
        Use atomic operations during insert and delete.
        (List::forEach): A generic interface for doing something on each node.
        (pthread_key::runAllDestructors): New method, run all destructors.
        (pthread_key::fork_buf): Make private.
        (pthread_key::run_destructor): Ditto.
        (pthread_key::saveAKey): New method for clearer source.
        (pthread_key::restoreAKey): Ditto.
        (pthread_key::destroyAKey): Ditto.
        (MTinterface::destructors): Remove.
@
text
@d1401 1
a1401 1
__pthread_create (pthread_t *thread, const pthread_attr_t *attr,
d1410 1
a1410 1
  if (!pthread::isGoodObject (thread))
d1421 1
a1421 1
__pthread_once (pthread_once_t *once_control, void (*init_routine) (void))
d1445 1
a1445 1
__pthread_cancel (pthread_t thread)
d1447 1
a1447 1
  if (!pthread::isGoodObject (&thread))
d1513 1
a1513 1
__pthread_atfork (void (*prepare)(void), void (*parent)(void), void (*child)(void))
d1729 1
a1729 1
__pthread_join (pthread_t *thread, void **return_val)
d1731 1
a1731 1
   pthread_t joiner = pthread::self ();
d1738 1
a1738 1
  if (!pthread::isGoodObject (thread))
d1769 1
a1769 1
__pthread_detach (pthread_t *thread)
d1771 1
a1771 1
  if (!pthread::isGoodObject (thread))
d1800 1
a1800 1
__pthread_suspend (pthread_t *thread)
d1802 1
a1802 1
  if (!pthread::isGoodObject (thread))
d1816 1
a1816 1
__pthread_continue (pthread_t *thread)
d1818 1
a1818 1
  if (!pthread::isGoodObject (thread))
d2459 1
a2459 1
__sem_init (sem_t *sem, int pshared, unsigned int value)
d2462 1
a2462 1
  if (semaphore::isGoodObject (sem))
d2470 1
a2470 1
  if (!semaphore::isGoodObject (sem))
d2480 1
a2480 1
__sem_destroy (sem_t *sem)
d2482 1
a2482 1
  if (!semaphore::isGoodObject (sem))
d2493 1
a2493 1
__sem_wait (sem_t *sem)
d2495 1
a2495 1
  if (!semaphore::isGoodObject (sem))
d2506 1
a2506 1
__sem_trywait (sem_t *sem)
d2508 1
a2508 1
  if (!semaphore::isGoodObject (sem))
d2518 1
a2518 1
__sem_post (sem_t *sem)
d2520 1
a2520 1
  if (!semaphore::isGoodObject (sem))
@


1.84
log
@2002-09-21  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc: Partial refactoring of pthread_key destructor
        handling. Loosely based on Thomas Pfaff's work.
        (pthread_key_destructor_list::Insert): Remove.
        (pthread_key_destructor_list::Pop): Remove.
        (pthread_key_destructor_list::IterateNull): Call the key's
        run_destructor method.
        (pthread_key::pthread_key): Initialize new member.
        (pthread_key::get): Mark as const for correctness.
        (pthread_key::run_destructor): Implement.
        * thread.h (pthread_key::get): Mark as const for correctness.
        (pthread_key::run_destructor): Declare.
        (List): New template class that implements a generic list.
        (pthread_key_destructor_list): Inherit from List, and remove
        now duplicate functions.
@
text
@a48 67
/*pthread_key_destructor_list class: to-be threadsafe single linked list
 *FIXME: Put me in a dedicated file, or a least a tools area !
 */

pthread_key_destructor *
pthread_key_destructor::InsertAfter (pthread_key_destructor *node)
{
  pthread_key_destructor *temp = next;
  next = node;
  return temp;
}

pthread_key_destructor *
pthread_key_destructor::UnlinkNext ()
{
  pthread_key_destructor *temp = next;
  if (next)
    next = next->Next ();
  return temp;
}

pthread_key_destructor *
pthread_key_destructor::Next ()
{
  return next;
}

  /*remove a given dataitem, wherever in the list it is */
pthread_key_destructor *
pthread_key_destructor_list::Remove (pthread_key *key)
{
  if (!key)
    return NULL;
  if (!head)
    return NULL;
  if (key == head->key)
    return Pop ();
  pthread_key_destructor *temp = head;
  while (temp && temp->Next () && !(key == temp->Next ()->key))
    {
      temp = temp->Next ();
    }
  if (temp)
    return temp->UnlinkNext ();
  return NULL;
}

pthread_key_destructor::
pthread_key_destructor (void (*thedestructor) (void *), pthread_key *key)
{
  destructor = thedestructor;
  next = NULL;
  this->key = key;
}

void
pthread_key_destructor_list::IterateNull ()
{
  pthread_key_destructor *temp = head;
  while (temp)
    {
      temp->key->run_destructor ();
      temp = temp->Next ();
    }
}


d374 1
a374 1
  MT_INTERFACE->destructors.IterateNull ();
d937 7
a943 1
pthread_key *pthread_key::keys = NULL;
d948 7
a954 7
  pthread_key *key = keys;
  debug_printf ("keys is %x",keys);
  while (key)
    {
      key->saveKeyToBuffer ();
      key = key->next;
    }
d960 13
a972 7
  pthread_key *key = keys;
  debug_printf ("keys is %x",keys);
  while (key)
    {
      key->recreateKeyFromBuffer ();
      key = key->next;
    }
d990 2
a991 7
  else if (destructor)
    {
      MT_INTERFACE->destructors.
	Insert (new pthread_key_destructor (destructor, this));
    }
  /* threadsafe addition is easy */
  next = (pthread_key *) InterlockedExchangePointer (&keys, this);
d996 3
a998 8
  if (pthread_key_destructor *dest = MT_INTERFACE->destructors.Remove (this))
    delete dest;
  TlsFree (dwTlsIndex);

  /* I'm not 100% sure the next bit is threadsafe. I think it is... */
  if (keys == this)
    InterlockedExchangePointer (keys, this->next);
  else
d1000 2
a1001 5
      pthread_key *tempkey = keys;
      while (tempkey->next && tempkey->next != this)
        tempkey = tempkey->next;
      /* but there may be a race between the loop above and this statement */
      InterlockedExchangePointer (&tempkey->next, this->next);
@


1.83
log
@2002-09-21  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc: Change verifyable_object_isvalid calls with
        PTHREAD_CONDATTR_MAGIC, PTHREAD_MUTEXATTR_MAGIC, PTHREAD_COND_MAGIC,
        SEM_MAGIC to objecttype::isGoodObject() calls throughout.
        (pthread_condattr::isGoodObject): Implement.
        (pthread_mutex::isGoodInitializer): Implement.
        (pthread_mutex::isGoodInitializerOrObject): Minor bugfix in the
        check for verifyable_object_isvalid result.
        (pthread_mutexattr::isGoodObject): Implement.
        (pthread_cond::isGoodObject): Ditto.
        (pthread_cond::isGoodInitializer): Ditto.
        (pthread_cond::isGoodInitializerOrObject): Ditto.
        (semaphore::isGoodObject): Ditto.
        * thread.h (pthread_mutex::isGoodInitializer): Declare.
        (pthread_condattr::isGoodObject): Ditto.
        (pthread_cond::isGoodObject): Const correctness.
        (pthread_cond::isGoodInitializer): Declare.
        (pthread_cond::isGoodInitializerOrObject): Ditto.
        (semaphore::isGoodObject): Const correctness.
@
text
@a75 10
void
pthread_key_destructor_list::Insert (pthread_key_destructor *node)
{
  if (!node)
    return;
  head = node->InsertAfter (head);
  if (!head)
    head = node;		/*first node special case */
}

a95 9
  /*get the first item and remove at the same time */
pthread_key_destructor *
pthread_key_destructor_list::Pop ()
{
  pthread_key_destructor *temp = head;
  head = head->Next ();
  return temp;
}

d110 1
a110 1
      temp->destructor ((temp->key)->get ());
d1040 1
a1040 1
pthread_key::pthread_key (void (*destructor) (void *)):verifyable_object (PTHREAD_KEY_MAGIC)
d1082 1
a1082 1
pthread_key::get ()
d1103 7
@


1.82
log
@2002-09-21  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc: Change verifyable_object_isvalid calls with
        PTHREAD_MUTEX_MAGIC and PTHREAD_KEY_MAGIC and PTHREAD_ATTR_MAGIC to
        ::isGoodObject() calls throughout.
        (MTinterface::Init): Remove dead code.
        (pthread_attr::isGoodObject): Implement.
        (pthread_key::isGoodObject): Implement.
        (pthread_mutex::isGoodObject): Implement.
        (pthread_mutex::isGoodInitializerOrObject): Implement.
        (pthread::isGoodObject): Update signature.
        * thread.h (pthread_key::isGoodObject): Declare.
        (pthread_attr::isGoodObject): Ditto.
        (pthread_mutex::isGoodObject): Ditto.
        (pthread_mutex::isGoodInitializerOrObject): Ditto.
        (pthread::isGoodObject): Change to a const parameter for const
        correctness.
        (pthread_mutexattr::isGoodObject): Declare.
        (pthread_condattr::isGoodObject): Ditto.
        (pthread_cond::isGoodObject): Ditto.
        (semaphore::isGoodObject): Ditto.
@
text
@d825 8
d1150 1
a1150 1
pthread_mutex::isGoodObject (pthread_mutex_t const *thread)
d1152 1
a1152 1
  if (verifyable_object_isvalid (thread, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d1158 1
a1158 1
pthread_mutex::isGoodInitializerOrObject (pthread_mutex_t const *thread)
d1160 9
a1168 1
  if (verifyable_object_isvalid (thread, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER) != VALID_OBJECT)
d1276 8
d2013 23
d2040 1
a2040 1
  if (check_valid_pointer (cond) && (*cond == PTHREAD_COND_INITIALIZER))
d2042 1
a2042 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
d2058 1
a2058 1
  if (attr && verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
d2061 1
a2061 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER) == VALID_OBJECT)
d2066 1
a2066 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
d2079 1
a2079 1
  if (*cond == PTHREAD_COND_INITIALIZER)
d2081 1
a2081 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
d2092 1
a2092 1
  if (*cond == PTHREAD_COND_INITIALIZER)
d2094 1
a2094 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
d2113 1
a2113 1
  if (*cond == PTHREAD_COND_INITIALIZER)
d2118 1
a2118 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
d2185 1
d2187 1
a2187 1
  if (verifyable_object_isvalid (condattr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
d2199 1
a2199 1
  if (verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
d2208 1
a2208 1
  if (verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
d2222 1
a2222 1
  if (verifyable_object_isvalid (condattr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
d2289 1
a2289 1
  if (attr && verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT || check_valid_pointer (mutex))
d2292 2
a2293 1
  if (pthread_mutex::isGoodInitializerOrObject (mutex))
d2311 1
a2311 1
  if (*mutex == PTHREAD_MUTEX_INITIALIZER)
d2330 4
d2340 1
a2340 1
      if (*mutex == PTHREAD_MUTEX_INITIALIZER)
d2358 1
a2358 1
  if (*mutex == PTHREAD_MUTEX_INITIALIZER)
d2370 1
a2370 1
  if (*mutex == PTHREAD_MUTEX_INITIALIZER)
d2381 1
a2381 1
  if (check_valid_pointer (mutex) && (*mutex == PTHREAD_MUTEX_INITIALIZER))
d2400 1
a2400 1
  if (*mutex == PTHREAD_MUTEX_INITIALIZER)
d2413 1
a2413 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2422 1
a2422 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2435 1
a2435 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2449 1
a2449 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != INVALID_OBJECT)
d2453 1
a2453 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2465 1
a2465 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2477 1
a2477 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2487 1
a2487 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2496 1
a2496 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2504 1
a2504 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2519 1
a2519 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2528 10
d2542 1
a2542 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != INVALID_OBJECT)
d2550 1
a2550 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
d2562 1
a2562 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
d2575 1
a2575 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
d2588 1
a2588 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
d2600 1
a2600 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
@


1.81
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@a254 12
#if 0
  for (int i = 0; i < MT_MAX_ITEMS; i++)
    {
      threadlist.items[i] = NULL;
      mutexlist.items[i] = NULL;
      semalist.items[i] = NULL;
    }

  threadlist.index = 0;
  mutexlist.index = 0;
  semalist.index = 0;
#endif
a260 6
#if 0
  winsup_reent._grp_pos = 0;
  winsup_reent._process_ident = 0;
  winsup_reent._process_logopt = 0;
  winsup_reent._process_facility = 0;
#endif
a264 1

a286 9
  /*possible the atfork lists should be inited here as well */

#if 0
  item->function = NULL;

  item->sigs = NULL;
  item->sigmask = NULL;
  item->sigtodo = NULL;
#endif
d397 1
a397 1
  if (verifyable_object_isvalid (&verifyable_mutex_obj, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d803 11
d884 1
a884 1
  if (verifyable_object_isvalid (&mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d905 1
a905 1
  if (verifyable_object_isvalid (&mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d1041 8
d1140 17
d1443 1
a1443 1
pthread::isGoodObject (pthread_t *thread)
d1461 1
a1461 1
  if (attr && verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1633 1
a1633 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1646 1
a1646 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1656 1
a1656 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1669 1
a1669 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1679 1
a1679 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1688 1
a1688 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1699 1
a1699 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1708 1
a1708 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1721 1
a1721 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1733 1
a1733 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1743 1
a1743 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1759 1
a1759 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1768 1
a1768 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1777 1
a1777 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1914 1
a1914 1
  if (verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC) == VALID_OBJECT)
d1919 1
a1919 1
  if (verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
d1931 1
a1931 1
  if (verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
d1972 1
a1972 1
  if (verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
d1981 1
a1981 1
  if (verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
d2069 1
a2069 1
  if (verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d2244 1
a2244 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER) == VALID_OBJECT)
d2248 1
a2248 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d2264 1
a2264 1
  if (verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d2307 1
a2307 1
  if (verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d2319 1
a2319 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d2330 1
a2330 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d2349 1
a2349 1
  if (verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
@


1.80
log
@2002-09-17  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc (pthread_key::set): Preserve GetLastError(). Reported
        by Thomas Pffaf.
@
text
@d390 1
a390 1
                    joiner (NULL), cleanup_stack (NULL) 
@


1.79
log
@2002-09-17  Robert Collins  <rbtcollins@@hotmail.com>

        This work inspires by Thomas Pfaff's pthread_fork patch (1).
        * fork.cc (fork_child): Remove MTinterface fixup call, it's
        adsorbed by pthread::atforkchild.
        Rename __pthread_atforkchild to pthread::atforkchild to give
        access to private members.
        (fork_parent): Rename __pthread_atforkparent to
        pthread::atforkparent to give it access to private members.
        Ditto for __pthread_atforkprepare.
        * thread.cc: Fix some formatting problems throughout.
        (MTinterface::fixup_before_fork): Implement.
        (MTinterface::fixup_after_fork): Fix pthread_keys.
        (pthread_key::keys): Implement.
        (pthread_key::fixup_before_fork): Ditto.
        (pthread_key::fixup_after_fork): Ditto.
        (pthread_key::pthread_key): Add to pthread_key::keys.
        (pthread_key::~pthread_key): Remove from pthread_key::keys.
        (pthread_key::saveKeyToBuffer): Implement.
        (pthread_key::recreateKeyFromBuffer): Ditto.
        (pthread::atforkprepare): Prepare all MT classes for fork.
        (pthread::atforkchild): And fix them up afterwards.
        * thread.h (pthread_key): Buffer the key value during
        fork in fork_buf.
        List the keys needing to be fixed up in a linked list with
        head pthread_key::keys.
        (pthread): Move atfork cygwin internal calls into the class.
        (MTInterface): Provide a fixup_before_fork for objecst that
        need to save state.
        (__pthread_atforkprepare): Remove.
        (__pthread_atforkparent): Remove.
        (__pthread_atforkchild): Remove.
@
text
@d1104 4
a1107 2
  set_errno (0);
  return TlsGetValue (dwTlsIndex);
@


1.78
log
@* init.cc: Cleanup slightly and remove obsolete code.
@
text
@d297 1
a297 1
  pthread::initMainThread(&mainthread, myself->hProcess);
d317 6
d327 1
d355 1
a355 1
pthread::initMainThread(pthread *mainThread, HANDLE win32_obj_id)
d359 1
a359 1
  setTlsSelfPointer(mainThread);
d372 1
a372 1
      return pthreadNull::getNullpthread();
d379 1
a379 1
pthread::setTlsSelfPointer(pthread *thisThread)
d385 2
d389 2
a390 2
		    cancelstate (0), canceltype (0), cancel_event(0),
		    joiner (NULL), cleanup_stack(NULL)
d492 1
a492 1
  if( __pthread_equal(&joiner, &thread ) )
d501 1
a501 1
  setTlsSelfPointer(0);
d526 1
a526 1
  else if (__pthread_equal(&thread, &self))
d728 1
a728 1
  if( WAIT_OBJECT_0 == WaitForSingleObject (cancel_event, 0 ) )
d735 1
a735 1
  pthread::self()->cancel_self ();
d788 1
a788 1
  InterlockedExchangePointer( &cleanup_stack, handler );
d820 1
a820 1
pthread::cancel_self()
d826 1
a826 1
pthread::getThreadId()
d1030 29
d1070 2
d1079 12
d1108 15
d1381 1
a1381 1
  struct _reent local_clib = _REENT_INIT(local_clib);
d1403 1
a1403 1
  setTlsSelfPointer(thread);
d1518 1
a1518 1
__pthread_atforkprepare (void)
d1520 2
d1531 1
a1531 1
__pthread_atforkparent (void)
d1542 1
a1542 1
__pthread_atforkchild (void)
d1544 2
d1787 1
a1787 1
  if (__pthread_equal(thread,&joiner))
d1792 1
a1792 1
  if((*thread)->attr.joinable == PTHREAD_CREATE_DETACHED)
d2536 1
a2536 1
pthreadNull::getNullpthread()
d2543 1
a2543 1
pthreadNull::pthreadNull()
d2549 1
a2549 1
pthreadNull::~pthreadNull()
d2596 1
a2596 1
pthreadNull::getsequence_np()
@


1.77
log
@2002-09-11  Robert Collins  <rbtcollins@@hotmail.com>

        * init.cc (dll_entry): On thread detach, if the thread hasn't
        exit()ed, do so.
        * pthread.cc (pthread_getsequence_np): Remove the
        __pthread_getsequence_np wrapper. This requires errno.h.
        * thread.cc (pthread::self): Instantiate a new pthread object
        when called and none exists. return a NULL object if instantiation
        fails.
        (pthread::precreate): Factor out common code.
        (pthread::postcreate): Ditto.
        (pthread::create): Ditto.
        (pthread::exit): Remove the TLS value when we exit to prevent
        double exits.
        (MTinterface::Init): Bugfix - don't mark the TLS index as created
        if one was not allocated.
        Apply Extract Method to move pthread specific initialisation into
        pthread.
        (pthread::initMainThread): Extracted method from MTinterface::Init.
        (pthread::setTlsSelfPointer): Extracted method from various pthread
        calls, to make reading those functions easier.
        (pthread::setThreadIdtoCurrent): Ditto.
        (pthread::cancel_self): Bring into the .cc file, it's only used
        within the class.
        (pthread::getThreadId): Ditto.
        (pthread::thread_init_wrapper): Apply Extract Method to the TLS
        setting logic.
        (pthread::isGoodObject): Extracted method from various pthread
        wrapper calls, for clarity of reading.
        (pthread::getsequence_np): Converted from __pthread_getsquence_np.
        (__pthread_create): Apply Extract Method to the object validation.
        (__pthread_cancel): Ditto.
        (__pthread_join): Ditto.
        (__pthread_detach): Ditto.
        (__pthread_suspend): Ditto.
        (__pthread_continue): Ditto.
        (__pthread_getschedparam): Ditto.
        (__pthread_getsequence_np): Remove.
        (__pthread_setschedparam): Apply Extract Method to the object
        validation.
        (pthreadNull::getNullpthread): New method, return the pthreadNull
        object.
        (pthreadNull::pthreadNull): Private constructor to prevent accidental
        use.
        (pthreadNull::~pthreadNull): Prevent compile warnings.
        (pthreadNull::create): Override pthread behaviour.
        (pthreadNull::exit): Ditto.
        (pthreadNull::cancel): Ditto.
        (pthreadNull::testcancel): Ditto.
        (pthreadNull::setcancelstate): Ditto.
        (pthreadNull::setcanceltype): Ditto.
        (pthreadNull::push_cleanup_handler): Ditto.
        (pthreadNull::pop_cleanup_handler): Ditto.
        (pthreadNull::getsequence_np): Ditto.
        (pthreadNull::_instance): Ditto.
        * thread.h (pthread): Declare pre- and post-create.
        Move GetThreadId to private scope and rename to getThreadId.
        Move setThreadIdtoCurrent to private scope.
        Make create virtual.
        Make ~pthread virtual.
        Declare initMainThread.
        Declare isGoodObject.
        Make exit virtual.
        Make cancel virtual.
        Make testcancel virtual.
        Make setcancelstate virtual.
        Make setcanceltype virtual.
        Make push_cleanup_handler virtual.
        Make pop_cleanup_handler virtual.
        Declare getsequence_np.
        Declare setTlsSelfPointer.
        (pthreadNull): New null object class for pthread.
        (__pthread_getsequence_np): Remove.
@
text
@d380 2
a381 2
                    cancelstate (0), canceltype (0), cancel_event(0),
                    joiner (NULL), cleanup_stack(NULL) 
d437 1
a437 1
{ 
d486 1
a486 1
    {  
d742 1
a742 1
        *oldstate = cancelstate;
d763 1
a763 1
        *oldtype = canceltype;
d777 1
a777 1
    api_fatal ("Attempt to push a cleanup handler across threads"); 
d788 1
a788 1
  
d796 1
a796 1
        (*handler->function) (handler->arg);
@


1.76
log
@2002-06-25  Thomas Pfaff  <tpfaff@@gmx.net>

        * include/pthread.h (PTHREAD_CANCELED): Defined a reasonable
        value.
	* pthread.cc (pthread_exit): Call method instead of function.
	(pthread_setcancelstate): Ditto.
	(pthread_setcanceltype): Ditto.
	(pthread_testcancel): Ditto.
	* thread.h (pthread::cancel_event): New member.
        (__pthread_cancel_self): New prototype.
	(pthread::exit): New Method.
	(pthread::cancel): Ditto.
	(pthread::testcancel): Ditto.
	(pthread::cancel_self): Ditto.
	(pthread::static_cancel_self): Ditto.
	(pthread::setcancelstate): Ditto.
	(pthread::setcanceltype): Ditto.
	(__pthread_cancel): Give c++ linkage.
	(__pthread_exit): Remove.
	(__pthread_setcancelstate): Ditto.
	(__pthread_setcanceltype): Ditto.
	(__pthread_testcancel): Ditto.
	 * thread.cc (pthread::pthread): Inititialize cancel_event.
	(pthread::~pthread): Close cancel_event if needed.
	(pthread::create): Create cancel_event.
	(pthread::exit): New method. Replacement for __pthread_exit.
	(pthread::cancel): New method.
	(pthread::testcancel): Ditto.
	(pthread::static_cancel_self); New static method.
	(pthread::setcancelstate): New method. Replacement for
	__pthread_setcancelstate.
	(pthread::setcanceltype): New method. Replacement for
	__pthread_setcanceltype.
	(pthread::pop_cleanup_handler): Added lock for async cancel safe
	cancellation.
	(pthread::thread_init_wrapper): Change __pthread_exit to
	thread->exit().
	(__pthread_cancel): Call method thread->cancel().
	(__pthread_exit): Remove.
	(__pthread_setcancelstate): Ditto.
	(__pthread_setcanceltype): Ditto.
	(__pthread_testcancel): Ditto.
@
text
@a285 1
      indexallocated = (-1);
d290 2
d297 1
a297 4
  mainthread.win32_obj_id = myself->hProcess;
  mainthread.setThreadIdtoCurrent ();
  /*store the main thread's self pointer */
  TlsSetValue (thread_self_dwTlsIndex, &mainthread);
d347 7
d358 18
a375 1
  return (pthread *) TlsGetValue (MT_INTERFACE->thread_self_dwTlsIndex);
d393 5
d400 1
a400 2
pthread::create (void *(*func) (void *), pthread_attr *newattr,
		 void *threadarg)
a414 2
  function = func;
  arg = threadarg;
d432 11
d453 2
a454 9
  else
    {
      InterlockedIncrement (&MT_INTERFACE->threadcount);
      /*FIXME: set the priority appropriately for system contention scope */
      if (attr.inheritsched == PTHREAD_EXPLICIT_SCHED)
	{
	  /*FIXME: set the scheduling settings for the new thread */
	  /*sched_thread_setparam (win32_obj_id, attr.schedparam); */
	}
d456 13
a468 1
    }
d491 3
d810 12
d1336 1
a1336 2
  /*the OS doesn't check this for <= 64 Tls entries (pre win2k) */
  TlsSetValue (MT_INTERFACE->thread_self_dwTlsIndex, thread);
d1365 14
d1389 1
a1389 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1426 1
a1426 1
  if (verifyable_object_isvalid (&thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1713 1
a1713 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1746 1
a1746 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1777 1
a1777 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1793 1
a1793 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1817 1
a1817 1
  if (verifyable_object_isvalid (&thread, PTHREAD_MAGIC) != VALID_OBJECT)
a1825 9

unsigned long
__pthread_getsequence_np (pthread_t *thread)
{
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
    return EINVAL;
  return (*thread)->GetThreadId ();
}

d1874 1
a1874 1
  if (verifyable_object_isvalid (&thread, PTHREAD_MAGIC) != VALID_OBJECT)
d2107 1
a2107 1
  if (verifyable_object_isvalid (&thread, PTHREAD_MAGIC) != VALID_OBJECT)
d2462 69
@


1.75
log
@* thread.cc (pthread::create): Added trace printf to get CreateThread
LastError.
@
text
@d358 2
a359 1
                    cancelstate (0), canceltype (0), joiner (NULL), cleanup_stack(NULL) 
d367 2
d400 9
d432 298
d746 2
d756 2
d1284 1
a1284 1
  thread->mutex.Lock();
d1288 1
a1288 1
  thread->mutex.UnLock();
d1301 1
a1301 1
  __pthread_exit (ret);
a1354 10
/*Cancelability states */


/*Perform the actual cancel */
void
__pthread_cleanup (pthread_t thread)
{
}


a1359 192
  if (thread->cancelstate == PTHREAD_CANCEL_ENABLE)
    {
#if 0
      /*once all the functions call testcancel (), we will do this */
      if (thread->canceltype == PTHREAD_CANCEL_DEFERRED)
	{
	}
      else
	{
	  /*possible FIXME: this function is meant to return asynchronously
	   *from the cancellation routine actually firing. So we may need some sort
	   *of signal to be sent that is immediately recieved and acted on.
	   */
	  __pthread_cleanup (thread);
	}
#endif
    }
/* return 0;
*/

  return ESRCH;
/*
  we return ESRCH until all the required functions call testcancel ();
  this will give applications predictable behaviour.

  the required function list is: *indicates done, X indicates not present in cygwin.
aio_suspend ()
*close ()
*creat ()
fcntl ()
fsync ()
getmsg ()
getpmsg ()
lockf ()
mq_receive ()
mq_send ()
msgrcv ()
msgsnd ()
msync ()
nanosleep ()
open ()
pause ()
poll ()
pread ()
pthread_cond_timedwait ()
pthread_cond_wait ()
*pthread_join ()
pthread_testcancel ()
putmsg ()
putpmsg ()
pwrite ()
read ()
readv ()
select ()
sem_wait ()
sigpause ()
sigsuspend ()
sigtimedwait ()
sigwait ()
sigwaitinfo ()
*sleep ()
system ()
tcdrain ()
*usleep ()
wait ()
wait3()
waitid ()
waitpid ()
write ()
writev ()

the optional list is:
catclose ()
catgets ()
catopen ()
closedir ()
closelog ()
ctermid ()
dbm_close ()
dbm_delete ()
dbm_fetch ()
dbm_nextkey ()
dbm_open ()
dbm_store ()
dlclose ()
dlopen ()
endgrent ()
endpwent ()
endutxent ()
fclose ()
fcntl ()
fflush ()
fgetc ()
fgetpos ()
fgets ()
fgetwc ()
fgetws ()
fopen ()
fprintf ()
fputc ()
fputs ()
fputwc ()
fputws ()
fread ()
freopen ()
fscanf ()
fseek ()
fseeko ()
fsetpos ()
ftell ()
ftello ()
ftw ()
fwprintf ()
fwrite ()
fwscanf ()
getc ()
getc_unlocked ()
getchar ()
getchar_unlocked ()
getcwd ()
getdate ()
getgrent ()
getgrgid ()
getgrgid_r ()
getgrnam ()
getgrnam_r ()
getlogin ()
getlogin_r ()
getpwent ()
*getpwnam ()
*getpwnam_r ()
*getpwuid ()
*getpwuid_r ()
gets ()
getutxent ()
getutxid ()
getutxline ()
getw ()
getwc ()
getwchar ()
getwd ()
glob ()
iconv_close ()
iconv_open ()
ioctl ()
lseek ()
mkstemp ()
nftw ()
opendir ()
openlog ()
pclose ()
perror ()
popen ()
printf ()
putc ()
putc_unlocked ()
putchar ()
putchar_unlocked ()
puts ()
pututxline ()
putw ()
putwc ()
putwchar ()
readdir ()
readdir_r ()
remove ()
rename ()
rewind ()
rewinddir ()
scanf ()
seekdir ()
semop ()
setgrent ()
setpwent ()
setutxent ()
strerror ()
syslog ()
tmpfile ()
tmpnam ()
ttyname ()
ttyname_r ()
ungetc ()
ungetwc ()
unlink ()
vfprintf ()
vfwprintf ()
vprintf ()
vwprintf ()
wprintf ()
wscanf ()

Note, that for fcntl (), for any value of the cmd argument.
d1361 1
a1361 37
And we must not introduce cancellation points anywhere else that's part of the posix or
opengroup specs.
 */
}

/*no races in these three functions: they are all current-thread-only */
int
__pthread_setcancelstate (int state, int *oldstate)
{
  class pthread *thread = pthread::self ();
  if (state != PTHREAD_CANCEL_ENABLE && state != PTHREAD_CANCEL_DISABLE)
    return EINVAL;
  *oldstate = thread->cancelstate;
  thread->cancelstate = state;
  return 0;
}

int
__pthread_setcanceltype (int type, int *oldtype)
{
  class pthread *thread = pthread::self ();
  if (type != PTHREAD_CANCEL_DEFERRED && type != PTHREAD_CANCEL_ASYNCHRONOUS)
    return EINVAL;
  *oldtype = thread->canceltype;
  thread->canceltype = type;
  return 0;
}

/*deferred cancellation request handler */
void
__pthread_testcancel (void)
{
  class pthread *thread = pthread::self ();
  if (thread->cancelstate == PTHREAD_CANCEL_DISABLE)
    return;
  /*check the cancellation event object here - not neededuntil pthread_cancel actually
   *does something*/
a1632 26
}

void
__pthread_exit (void *value_ptr)
{
  pthread * thread = pthread::self ();

  // run cleanup handlers
  thread->pop_all_cleanup_handlers ();

  MT_INTERFACE->destructors.IterateNull ();
  
  thread->mutex.Lock();
  // cleanup if thread is in detached state and not joined
  if( __pthread_equal(&thread->joiner, &thread ) )
    delete thread;
  else
    {  
      thread->return_ptr = value_ptr;
      thread->mutex.UnLock();
    }

  if (InterlockedDecrement (&MT_INTERFACE->threadcount) == 0)
    exit (0);
  else
    ExitThread (0);
@


1.74
log
@2002-06-12  Thomas Pfaff  <tpfaff@@gmx.net>

	* thread.h (pthread::cleanup_stack): Renamed cleanup_handlers to
	cleanup_stack.
	* thread.cc (pthread::pthread): Ditto.
	(pthread::create): Fixed mutex verification.
	(pthread::push_cleanup_handler): Renamed cleanup_handlers to
	cleanup_stack.
	Mutex calls removed, used InterlockedExchangePointer instead.
	(pthread::pop_cleanup_handler): Renamed cleanup_handlers to
	cleanup_stack.
	(pthread::pop_all_cleanup_handlers): Ditto.
	(__pthread_once): Check state first and return if already done.
	(__pthread_join): DEADLOCK test reverted to __pthread_equal
	call.
	(__pthread_detach): Unlock mutex before deletion.
@
text
@d402 4
a405 1
    magic = 0;
@


1.73
log
@* uinfo.cc (cygheap_user::ontherange): Use env_name for NetUserGetInfo.
(cygheap_user::env_logsrv): Verify env_domain is valid.
* environ.cc: Include child_info.h and keep spenvs[] sorted.
(environ_init): Check child_proc_info instead of myself->ppid_handle.
@
text
@d358 1
a358 1
cancelstate (0), canceltype (0), joiner (NULL), cleanup_handlers(NULL) 
d373 2
d389 1
a389 1
  if (verifyable_object_isvalid (&mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d422 2
a423 4
  mutex.Lock();
  handler->next = cleanup_handlers;
  cleanup_handlers = handler;
  mutex.UnLock();
d433 1
a433 1
  if (cleanup_handlers != NULL )
d435 1
a435 1
      __pthread_cleanup_handler *handler = cleanup_handlers;
d438 2
a439 3
	 (*handler->function) (handler->arg);

      cleanup_handlers = handler->next;
d446 1
a446 1
  while (cleanup_handlers != NULL)
d1017 4
d1028 1
a1028 1
  if (once_control->state == 0)
d1562 1
a1562 1
  thread->pop_all_cleanup_handlers();
d1587 4
d1595 2
a1596 6
  if ( joiner == *thread)    
    {
      if (return_val)
	*return_val = NULL;
      return EDEADLK;
    }
a1601 2
      if (return_val)
	*return_val = NULL;
d1644 3
a1646 1
    // thread has already terminated.
d1648 1
@


1.72
log
@/tmp/cvs610a0a90.1
@
text
@d1591 1
a1591 1
        *return_val = NULL;
d1600 1
a1600 1
        *return_val = NULL;
d1611 1
a1611 1
         *return_val = (*thread)->return_ptr;
@


1.71
log
@2002-06-10  Robert Collins  <rbtcollins@@hotmail.com>

        * cygwin.din: Add _pthread_cleanup_push and _pthread_cleanup_pop.
        * pthread.cc: Change __pthread_self to pthread::self() thruoghout.
        (_pthread_cleanup_push): New function.
        (_pthread_cleanup_pop): Ditto.
        * thread.cc: Thanks to Thomas Pfaff for the pthread cleanup_push,_pop
        patch, this work is derived from that.
        Change __pthread_self to pthread::self() thruoghout.
        (__pthread_self): Rename to pthread::self.
        (pthread::self): New method.
        (pthread::pthread): Initialize new member.
        (pthread::push_cleanup_handler): New method.
        (pthread::pop_cleanup_handler): New method.
        (pthread::pop_all_cleanup_handlers): New method.
        (__pthread_exit): Pop all cleanup handlers.
        * thread.h (pthread::push_cleanup_handler): Declare.
        (pthread::pop_cleanup_handler): Ditto.
        (pthread::pop_all_cleanup_handlers): Ditto.
        (pthread::self): New static method.
        (__pthread_exit): Give C++ linkage.
        (__pthread_join): Ditto.
        (__pthread_detach): Ditto.
        (__pthread_self): Remove.

2002-04-24  Thomas Pfaff  <tpfaff@@gmx.net>

        * include/pthread.h (__pthread_cleanup_handler): New structure
        (pthread_cleanup_push): Rewritten .
        (pthread_cleanup_pop): Ditto.
        (_pthread_cleanup_push): New prototype.
        (_pthread_cleanup_pop) Ditto.

2002-04-24  Thomas Pfaff  <tpfaff@@gmx.net>

        * thread.cc (thread_init_wrapper): Check if thread is already joined.
        (__pthread_join): Set joiner first.
        (__pthread_detach): Ditto.
@
text
@d387 8
d420 1
d423 1
d936 1
a936 1
thread_init_wrapper (void *_arg)
d968 1
d972 1
d1562 2
a1563 1

d1568 4
a1571 1
    thread->return_ptr = value_ptr;
d1588 1
a1588 1
  if ((*thread)->attr.joinable == PTHREAD_CREATE_DETACHED)
d1592 1
a1592 1
      return EINVAL;
d1595 3
a1597 1
  else if( __pthread_equal(thread, &joiner ) )
d1601 2
a1602 1
      return EDEADLK;
a1603 1

d1608 1
d1627 1
d1630 1
d1634 11
a1644 3
  // force cleanup on exit
  (*thread)->joiner = *thread;
  (*thread)->attr.joinable = PTHREAD_CREATE_DETACHED;
@


1.70
log
@/tmp/cvs610a0efc.1
@
text
@d346 11
d358 1
a358 1
cancelstate (0), canceltype (0), joiner(NULL)
d406 35
d959 2
a960 2
  if (thread->attr.joinable == PTHREAD_CREATE_DETACHED)
    thread->joiner = __pthread_self();
d1240 1
a1240 1
  class pthread *thread = __pthread_self ();
d1251 1
a1251 1
  class pthread *thread = __pthread_self ();
d1263 1
a1263 1
  class pthread *thread = __pthread_self ();
d1544 4
a1547 1
  pthread_t thread = __pthread_self ();
d1566 1
a1566 1
   pthread_t joiner = __pthread_self();
d1588 1
a1589 1
      (*thread)->joiner = joiner;
a1612 1
  (*thread)->attr.joinable = PTHREAD_CREATE_DETACHED;
d1615 1
d1977 1
a1977 1
  pthread *thread = __pthread_self ();
a1992 5
pthread_t
__pthread_self ()
{
  return (pthread *) TlsGetValue (MT_INTERFACE->thread_self_dwTlsIndex);
}
@


1.69
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d347 1
a347 1
cancelstate (0), canceltype (0)
d384 1
d912 4
a952 1
  InterlockedIncrement (&MT_INTERFACE->threadcount);
d1498 1
a1498 1
  class pthread *thread = __pthread_self ();
d1502 6
a1507 1
  thread->return_ptr = value_ptr;
d1517 2
d1526 1
a1526 1
	*return_val = NULL;
d1529 8
d1540 1
d1543 3
a1545 1
	*return_val = (*thread)->return_ptr;
a1560 1
      (*thread)->return_ptr = NULL;
d1565 3
@


1.68
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.67
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@a39 1
#include "sigproc.h"
@


1.66
log
@2002-05-02  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc (__pthread_cond_dowait): Fix a race on signalling from a
        thread woken by the same condition variable it's signalling on. Thanks
        to Michael Beach for the report and test case.
@
text
@a39 1
#include "sync.h"
@


1.65
log
@2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

        * thread.cc (semaphore::TryWait): Set errno as required by posix 1003.1.
        (__sem_wait): Ditto.
        (__sem_trywait): Ditto.
@
text
@d1794 4
d1802 1
a1802 3
  bool last = false;
  if (InterlockedDecrement (&((*cond)->waiting)) == 0)
    last = true;
a1805 2
  if (last == true)
    (*cond)->mutex = NULL;
d1808 2
@


1.64
log
@2001-12-26  Robert Collins  <rbtcollins@@hotmail.com>

        * thread.cc (pthread_cond::Signal): Use a separate flag for signal detection
        and broadcast semantics.
        (__pthread_cond_dowait): Ditto.
        * thread.h (pthread_cond): New flag for testing when a waiter has woken.
@
text
@d810 4
a813 1
    return EAGAIN;
d2219 4
a2222 1
    return EINVAL;
d2232 4
a2235 1
    return EINVAL;
@


1.63
log
@.
@
text
@d502 3
d509 6
d517 4
a520 1
  while (InterlockedIncrement (&waiting) != (temp - 1) && spins)
d522 1
a522 1
      InterlockedDecrement (&waiting);
d526 1
a526 1
	/* we've had 5 timeslices, and the woekn thread still hasn't done it's
d531 2
a532 1
  InterlockedDecrement (&waiting);
d1798 2
@


1.62
log
@.
@
text
@@


1.61
log
@.
@
text
@@


1.60
log
@.
@
text
@@


1.59
log
@.
@
text
@@


1.58
log
@.
@
text
@@


1.57
log
@minor reformatting.
@
text
@@


1.56
log
@minor reformatting.
@
text
@@


1.55
log
@* cygwin.din (ualarm): New export.
* dcrt0.cc (_dll_crt0): Add experimental tls storage declaration.
(dll_crt0): Ditto.
* debug.cc (thread_stub): Ditto.
* thread.cc: Minor cleanup.
(__pthread_create): Add experimental tls storage declaration.
* miscfuncs.cc: Define tls index.
* winsup.h: Declare experimental tls storage.
* window.cc (alarm): Use old timer return from setitimer.
(ualarm): New function.
@
text
@d1 1
a1 1
/*thread.cc: Locking and threading module functions
d6 1
a6 1
   Substantialy enhanced by Robert Collins <<rbtcollins@@hotmail.com>
d438 1
a438 1
  next = (pthread_cond *)InterlockedExchangePointer (&MT_INTERFACE->conds, this);
d661 1
a661 1
  next = (pthread_mutex *)InterlockedExchangePointer (&MT_INTERFACE->mutexs, this);
d762 1
a762 1
  next = (semaphore *)InterlockedExchangePointer (&MT_INTERFACE->semaphores, this);
d1297 1
a1297 1
    prepcb->next = (callback *)InterlockedExchangePointer ((LONG *) &MT_INTERFACE->pthread_prepare, (long int) prepcb);
d1306 1
a1306 1
    parentcb->next = (callback *)InterlockedExchangePointer ((LONG *) t, (long int) parentcb);
d1315 1
a1315 1
    childcb->next = (callback *)InterlockedExchangePointer ((LONG *) t, (long int) childcb);
@


1.54
log
@* include/pthread.h (PTHREAD_COND_INITIALIZER): Define.
* thread.cc (__pthread_cond_destroy): Add support for
PTHREAD_COND_INITIALIZER.
(__pthread_cond_init): Ditto.
(__pthread_cond_broadcast): Ditto.
(__pthread_cond_signal): Ditto.
(__pthread_cond_dowait): Ditto.
(__pthread_mutex_init): Handle PTHREAD_MUTEX_INITIALIZER correctly,
don't return error when it's passed as parameter.
* winsup.h (check_null_invalid_struct): Call correct function.
@
text
@d292 1
a292 1
	  ("local storage for thread couldn't be set\nThis means that we are not thread safe!\n");
d326 1
a326 1
  debug_printf("mutexs is %x\n",mutexs);
d333 1
a333 1
  debug_printf("conds is %x\n",conds);
d340 1
a340 1
  debug_printf("semaphores is %x\n",semaphores);
d378 1
a378 1
  win32_obj_id =::CreateThread (&sec_none_nih, attr.stacksize,
d423 1
a423 1
  this->win32_obj_id =::CreateEvent (&sec_none_nih, false,	/*auto signal reset - which I think is pthreads like ? */
d427 1
a427 1
  cond_access=NULL;
d430 1
a430 1
      system_printf ("couldn't init mutex, this %0p errno=%d\n", this, temperr);
d464 1
a464 1
    system_printf ("Failed to lock condition variable access mutex, this %0p\n", this);
d469 1
a469 1
	system_printf ("Failed to unlock condition variable access mutex, this %0p\n", this);
d472 1
a472 1
	 system_printf ("Broadcast called with invalid mutex\n");
d479 1
a479 1
    system_printf ("Failed to unlock condition variable access mutex, this %0p\n", this);
d486 1
a486 1
    system_printf ("Failed to lock condition variable access mutex, this %0p\n", this);
d490 1
a490 1
	system_printf ("Failed to unlock condition variable access mutex, this %0p\n",
d499 1
a499 1
	system_printf ("Failed to unlock condition variable access mutex, this %0p\n", this);
d521 1
a521 1
    system_printf ("Failed to unlock condition variable access mutex, this %0p\n", this);
d566 1
a566 1
  debug_printf("cond %x in fixup_after_fork\n", this);
d568 1
a568 1
    api_fatal("doesn't understand PROCESS_SHARED condition variables\n");
d570 1
a570 1
  this->win32_obj_id =::CreateEvent (&sec_none_nih, false, false, NULL);
d572 1
a572 1
    api_fatal("failed to create new win32 mutex\n");
d575 1
a575 1
    api_fatal("Forked() while a condition variable has waiting threads.\nReport to cygwin@@cygwin.com\n");
d644 1
a644 1
  if (attr && attr->pshared==PTHREAD_PROCESS_SHARED)
d654 1
a654 1
      this->win32_obj_id =::CreateMutex (&sec_none_nih, false, NULL);
d724 1
a724 1
  debug_printf("mutex %x in fixup_after_fork\n", this);
d726 1
a726 1
    api_fatal("pthread_mutex::fixup_after_fork () doesn'tunderstand PROCESS_SHARED mutex's\n");
d729 1
a729 1
    InitializeCriticalSection(&criticalsection);
d732 1
a732 1
      win32_obj_id =::CreateMutex (&sec_none_nih, false, NULL);
d734 1
a734 1
	api_fatal("pthread_mutex::fixup_after_fork() failed to create new win32 mutex\n");
d738 1
a738 1
    api_fatal("Forked() while a mutex has condition variables waiting on it.\nReport to cygwin@@cygwin.com\n");
d755 1
a755 1
  this->win32_obj_id =::CreateSemaphore (&sec_none_nih, value, LONG_MAX,
d812 1
a812 1
  debug_printf("sem %x in fixup_after_fork\n", this);
d814 1
a814 1
    api_fatal("doesn't understand PROCESS_SHARED semaphores variables\n");
d816 1
a816 1
  this->win32_obj_id =::CreateSemaphore (&sec_none_nih, currentvalue, LONG_MAX, NULL);
d818 1
a818 1
    api_fatal("failed to create new win32 semaphore\n");
d894 1
a894 1
  /*the OS doesn't check this for <=64 Tls entries (pre win2k) */
d922 1
d1297 1
a1297 1
    prepcb->next=(callback *)InterlockedExchangePointer ((LONG *) &MT_INTERFACE->pthread_prepare, (long int) prepcb);
d1306 1
a1306 1
    parentcb->next=(callback *)InterlockedExchangePointer ((LONG *) t, (long int) parentcb);
d1315 1
a1315 1
    childcb->next=(callback *)InterlockedExchangePointer ((LONG *) t, (long int) childcb);
d1763 1
a1763 1
    system_printf ("Failed to lock condition variable access mutex, this %0p\n", *cond);
d1769 1
a1769 1
	  system_printf ("Failed to unlock condition variable access mutex, this %0p\n", *cond);
d1777 1
a1777 1
    system_printf ("Failed to unlock condition variable access mutex, this %0p\n", *cond);
d1789 1
a1789 1
    system_printf ("Failed to lock condition variable access mutex, this %0p\n", *cond);
d1792 1
a1792 1
    system_printf ("Failed to unlock condition variable access mutex, this %0p\n", *cond);
d1801 1
a1801 1
  if (check_valid_pointer(abstime))
d1805 1
a1805 1
  ftime(&currSysTime);
d1949 1
a1949 1
  pthread_mutex_t *themutex=(pthread_mutex_t *) mutex;
@


1.53
log
@Eliminate excess whitespace.
@
text
@d1679 2
d1700 1
a1700 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != INVALID_OBJECT)
d1718 2
d1731 2
d1752 2
d1931 1
a1931 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER) != INVALID_OBJECT)
@


1.52
log
@Mon Oct  1 00:34:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc (pthread_cond_dowait): Hopefully eliminate a race on multiple thread
        wakeups.
@
text
@d1770 1
a1770 1
  /* this may allow a race on the mutex acquisition and waits.. 
d1967 3
a1969 3
        {
          int rv = __pthread_mutex_init (mutex, NULL);
          if (rv)
d1971 1
a1971 1
        }
@


1.51
log
@Sat Sep 29 18:26:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * pthread.cc (pthread_cond_timedwait): Deleted - exported from thread.cc.
        (pthread_cond_wait): Deleted - exported from thread.cc.
        * thread.cc (pthread_cond::BroadCast): Update to use the new syntax for
        verifyable_object_isvalid ().
        (pthread_cond::Signal): Ditto. Also attempt to fix the lost signal race
        with pthread_cond::TimedWait().
        (check_valid_pointer): Change definiton to void const *.
        (verifyable_object_isvalid): Add new parameter to allow identification of
        static initializers, and return a enum rather than magic numbers.
        (__pthread_create): Ditto.
        (__pthread_cleanup): Ditto.
        (__pthread_attr_init): Ditto.
        (__pthread_attr_getinheritsched): Ditto.
        (__pthread_attr_getschedparam): Ditto.
        (__pthread_attr_getschedpolicy): Ditto.
        (__pthread_attr_getscope): Ditto.
        (__pthread_attr_setdetachstate): Ditto.
        (__pthread_attr_getdetachstate): Ditto.
        (__pthread_attr_setinheritsched): Ditto.
        (__pthread_attr_setschedparam): Ditto.
        (__pthread_attr_setschedpolicy): Ditto.
        (__pthread_attr_setscope): Ditto.
        (__pthread_attr_setstacksize): Ditto.
        (__pthread_attr_getstacksize): Ditto.
        (__pthread_attr_destroy): Ditto.
        (__pthread_join): Ditto.
        (__pthread_detach): Ditto.
        (__pthread_suspend): Ditto.
        (__pthread_continue): Ditto.
        (__pthread_getschedparam): Ditto.
        (__pthread_getsequence_np): Ditto.
        (__pthread_key_create): Ditto.
        (__pthread_key_delete): Ditto.
        (__pthread_setschedparam): Ditto.
        (__pthread_setspecific): Ditto.
        (__pthread_getspecific): Ditto.
        (__pthread_cond_destroy): Ditto.
        (__pthread_cond_init): Ditto.
        (__pthread_cond_broadcast): Ditto.
        (__pthread_cond_signal): Ditto.
        (__pthread_condattr_init): Ditto.
        (__pthread_condattr_getpshared): Ditto.
        (__pthread_condattr_setpshared): Ditto.
        (__pthread_condattr_destroy): Ditto.
        (__pthread_kill): Ditto.
        (__pthread_mutex_init): Ditto.
        (__pthread_mutex_getprioceiling): Ditto.
        (__pthread_mutex_lock): Ditto.
        (__pthread_mutex_trylock): Ditto.
        (__pthread_mutex_unlock): Ditto.
        (__pthread_mutex_destroy): Ditto.
        (__pthread_mutex_setprioceiling): Ditto.
        (__pthread_mutexattr_getprotocol): Ditto.
        (__pthread_mutexattr_getpshared): Ditto.
        (__pthread_mutexattr_gettype): Ditto.
        (__pthread_mutexattr_init): Ditto.
        (__pthread_mutexattr_destroy): Ditto.
        (__pthread_mutexattr_setprotocol): Ditto.
        (__pthread_mutexattr_setprioceiling): Ditto.
        (__pthread_mutexattr_getprioceiling): Ditto.
        (__pthread_mutexattr_setpshared): Ditto.
        (__pthread_mutexattr_settype): Ditto.
        (__sem_init): Ditto.
        (__sem_destroy): Ditto.
        (__sem_wait): Ditto.
        (__sem_trywait): Ditto.
        (__sem_post): Ditto.
        (__pthread_cond_dowait): New function, contains core logic from
        __pthread_cond_wait and __pthread_cond_timedwait. Decrement (*cond)->waiting
        before reentering the cond access mutex to allow detection of lost signals.
        (__pthread_cond_timedwait): Rename to pthread_cond_timedwait, and call
        __pthread_cond_dowait after calculating the wait length.
        (__pthread_cond_wait): Rename to pthread_cond_wait, and call
        __pthread_cond_dowait.
        * thread.h: New enum for use with verifyable_object_isvalid.
        Remove the extern exporting of __pthread_cond_timedwait and __pthread_cond_wait.
@
text
@d1776 2
a1777 2
  (*cond)->mutex->Lock ();
  if (last)
@


1.50
log
@Tue Sep 25 21:25:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc (pthread_cond::BroadCast): Use address with verifyable_object_isvalid().
        (pthread_cond::Signal): Ditto.
        (__pthread_create): Ditto.
        (__pthread_cleanup): Ditto.
        (__pthread_attr_init): Ditto.
        (__pthread_attr_getinheritsched): Ditto.
        (__pthread_attr_getschedparam): Ditto.
        (__pthread_attr_getschedpolicy): Ditto.
        (__pthread_attr_getscope): Ditto.
        (__pthread_attr_setdetachstate): Ditto.
        (__pthread_attr_getdetachstate): Ditto.
        (__pthread_attr_setinheritsched): Ditto.
        (__pthread_attr_setschedparam): Ditto.
        (__pthread_attr_setschedpolicy): Ditto.
        (__pthread_attr_setscope): Ditto.
        (__pthread_attr_setstacksize): Ditto.
        (__pthread_attr_getstacksize): Ditto.
        (__pthread_attr_destroy): Ditto.
        (__pthread_join): Ditto.
        (__pthread_detach): Ditto.
        (__pthread_suspend): Ditto.
        (__pthread_continue): Ditto.
        (__pthread_getschedparam): Ditto.
        (__pthread_getsequence_np): Ditto.
        (__pthread_key_create): Ditto.
        (__pthread_key_delete): Ditto.
        (__pthread_setschedparam): Ditto.
        (__pthread_setspecific): Ditto.
        (__pthread_getspecific): Ditto.
        (__pthread_cond_destroy): Ditto.
        (__pthread_cond_init): Ditto.
        (__pthread_cond_broadcast): Ditto.
        (__pthread_cond_signal): Ditto.
        (__pthread_cond_timedwait): Ditto.
        (__pthread_cond_wait): Ditto.
        (__pthread_condattr_init): Ditto.
        (__pthread_condattr_getpshared): Ditto.
        (__pthread_condattr_setpshared): Ditto.
        (__pthread_condattr_destroy): Ditto.
        (__pthread_kill): Ditto.
        (__pthread_mutex_init): Ditto.
        (__pthread_mutex_getprioceiling): Ditto.
        (__pthread_mutex_lock): Ditto.
        (__pthread_mutex_trylock): Ditto.
        (__pthread_mutex_unlock): Ditto.
        (__pthread_mutex_destroy): Ditto.
        (__pthread_mutex_setprioceiling): Ditto.
        (__pthread_mutexattr_getprotocol): Ditto.
        (__pthread_mutexattr_getpshared): Ditto.
        (__pthread_mutexattr_gettype): Ditto.
        (__pthread_mutexattr_init): Ditto.
        (__pthread_mutexattr_destroy): Ditto.
        (__pthread_mutexattr_setprotocol): Ditto.
        (__pthread_mutexattr_setprioceiling): Ditto.
        (__pthread_mutexattr_getprioceiling): Ditto.
        (__pthread_mutexattr_setpshared): Ditto.
        (__pthread_mutexattr_settype): Ditto.
        (__sem_init): Ditto.
        (__sem_destroy): Ditto.
        (__sem_wait): Ditto.
        (__sem_trywait): Ditto.
        (__sem_post): Ditto.
        (verifyable_object_isvalid): Recieve a pointer to a pointer for verification.
        (__pthread_mutexattr_getprotocol): Fix typo in magic number.
        (__pthread_mutexattr_getpshared): Ditto.
        (__pthread_mutexattr_gettype): Ditto.
        * thread.h (verifyable_object_isvalid): Change prototype to recieve a pointer to a
        pointer for verification.
        * include/pthread.h: Fix typo for __cleanup_routine_type typedef. (Contrib from Net).
@
text
@d462 1
d466 1
a466 1
  if (!verifyable_object_isvalid (&mutex, PTHREAD_MUTEX_MAGIC))
d487 1
a487 1
  if (!verifyable_object_isvalid (&mutex, PTHREAD_MUTEX_MAGIC))
d494 8
d503 17
d833 1
a833 1
check_valid_pointer (void *pointer)
d835 1
a835 1
  if (!pointer || IsBadWritePtr (pointer, sizeof (verifyable_object)))
d840 2
a841 2
int
verifyable_object_isvalid (void const * objectptr, long magic)
d845 5
a849 3
    return 0;
  if (!*object || *object == PTHREAD_MUTEX_INITIALIZER)
    return 0;
d851 1
a851 1
    return 0;
d853 8
a860 2
    return 0;
  return -1;
d922 1
a922 1
  if (attr && !verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d927 1
a927 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d971 1
a971 1
  if (!verifyable_object_isvalid (&thread, PTHREAD_MAGIC))
d1322 2
d1325 1
a1325 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1338 1
a1338 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1348 1
a1348 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1361 1
a1361 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1371 1
a1371 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1380 1
a1380 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1391 1
a1391 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1400 1
a1400 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1413 1
a1413 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1425 1
a1425 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1435 1
a1435 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1451 1
a1451 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1460 1
a1460 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1469 1
a1469 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1494 1
a1494 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1519 1
a1519 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1535 1
a1535 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1551 1
a1551 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1575 1
a1575 1
  if (!verifyable_object_isvalid (&thread, PTHREAD_MAGIC))
d1588 1
a1588 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1600 1
a1600 1
  if (verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC))
d1605 1
a1605 1
  if (!verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC))
d1617 1
a1617 1
  if (!verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC))
d1641 1
a1641 1
  if (!verifyable_object_isvalid (&thread, PTHREAD_MAGIC))
d1658 1
a1658 1
  if (!verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC))
d1667 1
a1667 1
  if (!verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC))
d1679 1
a1679 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1695 1
a1695 1
  if (attr && !verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC))
d1698 1
a1698 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1703 1
a1703 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1716 1
a1716 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1727 1
a1727 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1736 2
a1737 2
__pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex,
			  const struct timespec *abstime)
a1741 2
  if (!abstime)
    return EINVAL;
d1747 1
a1747 1
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
d1749 1
a1749 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
a1750 6
  struct timeb currSysTime;
  long waitlength;
  ftime(&currSysTime);
  waitlength = (abstime->tv_sec - currSysTime.time) *1000;
  if (waitlength < 0)
    return ETIMEDOUT;
d1770 6
d1777 2
a1780 2
  if (InterlockedDecrement (&((*cond)->waiting)) == 0)
    (*cond)->mutex = NULL;
d1788 3
a1790 2
int
__pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex)
d1792 1
a1792 9
// see cond_timedwait for notes
  int rv;
  pthread_mutex_t *themutex = mutex;
  if (*mutex == PTHREAD_MUTEX_INITIALIZER)
    __pthread_mutex_init (mutex, NULL);
  themutex = mutex;
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
    return EINVAL;
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1794 8
d1803 4
a1806 26
  if (pthread_mutex_lock (&(*cond)->cond_access))
    system_printf ("Failed to lock condition variable access mutex, this %0p\n", *cond);

  if ((*cond)->waiting)
    if ((*cond)->mutex && ((*cond)->mutex != (*themutex)))
      {
	if (pthread_mutex_unlock (&(*cond)->cond_access))
	  system_printf ("Failed to unlock condition variable access mutex, this %0p\n", *cond);
	return EINVAL;
      }
  InterlockedIncrement (&((*cond)->waiting));

  (*cond)->mutex = (*themutex);
  InterlockedIncrement (&((*themutex)->condwaits));
  if (pthread_mutex_unlock (&(*cond)->cond_access))
    system_printf ("Failed to unlock condition variable access mutex, this %0p\n", *cond);
  rv = (*cond)->TimedWait (INFINITE);
  (*cond)->mutex->Lock ();
  if (pthread_mutex_lock (&(*cond)->cond_access))
    system_printf ("Failed to lock condition variable access mutex, this %0p\n", *cond);
  if (InterlockedDecrement (&((*cond)->waiting)) == 0)
    (*cond)->mutex = NULL;
  InterlockedDecrement (&((*themutex)->condwaits));
  if (pthread_mutex_unlock (&(*cond)->cond_access))
    system_printf ("Failed to unlock condition variable access mutex, this %0p\n", *cond);
  return rv;
d1813 1
a1813 1
  if (!verifyable_object_isvalid (condattr, PTHREAD_CONDATTR_MAGIC))
d1825 1
a1825 1
  if (!verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC))
d1834 1
a1834 1
  if (!verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC))
d1848 1
a1848 1
  if (!verifyable_object_isvalid (condattr, PTHREAD_CONDATTR_MAGIC))
d1862 1
a1862 1
  if (!verifyable_object_isvalid (&thread, PTHREAD_MAGIC))
d1920 1
a1920 1
  if (attr && !verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d1923 1
a1923 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
d1927 1
a1927 1
  if (!verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
d1943 1
a1943 1
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
d1960 1
a1960 3
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
    return EINVAL;
  if (*mutex == PTHREAD_MUTEX_INITIALIZER)
d1962 13
a1974 3
      int rv = __pthread_mutex_init (mutex, NULL);
      if (rv)
	return rv;
d1986 1
a1986 1
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
d1998 1
a1998 1
  if (!verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
d2009 1
a2009 1
  if (!verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
d2028 1
a2028 1
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
d2039 1
a2039 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2048 1
a2048 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2061 1
a2061 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2075 1
a2075 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2079 1
a2079 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2091 1
a2091 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2103 1
a2103 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2113 1
a2113 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2122 1
a2122 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2130 1
a2130 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2145 1
a2145 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2158 1
a2158 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC))
d2166 1
a2166 1
  if (!verifyable_object_isvalid (sem, SEM_MAGIC))
d2178 1
a2178 1
  if (!verifyable_object_isvalid (sem, SEM_MAGIC))
d2191 1
a2191 1
  if (!verifyable_object_isvalid (sem, SEM_MAGIC))
d2201 1
a2201 1
  if (!verifyable_object_isvalid (sem, SEM_MAGIC))
d2210 1
a2210 1
  if (!verifyable_object_isvalid (sem, SEM_MAGIC))
@


1.49
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d465 1
a465 1
  if (!verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
d486 1
a486 1
  if (!verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
d815 1
a815 1
verifyable_object_isvalid (verifyable_object *object, long magic)
d817 4
a820 1
  if (!object || object == PTHREAD_MUTEX_INITIALIZER)
d822 1
a822 1
  if (check_valid_pointer (object))
d824 1
a824 1
  if (object->magic != magic)
d888 1
a888 1
  if (attr && !verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d893 1
a893 1
  if (!verifyable_object_isvalid (*thread, PTHREAD_MAGIC))
d937 1
a937 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1289 1
a1289 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1302 1
a1302 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1312 1
a1312 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1325 1
a1325 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1335 1
a1335 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1344 1
a1344 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1355 1
a1355 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1364 1
a1364 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1377 1
a1377 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1389 1
a1389 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1399 1
a1399 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1415 1
a1415 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1424 1
a1424 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1433 1
a1433 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_ATTR_MAGIC))
d1458 1
a1458 1
  if (!verifyable_object_isvalid (*thread, PTHREAD_MAGIC))
d1483 1
a1483 1
  if (!verifyable_object_isvalid (*thread, PTHREAD_MAGIC))
d1499 1
a1499 1
  if (!verifyable_object_isvalid (*thread, PTHREAD_MAGIC))
d1515 1
a1515 1
  if (!verifyable_object_isvalid (*thread, PTHREAD_MAGIC))
d1539 1
a1539 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1552 1
a1552 1
  if (!verifyable_object_isvalid (*thread, PTHREAD_MAGIC))
d1564 1
a1564 1
  if (verifyable_object_isvalid (*key, PTHREAD_KEY_MAGIC))
d1569 1
a1569 1
  if (!verifyable_object_isvalid (*key, PTHREAD_KEY_MAGIC))
d1581 1
a1581 1
  if (!verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC))
d1605 1
a1605 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1622 1
a1622 1
  if (!verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC))
d1631 1
a1631 1
  if (!verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC))
d1643 1
a1643 1
  if (!verifyable_object_isvalid (*cond, PTHREAD_COND_MAGIC))
d1659 1
a1659 1
  if (attr && !verifyable_object_isvalid (*attr, PTHREAD_CONDATTR_MAGIC))
d1662 1
a1662 1
  if (verifyable_object_isvalid (*cond, PTHREAD_COND_MAGIC))
d1667 1
a1667 1
  if (!verifyable_object_isvalid (*cond, PTHREAD_COND_MAGIC))
d1680 1
a1680 1
  if (!verifyable_object_isvalid (*cond, PTHREAD_COND_MAGIC))
d1691 1
a1691 1
  if (!verifyable_object_isvalid (*cond, PTHREAD_COND_MAGIC))
d1713 1
a1713 1
  if (!verifyable_object_isvalid (*themutex, PTHREAD_MUTEX_MAGIC))
d1715 1
a1715 1
  if (!verifyable_object_isvalid (*cond, PTHREAD_COND_MAGIC))
d1763 1
a1763 1
  if (!verifyable_object_isvalid (*themutex, PTHREAD_MUTEX_MAGIC))
d1765 1
a1765 1
  if (!verifyable_object_isvalid (*cond, PTHREAD_COND_MAGIC))
d1800 1
a1800 1
  if (!verifyable_object_isvalid (*condattr, PTHREAD_CONDATTR_MAGIC))
d1812 1
a1812 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_CONDATTR_MAGIC))
d1821 1
a1821 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_CONDATTR_MAGIC))
d1835 1
a1835 1
  if (!verifyable_object_isvalid (*condattr, PTHREAD_CONDATTR_MAGIC))
d1849 1
a1849 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1907 1
a1907 1
  if (attr && !verifyable_object_isvalid (*attr, PTHREAD_MUTEXATTR_MAGIC))
d1910 1
a1910 1
  if (verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
d1914 1
a1914 1
  if (!verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
d1930 1
a1930 1
  if (!verifyable_object_isvalid (*themutex, PTHREAD_MUTEX_MAGIC))
d1947 2
d1950 5
a1954 3
    __pthread_mutex_init (mutex, NULL);
  if (!verifyable_object_isvalid (*themutex, PTHREAD_MUTEX_MAGIC))
    return EINVAL;
d1965 1
a1965 1
  if (!verifyable_object_isvalid (*themutex, PTHREAD_MUTEX_MAGIC))
d1977 1
a1977 1
  if (!verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
d1988 1
a1988 1
  if (!verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
d2007 1
a2007 1
  if (!verifyable_object_isvalid (*themutex, PTHREAD_MUTEX_MAGIC))
d2018 1
a2018 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_MUTEX_MAGIC))
d2027 1
a2027 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_MUTEX_MAGIC))
d2040 1
a2040 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_MUTEX_MAGIC))
d2054 1
a2054 1
  if (verifyable_object_isvalid (*attr, PTHREAD_MUTEXATTR_MAGIC))
d2058 1
a2058 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_MUTEXATTR_MAGIC))
d2070 1
a2070 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_MUTEXATTR_MAGIC))
d2082 1
a2082 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_MUTEXATTR_MAGIC))
d2092 1
a2092 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_MUTEXATTR_MAGIC))
d2101 1
a2101 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_MUTEXATTR_MAGIC))
d2109 1
a2109 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_MUTEXATTR_MAGIC))
d2124 1
a2124 1
  if (!verifyable_object_isvalid (*attr, PTHREAD_MUTEXATTR_MAGIC))
d2137 1
a2137 1
  if (verifyable_object_isvalid (*sem, SEM_MAGIC))
d2145 1
a2145 1
  if (!verifyable_object_isvalid (*sem, SEM_MAGIC))
d2157 1
a2157 1
  if (!verifyable_object_isvalid (*sem, SEM_MAGIC))
d2170 1
a2170 1
  if (!verifyable_object_isvalid (*sem, SEM_MAGIC))
d2180 1
a2180 1
  if (!verifyable_object_isvalid (*sem, SEM_MAGIC))
d2189 1
a2189 1
  if (!verifyable_object_isvalid (*sem, SEM_MAGIC))
@


1.49.2.1
log
@Merged changes from HEAD
@
text
@d465 1
a465 1
  if (!verifyable_object_isvalid (&mutex, PTHREAD_MUTEX_MAGIC))
d486 1
a486 1
  if (!verifyable_object_isvalid (&mutex, PTHREAD_MUTEX_MAGIC))
d815 1
a815 1
verifyable_object_isvalid (void const * objectptr, long magic)
d817 2
a818 1
  verifyable_object **object = (verifyable_object **)objectptr;
d821 1
a821 5
  if (!*object || *object == PTHREAD_MUTEX_INITIALIZER)
    return 0;
  if (check_valid_pointer (*object))
    return 0;
  if ((*object)->magic != magic)
d885 1
a885 1
  if (attr && !verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d890 1
a890 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d934 1
a934 1
  if (!verifyable_object_isvalid (&thread, PTHREAD_MAGIC))
d1286 1
a1286 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1299 1
a1299 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1309 1
a1309 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1322 1
a1322 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1332 1
a1332 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1341 1
a1341 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1352 1
a1352 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1361 1
a1361 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1374 1
a1374 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1386 1
a1386 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1396 1
a1396 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1412 1
a1412 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1421 1
a1421 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1430 1
a1430 1
  if (!verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC))
d1455 1
a1455 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1480 1
a1480 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1496 1
a1496 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1512 1
a1512 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1536 1
a1536 1
  if (!verifyable_object_isvalid (&thread, PTHREAD_MAGIC))
d1549 1
a1549 1
  if (!verifyable_object_isvalid (thread, PTHREAD_MAGIC))
d1561 1
a1561 1
  if (verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC))
d1566 1
a1566 1
  if (!verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC))
d1578 1
a1578 1
  if (!verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC))
d1602 1
a1602 1
  if (!verifyable_object_isvalid (&thread, PTHREAD_MAGIC))
d1619 1
a1619 1
  if (!verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC))
d1628 1
a1628 1
  if (!verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC))
d1640 1
a1640 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1656 1
a1656 1
  if (attr && !verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC))
d1659 1
a1659 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1664 1
a1664 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1677 1
a1677 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1688 1
a1688 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1710 1
a1710 1
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
d1712 1
a1712 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1760 1
a1760 1
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
d1762 1
a1762 1
  if (!verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC))
d1797 1
a1797 1
  if (!verifyable_object_isvalid (condattr, PTHREAD_CONDATTR_MAGIC))
d1809 1
a1809 1
  if (!verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC))
d1818 1
a1818 1
  if (!verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC))
d1832 1
a1832 1
  if (!verifyable_object_isvalid (condattr, PTHREAD_CONDATTR_MAGIC))
d1846 1
a1846 1
  if (!verifyable_object_isvalid (&thread, PTHREAD_MAGIC))
d1904 1
a1904 1
  if (attr && !verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d1907 1
a1907 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
d1911 1
a1911 1
  if (!verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
d1927 1
a1927 1
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
d1944 3
a1946 1
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
a1947 6
  if (*mutex == PTHREAD_MUTEX_INITIALIZER)
    {
      int rv = __pthread_mutex_init (mutex, NULL);
      if (rv)
	return rv;
    }
d1958 1
a1958 1
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
d1970 1
a1970 1
  if (!verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
d1981 1
a1981 1
  if (!verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
d2000 1
a2000 1
  if (!verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC))
d2011 1
a2011 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2020 1
a2020 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2033 1
a2033 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2047 1
a2047 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2051 1
a2051 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2063 1
a2063 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2075 1
a2075 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2085 1
a2085 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2094 1
a2094 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2102 1
a2102 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2117 1
a2117 1
  if (!verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC))
d2130 1
a2130 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC))
d2138 1
a2138 1
  if (!verifyable_object_isvalid (sem, SEM_MAGIC))
d2150 1
a2150 1
  if (!verifyable_object_isvalid (sem, SEM_MAGIC))
d2163 1
a2163 1
  if (!verifyable_object_isvalid (sem, SEM_MAGIC))
d2173 1
a2173 1
  if (!verifyable_object_isvalid (sem, SEM_MAGIC))
d2182 1
a2182 1
  if (!verifyable_object_isvalid (sem, SEM_MAGIC))
@


1.49.2.2
log
@Merged changes from HEAD
@
text
@a461 1
  /* TODO: implement the same race fix as Signal has */
d465 1
a465 1
  if (verifyable_object_isvalid (&mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d486 1
a486 1
  if (verifyable_object_isvalid (&mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
a492 8
  int temp = waiting;
  if (!temp)
    /* nothing to signal */
    {
      if (pthread_mutex_unlock (&cond_access))
	system_printf ("Failed to unlock condition variable access mutex, this %0p\n", this);
      return;
    }
a493 17
  /* No one can start waiting until we release the condition access mutex */
  /* The released thread will decrement waiting when it gets a time slice...
     without waiting for the access mutex
   */
  int spins = 10;
  while (InterlockedIncrement (&waiting) != (temp - 1) && spins)
    {
      InterlockedDecrement (&waiting);
      /* give up the cpu to force a context switch. */
      Sleep (0);
      if (spins == 5)
	/* we've had 5 timeslices, and the woekn thread still hasn't done it's
	 * thing - maybe we raced it with the event? */
	PulseEvent (win32_obj_id);
      spins--;
    }
  InterlockedDecrement (&waiting);
d807 1
a807 1
check_valid_pointer (void const *pointer)
d809 1
a809 1
  if (!pointer || IsBadWritePtr ((void *) pointer, sizeof (verifyable_object)))
d814 2
a815 2
verifyable_object_state
verifyable_object_isvalid (void const * objectptr, long magic, void *static_ptr)
d819 3
a821 5
    return INVALID_OBJECT;
  if (!*object)
    return INVALID_OBJECT;
  if (static_ptr && *object == static_ptr)
    return VALID_STATIC_OBJECT;
d823 1
a823 1
    return INVALID_OBJECT;
d825 2
a826 8
    return INVALID_OBJECT;
  return VALID_OBJECT;
}

verifyable_object_state
verifyable_object_isvalid (void const * objectptr, long magic)
{
  return verifyable_object_isvalid (objectptr, magic, NULL);
d888 1
a888 1
  if (attr && verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d893 1
a893 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d937 1
a937 1
  if (verifyable_object_isvalid (&thread, PTHREAD_MAGIC) != VALID_OBJECT)
a1287 2
  if (check_valid_pointer (attr))
    return EINVAL;
d1289 1
a1289 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1302 1
a1302 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1312 1
a1312 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1325 1
a1325 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1335 1
a1335 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1344 1
a1344 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1355 1
a1355 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1364 1
a1364 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1377 1
a1377 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1389 1
a1389 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1399 1
a1399 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1415 1
a1415 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1424 1
a1424 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1433 1
a1433 1
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
d1458 1
a1458 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1483 1
a1483 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1499 1
a1499 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1515 1
a1515 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1539 1
a1539 1
  if (verifyable_object_isvalid (&thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1552 1
a1552 1
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1564 1
a1564 1
  if (verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC) == VALID_OBJECT)
d1569 1
a1569 1
  if (verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
d1581 1
a1581 1
  if (verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
d1605 1
a1605 1
  if (verifyable_object_isvalid (&thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1622 1
a1622 1
  if (verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
d1631 1
a1631 1
  if (verifyable_object_isvalid (&key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
d1643 1
a1643 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
d1659 1
a1659 1
  if (attr && verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
d1662 1
a1662 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != INVALID_OBJECT)
d1667 1
a1667 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
d1680 1
a1680 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
d1691 1
a1691 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
d1700 2
a1701 2
__pthread_cond_dowait (pthread_cond_t *cond, pthread_mutex_t *mutex,
		       long waitlength)
d1706 2
d1713 1
a1713 1
  if (verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d1715 1
a1715 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
d1717 6
a1741 6
  /* this may allow a race on the mutex acquisition and waits.. 
   * But doing this within the cond access mutex creates a different race
   */
  bool last = false;
  if (InterlockedDecrement (&((*cond)->waiting)) == 0)
    last = true;
a1742 2
  if (last)
    (*cond)->mutex = NULL;
d1745 2
d1754 2
a1755 3
extern "C" int
pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex,
			const struct timespec *abstime)
d1757 7
a1763 1
  if (check_valid_pointer(abstime))
d1765 14
a1778 8
  struct timeb currSysTime;
  long waitlength;
  ftime(&currSysTime);
  waitlength = (abstime->tv_sec - currSysTime.time) *1000;
  if (waitlength < 0)
    return ETIMEDOUT;
  return __pthread_cond_dowait (cond, mutex, waitlength);
}
d1780 14
a1793 4
extern "C" int
pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex)
{
  return __pthread_cond_dowait (cond, mutex, INFINITE);
d1800 1
a1800 1
  if (verifyable_object_isvalid (condattr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
d1812 1
a1812 1
  if (verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
d1821 1
a1821 1
  if (verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
d1835 1
a1835 1
  if (verifyable_object_isvalid (condattr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
d1849 1
a1849 1
  if (verifyable_object_isvalid (&thread, PTHREAD_MAGIC) != VALID_OBJECT)
d1907 1
a1907 1
  if (attr && verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT || check_valid_pointer (mutex))
d1910 1
a1910 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER) != INVALID_OBJECT)
d1914 1
a1914 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d1930 1
a1930 1
  if (verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d1947 3
a1949 1
  switch (verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER))
d1951 3
a1953 13
    case INVALID_OBJECT:
      return EINVAL;
      break;
    case VALID_STATIC_OBJECT:
      if (*mutex == PTHREAD_MUTEX_INITIALIZER)
        {
          int rv = __pthread_mutex_init (mutex, NULL);
          if (rv)
	    return rv;
        }
      break;
    case VALID_OBJECT:
      break;
d1965 1
a1965 1
  if (verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d1977 1
a1977 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d1988 1
a1988 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d2007 1
a2007 1
  if (verifyable_object_isvalid (themutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d2018 1
a2018 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2027 1
a2027 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2040 1
a2040 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2054 1
a2054 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != INVALID_OBJECT)
d2058 1
a2058 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2070 1
a2070 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2082 1
a2082 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2092 1
a2092 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2101 1
a2101 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2109 1
a2109 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2124 1
a2124 1
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
d2137 1
a2137 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != INVALID_OBJECT)
d2145 1
a2145 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
d2157 1
a2157 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
d2170 1
a2170 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
d2180 1
a2180 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
d2189 1
a2189 1
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
@


1.49.2.3
log
@Merged changes from HEAD
@
text
@d1776 2
a1777 2
  (*themutex)->Lock ();
  if (last == true)
@


1.49.2.4
log
@Merged changes from HEAD
@
text
@d1 1
a1 1
/* thread.cc: Locking and threading module functions
d6 1
a6 1
   Substantialy enhanced by Robert Collins <rbtcollins@@hotmail.com>
d292 1
a292 1
	  ("local storage for thread couldn't be set\nThis means that we are not thread safe!");
d326 1
a326 1
  debug_printf ("mutexs is %x",mutexs);
d333 1
a333 1
  debug_printf ("conds is %x",conds);
d340 1
a340 1
  debug_printf ("semaphores is %x",semaphores);
d378 1
a378 1
  win32_obj_id = ::CreateThread (&sec_none_nih, attr.stacksize,
d423 1
a423 1
  this->win32_obj_id = ::CreateEvent (&sec_none_nih, false,	/*auto signal reset - which I think is pthreads like ? */
d427 1
a427 1
  cond_access = NULL;
d430 1
a430 1
      system_printf ("couldn't init mutex, this %p errno %d", this, temperr);
d438 1
a438 1
  next = (pthread_cond *) InterlockedExchangePointer (&MT_INTERFACE->conds, this);
d464 1
a464 1
    system_printf ("Failed to lock condition variable access mutex, this %p", this);
d469 1
a469 1
	system_printf ("Failed to unlock condition variable access mutex, this %p", this);
d472 1
a472 1
	 system_printf ("Broadcast called with invalid mutex");
d479 1
a479 1
    system_printf ("Failed to unlock condition variable access mutex, this %p", this);
d486 1
a486 1
    system_printf ("Failed to lock condition variable access mutex, this %p", this);
d490 1
a490 1
	system_printf ("Failed to unlock condition variable access mutex, this %p",
d499 1
a499 1
	system_printf ("Failed to unlock condition variable access mutex, this %p", this);
a501 3
  /* Prime the detection flag */
  ExitingWait = 1;
  /* Signal any waiting thread */
a505 6
   * InterLockedIncrement on 98 +, NT4 + returns the incremented value.
   * On 95, nt 3.51 < it returns a sign correct number - 0=0, + for greater than 0, -
   * for less than 0.
   * Because of this we cannot spin on the waiting count, but rather we need a
   * dedicated flag for a thread exiting the Wait function.
   * Also not that Interlocked* sync CPU caches with memory.
d508 1
a508 4
  /* When ExitingWait is nonzero after a decrement, the leaving thread has
   * done it's thing
   */
  while (InterlockedDecrement (&ExitingWait) == 0 && spins)
d510 1
a510 1
      InterlockedIncrement (&ExitingWait);
d514 1
a514 1
	/* we've had 5 timeslices, and the woken thread still hasn't done it's
d519 1
a519 2
  if (waiting + 1 != temp)
    system_printf ("Released too many threads - %d now %d originally", waiting, temp);
d521 1
a521 1
    system_printf ("Failed to unlock condition variable access mutex, this %p", this);
d566 1
a566 1
  debug_printf ("cond %x in fixup_after_fork", this);
d568 1
a568 1
    api_fatal ("doesn't understand PROCESS_SHARED condition variables");
d570 1
a570 1
  this->win32_obj_id = ::CreateEvent (&sec_none_nih, false, false, NULL);
d572 1
a572 1
    api_fatal ("failed to create new win32 mutex");
d575 1
a575 1
    api_fatal ("Forked () while a condition variable has waiting threads.\nReport to cygwin@@cygwin.com");
d644 1
a644 1
  if (attr && attr->pshared == PTHREAD_PROCESS_SHARED)
d654 1
a654 1
      this->win32_obj_id = ::CreateMutex (&sec_none_nih, false, NULL);
d661 1
a661 1
  next = (pthread_mutex *) InterlockedExchangePointer (&MT_INTERFACE->mutexs, this);
d724 1
a724 1
  debug_printf ("mutex %x in fixup_after_fork", this);
d726 1
a726 1
    api_fatal ("pthread_mutex::fixup_after_fork () doesn'tunderstand PROCESS_SHARED mutex's");
d729 1
a729 1
    InitializeCriticalSection (&criticalsection);
d732 1
a732 1
      win32_obj_id = ::CreateMutex (&sec_none_nih, false, NULL);
d734 1
a734 1
	api_fatal ("pthread_mutex::fixup_after_fork () failed to create new win32 mutex");
d738 1
a738 1
    api_fatal ("Forked () while a mutex has condition variables waiting on it.\nReport to cygwin@@cygwin.com");
d755 1
a755 1
  this->win32_obj_id = ::CreateSemaphore (&sec_none_nih, value, LONG_MAX,
d762 1
a762 1
  next = (semaphore *) InterlockedExchangePointer (&MT_INTERFACE->semaphores, this);
d812 1
a812 1
  debug_printf ("sem %x in fixup_after_fork", this);
d814 1
a814 1
    api_fatal ("doesn't understand PROCESS_SHARED semaphores variables");
d816 1
a816 1
  this->win32_obj_id = ::CreateSemaphore (&sec_none_nih, currentvalue, LONG_MAX, NULL);
d818 1
a818 1
    api_fatal ("failed to create new win32 semaphore");
d894 1
a894 1
  /*the OS doesn't check this for <= 64 Tls entries (pre win2k) */
a921 1
  DECLARE_TLS_STORAGE;
d1296 1
a1296 1
    prepcb->next = (callback *) InterlockedExchangePointer ((LONG *) &MT_INTERFACE->pthread_prepare, (long int) prepcb);
d1305 1
a1305 1
    parentcb->next = (callback *) InterlockedExchangePointer ((LONG *) t, (long int) parentcb);
d1314 1
a1314 1
    childcb->next = (callback *) InterlockedExchangePointer ((LONG *) t, (long int) childcb);
a1678 2
  if (check_valid_pointer (cond) && (*cond == PTHREAD_COND_INITIALIZER))
    return 0;
d1698 1
a1698 1
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER) == VALID_OBJECT)
a1715 2
  if (*cond == PTHREAD_COND_INITIALIZER)
    __pthread_cond_init (cond, NULL);
a1726 2
  if (*cond == PTHREAD_COND_INITIALIZER)
    __pthread_cond_init (cond, NULL);
a1745 2
  if (*cond == PTHREAD_COND_INITIALIZER)
    __pthread_cond_init (cond, NULL);
d1754 1
a1754 1
    system_printf ("Failed to lock condition variable access mutex, this %p", *cond);
d1760 1
a1760 1
	  system_printf ("Failed to unlock condition variable access mutex, this %p", *cond);
d1768 1
a1768 1
    system_printf ("Failed to unlock condition variable access mutex, this %p", *cond);
d1770 1
a1770 1
  /* this may allow a race on the mutex acquisition and waits..
a1775 2
  /* Tell Signal that we have been released */
  InterlockedDecrement (&((*cond)->ExitingWait));
d1780 1
a1780 1
    system_printf ("Failed to lock condition variable access mutex, this %p", *cond);
d1783 1
a1783 1
    system_printf ("Failed to unlock condition variable access mutex, this %p", *cond);
d1792 1
a1792 1
  if (check_valid_pointer (abstime))
d1796 1
a1796 1
  ftime (&currSysTime);
d1923 1
a1923 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER) == VALID_OBJECT)
d1940 1
a1940 1
  pthread_mutex_t *themutex = (pthread_mutex_t *) mutex;
d1967 3
a1969 3
	{
	  int rv = __pthread_mutex_init (mutex, NULL);
	  if (rv)
d1971 1
a1971 1
	}
@


1.49.2.5
log
@Merged changes from HEAD
@
text
@d810 1
a810 4
    {
      set_errno (EAGAIN);
      return -1;
    }
d2216 1
a2216 4
    {
      set_errno (EINVAL);
      return -1;
    }
d2226 1
a2226 4
    {
      set_errno (EINVAL);
      return -1;
    }
@


1.49.2.6
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d40 2
a347 11
/* pthread calls */

/* static methods */

pthread *
pthread::self ()
{
  return (pthread *) TlsGetValue (MT_INTERFACE->thread_self_dwTlsIndex);
}

/* member methods */
d349 1
a349 1
cancelstate (0), canceltype (0), joiner (NULL), cleanup_handlers(NULL) 
a377 8
  if (verifyable_object_isvalid (&mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
    {
      thread_printf ("New thread object access mutex is not valid. this %p",
		     this);
      magic = 0;
      return;
    }

a385 1
      InterlockedIncrement (&MT_INTERFACE->threadcount);
a395 37
void
pthread::push_cleanup_handler (__pthread_cleanup_handler *handler)
{
  if (this != self ())
    // TODO: do it?
    api_fatal ("Attempt to push a cleanup handler across threads"); 
  mutex.Lock();
  handler->next = cleanup_handlers;
  cleanup_handlers = handler;
  mutex.UnLock();
}

void
pthread::pop_cleanup_handler (int const execute)
{
  if (this != self ())
    // TODO: send a signal or something to the thread ?
    api_fatal ("Attempt to execute a cleanup handler across threads");
  
  if (cleanup_handlers != NULL )
    {
      __pthread_cleanup_handler *handler = cleanup_handlers;

      if (execute)
	 (*handler->function) (handler->arg);

      cleanup_handlers = handler->next;
    }
}

void
pthread::pop_all_cleanup_handlers ()
{
  while (cleanup_handlers != NULL)
    pop_cleanup_handler (1);
}

d881 1
a881 1
pthread::thread_init_wrapper (void *_arg)
a912 6
  thread->mutex.Lock();
  // if thread is detached force cleanup on exit
  if (thread->attr.joinable == PTHREAD_CREATE_DETACHED && thread->joiner == NULL)
    thread->joiner = pthread::self ();
  thread->mutex.UnLock();

d950 1
d1192 1
a1192 1
  class pthread *thread = pthread::self ();
d1203 1
a1203 1
  class pthread *thread = pthread::self ();
d1215 1
a1215 1
  class pthread *thread = pthread::self ();
d1496 1
a1496 4
  pthread * thread = pthread::self ();

  // run cleanup handlers
  thread->pop_all_cleanup_handlers();
a1498 10
  
  thread->mutex.Lock();
  // cleanup if thread is in detached state and not joined
  if( __pthread_equal(&thread->joiner, &thread ) )
    delete thread;
  else
    {  
      thread->return_ptr = value_ptr;
      thread->mutex.UnLock();
    }
d1500 1
a1509 2
   pthread_t joiner = pthread::self ();

d1514 1
a1514 10
  if ( joiner == *thread)    
    {
      if (return_val)
        *return_val = NULL;
      return EDEADLK;
    }

  (*thread)->mutex.Lock ();

  if((*thread)->attr.joinable == PTHREAD_CREATE_DETACHED)
d1517 1
a1517 2
        *return_val = NULL;
      (*thread)->mutex.UnLock ();
a1521 1
      (*thread)->joiner = joiner;
a1522 1
      (*thread)->mutex.UnLock ();
d1525 1
a1525 3
         *return_val = (*thread)->return_ptr;
      // cleanup
      delete (*thread);
a1538 1
  (*thread)->mutex.Lock ();
d1541 1
a1541 1
      (*thread)->mutex.UnLock ();
d1545 1
a1545 12
  // check if thread is still alive
  if (WAIT_TIMEOUT == WaitForSingleObject ((*thread)->win32_obj_id, 0) )
    {
      // force cleanup on exit
      (*thread)->joiner = *thread;
      (*thread)->attr.joinable = PTHREAD_CREATE_DETACHED;
      (*thread)->mutex.UnLock ();
    }
  else
    // thread has already terminated.
      delete (*thread);

a1793 4
  /* At this point calls to Signal will progress evebn if we aren' yet waiting
   * However, the loop there should allow us to get scheduled and call wait,
   * and have them call PulseEvent again if we dont' respond.
   */
d1798 3
a1800 1
  InterlockedDecrement (&((*cond)->waiting));
d1804 2
a1807 2
  if ((*cond)->waiting == 0)
    (*cond)->mutex = NULL;
d1904 1
a1904 1
  pthread *thread = pthread::self ();
d1920 5
@


1.49.2.7
log
@Merged changes from HEAD
@
text
@d1591 1
a1591 1
	*return_val = NULL;
d1600 1
a1600 1
	*return_val = NULL;
d1611 1
a1611 1
	 *return_val = (*thread)->return_ptr;
@


1.49.2.8
log
@correct merge
@
text
@d358 1
a358 1
                    cancelstate (0), canceltype (0), joiner (NULL), cleanup_stack(NULL) 
a372 2
  pthread_mutex *verifyable_mutex_obj = &mutex;

d387 1
a387 1
  if (verifyable_object_isvalid (&verifyable_mutex_obj, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d420 4
a423 2
  handler->next = cleanup_stack;
  InterlockedExchangePointer( &cleanup_stack, handler );
d433 1
a433 1
  if (cleanup_stack != NULL)
d435 1
a435 1
      __pthread_cleanup_handler *handler = cleanup_stack;
d438 3
a440 2
        (*handler->function) (handler->arg);
      cleanup_stack = handler->next;
d447 1
a447 1
  while (cleanup_stack != NULL)
a1017 4
  // already done ?
  if (once_control->state)
    return 0;

d1025 1
a1025 1
  if (!once_control->state)
d1559 1
a1559 1
  thread->pop_all_cleanup_handlers ();
a1583 4
   // Initialize return val with NULL
   if (return_val)
     *return_val = NULL;

d1588 6
a1593 2
  if (__pthread_equal(thread,&joiner))
    return EDEADLK;
d1599 2
d1643 1
a1643 3
    {
      // thread has already terminated.
      (*thread)->mutex.UnLock ();
a1644 1
    }
@


1.49.2.9
log
@Merged changes from HEAD
@
text
@d402 1
a402 4
    {
      thread_printf ("CreateThread failed: this %p LastError %E", this);
      magic = 0;
    }
@


1.49.2.10
log
@Merged changes from HEAD
@
text
@d358 1
a358 2
                    cancelstate (0), canceltype (0), cancel_event(0),
                    joiner (NULL), cleanup_stack(NULL) 
a365 2
  if (cancel_event)
    CloseHandle (cancel_event);
a396 9
  cancel_event = ::CreateEvent (NULL,TRUE,FALSE,NULL);
  if (!cancel_event)
    {
      system_printf ("couldn't create cancel event, this %p LastError %d", this, GetLastError () );
      /*we need the event for correct behaviour */
      magic = 0;
      return;
    }

a419 298
pthread::exit (void *value_ptr)
{
  class pthread *thread = this;

  // run cleanup handlers
  pop_all_cleanup_handlers ();

  MT_INTERFACE->destructors.IterateNull ();

  mutex.Lock ();
  // cleanup if thread is in detached state and not joined
  if( __pthread_equal(&joiner, &thread ) )
    delete this;
  else
    {  
      return_ptr = value_ptr;
      mutex.UnLock ();
    }

  if (InterlockedDecrement (&MT_INTERFACE->threadcount) == 0)
    ::exit (0);
  else
    ExitThread (0);
}

int
pthread::cancel (void)
{
  class pthread *thread = this;
  class pthread *self = pthread::self ();

  mutex.Lock ();

  if (canceltype == PTHREAD_CANCEL_DEFERRED ||
      cancelstate == PTHREAD_CANCEL_DISABLE)
    {
      // cancel deferred
      mutex.UnLock ();
      SetEvent (cancel_event);
      return 0;
    }

  else if (__pthread_equal(&thread, &self))
    {
      mutex.UnLock ();
      cancel_self ();
      return 0; // Never reached
    }

  // cancel asynchronous
  SuspendThread (win32_obj_id);
  if (WaitForSingleObject (win32_obj_id, 0) == WAIT_TIMEOUT)
    {
      CONTEXT context;
      context.ContextFlags = CONTEXT_CONTROL;
      GetThreadContext (win32_obj_id, &context);
      context.Eip = (DWORD) pthread::static_cancel_self;
      SetThreadContext (win32_obj_id, &context);
    }
  mutex.UnLock ();
  ResumeThread (win32_obj_id);

  return 0;
/*
  TODO: insert  pthread_testcancel into the required functions
  the required function list is: *indicates done, X indicates not present in cygwin.
aio_suspend ()
*close ()
*creat ()
fcntl ()
fsync ()
getmsg ()
getpmsg ()
lockf ()
mq_receive ()
mq_send ()
msgrcv ()
msgsnd ()
msync ()
nanosleep ()
open ()
pause ()
poll ()
pread ()
pthread_cond_timedwait ()
pthread_cond_wait ()
*pthread_join ()
pthread_testcancel ()
putmsg ()
putpmsg ()
pwrite ()
read ()
readv ()
select ()
sem_wait ()
sigpause ()
sigsuspend ()
sigtimedwait ()
sigwait ()
sigwaitinfo ()
*sleep ()
system ()
tcdrain ()
*usleep ()
wait ()
wait3()
waitid ()
waitpid ()
write ()
writev ()

the optional list is:
catclose ()
catgets ()
catopen ()
closedir ()
closelog ()
ctermid ()
dbm_close ()
dbm_delete ()
dbm_fetch ()
dbm_nextkey ()
dbm_open ()
dbm_store ()
dlclose ()
dlopen ()
endgrent ()
endpwent ()
endutxent ()
fclose ()
fcntl ()
fflush ()
fgetc ()
fgetpos ()
fgets ()
fgetwc ()
fgetws ()
fopen ()
fprintf ()
fputc ()
fputs ()
fputwc ()
fputws ()
fread ()
freopen ()
fscanf ()
fseek ()
fseeko ()
fsetpos ()
ftell ()
ftello ()
ftw ()
fwprintf ()
fwrite ()
fwscanf ()
getc ()
getc_unlocked ()
getchar ()
getchar_unlocked ()
getcwd ()
getdate ()
getgrent ()
getgrgid ()
getgrgid_r ()
getgrnam ()
getgrnam_r ()
getlogin ()
getlogin_r ()
getpwent ()
*getpwnam ()
*getpwnam_r ()
*getpwuid ()
*getpwuid_r ()
gets ()
getutxent ()
getutxid ()
getutxline ()
getw ()
getwc ()
getwchar ()
getwd ()
glob ()
iconv_close ()
iconv_open ()
ioctl ()
lseek ()
mkstemp ()
nftw ()
opendir ()
openlog ()
pclose ()
perror ()
popen ()
printf ()
putc ()
putc_unlocked ()
putchar ()
putchar_unlocked ()
puts ()
pututxline ()
putw ()
putwc ()
putwchar ()
readdir ()
readdir_r ()
remove ()
rename ()
rewind ()
rewinddir ()
scanf ()
seekdir ()
semop ()
setgrent ()
setpwent ()
setutxent ()
strerror ()
syslog ()
tmpfile ()
tmpnam ()
ttyname ()
ttyname_r ()
ungetc ()
ungetwc ()
unlink ()
vfprintf ()
vfwprintf ()
vprintf ()
vwprintf ()
wprintf ()
wscanf ()

Note, that for fcntl (), for any value of the cmd argument.

And we must not introduce cancellation points anywhere else that's part of the posix or
opengroup specs.
 */
}

void
pthread::testcancel (void)
{
  if (cancelstate == PTHREAD_CANCEL_DISABLE)
    return;

  if( WAIT_OBJECT_0 == WaitForSingleObject (cancel_event, 0 ) )
    cancel_self ();
}

void
pthread::static_cancel_self (void)
{
  pthread::self()->cancel_self ();
}


int
pthread::setcancelstate (int state, int *oldstate)
{
  int result = 0;

  mutex.Lock ();

  if (state != PTHREAD_CANCEL_ENABLE && state != PTHREAD_CANCEL_DISABLE)
    result = EINVAL;
  else
    {
      if (oldstate)
        *oldstate = cancelstate;
      cancelstate = state;
    }

  mutex.UnLock ();

  return result;
}

int
pthread::setcanceltype (int type, int *oldtype)
{
  int result = 0;

  mutex.Lock ();

  if (type != PTHREAD_CANCEL_DEFERRED && type != PTHREAD_CANCEL_ASYNCHRONOUS)
    result = EINVAL;
  else
    {
      if (oldtype)
        *oldtype = canceltype;
      canceltype = type;
    }

  mutex.UnLock ();

  return result;
}

void
a435 2
  mutex.Lock ();

a443 2

  mutex.UnLock ();
d970 1
a970 1
  thread->mutex.Lock ();
d974 1
a974 1
  thread->mutex.UnLock ();
d987 1
a987 1
  thread->exit (ret);
d1041 10
d1056 192
d1249 37
a1285 1
  return thread->cancel ();
d1557 26
@


1.49.2.11
log
@Merged changes from HEAD
@
text
@d286 1
a290 2
      else
	indexallocated = (-1);
d296 4
a299 1
  pthread::initMainThread(&mainthread, myself->hProcess);
a348 7
void
pthread::initMainThread(pthread *mainThread, HANDLE win32_obj_id)
{
  mainThread->win32_obj_id = win32_obj_id;
  mainThread->setThreadIdtoCurrent ();
  setTlsSelfPointer(mainThread);
}
d353 1
a353 18
  pthread *temp = (pthread *) TlsGetValue (MT_INTERFACE->thread_self_dwTlsIndex);
  if (temp)
      return temp;
  temp = new pthread ();
  temp->precreate (NULL);
  if (!temp->magic) {
      delete temp;
      return pthreadNull::getNullpthread();
  }
  temp->postcreate ();
  return temp;
}

void
pthread::setTlsSelfPointer(pthread *thisThread)
{
  /*the OS doesn't check this for <= 64 Tls entries (pre win2k) */
  TlsSetValue (MT_INTERFACE->thread_self_dwTlsIndex, thisThread);
d358 2
a359 2
		    cancelstate (0), canceltype (0), cancel_event(0),
		    joiner (NULL), cleanup_stack(NULL)
a370 5
void
pthread::setThreadIdtoCurrent ()
{
  thread_id = GetCurrentThreadId ();
}
d373 2
a374 1
pthread::precreate (pthread_attr *newattr)
d389 2
a407 11
}

void
pthread::create (void *(*func) (void *), pthread_attr *newattr,
		 void *threadarg)
{
  precreate (newattr);
  if (!magic)
      return;
   function = func;
   arg = threadarg;
d418 9
a426 2
  else {
      postcreate ();
d428 1
a428 13
  }
}

void
pthread::postcreate ()
{
    InterlockedIncrement (&MT_INTERFACE->threadcount);
    /*FIXME: set the priority appropriately for system contention scope */
    if (attr.inheritsched == PTHREAD_EXPLICIT_SCHED)
      {
	/*FIXME: set the scheduling settings for the new thread */
	/*sched_thread_setparam (win32_obj_id, attr.schedparam); */
      }
d446 1
a446 1
    {
a450 3
  /* Prevent DLL_THREAD_DETACH Attempting to clean us up */
  setTlsSelfPointer(0);

d699 1
a699 1
	*oldstate = cancelstate;
d720 1
a720 1
	*oldtype = canceltype;
d734 1
a734 1
    api_fatal ("Attempt to push a cleanup handler across threads");
d745 1
a745 1

d753 1
a753 1
	(*handler->function) (handler->arg);
a766 12
void
pthread::cancel_self()
{
  exit (PTHREAD_CANCELED);
}

DWORD
pthread::getThreadId()
{
  return thread_id;
}

d1281 2
a1282 1
  setTlsSelfPointer(thread);
a1310 14
bool
pthread::isGoodObject (pthread_t *thread)
{
  if (verifyable_object_isvalid (thread, PTHREAD_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

unsigned long
pthread::getsequence_np ()
{
  return getThreadId ();
}

d1321 1
a1321 1
  if (!pthread::isGoodObject (thread))
d1358 1
a1358 1
  if (!pthread::isGoodObject (&thread))
d1645 1
a1645 1
  if (!pthread::isGoodObject (thread))
d1678 1
a1678 1
  if (!pthread::isGoodObject (thread))
d1709 1
a1709 1
  if (!pthread::isGoodObject (thread))
d1725 1
a1725 1
  if (!pthread::isGoodObject (thread))
d1749 1
a1749 1
  if (!pthread::isGoodObject (&thread))
d1758 9
d1815 1
a1815 1
  if (!pthread::isGoodObject (&thread))
d2048 1
a2048 1
  if (!pthread::isGoodObject (&thread))
a2402 69

/* pthreadNull */
pthread *
pthreadNull::getNullpthread()
{
  /* because of weird entry points */
  _instance.magic = 0;
  return &_instance;
}

pthreadNull::pthreadNull()
{
  /* Mark ourselves as invalid */
  magic = 0;
}

pthreadNull::~pthreadNull()
{
}

void
pthreadNull::create (void *(*)(void *), pthread_attr *, void *)
{
}

void
pthreadNull::exit (void *value_ptr)
{
}

int
pthreadNull::cancel ()
{
  return 0;
}

void
pthreadNull::testcancel ()
{
}

int
pthreadNull::setcancelstate (int state, int *oldstate)
{
  return EINVAL;
}

int
pthreadNull::setcanceltype (int type, int *oldtype)
{
  return EINVAL;
}

void
pthreadNull::push_cleanup_handler (__pthread_cleanup_handler *handler)
{
}

void
pthreadNull::pop_cleanup_handler (int const execute)
{
}
unsigned long
pthreadNull::getsequence_np()
{
  return 0;
}

pthreadNull pthreadNull::_instance = pthreadNull ();
@


1.49.2.12
log
@Merged changes from HEAD
@
text
@d297 1
a297 1
  pthread::initMainThread (&mainthread, myself->hProcess);
a316 6
void
MTinterface::fixup_before_fork (void)
{
  pthread_key::fixup_before_fork ();
}

a320 1
  pthread_key::fixup_after_fork ();
d348 1
a348 1
pthread::initMainThread (pthread *mainThread, HANDLE win32_obj_id)
d352 1
a352 1
  setTlsSelfPointer (mainThread);
d365 1
a365 1
      return pthreadNull::getNullpthread ();
d372 1
a372 1
pthread::setTlsSelfPointer (pthread *thisThread)
a377 2


d380 2
a381 2
                    cancelstate (0), canceltype (0), cancel_event (0),
                    joiner (NULL), cleanup_stack (NULL) 
d483 1
a483 1
  if (__pthread_equal (&joiner, &thread ) )
d492 1
a492 1
  setTlsSelfPointer (0);
d517 1
a517 1
  else if (__pthread_equal (&thread, &self))
d719 1
a719 1
  if (WAIT_OBJECT_0 == WaitForSingleObject (cancel_event, 0 ) )
d726 1
a726 1
  pthread::self ()->cancel_self ();
d779 1
a779 1
  InterlockedExchangePointer (&cleanup_stack, handler );
d811 1
a811 1
pthread::cancel_self ()
d817 1
a817 1
pthread::getThreadId ()
a1020 29
/* pthread_key */
/* static members */
pthread_key *pthread_key::keys = NULL;

void
pthread_key::fixup_before_fork ()
{
  pthread_key *key = keys;
  debug_printf ("keys is %x",keys);
  while (key)
    {
      key->saveKeyToBuffer ();
      key = key->next;
    }
}

void
pthread_key::fixup_after_fork ()
{
  pthread_key *key = keys;
  debug_printf ("keys is %x",keys);
  while (key)
    {
      key->recreateKeyFromBuffer ();
      key = key->next;
    }
}

/* non-static members */
a1031 2
  /* threadsafe addition is easy */
  next = (pthread_key *) InterlockedExchangePointer (&keys, this);
a1038 12

  /* I'm not 100% sure the next bit is threadsafe. I think it is... */
  if (keys == this)
    InterlockedExchangePointer (keys, this->next);
  else
    {
      pthread_key *tempkey = keys;
      while (tempkey->next && tempkey->next != this)
        tempkey = tempkey->next;
      /* but there may be a race between the loop above and this statement */
      InterlockedExchangePointer (&tempkey->next, this->next);
    }
a1055 15
void
pthread_key::saveKeyToBuffer ()
{
  fork_buf = get ();
}

void
pthread_key::recreateKeyFromBuffer ()
{
  dwTlsIndex = TlsAlloc ();
  if (dwTlsIndex == TLS_OUT_OF_INDEXES)
    api_fatal ("pthread_key::recreateKeyFromBuffer () failed to reallocate Tls storage");
  set (fork_buf);
}

d1314 1
a1314 1
  struct _reent local_clib = _REENT_INIT (local_clib);
d1336 1
a1336 1
  setTlsSelfPointer (thread);
d1451 1
a1451 1
pthread::atforkprepare (void)
a1452 2
  MT_INTERFACE->fixup_before_fork ();

d1462 1
a1462 1
pthread::atforkparent (void)
d1473 1
a1473 1
pthread::atforkchild (void)
a1474 2
  MT_INTERFACE->fixup_after_fork ();

d1716 1
a1716 1
  if (__pthread_equal (thread,&joiner))
d1721 1
a1721 1
  if ((*thread)->attr.joinable == PTHREAD_CREATE_DETACHED)
d2465 1
a2465 1
pthreadNull::getNullpthread ()
d2472 1
a2472 1
pthreadNull::pthreadNull ()
d2478 1
a2478 1
pthreadNull::~pthreadNull ()
d2525 1
a2525 1
pthreadNull::getsequence_np ()
@


1.49.2.13
log
@Merged changes from HEAD
@
text
@d1104 2
a1105 4
  int savedError = ::GetLastError();
  void *result = TlsGetValue (dwTlsIndex);
  ::SetLastError (savedError);
  return result;
@


1.49.2.14
log
@Merged changes from HEAD
@
text
@d390 1
a390 1
                    joiner (NULL), cleanup_stack (NULL)
@


1.49.2.15
log
@Merged changes from HEAD
@
text
@d255 12
d273 6
d283 1
d306 9
d425 1
a425 1
  if (!pthread_mutex::isGoodObject(&verifyable_mutex_obj))
a830 11
/* static members */
bool
pthread_attr::isGoodObject (pthread_attr_t const *attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_ATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

/* instance members */

d901 1
a901 1
  if (!pthread_mutex::isGoodObject (&mutex))
d922 1
a922 1
  if (!pthread_mutex::isGoodObject (&mutex))
a1057 8
bool
pthread_key::isGoodObject (pthread_key_t const *key)
{
  if (verifyable_object_isvalid (key, PTHREAD_KEY_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

a1148 17
/* static members */
bool
pthread_mutex::isGoodObject (pthread_mutex_t const *thread)
{
  if (verifyable_object_isvalid (thread, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

bool
pthread_mutex::isGoodInitializerOrObject (pthread_mutex_t const *thread)
{
  if (verifyable_object_isvalid (thread, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER) != VALID_OBJECT)
    return false;
  return true;
}

d1435 1
a1435 1
pthread::isGoodObject (pthread_t const *thread)
d1453 1
a1453 1
  if (attr && !pthread_attr::isGoodObject (attr))
d1625 1
a1625 1
  if (!pthread_attr::isGoodObject (attr))
d1638 1
a1638 1
  if (!pthread_attr::isGoodObject (attr))
d1648 1
a1648 1
  if (!pthread_attr::isGoodObject (attr))
d1661 1
a1661 1
  if (!pthread_attr::isGoodObject (attr))
d1671 1
a1671 1
  if (!pthread_attr::isGoodObject (attr))
d1680 1
a1680 1
  if (!pthread_attr::isGoodObject (attr))
d1691 1
a1691 1
  if (!pthread_attr::isGoodObject (attr))
d1700 1
a1700 1
  if (!pthread_attr::isGoodObject (attr))
d1713 1
a1713 1
  if (!pthread_attr::isGoodObject (attr))
d1725 1
a1725 1
  if (!pthread_attr::isGoodObject (attr))
d1735 1
a1735 1
  if (!pthread_attr::isGoodObject (attr))
d1751 1
a1751 1
  if (!pthread_attr::isGoodObject (attr))
d1760 1
a1760 1
  if (!pthread_attr::isGoodObject (attr))
d1769 1
a1769 1
  if (!pthread_attr::isGoodObject (attr))
d1906 1
a1906 1
  if (pthread_key::isGoodObject (key))
d1911 1
a1911 1
  if (!pthread_key::isGoodObject (key))
d1923 1
a1923 1
  if (!pthread_key::isGoodObject (&key))
d1964 1
a1964 1
  if (!pthread_key::isGoodObject (&key))
d1973 1
a1973 1
  if (!pthread_key::isGoodObject (&key))
d2061 1
a2061 1
  if (!pthread_mutex::isGoodObject (themutex))
d2236 1
a2236 1
  if (pthread_mutex::isGoodInitializerOrObject (mutex))
d2240 1
a2240 1
  if (!pthread_mutex::isGoodObject (mutex))
d2256 1
a2256 1
  if (!pthread_mutex::isGoodObject (themutex))
d2299 1
a2299 1
  if (!pthread_mutex::isGoodObject (themutex))
d2311 1
a2311 1
  if (!pthread_mutex::isGoodObject (mutex))
d2322 1
a2322 1
  if (!pthread_mutex::isGoodObject (mutex)) 
d2341 1
a2341 1
  if (!pthread_mutex::isGoodObject (themutex))
@


1.49.2.16
log
@Merged changes from HEAD
@
text
@d49 86
d460 1
a460 1
  pthread_key::runAllDestructors ();
a824 8
bool
pthread_condattr::isGoodObject (pthread_condattr_t const *attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_CONDATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

d1015 1
a1015 7
List<pthread_key> pthread_key::keys;

void
pthread_key::saveAKey (pthread_key *key)
{
  key->saveKeyToBuffer ();
}
d1020 7
a1026 7
  keys.forEach (saveAKey);
}

void
pthread_key::restoreAKey (pthread_key *key)
{
  key->recreateKeyFromBuffer ();
d1032 7
a1038 13
  keys.forEach (restoreAKey);
}

void
pthread_key::destroyAKey (pthread_key *key)
{
  key->run_destructor ();
}

void
pthread_key::runAllDestructors ()
{
  keys.forEach (destroyAKey);
d1051 1
a1051 1
pthread_key::pthread_key (void (*aDestructor) (void *)):verifyable_object (PTHREAD_KEY_MAGIC), destructor (aDestructor)
d1056 7
a1062 2
  else
    keys.Insert (this);
d1067 8
a1074 3
  /* We may need to make the list code lock the list during operations
   */
  if (magic != 0) 
d1076 5
a1080 2
      keys.Remove (this);
      TlsFree (dwTlsIndex);
d1093 1
a1093 1
pthread_key::get () const
a1115 7
void
pthread_key::run_destructor () const
{
  if (destructor)
    destructor (get());
}

d1142 1
a1142 1
pthread_mutex::isGoodObject (pthread_mutex_t const *mutex)
d1144 1
a1144 1
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC) != VALID_OBJECT)
d1150 1
a1150 1
pthread_mutex::isGoodInitializer (pthread_mutex_t const *mutex)
d1152 1
a1152 9
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER) != VALID_STATIC_OBJECT)
    return false;
  return true;
}

bool
pthread_mutex::isGoodInitializerOrObject (pthread_mutex_t const *mutex)
{
  if (verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC, PTHREAD_MUTEX_INITIALIZER) == INVALID_OBJECT)
a1259 8
bool
pthread_mutexattr::isGoodObject (pthread_mutexattr_t const * attr)
{
  if (verifyable_object_isvalid (attr, PTHREAD_MUTEXATTR_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

d1457 1
a1457 1
pthread::create (pthread_t *thread, const pthread_attr_t *attr,
d1466 1
a1466 1
  if (!isGoodObject (thread))
d1477 1
a1477 1
pthread::once (pthread_once_t *once_control, void (*init_routine) (void))
d1501 1
a1501 1
pthread::cancel (pthread_t thread)
d1503 1
a1503 1
  if (!isGoodObject (&thread))
d1569 1
a1569 1
pthread::atfork (void (*prepare)(void), void (*parent)(void), void (*child)(void))
d1785 1
a1785 1
pthread::join (pthread_t *thread, void **return_val)
d1787 1
a1787 1
   pthread_t joiner = self ();
d1794 1
a1794 1
  if (!isGoodObject (thread))
d1825 1
a1825 1
pthread::detach (pthread_t *thread)
d1827 1
a1827 1
  if (!isGoodObject (thread))
d1856 1
a1856 1
pthread::suspend (pthread_t *thread)
d1858 1
a1858 1
  if (!isGoodObject (thread))
d1872 1
a1872 1
pthread::resume (pthread_t *thread)
d1874 1
a1874 1
  if (!isGoodObject (thread))
a1988 23
bool
pthread_cond::isGoodObject (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

bool
pthread_cond::isGoodInitializer (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER) != VALID_STATIC_OBJECT)
    return false;
  return true;
}

bool
pthread_cond::isGoodInitializerOrObject (pthread_cond_t const *cond)
{
  if (verifyable_object_isvalid (cond, PTHREAD_COND_MAGIC, PTHREAD_COND_INITIALIZER) == INVALID_OBJECT)
    return false;
  return true;
}
d1993 1
a1993 1
  if (pthread_cond::isGoodInitializer (cond))
d1995 1
a1995 1
  if (!pthread_cond::isGoodObject (cond))
d2011 1
a2011 1
  if (attr && !pthread_condattr::isGoodObject (attr))
d2014 1
a2014 1
  if (pthread_cond::isGoodObject (cond))
d2019 1
a2019 1
  if (!pthread_cond::isGoodObject (cond))
d2032 1
a2032 1
  if (pthread_cond::isGoodInitializer (cond))
d2034 1
a2034 1
  if (!pthread_cond::isGoodObject (cond))
d2045 1
a2045 1
  if (pthread_cond::isGoodInitializer (cond))
d2047 1
a2047 1
  if (!pthread_cond::isGoodObject (cond))
d2066 1
a2066 1
  if (pthread_cond::isGoodInitializer (cond))
d2071 1
a2071 1
  if (!pthread_cond::isGoodObject (cond))
a2137 1
  /* FIXME: we dereference blindly! */
d2139 1
a2139 1
  if (!pthread_condattr::isGoodObject (condattr))
d2151 1
a2151 1
  if (!pthread_condattr::isGoodObject (attr))
d2160 1
a2160 1
  if (!pthread_condattr::isGoodObject (attr))
d2174 1
a2174 1
  if (!pthread_condattr::isGoodObject (condattr))
d2241 1
a2241 1
  if (attr && !pthread_mutexattr::isGoodObject (attr) || check_valid_pointer (mutex))
d2244 1
a2244 2
  /* FIXME: bugfix: we should check *mutex being a valid address */
  if (pthread_mutex::isGoodObject (mutex))
d2262 1
a2262 1
  if (pthread_mutex::isGoodInitializer (mutex))
a2280 4
  /* This could be simplified via isGoodInitializerOrObject 
     and isGoodInitializer, but in a performance critical call like this....
     no.
     */
d2287 1
a2287 1
      if (pthread_mutex::isGoodInitializer (mutex))
d2305 1
a2305 1
  if (pthread_mutex::isGoodInitializer (mutex))
d2317 1
a2317 1
  if (pthread_mutex::isGoodInitializer (mutex))
d2328 1
a2328 1
  if (pthread_mutex::isGoodInitializer (mutex))
d2347 1
a2347 1
  if (pthread_mutex::isGoodInitializer (mutex))
d2360 1
a2360 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2369 1
a2369 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2382 1
a2382 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2396 1
a2396 1
  if (pthread_mutexattr::isGoodObject (attr))
d2400 1
a2400 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2412 1
a2412 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2424 1
a2424 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2434 1
a2434 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2443 1
a2443 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2451 1
a2451 1
  if (!pthread_mutexattr::isGoodObject (attr))
d2466 1
a2466 1
  if (!pthread_mutexattr::isGoodObject (attr))
a2474 10

/* static members */
bool
semaphore::isGoodObject (sem_t const * sem)
{
  if (verifyable_object_isvalid (sem, SEM_MAGIC) != VALID_OBJECT)
    return false;
  return true;
}

d2476 1
a2476 1
semaphore::init (sem_t *sem, int pshared, unsigned int value)
d2479 1
a2479 1
  if (isGoodObject (sem))
d2487 1
a2487 1
  if (!isGoodObject (sem))
d2497 1
a2497 1
semaphore::destroy (sem_t *sem)
d2499 1
a2499 1
  if (!isGoodObject (sem))
d2510 1
a2510 1
semaphore::wait (sem_t *sem)
d2512 1
a2512 1
  if (!isGoodObject (sem))
d2523 1
a2523 1
semaphore::trywait (sem_t *sem)
d2525 1
a2525 1
  if (!isGoodObject (sem))
d2535 1
a2535 1
semaphore::post (sem_t *sem)
d2537 1
a2537 1
  if (!isGoodObject (sem))
@


1.49.2.17
log
@Merged changes from HEAD
@
text
@d311 1
a311 1
  if (!pthread_mutex::isGoodObject (&verifyable_mutex_obj))
d1016 1
a1016 1
  int savedError = ::GetLastError ();
d1041 1
a1041 1
    destructor (get ());
@


1.48
log
@minor cleanups
@
text
@d502 1
a502 1
  if (!iswinnt)
d624 1
a624 1
  if (iswinnt)
d640 1
a640 1
  if (iswinnt)
d666 1
a666 1
  if (iswinnt)
d679 1
a679 1
  if (iswinnt)
d687 1
a687 1
  if (iswinnt)
d702 1
a702 1
  if (iswinnt)
@


1.47
log
@Wed Sep 12 13:03:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * autoload.cc (LoadDLLfuncEx): Auto load TryEnterCriticalSection - its a
n NT only call.
        * thread.cc (pthread_cond::TimedWait): Use critical sections for NT.
        (pthread_cond::fixup_after_fork): Don't detect bad apps.
        (pthread_mutex::pthread_mutex): Use critical sections for NT.
        (pthread_mutex::~pthread_mutex): Ditto.
        (pthread_mutex::Lock): Ditto.
        (pthread_mutex::TryLock): Ditto.
        (pthread_mutex::UnLock): Ditto.
        (pthread_mutex::fixup_after_fork): Ditto. Also do not detect bad apps.
        (__pthread_mutex_trylock): Move WIN32 specific test into the class metho
d.
        (__pthread_mutex_destroy): Prevent dereferencing passed pointer without
valid address.
        * thread.h (pthread_mutex): Use critical sections for NT.
@
text
@d6 1
d14 1
a14 1
/*Implementation overview and caveats:
d16 9
a24 8
  Win32 puts some contraints on what can and cannot be implemented. Where possible
  we work around those contrainsts. Where we cannot work around the constraints we
  either pretend to be conformant, or return an error code.

  Some caveats: PROCESS_SHARED objects while they pretend to be process shared,
  may not actually work. Some test cases are needed to determine win32's behaviour.
  My suspicion is that the win32 handle needs to be opened with different flags for
  proper operation.
d26 1
a26 2
  R.Collins, April 2001.
  */
d453 1
a453 1
        tempcond = tempcond->next;
d518 1
a518 1
	     
d630 1
a630 1
        magic = 0;
d645 1
a645 1
        CloseHandle (win32_obj_id);
d708 1
a708 1
        api_fatal("pthread_mutex::fixup_after_fork() failed to create new win32 mutex\n");
d750 1
a750 1
        tempsem = tempsem->next;
@


1.46
log
@Tue Sep 11 21:22:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* thread.cc (pthread_cond::~pthread_cond): Bugfix: Incorrect use of InterlockExchangePointer.
	(pthread_mutex::~pthread_mutex): Ditto.
	(semaphore::~semaphore): Ditto.
@
text
@d509 9
d520 2
d546 1
d549 4
d623 8
a630 5

  this->win32_obj_id =::CreateMutex (&sec_none_nih, false, NULL);

  if (!win32_obj_id)
    magic = 0;
d639 8
a646 3
  if (win32_obj_id)
    CloseHandle (win32_obj_id);
  win32_obj_id = NULL;
d649 2
a650 1
    InterlockedExchangePointer (&MT_INTERFACE->mutexs, this->next);
d657 1
d665 6
d674 1
d678 3
a680 1
  return WaitForSingleObject (win32_obj_id, 0);
d686 6
a691 1
  return ReleaseMutex (win32_obj_id);
d701 9
a709 4
  this->win32_obj_id =::CreateMutex (&sec_none_nih, false, NULL);

  if (!win32_obj_id)
    api_fatal("pthread_mutex::fixup_after_fork() failed to create new win32 mutex\n");
d712 3
d1959 1
a1959 1
  if ((*themutex)->TryLock () == WAIT_TIMEOUT)
d1978 1
a1978 1
  if (*mutex == PTHREAD_MUTEX_INITIALIZER)
@


1.45
log
@Tue Sep 11 18:15:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * dcrt0.cc (cygwin_finished_initializing): Copy _mtinterf on fork;
        * fork.cc (fork_child): fixup thread-related structures after fork;
        * thread.cc (MTinterface::Init): Initialise the new mutex, condition and semaphore lists.
        (MTinterface::fixup_after_fork): Iterate through each list and fixup the objects.
        (pthread_cond::pthread_cond): Add this to the condition list.
        (pthread_cond::~pthread_cond): Remove this from the condition list.
        (pthread_cond::fixup_after_fork): Recreate as best we can the pre-fork state.
        (pthread_mutex::pthread_mutex): Add this to the mutex list.
        (pthread_mutex::~pthread_mutex): Remove this from the mutex list.
        (pthread_mutex::fixup_after_fork): Recreate as best we can the pre-fork state.
        (semaphore::semaphore): Store the initial value, and add this to the semaphore list.
        (semaphore::~semaphore): Remove this from the semaphore list.
        (semaphore::Post): Increment the current semaphore value.
        (semaphore::TryWait): Decrement the current semaphore value.
        (semaphore::Wait): Ditto.
        (semaphote::fixup_after_fork): Recreate the pre-fork state as best we can.
        * thread.h (pthread_mutex): New members to allow fixup_after_fork.
        (pthread_cond): Ditto.
        (semaphore): Ditto.
        (MTinterface): New list heads for tracking conds and semaphores.
@
text
@d447 1
a447 1
    MT_INTERFACE->conds = (pthread_cond *)InterlockedExchangePointer (&MT_INTERFACE->conds, this->next);
d454 1
a454 1
      tempcond->next = (pthread_cond *)InterlockedExchangePointer (&tempcond->next, this->next);
a597 7
/*FIXME: implement InterlockExchangePointer and get rid of the silly typecasts in pthread_atfork
 */
#ifndef InterlockedExchangePointer
#define InterlockedExchangePointer InterlockedExchange
#endif
 

d625 1
a625 1
    MT_INTERFACE->mutexs = (pthread_mutex *)InterlockedExchangePointer (&MT_INTERFACE->mutexs, this->next);
d632 1
a632 1
      tempmutex->next = (pthread_mutex *)InterlockedExchangePointer (&tempmutex->next, this->next);
d696 1
a696 1
    MT_INTERFACE->semaphores = (semaphore *)InterlockedExchangePointer (&MT_INTERFACE->semaphores, this->next);
d703 1
a703 1
      tempsem->next = (semaphore *)InterlockedExchangePointer (&tempsem->next, this->next);
@


1.44
log
@Mon Sep 10 08:28:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * thread.h (MT_Interface): Remove pshared mutex array.
        Add a threadsafe list for mutex tracking (for fixupafter fork).
        * thread.cc (MTInterface::Init): Remove pshared mutex array.
        (pthread_mutex::pthread_mutex): Remove pshared mutex functionality.
        Fail with EINVAL on attempts to use pshared functionality.
        (__pthread_mutex_getpshared): Remove.
        (__pthread_cond_timedwait): Remove pshared mutex functionality.
        (__pthread_cond_wait): Ditto.
        (__pthread_mutex_init): Ditto.
        (__pthread_mutex_getprioceiling): Ditto.
        (__pthread_mutex_lock): Ditto.
        (__pthread_mutex_trylock): Ditto.
        (__pthread_mutex_unlock): Ditto.
        (__pthread_mutex_destroy): Ditto.
        (__pthread_mutex_setprioceiling): Ditto.
        (__pthread_mutexattr_setpshared): Ditto.
@
text
@d305 4
d320 27
d436 2
d445 11
d525 15
d598 7
d621 2
d630 11
d661 15
d692 3
d701 11
d717 3
a719 2
  long pc;
  ReleaseSemaphore (win32_obj_id, 1, &pc);
d730 2
a731 2
  else
    return 0;
d738 13
a1175 6

/*FIXME: implement InterlockExchangePointer and get rid of the silly typecasts below
 */
#ifndef InterlockedExchangePointer
#define InterlockedExchangePointer InterlockedExchange
#endif
@


1.43
log
@* thread.cc (InterlockedExchangePointer): Don't define if it already exists.
@
text
@a306 3
  for (int i = 0; i < 256; i++)
    pshared_mutexs[i] = NULL;

d515 4
a518 9
#define SYS_BASE (unsigned char) 0xC0
// Note: the order is important. This is an overloaded pthread_mutex_t from
// userland
typedef struct _pshared_mutex {
 unsigned char id;
 unsigned char reserved;
 unsigned char reserved2;
 unsigned char flags;
} pshared_mutex;
a519 1
/*pshared mutexs:
a538 67
pthread_mutex::pthread_mutex (unsigned short id):verifyable_object (PTHREAD_MUTEX_MAGIC)
{
  //FIXME: set an appropriate security mask - probably everyone.
  if (MT_INTERFACE->pshared_mutexs[id])
    return;
  char stringbuf[29];
  snprintf (stringbuf, 29, "CYGWINMUTEX0x%0x", id & 0x000f);
  system_printf ("name of mutex to transparently open %s\n",stringbuf);
  this->win32_obj_id =::CreateMutex (&sec_none_nih, false, stringbuf);
  if (win32_obj_id==0 || (win32_obj_id && GetLastError () != ERROR_ALREADY_EXISTS))
    {
      // the mutex has been deleted or we couldn't get access.
	// the error_already_exists test is because we are only opening an
	// existint mutex here
      system_printf ("couldn't get pshared mutex %x, %d\n",win32_obj_id, GetLastError ());
      CloseHandle (win32_obj_id);
      magic = 0;
      win32_obj_id = NULL;
      return;
    }
  pshared = PTHREAD_PROCESS_SHARED;

  MT_INTERFACE->pshared_mutexs[id] = this;
}

pthread_mutex::pthread_mutex (pthread_mutex_t *mutex, pthread_mutexattr *attr):verifyable_object (PTHREAD_MUTEX_MAGIC)
{
  /*attr checked in the C call */
  if (attr && attr->pshared==PTHREAD_PROCESS_SHARED)
    {
      //FIXME: set an appropriate security mask - probably everyone.
      // This does open a D.O.S. - the name is guessable (if you are willing to run
      // thru all possible address values :]
      char stringbuf[29];
      unsigned short id = 1;
      while (id < 256)
	{
	  snprintf (stringbuf, 29, "CYGWINMUTEX0x%0x", id & 0x000f);
	  system_printf ("name of mutex to create %s\n",stringbuf);
	  this->win32_obj_id =::CreateMutex (&sec_none_nih, false, stringbuf);
	  if (this->win32_obj_id && GetLastError () != ERROR_ALREADY_EXISTS)
	    {
	      MT_INTERFACE->pshared_mutexs[id] = this;
	      pshared_mutex *pmutex=(pshared_mutex *)(mutex);
	      pmutex->id = id;
	      pmutex->flags = SYS_BASE;
	      pshared = PTHREAD_PROCESS_SHARED;
	      condwaits = 0;
	      return;
	    }
	  id++;
	  CloseHandle (win32_obj_id);
	}
      magic = 0;
      win32_obj_id = NULL;
    }
  else
    {
      this->win32_obj_id =::CreateMutex (&sec_none_nih, false, NULL);

      if (!win32_obj_id)
	magic = 0;
      condwaits = 0;
      pshared = PTHREAD_PROCESS_PRIVATE;
    }
}

d544 1
a544 1
      /*for pshared mutex's we need the mutex address */
a581 20
pthread_mutex **
__pthread_mutex_getpshared (pthread_mutex_t *mutex)
{
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE) != SYS_BASE)
    return (pthread_mutex **) mutex;
  pshared_mutex *pmutex=(pshared_mutex *)(mutex);
  if ((MT_INTERFACE->pshared_mutexs[pmutex->id]) != NULL)
    return &(MT_INTERFACE->pshared_mutexs[pmutex->id]);
  /*attempt to get the existing mutex */
  pthread_mutex *newmutex;
  newmutex = new pthread_mutex (pmutex->id);
  if (!verifyable_object_isvalid (newmutex, PTHREAD_MUTEX_MAGIC))
  {
    delete (newmutex);
    MT_INTERFACE->pshared_mutexs[pmutex->id] = NULL;
    return &(MT_INTERFACE->pshared_mutexs[0]);
  }
  return &(MT_INTERFACE->pshared_mutexs[pmutex->id]);
}

a1537 2
// FIXME: pshared mutexs have the cond count in the shared memory area.
// We need to accomodate that.
d1550 1
a1550 5
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE == SYS_BASE))
    // a pshared mutex
    themutex = __pthread_mutex_getpshared (mutex);
  else
    themutex = mutex;
d1601 1
a1601 5
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE == SYS_BASE))
    // a pshared mutex
    themutex = __pthread_mutex_getpshared (mutex);
  else
    themutex = mutex;
d1686 1
a1686 1
  // two differ kills might clash: FIXME
a1745 3
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE == SYS_BASE))
    // a pshared mutex
    return EBUSY;
a1751 13
  if (attr && (*attr)->pshared == PTHREAD_PROCESS_SHARED)
    {
      pthread_mutex_t throwaway = new pthread_mutex (mutex, (*attr));
      mutex = __pthread_mutex_getpshared ((pthread_mutex_t *) mutex);

      if (!verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
	{
	  delete throwaway;
	  *mutex = NULL;
	  return EAGAIN;
	}
      return 0;
    }
a1768 3
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE == SYS_BASE))
    // a pshared mutex
    themutex = __pthread_mutex_getpshared ((pthread_mutex_t *) mutex);
d1777 1
a1777 1
   *When the mutex is released, reset the thre priority.
a1787 3
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE) == SYS_BASE)
    // a pshared mutex
    themutex = __pthread_mutex_getpshared (mutex);
a1799 3
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE) == SYS_BASE)
    // a pshared mutex
    themutex = __pthread_mutex_getpshared (mutex);
a1811 3
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE) == SYS_BASE)
    // a pshared mutex
    mutex = __pthread_mutex_getpshared (mutex);
a1822 3
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE) == SYS_BASE)
    // a pshared mutex
    mutex = __pthread_mutex_getpshared (mutex);
a1841 3
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE == SYS_BASE))
    // a pshared mutex
    themutex = __pthread_mutex_getpshared (mutex);
d1949 1
a1949 1
  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
@


1.42
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d1153 1
d1155 1
@


1.41
log
@* thread.cc (__pthread_equal): Invert return value so that true is returned
when threads are equal.
@
text
@d460 1
a460 1
  if (os_being_run != winNT)
@


1.40
log
@Tue 24 Jul 2001 02:28:00 PM  Trevor Forbes <t4bs@@hotmail.com>

	* thread.cc (verifyable_object_isvalid): Don't validate
	PTHREAD_MUTEX_INITIALIZER pointer as it will cause an exception
	in IsBadWritePtr() when running GDB.
@
text
@d1 1
a1 1
/* thread.cc: Locking and threading module functions
d13 1
a13 1
/* Implementation overview and caveats:
a24 1

d50 2
a51 2
/* pthread_key_destructor_list class: to-be threadsafe single linked list
 * FIXME: Put me in a dedicated file, or a least a tools area !
d55 1
a55 1
pthread_key_destructor::InsertAfter (pthread_key_destructor * node)
d78 1
a78 1
pthread_key_destructor_list::Insert (pthread_key_destructor * node)
d84 1
a84 1
    head = node;		/* first node special case */
d87 1
a87 1
  /* remove a given dataitem, wherever in the list it is */
d89 1
a89 1
pthread_key_destructor_list::Remove (pthread_key * key)
d107 1
a107 1
  /* get the first item and remove at the same time */
d117 1
a117 1
pthread_key_destructor (void (*thedestructor) (void *), pthread_key * key)
d295 1
a295 1
  threadcount = 1; /* 1 current thread when Init occurs.*/
d299 1
a299 1
  /* store the main thread's self pointer */
d305 1
a305 1
  /* possible the atfork lists should be inited here as well */
d332 1
a332 1
pthread::create (void *(*func) (void *), pthread_attr * newattr,
d335 1
a335 1
  /* already running ? */
d357 1
a357 1
      /* FIXME: set the priority appropriately for system contention scope */
d360 2
a361 2
	  /* FIXME: set the scheduling settings for the new thread */
	  /* sched_thread_setparam (win32_obj_id, attr.schedparam); */
d387 1
a387 1
pthread_cond::pthread_cond (pthread_condattr * attr):verifyable_object (PTHREAD_COND_MAGIC)
d394 4
a397 4
  this->win32_obj_id =::CreateEvent (&sec_none_nih, false,	/* auto signal reset - which I think is pthreads like ? */
				     false,	/* start non signaled */
				     NULL /* no name */);
  /* TODO: make a shared mem mutex if out attributes request shared mem cond */
d402 1
a402 1
      /* we need the mutex for correct behaviour */
d427 1
a427 1
      /* This isn't and API error - users are allowed to call this when no threads
d473 1
a473 1
      return 0;			/* POSIX doesn't allow errors after we modify the mutex state */
d478 1
a478 1
      return 0;			/* we have been signaled */
d498 1
a498 1
  if (pthread_key_destructor * dest = MT_INTERFACE->destructors.Remove (this))
d506 1
a506 1
  /* the OS function doesn't perform error checking */
d528 10
a537 10
/* pshared mutexs:
 * the mutex_t (size 4) is not used as a verifyable object because we cannot
 * guarantee the same address space for all processes.
 * we use the following:
 * high bit set (never a valid address).
 * second byte is reserved for the priority.
 * third byte is reserved
 * fourth byte is the mutex id. (max 255 cygwin mutexs system wide).
 * creating mutex's does get slower and slower, but as creation is a one time
 * job, it should never become an issue
d539 3
a541 3
 * And if you're looking at this and thinking, why not an array in cygwin for all mutexs,
 * - you incur a penalty on _every_ mutex call and you have toserialise them all.
 * ... Bad karma.
d543 3
a545 3
 * option 2? put everything in userspace and update the ABI?
 * - bad karma as well - the HANDLE, while identical across process's,
 * Isn't duplicated, it's reopened.
d573 1
a573 1
pthread_mutex::pthread_mutex (pthread_mutex_t *mutex, pthread_mutexattr * attr):verifyable_object (PTHREAD_MUTEX_MAGIC)
d575 1
a575 1
  /* attr checked in the C call */
d615 1
a615 1
pthread_mutex::pthread_mutex (pthread_mutexattr * attr):verifyable_object (PTHREAD_MUTEX_MAGIC)
d617 1
a617 1
  /* attr checked in the C call */
d620 1
a620 1
      /* for pshared mutex's we need the mutex address */
d666 2
a667 2
  /* attempt to get the existing mutex */
  pthread_mutex * newmutex;
d712 2
a713 2
  /* FIXME: signals should be able to interrupt semaphores...
   * We probably need WaitForMultipleObjects here.
d737 1
a737 1
/* Generic memory acccess routine - where should it live ? */
d747 1
a747 1
verifyable_object_isvalid (verifyable_object * object, long magic)
d758 1
a758 1
/*  Pthreads */
d770 1
a770 1
  sigset_t _sig_mask;		/* one set for everything to ignore. */
d785 1
a785 1
  /* This is not checked by the OS !! */
d789 1
a789 1
  /* the OS doesn't check this for <=64 Tls entries (pre win2k) */
d809 1
a809 1
  /* never reached */
d814 1
a814 1
__pthread_create (pthread_t * thread, const pthread_attr_t * attr,
d834 1
a834 1
__pthread_once (pthread_once_t * once_control, void (*init_routine) (void))
d837 5
a841 5
  /* Here we must set a cancellation handler to unlock the mutex if needed */
  /* but a cancellation handler is not the right thing. We need this in the thread
   * cleanup routine. Assumption: a thread can only be in one pthread_once routine
   * at a time. Stote a mutex_t * in the pthread_structure. if that's non null unlock
   * on pthread_exit ();
d848 1
a848 1
  /* Here we must remove our cancellation handler */
d853 1
a853 1
/* Cancelability states */
d856 1
a856 1
/* Perform the actual cancel */
d871 1
a871 1
      /* once all the functions call testcancel (), we will do this */
d877 3
a879 3
	  /* possible FIXME: this function is meant to return asynchronously
	   * from the cancellation routine actually firing. So we may need some sort
	   * of signal to be sent that is immediately recieved and acted on.
d885 1
a885 1
/*  return 0;
d893 1
a893 1
  the required function list is: * indicates done, X indicates not present in cygwin.
d997 4
a1000 4
* getpwnam ()
* getpwnam_r ()
* getpwuid ()
* getpwuid_r ()
d1066 1
a1066 1
/* no races in these three functions: they are all current-thread-only */
d1089 1
a1089 1
/* deferred cancellation request handler */
d1096 2
a1097 2
  /* check the cancellation event object here - not neededuntil pthread_cancel actually
   * does something*/
d1101 8
a1108 8
 * Races in pthread_atfork:
 * We are race safe in that any additions to the lists are made via
 * InterlockedExchangePointer.
 * However, if the user application doesn't perform syncronisation of some sort
 * It's not guaranteed that a near simultaneous call to pthread_atfork and fork
 * will result in the new atfork handlers being calls.
 * More rigorous internal syncronisation isn't needed as the user program isn't
 * guaranteeing their own state.
d1110 3
a1112 3
 * as far as multiple calls to pthread_atfork, the worst case is simultaneous calls
 * will result in an indeterminate order for parent and child calls (what gets inserted
 * first isn't guaranteed.)
d1114 3
a1116 3
 * There is one potential race... Does the result of InterlockedExchangePointer
 * get committed to the return location _before_ any context switches can occur?
 * If yes, we're safe, if no, we're not.
d1151 1
a1151 1
/* FIXME: implement InterlockExchangePointer and get rid of the silly typecasts below
d1155 3
a1157 3
/* Register a set of functions to run before and after fork.
 * prepare calls are called in LI-FC order.
 * parent and child calls are called in FI-FC order.
d1162 1
a1162 1
  callback * prepcb = NULL, * parentcb = NULL, * childcb = NULL;
d1200 1
a1200 1
    callback ** t = &MT_INTERFACE->pthread_parent;
d1203 1
a1203 1
    /* t = pointer to last next in the list */
d1209 1
a1209 1
    callback ** t = &MT_INTERFACE->pthread_child;
d1212 1
a1212 1
    /* t = pointer to last next in the list */
d1219 1
a1219 1
__pthread_attr_init (pthread_attr_t * attr)
d1232 1
a1232 1
__pthread_attr_getinheritsched (const pthread_attr_t * attr,
d1242 1
a1242 1
__pthread_attr_getschedparam (const pthread_attr_t * attr,
d1251 3
a1253 3
/* From a pure code point of view, this should call a helper in sched.cc,
 * to allow for someone adding scheduler policy changes to win32 in the future.
 * However that's extremely unlikely, so short and sweet will do us
d1256 1
a1256 1
__pthread_attr_getschedpolicy (const pthread_attr_t * attr, int *policy)
d1266 1
a1266 1
__pthread_attr_getscope (const pthread_attr_t * attr, int *contentionscope)
d1275 1
a1275 1
__pthread_attr_setdetachstate (pthread_attr_t * attr, int detachstate)
d1286 1
a1286 1
__pthread_attr_getdetachstate (const pthread_attr_t * attr, int *detachstate)
d1295 1
a1295 1
__pthread_attr_setinheritsched (pthread_attr_t * attr, int inheritsched)
d1307 1
a1307 1
__pthread_attr_setschedparam (pthread_attr_t * attr,
d1318 1
a1318 1
/* See __pthread_attr_getschedpolicy for some notes */
d1320 1
a1320 1
__pthread_attr_setschedpolicy (pthread_attr_t * attr, int policy)
d1330 1
a1330 1
__pthread_attr_setscope (pthread_attr_t * attr, int contentionscope)
d1337 2
a1338 2
  /* In future, we may be able to support system scope by escalating the thread
   * priority to exceed the priority class. For now we only support PROCESS scope. */
d1346 1
a1346 1
__pthread_attr_setstacksize (pthread_attr_t * attr, size_t size)
d1355 1
a1355 1
__pthread_attr_getstacksize (const pthread_attr_t * attr, size_t * size)
d1364 1
a1364 1
__pthread_attr_destroy (pthread_attr_t * attr)
d1388 1
a1388 1
__pthread_join (pthread_t * thread, void **return_val)
d1390 1
a1390 1
  /* FIXME: wait on the thread cancellation event as well - we are a cancellation point*/
d1406 1
a1406 1
    }	/* End if */
d1414 1
a1414 1
__pthread_detach (pthread_t * thread)
d1430 1
a1430 1
__pthread_suspend (pthread_t * thread)
d1446 1
a1446 1
__pthread_continue (pthread_t * thread)
d1458 2
a1459 2
/* provided for source level compatability.
 * See http://www.opengroup.org/onlinepubs/007908799/xsh/pthread_getconcurrency.html
d1467 1
a1467 1
/* keep this in sync with sched.cc */
d1475 2
a1476 2
  /* we don't return the current effective priority, we return the current requested
   * priority */
d1483 1
a1483 1
__pthread_getsequence_np (pthread_t * thread)
d1490 1
a1490 1
/* Thread SpecificData */
d1492 1
a1492 1
__pthread_key_create (pthread_key_t * key, void (*destructor) (void *))
d1494 2
a1495 2
  /* The opengroup docs don't define if we should check this or not,
   * but creation is relatively rare..
d1521 2
a1522 2
/* provided for source level compatability.
 * See http://www.opengroup.org/onlinepubs/007908799/xsh/pthread_getconcurrency.html
d1533 1
a1533 1
/* keep syncronised with sched.cc */
d1571 1
a1571 1
/* Thread synchronisation */
d1574 1
a1574 1
__pthread_cond_destroy (pthread_cond_t * cond)
d1579 1
a1579 1
  /* reads are atomic */
d1590 1
a1590 1
__pthread_cond_init (pthread_cond_t * cond, const pthread_condattr_t * attr)
d1611 1
a1611 1
__pthread_cond_broadcast (pthread_cond_t * cond)
d1622 1
a1622 1
__pthread_cond_signal (pthread_cond_t * cond)
d1635 1
a1635 1
__pthread_cond_timedwait (pthread_cond_t * cond, pthread_mutex_t * mutex,
d1659 1
a1659 1
  waitlength = (abstime->tv_sec - currSysTime.time) * 1000;
d1663 1
a1663 1
  /* if the cond variable is blocked, then the above timer test maybe wrong. *shrug* */
d1694 1
a1694 1
__pthread_cond_wait (pthread_cond_t * cond, pthread_mutex_t * mutex)
d1740 1
a1740 1
__pthread_condattr_init (pthread_condattr_t * condattr)
d1753 1
a1753 1
__pthread_condattr_getpshared (const pthread_condattr_t * attr, int *pshared)
d1762 1
a1762 1
__pthread_condattr_setpshared (pthread_condattr_t * attr, int pshared)
d1768 1
a1768 1
  /* shared cond vars not currently supported */
d1776 1
a1776 1
__pthread_condattr_destroy (pthread_condattr_t * condattr)
d1785 1
a1785 1
/* Thread signal */
d1805 1
a1805 1
__pthread_sigmask (int operation, const sigset_t * set, sigset_t * old_set)
d1822 1
a1822 1
/*  ID */
d1830 1
a1830 1
__pthread_equal (pthread_t * t1, pthread_t * t2)
d1832 1
a1832 1
  return (*t1 - *t2);
d1835 1
a1835 1
/* Mutexes  */
d1837 7
a1843 7
/* FIXME: there's a potential race with PTHREAD_MUTEX_INITALIZER:
 * the mutex is not actually inited until the first use.
 * So two threads trying to lock/trylock may collide.
 * Solution: we need a global mutex on mutex creation, or possibly simply
 * on all constructors that allow INITIALIZER macros.
 * the lock should be very small: only around the init routine, not
 * every test, or all mutex access will be synchronised.
d1847 2
a1848 2
__pthread_mutex_init (pthread_mutex_t * mutex,
		      const pthread_mutexattr_t * attr)
d1883 1
a1883 1
__pthread_mutex_getprioceiling (const pthread_mutex_t * mutex,
d1894 2
a1895 2
  /* We don't define _POSIX_THREAD_PRIO_PROTECT because we do't currently support
   * mutex priorities.
d1897 4
a1900 4
   * We can support mutex priorities in the future though:
   * Store a priority with each mutex.
   * When the mutex is optained, set the thread priority as appropriate
   * When the mutex is released, reset the thre priority.
d1906 1
a1906 1
__pthread_mutex_lock (pthread_mutex_t * mutex)
d1921 1
a1921 1
__pthread_mutex_trylock (pthread_mutex_t * mutex)
d1937 1
a1937 1
__pthread_mutex_unlock (pthread_mutex_t * mutex)
d1951 1
a1951 1
__pthread_mutex_destroy (pthread_mutex_t * mutex)
d1961 1
a1961 1
  /* reading a word is atomic */
d1971 1
a1971 1
__pthread_mutex_setprioceiling (pthread_mutex_t * mutex, int prioceiling,
d1985 2
a1986 2
/* Win32 doesn't support mutex priorities - see __pthread_mutex_getprioceiling
 * for more detail */
d1988 1
a1988 1
__pthread_mutexattr_getprotocol (const pthread_mutexattr_t * attr,
d1997 1
a1997 1
__pthread_mutexattr_getpshared (const pthread_mutexattr_t * attr,
d2006 3
a2008 3
/* Win32 mutex's are equivalent to posix RECURSIVE mutexs.
 * We need to put glue in place to support other types of mutex's. We map
 * PTHREAD_MUTEX_DEFAULT to PTHREAD_MUTEX_RECURSIVE and return EINVAL for other types.
d2011 1
a2011 1
__pthread_mutexattr_gettype (const pthread_mutexattr_t * attr, int *type)
d2019 2
a2020 2
/* Currently pthread_mutex_init ignores the attr variable, this is because
 * none of the variables have any impact on it's behaviour.
d2022 1
a2022 1
 * FIXME: write and test process shared mutex's.
d2025 1
a2025 1
__pthread_mutexattr_init (pthread_mutexattr_t * attr)
d2041 1
a2041 1
__pthread_mutexattr_destroy (pthread_mutexattr_t * attr)
d2051 1
a2051 1
/* Win32 doesn't support mutex priorities */
d2053 1
a2053 1
__pthread_mutexattr_setprotocol (pthread_mutexattr_t * attr, int protocol)
d2060 1
a2060 1
/* Win32 doesn't support mutex priorities */
d2062 1
a2062 1
__pthread_mutexattr_setprioceiling (pthread_mutexattr_t * attr,
d2071 1
a2071 1
__pthread_mutexattr_getprioceiling (const pthread_mutexattr_t * attr,
d2080 1
a2080 1
__pthread_mutexattr_setpshared (pthread_mutexattr_t * attr, int pshared)
d2084 2
a2085 2
  /* we don't use pshared for anything as yet. We need to test PROCESS_SHARED
   * functionality
d2093 1
a2093 1
/* see __pthread_mutex_gettype */
d2095 1
a2095 1
__pthread_mutexattr_settype (pthread_mutexattr_t * attr, int type)
d2105 1
a2105 1
/* Semaphores */
d2107 1
a2107 1
__sem_init (sem_t * sem, int pshared, unsigned int value)
d2109 1
a2109 1
  /* opengroup calls this undefined */
d2128 1
a2128 1
__sem_destroy (sem_t * sem)
d2133 1
a2133 1
  /* FIXME - new feature - test for busy against threads... */
d2141 1
a2141 1
__sem_wait (sem_t * sem)
d2151 1
a2151 1
__sem_trywait (sem_t * sem)
d2160 1
a2160 1
__sem_post (sem_t * sem)
@


1.39
log
@Change check_null_empty_path* to check_null_empty_str* throughout.
* path.cc (path_conv::check): Add signal protection here since retrieving info
about remote shares can take some time.
* path.h (check_null_empty_str_errno): Convert to a function prototype.
* path.cc (check_null_empty_str): Move to miscfuncs.cc.
* miscfuncs.cc (check_null_empty_str_errno): New function.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(check_null_empty_str): Change from VirtualQuery to IsBadWritePtr.
* thread.cc (check_valid_pointer): Ditto.
* resource.cc (getrlimit): Use check_null_invalid_struct macro for checking
validity of pointer.
(setrlimit): Ditto.
@
text
@d750 1
a750 1
  if (!object)
@


1.38
log
@Remove trailing tabs.
@
text
@d742 1
a742 3
  MEMORY_BASIC_INFORMATION m;
  if (!pointer || !VirtualQuery (pointer, &m, sizeof (m))
      || (m.State != MEM_COMMIT))
@


1.37
log
@* mmap.cc: Clean up *ResourceLock calls throughout.
* thread.cc (pthread_cond::TimedWait): Check for WAIT_TIMEOUT as well as
WAIT_ABANDONED.
(__pthread_cond_timedwait): Calculate a relative wait from the abstime
parameter.
@
text
@d404 1
a404 1
      magic = 0;	
@


1.36
log
@forced commit
@
text
@d47 1
d400 1
a400 1
  if ((temperr = pthread_mutex_init (&this->cond_access, NULL))) 
d424 1
a424 1
  if (!verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC)) 
d427 3
a429 3
        system_printf ("Failed to unlock condition variable access mutex, this %0p\n", this);
      /* This isn't and API error - users are allowed to call this when no threads 
	 are waiting 
d448 2
a449 2
        system_printf ("Failed to unlock condition variable access mutex, this %0p\n",
                       this);
d476 1
d585 7
a591 7
        {
          snprintf (stringbuf, 29, "CYGWINMUTEX0x%0x", id & 0x000f);
          system_printf ("name of mutex to create %s\n",stringbuf);
          this->win32_obj_id =::CreateMutex (&sec_none_nih, false, stringbuf);
          if (this->win32_obj_id && GetLastError () != ERROR_ALREADY_EXISTS)
            {
              MT_INTERFACE->pshared_mutexs[id] = this;
d594 1
a594 1
              pmutex->flags = SYS_BASE;
d601 1
a601 1
        }
d610 1
a610 1
        magic = 0;
d1641 1
a1641 1
// and yes cond_access here is still open to a race. (we increment, context swap, 
d1659 6
d1666 1
d1673 3
a1675 3
        if (pthread_mutex_unlock (&(*cond)->cond_access))
          system_printf ("Failed to unlock condition variable access mutex, this %0p\n", *cond);
        return EINVAL;
d1683 1
a1683 1
  rv = (*cond)->TimedWait (abstime->tv_sec * 1000);
d1720 3
a1722 3
        if (pthread_mutex_unlock (&(*cond)->cond_access))
          system_printf ("Failed to unlock condition variable access mutex, this %0p\n", *cond);
        return EINVAL;
d1868 5
a1872 5
        {
          delete throwaway;
          *mutex = NULL;
          return EAGAIN;
        }
@


1.35
log
@2001-06-22  Robert Collins  rbtcollins@@hotmail.com

	* thread.cc (__pthread_cond_timedwait): Lock the waiting mutex before
	the condition protect mutex to avoid deadlocking. (Found by Greg Smith).
	(__pthread_cond_wait): Ditto.
@
text
@@


1.34
log
@* thread.cc (pthread_cond::Signal): Release the condition access variable
correctly.
@
text
@d1675 1
a1677 1
  (*cond)->mutex->Lock ();
d1722 1
a1724 1
  (*cond)->mutex->Lock ();
@


1.33
log
@* thread.cc (pthread_cond::Broadcast): Don't print error messages on invalid
mutexs - user programs are allowed to call pthread_cond_broadcast like that.
(__pthread_cond_timedwait): Initialise themutex properly.
(__pthread_cond_wait): Initialise themutex properly.
@
text
@d445 6
a450 1
    return;
@


1.32
log
@Sun May  6 17:05:00 2001  Robert Collins <rbtcollins@@hotmail.com>
	* thread.h (pthread_cond): New element cond_access to allow atomic broadcasts.
	* thread.cc (pthread_cond::pthread_cond): Initialise cond_access.
	(pthread_cond::~pthread_cond): Destroy cond_access.
	(pthread_cond::Broadcast): Use cond_access.
	(pthread_cond::Signal): Use cond_access.
	(pthread_cond_wait): Use cond_access.
	(pthread_cond_timedwait): Use cond_access.
@
text
@d427 4
a430 1
      system_printf ("Broadcast called with invalid mutex\n");
d1645 2
d1693 2
@


1.31
log
@Revert much of previous erroneous checkin.  Add ChangeLog entry.

* pinfo.h: Correctly set __SIGOFFSET.
* path.cc (hash_path_name): Avoid calling library functions for simple copying
of characters.
* shortcut.c: Use WIN32_LEAN_AND_MEAN.
* smallprint.c: Ditto.
* environ.cc (getwinenv): Minor clarity fix.
* localtime.c: No need to include windows.h
* string.h: New file.
@
text
@d389 1
d397 8
d414 1
d420 11
a430 6
  // This potentially has an unfairness bug. We should
  // consider preventing the wakeups from resuming until we finish signalling.
  if (!verifyable_object_isvalid (mutex, PTHREAD_MUTEX_MAGIC))
    return;
  PulseEvent (win32_obj_id);
  while (InterlockedDecrement (&waiting) != 0)
d432 2
a433 1
  mutex = NULL;
d439 2
d444 2
d1631 2
d1648 3
d1653 5
a1657 1
      return EINVAL;
d1662 2
d1665 2
d1671 2
d1680 1
d1693 3
d1698 5
a1702 1
      return EINVAL;
d1707 2
d1710 2
d1716 2
a1717 1

@


1.30
log
@* exceptions.cc (ctrl_c_handler): Always send signal to process if it has no
tty.
@
text
@d415 1
a415 1
  while (ilockdecr (&waiting) != 0)
d801 1
a801 1
  ilockincr (&MT_INTERFACE->threadcount);
d1076 1
a1076 1
 * ilockexch.
d1087 1
a1087 1
 * There is one potential race... Does the result of ilockexch
d1126 1
a1126 1
/*#define ilockexch ilockExchange */
d1168 1
a1168 1
    prepcb->next=(callback *)ilockexch ((LONG *) &MT_INTERFACE->pthread_prepare, (long int) prepcb);
d1177 1
a1177 1
    parentcb->next=(callback *)ilockexch ((LONG *) t, (long int) parentcb);
d1186 1
a1186 1
    childcb->next=(callback *)ilockexch ((LONG *) t, (long int) childcb);
d1354 1
a1354 1
  if (ilockdecr (&MT_INTERFACE->threadcount) == 0)
d1629 1
a1629 1
  ilockincr (&((*cond)->waiting));
d1632 1
a1632 1
  ilockincr (&((*themutex)->condwaits));
d1635 1
a1635 1
  if (ilockdecr (&((*cond)->waiting)) == 0)
d1637 1
a1637 1
  ilockdecr (&((*themutex)->condwaits));
d1660 1
a1660 1
  ilockincr (&((*cond)->waiting));
d1663 1
a1663 1
  ilockincr (&((*themutex)->condwaits));
d1666 1
a1666 1
  if (ilockdecr (&((*cond)->waiting)) == 0)
d1668 1
a1668 1
  ilockdecr (&((*themutex)->condwaits));
@


1.29
log
@* thread.cc (thread_init_wrapper): Use _REENT_INIT to initialize the reent
structure of newlib.
* sigproc.h (sig_send): Add exception parameter to sig_send.
* sigproc.cc (sig_send): Ditto.  Use it when setting frame info.
* exceptions.cc (handle_exceptions): Use exception flag when calling sig_send.
@
text
@d415 1
a415 1
  while (InterlockedDecrement (&waiting) != 0)
d801 1
a801 1
  InterlockedIncrement (&MT_INTERFACE->threadcount);
d1076 1
a1076 1
 * InterlockedExchangePointer.
d1087 1
a1087 1
 * There is one potential race... Does the result of InterlockedExchangePointer
d1126 1
a1126 1
#define InterlockedExchangePointer InterlockedExchange
d1168 1
a1168 1
    prepcb->next=(callback *)InterlockedExchangePointer ((LONG *) &MT_INTERFACE->pthread_prepare, (long int) prepcb);
d1177 1
a1177 1
    parentcb->next=(callback *)InterlockedExchangePointer ((LONG *) t, (long int) parentcb);
d1186 1
a1186 1
    childcb->next=(callback *)InterlockedExchangePointer ((LONG *) t, (long int) childcb);
d1354 1
a1354 1
  if (InterlockedDecrement (&MT_INTERFACE->threadcount) == 0)
d1629 1
a1629 1
  InterlockedIncrement (&((*cond)->waiting));
d1632 1
a1632 1
  InterlockedIncrement (&((*themutex)->condwaits));
d1635 1
a1635 1
  if (InterlockedDecrement (&((*cond)->waiting)) == 0)
d1637 1
a1637 1
  InterlockedDecrement (&((*themutex)->condwaits));
d1660 1
a1660 1
  InterlockedIncrement (&((*cond)->waiting));
d1663 1
a1663 1
  InterlockedIncrement (&((*themutex)->condwaits));
d1666 1
a1666 1
  if (InterlockedDecrement (&((*cond)->waiting)) == 0)
d1668 1
a1668 1
  InterlockedDecrement (&((*themutex)->condwaits));
@


1.28
log
@spacing changes.
@
text
@d740 1
a740 1
  struct _reent local_clib;
a750 1
  memset (&local_clib, 0, sizeof (struct _reent));
a751 5

  local_clib._errno = 0;
  local_clib._stdin = &local_clib.__sf[0];
  local_clib._stdout = &local_clib.__sf[1];
  local_clib._stderr = &local_clib.__sf[2];
@


1.27
log
@Mon Apr 23  9:27:00 2001  Robert Collins <rbtcollins@@hotmail.com>

       * thread.cc (MTinterface::Init): Always initialise per process variables.
@
text
@d17 1
a17 1
  either pretend to be conformant, or return an error code. 
d50 1
a50 1
/* pthread_key_destructor_list class: to-be threadsafe single linked list 
d307 2
a308 1
  for (int i =0;i<256;i++)pshared_mutexs[i]=NULL;
d361 1
a361 1
	  /* sched_thread_setparam(win32_obj_id, attr.schedparam); */
d395 1
a395 1
				     NULL /* no name */ );
d436 2
a437 2
      ReleaseMutex(mutex->win32_obj_id);
      rv = WaitForSingleObject(win32_obj_id, dwMilliseconds);
d472 1
a472 1
};
d490 1
a490 1
// Note: the order is important. This is an overloaded pthread_mutex_t from 
d525 2
a526 2
  snprintf(stringbuf, 29, "CYGWINMUTEX0x%0x", id & 0x000f);
  system_printf("name of mutex to transparently open %s\n",stringbuf);
d528 1
a528 1
  if (win32_obj_id==0 || (win32_obj_id && GetLastError() != ERROR_ALREADY_EXISTS))
d530 1
a530 1
      // the mutex has been deleted or we couldn't get access. 
d533 4
a536 4
      system_printf("couldn't get pshared mutex %x, %d\n",win32_obj_id, GetLastError());
      CloseHandle(win32_obj_id);
      magic=0;
      win32_obj_id=NULL;
d541 1
a541 1
  MT_INTERFACE->pshared_mutexs[id]=this;
d553 1
a553 1
      unsigned short id=1;
d556 2
a557 2
          snprintf(stringbuf, 29, "CYGWINMUTEX0x%0x", id & 0x000f);
          system_printf("name of mutex to create %s\n",stringbuf);
d559 1
a559 1
          if (this->win32_obj_id && GetLastError() != ERROR_ALREADY_EXISTS)
d561 1
a561 1
              MT_INTERFACE->pshared_mutexs[id]=this;
d563 3
a565 3
	      pmutex->id=id;
              pmutex->flags=SYS_BASE;
	      pshared=PTHREAD_PROCESS_SHARED;
d570 1
a570 1
	  CloseHandle(win32_obj_id);
d572 2
a573 2
      magic=0;
      win32_obj_id=NULL;
d597 1
a597 1
    
d608 1
a608 1
  win32_obj_id=NULL;
d630 1
a630 1
__pthread_mutex_getpshared(pthread_mutex_t *mutex)
d632 2
a633 2
  if ((((pshared_mutex *)(mutex))->flags & SYS_BASE) != SYS_BASE )
    return (pthread_mutex **)mutex;
d635 1
a635 1
  if ((MT_INTERFACE->pshared_mutexs[pmutex->id]) != NULL )
d643 1
a643 1
    MT_INTERFACE->pshared_mutexs[pmutex->id]=NULL;
d645 1
a645 1
  }    
d656 1
a656 1
};
d786 1
a786 1
// it's all now in __pthread_exit();
d807 1
a807 1
  InterlockedIncrement(&MT_INTERFACE->threadcount);
d819 2
a820 2
   * at a time. Stote a mutex_t * in the pthread_structure. if that's non null unlock 
   * on pthread_exit();
d850 1
a850 1
      /* once all the functions call testcancel(), we will do this */
d864 1
a864 1
/*  return 0; 
d869 1
a869 1
  we return ESRCH until all the required functions call testcancel();
d873 39
a911 39
aio_suspend()
*close()
*creat()
fcntl()
fsync()
getmsg()
getpmsg()
lockf()
mq_receive()
mq_send()
msgrcv()
msgsnd()
msync()
nanosleep()
open()
pause()
poll()
pread()
pthread_cond_timedwait()
pthread_cond_wait()
*pthread_join()
pthread_testcancel()
putmsg()
putpmsg()
pwrite()
read()
readv()
select()
sem_wait()
sigpause()
sigsuspend()
sigtimedwait()
sigwait()
sigwaitinfo()
*sleep()
system()
tcdrain()
*usleep()
wait()
d913 4
a916 4
waitid()
waitpid()
write()
writev()
d919 118
a1036 118
catclose()
catgets()
catopen()
closedir()
closelog()
ctermid()
dbm_close()
dbm_delete()
dbm_fetch()
dbm_nextkey()
dbm_open()
dbm_store()
dlclose()
dlopen()
endgrent()
endpwent()
endutxent()
fclose()
fcntl()
fflush()
fgetc()
fgetpos()
fgets()
fgetwc()
fgetws()
fopen()
fprintf()
fputc()
fputs()
fputwc()
fputws()
fread()
freopen()
fscanf()
fseek()
fseeko()
fsetpos()
ftell()
ftello()
ftw()
fwprintf()
fwrite()
fwscanf()
getc()
getc_unlocked()
getchar()
getchar_unlocked()
getcwd()
getdate()
getgrent()
getgrgid()
getgrgid_r()
getgrnam()
getgrnam_r()
getlogin()
getlogin_r()
getpwent()
* getpwnam()
* getpwnam_r()
* getpwuid()
* getpwuid_r() 
gets()
getutxent()
getutxid()
getutxline()
getw()
getwc()
getwchar()
getwd()
glob()
iconv_close()
iconv_open()
ioctl()
lseek()
mkstemp()
nftw()
opendir()
openlog()
pclose()
perror()
popen()
printf()
putc()
putc_unlocked()
putchar()
putchar_unlocked()
puts()
pututxline()
putw()
putwc()
putwchar()
readdir()
readdir_r()
remove()
rename()
rewind()
rewinddir()
scanf()
seekdir()
semop()
setgrent()
setpwent()
setutxent()
strerror()
syslog()
tmpfile()
tmpnam()
ttyname()
ttyname_r()
ungetc()
ungetwc()
unlink()
vfprintf()
vfwprintf()
vprintf()
vwprintf()
wprintf()
wscanf()
d1038 1
a1038 1
Note, that for fcntl(), for any value of the cmd argument. 
d1081 1
a1081 1
 * We are race safe in that any additions to the lists are made via 
d1084 1
a1084 1
 * It's not guaranteed that a near simultaneous call to pthread_atfork and fork 
d1086 2
a1087 2
 * More rigorous internal syncronisation isn't needed as the user program isn't 
 * guaranteeing their own state. 
d1093 1
a1093 1
 * There is one potential race... Does the result of InterlockedExchangePointer 
d1098 1
a1098 1
__pthread_atforkprepare(void)
d1100 1
a1100 1
  callback *cb=MT_INTERFACE->pthread_prepare;
d1103 2
a1104 2
      cb->cb();
      cb=cb->next;
d1108 2
a1109 2
void 
__pthread_atforkparent(void)
d1111 1
a1111 1
  callback *cb=MT_INTERFACE->pthread_parent;
d1114 2
a1115 2
      cb->cb();
      cb=cb->next;
d1120 1
a1120 1
__pthread_atforkchild(void)
d1122 1
a1122 1
  callback *cb=MT_INTERFACE->pthread_child;
d1125 2
a1126 2
      cb->cb();
      cb=cb->next;
d1134 1
a1134 1
/* Register a set of functions to run before and after fork. 
d1139 1
a1139 1
__pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void))
d1141 1
a1141 1
  callback * prepcb=NULL, * parentcb=NULL, * childcb=NULL;
d1174 1
a1174 1
    prepcb->next=(callback *)InterlockedExchangePointer((LONG *) &MT_INTERFACE->pthread_prepare, (long int) prepcb);
d1183 1
a1183 1
    parentcb->next=(callback *)InterlockedExchangePointer((LONG *)t, (long int) parentcb);
d1192 1
a1192 1
    childcb->next=(callback *)InterlockedExchangePointer((LONG *)t, (long int) childcb);
d1232 1
a1232 1
 * However that's extremely unlikely, so short and sweet will do us 
d1316 1
a1316 1
  /* In future, we may be able to support system scope by escalating the thread 
d1360 1
a1360 1
  if (InterlockedDecrement(&MT_INTERFACE->threadcount) == 0)
d1387 1
a1387 1
  pthread_testcancel();
d1474 1
a1474 1
   * but creation is relatively rare.. 
d1500 1
a1500 1
/* provided for source level compatability. 
d1620 1
a1620 1
  pthread_mutex **themutex=NULL;
d1623 1
a1623 1
  if (( ((pshared_mutex *)(mutex))->flags & SYS_BASE == SYS_BASE ))
d1625 1
a1625 1
    themutex = __pthread_mutex_getpshared(mutex);
d1652 1
a1652 1
  pthread_mutex_t *themutex=mutex;
d1655 1
a1655 1
  if (( ((pshared_mutex *)(mutex))->flags & SYS_BASE == SYS_BASE ))
d1657 1
a1657 1
    themutex = __pthread_mutex_getpshared(mutex);
d1790 1
a1790 1
  if (( ((pshared_mutex *)(mutex))->flags & SYS_BASE == SYS_BASE ))
d1802 2
a1803 2
      mutex = __pthread_mutex_getpshared((pthread_mutex_t *)mutex);
	
d1826 1
a1826 1
  pthread_mutex_t *themutex=(pthread_mutex_t *)mutex;
d1829 1
a1829 1
  if (( ((pshared_mutex *)(mutex))->flags & SYS_BASE == SYS_BASE ))
d1831 1
a1831 1
    themutex = __pthread_mutex_getpshared((pthread_mutex_t *)mutex);
d1838 1
a1838 1
   * Store a priority with each mutex. 
d1848 1
a1848 1
  pthread_mutex_t *themutex=mutex;
d1851 1
a1851 1
  if (( ((pshared_mutex *)(mutex))->flags & SYS_BASE) == SYS_BASE )
d1853 1
a1853 1
    themutex = __pthread_mutex_getpshared(mutex);
d1863 1
a1863 1
  pthread_mutex_t *themutex=mutex;
d1866 1
a1866 1
  if (( ((pshared_mutex *)(mutex))->flags & SYS_BASE) == SYS_BASE )
d1868 1
a1868 1
    themutex = __pthread_mutex_getpshared(mutex);
d1881 1
a1881 1
  if (( ((pshared_mutex *)(mutex))->flags & SYS_BASE) == SYS_BASE )
d1883 1
a1883 1
    mutex = __pthread_mutex_getpshared(mutex);
d1895 1
a1895 1
  if (( ((pshared_mutex *)(mutex))->flags & SYS_BASE) == SYS_BASE )
d1897 1
a1897 1
    mutex = __pthread_mutex_getpshared(mutex);
d1914 1
a1914 1
  pthread_mutex_t *themutex=mutex;
d1917 1
a1917 1
  if (( ((pshared_mutex *)(mutex))->flags & SYS_BASE == SYS_BASE ))
d1919 1
a1919 1
    themutex = __pthread_mutex_getpshared(mutex);
d1925 1
a1925 1
/* Win32 doesn't support mutex priorities - see __pthread_mutex_getprioceiling 
d1946 2
a1947 2
/* Win32 mutex's are equivalent to posix RECURSIVE mutexs. 
 * We need to put glue in place to support other types of mutex's. We map 
d2024 2
a2025 2
  /* we don't use pshared for anything as yet. We need to test PROCESS_SHARED 
   * functionality 
@


1.26
log
@* thread.cc (MTinterface::Init): Remove accidentally checked in code.
@
text
@d297 5
a306 5
  mainthread.win32_obj_id = myself->hProcess;
  mainthread.setThreadIdtoCurrent ();
  /* store the main thread's self pointer */
  TlsSetValue (thread_self_dwTlsIndex, &mainthread);
  
@


1.25
log
@Sun Apr 22 20:22:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* passwd.cc (getpwuid): Check for thread cancellation.
	(getpwuid_r): Ditto.
	(getpwname): Ditto.
	(getpwnam_r): Ditto.
	* thread.h (pthread_mutex): New constructors for pshared operation.
	(MTinterface): Associative array for pshared mutex's.
	* thread.cc (MTinterface::Init): Initailize pshared mutex array.
	(pthread_cond::BroadCast): Implementation notes.
	(pthread_cond::TimedWait): Remove use of SignalObjectAndWait on non-NT systems.
	(pthread_mutex::pthread_mutex(unsigned short)): New function.
	(pthread_mutex::pthread_mutex (pthread_mutex_t *, pthread_mutexattr *)):New function.
	(pthread_mutex::pthread_mutex(pthread_mutexattr *)): Fail on pshared mutex's.
	(__pthread_mutex_getpshared): New function.
	(__pthread_join): Check for thread cancellation.
	(__pthread_cond_timedwait): Support pshared mutex's.
	(__pthread_cond_wait): Ditto.
	(__pthread_condattr_setpshared): Error on PROCESS_SHARED requests.
	(__pthread_mutex_init): Support pshared mutex's.
	(__pthread_mutex_getprioceiling): Ditto.
	(__pthread_mutex_lock): Ditto.
	(__pthread_mutex_trylock): Ditto.
	(__pthread_mutex_unlock): Ditto.
	(__pthread_mutex_destroy): Ditto.
	(__pthread_mutex_setprioceiling): Ditto.
	(__pthread_mutexattr_setpshared): Support PTHREAD_PROCESS_PSHARED requests.
@
text
@a299 2
  /* shm areas a inherited when forking */
  shm_head = NULL;
@


1.24
log
@Sat Apr 14 17:04:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* thread.h (MTinterface): Add threadcount.
	* thread.cc (MTinterface::Init): Set threadcount to 1.
	(__pthread_create): Increment threadcount.
	(__pthread_exit): Decrement threadcount and call exit() from the last thread.
@
text
@d46 1
d300 3
d308 3
d411 2
d432 10
a441 2
  DWORD rv =
    SignalObjectAndWait (mutex->win32_obj_id, win32_obj_id, dwMilliseconds,
a469 5
/* FIXME: New feature completeness.
 * bracketed code is to called when the thread exists, not when delete is called
 * if (destructor && TlsGetValue(dwTlsIndex))
 *   destructor (TlsGetValue(dwTlsIndex));
 */
d490 97
d589 8
d598 2
a599 1
  if (!this->win32_obj_id)
d602 1
d609 1
d630 20
d873 1
a873 1
  the required function list is:
d875 2
a876 2
close()
creat()
d894 1
a894 1
pthread_join()
d908 1
a908 1
sleep()
d911 1
a911 1
usleep()
d977 4
a980 4
getpwnam()
getpwnam_r()
getpwuid()
getpwuid_r()
d1370 1
d1386 3
a1388 1
    }				/* End if */
d1612 2
d1621 1
d1624 5
a1628 1
  if (!verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
d1634 1
a1634 1
    if ((*cond)->mutex && ((*cond)->mutex != (*mutex)))
d1638 2
a1639 2
  (*cond)->mutex = (*mutex);
  InterlockedIncrement (&((*mutex)->condwaits));
d1644 1
a1644 1
  InterlockedDecrement (&((*mutex)->condwaits));
d1653 1
d1656 4
a1659 1
  if (!verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
d1665 1
a1665 1
    if ((*cond)->mutex && ((*cond)->mutex != (*mutex)))
d1669 2
a1670 2
  (*cond)->mutex = (*mutex);
  InterlockedIncrement (&((*mutex)->condwaits));
d1675 1
a1675 1
  InterlockedDecrement (&((*mutex)->condwaits));
d1709 3
d1791 3
d1800 13
d1827 1
d1830 4
a1833 1
  if (!verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
d1849 1
d1852 4
a1855 1
  if (!verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
d1857 1
a1857 1
  (*mutex)->Lock ();
d1864 1
d1867 4
a1870 1
  if (!verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
d1872 1
a1872 1
  if ((*mutex)->TryLock () == WAIT_TIMEOUT)
d1882 3
d1896 3
d1915 1
d1918 4
a1921 1
  if (!verifyable_object_isvalid (*mutex, PTHREAD_MUTEX_MAGIC))
d2028 1
a2028 1
  if (pshared != PTHREAD_PROCESS_PRIVATE)
@


1.23
log
@* fork.cc (fork_child): Call the __pthread_atforkchild function.
(fork_parent): Call the __pthread_atforkparent function.
* cygwin.din: Export pthread_atfork.
* thread.h (callback): New class.
(MTinterface): Use it.
* thread.cc (__pthread_atforkprepare): New function.
(__pthread_atforkparent): New function.
(__pthread_atforkchild): New function.
(__pthread_atfork): New function.
* pthread.cc (pthread_atfork): New function.
@
text
@d294 1
d668 1
a1218 1
// FIXME: run the destructors of thread_key items here
d1221 4
a1224 1
  ExitThread (0);
@


1.22
log
@	* configure.in: Remove PTH_ALLOW.
	* cygwin.din: Remove @@PTH_ALLOW@@ prefixes to pthread functions.
	Add new pthread exports.
	* pthread.cc: New wrapper functions for the above new exports.
	* sched.cc (valid_sched_parameters): New function.
	(sched_setparam): Use it.
	(sched_set_thread_priority): New function. Used by pthread_sched*.
	* thread.cc (pthread_key_destructor::InsertAfter): New function.
	(pthread_key_destructor::UnlinkNext): New function.
	(pthread_key_destructor::Next): New function.
	(pthread_key_destructor_list::Insert): New function.
	(pthread_key_destructor_list::Remove): New function.
	(pthread_key_destructor_list::Pop): New function.
	(pthread_key_destructor::pthread_key_destructor): New function.
	(pthread_key_destructor_list::IterateNull): New function.
	(MTinterface::Init): Initialise new member.
	(pthread::pthread): Initialise new members.
	(pthread::create): Copy new attributes. Set the new thread priority.
	(pthread_attr::pthread_attr): Initialise new members.
	(pthread_key::pthread_key): Setup destructor function.
	(pthread_key::~pthread_key): Remove destructor function.
	(pthread_mutexattr::pthread_mutexattr): New function.
	(pthread_mutexattr::~pthread_mutexattr): New function.
	(__pthread_once): New function.
	(__pthread_cleanup): New function.
	(__pthread_cancel): New function.
	(__pthread_setcancelstate): New function.
	(__pthread_setcanceltype): New function.
	(__pthread_testcancel): New function.
	(__pthread_attr_getinheritsched): New function.
	(__pthread_attr_getschedparam): New function.
	(__pthread_attr_getschedpolicy): New function.
	(__pthread_attr_getscope): New function.
	(__pthread_attr_setinheritsched): New function.
	(__pthread_attr_setschedparam): New function.
	(__pthread_attr_setschedpolicy): New function.
	(__pthread_attr_setscope): New function.
	(__pthread_exit): Call any key destructors on thread exit.
	(__pthread_join): Use the embedded attr values.
	(__pthread_detach): Use the embedded attr values.
	(__pthread_getconcurrency): New function.
	(__pthread_getschedparam): New function.
	(__pthread_key_create): Pass the destructor on object creation.
	(__pthread_key_delete): Correct incorrect prototype.
	(__pthread_setconcurrency): New function.
	(__pthread_setschedparam): New function.
	(__pthread_cond_timedwait): Support static mutex initialisers.
	(__pthread_cond_wait): Ditto.
	(__pthread_mutex_getprioceiling): New function.
	(__pthread_mutex_lock): Support static mutex initialisers.
	(__pthread_mutex_trylock): Ditto.
	(__pthread_mutex_unlock): Ditto.
	(__pthread_mutex_destroy): Ditto.
	(__pthread_mutex_setprioceiling): New function.
	(__pthread_mutexattr_getprotocol): New function.
	(__pthread_mutexattr_getpshared): New function.
	(__pthread_mutexattr_gettype): New function.
	(__pthread_mutexattr_init): New function.
	(__pthread_mutexattr_destroy): New function.
	(__pthread_mutexattr_setprotocol): New function.
	(__pthread_mutexattr_setprioceiling): New function.
	(__pthread_mutexattr_getprioceiling): New function.
	(__pthread_mutexattr_setpshared): New function.
	(__pthread_mutexattr_settype): New function.
	Remove stubs for non MT_SAFE compilation.
	* thread.h: Remove duplicate #defines.
	Add prototypes for new functions in thread.cc.
	(pthread_key_destructor): New class.
	(pthread_key_destructor_list): New class.
	(pthread_attr): Add new members.
	(pthread): Remove members that are duplicated in the pthread_attr class.
	(pthread_mutex_attr): Add new members.
	(pthread_once): New class.
	* include/pthread.h: Add prototypes for new functions exported from cygwin1.dll.
	Remove typedefs.
	* include/sched.h: Add prototypes for new functions in sched.cc.
	* include/cygwin/types.h: Add typedefs from pthread.h
@
text
@d938 118
@


1.21
log
@* Makefile.in: Put -lgcc last in list of libraries, since stdc++ library needs
it.
* cygwin.din: Remove obsolete "__empty" export.
* exceptions.cc (call_signal_handler_now): Force inclusion of function even
when -finline-functions is specified.
* sigproc.h: Remove obsolete call_signal_handler declaration.
* fhandler_console.cc (cp_get_internal): New function.
(cp_convert): New function.
(con_to_str): New function.
(str_to_con): New function.
(fhandler_console::read): Replace OemToCharBuff with con_to_str.
(fhandler_console::write_normal): Replace CharToOemBuff with str_to_con.
@
text
@d13 15
d49 86
a136 2
#define NOT_IMP(n)  system_printf ("not implemented %s\n", n); return 0;

d293 2
d312 2
a313 1
pthread::pthread ():verifyable_object (PTHREAD_MAGIC), win32_obj_id (0)
d335 2
d349 9
a357 1
    ResumeThread (win32_obj_id);
d361 2
a362 1
joinable (PTHREAD_CREATE_JOINABLE), stacksize (0)
d364 1
d371 2
a372 2
pthread_condattr::pthread_condattr ():verifyable_object 
(PTHREAD_CONDATTR_MAGIC), shared (PTHREAD_PROCESS_PRIVATE)
d386 3
a388 4
  this->win32_obj_id =::CreateEvent (&sec_none_nih, 
	false,	/* auto signal reset - which I think is pthreads like ? */
	false,	/* start non signaled */
	NULL /* no name */ );
d428 1
a428 1
      return 0;		/* POSIX doesn't allow errors after we modify the mutex state */
d432 1
a432 1
      return 0;		/* we have been signaled */
d438 1
a438 1
pthread_key::pthread_key ():verifyable_object (PTHREAD_KEY_MAGIC)
d443 5
d457 2
d483 1
a483 1
};
d509 9
d672 267
d952 43
d1015 51
d1075 1
a1075 1
__pthread_attr_getstacksize (pthread_attr_t * attr, size_t * size)
d1098 1
d1111 1
a1111 1
  if ((*thread)->joinable == PTHREAD_CREATE_DETACHED)
d1119 1
a1119 1
      (*thread)->joinable = PTHREAD_CREATE_DETACHED;
d1134 1
a1134 1
  if ((*thread)->joinable == PTHREAD_CREATE_DETACHED)
d1140 1
a1140 1
  (*thread)->joinable = PTHREAD_CREATE_DETACHED;
d1173 24
d1215 1
a1215 1
  *key = new pthread_key ();
d1227 1
a1227 1
__pthread_key_delete (pthread_key_t * key)
d1229 1
a1229 1
  if (!verifyable_object_isvalid (*key, PTHREAD_KEY_MAGIC))
d1232 1
a1232 1
  delete (*key);
d1236 30
d1354 2
d1381 2
d1449 1
a1449 1
__pthread_kill (pthread_t * thread, int sig)
d1454 1
a1454 1
  if (!verifyable_object_isvalid (*thread, PTHREAD_MAGIC))
d1457 2
a1458 2
  if ((*thread)->sigs)
    myself->setthread2signal (*thread);
d1485 2
a1486 1
pthread_t __pthread_self ()
d1499 9
d1529 19
d1550 2
d1561 2
d1573 2
d1584 2
d1598 131
d1793 1
a1793 176

#else

// empty functions needed when makeing the dll without mt_safe support
extern "C"
{
int __pthread_create (pthread_t *, const pthread_attr_t *,
		      TFD (start_routine), void *arg)
{
  return -1;
}
int __pthread_attr_init (pthread_attr_t * attr)
{
  return -1;
}
int __pthread_attr_destroy (pthread_attr_t * attr)
{
  return -1;
}
int __pthread_attr_setdetachstate (pthread_attr_t * attr, int detachstate)
{
  return -1;
}
int
  __pthread_attr_getdetachstate (const pthread_attr_t * attr,
				 int *detachstate)
{
  return -1;
}
int __pthread_attr_setstacksize (pthread_attr_t * attr, size_t size)
{
  return -1;
}
int __pthread_attr_getstacksize (pthread_attr_t * attr, size_t * size)
{
  return -1;
}
/* these cannot be supported on win32 - the os allocates it's own stack space..
 __pthread_attr_setstackaddr (...){ return -1; };
 __pthread_attr_getstackaddr (...){ return -1; };
*/
int __pthread_exit (void *value_ptr)
{
  return -1;
}

int __pthread_join (pthread_t thread_id, void **return_val)
{
  return -1;
}

unsigned long __pthread_getsequence_np (pthread_t * thread)
{
  return 0;
}
int __pthread_key_create (pthread_key_t * key)
{
  return -1;
}
int __pthread_key_delete (pthread_key_t * key)
{
  return -1;
}
int __pthread_setspecific (pthread_key_t * key, const void *value)
{
  return -1;
}
void *__pthread_getspecific (pthread_key_t * key)
{
  return NULL;
}
int __pthread_kill (pthread_t * thread, int sig)
{
  return -1;
}
int __pthread_sigmask (int operation, const sigset_t * set,
		       sigset_t * old_set)
{
  return -1;
}
pthread_t __pthread_self ()
{
  return -1;
}
int __pthread_equal (pthread_t * t1, pthread_t * t2)
{
  return -1;
}
int __pthread_mutex_init (pthread_mutex_t *, const pthread_mutexattr_t *)
{
  return -1;
}
int __pthread_mutex_lock (pthread_mutex_t *)
{
  return -1;
}
int __pthread_mutex_trylock (pthread_mutex_t *)
{
  return -1;
}
int __pthread_mutex_unlock (pthread_mutex_t *)
{
  return -1;
}
int __pthread_mutex_destroy (pthread_mutex_t *)
{
  return -1;
}
int __pthread_cond_destroy (pthread_cond_t *)
{
  return -1;
}
int __pthread_cond_init (pthread_cond_t *, const pthread_condattr_t *)
{
  return -1;
}
int __pthread_cond_signal (pthread_cond_t *)
{
  return -1;
}
int __pthread_cond_broadcast (pthread_cond_t *)
{
  return -1;
}
int __pthread_cond_timedwait (pthread_cond_t *, pthread_mutex_t *,
			      const struct timespec *)
{
  return -1;
}
int __pthread_cond_wait (pthread_cond_t *, pthread_mutex_t *)
{
  return -1;
}
int __pthread_condattr_init (pthread_condattr_t *)
{
  return -1;
}
int __pthread_condattr_destroy (pthread_condattr_t *)
{
  return -1;
}
int __pthread_condattr_getpshared (pthread_condattr_t *, int *)
{
  return -1;
}
int __pthread_condattr_setpshared (pthread_condattr_t *, int)
{
  return -1;
}
int __sem_init (sem_t * sem, int pshared, unsigned int value)
{
  return -1;
}
int __sem_destroy (sem_t * sem)
{
  return -1;
}
int __sem_wait (sem_t * sem)
{
  return -1;
}
int __sem_trywait (sem_t * sem)
{
  return -1;
}
int __sem_post (sem_t * sem)
{
  return -1;
}
struct _reent *_reent_clib ()
{
  return NULL;
  }
}

#endif				// MT_SAFE
@


1.20
log
@* sched.cc: New file.  Implement sched*.
* include/sched.h: New file.  User land includes for sched*.
* Makefile.in: Add sched.o
* cygwin.din: Add exports for sched*.
@
text
@d1082 31
a1112 31
  int __pthread_create (pthread_t *, const pthread_attr_t *,
			TFD (start_routine), void *arg)
  {
    return -1;
  }
  int __pthread_attr_init (pthread_attr_t * attr)
  {
    return -1;
  }
  int __pthread_attr_destroy (pthread_attr_t * attr)
  {
    return -1;
  }
  int __pthread_attr_setdetachstate (pthread_attr_t * attr, int detachstate)
  {
    return -1;
  }
  int
    __pthread_attr_getdetachstate (const pthread_attr_t * attr,
				   int *detachstate)
  {
    return -1;
  }
  int __pthread_attr_setstacksize (pthread_attr_t * attr, size_t size)
  {
    return -1;
  }
  int __pthread_attr_getstacksize (pthread_attr_t * attr, size_t * size)
  {
    return -1;
  }
d1114 7
a1120 7
   __pthread_attr_setstackaddr (...){ return -1; };
   __pthread_attr_getstackaddr (...){ return -1; };
 */
  int __pthread_exit (void *value_ptr)
  {
    return -1;
  }
d1122 4
a1125 4
  int __pthread_join (pthread_t thread_id, void **return_val)
  {
    return -1;
  }
d1127 121
a1247 121
  unsigned long __pthread_getsequence_np (pthread_t * thread)
  {
    return 0;
  }
  int __pthread_key_create (pthread_key_t * key)
  {
    return -1;
  }
  int __pthread_key_delete (pthread_key_t * key)
  {
    return -1;
  }
  int __pthread_setspecific (pthread_key_t * key, const void *value)
  {
    return -1;
  }
  void *__pthread_getspecific (pthread_key_t * key)
  {
    return NULL;
  }
  int __pthread_kill (pthread_t * thread, int sig)
  {
    return -1;
  }
  int __pthread_sigmask (int operation, const sigset_t * set,
			 sigset_t * old_set)
  {
    return -1;
  }
  pthread_t __pthread_self ()
  {
    return -1;
  }
  int __pthread_equal (pthread_t * t1, pthread_t * t2)
  {
    return -1;
  }
  int __pthread_mutex_init (pthread_mutex_t *, const pthread_mutexattr_t *)
  {
    return -1;
  }
  int __pthread_mutex_lock (pthread_mutex_t *)
  {
    return -1;
  }
  int __pthread_mutex_trylock (pthread_mutex_t *)
  {
    return -1;
  }
  int __pthread_mutex_unlock (pthread_mutex_t *)
  {
    return -1;
  }
  int __pthread_mutex_destroy (pthread_mutex_t *)
  {
    return -1;
  }
  int __pthread_cond_destroy (pthread_cond_t *)
  {
    return -1;
  }
  int __pthread_cond_init (pthread_cond_t *, const pthread_condattr_t *)
  {
    return -1;
  }
  int __pthread_cond_signal (pthread_cond_t *)
  {
    return -1;
  }
  int __pthread_cond_broadcast (pthread_cond_t *)
  {
    return -1;
  }
  int __pthread_cond_timedwait (pthread_cond_t *, pthread_mutex_t *,
				const struct timespec *)
  {
    return -1;
  }
  int __pthread_cond_wait (pthread_cond_t *, pthread_mutex_t *)
  {
    return -1;
  }
  int __pthread_condattr_init (pthread_condattr_t *)
  {
    return -1;
  }
  int __pthread_condattr_destroy (pthread_condattr_t *)
  {
    return -1;
  }
  int __pthread_condattr_getpshared (pthread_condattr_t *, int *)
  {
    return -1;
  }
  int __pthread_condattr_setpshared (pthread_condattr_t *, int)
  {
    return -1;
  }
  int __sem_init (sem_t * sem, int pshared, unsigned int value)
  {
    return -1;
  }
  int __sem_destroy (sem_t * sem)
  {
    return -1;
  }
  int __sem_wait (sem_t * sem)
  {
    return -1;
  }
  int __sem_trywait (sem_t * sem)
  {
    return -1;
  }
  int __sem_post (sem_t * sem)
  {
    return -1;
  }
  struct _reent *_reent_clib ()
  {
    return NULL;
@


1.19
log
@Fix spacing, copyrights.
@
text
@d21 1
d30 1
a37 42
#define CHECKHANDLE(rval, release) \
  if (!item->HandleOke ()) \
    { \
      if (release) \
	item->used=false; \
      return rval; \
    }

#define GETTHREAD(n) \
  if (!thread) system_printf ("thread is NULL");\
  SetResourceLock (LOCK_THREAD_LIST, READ_LOCK, n);\
  ThreadItem *item=user_data->threadinterface->GetThread (thread); \
  ReleaseResourceLock (LOCK_THREAD_LIST, READ_LOCK, n); \
  if (!item) return EINVAL; \
  CHECKHANDLE (EINVAL, 0);

#define GETMUTEX(n) \
  SetResourceLock (LOCK_MUTEX_LIST, READ_LOCK, n); \
  MutexItem* item=user_data->threadinterface->GetMutex (mutex); \
  ReleaseResourceLock (LOCK_MUTEX_LIST, READ_LOCK, n); \
  if (!item) return EINVAL;  \
  CHECKHANDLE (EINVAL, 0);

#define GETSEMA(n) \
  SetResourceLock (LOCK_SEM_LIST, READ_LOCK, n); \
  SemaphoreItem* item=user_data->threadinterface->GetSemaphore (sem); \
  ReleaseResourceLock (LOCK_SEM_LIST, READ_LOCK, n); \
  if (!item) return EINVAL; \
  CHECKHANDLE (EINVAL, 0);

#define GETCOND(n) \
  SetResourceLock (LOCK_COND_LIST, READ_LOCK, n); \
  CondItem *item=user_data->threadinterface->GetCond (cond); \
  ReleaseResourceLock (LOCK_COND_LIST, READ_LOCK, n); \
  if (!item) return EINVAL; \
  CHECKHANDLE (EINVAL, 0);

#define CHECKITEM(rn, rm, fn) \
  if (!item) { \
    ReleaseResourceLock (rn, rm, fn); \
    return EINVAL;  }; \

d42 2
a43 1
  struct __reent_t *_r = (struct __reent_t *) TlsGetValue (MT_INTERFACE->reent_index);
d75 3
a77 2
  thread_printf ("Get Resource lock %d ==> %p for %p , real : %d , threadid %d ",
		 _resid, &lock, user_data, myself->pid, GetCurrentThreadId ());
d101 2
a102 1
  thread_printf ("Release resource lock %d mode %d for %s done", _res_id, _mode, _function);
d118 4
a121 3
  thread_printf ("Assert Resource lock %d ==> for %p , real : %d , threadid %d count %d owner %d",
		 _res_id, user_data, myself->pid, GetCurrentThreadId (),
		 user_data->resourcelocks->count, user_data->resourcelocks->owner);
a152 71
// Thread interface

void
MTinterface::ReleaseItem (MTitem * _item)
{
  _item->used = false;
}

MTitem *
MTinterface::Find (void *_value, int (*comp) (void *, void *), register int &_index, MTList * _list)
{
  register MTitem *current = NULL;
  for (; _index < _list->index; _index++)
    {
      current = _list->items[_index];
      if (current->used && comp (current, _value))
	break;
      current = NULL;
    }
  return current;
}

int
MTinterface::Find (MTitem & _item, MTList * _list)
{
  register MTitem *current;
  register int _index = 0;
  for (; _index < _list->index; _index++)
    {
      current = _list->items[_index];
      if (current->used && current == &_item)
	break;
    }
  return (_index == _list->index ? -1 : _index);
}

int
MTinterface::FindNextUnused (MTList * _list)
{
  register int i = 0;
  for (; i < _list->index && _list->items[i] != NULL && _list->items[i]->used && _list->items[i]->joinable != 'Y';  i++)
    continue;
  return i;
}

MTitem *
MTinterface::GetItem (int _index, MTList * _list)
{
  return (_index < _list->index ? _list->items[_index] : NULL);
}

MTitem *
MTinterface::SetItem (int _index, MTitem * _item, MTList * _list)
{
  if (_index == _list->index && _list->index < MT_MAX_ITEMS)
    _list->index++;
  return (_index < _list->index ? _list->items[_index] = _item : NULL);
}

int
CmpPthreadObj (void *_i, void *_value)
{
  return ((MTitem *) _i)->Id () == *(int *) _value;
}

int
CmpThreadId (void *_i, void *_id)
{
  return ((ThreadItem *) _i)->thread_id == * (DWORD *) _id;
}

d184 10
a196 1
  // create entry for main thread
d198 4
a201 6
  ThreadItem *item = (ThreadItem *) GetItem (0, &threadlist);

  item = (ThreadItem *) SetItem (0, &mainthread, &threadlist);
  item->used = true;
  item->win32_obj_id = myself->hProcess;
  item->thread_id = GetCurrentThreadId ();
d211 1
a211 2
ThreadItem *
MTinterface::CreateThread (pthread_t * t, TFD (func), void *arg, pthread_attr_t a)
d213 1
a213 1
  AssertResourceOwner (LOCK_THREAD_LIST, WRITE_LOCK | READ_LOCK);
d215 5
a219 1
  int i = FindNextUnused (&threadlist);
a220 5
  ThreadItem *item = (ThreadItem *) GetItem (i, &threadlist);
  if (!item)
    item = (ThreadItem *) SetItem (i, new ThreadItem (), &threadlist);
  if (!item)
    system_printf ("thread creation failed");
d222 7
a228 4
  item->used = true;
  item->function = func;
  item->arg = arg;
  item->attr = a;
d230 7
a236 2
  item->win32_obj_id = ::CreateThread (&sec_none_nih, item->attr.stacksize,
   (LPTHREAD_START_ROUTINE) thread_init_wrapper, item, 0, &item->thread_id);
d238 3
a240 1
  CHECKHANDLE (NULL, 1);
d242 5
a246 1
  *t = (pthread_t) item->win32_obj_id;
d248 3
a250 1
  return item;
d253 1
a253 2
MutexItem *
MTinterface::CreateMutex (pthread_mutex_t * mutex)
d255 1
a255 1
  AssertResourceOwner (LOCK_MUTEX_LIST, WRITE_LOCK | READ_LOCK);
d257 4
a260 1
  int i = FindNextUnused (&mutexlist);
d262 3
a264 6
  MutexItem *item = (MutexItem *) GetItem (i, &mutexlist);
  if (!item)
    item = (MutexItem *) SetItem (i, new MutexItem (), &mutexlist);
  if (!item)
    system_printf ("mutex creation failed");
  item->used = true;
d266 5
a270 1
  item->win32_obj_id = ::CreateMutex (&sec_none_nih, false, NULL);
d272 4
a275 1
  CHECKHANDLE (NULL, 1);
d277 3
a279 1
  *mutex = (pthread_mutex_t) item->win32_obj_id;
d281 4
a284 1
  return item;
d287 2
a288 2
ThreadItem *
MTinterface::GetCallingThread ()
d290 6
a295 4
  AssertResourceOwner (LOCK_THREAD_LIST, READ_LOCK);
  DWORD id = GetCurrentThreadId ();
  int index = 0;
  return (ThreadItem *) Find (&id, &CmpThreadId, index, &threadlist);
d298 10
a307 2
ThreadItem *
MTinterface::GetThread (pthread_t * _t)
d309 14
a322 3
  AssertResourceOwner (LOCK_THREAD_LIST, READ_LOCK);
  int index = 0;
  return (ThreadItem *) Find (_t, &CmpPthreadObj, index, &threadlist);
d325 1
a325 2
MutexItem *
MTinterface::GetMutex (pthread_mutex_t * mp)
d327 3
a329 3
  AssertResourceOwner (LOCK_MUTEX_LIST, READ_LOCK);
  int index = 0;
  return (MutexItem *) Find (mp, &CmpPthreadObj, index, &mutexlist);
d332 12
a343 2
SemaphoreItem *
MTinterface::GetSemaphore (sem_t * sp)
d345 3
a347 3
  AssertResourceOwner (LOCK_SEM_LIST, READ_LOCK);
  int index = 0;
  return (SemaphoreItem *) Find (sp, &CmpPthreadObj, index, &semalist);
d350 2
a351 2
CondItem *
MTinterface::GetCond (pthread_cond_t * mp)
d353 2
a354 3
  AssertResourceOwner (LOCK_COND_LIST, READ_LOCK);
  int index = 0;
  return (CondItem *) Find (mp, &CmpPthreadObj, index, &condlist);
d357 9
a365 2
void
MTitem::Destroy ()
d367 2
a368 1
  CloseHandle (win32_obj_id);
d372 1
a372 1
MutexItem::Lock ()
d378 1
a378 1
MutexItem::TryLock ()
d384 1
a384 1
MutexItem::UnLock ()
d389 1
a389 2
SemaphoreItem *
MTinterface::CreateSemaphore (sem_t * _s, int pshared, int _v)
d391 5
a395 19
  AssertResourceOwner (LOCK_SEM_LIST, WRITE_LOCK | READ_LOCK);

  int i = FindNextUnused (&semalist);

  SemaphoreItem *item = (SemaphoreItem *) GetItem (i, &semalist);
  if (!item)
    item = (SemaphoreItem *) SetItem (i, new SemaphoreItem (), &semalist);
  if (!item)
    system_printf ("semaphore creation failed");
  item->used = true;
  item->shared = pshared;

  item->win32_obj_id = ::CreateSemaphore (&sec_none_nih, _v, LONG_MAX, NULL);

  CHECKHANDLE (NULL, 1);

  *_s = (sem_t) item->win32_obj_id;

  return item;
d398 1
a398 2
int
SemaphoreItem::Wait ()
d400 2
a401 1
  return WaitForSingleObject (win32_obj_id, INFINITE);
d404 2
a405 2
int
SemaphoreItem::Post ()
d408 1
a408 1
  return ReleaseSemaphore (win32_obj_id, 1, &pc);
d412 1
a412 1
SemaphoreItem::TryWait ()
d414 7
a420 1
  return WaitForSingleObject (win32_obj_id, 0);
d423 2
a424 3
/* Condition Items */
CondItem *
MTinterface::CreateCond (pthread_cond_t * cond, const pthread_condattr_t * attr)
d426 1
a426 24
  AssertResourceOwner (LOCK_COND_LIST, WRITE_LOCK | READ_LOCK);

  int i = FindNextUnused (&condlist);

  CondItem *item = (CondItem *) GetItem (i, &condlist);
  if (!item)
    item = (CondItem *) SetItem (i, new CondItem (), &condlist);
  if (!item)
    system_printf ("cond creation failed");
  item->used = true;
  item->shared = attr ? attr->shared: PTHREAD_PROCESS_PRIVATE;
  item->mutexitem=NULL;
  item->waiting=0;

  item->win32_obj_id = ::CreateEvent (&sec_none_nih,
	false, /* auto signal reset - which I think is pthreads like ? */
	false, /* start non signaled */
	NULL /* no name */);

  CHECKHANDLE (NULL, 1);

  *cond = (pthread_cond_t) item->win32_obj_id;

  return item;
d429 2
a430 3

int
CondItem::Signal ()
a431 1
  return !PulseEvent (win32_obj_id);
d434 1
a434 2
int
CondItem::Wait ()
d436 1
a436 6
  DWORD rv = SignalObjectAndWait (mutexitem->win32_obj_id, win32_obj_id, INFINITE, false);
  switch (rv) {
    case WAIT_FAILED: return 0; /* POSIX doesn't allow errors after we modify the mutex state */
    case WAIT_OBJECT_0: return 0; /* we have been signaled */
    default: return 0;
  }
d439 3
a441 2
int
CondItem::TimedWait (DWORD dwMilliseconds)
d443 5
a447 7
  DWORD rv = SignalObjectAndWait (mutexitem->win32_obj_id, win32_obj_id, dwMilliseconds, false);
  switch (rv) {
    case WAIT_FAILED: return 0; /* POSIX doesn't allow errors after we modify the mutex state */
    case WAIT_ABANDONED: return ETIMEDOUT;
    case WAIT_OBJECT_0: return 0; /* we have been signaled */
    default: return 0;
  }
d451 1
a451 1
CondItem::BroadCast ()
d453 5
a457 1
  if (!mutexitem)
d459 1
a459 5
  PulseEvent (win32_obj_id);
  while (InterlockedDecrement (&waiting)!=0)
    PulseEvent (win32_obj_id);
  mutexitem=NULL;
  return 0;
a462 1

d468 1
a468 1
  ThreadItem *thread = (ThreadItem *) _arg;
d495 1
d499 3
d507 2
a508 1
  thread_printf ("started thread %p %p %p %p %p %p", _arg, &local_clib, _impure_ptr, thread, thread->function, thread->arg);
d513 1
a513 1
  // FIXME : cleanup code
d515 6
a520 3
  //  thread->used = false;	// release thread entry
    thread->return_ptr = ret;
  ExitThread (0);
d524 2
a525 1
__pthread_create (pthread_t * thread, const pthread_attr_t * attr, TFD (start_routine), void *arg)
d527 11
a537 1
  SetResourceLock (LOCK_THREAD_LIST, WRITE_LOCK | READ_LOCK, "__pthread_create");
d539 2
a540 2
  pthread_attr_t a;
  ThreadItem *item;
d542 5
a546 3
  if (attr)
    item = MT_INTERFACE->CreateThread (thread, start_routine, arg, *attr);
  else
d548 3
a550 2
      __pthread_attr_init (&a);
      item = MT_INTERFACE->CreateThread (thread, start_routine, arg, a);
d552 2
d555 8
a562 3
  CHECKITEM (LOCK_THREAD_LIST, WRITE_LOCK | READ_LOCK, "__pthread_create")

  ReleaseResourceLock (LOCK_THREAD_LIST, WRITE_LOCK | READ_LOCK, "__pthread_create");
d567 1
a567 1
__pthread_attr_init (pthread_attr_t * attr)
d569 3
a571 1
  attr->stacksize = 0;
d578 3
a580 1
  attr->stacksize = size;
d587 3
a589 1
  *size = attr->stacksize;
d594 1
a594 1
__pthread_attr_destroy (pthread_attr_t * /*attr*/)
d596 4
d603 1
a603 1
int
d606 5
a610 2
  ThreadItem *item = MT_INTERFACE->GetCallingThread ();
  item->return_ptr = value_ptr;
a611 1
  return 0;
d617 2
a618 1
  ThreadItem *item=user_data->threadinterface->GetThread (thread);
d620 3
a622 7

  if (!item)
     return ESRCH;

  if (item->joinable == 'N')
  {
     if (return_val)
d624 2
a625 2
     return EINVAL;
  }
d627 6
a632 6
  {
     item->joinable = 'N';
     WaitForSingleObject ((HANDLE)*thread, INFINITE);
     if (return_val)
	*return_val = item->return_ptr;
  }/* End if*/
d640 2
a641 3
  ThreadItem *item=user_data->threadinterface->GetThread (thread);
  if (!item)
     return ESRCH;
d643 5
a647 5
  if (item->joinable == 'N')
  {
     item->return_ptr = NULL;
     return EINVAL;
  }
d649 1
a649 1
  item->joinable = 'N';
d656 2
a657 3
  ThreadItem *item=user_data->threadinterface->GetThread (thread);
  if (!item)
     return ESRCH;
d659 5
a663 5
  if (item->suspended == false)
  {
     item->suspended = true;
     SuspendThread ((HANDLE)*thread);
  }
d672 6
a677 7
  ThreadItem *item=user_data->threadinterface->GetThread (thread);
  if (!item)
     return ESRCH;

  if (item->suspended == true)
	ResumeThread ((HANDLE)*thread);
  item->suspended = false;
d685 3
a687 2
  GETTHREAD ("__pthread_getsequence_np");
  return item->GetThreadId ();
d692 1
a692 1
__pthread_key_create (pthread_key_t */*key*/)
d694 15
a708 1
  NOT_IMP ("_p_key_create\n");
d712 1
a712 1
__pthread_key_delete (pthread_key_t */*key*/)
d714 5
a718 1
  NOT_IMP ("_p_key_delete\n");
d720 2
d723 1
a723 1
__pthread_setspecific (pthread_key_t */*key*/, const void */*value*/)
d725 4
a728 1
  NOT_IMP ("_p_key_setsp\n");
d730 1
d732 1
a732 1
__pthread_getspecific (pthread_key_t */*key*/)
d734 5
a738 1
  NOT_IMP ("_p_key_getsp\n");
d744 1
a744 1
__pthread_cond_destroy (pthread_cond_t *cond)
d746 2
a747 1
  SetResourceLock (LOCK_COND_LIST, READ_LOCK | WRITE_LOCK, "__pthread_cond_destroy");
d749 3
a751 3
  CondItem *item = MT_INTERFACE->GetCond (cond);

  CHECKITEM (LOCK_COND_LIST, WRITE_LOCK | READ_LOCK, "__pthread_cond_init");
d753 2
a754 1
  item->Destroy ();
a755 4
  MT_INTERFACE->ReleaseItem (item);

  ReleaseResourceLock (LOCK_COND_LIST, READ_LOCK | WRITE_LOCK, "__pthread_cond_destroy")
;
d760 1
a760 1
__pthread_cond_init (pthread_cond_t *cond, const pthread_condattr_t *attr)
d762 1
a762 1
  if (attr && (attr->valid != 0xf341))
a763 1
  SetResourceLock (LOCK_COND_LIST, WRITE_LOCK | READ_LOCK, "__pthread_cond_init");
d765 4
a768 1
  CondItem *item = MT_INTERFACE->CreateCond (cond, attr);
d770 6
a775 1
  CHECKITEM (LOCK_COND_LIST, WRITE_LOCK | READ_LOCK, "__pthread_cond_init");
a776 1
  ReleaseResourceLock (LOCK_COND_LIST, WRITE_LOCK | READ_LOCK, "__pthread_cond_init");
a777 1

d781 1
a781 1
__pthread_cond_broadcast (pthread_cond_t *cond)
d783 2
a784 1
  GETCOND("_pthread_cond_lock");
d786 1
a786 1
  item->BroadCast ();
d792 1
a792 1
__pthread_cond_signal (pthread_cond_t *cond)
d794 2
a795 1
  GETCOND("_pthread_cond_lock");
d797 1
a797 1
  item->Signal ();
d803 2
a804 1
__pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime)
d809 1
a809 6
  SetResourceLock (LOCK_MUTEX_LIST, READ_LOCK, "_ptherad_mutex_lock");
  MutexItem* mutexitem=user_data->threadinterface->GetMutex (mutex);
  ReleaseResourceLock (LOCK_MUTEX_LIST, READ_LOCK, "_ptherad_mutex_lock");
  if (!mutexitem) return EINVAL;
  if (!mutexitem->HandleOke ())
  {
d811 1
a811 3
  }
  GETCOND("_pthread_cond_lock");
  if (item->mutexitem && (item->mutexitem != mutexitem))
d814 12
a825 6
  item->mutexitem=mutexitem;
  InterlockedIncrement (&item->waiting);
  rv = item->TimedWait (abstime->tv_sec*1000);
  mutexitem->Lock ();
  if (InterlockedDecrement (&item->waiting)==0)
    item->mutexitem=NULL;
d831 1
a831 1
__pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex)
d834 1
a834 6
  SetResourceLock (LOCK_MUTEX_LIST, READ_LOCK, "_ptherad_mutex_lock");
  MutexItem* mutexitem=user_data->threadinterface->GetMutex (mutex);
  ReleaseResourceLock (LOCK_MUTEX_LIST, READ_LOCK, "_ptherad_mutex_lock");
  if (!mutexitem) return EINVAL;
  if (!mutexitem->HandleOke ())
  {
d836 1
a836 3
  }
  GETCOND("_pthread_cond_lock");
  if (item->mutexitem && (item->mutexitem != mutexitem))
d839 12
a850 6
  item->mutexitem=mutexitem;
  InterlockedIncrement (&item->waiting);
  rv = item->Wait ();
  mutexitem->Lock ();
  if (InterlockedDecrement (&item->waiting)==0)
    item->mutexitem=NULL;
d858 7
a864 2
  condattr->shared = 0;
  condattr->valid  = 0xf341; /* Roberts magic number */
d871 1
a871 1
  if (!attr || (attr->valid != 0xf341))
d873 1
a873 1
  *pshared = attr->shared;
d880 1
a880 1
  if (!attr || (attr->valid != 0xf341) || (pshared <0) || (pshared > 1))
d882 3
a884 1
  attr->shared = pshared;
d891 4
a894 3
  if (!condattr || (condattr->valid != 0xf341))
      return EINVAL;
  condattr->valid=0;
d902 1
a902 1
  // lock myself, for the use of thread2signal
a903 1
  GETTHREAD ("__pthread_kill");
d905 5
a909 2
  if (item->sigs)
    myself->setthread2signal (item);
d920 1
a920 3
  SetResourceLock (LOCK_THREAD_LIST, READ_LOCK, "__pthread_sigmask");
  ThreadItem *item = MT_INTERFACE->GetCallingThread ();
  ReleaseResourceLock (LOCK_THREAD_LIST, READ_LOCK, "__pthread_sigmask");
d925 2
a926 2
  if (item->sigs)
    myself->setthread2signal (item);
d936 1
a936 2
pthread_t
__pthread_self ()
d938 1
a938 7
  SetResourceLock (LOCK_THREAD_LIST, READ_LOCK, "__pthread_self");

  ThreadItem *item = MT_INTERFACE->GetCallingThread ();

  ReleaseResourceLock (LOCK_THREAD_LIST, READ_LOCK, "__pthread_self");
  return (pthread_t) item->Id ();

d950 2
a951 1
__pthread_mutex_init (pthread_mutex_t * mutex, const pthread_mutexattr_t */*_attr*/)
d953 2
a954 1
  SetResourceLock (LOCK_MUTEX_LIST, WRITE_LOCK | READ_LOCK, "__pthread_mutex_init");
d956 2
a957 1
  MutexItem *item = MT_INTERFACE->CreateMutex (mutex);
d959 7
a965 3
  CHECKITEM (LOCK_MUTEX_LIST, WRITE_LOCK | READ_LOCK, "__pthread_mutex_init");

  ReleaseResourceLock (LOCK_MUTEX_LIST, WRITE_LOCK | READ_LOCK, "__pthread_mutex_init");
d972 3
a974 4
  GETMUTEX ("_ptherad_mutex_lock");

  item->Lock ();

d981 3
a983 3
  GETMUTEX ("_ptherad_mutex_lock");

  if (item->TryLock () == WAIT_TIMEOUT)
a984 1

d991 3
a993 4
  GETMUTEX ("_ptherad_mutex_lock");

  item->UnLock ();

d1000 2
a1001 1
  SetResourceLock (LOCK_MUTEX_LIST, READ_LOCK | WRITE_LOCK, "__pthread_mutex_destroy");
d1003 3
a1005 5
  MutexItem *item = MT_INTERFACE->GetMutex (mutex);

  CHECKITEM (LOCK_MUTEX_LIST, WRITE_LOCK | READ_LOCK, "__pthread_mutex_init");

  item->Destroy ();
d1007 2
a1008 3
  MT_INTERFACE->ReleaseItem (item);

  ReleaseResourceLock (LOCK_MUTEX_LIST, READ_LOCK | WRITE_LOCK, "__pthread_mutex_destroy");
d1016 3
a1018 1
  SetResourceLock (LOCK_SEM_LIST, READ_LOCK | WRITE_LOCK, "__sem_init");
d1020 2
a1021 1
  SemaphoreItem *item = MT_INTERFACE->CreateSemaphore (sem, pshared, value);
d1023 1
a1023 1
  CHECKITEM (LOCK_SEM_LIST, READ_LOCK | WRITE_LOCK, "__sem_init");
d1025 6
a1030 1
  ReleaseResourceLock (LOCK_SEM_LIST, READ_LOCK | WRITE_LOCK, "__sem_init");
d1037 2
a1038 5
  SetResourceLock (LOCK_SEM_LIST, READ_LOCK | WRITE_LOCK, "__sem_destroy");

  SemaphoreItem *item = MT_INTERFACE->GetSemaphore (sem);

  CHECKITEM (LOCK_SEM_LIST, READ_LOCK | WRITE_LOCK, "__sem_init");
d1040 1
a1040 1
  item->Destroy ();
d1042 2
a1043 3
  MT_INTERFACE->ReleaseItem (item);

  ReleaseResourceLock (LOCK_SEM_LIST, READ_LOCK | WRITE_LOCK, "__sem_destroy");
d1050 2
a1051 3
  GETSEMA ("__sem_wait");

  item->Wait ();
d1053 1
d1060 2
a1061 1
  GETSEMA ("__sem_trywait");
d1063 1
a1063 4
  if (item->TryWait () == WAIT_TIMEOUT)
    return EAGAIN;

  return 0;
d1069 2
a1070 3
  GETSEMA ("__sem_post");

  item->Post ();
d1072 1
d1082 2
a1083 1
  int __pthread_create (pthread_t *, const pthread_attr_t *, TFD (start_routine), void *arg)
d1095 10
d1113 1
a1113 1
/*
d1124 1
a1124 1
     return -1;
d1151 2
a1152 1
  int __pthread_sigmask (int operation, const sigset_t * set, sigset_t * old_set)
d1200 2
a1201 1
  int __pthread_cond_timedwait (pthread_cond_t *, pthread_mutex_t *, const struct timespec *)
d1251 1
a1251 1
#endif // MT_SAFE
@


1.18
log
@* thread.cc (MTinterface::CreateCond): Check for null attr pointer.
@
text
@d5 1
a5 1
   Written by Marco Fuykschot <marco@@ddi.nl>
a188 1

a276 1

d488 1
a488 1
  item->win32_obj_id = ::CreateEvent (&sec_none_nih, 
d491 1
a491 2
	NULL /* no name */ );

d504 1
a504 1
  return !PulseEvent(win32_obj_id);
d535 3
a537 3
  PulseEvent(win32_obj_id);
  while (InterlockedDecrement(&waiting)!=0)
    PulseEvent(win32_obj_id);
d542 1
a542 1
//////////////////////////  Pthreads
d547 1
a547 1
// Setup the local/global storage of this thread
d558 1
a558 1
// setup signal structures
a575 1

a583 1

d586 1
a586 2

// call the user's thread
d589 1
a589 1
// FIX ME : cleanup code
d591 1
a591 1
//  thread->used = false;	// release thread entry
a727 3



d761 1
a761 1
__pthread_cond_destroy(pthread_cond_t *cond)
d779 1
a779 1
__pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr)
d794 2
a795 1
int __pthread_cond_broadcast(pthread_cond_t *cond)
d798 2
a799 2
  
  item->BroadCast();
d804 2
a805 1
int __pthread_cond_signal(pthread_cond_t *cond)
d809 1
a809 1
  item->Signal();
d814 2
a815 1
int __pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime)
d833 4
a836 4
  InterlockedIncrement(&item->waiting);
  rv = item->TimedWait(abstime->tv_sec*1000);
  mutexitem->Lock();
  if (InterlockedDecrement(&item->waiting)==0)
d842 3
a844 2
int __pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
{ 
d846 4
a849 4
  SetResourceLock (LOCK_MUTEX_LIST, READ_LOCK, "_ptherad_mutex_lock"); 
  MutexItem* mutexitem=user_data->threadinterface->GetMutex (mutex); 
  ReleaseResourceLock (LOCK_MUTEX_LIST, READ_LOCK, "_ptherad_mutex_lock"); 
  if (!mutexitem) return EINVAL;  
d851 2
a852 2
  { 
    return EINVAL; 
d857 1
a857 1
  
d859 4
a862 4
  InterlockedIncrement(&item->waiting);
  rv = item->Wait();  
  mutexitem->Lock();
  if (InterlockedDecrement(&item->waiting)==0)
d864 1
a864 1
 
d888 1
a888 1
  if (!attr || (attr->valid != 0xf341) || (pshared <0) || (pshared > 1 ))
d907 2
a908 2
// lock myself, for the use of thread2signal
  // two differ kills might clash: FIX ME
d916 1
a916 1
// unlock myself
d927 2
a928 2
// lock this myself, for the use of thread2signal
  // two differt kills might clash: FIX ME
d935 1
a935 1
// unlock this myself
d1180 1
a1180 1
  int __pthread_cond_destroy(pthread_cond_t *)
d1184 1
a1184 1
  int __pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *)
d1188 1
a1188 1
  int __pthread_cond_signal(pthread_cond_t *)
d1192 1
a1192 1
  int __pthread_cond_broadcast(pthread_cond_t *)
d1196 1
a1196 1
  int __pthread_cond_timedwait(pthread_cond_t *, pthread_mutex_t *, const struct timespec *)
d1200 1
a1200 1
  int __pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *)
@


1.17
log
@* cygwin.din: Export the new functions.
* pthread.cc (pthread_cond_*): Add wrapper functions that call __pthread_cond*
functions.
* thread.cc (__pthread_cond_*): Implement the pthread_cond* functions.
* thread.h: Add new class entries and prototypes for __pthread_cond* functions.
* include/pthread.h: user land header prototypes for pthread_cond* functions
and related defines.
@
text
@d486 1
a486 1
  item->shared = attr->shared;
@


1.16
log
@* cygwin.din: Export rand48 functions.
* thread.cc (MTinterface::Init): Remove the initialization of `reent_data'.
* dcrt0.cc: Add the initalizer to the declaration of `reent_data'.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 35.
@
text
@d66 7
d397 7
d472 72
d767 141
a922 1

d1182 40
@


1.15
log
@* pinfo.cc (codepage_init): Move function.
* environ.cc (codepage_init): To here.
* exceptoins.cc (SIG_NONMASKABLE): Remove SIGCONT from consideration since it
is supposed to be maskable.
* signal.cc (sigaction): Ditto.
* sigproc.cc (wait_sig): Ditto.
* winsup.h: Eliminate global declaration of codepage_init.
@
text
@a303 8

  struct _reent *r = _REENT;
  memset (r, 0, sizeof (struct _reent));

  r->_errno = 0;
  r->_stdin = &r->__sf[0];
  r->_stdout = &r->__sf[1];
  r->_stderr = &r->__sf[2];
@


1.14
log
@* thread.cc: Need LONG_MAX definition.
@
text
@d3 1
a3 1
   Copyright 1998, 2000 Cygnus Solutions.
@


1.13
log
@* thread.cc (MTinterface::CreateSemaphore): Correctly set semaphore max.
@
text
@d19 1
@


1.12
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d437 1
a437 1
  item->win32_obj_id = ::CreateSemaphore (&sec_none_nih, _v, _v, NULL);
@


1.11
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@a22 1
#include "thread.h"
d83 1
a83 1
};
d97 1
a97 1
};
d110 1
a110 1
};
d140 1
a140 1
};
a158 2
  thread_printf ("Init resource lock %p -> %p", this, &lock);

d167 2
a168 2
  thread_printf ("Resource lock %p inited by %p , %d", &lock, user_data, myself->pid);
};
d179 1
a179 1
};
d188 1
a188 1
};
d202 1
a202 1
};
d216 1
a216 1
};
d222 2
a223 1
  for (; i < _list->index && _list->items[i] != NULL && _list->items[i]->used && _list->items[i]->joinable != 'Y';  i++);
d225 1
a225 1
};
d231 1
a231 1
};
d239 1
a239 1
};
d245 1
a245 1
};
d251 1
a251 1
};
d254 1
a254 1
MTinterface::Init0 ()
d256 1
d267 1
d275 1
d280 1
d285 2
a286 1
};
a287 3
void
MTinterface::Init1 ()
{
d290 1
a290 3
  int i = FindNextUnused (&threadlist);
  assert (i == 0);
  ThreadItem *item = (ThreadItem *) GetItem (i, &threadlist);
d292 1
a292 1
  item = (ThreadItem *) SetItem (i, &mainthread, &threadlist);
d296 1
d302 1
a302 1
};
a303 3
void
MTinterface::ClearReent ()
{
d311 1
a311 3

};

d339 1
a339 2
};

d371 1
a371 1
};
d379 1
a379 1
};
d402 1
a402 1
};
d408 1
a408 1
};
d414 1
a414 1
};
d444 1
a444 1
};
d450 1
a450 1
};
d457 1
a457 1
};
d463 1
a463 1
};
d543 1
a543 1
};
d550 1
a550 1
};
d557 1
a557 1
};
d564 1
a564 1
};
d570 1
a570 1
};
d605 1
a605 1
};
d663 1
a663 1
};
d670 1
a670 1
};
d676 1
a676 1
};
d681 1
a681 1
};
d686 1
a686 1
};
d704 1
a704 1
};
d724 1
a724 1
};
d737 1
a737 1
};
d743 1
a743 1
};
d758 1
a758 1
};
d768 1
a768 1
};
d779 1
a779 1
};
d789 1
a789 1
};
d806 1
a806 1
};
d820 1
a820 1
};
d837 1
a837 1
};
d847 1
a847 1
};
d858 1
a858 1
};
d868 1
a868 1
};
@


1.10
log
@* path.cc (readlink): Check if buffer length is positive.  Truncate output to
buffer length.  Don't terminate buffer with '\0'.
@
text
@d27 2
@


1.9
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d244 1
a244 1
  return ( (MTitem *) _i)->Id () == * (int *) _value;
d250 1
a250 1
  return ( (ThreadItem *) _i)->thread_id == * (DWORD *) _id;
@


1.8
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d199 1
a199 1
        break;
d214 1
a214 1
        break;
d484 1
a484 1
  sigset_t _sig_mask;           /* one set for everything to ignore. */
d523 1
a523 1
//  thread->used = false;         // release thread entry
d598 1
a598 1
        *return_val = NULL;
d606 1
a606 1
        *return_val = item->return_ptr;
d654 1
a654 1
        ResumeThread ((HANDLE)*thread);
d997 1
a997 1
#endif                          // MT_SAFE
@


1.7
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d23 3
@


1.6
log
@* hinfo.cc (hinfo::find_unused_handle): Just check for table entry == NULL
since we are already bounds checked by default.
* thread.cc (ResourceLocks::Lock): Streamline this function since it is called
a lot.
(ReleaseResourceLock): Ditto.
@
text
@a20 1

d23 1
@


1.5
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d29 1
a29 1
#define NOT_IMP(n)  system_printf("not implemented %s\n",n); return 0;
d31 7
a37 4
#define CHECKHANDLE(rval,release) \
  if ( ! item->HandleOke() ) { \
    if ( release ) item->used=false; \
    return rval; };
d40 6
a45 6
  if ( ! thread ) system_printf("thread is NULL");\
  SetResourceLock(LOCK_THREAD_LIST,READ_LOCK,n);\
  ThreadItem *item=user_data->threadinterface->GetThread(thread); \
  ReleaseResourceLock(LOCK_THREAD_LIST,READ_LOCK,n); \
  if ( ! item ) return EINVAL; \
  CHECKHANDLE(EINVAL,0);
d48 5
a52 5
  SetResourceLock(LOCK_MUTEX_LIST,READ_LOCK,n); \
  MutexItem* item=user_data->threadinterface->GetMutex(mutex); \
  ReleaseResourceLock(LOCK_MUTEX_LIST,READ_LOCK,n); \
  if ( ! item ) return EINVAL;  \
  CHECKHANDLE(EINVAL,0);
d55 9
a63 9
  SetResourceLock(LOCK_SEM_LIST,READ_LOCK,n); \
  SemaphoreItem* item=user_data->threadinterface->GetSemaphore(sem); \
  ReleaseResourceLock(LOCK_SEM_LIST,READ_LOCK,n); \
  if ( ! item ) return EINVAL; \
  CHECKHANDLE(EINVAL,0);

#define CHECKITEM(rn,rm,fn) \
  if ( ! item ) { \
    ReleaseResourceLock(rn,rm,fn); \
d74 1
a74 3
    {
      system_printf ("local thread storage not inited");
    }
d89 1
a89 3
    {
      system_printf ("local thread storage not inited");
    }
d95 13
d111 3
a113 3
#if 0
  if (!threadsafe)
    return;
a114 1
  thread_printf ("Set resource lock %d mode %d for %s start", _res_id, _mode, _function);
d126 1
a126 4
#if 0
  if (!threadsafe)
    return;
#endif
a128 1
#ifdef _CYG_THREAD_FAILSAFE
d143 3
a145 1
  thread_printf ("Assert Resource lock %d ==> for %p , real : %d , threadid %d count %d owner %d", _res_id, user_data, (myself ? myself->pid : -1), GetCurrentThreadId (), user_data->resourcelocks->count, user_data->resourcelocks->owner);
d147 1
a147 3
    {
      system_printf ("assertion failed, not the resource owner");
    };
a151 12
LPCRITICAL_SECTION
ResourceLocks::Lock (int _resid)
{
  if (!inited)
    {
      system_printf ("lock called before initialization");
    };

  thread_printf ("Get Resource lock %d ==> %p for %p , real : %d , threadid %d ", _resid, &lock, user_data, (myself ? myself->pid : -1), GetCurrentThreadId ());
  return &lock;
};

d165 1
a165 1
  thread_printf ("Resource lock %p inited by %p , %d", &lock, user_data, (myself ? myself->pid : -1));
d176 1
a176 1
    };
d198 1
a198 1
    };
d212 1
a212 1
    };
d241 1
a241 1
  return ((MTitem *) _i)->Id () == *(int *) _value;
d247 1
a247 1
  return ((ThreadItem *) _i)->thread_id == *(DWORD *) _id;
d258 1
a258 1
    };
d539 1
a539 3
    };


d577 1
a577 1
  ThreadItem *item = MT_INTERFACE->GetCallingThread();
d579 1
a579 1
  ExitThread(0);
d584 1
a584 1
__pthread_join(pthread_t * thread, void **return_val)
d586 1
a586 1
  ThreadItem *item=user_data->threadinterface->GetThread(thread);
d601 1
a601 1
     WaitForSingleObject((HANDLE)*thread, INFINITE);
d610 1
a610 1
__pthread_detach(pthread_t * thread)
d612 1
a612 1
  ThreadItem *item=user_data->threadinterface->GetThread(thread);
d627 1
a627 1
__pthread_suspend(pthread_t * thread)
d629 1
a629 1
  ThreadItem *item=user_data->threadinterface->GetThread(thread);
d636 1
a636 1
     SuspendThread( (HANDLE)*thread);
d644 1
a644 1
__pthread_continue(pthread_t * thread)
d646 1
a646 1
  ThreadItem *item=user_data->threadinterface->GetThread(thread);
d651 1
a651 1
        ResumeThread( (HANDLE)*thread);
d881 1
a881 1
  };
d885 1
a885 1
  };
d889 1
a889 1
  };
d893 1
a893 1
  };
d897 1
a897 1
  };
d899 2
a900 2
   __pthread_attr_setstackaddr(...){ return -1; };
   __pthread_attr_getstackaddr(...){ return -1; };
d905 1
a905 1
  };
d907 1
a907 1
  int __pthread_join(pthread_t thread_id, void **return_val)
d915 1
a915 1
  };
d919 1
a919 1
  };
d923 1
a923 1
  };
d927 1
a927 1
  };
d931 1
a931 1
  };
d935 1
a935 1
  };
d939 1
a939 1
  };
d943 1
a943 1
  };
d947 1
a947 1
  };
d951 1
a951 1
  };
d955 1
a955 1
  };
d959 1
a959 1
  };
d963 1
a963 1
  };
d967 1
a967 1
  };
d971 1
a971 1
  };
d975 1
a975 1
  };
d979 1
a979 1
  };
d983 1
a983 1
  };
d987 1
a987 1
  };
d991 1
a991 1
  };
@


1.4
log
@* Makefile.in: Use variables rather than configure constructs where
appropriate.
(LIBCOS): Find additional stub library stuff in their own subdirectory.
* dcrt0.cc: Convert user_data pointer to static __cygwin_user_data area.
(do_global_ctors): Check magic_bisquit for initialization.
(dll_crt0_1): First group of premain functions prior to fd initialization.  Run
second group before calling main.
(dll_crt0 ()): New function, called from new initialization code.
(dll_crt0 (per_process *uptr)): Call new dll_crt0 () function on
initialization.
* debug.cc (thread_stub): Initialize bottom of stack with per-thread info.
* environ.cc (parse_thing): Use binmode global to control CYGWIN=binmode
behavior.
* fhandler.cc (fhandler_base::open): Allow explicit setting of __fmode to
O_BINARY or O_TEXT to override disk mount settings.
* libcmain.cc: Move to lib subdirectory.
* libccrt0.cc: Ditto.
* dll_main.cc: Ditto.
* dll_entry.cc: Ditto.
* getopt.c: Ditto.
* thread.cc (thread_init_wrapper): Call ExitThread explicitly rather than
returning, as a preliminary step towards placing per thread info at the bottom
of the stack.
* winsup.h: Move per_process class to include/sys/cygwin.h.  Declare new
dll_crt0().
* include/cygwin/version.h: Bump API minor version.
* binmode.c: New file.
* textmode.c: Ditto.
* lib/_cygwin_crt0_common.cc: Ditto.
* lib/crt0.h: Ditto.
* lib/cygwin_attach_dll.c: Ditto.
* lib/cygwin_crt0.c: Ditto.
* lib/dll_entry.cc: Ditto.
* lib/dll_main.cc: Ditto.
* lib/getopt.c: Ditto.
* lib/libcmain.c: Ditto.
* lib/premain0.c: Ditto.
* lib/premain1.c: Ditto.
* lib/premain2.c: Ditto.
* lib/premain3.c: Ditto.
@
text
@d18 1
a19 1
#include "winsup.h"
@


1.3
log
@* path.cc (mount_info::cygdrive_posix_path): Don't add trailing slash if
referring to something like c:\.
* dcrt0.cc (dll_crt0_1): Move uinfo initialization prior to sig_send
initialization to give signal thread a chance to finish.
* debug.cc (WFSO): Move to sigproc.cc
(WFMO): Ditto.
* exceptions.cc (interruptible): Allocate slightly more space for directory
just for paranoia's sake.
(call_handler): Eliminate nonmain argument.  Determine if main thread has set a
frame pointer and use it if so.
(sig_handle): Eliminate nonmain argument.
* net.cc: Record frame information in appropriate routines throughout.
* select.cc (select): Ditto.
* sigproc.cc: Use sigthread structure to record mainthread id throughout.
(sig_send): Record frame information for signal handler.
(wait_sig): Reflect argument change in sig_handle.
(WFSO): Move here and record frame information for signal handler.
(WFMO): Ditto.
* sigproc.h: Implement new "sigthread" class.  Implement "sigframe" class for
manipulating signal frame info.
* thread.cc (__pthread_kill): Use standard _kill() function rather than calling
sig_send directly.
* winsup.h: Eliminate ebp element from signal_dispatch class.
@
text
@d527 1
a527 1
  return ret;
@


1.2
log
@Fix final round of gcc warnings relating to unused parameters.
@
text
@d708 1
a708 1
  int rval = sig_send (myself, sig);
@


1.1
log
@Initial revision
@
text
@d576 1
a576 1
__pthread_attr_destroy (pthread_attr_t * attr)
d676 1
a676 1
__pthread_key_create (pthread_key_t * key)
d682 1
a682 1
__pthread_key_delete (pthread_key_t * key)
d687 1
a687 1
__pthread_setspecific (pthread_key_t * key, const void *value)
d692 1
a692 1
__pthread_getspecific (pthread_key_t * key)
d757 1
a757 1
__pthread_mutex_init (pthread_mutex_t * mutex, const pthread_mutexattr_t * _attr)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
