head	1.129;
access;
symbols
	cygwin-1_7_35-release:1.129
	cygwin-1_7_34-release:1.129
	cygwin-1_7_33-release:1.124.2.2
	cygwin-1_7_32-release:1.124.2.1
	cygwin-1_7_31-release:1.124.2.1
	cygwin-1_7_30-release:1.124
	cygwin-1_7_29-release:1.124
	cygwin-1_7_29-release-branchpoint:1.124.0.2
	cygwin-pre-user-db:1.124
	cygwin-1_7_28-release:1.124
	cygwin-1_7_27-release:1.124
	cygwin-1_7_26-release:1.124
	cygwin-1_7_25-release:1.123
	cygwin-1_7_24-release:1.123
	cygwin-1_7_23-release:1.123
	cygwin-1_7_22-release:1.123
	cygwin-1_7_21-release:1.123
	cygwin-1_7_20-release:1.123
	cygwin-1_7_19-release:1.123
	cygwin-64bit-postmerge:1.123
	cygwin-64bit-premerge-branch:1.122.0.2
	cygwin-64bit-premerge:1.122
	cygwin-1_7_18-release:1.122
	post-ptmalloc3:1.120.2.12
	pre-ptmalloc3:1.120.2.12
	cygwin-1_7_17-release:1.121
	cygwin-64bit-branch:1.120.0.2
	cygwin-1_7_16-release:1.120
	cygwin-1_7_15-release:1.120
	cygwin-1_7_14_2-release:1.120
	cygwin-1_7_14-release:1.120
	cygwin-1_7_12-release:1.120
	cygwin-1_7_11-release:1.118
	cygwin-1_7_10-release:1.118
	signal-rewrite:1.109.0.2
	pre-notty:1.102
	cygwin-1_7_9-release:1.93
	cv-post-1_7_9:1.93.0.2
	cygwin-1_7_8-release:1.93
	cygwin-1_7_7-release:1.91
	cygwin-1_7_5-release:1.90
	cygwin-1_7_4-release:1.90
	cygwin-1_7_3-release:1.90
	cygwin-1_7_2-release:1.90
	fifo_doover3:1.89.0.4
	cygwin-1_7_1-release:1.89
	prefifo:1.89
	cv-branch-2:1.89.0.2
	pre-ripout-set_console_state_for_spawn:1.84
	EOL_registry_mounts:1.82
	preoverlapped:1.74
	drop_9x_support_start:1.71
	cr-0x5f1:1.71.0.4
	cv-branch:1.71.0.2
	pre-ptymaster-archetype:1.71
	cr-0x3b58:1.67.0.4
	cr-0x5ef:1.67.0.2
	after-mmap-privanon-noreserve:1.66
	after-mmap-revamp:1.66
	before-mmap-revamp:1.65
	cgf-more-exit-sync:1.65
	post_wait_sig_exit:1.65
	pre_wait_sig_exit:1.65
	reparent-point:1.44
	noreparent:1.44.0.2
	cr-0x5e6:1.43.0.2
	cr-0x9e:1.41.0.6
	cr-0x9d:1.41.0.4
	cgf-deleteme:1.41.0.2
	pre-sigrewrite:1.40
	corinna-01:1.39
	cr-0x9c:1.36.0.6
	cr-0x9b:1.36.0.4
	cr-0x99:1.36
	Z-emcb-cygwin_daemon:1.36.0.2
	w32api-2_2:1.29
	mingw-runtime-2_4:1.29
	pre-cgf-merge:1.37
	cgf-dev-branch:1.29.0.2
	Z-cygwin_daemon_merge_HEAD:1.21
	cygwin_daemon:1.14.0.2
	Z-cygwin_daemon_merge-new_HEAD:1.21;
locks; strict;
comment	@// @;


1.129
date	2015.01.22.13.46.11;	author corinna;	state Exp;
branches;
next	1.128;

1.128
date	2014.10.09.13.24.37;	author corinna;	state Exp;
branches;
next	1.127;

1.127
date	2014.10.08.15.25.52;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2014.05.20.11.20.02;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2014.02.09.19.44.54;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2013.10.16.15.14.22;	author corinna;	state Exp;
branches
	1.124.2.1;
next	1.123;

1.123
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2012.08.16.23.34.43;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2012.03.27.18.31.09;	author corinna;	state Exp;
branches
	1.120.2.1;
next	1.119;

1.119
date	2012.03.27.18.30.28;	author corinna;	state Exp;
branches;
next	1.118;

1.118
date	2011.12.22.12.25.09;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2011.12.22.11.25.44;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2011.12.22.11.02.33;	author corinna;	state Exp;
branches;
next	1.115;

1.115
date	2011.12.14.20.23.27;	author corinna;	state Exp;
branches;
next	1.114;

1.114
date	2011.12.12.21.38.08;	author corinna;	state Exp;
branches;
next	1.113;

1.113
date	2011.12.12.17.27.18;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2011.10.15.19.13.57;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2011.10.10.18.59.56;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2011.08.20.18.55.45;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2011.08.16.20.08.34;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2011.08.11.16.43.26;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2011.08.10.13.13.09;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2011.08.07.11.04.32;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2011.06.28.10.21.34;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2011.06.12.20.15.26;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2011.06.06.05.02.10;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.100;

1.100
date	2011.05.23.08.53.25;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2011.05.21.15.57.16;	author corinna;	state Exp;
branches;
next	1.98;

1.98
date	2011.05.20.18.07.52;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2011.05.13.06.50.20;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2011.05.11.10.31.22;	author corinna;	state Exp;
branches;
next	1.95;

1.95
date	2011.04.04.12.23.35;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2011.04.01.09.00.21;	author yselkowitz;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.13.13.02.19;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2010.09.06.09.47.01;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2010.05.18.14.30.50;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2010.03.09.21.26.55;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2009.02.04.16.40.04;	author corinna;	state Exp;
branches;
next	1.88;

1.88
date	2009.01.20.18.04.32;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2009.01.20.17.22.11;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2008.04.13.16.47.21;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.07.11.24.51;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2008.02.14.16.47.11;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2008.02.01.12.37.51;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2007.12.06.18.24.06;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2007.12.03.14.13.03;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.29.15.13.00;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2007.03.06.14.48.24;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2006.02.11.04.53.14;	author cgf;	state Exp;
branches
	1.71.4.1;
next	1.70;

1.70
date	2006.02.05.18.18.02;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2006.01.27.21.50.40;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2006.01.24.17.40.55;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2006.01.04.03.43.55;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2005.11.28.22.32.29;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.24.04.38.39;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.20.06.19.54;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2005.08.19.16.18.42;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2005.08.08.15.33.31;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.06.20.05.00;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2005.05.02.03.50.07;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2005.04.13.16.41.32;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2005.04.03.08.45.18;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2005.03.29.09.10.59;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2005.02.13.18.17.28;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2005.02.01.15.11.43;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.31.12.02.07;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2005.01.31.10.28.53;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2005.01.29.13.34.34;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2005.01.29.11.23.06;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.16.17.00.26;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.07.11.39.52;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2005.01.06.23.00.08;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.22.11.35.29;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.18.16.41.27;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.18.16.37.44;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2004.09.03.01.53.11;	author cgf;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.26.04.40.52;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.27.02.30.46;	author phumblet;	state Exp;
branches;
next	1.38;

1.38
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.17.02.10.13;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.05.03.04.28;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.09.01.33.06;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.24.20.14.19;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.08.17.56.13;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.08.16.44.24;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2003.01.09.08.22.04;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.05.04.24.48;	author cgf;	state Exp;
branches
	1.27.8.1;
next	1.26;

1.26
date	2002.11.05.04.23.41;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.05.03.21.32;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.30.21.05.17;	author cgf;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.09.25.12.24.22;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.31.16.37.51;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.02.01.36.15;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.01.19.03.26;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.30.23.02.58;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.30.17.05.48;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.06.15.35.06;	author corinna;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.02.16.42.02;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.02.03.13.22;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.31.20.30.36;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.30.07.45.30;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.22.22.09.57;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.12.01.37.48;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.04.03.24.35;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.03.02.43.45;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.02.23.58.20;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.02.04.26.05;	author cgf;	state Exp;
branches;
next	;

1.124.2.1
date	2014.07.16.09.54.55;	author corinna;	state Exp;
branches;
next	1.124.2.2;

1.124.2.2
date	2014.11.13.12.53.01;	author corinna;	state Exp;
branches;
next	;

1.120.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.120.2.2;

1.120.2.2
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.120.2.3;

1.120.2.3
date	2012.11.05.20.17.08;	author corinna;	state Exp;
branches;
next	1.120.2.4;

1.120.2.4
date	2012.11.07.14.52.00;	author corinna;	state Exp;
branches;
next	1.120.2.5;

1.120.2.5
date	2012.11.12.17.26.21;	author corinna;	state Exp;
branches;
next	1.120.2.6;

1.120.2.6
date	2012.11.15.15.15.25;	author corinna;	state Exp;
branches;
next	1.120.2.7;

1.120.2.7
date	2012.12.10.11.45.47;	author corinna;	state Exp;
branches;
next	1.120.2.8;

1.120.2.8
date	2012.12.13.18.45.39;	author corinna;	state Exp;
branches;
next	1.120.2.9;

1.120.2.9
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.120.2.10;

1.120.2.10
date	2013.02.09.20.29.37;	author corinna;	state Exp;
branches;
next	1.120.2.11;

1.120.2.11
date	2013.02.12.11.24.35;	author corinna;	state Exp;
branches;
next	1.120.2.12;

1.120.2.12
date	2013.02.15.13.36.36;	author corinna;	state Exp;
branches;
next	;

1.71.4.1
date	2008.02.18.14.08.37;	author corinna;	state Exp;
branches;
next	;

1.29.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2003.03.09.16.22.58;	author cgf;	state Exp;
branches;
next	1.29.2.4;

1.29.2.4
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.29.2.5;

1.29.2.5
date	2003.05.26.19.39.06;	author cgf;	state Exp;
branches;
next	1.29.2.6;

1.29.2.6
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.29.2.7;

1.29.2.7
date	2003.07.10.01.06.23;	author cgf;	state Exp;
branches;
next	1.29.2.8;

1.29.2.8
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	;

1.27.8.1
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	1.27.8.2;

1.27.8.2
date	2003.01.09.08.22.51;	author cgf;	state Exp;
branches;
next	;

1.24.2.1
date	2002.11.07.03.47.46;	author cgf;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.13.14.34.05;	author rbcollins;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.07.01.13.53.39;	author scottc;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.07.02.10.58.18;	author scottc;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2002.09.03.13.52.07;	author scottc;	state Exp;
branches;
next	1.14.2.5;

1.14.2.5
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	1.14.2.6;

1.14.2.6
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.129
log
@	* fhandler.h (class fhandler_process): Add fd_type member.
	* fhandler_process.cc (process_tab): Fix indentation.
	(fhandler_process::exists): Rely on format_process_fd returning file
	type in fd_type.
	(struct process_fd_t): Add fd_type member.
	(fhandler_process::fill_filebuf): Allow format_process_fd to set
	this->fd_type member.
	(format_process_fd): Fix path evaluation to allow recognizing trailing
	path components.  Fix check for file descriptor path component.  Return
	virt_symlink in fd_type if no trailing path compenents exist, return
	virt_fsdir otherwise and copy full resulting path into destbuf.
	* path.cc (path_conv::check): If /proc/$PID/fd symlink has trailing
	path components, reparse resulting path as if it's the incoming path.
	Add comment to wail over the outdated and hackish check method, and to
	explain what we do here.
@
text
@/* fhandler_process.cc: fhandler for /proc/<pid> virtual filesystem

   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
   2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <stdlib.h>
#include <stdio.h>
#include <sys/cygwin.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "fhandler_virtual.h"
#include "pinfo.h"
#include "shared_info.h"
#include "dtable.h"
#include "cygheap.h"
#include "ntdll.h"
#include "cygtls.h"
#include "mount.h"
#include "tls_pbuf.h"
#include <sys/sysmacros.h>
#include <sys/param.h>
#include <ctype.h>

#define _COMPILING_NEWLIB
#include <dirent.h>

static off_t format_process_maps (void *, char *&);
static off_t format_process_stat (void *, char *&);
static off_t format_process_status (void *, char *&);
static off_t format_process_statm (void *, char *&);
static off_t format_process_winexename (void *, char *&);
static off_t format_process_winpid (void *, char *&);
static off_t format_process_exename (void *, char *&);
static off_t format_process_root (void *, char *&);
static off_t format_process_cwd (void *, char *&);
static off_t format_process_cmdline (void *, char *&);
static off_t format_process_ppid (void *, char *&);
static off_t format_process_uid (void *, char *&);
static off_t format_process_pgid (void *, char *&);
static off_t format_process_sid (void *, char *&);
static off_t format_process_gid (void *, char *&);
static off_t format_process_ctty (void *, char *&);
static off_t format_process_fd (void *, char *&);
static off_t format_process_mounts (void *, char *&);
static off_t format_process_mountinfo (void *, char *&);

static const virt_tab_t process_tab[] =
{
  { _VN ("."),          FH_PROCESS,   virt_directory, NULL },
  { _VN (".."),         FH_PROCESS,   virt_directory, NULL },
  { _VN ("cmdline"),    FH_PROCESS,   virt_file,      format_process_cmdline },
  { _VN ("ctty"),       FH_PROCESS,   virt_file,      format_process_ctty },
  { _VN ("cwd"),        FH_PROCESS,   virt_symlink,   format_process_cwd },
  { _VN ("exe"),        FH_PROCESS,   virt_symlink,   format_process_exename },
  { _VN ("exename"),    FH_PROCESS,   virt_file,      format_process_exename },
  { _VN ("fd"),         FH_PROCESSFD, virt_directory, format_process_fd },
  { _VN ("gid"),        FH_PROCESS,   virt_file,      format_process_gid },
  { _VN ("maps"),       FH_PROCESS,   virt_file,      format_process_maps },
  { _VN ("mountinfo"),  FH_PROCESS,   virt_file,      format_process_mountinfo },
  { _VN ("mounts"),     FH_PROCESS,   virt_file,      format_process_mounts },
  { _VN ("pgid"),       FH_PROCESS,   virt_file,      format_process_pgid },
  { _VN ("ppid"),       FH_PROCESS,   virt_file,      format_process_ppid },
  { _VN ("root"),       FH_PROCESS,   virt_symlink,   format_process_root },
  { _VN ("sid"),        FH_PROCESS,   virt_file,      format_process_sid },
  { _VN ("stat"),       FH_PROCESS,   virt_file,      format_process_stat },
  { _VN ("statm"),      FH_PROCESS,   virt_file,      format_process_statm },
  { _VN ("status"),     FH_PROCESS,   virt_file,      format_process_status },
  { _VN ("uid"),        FH_PROCESS,   virt_file,      format_process_uid },
  { _VN ("winexename"), FH_PROCESS,   virt_file,      format_process_winexename },
  { _VN ("winpid"),     FH_PROCESS,   virt_file,      format_process_winpid },
  { NULL, 0,	        FH_NADA,      virt_none,      NULL }
};

static const int PROCESS_LINK_COUNT =
  (sizeof (process_tab) / sizeof (virt_tab_t)) - 1;
int get_process_state (DWORD dwProcessId);
static bool get_mem_values (DWORD dwProcessId, unsigned long *vmsize,
			    unsigned long *vmrss, unsigned long *vmtext,
			    unsigned long *vmdata, unsigned long *vmlib,
			    unsigned long *vmshare);

/* Returns 0 if path doesn't exist, >0 if path is a directory,
   -1 if path is a file, -2 if path is a symlink, -3 if path is a pipe,
   -4 if path is a socket. */
virtual_ftype_t
fhandler_process::exists ()
{
  const char *path = get_name ();
  debug_printf ("exists (%s)", path);
  path += proc_len + 1;
  while (*path != 0 && !isdirsep (*path))
    path++;
  if (*path == 0)
    return virt_rootdir;

  virt_tab_t *entry = virt_tab_search (path + 1, true, process_tab,
				       PROCESS_LINK_COUNT);
  if (entry)
    {
      if (!path[entry->name_len + 1])
	{
	  fileid = entry - process_tab;
	  return entry->type;
	}
      if (entry->type == virt_directory)	/* fd subdir only */
	{
	  fileid = entry - process_tab;
	  if (fill_filebuf ())
	    return fd_type;
	  /* Check for nameless device entries. */
	  path = strrchr (path, '/');
	  if (path && *++path)
	    {
	      if (!strncmp (path, "pipe:[", 6))
		return virt_pipe;
	      else if (!strncmp (path, "socket:[", 8))
		return virt_socket;
	    }
	}
    }
  return virt_none;
}

fhandler_process::fhandler_process ():
  fhandler_proc ()
{
}

int __reg2
fhandler_process::fstat (struct stat *buf)
{
  const char *path = get_name ();
  int file_type = exists ();
  fhandler_base::fstat (buf);
  path += proc_len + 1;
  pid = atoi (path);

  pinfo p (pid);
  /* If p->pid != pid, then pid is actually the Windows PID for an execed
     Cygwin process, and the pinfo entry is the additional entry created
     at exec time.  We don't want to enable the user to access a process
     entry by using the Win32 PID, though. */
  if (!p || p->pid != pid)
    {
      set_errno (ENOENT);
      return -1;
    }

  buf->st_mode &= ~_IFMT & NO_W;

  switch (file_type)
    {
    case virt_none:
      set_errno (ENOENT);
      return -1;
    case virt_directory:
    case virt_rootdir:
      buf->st_ctime = buf->st_mtime = buf->st_birthtime = p->start_time;
      buf->st_ctim.tv_nsec = buf->st_mtim.tv_nsec
	= buf->st_birthtim.tv_nsec = 0;
      time_as_timestruc_t (&buf->st_atim);
      buf->st_uid = p->uid;
      buf->st_gid = p->gid;
      buf->st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
      if (file_type == 1)
	buf->st_nlink = 2;
      else
	buf->st_nlink = 3;
      return 0;
    case virt_symlink:
      buf->st_uid = p->uid;
      buf->st_gid = p->gid;
      buf->st_mode = S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;
      return 0;
    case virt_pipe:
      buf->st_uid = p->uid;
      buf->st_gid = p->gid;
      buf->st_mode = S_IFIFO | S_IRUSR | S_IWUSR;
      return 0;
    case virt_socket:
      buf->st_uid = p->uid;
      buf->st_gid = p->gid;
      buf->st_mode = S_IFSOCK | S_IRUSR | S_IWUSR;
      return 0;
    case virt_file:
    default:
      buf->st_uid = p->uid;
      buf->st_gid = p->gid;
      buf->st_mode |= S_IFREG | S_IRUSR | S_IRGRP | S_IROTH;
      return 0;
    }
}

DIR *
fhandler_process::opendir (int fd)
{
  DIR *dir = fhandler_virtual::opendir (fd);
  if (dir && process_tab[fileid].fhandler == FH_PROCESSFD)
    fill_filebuf ();
  return dir;
}

int
fhandler_process::closedir (DIR *dir)
{
  return fhandler_virtual::closedir (dir);
}

int
fhandler_process::readdir (DIR *dir, dirent *de)
{
  int res = ENMFILE;
  if (process_tab[fileid].fhandler == FH_PROCESSFD)
    {
      if ((size_t) dir->__d_position >= 2 + filesize / sizeof (int))
	goto out;
    }
  else if (dir->__d_position >= PROCESS_LINK_COUNT)
    goto out;
  if (process_tab[fileid].fhandler == FH_PROCESSFD && dir->__d_position > 1)
    {
      int *p = (int *) filebuf;
      __small_sprintf (de->d_name, "%d", p[dir->__d_position++ - 2]);
      de->d_type = DT_LNK;
    }
  else
    {
      strcpy (de->d_name, process_tab[dir->__d_position].name);
      de->d_type = virt_ftype_to_dtype (process_tab[dir->__d_position].type);
      dir->__d_position++;
    }
  dir->__flags |= dirent_saw_dot | dirent_saw_dot_dot;
  res = 0;
out:
  syscall_printf ("%d = readdir(%p, %p) (%s)", res, dir, de, de->d_name);
  return res;
}

int
fhandler_process::open (int flags, mode_t mode)
{
  int res = fhandler_virtual::open (flags, mode);
  if (!res)
    goto out;

  nohandle (true);

  const char *path;
  path = get_name () + proc_len + 1;
  pid = atoi (path);
  while (*path != 0 && !isdirsep (*path))
    path++;

  if (*path == 0)
    {
      if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
	{
	  set_errno (EEXIST);
	  res = 0;
	  goto out;
	}
      else if (flags & O_WRONLY)
	{
	  set_errno (EISDIR);
	  res = 0;
	  goto out;
	}
      else
	{
	  flags |= O_DIROPEN;
	  goto success;
	}
    }

  virt_tab_t *entry;
  entry = virt_tab_search (path + 1, true, process_tab, PROCESS_LINK_COUNT);
  if (!entry)
    {
      set_errno ((flags & O_CREAT) ? EROFS : ENOENT);
      res = 0;
      goto out;
    }
  if (entry->fhandler == FH_PROCESSFD)
    {
      flags |= O_DIROPEN;
      goto success;
    }
  if (flags & O_WRONLY)
    {
      set_errno (EROFS);
      res = 0;
      goto out;
    }

  fileid = entry - process_tab;
  if (!fill_filebuf ())
	{
	  res = 0;
	  goto out;
	}

  if (flags & O_APPEND)
    position = filesize;
  else
    position = 0;

success:
  res = 1;
  set_flags ((flags & ~O_TEXT) | O_BINARY);
  set_open_status ();
out:
  syscall_printf ("%d = fhandler_proc::open(%y, 0%o)", res, flags, mode);
  return res;
}

struct process_fd_t {
  const char *path;
  _pinfo *p;
  virtual_ftype_t *fd_type;
};

bool
fhandler_process::fill_filebuf ()
{
  const char *path;
  path = get_name () + proc_len + 1;
  if (!pid)
    pid = atoi (path);

  pinfo p (pid);
  /* If p->pid != pid, then pid is actually the Windows PID for an execed
     Cygwin process, and the pinfo entry is the additional entry created
     at exec time.  We don't want to enable the user to access a process
     entry by using the Win32 PID, though. */
  if (!p || p->pid != pid)
    {
      set_errno (ENOENT);
      return false;
    }

  if (process_tab[fileid].format_func)
    {
      if (process_tab[fileid].fhandler == FH_PROCESSFD)
	{
	  process_fd_t fd = { path, p , &fd_type };
	  filesize = process_tab[fileid].format_func (&fd, filebuf);
	}
      else
	filesize = process_tab[fileid].format_func (p, filebuf);
      return !filesize ? false : true;
    }
  return false;
}

static off_t
format_process_fd (void *data, char *&destbuf)
{
  _pinfo *p = ((process_fd_t *) data)->p;
  const char *path = ((process_fd_t *) data)->path;
  size_t fs = 0;
  /* path looks like "$PID/fd", "$PID/fd/", "$PID/fd/[0-9]*".  In the latter
     case a trailing slash and more followup chars are allowed, provided the
     descriptor symlink points to a directory. */
  char *fdp = strchr (path, '/') + 3;
  /* The "fd" directory itself? */
  if (fdp[0] =='\0' || (fdp[0] == '/' && fdp[1] == '\0'))
    {
      if (destbuf)
	cfree (destbuf);
      destbuf = p->fds (fs);
      *((process_fd_t *) data)->fd_type = virt_symlink;
    }
  else
    {
      char *e;
      int fd;

      if (destbuf)
	cfree (destbuf);
      fd = strtol (++fdp, &e, 10);
      if (fd < 0 || e == fdp || (*e != '/' && *e != '\0'))
	{
	  set_errno (ENOENT);
	  return 0;
	}
      destbuf = p->fd (fd, fs);
      if (!destbuf || !*destbuf)
	{
	  set_errno (ENOENT);
	  return 0;
	}
      if (*e == '\0')
	*((process_fd_t *) data)->fd_type = virt_symlink;
      else /* trailing path */
	{
	  char *newbuf = (char *) cmalloc_abort (HEAP_STR, strlen (destbuf)
							   + strlen (e) + 1);
	  stpcpy (stpcpy (newbuf, destbuf), e);
	  cfree (destbuf);
	  destbuf = newbuf;
	  *((process_fd_t *) data)->fd_type = virt_fsdir;
	}
    }
  return fs;
}

static off_t
format_process_ppid (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  destbuf = (char *) crealloc_abort (destbuf, 40);
  return __small_sprintf (destbuf, "%d\n", p->ppid);
}

static off_t
format_process_uid (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  destbuf = (char *) crealloc_abort (destbuf, 40);
  return __small_sprintf (destbuf, "%d\n", p->uid);
}

static off_t
format_process_pgid (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  destbuf = (char *) crealloc_abort (destbuf, 40);
  return __small_sprintf (destbuf, "%d\n", p->pgid);
}

static off_t
format_process_sid (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  destbuf = (char *) crealloc_abort (destbuf, 40);
  return __small_sprintf (destbuf, "%d\n", p->sid);
}

static off_t
format_process_gid (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  destbuf = (char *) crealloc_abort (destbuf, 40);
  return __small_sprintf (destbuf, "%d\n", p->gid);
}

static off_t
format_process_ctty (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  if (p->ctty < 0)
    {
      destbuf = (char *) crealloc_abort (destbuf, 2);
      return __small_sprintf (destbuf, "\n");
    }
  device d;
  d.parse (p->ctty);
  destbuf = (char *) crealloc_abort (destbuf, strlen (d.name) + 2);
  return __small_sprintf (destbuf, "%s\n", d.name);
}

static off_t
format_process_root (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  size_t fs;

  if (destbuf)
    {
      cfree (destbuf);
      destbuf = NULL;
    }
  destbuf = p->root (fs);
  if (!destbuf || !*destbuf)
    {
      destbuf = cstrdup ("<defunct>");
      fs = strlen (destbuf) + 1;
    }
  return fs;
}

static off_t
format_process_cwd (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  size_t fs;

  if (destbuf)
    {
      cfree (destbuf);
      destbuf = NULL;
    }
  destbuf = p->cwd (fs);
  if (!destbuf || !*destbuf)
    {
      destbuf = cstrdup ("<defunct>");
      fs = strlen (destbuf) + 1;
    }
  return fs;
}

static off_t
format_process_cmdline (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  size_t fs;

  if (destbuf)
    {
      cfree (destbuf);
      destbuf = NULL;
    }
  destbuf = p->cmdline (fs);
  if (!destbuf || !*destbuf)
    {
      destbuf = cstrdup ("<defunct>");
      fs = strlen (destbuf) + 1;
    }
  return fs;
}

static off_t
format_process_exename (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  int len;
  tmp_pathbuf tp;

  char *buf = tp.c_get ();
  if (p->process_state & PID_EXITED)
    stpcpy (buf, "<defunct>");
  else
    {
      mount_table->conv_to_posix_path (p->progname, buf, 1);
      len = strlen (buf);
      if (len > 4)
	{
	  char *s = buf + len - 4;
	  if (ascii_strcasematch (s, ".exe"))
	    *s = 0;
	}
    }
  destbuf = (char *) crealloc_abort (destbuf, (len = strlen (buf)) + 1);
  stpcpy (destbuf, buf);
  return len;
}

static off_t
format_process_winpid (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  destbuf = (char *) crealloc_abort (destbuf, 20);
  return __small_sprintf (destbuf, "%d\n", p->dwProcessId);
}

static off_t
format_process_winexename (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  size_t len = sys_wcstombs (NULL, 0, p->progname);
  destbuf = (char *) crealloc_abort (destbuf, len + 1);
  sys_wcstombs (destbuf, len, p->progname);
  destbuf[len] = '\n';
  return len + 1;
}

struct heap_info
{
  struct heap
  {
    heap *next;
    unsigned heap_id;
    char *base;
    char *end;
    unsigned long flags;
  };
  heap *heap_vm_chunks;

  heap_info (DWORD pid)
    : heap_vm_chunks (NULL)
  {
    PDEBUG_BUFFER buf;
    NTSTATUS status;
    PDEBUG_HEAP_ARRAY harray;

    buf = RtlCreateQueryDebugBuffer (0, FALSE);
    if (!buf)
      return;
    status = RtlQueryProcessDebugInformation (pid, PDI_HEAPS | PDI_HEAP_BLOCKS,
					      buf);
    if (NT_SUCCESS (status)
	&& (harray = (PDEBUG_HEAP_ARRAY) buf->HeapInformation) != NULL)
      for (ULONG hcnt = 0; hcnt < harray->Count; ++hcnt)
	{
	  PDEBUG_HEAP_BLOCK barray = (PDEBUG_HEAP_BLOCK)
				     harray->Heaps[hcnt].Blocks;
	  if (!barray)
	    continue;
	  for (ULONG bcnt = 0; bcnt < harray->Heaps[hcnt].BlockCount; ++bcnt)
	    if (barray[bcnt].Flags & 2)
	      {
		heap *h = (heap *) malloc (sizeof (heap));
		if (h)
		  {
		    *h = (heap) { heap_vm_chunks,
				  hcnt, (char *) barray[bcnt].Address,
				  (char *) barray[bcnt].Address
					   + barray[bcnt].Size,
				  harray->Heaps[hcnt].Flags };
		    heap_vm_chunks = h;
		  }
	      }
	}
    RtlDestroyQueryDebugBuffer (buf);
  }

  char *fill_if_match (char *base, ULONG type, char *dest)
  {
    for (heap *h = heap_vm_chunks; h; h = h->next)
      if (base >= h->base && base < h->end)
	{
	  char *p = dest + __small_sprintf (dest, "[win heap %ld", h->heap_id);
	  if (!(h->flags & HEAP_FLAG_NONDEFAULT))
	    p = stpcpy (p, " default");
	  if ((h->flags & HEAP_FLAG_SHAREABLE) && (type & MEM_MAPPED))
	    p = stpcpy (p, " shared");
	  if (h->flags & HEAP_FLAG_EXECUTABLE)
	    p = stpcpy (p, " exec");
	  if (h->flags & HEAP_FLAG_GROWABLE)
	    p = stpcpy (p, " grow");
	  if (h->flags & HEAP_FLAG_NOSERIALIZE)
	    p = stpcpy (p, " noserial");
	  if (h->flags == HEAP_FLAG_DEBUGGED)
	    p = stpcpy (p, " debug");
	  stpcpy (p, "]");
	  return dest;
	}
    return 0;
  }

  ~heap_info ()
  {
    heap *n = 0;
    for (heap *m = heap_vm_chunks; m; m = n)
      {
	n = m->next;
	free (m);
      }
  }
};

struct thread_info
{
  struct region
  {
    region *next;
    ULONG thread_id;
    char *start;
    char *end;
    bool teb;
  };
  region *regions;

  thread_info (DWORD pid, HANDLE process)
    : regions (NULL)
  {
    NTSTATUS status;
    PVOID buf = NULL;
    ULONG size = 50 * (sizeof (SYSTEM_PROCESS_INFORMATION)
		       + 16 * sizeof (SYSTEM_THREADS));
    PSYSTEM_PROCESS_INFORMATION proc;
    PSYSTEM_THREADS thread;

    do
      {
	buf = realloc (buf, size);
	status = NtQuerySystemInformation (SystemProcessInformation,
					   buf, size, NULL);
	size <<= 1;
      }
    while (status == STATUS_INFO_LENGTH_MISMATCH);
    if (!NT_SUCCESS (status))
      {
	if (buf)
	  free (buf);
	debug_printf ("NtQuerySystemInformation, %y", status);
	return;
      }
    proc = (PSYSTEM_PROCESS_INFORMATION) buf;
    while (true)
      {
	if ((DWORD) (uintptr_t) proc->UniqueProcessId == pid)
	  break;
	if (!proc->NextEntryOffset)
	  {
	    free (buf);
	    return;
	  }
	proc = (PSYSTEM_PROCESS_INFORMATION) ((PBYTE) proc + proc->NextEntryOffset);
      }
    thread = proc->Threads;
    for (ULONG i = 0; i < proc->NumberOfThreads; ++i)
      {
	THREAD_BASIC_INFORMATION tbi;
	TEB teb;
	HANDLE thread_h;

	if (!(thread_h = OpenThread (THREAD_QUERY_INFORMATION, FALSE,
				     (ULONG) (ULONG_PTR) thread[i].ClientId.UniqueThread)))
	  continue;
	status = NtQueryInformationThread (thread_h, ThreadBasicInformation,
					   &tbi, sizeof tbi, NULL);
	CloseHandle (thread_h);
	if (!NT_SUCCESS (status))
	  continue;
	region *r = (region *) malloc (sizeof (region));
	if (r)
	  {
	    *r = (region) { regions, (ULONG) (ULONG_PTR) thread[i].ClientId.UniqueThread,
			    (char *) tbi.TebBaseAddress,
			    (char *) tbi.TebBaseAddress + wincap.page_size (),
			    true };
	    regions = r;
	  }
	if (!ReadProcessMemory (process, (PVOID) tbi.TebBaseAddress,
				&teb, sizeof teb, NULL))
	  continue;
	r = (region *) malloc (sizeof (region));
	if (r)
	  {
	    *r = (region) { regions, (ULONG) (ULONG_PTR) thread[i].ClientId.UniqueThread,
			    (char *) (teb.DeallocationStack
				      ?: teb.Tib.StackLimit),
			    (char *) teb.Tib.StackBase,
			    false };
	    regions = r;
	  }
      }
    free (buf);
  }

  char *fill_if_match (char *base, ULONG type, char *dest)
  {
    for (region *r = regions; r; r = r->next)
      if ((base >= r->start && base < r->end)
	  /* Special case WOW64.  The TEB is 8K within the region reserved
	     for it.  No idea what the lower 8K are used for. */
	  || (r->teb && wincap.is_wow64 ()
	      && r->start == base + 2 * wincap.page_size ()))
	{
	  char *p = dest + __small_sprintf (dest, "[%s (tid %ld)",
					    r->teb ? "teb" : "stack",
					    r->thread_id);
	  if (type & MEM_MAPPED)
	    p = stpcpy (p, " shared");
	  stpcpy (p, "]");
	  return dest;
	}
    return 0;
  }

  ~thread_info ()
  {
    region *n = 0;
    for (region *m = regions; m; m = n)
      {
	n = m->next;
	free (m);
      }
  }
};

static off_t
format_process_maps (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  HANDLE proc = OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
			     FALSE, p->dwProcessId);
  if (!proc)
    return 0;

  NTSTATUS status;
  PROCESS_BASIC_INFORMATION pbi;
  PPEB peb = NULL;

  memset (&pbi, 0, sizeof (pbi));
  status = NtQueryInformationProcess (proc, ProcessBasicInformation,
				      &pbi, sizeof pbi, NULL);
  if (NT_SUCCESS (status))
    peb = pbi.PebBaseAddress;
  /* myself is in the same spot in every process, so is the pointer to the
     procinfo.  But make sure the destructor doesn't try to release procinfo! */
  pinfo proc_pinfo;
  if (ReadProcessMemory (proc, &myself, &proc_pinfo, sizeof proc_pinfo, NULL))
    proc_pinfo.preserve ();
  /* The heap info on the cygheap is also in the same spot in each process
     because the cygheap is located at the same address. */
  user_heap_info user_heap;
  ReadProcessMemory (proc, &cygheap->user_heap, &user_heap,
		     sizeof user_heap, NULL);

  off_t len = 0;

  union access
  {
    char flags[8];
    off_t word;
  } a;

  struct region {
    access a;
    char *abase;
    char *rbase;
    char *rend;
  } cur = {{{'\0'}}, (char *)1, 0, 0};

  MEMORY_BASIC_INFORMATION mb;
  dos_drive_mappings drive_maps;
  heap_info heaps (p->dwProcessId);
  thread_info threads (p->dwProcessId, proc);
  struct stat st;
  long last_pass = 0;

  tmp_pathbuf tp;
  PMEMORY_SECTION_NAME msi = (PMEMORY_SECTION_NAME) tp.w_get ();
  char *posix_modname = tp.c_get ();
  size_t maxsize = 0;

  if (destbuf)
    {
      cfree (destbuf);
      destbuf = NULL;
    }

  /* Iterate over each VM region in the address space, coalescing
     memory regions with the same permissions. Once we run out, do one
     last_pass to trigger output of the last accumulated region.
     
     FIXME:  32 bit processes can't get address information beyond the
	     32 bit address space from 64 bit processes.  We have to run
	     this functionality in the target process, if the target
	     process is 64 bit and our own process is 32 bit. */
  for (char *i = 0;
       VirtualQueryEx (proc, i, &mb, sizeof(mb)) || (1 == ++last_pass);
       i = cur.rend)
    {
      if (last_pass)
	posix_modname[0] = '\0';
      if (mb.State == MEM_FREE)
	a.word = 0;
      else if (mb.State == MEM_RESERVE)
	{
	  char *p = stpcpy (a.flags, "===");
	  stpcpy (p, (mb.Type & MEM_MAPPED) ? "s" : "p");
	}
      else
	{
	  static DWORD const RO = (PAGE_EXECUTE_READ | PAGE_READONLY);
	  static DWORD const RW = (PAGE_EXECUTE_READWRITE | PAGE_READWRITE
				   | PAGE_EXECUTE_WRITECOPY | PAGE_WRITECOPY);
	  static DWORD const X = (PAGE_EXECUTE | PAGE_EXECUTE_READ
				  | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);
	  static DWORD const WC = (PAGE_EXECUTE_WRITECOPY | PAGE_WRITECOPY);
	  DWORD p = mb.Protect;
	  a = (access) {{
	      (p & (RO | RW))				? 'r' : '-',
	      (p & (RW))				? 'w' : '-',
	      (p & (X))					? 'x' : '-',
	      (mb.Type & MEM_MAPPED) && !(p & (WC))	? 's'
	      : (p & PAGE_GUARD)			? 'g' : 'p',
	      '\0', // zero-fill the remaining bytes
	    }};
	}

      region next = { a,
		      (char *) mb.AllocationBase,
		      (char *) mb.BaseAddress,
		      (char *) mb.BaseAddress+mb.RegionSize
      };

      /* Windows permissions are more fine-grained than the unix rwxp,
	 so we reduce clutter by manually coalescing regions sharing
	 the same allocation base and effective permissions. */
      bool newbase = (next.abase != cur.abase);
      if (!last_pass && !newbase && next.a.word == cur.a.word)
	  cur.rend = next.rend; /* merge with previous */
      else
	{
	  /* output the current region if it's "interesting". */
	  if (cur.a.word)
	    {
	      size_t newlen = strlen (posix_modname) + 62;
	      if (len + newlen >= maxsize)
		destbuf = (char *)
		  crealloc_abort (destbuf,
				  maxsize += roundup2 (newlen, 2048UL));
	      int written = __small_sprintf (destbuf + len,
					     "%08lx-%08lx %s %08lx %04x:%04x %U   ",
					     cur.rbase, cur.rend, cur.a.flags,
					     cur.rbase - cur.abase,
					     st.st_dev >> 16,
					     st.st_dev & 0xffff,
					     st.st_ino);
	      while (written < 62)
		destbuf[len + written++] = ' ';
	      len += written;
	      len += __small_sprintf (destbuf + len, "%s\n", posix_modname);
	    }
	  /* start of a new region (but possibly still the same allocation). */
	  cur = next;
	  /* if a new allocation, figure out what kind it is. */
	  if (newbase && !last_pass && mb.State != MEM_FREE)
	    {
	      /* If the return length pointer is missing, NtQueryVirtualMemory
		 returns with STATUS_ACCESS_VIOLATION on Windows 2000. */
	      SIZE_T ret_len = 0;

	      st.st_dev = 0;
	      st.st_ino = 0;
	      if ((mb.Type & (MEM_MAPPED | MEM_IMAGE))
		  && NT_SUCCESS (status = NtQueryVirtualMemory (proc, cur.abase,
						       MemorySectionName,
						       msi, 65536, &ret_len)))
		{
		  PWCHAR dosname =
		      drive_maps.fixup_if_match (msi->SectionFileName.Buffer);
		  if (mount_table->conv_to_posix_path (dosname,
						       posix_modname, 0))
		    sys_wcstombs (posix_modname, NT_MAX_PATH, dosname);
		  stat64 (posix_modname, &st);
		}
	      else if (!threads.fill_if_match (cur.abase, mb.Type,
					       posix_modname)
		       && !heaps.fill_if_match (cur.abase, mb.Type,
						posix_modname))
		{
		  if (cur.abase == (char *) peb)
		    strcpy (posix_modname, "[peb]");
		  else if (cur.abase == (char *) &SharedUserData)
		    strcpy (posix_modname, "[shared-user-data]");
		  else if (cur.abase == (char *) cygwin_shared)
		    strcpy (posix_modname, "[cygwin-shared]");
		  else if (cur.abase == (char *) user_shared)
		    strcpy (posix_modname, "[cygwin-user-shared]");
		  else if (cur.abase == (char *) *proc_pinfo)
		    strcpy (posix_modname, "[procinfo]");
		  else if (cur.abase == user_heap.base)
		    strcpy (posix_modname, "[heap]");
		  else
		    posix_modname[0] = 0;
		}
	    }
	}
    }
  CloseHandle (proc);
  return len;
}

static off_t
format_process_stat (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  char cmd[NAME_MAX + 1];
  int state = 'R';
  unsigned long fault_count = 0UL,
		utime = 0UL, stime = 0UL,
		start_time = 0UL,
		vmsize = 0UL, vmrss = 0UL, vmmaxrss = 0UL;
  int priority = 0;
  if (p->process_state & PID_EXITED)
    strcpy (cmd, "<defunct>");
  else
    {
      PWCHAR last_slash = wcsrchr (p->progname, L'\\');
      sys_wcstombs (cmd, NAME_MAX + 1,
		    last_slash ? last_slash + 1 : p->progname);
      int len = strlen (cmd);
      if (len > 4)
	{
	  char *s = cmd + len - 4;
	  if (ascii_strcasematch (s, ".exe"))
	    *s = 0;
	 }
    }
  /* Note: under Windows, a process is always running - it's only threads
     that get suspended.  Therefore the default state is R (runnable). */
  if (p->process_state & PID_EXITED)
    state = 'Z';
  else if (p->process_state & PID_STOPPED)
    state = 'T';
  else
    state = get_process_state (p->dwProcessId);
  start_time = (GetTickCount () / 1000 - time (NULL) + p->start_time) * HZ;

  NTSTATUS status;
  HANDLE hProcess;
  VM_COUNTERS vmc;
  KERNEL_USER_TIMES put;
  PROCESS_BASIC_INFORMATION pbi;
  QUOTA_LIMITS ql;
  SYSTEM_TIMEOFDAY_INFORMATION stodi;
  SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION spt;
  hProcess = OpenProcess (PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
			  FALSE, p->dwProcessId);
  if (hProcess != NULL)
    {
      status = NtQueryInformationProcess (hProcess, ProcessVmCounters,
					  (PVOID) &vmc, sizeof vmc, NULL);
      if (NT_SUCCESS (status))
	status = NtQueryInformationProcess (hProcess, ProcessTimes,
					    (PVOID) &put, sizeof put, NULL);
      if (NT_SUCCESS (status))
	status = NtQueryInformationProcess (hProcess, ProcessBasicInformation,
					    (PVOID) &pbi, sizeof pbi, NULL);
      if (NT_SUCCESS (status))
	status = NtQueryInformationProcess (hProcess, ProcessQuotaLimits,
					    (PVOID) &ql, sizeof ql, NULL);
      CloseHandle (hProcess);
    }
  else
    {
      DWORD error = GetLastError ();
      __seterrno_from_win_error (error);
      debug_printf ("OpenProcess: ret %u", error);
      return 0;
    }
  if (NT_SUCCESS (status))
    status = NtQuerySystemInformation (SystemTimeOfDayInformation,
				       (PVOID) &stodi, sizeof stodi, NULL);
  if (NT_SUCCESS (status))
    status = NtQuerySystemInformation (SystemProcessorPerformanceInformation,
				       (PVOID) &spt, sizeof spt, NULL);
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      debug_printf ("NtQueryInformationProcess: status %y, %E", status);
      return 0;
    }
  fault_count = vmc.PageFaultCount;
  utime = put.UserTime.QuadPart * HZ / 10000000ULL;
  stime = put.KernelTime.QuadPart * HZ / 10000000ULL;
#if 0
   if (stodi.CurrentTime.QuadPart > put.CreateTime.QuadPart)
     start_time = (spt.KernelTime.QuadPart + spt.UserTime.QuadPart -
		   stodi.CurrentTime.QuadPart + put.CreateTime.QuadPart) * HZ / 10000000ULL;
   else
     /*
      * sometimes stodi.CurrentTime is a bit behind
      * Note: some older versions of procps are broken and can't cope
      * with process start times > time(NULL).
      */
     start_time = (spt.KernelTme.QuadPart + spt.UserTime.QuadPart) * HZ / 10000000ULL;
#endif
  /* The BasePriority returned to a 32 bit process under WOW64 is
     apparently broken, for 32 and 64 bit target processes.  64 bit
     processes get the correct base priority, even for 32 bit processes. */
  if (wincap.is_wow64 ())
    priority = 8; /* Default value. */
  else
    priority = pbi.BasePriority;
  unsigned page_size = wincap.page_size ();
  vmsize = vmc.PagefileUsage;
  vmrss = vmc.WorkingSetSize / page_size;
  vmmaxrss = ql.MaximumWorkingSetSize / page_size;

  destbuf = (char *) crealloc_abort (destbuf, strlen (cmd) + 320);
  return __small_sprintf (destbuf, "%d (%s) %c "
				   "%d %d %d %d %d "
				   "%u %lu %lu %u %u %lu %lu "
				   "%ld %ld %d %d %d %d "
				   "%lu %lu "
				   "%ld %lu",
			  p->pid, cmd, state,
			  p->ppid, p->pgid, p->sid, p->ctty, -1,
			  0, fault_count, fault_count, 0, 0, utime, stime,
			  utime, stime, priority, 0, 0, 0,
			  start_time, vmsize,
			  vmrss, vmmaxrss
			  );
}

static off_t
format_process_status (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  char cmd[NAME_MAX + 1];
  int state = 'R';
  const char *state_str = "unknown";
  unsigned long vmsize = 0UL, vmrss = 0UL, vmdata = 0UL, vmlib = 0UL,
		vmtext = 0UL, vmshare = 0UL;

  PWCHAR last_slash = wcsrchr (p->progname, L'\\');
  sys_wcstombs (cmd, NAME_MAX + 1, last_slash ? last_slash + 1 : p->progname);
  int len = strlen (cmd);
  if (len > 4)
    {
      char *s = cmd + len - 4;
      if (ascii_strcasematch (s, ".exe"))
	*s = 0;
     }
  /* Note: under Windows, a process is always running - it's only threads
     that get suspended.  Therefore the default state is R (runnable). */
  if (p->process_state & PID_EXITED)
    state = 'Z';
  else if (p->process_state & PID_STOPPED)
    state = 'T';
  else
    state = get_process_state (p->dwProcessId);
  switch (state)
    {
    case 'O':
      state_str = "running";
      break;
    case 'D':
    case 'S':
      state_str = "sleeping";
      break;
    case 'R':
      state_str = "runnable";
      break;
    case 'Z':
      state_str = "zombie";
      break;
    case 'T':
      state_str = "stopped";
      break;
    }
  if (!get_mem_values (p->dwProcessId, &vmsize, &vmrss, &vmtext, &vmdata,
		       &vmlib, &vmshare))
    return 0;
  unsigned page_size = wincap.page_size ();
  vmsize *= page_size; vmrss *= page_size; vmdata *= page_size;
  vmtext *= page_size; vmlib *= page_size;
  /* The real uid value for *this* process is stored at cygheap->user.real_uid
     but we can't get at the real uid value for any other process, so
     just fake it as p->uid.  Similar for p->gid. */
  destbuf = (char *) crealloc_abort (destbuf, strlen (cmd) + 320);
  return __small_sprintf (destbuf, "Name:\t%s\n"
				   "State:\t%c (%s)\n"
				   "Tgid:\t%d\n"
				   "Pid:\t%d\n"
				   "PPid:\t%d\n"
				   "Uid:\t%d %d %d %d\n"
				   "Gid:\t%d %d %d %d\n"
				   "VmSize:\t%8d kB\n"
				   "VmLck:\t%8d kB\n"
				   "VmRSS:\t%8d kB\n"
				   "VmData:\t%8d kB\n"
				   "VmStk:\t%8d kB\n"
				   "VmExe:\t%8d kB\n"
				   "VmLib:\t%8d kB\n"
				   "SigPnd:\t%016x\n"
				   "SigBlk:\t%016x\n"
				   "SigIgn:\t%016x\n",
			  cmd,
			  state, state_str,
			  p->pgid,
			  p->pid,
			  p->ppid,
			  p->uid, p->uid, p->uid, p->uid,
			  p->gid, p->gid, p->gid, p->gid,
			  vmsize >> 10, 0, vmrss >> 10, vmdata >> 10, 0,
			  vmtext >> 10, vmlib >> 10,
			  0, 0, _my_tls.sigmask
			  );
}

static off_t
format_process_statm (void *data, char *&destbuf)
{
  _pinfo *p = (_pinfo *) data;
  unsigned long vmsize = 0UL, vmrss = 0UL, vmtext = 0UL, vmdata = 0UL,
		vmlib = 0UL, vmshare = 0UL;
  if (!get_mem_values (p->dwProcessId, &vmsize, &vmrss, &vmtext, &vmdata,
		       &vmlib, &vmshare))
    return 0;
  destbuf = (char *) crealloc_abort (destbuf, 96);
  return __small_sprintf (destbuf, "%ld %ld %ld %ld %ld %ld 0\n",
			  vmsize, vmrss, vmshare, vmtext, vmlib, vmdata);
}

extern "C" {
  FILE *setmntent (const char *, const char *);
  struct mntent *getmntent (FILE *);
};

static off_t
format_process_mountstuff (void *data, char *&destbuf, bool mountinfo)
{
  _pinfo *p = (_pinfo *) data;
  user_info *u_shared = NULL;
  HANDLE u_hdl = NULL;
  off_t len = 0;
  struct mntent *mnt;

  if (p->uid != myself->uid)
    {
      WCHAR sid_string[UNLEN + 1] = L""; /* Large enough for SID */

      cygsid p_sid;

      if (!p_sid.getfrompw (internal_getpwuid (p->uid)))
	return 0;
      p_sid.string (sid_string);
      u_shared = (user_info *) open_shared (sid_string, USER_VERSION, u_hdl,
					    sizeof (user_info), SH_JUSTOPEN,
					    &sec_none_nih);
      if (!u_shared)
	return 0;
    }
  else
    u_shared = user_shared;
  mount_info *mtab = &u_shared->mountinfo;

  /* Store old value of _my_tls.locals here. */
  int iteration = _my_tls.locals.iteration;
  unsigned available_drives = _my_tls.locals.available_drives;
  /* This reinitializes the above values in _my_tls. */
  setmntent (NULL, NULL);
  /* Restore iteration immediately since it's not used below.  We use the
     local iteration variable instead*/
  _my_tls.locals.iteration = iteration;

  for (iteration = 0; (mnt = mtab->getmntent (iteration)); ++iteration)
    {
      /* We have no access to the drives mapped into another user session and
	 _my_tls.locals.available_drives contains the mappings of the current
	 user.  So, when printing the mount table of another user, we check
	 each cygdrive entry if it's a remote drive.  If so, ignore it. */
      if (iteration >= mtab->nmounts && u_hdl)
	{
	  WCHAR drive[3] = { (WCHAR) mnt->mnt_fsname[0], L':', L'\0' };
	  disk_type dt = get_disk_type (drive);

	  if (dt == DT_SHARE_SMB || dt == DT_SHARE_NFS)
	    continue;
	}
      destbuf = (char *) crealloc_abort (destbuf, len
						  + strlen (mnt->mnt_fsname)
						  + strlen (mnt->mnt_dir)
						  + strlen (mnt->mnt_type)
						  + strlen (mnt->mnt_opts)
						  + 30);
      if (mountinfo)
	{
	  path_conv pc (mnt->mnt_dir, PC_SYM_NOFOLLOW | PC_POSIX);
	  dev_t dev = pc.exists () ? pc.fs_serial_number () : -1;

	  len += __small_sprintf (destbuf + len,
				  "%d %d %d:%d / %s %s - %s %s %s\n",
				  iteration, iteration,
				  major (dev), minor (dev),
				  mnt->mnt_dir, mnt->mnt_opts,
				  mnt->mnt_type, mnt->mnt_fsname,
				  (pc.fs_flags () & FILE_READ_ONLY_VOLUME)
				  ? "ro" : "rw");
	}
      else
	len += __small_sprintf (destbuf + len, "%s %s %s %s %d %d\n",
				mnt->mnt_fsname, mnt->mnt_dir, mnt->mnt_type,
				mnt->mnt_opts, mnt->mnt_freq, mnt->mnt_passno);
    }

  /* Restore available_drives */
  _my_tls.locals.available_drives = available_drives;

  if (u_hdl) /* Only not-NULL if open_shared has been called. */
    {
      UnmapViewOfFile (u_shared);
      CloseHandle (u_hdl);
    }
  return len;
}

static off_t
format_process_mounts (void *data, char *&destbuf)
{
  return format_process_mountstuff (data, destbuf, false);
}

static off_t
format_process_mountinfo (void *data, char *&destbuf)
{
  return format_process_mountstuff (data, destbuf, true);
}

int
get_process_state (DWORD dwProcessId)
{
  /* This isn't really heavy magic - just go through the processes' threads
     one by one and return a value accordingly.  Errors are silently ignored. */
  NTSTATUS status;
  PSYSTEM_PROCESS_INFORMATION p, sp;
  ULONG n = 0x4000;
  int state =' ';

  p = (PSYSTEM_PROCESS_INFORMATION) malloc (n);
  if (!p)
    return state;
  while (true)
    {
      status = NtQuerySystemInformation (SystemProcessInformation,
					 (PVOID) p, n, NULL);
      if (status != STATUS_INFO_LENGTH_MISMATCH)
	break;
      n <<= 1;
      PSYSTEM_PROCESS_INFORMATION new_p = (PSYSTEM_PROCESS_INFORMATION) realloc (p, n);
      if (!new_p)
      	goto out;
      p = new_p;
    }
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtQuerySystemInformation: status %y, %u",
		    status, RtlNtStatusToDosError (status));
      goto out;
    }
  state = 'Z';
  sp = p;
  for (;;)
    {
      if ((DWORD) (uintptr_t) sp->UniqueProcessId == dwProcessId)
	{
	  SYSTEM_THREADS *st;
	  st = &sp->Threads[0];
	  state = 'S';
	  for (unsigned i = 0; i < sp->NumberOfThreads; i++)
	    {
	      /* FIXME: at some point we should consider generating 'O' */
	      if (st->State == StateRunning ||
		  st->State == StateReady)
		{
		  state = 'R';
		  goto out;
		}
	      st++;
	    }
	  break;
	}
      if (!sp->NextEntryOffset)
	 break;
      sp = (PSYSTEM_PROCESS_INFORMATION) ((char *) sp + sp->NextEntryOffset);
    }
out:
  free (p);
  return state;
}

static bool
get_mem_values (DWORD dwProcessId, unsigned long *vmsize, unsigned long *vmrss,
		unsigned long *vmtext, unsigned long *vmdata,
		unsigned long *vmlib, unsigned long *vmshare)
{
  bool res = false;
  NTSTATUS status;
  HANDLE hProcess;
  VM_COUNTERS vmc;
  PMEMORY_WORKING_SET_LIST p;
  SIZE_T n = 0x4000, length;

  hProcess = OpenProcess (PROCESS_QUERY_INFORMATION, FALSE, dwProcessId);
  if (hProcess == NULL)
    {
      __seterrno ();
      debug_printf ("OpenProcess, %E");
      return false;
    }
  p = (PMEMORY_WORKING_SET_LIST) malloc (n);
  if (!p)
    goto out;
  while (true)
    {
      status = NtQueryVirtualMemory (hProcess, 0, MemoryWorkingSetList,
				     (PVOID) p, n,
				     (length = (SIZE_T) -1, &length));
      if (status != STATUS_INFO_LENGTH_MISMATCH)
	break;
      n <<= 1;
      PMEMORY_WORKING_SET_LIST new_p = (PMEMORY_WORKING_SET_LIST)
				       realloc (p, n);
      if (!new_p)
	goto out;
      p = new_p;
    }
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtQueryVirtualMemory: status %y", status);
      if (status == STATUS_PROCESS_IS_TERMINATING)
	{
	  *vmsize = *vmrss = *vmtext = *vmdata = *vmlib = *vmshare = 0;
	  res = true;
	}
      else
	__seterrno_from_nt_status (status);
      goto out;
    }
  for (unsigned long i = 0; i < p->NumberOfPages; i++)
    {
      ++*vmrss;
      unsigned flags = p->WorkingSetList[i] & 0x0FFF;
      if ((flags & (WSLE_PAGE_EXECUTE | WSLE_PAGE_SHAREABLE))
	  == (WSLE_PAGE_EXECUTE | WSLE_PAGE_SHAREABLE))
	++*vmlib;
      else if (flags & WSLE_PAGE_SHAREABLE)
	++*vmshare;
      else if (flags & WSLE_PAGE_EXECUTE)
	++*vmtext;
      else
	++*vmdata;
    }
  status = NtQueryInformationProcess (hProcess, ProcessVmCounters, (PVOID) &vmc,
				      sizeof vmc, NULL);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtQueryInformationProcess: status %y", status);
      __seterrno_from_nt_status (status);
      goto out;
    }
  *vmsize = vmc.PagefileUsage / wincap.page_size ();
  res = true;
out:
  free (p);
  CloseHandle (hProcess);
  return res;
}
@


1.128
log
@	* fhandler_proc.cc (fhandler_proc::readdir): Set dirent d_type.
	* fhandler_process.cc (fhandler_process::readdir): Ditto.
	* fhandler_procnet.cc (fhandler_procnet::readdir): Ditto.
	* fhandler_procsys.cc (fhandler_procsys::readdir): Ditto.
	* fhandler_procsysvipc.cc (fhandler_procsysvipc::readdir): Ditto.
	*  fhandler_virtual.h (virt_ftype_to_dtype): Define new inline function
	to generate dirent d_type from virtual_ftype_t.
@
text
@d4 1
a4 1
   2013, 2014 Red Hat, Inc.
d80 1
a80 1
  { NULL, 0,	        FH_NADA,       virt_none,      NULL }
d114 1
a114 1
      if (entry->type == virt_directory)
d118 1
a118 1
	    return virt_symlink;
d328 1
d354 1
a354 1
	  process_fd_t fd = { path, p };
d370 6
a375 3
  char *fdp = strrchr (path, '/');

  if (!fdp || *++fdp == 'f') /* The "fd" directory itself. */
d380 1
d384 3
d389 2
a390 2
      int fd = atoi (fdp);
      if (fd < 0 || (fd == 0 && !isdigit (*fdp)))
d401 11
@


1.127
log
@	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.
@
text
@d233 1
d236 5
a240 1
    strcpy (de->d_name, process_tab[dir->__d_position++].name);
@


1.126
log
@	* fhandler_process.cc (get_mem_values): Rearrange code slightly to
	avoid resource leakage (CID 59973).
	(format_process_stat): Drop temporary variable wcmd and avoid
	string copy without length check (CID 60050).
	(format_process_status): Ditto (CID 60051).
@
text
@d1163 2
a1164 2
  return __small_sprintf (destbuf, "%ld %ld %ld %ld %ld %ld %ld",
			  vmsize, vmrss, vmshare, vmtext, vmlib, vmdata, 0);
@


1.125
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@a948 1
  WCHAR wcmd[NAME_MAX + 1];
d960 2
a961 2
      wcscpy (wcmd, last_slash ? last_slash + 1 : p->progname);
      sys_wcstombs (cmd, NAME_MAX + 1, wcmd);
a1071 1
  WCHAR wcmd[NAME_MAX + 1];
d1074 3
a1076 2
  unsigned long vmsize = 0UL, vmrss = 0UL, vmdata = 0UL, vmlib = 0UL, vmtext = 0UL,
		vmshare = 0UL;
d1078 1
a1078 2
  wcscpy (wcmd, last_slash ? last_slash + 1 : p->progname);
  sys_wcstombs (cmd, NAME_MAX + 1, wcmd);
a1345 3
  p = (PMEMORY_WORKING_SET_LIST) malloc (n);
  if (!p)
    return false;
d1353 3
@


1.124
log
@	* fhandler_process.cc (format_process_ctty): Fix random content of
	/proc/$PID/ctty if the process has no controlling tty.  Set to just
	"\n" instead.
@
text
@d4 1
a4 1
   2013 Red Hat, Inc.
a26 1
#include "pwdgrp.h"
@


1.124.2.1
log
@Add more missing patches
@
text
@d4 1
a4 1
   2013, 2014 Red Hat, Inc.
d950 1
d962 2
a963 2
      sys_wcstombs (cmd, NAME_MAX + 1,
		    last_slash ? last_slash + 1 : p->progname);
d1074 1
d1077 2
a1078 3
  unsigned long vmsize = 0UL, vmrss = 0UL, vmdata = 0UL, vmlib = 0UL,
		vmtext = 0UL, vmshare = 0UL;

d1080 2
a1081 1
  sys_wcstombs (cmd, NAME_MAX + 1, last_slash ? last_slash + 1 : p->progname);
d1349 3
a1358 3
  p = (PMEMORY_WORKING_SET_LIST) malloc (n);
  if (!p)
    goto out;
@


1.124.2.2
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d1164 2
a1165 2
  return __small_sprintf (destbuf, "%ld %ld %ld %ld %ld %ld 0\n",
			  vmsize, vmrss, vmshare, vmtext, vmlib, vmdata);
@


1.123
log
@	* Merge in cygwin-64bit-branch.
@
text
@d436 6
a442 1
  _pinfo *p = (_pinfo *) data;
@


1.122
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d37 19
a55 19
static _off64_t format_process_maps (void *, char *&);
static _off64_t format_process_stat (void *, char *&);
static _off64_t format_process_status (void *, char *&);
static _off64_t format_process_statm (void *, char *&);
static _off64_t format_process_winexename (void *, char *&);
static _off64_t format_process_winpid (void *, char *&);
static _off64_t format_process_exename (void *, char *&);
static _off64_t format_process_root (void *, char *&);
static _off64_t format_process_cwd (void *, char *&);
static _off64_t format_process_cmdline (void *, char *&);
static _off64_t format_process_ppid (void *, char *&);
static _off64_t format_process_uid (void *, char *&);
static _off64_t format_process_pgid (void *, char *&);
static _off64_t format_process_sid (void *, char *&);
static _off64_t format_process_gid (void *, char *&);
static _off64_t format_process_ctty (void *, char *&);
static _off64_t format_process_fd (void *, char *&);
static _off64_t format_process_mounts (void *, char *&);
static _off64_t format_process_mountinfo (void *, char *&);
d140 1
a140 1
fhandler_process::fstat (struct __stat64 *buf)
d225 1
a225 1
      if (dir->__d_position >= 2 + filesize / sizeof (int))
d317 1
a317 1
  syscall_printf ("%d = fhandler_proc::open(%p, %d)", res, flags, mode);
d359 1
a359 1
static _off64_t
d393 1
a393 1
static _off64_t
d401 1
a401 1
static _off64_t
d409 1
a409 1
static _off64_t
d417 1
a417 1
static _off64_t
d425 1
a425 1
static _off64_t
d433 1
a433 1
static _off64_t
d443 1
a443 1
static _off64_t
d463 1
a463 1
static _off64_t
d483 1
a483 1
static _off64_t
d503 1
a503 1
static _off64_t
d529 1
a529 1
static _off64_t
d537 1
a537 1
static _off64_t
d650 3
a652 3
    size_t size = 50 * (sizeof (SYSTEM_PROCESSES)
			+ 16 * sizeof (SYSTEM_THREADS));
    PSYSTEM_PROCESSES proc;
d658 1
a658 1
	status = NtQuerySystemInformation (SystemProcessesAndThreadsInformation,
d667 1
a667 1
	debug_printf ("NtQuerySystemInformation, %p", status);
d670 1
a670 1
    proc = (PSYSTEM_PROCESSES) buf;
d673 1
a673 1
	if (proc->ProcessId == pid)
d675 1
a675 1
	if (!proc->NextEntryDelta)
d680 1
a680 1
	proc = (PSYSTEM_PROCESSES) ((PBYTE) proc + proc->NextEntryDelta);
d683 1
a683 1
    for (ULONG i = 0; i < proc->ThreadCount; ++i)
d690 1
a690 1
				     (ULONG) thread[i].ClientId.UniqueThread)))
d700 1
a700 1
	    *r = (region) { regions, (ULONG) thread[i].ClientId.UniqueThread,
d712 1
a712 1
	    *r = (region) { regions, (ULONG) thread[i].ClientId.UniqueThread,
d754 1
a754 1
static _off64_t
d783 1
a783 1
  _off64_t len = 0;
d788 1
a788 1
    _off64_t word;
d802 1
a802 1
  struct __stat64 st;
d818 6
a823 1
     last_pass to trigger output of the last accumulated region. */
d875 3
a877 3
		destbuf = (char *) crealloc_abort (destbuf,
						   maxsize += roundup2 (newlen,
									2048));
d897 1
a897 1
	      ULONG ret_len = 0;
d940 1
a940 1
static _off64_t
d983 2
a984 2
  SYSTEM_TIME_OF_DAY_INFORMATION stodi;
  SYSTEM_PROCESSOR_TIMES spt;
d1006 1
a1006 1
      debug_printf ("OpenProcess: ret %d", error);
d1013 2
a1014 2
    status = NtQuerySystemInformation (SystemProcessorTimes, (PVOID) &spt,
				       sizeof spt, NULL);
d1018 1
a1018 1
      debug_printf ("NtQueryInformationProcess: status %p, %E", status);
d1036 7
a1042 1
  priority = pbi.BasePriority;
d1051 2
a1052 2
				   "%lu %lu %lu %lu %lu %lu %lu "
				   "%ld %ld %ld %ld %ld %ld "
d1054 4
a1057 6
				   "%ld "
				   "%lu",
			  p->pid, cmd,
			  state,
			  p->ppid, p->pgid, p->sid, p->ctty,
			  -1, 0, fault_count, fault_count, 0, 0, utime, stime,
d1064 1
a1064 1
static _off64_t
d1151 1
a1151 1
static _off64_t
d1170 1
a1170 1
static _off64_t
d1176 1
a1176 1
  _off64_t len = 0;
d1215 1
a1215 1
	  WCHAR drive[3] = { mnt->mnt_fsname[0], L':', L'\0' };
d1258 1
a1258 1
static _off64_t
d1264 1
a1264 1
static _off64_t
d1276 1
a1276 1
  PSYSTEM_PROCESSES p, sp;
d1280 1
a1280 1
  p = (PSYSTEM_PROCESSES) malloc (n);
d1285 1
a1285 1
      status = NtQuerySystemInformation (SystemProcessesAndThreadsInformation,
d1290 1
a1290 1
      PSYSTEM_PROCESSES new_p = (PSYSTEM_PROCESSES) realloc (p, n);
d1297 1
a1297 1
      debug_printf ("NtQuerySystemInformation: status %p, %lu",
d1305 1
a1305 1
      if (sp->ProcessId == dwProcessId)
d1310 1
a1310 1
	  for (unsigned i = 0; i < sp->ThreadCount; i++)
d1323 1
a1323 1
      if (!sp->NextEntryDelta)
d1325 1
a1325 1
      sp = (PSYSTEM_PROCESSES) ((char *) sp + sp->NextEntryDelta);
d1342 1
a1342 1
  ULONG n = 0x4000, length;
d1358 1
a1358 1
				     (length = ULONG_MAX, &length));
d1370 1
a1370 1
      debug_printf ("NtQueryVirtualMemory: status %p", status);
d1398 1
a1398 1
      debug_printf ("NtQueryInformationProcess: status %p", status);
@


1.121
log
@whitespace cleanup
@
text
@d3 2
a4 2
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012 Red Hat, Inc.
d139 1
a139 1
int
@


1.120
log
@	Fix copyright.
@
text
@d1208 1
a1208 1
	  
@


1.120.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d37 19
a55 19
static off_t format_process_maps (void *, char *&);
static off_t format_process_stat (void *, char *&);
static off_t format_process_status (void *, char *&);
static off_t format_process_statm (void *, char *&);
static off_t format_process_winexename (void *, char *&);
static off_t format_process_winpid (void *, char *&);
static off_t format_process_exename (void *, char *&);
static off_t format_process_root (void *, char *&);
static off_t format_process_cwd (void *, char *&);
static off_t format_process_cmdline (void *, char *&);
static off_t format_process_ppid (void *, char *&);
static off_t format_process_uid (void *, char *&);
static off_t format_process_pgid (void *, char *&);
static off_t format_process_sid (void *, char *&);
static off_t format_process_gid (void *, char *&);
static off_t format_process_ctty (void *, char *&);
static off_t format_process_fd (void *, char *&);
static off_t format_process_mounts (void *, char *&);
static off_t format_process_mountinfo (void *, char *&);
d140 1
a140 1
fhandler_process::fstat (struct stat *buf)
d359 1
a359 1
static off_t
d393 1
a393 1
static off_t
d401 1
a401 1
static off_t
d409 1
a409 1
static off_t
d417 1
a417 1
static off_t
d425 1
a425 1
static off_t
d433 1
a433 1
static off_t
d443 1
a443 1
static off_t
d463 1
a463 1
static off_t
d483 1
a483 1
static off_t
d503 1
a503 1
static off_t
d529 1
a529 1
static off_t
d537 1
a537 1
static off_t
d754 1
a754 1
static off_t
d783 1
a783 1
  off_t len = 0;
d788 1
a788 1
    off_t word;
d802 1
a802 1
  struct stat st;
d935 1
a935 1
static off_t
d1055 1
a1055 1
static off_t
d1142 1
a1142 1
static off_t
d1161 1
a1161 1
static off_t
d1167 1
a1167 1
  off_t len = 0;
d1249 1
a1249 1
static off_t
d1255 1
a1255 1
static off_t
@


1.120.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d1208 1
a1208 1

@


1.120.2.3
log
@	* fhandler_process.cc: Fix debug printf calls to be type safe.
	Add casts to avoid compiler warnings.
	(get_mem_values): Avoid using ULONG_MAX since it's NOT matching
	ULONG on 64 bit.
	* fhandler_procnet.cc (fhandler_procnet::open): Fix syscall_printf call
	to be type safe.
	(format_procnet_ifinet6): Add cast to avoid compiler warnings.
	* ntdll.h (struct _DEBUG_HEAP_BLOCK): Change Address to ULONG_PTR.

	* include/bits/wordsize.h: Fix __WORDSIZE definition for x86_64.
	Add __WORDSIZE_COMPAT32 as on Linux.
	* include/inttypes.h: Include bits/wordsize.h.  Use __WORDSIZE check
	where appropriate.
	* include/limits.h: Include bits/wordsize.h.
	(CHAR_BIT): Change definition to rely on default
	compiler definition.
	(LONG_BIT): Ditto.
	(WORD_BIT): Ditto.
	(__LONG_MAX__): Use __WORDSIZE check.
	(RTSIG_MAX): Ditto.
	* include/stdint.h: Include bits/wordsize.h.  Use __WORDSIZE check
	where appropriate.
	* include/cygwin/signal.h: Ditto.
	* include/cygwin/types.h: Ditto.

	* include/asm/byteorder.h (__ntohl): Use bswap instruction, available
	since i486.
	(__ntohs): Fix constraint to work on 64 bit CPU as well.
@
text
@d225 1
a225 1
      if ((size_t) dir->__d_position >= 2 + filesize / sizeof (int))
d317 1
a317 1
  syscall_printf ("%d = fhandler_proc::open(%y, %d)", res, flags, mode);
d667 1
a667 1
	debug_printf ("NtQuerySystemInformation, %y", status);
d690 1
a690 1
				     (ULONG) (ULONG_PTR) thread[i].ClientId.UniqueThread)))
d700 1
a700 1
	    *r = (region) { regions, (ULONG) (ULONG_PTR) thread[i].ClientId.UniqueThread,
d712 1
a712 1
	    *r = (region) { regions, (ULONG) (ULONG_PTR) thread[i].ClientId.UniqueThread,
d1013 1
a1013 1
      debug_printf ("NtQueryInformationProcess: status %y, %E", status);
d1206 1
a1206 1
	  WCHAR drive[3] = { (WCHAR) mnt->mnt_fsname[0], L':', L'\0' };
d1288 1
a1288 1
      debug_printf ("NtQuerySystemInformation: status %y, %lu",
d1349 1
a1349 1
				     (length = (ULONG) -1, &length));
d1361 1
a1361 1
      debug_printf ("NtQueryVirtualMemory: status %y", status);
d1389 1
a1389 1
      debug_printf ("NtQueryInformationProcess: status %y", status);
@


1.120.2.4
log
@	* fhandler_process.cc (heap_info::heap_info): Add comment to explain a
	TODO item.
@
text
@a566 16
    /* FIXME:

       This functionality has two problems on 64 bit machines:

       - 32 bit processes can't call this function for 64 bit processes at all,
         same as the Win32 toolhelp functions.

       - The heap information fetched from 32 bit processes is broken, if
	 the caller is a 64 bit process.  Again, the toolhelp functions suffer
	 the same fate.

       TODO:

       Therefore the only way around this is to call the below Rtl functions
       within the context of the process for which the information is to be
       collected. */
@


1.120.2.5
log
@	* dlfcn.cc (dlopen): Change cast to accommodate type change in ntdll.h
	* fhandler_process.cc (thread_info::thread_info): Change type of local
	variable size to ULONG to match NtQuerySystemInformation call.
	Add cast to avoid compiler warnings.
	(get_process_state): Add cast to avoid compiler warnings.  Accommodate
	name change of NextEntryOffset member of PSYSTEM_PROCESS_INFORMATION
	structure.
	* mmap.cc: Add casts to avoid compiler warnings.
	(mlock): Change type of local variables min and max to match
	GetProcessWorkingSetSize call.
	* nlsfuncs.cc (__collate_range_cmp): Add casts to avoid compiler
	warnings.
	* ntdll.h: Drop accommodations for Mingw32.  Fix a couple of formatting
	glitches.  Add a comment to all structures explicitely tested on 64 bit.
	(SYSTEM_INFORMATION_CLASS): Change SystemProcessesAndThreadsInformation
	to SystemProcessInformation and SystemProcessorTimes to
	SystemProcessorPerformanceInformation to match MSDN.
	(SYSTEM_BASIC_INFORMATION): Fix member types to match 64 bit.
	(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION): Rename from
	SYSTEM_PROCESSOR_TIMES to use official name from MSDN.  Accommodate
	throughout.  Drop unneeded align attribute.
	(VM_COUNTERS): Fix member types to match 64 bit.
	(SYSTEM_PROCESS_INFORMATION): Rename from SYSTEM_PROCESSES to use
	official name from MSDN.  Fix member types to match 64 bit.  Change
	member names to match MSDN and Mingw64.  Accommodate throughout.
	(IO_STATUS_BLOCK): Change to use MSDN definition.
	(SYSTEM_TIMEOFDAY_INFORMATION): Rename from
	SYSTEM_TIME_OF_DAY_INFORMATION to use official name from MSDN.
	Accommodate throughout.  Add Reserved1 area per MSDN.
	(LDR_DATA_TABLE_ENTRY): Add comment for future reference.  Change
	type of LoadCount to USHORT.
	(PEB_LDR_DATA): Change type of Initialized to BOOLEAN.  Add comment for
	future reference.
	(PEB): Fix member types to match 64 bit.
	(GDI_TEB_BATCH): New type.
	(TEB): Fix member types to match 64 bit.
	(PROCESS_BASIC_INFORMATION): Ditto.
	(MEMORY_WORKING_SET_LIST): Ditto.
	(SharedUserData): Change comment to note the fact that the address
	is valid on 32 and 64 bit.
	* pinfo.cc (winpids::enum_processes): Add cast to avoid compiler
	warnings.
	* select.cc (pipe_data_available): Add braces in initalization of an
	IO_STATUS_BLOCK to match new definition.
	* wincap.h (class wincapc): Change type of wow64 to ULONG_PTR to match
	MSDN description.
	(wincapc::is_wow64): Convert return value explicitely to bool.
	* wow64.cc (wow64_test_for_64bit_parent): Change type of wow64 to
	ULONG_PTR to match MSDN description.  Add a cast to avoid compiler
	warning.
	* regex/engine.c: Avoid compiler warnings about unused and potentially
	uninitialized variables.
	* regex/regcomp.c: Ditto.  Drop unnecessary definition of LCID.
@
text
@d666 3
a668 3
    ULONG size = 50 * (sizeof (SYSTEM_PROCESS_INFORMATION)
		       + 16 * sizeof (SYSTEM_THREADS));
    PSYSTEM_PROCESS_INFORMATION proc;
d674 1
a674 1
	status = NtQuerySystemInformation (SystemProcessInformation,
d686 1
a686 1
    proc = (PSYSTEM_PROCESS_INFORMATION) buf;
d689 1
a689 1
	if ((DWORD) (uintptr_t) proc->UniqueProcessId == pid)
d691 1
a691 1
	if (!proc->NextEntryOffset)
d696 1
a696 1
	proc = (PSYSTEM_PROCESS_INFORMATION) ((PBYTE) proc + proc->NextEntryOffset);
d699 1
a699 1
    for (ULONG i = 0; i < proc->NumberOfThreads; ++i)
d994 2
a995 2
  SYSTEM_TIMEOFDAY_INFORMATION stodi;
  SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION spt;
d1024 2
a1025 2
    status = NtQuerySystemInformation (SystemProcessorPerformanceInformation,
				       (PVOID) &spt, sizeof spt, NULL);
d1283 1
a1283 1
  PSYSTEM_PROCESS_INFORMATION p, sp;
d1287 1
a1287 1
  p = (PSYSTEM_PROCESS_INFORMATION) malloc (n);
d1292 1
a1292 1
      status = NtQuerySystemInformation (SystemProcessInformation,
d1297 1
a1297 1
      PSYSTEM_PROCESS_INFORMATION new_p = (PSYSTEM_PROCESS_INFORMATION) realloc (p, n);
d1312 1
a1312 1
      if ((DWORD) (uintptr_t) sp->UniqueProcessId == dwProcessId)
d1317 1
a1317 1
	  for (unsigned i = 0; i < sp->NumberOfThreads; i++)
d1330 1
a1330 1
      if (!sp->NextEntryOffset)
d1332 1
a1332 1
      sp = (PSYSTEM_PROCESS_INFORMATION) ((char *) sp + sp->NextEntryOffset);
@


1.120.2.6
log
@	* fhandler_process.cc (format_process_stat): Add comment to explain
	the WOW64 problems concerning the BasePriority value.  Fix format
	string in __small_sprintf call.
	* ntdll.h: Mark more native structures as tested on 64 bit.
	(enum _EVENT_TYPE): Drop definition.
	(enum _TIMER_TYPE): Ditto.
	(enum _SECTION_INHERIT): Drop __MINGW64_VERSION_MAJOR guard.
@
text
@d1047 1
a1047 7
  /* The BasePriority returned to a 32 bit process under WOW64 is
     apparently broken, for 32 and 64 bit target processes.  64 bit
     processes get the correct base priority, even for 32 bit processes. */
  if (wincap.is_wow64 ())
    priority = 8; /* Default value. */
  else
    priority = pbi.BasePriority;
d1056 2
a1057 2
				   "%u %lu %lu %u %u %lu %lu "
				   "%ld %ld %d %d %d %d "
d1059 6
a1064 4
				   "%ld %lu",
			  p->pid, cmd, state,
			  p->ppid, p->pgid, p->sid, p->ctty, -1,
			  0, fault_count, fault_count, 0, 0, utime, stime,
@


1.120.2.7
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d317 1
a317 1
  syscall_printf ("%d = fhandler_proc::open(%y, 0%o)", res, flags, mode);
d908 1
a908 1
	      SIZE_T ret_len = 0;
d1017 1
a1017 1
      debug_printf ("OpenProcess: ret %u", error);
d1308 1
a1308 1
      debug_printf ("NtQuerySystemInformation: status %y, %u",
d1353 1
a1353 1
  SIZE_T n = 0x4000, length;
d1369 1
a1369 1
				     (length = (SIZE_T) -1, &length));
@


1.120.2.8
log
@	* pinfo.h (enum picom): Add PICOM_HEAP_INFO.
	(_pinfo::win_heap_info): Declare.
	(struct win_heap_info): Rename from heap_info and define here.  Change
	to accommodate 64 bit.
	* fhandler_process.cc (struct win_heap_info): Just implement here.
	(win_heap_info::gen_heap_info): New method.
	(format_process_maps): Accommodate above changes.  Add FIXME comment
	to explain 32->64 bit problem with VirtualQueryEx.
	* pinfo.cc (commune_process): Handle PICOM_HEAP_INFO.
	(_pinfo::commune_request): Ditto.
	(_pinfo::win_heap_info): New method.
@
text
@d548 1
a548 1
win_heap_info::win_heap_info (_pinfo *p)
d550 23
a572 4
  size_t size;
  heap_vm_chunks = (heap *) p->win_heap_info (size);
  heap_vm_chunks_end = (heap *) ((caddr_t) heap_vm_chunks + size);
}
d574 37
a610 61
commune_result
win_heap_info::gen_heap_info ()
{
  commune_result cr;
  PDEBUG_BUFFER buf;
  NTSTATUS status;
  PDEBUG_HEAP_ARRAY harray;
  PDEBUG_HEAP_BLOCK barray;
  heap *h = NULL;

  cr.n = 0;
  cr.s = NULL;
  buf = RtlCreateQueryDebugBuffer (0, FALSE);
  if (!buf)
    goto err;
  status = RtlQueryProcessDebugInformation (GetCurrentProcessId (),
					    PDI_HEAPS | PDI_HEAP_BLOCKS,
					    buf);
  if (!NT_SUCCESS (status))
    goto err;
  harray = (PDEBUG_HEAP_ARRAY) buf->HeapInformation;
  if (!harray)
    goto err;
  /* Compute size. */
  for (ULONG hcnt = 0; hcnt < harray->Count; ++hcnt)
    {
      barray = (PDEBUG_HEAP_BLOCK) harray->Heaps[hcnt].Blocks;
      if (!barray)
	continue;
      for (ULONG bcnt = 0; bcnt < harray->Heaps[hcnt].BlockCount; ++bcnt)
	if (barray[bcnt].Flags & 2)
	  cr.n += sizeof (heap);
    }
  if (!cr.n)
    goto err;
  /* Allocate. */
  cr.s = (char *) cmalloc_abort (HEAP_COMMUNE, cr.n);
  if (!cr.s)
    {
      cr.n = 0;
      goto err;
    }
  /* Fill array. */
  h = (heap *) cr.s;
  for (ULONG hcnt = 0; hcnt < harray->Count; ++hcnt)
    {
      barray = (PDEBUG_HEAP_BLOCK) harray->Heaps[hcnt].Blocks;
      if (!barray)
	continue;
      for (ULONG bcnt = 0; bcnt < harray->Heaps[hcnt].BlockCount; ++bcnt)
	if (barray[bcnt].Flags & 2)
	  {
	    h->heap_id = hcnt;
	    h->flags = harray->Heaps[hcnt].Flags;
	    h->_TYPE64_SET (base, barray[bcnt].Address);
	    h->_TYPE64_SET (end, h->base +  barray[bcnt].Size);
	    ++h;
	  }
    }
err:
  if (buf)
d612 25
a636 2
  return cr;
}
d638 4
a641 5
char *
win_heap_info::fill_if_match (char *base, ULONG type, char *dest)
{
  for (heap *h = heap_vm_chunks; h < heap_vm_chunks_end; ++h)
    if (base >= h->base && base < h->end)
d643 2
a644 15
	char *p = dest + __small_sprintf (dest, "[win heap %ld", h->heap_id);
	if (!(h->flags & HEAP_FLAG_NONDEFAULT))
	  p = stpcpy (p, " default");
	if ((h->flags & HEAP_FLAG_SHAREABLE) && (type & MEM_MAPPED))
	  p = stpcpy (p, " shared");
	if (h->flags & HEAP_FLAG_EXECUTABLE)
	  p = stpcpy (p, " exec");
	if (h->flags & HEAP_FLAG_GROWABLE)
	  p = stpcpy (p, " grow");
	if (h->flags & HEAP_FLAG_NOSERIALIZE)
	  p = stpcpy (p, " noserial");
	if (h->flags == HEAP_FLAG_DEBUGGED)
	  p = stpcpy (p, " debug");
	stpcpy (p, "]");
	return dest;
d646 2
a647 7
  return 0;
}

win_heap_info::~win_heap_info ()
{
  cfree (heap_vm_chunks);
}
d816 1
a816 1
  win_heap_info heaps (p);
d834 1
a834 6
     last_pass to trigger output of the last accumulated region.
     
     FIXME:  32 bit processes can't get address information beyond the
	     32 bit address space from 64 bit processes.  We have to run
	     this functionality in the target process, if the target
	     process is 64 bit and our own process is 32 bit. */
@


1.120.2.9
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
   2013 Red Hat, Inc.
d139 1
a139 1
int __reg2
@


1.120.2.10
log
@	* fhandler_process.cc (win_heap_info::~win_heap_info): Only try to free
	heap_vm_chunks if it's not NULL.
	* pinfo.h (struct commune_result): Change type of n to DWORD.
	* pinfo.cc (_pinfo::commune_request): Change type of n to DWORD to
	fix subsequent sizeof test after reading from commune pipe on x86_64.
	Raise read timeout to match write timeout.
@
text
@d647 1
a647 2
  if (heap_vm_chunks)
    cfree (heap_vm_chunks);
@


1.120.2.11
log
@	* fhandler_floppy.cc (fhandler_dev_floppy::open): Cast second parameter
	in roundup2 to same size as first parameter to make sure mask size is
	correct.
	* fhandler_process.cc (format_process_maps): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::dup): Ditto.
	* hookapi.cc (find_first_notloaded_dll): Add cast.
	* spawn.cc (av::fixup): Ditto.
	* wincap.h: Add comment to explain the folowing change.
	(wincapc::page_size): Return size_t.
	(wincapc::allocation_granularity): Ditto.

	* mmap.cc: Throughout, accommodate the fact that AT_ROUND_TO_PAGE isn't
	support on 64 bit at all.
	(class mmap_allocator): New class to allocate mmap slots on x86_64.
	(mmap_alloc): Define global instant of mmap_allocator.
	(mmap64): Call mmap_alloc.alloc on x86_64.
@
text
@d893 3
a895 3
		destbuf = (char *)
		  crealloc_abort (destbuf,
				  maxsize += roundup2 (newlen, 2048UL));
@


1.120.2.12
log
@	* Makefile.in (toollibdir): Remove.  Revert to using tooldir instead.
	* configure.ac (DLL_NAME): Set to cygwin1.dll in x86_64 case, too.
	* configure: Regenerate.
	* cygwin.sc.in (SEARCH_DIR): Align to 32 bit search dir, use lib, rather
	than lib64.
	* cygwin64.din (LIBRARY): Set name to cygwin1.dll.
	* fhandler_process.cc (struct heap_info): Drop win_heap_info class
	and revert code to former heap_info implementation.
	(format_process_maps): Define heaps back to heap_info
	* hookapi.cc (hook_or_detect_cygwin): Add shortcut so the code does
	not search executable for being a Cygwin executable, if the architecture
	is not matching the current Cygwin.  Always use for "cygwin1.dll".
	* pinfo.cc (commune_process): Drop PICOM_HEAP_INFO code.
	(_pinfo::commune_request): Ditto.
	(_pinfo::win_heap_info): Remove.
	* pinfo.h (enum picom): Remove PICOM_HEAP_INFO.
@
text
@d548 1
a548 1
struct heap_info
d550 4
a553 9
  struct heap
  {
    heap *next;
    unsigned heap_id;
    char *base;
    char *end;
    unsigned long flags;
  };
  heap *heap_vm_chunks;
d555 61
a615 35
  heap_info (DWORD pid)
    : heap_vm_chunks (NULL)
  {
    PDEBUG_BUFFER buf;
    NTSTATUS status;
    PDEBUG_HEAP_ARRAY harray;

    buf = RtlCreateQueryDebugBuffer (0, FALSE);
    if (!buf)
      return;
    status = RtlQueryProcessDebugInformation (pid, PDI_HEAPS | PDI_HEAP_BLOCKS,
					      buf);
    if (NT_SUCCESS (status)
	&& (harray = (PDEBUG_HEAP_ARRAY) buf->HeapInformation) != NULL)
      for (ULONG hcnt = 0; hcnt < harray->Count; ++hcnt)
	{
	  PDEBUG_HEAP_BLOCK barray = (PDEBUG_HEAP_BLOCK)
				     harray->Heaps[hcnt].Blocks;
	  if (!barray)
	    continue;
	  for (ULONG bcnt = 0; bcnt < harray->Heaps[hcnt].BlockCount; ++bcnt)
	    if (barray[bcnt].Flags & 2)
	      {
		heap *h = (heap *) malloc (sizeof (heap));
		if (h)
		  {
		    *h = (heap) { heap_vm_chunks,
				  hcnt, (char *) barray[bcnt].Address,
				  (char *) barray[bcnt].Address
					   + barray[bcnt].Size,
				  harray->Heaps[hcnt].Flags };
		    heap_vm_chunks = h;
		  }
	      }
	}
d617 2
a618 1
  }
d620 5
a624 28
  char *fill_if_match (char *base, ULONG type, char *dest)
  {
    for (heap *h = heap_vm_chunks; h; h = h->next)
      if (base >= h->base && base < h->end)
	{
	  char *p = dest + __small_sprintf (dest, "[win heap %ld", h->heap_id);
	  if (!(h->flags & HEAP_FLAG_NONDEFAULT))
	    p = stpcpy (p, " default");
	  if ((h->flags & HEAP_FLAG_SHAREABLE) && (type & MEM_MAPPED))
	    p = stpcpy (p, " shared");
	  if (h->flags & HEAP_FLAG_EXECUTABLE)
	    p = stpcpy (p, " exec");
	  if (h->flags & HEAP_FLAG_GROWABLE)
	    p = stpcpy (p, " grow");
	  if (h->flags & HEAP_FLAG_NOSERIALIZE)
	    p = stpcpy (p, " noserial");
	  if (h->flags == HEAP_FLAG_DEBUGGED)
	    p = stpcpy (p, " debug");
	  stpcpy (p, "]");
	  return dest;
	}
    return 0;
  }

  ~heap_info ()
  {
    heap *n = 0;
    for (heap *m = heap_vm_chunks; m; m = n)
d626 15
a640 2
	n = m->next;
	free (m);
d642 8
a649 2
  }
};
d818 1
a818 1
  heap_info heaps (p->dwProcessId);
@


1.119
log
@	* fhandler_process.cc (process_tab): Add entry for mountinfo.
	(format_process_mountstuff): New function, derived from
	format_process_mounts.  Only open another user's user_info shared
	memory area if the process is owned by another user.  Actually
	access the opened shared user_info to get the right mount table.
	For other users, don't print remote cygdrive mount points.  Print
	mountinfo or mounts output depending on the bool mountinfo argument.
	(format_process_mounts): Just call format_process_mountstuff with
	mountinfo set to false.
	(format_process_mountinfo): Ditto with mountinfo set to true.

	* new-features.sgml (ov-new1.7.11): Add mountinfo.
@
text
@d4 1
a4 1
   2010, 2011 Red Hat, Inc.
@


1.118
log
@	* external.cc (cygwin_internal): Implement CW_ALLOC_DRIVE_MAP,
	CW_MAP_DRIVE_MAP, CW_FREE_DRIVE_MAP.
	* fhandler_process.cc: Include mount.h.
	(get_volume_path_names_for_volume_name): Move to mount.cc.
	(struct dos_drive_mappings): Ditto.
	* mount.cc (get_volume_path_names_for_volume_name): Move here.
	(dos_drive_mappings::dos_drive_mappings): Ditto.
	(dos_drive_mappings::fixup_if_match): Ditto.
	(dos_drive_mappings::~dos_drive_mappings): Ditto.
	* mount.h (class dos_drive_mappings): Declare her.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_ALLOC_DRIVE_MAP,
	CW_MAP_DRIVE_MAP, CW_FREE_DRIVE_MAP.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d30 1
d55 1
d69 1
d1162 1
a1162 1
format_process_mounts (void *data, char *&destbuf)
d1170 1
a1170 1
  if (p->pid != myself->pid)
d1187 1
d1194 5
a1198 1
  while ((mnt = getmntent (NULL)))
d1200 12
d1217 19
a1235 4
						  + 28);
      len += __small_sprintf (destbuf + len, "%s %s %s %s %d %d\n",
			      mnt->mnt_fsname, mnt->mnt_dir, mnt->mnt_type,
			      mnt->mnt_opts, mnt->mnt_freq, mnt->mnt_passno);
d1237 2
a1238 2
  /* Restore old value of _my_tls.locals here. */
  _my_tls.locals.iteration = iteration;
d1249 12
@


1.117
log
@	* fhandler_process.cc: Drop unneeded includes.
@
text
@d28 1
a544 163
static bool
get_volume_path_names_for_volume_name (LPCWSTR vol, LPWSTR mounts)
{
  DWORD len;
  if (GetVolumePathNamesForVolumeNameW (vol, mounts, NT_MAX_PATH, &len))
    return true;

  /* Windows 2000 doesn't have GetVolumePathNamesForVolumeNameW.
     Just assume that mount points are not longer than MAX_PATH. */
  WCHAR drives[MAX_PATH], dvol[MAX_PATH], mp[MAX_PATH + 3];
  if (!GetLogicalDriveStringsW (MAX_PATH, drives))
    return false;
  for (PWCHAR drive = drives; *drive; drive = wcschr (drive, '\0') + 1)
    {
      if (!GetVolumeNameForVolumeMountPointW (drive, dvol, MAX_PATH))
	continue;
      if (!wcscasecmp (vol, dvol))
	mounts = wcpcpy (mounts, drive) + 1;
      wcscpy (mp, drive);
      HANDLE h = FindFirstVolumeMountPointW (dvol, mp + 3, MAX_PATH);
      if (h == INVALID_HANDLE_VALUE)
	continue;
      do
	{
	  if (GetVolumeNameForVolumeMountPointW (mp, dvol, MAX_PATH))
	    if (!wcscasecmp (vol, dvol))
	      mounts = wcpcpy (mounts, drive) + 1;
	}
      while (FindNextVolumeMountPointW (h, mp, MAX_PATH));
      FindVolumeMountPointClose (h);
    }
  *mounts = L'\0';
  return true;
}

struct dos_drive_mappings
{
  struct mapping
  {
    mapping *next;
    size_t doslen;
    size_t ntlen;
    wchar_t *dospath;
    wchar_t *ntdevpath;
  };
  mapping *mappings;

  dos_drive_mappings ()
    : mappings(0)
  {
    tmp_pathbuf tp;
    wchar_t vol[64]; /* Long enough for Volume GUID string */
    wchar_t *devpath = tp.w_get ();
    wchar_t *mounts = tp.w_get ();

    /* Iterate over all volumes, fetch the first path from the list of
       DOS paths the volume is mounted to, or use the GUID volume path
       otherwise. */
    HANDLE sh = FindFirstVolumeW (vol, 64);
    if (sh == INVALID_HANDLE_VALUE)
      debug_printf ("FindFirstVolumeW, %E");
    else
      do
	{
	  /* Skip drives which are not mounted. */
	  if (!get_volume_path_names_for_volume_name (vol, mounts)
	      || mounts[0] == L'\0')
	    continue;
	  *wcsrchr (vol, L'\\') = L'\0';
	  if (QueryDosDeviceW (vol + 4, devpath, NT_MAX_PATH))
	    {
	      /* The DOS drive mapping can be another symbolic link.  If so,
		 the mapping won't work since the section name is the name
		 after resolving all symlinks.  Resolve symlinks here, too. */
	      for (int syml_cnt = 0; syml_cnt < SYMLOOP_MAX; ++syml_cnt)
		{
		  UNICODE_STRING upath;
		  OBJECT_ATTRIBUTES attr;
		  NTSTATUS status;
		  HANDLE h;

		  RtlInitUnicodeString (&upath, devpath);
		  InitializeObjectAttributes (&attr, &upath,
					      OBJ_CASE_INSENSITIVE, NULL, NULL);
		  status = NtOpenSymbolicLinkObject (&h, SYMBOLIC_LINK_QUERY,
						     &attr);
		  if (!NT_SUCCESS (status))
		    break;
		  RtlInitEmptyUnicodeString (&upath, devpath, (NT_MAX_PATH - 1)
							      * sizeof (WCHAR));
		  status = NtQuerySymbolicLinkObject (h, &upath, NULL);
		  NtClose (h);
		  if (!NT_SUCCESS (status))
		    break;
		  devpath[upath.Length / sizeof (WCHAR)] = L'\0';
		}
	      mapping *m = new mapping ();
	      if (m)
		{
		  m->dospath = wcsdup (mounts);
		  m->ntdevpath = wcsdup (devpath);
		  if (!m->dospath || !m->ntdevpath)
		    {
		      free (m->dospath);
		      free (m->ntdevpath);
		      delete m;
		      continue;
		    }
		  m->doslen = wcslen (m->dospath);
		  m->dospath[--m->doslen] = L'\0'; /* Drop trailing backslash */
		  m->ntlen = wcslen (m->ntdevpath);
		  m->next = mappings;
		  mappings = m;
		}
	    }
	  else
	    debug_printf ("Unable to determine the native mapping for %ls "
			  "(error %lu)", vol, GetLastError ());
	}
      while (FindNextVolumeW (sh, vol, 64));
      FindVolumeClose (sh);
  }

  wchar_t *fixup_if_match (wchar_t *path)
  {
    /* Check for network drive first. */
    if (!wcsncmp (path, L"\\Device\\Mup\\", 12))
      {
	path += 10;
	path[0] = L'\\';
	return path;
      }
    /* Then test local drives. */
    for (mapping *m = mappings; m; m = m->next)
      if (!wcsncmp (m->ntdevpath, path, m->ntlen))
	{
	  wchar_t *tmppath;

	  if (m->ntlen > m->doslen)
	    wcsncpy (path += m->ntlen - m->doslen, m->dospath, m->doslen);
	  else if ((tmppath = wcsdup (path + m->ntlen)) != NULL)
	    {
	      wcpcpy (wcpcpy (path, m->dospath), tmppath);
	      free (tmppath);
	    }
	  break;
	}
    return path;
  }

  ~dos_drive_mappings ()
  {
    mapping *n = 0;
    for (mapping *m = mappings; m; m = n)
      {
	n = m->next;
	free (m->dospath);
	free (m->ntdevpath);
	delete m;
      }
  }
};

@


1.116
log
@	Throughout use wincap.allocation_granularity instead of getpagesize.
	Throughout use wincap.page_size instead of getsystempagesize.
	Throughout use "status" as variable name to hold NTSTATUS values.
	* fhandler_mem.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	Fix debug_printf output.  Rectify long statements.  Fix comment
	formatting.
	* fhandler_proc.cc: Ditto.
	(format_proc_swaps): Drop useless test for ERROR_PROC_NOT_FOUND.
	* fhandler_process.cc: Ditto as in fhandler_mem.cc.
	(get_process_state): Rearrange allocation loop.  Use malloc/realloc.
	(get_mem_values): Fix potential NULL pointer usage.  Drop unused
	variable.
	* pinfo.cc (winpids::enum_processes): Handle low memory gracefully.
	* sec_auth.cc (get_priv_list): Drop local variable ret.
	* shared.cc (memory_init): Drop outdated call to getpagesize.
	* syscalls.cc (getsystempagesize): Remove.
	* sysconf.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	(sysinfo): Constify sizeof_stodi.  Drop useless test for
	ERROR_PROC_NOT_FOUND.
	* thread.cc (pthread_getattr_np): Cast pointers to uintptr_t rather
	than to int for pointer arithmetic.
	* winsup.h (getsystempagesize): Drop declaration.
@
text
@a30 2
#include <psapi.h>
#include <tlhelp32.h>
@


1.115
log
@	Don't leave Windows 2000 behind.

	* autoload.cc (GetSystemWow64DirectoryW): Define.
	(GetVolumePathNamesForVolumeNameW): Define.
	* fhandler_process.cc (get_volume_path_names_for_volume_name): New
	static function to workaround missing GetVolumePathNamesForVolumeNameW
	function in Windows 2000.
	(dos_drive_mappings::dos_drive_mappings): Call
	get_volume_path_names_for_volume_name instead of
	GetVolumePathNamesForVolumeNameW.
@
text
@d91 2
a92 3
 * -1 if path is a file, -2 if path is a symlink, -3 if path is a pipe,
 * -4 if path is a socket.
 */
d1023 1
a1023 1
	  cur.rend = next.rend; // merge with previous
d1026 1
a1026 1
	  // output the current region if it's "interesting"
d1046 1
a1046 1
	  // start of a new region (but possibly still the same allocation)
d1048 1
a1048 1
	  // if a new allocation, figure out what kind it is
d1123 2
a1124 4
  /*
   * Note: under Windows, a _process_ is always running - it's only _threads_
   * that get suspended. Therefore the default state is R (runnable).
   */
d1133 1
a1133 1
  NTSTATUS ret;
d1145 11
a1155 19
      ret = NtQueryInformationProcess (hProcess,
				       ProcessVmCounters,
				       (PVOID) &vmc,
				       sizeof vmc, NULL);
      if (ret == STATUS_SUCCESS)
	ret = NtQueryInformationProcess (hProcess,
					 ProcessTimes,
					 (PVOID) &put,
					 sizeof put, NULL);
      if (ret == STATUS_SUCCESS)
	ret = NtQueryInformationProcess (hProcess,
					 ProcessBasicInformation,
					 (PVOID) &pbi,
					 sizeof pbi, NULL);
      if (ret == STATUS_SUCCESS)
	ret = NtQueryInformationProcess (hProcess,
					 ProcessQuotaLimits,
					 (PVOID) &ql,
					 sizeof ql, NULL);
d1165 7
a1171 9
  if (ret == STATUS_SUCCESS)
    ret = NtQuerySystemInformation (SystemTimeOfDayInformation,
				    (PVOID) &stodi,
				    sizeof stodi, NULL);
  if (ret == STATUS_SUCCESS)
    ret = NtQuerySystemInformation (SystemProcessorTimes,
				    (PVOID) &spt,
				    sizeof spt, NULL);
  if (ret != STATUS_SUCCESS)
d1173 2
a1174 2
      __seterrno_from_nt_status (ret);
      debug_printf ("NtQueryInformationProcess: ret %d, Dos(ret) %E", ret);
d1193 1
a1193 1
  unsigned page_size = getsystempagesize ();
d1236 2
a1237 4
  /*
   * Note: under Windows, a _process_ is always running - it's only _threads_
   * that get suspended. Therefore the default state is R (runnable).
   */
d1266 1
a1266 1
  unsigned page_size = getsystempagesize ();
d1269 3
a1271 3
  // The real uid value for *this* process is stored at cygheap->user.real_uid
  // but we can't get at the real uid value for any other process, so
  // just fake it as p->uid. Similar for p->gid.
d1381 5
a1385 9
  /*
   * This isn't really heavy magic - just go through the processes'
   * threads one by one and return a value accordingly
   * Errors are silently ignored.
   */
  NTSTATUS ret;
  SYSTEM_PROCESSES *sp;
  ULONG n = 0x1000;
  PULONG p = new ULONG[n];
d1387 17
a1403 6
  while (STATUS_INFO_LENGTH_MISMATCH ==
	 (ret = NtQuerySystemInformation (SystemProcessesAndThreadsInformation,
					 (PVOID) p,
					 n * sizeof *p, NULL)))
    delete [] p, p = new ULONG[n *= 2];
  if (ret != STATUS_SUCCESS)
d1405 2
a1406 2
      debug_printf ("NtQuerySystemInformation: ret %d, Dos(ret) %d",
		    ret, RtlNtStatusToDosError (ret));
d1410 1
a1410 1
  sp = (SYSTEM_PROCESSES *) p;
d1433 1
a1433 1
      sp = (SYSTEM_PROCESSES *) ((char *) sp + sp->NextEntryDelta);
d1436 1
a1436 1
  delete [] p;
d1446 1
a1446 1
  NTSTATUS ret;
d1449 1
a1449 1
  MEMORY_WORKING_SET_LIST *mwsl;
d1451 5
a1455 4
  PMEMORY_WORKING_SET_LIST p = (PMEMORY_WORKING_SET_LIST) malloc (n);
  unsigned page_size = getsystempagesize ();
  hProcess = OpenProcess (PROCESS_QUERY_INFORMATION,
			  FALSE, dwProcessId);
d1464 4
a1467 3
      ret = NtQueryVirtualMemory (hProcess, 0, MemoryWorkingSetList,
				  (PVOID) p, n, (length = ULONG_MAX, &length));
      if (ret != STATUS_INFO_LENGTH_MISMATCH)
d1476 1
a1476 1
  if (!NT_SUCCESS (ret))
d1478 2
a1479 2
      debug_printf ("NtQueryVirtualMemory: ret %p", ret);
      if (ret == STATUS_PROCESS_IS_TERMINATING)
d1485 1
a1485 1
	__seterrno_from_nt_status (ret);
d1488 1
a1488 2
  mwsl = (MEMORY_WORKING_SET_LIST *) p;
  for (unsigned long i = 0; i < mwsl->NumberOfPages; i++)
d1491 1
a1491 1
      unsigned flags = mwsl->WorkingSetList[i] & 0x0FFF;
d1502 3
a1504 3
  ret = NtQueryInformationProcess (hProcess, ProcessVmCounters, (PVOID) &vmc,
				   sizeof vmc, NULL);
  if (!NT_SUCCESS (ret))
d1506 2
a1507 2
      debug_printf ("NtQueryInformationProcess: ret %p", ret);
      __seterrno_from_nt_status (ret);
d1510 1
a1510 1
  *vmsize = vmc.PagefileUsage / page_size;
@


1.114
log
@	* fhandler_process.cc (dos_drive_mappings): Partially rewrite to
	handle volumes mounted into juntion points correctly.
@
text
@d547 35
a610 1
	  DWORD len;
d612 1
a612 1
	  if (!GetVolumePathNamesForVolumeNameW (vol, mounts, NT_MAX_PATH, &len)
@


1.113
log
@	* fhandler_process.cc (dos_drive_mappings::dos_drive_mappings): Fully
	resolve symbolic links returned by QueryDosDeviceW.  Explain why.
@
text
@d552 4
a555 3
    int len;
    wchar_t drive_letter;
    wchar_t mapping[1];
d562 11
a572 23
    /* The logical drive strings buffer holds a list of (at most 26)
       drive names separated by nulls and terminated by a double-null:

       "a:\\\0b:\\\0...z:\\\0"

       The annoying part is, QueryDosDeviceW wants only "x:" rather
       than the "x:\" we get back from GetLogicalDriveStringsW, so
       we'll have to strip out the trailing slash for each mapping.

       The returned mapping a native NT pathname (\Device\...) which
       we can use to fix up the output of GetMappedFileNameW
    */
    static unsigned const DBUFLEN = 26 * 4;
    wchar_t dbuf[DBUFLEN + 1];
    wchar_t pbuf[NT_MAX_PATH];
    wchar_t drive[] = {L'x', L':', 0};
    unsigned result = GetLogicalDriveStringsW (DBUFLEN * sizeof (wchar_t),
					       dbuf);
    if (!result)
      debug_printf ("Failed to get logical DOS drive names: %lu",
		    GetLastError ());
    else if (result > DBUFLEN)
      debug_printf ("Too many mapped drive letters: %u", result);
d574 60
a633 45
      for (wchar_t *cur = dbuf; (*drive = *cur); cur = wcschr (cur, L'\0')+1)
	if (QueryDosDeviceW (drive, pbuf, NT_MAX_PATH))
	  {
	    /* The DOS drive mapping can be another symbolic link.  The result
	       is that the mapping won't work since the section name is the
	       name after resolving all symbolic links.  So we have to resolve
	       symbolic links here, too. */
	    for (int syml_cnt = 0; syml_cnt < SYMLOOP_MAX; ++syml_cnt)
	      {
		UNICODE_STRING upath;
		OBJECT_ATTRIBUTES attr;
		NTSTATUS status;
		HANDLE h;

		RtlInitUnicodeString (&upath, pbuf);
		InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE,
					    NULL, NULL);
		status = NtOpenSymbolicLinkObject (&h, SYMBOLIC_LINK_QUERY,
						   &attr);
		if (!NT_SUCCESS (status))
		  break;
		RtlInitEmptyUnicodeString (&upath, pbuf,
					   (NT_MAX_PATH - 1) * sizeof (WCHAR));
		status = NtQuerySymbolicLinkObject (h, &upath, NULL);
		NtClose (h);
		if (!NT_SUCCESS (status))
		  break;
		pbuf[upath.Length / sizeof (WCHAR)] = L'\0';
	      }
	    size_t plen = wcslen (pbuf);
	    size_t psize = plen * sizeof (wchar_t);
	    debug_printf ("DOS drive %ls maps to %ls", drive, pbuf);
	    mapping *m = (mapping*) malloc (sizeof (mapping) + psize);
	    if (m)
	      {
		m->next = mappings;
		m->len = plen;
		m->drive_letter = *drive;
		memcpy (m->mapping, pbuf, psize + sizeof (wchar_t));
		mappings = m;
	      }
	  }
	else
	  debug_printf ("Unable to determine the native mapping for %ls "
			"(error %lu)", drive, GetLastError ());
d647 1
a647 1
      if (!wcsncmp (m->mapping, path, m->len))
d649 9
a657 3
	  path += m->len - 2;
	  path[0] = m->drive_letter;
	  path[1] = L':';
d669 3
a671 1
	free (m);
@


1.112
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d588 26
@


1.111
log
@	* fhandler_process.cc (dos_drive_mappings::fixup_if_match): Convert
	native NT network paths into DOS UNC paths.
@
text
@d239 1
a239 1
  syscall_printf ("%d = readdir (%p, %p) (%s)", res, dir, de, de->d_name);
d316 1
a316 1
  syscall_printf ("%d = fhandler_proc::open (%p, %d)", res, flags, mode);
@


1.110
log
@	* fhandler.h (fhandler_process::closedir): Declare.
	* fhandler_process.cc (fhandler_process::closedir): New function to
	avoid a SEGV in fhandler_proc::closedir.
@
text
@d608 8
@


1.109
log
@	* fhandler_process.cc (format_process_maps): Define page protection
	shortcuts RO, X, and WC.  Use in creating access flag string.  Don't
	set type flag to 's' for copy-on-write pages, as on Linux.
@
text
@d213 6
@


1.108
log
@	* dlfcn.cc (dlopen): Reimplement RTLD_NODELETE for Windows 2000 using
	internal datastructures.  Explain the code.
	* ntdll.h (struct _LDR_DATA_TABLE_ENTRY): Define.
	(struct _PEB_LDR_DATA): Define.
	(struct _PEB): Change PVOID LoaderData to PPEB_LDR_DATA Ldr.

	* fhandler_process.cc (format_process_maps): Call NtQueryVirtualMemory
	with valid return length pointer.  Explain why.
@
text
@d910 1
d913 3
d918 5
a922 6
	      (p & (RW | PAGE_EXECUTE_READ | PAGE_READONLY))   ? 'r' : '-',
	      (p & (RW))				       ? 'w' : '-',
	      (p & (PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_READ
		    | PAGE_EXECUTE_WRITECOPY | PAGE_EXECUTE))  ? 'x' : '-',
	      (mb.Type & MEM_MAPPED)			       ? 's'
	      : (p & PAGE_GUARD)			       ? 'g' : 'p',
@


1.107
log
@	* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Don't allow to
	access process info by using the Windows PID.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	(fhandler_process::fill_filebuf): Ditto.
@
text
@d963 4
d970 1
a970 1
		  && NT_SUCCESS (NtQueryVirtualMemory (proc, cur.abase,
d972 1
a972 1
						       msi, 65536, NULL)))
@


1.106
log
@	* fhandler_process.cc (format_process_status): Always print process name
	even for zombies.
	(get_mem_values): Fix loop fetching working set list to avoid out of
	memory conditions.  Return all mem values set to 0 for zombies.
	* ntdll.h (STATUS_PROCESS_IS_TERMINATING): Define.
@
text
@d146 1
d148 5
a152 1
  if (!p)
d328 5
a332 2

  if (!p)
@


1.105
log
@	* fhandler_process.cc (format_process_maps): Actually print info about
	the application heap of the printed process, not of the current process.
@
text
@d1138 10
a1147 15
  if (p->process_state & PID_EXITED)
    strcpy (cmd, "<defunct>");
  else
    {
      PWCHAR last_slash = wcsrchr (p->progname, L'\\');
      wcscpy (wcmd, last_slash ? last_slash + 1 : p->progname);
      sys_wcstombs (cmd, NAME_MAX + 1, wcmd);
      int len = strlen (cmd);
      if (len > 4)
	{
	  char *s = cmd + len - 4;
	  if (ascii_strcasematch (s, ".exe"))
	    *s = 0;
	 }
    }
d1368 1
a1368 1
  do
d1372 8
a1379 11
      if (ret == STATUS_INFO_LENGTH_MISMATCH
	  || (!NT_SUCCESS (ret) && length > n))
	{
	  ret = STATUS_INFO_LENGTH_MISMATCH;
	  n <<= 1;
	  PMEMORY_WORKING_SET_LIST new_p = (PMEMORY_WORKING_SET_LIST)
					   realloc (p, n);
	  if (!new_p)
	    goto out;
	  p = new_p;
	}
a1380 1
  while (!NT_SUCCESS (ret));
d1384 7
a1390 1
      __seterrno_from_nt_status (ret);
@


1.104
log
@	* fhandler_process.cc (heap_info::fill_if_match): Rename info to
	note that this heap is a Windows heap.
	(format_process_maps): Print info about application heap.
@
text
@d845 5
d984 1
a984 1
		  else if (cur.abase == cygheap->user_heap.base)
@


1.103
log
@Rename FH_BAD to FH_NADA throughout.
* devices.h (FH_ERROR): New value.
(iscons_dev): Extend to detect all the console device types.
* devices.in: Set aside storage for FH_ERROR.
* dtable.cc (dtable::init_std_file_from_handle): Use iscons_dev to detect when
device is a console.
(fh_alloc): Pass device to console constructor.
(build_fh_pc): Short circuit when we detect that the constructor saw an error.
* fhandler.h (fhandler_console::fhandler_console): Accept fh_devices parameter.
(get_tty_stuff): Change to void.
* fhandler_console (fhandler_console::set_unit): Set device to FH_ERROR on
attempt to access anything other than the current console.
(fhandler_console::get_tty_stuff): Change to void return.
(fhandler_console::open): Return EPERM on FH_ERROR device type.
(fhandler_console::fhandler_console): Set the device type appropriately before
calling get_tty_stuff and rely on that function to reset it if necessary.
@
text
@d671 1
a671 1
	  char *p = dest + __small_sprintf (dest, "[heap %ld", h->heap_id);
d979 2
@


1.102
log
@whitespace elimination
@
text
@d79 1
a79 1
  { NULL, 0,	        FH_BAD,       virt_none,      NULL }
@


1.101
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d333 1
a333 1
        {
d543 1
a543 1
  
d555 1
a555 1
       
d591 1
a591 1
  
d604 1
a604 1
  
d643 1
a643 1
      	{
d665 1
a665 1
  
d689 2
a690 2
  
  ~heap_info () 
d728 1
a728 1
      	size <<= 1;
d756 1
a756 1
	
d790 1
a790 1
  
d810 2
a811 2
  
  ~thread_info () 
d847 1
a847 1
  
d860 1
a860 1
  
d878 1
a878 1
  
d887 1
a887 1
      	posix_modname[0] = '\0';
d916 1
a916 1
      
d947 1
a947 1
	  // if a new allocation, figure out what kind it is 
d1250 1
a1250 1
      	return 0;
d1325 1
a1325 1
              /* FIXME: at some point we should consider generating 'O' */
d1372 1
a1372 1
      	{
@


1.100
log
@	* fhandler_process.cc (thread_info::fill_if_match): Reformat.
	(format_process_maps): Ditto.  Fetch pointer to procinfo structure
	from mapped process.  Print info about global shared Cygwin regions.
@
text
@d79 1
a79 1
  { NULL, 0,	        0,            virt_none,      NULL }
d421 1
d423 3
a425 2
  destbuf = (char *) crealloc_abort (destbuf, 40);
  return __small_sprintf (destbuf, "%d\n", p->ctty);
d1113 1
a1113 1
			  p->ppid, p->pgid, p->sid, makedev (FH_TTYS, p->ctty),
@


1.99
log
@	* fhandler_process.cc (struct dos_drive_mappings): Use malloc/free
	rather than cmalloc/cfree.  Check return value from malloc before
	using it.
	(struct heap_info): Ditto.
	(struct thread_info): Ditto.  Rename from stack_info.  Rename members
	and local variables accordingly.
	(thread_info::thread_info): Store stack and TEB addresses.
	(thread_info::fill_if_match): Print "teb" if a TEB address has been
	found.  Special case for WOW64, explain why.
	(format_process_maps): Fetch PEB address.  Print MEM_RESERVE regions
	with equal signs to distinguish them from PAGE_NOACCESS regions.  Fix
	printing of 'p' and 's' to differ between MEM_PRIVATE and MEM_MAPPED
	pages, as on Linux.  Print 'g' instead of 'p for PAGE_GUARD pages.
	Print PEB and SharedUserData area if recognized.
@
text
@d798 3
a800 5
	  char *p;

	  p = dest + __small_sprintf (dest, "[%s (tid %ld)",
				      r->teb ? "teb" : "stack",
				      r->thread_id);
d825 1
a825 2
			     FALSE,
			     p->dwProcessId);
d833 1
d838 5
d971 6
@


1.98
log
@	* fhandler_process.cc (struct heap_info): Change type of base and end
	members to char *.  Print "shared" rather than "share".
	(struct stack_info): New class to fetch process stack information.
	(format_process_maps): Initialize and check for stack information.
@
text
@d575 9
a583 7
	    mapping *m = (mapping*) cmalloc (HEAP_FHANDLER,
					     sizeof (mapping) + psize);
	    m->next = mappings;
	    m->len = plen;
	    m->drive_letter = *drive;
	    memcpy (m->mapping, pbuf, psize + sizeof (wchar_t));
	    mappings = m;
d609 1
a609 1
	cfree (m);
d649 10
a658 6
		heap *h = (heap *) cmalloc (HEAP_FHANDLER, sizeof (heap));
		*h = (heap) { heap_vm_chunks,
			      hcnt, (char *) barray[bcnt].Address,
			      (char *) barray[bcnt].Address + barray[bcnt].Size,
			      harray->Heaps[hcnt].Flags };
		heap_vm_chunks = h;
d694 1
a694 1
	cfree (m);
d699 1
a699 1
struct stack_info
d701 1
a701 1
  struct stack
d703 1
a703 1
    stack *next;
d707 1
d709 1
a709 1
  stack *stacks;
d711 2
a712 2
  stack_info (DWORD pid, HANDLE process)
    : stacks (NULL)
d763 9
d775 10
a784 5
	stack *s = (stack *) cmalloc (HEAP_FHANDLER, sizeof (stack));
	*s = (stack) { stacks, (ULONG) thread[i].ClientId.UniqueThread,
		       (char *) (teb.DeallocationStack ?: teb.Tib.StackLimit),
		       (char *) teb.Tib.StackBase };
	stacks = s;
d791 6
a796 2
    for (stack *s = stacks; s; s = s->next)
      if (base >= s->start && base < s->end)
d798 5
a802 2
	  char *p = dest + __small_sprintf (dest, "[stack (tid %ld)",
					    s->thread_id);
d811 1
a811 1
  ~stack_info () 
d813 2
a814 2
    stack *n = 0;
    for (stack *m = stacks; m; m = n)
d817 1
a817 1
	cfree (m);
d832 9
d859 1
a859 1
  stack_info stacks (p->dwProcessId, proc);
d881 2
d885 5
d896 2
a897 2
	      (p & (RW | PAGE_EXECUTE_READ | PAGE_READONLY))?	'r' : '-',
	      (p & (RW))?					'w' : '-',
d899 3
a901 2
		    | PAGE_EXECUTE_WRITECOPY | PAGE_EXECUTE))?	'x' : '-',
	      (p & (PAGE_GUARD))? 				's' : 'p',
d943 1
a943 1
	  if (newbase && !last_pass)
d959 2
a960 2
	      else if (!stacks.fill_if_match (cur.abase, mb.Type,
					      posix_modname)
d964 4
a967 2
		  if (mb.Type & MEM_MAPPED)
		    strcpy (posix_modname, "[shareable]");
@


1.97
log
@	* fhandler_process.cc (struct heap_info::heap): Convert base to
	uintptr_t.  Add heap_id, end, flags members.
	(heap_info::heap_vm_chunks): Rename from heaps.
	(heap_info::heap_info): Rearrange using RtlQueryProcessDebugInformation
	to get information of heap virtual memory blocks.  Store heap id and
	flags, as well as end address of each block.
	(heap_info::fill_if_match): Check incoming base address against full
	address range of heap chunks.  Convert flag values in extra heap
	information.
	(format_process_maps): Change order so that heap check is done before
	MEM_MAPPED check since there are shareable heaps.
	* ntdll.h (PDI_HEAP_BLOCKS): Define.
	(HEAP_FLAG_NOSERIALIZE): Define.
	(HEAP_FLAG_GROWABLE): Define.
	(HEAP_FLAG_EXCEPTIONS): Define.
	(HEAP_FLAG_NONDEFAULT): Define.
	(HEAP_FLAG_SHAREABLE): Define.
	(HEAP_FLAG_EXECUTABLE): Define.
	(HEAP_FLAG_DEBUGGED): Define.
	(struct _DEBUG_HEAP_ARRAY): Define.
	(struct _DEBUG_HEAP_BLOCK): Define.
@
text
@d618 2
a619 2
    uintptr_t base;
    uintptr_t end;
d625 1
a625 1
    : heap_vm_chunks (0)
d649 2
a650 2
			      hcnt, barray[bcnt].Address,
			      barray[bcnt].Address + barray[bcnt].Size,
d658 1
a658 1
  char *fill_if_match (void *base, ULONG type, char *dest )
d661 1
a661 1
      if ((uintptr_t) base >= h->base && (uintptr_t) base < h->end)
d663 1
a663 3
	  char *p;
	  __small_sprintf (dest, "[heap %ld", h->heap_id);
	  p = strchr (dest, '\0');
d667 1
a667 1
	    p = stpcpy (p, " share");
d693 101
d822 1
d914 4
a917 1
	      else if (!heaps.fill_if_match (cur.abase, mb.Type, posix_modname))
@


1.96
log
@	* fhandler_process.cc (format_process_maps): Rework to report
	all mapped address space in a process (committed or reserved),
	identifying the nature of the mapping (mapped file/image, heap,
	shared memory) when possible.
	(dos_drive_mappings): New helper classes.
	(heap_info): Ditto.
	* ntdll.h (struct _MEMORY_SECTION_NAME): Define.
@
text
@d617 4
a620 1
    void *base;
d622 1
a622 1
  heap *heaps;
d625 1
a625 1
    : heaps (0)
d627 29
a655 12
    HANDLE hHeapSnap = CreateToolhelp32Snapshot (TH32CS_SNAPHEAPLIST, pid);
    HEAPLIST32 hl;
    hl.dwSize = sizeof(hl);

    if (hHeapSnap != INVALID_HANDLE_VALUE && Heap32ListFirst (hHeapSnap, &hl))
      do
	{
	  heap *h = (heap *) cmalloc (HEAP_FHANDLER, sizeof (heap));
	  *h = (heap) {heaps, (void*) hl.th32HeapID};
	  heaps = h;
	} while (Heap32ListNext (hHeapSnap, &hl));
    CloseHandle (hHeapSnap);
d658 1
a658 1
  char *fill_if_match (void *base, char *dest )
d660 2
a661 3
    long count = 0;
    for (heap *h = heaps; h && ++count; h = h->next)
      if (base == h->base)
d663 16
a678 1
	  __small_sprintf (dest, "[heap %ld]", count);
d687 1
a687 1
    for (heap *m = heaps; m; m = n)
d814 7
a820 5
	      else if (mb.Type & MEM_MAPPED)
		strcpy (posix_modname, "[shareable]");
	      else if (!(mb.Type & MEM_PRIVATE
			 && heaps.fill_if_match (cur.abase, posix_modname)))
		posix_modname[0] = 0;
@


1.95
log
@	Drop NT4 support.
	* autoload.cc (DnsQuery_A): Fatal if not available.
	(DnsRecordListFree): Ditto.
	(DsGetDcNameW): Ditto.
	(NetGetAnyDCName): Remove.
	(NetGetDCName): Remove.
	(EnumProcessModules): Fatal if not available.
	(GetModuleFileNameExW): Ditto.
	(GetModuleInformation): Ditto.
	(GetProcessMemoryInfo): Ditto.
	(QueryWorkingSet): Ditto.
	(LsaRegisterLogonProcess): Ditto.
	* fenv.cc (_feinitialise): Drop supports_sse condition.
	* fhandler_disk_file.cc (path_conv::isgood_inode): Fix comment.
	(fhandler_base::fstat_by_name): Drop has_fileid_dirinfo condition.
	(fhandler_disk_file::opendir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Fix comment.
	* fhandler_proc.cc (format_proc_partitions): Drop NT4-only code.
	* fhandler_process.cc (get_process_state): Ditto.
	* kernel32.cc (GetWindowsDirectoryW): Remove.
	(GetWindowsDirectoryA): Remove.
	* miscfuncs.cc (nice_to_winprio): Drop NT4-only code.
	* mount.cc (fs_info::update): Fix comments.
	* net.cc (get_2k_ifs): Drop NT4-only code.
	* sec_auth.cc (get_logon_server): Ditto.
	(lsaauth): Drop NT4-specific error handling.
	* security.cc (alloc_sd): Set SE_DACL_PROTECTED unconditionally.
	* select.cc (select_stuff::wait): Always use MWMO_INPUTAVAILABLE.
	(peek_windows): Drop NT4-only condition in call to PeekMessage.
	* syscalls.cc (gethostid): Remove NT4-only workaround.
	* wincap.cc: Througout, drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse from
	wincaps.
	(wincap_nt4sp4): Remove.
	(wincap_minimal): Set to wincap_2000.
	(wincapc::init): Rely on availability of OSVERSIONINFOEX structure.
	Treat error from GetVersionEx as fatal.  Treat NT4 as fatal.
	* wincap.h (struct wincaps): Drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse flags
	and methods.
	* winlean.h (GetWindowsDirectoryW) Define as GetSystemWindowsDirectoryW.
	(GetWindowsDirectoryA): Define as GetSystemWindowsDirectoryA.
@
text
@d32 1
d531 130
d672 19
a690 5
  HMODULE *modules;
  DWORD needed, i;
  DWORD_PTR wset_size;
  DWORD_PTR *workingset = NULL;
  MODULEINFO info;
d693 1
a693 1
  PWCHAR modname = tp.w_get ();
d702 7
a708 1
  if (!EnumProcessModules (proc, NULL, 0, &needed))
d710 16
a725 11
      __seterrno ();
      len = -1;
      goto out;
    }
  modules = (HMODULE*) alloca (needed);
  if (!EnumProcessModules (proc, modules, needed, &needed))
    {
      __seterrno ();
      len = -1;
      goto out;
    }
d727 38
a764 28
  QueryWorkingSet (proc, (void *) &wset_size, sizeof wset_size);
  if (GetLastError () == ERROR_BAD_LENGTH)
    {
      workingset = (DWORD_PTR *) alloca (sizeof (DWORD_PTR) * ++wset_size);
      if (!QueryWorkingSet (proc, (void *) workingset,
			    sizeof (DWORD_PTR) * wset_size))
	workingset = NULL;
    }
  for (i = 0; i < needed / sizeof (HMODULE); i++)
    if (GetModuleInformation (proc, modules[i], &info, sizeof info)
	&& GetModuleFileNameExW (proc, modules[i], modname, NT_MAX_PATH))
      {
	char access[5];
	strcpy (access, "r--p");
	struct __stat64 st;
	if (mount_table->conv_to_posix_path (modname, posix_modname, 0))
	  sys_wcstombs (posix_modname, NT_MAX_PATH, modname);
	if (stat64 (posix_modname, &st))
	  {
	    st.st_dev = 0;
	    st.st_ino = 0;
	  }
	size_t newlen = strlen (posix_modname) + 62;
	if (len + newlen >= maxsize)
	  destbuf = (char *) crealloc_abort (destbuf,
					   maxsize += roundup2 (newlen, 2048));
	if (workingset)
	  for (unsigned i = 1; i <= wset_size; ++i)
d766 6
a771 3
	      DWORD_PTR addr = workingset[i] & 0xfffff000UL;
	      if ((char *)addr >= info.lpBaseOfDll
		  && (char *)addr < (char *)info.lpBaseOfDll + info.SizeOfImage)
d773 6
a778 4
		  access[0] = (workingset[i] & 0x5) ? 'r' : '-';
		  access[1] = (workingset[i] & 0x4) ? 'w' : '-';
		  access[2] = (workingset[i] & 0x2) ? 'x' : '-';
		  access[3] = (workingset[i] & 0x100) ? 's' : 'p';
d780 5
d786 2
a787 16
	int written = __small_sprintf (destbuf + len,
				"%08lx-%08lx %s %08lx %04x:%04x %U   ",
				info.lpBaseOfDll,
				(unsigned long)info.lpBaseOfDll
				+ info.SizeOfImage,
				access,
				info.EntryPoint,
				st.st_dev >> 16,
				st.st_dev & 0xffff,
				st.st_ino);
	while (written < 62)
	  destbuf[len + written++] = ' ';
	len += written;
	len += __small_sprintf (destbuf + len, "%s\n", posix_modname);
      }
out:
@


1.94
log
@* fhandler_proc.cc (format_proc_loadavg): Add running/total
processes as fourth component of output.
* fhandler_process.cc (get_process_state): Make non-static.
Add FIXME about generating an 'O' flag.
@
text
@d3 2
a4 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Red Hat, Inc.
d962 1
a962 13
	  if (wincap.has_process_io_counters ())
	    /*
	     * Windows 2000 and XP have an extra member in SYSTEM_PROCESSES
	     * which means the offset of the first SYSTEM_THREADS entry is
	     * different on these operating systems compared to NT 4.
	     */
	    st = &sp->Threads[0];
	  else
	    /*
	     * 136 is the offset of the first SYSTEM_THREADS entry on
	     * Windows NT 4.
	     */
	    st = (SYSTEM_THREADS *) ((char *) sp + 136);
@


1.93
log
@	* fhandler_process.cc (get_mem_values): Simplify code.  Fix
	NtQueryVirtualMemory loop so it handles memory allocation gracefully.
	Always set errno to a useful value.
@
text
@d82 1
a82 2

static int get_process_state (DWORD dwProcessId);
d930 1
a930 1
static int
d977 1
@


1.92
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procsys.o.
	* devices.h (enum fh_devices): Add FH_PROCSYS.
	* devices.in (dev_procsys_storage): New device.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add code to allocate fhandler_procsys.
	* fhandler.h (proc_len): Convert to size_t.
	(procsys): Declare.
	(procsys_len): Declare.
	(enum virtual_ftype_t): Move here from fhandler_virtual.h.
	Add members supported by fhandler_procsys.
	(fhandler_virtual::exists): Return virtual_ftype_t.  Change
	in all derived classes.
	(class fhandler_procsys): New class.
	(fhandler_union): Add fhandler_procnet and fhandler_procsys members.
	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Use
	ro_u_proc.
	(fhandler_base::fstat_by_handle): Don't copy attributes if file is an
	NT device.
	(fhandler_base::fstat_by_name): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::exists): Return
	virtual_ftype_t.
	* fhandler_proc.cc (proc_tab): Sort alphabetically.  Use _VN macro
	to store length.
	(proc_len): Change to size_t.
	(proc_tab_cmp): New static function.
	(virt_tab_search): New function to search entry in virt_tab_t
	arrays.  Use throughout in /proc and sibling classes instead of
	loop.
	(fhandler_proc::exists): Return virtual_ftype_t.
	* fhandler_process.cc (process_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_process::exists): Return virtual_ftype_t.
	(fhandler_process::open): Simplify code.
	* fhandler_procnet.cc (procnet_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_procnet::exists): Return virtual_ftype_t.
	(fhandler_procnet::open): Simplify.
	* fhandler_procsys.cc: New file.
	* fhandler_registry.cc (fhandler_registry::exists): Return
	virtual_ftype_t.
	* fhandler_virtual.cc (fhandler_virtual::exists): Ditto.
	* fhandler_virtual.h (enum virtual_ftype_t): Move to fhandler.h.
	(virt_tab_t): Add name_len member.
	(_VN): New macro.
	(virt_tab_search): Declare.
	* mount.cc (mount_info::conv_to_win32_path): Fix comment.  Backslashify
	isprocsys_dev paths.
	* ntdll.h (STATUS_OBJECT_TYPE_MISMATCH): Define
	(STATUS_INSTANCE_NOT_AVAILABLE): Define.
	(STATUS_PIPE_NOT_AVAILABLE): Define.
	(STATUS_INVALID_PIPE_STATE): Define.
	(STATUS_PIPE_BUSY): Define.
	(SYMBOLIC_LINK_QUERY): Define.
	(NtOpenSymbolicLinkObject): Declare.
	(NtQuerySymbolicLinkObject): Declare.
	* path.cc (path_conv::check): Accommodate fact that exists method
	returns virtual_ftype_t now.  Add cases for new virtual_ftype_t
	types.
	(cygwin_conv_path): Add GLOBALROOT prefix to native device paths.
	Make sure to strip \\?\ prefix only for actual filesystem-based
	paths, not for all paths.
	* path.h (isproc_dev): Add FH_PROCSYS.
	(isprocsys_dev): Define.
@
text
@d1002 1
a1002 1
  bool res = true;
d1007 2
a1008 2
  ULONG n = 0x1000, length;
  PULONG p = (PULONG) malloc (sizeof (ULONG) * n);
d1014 2
a1015 3
      DWORD error = GetLastError ();
      __seterrno_from_win_error (error);
      debug_printf ("OpenProcess: ret %d", error);
d1018 1
a1018 9
  while ((ret = NtQueryVirtualMemory (hProcess, 0,
				      MemoryWorkingSetList,
				      (PVOID) p,
				      n * sizeof *p, &length)),
	 (ret == STATUS_SUCCESS || ret == STATUS_INFO_LENGTH_MISMATCH) &&
	 length >= (n * sizeof (*p)))
      p = (PULONG) realloc (p, n *= (2 * sizeof (ULONG)));

  if (ret != STATUS_SUCCESS)
d1020 19
a1038 3
      debug_printf ("NtQueryVirtualMemory: ret %d, Dos(ret) %d",
		   ret, RtlNtStatusToDosError (ret));
      res = false;
d1046 2
a1047 1
      if ((flags & (WSLE_PAGE_EXECUTE | WSLE_PAGE_SHAREABLE)) == (WSLE_PAGE_EXECUTE | WSLE_PAGE_SHAREABLE))
d1058 1
a1058 1
  if (ret != STATUS_SUCCESS)
d1060 2
a1061 3
      debug_printf ("NtQueryInformationProcess: ret %d, Dos(ret) %d",
		    ret, RtlNtStatusToDosError (ret));
      res = false;
d1065 1
@


1.91
log
@* environ.cc (regopt): Change the first argument to wide char string.
(environ_init): Accommodate change to the first argument of regopt.
* exception.cc (open_stackdumpfile): Accommodate change to the type of progname
in _pinfo.
* external.cc (fillout_pinfo): Ditto.
* fhandler_process.cc (format_process_winexename): Ditto.
(format_process_stat): Ditto.
* fork.cc (fork::parent): Ditto.
* pinfo.cc (pinfo_basic::pinfo_basic): Call GetModuleFileNameW instead of
GetModuleFileName.
(pinfo::thisproc): Accommodate change to the type of progname in _pinfo.
(pinfo_init): Ditto.
* pinfo.h (_pinfo): Change the type of progname to a wide char array.
* registry.h (reg_key::get_int): Change the first argument from constant point
to pointer to constant.
(reg_key::get_string): Ditto.  Change the last argument likewise.
* registry.cc (reg_key::get_int): Accommodate change to the declaration.
(reg_key::get_string): Ditto.
* strace.cc (strace::hello): Accommodate change to the type of progname in
_pinfo.
(strace::vsprntf): Ditto.
@
text
@d56 22
a77 22
  { ".",          FH_PROCESS,   virt_directory, NULL },
  { "..",         FH_PROCESS,   virt_directory, NULL },
  { "ppid",       FH_PROCESS,   virt_file,      format_process_ppid },
  { "winpid",     FH_PROCESS,   virt_file,	format_process_winpid },
  { "winexename", FH_PROCESS,   virt_file,      format_process_winexename },
  { "status",     FH_PROCESS,   virt_file,      format_process_status },
  { "uid",        FH_PROCESS,   virt_file,      format_process_uid },
  { "gid",        FH_PROCESS,   virt_file,      format_process_gid },
  { "pgid",       FH_PROCESS,   virt_file,      format_process_pgid },
  { "sid",        FH_PROCESS,   virt_file,      format_process_sid },
  { "ctty",       FH_PROCESS,   virt_file,      format_process_ctty },
  { "stat",       FH_PROCESS,   virt_file,      format_process_stat },
  { "statm",      FH_PROCESS,   virt_file,      format_process_statm },
  { "cmdline",    FH_PROCESS,   virt_file,      format_process_cmdline },
  { "maps",       FH_PROCESS,   virt_file,      format_process_maps },
  { "fd",         FH_PROCESSFD, virt_directory, format_process_fd },
  { "exename",    FH_PROCESS,   virt_file,      format_process_exename },
  { "root",       FH_PROCESS,   virt_symlink,   format_process_root },
  { "exe",        FH_PROCESS,   virt_symlink,   format_process_exename },
  { "cwd",        FH_PROCESS,   virt_symlink,   format_process_cwd },
  { "mounts",     FH_PROCESS,   virt_file,      format_process_mounts },
  { NULL,         0,            virt_none,      NULL }
d93 1
a93 1
int
d102 1
a102 1
    return 2;
d104 3
a106 1
  for (int i = 0; process_tab[i].name; i++)
d108 1
a108 1
      if (!strcmp (path + 1, process_tab[i].name))
d110 2
a111 2
	  fileid = i;
	  return process_tab[i].type;
d113 1
a113 4
      if (process_tab[i].type == virt_directory
	  && !strncmp (path + 1, process_tab[i].name,
		       strlen (process_tab[i].name))
	  && path[1 + strlen (process_tab[i].name)] == '/')
d115 1
a115 1
	  fileid = i;
a233 2
  int process_file_no = -1;

d267 3
a269 2
  process_file_no = -1;
  for (int i = 0; process_tab[i].name; i++)
d271 3
a273 18
      if (path_prefix_p (process_tab[i].name, path + 1,
			 strlen (process_tab[i].name), false))
	process_file_no = i;
    }
  if (process_file_no == -1)
    {
      if (flags & O_CREAT)
	{
	  set_errno (EROFS);
	  res = 0;
	  goto out;
	}
      else
	{
	  set_errno (ENOENT);
	  res = 0;
	  goto out;
	}
d275 1
a275 1
  if (process_tab[process_file_no].fhandler == FH_PROCESSFD)
d287 1
a287 1
  fileid = process_file_no;
@


1.90
log
@* shared_info.h (open_shared): Create function wrapper for common use case.
(open_shared): Change fifth argument to a pointer rather than a reference.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Eliminate use of dummy
variable and call open_shared with constant.
* fhandler_process.cc (format_process_mounts): Ditto.
* pinfo.cc (pinfo::init): Pass pointer to shloc.
* shared.cc (shared_mem_inited): New variable.
(open_shared): Crate function wrapper for common use case.
(open_shared): Accommodate change to fifth argument to a pointer.
(shared_info::initialize): Remove spinlock test.  Simplify function.  Move
get_session_parent_dir call back here.
(memory_init): Protect global shared settings with shared_mem_inited spinlock.
Move get_session_parent_dir call to shared_info::initialize.
@
text
@d540 3
a542 3
  int len = strlen (p->progname);
  destbuf = (char *) crealloc_abort (destbuf, len + 2);
  strcpy (destbuf, p->progname);
d652 1
d663 3
a665 2
      char *last_slash = strrchr (p->progname, '\\');
      strcpy (cmd, last_slash ? last_slash + 1 : p->progname);
d784 1
d793 3
a795 2
      char *last_slash = strrchr (p->progname, '\\');
      strcpy (cmd, last_slash ? last_slash + 1 : p->progname);
@


1.89
log
@	* fhandler_proc.cc (proc_tab): Add entry for mounts symlink.
	(format_proc_mounts): New function to implement mounts symlink.
	* fhandler_process.cc (process_tab): Add entry for mounts file.
	(format_process_mounts): New function to implement mounts file.
@
text
@a899 1
      shared_locations sl = SH_JUSTOPEN;
d907 1
a907 1
					    sizeof (user_info), sl,
@


1.88
log
@	* fhandler_procnet.cc: Reorganize global procnet content data into a
	new struct virt_tab_t.  Accommodate throughout.

	* fhandler.h: Fix copyright dates.
	* fhandler_process.cc: Ditto.
	* fhandler_registry.cc: Ditto.
@
text
@d13 1
d26 1
d52 1
d76 1
d883 62
@


1.87
log
@	* devices.h (FH_PROCESSFD): New device type.
	* dtable.cc (build_fh_pc): Add case for FH_PROCESSFD.
	* fhandler.h (class fhandler_virtual): Drop bufalloc member.
	* fhandler_virtual.h: New header.
	* fhandler_proc.cc: Remove types proc_type_t and proc_tab_t in favor
	of types virt_type_t and virt_tab_t from fhandler_virtual.h.
	Change prototypes of format_XXX functions accordingly.
	(proc_tab): Drop size member info.
	(fhandler_proc::fill_filebuf): Don't allocate filebuf here.  Allocate
	it in the format_XXX functions.
	* fhandler_process.cc: Reorganize global process content data into a
	new struct virt_tab_t.  Accommodate throughout.
	(format_process_winexename): New function.
	(format_process_winpid): New function.
	(format_process_exename): New function.
	(format_process_root): New function.
	(format_process_cwd): New function.
	(format_process_cmdline): New function.
	(format_process_ppid): New function.
	(format_process_uid): New function.
	(format_process_pgid): New function.
	(format_process_sid): New function.
	(format_process_gid): New function.
	(format_process_ctty): New function.
	(format_process_fd): New function.
	* fhandler_procnet.cc (fhandler_procnet::fill_filebuf): Don't use
	bufalloc.
	* fhandler_registry.cc (fhandler_registry::fill_filebuf): Define
	bufalloc locally.
	* fhandler_virtual.cc (fhandler_virtual::fhandler_virtual): Drop
	initialization of bufalloc.
	(fhandler_virtual::dup): Drop copying bufalloc.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008 Red Hat, Inc.
@


1.86
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d18 1
d33 41
a73 47
static const int PROCESS_PPID = 2;
static const int PROCESS_WINPID = 3;
static const int PROCESS_WINEXENAME = 4;
static const int PROCESS_STATUS = 5;
static const int PROCESS_UID = 6;
static const int PROCESS_GID = 7;
static const int PROCESS_PGID = 8;
static const int PROCESS_SID = 9;
static const int PROCESS_CTTY = 10;
static const int PROCESS_STAT = 11;
static const int PROCESS_STATM = 12;
static const int PROCESS_CMDLINE = 13;
static const int PROCESS_MAPS = 14;
static const int PROCESS_FD = 15;
static const int PROCESS_EXENAME = 16;
/* Keep symlinks always the last entries. */
static const int PROCESS_ROOT = 17;
static const int PROCESS_EXE = 18;
static const int PROCESS_CWD = 19;

/* The position of "root" defines the beginning of symlik entries. */
#define is_symlink(nr) ((nr) >= PROCESS_ROOT)

static const char * const process_listing[] =
{
  ".",
  "..",
  "ppid",
  "winpid",
  "winexename",
  "status",
  "uid",
  "gid",
  "pgid",
  "sid",
  "ctty",
  "stat",
  "statm",
  "cmdline",
  "maps",
  "fd",
  "exename",
  /* Keep symlinks always the last entries. */
  "root",
  "exe",
  "cwd",
  NULL
d77 1
a77 1
  (sizeof (process_listing) / sizeof (const char *)) - 1;
a78 4
static _off64_t format_process_maps (_pinfo *p, char *&destbuf, size_t maxsize);
static _off64_t format_process_stat (_pinfo *p, char *destbuf, size_t maxsize);
static _off64_t format_process_status (_pinfo *p, char *destbuf, size_t maxsize);
static _off64_t format_process_statm (_pinfo *p, char *destbuf, size_t maxsize);
d100 1
a100 7
  for (int i = 0; process_listing[i]; i++)
    if (!strcmp (path + 1, process_listing[i]))
      {
	fileid = i;
	return is_symlink (i) ? -2 : (i == PROCESS_FD) ? 1 : -1;
      }
  if (!strncmp (strchr (path, '/') + 1, "fd/", 3))
d102 22
a123 11
      fileid = PROCESS_FD;
      if (fill_filebuf ())
	return -2;
      /* Check for nameless device entries. */
      path = strrchr (path, '/');
      if (path && *++path)
	{
	  if (!strncmp (path, "pipe:[", 6))
	    return -3;
	  else if (!strncmp (path, "socket:[", 8))
	    return -4;
d126 1
a126 1
  return 0;
d153 1
a153 1
    case 0:
d156 2
a157 2
    case 1:
    case 2:
d170 1
a170 1
    case -2:
d175 1
a175 1
    case -3:
d180 1
a180 1
    case -4:
d185 1
a185 1
    case -1:
d198 1
a198 1
  if (dir && fileid == PROCESS_FD)
d207 1
a207 1
  if (fileid == PROCESS_FD)
d214 1
a214 1
  if (fileid == PROCESS_FD && dir->__d_position > 1)
d220 1
a220 1
    strcpy (de->d_name, process_listing[dir->__d_position++]);
d267 1
a267 1
  for (int i = 0; process_listing[i]; i++)
d269 2
a270 2
      if (path_prefix_p (process_listing[i], path + 1,
			 strlen (process_listing[i]), false))
d288 1
a288 1
  if (process_file_no == PROCESS_FD)
d321 5
d342 167
a508 1
  switch (fileid)
d510 8
a517 157
    case PROCESS_FD:
      {
	size_t fs;
	char *fdp = strrchr (path, '/');
	if (!fdp || *++fdp == 'f') /* The "fd" directory itself. */
	  {
	    if (filebuf)
	      cfree (filebuf);
	    filebuf = p->fds (fs);
	  }
	else
	  {
	    if (filebuf)
	      cfree (filebuf);
	    int fd = atoi (fdp);
	    if (fd < 0 || (fd == 0 && !isdigit (*fdp)))
	      {
		set_errno (ENOENT);
		return false;
	      }
	    filebuf = p->fd (fd, fs);
	    if (!filebuf || !*filebuf)
	      {
		set_errno (ENOENT);
		return false;
	      }
	  }
	filesize = fs;
	break;
      }
    case PROCESS_UID:
    case PROCESS_GID:
    case PROCESS_PGID:
    case PROCESS_SID:
    case PROCESS_CTTY:
    case PROCESS_PPID:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 40);
	int num;
	switch (fileid)
	  {
	  case PROCESS_PPID:
	    num = p->ppid;
	    break;
	  case PROCESS_UID:
	    num = p->uid;
	    break;
	  case PROCESS_PGID:
	    num = p->pgid;
	    break;
	  case PROCESS_SID:
	    num = p->sid;
	    break;
	  case PROCESS_GID:
	    num = p->gid;
	    break;
	  case PROCESS_CTTY:
	    num = p->ctty;
	    break;
	  default: // what's this here for?
	    num = 0;
	    break;
	  }
	__small_sprintf (filebuf, "%d\n", num);
	filesize = strlen (filebuf);
	break;
      }
    case PROCESS_ROOT:
    case PROCESS_CWD:
    case PROCESS_CMDLINE:
      {
	if (filebuf)
	  {
	    cfree (filebuf);
	    filebuf = NULL;
	  }
	size_t fs;
	switch (fileid)
	  {
	  case PROCESS_ROOT:
	    filebuf = p->root (fs);
	    break;
	  case PROCESS_CWD:
	    filebuf = p->cwd (fs);
	    break;
	  case PROCESS_CMDLINE:
	    filebuf = p->cmdline (fs);
	    break;
	  }
	filesize = fs;
	if (!filebuf || !*filebuf)
	  {
	    filebuf = cstrdup ("<defunct>");
	    filesize = strlen (filebuf) + 1;
	  }
	break;
      }
    case PROCESS_EXENAME:
    case PROCESS_EXE:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = NT_MAX_PATH);
	if (p->process_state & PID_EXITED)
	  strcpy (filebuf, "<defunct>");
	else
	  {
	    mount_table->conv_to_posix_path (p->progname, filebuf, 1);
	    int len = strlen (filebuf);
	    if (len > 4)
	      {
		char *s = filebuf + len - 4;
		if (ascii_strcasematch (s, ".exe"))
		  *s = 0;
	      }
	  }
	filesize = strlen (filebuf);
	break;
      }
    case PROCESS_WINPID:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 40);
	__small_sprintf (filebuf, "%d\n", p->dwProcessId);
	filesize = strlen (filebuf);
	break;
      }
    case PROCESS_WINEXENAME:
      {
	int len = strlen (p->progname);
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = (len + 2));
	strcpy (filebuf, p->progname);
	filebuf[len] = '\n';
	filesize = len + 1;
	break;
      }
    case PROCESS_STATUS:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 2048);
	filesize = format_process_status (*p, filebuf, bufalloc);
	break;
      }
    case PROCESS_STAT:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 2048);
	filesize = format_process_stat (*p, filebuf, bufalloc);
	break;
      }
    case PROCESS_STATM:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 2048);
	filesize = format_process_statm (*p, filebuf, bufalloc);
	break;
      }
    case PROCESS_MAPS:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 2048);
	filesize = format_process_maps (*p, filebuf, bufalloc);
	break;
      }
d519 4
d524 17
a540 1
  return true;
d544 1
a544 1
format_process_maps (_pinfo *p, char *&destbuf, size_t maxsize)
d546 1
d563 1
d565 5
d606 4
a609 2
	if (len + strlen (posix_modname) + 62 > maxsize - 1)
	  destbuf = (char *) crealloc_abort (destbuf, maxsize += 2048);
d644 1
a644 1
format_process_stat (_pinfo *p, char *destbuf, size_t maxsize)
d646 1
d755 1
d774 1
a774 1
format_process_status (_pinfo *p, char *destbuf, size_t maxsize)
d776 1
d834 1
d866 1
a866 1
format_process_statm (_pinfo *p, char *destbuf, size_t maxsize)
d868 1
d874 1
@


1.85
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@d934 1
a934 1
      if (flags & (WSLE_PAGE_EXECUTE | WSLE_PAGE_SHAREABLE) == (WSLE_PAGE_EXECUTE | WSLE_PAGE_SHAREABLE))
@


1.84
log
@	* fhandler_disk_file.cc (fhandler_disk_file::readdir_helper): Simplify
	code which checks for symlinks.  Fix problem with UNC paths.

	* environ.cc (struct parse_thing): Remove transparent_exe option.
	* syscalls.cc (transparent_exe): Remove.
	(unlink): Always add stat_suffixes, drop transparent_exe check.
	(open): Ditto.
	(link): Ditto.
	(pathconf): Ditto.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Ditto.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Always remove
	.exe suffix.
	* path.cc (realpath): Never attach known_suffix.
@
text
@d110 1
a110 1
    if (pathmatch (path + 1, process_listing[i]))
d115 1
a115 1
  if (pathnmatch (strchr (path, '/') + 1, "fd/", 3))
d273 2
a274 2
      if (path_prefix_p
	  (process_listing[i], path + 1, strlen (process_listing[i])))
@


1.83
log
@Remove unneeded header files from source files throughout.
@
text
@d449 2
a450 3
	    /* If transparent_exe isn't set, the link keeps its suffix so that
	       an open(2) call will succeed on /proc/$PID/exe. */
	    if (transparent_exe)
d452 3
a454 7
		int len = strlen (filebuf);
		if (len > 4)
		  {
		    char *s = filebuf + len - 4;
		    if (ascii_strcasematch (s, ".exe"))
		      *s = 0;
		  }
@


1.82
log
@	* Fix copyright dates.
@
text
@a11 1
#include <unistd.h>
a13 1
#include <ntdef.h>
a25 2
#include <assert.h>
#include <sys/sysmacros.h>
@


1.81
log
@	* Makefile.in (DLL_OFILES): Add tls_pbuf.o.
	* autoload.cc (CreateDesktopW): Replace CreateDesktopA.
	(CreateWindowStationW): Replace CreateWindowStationA.
	(GetUserObjectInformationW): Replace GetUserObjectInformationA.
	* cygheap.h (cwdstuff::get): Assume default buffer size NT_MAX_PATH.
	* cygtls.cc (_cygtls::remove): Free temporary TLS path buffers.
	* cygtls.h (TP_NUM_C_BUFS): Define.
	(TP_NUM_W_BUFS): Define.
	(class tls_pathbuf): New class to store pointers to thread local
	temporary path buffers.
	(_local_storage::pathbufs): New member.
	* environ.cc (win_env::add_cache): Use temporary TLS path buffer instead
	of stack based buffer.
	(posify): Get temporary outenv buffer from calling function.
	(environ_init): Create temporary TLS path buffer for posify.
	(build_env): Create Windows environment block as WCHAR buffer.
	* environ.h (build_env): Change declaration accordingly.
	* external.cc (sync_winenv): Accommodate build_env change.
	* fhandler_console.cc (fhandler_console::need_invisible): Use
	GetUserObjectInformationW and CreateWindowStationW.
	* fhandler_process.cc (format_process_maps): Use temporary TLS path
	buffer instead of stack based buffer.
	* fork.cc (frok::parent): Convert to use CreateProcessW.
	* path.cc: Throughout use temporary TLS path buffers instead of stack
	based buffer.  Replace checks for CYG_MAX_PATH by checks for
	NT_MAX_PATH.
	(getfileattr): New function to replace GetFileAttributesA.
	(normalize_win32_path): Remove Win32 and NT long path prefixes.
	(getwd): Assume PATH_MAX + 1 buffer per SUSv3.
	* path.h (class path_conv): Set path buffer to size NT_MAX_PATH.
	(iswdrive): Define.
	* pinfo.cc (commune_process): Use temporary TLS path buffer instead of
	stack based buffer.
	* registry.cc (get_registry_hive_path): Ditto.
	(load_registry_hive): Ditto.
	* spawn.cc (spawn_guts): Convert to use CreateProcessW and
	CreateProcessAsUserW.
	(av::fixup): Open/close file using NtOpenFile/NtClose.
	* syscalls.cc (mknod_worker): Allow PATH_MAX file name.
	(mknod32): Ditto.
	(getusershell): Ditto.
	* tls_pbuf.cc: New file implementing tls_pathbuf and tmp_pathbuf
	methods.
	* tls_pbuf.h: New header for files using tmp_pathbuf.
	* tlsoffsets.h: Regenerate.
	* winsup.h (NT_MAX_PATH): Define as 32767 to avoid USHORT overflow.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007 Red Hat, Inc.
@


1.80
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d26 1
d529 4
a532 2
  WCHAR modname[NT_MAX_PATH];
  char posix_modname[NT_MAX_PATH];
d558 1
a558 1
	&& GetModuleFileNameExW (proc, modules[i], modname, sizeof modname))
@


1.79
log
@	* cygheap.cc (cwcsdup): New function.
	(cwcsdup1): New function.
	* cygheap.h (cygheap_user::get_windows_id): New method returning PWCHAR.
	(cwcsdup): Declare.
	(cwcsdup1): Declare.
	* registry.cc (get_registry_hive_path): Use WCHAR instead of char
	throughout.
	(load_registry_hive): Ditto.
	* registry.h (get_registry_hive_path): Change declaration accordingly.
	(load_registry_hive): Ditto.
	* sec_helper.cc (cygpsid::string): New method returning PWCHAR.
	* security.h (cygpsid::string): Declare.
	* syscalls.cc (seteuid32): Convert local name var to WCHAR.
	* uinfo.cc (cygheap_user::env_userprofile): Convert local name buffers
	to WCHAR.  Call sys_wcstombs_alloc to generate puserprof buffer.

	* winsup.h: Fix comment.
	(NT_MAX_PATH): New definition for maximum internal path length.
	Use throughout where appropriate.
	* include/limits.h (PATH_MAX): Set to 4096 as on Linux.
@
text
@d25 1
d816 1
a816 1
			  0, 0, p->getsigmask ()
@


1.78
log
@	* string.h: Re-enable inline strcasematch and strncasematch
	implementations and rename to ascii_strcasematch/ascii_strncasematch.
	* dcrt0.cc: Replace str[n]casematch with ascii_str[n]casematch where
	applicable.
	* environ.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* hookapi.cc: Ditto.
	* path.cc: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* uinfo.cc: Ditto.
	* winf.cc: Ditto.
@
text
@d445 1
a445 1
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = PATH_MAX);
d527 2
a528 2
  WCHAR modname[PATH_MAX];
  char posix_modname[PATH_MAX];
d560 1
a560 1
	  sys_wcstombs (posix_modname, PATH_MAX, modname);
@


1.77
log
@	* dcrt0.cc (initial_env): Use PATH_MAX instead of CYG_MAX_PATH for path
	name buffer size.
	(dll_crt0_1): Allocate new_argv0 with PATH_MAX size.
	* exceptions.cc (debugger_command): Set size to 2 * PATH_MAX + 20;
	(error_start_init): Use PATH_MAX instead of CYG_MAX_PATH for path
	name buffer size.
	* external.cc (fillout_pinfo): Always fill out ep.progname 0-terminated.
	Fill out ep.progname_long.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Allocate
	buffer for executable filename with PATH_MAX size.
	* pinfo.cc: Throughout use PATH_MAX instead of CYG_MAX_PATH.
	* pinfo.h (class _pinfo): Set progname size to PATH_MAX.
	* smallprint.cc: Include limits.h.  Use PATH_MAX instead of CYG_MAX_PATH
	for path name buffer size.
	* strace.cc (strace::vsprntf): Ditto.
	* include/sys/cygwin.h (EXTERNAL_PINFO_VERSION_32_LP): Define.
	(EXTERNAL_PINFO_VERSION): Set to EXTERNAL_PINFO_VERSION_32_LP.
	(struct external_pinfo): Add progname_long member.
	* include/sys/dirent.h: Correctly include limits.h instead of
	sys/limits.h.
@
text
@d459 1
a459 1
		    if (strcasematch (s, ".exe"))
d621 1
a621 1
	  if (strcasematch (s, ".exe"))
d747 1
a747 1
	  if (strcasematch (s, ".exe"))
@


1.76
log
@	* autoload.cc (GetModuleFileNameExW): Replace definition of
	GetModuleFileNameExA.
	* fhandler_process.cc (format_process_maps): Change modname type to
	WCHAR.  Set buffer sizes to PATH_MAX.  Call GetModuleFileNameExW
	instead of GetModuleFileNameExA.  Call mount_info::conv_to_posix_path
	instead of cygwin_conv_to_full_posix_path.  Set posix_modname to
	modname if that call fails.
	(format_process_stat): Set cmd buffer size to NAME_MAX + 1.  Simplify
	setting cmd to process name.
	(format_process_status): Ditto.
	* path.cc (mount_info::conv_to_posix_path): Call sys_wcstombs
	correctly.
@
text
@d445 1
a445 1
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = CYG_MAX_PATH);
@


1.75
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d527 2
a528 2
  char modname[CYG_MAX_PATH];
  char posix_modname[CYG_MAX_PATH];
d554 1
a554 1
	&& GetModuleFileNameEx (proc, modules[i], modname, sizeof modname))
d559 2
a560 1
	cygwin_conv_to_full_posix_path (modname, posix_modname);
d604 1
a604 1
  char cmd[CYG_MAX_PATH];
d615 2
a616 4
      strcpy (cmd, p->progname);
      char *last_slash = strrchr (cmd, '\\');
      if (last_slash != NULL)
	strcpy (cmd, last_slash + 1);
d732 1
a732 1
  char cmd[CYG_MAX_PATH];
d741 2
a742 4
      strcpy (cmd, p->progname);
      char *last_slash = strrchr (cmd, '\\');
      if (last_slash != NULL)
	strcpy (cmd, last_slash + 1);
@


1.74
log
@	* cygwin.din: Export fdopendir.
	* dir.cc (opendir): Call fhandler's opendir with fd set to -1.
	(fdopendir): New function.
	(seekdir64): Use dirent_info_mask.
	(rewinddir): Ditto.
	(closedir): Only release underlying file descriptor if it has been
	reserved by opendir itself.
	* fhandler.cc (fhandler_base::opendir): Accommodate new parameter.
	* fhandler.h (dirent_states): Add dirent_valid_fd and dirent_info_mask.
	(fhander_XXX::opendir): Add file descriptor parameter.  Use regparms.
	(fhandler_procnet::opendir): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Ditto.
	If called from fdopendir, use existing handle to re-open directory
	with valid flags.  Rename fd to cfd.  Use only if no valid incoming fd.
	(fhandler_cygdrive::opendir): Accommodate new parameter.
	* fhandler_process.cc (fhandler_process::opendir): Ditto.
	* fhandler_procnet.cc (fhandler_procnet::opendir): Drop definition.
	* fhandler_virtual.cc (fhandler_virtual::opendir): Accommodate new
	parameter.  Only create new file descriptor entry if called from
	opendir.  Remove duplicated setting of dir->__flags.
	* posix.sgml: Add fdopendir to list of implemented Solaris functions.
	* include/cygwin/version.h: Bump API minor number.
	* include/sys/dirent.h: Declare fdopendir.
@
text
@d382 1
a382 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 40);
d445 1
a445 1
	filebuf = (char *) crealloc (filebuf, bufalloc = CYG_MAX_PATH);
d469 1
a469 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 40);
d477 1
a477 1
	filebuf = (char *) crealloc (filebuf, bufalloc = (len + 2));
d485 1
a485 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 2048);
d491 1
a491 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 2048);
d497 1
a497 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 2048);
d503 1
a503 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 2048);
d566 1
a566 1
	  destbuf = (char *) crealloc (destbuf, maxsize += 2048);
@


1.73
log
@	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Set new stat member
	st_birthtim to useful value.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Take
	additional parameter for creation time.  Fill st_birthtim with it.
	Accomodate additional creation time parameter throughout.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Set new stat member
	st_birthtim to useful value.
	* fhandler.cc (fhandler_base::fstat): Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Ditto.
	* include/cygwin/version.h: Bump API minor number.
	* include/cygwin/stat.h (struct __stat64): Replace st_spare4 with
	timestruc_t st_birthtim.
	(struct stat): Ditto if __CYGWIN_USE_BIG_TYPES__ is defined.
	(st_birthtime): Define if __CYGWIN_USE_BIG_TYPES__ is defined.
@
text
@d201 1
a201 1
fhandler_process::opendir ()
d203 3
a205 7
  DIR *dir = fhandler_virtual::opendir ();
  if (dir)
    {
      if (fileid == PROCESS_FD)
	fill_filebuf ();
      dir->__flags = 0;
    }
@


1.72
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@d164 3
a166 2
      buf->st_ctime = buf->st_mtime = p->start_time;
      buf->st_ctim.tv_nsec = buf->st_mtim.tv_nsec = 0;
@


1.71
log
@* fhandler_process.cc (format_process_stat): Use cygwin-derived start time even
on NT since it is the logical start time of the "process".
* pinfo.cc (set_myself): Don't set start time when it should have already been
set previously.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006 Red Hat, Inc.
a517 3
  if (!wincap.is_winnt ())
    return 0;

d637 1
a637 1
  else if (wincap.is_winnt ())
d640 22
a661 42
  if (wincap.is_winnt ())
    {
      NTSTATUS ret;
      HANDLE hProcess;
      VM_COUNTERS vmc;
      KERNEL_USER_TIMES put;
      PROCESS_BASIC_INFORMATION pbi;
      QUOTA_LIMITS ql;
      SYSTEM_TIME_OF_DAY_INFORMATION stodi;
      SYSTEM_PROCESSOR_TIMES spt;
      hProcess = OpenProcess (PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
			      FALSE, p->dwProcessId);
      if (hProcess != NULL)
	{
	  ret = NtQueryInformationProcess (hProcess,
					   ProcessVmCounters,
					   (PVOID) &vmc,
					   sizeof vmc, NULL);
	  if (ret == STATUS_SUCCESS)
	    ret = NtQueryInformationProcess (hProcess,
					     ProcessTimes,
					     (PVOID) &put,
					     sizeof put, NULL);
	  if (ret == STATUS_SUCCESS)
	    ret = NtQueryInformationProcess (hProcess,
					     ProcessBasicInformation,
					     (PVOID) &pbi,
					     sizeof pbi, NULL);
	  if (ret == STATUS_SUCCESS)
	    ret = NtQueryInformationProcess (hProcess,
					     ProcessQuotaLimits,
					     (PVOID) &ql,
					     sizeof ql, NULL);
	  CloseHandle (hProcess);
	}
      else
	{
	  DWORD error = GetLastError ();
	  __seterrno_from_win_error (error);
	  debug_printf ("OpenProcess: ret %d", error);
	  return 0;
	}
d663 4
a666 3
	ret = NtQuerySystemInformation (SystemTimeOfDayInformation,
					(PVOID) &stodi,
					sizeof stodi, NULL);
d668 30
a697 12
	ret = NtQuerySystemInformation (SystemProcessorTimes,
					(PVOID) &spt,
					sizeof spt, NULL);
      if (ret != STATUS_SUCCESS)
	{
	  __seterrno_from_nt_status (ret);
	  debug_printf ("NtQueryInformationProcess: ret %d, Dos(ret) %E", ret);
	  return 0;
	}
      fault_count = vmc.PageFaultCount;
      utime = put.UserTime.QuadPart * HZ / 10000000ULL;
      stime = put.KernelTime.QuadPart * HZ / 10000000ULL;
d699 10
a708 10
       if (stodi.CurrentTime.QuadPart > put.CreateTime.QuadPart)
	 start_time = (spt.KernelTime.QuadPart + spt.UserTime.QuadPart -
		       stodi.CurrentTime.QuadPart + put.CreateTime.QuadPart) * HZ / 10000000ULL;
       else
	 /*
	  * sometimes stodi.CurrentTime is a bit behind
	  * Note: some older versions of procps are broken and can't cope
	  * with process start times > time(NULL).
	  */
	 start_time = (spt.KernelTme.QuadPart + spt.UserTime.QuadPart) * HZ / 10000000ULL;
d710 5
a714 6
      priority = pbi.BasePriority;
      unsigned page_size = getsystempagesize ();
      vmsize = vmc.PagefileUsage;
      vmrss = vmc.WorkingSetSize / page_size;
      vmmaxrss = ql.MaximumWorkingSetSize / page_size;
    }
d765 1
a765 1
  else if (wincap.is_winnt ())
d786 6
a791 8
  if (wincap.is_winnt ())
    {
      if (!get_mem_values (p->dwProcessId, &vmsize, &vmrss, &vmtext, &vmdata, &vmlib, &vmshare))
	return 0;
      unsigned page_size = getsystempagesize ();
      vmsize *= page_size; vmrss *= page_size; vmdata *= page_size;
      vmtext *= page_size; vmlib *= page_size;
    }
d819 2
a820 1
			  vmsize >> 10, 0, vmrss >> 10, vmdata >> 10, 0, vmtext >> 10, vmlib >> 10,
d830 3
a832 6
  if (wincap.is_winnt ())
    {
      if (!get_mem_values (p->dwProcessId, &vmsize, &vmrss, &vmtext, &vmdata,
			   &vmlib, &vmshare))
	return 0;
    }
d834 1
a834 2
			  vmsize, vmrss, vmshare, vmtext, vmlib, vmdata, 0
			  );
@


1.71.4.1
log
@	* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and
	use either main sigmask or current thread sigmask.
	(set_process_mask): Ditto.
	(sighold): Ditto.
	(sigrelse): Ditto.
	(sigset): Ditto.
	(set_process_mask_delta): Ditto.
	(_cygtls::call_signal_handler): Ditto.
	* fhandler_process.cc (format_process_status): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* pinfo.h (class pinfo): Ditto.
	* select.cc (pselect): Ditto.
	* signal.cc (sigprocmask): Ditto.
	(abort): Ditto.
	(sigpause): Ditto.
	(sigsend): Ditto.
	(wait_sig): Ditto.
	* sigproc.cc (sig_send): Ditto.
	(pending_signals::add): Ditto.
	(wait_sig): Ditto.
	* thread.h (pthread::parent_tls): New member.
	* thread.cc (pthread::pthread): Record parent_tls here.
	(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@a22 1
#include "cygtls.h"
d827 1
a827 1
			  0, 0, _my_tls.sigmask
@


1.70
log
@	* environ.cc (struct parse_thing): Add transparent_exe option.
	* fhandler_disk_file.cc (fhandler_disk_file::link): Accomodate
	transparent_exe option.  Add .exe suffix for links to executable files,
	if transparent_exe is set.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Remove .exe
	suffix if transparent_exe option is set.
	* path.cc (symlink_worker): Accomodate transparent_exe option.
	(realpath): Don't tack on .exe suffix if transparent_exe is set.
	* syscalls.cc (transparent_exe): New global variable.
	(unlink): Accomodate transparent_exe option.
	(open): Ditto.
	(link): Ditto.
	(rename): Ditto. Maybe add .exe suffix when renaming executable files.
	(pathconf): Accomodate transparent_exe option.
	* winsup.h: Declare transparent_exe.
@
text
@d642 2
a643 3
  if (!wincap.is_winnt ())
    start_time = (GetTickCount () / 1000 - time (NULL) + p->start_time) * HZ;
  else
a701 1
      start_time = (put.CreateTime.QuadPart - stodi.BootTime.QuadPart) * HZ / 10000000ULL;
@


1.69
log
@	* autoload.cc (NtQueryDirectoryFile): Define.
	* dir.cc (__opendir_with_d_ino): Just call opendir.
	(opendir): Remove CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO handling.
	(readdir_worker): Only try generating d_ino if it's 0.
	Utilize namehash of directories fhandler.  Call readdir_get_ino to
	generate d_ino for "..".
	(seekdir64): Keep dirent_set_d_ino flag.
	* fhandler.h (enum dirent_states): Add dirent_get_d_ino.
	(class fhandler_disk_file): Declare new private methods readdir_helper
	and readdir_9x.
	* fhandler_disk_file.cc (path_conv::hasgood_inode): New method to
	evaluate if a filesystem has reliable inode numbers.
	(fhandler_base::fstat_by_handle): Accomodate structure member name
	change from IndexNumber to FileId.
	(fhandler_base::fstat_helper): Call hasgood_inode here.
	(fhandler_disk_file::opendir): Call fhaccess only for real files.
	Don't append '*' to __d_dirname here, move to readdir_9x.  On NT,
	open directory handle here.  Set dirent_get_d_ino and dirent_set_d_ino
	flags according to wincap and filesystem.
	(fhandler_disk_file::readdir_helper): New method to implement readdir
	postprocessing only once.
	(readdir_get_ino_by_handle): New static function.
	(readdir_get_ino): New function to centralize inode number evaluation
	in case inode number hasn't been returned by NtQueryDirectoryFile.
	(fhandler_disk_file::readdir): Move old functionality to readdir_9x.
	Call readdir_9x when on 9x/Me.  Implement NT specific readdir here.
	(fhandler_disk_file::readdir_9x): Move 9x specific readdir here.
	(fhandler_disk_file::seekdir): Accomodate new NT readdir method.
	(fhandler_disk_file::closedir): Ditto.
	(fhandler_cygdrive::fstat): Set d_ino to namehash. Add comment.
	(fhandler_cygdrive::opendir): Call get_namehash to prepare later
	correct evaluation of d_ino.
	(fhandler_cygdrive::readdir): Replace recursion with loop. Evaluate
	drive's d_ino by calling readdir_get_ino.
	* fhandler_proc.cc (fhandler_proc::readdir): Set dirent_saw_dot and
	dirent_saw_dot_dot to avoid seeing . and .. entries twice.
	* fhandler_process.cc (fhandler_process::readdir): Ditto.
	* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
	* ntdll.h (STATUS_INVALID_PARAMETER): New define.
	(STATUS_INVALID_LEVEL): New define.
	(struct _FILE_INTERNAL_INFORMATION): Rename member IndexNumber to
	FileId (as in Nebbitt).
	* path.h (path_conv::hasgood_inode): Now implemented in
	fhandler_disk_file.cc.
	* wincap.h (wincaps::has_fileid_dirinfo): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (readdir_get_ino): Add declaration.
	* include/sys/dirent.h (struct dirent): Slightly rename structure
	members to accomodate changes.
	Remove __USE_EXPENSIVE_CYGWIN_D_INO handling and declaration of
	__opendir_with_d_ino.
@
text
@d454 3
a456 7
#if 0
	    /* Temporarily disabled.  The link will have a suffix so that
	       an open(2) call will succeed on /proc/$PID/exe now.  This
	       might become unnecessary if open(2) handles the .exe suffix
	       at one point. */
	    int len = strlen (filebuf);
	    if (len > 4)
d458 7
a464 3
		char *s = filebuf + len - 4;
		if (strcasematch (s, ".exe"))
		  *s = 0;
a465 1
#endif
@


1.68
log
@	* fhandler_process.cc (fhandler_process::fill_filebuf): Disable
	stripping the .exe suffix from the link target in PROCESS_EXE and
	PROCESS_EXENAME case.
	* path.cc (realpath): Tack on .exe suffix if necessary.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005 Red Hat, Inc.
d230 1
@


1.67
log
@* fhandler_process.cc (fhandler_process::readdir): Add missing argument to
syscall_printf.
* fhandler_console.cc (fhandler_console::need_invisible): Use made-up name for
windows station rather than asking Windows to create one for us.
* spawn.cc (spawn_guts): Don't mess with console if we're detaching.
@
text
@d453 5
d465 1
@


1.66
log
@	* autoload.cc (NtCreateSection): Define.
	* cygheap.cc (_csbrk): Call getpagesize instead of getshmlba.
	* dcrt0.cc (dll_crt0_0): Call mmap_init.
	* external.cc (cygwin_internal): Call getpagesize instead of getshmlba.
	* fhandler.h (fhandler_base::mmap): Change access to prot parameter.
	(fhandler_base::fixup_mmap_after_fork): Ditto.
	(fhandler_disk_file::mmap): Ditto.
	(fhandler_disk_file::fixup_mmap_after_fork): Ditto.
	(fhandler_dev_mem::mmap): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::write): Call getsystempagesize
	instead of getpagesize.
	(fhandler_dev_mem::read): Ditto.
	(fhandler_dev_mem::fstat): Ditto.
	(fhandler_dev_mem::mmap): Move to mmap.cc.
	(fhandler_dev_mem::munmap): Ditto.
	(fhandler_dev_mem::msync): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.
	* fhandler_proc.cc (format_proc_meminfo): Call getsystempagesize
	instead of getpagesize.
	* fhandler_process.cc (format_process_stat): Ditto.
	(format_process_status): Ditto.
	(get_mem_values): Ditto.
	* mmap.cc: Fix formatting.  Try to make more readable and modular.
	Take advantage of pagesize==granularity.
	(gen_protect): New static function to evaluate Windows
	protection bits from POSIX protection and flags.
	(gen_access): Ditto for Windows access mode.
	(VirtualProt9x): Wrapper function to call VirtualProtect on 9x.
	(VirtualProtNT): Ditto for NT.
	(VirtualProtEx9x): Ditto for VirtualProtectEx on 9x.
	(VirtualProtExNT): Ditto for NT.
	(CreateMapping9x): Wrapper function for creating a mapping handle on 9x.
	(CreateMappingNT): Ditto for NT.
	(MapView9x): Wrapper function to map a view on 9x.
	(MapViewNT): Ditto for NT.
	(mmap_funcs_9x): Structure containing function pointers to wrapper
	functions for 9x.
	(mmap_funcs_nt): Ditto for NT.
	(mmap_func): Pointer to wrapper functions used in subsequent code.
	(mmap_init): Initialize mmap_func depending on OS.
	(class mmap_record): Use sensible member names.  Add POSIX protection
	member. Drop Windows access flags member.  Constify more methods.
	Use accessors instead of direct member access inside of own methods.
	(mmap_record::gen_protect): Class wrapper to evaluate matching
	Windows protection bits.
	(mmap_record::gen_access): Ditto for Windows access flags.
	(mmap_record::compatible_flags): New function to check if flags are
	compatible with flags of existing map.
	(list::add_record): Drop offset and length arguments.
	(class map): Change counters to unsigned.  Match usage throughout.
	(mmapped_areas): Convert from pointer to global struct.
	(mmap_record::alloc_page_map): Simplify.
	(mmap_record::map_pages): Ditto.
	(mmap_record::fixup_page_map): Delete.
	(mmap64): Simplify.  Add workaround for Windows 98 bug.  Fix bug on
	NT that existing anonymous mappings weren't searched for a match.
	(munmap): Add workaround for Windows 98 bug.
	(msync): Simplify.
	(mprotect): Handle existing maps correctly.
	(mlock): Add local pagesize variable and enlightening comment.
	(fhandler_disk_file::mmap): Main functionality now in CreateMapping/
	MapView wrapper functions.
	(fhandler_disk_file::fixup_mmap_after_fork): Call MapView wrapper.
	(fhandler_dev_mem::mmap): Moved from fhandler_mem.cc.  Simplify by
	calling MapViewNT.
	(fhandler_dev_mem::munmap): Moved from fhandler_mem.cc.
	(fhandler_dev_mem::msync): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.  Call MapViewNT.
	(fixup_mmaps_after_fork): Restructure and hopefully speed up loop for
	setting protection and memory content on MAP_PRIVATE maps.
	* ntdll.h (AT_ROUND_TO_PAGE): Remove define.
	(AT_EXTENDABLE_FILE): Add define.
	(NtCreateSection): Add prototype.
	* syscalls.cc (getpagesize): Return granularity as pagesize now.
	(getsystempagesize): New function to retrieve "real" pagesize.
	(getshmlba): Delete since it's replaced by getpagesize now.
	* wincap.h (wincaps::has_mmap_alignment_bug): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (getshmlba): Drop prototype.
	(getsystempagesize): Add prototype.
	(mmap_init): Ditto.
	* include/sys/mman.h: (Not yet) define MAP_NORESERVE.
@
text
@d232 1
a232 1
  syscall_printf ("%d = readdir (%p, %p) (%s)", dir, de, de->d_name);
@


1.65
log
@* cygheap.h (cygheap_types): Add HEAP_COMMUNE.
* fhandler_proc.cc: Use cygheap rather than user heap for allocation of filebuf
throughout.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_process.cc: Ditto.
(get_mem_values): Use malloc/realloc/free rather than new.
* pinfo.cc (_pinfo::commune_send): Allocate on cygwin heap rather than user
heap.  Avoid calling ReadFile when correct number of characters have been read
or suffer buffer corruption.
(_pinfo::fd): Allocate on cygwin heap rather than user heap.
(_pinfo::fds): Ditto.
(_pinfo::root): Ditto.
(_pinfo::cwd): Ditto.
(_pinfo::cmdline): Ditto.
* devices.h (FH_DEV): New define.
* devices.in: Detect lone /dev.
* devices.cc: Regenerate.
* path.cc (path_conv::check): Treat FH_DEV as a special case.
@
text
@d711 1
a711 1
      unsigned page_size = getpagesize ();
d791 1
a791 1
      unsigned page_size = getpagesize ();
d921 1
a921 1
  unsigned page_size = getpagesize ();
@


1.64
log
@* cygerrno.h (geterrno_from_win_error): Change declaration to default to using
GetLastError and EACCESS.
* cygwin.din: Export readdir_r.
* include/cygwin/version.h: Bump API version number to 138.
* syscalls.cc (readdir_worker): New function, renamed from old readdir()
function.
(readdir): Use readdir_worker.
(readdir_r): New function.
* fhandler.h (fhandler_base::readdir): Accommodate second argument indicating
dirent buffer.
(fhandler_disk_file::readdir): Ditto.
(fhandler_cygdrive::readdir): Ditto.
(fhandler_proc::readdir): Ditto.
(fhandler_netdrive::readdir): Ditto.
(fhandler_registry::readdir): Ditto.
(fhandler_process::readdir): Ditto.
* fhandler.cc (fhandler_base::readdir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Ditto.
* fhandler_cygdrive.cc (fhandler_cygdrive::readdir): Ditto.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_netdrive.cc (fhandler_netdrive::readdir): Ditto.
* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
* fhandler_process.cc (fhandler_process::readdir): Ditto.
@
text
@d354 1
a354 1
	      free (filebuf);
d360 1
a360 1
	      free (filebuf);
d384 1
a384 1
	filebuf = (char *) realloc (filebuf, bufalloc = 40);
d419 4
a422 1
	  free (filebuf);
d439 1
a439 1
	    filebuf = strdup ("<defunct>");
d447 1
a447 1
	filebuf = (char *) realloc (filebuf, bufalloc = CYG_MAX_PATH);
d466 1
a466 1
	filebuf = (char *) realloc (filebuf, bufalloc = 40);
d474 1
a474 1
	filebuf = (char *) realloc (filebuf, bufalloc = (len + 2));
d482 1
a482 1
	filebuf = (char *) realloc (filebuf, bufalloc = 2048);
d488 1
a488 1
	filebuf = (char *) realloc (filebuf, bufalloc = 2048);
d494 1
a494 1
	filebuf = (char *) realloc (filebuf, bufalloc = 2048);
d500 1
a500 1
	filebuf = (char *) realloc (filebuf, bufalloc = 2048);
d566 1
a566 1
	  destbuf = (char *) realloc (destbuf, maxsize += 2048);
d920 1
a920 1
  PULONG p = new ULONG[n];
d936 3
a938 2
	 length >= n * sizeof *p)
    delete [] p, p = new ULONG[n *= 2];
d952 1
a952 1
	  ++*vmlib;
d954 1
a954 1
	  ++*vmshare;
d956 1
a956 1
	  ++*vmtext;
d958 1
a958 1
	  ++*vmdata;
d960 1
a960 3
  ret = NtQueryInformationProcess (hProcess,
				   ProcessVmCounters,
				   (PVOID) &vmc,
d971 1
a971 1
  delete [] p;
@


1.63
log
@* fhandler.h (dirent_states): Add dirent_isroot, dirent_saw_cygdrive,
dirent_saw_dev.
* dir.cc (opendir): Don't zero __flags here.  Push that responsibility to
opendir methods.
(seekdir): Preserve dirent_isrrot in __flags.
(rewinddir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::opendir): Set dirent_isroot
appropriately.
(fhandler_disk_file::readdir): Fill in "cygdrive" and "dev" if it is the root
dir and they are missing.
* fhandler_process.cc (fhandler_process::opendir): Set __flags here.
* fhandler_virtual.cc (fhandler_virtual::opendir): Set __flags here.
@
text
@d212 2
a213 2
struct dirent *
fhandler_process::readdir (DIR * dir)
d215 1
d219 1
a219 1
	return NULL;
d222 1
a222 1
    return NULL;
d226 1
a226 3
      __small_sprintf (dir->__d_dirent->d_name, "%d", p[dir->__d_position++ - 2]);
      syscall_printf ("%p = readdir (%p) (%s)", &dir->__d_dirent, dir,
		      dir->__d_dirent->d_name);
d229 5
a233 6
    {
      strcpy (dir->__d_dirent->d_name, process_listing[dir->__d_position++]);
      syscall_printf ("%p = readdir (%p) (%s)", &dir->__d_dirent, dir,
		      dir->__d_dirent->d_name);
    }
  return dir->__d_dirent;
@


1.62
log
@	* fhandler_process.cc (fhandler_process::open): Allow opening of
	/proc/<pid>/fd for reading.
	* fhandler_registry.cc (fhandler_registry::open): Ditto for registry
	keys.
@
text
@d203 6
a208 2
  if (dir && fileid == PROCESS_FD)
    fill_filebuf ();
@


1.61
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d296 2
a297 3
      set_errno (EISDIR);
      res = 0;
      goto out;
@


1.60
log
@white space and minor comment cleanup.
@
text
@d145 1
a145 1
  (void) fhandler_base::fstat (buf);
@


1.59
log
@	* cygerrno.h (__seterrno_from_nt_status): Define. Always set Win32
	error code as well as errno. Use throughout where errno is set from
	NT status.
	(set_errno): Evaluate val only once.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Fix typo in
	debug output.
	* fhandler_mem.cc (fhandler_dev_mem::open): Rely on
	__seterrno_from_nt_status setting Win32 error code in debug output.
	* fhandler_proc.cc (format_proc_uptime): Ditto.
	(format_proc_stat): Ditto.
	* fhandler_process.cc (format_process_stat): Ditto.
	* sysconf.cc (sysconf): Ditto.
@
text
@d121 1
a121 1
        return -2;
d125 1
a125 1
        {
d214 1
a214 1
        return NULL;
d417 1
a417 1
        if (filebuf)
@


1.58
log
@	Unify usage of CYG_MAX_PATH throughout.  Change buffers from
	size CYG_MAX_PATH + 1 to CYG_MAX_PATH.  Change length tests
	accordingly.
@
text
@d686 2
a687 3
	  __seterrno_from_win_error (RtlNtStatusToDosError (ret));
	  debug_printf ("NtQueryInformationProcess: ret %d, Dos(ret) %d",
		       ret, RtlNtStatusToDosError (ret));
@


1.57
log
@	* fhandler_process.cc: Re-add exename.
@
text
@d523 2
a524 2
  char modname[CYG_MAX_PATH + 1];
  char posix_modname[CYG_MAX_PATH + 1];
@


1.56
log
@white space
@
text
@d48 1
d50 3
a52 3
static const int PROCESS_ROOT = 16;
static const int PROCESS_EXE = 17;
static const int PROCESS_CWD = 18;
d75 1
d440 1
@


1.55
log
@	* fhandler.cc (fhandler_base::get_proc_fd_name): Don't generate
	"device:" entry.
	* fhandler.h (fhandler_socket::open): New method.
	(fhandler_pipe::open): New method.
	* fhandler_proc.cc (fhandler_proc::exists): Return -2 in case of
	/proc/self.
	* fhandler_process.cc (fhandler_process::exists): Return -2 in
	case of symlinks, -3 for pipes and -4 for sockets.
	(fhandler_process::fstat): Handle pipes and sockets.
	(fhandler_process::open): Handle opening /proc/<pid>/fd.
	(fhandler_process::fill_filebuf): Generate empty names for
	non exisiting file descriptors.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Always
	generate "socket:[number]" strings as on Linux.
	(fhandler_socket::open): New method.
	(fhandler_socket::fstat): Always return socket type.
	* path.cc (symlink_info::set): Remove unused second parameter.
	(path_conv::check): Handle pipes and sockets in /proc.
	Set correct device type for AF_LOCAL sockets.
	* pinfo.cc (_pinfo::commune_recv): Generate empty names for
	non exisiting file descriptors.
	(_pinfo::fd): Ditto.
	* pipe.cc (fhandler_pipe::open): New method.
@
text
@d346 1
a346 1
	size_t fs; 
d417 1
a417 1
	size_t fs; 
d585 1
a585 1
        len += written;
@


1.54
log
@	* fhandler_process.cc (format_process_maps): Get destbuf argument by
	reference.  Allow resizing of destbuf as necessary.  Fix string
	handling.
@
text
@d95 2
a96 1
 * -1 if path is a file, -2 if path is a symlink.
d120 9
d178 10
d292 6
d367 2
a368 2
		filebuf = strdup ("<disconnected>");
		fs = strlen (filebuf) + 1;
@


1.53
log
@	* cygheap.h (class cygheap_fdenum): New class to enumerate used
	fhandlers.
	* dtable.h (class dtable): Add cygheap_fdenum as friend class.
	* fhandler.h (fhandler_base::get_proc_fd_name): New virtual method
	to return a name for /proc/<pid>/fd.
	(fhandler_socket::get_proc_fd_name): Ditto.
	(fhandler_pipe::get_proc_fd_name): Ditto.
	(fhandler_virtual::opendir): Make virtual method.
	(fhandler_process::opendir): New method.
	* fhandler.cc (fhandler_base::get_proc_fd_name): New method.
	* fhandler_process.cc: Include ctype.h.
	(PROCESS_FD): Define.
	(process_listing): Add "fd".
	(fhandler_process::exists): Fix comment.  Return 1 in case of "fd"
	directory. Handle files below "fd".
	(fhandler_process::fstat): Drop "self" handling.  Set correct link
	count for directories.
	(fhandler_process::opendir): New method to handle "fd" directory.
	(fhandler_process::readdir): Add "fd" handling.
	(fhandler_process::open): Drop "self" handling.
	(fhandler_process::fill_filebuf): Ditto.  Add "fd" handling.  Fix
	"maps" output string.
	* fhandler_registry.cc (fhandler_registry::fstat): Set correct link
	count for directories.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): New method.
	* path.cc (symlink_info::set): Fix thinko.
	* pinfo.cc (_pinfo::commune_recv): Rename pathbuf to path throughout.
	Drop local path variable in PICOM_FIFO case.  Fix debug output.
	Close handles as early as possible. Add PICOM_FDS and PICOM_FD
	handling.
	(_pinfo::commune_send): Add PICOM_FDS and PICOM_FD handling.
	(_pinfo::fd): New method.
	(_pinfo::fds): New method.
	* pinfo.h (enum picom): Add PICOM_FDS and PICOM_FD.
	(_pinfo::fd): Declare.
	(_pinfo::fds): Declare.
	* pipe.cc (fhandler_pipe::get_proc_fd_name): New method.
@
text
@d84 1
a84 1
static _off64_t format_process_maps (_pinfo *p, char *destbuf, size_t maxsize);
d477 1
a477 1
format_process_maps (_pinfo *p, char *destbuf, size_t maxsize)
d532 2
a533 2
	if (len + strlen (posix_modname) + 50 > maxsize - 1)
	  break;
d557 3
a559 3
	while (written++ < 61)
	  destbuf[len + written] = ' ';
        len += written - 1;
@


1.52
log
@	* smallprint.c (rn): Change uval to unsigned long long to fix 64 bit
	handling.
	* fhandler_process.cc (format_process_maps): Print major, minor and
	inode numbers correctly.
@
text
@d28 1
d47 1
d49 3
a51 3
static const int PROCESS_ROOT = 15;
static const int PROCESS_EXE = 16;
static const int PROCESS_CWD = 17;
d73 1
d95 1
a95 1
 * <0 if path is a file.
d112 1
a112 1
	return is_symlink (i) ? -2 : -1;
d114 6
d135 1
a135 4
  if (path_prefix_p ("self", path, 4))
    pid = getpid ();
  else
    pid = atoi (path);
a150 2
      buf->st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
      return 0;
d158 4
a161 1
      buf->st_nlink = PROCESS_LINK_COUNT;
d177 9
d189 6
a194 1
  if (dir->__d_position >= PROCESS_LINK_COUNT)
d196 13
a208 3
  strcpy (dir->__d_dirent->d_name, process_listing[dir->__d_position++]);
  syscall_printf ("%p = readdir (%p) (%s)", &dir->__d_dirent, dir,
		  dir->__d_dirent->d_name);
d225 1
a225 4
  if (path_prefix_p ("self", path, 4))
    pid = getpid ();
  else
    pid = atoi (path);
d303 2
d306 2
a307 8
    {
      const char *path;
      path = get_name () + proc_len + 1;
      if (path_prefix_p ("self", path, 4))
	pid = getpid ();
      else
	pid = atoi (path);
    }
d318 30
d559 1
a559 1
        len += written;
@


1.51
log
@	* autoload.cc (GetModuleFileNameExA): Add.
	(GetModuleInformation): Add.
	(QueryWorkingSet): Add.
	* fhandler.h (fhandler_virtual::get_filebuf): New method.
	* fhandler_proc.cc (PROC_SELF): Define.
	(proc_fhandlers): Change type of self to FH_PROC.
	(fhandler_proc::exists): Return -3 if self.
	(fhandler_proc::fstat): Handle self as symlink.
	(fhandler_proc::fill_filebuf): Handle self.
	* fhandler_process.cc: Include psapi.h.
	(PROCESS_EXENAME): Remove.
	(PROCESS_MAPS): Define.
	(PROCESS_ROOT): Define.
	(PROCESS_EXE): Define.
	(PROCESS_CWD): Define.
	(process_listing): Remove "exename", add "maps, "root", "exe" and
	"cwd" elements.
	(fhandler_process::exists): Return -2 for symlinks.
	(fhandler_process::fstat): Handle symlinks.
	(fill_filebuf): Evaluate pid if pid is 0.  Use exename handling for
	exe.  Handle maps, root and cwd.
	(format_process_maps): New function evaluating "maps".
	* path.cc (symlink_info::set): New method to fill symlink_info
	with data matching virtual symlinks.
	(path_conv::check): Handle virtual symlinks.
	* pinfo.cc (_pinfo::commune_recv): Add PICOM_CWD and PICOM_ROOT
	handling.
	(_pinfo::commune_send): Ditto.
	(_pinfo::root): New function.
	(_pinfo::cwd): New function.
	* pinfo.h (enum picom): Add PICOM_CWD and PICOM_ROOT.
	(_pinfo::root): Declare.
	(_pinfo::cwd): Declare.
@
text
@d471 1
d473 5
d494 1
a494 1
				"%08lx-%08lx %s %08lx 00:00 %lu   ",
d500 4
a503 2
				info.SizeOfImage);
	while (written++ < 49)
@


1.50
log
@* init.cc (dll_entry): Remove unused extern.
* include/sys/cygwin.h: Remove PID_ZOMBIE.
* pinfo.h: Rename EXITCODE_* defines.
(pinfo::set_exit_state): Remove parameter.
* pinfo.cc (set_exit_state): Remove parameter.  Reverse sense of test so that
exitcode is checked for having been set rather than not having been set.  Set
flag when exitcode has been established.  Don't set PID_STATE here.
(pinfo::init): Remove exitcode initialization.
(pinfo::exit): Reflect change in EXITCODE_* naming.  Set flag when exitcode has
been established.  Reflect change in arguments to set_process_state.
(proc_waiter): Reflect change in arguments to set_process_state.  Set
process_state here and only here.
* fhandler_process.cc (fhandler_process::fill_filebuf): Reflect removal of
PID_ZOMBIE define.
(format_process_stat): Ditto.
(format_process_status): Ditto.
* sigproc.cc (pid_exists): Ditto.
(stopped_or_terminated): Ditto.  Make sure that only low-order 16 bits of
exitcode are used.
* spawn.cc (spawn_guts): Reflect change in EXITCODE_* naming.
@
text
@d28 1
d34 19
a52 12
static const int PROCESS_EXENAME = 3;
static const int PROCESS_WINPID = 4;
static const int PROCESS_WINEXENAME = 5;
static const int PROCESS_STATUS = 6;
static const int PROCESS_UID = 7;
static const int PROCESS_GID = 8;
static const int PROCESS_PGID = 9;
static const int PROCESS_SID = 10;
static const int PROCESS_CTTY = 11;
static const int PROCESS_STAT = 12;
static const int PROCESS_STATM = 13;
static const int PROCESS_CMDLINE = 14;
a58 1
  "exename",
d70 5
d81 1
d107 4
a110 1
      return -1;
d156 6
a162 1
    case -1:
d275 9
d331 2
d335 1
a335 1
	if (filebuf)
d337 13
a349 2
	size_t fs;
	filebuf = p->cmdline (fs);
d358 1
a358 1
    case PROCESS_EXENAME:
d411 6
d423 83
@


1.49
log
@	* fhandler_process.cc: Fix copyright date.
@
text
@d318 1
a318 1
	if (p->process_state & (PID_ZOMBIE | PID_EXITED))
d383 1
a383 1
  if (p->process_state & (PID_ZOMBIE | PID_EXITED))
d403 1
a403 1
  if (p->process_state & PID_ZOMBIE)
d516 1
a516 1
  if (p->process_state & (PID_ZOMBIE | PID_EXITED))
d536 1
a536 1
  if (p->process_state & PID_ZOMBIE)
@


1.48
log
@	* fhandler_process.cc: Use strcasematch instead of strcasecmp
	throughout.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004 Red Hat, Inc.
@


1.47
log
@	* fhandler_process.cpp (format_process_status): Use tabs in formatting
	instead of spaces.
@
text
@d327 1
a327 1
		if (strcasecmp (s, ".exe") == 0)
d395 1
a395 1
	  if (strcasecmp (s, ".exe") == 0)
d528 1
a528 1
	  if (strcasecmp (s, ".exe") == 0)
@


1.46
log
@revert erroneous checkin
@
text
@d572 17
a588 17
  return __small_sprintf (destbuf, "Name:   %s\n"
				   "State:  %c (%s)\n"
				   "Tgid:   %d\n"
				   "Pid:    %d\n"
				   "PPid:   %d\n"
				   "Uid:    %d %d %d %d\n"
				   "Gid:    %d %d %d %d\n"
				   "VmSize: %8d kB\n"
				   "VmLck:  %8d kB\n"
				   "VmRSS:  %8d kB\n"
				   "VmData: %8d kB\n"
				   "VmStk:  %8d kB\n"
				   "VmExe:  %8d kB\n"
				   "VmLib:  %8d kB\n"
				   "SigPnd: %016x\n"
				   "SigBlk: %016x\n"
				   "SigIgn: %016x\n",
@


1.45
log
@* fhandler_proc.cc (proc_listing): Add entry for "self".
(proc_fhandlers): Add entry for "self".
* fhandler_process.cc (fhandler_process::fstate): Handle "self".
(fhandler_process::open): Handle "self".
@
text
@d322 1
a322 2
	    charplus x (p->progname);
	    mount_table->conv_to_posix_path (x, filebuf, 1);
@


1.44
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d110 4
a113 1
  pid = atoi (path);
d173 4
a176 1
  pid = atoi (path);
d322 2
a323 1
	    mount_table->conv_to_posix_path (p->progname, filebuf, 1);
@


1.43
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d444 1
a444 2
	  debug_printf ("OpenProcess: ret = %d",
			error);
d458 1
a458 2
	  debug_printf ("NtQueryInformationProcess: ret = %d, "
		       "Dos(ret) = %d",
d631 2
a632 3
      debug_printf ("NtQuerySystemInformation: ret = %d, "
		   "Dos(ret) = %d",
		   ret, RtlNtStatusToDosError (ret));
d696 1
a696 2
      debug_printf ("OpenProcess: ret = %d",
		    error);
d708 1
a708 2
      debug_printf ("NtQueryVirtualMemory: ret = %d, "
		   "Dos(ret) = %d",
d733 1
a733 2
      debug_printf ("NtQueryInformationProcess: ret = %d, "
		    "Dos(ret) = %d",
@


1.42
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d166 1
a166 1
  set_nohandle (true);
@


1.41
log
@* dcrt0.cc (reent_data): Reluctantly resurrect.
(__cygwin_user_data::impure_ptr): Ditto.
(_dll_crt0): Reluctantly initialize _impure_ptr here.
(initialize_main_tls): Eliminate local_clib initialization since it now happens
in init_thread.
* init.cc (dll_entry): Reluctantly remove code which set _impure_ptr to the
main thread's local_clib.
* perthread.h (reent_data): Remove obsolete declaration.
* sigproc.cc (proc_subproc): Add more debugging output.
(get_proc_lock): Ditto.
*dcrt0.cc (dll_crt0_1): Allocate argv[0] via malloc since main thread could
exit.
@
text
@d3 1
a3 1
   Copyright 2002, 2003 Red Hat, Inc.
@


1.40
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d303 4
a306 1
	  filebuf = strdup ("<defunct>");
@


1.39
log
@2003-09-26  Pierre Humblet <pierre.humblet@@ieee.org>

	* pinfo.cc (pinfo::init): Do not give FILE_MAP_WRITE access to Everybody.
	* exceptions.cc (sig_handle_tty_stop): Do not create pinfo parent with
	PID_MAP_WRITE.
	* fhandler_process.cc (fhandler_process::fill_filebuf): Ditto for pinfo p.
	* signal.cc (kill_worker): Ditto for pinfo dest.
@
text
@d308 1
a308 1
	filebuf = (char *) realloc (filebuf, bufalloc = MAX_PATH);
d367 1
a367 1
  char cmd[MAX_PATH];
d504 1
a504 1
  char cmd[MAX_PATH];
@


1.38
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d248 1
a248 2
  pinfo p (pid, PID_MAP_RW);	// PID_MAP_RW for cmdline since it
  				// needs to signal the other process
@


1.37
log
@* fhandler_process.cc (fhandler_process::fill_filebuf): Open pinfo with
PID_MAP_RW.
* sigproc.cc (talktome): Ditto for winpids.
@
text
@d18 1
a20 1
#include "path.h"
d99 1
a99 1
  fhandler_proc (FH_PROCESS)
d104 1
a104 1
fhandler_process::fstat (struct __stat64 *buf, path_conv *pc)
d108 1
a108 1
  (void) fhandler_base::fstat (buf, pc);
d158 1
a158 1
fhandler_process::open (path_conv *pc, int flags, mode_t mode)
d162 1
a162 1
  int res = fhandler_virtual::open (pc, flags, mode);
@


1.36
log
@* fhandler_disk_file.cc (fhandler_cygdrive::readdir): Do not change 'errno' if
end of directory condition is encountered as per SUSv2.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_process (fhandler_process::readdir): Ditto.
* fhandler_registry (fhandler_registry::readdir): Ditto.
@
text
@d248 2
a249 1
  pinfo p (pid);
@


1.35
log
@* cygheap.cc (creturn): Set appropriate errno when out of memory.
(ccalloc): Only issue system_printf when debugging.
* dtable.cc (dtable::extend): Only allocate 100 * the incremental growth size
max.  Set errno appropriately.
(dtable::build_fhandler): Check for error from set_name.
* fhandler.cc (fhandler_base::set_name): Set errno and return error on OOM.
* fhandler.h (fhandler_base::set_name): Change to bool.
* fhandler_process.cc (format_process_stat): Fix formatting.
* resource.cc (getrlimit): Return greater of OPEN_MAX or fd table size.
* sysconf.cc (sysconf): Ditto.
@
text
@d150 1
a150 4
    {
      set_errno (ENMFILE);
      return NULL;
    }
@


1.34
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d403 3
a405 1
 if (wincap.is_winnt ())
d464 5
a468 3
       fault_count = vmc.PageFaultCount;
       utime = put.UserTime.QuadPart * HZ / 10000000ULL;
       stime = put.KernelTime.QuadPart * HZ / 10000000ULL;
d478 7
a484 10
	 start_time = (spt.KernelTime.QuadPart + spt.UserTime.QuadPart) * HZ / 10000000ULL;
       priority = pbi.BasePriority;
       unsigned page_size = getpagesize ();
       vmsize = vmc.PagefileUsage;
       vmrss = vmc.WorkingSetSize / page_size;
       vmmaxrss = ql.MaximumWorkingSetSize / page_size;
    }
  else
    {
      start_time = (GetTickCount () / 1000 - time (NULL) + p->start_time) * HZ;
d486 1
@


1.33
log
@	* fhandler_process.cc (format_process_stat): use PagefileUsage
	instead of VirtualSize.
	(get_mem_values): Ditto.
@
text
@a11 1
#include <errno.h>
@


1.32
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@d478 1
a478 1
       vmsize = vmc.VirtualSize;
d743 1
a743 1
  *vmsize = vmc.VirtualSize / page_size;
@


1.31
log
@Revert below changes regarding _pinfo::cmdline.
@
text
@d70 3
a72 3
static __off64_t format_process_stat (_pinfo *p, char *destbuf, size_t maxsize);
static __off64_t format_process_status (_pinfo *p, char *destbuf, size_t maxsize);
static __off64_t format_process_statm (_pinfo *p, char *destbuf, size_t maxsize);
d368 1
a368 1
static __off64_t
d503 1
a503 1
static __off64_t
d596 1
a596 1
static __off64_t
@


1.30
log
@	* external.cc (cygwin_internal): Change n to __off64_t to match change
	of _pinfo::cmdline.
	* fhandler.h (class fhandler_virtual): Change filesize member to
	__off64_t.
	* fhandler_proc.cc (format_proc_meminfo): Change to return __off64_t.
	(format_proc_stat): Ditto.
	(format_proc_uptime): Ditto.
	* fhandler_process.cc (format_process_stat): Ditto.
	(format_process_status): Ditto.
	(format_process_statm): Ditto.
	* pinfo.cc (_pinfo::cmdline): Expect __off64_t parameter.
	* pinfo.h (class _pinfo): Change declaration of cmdline accordingly.
@
text
@d303 3
a305 1
	filebuf = p->cmdline (filesize);
d368 1
a368 2
static
__off64_t
d503 1
a503 2
static
__off64_t
d596 1
a596 2
static
__off64_t
d612 1
a612 2
static
int
d679 1
a679 2
static
bool
@


1.29
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d70 3
a72 3
static off_t format_process_stat (_pinfo *p, char *destbuf, size_t maxsize);
static off_t format_process_status (_pinfo *p, char *destbuf, size_t maxsize);
static off_t format_process_statm (_pinfo *p, char *destbuf, size_t maxsize);
d367 1
a367 1
off_t
d503 1
a503 1
off_t
d597 1
a597 1
off_t
@


1.29.2.1
log
@merge from trunk
@
text
@d100 1
a100 1
  fhandler_proc ()
@


1.29.2.2
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@a18 1
#include "path.h"
d21 1
d105 1
a105 1
fhandler_process::fstat (struct __stat64 *buf)
d109 1
a109 1
  (void) fhandler_base::fstat (buf);
d162 1
a162 1
fhandler_process::open (int flags, mode_t mode)
d166 1
a166 1
  int res = fhandler_virtual::open (flags, mode);
@


1.29.2.3
log
@merge from trunk
@
text
@d70 3
a72 3
static __off64_t format_process_stat (_pinfo *p, char *destbuf, size_t maxsize);
static __off64_t format_process_status (_pinfo *p, char *destbuf, size_t maxsize);
static __off64_t format_process_statm (_pinfo *p, char *destbuf, size_t maxsize);
d303 1
a303 3
	size_t fs;
	filebuf = p->cmdline (fs);
	filesize = fs;
d366 2
a367 1
static __off64_t
d502 2
a503 1
static __off64_t
d596 2
a597 1
static __off64_t
d613 2
a614 1
static int
d681 2
a682 1
static bool
@


1.29.2.4
log
@merge from trunk
@
text
@d70 3
a72 3
static _off64_t format_process_stat (_pinfo *p, char *destbuf, size_t maxsize);
static _off64_t format_process_status (_pinfo *p, char *destbuf, size_t maxsize);
static _off64_t format_process_statm (_pinfo *p, char *destbuf, size_t maxsize);
d368 1
a368 1
static _off64_t
d503 1
a503 1
static _off64_t
d596 1
a596 1
static _off64_t
@


1.29.2.5
log
@merge from trunk
@
text
@d478 1
a478 1
       vmsize = vmc.PagefileUsage;
d743 1
a743 1
  *vmsize = vmc.PagefileUsage / page_size;
@


1.29.2.6
log
@merge from trunk
@
text
@d12 1
@


1.29.2.7
log
@merge from trunk
@
text
@d403 1
a403 3
  if (!wincap.is_winnt ())
    start_time = (GetTickCount () / 1000 - time (NULL) + p->start_time) * HZ;
  else
d462 3
a464 5
      fault_count = vmc.PageFaultCount;
      utime = put.UserTime.QuadPart * HZ / 10000000ULL;
      stime = put.KernelTime.QuadPart * HZ / 10000000ULL;
      start_time = (put.CreateTime.QuadPart - stodi.BootTime.QuadPart) * HZ / 10000000ULL;
#if 0
d474 10
a483 7
	 start_time = (spt.KernelTme.QuadPart + spt.UserTime.QuadPart) * HZ / 10000000ULL;
#endif
      priority = pbi.BasePriority;
      unsigned page_size = getpagesize ();
      vmsize = vmc.PagefileUsage;
      vmrss = vmc.WorkingSetSize / page_size;
      vmmaxrss = ql.MaximumWorkingSetSize / page_size;
a484 1

@


1.29.2.8
log
@merge from trunk
@
text
@d150 4
a153 1
    return NULL;
@


1.28
log
@Use isdirsep rather than SLASH_P throughout.
* path.cc (iscygdrive): Disallow /cygdrive\x.
(normalize_posix_path): "Normalize" a windows path, if detected, rather than
converting to posix.
* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support and capability
checking for B230400 bitrate.
(fhandler_serial::tcgetattr): Add support for B230400 bitrate.
* include/sys/termios.h: Add B230400 definition for Posix support of 230.4Kbps.
@
text
@d3 1
a3 1
   Copyright 2002 Red Hat, Inc.
@


1.27
log
@revert erroneous checkins
@
text
@d88 1
a88 1
  while (*path != 0 && !SLASH_P (*path))
d175 1
a175 1
  while (*path != 0 && !SLASH_P (*path))
@


1.27.8.1
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d100 1
a100 1
  fhandler_proc ()
@


1.27.8.2
log
@.
@
text
@d88 1
a88 1
  while (*path != 0 && !isdirsep (*path))
d175 1
a175 1
  while (*path != 0 && !isdirsep (*path))
@


1.26
log
@* sigproc.cc (WAIT_SIG_PRIORITY): Bump to THREAD_PRIORITY_TIME_CRITICAL.
@
text
@d63 1
a63 1
  "qmdline",
@


1.25
log
@* fhandler_process.cc (fhandler_process::fill_filebuf): Deal with error
condition from cmdline retrieval.
@
text
@d63 1
a63 1
  "cmdline",
@


1.24
log
@* external.cc (cygwin_internal): Implement CW_CMDLINE.
* pinfo.h (SIGCOMMUNE): New signal type.
(commune_result): New structure for commune functions.
(picom): New enum for commune functions.
(_pinfo::hello_pid): New.  Pid who's communicating with me.
(_pinfo::tothem): New.  Handle of communicating pipe.
(_pinfo::fromthem): Ditto.
(_pinfo::commune_recv): Declare.
(_pinfo::commune_send): Declare.
(_pinfo::alive): Declare.
(_pinfo::cmdline): Declare.
(_pinfo::lock): Declare.
* pinfo.cc (set_myself): Initialize new _pinfo lock.
(_pinfo::alive): Define.  Determines if process still exists.
(_pinfo::commune_recv): Define.  Receive info from another cooperating process.
(_pinfo::commune_send): Define.  Send info to another cooperating process.
(_pinfo::cmdline): Define.  Determine command line of a given process.
* include/sys/cygwin.h (CW_CMDLINE): Define.
*sigproc.cc (talktome): Communicate with any processes who want to talk to me.
(wait_sig): Honor __SIGCOMMUNE.
* fhandler.cc (fhandler_virtual::fixup_after_exec): Declare.
* fhandler_proc.cc: Use malloc/free/realloc throughout rather than cmalloc
since buffers don't need to be propagated to subprocesses.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
(fhandler_virtual::fixup_after_exec): Define.
* fhandler_process.cc: Ditto for malloc/free/realloc.
(process_listin): Add "cmdline".
(fhandler_process::fill_filebuf): Implement PROCESS_CMDLINE.
* miscfuncs.cc (isalpha_array): New array populated with xor values for alpha
characters to switch from one case to another.
* string.h (cygwin_strcasematch): New asm implementation of case match.
* string.h (cygwin_nstrcasematch): New asm implementation of counted case
match.
@
text
@d304 1
a304 1
	if (!*filebuf)
@


1.24.2.1
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
* fhandler.h (fhandler_serial::vmin_): Declare as size_t.
* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@d45 1
d63 1
d269 1
a269 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
d299 9
d310 1
a310 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = MAX_PATH);
d329 1
a329 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
d337 1
a337 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = (len + 2));
d345 1
a345 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
d351 1
a351 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
d357 1
a357 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
@


1.23
log
@* fhandler_proc.cc (format_process_stat): make ctty a real device number.
(format_process_status): use effective uid/gid as real and saved uid/gid.
@
text
@d45 1
d63 1
d269 1
a269 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
d299 9
d310 1
a310 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = MAX_PATH);
d329 1
a329 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
d337 1
a337 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = (len + 2));
d345 1
a345 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
d351 1
a351 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
d357 1
a357 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
@


1.22
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d28 1
d490 2
a491 2
			  p->ppid, p->pgid, p->sid, p->ctty, -1,
			  0, fault_count, fault_count, 0, 0, utime, stime,
d560 3
d585 2
a586 2
			  p->uid, cygheap->user.real_uid, cygheap->user.real_uid, p->uid,
			  p->gid, cygheap->user.real_gid, cygheap->user.real_gid, p->gid,
@


1.21
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d65 1
a65 1
  (sizeof(process_listing) / sizeof(const char *)) - 1;
d478 1
a478 1
      start_time = (GetTickCount() / 1000 - time(NULL) + p->start_time) * HZ;
@


1.20
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d71 4
a74 4
static bool get_mem_values(DWORD dwProcessId, unsigned long *vmsize,
			   unsigned long *vmrss, unsigned long *vmtext,
			   unsigned long *vmdata, unsigned long *vmlib,
			   unsigned long *vmshare);
d129 1
a129 1
      time_as_timestruc_t(&buf->st_atim);
d376 1
a376 1
      strcpy(cmd, p->progname);
d437 1
a437 1
	  debug_printf("OpenProcess: ret = %d",
d452 1
a452 1
	  debug_printf("NtQueryInformationProcess: ret = %d, "
d471 1
a471 1
       unsigned page_size = getpagesize();
d510 1
a510 1
      strcpy(cmd, p->progname);
d555 1
a555 1
      unsigned page_size = getpagesize();
d626 1
a626 1
      debug_printf("NtQuerySystemInformation: ret = %d, "
d675 3
a677 2
get_mem_values(DWORD dwProcessId, unsigned long *vmsize, unsigned long *vmrss, unsigned long *vmtext,
	       unsigned long *vmdata, unsigned long *vmlib, unsigned long *vmshare)
d686 1
a686 1
  unsigned page_size = getpagesize();
d691 1
a691 1
      DWORD error = GetLastError();
d693 1
a693 1
      debug_printf("OpenProcess: ret = %d",
d706 1
a706 1
      debug_printf("NtQueryVirtualMemory: ret = %d, "
d732 3
a734 3
      debug_printf("NtQueryInformationProcess: ret = %d, "
		   "Dos(ret) = %d",
		   ret, RtlNtStatusToDosError (ret));
@


1.19
log
@* fhandler_proc.cc: Add <sys/param.h> include.
(format_proc_uptime): Use KernelTime and UserTime only as they include the
other counters.
(format_proc_stat): KernelTime includes IdleTime, so subtract IdleTime from
KernelTime.  Make number of 'jiffies' per second same as HZ define.
* fhandler_process.cc: Add <sys/param.h> include.
(format_process_stat): Make number of 'jiffies' per second same as HZ define.
Use KernelTime and UserTime only to calculate start_time.
@
text
@d227 1
a227 1
  	{
d461 2
a462 2
         start_time = (spt.KernelTime.QuadPart + spt.UserTime.QuadPart -
                       stodi.CurrentTime.QuadPart + put.CreateTime.QuadPart) * HZ / 10000000ULL;
d593 1
a593 1
  		vmlib = 0UL, vmshare = 0UL;
@


1.18
log
@* autoload.cc (GetSecurityInfo): Define new autoload function.
(RegQueryInfoKeyA): Ditto.
* fhandler.h (fhandler_virtual::fill_filebuf): Change return type to bool.
(fhandler_proc::fill_filebuf): Ditto.
(fhandler_registry::fill_filebuf): Ditto.
(fhandler_process::fill_filebuf): Ditto.
(fhandler_registry::value_name): Add new member.
(fhandler_registry::close): Add new method.
(fhandler_process::p): Remove member.
* fhandler_proc.cc (fhandler_proc::open): Add set_nohandle after calling
superclass method.  Check return value of fill_filebuf.
(fhandler_proc::fill_filebuf): Change return type to bool.  Add return
statement.
* fhandler_process.cc (fhandler_process::open): Add set_nohandle after calling
superclass method.  Remove references to p.  Check return value of
fill_filebuf.
(fhandler_process::fill_filebuf): Change return type to bool.  Don't use
dereference operator on p.  Add return statement.
(fhandler_process::format_process_stat): Fix typo.
* fhandler_registry.cc: Add static open_key declaration.
(fhandler_registry::exists): Assume path is already normalised.  Try opening
the path as a key in its own right first, before reverting to enumerating
subkeys and values of the parent key.
(fhandler_registry::fstat): Add additional code to return more relevant
information about the registry key/value.
(fhandler_registry::readdir): Explicitly set desired access when opening
registry key.  Remove output of buf from debug_printf format string.
(fhandler_registry::open): Use set_io_handle to store registry key handle.  Set
value_name member.  Move code to read a value from the registry to
fill_filebuf.  Add call to fill_filebuf.
(fhandler_registry::close): New method.
(fhandler_registry::fill_filebuf): Change return type to bool.  Add code to
read a value from registry.
(fhandler_registry::open_key): Make function static.  Use KEY_READ as desired
access unless this is the last path component.  Check the return value of
RegOpenKeyEx for an error instead of hKey.
* fhandler_virtual.cc (fhandler_virtual::lseek): Check the return value of
fill_filebuf.
(fhandler_virtual::open): Remove call to set_nohandle.
(fhandler_virtual::fill_filebuf): Change return type to bool.  Add return
statement.
* security.cc (get_nt_object_attribute): New function.
(get_object_attribute): New function.
* security.h (get_object_attribute): New function declaration.
@
text
@d26 1
d458 2
a459 2
       utime = put.UserTime.QuadPart / 100000ULL;
       stime = put.KernelTime.QuadPart / 100000ULL;
d461 2
a462 4
	 start_time = (spt.InterruptTime.QuadPart + spt.KernelTime.QuadPart +
		       spt.IdleTime.QuadPart + spt.UserTime.QuadPart +
		       spt.DpcTime.QuadPart - stodi.CurrentTime.QuadPart +
		       put.CreateTime.QuadPart) / 100000ULL;
d469 1
a469 3
	 start_time = (spt.InterruptTime.QuadPart + spt.KernelTime.QuadPart +
		       spt.IdleTime.QuadPart + spt.UserTime.QuadPart +
		       spt.DpcTime.QuadPart) / 100000ULL;
d478 1
a478 1
      start_time = (GetTickCount() / 1000 - time(NULL) + p->start_time) * 100;
@


1.17
log
@* fhandler_clipboard.c (fhandler_dev_clipboard::open): Force text mode.
* fhandler_console.cc (fhandler_console::open): *Really* force binary mode
rather than make it optional.
* fhandler_proc.cc (fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (set_flags): Add more debugging.
@
text
@d44 2
a45 1
static const char *process_listing[] = {
d63 2
a64 1
static const int PROCESS_LINK_COUNT = (sizeof(process_listing) / sizeof(const char *)) - 1;
d70 4
a73 2
static bool get_mem_values(DWORD dwProcessId, unsigned long *vmsize, unsigned long *vmrss, unsigned long *vmtext,
			   unsigned long *vmdata, unsigned long *vmlib, unsigned long *vmshare);
d166 2
a223 9
  {
  pinfo p (pid);
  if (!p)
    {
      set_errno (ENOENT);
      res = 0;
      goto out;
    }

d225 5
a229 2
  this->p = &p;
  fill_filebuf ();
a234 2
  this->p = NULL;
  }
d245 1
a245 1
void
d248 1
a248 1
  pinfo pmaybe;
d252 2
a253 2
      pmaybe.init (pid);
      p = &pmaybe;
a255 3
  if (!p)
    return;

d266 1
a266 1
	filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
d271 1
a271 1
	    num = (*p)->ppid;
d274 1
a274 1
	    num = (*p)->uid;
d277 1
a277 1
	    num = (*p)->pgid;
d280 1
a280 1
	    num = (*p)->sid;
d283 1
a283 1
	    num = (*p)->gid;
d286 1
a286 1
	    num = (*p)->ctty;
d299 2
a300 2
	filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = MAX_PATH);
	if ((*p)->process_state & (PID_ZOMBIE | PID_EXITED))
d304 1
a304 1
	    mount_table->conv_to_posix_path ((*p)->progname, filebuf, 1);
d319 2
a320 2
	filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
	__small_sprintf (filebuf, "%d\n", (*p)->dwProcessId);
d326 1
a326 1
	int len = strlen ((*p)->progname);
d328 2
a329 2
	filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = (len + 2));
	strcpy (filebuf, (*p)->progname);
d338 1
a338 1
	filesize = format_process_status ((*p), filebuf, bufalloc);
d345 1
a345 1
	filesize = format_process_stat ((*p), filebuf, bufalloc);
d352 1
a352 1
	filesize = format_process_statm ((*p), filebuf, bufalloc);
d357 1
a357 2
  if (p == &pmaybe)
    p = NULL;
d372 1
a372 1
    strcpy (cmd, "<defunct");
d595 2
a596 2
  unsigned long vmsize = 0UL, vmrss = 0UL, vmtext = 0UL, vmdata = 0UL, vmlib = 0UL,
		vmshare = 0UL;
d599 2
a600 1
      if (!get_mem_values (p->dwProcessId, &vmsize, &vmrss, &vmtext, &vmdata, &vmlib, &vmshare))
@


1.16
log
@* fhandler.h (fhandler_process::pid): New field.
(fhandler_process::fstat): Remove unneeded array.  Set pid element.
(fhandler_process::open): Ditto.
(fhandler_process::fill_filebuf): Handle case where 'p' field is NULL.
@
text
@d240 1
a240 1
  set_flags (flags & ~O_TEXT, O_BINARY);
@


1.15
log
@* fhandler.h (fhandler_process::p): New field.
(fhandler_process:fill_filebuf): Revert to same definition as virtual in parent
class.
(fhandler_process::open): Fill out p field rather than passing as an argument.
(fhandler_process::fill_filebuf): Use p pointer rather than argument.
@
text
@d103 1
a103 2
  int pid = atoi (path);
  winpids pids;
d107 1
a107 1
      set_errno(ENOENT);
d156 1
a156 2
  int process_file_no = -1, pid;
  winpids pids;
d250 11
d361 3
@


1.14
log
@	* fhandler.cc (fhandler_base::fstat): Initialise tv_nsec member of
	st_atim, st_mtim, and st_ctim fields.
	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Ditto.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	* glob.c (stat32_to_STAT): Copy across the whole st_atim,
	st_mtime, and st_ctim fields.
	* syscalls.cc (stat64_to_stat32): Ditto.
	* times.cc (to_timestruc_t): New function.
	(time_as_timestruc_t): New function.
	* winsup.h: Add to_timestruc_t and time_as_timestruc_t functions.
	* include/cygwin/stat.h: Replace time_t with timestruc_t
	throughout for all file times, removing the st_spare1, st_spare2,
	and st_spare3 fields in the process. Add macros to access tv_sec
	fields by old names.
	* include/cygwin/types.h: Typedef timespec_t and timestruc_t as
	struct timespec.
@
text
@d230 2
a231 1
  fill_filebuf (p);
d237 1
d250 1
a250 1
fhandler_process::fill_filebuf (pinfo& p)
d267 1
a267 1
	    num = p->ppid;
d270 1
a270 1
	    num = p->uid;
d273 1
a273 1
	    num = p->pgid;
d276 1
a276 1
	    num = p->sid;
d279 1
a279 1
	    num = p->gid;
d282 1
a282 1
	    num = p->ctty;
d296 1
a296 1
	if (p->process_state & (PID_ZOMBIE | PID_EXITED))
d300 1
a300 1
	    mount_table->conv_to_posix_path (p->progname, filebuf, 1);
d316 1
a316 1
	__small_sprintf (filebuf, "%d\n", p->dwProcessId);
d322 1
a322 1
	int len = strlen (p->progname);
d325 1
a325 1
	strcpy (filebuf, p->progname);
d334 1
a334 1
	filesize = format_process_status (p, filebuf, bufalloc);
d341 1
a341 1
	filesize = format_process_stat (p, filebuf, bufalloc);
d348 1
a348 1
	filesize = format_process_statm (p, filebuf, bufalloc);
@


1.14.2.1
log
@Merged changes from HEAD
@
text
@@


1.14.2.2
log
@Merged changes from HEAD
@
text
@d103 2
a104 1
  pid = atoi (path);
d108 1
a108 1
      set_errno (ENOENT);
d157 2
a158 1
  int process_file_no = -1;
d230 1
a230 2
  this->p = &p;
  fill_filebuf ();
a235 1
  this->p = NULL;
d248 1
a248 1
fhandler_process::fill_filebuf ()
a249 11
  pinfo pmaybe;

  if (!p)
    {
      pmaybe.init (pid);
      p = &pmaybe;
    }

  if (!p)
    return;

d265 1
a265 1
	    num = (*p)->ppid;
d268 1
a268 1
	    num = (*p)->uid;
d271 1
a271 1
	    num = (*p)->pgid;
d274 1
a274 1
	    num = (*p)->sid;
d277 1
a277 1
	    num = (*p)->gid;
d280 1
a280 1
	    num = (*p)->ctty;
d294 1
a294 1
	if ((*p)->process_state & (PID_ZOMBIE | PID_EXITED))
d298 1
a298 1
	    mount_table->conv_to_posix_path ((*p)->progname, filebuf, 1);
d314 1
a314 1
	__small_sprintf (filebuf, "%d\n", (*p)->dwProcessId);
d320 1
a320 1
	int len = strlen ((*p)->progname);
d323 1
a323 1
	strcpy (filebuf, (*p)->progname);
d332 1
a332 1
	filesize = format_process_status ((*p), filebuf, bufalloc);
d339 1
a339 1
	filesize = format_process_stat ((*p), filebuf, bufalloc);
d346 1
a346 1
	filesize = format_process_statm ((*p), filebuf, bufalloc);
a349 3

  if (p == &pmaybe)
    p = NULL;
@


1.14.2.3
log
@Merged changes from HEAD
@
text
@d44 1
a44 2
static const char * const process_listing[] =
{
d62 1
a62 2
static const int PROCESS_LINK_COUNT =
  (sizeof(process_listing) / sizeof(const char *)) - 1;
d68 2
a69 4
static bool get_mem_values(DWORD dwProcessId, unsigned long *vmsize,
			   unsigned long *vmrss, unsigned long *vmtext,
			   unsigned long *vmdata, unsigned long *vmlib,
			   unsigned long *vmshare);
a161 2
  set_nohandle (true);

d218 9
d228 2
a229 5
  if (!fill_filebuf ())
  	{
	  res = 0;
	  goto out;
	}
d235 2
d240 1
a240 1
  set_flags ((flags & ~O_TEXT) | O_BINARY);
d247 1
a247 1
bool
d250 1
a250 1
  pinfo p (pid);
d254 2
a255 2
      set_errno (ENOENT);
      return false;
d258 3
d271 1
a271 1
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
d276 1
a276 1
	    num = p->ppid;
d279 1
a279 1
	    num = p->uid;
d282 1
a282 1
	    num = p->pgid;
d285 1
a285 1
	    num = p->sid;
d288 1
a288 1
	    num = p->gid;
d291 1
a291 1
	    num = p->ctty;
d304 2
a305 2
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = MAX_PATH);
	if (p->process_state & (PID_ZOMBIE | PID_EXITED))
d309 1
a309 1
	    mount_table->conv_to_posix_path (p->progname, filebuf, 1);
d324 2
a325 2
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
	__small_sprintf (filebuf, "%d\n", p->dwProcessId);
d331 1
a331 1
	int len = strlen (p->progname);
d333 2
a334 2
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = (len + 2));
	strcpy (filebuf, p->progname);
d343 1
a343 1
	filesize = format_process_status (*p, filebuf, bufalloc);
d350 1
a350 1
	filesize = format_process_stat (*p, filebuf, bufalloc);
d357 1
a357 1
	filesize = format_process_statm (*p, filebuf, bufalloc);
d362 2
a363 1
  return true;
d378 1
a378 1
    strcpy (cmd, "<defunct>");
d601 2
a602 2
  unsigned long vmsize = 0UL, vmrss = 0UL, vmtext = 0UL, vmdata = 0UL,
  		vmlib = 0UL, vmshare = 0UL;
d605 1
a605 2
      if (!get_mem_values (p->dwProcessId, &vmsize, &vmrss, &vmtext, &vmdata,
			   &vmlib, &vmshare))
@


1.14.2.4
log
@Merged changes from HEAD
@
text
@a25 1
#include <sys/param.h>
d457 2
a458 2
       utime = put.UserTime.QuadPart * HZ / 10000000ULL;
       stime = put.KernelTime.QuadPart * HZ / 10000000ULL;
d460 4
a463 2
         start_time = (spt.KernelTime.QuadPart + spt.UserTime.QuadPart -
                       stodi.CurrentTime.QuadPart + put.CreateTime.QuadPart) * HZ / 10000000ULL;
d470 3
a472 1
	 start_time = (spt.KernelTime.QuadPart + spt.UserTime.QuadPart) * HZ / 10000000ULL;
d481 1
a481 1
      start_time = (GetTickCount() / 1000 - time(NULL) + p->start_time) * HZ;
@


1.14.2.5
log
@Merged changes from HEAD
@
text
@d227 1
a227 1
	{
d461 2
a462 2
	 start_time = (spt.KernelTime.QuadPart + spt.UserTime.QuadPart -
		       stodi.CurrentTime.QuadPart + put.CreateTime.QuadPart) * HZ / 10000000ULL;
d593 1
a593 1
		vmlib = 0UL, vmshare = 0UL;
@


1.14.2.6
log
@Merged changes from HEAD
@
text
@d71 4
a74 4
static bool get_mem_values (DWORD dwProcessId, unsigned long *vmsize,
			    unsigned long *vmrss, unsigned long *vmtext,
			    unsigned long *vmdata, unsigned long *vmlib,
			    unsigned long *vmshare);
d129 1
a129 1
      time_as_timestruc_t (&buf->st_atim);
d376 1
a376 1
      strcpy (cmd, p->progname);
d437 1
a437 1
	  debug_printf ("OpenProcess: ret = %d",
d452 1
a452 1
	  debug_printf ("NtQueryInformationProcess: ret = %d, "
d471 1
a471 1
       unsigned page_size = getpagesize ();
d510 1
a510 1
      strcpy (cmd, p->progname);
d555 1
a555 1
      unsigned page_size = getpagesize ();
d626 1
a626 1
      debug_printf ("NtQuerySystemInformation: ret = %d, "
d675 2
a676 3
get_mem_values (DWORD dwProcessId, unsigned long *vmsize, unsigned long *vmrss,
		unsigned long *vmtext, unsigned long *vmdata,
		unsigned long *vmlib, unsigned long *vmshare)
d685 1
a685 1
  unsigned page_size = getpagesize ();
d690 1
a690 1
      DWORD error = GetLastError ();
d692 1
a692 1
      debug_printf ("OpenProcess: ret = %d",
d705 1
a705 1
      debug_printf ("NtQueryVirtualMemory: ret = %d, "
d731 3
a733 3
      debug_printf ("NtQueryInformationProcess: ret = %d, "
		    "Dos(ret) = %d",
		    ret, RtlNtStatusToDosError (ret));
@


1.13
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d124 2
a125 1
      buf->st_atime = time(NULL);
@


1.12
log
@* fhandler_process.cc (fhandler_process::open): Set fileid.
@
text
@a11 1
#include <sys/fcntl.h>
d239 1
a240 1
  set_flags (flags);
@


1.11
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d229 1
@


1.10
log
@* fhandler.cc (fhandler_base::fstat): Move dev and ino calculation into caller.
* syscalls.cc (stat_worker): Calculate dev and ino calculation here, if zero.
* fhandler_proc.cc (fhandler_proc::fhandler_proc): Minor reorg for debugging.
* fhandler_process.cc (fhandler_process::exists): Return 0 on nonexistence.
(fhandler_process::fstat): Simplify pid logic.
* fhandler_tape.cc (fhandler_dev_tape::fstat): Minor reformatting.
@
text
@a20 1
#include "sigproc.h"
a158 1
  _pinfo *p;
d219 4
a222 1
  for (unsigned i = 0; i < pids.npids; i++)
d224 4
a227 1
      p = pids[i];
d229 1
a229 14
      if (!proc_exists (p))
	continue;

      if (p->pid == pid)
	goto found;
    }
  set_errno (ENOENT);
  res = 0;
  goto out;
found:
  fileid = process_file_no;
  saved_pid = pid;
  saved_p = p;
  fill_filebuf ();
d235 1
d247 1
a247 1
fhandler_process::fill_filebuf ()
a248 7
  // has this process gone away?
  if (!proc_exists (saved_p) || saved_p->pid != saved_pid)
    {
      if (filebuf)
	cfree(filebuf);
      filesize = 0; bufalloc = (size_t) -1;
    }
d264 1
a264 1
	    num = saved_p->ppid;
d267 1
a267 1
	    num = saved_p->uid;
d270 1
a270 1
	    num = saved_p->pgid;
d273 1
a273 1
	    num = saved_p->sid;
d276 1
a276 1
	    num = saved_p->gid;
d279 1
a279 1
	    num = saved_p->ctty;
d293 1
a293 1
	if (saved_p->process_state & (PID_ZOMBIE | PID_EXITED))
d297 1
a297 1
	    mount_table->conv_to_posix_path (saved_p->progname, filebuf, 1);
d313 1
a313 1
	__small_sprintf (filebuf, "%d\n", saved_p->dwProcessId);
d319 1
a319 1
	int len = strlen (saved_p->progname);
d322 1
a322 1
	strcpy (filebuf, saved_p->progname);
d331 1
a331 1
	filesize = format_process_status (saved_p, filebuf, bufalloc);
d338 1
a338 1
	filesize = format_process_stat (saved_p, filebuf, bufalloc);
d345 1
a345 1
	filesize = format_process_statm (saved_p, filebuf, bufalloc);
d347 1
a347 1
    }
@


1.9
log
@* fhandler_proc.cc (fhandler_proc::readdir): Set errno when no more files.
* fhandler_process.cc (fhandler_process::readdir): Ditto.
* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
@
text
@d90 1
a90 1
  return 1;
d107 2
a108 2
  _pinfo *p;
  for (unsigned i = 0; i < pids.npids; i++)
d110 3
a112 4
      p = pids[i];

      if (!proc_exists (p))
	continue;
a113 6
      if (p->pid == pid)
	goto found;
    }
  set_errno(ENOENT);
  return -1;
found:
@


1.8
log
@	* autoload.cc: Replace autoload statments for ZwXXX by NtXXX.
	Drop ZwQuerySystemInformation since NtQuerySystemInformation was
	already available.
	* fhandler_proc.cc (format_proc_uptime): Replace call to
	ZwQuerySystemInformation by call to NtQuerySystemInformation.
	(format_proc_stat): Ditto.
	* fhandler_process.cc (format_process_stat): Replace call to
	ZwQueryInformationProcess by call to NtQueryInformationProcess.
	(get_process_state): Ditto.
	(get_mem_values): Ditto.  Replace call to ZwQueryVirtualMemory by
	call to NtQueryVirtualMemory.
	* ntdll.h: Cleanup.  Drop ZwQuerySystemInformation since
	NtQuerySystemInformation was already available.  Replace declarations
	of ZwXXX functions by declarations of NtXXX.
	* pinfo.cc (winpids::enumNT): Replace call to ZwQuerySystemInformation
	by call to NtQuerySystemInformation.
@
text
@d152 4
a155 1
    return NULL;
@


1.7
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d421 1
a421 1
	  ret = ZwQueryInformationProcess (hProcess,
d426 1
a426 1
	    ret = ZwQueryInformationProcess (hProcess,
d431 1
a431 1
	    ret = ZwQueryInformationProcess (hProcess,
d436 1
a436 1
	    ret = ZwQueryInformationProcess (hProcess,
d451 1
a451 1
	ret = ZwQuerySystemInformation (SystemTimeOfDayInformation,
d455 1
a455 1
	ret = ZwQuerySystemInformation (SystemProcessorTimes,
d632 1
a632 1
	 (ret = ZwQuerySystemInformation (SystemProcessesAndThreadsInformation,
d708 1
a708 1
  while ((ret = ZwQueryVirtualMemory (hProcess, 0,
d737 1
a737 1
  ret = ZwQueryInformationProcess (hProcess,
@


1.6
log
@* fhandler.h (fhandler_virtual::exists): Eliminate path argument.
(fhandler_proc::exists): Ditto.
(fhandler_registry::exists): Ditto.
(fhandler_process::exists): Ditto.
* fhandler_proc.cc (fhandler_proc::exists): Ditto.  Use built-in name.
* fhandler_process.cc (fhandler_process::exists): Ditto.
(fstat): Ditto.
* fhandler_registry.cc (fhandler_registry::exists): Ditto.
(fhandler_registry::fstat): Ditto.
* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
* path.cc (path_conv::check): Ditto.  Add debugging.
* syscalls.cc (dup): Always call dup2 for error handling.
@
text
@d71 1
a71 1
                           unsigned long *vmdata, unsigned long *vmlib, unsigned long *vmshare);
d113 1
a113 1
        continue;
d116 1
a116 1
        goto found;
d155 1
a155 1
                  dir->__d_dirent->d_name);
d179 5
a183 5
        {
          set_errno (EEXIST);
          res = 0;
          goto out;
        }
d185 5
a189 5
        {
          set_errno (EISDIR);
          res = 0;
          goto out;
        }
d191 4
a194 4
        {
          flags |= O_DIROPEN;
          goto success;
        }
d201 2
a202 2
          (process_listing[i], path + 1, strlen (process_listing[i])))
        process_file_no = i;
d207 5
a211 5
        {
          set_errno (EROFS);
          res = 0;
          goto out;
        }
d213 5
a217 5
        {
          set_errno (ENOENT);
          res = 0;
          goto out;
        }
d230 1
a230 1
        continue;
d233 1
a233 1
        goto found;
d265 1
a265 1
        cfree(filebuf);
d277 30
a306 30
        if (!filebuf)
        filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
        int num;
        switch (fileid)
          {
          case PROCESS_PPID:
            num = saved_p->ppid;
            break;
          case PROCESS_UID:
            num = saved_p->uid;
            break;
          case PROCESS_PGID:
            num = saved_p->pgid;
            break;
          case PROCESS_SID:
            num = saved_p->sid;
            break;
          case PROCESS_GID:
            num = saved_p->gid;
            break;
          case PROCESS_CTTY:
            num = saved_p->ctty;
            break;
          default: // what's this here for?
            num = 0;
            break;
          }
        __small_sprintf (filebuf, "%d\n", num);
        filesize = strlen (filebuf);
        break;
d310 17
a326 17
        if (!filebuf)
        filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = MAX_PATH);
        if (saved_p->process_state & (PID_ZOMBIE | PID_EXITED))
          strcpy (filebuf, "<defunct>");
        else
          {
            mount_table->conv_to_posix_path (saved_p->progname, filebuf, 1);
            int len = strlen (filebuf);
            if (len > 4)
              {
                char *s = filebuf + len - 4;
                if (strcasecmp (s, ".exe") == 0)
                  *s = 0;
              }
          }
        filesize = strlen (filebuf);
        break;
d330 5
a334 5
        if (!filebuf)
        filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
        __small_sprintf (filebuf, "%d\n", saved_p->dwProcessId);
        filesize = strlen (filebuf);
        break;
d338 7
a344 7
        int len = strlen (saved_p->progname);
        if (!filebuf)
        filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = (len + 2));
        strcpy (filebuf, saved_p->progname);
        filebuf[len] = '\n';
        filesize = len + 1;
        break;
d348 4
a351 4
        if (!filebuf)
          filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
        filesize = format_process_status (saved_p, filebuf, bufalloc);
        break;
d355 4
a358 4
        if (!filebuf)
          filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
        filesize = format_process_stat (saved_p, filebuf, bufalloc);
        break;
d362 4
a365 4
        if (!filebuf)
          filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
        filesize = format_process_statm (saved_p, filebuf, bufalloc);
        break;
d377 3
a379 3
                utime = 0UL, stime = 0UL,
                start_time = 0UL,
                vmsize = 0UL, vmrss = 0UL, vmmaxrss = 0UL;
d388 1
a388 1
        strcpy (cmd, last_slash + 1);
d391 5
a395 5
        {
          char *s = cmd + len - 4;
          if (strcasecmp (s, ".exe") == 0)
            *s = 0;
         }
d418 1
a418 1
                              FALSE, p->dwProcessId);
d420 22
a441 22
        {
          ret = ZwQueryInformationProcess (hProcess,
                                           ProcessVmCounters,
                                           (PVOID) &vmc,
                                           sizeof vmc, NULL);
          if (ret == STATUS_SUCCESS)
            ret = ZwQueryInformationProcess (hProcess,
                                             ProcessTimes,
                                             (PVOID) &put,
                                             sizeof put, NULL);
          if (ret == STATUS_SUCCESS)
            ret = ZwQueryInformationProcess (hProcess,
                                             ProcessBasicInformation,
                                             (PVOID) &pbi,
                                             sizeof pbi, NULL);
          if (ret == STATUS_SUCCESS)
            ret = ZwQueryInformationProcess (hProcess,
                                             ProcessQuotaLimits,
                                             (PVOID) &ql,
                                             sizeof ql, NULL);
          CloseHandle (hProcess);
        }
d443 7
a449 7
        {
          DWORD error = GetLastError ();
          __seterrno_from_win_error (error);
          debug_printf("OpenProcess: ret = %d",
                        error);
          return 0;
        }
d451 3
a453 3
        ret = ZwQuerySystemInformation (SystemTimeOfDayInformation,
                                        (PVOID) &stodi,
                                        sizeof stodi, NULL);
d455 3
a457 3
        ret = ZwQuerySystemInformation (SystemProcessorTimes,
                                        (PVOID) &spt,
                                        sizeof spt, NULL);
d459 7
a465 7
        {
          __seterrno_from_win_error (RtlNtStatusToDosError (ret));
          debug_printf("NtQueryInformationProcess: ret = %d, "
                       "Dos(ret) = %d",
                       ret, RtlNtStatusToDosError (ret));
          return 0;
        }
d470 4
a473 4
         start_time = (spt.InterruptTime.QuadPart + spt.KernelTime.QuadPart +
                       spt.IdleTime.QuadPart + spt.UserTime.QuadPart +
                       spt.DpcTime.QuadPart - stodi.CurrentTime.QuadPart +
                       put.CreateTime.QuadPart) / 100000ULL;
d475 8
a482 8
         /*
          * sometimes stodi.CurrentTime is a bit behind
          * Note: some older versions of procps are broken and can't cope
          * with process start times > time(NULL).
          */
         start_time = (spt.InterruptTime.QuadPart + spt.KernelTime.QuadPart +
                       spt.IdleTime.QuadPart + spt.UserTime.QuadPart +
                       spt.DpcTime.QuadPart) / 100000ULL;
d494 14
a507 14
                                   "%d %d %d %d %d "
                                   "%lu %lu %lu %lu %lu %lu %lu "
                                   "%ld %ld %ld %ld %ld %ld "
                                   "%lu %lu "
                                   "%ld "
                                   "%lu",
                          p->pid, cmd,
                          state,
                          p->ppid, p->pgid, p->sid, p->ctty, -1,
                          0, fault_count, fault_count, 0, 0, utime, stime,
                          utime, stime, priority, 0, 0, 0,
                          start_time, vmsize,
                          vmrss, vmmaxrss
                          );
d518 1
a518 1
                vmshare = 0UL;
d526 1
a526 1
        strcpy (cmd, last_slash + 1);
d529 5
a533 5
        {
          char *s = cmd + len - 4;
          if (strcasecmp (s, ".exe") == 0)
            *s = 0;
         }
d567 1
a567 1
        return 0;
d573 26
a598 26
                                   "State:  %c (%s)\n"
                                   "Tgid:   %d\n"
                                   "Pid:    %d\n"
                                   "PPid:   %d\n"
                                   "Uid:    %d %d %d %d\n"
                                   "Gid:    %d %d %d %d\n"
                                   "VmSize: %8d kB\n"
                                   "VmLck:  %8d kB\n"
                                   "VmRSS:  %8d kB\n"
                                   "VmData: %8d kB\n"
                                   "VmStk:  %8d kB\n"
                                   "VmExe:  %8d kB\n"
                                   "VmLib:  %8d kB\n"
                                   "SigPnd: %016x\n"
                                   "SigBlk: %016x\n"
                                   "SigIgn: %016x\n",
                          cmd,
                          state, state_str,
                          p->pgid,
                          p->pid,
                          p->ppid,
                          p->uid, cygheap->user.real_uid, cygheap->user.real_uid, p->uid,
                          p->gid, cygheap->user.real_gid, cygheap->user.real_gid, p->gid,
                          vmsize >> 10, 0, vmrss >> 10, vmdata >> 10, 0, vmtext >> 10, vmlib >> 10,
                          0, 0, p->getsigmask ()
                          );
d606 1
a606 1
                vmshare = 0UL;
d610 1
a610 1
        return 0;
d613 2
a614 2
                          vmsize, vmrss, vmshare, vmtext, vmlib, vmdata, 0
                          );
d632 3
a634 3
         (ret = ZwQuerySystemInformation (SystemProcessesAndThreadsInformation,
                                         (PVOID) p,
                                         n * sizeof *p, NULL)))
d639 2
a640 2
                   "Dos(ret) = %d",
                   ret, RtlNtStatusToDosError (ret));
d648 28
a675 28
        {
          SYSTEM_THREADS *st;
          if (wincap.has_process_io_counters ())
            /*
             * Windows 2000 and XP have an extra member in SYSTEM_PROCESSES
             * which means the offset of the first SYSTEM_THREADS entry is
             * different on these operating systems compared to NT 4.
             */
            st = &sp->Threads[0];
          else
            /*
             * 136 is the offset of the first SYSTEM_THREADS entry on
             * Windows NT 4.
             */
            st = (SYSTEM_THREADS *) ((char *) sp + 136);
          state = 'S';
          for (unsigned i = 0; i < sp->ThreadCount; i++)
            {
              if (st->State == StateRunning ||
                  st->State == StateReady)
                {
                  state = 'R';
                  goto out;
                }
              st++;
            }
          break;
        }
d677 1
a677 1
         break;
d688 1
a688 1
               unsigned long *vmdata, unsigned long *vmlib, unsigned long *vmshare)
d699 1
a699 1
                          FALSE, dwProcessId);
d705 1
a705 1
                    error);
d709 5
a713 5
                                      MemoryWorkingSetList,
                                      (PVOID) p,
                                      n * sizeof *p, &length)),
         (ret == STATUS_SUCCESS || ret == STATUS_INFO_LENGTH_MISMATCH) &&
         length >= n * sizeof *p)
d718 2
a719 2
                   "Dos(ret) = %d",
                   ret, RtlNtStatusToDosError (ret));
d729 1
a729 1
          ++*vmlib;
d731 1
a731 1
          ++*vmshare;
d733 1
a733 1
          ++*vmtext;
d735 1
a735 1
          ++*vmdata;
d738 3
a740 3
                                   ProcessVmCounters,
                                   (PVOID) &vmc,
                                   sizeof vmc, NULL);
d744 2
a745 2
                   "Dos(ret) = %d",
                   ret, RtlNtStatusToDosError (ret));
@


1.5
log
@* autoload.cc: Add dynamic load statements for 'ZwQueryInformationProcess' and
'ZwQueryVirtualMemory'.
* fhandler.h: Change type of bufalloc and filesize members of fhandler_virtual
from int to size_t.  Change type of position member from __off32_t to
__off64_t.  Add new fileid member to fhandler_virtual class.  Make seekdir take
an __off64_t argument.  Make lseek take an __off64_t argument.  Add
fill_filebuf method to fhandler_virtual.  Add fill_filebuf method to
fhandler_proc.  Add fill_filebuf method to fhandler_registry.  Add fill_filebuf
method to fhandler_process.  Add saved_pid and saved_p members to
fhandler_process.
* fhandler_proc.cc (proc_listing_array): Add 'loadavg', 'meminfo', and 'stat'.
(proc_fhandlers array): Ditto.
(fhandler_proc::open): Use fill_filebuf to flesh out the file contents.
(fhandler_proc::fill_filebuf): New method.
(fhandler_proc::format_proc_meminfo): Ditto.
(fhandler_proc::format_proc_stat): Ditto.
(fhandler_proc::format_proc_uptime): Ditto.
* fhandler_process.cc (process_listing): Add 'stat' and 'statm'.
(fhandler_process::fstat): Find the _pinfo structure for the process named in
the filename.  Return ENOENT if the process is no longer around.  Set the gid
and uid fields of the stat structure.
(fhandler_process::open): Store pid and pointer to _pinfo structure in
saved_pid and saved_p respectively.  Use fill_filebuf to flesh out file
contents.
(fhandler_proc::fill_filebuf): New method.
(format_process_stat): New function.
(format_process_status): Ditto.
(format_process_statm): Ditto.
(get_process_state): Ditto.
(get_mem_values): Ditto.
* fhandler_registry.cc (fhandler_registry::seekdir): Change argument type from
__off32_t to __off64_t.
(fhandler_registry::fill_filebuf): New method.
* fhandler_virtual.cc (fhandler_virtual::seekdir): Change argument type from
__off32_t to __off64_t.
(fhandler_virtual::lseek): Ditto.
(fhandler_virtual::fill_filebuf): New method.
(fhandler_virtual::fhandler_virtual): Initialise fileid to -1.
* wincap.cc: Set flag has_process_io_counters appropriately.
* wincap.h: Add flag has_process_io_counters.
@
text
@d77 1
a77 1
fhandler_process::exists (const char *path)
d79 1
d102 1
a102 1
  int file_type = exists (path);
@


1.4
log
@* net.cc (getdomainname): Change second argument of getdomainname to size_t.
* fhandler_proc.cc (proc_listing): Add '.' and '..' to directory listing.
(fhandler_proc::open): Change use of mode to flags.  If the file does not exist
already, fail with EROFS if O_CREAT flag is set.  Change EROFS error to EACCES
error when writing to a file.  Use cmalloc to allocate memory for filebuf.
(fhandler_proc::close): Use cfree to free filebuf.
(fhandler_proc::get_proc_fhandler): Properly detect attempts to access unknown
subdir.
* fhandler_process.cc (process_listing): Add '.' and '..' to directory listing.
(fhandler_process::open): Use cmalloc to allocate memory for filebuf.
(fhandler_process::close): Use cfree to free filebuf.
* fhandler_registry.cc (registry_listing): Add .  and '..' to directory
listing.
(fhandler_registry::open): Move check for open for writing before open_key.
Use cmalloc to allocate memory for filebuf.
(fhandler_registry::close): Use cfree to free filebuf.
(fhandler_registry::telldir): Use lower 16 bits of __d_position as position in
directory.
(fhandler_registry::seekdir): Ditto.
* fhandler_virtual.cc (fhandler_virtual::write): Change EROFS error to EACCES
error.
(fhandler_virtual::open): Set the NOHANDLE flag.
(fhandler_virtual::dup): Add call to fhandler_base::dup.  Allocate child's
filebuf using cmalloc.  Copy filebuf from parent to child.
(fhandler_virtual::close): Use cfree to free filebuf.
(fhandler_virtual::~fhandler_virtual): Ditto.
(from Chris Faylor <cgf@@redhat.com>).
(fhandler_registry::readdir): Add support for '.' and '..' files in
subdirectories of /proc/registry.
* path.cc (path_conv::check): Do not return ENOENT if a file is not found in
/proc.
@
text
@d17 1
d27 1
d43 2
d59 2
d66 7
d100 2
a101 1
  int file_type = exists (get_name ());
d103 17
d131 4
d140 3
a142 1
      buf->st_mode |= S_IFREG;
d238 30
a267 1
  switch (process_file_no)
d276 1
d279 1
a279 1
        switch (process_file_no)
d282 1
a282 1
            num = p->ppid;
d285 1
a285 1
            num = p->uid;
d288 1
a288 1
            num = p->pgid;
d291 4
a294 1
            num = p->sid;
a295 1
	  default:
d297 4
a300 1
            num = p->ctty;
d309 1
d311 1
a311 1
        if (p->process_state & (PID_ZOMBIE | PID_EXITED))
d315 1
a315 1
            mount_table->conv_to_posix_path (p->progname, filebuf, 1);
d329 1
d331 1
a331 1
        __small_sprintf (filebuf, "%d\n", p->dwProcessId);
d337 2
a338 1
        int len = strlen (p->progname);
d340 1
a340 1
        strcpy (filebuf, p->progname);
d347 3
a349 11
        filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 3);
        filebuf[0] = ' ';
        filebuf[1] = '\n';
        filebuf[2] = 0;
        if (p->process_state & PID_STOPPED)
          filebuf[0] = 'S';
        else if (p->process_state & PID_TTYIN)
          filebuf[0] = 'I';
        else if (p->process_state & PID_TTYOU)
          filebuf[0] = 'O';
        filesize = 2;
d352 135
d488 20
d509 11
a519 2
  if (flags & O_APPEND)
    position = filesize;
d521 162
a682 1
    position = 0;
d684 65
a748 4
success:
  res = 1;
  set_open_status ();
  set_flags (flags);
d750 2
a751 1
  syscall_printf ("%d = fhandler_proc::open (%p, %d)", res, flags, mode);
@


1.3
log
@* fhandler_proc.cc (fhandler_proc::fstat): Use fhandler name rather than
path_conv name.
(fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::fstat): Use fhandler name rather than
path_conv name.
(fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::fstat): Use fhandler name rather
than path_conv name.
(fhandler_registry::open): Ditto.
* path.cc (path_conv::check): Don't copy posix path when virtual.
(mount_info::conv_to_win32_path): Don't zero string when isproc.  Just derive
normal windows path.
* path.h (path_conv::clear_normalized_path): Declare new method.
* path.cc (path_conv::clear_normalized_path): Define new method.
* dtable.cc (build_fhandler_from_name): Clear normalized path when finished to
conserve space.
@
text
@d24 2
d31 10
a40 10
static const int PROCESS_PPID = 0;
static const int PROCESS_EXENAME = 1;
static const int PROCESS_WINPID = 2;
static const int PROCESS_WINEXENAME = 3;
static const int PROCESS_STATUS = 4;
static const int PROCESS_UID = 5;
static const int PROCESS_GID = 6;
static const int PROCESS_PGID = 7;
static const int PROCESS_SID = 8;
static const int PROCESS_CTTY = 9;
d43 2
d140 1
a140 1
      if ((mode & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
d146 1
a146 1
      else if (mode & O_WRONLY)
d168 1
a168 1
      if ((mode & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
d181 1
a181 1
  if (mode & O_WRONLY)
d210 1
a210 1
        filebuf = new char[bufalloc = 40];
d237 1
a237 1
        filebuf = new char[bufalloc = MAX_PATH];
d256 1
a256 1
        filebuf = new char[bufalloc = 40];
d264 1
a264 1
        filebuf = new char[len + 2];
d272 1
a272 1
        filebuf = new char[bufalloc = 3];
@


1.2
log
@* fhandler_proc.cc (fhandler_proc::fstat): Prime with information from
fhandler_base::fstat.  Use defines rather than constants for permission
settings.
@
text
@d83 1
a83 1
  int file_type = exists ((const char *) get_name ());
d129 1
a129 1
  path = (const char *) *pc + proc_len + 1;
@


1.1
log
@add new files
@
text
@d81 1
a81 1
fhandler_process::fstat (struct __stat64 *buf, path_conv *path)
d84 3
d93 1
a93 2
      buf->st_mode = S_IFDIR | 0555;
      buf->st_nlink = 1;
d96 1
a96 1
      buf->st_mode = S_IFDIR | 0555;
d101 1
a101 2
      buf->st_mode = S_IFREG | 0444;
      buf->st_nlink = 1;
@

