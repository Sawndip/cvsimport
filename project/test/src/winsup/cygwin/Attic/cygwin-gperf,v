head	1.5;
access;
symbols
	pre-sigrewrite:1.4
	corinna-01:1.4
	cgf-dev-branch:1.1.0.2;
locks; strict;
comment	@# @;


1.5
date	2003.11.28.20.55.58;	author cgf;	state dead;
branches;
next	1.4;

1.4
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.16.01.55.51;	author cgf;	state dead;
branches;
next	1.2;

1.2
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.29.06.14.13;	author cgf;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.12.29.06.14.13;	author cgf;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.02.01.18.42.23;	author cgf;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.02.05.14.25.06;	author cgf;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.02.23.06.00.21;	author cgf;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.02.23.07.03.22;	author cgf;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.02.27.15.10.22;	author cgf;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2003.03.02.23.39.10;	author cgf;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2003.03.09.18.15.57;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@#!/usr/bin/perl
use strict;
sub read_devices($%);
my $infile = shift;
my $incfile = shift;
open(GPERF, "gperf  -c --key-positions='5-8,1-2,9-10' -r -t -C -E " .
            "-T -L 'ANSI-C' -Hdevhash -N'device::lookup' -Z devstring " .
	    "-7 -G $infile |");
my @@lines = <GPERF>;
my $ix = 0;
my $i = 0;
my $n = -1;
my $findclose = 0;
my $add_device = '';
my %fh_static;
my %fh_declare = (
    'cygdrive' => 'dev_cygdrive_storage',
    'fs' => 'dev_fs_storage',
    'proc' => 'dev_proc_storage',
    'registry' => 'dev_registry_storage',
    'process' => 'dev_process_storage',
    'piper' => 'dev_piper_storage',
    'pipew' => 'dev_pipew_storage',
    'tcp' => 'dev_tcp_storage',
    'udp' => 'dev_udp_storage',
    'icmp' => 'dev_icmp_storage',
    'unix' => 'dev_unix_storage',
    'stream' => 'dev_stream_storage',
    'dgram' => 'dev_dgram_storage'
);

foreach (@@lines) {
    $i++;
    s/\[(str\[[^\]]*\])\]/[(unsigned) cyg_tolower ($1)]/o and next;
    s/static (.* )wordlist/static NO_COPY $1wordlist/o and do {
	$findclose = 1;
    };
    s/([   ]*)if \(\*str.*$/$1if (strncasematch (str, s, len))/o and next;
    $findclose and /};/o and do {
        $_ .= "\n";
	$_ .=<<'EOF';
const device dev_cygdrive_storage =
  {"/cygdrive", FH_CYGDRIVE, "/cygdrive", 0, 0, 0, 0};

const device dev_fs_storage =
  {"", FH_FS, "", 0, 0, 0, 0};

const device dev_proc_storage =
  {"", FH_PROC, "", 0, 0, 0, 0};

const device dev_registry_storage =
  {"", FH_REGISTRY, "", 0, 0, 0, 0};

const device dev_process_storage =
  {"", FH_PROCESS, "", 0, 0, 0, 0};

const device dev_tcp_storage =
  {"/dev/inet/tcp", FH_TCP, "", 0, 0, 0, 0};

const device dev_udp_storage =
  {"/dev/inet/udp", FH_UCP, "", 0, 0, 0, 0};

const device dev_icmp_storage =
  {"/dev/inet/icmp", FH_ICMP, "", 0, 0, 0, 0};

const device dev_unix_storage =
  {"/dev/inet/unix", FH_UNIX, "", 0, 0, 0, 0};

const device dev_stream_storage =
  {"/dev/inet/stream", FH_STREAM, "", 0, 0, 0, 0};

const device dev_dgram_storage =
  {"/dev/inet/dgram", FH_DGRAM, "", 0, 0, 0, 0};

const device dev_piper_storage =
  {"", FH_PIPER, "", 0, 0, 0, 0};

const device dev_pipew_storage =
  {"", FH_PIPEW, "", 0, 0, 0, 0};

const device dev_fs =
  {"", FH_FS, "", 0, 0, 0, 0};
EOF
        for my $f (sort keys %fh_declare) {
	    $_ .= 'const device dev_' . $f . "_storage = $fh_declare{$f};\n"
	      if $fh_declare{$f} !~ /_storage/;
	}
	$_ .= "\n";
	$_ .= read_devices($incfile, %fh_declare);
	$findclose = 0;
    };
    /^(\s+)(\{".*)/ or next;
    my $indent = $1;
    my $rest = $2;
    for my $f ($rest =~ /\{([^}]+)\}/g) {
	$f eq '""' and do {
	    $ix++;
	    next;
	};
	my ($str, $fh) = (split(/, /, $f))[0..1];
	if ($str !~ m!^"(?:/dev|:bad:)!) {
	    $ix++;
	} else {
	    my $what = lc(($fh =~ /FH_(.+)/o)[0]);
	    my $addon = '';
	    while (defined $fh_static{$what . $addon} &&
		   $fh_static{$what . $addon} ne $f) {
		$addon++;
	    }
	    $what .= $addon;
	    $fh_static{$what} = $f;
	    $fh_declare{$what} = "wordlist[$ix]";
	    $ix++;
	}
    }
}

print @@lines;

sub read_devices($%) {
    my $fn = shift;
    my %fh_declare = @@_;
    open(F, "$fn") or die "$0: couldn't open $fn - $!\n";
    my (%dev, %fh);
    local $_;
    while (<F>) {
	/^\s*DEV_([A-Z_0-9]+)_MAJOR\s*=\s*(\d+)/ and do {
	    my $dev = lc($1);
	    next unless $fh_declare{$dev};
	    my $a = sprintf "%08d", $2;
	    $dev{$2} = '&' . $fh_declare{$dev} . " /* \L$1 */";
	    next;
	};
	/^\s*FH_([A-Z_0-9]+)\s*=\s*FHDEV\s*\((\d+),\s*(\d+)\)/ and do {
	      my $a = sprintf "%08d.%08d", $2, $3;
	      $fh{$a} = '&' . $fh_declare{lc($1)} . " /* \L$1 */";
	};
    };
    close F;
    my $toprint = '';
    $toprint = "const device *unit_devices[] =\n{";
    for my $f (sort keys %dev) {
	$toprint .= "\n  $dev{$f}," if length($dev{$f});
    }
    chop $toprint;
    $toprint .= "\n};\n\nconst device *uniq_devices[] = \n{";
    for my $f (sort keys %fh) {
	$toprint .= "\n  $fh{$f},";
    }
    chop $toprint;
    $toprint .= "\n};\n";
    return $toprint;
}
@


1.4
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@@


1.3
log
@remove errnoneously added files
@
text
@d6 1
a6 1
open(GPERF, "gperf  -c --key-positions='1-2,5-7,9-10' -r -t -C -E " .
d17 13
a29 5
    'cygdrive_dev' => '&cygdrive_dev_storage',
    'fs_dev' => '&fs_dev_storage',
    'proc_dev' => '&proc_dev_storage',
    'registry_dev' => '&registry_dev_storage',
    'process_dev' => '&process_dev_storage'
d42 1
a42 1
static const device cygdrive_dev_storage =
d45 2
a46 2
static const device fs_dev_storage =
  {"", FH_CYGDRIVE, "", 0, 0, 0, 0};
d48 1
a48 1
static const device proc_dev_storage =
d51 1
a51 1
static const device registry_dev_storage =
d54 1
a54 1
static const device process_dev_storage =
d57 26
d85 2
a86 1
	    $_ .= "const device *$f = $fh_declare{$f};\n";
d101 1
a101 1
	if ($str !~ "/dev") {
d104 1
a104 1
	    my $what = lc(($fh =~ /FH_(.+)/o)[0]) . '_dev' ;
d112 1
a112 1
	    $fh_declare{$what} = "wordlist + $ix";
d128 2
d131 1
a131 1
	    $dev{$2} = $fh_declare{lc($1) . '_dev'} . " /* \L$1 */";
d136 1
a136 1
	      $fh{$a} = $fh_declare{lc($1) . '_dev'} . " /* \L$1 */";
d143 1
a143 1
	$toprint .= "\n  $dev{$f},";
@


1.2
log
@merge from trunk
@
text
@@


1.1
log
@file cygwin-gperf was initially added on branch cgf-dev-branch.
@
text
@d1 116
@


1.1.2.1
log
@* cygwin-gperf: New file.
* Makefile.in: Use cygwin-gperf script to build devices.cc.
* configure.in: Remove some comments.
* configure: Regenerate.
* devices.gperf: Remove max unit determination from FH_TTY.  Add /dev/kmem.
Add /dev/fifo.  Add /dev/rawdrive.  Remove specific "const device *"
declarations since they are now autogenerated.
(device::parse): Treat FH_TTY specially.  Move logic for determining real tty
device to separate function.
(device::init): Reduce to nothing.
(device::parse): New function taking different arguments.
(device::parse): Ditto.
(device::tty_to_real_device): New function.
* devices.h (struct device): Define above new functions.
(device::dev_on_fs): New element.
(device::setfs): New function.
(device::isfs): Ditto.
* dtable.cc (dtable::build_fhandler): Treat FH_TTY specially.
* fhandler.cc (fhandler_base::set_name): Make special determination for
non-disk-resident devices.
* fhandler.h (fhandler_base::isdevice): Renamed from 'is_device'.
(fhandler_disk_file::isdevice): Ditto.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_device): New function.
(fhandler_tty_slave::get_unit): Declare.
(fhandler_disk_file::readdir): Take special .lnk consideration for devices as
well as symlinks.
* fhandler_tty.cc: Use get_unit () rather than dev.minor throughout.
(fhandler_tty_slave::get_unit): Define new function.
* path.cc (symlink_info::major): New element.
(symlink_info::major): Ditto.
(symlink_info::devtype): Ditto.
(path_conv::check): Handle devices detected by symlink_info::check.
(win32_device_name): Eliminate special FH_TTY handling.
(symlink): Move bulk of procesing to symlink_worker.
(symlink_worker): New function.  Handles devices.
(symlink_info::parse_device): Parse info from potential device file into
symlink_info elements.
(symlink_info::check): If contents of .lnk file begin with a ':' then treat the
file as a device file.
* path.h (isdevice): Renamed from is_device.
(is_auto_device): New function.
(is_fs_device): Ditto.
* syscalls.cc (chown_worker): Allow setting of ownership for on-disk devices.
(chmod): Ditto.
(mknod): Implement.
* winsup.h (symlink_worker): Declare.
@
text
@a0 116
#!/usr/bin/perl
use strict;
sub read_devices($%);
my $infile = shift;
my $incfile = shift;
open(GPERF, "gperf  -c --key-positions='1-2,5-7,9-10' -r -t -C -E " .
            "-T -L 'ANSI-C' -Hdevhash -N'device::lookup' -Z devstring " .
	    "-7 -G $infile |");
my @@lines = <GPERF>;
my $ix = 0;
my $i = 0;
my $n = -1;
my $findclose = 0;
my $add_device = '';
my %fh_static;
my %fh_declare = (
    'cygdrive_dev' => '&cygdrive_dev_storage',
    'fs_dev' => '&fs_dev_storage',
    'proc_dev' => '&proc_dev_storage',
    'registry_dev' => '&registry_dev_storage',
    'process_dev' => '&process_dev_storage'
);

foreach (@@lines) {
    $i++;
    s/\[(str\[[^\]]*\])\]/[(unsigned) cyg_tolower ($1)]/o and next;
    s/static (.* )wordlist/static NO_COPY $1wordlist/o and do {
	$findclose = 1;
    };
    s/([   ]*)if \(\*str.*$/$1if (strncasematch (str, s, len))/o and next;
    $findclose and /};/o and do {
        $_ .= "\n";
	$_ .=<<'EOF';
static const device cygdrive_dev_storage =
  {"/cygdrive", FH_CYGDRIVE, "/cygdrive", 0, 0, 0, 0};

static const device fs_dev_storage =
  {"", FH_CYGDRIVE, "", 0, 0, 0, 0};

static const device proc_dev_storage =
  {"", FH_PROC, "", 0, 0, 0, 0};

static const device registry_dev_storage =
  {"", FH_REGISTRY, "", 0, 0, 0, 0};

static const device process_dev_storage =
  {"", FH_PROCESS, "", 0, 0, 0, 0};

EOF
        for my $f (sort keys %fh_declare) {
	    $_ .= "const device *$f = $fh_declare{$f};\n";
	}
	$_ .= "\n";
	$_ .= read_devices($incfile, %fh_declare);
	$findclose = 0;
    };
    /^(\s+)(\{".*)/ or next;
    my $indent = $1;
    my $rest = $2;
    for my $f ($rest =~ /\{([^}]+)\}/g) {
	$f eq '""' and do {
	    $ix++;
	    next;
	};
	my ($str, $fh) = (split(/, /, $f))[0..1];
	if ($str !~ "/dev") {
	    $ix++;
	} else {
	    my $what = lc(($fh =~ /FH_(.+)/o)[0]) . '_dev' ;
	    my $addon = '';
	    while (defined $fh_static{$what . $addon} &&
		   $fh_static{$what . $addon} ne $f) {
		$addon++;
	    }
	    $what .= $addon;
	    $fh_static{$what} = $f;
	    $fh_declare{$what} = "wordlist + $ix";
	    $ix++;
	}
    }
}

print @@lines;

sub read_devices($%) {
    my $fn = shift;
    my %fh_declare = @@_;
    open(F, "$fn") or die "$0: couldn't open $fn - $!\n";
    my (%dev, %fh);
    local $_;
    while (<F>) {
	/^\s*DEV_([A-Z_0-9]+)_MAJOR\s*=\s*(\d+)/ and do {
	    my $a = sprintf "%08d", $2;
	    $dev{$2} = $fh_declare{lc($1) . '_dev'} . " /* \L$1 */";
	    next;
	};
	/^\s*FH_([A-Z_0-9]+)\s*=\s*FHDEV\s*\((\d+),\s*(\d+)\)/ and do {
	      my $a = sprintf "%08d.%08d", $2, $3;
	      $fh{$a} = $fh_declare{lc($1) . '_dev'} . " /* \L$1 */";
	};
    };
    close F;
    my $toprint = '';
    $toprint = "const device *unit_devices[] =\n{";
    for my $f (sort keys %dev) {
	$toprint .= "\n  $dev{$f},";
    }
    chop $toprint;
    $toprint .= "\n};\n\nconst device *uniq_devices[] = \n{";
    for my $f (sort keys %fh) {
	$toprint .= "\n  $fh{$f},";
    }
    chop $toprint;
    $toprint .= "\n};\n";
    return $toprint;
}
@


1.1.2.2
log
@merge from trunk
@
text
@d6 1
a6 1
open(GPERF, "gperf  -c --key-positions='5-8,1-2,9-10' -r -t -C -E " .
@


1.1.2.3
log
@merge from trunk
@
text
@a92 2
	    my $dev = lc($1) . '_dev';
	    next unless $fh_declare{$dev};
d94 1
a94 1
	    $dev{$2} = $fh_declare{$dev} . " /* \L$1 */";
d106 1
a106 1
	$toprint .= "\n  $dev{$f}," if length($dev{$f});
@


1.1.2.4
log
@merge from trunk
@
text
@d66 1
a66 1
	if ($str !~ m!^"(?:/dev|:bad:)!) {
@


1.1.2.5
log
@* cygwin-gperf: Fix typo in FH_FS static storage.
* devices.gperf (device::parse): Default to fs "device" when nothing else is
found.
* fhandler.cc (fhandler_base::device_access_denied): Use access_worker rather
than access to avoid reparsing pc.
* fhandler_nodevice.cc (fhandler_nodevice::open): Set errno to ENXIO rather
than ENODEV.
* path.cc (path_conv::check): Default to FH_FS rather than FH_BAD.
(mount_info::conv_to_win32_path): Ditto.
(win32_device_name): Don't do device handling if FH_FS.
* path.h (path_conv::get_devn): Just return raw device number.
* syscalls.cc (access_worker): New function, split from access().  Correctly
deal with special devices in light of recent ntsec changes.
(access): Use access_worker.
@
text
@d38 1
a38 1
  {"", FH_FS, "", 0, 0, 0, 0};
@


1.1.2.6
log
@merge from trunk
@
text
@d21 1
a21 4
    'process_dev' => '&process_dev_storage',
    'piper_dev' => '&piper_dev_storage',
    'pipew_dev' => '&pipew_dev_storage',
    'socket_dev' => '&socket_dev_storage'
a47 9

static const device socket_dev_storage =
  {"", FH_SOCKET, "", 0, 0, 0, 0};

static const device piper_dev_storage =
  {"", FH_PIPER, "", 0, 0, 0, 0};

static const device pipew_dev_storage =
  {"", FH_PIPEW, "", 0, 0, 0, 0};
@


1.1.2.7
log
@Merge from trunk.
* Makefile.in (devicess.cc): Make generation dependent on cygwin-gperf.
* cygheap.h (cygheap_fdmanip): Add fhandler_socket cast.
* cygwin-gperf: Autogenerate references to network devices.
* devices.h: Create separate device types for all network types.  Export
references to global network device storage.
* dtable.cc (dtable::release): Use generic determination to control when
need_fixup_before needs to be decremented.
(dtable::init_std_file_from_handle): Replace use of 'socket_dev' with
'tcp_dev'.
(build_fh_pc): Adapt to new socket types.  Don't increment fixup_before here.
* fhandler.h (fhandler_base::need_fixup_before): Declare/define.
(fhandler_socket::need_fixup_before): Ditto.
* fhandler_socket.cc (fhandler_socket::accept): Accommodate new fdsock
definition.
* net.cc: Throughout, change use of fdsock to return true/false for
success/failure and take cygheap_fdmanip type and device
* select.cc (set_bits): Use 'is_socket ()' test rather than specificially
testing device type.
@
text
@d24 1
a24 6
    'tcp_dev' => '&tcp_dev_storage',
    'udp_dev' => '&udp_dev_storage',
    'icmp_dev' => '&icmp_dev_storage',
    'unix_dev' => '&unix_dev_storage',
    'stream_dev' => '&stream_dev_storage',
    'dgram_dev' => '&dgram_dev_storage'
d52 2
a53 17
static const device tcp_dev_storage =
  {"/dev/inet/tcp", FH_TCP, "", 0, 0, 0, 0};

static const device udp_dev_storage =
  {"/dev/inet/udp", FH_UCP, "", 0, 0, 0, 0};

static const device icmp_dev_storage =
  {"/dev/inet/icmp", FH_ICMP, "", 0, 0, 0, 0};

static const device unix_dev_storage =
  {"/dev/inet/unix", FH_UNIX, "", 0, 0, 0, 0};

static const device stream_dev_storage =
  {"/dev/inet/stream", FH_STREAM, "", 0, 0, 0, 0};

static const device dgram_dev_storage =
  {"/dev/inet/dgram", FH_DGRAM, "", 0, 0, 0, 0};
@


1.1.2.8
log
@Merge from trunk.
* Makefile.in: Explicitly call perl to run cygwin-gperf.
* path.cc: Move some device stuff.
* cygwin-gperf: Define some device stuff.
* devices.h: Declare some device stuff.
@
text
@a80 2
static const device dev_fs =
  {"", FH_FS, "", 0, 0, 0, 0};
@


