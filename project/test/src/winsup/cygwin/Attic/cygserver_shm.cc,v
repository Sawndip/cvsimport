head	1.12;
access;
symbols
	Z-emcb-cygwin_daemon:1.11.0.2
	w32api-2_2:1.11
	mingw-runtime-2_4:1.11
	pre-cgf-merge:1.11
	cgf-dev-branch:1.11.0.16
	cygwin_daemon_merge_HEAD:1.1
	Z-cygwin_daemon_merge_HEAD:1.10
	Z-cygwin_daemon_merge-new_HEAD:1.10
	cygwin_daemon:1.1.0.2;
locks; strict;
comment	@// @;


1.12
date	2003.08.30.16.31.10;	author cgf;	state dead;
branches;
next	1.11;

1.11
date	2002.09.30.15.17.44;	author cgf;	state Exp;
branches
	1.11.16.1;
next	1.10;

1.10
date	2002.09.22.12.04.15;	author scottc;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.21.13.03.23;	author scottc;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.23.22.56.56;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.28.01.55.39;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.13.02.34.04;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.04.08.45.40;	author rbcollins;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.04.08.12.53;	author rbcollins;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.04.07.22.08;	author rbcollins;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.28.14.30.27;	author rbcollins;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.25.06.31.04;	author rbcollins;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.25.06.31.04;	author rbcollins;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.09.30.13.56.37;	author rbcollins;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.01.02.49.19;	author rbcollins;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.02.06.46.05;	author rbcollins;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.10.04.04.21.06;	author rbcollins;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2001.10.07.21.58.20;	author rbcollins;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2002.06.13.14.34.01;	author rbcollins;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2002.06.15.21.01.44;	author scottc;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2002.06.15.23.39.46;	author scottc;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2002.06.16.12.15.22;	author scottc;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2002.06.16.13.37.58;	author scottc;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2002.06.16.14.44.56;	author scottc;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2002.06.17.21.35.33;	author scottc;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2002.06.24.10.55.34;	author scottc;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	2002.06.24.12.31.24;	author scottc;	state Exp;
branches;
next	1.1.2.16;

1.1.2.16
date	2002.06.28.12.23.27;	author scottc;	state Exp;
branches;
next	1.1.2.17;

1.1.2.17
date	2002.06.28.18.04.02;	author scottc;	state Exp;
branches;
next	1.1.2.18;

1.1.2.18
date	2002.06.30.21.01.48;	author scottc;	state Exp;
branches;
next	1.1.2.19;

1.1.2.19
date	2002.06.30.21.19.56;	author scottc;	state Exp;
branches;
next	1.1.2.20;

1.1.2.20
date	2002.06.30.21.24.25;	author scottc;	state Exp;
branches;
next	1.1.2.21;

1.1.2.21
date	2002.07.03.02.40.49;	author scottc;	state Exp;
branches;
next	1.1.2.22;

1.1.2.22
date	2002.07.10.14.40.16;	author scottc;	state Exp;
branches;
next	1.1.2.23;

1.1.2.23
date	2002.07.11.13.22.13;	author scottc;	state Exp;
branches;
next	1.1.2.24;

1.1.2.24
date	2002.07.11.13.58.14;	author scottc;	state Exp;
branches;
next	1.1.2.25;

1.1.2.25
date	2002.07.11.21.40.05;	author scottc;	state Exp;
branches;
next	1.1.2.26;

1.1.2.26
date	2002.07.12.21.08.27;	author scottc;	state Exp;
branches;
next	1.1.2.27;

1.1.2.27
date	2002.07.27.01.16.35;	author scottc;	state Exp;
branches;
next	1.1.2.28;

1.1.2.28
date	2002.07.27.22.10.50;	author scottc;	state Exp;
branches;
next	1.1.2.29;

1.1.2.29
date	2002.07.27.23.01.01;	author scottc;	state Exp;
branches;
next	1.1.2.30;

1.1.2.30
date	2002.07.28.11.50.33;	author scottc;	state Exp;
branches;
next	1.1.2.31;

1.1.2.31
date	2002.09.21.09.52.33;	author scottc;	state Exp;
branches;
next	1.1.2.32;

1.1.2.32
date	2002.09.22.10.31.45;	author scottc;	state Exp;
branches;
next	1.1.2.33;

1.1.2.33
date	2002.09.22.10.54.38;	author scottc;	state Exp;
branches;
next	;

1.11.16.1
date	2003.09.02.02.31.07;	author cgf;	state dead;
branches;
next	;


desc
@@


1.12
log
@Remove some cygserver files.
@
text
@/* cygserver_shm.cc: Single unix specification IPC interface for Cygwin.

   Copyright 2002 Red Hat, Inc.

   Written by Conrad Scott <conrad.scott@@dsl.pipex.com>.
   Based on code by Robert Collins <robert.collins@@hotmail.com>.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "woutsup.h"

#include <errno.h>
#include <pthread.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "cygserver_ipc.h"
#include "cygserver_shm.h"
#include "security.h"

#include "cygwin/cygserver.h"
#include "cygwin/cygserver_process.h"
#include "cygwin/cygserver_transport.h"

/*---------------------------------------------------------------------------*
 * class server_shmmgr
 *
 * A singleton class.
 *---------------------------------------------------------------------------*/

#define shmmgr (server_shmmgr::instance ())

class server_shmmgr
{
private:
  class attach_t
  {
  public:
    class process *const _client;
    unsigned int _refcnt;

    attach_t *_next;

    attach_t (class process *const client)
      : _client (client),
	_refcnt (0),
	_next (NULL)
    {}
  };

  class segment_t
  {
  private:
    // Bits for the _flg field.
    enum { IS_DELETED = 0x01 };

  public:
    const int _intid;
    const int _shmid;
    struct shmid_ds _ds;

    segment_t *_next;

    segment_t (const key_t key, const int intid, const HANDLE hFileMap);
    ~segment_t ();

    bool is_deleted () const
    {
      return _flg & IS_DELETED;
    }

    bool is_pending_delete () const
    {
      return !_ds.shm_nattch && is_deleted ();
    }

    void mark_deleted ()
    {
      assert (!is_deleted ());

      _flg |= IS_DELETED;
    }

    int attach (class process *, HANDLE & hFileMap);
    int detach (class process *);

  private:
    static long _sequence;

    int _flg;
    const HANDLE _hFileMap;
    attach_t *_attach_head;	// A list sorted by winpid;

    attach_t *find (const class process *, attach_t **previous = NULL);
  };

  class cleanup_t : public cleanup_routine
  {
  public:
    cleanup_t (const segment_t *const segptr)
      : cleanup_routine (reinterpret_cast<void *> (segptr->_shmid))
    {
      assert (key ());
    }

    int shmid () const { return reinterpret_cast<int> (key ()); }

    virtual void cleanup (class process *const client)
    {
      const int res = shmmgr.shmdt (shmid (), client);

      if (res != 0)
	debug_printf ("process cleanup failed [shmid = %d]: %s",
		      shmid (), strerror (-res));
    }
  };

public:
  static server_shmmgr & instance ();

  int shmat (HANDLE & hFileMap,
	     int shmid, int shmflg, class process *);
  int shmctl (int & out_shmid, struct shmid_ds & out_ds,
	      struct shminfo & out_shminfo, struct shm_info & out_shm_info,
	      const int shmid, int cmd, const struct shmid_ds &,
	      class process *);
  int shmdt (int shmid, class process *);
  int shmget (int & out_shmid, key_t, size_t, int shmflg, uid_t, gid_t,
	      class process *);

private:
  static server_shmmgr *_instance;
  static pthread_once_t _instance_once;

  static void initialise_instance ();

  CRITICAL_SECTION _segments_lock;
  segment_t *_segments_head;	// A list sorted by int_id.

  int _shm_ids;			// Number of shm segments (for ipcs(8)).
  int _shm_tot;			// Total bytes of shm segments (for ipcs(8)).
  int _shm_atts;		// Number of attached segments (for ipcs(8)).
  int _intid_max;		// Highest intid yet allocated (for ipcs(8)).

  server_shmmgr ();
  ~server_shmmgr ();

  // Undefined (as this class is a singleton):
  server_shmmgr (const server_shmmgr &);
  server_shmmgr & operator= (const server_shmmgr &);

  segment_t *find_by_key (key_t);
  segment_t *find (int intid, segment_t **previous = NULL);

  int new_segment (key_t, size_t, int shmflg, pid_t, uid_t, gid_t);

  segment_t *new_segment (key_t, size_t, HANDLE);
  void delete_segment (segment_t *);
};

/* static */ long server_shmmgr::segment_t::_sequence = 0;

/* static */ server_shmmgr *server_shmmgr::_instance = NULL;
/* static */ pthread_once_t server_shmmgr::_instance_once = PTHREAD_ONCE_INIT;

/*---------------------------------------------------------------------------*
 * server_shmmgr::segment_t::segment_t ()
 *---------------------------------------------------------------------------*/

server_shmmgr::segment_t::segment_t (const key_t key,
				     const int intid,
				     const HANDLE hFileMap)
  : _intid (intid),
    _shmid (ipc_int2ext (intid, IPC_SHMOP, _sequence)),
    _next (NULL),
    _flg (0),
    _hFileMap (hFileMap),
    _attach_head (NULL)
{
  assert (0 <= _intid && _intid < SHMMNI);

  memset (&_ds, '\0', sizeof (_ds));
  _ds.shm_perm.key = key;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::segment_t::~segment_t ()
 *---------------------------------------------------------------------------*/

server_shmmgr::segment_t::~segment_t ()
{
  assert (!_attach_head);

  if (!CloseHandle (_hFileMap))
    syscall_printf ("failed to close file map [handle = 0x%x]: %E", _hFileMap);
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::segment_t::attach ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::segment_t::attach (class process *const client,
				  HANDLE & hFileMap)
{
  assert (client);

  if (!DuplicateHandle (GetCurrentProcess (),
			_hFileMap,
			client->handle (),
			&hFileMap,
			0,
			FALSE, // bInheritHandle
			DUPLICATE_SAME_ACCESS))
    {
      syscall_printf (("failed to duplicate handle for client "
		       "[key = 0x%016llx, shmid = %d, handle = 0x%x]: %E"),
		      _ds.shm_perm.key, _shmid, _hFileMap);

      return -EACCES;	// FIXME: Case analysis?
    }

  _ds.shm_lpid  = client->cygpid ();
  _ds.shm_nattch += 1;
  _ds.shm_atime = time (NULL); // FIXME: sub-second times.

  attach_t *previous = NULL;
  attach_t *attptr = find (client, &previous);

  if (!attptr)
    {
      attptr = safe_new (attach_t, client);

      if (previous)
	{
	  attptr->_next = previous->_next;
	  previous->_next = attptr;
	}
      else
	{
	  attptr->_next = _attach_head;
	  _attach_head = attptr;
	}
    }

  attptr->_refcnt += 1;

  cleanup_t *const cleanup = safe_new (cleanup_t, this);

  // FIXME: ::add should only fail if the process object is already
  // cleaning up; but it can't be doing that since this thread has it
  // locked.

  const bool result = client->add (cleanup);

  assert (result);

  return 0;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::segment_t::detach ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::segment_t::detach (class process *const client)
{
  attach_t *previous = NULL;
  attach_t *const attptr = find (client, &previous);

  if (!attptr)
    return -EINVAL;

  if (client->is_active ())
    {
      const cleanup_t key (this);

      if (!client->remove (&key))
	syscall_printf (("failed to remove cleanup routine for %d(%lu) "
			 "[shmid = %d]"),
			client->cygpid (), client->winpid (),
			_shmid);
    }

  attptr->_refcnt -= 1;

  if (!attptr->_refcnt)
    {
      assert (previous ? previous->_next == attptr : _attach_head == attptr);

      if (previous)
	previous->_next = attptr->_next;
      else
	_attach_head = attptr->_next;

      safe_delete (attptr);
    }

  assert (_ds.shm_nattch > 0);

  _ds.shm_lpid  = client->cygpid ();
  _ds.shm_nattch -= 1;
  _ds.shm_dtime = time (NULL); // FIXME: sub-second times.

  return 0;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::segment_t::find ()
 *---------------------------------------------------------------------------*/

server_shmmgr::attach_t *
server_shmmgr::segment_t::find (const class process *const client,
				attach_t **previous)
{
  if (previous)
    *previous = NULL;

  // Nb. The _attach_head list is sorted by winpid.

  for (attach_t *attptr = _attach_head; attptr; attptr = attptr->_next)
    if (attptr->_client == client)
      return attptr;
    else if (attptr->_client->winpid () > client->winpid ())
      return NULL;
    else if (previous)
      *previous = attptr;

  return NULL;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::instance ()
 *---------------------------------------------------------------------------*/

/* static */ server_shmmgr &
server_shmmgr::instance ()
{
  pthread_once (&_instance_once, &initialise_instance);

  assert (_instance);

  return *_instance;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::shmat ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::shmat (HANDLE & hFileMap,
		      const int shmid, const int shmflg,
		      class process *const client)
{
  syscall_printf ("shmat (shmid = %d, shmflg = 0%o) for %d(%lu)",
		  shmid, shmflg, client->cygpid (), client->winpid ());

  int result = 0;
  EnterCriticalSection (&_segments_lock);

  segment_t *const segptr = find (ipc_ext2int (shmid, IPC_SHMOP));

  if (!segptr)
    result = -EINVAL;
  else
    result = segptr->attach (client, hFileMap);

  if (!result)
    _shm_atts += 1;

  LeaveCriticalSection (&_segments_lock);

  if (result < 0)
    syscall_printf (("-1 [%d] = shmat (shmid = %d, shmflg = 0%o) "
		     "for %d(%lu)"),
		    -result, shmid, shmflg,
		    client->cygpid (), client->winpid ());
  else
    syscall_printf (("0x%x = shmat (shmid = %d, shmflg = 0%o) "
		     "for %d(%lu)"),
		    hFileMap, shmid, shmflg,
		    client->cygpid (), client->winpid ());

  return result;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::shmctl ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::shmctl (int & out_shmid,
		       struct shmid_ds & out_ds,
		       struct shminfo & out_shminfo,
		       struct shm_info & out_shm_info,
		       const int shmid, const int cmd,
		       const struct shmid_ds & ds,
		       class process *const client)
{
  syscall_printf ("shmctl (shmid = %d, cmd = 0x%x) for %d(%lu)",
		  shmid, cmd, client->cygpid (), client->winpid ());

  int result = 0;
  EnterCriticalSection (&_segments_lock);

  switch (cmd)
    {
    case IPC_STAT:
    case SHM_STAT:		// Uses intids rather than shmids.
    case IPC_SET:
    case IPC_RMID:
      {
	int intid;

	if (cmd == SHM_STAT)
	  intid = shmid;
	else
	  intid = ipc_ext2int (shmid, IPC_SHMOP);

	segment_t *const segptr = find (intid);

	if (!segptr)
	  result = -EINVAL;
	else
	  switch (cmd)
	    {
	    case IPC_STAT:
	      out_ds = segptr->_ds;
	      break;

	    case IPC_SET:
	      segptr->_ds.shm_perm.uid = ds.shm_perm.uid;
	      segptr->_ds.shm_perm.gid = ds.shm_perm.gid;
	      segptr->_ds.shm_perm.mode = ds.shm_perm.mode & 0777;
	      segptr->_ds.shm_lpid = client->cygpid ();
	      segptr->_ds.shm_ctime = time (NULL); // FIXME: sub-second times.
	      break;

	    case IPC_RMID:
	      if (segptr->is_deleted ())
		result = -EIDRM;
	      else
		{
		  segptr->mark_deleted ();
		  if (segptr->is_pending_delete ())
		    delete_segment (segptr);
		}
	      break;

	    case SHM_STAT:	// ipcs(8) i'face.
	      out_ds = segptr->_ds;
	      out_shmid = segptr->_shmid;
	      break;
	    }
      }
      break;

    case IPC_INFO:
      out_shminfo.shmmax = SHMMAX;
      out_shminfo.shmmin = SHMMIN;
      out_shminfo.shmmni = SHMMNI;
      out_shminfo.shmseg = SHMSEG;
      out_shminfo.shmall = SHMALL;
      break;

    case SHM_INFO:		// ipcs(8) i'face.
      out_shmid = _intid_max;
      out_shm_info.shm_ids = _shm_ids;
      out_shm_info.shm_tot = _shm_tot;
      out_shm_info.shm_atts = _shm_atts;
      break;

    default:
      result = -EINVAL;
      break;
    }

  LeaveCriticalSection (&_segments_lock);

  if (result < 0)
    syscall_printf (("-1 [%d] = "
		     "shmctl (shmid = %d, cmd = 0x%x) for %d(%lu)"),
		    -result,
		    shmid, cmd, client->cygpid (), client->winpid ());
  else
    syscall_printf (("%d = "
		     "shmctl (shmid = %d, cmd = 0x%x) for %d(%lu)"),
		    ((cmd == SHM_STAT || cmd == SHM_INFO)
		     ? out_shmid
		     : result),
		    shmid, cmd, client->cygpid (), client->winpid ());

  return result;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::shmdt ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::shmdt (const int shmid, class process *const client)
{
  syscall_printf ("shmdt (shmid = %d) for %d(%lu)",
		  shmid, client->cygpid (), client->winpid ());

  int result = 0;
  EnterCriticalSection (&_segments_lock);

  segment_t *const segptr = find (ipc_ext2int (shmid, IPC_SHMOP));

  if (!segptr)
    result = -EINVAL;
  else
    result = segptr->detach (client);

  if (!result)
    _shm_atts -= 1;

  if (!result && segptr->is_pending_delete ())
    delete_segment (segptr);

  LeaveCriticalSection (&_segments_lock);

  if (result < 0)
    syscall_printf ("-1 [%d] = shmdt (shmid = %d) for %d(%lu)",
		    -result, shmid, client->cygpid (), client->winpid ());
  else
    syscall_printf ("%d = shmdt (shmid = %d) for %d(%lu)",
		    result, shmid, client->cygpid (), client->winpid ());

  return result;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::shmget ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::shmget (int & out_shmid,
		       const key_t key, const size_t size, const int shmflg,
		       const uid_t uid, const gid_t gid,
		       class process *const client)
{
  syscall_printf (("shmget (key = 0x%016llx, size = %u, shmflg = 0%o) "
		   "for %d(%lu)"),
		  key, size, shmflg,
		  client->cygpid (), client->winpid ());

  int result = 0;
  EnterCriticalSection (&_segments_lock);

  if (key == IPC_PRIVATE)
    result = new_segment (key, size, shmflg,
			  client->cygpid (), uid, gid);
  else
    {
      segment_t *const segptr = find_by_key (key);

      if (!segptr)
	if (shmflg & IPC_CREAT)
	  result = new_segment (key, size, shmflg,
				client->cygpid (), uid, gid);
	else
	  result = -ENOENT;
      else if (segptr->is_deleted ())
	result = -EIDRM;
      else if ((shmflg & IPC_CREAT) && (shmflg & IPC_EXCL))
	result = -EEXIST;
      else if ((shmflg & ~(segptr->_ds.shm_perm.mode)) & 0777)
	result = -EACCES;
      else if (size && segptr->_ds.shm_segsz < size)
	result = -EINVAL;
      else
	result = segptr->_shmid;
    }

  LeaveCriticalSection (&_segments_lock);

  if (result >= 0)
    {
      out_shmid = result;
      result = 0;
    }

  if (result < 0)
    syscall_printf (("-1 [%d] = "
		     "shmget (key = 0x%016llx, size = %u, shmflg = 0%o) "
		     "for %d(%lu)"),
		    -result,
		    key, size, shmflg,
		    client->cygpid (), client->winpid ());
  else
    syscall_printf (("%d = "
		     "shmget (key = 0x%016llx, size = %u, shmflg = 0%o) "
		     "for %d(%lu)"),
		    out_shmid,
		    key, size, shmflg,
		    client->cygpid (), client->winpid ());

  return result;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::initialise_instance ()
 *---------------------------------------------------------------------------*/

/* static */ void
server_shmmgr::initialise_instance ()
{
  assert (!_instance);

  _instance = safe_new0 (server_shmmgr);

  assert (_instance);
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::server_shmmgr ()
 *---------------------------------------------------------------------------*/

server_shmmgr::server_shmmgr ()
  : _segments_head (NULL),
    _shm_ids (0),
    _shm_tot (0),
    _shm_atts (0),
    _intid_max (0)
{
  InitializeCriticalSection (&_segments_lock);
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::~server_shmmgr ()
 *---------------------------------------------------------------------------*/

server_shmmgr::~server_shmmgr ()
{
  DeleteCriticalSection (&_segments_lock);
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::find_by_key ()
 *---------------------------------------------------------------------------*/

server_shmmgr::segment_t *
server_shmmgr::find_by_key (const key_t key)
{
  for (segment_t *segptr = _segments_head; segptr; segptr = segptr->_next)
    if (segptr->_ds.shm_perm.key == key)
      return segptr;

  return NULL;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::find ()
 *---------------------------------------------------------------------------*/

server_shmmgr::segment_t *
server_shmmgr::find (const int intid, segment_t **previous)
{
  if (previous)
    *previous = NULL;

  for (segment_t *segptr = _segments_head; segptr; segptr = segptr->_next)
    if (segptr->_intid == intid)
      return segptr;
    else if (segptr->_intid > intid) // The list is sorted by intid.
      return NULL;
    else if (previous)
      *previous = segptr;

  return NULL;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::new_segment ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::new_segment (const key_t key,
			    const size_t size,
			    const int shmflg,
			    const pid_t cygpid,
			    const uid_t uid,
			    const gid_t gid)
{
  if (size < SHMMIN || size > SHMMAX)
      return -EINVAL;

  const HANDLE hFileMap = CreateFileMapping (INVALID_HANDLE_VALUE,
					     NULL, PAGE_READWRITE,
					     0, size,
					     NULL);

  if (!hFileMap)
    {
      syscall_printf ("failed to create file mapping [size = %lu]: %E", size);
      return -ENOMEM;		// FIXME
    }

  segment_t *const segptr = new_segment (key, size, hFileMap);

  if (!segptr)
    {
      (void) CloseHandle (hFileMap);
      return -ENOSPC;
    }

  segptr->_ds.shm_perm.cuid = segptr->_ds.shm_perm.uid = uid;
  segptr->_ds.shm_perm.cgid = segptr->_ds.shm_perm.gid = gid;
  segptr->_ds.shm_perm.mode = shmflg & 0777;
  segptr->_ds.shm_segsz = size;
  segptr->_ds.shm_cpid = cygpid;
  segptr->_ds.shm_ctime = time (NULL); // FIXME: sub-second times.

  return segptr->_shmid;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::new_segment ()
 *
 * Allocate a new segment for the given key and file map with the
 * lowest available intid and insert into the segment map.
 *---------------------------------------------------------------------------*/

server_shmmgr::segment_t *
server_shmmgr::new_segment (const key_t key, const size_t size,
			    const HANDLE hFileMap)
{
  // FIXME: Overflow risk.
  if (_shm_tot + size > SHMALL)
    return NULL;

  int intid = 0;		// Next expected intid value.
  segment_t *previous = NULL;	// Insert pointer.

  // Find first unallocated intid.
  for (segment_t *segptr = _segments_head;
       segptr && segptr->_intid == intid;
       segptr = segptr->_next, intid++)
    {
      previous = segptr;
    }

  /* By the time this condition is reached (given the default value of
   * SHMMNI), the linear searches should all replaced by something
   * just a *little* cleverer . . .
   */
  if (intid >= SHMMNI)
    return NULL;

  segment_t *const segptr = safe_new (segment_t, key, intid, hFileMap);

  assert (segptr);

  if (previous)
    {
      segptr->_next = previous->_next;
      previous->_next = segptr;
    }
  else
    {
      segptr->_next = _segments_head;
      _segments_head = segptr;
    }

  _shm_ids += 1;
  _shm_tot += size;
  if (intid > _intid_max)
    _intid_max = intid;

  return segptr;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::delete_segment ()
 *---------------------------------------------------------------------------*/

void
server_shmmgr::delete_segment (segment_t *const segptr)
{
  assert (segptr);
  assert (segptr->is_pending_delete ());

  segment_t *previous = NULL;

  const segment_t *const tmp = find (segptr->_intid, &previous);

  assert (tmp == segptr);
  assert (previous ? previous->_next == segptr : _segments_head == segptr);

  if (previous)
    previous->_next = segptr->_next;
  else
    _segments_head = segptr->_next;

  assert (_shm_ids > 0);
  _shm_ids -= 1;
  _shm_tot -= segptr->_ds.shm_segsz;

  safe_delete (segptr);
}

/*---------------------------------------------------------------------------*
 * client_request_shm::client_request_shm ()
 *---------------------------------------------------------------------------*/

client_request_shm::client_request_shm ()
  : client_request (CYGSERVER_REQUEST_SHM,
		    &_parameters, sizeof (_parameters))
{
  // verbose: syscall_printf ("created");
}

/*---------------------------------------------------------------------------*
 * client_request_shm::serve ()
 *---------------------------------------------------------------------------*/

void
client_request_shm::serve (transport_layer_base *const conn,
			   process_cache *const cache)
{
  assert (conn);

  assert (!error_code ());

  if (msglen () != sizeof (_parameters.in))
    {
      syscall_printf ("bad request body length: expecting %lu bytes, got %lu",
		      sizeof (_parameters), msglen ());
      error_code (EINVAL);
      msglen (0);
      return;
    }

  // FIXME: Get a return code out of this and don't continue on error.
  conn->impersonate_client ();

  class process *const client = cache->process (_parameters.in.cygpid,
						_parameters.in.winpid);

  if (!client)
    {
      error_code (EAGAIN);
      msglen (0);
      return;
    }

  int result = -EINVAL;

  switch (_parameters.in.shmop)
    {
    case SHMOP_shmget:
      result = shmmgr.shmget (_parameters.out.shmid,
			      _parameters.in.key, _parameters.in.size,
			      _parameters.in.shmflg,
			      _parameters.in.uid, _parameters.in.gid,
			      client);
      break;

    case SHMOP_shmat:
      result = shmmgr.shmat (_parameters.out.hFileMap,
			     _parameters.in.shmid, _parameters.in.shmflg,
			     client);
      break;

    case SHMOP_shmdt:
      result = shmmgr.shmdt (_parameters.in.shmid, client);
      break;

    case SHMOP_shmctl:
      result = shmmgr.shmctl (_parameters.out.shmid,
			      _parameters.out.ds, _parameters.out.shminfo,
			      _parameters.out.shm_info,
			      _parameters.in.shmid, _parameters.in.cmd,
			      _parameters.in.ds,
			      client);
      break;
    }

  client->release ();
  conn->revert_to_self ();

  if (result < 0)
    {
      error_code (-result);
      msglen (0);
    }
  else
    msglen (sizeof (_parameters.out));
}
@


1.11
log
@whitespace
@
text
@@


1.11.16.1
log
@merge from trunk
@
text
@@


1.10
log
@2002-09-22  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	GNUify non-GNU formatted functions calls throughout.

2002-09-22  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (with_strerr): Remove macro.
	(server_shmmgr::segment_t::~segment_t): Remove calls to with_strerr.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::new_segment): Ditto.
	* shm.cc (with_strerr): Remove macro.
	(client_shmmgr::shmdt): Remove calls to with_strerr.
	(client_shmmgr::attach): Ditto.

2002-09-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/sys/ipc.h: Move to "include/cygwin/ipc.h".
	* include/sys/msg.h: Move to "include/cygwin/msg.h".
	* include/sys/sem.h: Move to "include/cygwin/sem.h".
	* include/sys/shm.h: Move to "include/cygwin/shm.h".
	* include/cygwin/ipc.h: New file.
	* include/cygwin/msg.h: Ditto.
	* include/cygwin/sem.h: Ditto.
	* include/cygwin/shm.h: Ditto.
	* cygserver_shm.h: Update includes.
	* msg.cc: Ditto.
	* sem.cc: Ditto.

2002-09-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h (safe_delete): Make a templated function.
	* cygserver.cc (~server_request): Update use of safe_delete.
	(main): Ditto.
	* cygserver_client.cc (client_request::handle_request): Ditto.
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::remove): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	* cygserver_shm.cc (server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* shm.cc (client_shmmgr::shmdt): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.

2002-08-29  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: Replace #include <new> with an explicit
	definition of the placement new operator.
	(safe_delete): Remove unnecessary ## operator.

2002-07-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (class server_shmmgr): Remove `cleanup_t'
	friend declaration.
	(cleanup_t::cleanup_t): Use the segment's shmid as the key rather
	than the segment pointer itself.
	(cleanup_t::segptr): Remove method.
	(cleanup_t::shmid): New method.
	(cleanup_t::cleanup): Update for new key value.
	(server_shmmgr::find (segment_t *)): Remove method.
	* include/cygwin/cygserver_process.h (cleanup_routine::key): Make
	method const.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_process.h
	(cleanup_routine::_key): New field.
	(cleanup_routine::cleanup_routine): Initialise new field with new
	argument.
	(cleanup_routine::operator==): New method.
	(cleanup_routine::key): New method.
	(cleanup_routine::cleanup): Make argument non-const.
	(process::is_active): New method.
	(process::remove): Ditto.
	(process::check_exit_code): Rename method.
	* cygserver_process.cc (process::add): Reorganize code.
	(process::remove): New method.
	(process::check_exit_code): Rename method.
	(process::cleanup): Use new `process::is_active' method.
	(process_cache::process): Ditto.
	(process_cache::sync_wait_array): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr): Make `cleanup_t' a friend.
	(segment_t::detach): Make argument non-const.  Remove cleanup
	object from client if appropriate.
	(cleanup_t::_segptr): Remove field.
	(cleanup_t::cleanup_t): Initialise parent explicitly.  Remove
	field.
	(cleanup_t::segptr): New method.
	(cleanup_t::cleanup): Add error checking and reporting.
	(server_shmmgr::shmdt): Make argument non-const.
	(server_shmmgr::find (segment_t *)): New method.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (client_request_shutdown::client_request_shutdown):
	Comment out verbose tracing statement.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Ditto.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	* cygserver_shm.cc (client_request_shm::client_request_shm):
	Ditto.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc (transport_layer_pipes::listen):
	Set `_is_listening_endpoint' appropriately.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(transport_layer_base::listen): Change return type.
	(transport_layer_base::connect): Ditto.
	* include/cygwin/cygserver_transport_pipes.h
	(transport_layer_pipes::listen): Change return type.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::_sec_none_nih): Remove unused field.
	(transport_layer_pipes::_is_listening_endpoint): New field.
	* cygserver_transport_pipes.cc: Synchronize with sockets code.
	(transport_layer_pipes::transport_layer_pipes): Initialise new
	field.  Separate out asserts.
	(transport_layer_pipes::listen): Change return type.  Add asserts.
	(transport_layer_pipes::accept): Add asserts.
	(transport_layer_pipes::read): Change conditional to an assert.
	Add assert.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Change return type.  Change
	conditional to an assert.  Add asserts.  Rationalize error code
	slightly.
	(transport_layer_pipes::impersonate_client): Add asserts.
	* include/cygwin/cygserver_transport_sockets.h
	(transport_layer_sockets::listen): Change return type.
	(transport_layer_sockets::connect): Ditto.
	(transport_layer_sockets::_addr): Change type of field.
	(transport_layer_sockets::_addr_len): Ditto.
	(transport_layer_sockets::_is_accepted_endpoint): New field.
	(transport_layer_sockets::_is_listening_endpoint): Ditto.
	* cygserver_transport_sockets.cc
	(MAX_CONNECT_RETRY): New constant.
	(transport_layer_sockets::transport_layer_sockets): Initialise new
	fields.  Only initialise the socket address where necessary.
	(transport_layer_sockets::listen): Change return type.  Rewrite.
	(transport_layer_sockets::accept): Add asserts.  Add tracing
	statements.  Use a local variable to hold the accepted address.
	(transport_layer_sockets::close): Add tracing statements.  Unlink
	the UNIX domain socket file as appropriate.  Close the socket
	cleanly.
	(transport_layer_sockets::read): Rewrite method.
	(transport_layer_sockets::write): Ditto.
	(transport_layer_sockets::connect): Change return type.  Rewrite.
	* cygserver.cc (server_submission_loop::request_loop): Run the
	listening thread at high priority with special handling for
	shutdown.
	(main): Print the request error code rather than errno in shutdown
	request code.  Install signal handlers with sigaction(2) to avoid
	setting SA_RESTART.  Check value of the listen method call, now it
	has one.
	* cygserver_client.cc (client_request::make_request): Check new
	return value on connect method call.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport_pipes.h
	(cygserver_transport_pipes::_sd): Rename field.
	(cygserver_transport_pipes::_sec_none_nih): Ditto.
	(cygserver_transport_pipes::_sec_all_nih): Ditto.
	(cygserver_transport_pipes::_pipe_name): Ditto.
	(cygserver_transport_pipes::_hPipe): Ditto.
	(cygserver_transport_pipes::_is_accepted_endpoint): Ditto.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::transport_layer_pipes): Rename fields.
	(transport_layer_pipes::init_security): Ditto.
	(transport_layer_pipes::listen): Ditto.
	(transport_layer_pipes::accept): Ditto.
	(transport_layer_pipes::close): Ditto.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.
	(transport_layer_pipes::revert_to_self): Ditto.
	* include/cygwin/cygserver_transport_sockets.h
	(cygserver_transport_sockets::_fd): Rename field.
	(cygserver_transport_sockets::_addr): Ditto.
	(cygserver_transport_sockets::_addr_len): Ditto.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::transport_layer_sockets): Rename fields.
	(transport_layer_sockets::listen): Ditto.
	(transport_layer_sockets::accept): Ditto.
	(transport_layer_sockets::close): Ditto.
	(transport_layer_sockets::read): Ditto.
	(transport_layer_sockets::write): Ditto.
	(transport_layer_sockets::connect): Ditto.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (with_strerr): Fix use of %p format.
	* shm.cc (client_shmmgr::shmat): Ditto.
	(client_shmmgr::shmctl): Ditto.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::attach): Ditto.

2002-07-14  Christopher Faylor  <cgf@@redhat.com>

	* woutsup.h (system_printf): Remove extraneous semicolon from macro
	definition.

2002-07-14  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc
	(transport_layer_pipes::connect): Use ProtectHandle in DLL code.
	(transport_layer_pipes::close): Use ForceCloseHandle in DLL code.

2002-07-13  Nicholas Wourms  <nwourms@@netscape.com>

	* threaded_queue.h (class queue_submission_loop): Correct friend
	declaration for GCC 3.1.1.
	* include/cygwin/cygserver_process.h (class process): Ditto.
	(class process_cache): Ditto.

2002-07-12  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::shmdt): Only call
	delete_segment if the segment exists [sic].

2002-07-12  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: Include <new> rather than <new.h> for gcc 3.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: New file extracted from "woutsup.h".
	* woutsup.h: Move the "safe" new/delete macros into the new
	"safe_memory.h" header file and include that here.
	* cygserver_client.cc: Explicitly include "safe_memory.h" for
	client-side code.
	(client_request::make_request): Use the "safe" new/delete macros
	unconditionally, i.e. use them on the client side as well as on
	the server side.
	* cygserver_transport.cc: Explicitly include "safe_memory.h" for
	client-side code.
	(create_server_transport): Use the "safe" new/delete macros
	unconditionally, i.e. use them on the client side as well as on
	the server side.
	* shm.cc: Include "safe_memory.h".
	(client_shmmgr::instance): Use the "safe" new/delete macros.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::new_segment): Ditto.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_process (process::process): Add the client's cygpid
	and winpid to all tracing statements as appropriate.
	(process::exit_code): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::shmat): Ditto.
	(server_shmmgr::shmdt): Ditto.
	(server_shmmgr::shmctl): Add a process object argument and remove
	the explicit cygpid argument.  Add the client's cygpid and winpid
	to all tracing statements as appropriate.
	(server_shmmgr::shmget): Ditto.
	(client_request_shm::serve): Update for the new signature of the
	shmctl and shmget methods.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (client_request_shutdown::serve): Don't set the
	shutdown flag directly, but send a SIGINT, as the signal handler
	sets the flag and the signal breaks the pause(2) in the main loop.
	(print_usage): Add new options.
	(main): Add new --cleanup-threads and --request-threads options to
	set the number of threads used by the daemon.  Use pause(2) rather
	the win32 Sleep in the main loop.
	* shm.cc (shmat): Add sigframe.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Automatically detach processes from any
	segments they are attached to at exit.
	(class server_shmmgr::attach_t): New class.
	(server_shmmgr::segment_t::IS_DELETED): Rename and make private.
	(server_shmmgr::segment_t::_sequence): Make private.
	(server_shmmgr::segment_t::_flg): Ditto.
	(server_shmmgr::segment_t::_hFileMap): Ditto.
	(server_shmmgr::segment_t::_attach_head): New private field.
	(server_shmmgr::segment_t::segment_t): Initialise new fields.
	Make non-inline.
	(server_shmmgr::segment_t::~segment_t): New method.
	(server_shmmgr::segment_t::is_deleted): Ditto.
	(server_shmmgr::segment_t::is_pending_delete): Ditto.
	(server_shmmgr::segment_t::mark_deleted): Ditto.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::segment_t::find): Ditto.
	(class server_shmmgr::cleanup_t): New class.
	(server_shmmgr::_shm_atts): New private field.
	(server_shmmgr::shmat): Add a process object argument to replace
	the removed process_cache, cygpid and winpid arguments.  Remove
	the process_cache manipulations.  Move body of code to the
	segment_t::attach method.  Increment _shm_atts when required.
	Update tracing statements.
	(server_shmmgr::shmdt): Add a process object argument to replace
	the removed cygpid argument.  Move body of code to the
	segment_t::detach method.  Decrement _shm_atts when required.
	Update tracing statements.
	(server_shmmgr::shmget): Use the new segment_t::is_deleted method.
	(server_shmmgr::server_shmmgr): Initialise the new _shm_atts
	field.
	(server_shmmgr::delete_segment): Remove the CloseHandle code, as
	this is now done in the segment_t destructor.
	(client_request_shm::serve): Look up the client's process object
	and pass to the server_shmmgr::shmat and server_shmmgr::shmdt
	methods rather than passing the cache, winpid and cygpid.
	* cygserver_process.h: Add a cygpid to the process object to make
	it more useful and then pass process objects rather than winpids
	where possible.
	(cleanup_routine::cleanup): Change argument to be a pointer to a
	process object.
	(class process): Re-order fields for no discernible reason.
	(process::_cygpid): New field.
	(process::process): Add a cygpid argument.
	(process::winpid): New method.
	(process::cygpid): Ditto.
	(process::add): Make public, as it always should have been.
	(process_cache::process): Add a cygpid argument.
	* cygserver_process.cc (process::process): Add a cygpid argument
	and use it to initialise the `_cygpid' field.  Re-order
	initialisers to match new field order.
	(process::cleanup): Pass `this' rather than just the winpid to
	cleanup_routine::cleanup.
	(process_cache::process): Add a cygpid argument and pass it to the
	process object constructor.
	* include/sys/shm.h (shmatt_t): Make unsigned as per SUSv3.
	(shm_info::shm_atts): New field.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (class server_shmmgr::segment_t): Add `_'
	prefix to the names of all fields.

2002-07-10  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* msg.cc: New file of stub functions, no functionality.
	* sem.cc: Ditto.
	* shm.cc (client_shmmgr::shmctl): Add support for an out shm_info
	buffer for the SHM_INFO command.
	(client_shmmgr::shmget): Use %X to print keys.
	* include/sys/ipc.h: Comment all fields and values.
	(IPC_PRIVATE): Change to be non-negative.
	* include/sys/msg.h: New file with SUSv3 and ipcs(8) interfaces.
	* include/sys/sem.h: Ditto.
	* include/sys/shm.h: Comment all fields and values.
	(struct shm_info): New struct.
	* cygserver_shm.h (client_request_shm::shminfo): Rename.
	(client_request_shm::shm_info): New method.
	(client_request_shm::_parameters.out.hFileMap): Move into union.
	(client_request_shm::_parameters.out.shminfo): Rename.
	(client_request_shm::_parameters.out.shm_info): New field.
	* cygserver_shm.cc (server_shmmgr::_shm_ids): Rename.
	(server_shmmgr::_shm_tot): New field.
	(server_shmmgr::shmctl): Rename `out_shminfo' argument.  Add
	`out_shm_info' argument.  Fill in the `out_shm_info' argument in
	the SHM_INFO command.
	(server_shmmgr::shmget): Check `shmflg' against the mode of
	existing segments as per Stevens 1990, p. 123.
	(server_shmmgr::server_shmmgr): Initialise the new `_shm_tot'
	field.
	(server_shmmgr::new_segment): Set ENOMEM if CreateFileMapping
	fails.  Pass `size' to new_segment.
	(server_shmmgr::new_segment): Add size argument and use it to
	check against and update the new `_shm_tot' field.
	(server_shmmgr::delete_segment): Update the new `_shm_tot' field.
	* Makefile.in (DLL_OFILES): Add new DLL object files.

2002-07-09  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc: The main change is to make the
	client try harder to connect to the server if it's previously
	connected, and so has good grounds for believing that the server
	is running.
	(MAX_WAIT_NAMED_PIPE_RETRY): Change to be an enumerator.
	(WAIT_NAMED_PIPE_TIMEOUT): Ditto.
	(transport_layer_pipes::accept): Use interlocked operators on
	`pipe_instance'.
	(transport_layer_pipes::close): Rearrange so that FlushFileBuffers
	and DisconnectNamedPipe are only called for accepted endpoints.
	Use interlocked operators on `pipe_instance'.
	(transport_layer_pipes::read): Use set_errno where required.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Add local static variable
	`assume_cygserver'.  Set it if a connection is made to cygserver,
	clear it if a connection is not made even after retrying.  If set,
	ignore all errors from CreateFile and retry the connection.  Catch
	the situation where WaitNamedPipe fails to wait [sic] and add a
	`Sleep (0)' so that the server gets a chance to run.

2002-07-03  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* dcrt0.cc: Only check for cygserver if and when required.
	(dll_crt0_1): Remove call to `cygserver_init ()'.
	* fhandler_tty.cc (fhandler_tty_slave::open): Change the cygserver
	logic to allow for the fact that `cygserver_init ()' may not yet
	have been called.
	(fhandler_tty_slave::cygserver_attach_tty): Tweak the cygserver
	request logic to conform to the practice elsewhere in the code.
	* tty.cc (tty::common_init): Add an explicit call to
	`cygserver_init ()' if it hasn't already been called.
	* include/cygwin/cygserver.h (CYGSERVER_UNAVAIL): Rename from
	`CYGSERVER_DEAD'.
	(client_request_get_version::check_version): Make available in
	cygserver as well the DLL.
	(check_cygserver_available): Ditto.  Remove `check_version_too'
	argument.
	(cygserver_init): Ditto.  And likewise.
	* cygserver_client.cc (client_request_get_version::check_version):
	Make available in cygserver as well the DLL.
	(client_request::make_request): This may now be called without
	`cygserver_init ()' having been called first.  Detect this and
	call it as required.  Add tracing.
	(check_cygserver_available): Make available in cygserver as well
	the DLL.  Remove `check_version_too' argument and always check the
	version information.  And since this is called from within
	`cygserver_init ()', force `cygserver_running' before calling
	`client_request::make_request ()'.
	(cygserver_init): Make available in cygserver as well the DLL.
	Remove `check_version_too' argument.

2002-07-03  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Implement the ipcs(8) interfaces, IPC_INFO,
	SHM_STAT and SHM_INFO.
	(server_shmmgr::segment_t::sequence): New static field.
	(server_shmmgr::segment_t::key): Remove field, use the new
	ds.shm_perm.key field instead.
	(server_shmmgr::segment_t::shmid): Remove field.
	(server_shmmgr::segment_t::intid): New field.
	(server_shmmgr::segment_t::segment_t): Use the `key' argument to
	initialise `ds.shm_perm.key'.  Change from using `shmid' to
	`intid'.
	(server_shmmgr::_shmseg_cnt): Renamed from `_shmid_cnt'.
	(server_shmmgr::_intid_max): Renamed from `_shmid_max.
	(server_shmmgr::shmat): Move the out arguments to the start of the
	argument list.  Rename the `pid' argument as `cygpid'.  Add
	tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmctl): Add separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add support for the ipcs(8)
	interfaces.  Add tracing.  Pass an intid to `find ()', not a
	shmid.
	(server_shmmgr::shmdt): Rename the `pid' argument as `cygpid'.
	Add tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmget): Add a separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add tracing.
	(server_shmmgr::server_shmmgr): Update for new field names.
	(server_shmmgr::find_by_key): Update for the new `ds.shm_perm.key'
	field.
	(server_shmmgr::find): Update to use the new `segment_t::intid'
	field.
	(server_shmmgr::new_segment): Rename the `pid' argument as
	`cygpid'.  Check that the requested size is within bounds.  Handle
	new error result from `new_segment (key, HANDLE)'.
	(server_shmmgr::new_segment): Work with intids, not shmids.  Check
	that the new intid is within bounds.  Update for new field names.
	(server_shmmgr::delete_segment): Pass an intid to `find ()', not a
	shmid.  Update for new field names.
	(client_request_shm::serve): Check that the incoming message
	length is the size of the `_parameters.in' struct, not of the
	whole in/out parameter union.  Likewise, set the outgoing message
	length to the size of the `_parameters.out' struct.  Update for
	the new server_shmmgr interfaces.
	* include/sys/ipc.h (ipc_perm::key): New field.
	* include/sys/shm.h (SHM_INFO): New constant.
	* cygserver_ipc.h (IPCMNI): New constant.
	(ipc_int2ext): Add `sequence' argument and munge this into the
	external ipc id.
	(ipc_ext2int_subsys): Unmunge the sequence number from the
	external ipc id.
	(ipc_ext2int): Ditto.
	(ipc_inc_id): Remove.
	(ipc_dec_id): Remove.
	* cygserver_shm.h (SHMMAX): New constant.
	(SHMMIN): Ditto.
	(SHMMNI): Ditto.
	(SHMSEG): Ditto.
	(SHMALL): Ditto.
	(client_request_shm::_parameters): Re-arrange as a union of two
	separate structs, one for in arguments, the other for out.
	(client_request_shm::shmid): Update for the new parameter layout.
	(client_request_shm::ds): Ditto.
	(client_request_shm::info): New method.
	* shm.cc (client_shmmgr::_shmat_cnt): New static field.
	(client_shmmgr::shmat): Add locking.  Add tracing.
	(client_shmmgr::shmctl): Update for ipcs(8) commands.  Add
	tracing.  Add more argument checking.
	(client_shmmgr::shmdt): Add locking.  Add tracing.  Update the new
	`_shmat_cnt' field.
	(client_shmmgr::shmget): Add tracing.
	(client_shmmgr::fixup_shms_after_fork): Add tracing.  Add
	consistency checking.
	(client_shmmgr::attach): Add more tracing.
	(client_shmmgr::new_segment): Update the new `_shmat_cnt' field.
	(client_request_shm::client_request_shm): Update for the new
	parameter layout.  Set the outgoing message length to the size of
	the `_parameters.in' struct, not of the whole in/out parameter
	union.

2002-07-02  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* shm.cc: Remove the use of a static client_shmmgr object.
	(client_shmmgr::_instance): New static variable.
	(client_shmmgr::instance): Allocate a new shmmgr on the heap,
	rather than using a local static object.

2002-07-01  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport.cc (create_server_transport): Fix
	cut-and-paste error.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::handle_request): Don't
	bother with the client request activity marker when compiled with
	debugging output.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc
	(MAX_WAIT_NAMED_PIPE_RETRY): New constant.
	(WAIT_NAMED_PIPE_TIMEOUT): Ditto.
	(transport_layer_pipes::close): The `pipe' field is now either
	NULL or a valid handle, and it should never have the value
	`INVALID_HANDLE_VALUE'.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.
	(transport_layer_pipes::connect): Ditto.  New, but still bogus,
	retry logic.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::server_shmmgr): All fields have
	to be initialized now that the singleton is no longer static.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::_instance): New static field.
	(server_shmmgr::_instance_once): Ditto.
	(server_shmmgr::initialise_instance): New static method.
	(server_shmmgr::instance): Use a pthread_once_t rather than
	relying on a local static variable.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h: Remove all uses of the C++ new and delete operators
	throughout cygserver until they are fully thread-safe.
	(safe_new0): New macro to replace the C++ new operator.
	(safe_new): Ditto.
	(safe_delete): New macro to replace the C++ delete operator.
	* cygserver_client.cc (client_request::handle_request): Replace
	all uses of the C++ new and delete operators with the new macros
	from "woutsup.h".
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::new_segment): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* cygserver_transport.cc (create_server_transport): Ditto.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::accept): Ditto.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::accept): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.
	(threaded_queue::stop): Replace sleep(3) with win32 Sleep.
	* cygserver.cc (~server_request): Replace all uses of the C++ new
	and delete operators with the new macros from "woutsup.h".
	(server_submission_loop::request_loop): Ditto.
	(main): Ditto.  Replace sleep(3) with win32 Sleep.  Replace
	iostreams with FILEs.
	(print_usage): Replace iostreams with FILEs.
	(print_version): Ditto.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_sockets.cc
	(transport_layer_sockets::accept): Rename local variable
	`accept_fd' to avoid shadowing the `fd' field.

2002-06-29  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygwin_ipc.h: Moved (back) to "include/sys/ipc.h".
	* cygwin_shm.h: Moved (back) to "include/sys/shm.h".
	* include/sys/ipc.h: New file.
	* include/sys/shm.h: New file.
	* cygserver_shm.h: Update for new header file locations.
	* ipc.cc: Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::make_request): Comment out
	a verbose tracing statement.
	* cygserver_process.cc (process_cache::sync_wait_array): Fix
	broken assert.
	* include/cygwin/cygserver.h (class client_request): Remove excess
	use of `class' qualifier in declarations.
	(class client_request_get_version): Ditto.
	(class client_request_shutdown): Ditto.
	(class client_request_attach_tty): Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_ipc.h: New file.
	* cygserver_shm.h: Re-written from scratch.
	* cygserver_shm.cc: Ditto.
	* shm.cc: Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* threaded_queue.h (class queue_request): Re-write.
	(threaded_queue_thread_function): Remove.
	(class queue_process_param): Remove.
	(class threaded_queue): Re-write.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	(TInterlockedExchangePointer): New templated function.
	(TInterlockedCompareExchangePointer): Ditto.
	* threaded_queue.cc (worker_function): Remove.
	(class threaded_queue): Re-write.
	(class queue_process_param): Remove.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	* include/cygwin/cygserver_process.h (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver_process.cc (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver.cc (request_count): Remove unused variable.
	(class server_request): Move methods inline.
	(class server_process_param): Remove.
	(class server_request_queue): Remove.
	(request_queue): Move into `main ()' and change type to
	`threaded_queue'.
	(request_loop): Remove.
	(class server_submission_loop): New version of the old
	`server_process_param' class.
	(shutdown_server): New variable.
	(client_request_shutdown::serve): Set `shutdown_server' to trigger
	shutdown.
	(handle_signal): Ditto.
	(main): Install signal handler for SIGINT rather than SIGQUIT.
	Use new interfaces for the `request_queue' and the `cache'.
	Create a `server_submission_loop' and add to the `request_queue'.
	Add check for the `shutdown_server' variable to the main loop.
	* cygserver_shm.cc (client_request_shm::serve): Release the
	process object after use.

2002-06-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::handle_request): Correct
	tracing statement.
	* cygserver_transport_pipes.cc: Remove local definition of
	FILE_FLAG_FIRST_PIPE_INSTANCE constant.
	* cygwin_ipc.h: Update copyright notice.
	* cygwin_shm.h: Ditto.
	* woutsup.h: Add definition of _WIN32_WINNT.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client (client_request::make_request): Replace my
	inappropriate use of set_errno () with error_code () throughout.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h: Add forward declarations of class
	transport_layer_base and class process_cache to reduce
	dependencies between header files.
	* include/cygwin/cygserver_process.h: Add include of
	"threaded_queue.h".
	* cygserver.cc: Remove unnecessary cygserver header files.
	* cygserver_client.cc: Ditto.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_shm.h: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* dcrt0.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.h: Replace <sys/shm.h> with "cygwin_shm.h" after
	merge from HEAD.
	* cygwin_ipc.h: Update with changes to include/sys/ipc.h lost in
	merge from HEAD.
	* cygwin_shm.h: Ditto.

2002-06-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc: The tests for a duplicate server instance are now
	the responsibility of the transport layer.
	(request_loop): Use new `recoverable' flag in call to
	`cygserver_transport::accept ()' and shutdown on an unrecoverable
	error.
	(main): Never call `cygserver_init ()'.  Fake `cygserver_running'
	just for sending a shutdown request.
	* cygserver_client.cc (client_request::send): Comment out
	message-size tracing statements as verbose.
	(client_request::handle): Ditto.
	(client_request_get_version::check_version): #ifdef as DLL-only.
	(check_cygserver_available): Ditto.
	(cygserver_init): Ditto.
	* include/cygwin/cygserver.h
	(client_request_get_version::check_version): #ifdef as DLL-only.
	(check_cygserver_available): Ditto.
	(cygserver_init): Ditto.
	* include/cygwin/cygserver_transport.h
	(transport_layer_base::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_base::revert_to_self): Ditto.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.  Add a `recoverable' out
	flag for error handling.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	(transport_layer_pipes): Change type of the `pipe_name' field.
	Remove the `inited' field, as unnecessary.  Add new
	`is_accepted_endpoint' field.
	* include/cygwin/cygserver_transport.cc
	(transport_layer_base::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_base::revert_to_self): Ditto.
	* include/cygwin/cygserver_transport_sockets.cc
	(transport_layer_sockets::listen): #ifdef as cygserver-only.
	(transport_layer_sockets::accept): #ifdef as cygserver-only.
	Analyse any errno from `accept ()' and set `recoverable' as
	appropriate.
	* cygserver_transport_pipes.cc: Add local #define of
	`FILE_FLAG_FIRST_PIPE_INSTANCE'.
	(pipe_instance_lock_once): New variable.
	(pipe_instance_lock): Ditto.
	(pipe_instance): Ditto.
	(initialise_pipe_instance_lock): New function.
	(transport_layer_pipes::transport_layer_pipes): Change
	initialization of `pipe_name'.  Initialize `is_accepted_endpoint'
	as appropriate.  Remove use of `inited'.
	(transport_layer_pipes::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_pipes::revert_to_self): Ditto.
	(transport_layer_pipes::listen): Ditto.
	(transport_layer_pipes::accept): Ditto.  Keep track of how often
	many named pipes have been created, in the `pipe_instance'
	variable, and pass the `FILE_FLAG_FIRST_PIPE_INSTANCE' flag on the
	open of the first instance.  Analyse the error code from
	`CreateNamedPipe ()' and set the `recoverable' flag as
	appropriate.
	(transport_layer_pipes::close): Update the `pipe_instance' count.

2002-06-18  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h (cygserver_running): Add declaration.
	(api_fatal): Eliminate.
	* include/cygwin/cygserver.h
	(client_request_get_version::check_version): Change return type to
	bool.
	(check_cygserver_available): New function.
	(cygserver_init): Add check_version_too argument.
	* cygserver_client.cc (allow_daemon): Make a bool.
	(client_request_get_version::make_request): See errno on error.
	Remove special case for CYGSERVER_REQUEST_GET_VERSION; this is now
	handled in cygserver_init().
	(client_request_get_version::check_version): Use syscall_printf()
	instead of api_fatal(). Return true if cygserver version is
	compatible.
	(check_cygserver_available): New function; code moved here from
	cygserver_init().
	(cygserver_init): Move some code into check_cygserver_available().
	* cygserver.cc (__set_errno): Copy from debug.cc so that
	set_errno() can be used when __OUTSIDE_CYGWIN__.
	(main): Call cygserver_init() to set up cygserver_running and add
	checks against this to (try and) prevent multiple copies of
	cygserver running simultaneously.  Remember to delete all
	transport connections so that (one day) the transport classes can
	tidy up on cygserver shutdown.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (main): Adjust tracing output for a cleaner display
	when compiled without --enable-debugging.
	* threaded_queue.cc (threaded_queue::cleanup): Ditto.
	(queue_process_param::stop): Ditto.
	* include/cygwin/cygserver.h
	(client_request::make_request): Make non-virtual.
	(client_request::send): Make virtual and protected, not private.
	(client_request_attach_tty::send): New virtual method.
	* cygserver_client.cc: Use the `msglen()' accessor rather than
	`_header.msglen' throughout.
	(client_request_attach_tty::send): New method.
	(client_request::make_request): Remove the explicit close of
	`transport' as it is closed on deletion.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h: Change the client_request classes to
	give greater encapsulation and to allow variable length requests
	and replies.
	(enum cygserver_request_code): Now client_request::request_code_t.
	(class request_header): Now client_request::header_t.  Make a
	union of the request_code and the error_code.  The `cb' field,
	which was the buffer length, is now the `size_t msglen' field.
	(struct request_get_version): Now
	client_request_get_version::request_get_version.
	(struct request_shutdown): Remove unused type.
	(struct request_attach_tty): Now
	client_request_attach_tty::request_attach_tty.
	(client_request::_buf): Make field const.
	(client_request::_buflen): New const private field.
	(client_request::request_code): New accessor.
	(client_request::error_code): Ditto.
	(client_request::msglen): Ditto.
	(client_request::handle_request): New static method.
	(client_request::make_request): New virtual method.
	(client_request::handle): New method.
	(client_request::send): Make private.
	(client_request_get_version::check_version): New method.
	(client_request_get_version::serve): Make private.
	(client_request_get_version::version): Ditto.
	(client_request_shutdown::serve): Ditto.
	(client_request_attach_tty::req): Ditto.
	(client_request_attach_tty::serve): Ditto.
	(client_request_attach_tty::from_master): Make method const.
	(client_request_attach_tty::from_master): Ditto.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Track
	changes to the client_request classes.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	(client_request_get_version::check_version): New method to
	encapsulate code from cygserver_init().
	(client_request_shutdown::client_request_shutdown): Move into
	"cygserver.cc".
	(client_request::send): Track changes to the client_request
	classes.  Add more error checking.
	(client_request::handle_request): New static method containing the
	first half of the old server_request::process() code.
	(client_request::make_request): New method to replace the old
	cygserver_request() function.
	(client_request::handle): New method containing the second half of
	the old server_request::process() code.
	(cygserver_init): Track changes to the client_request classes.  In
	particular, some code moved into the
	client_request_get_version::check_version() method.
	* cygserver.cc (client_request_attach_tty::serve): Track changes
	to the client_request classes.  In particular, only return a reply
	body if some handles are successfully duplicated for the client.
	And remove goto's.
	(client_request_get_version::serve): Track changes to the
	client_request classes.
	(client_request_shutdown::serve): Ditto.
	(class client_request_invalid): Dead, and so young too.
	(server_request::request_buffer): Remove unnecessary field.
	(client_request_shutdown::client_request_shutdown): Moved here
	from "cygserver_client.cc".
	(server_request::process): Implementation moved into the new
	client_request::handle_request() and client_request::handle()
	methods.
	* cygserver_shm.h (class client_request_shm): Put client- and
	server-specific interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__
	guards.
	(client_request_shm::serve): Make private.
	* cygserver_shm.cc
	(client_request_shm::client_request_shm): Track changes to the
	client_request classes.
	(client_request_shm::serve): Ditto
	* shm.cc (client_request_shm::client_request_shm): Ditto.  Use
	alloc_sd() rather than set_security_attribute() to get access to
	the SECURITY_DESCRIPTOR length, so that we can use it to set the
	request body length.
	(shmat): Track changes to the client_request classes. In
	particular, allocate client_request objects on the stack rather
	than on the heap, and use the client_request::make_request()
	method rather than the old cygserver_request() function.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::cygserver_attach_tty): Ditto.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(cygserver_transport::read): Change buffer type to void *.
	(cygserver_transport::write): Ditto.
	* include/cygwin/cygserver_transport_sockets.h
	(cygserver_transport_sockets::read): Ditto.
	(cygserver_transport_sockets::write): Ditto.
	* include/cygwin/cygserver_transport_pipes.h
	(cygserver_transport_pipes::read): Ditto.
	(cygserver_transport_pipes::write): Ditto.
	* cygserver_transport_sockets.cc
	(cygserver_transport_sockets::read): Ditto.
	(cygserver_transport_sockets::write): Ditto.
	* cygserver_transport_pipes.cc
	(cygserver_transport_pipes::read): Ditto. Set errno on error, to
	match behaviour of cygserver_transport_sockets class.
	(cygserver_transport_pipes::write): Ditto.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (version): New static variable.
	(server_request_queue::add_connection): Remove my gratuitous use
	of studly caps.
	(setup_privileges): Declare static.
	(handle_signal): Ditto.
	(longopts): Make a local variable of main().
	(opts): Ditto.
	(print_usage): New function.
	(print_version): Ditto (tip of the hat to Joshua Daniel Franklin
	for inspiration here).
	(main): More argument checking.  Add --help and --version options.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h (client_request::serve): Make pure
	virtual.
	* cygserver.cc (client_request::serve): Remove definition of pure
	virtual method.
	(class client_request_invalid): New class.
	(server_request::process): Use new client_request_invalid
	class. And remove goto's.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (class server_request): Add virtual destructor.
	(server_request_queue::addConnection): New method to replace bad
	virtual add() method.
	(request_loop): Replace call to queue->add() with call to
	queue->addConnection().
	(server_request::server_request): Use field initialization.
	(server_request::~server_request): New virtual destructor.
	(server_request::process): Remove close and delete of
	transport_layer_base object. It is deleted by the server_request's
	own destructor and closed by its own destructor.
	* include/cygwin/cygserver.h
	(client_request::operator request_header): Remove unused method.
	* cygserver_client.cc: Ditto.
	* include/cygwin/cygserver_process.h
	(class cleanup_routine): Add virtual destructor.
	(cleanup_routine::cleanup): Make pure virtual.
	(class process_cache): Make destructor non-virtual.
	(process_cache::add): Ditto.
	* cygserver_process.cc
	(cleanup_routine::~cleanup_routine): New virtual destructor.
	* include/cygwin/cygserver_transport.h
	(class transport_layer_base): Add virtual destructor.
	* cygserver_transport.cc
	(transport_layer_base::~transport_layer_base): New virtual
	destructor.
	* include/cygwin/cygserver_transport_pipes.h
	(class transport_layer_pipes): Add virtual destructor.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::~transport_layer_pipes): New virtual
	destructor.
	(transport_layer_pipes::close): Null out handle after closing.
	* include/cygwin/cygserver_transport_sockets.h
	(class transport_layer_sockets): Add virtual destructor.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::~transport_layer_sockets): New virtual
	destructor.
	(transport_layer_sockets::close): Null out fd after closing.
	* threaded_queue.h (class queue_request): Add virtual destructor.
	(queue_request::process): Make pure virtual.
	* threaded_queue.cc (~queue_request): New virtual destructor.
	(queue_request::process): Remove definition of pure virtual
	method.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h (client_request::send): Make
	non-virtual.
	(class client_request_attach_tty): Put client- and server-specific
	interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__ guards.
	* cygserver_client.cc: Ditto.
	(cygserver_init): Fix error handling.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc: Throughout the code, check and correct level of
	the XXX_printf() functions used. Comment out several of the
	debug_printf() calls with "// verbose:".  Reformat and correct
	typos of some of the XXX_printf() formats.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* shm.cc (hi_ulong): New function to allow printing of a 64-bit
	key with current small_printf implementation.
	(lo_ulong): Ditto.
	(client_request_shm::client_request_shm): Use hi_ulong() and
	lo_ulong() in call to debug_printf().

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Remove #define __INSIDE_CYGWIN__ from around
	<sys/shm.h> as it no longer contains any internal code.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/sys/ipc.h (IPC_PRIVATE): Add cast to key_t.
	(IPC_INFO): New flag for ipcs(8).
	(IPC_RMID IPC_SET IPC_STAT): Renumber.
	* include/sys/shm.h (SHM_RDONLY SHM_RND): Renumber with distinct
	values [sic].
	(class _shmattach): Internal type moved to "cygserver_shm.h".
	(class shmnode): Ditto.
	(class shmid_ds): Ditto.
	(struct shmid_ds): Add spare fields.
	(struct shminfo): New type for IPC_INFO interface.
	* cygserver_shm.h: Remove obsolete #if 0 ... #endif block.
	(class shm_cleanup): Remove unused class.
	(struct _shmattach): Internal type moved from <sys/shm.h>.
	(struct shmnode): Ditto.
	(struct int_shmid_ds): Ditto. Renamed to avoid name clash with
	public interface struct shmid_ds. Use the shmid_bs structure as a
	field.
	* cygserver_shm.cc: Remove obsolete #if 0 ... #endif block.
	(client_request_shm::serve): Update for redefinition of
	int_shmid_ds structure.
	* shm.cc (build_inprocess_shmds): Ditto.
	(fixup_shms_after_fork): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove obsolete #if 0 ... #endif code.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(transport_layer_base::transport_layer_base): Remove since it is
	now redundant.
	(transport_layer_base::listen): Make a pure virtual method.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.
	* cygserver_transport.cc
	(transport_layer_base::transport_layer_base): Remove since it is
	now redundant.
	(transport_layer_base::listen): Remove since it is now a pure
	virtual method.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (check_and_dup_handle): Only use security code if
	running on NT, i.e. if wincap.has_security().
	(client_request_attach_tty::serve): Add check for has_security().
	* cygserver_process.cc (process_cache::process): Use DWORD winpid
	throughout to avoid win32 vs. cygwin pid confusion.
	(process::process): Ditto.
	* cygserver_shm.cc (client_request_shm::serve): Only use security
	code if running on NT, i.e. if wincap.has_security().
	* cygserver_shm.h (client_request_shm::parameters.in): Replace the
	ambiguous pid field with cygpid and winpid fields.
	(client_request_shm::client_request_shm): Reduce to only two
	client-side constructors: one for SHM_CREATE, another for all the
	other requests.
	* shm.cc (client_request_shm::client_request_shm):
	Ditto. Initialize cygpid and winpid fields here. On NT initialize
	sd_buf here using set_security_attribute() to make use of the euid
	and egid.
	(shmat): Use new client_request_shm constructor.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove security code, now performed in the
	relevant client_request_shm constructor.
	* include/cygwin/cygserver_process.h: (class cleanup_routine):
	Change winpid type to DWORD.
	(class process): Ditto.

2002-06-15  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h: New file.
	* cygserver.cc: Use "woutsup.h" and new XXX_printf macros.
	(getfunc): New function, copied verbatim from "strace.cc".
	(__cygserver__printf): New function.
	* cygserver_client.cc: Use "woutsup.h" and new XXX_printf macros.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* threaded_queue.cc: Ditto.
	* shm.cc: Remove trailing \n from XXX_printf format strings.
	* Makefile.in: Remove special __OUTSIDE_CYGWIN__ case for
	cygserver_shm.cc.
@
text
@d51 2
a52 2
        _refcnt (0),
        _next (NULL)
@


1.9
log
@	* cygwin_ipc.h: Move to "include/cygwin/ipc.h".
	* cygwin_shm.h: Move to "include/cygwin/shm.h".
	* include/cygwin/ipc.h: New file.
	* include/cygwin/shm.h: New file.
	* ipc.c:c Update <cygwin/ipc.h> include.
	* cygserver_shm.cc: Update <cygwin/shm.h> include.
	* shm.cc: Ditto.
@
text
@d1 1
a1 1
/* cygserver_shm.cc: Single unix specification IPC interface for Cygwin
d3 1
a3 1
Copyright 2001, 2002 Red Hat, Inc.
d5 2
a6 1
Originally written by Robert Collins <robert.collins@@hotmail.com>
d14 1
a14 14
#ifdef __OUTSIDE_CYGWIN__
#undef __INSIDE_CYGWIN__
#else
#include "winsup.h"
#endif

#ifndef __INSIDE_CYGWIN__
#define DEBUG 0
#define system_printf printf
#define debug_printf if (DEBUG) printf
#define api_fatal printf
#include <stdio.h>
#include <windows.h>
#endif
a15 1
#include <sys/stat.h>
d17 1
a17 6
#include "cygerrno.h"
#include <unistd.h>
#include "security.h"
//#include "fhandler.h"
//#include "dtable.h"
//#include "cygheap.h"
d19 4
a22 11
//#include "thread.h"
#ifndef __INSIDE_CYGWIN__
#define __INSIDE_CYGWIN__
#include <cygwin/shm.h>
#undef __INSIDE_CYGWIN__
#else
#include <cygwin/shm.h>
#endif
//#include "perprocess.h"
#include <threaded_queue.h>
#include <cygwin/cygserver_process.h>
d24 57
d82 32
a113 131
// FIXME IS THIS CORRECT
/* Implementation notes: We use two shared memory regions per key:
 * One for the control structure, and one for the shared memory.
 * While this has a higher overhead tham a single shared area,
 * It allows more flexability. As the entire code is transparent to the user
 * We can merge these in the future should it be needed.
 * Also, IPC_PRIVATE keys create unique mappings each time. The shm_ids just
 * keep monotonically incrementing - system wide.
 */
size_t
getsystemallocgranularity ()
{
  SYSTEM_INFO sysinfo;
  static size_t buffer_offset = 0;
  if (buffer_offset)
    return buffer_offset;
  GetSystemInfo (&sysinfo);
  buffer_offset = sysinfo.dwAllocationGranularity;
  return buffer_offset;
}


client_request_shm::client_request_shm ():client_request (CYGSERVER_REQUEST_SHM_GET,
		sizeof (parameters))
{
  buffer = (char *) &parameters;
}

/* FIXME: If building on a 64-bit compiler, the address->int typecast will fail.
 * Solution: manually calculate the next id value
 */

#if 0
extern
"C" void *
shmat (int shmid, const void *shmaddr, int parameters.in.shmflg)
{
  class shmid_ds *
    shm = (class shmid_ds *)
    shmid;			//FIXME: verifyable object test

  if (shmaddr)
    {
      //FIXME: requested base address ?!
      set_errno (EINVAL);
      return (void *) -1;
    }

  void *
    rv =
    MapViewOfFile (shm->attachmap,


		   (parameters.in.shmflg & SHM_RDONLY) ?
		   FILE_MAP_READ : FILE_MAP_WRITE, 0,
		   0, 0);

  if (!rv)
    {
      //FIXME: translate GetLastError()
      set_errno (EACCES);
      return (void *) -1;
    }

/* FIXME: this needs to be globally protected to prevent a mismatch betwen
 * attach count and attachees list
 */

  InterlockedIncrement (&shm->shm_nattch);
  _shmattach *
    attachnode =
    new
    _shmattach;

  attachnode->data = rv;
  attachnode->next =
    (_shmattach *) InterlockedExchangePointer ((LONG *) & shm->attachhead,
					       (long int) attachnode);
  return rv;
}
#endif

/* FIXME: evaluate getuid() and getgid() against the requested mode. Then
 * choose PAGE_READWRITE | PAGE_READONLY and FILE_MAP_WRITE  |  FILE_MAP_READ
 * appropriately
 */

/* Test result from openbsd: shm ids are persistent cross process if a handle is left
 * open. This could lead to resource starvation: we're not copying that behaviour
 * unless we have to. (It will involve acygwin1.dll gloal shared list :[ ).
 */
/* FIXME: shmid should be a verifyable object
 */

/* FIXME: on NT we should check everything against the SD. On 95 we just emulate.
 */

extern GENERIC_MAPPING
  access_mapping;

extern int
check_and_dup_handle (HANDLE from_process, HANDLE to_process,
		      HANDLE from_process_token,
		      DWORD access,
		      HANDLE from_handle,
		      HANDLE * to_handle_ptr, BOOL bInheritHandle);

//FIXME: where should this live
static shmnode *
  shm_head =
  NULL;
//FIXME: ditto.
static shmnode *
  deleted_head = NULL;
/* must be long for InterlockedIncrement */
static long
  new_id =
  0;
static long
  new_private_key =
  0;

static void
delete_shmnode (shmnode **nodeptr)
{
  shmnode *node = *nodeptr;

  // remove from the list
  if (node == shm_head)
    shm_head = shm_head->next;
  else
d115 86
a200 17
      shmnode *tempnode = shm_head;
      while (tempnode && tempnode->next != node)
	tempnode = tempnode->next;
      if (tempnode)
	tempnode->next = node->next;
      // else log the unexpected !
    }

    // release the shared data view
    UnmapViewOfFile (node->shmds->mapptr);
    delete node->shmds;
    CloseHandle (node->filemap);
    CloseHandle (node->attachmap);

    // free the memory
    delete node;
    nodeptr = NULL;
d203 7
a209 2
void
client_request_shm::serve (transport_layer_base * conn, process_cache * cache)
d211 25
a235 18
//  DWORD sd_size = 4096;
//  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) parameters.in.sd_buf;
//  /* create a sd for our open requests based on shmflag & 0x01ff */
//  psd = alloc_sd (getuid (), getgid (), cygheap->user.logsrv (),
//		    parameters.in.shmflg & 0x01ff, psd, &sd_size);

  HANDLE from_process_handle = NULL;
  HANDLE token_handle = NULL;
  DWORD rc;

  from_process_handle = cache->process (parameters.in.pid)->handle ();
  /* possible TODO: reduce the access on the handle before we use it */
  /* Note that unless we do this, we don't need to call CloseHandle - it's kept open
   * by the process cache until the process terminates.
   * We may need a refcount on the cache however...
   */
  if (!from_process_handle)
d237 12
a248 3
      debug_printf ("error opening process (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      return;
d251 31
a281 1
  conn->impersonate_client ();
d283 6
a288 2
  rc = OpenThreadToken (GetCurrentThread (),
			TOKEN_QUERY, TRUE, &token_handle);
d290 1
a290 1
  conn->revert_to_self ();
d292 1
a292 1
  if (!rc)
d294 8
a301 4
      debug_printf ("error opening thread token (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      CloseHandle (from_process_handle);
      return;
d304 87
d392 15
a406 3
  /* we trust the clients request - we will be doing it as them, and
   * the worst they can do is open their own permissions
   */
d408 2
d411 20
a430 16
  SECURITY_ATTRIBUTES sa;
  sa.nLength = sizeof (sa);
  sa.lpSecurityDescriptor = psd;
  sa.bInheritHandle = TRUE;	/* the memory structures inherit ok */

  char *shmname = NULL, *shmaname = NULL;
  char stringbuf[29], stringbuf1[29];

  /* TODO: make this code block a function! */
  if (parameters.in.type == SHM_REATTACH)
    {
      /* just find and fill out the existing shm_id */
      shmnode *tempnode = shm_head;
      while (tempnode)
	{
	  if (tempnode->shm_id == parameters.in.shm_id)
d432 16
a447 6
	      parameters.out.shm_id = tempnode->shm_id;
	      parameters.out.key = tempnode->key;
	      if (check_and_dup_handle
		  (GetCurrentProcess (), from_process_handle, token_handle,
		   DUPLICATE_SAME_ACCESS, tempnode->filemap,
		   &parameters.out.filemap, TRUE) != 0)
d449 3
a451 3
		  debug_printf ("error duplicating filemap handle (%lu)\n",
				GetLastError ());
		  header.error_code = EACCES;
d453 6
a458 11
	      if (check_and_dup_handle
		  (GetCurrentProcess (), from_process_handle, token_handle,
		   DUPLICATE_SAME_ACCESS, tempnode->attachmap,
		   &parameters.out.attachmap, TRUE) != 0)
		{
		  debug_printf ("error duplicating attachmap handle (%lu)\n",
				GetLastError ());
		  header.error_code = EACCES;
		}
	      CloseHandle (token_handle);
	      return;
d460 120
a579 5
	  tempnode = tempnode->next;
	}
      header.error_code = EINVAL;
      CloseHandle (token_handle);
      return;
d582 3
a584 7
  /* someone attached */
  /* someone can send shm_id's they don't have and currently we will increment those
   * attach counts. If someone wants to fix that, please go ahead.
   * The problem is that shm_get has nothing to do with the ability to attach. Attach
   * requires a permission check, which we get the OS to do in MapViewOfFile.
   */
  if (parameters.in.type == SHM_ATTACH)
d586 2
a587 15
      shmnode *tempnode = shm_head;
      while (tempnode)
	{
	  if (tempnode->shm_id == parameters.in.shm_id)
	    {
	      InterlockedIncrement (&tempnode->shmds->shm_nattch);
	      header.error_code = 0;
	      CloseHandle (token_handle);
	      return;
	    }
	  tempnode = tempnode->next;
	}
      header.error_code = EINVAL;
      CloseHandle (token_handle);
      return;
d590 111
a700 2
  /* Someone detached */
  if (parameters.in.type == SHM_DETACH)
d702 2
a703 15
      shmnode *tempnode = shm_head;
      while (tempnode)
	{
	  if (tempnode->shm_id == parameters.in.shm_id)
	    {
	      InterlockedDecrement (&tempnode->shmds->shm_nattch);
	      header.error_code = 0;
	      CloseHandle (token_handle);
	      return;
	    }
	  tempnode = tempnode->next;
	}
      header.error_code = EINVAL;
      CloseHandle (token_handle);
      return;
d706 3
a708 2
  /* Someone wants the ID removed. */
  if (parameters.in.type == SHM_DEL)
d710 2
a711 31
      shmnode **tempnode = &shm_head;
      while (*tempnode)
	  {
	    if ((*tempnode)->shm_id == parameters.in.shm_id)
	      {
		// unlink from the accessible node list
		shmnode *temp2 = *tempnode;
		*tempnode = temp2->next;
		// link into the deleted list
		temp2->next = deleted_head;
		deleted_head = temp2;

		// FIXME: when/where do we delete the handles?
		if (temp2->shmds->shm_nattch)
		  {
		    // FIXME: add to a pending queue?
		  }
		else
		  {
		    delete_shmnode (&temp2);
		  }

		header.error_code = 0;
		CloseHandle (token_handle);
		return;
	      }
	    tempnode = &(*tempnode)->next;
	  }
      header.error_code = EINVAL;
      CloseHandle (token_handle);
      return;
d714 9
d724 22
a745 1
  if (parameters.in.type == SHM_CREATE)
d747 9
a755 3
      /* FIXME: enter the checking for existing keys mutex. This mutex _must_ be system wide
       * to prevent races on shmget.
       */
d757 3
a759 14
      if (parameters.in.key == IPC_PRIVATE)
	{
	  /* create the mapping name (CYGWINSHMKPRIVATE_0x01234567 */
	  /* The K refers to Key, the actual mapped area has D */
	  long private_key = (int) InterlockedIncrement (&new_private_key);
	  snprintf (stringbuf, 29, "CYGWINSHMKPRIVATE_0x%0x", private_key);
	  shmname = stringbuf;
	  snprintf (stringbuf1, 29, "CYGWINSHMDPRIVATE_0x%0x", private_key);
	  shmaname = stringbuf1;
	}
      else
	{
	  /* create the mapping name (CYGWINSHMK0x0123456789abcdef */
	  /* The K refers to Key, the actual mapped area has D */
d761 10
a770 8
	  snprintf (stringbuf, 29, "CYGWINSHMK0x%0qx", parameters.in.key);
	  shmname = stringbuf;
	  snprintf (stringbuf1, 29, "CYGWINSHMD0x%0qx", parameters.in.key);
	  shmaname = stringbuf1;
	  debug_printf ("system id strings are \n%s\n%s\n", shmname,
			shmaname);
	  debug_printf ("key input value is 0x%0qx\n", parameters.in.key);
	}
d772 4
a775 1
      /* attempt to open the key */
d777 2
a778 4
      /* get an existing key */
      /* On unix the same shmid identifier is returned on multiple calls to shm_get
       * with the same key and size. Different modes is a ?.
       */
d780 3
d784 5
d790 1
a790 3
      /* walk the list of known keys and return the id if found. remember, we are
       * authoritative...
       */
d792 1
a792 62
      shmnode *tempnode = shm_head;
      while (tempnode)
	{
	  if (tempnode->key == parameters.in.key
	      && parameters.in.key != IPC_PRIVATE)
	    {
	      // FIXME: free the mutex
	      if (parameters.in.size
		  && tempnode->shmds->shm_segsz < parameters.in.size)
		{
		  header.error_code = EINVAL;
		  CloseHandle (token_handle);
		  return;
		}
	      /* FIXME: can the same process call this twice without error ? test
	       * on unix
	       */
	      if ((parameters.in.shmflg & IPC_CREAT)
		  && (parameters.in.shmflg & IPC_EXCL))
		{
		  header.error_code = EEXIST;
		  debug_printf
		    ("attempt to exclusively create already created shm_area with key 0x%0qx\n",
		     parameters.in.key);
		  // FIXME: free the mutex
		  CloseHandle (token_handle);
		  return;
		}
	      // FIXME: do we need to other tests of the requested mode with the
	      // tempnode->shm_id mode ? testcase on unix needed.
	      // FIXME how do we do the security test? or
	      // do we wait for shmat to bother with that?
	      /* One possibly solution: impersonate the client, and then test we can
	       * reopen the area. In fact we'll probably have to do that to get
	       * handles back to them, alternatively just tell them the id, and then
	       * let them attempt the open.
	       */
	      parameters.out.shm_id = tempnode->shm_id;
	      if (check_and_dup_handle
		  (GetCurrentProcess (), from_process_handle, token_handle,
		   DUPLICATE_SAME_ACCESS, tempnode->filemap,
		   &parameters.out.filemap, TRUE) != 0)
		{
		  printf ("error duplicating filemap handle (%lu)\n",
			  GetLastError ());
		  header.error_code = EACCES;
/*mutex*/
		  CloseHandle (token_handle);
		  return;
		}
	      if (check_and_dup_handle
		  (GetCurrentProcess (), from_process_handle, token_handle,
		   DUPLICATE_SAME_ACCESS, tempnode->attachmap,
		   &parameters.out.attachmap, TRUE) != 0)
		{
		  printf ("error duplicating attachmap handle (%lu)\n",
			  GetLastError ());
		  header.error_code = EACCES;
/*mutex*/
		  CloseHandle (token_handle);
		  return;
		}
d794 2
a795 6
	      CloseHandle (token_handle);
	      return;
	    }
	  tempnode = tempnode->next;
	}
      /* couldn't find a currently open shm area. */
d797 4
a800 13
      /* create one */
      /* do this as the client */
      conn->impersonate_client ();
      /* This may need sh_none... it's only a control structure */
      HANDLE filemap = CreateFileMapping (INVALID_HANDLE_VALUE,	// system pagefile.
					  &sa,
					  PAGE_READWRITE,	// protection
					  0x00000000,
					  getsystemallocgranularity (),
					  shmname	// object name
	);
      int lasterr = GetLastError ();
      conn->revert_to_self ();
d802 3
a804 11
      if (filemap == NULL)
	{
	  /* We failed to open the filemapping ? */
	  system_printf ("failed to open file mapping: %lu\n",
			 GetLastError ());
	  // free the mutex
	  // we can assume that it exists, and that it was an access problem.
	  header.error_code = EACCES;
	  CloseHandle (token_handle);
	  return;
	}
d806 2
a807 18
      /* successfully opened the control region mapping */
      /* did we create it ? */
      int oldmapping = lasterr == ERROR_ALREADY_EXISTS;
      if (oldmapping)
	{
	  /* should never happen - we are the global daemon! */
#if 0
	  if ((parameters.in.shmflg & IPC_CREAT)
	      && (parameters.in.shmflg & IPC_EXCL))
#endif
	    {
	      /* FIXME free mutex */
	      CloseHandle (filemap);
	      header.error_code = EEXIST;
	      CloseHandle (token_handle);
	      return;
	    }
	}
d809 10
a818 10
      /* we created a new mapping */
      if (parameters.in.key != IPC_PRIVATE &&
	  (parameters.in.shmflg & IPC_CREAT) == 0)
	{
	  CloseHandle (filemap);
	  /* FIXME free mutex */
	  header.error_code = ENOENT;
	  CloseHandle (token_handle);
	  return;
	}
d820 3
a822 3
      conn->impersonate_client ();
      void *mapptr = MapViewOfFile (filemap, FILE_MAP_WRITE, 0, 0, 0);
      conn->revert_to_self ();
d824 5
a828 9
      if (!mapptr)
	{
	  CloseHandle (filemap);
	  //FIXME: close filemap and free the mutex
	  /* we couldn't access the mapped area with the requested permissions */
	  header.error_code = EACCES;
	  CloseHandle (token_handle);
	  return;
	}
d830 1
a830 12
      conn->impersonate_client ();
      /* Now get the user data */
      HANDLE attachmap = CreateFileMapping (INVALID_HANDLE_VALUE,	// system pagefile
					    &sa,
					    PAGE_READWRITE,	// protection (FIXME)
					    0x00000000,
					    parameters.in.size +
					    parameters.in.size %
					    getsystemallocgranularity (),
					    shmaname	// object name
	);
      conn->revert_to_self ();
d832 8
a839 10
      if (attachmap == NULL)
	{
	  system_printf ("failed to get shm attachmap\n");
	  header.error_code = ENOMEM;
	  UnmapViewOfFile (mapptr);
	  CloseHandle (filemap);
	  /* FIXME exit the mutex */
	  CloseHandle (token_handle);
	  return;
	}
d841 2
a842 12
      shmid_ds *shmtemp = new shmid_ds;
      if (!shmtemp)
	{
	  system_printf ("failed to malloc shm node\n");
	  header.error_code = ENOMEM;
	  UnmapViewOfFile (mapptr);
	  CloseHandle (filemap);
	  CloseHandle (attachmap);
	  /* FIXME exit mutex */
	  CloseHandle (token_handle);
	  return;
	}
d844 2
a845 58
      /* fill out the node data */
      shmtemp->shm_perm.cuid = getuid ();
      shmtemp->shm_perm.uid = shmtemp->shm_perm.cuid;
      shmtemp->shm_perm.cgid = getgid ();
      shmtemp->shm_perm.gid = shmtemp->shm_perm.cgid;
      shmtemp->shm_perm.mode = parameters.in.shmflg & 0x01ff;
      shmtemp->shm_lpid = 0;
      shmtemp->shm_nattch = 0;
      shmtemp->shm_atime = 0;
      shmtemp->shm_dtime = 0;
      shmtemp->shm_ctime = time (NULL);
      shmtemp->shm_segsz = parameters.in.size;
      *(shmid_ds *) mapptr = *shmtemp;
      shmtemp->mapptr = mapptr;

      /* no need for InterlockedExchange here, we're serialised by the global mutex */
      tempnode = new shmnode;
      tempnode->shmds = shmtemp;
      tempnode->shm_id = (int) InterlockedIncrement (&new_id);
      tempnode->key = parameters.in.key;
      tempnode->filemap = filemap;
      tempnode->attachmap = attachmap;
      tempnode->next = shm_head;
      shm_head = tempnode;

      /* we now have the area in the daemon list, opened.

	 FIXME: leave the system wide shm mutex */

      parameters.out.shm_id = tempnode->shm_id;
      if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
				token_handle,
				DUPLICATE_SAME_ACCESS,
				tempnode->filemap, &parameters.out.filemap,
				TRUE) != 0)
	{
	  printf ("error duplicating filemap handle (%lu)\n",
		  GetLastError ());
	  header.error_code = EACCES;
	  CloseHandle (token_handle);
/* mutex et al */
	  return;
	}
      if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
				token_handle,
				DUPLICATE_SAME_ACCESS,
				tempnode->attachmap,
				&parameters.out.attachmap, TRUE) != 0)
	{
	  printf ("error duplicating attachmap handle (%lu)\n",
		  GetLastError ());
	  header.error_code = EACCES;
	  CloseHandle (from_process_handle);
	  CloseHandle (token_handle);
/* more cleanup... yay! */
	  return;
	}
      CloseHandle (token_handle);
d847 4
d854 1
a854 2
  header.error_code = ENOSYS;
  CloseHandle (token_handle);
d856 32
d889 7
a895 1
  return;
@


1.8
log
@Use cygwin_{shm,ipc}.h instead of /sys/{shm,ipc}.h throughout.
* sys/ipc.h: Remove.
* sys/shm.h: Remove.
* cygwin_ipc.h: New file.
* cygwin_shm.h: New file.
@
text
@d40 1
a40 1
#include "cygwin_shm.h"
d43 1
a43 1
#include "cygwin_shm.h"
@


1.7
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d40 1
a40 1
#include <sys/shm.h>
d43 1
a43 1
#include <sys/shm.h>
@


1.6
log
@whitespace cleanup, update copyright
@
text
@d3 1
a3 1
   Copyright 2001, 2002 Red Hat, Inc.
d5 1
a5 1
   Originally written by Robert Collins <robert.collins@@hotmail.com>
d7 1
a7 5
   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */
d9 3
d365 1
a365 1
		
@


1.5
log
@2002-03-04  Robert Collins  <rbtcollins@@hotmail.com>

        * cygserver_shm.cc (delete_shmnode): New function.
        (client_request_shm::serve): Use it.
@
text
@d3 1
a3 1
   Copyright 2001 Red Hat, Inc.
d80 1
a80 1
 * Solution: manually calculate the next id value 
d139 1
a139 1
 * open. This could lead to resource starvation: we're not copying that behaviour 
d185 1
a185 1
        tempnode = tempnode->next;
d187 1
a187 1
        tempnode->next = node->next;
d201 1
a201 1
  
d210 1
a210 1
//                parameters.in.shmflg & 0x01ff, psd, &sd_size);
d219 2
a220 2
   * by the process cache until the process terminates. 
   * We may need a refcount on the cache however... 
d246 1
a246 1
   * the worst they can do is open their own permissions 
d367 3
a369 3
	        header.error_code = 0;
	        CloseHandle (token_handle);
	        return;
d412 1
a412 1
      /* On unix the same shmid identifier is returned on multiple calls to shm_get 
d436 1
a436 1
	      /* FIXME: can the same process call this twice without error ? test 
d450 1
a450 1
	      // FIXME: do we need to other tests of the requested mode with the 
d455 1
a455 1
	       * reopen the area. In fact we'll probably have to do that to get 
d498 1
a498 1
					  PAGE_READWRITE,	// protection  
d624 1
a624 1
      /* we now have the area in the daemon list, opened. 
d626 1
a626 1
         FIXME: leave the system wide shm mutex */
@


1.4
log
@2002-03-04  Robert Collins  <rbtcollins@@hotmail.com>

        * cygserver_shm.cc (client_request_shm::serve): Implement SHM_DETACH.
        * shm.cc (shmdt): Implement.
@
text
@d173 29
d358 8
@


1.3
log
@2002-03-04  Robert Collins  <rbtcollins@@hotmail.com>

        * cygserver_shm.cc: Run indent.
        (deleted_head): New global for storing shm id's pending deletion.
        (client_request_shm::serve): Return ENOSYS for invalid request types.
        Implement SHM_DEL - delete a shm id.
        * cygserver_shm.h (SHM_DEL): New type value.
        * shm.cc (delete_inprocess_shmds): New function, does what it's name implies.
        (shmctl): Implement shm_rmid control type.
@
text
@d293 20
@


1.2
log
@2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* Merged cygwin_daemon into head minus the new shm and ipc exports.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* fhandler_tty.cc (fhandler_tty_slave::open): More debugging.
	(fhandler_tty_slave::read): Fix printf type for the handle.
	* tty.cc (tty::common_init): Add a FIXME for security.

2002-01-29  Robert Collins  <rbtcollins@@hotmail.com>

	* Makefile.in (OBJS): Remove duplicate localtime.o.

2002-01-17  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (check_and_dup_handle): Consolidate the two variants for
	simplicity.
	Add Some basic debug output.
	(client_request_attach_tty::serve): Use the new debug_printf for clarity.
	Mark the duplicated handles as inheritable - fixup_after_fork() doesn't reopen
	tty's.

2002-01-16  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (transport): Correct scope.
	(client_request_attach_tty::serve): Add more debug information.
	Fix erroneous use of transport instead of conn.
	* cygserver_transport_pipes.cc (transport_layer_pipes::close): More debug.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.

Mon Oct  8  7:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (server_request::process): Rename client_request_shm_get to
	client_request_shm.
	* cygserver_process.cc (process_cache::add): Rename to add_task.
	Use process_cleanup instead of process_request.
	(process_cache::remove_process): New method.
	(process::process): Initialize new members.
	(process::~process): New member.
	(process::cleanup): New method.
	(process::add_cleanup_routine): New method.
	(process_request::process): Rename to process_cleanup.
	Call the process object's cleanup method and then delete it.
	(process_process_param::request_loop): Remove the signalling process.
	* cygserver_shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm_get::serve): Handle attach request counting.
	* cygserver_shm.h: Globally rename client_request_shm_get to client_request_shm.
	(class shm_cleanup): New class.
	* shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm::client_request_shm): New constructor for attach requests.
	(shmat): Use it.
	* include/cygwin/cygserver_process.h (class process_request): Rename to
	process_cleanup.
	(class cleanup_routine): New class.
	(class process): New members and methods to allow calling back when the process
	terminates.

Thu Oct  4 14:12:00 2001  Robert Collins <rbtcollins@@hotmail.com>
	* cygserver.cc (request_loop): Make static.
	(main): Use new cache constructor syntax.
	Start cache worker threads.
	Cleanup the cache at shutdown.
	* cygserver_process.cc: Run indent.
	(process_cache::process_cache): Add a trigger to use when adding a process.
	(process_cache::process): Move process_entry to process.
	Insert at the end of the list.
	Trigger the request loop when new process's inserted.
	(process_cache::process_requests): Do it.
	(process_cache::add): New method.
	(process_cache::handle_snapshot): New method.
	(process::process): Merge in the process_entry fields.
	(process::handle): Make a stub function.
	(process::exit_code): New method.
	(process_request::process): New method.
	(process_process_param::request_loop): New method.
	* cygserver_shm.cc: New header dependency - threaded_queue.h.
	* threaded_queue.cc (threaded_queue::cleanup): Clearer messages.
	(queue_process_param::stop): Short spinlock on interruptible threads.
	* threaded_queue.h (class threaded_queue): New constructor.
	* include/cygwin/cygserver_process.h (process_request): New class.
	(process_entry): Remove.
	(process): Merge in process_entry.
	(process_cache): Inherit from threaded_queue.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (class server_process_param): Use new constructor syntax.
	* cygserver_process.cc (process_cache::~process_cache): New function.
	* threaded_queue.cc: Define condition debug_printf.
	Run indent.
	(threaded_queue::cleanup): Move queue_process_param guts to a method.
	(threaded_queue::process_requests): Ditto.
	(queue_process_param::queue_process_param): New method.
	(queue_process_param::~queue_process_param): Ditto.
	(queue_process_param::start): Ditto.
	(queue_process_param::stop): Ditto.
	* threaded_queue.h (class queue_process_param): Add support for
	interruptible request loops.
	* cygwin/include/cygwin/cygserver_process.h (class process_cache): Add
	destructor.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver_client.cc: New flag allow_daemon to disable the daemon completely.
	(cygserver_request): Check it.
	(cygserver_init): Ditto.
	* environ.cc (parse_thing): Add (no)daemon option.

Tue Oct  2 23:00:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* shm.cc: Update to handle include changes from HEAD.

Tue Oct  2 16:06:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Remove cygserver_shm.o from cygwin1.dll.
	Rename cygserver_shm_outside.o to cygserver_shm.o.
	* cygserver.cc (server_request::process): Use the new client_request
	constructor.
	* cygserver_client.cc: Remove the #ifdef's stubs for the server method
	within cygwin.
	(client_request_attach_tty::client_request_attach_tty): Use the new
	client_request constructor.
	(client_request_shutdown::client_request_shutdown): Ditto.
	(client_request::client_request): Ditto.
	* cygserver_shm.cc (client_request_shm_get::serve): Remove the
	#ifdef'd stub for in-cygwin builds.
	(client_request_shm_get::client_request_shm_get): Use the new
	client_request constructor, and remove the in-cygwin variants.
	* cygserver_shm.h (class client_request_shm_get): #ifndef test the
	serve method - it's only used in cygserver.
	* shm.cc (client_request_shm_get::client_request_shm_get): New function.
	* include/cygwin/cygserver.h (request_header): New constructor.
	(class client_request): Use it.
	New constructor accepting the header size.
	#ifndef test the server method - it's only used within cygserver.
	(client_request_get_version): #ifdef test the server method.
	(client_request_shutdown): Ditto.
	(client_request_attach_tty): Ditto.

Tue Oct  2  9:57:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: add threaded_queue.o to cygserver.exe.
	* cygserver.cc: Include threaded_queue.h
	(class server_request): Inherit from queue_request.
	(class server_process_param): Inherit from queue_process_param.
	(class server_request_queue): Inherit from threaded_queue.
	(request_loop): Adjust for new types.
	(server_request_queue::process_requests): Remove guts to
	threaded_queue::process_requests.
	(server_request::server_request): Adjust for new types.
	(worker_function): Delete.
	(server_request_queue::create_workers): Delete.
	(server_request_queue::cleanup): Delete.
	(server_request_queue::add): Move guts to threaded_queue::add.
	* threaded_queue.cc: New file.
	* threaded_queue.h: New file.

Mon Oct  1 12:38:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (client_request::serve): New function.
	* cygserver_process.cc: Inlude <pthread.h> for pthread_once.
	(process_cache::process_cache): Initialise a crtiical section for write access.
	(process_cache::process): Use the critical section. Also add missing entries to
	the cache.
	(do_process_init): New function to initalise class process static variables.
	(process::process): Ensure that the process access critical section is
	initialised.
	(process::handle): Close the handle of old process's when they have terminated
	and we are returning the handle for a process with the same pid.
	* cygserver_shm.cc: Run indent.
	Include cygserver_process.h to allow process cache functionality.
	(client_request_shm_get::serve): New parameter for process cache support.
	Use the process cache, not OpenProcess to get a handle to the originating process.
	Fix a handle leak with token_handle.
	* cygserver_shm.h (class client_request_shm_get): Update ::serve for process
	cache support.
	* cygserver_transport_pipes.cc: Redefine debug_printf to be conditional on DEBUG.
	* include/cygwin/cygserver.h: Do not implement client_request::serve in the
	header.
	* include/cygwin/cygserver_process.h (class process_cache): Add a write access
	critical section to prevent races when requests from a  multithreaded
	application arrive.

Sun Sep 30 23:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_process.o to cygserver.exe.
	* cygserver.cc: Include signal.h and cygwin_version.h.
	Define debug_printf as a macro.
	Define DEBUG to a value.
	(client_request_attach_tty::serve): Add beginning of process cache support.
	Change from #ifdef DEBUG to work with new DEBUG style.
	(client_request_get_version::serve): Add beginning of process cache support.
	(class server_request): New prototype for support of process cache.
	(class queue_process_param): New class to allow request loop threading.
	(class server_request_queue): Add beginning of process cache support.
	Allow request loop threading.
	(request_loop): Thread function for request loops.
	(server_request_queue::process_requests): Initiator for threaded request loops.
	(client_request_shutdown::serve): Add beginning of process cache support.
	(server_request::server_request): Ditto.
	(server_request::process): Use debug_printf. Add beginning of process cache
	support.
	(server_request_queue::cleanup): Kill off any request loop threads.
	(server_request_queue::add): Add beginning of process cache support.
	(handle_signal): Trigger a shutdown.
	(main): Print out some useful info at startup - version, date time.
	Add process cache support.
	Spawn a separate thread for the transport request loop, thus allowing concurrent
	support for multiple transports.
	* cygserver_client.cc (client_request_get_version::serve): Add process cache
	support.
	(client_request_attach_tty::serve): Add process cache support.
	(client_request_shutdown::serve): Add process cache support.
	* cygsserver_process.cc: New file with the process cache support.
	* cygserver_shm.cc: Redefine debug_printf to allow conditional output.
	* cygwin.din: Export shmdt().
	* shm.cc: Run indent.
	Update FIXME's.
	(shmdt): New function.
	* include/cygwin/cygserver.h (class client_request): Add process cache support.
	(class client_request_get_version): Ditto.
	(class client_request_shutdown): Ditto.
	(class client_request_attach_tty): Ditto.
	* include/cygwin/cygserver_process.h: New header for process cache support.

Sun Sep 30  8:52:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* include/cygwin/cygserver_transport.h: Add copyright header.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.

Sat Sep 29 20:40:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_transport_sockets.o to DLL_OFILES.
	Add cygserver_transport_sockets_outside.o to cygserver.exe.
	* cygserver.cc: Include new include files.
	* cygserver_client.cc: Ditto.
	* cygserver_shm.h: No need to include <sys/socket.h> now.
	* cygerver_transport.cc: Include new include files.
	(transport_layer_base::transport_layer_base): Strip back to a stub.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.
	* cygserver_transport_pipes.cc: Include new header
	"cygwin/cygserver_transport_pipes.h".
	* cygserver_transport_sockets.cc: New file.
	* dcrt0.cc: No need to include <sys/socket.h> now.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.
	* include/cygwin/cygserver_transport.h: Strip the base class to a stub.
	Remove the cygserver_transport_pipes class.
	* include/cygwin/cygserver_transport_pipes.h: New file.
	* include/cygwin/cygserver_transport_sockets.h: New file.

Tue Sep 25 16:22:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* autoload.cc: Add dynamic load statement for 'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when obtaining
	handles from the parent process. On failure or 9x use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
	* cygserver.cc: New file.
	* cygserver_client.cc: New file.
	* cygserver_shm.cc: New file.
	* cygserver_shm.h: New file.
	* cygserver_transport.cc: New file.
	* cygserver_transport_pipes.cc: New file.
	* ipc.cc: New file.
	* shm.cc: New file.
	* include/cygwin/cygserver.h: New file.
	* include/cygwin/cygserver_transport.h: New file.
	* include/sys/ipc.h: New file.
	* include/sys/shm.h: New file.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* thread.cc (semaphore::TryWait): Set errno as required by posix 1003.1.
	(__sem_wait): Ditto.
	(__sem_trywait): Ditto.
@
text
@d73 2
a74 1
client_request_shm::client_request_shm ():client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
d84 2
a85 1
extern "C" void *
d88 3
a90 1
  class shmid_ds *shm = (class shmid_ds *) shmid;	//FIXME: verifyable object test
d99 3
a101 1
  void *rv = MapViewOfFile (shm->attachmap,
d104 3
a106 3
			    (parameters.in.shmflg & SHM_RDONLY) ?
			    FILE_MAP_READ : FILE_MAP_WRITE, 0,
			    0, 0);
d120 4
a123 1
  _shmattach *attachnode = new _shmattach;
d148 2
a149 1
extern GENERIC_MAPPING access_mapping;
d159 6
a164 1
static shmnode *shm_head = NULL;
d166 6
a171 2
static long new_id = 0;
static long new_private_key = 0;
d174 1
a174 2
client_request_shm::serve (transport_layer_base * conn,
			       process_cache * cache)
d278 3
a280 3
        {
          if (tempnode->shm_id == parameters.in.shm_id)
            {
d283 5
a287 5
              CloseHandle (token_handle);
              return;
            }
          tempnode = tempnode->next;
        }
d293 27
a319 1
  /* it's a original request from the users */
a320 3
  /* FIXME: enter the checking for existing keys mutex. This mutex _must_ be system wide
   * to prevent races on shmget.
   */
d322 1
a322 1
  if (parameters.in.key == IPC_PRIVATE)
d324 18
a341 12
      /* create the mapping name (CYGWINSHMKPRIVATE_0x01234567 */
      /* The K refers to Key, the actual mapped area has D */
      long private_key = (int) InterlockedIncrement (&new_private_key);
      snprintf (stringbuf, 29, "CYGWINSHMKPRIVATE_0x%0x", private_key);
      shmname = stringbuf;
      snprintf (stringbuf1, 29, "CYGWINSHMDPRIVATE_0x%0x", private_key);
      shmaname = stringbuf1;
    }
  else
    {
      /* create the mapping name (CYGWINSHMK0x0123456789abcdef */
      /* The K refers to Key, the actual mapped area has D */
d343 8
a350 7
      snprintf (stringbuf, 29, "CYGWINSHMK0x%0qx", parameters.in.key);
      shmname = stringbuf;
      snprintf (stringbuf1, 29, "CYGWINSHMD0x%0qx", parameters.in.key);
      shmaname = stringbuf1;
      debug_printf ("system id strings are \n%s\n%s\n", shmname, shmaname);
      debug_printf ("key input value is 0x%0qx\n", parameters.in.key);
    }
d352 1
a352 1
  /* attempt to open the key */
d354 4
a357 4
  /* get an existing key */
  /* On unix the same shmid identifier is returned on multiple calls to shm_get 
   * with the same key and size. Different modes is a ?.
   */
d361 3
a363 3
  /* walk the list of known keys and return the id if found. remember, we are
   * authoritative...
   */
d365 2
a366 5
  shmnode *tempnode = shm_head;
  while (tempnode)
    {
      if (tempnode->key == parameters.in.key
	  && parameters.in.key != IPC_PRIVATE)
d368 2
a369 3
	  // FIXME: free the mutex
	  if (parameters.in.size
	      && tempnode->shmds->shm_segsz < parameters.in.size)
d371 57
a427 1
	      header.error_code = EINVAL;
d431 37
a467 3
	  /* FIXME: can the same process call this twice without error ? test 
	   * on unix
	   */
d470 1
d472 2
a474 40
	      debug_printf
		("attempt to exclusively create already created shm_area with key 0x%0qx\n",
		 parameters.in.key);
	      // FIXME: free the mutex
	      CloseHandle (token_handle);
	      return;
	    }
	  // FIXME: do we need to other tests of the requested mode with the 
	  // tempnode->shm_id mode ? testcase on unix needed.
	  // FIXME how do we do the security test? or
	  // do we wait for shmat to bother with that?
	  /* One possibly solution: impersonate the client, and then test we can
	   * reopen the area. In fact we'll probably have to do that to get 
	   * handles back to them, alternatively just tell them the id, and then
	   * let them attempt the open.
	   */
	  parameters.out.shm_id = tempnode->shm_id;
	  if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
				    token_handle,
				    DUPLICATE_SAME_ACCESS,
				    tempnode->filemap,
				    &parameters.out.filemap, TRUE) != 0)
	    {
	      printf ("error duplicating filemap handle (%lu)\n",
		      GetLastError ());
	      header.error_code = EACCES;
/*mutex*/
	      CloseHandle (token_handle);
	      return;
	    }
	  if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
				    token_handle,
				    DUPLICATE_SAME_ACCESS,
				    tempnode->attachmap,
				    &parameters.out.attachmap, TRUE) != 0)
	    {
	      printf ("error duplicating attachmap handle (%lu)\n",
		      GetLastError ());
	      header.error_code = EACCES;
/*mutex*/
d478 1
d480 7
a489 3
      tempnode = tempnode->next;
    }
  /* couldn't find a currently open shm area. */
d491 3
a493 24
  /* create one */
  /* do this as the client */
  conn->impersonate_client ();
  /* This may need sh_none... it's only a control structure */
  HANDLE filemap = CreateFileMapping (INVALID_HANDLE_VALUE,	// system pagefile.
				      &sa,
				      PAGE_READWRITE,	// protection  
				      0x00000000,
				      getsystemallocgranularity (),
				      shmname	// object name
    );
  int lasterr = GetLastError ();
  conn->revert_to_self ();

  if (filemap == NULL)
    {
      /* We failed to open the filemapping ? */
      system_printf ("failed to open file mapping: %lu\n", GetLastError ());
      // free the mutex
      // we can assume that it exists, and that it was an access problem.
      header.error_code = EACCES;
      CloseHandle (token_handle);
      return;
    }
d495 1
a495 10
  /* successfully opened the control region mapping */
  /* did we create it ? */
  int oldmapping = lasterr == ERROR_ALREADY_EXISTS;
  if (oldmapping)
    {
      /* should never happen - we are the global daemon! */
#if 0
      if ((parameters.in.shmflg & IPC_CREAT)
	  && (parameters.in.shmflg & IPC_EXCL))
#endif
a496 1
	  /* FIXME free mutex */
d498 3
a500 1
	  header.error_code = EEXIST;
a503 1
    }
d505 12
a516 10
  /* we created a new mapping */
  if (parameters.in.key != IPC_PRIVATE &&
      (parameters.in.shmflg & IPC_CREAT) == 0)
    {
      CloseHandle (filemap);
      /* FIXME free mutex */
      header.error_code = ENOENT;
      CloseHandle (token_handle);
      return;
    }
d518 10
a527 3
  conn->impersonate_client ();
  void *mapptr = MapViewOfFile (filemap, FILE_MAP_WRITE, 0, 0, 0);
  conn->revert_to_self ();
d529 12
a540 9
  if (!mapptr)
    {
      CloseHandle (filemap);
      //FIXME: close filemap and free the mutex
      /* we couldn't access the mapped area with the requested permissions */
      header.error_code = EACCES;
      CloseHandle (token_handle);
      return;
    }
d542 57
a598 20
  conn->impersonate_client ();
  /* Now get the user data */
  HANDLE attachmap = CreateFileMapping (INVALID_HANDLE_VALUE,	// system pagefile
					&sa,
					PAGE_READWRITE,	// protection (FIXME)
					0x00000000,
					parameters.in.size +
					parameters.in.size %
					getsystemallocgranularity (),
					shmaname	// object name
    );
  conn->revert_to_self ();

  if (attachmap == NULL)
    {
      system_printf ("failed to get shm attachmap\n");
      header.error_code = ENOMEM;
      UnmapViewOfFile (mapptr);
      CloseHandle (filemap);
      /* FIXME exit the mutex */
a599 2
      return;
    }
a600 10
  shmid_ds *shmtemp = new shmid_ds;
  if (!shmtemp)
    {
      system_printf ("failed to malloc shm node\n");
      header.error_code = ENOMEM;
      UnmapViewOfFile (mapptr);
      CloseHandle (filemap);
      CloseHandle (attachmap);
      /* FIXME exit mutex */
      CloseHandle (token_handle);
d604 1
a604 55
  /* fill out the node data */
  shmtemp->shm_perm.cuid = getuid ();
  shmtemp->shm_perm.uid = shmtemp->shm_perm.cuid;
  shmtemp->shm_perm.cgid = getgid ();
  shmtemp->shm_perm.gid = shmtemp->shm_perm.cgid;
  shmtemp->shm_perm.mode = parameters.in.shmflg & 0x01ff;
  shmtemp->shm_lpid = 0;
  shmtemp->shm_nattch = 0;
  shmtemp->shm_atime = 0;
  shmtemp->shm_dtime = 0;
  shmtemp->shm_ctime = time (NULL);
  shmtemp->shm_segsz = parameters.in.size;
  *(shmid_ds *) mapptr = *shmtemp;
  shmtemp->mapptr = mapptr;

  /* no need for InterlockedExchange here, we're serialised by the global mutex */
  tempnode = new shmnode;
  tempnode->shmds = shmtemp;
  tempnode->shm_id = (int) InterlockedIncrement (&new_id);
  tempnode->key = parameters.in.key;
  tempnode->filemap = filemap;
  tempnode->attachmap = attachmap;
  tempnode->next = shm_head;
  shm_head = tempnode;

  /* we now have the area in the daemon list, opened. 

     FIXME: leave the system wide shm mutex */

  parameters.out.shm_id = tempnode->shm_id;
  if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
			    token_handle,
			    DUPLICATE_SAME_ACCESS,
			    tempnode->filemap, &parameters.out.filemap,
			    TRUE) != 0)
    {
      printf ("error duplicating filemap handle (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      CloseHandle (token_handle);
/* mutex et al */
      return;
    }
  if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
			    token_handle,
			    DUPLICATE_SAME_ACCESS,
			    tempnode->attachmap, &parameters.out.attachmap,
			    TRUE) != 0)
    {
      printf ("error duplicating attachmap handle (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      CloseHandle (from_process_handle);
      CloseHandle (token_handle);
/* more cleanup... yay! */
      return;
    }
d606 2
@


1.1
log
@file cygserver_shm.cc was initially added on branch cygwin_daemon.
@
text
@d1 552
@


1.1.2.1
log
@Tue Sep 25 16:22:00 2001 Robert Collins <rbtcollins@@hotmail.com>

        * autoload.cc: Add dynamic load statement for
	'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build
	instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when
	obtaining handles from the parent process. On failure or 9x
	use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
										CVS: ----------------------------------------------------------------------
@
text
@a0 530
/* shm.cc: Single unix specification IPC interface for Cygwin

   Copyright 2001 Red Hat, Inc.

   Originally written by Robert Collins <robert.collins@@hotmail.com>

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */


#ifdef __OUTSIDE_CYGWIN__
#undef __INSIDE_CYGWIN__
#else
#include "winsup.h"
#endif

#ifndef __INSIDE_CYGWIN__
#define system_printf printf
#define debug_printf printf
#define api_fatal printf
#include <stdio.h>
#include <windows.h>
#endif

#include <sys/stat.h>
#include <errno.h>
#include "cygerrno.h"
#include <unistd.h>
#include "security.h"
//#include "fhandler.h"
//#include "dtable.h"
//#include "cygheap.h"
#include <stdio.h>
//#include "thread.h"
#ifndef __INSIDE_CYGWIN__
#define __INSIDE_CYGWIN__
#include <sys/shm.h>
#undef __INSIDE_CYGWIN__
#else
#include <sys/shm.h>
#endif
//#include "perprocess.h"
#include "cygserver_shm.h"

// FIXME IS THIS CORRECT
/* Implementation notes: We use two shared memory regions per key:
 * One for the control structure, and one for the shared memory.
 * While this has a higher overhead tham a single shared area,
 * It allows more flexability. As the entire code is transparent to the user
 * We can merge these in the future should it be needed.
 * Also, IPC_PRIVATE keys create unique mappings each time. The shm_ids just
 * keep monotonically incrementing - system wide.
 */
size_t getsystemallocgranularity ()
{
  SYSTEM_INFO sysinfo;
  static size_t buffer_offset = 0;
  if (buffer_offset)
    return buffer_offset;
  GetSystemInfo (&sysinfo);
  buffer_offset = sysinfo.dwAllocationGranularity;
  return buffer_offset;
}

client_request_shm_get::client_request_shm_get () : client_request (CYGSERVER_REQUEST_SHM_GET)
{
  header.cb = sizeof (parameters);
  buffer = (char *) &parameters;
  header.error_code = 0;
}

client_request_shm_get::client_request_shm_get (int nshm_id, pid_t npid) : client_request (CYGSERVER_REQUEST_SHM_GET)
{
  header.cb = sizeof (parameters);
  buffer = (char *) &parameters;
  header.error_code = 0;
  parameters.in.shm_id = nshm_id;
  parameters.in.type = SHM_REATTACH;
  parameters.in.pid = npid;
}

client_request_shm_get::client_request_shm_get (key_t nkey, size_t nsize,
						int nshmflg, char psdbuf[4096], pid_t npid):	client_request (CYGSERVER_REQUEST_SHM_GET)
{
  header.cb = sizeof (parameters);
  buffer = (char *) &parameters;
  parameters.in.key = nkey;
  parameters.in.size = nsize;
  parameters.in.shmflg = nshmflg;
  parameters.in.type = SHM_CREATE;
  parameters.in.pid = npid;
  memcpy (parameters.in.sd_buf, psdbuf, 4096);
}

/* FIXME: If building on a 64-bit compiler, the address->int typecast will fail.
 * Solution: manually calculate the next id value 
 */

#if 0
extern "C" void *
shmat (int shmid, const void *shmaddr, int parameters.in.shmflg)
{
  class shmid_ds *shm = (class shmid_ds *) shmid;	//FIXME: verifyable object test

  if (shmaddr)
    {
      //FIXME: requested base address ?!
      set_errno (EINVAL);
      return (void *) -1;
    }

  void *rv = MapViewOfFile (shm->attachmap,

			    
			    (parameters.in.
			     shmflg & SHM_RDONLY) ? FILE_MAP_READ :
			    FILE_MAP_WRITE, 0,
			    0, 0);

  if (!rv)
    {
      //FIXME: translate GetLastError()
      set_errno (EACCES);
      return (void *) -1;
    }

/* FIXME: this needs to be globally protected to prevent a mismatch betwen
 * attach count and attachees list
 */

  InterlockedIncrement (&shm->shm_nattch);
  _shmattach *attachnode = new _shmattach;

  attachnode->data = rv;
  attachnode->next =
    (_shmattach *) InterlockedExchangePointer ((LONG *) & shm->attachhead,
					       (long int) attachnode);
  return rv;
}
#endif

/* FIXME: evaluate getuid() and getgid() against the requested mode. Then
 * choose PAGE_READWRITE | PAGE_READONLY and FILE_MAP_WRITE  |  FILE_MAP_READ
 * appropriately
 */

/* Test result from openbsd: shm ids are persistent cross process if a handle is left
 * open. This could lead to resource starvation: we're not copying that behaviour 
 * unless we have to. (It will involve acygwin1.dll gloal shared list :[ ).
 */
/* FIXME: shmid should be a verifyable object
 */

/* FIXME: on NT we should check everything against the SD. On 95 we just emulate.
 */

/* for dll size */
#ifdef __INSIDE_CYGWIN__
void
client_request_shm_get::serve (transport_layer_base * conn)
{
}
#else

extern GENERIC_MAPPING access_mapping;

extern int
check_and_dup_handle (HANDLE from_process, HANDLE to_process,
		      HANDLE from_process_token,
                      DWORD access,
                      HANDLE from_handle,
                      HANDLE* to_handle_ptr, BOOL bInheritHandle);

//FIXME: where should this live
static shmnode *shm_head = NULL;
/* must be long for InterlockedIncrement */
static long new_id = 0;
static long new_private_key = 0;

void
client_request_shm_get::serve (transport_layer_base * conn)
{
//  DWORD sd_size = 4096;
//  char sd_buf[4096];
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) parameters.in.sd_buf;
//  /* create a sd for our open requests based on shmflag & 0x01ff */
//  psd = alloc_sd (getuid (), getgid (), cygheap->user.logsrv (),
//                parameters.in.shmflg & 0x01ff, psd, &sd_size);

  HANDLE from_process_handle = NULL;
  HANDLE token_handle = NULL;
  DWORD rc;

  from_process_handle = OpenProcess (PROCESS_DUP_HANDLE, FALSE, parameters.in.pid);
  if (!from_process_handle)
    {
      printf ("error opening process (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      return;
    }

  conn->impersonate_client ();
  
  rc = OpenThreadToken (GetCurrentThread (),
  			TOKEN_QUERY,
                        TRUE,
			&token_handle);

  conn->revert_to_self ();

  if (!rc)
    {
      printf ("error opening thread token (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      CloseHandle (from_process_handle);
      return;
    }


  /* we trust the clients request - we will be doing it as them, and
   * the worst they can do is open their own permissions 
   */


  SECURITY_ATTRIBUTES sa;
  sa.nLength = sizeof (sa);
  sa.lpSecurityDescriptor = psd;
  sa.bInheritHandle = TRUE; /* the memory structures inherit ok */

  char *shmname = NULL, *shmaname = NULL;
  char stringbuf[29], stringbuf1[29];

  if (parameters.in.type == SHM_REATTACH)
    {
      /* just find and fill out the existing shm_id */
  shmnode *tempnode = shm_head;
  while (tempnode)
    {
      if (tempnode->shm_id == parameters.in.shm_id)
        {
          parameters.out.shm_id = tempnode->shm_id;
 	  parameters.out.key = tempnode->key;
  if (check_and_dup_handle (GetCurrentProcess (),from_process_handle,
                           token_handle,
                           DUPLICATE_SAME_ACCESS,
		    tempnode->filemap, &parameters.out.filemap, TRUE) != 0)
    {
      printf ("error duplicating filemap handle (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      CloseHandle (from_process_handle);
    }
     if (check_and_dup_handle (GetCurrentProcess (),from_process_handle,
		token_handle,
                DUPLICATE_SAME_ACCESS,
          tempnode->attachmap, &parameters.out.attachmap, TRUE) != 0)
    {
      printf ("error duplicating attachmap handle (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      CloseHandle (from_process_handle);
    }
          return;
        }
      tempnode = tempnode->next;
    }     
  header.error_code = EINVAL;
  return;
    }
  /* it's a original request from the users */

  /* FIXME: enter the checking for existing keys mutex. This mutex _must_ be system wide
   * to prevent races on shmget.
   */

  if (parameters.in.key == IPC_PRIVATE)
    {
      /* create the mapping name (CYGWINSHMKPRIVATE_0x01234567 */
      /* The K refers to Key, the actual mapped area has D */
      long private_key = (int) InterlockedIncrement (&new_private_key);
      snprintf (stringbuf , 29, "CYGWINSHMKPRIVATE_0x%0x", private_key);
	shmname = stringbuf;
	snprintf (stringbuf1, 29, "CYGWINSHMDPRIVATE_0x%0x", private_key);
	shmaname = stringbuf1;
    }
  else
    {
  /* create the mapping name (CYGWINSHMK0x0123456789abcdef */
  /* The K refers to Key, the actual mapped area has D */

  snprintf (stringbuf , 29, "CYGWINSHMK0x%0qx", parameters.in.key);
  shmname = stringbuf;
  snprintf (stringbuf1, 29, "CYGWINSHMD0x%0qx", parameters.in.key);
  shmaname = stringbuf1;
debug_printf ("system id strings are \n%s\n%s\n",shmname,shmaname);
debug_printf ("key input value is 0x%0qx\n", parameters.in.key);
    }

  /* attempt to open the key */

  /* get an existing key */
  /* On unix the same shmid identifier is returned on multiple calls to shm_get 
   * with the same key and size. Different modes is a ?.
   */



  /* walk the list of known keys and return the id if found. remember, we are
   * authoritative...
   */

  shmnode *tempnode = shm_head;
  while (tempnode)
    {
      if (tempnode->key == parameters.in.key
	  && parameters.in.key != IPC_PRIVATE)
	{
	  // FIXME: free the mutex
	  if (parameters.in.size
	      && tempnode->shmds->shm_segsz < parameters.in.size)
	    {
	      header.error_code = EINVAL;
	      return;
	    }
	  /* FIXME: can the same process call this twice without error ? test 
	   * on unix
	   */
	  if ((parameters.in.shmflg & IPC_CREAT)
	      && (parameters.in.shmflg & IPC_EXCL))
	    {
	      header.error_code = EEXIST;
	      debug_printf ("attempt to exclusively create already created shm_area with key 0x%0qx\n",parameters.in.key);
	      // FIXME: free the mutex
	      return;
	    }
	  // FIXME: do we need to other tests of the requested mode with the 
	  // tempnode->shm_id mode ? testcase on unix needed.
	  // FIXME how do we do the security test? or
	  // do we wait for shmat to bother with that?
	  /* One possibly solution: impersonate the client, and then test we can
	   * reopen the area. In fact we'll probably have to do that to get 
	   * handles back to them, alternatively just tell them the id, and then
	   * let them attempt the open.
	   */
	  parameters.out.shm_id = tempnode->shm_id;
if (check_and_dup_handle (GetCurrentProcess (),from_process_handle,
                           token_handle,
              DUPLICATE_SAME_ACCESS,
                    tempnode->filemap, &parameters.out.filemap,TRUE) != 0)
    {
      printf ("error duplicating filemap handle (%lu)\n", GetLastError ());
      header.error_code = EACCES;
/*mutex*/
      CloseHandle (from_process_handle);
 return;
    }
if (check_and_dup_handle (GetCurrentProcess (),from_process_handle,
                            token_handle,
                            DUPLICATE_SAME_ACCESS,
          tempnode->attachmap, &parameters.out.attachmap, TRUE) != 0)
    {
      printf ("error duplicating attachmap handle (%lu)\n", GetLastError ());
      header.error_code = EACCES;
/*mutex*/
      CloseHandle (from_process_handle);
return;
    }

	  return;
	}
      tempnode = tempnode->next;
    }
  /* couldn't find a currently open shm area. */

  /* create one */
  /* do this as the client */
  conn->impersonate_client ();
  /* This may need sh_none... it's only a control structure */
  HANDLE filemap = CreateFileMapping (INVALID_HANDLE_VALUE,	// system pagefile.
				      &sa,
				      PAGE_READWRITE,	// protection  
				      0x00000000,
				      getsystemallocgranularity (),
				      shmname	// object name
    );
  int lasterr = GetLastError ();
  conn->revert_to_self ();

  if (filemap == NULL)
    {
      /* We failed to open the filemapping ? */
      system_printf ("failed to open file mapping: %lu\n", GetLastError ());
      // free the mutex
      // we can assume that it exists, and that it was an access problem.
      header.error_code = EACCES;
      return;
    }

  /* successfully opened the control region mapping */
  /* did we create it ? */
  int oldmapping = lasterr == ERROR_ALREADY_EXISTS;
  if (oldmapping)
    {
      /* should never happen - we are the global daemon! */
#if 0
      if ((parameters.in.shmflg & IPC_CREAT)
	  && (parameters.in.shmflg & IPC_EXCL))
#endif
	{
	  /* FIXME free mutex */
	  CloseHandle (filemap);
	  header.error_code = EEXIST;
	  return;
	}
    }

    /* we created a new mapping */
    if (parameters.in.key != IPC_PRIVATE &&
	(parameters.in.shmflg & IPC_CREAT) == 0)
      {
        CloseHandle (filemap);
        /* FIXME free mutex */
        header.error_code = ENOENT;
        return;
      }

  conn->impersonate_client ();
  void *mapptr = MapViewOfFile (filemap, FILE_MAP_WRITE, 0, 0, 0);
  conn->revert_to_self ();

  if (!mapptr)
    {
      CloseHandle (filemap);
      //FIXME: close filemap and free the mutex
      /* we couldn't access the mapped area with the requested permissions */
      header.error_code = EACCES;
      return;
    }

  conn->impersonate_client ();
  /* Now get the user data */
  HANDLE attachmap = CreateFileMapping (INVALID_HANDLE_VALUE,	// system pagefile
					&sa,
					PAGE_READWRITE,	// protection (FIXME)
					0x00000000,
					parameters.in.size +
					parameters.in.size %
					getsystemallocgranularity (),
					shmaname	// object name
    );
  conn->revert_to_self ();

  if (attachmap == NULL)
    {
      system_printf ("failed to get shm attachmap\n");
      header.error_code = ENOMEM;
      UnmapViewOfFile (mapptr);
      CloseHandle (filemap);
      /* FIXME exit the mutex */
      return;
    }

  shmid_ds *shmtemp = new shmid_ds;
  if (!shmtemp)
    {
      system_printf ("failed to malloc shm node\n");
      header.error_code = ENOMEM;
      UnmapViewOfFile (mapptr);
      CloseHandle (filemap);
      CloseHandle (attachmap);
      /* FIXME exit mutex */
      return;
    }

  /* fill out the node data */
  shmtemp->shm_perm.cuid = getuid ();
  shmtemp->shm_perm.uid = shmtemp->shm_perm.cuid;
  shmtemp->shm_perm.cgid = getgid ();
  shmtemp->shm_perm.gid = shmtemp->shm_perm.cgid;
  shmtemp->shm_perm.mode = parameters.in.shmflg & 0x01ff;
  shmtemp->shm_lpid = 0;
  shmtemp->shm_nattch = 0;
  shmtemp->shm_atime = 0;
  shmtemp->shm_dtime = 0;
  shmtemp->shm_ctime = time (NULL);
  shmtemp->shm_segsz = parameters.in.size;
  *(shmid_ds *) mapptr = *shmtemp;
  shmtemp->mapptr = mapptr;

  /* no need for InterlockedExchange here, we're serialised by the global mutex */
  tempnode = new shmnode;
  tempnode->shmds = shmtemp;
  tempnode->shm_id = (int) InterlockedIncrement (&new_id);
  tempnode->key = parameters.in.key;
  tempnode->filemap = filemap;
  tempnode->attachmap = attachmap;
  tempnode->next = shm_head;
  shm_head = tempnode;

  /* we now have the area in the daemon list, opened. 

  FIXME: leave the system wide shm mutex */

  parameters.out.shm_id = tempnode->shm_id;
if (check_and_dup_handle (GetCurrentProcess (),from_process_handle,
                           token_handle,
              DUPLICATE_SAME_ACCESS,
                    tempnode->filemap, &parameters.out.filemap, TRUE) != 0)
    {
      printf ("error duplicating filemap handle (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      CloseHandle (from_process_handle);
/* mutex et al */
return;
    }
if (check_and_dup_handle (GetCurrentProcess (),from_process_handle,
                            token_handle,
                           DUPLICATE_SAME_ACCESS,
          tempnode->attachmap, &parameters.out.attachmap, TRUE) != 0)
    {
      printf ("error duplicating attachmap handle (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      CloseHandle (from_process_handle);
/* more cleanup... yay! */
return;
    }
  return;
}
#endif
@


1.1.2.2
log
@Sun Sep 30 23:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * Makefile.in: Add cygserver_process.o to cygserver.exe.
        * cygserver.cc: Include signal.h and cygwin_version.h.
        Define debug_printf as a macro.
        Define DEBUG to a value.
        (client_request_attach_tty::serve): Add beginning of process cache support.
        Change from #ifdef DEBUG to work with new DEBUG style.
        (client_request_get_version::serve): Add beginning of process cache support.
        (class server_request): New prototype for support of process cache.
        (class queue_process_param): New class to allow request loop threading.
        (class server_request_queue): Add beginning of process cache support.
        Allow request loop threading.
        (request_loop): Thread function for request loops.
        (server_request_queue::process_requests): Initiator for threaded request loops.
        (client_request_shutdown::serve): Add beginning of process cache support.
        (server_request::server_request): Ditto.
        (server_request::process): Use debug_printf. Add beginning of process cache support.
        (server_request_queue::cleanup): Kill off any request loop threads.
        (server_request_queue::add): Add beginning of process cache support.
        (handle_signal): Trigger a shutdown.
        (main): Print out some useful info at startup - version, date time.
        Add process cache support.
        Spawn a separate thread for the transport request loop, thus allowing concurrent
        support for multiple transports.
        * cygserver_client.cc (client_request_get_version::serve): Add process cache support.
        (client_request_attach_tty::serve): Add process cache support.
        (client_request_shutdown::serve): Add process cache support.
        * cygsserver_process.cc: New file with the process cache support.
        * cygserver_shm.cc: Redefine debug_printf to allow conditional output.
        * cygwin.din: Export shmdt().
        * shm.cc: Run indent.
        Update FIXME's.
        (shmdt): New function.
        * include/cygwin/cygserver.h (class client_request): Add process cache support.
        (class client_request_get_version): Ditto.
        (class client_request_shutdown): Ditto.
        (class client_request_attach_tty): Ditto.
        * include/cygwin/cygserver_process.h: New header for process cache support.
@
text
@d1 1
a1 1
/* cygserver_shm.cc: Single unix specification IPC interface for Cygwin
a20 1
#define DEBUG 0
d22 1
a22 1
#define debug_printf if (DEBUG) printf
d296 2
a297 2
  debug_printf ("system id strings are \n%s\n%s\n",shmname,shmaname);
  debug_printf ("key input value is 0x%0qx\n", parameters.in.key);
@


1.1.2.3
log
@Mon Oct  1 12:38:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * cygserver.cc (client_request::serve): New function.
        * cygserver_process.cc: Inlude <pthread.h> for pthread_once.
        (process_cache::process_cache): Initialise a crtiical section for write access.
        (process_cache::process): Use the critical section. Also add missing entries to
        the cache.
        (do_process_init): New function to initalise class process static variables.
        (process::process): Ensure that the process access critical section is initialised.
        (process::handle): Close the handle of old process's when they have terminated
        and we are returning the handle for a process with the same pid.
        * cygserver_shm.cc: Run indent.
        Include cygserver_process.h to allow process cache functionality.
        (client_request_shm_get::serve): New parameter for process cache support.
        Use the process cache, not OpenProcess to get a handle to the originating process.
        Fix a handle leak with token_handle.
        * cygserver_shm.h (class client_request_shm_get): Update ::serve for process cache support.
        * cygserver_transport_pipes.cc: Redefine debug_printf to be conditional on DEBUG.
        * include/cygwin/cygserver.h: Do not implement client_request::serve in the header.
        * include/cygwin/cygserver_process.h (class process_cache): Add a write access cri
tical section to prevent races when requests from a  multithreaded application arrive.
@
text
@a47 1
#include <cygwin/cygserver_process.h>
d58 1
a58 2
size_t
getsystemallocgranularity ()
d69 1
a69 1
client_request_shm_get::client_request_shm_get ():client_request (CYGSERVER_REQUEST_SHM_GET)
d76 1
a76 2
client_request_shm_get::client_request_shm_get (int nshm_id, pid_t npid):
client_request (CYGSERVER_REQUEST_SHM_GET)
d87 1
a87 4
						int nshmflg,
						char psdbuf[4096],
						pid_t npid):
client_request (CYGSERVER_REQUEST_SHM_GET)
d118 4
a121 3

			    (parameters.in.shmflg & SHM_RDONLY) ?
			    FILE_MAP_READ : FILE_MAP_WRITE, 0,
d164 1
a164 2
client_request_shm_get::serve (transport_layer_base * conn,
			       process_cache * cache)
d174 3
a176 3
		      DWORD access,
		      HANDLE from_handle,
		      HANDLE * to_handle_ptr, BOOL bInheritHandle);
d185 1
a185 2
client_request_shm_get::serve (transport_layer_base * conn,
			       process_cache * cache)
d198 1
a198 6
  from_process_handle = cache->process (parameters.in.pid)->handle ();
  /* possible TODO: reduce the access on the handle before we use it */
  /* Note that unless we do this, we don't need to call CloseHandle - it's kept open
   * by the process cache until the process terminates. 
   * We may need a refcount on the cache however... 
   */
d201 1
a201 1
      debug_printf ("error opening process (%lu)\n", GetLastError ());
d207 1
a207 1

d209 3
a211 1
			TOKEN_QUERY, TRUE, &token_handle);
d217 1
a217 1
      debug_printf ("error opening thread token (%lu)\n", GetLastError ());
d232 1
a232 1
  sa.bInheritHandle = TRUE;	/* the memory structures inherit ok */
d240 31
a270 33
      shmnode *tempnode = shm_head;
      while (tempnode)
	{
	  if (tempnode->shm_id == parameters.in.shm_id)
	    {
	      parameters.out.shm_id = tempnode->shm_id;
	      parameters.out.key = tempnode->key;
	      if (check_and_dup_handle
		  (GetCurrentProcess (), from_process_handle, token_handle,
		   DUPLICATE_SAME_ACCESS, tempnode->filemap,
		   &parameters.out.filemap, TRUE) != 0)
		{
		  debug_printf ("error duplicating filemap handle (%lu)\n",
				GetLastError ());
		  header.error_code = EACCES;
		}
	      if (check_and_dup_handle
		  (GetCurrentProcess (), from_process_handle, token_handle,
		   DUPLICATE_SAME_ACCESS, tempnode->attachmap,
		   &parameters.out.attachmap, TRUE) != 0)
		{
		  debug_printf ("error duplicating attachmap handle (%lu)\n",
				GetLastError ());
		  header.error_code = EACCES;
		}
	      CloseHandle (token_handle);
	      return;
	    }
	  tempnode = tempnode->next;
	}
      header.error_code = EINVAL;
      CloseHandle (token_handle);
      return;
d283 4
a286 4
      snprintf (stringbuf, 29, "CYGWINSHMKPRIVATE_0x%0x", private_key);
      shmname = stringbuf;
      snprintf (stringbuf1, 29, "CYGWINSHMDPRIVATE_0x%0x", private_key);
      shmaname = stringbuf1;
d290 2
a291 2
      /* create the mapping name (CYGWINSHMK0x0123456789abcdef */
      /* The K refers to Key, the actual mapped area has D */
d293 6
a298 6
      snprintf (stringbuf, 29, "CYGWINSHMK0x%0qx", parameters.in.key);
      shmname = stringbuf;
      snprintf (stringbuf1, 29, "CYGWINSHMD0x%0qx", parameters.in.key);
      shmaname = stringbuf1;
      debug_printf ("system id strings are \n%s\n%s\n", shmname, shmaname);
      debug_printf ("key input value is 0x%0qx\n", parameters.in.key);
a324 1
	      CloseHandle (token_handle);
d334 1
a334 3
	      debug_printf
		("attempt to exclusively create already created shm_area with key 0x%0qx\n",
		 parameters.in.key);
a335 1
	      CloseHandle (token_handle);
d348 7
a354 9
	  if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
				    token_handle,
				    DUPLICATE_SAME_ACCESS,
				    tempnode->filemap,
				    &parameters.out.filemap, TRUE) != 0)
	    {
	      printf ("error duplicating filemap handle (%lu)\n",
		      GetLastError ());
	      header.error_code = EACCES;
d356 10
a365 12
	      CloseHandle (token_handle);
	      return;
	    }
	  if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
				    token_handle,
				    DUPLICATE_SAME_ACCESS,
				    tempnode->attachmap,
				    &parameters.out.attachmap, TRUE) != 0)
	    {
	      printf ("error duplicating attachmap handle (%lu)\n",
		      GetLastError ());
	      header.error_code = EACCES;
d367 3
a369 3
	      CloseHandle (token_handle);
	      return;
	    }
a370 1
	  CloseHandle (token_handle);
a397 1
      CloseHandle (token_handle);
a414 1
	  CloseHandle (token_handle);
d419 9
a427 10
  /* we created a new mapping */
  if (parameters.in.key != IPC_PRIVATE &&
      (parameters.in.shmflg & IPC_CREAT) == 0)
    {
      CloseHandle (filemap);
      /* FIXME free mutex */
      header.error_code = ENOENT;
      CloseHandle (token_handle);
      return;
    }
a438 1
      CloseHandle (token_handle);
a461 1
      CloseHandle (token_handle);
a473 1
      CloseHandle (token_handle);
d504 1
a504 1
     FIXME: leave the system wide shm mutex */
d507 4
a510 5
  if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
			    token_handle,
			    DUPLICATE_SAME_ACCESS,
			    tempnode->filemap, &parameters.out.filemap,
			    TRUE) != 0)
d514 1
a514 1
      CloseHandle (token_handle);
d516 1
a516 1
      return;
d518 4
a521 5
  if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
			    token_handle,
			    DUPLICATE_SAME_ACCESS,
			    tempnode->attachmap, &parameters.out.attachmap,
			    TRUE) != 0)
a525 1
      CloseHandle (token_handle);
d527 1
a527 1
      return;
a528 1
  CloseHandle (token_handle);
@


1.1.2.4
log
@Tue Oct  2 16:06:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * Makefile.in: Remove cygserver_shm.o from cygwin1.dll.
        Rename cygserver_shm_outside.o to cygserver_shm.o.
        * cygserver.cc (server_request::process): Use the new client_request
        constructor.
        * cygserver_client.cc: Remove the #ifdef's stubs for the server method
        within cygwin.
        (client_request_attach_tty::client_request_attach_tty): Use the new
        client_request constructor.
        (client_request_shutdown::client_request_shutdown): Ditto.
        (client_request::client_request): Ditto.
        * cygserver_shm.cc (client_request_shm_get::serve): Remove the
        #ifdef'd stub for in-cygwin builds.
        (client_request_shm_get::client_request_shm_get): Use the new
        client_request constructor, and remove the in-cygwin variants.
        * cygserver_shm.h (class client_request_shm_get): #ifndef test the
        serve method - it's only used in cygserver.
        * shm.cc (client_request_shm_get::client_request_shm_get): New function.
        * include/cygwin/cygserver.h (request_header): New constructor.
        (class client_request): Use it.
        New constructor accepting the header size.
        #ifndef test the server method - it's only used within cygserver.
        (client_request_get_version): #ifdef test the server method.
        (client_request_shutdown): Ditto.
        (client_request_attach_tty): Ditto.
@
text
@d71 17
d89 5
a93 1
client_request_shm_get::client_request_shm_get ():client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
d95 1
d97 6
d166 9
d562 1
@


1.1.2.5
log
@Thu Oct  4 14:12:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * cygserver.cc (request_loop): Make static.
        (main): Use new cache constructor syntax.
        Start cache worker threads.
        Cleanup the cache at shutdown.
        * cygserver_process.cc: Run indent.
        (process_cache::process_cache): Add a trigger to use when adding a process.
        (process_cache::process): Move process_entry to process.
        Insert at the end of the list.
        Trigger the request loop when new process's inserted.
        (process_cache::process_requests): Do it.
        (process_cache::add): New method.
        (process_cache::handle_snapshot): New method.
        (process::process): Merge in the process_entry fields.
        (process::handle): Make a stub function.
        (process::exit_code): New method.
        (process_request::process): New method.
        (process_process_param::request_loop): New method.
        * cygserver_shm.cc: New header dependency - threaded_queue.h.
        * threaded_queue.cc (threaded_queue::cleanup): Clearer messages.
        (queue_process_param::stop): Short spinlock on interruptible threads.
        * threaded_queue.h (class threaded_queue): New constructor.
        * include/cygwin/cygserver_process.h (process_request): New class.
        (process_entry): Remove.
        (process): Merge in process_entry.
        (process_cache): Inherit from threaded_queue.
@
text
@a47 1
#include <threaded_queue.h>
@


1.1.2.6
log
@Mon Oct  8  7:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * cygserver.cc (server_request::process): Rename client_request_shm_get to
        client_request_shm.
        * cygserver_process.cc (process_cache::add): Rename to add_task.
        Use process_cleanup instead of process_request.
        (process_cache::remove_process): New method.
        (process::process): Initialize new members.
        (process::~process): New member.
        (process::cleanup): New method.
        (process::add_cleanup_routine): New method.
        (process_request::process): Rename to process_cleanup.
        Call the process object's cleanup method and then delete it.
        (process_process_param::request_loop): Remove the signalling process.
        * cygserver_shm.cc: Globally rename client_request_shm_get to client_request_shm.
        (client_request_shm_get::serve): Handle attach request counting.
        * cygserver_shm.h: Globally rename client_request_shm_get to client_request_shm.
        (class shm_cleanup): New class.
        * shm.cc: Globally rename client_request_shm_get to client_request_shm.
        (client_request_shm::client_request_shm): New constructor for attach requests.
        (shmat): Use it.
        * include/cygwin/cygserver_process.h (class process_request): Rename to
        process_cleanup.
        (class cleanup_routine): New class.
        (class process): New members and methods to allow calling back when the process
        terminates.
@
text
@d47 1
a49 1
#include "cygserver_shm.h"
d73 1
a73 1
client_request_shm::client_request_shm ():client_request (CYGSERVER_REQUEST_SHM_GET, sizeof (parameters))
d155 1
a155 1
client_request_shm::serve (transport_layer_base * conn,
a210 1
  /* TODO: make this code block a function! */
a247 26

  /* someone attached */
  /* someone can send shm_id's they don't have and currently we will increment those
   * attach counts. If someone wants to fix that, please go ahead.
   * The problem is that shm_get has nothing to do with the ability to attach. Attach
   * requires a permission check, which we get the OS to do in MapViewOfFile.
   */
  if (parameters.in.type == SHM_ATTACH)
    {
      shmnode *tempnode = shm_head;
      while (tempnode)
        {
          if (tempnode->shm_id == parameters.in.shm_id)
            {
	      InterlockedIncrement (&tempnode->shmds->shm_nattch);
	      header.error_code = 0;
              CloseHandle (token_handle);
              return;
            }
          tempnode = tempnode->next;
        }
      header.error_code = EINVAL;
      CloseHandle (token_handle);
      return;
    }

@


1.1.2.7
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
Copyright 2001, 2002 Red Hat, Inc.
d5 1
a5 1
Originally written by Robert Collins <robert.collins@@hotmail.com>
d7 5
a11 1
This file is part of Cygwin.
a12 3
This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
d73 1
a73 2
client_request_shm::client_request_shm ():client_request (CYGSERVER_REQUEST_SHM_GET,
		sizeof (parameters))
d79 1
a79 1
 * Solution: manually calculate the next id value
d83 1
a83 2
extern
"C" void *
d86 1
a86 3
  class shmid_ds *
    shm = (class shmid_ds *)
    shmid;			//FIXME: verifyable object test
d95 1
a95 3
  void *
    rv =
    MapViewOfFile (shm->attachmap,
d98 3
a100 3
		   (parameters.in.shmflg & SHM_RDONLY) ?
		   FILE_MAP_READ : FILE_MAP_WRITE, 0,
		   0, 0);
d114 1
a114 4
  _shmattach *
    attachnode =
    new
    _shmattach;
d130 1
a130 1
 * open. This could lead to resource starvation: we're not copying that behaviour
d139 1
a139 2
extern GENERIC_MAPPING
  access_mapping;
d149 1
a149 6
static shmnode *
  shm_head =
  NULL;
//FIXME: ditto.
static shmnode *
  deleted_head = NULL;
d151 2
a152 35
static long
  new_id =
  0;
static long
  new_private_key =
  0;

static void
delete_shmnode (shmnode **nodeptr)
{
  shmnode *node = *nodeptr;

  // remove from the list
  if (node == shm_head)
    shm_head = shm_head->next;
  else
    {
      shmnode *tempnode = shm_head;
      while (tempnode && tempnode->next != node)
	tempnode = tempnode->next;
      if (tempnode)
	tempnode->next = node->next;
      // else log the unexpected !
    }

    // release the shared data view
    UnmapViewOfFile (node->shmds->mapptr);
    delete node->shmds;
    CloseHandle (node->filemap);
    CloseHandle (node->attachmap);

    // free the memory
    delete node;
    nodeptr = NULL;
}
d155 2
a156 1
client_request_shm::serve (transport_layer_base * conn, process_cache * cache)
d163 1
a163 1
//		    parameters.in.shmflg & 0x01ff, psd, &sd_size);
d172 2
a173 2
   * by the process cache until the process terminates.
   * We may need a refcount on the cache however...
d199 1
a199 1
   * the worst they can do is open their own permissions
d260 3
a262 3
	{
	  if (tempnode->shm_id == parameters.in.shm_id)
	    {
d265 5
a269 5
	      CloseHandle (token_handle);
	      return;
	    }
	  tempnode = tempnode->next;
	}
d275 5
a279 19
  /* Someone detached */
  if (parameters.in.type == SHM_DETACH)
    {
      shmnode *tempnode = shm_head;
      while (tempnode)
	{
	  if (tempnode->shm_id == parameters.in.shm_id)
	    {
	      InterlockedDecrement (&tempnode->shmds->shm_nattch);
	      header.error_code = 0;
	      CloseHandle (token_handle);
	      return;
	    }
	  tempnode = tempnode->next;
	}
      header.error_code = EINVAL;
      CloseHandle (token_handle);
      return;
    }
d281 1
a281 2
  /* Someone wants the ID removed. */
  if (parameters.in.type == SHM_DEL)
d283 7
a289 31
      shmnode **tempnode = &shm_head;
      while (*tempnode)
	  {
	    if ((*tempnode)->shm_id == parameters.in.shm_id)
	      {
		// unlink from the accessible node list
		shmnode *temp2 = *tempnode;
		*tempnode = temp2->next;
		// link into the deleted list
		temp2->next = deleted_head;
		deleted_head = temp2;

		// FIXME: when/where do we delete the handles?
		if (temp2->shmds->shm_nattch)
		  {
		    // FIXME: add to a pending queue?
		  }
		else
		  {
		    delete_shmnode (&temp2);
		  }

		header.error_code = 0;
		CloseHandle (token_handle);
		return;
	      }
	    tempnode = &(*tempnode)->next;
	  }
      header.error_code = EINVAL;
      CloseHandle (token_handle);
      return;
d291 1
a291 3


  if (parameters.in.type == SHM_CREATE)
d293 2
a294 3
      /* FIXME: enter the checking for existing keys mutex. This mutex _must_ be system wide
       * to prevent races on shmget.
       */
d296 7
a302 14
      if (parameters.in.key == IPC_PRIVATE)
	{
	  /* create the mapping name (CYGWINSHMKPRIVATE_0x01234567 */
	  /* The K refers to Key, the actual mapped area has D */
	  long private_key = (int) InterlockedIncrement (&new_private_key);
	  snprintf (stringbuf, 29, "CYGWINSHMKPRIVATE_0x%0x", private_key);
	  shmname = stringbuf;
	  snprintf (stringbuf1, 29, "CYGWINSHMDPRIVATE_0x%0x", private_key);
	  shmaname = stringbuf1;
	}
      else
	{
	  /* create the mapping name (CYGWINSHMK0x0123456789abcdef */
	  /* The K refers to Key, the actual mapped area has D */
d304 1
a304 8
	  snprintf (stringbuf, 29, "CYGWINSHMK0x%0qx", parameters.in.key);
	  shmname = stringbuf;
	  snprintf (stringbuf1, 29, "CYGWINSHMD0x%0qx", parameters.in.key);
	  shmaname = stringbuf1;
	  debug_printf ("system id strings are \n%s\n%s\n", shmname,
			shmaname);
	  debug_printf ("key input value is 0x%0qx\n", parameters.in.key);
	}
d306 4
a309 1
      /* attempt to open the key */
a310 4
      /* get an existing key */
      /* On unix the same shmid identifier is returned on multiple calls to shm_get
       * with the same key and size. Different modes is a ?.
       */
d313 3
d317 5
a321 6
      /* walk the list of known keys and return the id if found. remember, we are
       * authoritative...
       */

      shmnode *tempnode = shm_head;
      while (tempnode)
d323 3
a325 2
	  if (tempnode->key == parameters.in.key
	      && parameters.in.key != IPC_PRIVATE)
d327 1
a327 57
	      // FIXME: free the mutex
	      if (parameters.in.size
		  && tempnode->shmds->shm_segsz < parameters.in.size)
		{
		  header.error_code = EINVAL;
		  CloseHandle (token_handle);
		  return;
		}
	      /* FIXME: can the same process call this twice without error ? test
	       * on unix
	       */
	      if ((parameters.in.shmflg & IPC_CREAT)
		  && (parameters.in.shmflg & IPC_EXCL))
		{
		  header.error_code = EEXIST;
		  debug_printf
		    ("attempt to exclusively create already created shm_area with key 0x%0qx\n",
		     parameters.in.key);
		  // FIXME: free the mutex
		  CloseHandle (token_handle);
		  return;
		}
	      // FIXME: do we need to other tests of the requested mode with the
	      // tempnode->shm_id mode ? testcase on unix needed.
	      // FIXME how do we do the security test? or
	      // do we wait for shmat to bother with that?
	      /* One possibly solution: impersonate the client, and then test we can
	       * reopen the area. In fact we'll probably have to do that to get
	       * handles back to them, alternatively just tell them the id, and then
	       * let them attempt the open.
	       */
	      parameters.out.shm_id = tempnode->shm_id;
	      if (check_and_dup_handle
		  (GetCurrentProcess (), from_process_handle, token_handle,
		   DUPLICATE_SAME_ACCESS, tempnode->filemap,
		   &parameters.out.filemap, TRUE) != 0)
		{
		  printf ("error duplicating filemap handle (%lu)\n",
			  GetLastError ());
		  header.error_code = EACCES;
/*mutex*/
		  CloseHandle (token_handle);
		  return;
		}
	      if (check_and_dup_handle
		  (GetCurrentProcess (), from_process_handle, token_handle,
		   DUPLICATE_SAME_ACCESS, tempnode->attachmap,
		   &parameters.out.attachmap, TRUE) != 0)
		{
		  printf ("error duplicating attachmap handle (%lu)\n",
			  GetLastError ());
		  header.error_code = EACCES;
/*mutex*/
		  CloseHandle (token_handle);
		  return;
		}

d331 3
a333 37
	  tempnode = tempnode->next;
	}
      /* couldn't find a currently open shm area. */

      /* create one */
      /* do this as the client */
      conn->impersonate_client ();
      /* This may need sh_none... it's only a control structure */
      HANDLE filemap = CreateFileMapping (INVALID_HANDLE_VALUE,	// system pagefile.
					  &sa,
					  PAGE_READWRITE,	// protection
					  0x00000000,
					  getsystemallocgranularity (),
					  shmname	// object name
	);
      int lasterr = GetLastError ();
      conn->revert_to_self ();

      if (filemap == NULL)
	{
	  /* We failed to open the filemapping ? */
	  system_printf ("failed to open file mapping: %lu\n",
			 GetLastError ());
	  // free the mutex
	  // we can assume that it exists, and that it was an access problem.
	  header.error_code = EACCES;
	  CloseHandle (token_handle);
	  return;
	}

      /* successfully opened the control region mapping */
      /* did we create it ? */
      int oldmapping = lasterr == ERROR_ALREADY_EXISTS;
      if (oldmapping)
	{
	  /* should never happen - we are the global daemon! */
#if 0
a335 1
#endif
a336 2
	      /* FIXME free mutex */
	      CloseHandle (filemap);
d338 40
a380 1
	}
a381 7
      /* we created a new mapping */
      if (parameters.in.key != IPC_PRIVATE &&
	  (parameters.in.shmflg & IPC_CREAT) == 0)
	{
	  CloseHandle (filemap);
	  /* FIXME free mutex */
	  header.error_code = ENOENT;
d385 3
d389 24
a412 3
      conn->impersonate_client ();
      void *mapptr = MapViewOfFile (filemap, FILE_MAP_WRITE, 0, 0, 0);
      conn->revert_to_self ();
d414 10
a423 1
      if (!mapptr)
d425 1
d427 1
a427 3
	  //FIXME: close filemap and free the mutex
	  /* we couldn't access the mapped area with the requested permissions */
	  header.error_code = EACCES;
d431 1
d433 14
a446 12
      conn->impersonate_client ();
      /* Now get the user data */
      HANDLE attachmap = CreateFileMapping (INVALID_HANDLE_VALUE,	// system pagefile
					    &sa,
					    PAGE_READWRITE,	// protection (FIXME)
					    0x00000000,
					    parameters.in.size +
					    parameters.in.size %
					    getsystemallocgranularity (),
					    shmaname	// object name
	);
      conn->revert_to_self ();
d448 9
a456 10
      if (attachmap == NULL)
	{
	  system_printf ("failed to get shm attachmap\n");
	  header.error_code = ENOMEM;
	  UnmapViewOfFile (mapptr);
	  CloseHandle (filemap);
	  /* FIXME exit the mutex */
	  CloseHandle (token_handle);
	  return;
	}
d458 12
a469 12
      shmid_ds *shmtemp = new shmid_ds;
      if (!shmtemp)
	{
	  system_printf ("failed to malloc shm node\n");
	  header.error_code = ENOMEM;
	  UnmapViewOfFile (mapptr);
	  CloseHandle (filemap);
	  CloseHandle (attachmap);
	  /* FIXME exit mutex */
	  CloseHandle (token_handle);
	  return;
	}
d471 7
a477 57
      /* fill out the node data */
      shmtemp->shm_perm.cuid = getuid ();
      shmtemp->shm_perm.uid = shmtemp->shm_perm.cuid;
      shmtemp->shm_perm.cgid = getgid ();
      shmtemp->shm_perm.gid = shmtemp->shm_perm.cgid;
      shmtemp->shm_perm.mode = parameters.in.shmflg & 0x01ff;
      shmtemp->shm_lpid = 0;
      shmtemp->shm_nattch = 0;
      shmtemp->shm_atime = 0;
      shmtemp->shm_dtime = 0;
      shmtemp->shm_ctime = time (NULL);
      shmtemp->shm_segsz = parameters.in.size;
      *(shmid_ds *) mapptr = *shmtemp;
      shmtemp->mapptr = mapptr;

      /* no need for InterlockedExchange here, we're serialised by the global mutex */
      tempnode = new shmnode;
      tempnode->shmds = shmtemp;
      tempnode->shm_id = (int) InterlockedIncrement (&new_id);
      tempnode->key = parameters.in.key;
      tempnode->filemap = filemap;
      tempnode->attachmap = attachmap;
      tempnode->next = shm_head;
      shm_head = tempnode;

      /* we now have the area in the daemon list, opened.

	 FIXME: leave the system wide shm mutex */

      parameters.out.shm_id = tempnode->shm_id;
      if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
				token_handle,
				DUPLICATE_SAME_ACCESS,
				tempnode->filemap, &parameters.out.filemap,
				TRUE) != 0)
	{
	  printf ("error duplicating filemap handle (%lu)\n",
		  GetLastError ());
	  header.error_code = EACCES;
	  CloseHandle (token_handle);
/* mutex et al */
	  return;
	}
      if (check_and_dup_handle (GetCurrentProcess (), from_process_handle,
				token_handle,
				DUPLICATE_SAME_ACCESS,
				tempnode->attachmap,
				&parameters.out.attachmap, TRUE) != 0)
	{
	  printf ("error duplicating attachmap handle (%lu)\n",
		  GetLastError ());
	  header.error_code = EACCES;
	  CloseHandle (from_process_handle);
	  CloseHandle (token_handle);
/* more cleanup... yay! */
	  return;
	}
d479 2
d482 10
d495 55
a549 1
  header.error_code = ENOSYS;
a550 2


@


1.1.2.8
log
@	* woutsup.h: New file.
	* cygserver.cc: Use "woutsup.h" and new XXX_printf macros.
	(getfunc): New function, copied verbatim from "strace.cc".
	(__cygserver__printf): New function.
	* cygserver_client.cc: Use "woutsup.h" and new XXX_printf macros.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* threaded_queue.cc: Ditto.
	* shm.cc: Remove trailing \n from XXX_printf format strings.
	* Makefile.in: Remove redundant __OUTSIDE_CYGWIN__ case for
	cygserver_shm.cc.
@
text
@d13 14
a26 1
#include "woutsup.h"
d28 1
a28 1
// #include <sys/stat.h>
a29 2
#include <stdio.h>
#include <time.h>
d36 1
d38 1
d42 3
d223 1
a223 1
      debug_printf ("error opening process (%lu)", GetLastError ());
d237 1
a237 1
      debug_printf ("error opening thread token (%lu)", GetLastError ());
d273 1
a273 1
		  debug_printf ("error duplicating filemap handle (%lu)",
d282 1
a282 1
		  debug_printf ("error duplicating attachmap handle (%lu)",
d403 1
a403 1
	  debug_printf ("system id strings: %s, %s", shmname,
d405 1
a405 1
	  debug_printf ("key input value is 0x%0qx", parameters.in.key);
d443 1
a443 1
		    ("attempt to exclusively create already created shm_area with key 0x%0qx",
d464 2
a465 2
		  system_printf ("error duplicating filemap handle (%lu)",
				 GetLastError ());
d476 2
a477 2
		  system_printf ("error duplicating attachmap handle (%lu)",
				 GetLastError ());
d508 1
a508 1
	  system_printf ("failed to open file mapping: %lu",
d576 1
a576 1
	  system_printf ("failed to get shm attachmap");
d588 1
a588 1
	  system_printf ("failed to malloc shm node");
d634 2
a635 2
	  system_printf ("error duplicating filemap handle (%lu)",
			 GetLastError ());
d647 2
a648 2
	  system_printf ("error duplicating attachmap handle (%lu)",
			 GetLastError ());
@


1.1.2.9
log
@	* cygserver.cc (check_and_dup_handle): Only use security code if
	running on NT, i.e. if wincap.has_security().
	(client_request_attach_tty::serve): Add check for has_security().
	* cygserver_process.cc (process_cache::process): Use DWORD winpid
	throughout to avoid win32 vs. cygwin pid confusion.
	(process::process): Ditto.
	* cygserver_shm.cc (client_request_shm::serve): Only use security
	code if running on NT, i.e. if wincap.has_security().
	* cygserver_shm.h (client_request_shm::parameters.in): Replace the
	ambiguous pid field with cygpid and winpid fields.
	(client_request_shm::client_request_shm): Reduce to only two
	client-side constructors: one for SHM_CREATE, another for all the
	other requests.
	* shm.cc (client_request_shm::client_request_shm):
	Ditto. Initialize cygpid and winpid fields here. On NT initialize
	sd_buf here using set_security_attribute() to make use of the euid
	and egid.
	(shmat): Use new client_request_shm constructor.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove security code, now performed in the
	relevant client_request_shm constructor.
	* include/cygwin/cygserver_process.h: (class cleanup_routine):
	Change winpid type to DWORD.
	(class process): Ditto.
@
text
@d3 1
a3 1
   Copyright 2001, 2002 Red Hat, Inc.
d5 1
a5 1
   Originally written by Robert Collins <robert.collins@@hotmail.com>
d7 1
a7 1
   This file is part of Cygwin.
d9 3
a11 3
   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */
d57 1
a57 1
	       sizeof (parameters))
d188 7
d199 1
a199 1
  from_process_handle = cache->process (parameters.in.winpid)->handle ();
d212 8
a219 1
  if (wincap.has_security ())
d221 5
a225 1
      conn->impersonate_client ();
a226 2
      rc = OpenThreadToken (GetCurrentThread (),
			    TOKEN_QUERY, TRUE, &token_handle);
d228 3
a230 1
      conn->revert_to_self ();
d232 5
a236 8
      if (!rc)
	{
	  debug_printf ("error opening thread token (%lu)", GetLastError ());
	  header.error_code = EACCES;
	  CloseHandle (from_process_handle);
	  return;
	}
    }
a475 10

      /* we trust the clients request - we will be doing it as them, and
       * the worst they can do is open their own permissions
       */

      SECURITY_ATTRIBUTES sa;
      sa.nLength = sizeof (sa);
      sa.lpSecurityDescriptor = (PSECURITY_DESCRIPTOR) parameters.in.sd_buf;
      sa.bInheritHandle = TRUE;	/* the memory structures inherit ok */

d485 2
a486 2
					  );
      DWORD lasterr = GetLastError ();
@


1.1.2.10
log
@	* include/sys/ipc.h (IPC_PRIVATE): Add cast to key_t.
	(IPC_INFO): New flag for ipcs(8).
	(IPC_RMID IPC_SET IPC_STAT): Renumber.
	* include/sys/shm.h (SHM_RDONLY SHM_RND): Renumber with distinct
	values [sic].
	(class _shmattach): Internal type moved to "cygserver_shm.h".
	(class shmnode): Ditto.
	(class shmid_ds): Ditto.
	(struct shmid_ds): Add spare fields.
	(struct shminfo): New type for IPC_INFO interface.
	* cygserver_shm.h: Remove obsolete #if 0 ... #endif block.
	(class shm_cleanup): Remove unused class.
	(struct _shmattach): Internal type moved from <sys/shm.h>.
	(struct shmnode): Ditto.
	(struct int_shmid_ds): Ditto. Renamed to avoid name clash with
	public interface struct shmid_ds. Use the shmid_bs structure as a
	field.
	* cygserver_shm.cc: Remove obsolete #if 0 ... #endif block.
	(client_request_shm::serve): Update for redefinition of
	int_shmid_ds structure.
	* shm.cc (build_inprocess_shmds): Ditto.
	(fixup_shms_after_fork): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove obsolete #if 0 ... #endif code.
@
text
@d62 54
d278 1
a278 1
	      InterlockedIncrement (&tempnode->shmds->ds.shm_nattch);
d298 1
a298 1
	      InterlockedDecrement (&tempnode->shmds->ds.shm_nattch);
d326 1
a326 1
		if (temp2->shmds->ds.shm_nattch)
d398 1
a398 1
		  && tempnode->shmds->ds.shm_segsz < parameters.in.size)
d564 1
a564 1
      int_shmid_ds *shmtemp = new int_shmid_ds;
d578 12
a589 12
      shmtemp->ds.shm_perm.cuid = getuid ();
      shmtemp->ds.shm_perm.uid = shmtemp->ds.shm_perm.cuid;
      shmtemp->ds.shm_perm.cgid = getgid ();
      shmtemp->ds.shm_perm.gid = shmtemp->ds.shm_perm.cgid;
      shmtemp->ds.shm_perm.mode = parameters.in.shmflg & 0x01ff;
      shmtemp->ds.shm_lpid = 0;
      shmtemp->ds.shm_nattch = 0;
      shmtemp->ds.shm_atime = 0;
      shmtemp->ds.shm_dtime = 0;
      shmtemp->ds.shm_ctime = time (NULL);
      shmtemp->ds.shm_segsz = parameters.in.size;
      *(shmid_ds *) mapptr = shmtemp->ds;
@


1.1.2.11
log
@	* cygserver_shm.cc: Remove #define __INSIDE_CYGWIN__ from around
	<sys/shm.h> as it no longer contains any internal code.
@
text
@d26 1
d28 1
@


1.1.2.12
log
@	* cygserver.cc: Throughout the code, check and correct level of
	the XXX_printf() functions used. Comment out several of the
	debug_printf() calls with "// verbose:".  Reformat and correct
	typos of some of the XXX_printf() formats.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* shm.cc (hi_ulong): New function to allow printing of a 64-bit
	key with current small_printf implementation.
	(lo_ulong): Ditto.
	(client_request_shm::client_request_shm): Use hi_ulong() and
	lo_ulong() in call to debug_printf().
@
text
@d144 1
a144 1
      system_printf ("error opening process (%lu)", GetLastError ());
d160 1
a160 1
	  system_printf ("error opening thread token (%lu)", GetLastError ());
d186 2
a187 2
		  system_printf ("error duplicating filemap handle (%lu)",
				 GetLastError ());
d195 2
a196 2
		  system_printf ("error duplicating attachmap handle (%lu)",
				 GetLastError ());
d316 2
a317 2
	  debug_printf ("system id strings: key = %s", shmname);
	  debug_printf ("system id strings: data = %s", shmaname);
@


1.1.2.13
log
@	* include/cygwin/cygserver.h: Change the client_request classes to
	give greater encapsulation and to allow variable length requests
	and replies.
	(enum cygserver_request_code): Now client_request::request_code_t.
	(class request_header): Now client_request::header_t.  Make a
	union of the request_code and the error_code.  The `cb' field,
	which was the buffer length, is now the `size_t msglen' field.
	(struct request_get_version): Now
	client_request_get_version::request_get_version.
	(struct request_shutdown): Remove unused type.
	(struct request_attach_tty): Now
	client_request_attach_tty::request_attach_tty.
	(client_request::_buf): Make field const.
	(client_request::_buflen): New const private field.
	(client_request::request_code): New accessor.
	(client_request::error_code): Ditto.
	(client_request::msglen): Ditto.
	(client_request::handle_request): New static method.
	(client_request::make_request): New virtual method.
	(client_request::handle): New method.
	(client_request::send): Make private.
	(client_request_get_version::check_version): New method.
	(client_request_get_version::serve): Make private.
	(client_request_get_version::version): Ditto.
	(client_request_shutdown::serve): Ditto.
	(client_request_attach_tty::req): Ditto.
	(client_request_attach_tty::serve): Ditto.
	(client_request_attach_tty::from_master): Make method const.
	(client_request_attach_tty::from_master): Ditto.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Track
	changes to the client_request classes.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	(client_request_get_version::check_version): New method to
	encapsulate code from cygserver_init().
	(client_request_shutdown::client_request_shutdown): Move into
	"cygserver.cc".
	(client_request::send): Track changes to the client_request
	classes.  Add more error checking.
	(client_request::handle_request): New static method containing the
	first half of the old server_request::process() code.
	(client_request::make_request): New method to replace the old
	cygserver_request() function.
	(client_request::handle): New method containing the second half of
	the old server_request::process() code.
	(cygserver_init): Track changes to the client_request classes.  In
	particular, some code moved into the
	client_request_get_version::check_version() method.
	* cygserver.cc (client_request_attach_tty::serve): Track changes
	to the client_request classes.  In particular, only return a reply
	body if some handles are successfully duplicated for the client.
	And remove goto's.
	(client_request_get_version::serve): Track changes to the
	client_request classes.
	(client_request_shutdown::serve): Ditto.
	(class client_request_invalid): Dead, and so young too.
	(server_request::request_buffer): Remove unnecessary field.
	(client_request_shutdown::client_request_shutdown): Moved here
	from "cygserver_client.cc".
	(server_request::process): Implementation moved into the new
	client_request::handle_request() and client_request::handle()
	methods.
	* cygserver_shm.h (class client_request_shm): Put client- and
	server-specific interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__
	guards.
	(client_request_shm::serve): Make private.
	* cygserver_shm.cc
	(client_request_shm::client_request_shm): Track changes to the
	client_request classes.
	(client_request_shm::serve): Ditto
	* shm.cc (client_request_shm::client_request_shm): Ditto.  Use
	alloc_sd() rather than set_security_attribute() to get access to
	the SECURITY_DESCRIPTOR length, so that we can use it to set the
	request body length.
	(shmat): Track changes to the client_request classes. In
	particular, allocate client_request objects on the stack rather
	than on the heap, and use the client_request::make_request()
	method rather than the old cygserver_request() function.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::cygserver_attach_tty): Ditto.
@
text
@d15 1
a15 4
#include <sys/types.h>
#include <sys/shm.h>

#include <assert.h>
d19 1
d21 9
a29 2

#include "cygerrno.h"
a30 3
#include "cygwin/cygserver_process.h"
#include "security.h"
#include "threaded_queue.h"
d53 3
a55 2
client_request_shm::client_request_shm ()
  : client_request (CYGSERVER_REQUEST_SHM, &parameters, sizeof (parameters))
d57 1
a57 1
  syscall_printf ("created");
d130 1
a130 2
client_request_shm::serve (transport_layer_base * const conn,
			   process_cache * const cache)
a131 24
  assert (conn);
  assert (cache);

  assert (!error_code ());

  // The minimum possible request length.  SHM_CREATE requests should
  // be longer than this.
  const size_t min_req_msglen =
    (sizeof (parameters.in) - sizeof (parameters.in.sd_buf));

  if (msglen () < min_req_msglen)
    {
      syscall_printf (("bad request body length: " 
		       "expecting at least %lu bytes, got %lu"),
		      min_req_msglen, msglen ());
      error_code (EINVAL);
      msglen (0);
      return;
    }

  // FIXME: check length of sd_buf contents for SHM_CREATE?

  msglen (sizeof (parameters.out));

d145 1
a145 1
      error_code (EACCES);
d161 1
a161 1
	  error_code (EACCES);
d188 1
a188 1
		  error_code (EACCES);
d197 1
a197 1
		  error_code (EACCES);
d204 1
a204 1
      error_code (EINVAL);
d223 1
d229 1
a229 1
      error_code (EINVAL);
d243 1
d249 1
a249 1
      error_code (EINVAL);
d259 1
a259 1
	{
d279 1
d285 1
a285 1
      error_code (EINVAL);
d328 2
d344 1
a344 1
		  error_code (EINVAL);
d354 1
a354 1
		  error_code (EEXIST);
d379 2
a380 2
		  error_code (EACCES);
		  /*mutex*/
d391 2
a392 2
		  error_code (EACCES);
		  /*mutex*/
d435 1
a435 1
	  error_code (EACCES);
d453 1
a453 1
	      error_code (EEXIST);
d465 1
a465 1
	  error_code (ENOENT);
d479 1
a479 1
	  error_code (EACCES);
d494 1
a494 1
					    );
d500 1
a500 1
	  error_code (ENOMEM);
d512 1
a512 1
	  error_code (ENOMEM);
d548 1
a548 1
      FIXME: leave the system wide shm mutex */
d559 1
a559 1
	  error_code (EACCES);
d561 1
a561 1
	  /* mutex et al */
d572 1
a572 1
	  error_code (EACCES);
d575 1
a575 1
	  /* more cleanup... yay! */
d579 1
d583 1
a583 1
  error_code (ENOSYS);
d585 1
@


1.1.2.14
log
@Merged changes from HEAD
@
text
@d15 3
@


1.1.2.15
log
@	* include/cygwin/cygserver.h: Add forward declarations of class
	transport_layer_base and class process_cache to reduce
	dependencies between header files.
	* include/cygwin/cygserver_process.h: Add include of
	"threaded_queue.h".
	* cygserver.cc: Remove unnecessary cygserver header files.
	* cygserver_client.cc: Ditto.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_shm.h: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* dcrt0.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.
@
text
@d23 1
d25 1
a25 4

#include "cygwin/cygserver.h"
#include "cygwin/cygserver_process.h"
#include "cygwin/cygserver_transport.h"
@


1.1.2.16
log
@	* threaded_queue.h (class queue_request): Re-write.
	(threaded_queue_thread_function): Remove.
	(class queue_process_param): Remove.
	(class threaded_queue): Re-write.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	(TInterlockedExchangePointer): New templated function.
	(TInterlockedCompareExchangePointer): Ditto.
	* threaded_queue.cc (worker_function): Remove.
	(class threaded_queue): Re-write.
	(class queue_process_param): Remove.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	* include/cygwin/cygserver_process.h (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver_process.cc (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver.cc (request_count): Remove unused variable.
	(class server_request): Move methods inline.
	(class server_process_param): Remove.
	(class server_request_queue): Remove.
	(request_queue): Move into `main ()' and change type to
	`threaded_queue'.
	(request_loop): Remove.
	(class server_submission_loop): New version of the old
	`server_process_param' class.
	(shutdown_server): New variable.
	(client_request_shutdown::serve): Set `shutdown_server' to trigger
	shutdown.
	(handle_signal): Ditto.
	(main): Install signal handler for SIGINT rather than SIGQUIT.
	Use new interfaces for the `request_queue' and the `cache'.
	Create a `server_submission_loop' and add to the `request_queue'.
	Add check for the `shutdown_server' variable to the main loop.
	* cygserver_shm.cc (client_request_shm::serve): Release the
	process object after use.
@
text
@d7 1
a7 1
This file is part of Cygwin.
d9 3
a11 3
This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
d157 1
a157 5
  class process *const process = cache->process (parameters.in.winpid);
  assert (process);
  from_process_handle = process->handle ();
  process->release ();

@


1.1.2.17
log
@	* cygserver_ipc.h: New file.
	* cygserver_shm.h: Re-written from scratch.
	* cygserver_shm.cc: Ditto.
	* shm.cc: Ditto.
@
text
@d1 1
a1 1
/* cygserver_shm.cc: Single unix specification IPC interface for Cygwin.
d3 1
a3 1
   Copyright 2002 Red Hat, Inc.
d5 1
a5 2
   Written by Conrad Scott <conrad.scott@@dsl.pipex.com>.
   Based on code by Robert Collins <robert.collins@@hotmail.com>.
d15 1
a16 1
#include <pthread.h>
a17 1
#include <string.h>
d19 1
d21 1
a21 1
#include "cygserver_ipc.h"
d29 20
a48 47
/*---------------------------------------------------------------------------*
 * with_strerr ()
 *---------------------------------------------------------------------------*/

#define with_strerr(MSG, ACTION)					\
  do									\
    {									\
      const DWORD lasterr = GetLastError ();				\
      char *MSG = NULL;							\
      if (!FormatMessage ((FORMAT_MESSAGE_ALLOCATE_BUFFER		\
			   | FORMAT_MESSAGE_FROM_SYSTEM			\
			   | FORMAT_MESSAGE_IGNORE_INSERTS),		\
			  NULL,						\
			  lasterr,					\
			  MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),	\
			  reinterpret_cast<char *>(&MSG),		\
			  0,						\
			  NULL))					\
	{								\
	  MSG = static_cast<char *>					\
	    (LocalAlloc (LMEM_FIXED, 24)); /* Big enough. */		\
	  if (!MSG)							\
	    {								\
	      system_printf (("failure in LocalAlloc(LMEM_FIXED, 16): "	\
			      "error = %lu"),				\
			     GetLastError ());				\
	    }								\
	  else								\
	    {								\
	      snprintf (MSG, 24, "error = %lu", lasterr);		\
	    }								\
	}								\
      SetLastError (lasterr);						\
      { ACTION; }							\
      if (MSG && !LocalFree (MSG))					\
	{								\
	  system_printf ("failed to free memory at %p, error = %lu",	\
			 MSG, GetLastError ());				\
	}								\
      SetLastError (lasterr);						\
    } while (false)

/*---------------------------------------------------------------------------*
 * class server_shmmgr
 *
 * A singleton class.
 *---------------------------------------------------------------------------*/
d50 2
a51 3
#define shmmgr (server_shmmgr::instance ())

class server_shmmgr
d53 2
a54 12
private:
  class segment_t
  {
  public:
    // Bits for the _flg field.
    enum { REMOVED = 0x01 };

    const key_t key;
    const int shmid;
    struct shmid_ds ds;
    int flg;
    const HANDLE hFileMap;
d56 49
a104 4
    segment_t *next;

    segment_t (const key_t key, const int shmid, const HANDLE hFileMap)
      : key (key), shmid (shmid), flg (0), hFileMap (hFileMap), next (NULL)
d106 18
a123 3
      bzero (&ds, sizeof (ds));
    }
  };
d125 3
a127 39
public:
  static server_shmmgr & instance ();

  int shmat (int shmid, int shmflg,
	     pid_t, HANDLE & hFileMap,
	     process_cache *, DWORD winpid);
  int shmctl (int shmid, int cmd, struct shmid_ds &, pid_t);
  int shmdt (int shmid, pid_t);
  int shmget (key_t, size_t, int shmflg, pid_t, uid_t, gid_t);

private:
  CRITICAL_SECTION _segments_lock;
  segment_t *_segments_head;	// A list sorted by shmid.

  int _shmid_cnt;		// Number of shmid's allocated (for ipcs(8)).
  int _shmid_max;		// Highest shmid yet allocated (for ipcs(8)).

  server_shmmgr ();
  ~server_shmmgr ();

  // Undefined (as this class is a singleton):
  server_shmmgr (const server_shmmgr &);
  server_shmmgr & operator= (const server_shmmgr &);

  segment_t *find_by_key (key_t);
  segment_t *find (int shmid, segment_t **previous = NULL);

  int new_segment (key_t, size_t, int shmflg, pid_t, uid_t, gid_t);

  segment_t *new_segment (key_t, HANDLE);
  void delete_segment (segment_t *);
};

/*---------------------------------------------------------------------------*
 * server_shmmgr::instance ()
 *---------------------------------------------------------------------------*/

server_shmmgr &
server_shmmgr::instance ()
d129 2
a130 1
  static server_shmmgr instance;
d132 1
a132 2
  return instance;
}
d134 13
a146 14
/*---------------------------------------------------------------------------*
 * server_shmmgr::shmat ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::shmat (const int shmid, const int shmflg,
		      const pid_t pid, HANDLE & hFileMap,
		      process_cache *const cache, const DWORD winpid)
{
  process *const client = cache->process (winpid);

  if (!client)
    {
      return -EAGAIN;
d149 1
a149 2
  int result;
  EnterCriticalSection (&_segments_lock);
d151 1
a151 1
  segment_t *const segptr = find (shmid);
d153 15
a167 9
  if (!segptr)
    result = -EINVAL;
  else if (!DuplicateHandle (GetCurrentProcess (),
			     segptr->hFileMap,
			     client->handle (),
			     &hFileMap,
			     0,
			     FALSE, // bInheritHandle
			     DUPLICATE_SAME_ACCESS))
d169 4
a172 6
      with_strerr (msg,
		   syscall_printf (("failed to duplicate handle for client "
				    "[key = %lld, shmid = %d, handle = %p]:"
				    "%s"),
				   segptr->key, segptr->shmid,
				   segptr->hFileMap, msg));
d174 1
a174 3
      result = -EACCES;		// FIXME
    }
  else
d176 1
a176 3
      segptr->ds.shm_lpid  = pid;
      segptr->ds.shm_nattch += 1;
      segptr->ds.shm_atime = time (NULL); // FIXME: sub-second times.
d178 2
a179 2
      result = 0;
    }
d181 1
a181 1
  LeaveCriticalSection (&_segments_lock);
d183 8
a190 14
  client->release ();
  return result;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::shmctl ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::shmctl (const int shmid, const int cmd, struct shmid_ds & ds,
		       const pid_t pid)
{
  int result;
  EnterCriticalSection (&_segments_lock);
d192 2
a193 1
  segment_t *const segptr = find (shmid);
d195 2
a196 3
  if (!segptr)
    result = -EINVAL;
  else
d198 3
a200 1
      switch (cmd)
d202 1
a202 18
	case IPC_STAT:
	  ds = segptr->ds;
	  result = 0;
	  break;

	case IPC_SET:
	  segptr->ds.shm_perm.uid = ds.shm_perm.uid;
	  segptr->ds.shm_perm.gid = ds.shm_perm.gid;
	  segptr->ds.shm_perm.mode = ds.shm_perm.mode & 0777;
	  segptr->ds.shm_lpid = pid;
	  segptr->ds.shm_ctime = time (NULL); // FIXME: sub-second times.
	  result = 0;
	  break;

	case IPC_RMID:
	  if (segptr->flg & segment_t::REMOVED)
	    result = -EIDRM;
	  else
d204 22
a225 4
	      segptr->flg |= segment_t::REMOVED;
	      if (!segptr->ds.shm_nattch)
		delete_segment (segptr);
	      result = 0;
d227 1
a227 13
	  break;

	case IPC_INFO:
	  result = -EINVAL;
	  break;

	case SHM_STAT:
	  result = -EINVAL;
	  break;

	default:
	  result = -EINVAL;
	  break;
d229 3
d234 7
a240 19
  LeaveCriticalSection (&_segments_lock);
  return result;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::shmdt ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::shmdt (const int shmid, const pid_t pid)
{
  int result;
  EnterCriticalSection (&_segments_lock);

  segment_t *const segptr = find (shmid);

  if (!segptr)
    result = -EINVAL;
  else
d242 14
a255 10
      assert (segptr->ds.shm_nattch > 0);

      segptr->ds.shm_lpid  = pid;
      segptr->ds.shm_nattch -= 1;
      segptr->ds.shm_dtime = time (NULL); // FIXME: sub-second times.

      if (!segptr->ds.shm_nattch && (segptr->flg & segment_t::REMOVED))
	delete_segment (segptr);

      result = 0;
d258 2
a259 19
  LeaveCriticalSection (&_segments_lock);
  return result;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::shmget ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::shmget (const key_t key, const size_t size, const int shmflg,
		       const pid_t pid, const uid_t uid, const gid_t gid)
{
  int result;
  EnterCriticalSection (&_segments_lock);

  /* Does a segment already exist with that key? */
  if (key == IPC_PRIVATE)
    result = new_segment (key, size, shmflg, pid, uid, gid);
  else
d261 14
a274 100
      segment_t *const segptr = find_by_key (key);

      if (!segptr)
	if (shmflg & IPC_CREAT)
	  result = new_segment (key, size, shmflg, pid, uid, gid);
	else
	  result = -ENOENT;
      else if (segptr->flg & segment_t::REMOVED)
	result = -EIDRM;
      else if ((shmflg & IPC_CREAT) && (shmflg & IPC_EXCL))
	result = -EEXIST;
      else if (size && segptr->ds.shm_segsz < size)
	result = -EINVAL;
      else
	result = segptr->shmid;
    }

  LeaveCriticalSection (&_segments_lock);
  return result;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::server_shmmgr ()
 *---------------------------------------------------------------------------*/

server_shmmgr::server_shmmgr ()
  : _segments_head (NULL)
{
  InitializeCriticalSection (&_segments_lock);
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::~server_shmmgr ()
 *---------------------------------------------------------------------------*/

server_shmmgr::~server_shmmgr ()
{
  DeleteCriticalSection (&_segments_lock);
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::find_by_key ()
 *---------------------------------------------------------------------------*/

server_shmmgr::segment_t *
server_shmmgr::find_by_key (const key_t key)
{
  for (segment_t *segptr = _segments_head; segptr; segptr = segptr->next)
    if (segptr->key == key)
      return segptr;

  return NULL;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::find ()
 *---------------------------------------------------------------------------*/

server_shmmgr::segment_t *
server_shmmgr::find (const int shmid, segment_t **previous)
{
  if (previous)
    *previous = NULL;

  for (segment_t *segptr = _segments_head; segptr; segptr = segptr->next)
    if (segptr->shmid == shmid)
      return segptr;
    else if (segptr->shmid > shmid) // The list is sorted by shmid.
      return NULL;
    else if (previous)
      *previous = segptr;

  return NULL;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::new_segment ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::new_segment (const key_t key,
			    const size_t size,
			    const int shmflg,
			    const pid_t pid,
			    const uid_t uid,
			    const gid_t gid)
{
  const HANDLE hFileMap = CreateFileMapping (INVALID_HANDLE_VALUE,
					     NULL, PAGE_READWRITE,
					     0, size,
					     NULL);

  if (!hFileMap)
    {
      with_strerr (msg,
		   syscall_printf (("failed to create file mapping "
				    "[size = %lu]: %s"),
				   size, msg));

      return -EINVAL;		// FIXME
d277 2
a278 29
  segment_t *const segptr = new_segment (key, hFileMap);

  segptr->ds.shm_perm.cuid = segptr->ds.shm_perm.uid = uid;
  segptr->ds.shm_perm.cgid = segptr->ds.shm_perm.gid = gid;
  segptr->ds.shm_perm.mode = shmflg & 0777;
  segptr->ds.shm_segsz = size;
  segptr->ds.shm_cpid = pid;
  segptr->ds.shm_ctime = time (NULL); // FIXME: sub-second times.

  return segptr->shmid;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::new_segment ()
 *
 * Allocate a new segment for the given key and file map with the
 * lowest available shmid and insert into the segment map.
 *---------------------------------------------------------------------------*/

server_shmmgr::segment_t *
server_shmmgr::new_segment (const key_t key, const HANDLE hFileMap)
{
  int shmid = ipc_int2ext (0, IPC_SHMOP); // Next expected shmid value.
  segment_t *previous = NULL;	// Insert pointer.

  // Find first unallocated shmid.
  for ( segment_t *segptr = _segments_head;
	segptr && segptr->shmid == shmid;
	segptr = segptr->next, shmid = ipc_inc_id (shmid, IPC_SHMOP))
d280 30
a309 1
      previous = segptr;
a311 1
  segment_t *const segptr = new segment_t (key, shmid, hFileMap);
d313 1
a313 3
  assert (segptr);

  if (previous)
d315 3
a317 8
      segptr->next = previous->next;
      previous->next = segptr;
    }
  else
    {
      segptr->next = _segments_head;
      _segments_head = segptr;
    }
d319 14
a332 3
  _shmid_cnt += 1;
  if (shmid > _shmid_max)
    _shmid_max = shmid;
d334 8
a341 2
  return segptr;
}
d343 1
a343 3
/*---------------------------------------------------------------------------*
 * server_shmmgr::delete_segment ()
 *---------------------------------------------------------------------------*/
d345 8
a352 6
void
server_shmmgr::delete_segment (segment_t *const segptr)
{
  assert (segptr);
  assert (!segptr->ds.shm_nattch);
  assert (segptr->flg & segment_t::REMOVED);
d354 62
a415 1
  segment_t *previous = NULL;
d417 6
a422 1
  const segment_t *const tmp = find (segptr->shmid, &previous);
d424 1
a424 2
  assert (tmp == segptr);
  assert (previous ? previous->next == segptr : _segments_head == segptr);
d426 21
a446 4
  if (previous)
    previous->next = segptr->next;
  else
    _segments_head = segptr->next;
d448 11
a458 5
  if (!CloseHandle (segptr->hFileMap))
    with_strerr (msg,
		 syscall_printf (("failed to close file map "
				  "[handle = %p]: %s"),
				 segptr->hFileMap, msg));
d460 18
a477 2
  assert (_shmid_cnt > 0);
  _shmid_cnt -= 1;
d479 10
a488 2
  delete segptr;
}
d490 3
a492 3
/*---------------------------------------------------------------------------*
 * client_request_shm::client_request_shm ()
 *---------------------------------------------------------------------------*/
d494 9
a502 6
client_request_shm::client_request_shm ()
  : client_request (CYGSERVER_REQUEST_SHM,
		    &_parameters, sizeof (_parameters))
{
  syscall_printf ("created");
}
d504 12
a515 3
/*---------------------------------------------------------------------------*
 * client_request_shm::serve ()
 *---------------------------------------------------------------------------*/
d517 10
a526 5
void
client_request_shm::serve (transport_layer_base *const conn,
			   process_cache *const cache)
{
  assert (conn);
d528 12
a539 1
  assert (!error_code ());
d541 58
a598 6
  if (msglen () != sizeof (_parameters))
    {
      syscall_printf ("bad request body length: expecting %lu bytes, got %lu",
		      sizeof (_parameters), msglen ());
      error_code (EINVAL);
      msglen (0);
d602 2
a603 31
  // FIXME: Get a return code out of this and don't continue on error.
  conn->impersonate_client ();

  int result = -EINVAL;

  switch (_parameters.in.shmop)
    {
    case SHMOP_shmget:
      result = shmmgr.shmget (_parameters.in.key, _parameters.in.size,
			      _parameters.in.shmflg, _parameters.in.cygpid,
			      _parameters.in.uid, _parameters.in.gid);
      _parameters.shmid = result;
      break;

    case SHMOP_shmat:
      result = shmmgr.shmat (_parameters.shmid, _parameters.in.shmflg,
			     _parameters.in.cygpid, _parameters.out.hFileMap,
			     cache, _parameters.in.winpid);
      break;

    case SHMOP_shmdt:
      result = shmmgr.shmdt (_parameters.shmid, _parameters.in.cygpid);
      break;

    case SHMOP_shmctl:
      result = shmmgr.shmctl (_parameters.shmid, _parameters.in.cmd,
			      _parameters.ds, _parameters.in.cygpid);
      break;
    }

  conn->revert_to_self ();
d605 1
a605 5
  if (result < 0)
    {
      error_code (-result);
      msglen (0);
    }
@


1.1.2.18
log
@	* woutsup.h: Remove all uses of the C++ new and delete operators
	throughout cygserver until they are fully thread-safe.
	(safe_new0): New macro to replace the C++ new operator.
	(safe_new): Ditto.
	(safe_delete): New macro to replace the C++ delete operator.
	* cygserver_client.cc (client_request::handle_request): Replace
	all uses of the C++ new and delete operators with the new macros
	from "woutsup.h".
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::new_segment): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* cygserver_transport.cc (create_server_transport): Ditto.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::accept): Ditto.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::accept): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.
	(threaded_queue::stop): Replace sleep(3) with win32 Sleep.
	* cygserver.cc (~server_request): Replace all uses of the C++ new
	and delete operators with the new macros from "woutsup.h".
	(server_submission_loop::request_loop): Ditto.
	(main): Ditto.  Replace sleep(3) with win32 Sleep.  Replace
	iostreams with FILEs.
	(print_usage): Replace iostreams with FILEs.
	(print_version): Ditto.
@
text
@d450 1
a450 1
  segment_t *const segptr = safe_new (segment_t, key, shmid, hFileMap);
d504 1
a504 1
  safe_delete (segment_t, segptr);
@


1.1.2.19
log
@	* cygserver_shm.cc (server_shmmgr::_instance): New static field.
	(server_shmmgr::_instance_once): Ditto.
	(server_shmmgr::initialise_instance): New static method.
	(server_shmmgr::instance): Use a pthread_once_t rather than
	relying on a local static variable.
@
text
@a114 5
  static server_shmmgr *_instance;
  static pthread_once_t _instance_once;

  static void initialise_instance ();

a136 3
/* static */ server_shmmgr *server_shmmgr::_instance = NULL;
/* static */ pthread_once_t server_shmmgr::_instance_once = PTHREAD_ONCE_INIT;

d141 1
a141 1
/* static */ server_shmmgr &
d144 1
a144 1
  pthread_once (&_instance_once, &initialise_instance);
d146 1
a146 3
  assert (_instance);

  return *_instance;
a333 12
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::initialise_instance ()
 *---------------------------------------------------------------------------*/

/* static */ void
server_shmmgr::initialise_instance ()
{
  assert (!_instance);

  _instance = safe_new0 (server_shmmgr);
@


1.1.2.20
log
@	* cygserver_shm.cc (server_shmmgr::server_shmmgr): All fields have
	to be initialized now that the singleton is no longer static.
@
text
@d363 1
a363 3
  : _segments_head (NULL),
    _shmid_cnt (0),
    _shmid_max (0)
@


1.1.2.21
log
@	* cygserver_shm.cc: Implement the ipcs(8) interfaces, IPC_INFO,
	SHM_STAT and SHM_INFO.
	(server_shmmgr::segment_t::sequence): New static field.
	(server_shmmgr::segment_t::key): Remove field, use the new
	ds.shm_perm.key field instead.
	(server_shmmgr::segment_t::shmid): Remove field.
	(server_shmmgr::segment_t::intid): New field.
	(server_shmmgr::segment_t::segment_t): Use the `key' argument to
	initialise `ds.shm_perm.key'.  Change from using `shmid' to
	`intid'.
	(server_shmmgr::_shmseg_cnt): Renamed from `_shmid_cnt'.
	(server_shmmgr::_intid_max): Renamed from `_shmid_max.
	(server_shmmgr::shmat): Move the out arguments to the start of the
	argument list.  Rename the `pid' argument as `cygpid'.  Add
	tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmctl): Add separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add support for the ipcs(8)
	interfaces.  Add tracing.  Pass an intid to `find ()', not a
	shmid.
	(server_shmmgr::shmdt): Rename the `pid' argument as `cygpid'.
	Add tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmget): Add a separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add tracing.
	(server_shmmgr::server_shmmgr): Update for new field names.
	(server_shmmgr::find_by_key): Update for the new `ds.shm_perm.key'
	field.
	(server_shmmgr::find): Update to use the new `segment_t::intid'
	field.
	(server_shmmgr::new_segment): Rename the `pid' argument as
	`cygpid'.  Check that the requested size is within bounds.  Handle
	new error result from `new_segment (key, HANDLE)'.
	(server_shmmgr::new_segment): Work with intids, not shmids.  Check
	that the new intid is within bounds.  Update for new field names.
	(server_shmmgr::delete_segment): Pass an intid to `find ()', not a
	shmid.  Update for new field names.
	(client_request_shm::serve): Check that the incoming message
	length is the size of the `_parameters.in' struct, not of the
	whole in/out parameter union.  Likewise, set the outgoing message
	length to the size of the `_parameters.out' struct.  Update for
	the new server_shmmgr interfaces.
	* include/sys/ipc.h (ipc_perm::key): New field.
	* include/sys/shm.h (SHM_INFO): New constant.
	* cygserver_ipc.h (IPCMNI): New constant.
	(ipc_int2ext): Add `sequence' argument and munge this into the
	external ipc id.
	(ipc_ext2int_subsys): Unmunge the sequence number from the
	external ipc id.
	(ipc_ext2int): Ditto.
	(ipc_inc_id): Remove.
	(ipc_dec_id): Remove.
	* cygserver_shm.h (SHMMAX): New constant.
	(SHMMIN): Ditto.
	(SHMMNI): Ditto.
	(SHMSEG): Ditto.
	(SHMALL): Ditto.
	(client_request_shm::_parameters): Re-arrange as a union of two
	separate structs, one for in arguments, the other for out.
	(client_request_shm::shmid): Update for the new parameter layout.
	(client_request_shm::ds): Ditto.
	(client_request_shm::info): New method.
	* shm.cc (client_shmmgr::_shmat_cnt): New static field.
	(client_shmmgr::shmat): Add locking.  Add tracing.
	(client_shmmgr::shmctl): Update for ipcs(8) commands.  Add
	tracing.  Add more argument checking.
	(client_shmmgr::shmdt): Add locking.  Add tracing.  Update the new
	`_shmat_cnt' field.
	(client_shmmgr::shmget): Add tracing.
	(client_shmmgr::fixup_shms_after_fork): Add tracing.  Add
	consistency checking.
	(client_shmmgr::attach): Add more tracing.
	(client_shmmgr::new_segment): Update the new `_shmat_cnt' field.
	(client_request_shm::client_request_shm): Update for the new
	parameter layout.  Set the outgoing message length to the size of
	the `_parameters.in' struct, not of the whole in/out parameter
	union.
@
text
@d66 1
a66 1
	  system_printf ("failed to free memory at 0x%p, error = %lu",	\
d89 1
a89 3
    static long sequence;

    const int intid;
d91 1
a91 1
    shmid_ds ds;
d97 2
a98 6
    segment_t (const key_t key, const int intid, const HANDLE hFileMap)
      : intid (intid),
	shmid (ipc_int2ext (intid, IPC_SHMOP, sequence)),
	flg (0),
	hFileMap (hFileMap),
	next (NULL)
d100 1
a100 4
      assert (0 <= intid && intid < SHMMNI);

      memset (&ds, '\0', sizeof (ds));
      ds.shm_perm.key = key;
d107 4
a110 4
  int shmat (HANDLE & hFileMap,
	     int shmid, int shmflg, pid_t, process_cache *, DWORD winpid);
  int shmctl (int & out_shmid, shmid_ds & out_ds, shminfo & out_info,
	      const int shmid, int cmd, const shmid_ds &, pid_t);
d112 1
a112 1
  int shmget (int & out_shmid, key_t, size_t, int shmflg, pid_t, uid_t, gid_t);
d121 1
a121 1
  segment_t *_segments_head;	// A list sorted by int_id.
d123 2
a124 2
  int _shmseg_cnt;		// Number of shm segments (for ipcs(8)).
  int _intid_max;		// Highest intid yet allocated (for ipcs(8)).
d134 1
a134 1
  segment_t *find (int intid, segment_t **previous = NULL);
a141 2
/* static */ long server_shmmgr::segment_t::sequence = 0;

d164 2
a165 3
server_shmmgr::shmat (HANDLE & hFileMap,
		      const int shmid, const int shmflg,
		      const pid_t cygpid,
a167 3
  syscall_printf ("shmat (shmid = %d, shmflg = 0%o) for %d(%lu)",
		  shmid, shmflg, cygpid, winpid);

a171 4
      syscall_printf (("-1 [%d] = shmat (shmid = %d, shmflg = 0%o) "
		       "for %d(%lu)"),
		      0, EAGAIN, shmid, shmflg,
		      cygpid, winpid);
d175 1
a175 1
  int result = 0;
d178 1
a178 1
  segment_t *const segptr = find (ipc_ext2int (shmid, IPC_SHMOP));
d192 1
a192 1
				    "[key = 0x%016llx, shmid = %d, handle = 0x%x]:"
d194 1
a194 1
				   segptr->ds.shm_perm.key, segptr->shmid,
d201 1
a201 1
      segptr->ds.shm_lpid  = cygpid;
d204 2
a210 8

  if (result < 0)
    syscall_printf ("-1 [%d] = shmat (shmid = %d, shmflg = 0%o) for %d(%lu)",
		    -result, shmid, shmflg, cygpid, winpid);
  else
    syscall_printf ("0x%x = shmat (shmid = %d, shmflg = 0%o) for %d(%lu)",
		    hFileMap, shmid, shmflg, cygpid, winpid);

d219 2
a220 3
server_shmmgr::shmctl (int & out_shmid, shmid_ds & out_ds, shminfo & out_info,
		       const int shmid, const int cmd, const shmid_ds & ds,
		       const pid_t cygpid)
d222 2
a223 2
  syscall_printf ("shmctl (shmid = %d, cmd = 0x%x) for %d",
		  shmid, cmd, cygpid);
d225 1
a225 2
  int result = 0;
  EnterCriticalSection (&_segments_lock);
d227 3
a229 1
  switch (cmd)
d231 20
a250 18
    case IPC_STAT:
    case SHM_STAT:		// Uses intids rather than shmids.
    case IPC_SET:
    case IPC_RMID:
      {
	int intid;

	if (cmd == SHM_STAT)
	  intid = shmid;
	else
	  intid = ipc_ext2int (shmid, IPC_SHMOP);

	segment_t *const segptr = find (intid);

	if (!segptr)
	  result = -EINVAL;
	else
	  switch (cmd)
d252 4
a255 27
	    case IPC_STAT:
	      out_ds = segptr->ds;
	      break;

	    case IPC_SET:
	      segptr->ds.shm_perm.uid = ds.shm_perm.uid;
	      segptr->ds.shm_perm.gid = ds.shm_perm.gid;
	      segptr->ds.shm_perm.mode = ds.shm_perm.mode & 0777;
	      segptr->ds.shm_lpid = cygpid;
	      segptr->ds.shm_ctime = time (NULL); // FIXME: sub-second times.
	      break;

	    case IPC_RMID:
	      if (segptr->flg & segment_t::REMOVED)
		result = -EIDRM;
	      else
		{
		  segptr->flg |= segment_t::REMOVED;
		  if (!segptr->ds.shm_nattch)
		    delete_segment (segptr);
		}
	      break;

	    case SHM_STAT:	// ipcs(8) i'face.
	      out_ds = segptr->ds;
	      out_shmid = segptr->shmid;
	      break;
d257 1
a257 2
      }
      break;
d259 3
a261 7
    case IPC_INFO:
      out_info.shmmax = SHMMAX;
      out_info.shmmin = SHMMIN;
      out_info.shmmni = SHMMNI;
      out_info.shmseg = SHMSEG;
      out_info.shmall = SHMALL;
      break;
d263 3
a265 3
    case SHM_INFO:		// ipcs(8) i'face.
      out_shmid = _intid_max;
      break;
d267 4
a270 3
    default:
      result = -EINVAL;
      break;
a273 14

  if (result < 0)
    syscall_printf (("-1 [%d] = "
		     "shmctl (shmid = %d, cmd = 0x%x) for %d"),
		    -result,
		    shmid, cmd, cygpid);
  else
    syscall_printf (("%d = "
		     "shmctl (shmid = %d, cmd = 0x%x) for %d"),
		    ((cmd == SHM_STAT || cmd == SHM_INFO)
		     ? out_shmid
		     : result),
		    shmid, cmd, cygpid);

d282 1
a282 1
server_shmmgr::shmdt (const int shmid, const pid_t cygpid)
d284 1
a284 4
  syscall_printf ("shmdt (shmid = %d) for %d",
		  shmid, cygpid);

  int result = 0;
d287 1
a287 1
  segment_t *const segptr = find (ipc_ext2int (shmid, IPC_SHMOP));
d295 1
a295 1
      segptr->ds.shm_lpid  = cygpid;
d301 2
a305 8

  if (result < 0)
    syscall_printf ("-1 [%d] = shmdt (shmid = %d) for %d",
		    -result, shmid, cygpid);
  else
    syscall_printf ("%d = shmdt (shmid = %d) for %d",
		    result, shmid, cygpid);

d314 4
a317 9
server_shmmgr::shmget (int & out_shmid,
		       const key_t key, const size_t size, const int shmflg,
		       const pid_t cygpid, const uid_t uid, const gid_t gid)
{
  syscall_printf ("shmget (key = 0x%016llx, size = %u, shmflg = 0%o) for %d",
		  key, size, shmflg,
		  cygpid);

  int result = 0;
d322 1
a322 1
    result = new_segment (key, size, shmflg, cygpid, uid, gid);
d329 1
a329 1
	  result = new_segment (key, size, shmflg, cygpid, uid, gid);
a342 22

  if (result >= 0)
    {
      out_shmid = result;
      result = 0;
    }

  if (result < 0)
    syscall_printf (("-1 [%d] = "
		     "shmget (key = 0x%016llx, size = %u, shmflg = 0%o) "
		     "for %d"),
		    -result,
		    key, size, shmflg,
		    cygpid);
  else
    syscall_printf (("%d = "
		     "shmget (key = 0x%016llx, size = %u, shmflg = 0%o) "
		     "for %d"),
		    out_shmid,
		    key, size, shmflg,
		    cygpid);

d364 2
a365 2
    _shmseg_cnt (0),
    _intid_max (0)
d387 1
a387 1
    if (segptr->ds.shm_perm.key == key)
d398 1
a398 1
server_shmmgr::find (const int intid, segment_t **previous)
d404 1
a404 1
    if (segptr->intid == intid)
d406 1
a406 1
    else if (segptr->intid > intid) // The list is sorted by intid.
d422 1
a422 1
			    const pid_t cygpid,
a425 3
  if (size < SHMMIN || size > SHMMAX)
      return -EINVAL;

a442 6
  if (!segptr)
    {
      (void) CloseHandle (hFileMap);
      return -ENOSPC;
    }

d447 1
a447 1
  segptr->ds.shm_cpid = cygpid;
d457 1
a457 1
 * lowest available intid and insert into the segment map.
d463 1
a463 1
  int intid = 0;		// Next expected intid value.
d466 4
a469 4
  // Find first unallocated intid.
  for (segment_t *segptr = _segments_head;
       segptr && segptr->intid == intid;
       segptr = segptr->next, intid++)
d474 1
a474 8
  /* By the time this condition is reached (given the default value of
   * SHMMNI), the linear searches should all replaced by something
   * just a *little* cleverer . . .
   */
  if (intid >= SHMMNI)
    return NULL;

  segment_t *const segptr = safe_new (segment_t, key, intid, hFileMap);
d489 3
a491 3
  _shmseg_cnt += 1;
  if (intid > _intid_max)
    _intid_max = intid;
d509 1
a509 1
  const segment_t *const tmp = find (segptr->intid, &previous);
d522 1
a522 1
				  "[handle = 0x%x]: %s"),
d525 2
a526 2
  assert (_shmseg_cnt > 0);
  _shmseg_cnt -= 1;
d554 1
a554 1
  if (msglen () != sizeof (_parameters.in))
d571 1
a571 2
      result = shmmgr.shmget (_parameters.out.shmid,
			      _parameters.in.key, _parameters.in.size,
d574 1
d578 2
a579 3
      result = shmmgr.shmat (_parameters.out.hFileMap,
			     _parameters.in.shmid, _parameters.in.shmflg,
			     _parameters.in.cygpid,
d584 1
a584 1
      result = shmmgr.shmdt (_parameters.in.shmid, _parameters.in.cygpid);
d588 2
a589 4
      result = shmmgr.shmctl (_parameters.out.shmid,
			      _parameters.out.ds, _parameters.out.info,
			      _parameters.in.shmid, _parameters.in.cmd,
			      _parameters.in.ds, _parameters.in.cygpid);
a599 2
  else
    msglen (sizeof (_parameters.out));
@


1.1.2.22
log
@	* msg.cc: New file of stub functions, no functionality.
	* sem.cc: Ditto.
	* shm.cc (client_shmmgr::shmctl): Add support for an out shm_info
	buffer for the SHM_INFO command.
	(client_shmmgr::shmget): Use %X to print keys.
	* include/sys/ipc.h: Comment all fields and values.
	(IPC_PRIVATE): Change to be non-negative.
	* include/sys/msg.h: New file with SUSv3 and ipcs(8) interfaces.
	* include/sys/sem.h: Ditto.
	* include/sys/shm.h: Comment all fields and values.
	(struct shm_info): New struct.
	* cygserver_shm.h (client_request_shm::shminfo): Rename.
	(client_request_shm::shm_info): New method.
	(client_request_shm::_parameters.out.hFileMap): Move into union.
	(client_request_shm::_parameters.out.shminfo): Rename.
	(client_request_shm::_parameters.out.shm_info): New field.
	* cygserver_shm.cc (server_shmmgr::_shm_ids): Rename.
	(server_shmmgr::_shm_tot): New field.
	(server_shmmgr::shmctl): Rename `out_shminfo' argument.  Add
	`out_shm_info' argument.  Fill in the `out_shm_info' argument in
	the SHM_INFO command.
	(server_shmmgr::shmget): Check `shmflg' against the mode of
	existing segments as per Stevens 1990, p. 123.
	(server_shmmgr::server_shmmgr): Initialize the new `_shm_tot'
	field.
	(server_shmmgr::new_segment): Set ENOMEM if CreateFileMapping
	fails.  Pass `size' to new_segment.
	(server_shmmgr::new_segment): Add size argument and use it to
	check against and update the new `_shm_tot' field.
	(server_shmmgr::delete_segment): Update the new `_shm_tot' field.
	* cygwin.din: Add the SysV IPC msg and sem interfaces.
	* Makefile.in (DLL_OFILES): Add new DLL object files.
@
text
@d93 1
a93 1
    struct shmid_ds ds;
d118 2
a119 3
  int shmctl (int & out_shmid, struct shmid_ds & out_ds,
	      struct shminfo & out_shminfo, struct shm_info & out_shm_info,
	      const int shmid, int cmd, const struct shmid_ds &, pid_t);
d132 1
a132 2
  int _shm_ids;			// Number of shm segments (for ipcs(8)).
  int _shm_tot;			// Total bytes of shm segments (for ipcs(8)).
d147 1
a147 1
  segment_t *new_segment (key_t, size_t, HANDLE);
d244 2
a245 6
server_shmmgr::shmctl (int & out_shmid,
		       struct shmid_ds & out_ds,
		       struct shminfo & out_shminfo,
		       struct shm_info & out_shm_info,
		       const int shmid, const int cmd,
		       const struct shmid_ds & ds,
d307 5
a311 5
      out_shminfo.shmmax = SHMMAX;
      out_shminfo.shmmin = SHMMIN;
      out_shminfo.shmmni = SHMMNI;
      out_shminfo.shmseg = SHMSEG;
      out_shminfo.shmall = SHMALL;
a315 2
      out_shm_info.shm_ids = _shm_ids;
      out_shm_info.shm_tot = _shm_tot;
d398 1
a413 2
      else if ((shmflg & ~(segptr->ds.shm_perm.mode)) & 0777)
	result = -EACCES;
d464 1
a464 2
    _shm_ids (0),
    _shm_tot (0),
d541 1
a541 1
      return -ENOMEM;		// FIXME
d544 1
a544 1
  segment_t *const segptr = new_segment (key, size, hFileMap);
d570 1
a570 2
server_shmmgr::new_segment (const key_t key, const size_t size,
			    const HANDLE hFileMap)
a571 3
  if (_shm_tot + size > SHMALL)
    return NULL;

d605 1
a605 2
  _shm_ids += 1;
  _shm_tot += size;
d641 2
a642 3
  assert (_shm_ids > 0);
  _shm_ids -= 1;
  _shm_tot -= segptr->ds.shm_segsz;
d706 1
a706 2
			      _parameters.out.ds, _parameters.out.shminfo,
			      _parameters.out.shm_info,
@


1.1.2.23
log
@	* cygserver_shm.cc (class server_shmmgr::segment_t): Add `_'
	prefix to the names of all fields.
@
text
@d89 1
a89 1
    static long _sequence;
d91 5
a95 5
    const int _intid;
    const int _shmid;
    struct shmid_ds _ds;
    int _flg;
    const HANDLE _hFileMap;
d97 1
a97 1
    segment_t *_next;
d100 5
a104 5
      : _intid (intid),
	_shmid (ipc_int2ext (_intid, IPC_SHMOP, _sequence)),
	_flg (0),
	_hFileMap (hFileMap),
	_next (NULL)
d106 1
a106 1
      assert (0 <= _intid && _intid < SHMMNI);
d108 2
a109 2
      memset (&_ds, '\0', sizeof (_ds));
      _ds.shm_perm.key = key;
d153 1
a153 1
/* static */ long server_shmmgr::segment_t::_sequence = 0;
d204 1
a204 1
			     segptr->_hFileMap,
d215 2
a216 2
				   segptr->_ds.shm_perm.key, segptr->_shmid,
				   segptr->_hFileMap, msg));
d222 3
a224 3
      segptr->_ds.shm_lpid  = cygpid;
      segptr->_ds.shm_nattch += 1;
      segptr->_ds.shm_atime = time (NULL); // FIXME: sub-second times.
d282 1
a282 1
	      out_ds = segptr->_ds;
d286 5
a290 5
	      segptr->_ds.shm_perm.uid = ds.shm_perm.uid;
	      segptr->_ds.shm_perm.gid = ds.shm_perm.gid;
	      segptr->_ds.shm_perm.mode = ds.shm_perm.mode & 0777;
	      segptr->_ds.shm_lpid = cygpid;
	      segptr->_ds.shm_ctime = time (NULL); // FIXME: sub-second times.
d294 1
a294 1
	      if (segptr->_flg & segment_t::REMOVED)
d298 2
a299 2
		  segptr->_flg |= segment_t::REMOVED;
		  if (!segptr->_ds.shm_nattch)
d305 2
a306 2
	      out_ds = segptr->_ds;
	      out_shmid = segptr->_shmid;
d368 1
a368 1
      assert (segptr->_ds.shm_nattch > 0);
d370 3
a372 3
      segptr->_ds.shm_lpid  = cygpid;
      segptr->_ds.shm_nattch -= 1;
      segptr->_ds.shm_dtime = time (NULL); // FIXME: sub-second times.
d374 1
a374 1
      if (!segptr->_ds.shm_nattch && (segptr->_flg & segment_t::REMOVED))
d417 1
a417 1
      else if (segptr->_flg & segment_t::REMOVED)
d421 1
a421 1
      else if ((shmflg & ~(segptr->_ds.shm_perm.mode)) & 0777)
d423 1
a423 1
      else if (size && segptr->_ds.shm_segsz < size)
d426 1
a426 1
	result = segptr->_shmid;
d496 2
a497 2
  for (segment_t *segptr = _segments_head; segptr; segptr = segptr->_next)
    if (segptr->_ds.shm_perm.key == key)
d513 2
a514 2
  for (segment_t *segptr = _segments_head; segptr; segptr = segptr->_next)
    if (segptr->_intid == intid)
d516 1
a516 1
    else if (segptr->_intid > intid) // The list is sorted by intid.
d562 6
a567 6
  segptr->_ds.shm_perm.cuid = segptr->_ds.shm_perm.uid = uid;
  segptr->_ds.shm_perm.cgid = segptr->_ds.shm_perm.gid = gid;
  segptr->_ds.shm_perm.mode = shmflg & 0777;
  segptr->_ds.shm_segsz = size;
  segptr->_ds.shm_cpid = cygpid;
  segptr->_ds.shm_ctime = time (NULL); // FIXME: sub-second times.
d569 1
a569 1
  return segptr->_shmid;
d591 2
a592 2
       segptr && segptr->_intid == intid;
       segptr = segptr->_next, intid++)
d610 2
a611 2
      segptr->_next = previous->_next;
      previous->_next = segptr;
d615 1
a615 1
      segptr->_next = _segments_head;
d635 2
a636 2
  assert (!segptr->_ds.shm_nattch);
  assert (segptr->_flg & segment_t::REMOVED);
d640 1
a640 1
  const segment_t *const tmp = find (segptr->_intid, &previous);
d643 1
a643 1
  assert (previous ? previous->_next == segptr : _segments_head == segptr);
d646 1
a646 1
    previous->_next = segptr->_next;
d648 1
a648 1
    _segments_head = segptr->_next;
d650 1
a650 1
  if (!CloseHandle (segptr->_hFileMap))
d654 1
a654 1
				 segptr->_hFileMap, msg));
d658 1
a658 1
  _shm_tot -= segptr->_ds.shm_segsz;
@


1.1.2.24
log
@	* cygserver_shm.cc: Automatically detach processes from any
	segments they are attached to at exit.
	(class server_shmmgr::attach_t): New class.
	(server_shmmgr::segment_t::IS_DELETED): Rename and make private.
	(server_shmmgr::segment_t::_sequence): Make private.
	(server_shmmgr::segment_t::_flg): Ditto.
	(server_shmmgr::segment_t::_hFileMap): Ditto.
	(server_shmmgr::segment_t::_attach_head): New private field.
	(server_shmmgr::segment_t::segment_t): Initialise new fields.
	Make non-inline.
	(server_shmmgr::segment_t::~segment_t): New method.
	(server_shmmgr::segment_t::is_deleted): Ditto.
	(server_shmmgr::segment_t::is_pending_delete): Ditto.
	(server_shmmgr::segment_t::mark_deleted): Ditto.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::segment_t::find): Ditto.
	(class server_shmmgr::cleanup_t): New class.
	(server_shmmgr::_shm_atts): New private field.
	(server_shmmgr::shmat): Add a process object argument to replace
	the removed process_cache, cygpid and winpid arguments.  Remove
	the process_cache manipulations.  Move body of code to the
	segment_t::attach method.  Increment _shm_atts when required.
	Update tracing statements.
	(server_shmmgr::shmdt): Add a process object argument to replace
	the removed cygpid argument.  Move body of code to the
	segment_t::detach method.  Decrement _shm_atts when required.
	Update tracing statements.
	(server_shmmgr::shmget): Use the new segment_t::is_deleted method.
	(server_shmmgr::server_shmmgr): Initialise the new _shm_atts
	field.
	(server_shmmgr::delete_segment): Remove the CloseHandle code, as
	this is now done in the segment_t destructor.
	(client_request_shm::serve): Look up the client's process object
	and pass to the server_shmmgr::shmat and server_shmmgr::shmdt
	methods rather than passing the cache, winpid and cygpid.
	* cygserver_process.h: Add a cygpid to the process object to make
	it more useful and then pass process objects rather than winpids
	where possible.
	(cleanup_routine::cleanup): Change argument to be a pointer to a
	process object.
	(class process): Re-order fields for no discernible reason.
	(process::_cygpid): New field.
	(process::process): Add a cygpid argument.
	(process::winpid): New method.
	(process::cygpid): Ditto.
	(process::add): Make public, as it always should have been.
	(process_cache::process): Add a cygpid argument.
	* cygserver_process.cc (process::process): Add a cygpid argument
	and use it to initialise the `_cygpid' field.  Re-order
	initialisers to match new field order.
	(process::cleanup): Pass `this' rather than just the winpid to
	cleanup_routine::cleanup.
	(process_cache::process): Add a cygpid argument and pass it to the
	process object constructor.
	* include/sys/shm.h (shmatt_t): Make unsigned as per SUSv3.
	(shm_info::shm_atts): New field.
@
text
@d83 1
a83 1
  class attach_t
d86 2
a87 2
    class process *const _client;
    unsigned int _refcnt;
d89 1
a89 14
    attach_t *_next;

    attach_t (class process *const client)
      : _client (client),
        _refcnt (0),
        _next (NULL)
    {}
  };

  class segment_t
  {
  private:
    // Bits for the _flg field.
    enum { IS_DELETED = 0x01 };
a90 1
  public:
a93 29

    segment_t *_next;

    segment_t (const key_t key, const int intid, const HANDLE hFileMap);
    ~segment_t ();

    bool is_deleted () const
    {
      return _flg & IS_DELETED;
    }

    bool is_pending_delete () const
    {
      return !_ds.shm_nattch && is_deleted ();
    }

    void mark_deleted ()
    {
      assert (!is_deleted ());

      _flg |= IS_DELETED;
    }

    int attach (class process *, HANDLE & hFileMap);
    int detach (const class process *);

  private:
    static long _sequence;

a95 1
    attach_t *_attach_head;	// A list sorted by winpid;
d97 1
a97 2
    attach_t *find (const class process *, attach_t **previous = NULL);
  };
d99 6
a104 5
  class cleanup_t : public cleanup_routine
  {
  public:
    cleanup_t (segment_t *const segptr)
      : _segptr (segptr)
d106 1
a106 6
      assert (_segptr);
    }

    virtual void cleanup (const class process *const client)
    {
      assert (_segptr);
d108 2
a109 1
      shmmgr.shmdt (_segptr->_shmid, client);
a110 3

  private:
    segment_t *const _segptr;
d117 1
a117 1
	     int shmid, int shmflg, class process *);
d121 1
a121 1
  int shmdt (int shmid, const class process *);
a134 1
  int _shm_atts;		// Number of attached segments (for ipcs(8)).
a158 162
 * server_shmmgr::segment_t::segment_t ()
 *---------------------------------------------------------------------------*/

server_shmmgr::segment_t::segment_t (const key_t key,
				     const int intid,
				     const HANDLE hFileMap)
  : _intid (intid),
    _shmid (ipc_int2ext (intid, IPC_SHMOP, _sequence)),
    _next (NULL),
    _flg (0),
    _hFileMap (hFileMap),
    _attach_head (NULL)
{
  assert (0 <= _intid && _intid < SHMMNI);

  memset (&_ds, '\0', sizeof (_ds));
  _ds.shm_perm.key = key;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::segment_t::~segment_t ()
 *---------------------------------------------------------------------------*/

server_shmmgr::segment_t::~segment_t ()
{
  assert (!_attach_head);

  if (!CloseHandle (_hFileMap))
    with_strerr
      (msg,
       syscall_printf (("failed to close file map [handle = 0x%x]: %s"),
		       _hFileMap, msg));
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::segment_t::attach ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::segment_t::attach (class process *const client,
				  HANDLE & hFileMap)
{
  assert (client);

  if (!DuplicateHandle (GetCurrentProcess (),
			_hFileMap,
			client->handle (),
			&hFileMap,
			0,
			FALSE, // bInheritHandle
			DUPLICATE_SAME_ACCESS))
    {
      with_strerr
	(msg,
	 syscall_printf (("failed to duplicate handle for client "
			  "[key = 0x%016llx, shmid = %d, handle = 0x%x]:"
			  "%s"),
			 _ds.shm_perm.key, _shmid, _hFileMap,
			 msg));

      return -EACCES;	// FIXME: Case analysis?
    }

  _ds.shm_lpid  = client->cygpid ();
  _ds.shm_nattch += 1;
  _ds.shm_atime = time (NULL); // FIXME: sub-second times.

  attach_t *previous = NULL;
  attach_t *attptr = find (client, &previous);

  if (!attptr)
    {
      attptr = safe_new (attach_t, client);

      if (previous)
	{
	  attptr->_next = previous->_next;
	  previous->_next = attptr;
	}
      else
	{
	  attptr->_next = _attach_head;
	  _attach_head = attptr;
	}
    }

  attptr->_refcnt += 1;

  cleanup_t *const cleanup = safe_new (cleanup_t, this);

  // FIXME: ::add should only fail if the process object is already
  // cleaning up; but it can't be doing that since this thread has it
  // locked.

  const bool result = client->add (cleanup);

  assert (result);

  return 0;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::segment_t::detach ()
 *---------------------------------------------------------------------------*/

int
server_shmmgr::segment_t::detach (const class process *const client)
{
  attach_t *previous = NULL;
  attach_t *const attptr = find (client, &previous);

  if (!attptr)
    return -EINVAL;

  attptr->_refcnt -= 1;

  if (!attptr->_refcnt)
    {
      assert (previous ? previous->_next == attptr : _attach_head == attptr);

      if (previous)
	previous->_next = attptr->_next;
      else
	_attach_head = attptr->_next;

      safe_delete (attach_t, attptr);
    }

  assert (_ds.shm_nattch > 0);

  _ds.shm_lpid  = client->cygpid ();
  _ds.shm_nattch -= 1;
  _ds.shm_dtime = time (NULL); // FIXME: sub-second times.

  return 0;
}

/*---------------------------------------------------------------------------*
 * server_shmmgr::segment_t::find ()
 *---------------------------------------------------------------------------*/

server_shmmgr::attach_t *
server_shmmgr::segment_t::find (const class process *const client,
				attach_t **previous)
{
  if (previous)
    *previous = NULL;

  // Nb. The _attach_head list is sorted by winpid.

  for (attach_t *attptr = _attach_head; attptr; attptr = attptr->_next)
    if (attptr->_client == client)
      return attptr;
    else if (attptr->_client->winpid () > client->winpid ())
      return NULL;
    else if (previous)
      *previous = attptr;

  return NULL;
}

/*---------------------------------------------------------------------------*
d179 2
a180 1
		      class process *const client)
d182 13
a194 2
  syscall_printf ("shmat (shmid = %d, shmflg = 0%o) for %d",
		  shmid, shmflg, client->cygpid ());
d203 17
d221 5
a225 1
    result = segptr->attach (client, hFileMap);
d227 1
a227 2
  if (!result)
    _shm_atts += 1;
d229 1
a229 1
  LeaveCriticalSection (&_segments_lock);
d232 2
a233 2
    syscall_printf ("-1 [%d] = shmat (shmid = %d, shmflg = 0%o) for %d",
		    -result, shmid, shmflg, client->cygpid ());
d235 2
a236 2
    syscall_printf ("0x%x = shmat (shmid = %d, shmflg = 0%o) for %d",
		    hFileMap, shmid, shmflg, client->cygpid ());
d294 1
a294 1
	      if (segptr->is_deleted ())
d298 2
a299 2
		  segptr->mark_deleted ();
		  if (segptr->is_pending_delete ())
a323 1
      out_shm_info.shm_atts = _shm_atts;
d354 1
a354 1
server_shmmgr::shmdt (const int shmid, const class process *const client)
d357 1
a357 1
		  shmid, client->cygpid ());
d367 2
a368 1
    result = segptr->detach (client);
d370 3
a372 2
  if (!result)
    _shm_atts -= 1;
d374 3
a376 2
  if (segptr->is_pending_delete ())
    delete_segment (segptr);
d382 1
a382 1
		    -result, shmid, client->cygpid ());
d385 1
a385 1
		    result, shmid, client->cygpid ());
d417 1
a417 1
      else if (segptr->is_deleted ())
a464 2

  assert (_instance);
a474 1
    _shm_atts (0),
d546 4
a549 4
      with_strerr
	(msg,
	 syscall_printf (("failed to create file mapping [size = %lu]: %s"),
			 size, msg));
a582 1
  // FIXME: Overflow risk.
d635 2
a636 1
  assert (segptr->is_pending_delete ());
d650 6
a697 10
  class process *const client = cache->process (_parameters.in.cygpid,
						_parameters.in.winpid);

  if (!client)
    {
      error_code (EAGAIN);
      msglen (0);
      return;
    }

d712 2
a713 1
			     client);
d717 1
a717 1
      result = shmmgr.shmdt (_parameters.in.shmid, client);
a728 1
  client->release ();
@


1.1.2.25
log
@	* cygserver_process (process::process): Add the client's cygpid
	and winpid to all tracing statements as appropriate.
	(process::exit_code): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::shmat): Ditto.
	(server_shmmgr::shmdt): Ditto.
	(server_shmmgr::shmctl): Add a process object argument and remove
	the explicit cygpid argument.  Add the client's cygpid and winpid
	to all tracing statements as appropriate.
	(server_shmmgr::shmget): Ditto.
	(client_request_shm::serve): Update for the new signature of the
	shmctl and shmget methods.
@
text
@d171 1
a171 2
	      const int shmid, int cmd, const struct shmid_ds &,
	      class process *);
d173 1
a173 2
  int shmget (int & out_shmid, key_t, size_t, int shmflg, uid_t, gid_t,
	      class process *);
d395 2
a396 2
  syscall_printf ("shmat (shmid = %d, shmflg = 0%o) for %d(%lu)",
		  shmid, shmflg, client->cygpid (), client->winpid ());
d414 2
a415 4
    syscall_printf (("-1 [%d] = shmat (shmid = %d, shmflg = 0%o) "
		     "for %d(%lu)"),
		    -result, shmid, shmflg,
		    client->cygpid (), client->winpid ());
d417 2
a418 4
    syscall_printf (("0x%x = shmat (shmid = %d, shmflg = 0%o) "
		     "for %d(%lu)"),
		    hFileMap, shmid, shmflg,
		    client->cygpid (), client->winpid ());
d434 1
a434 1
		       class process *const client)
d436 2
a437 2
  syscall_printf ("shmctl (shmid = %d, cmd = 0x%x) for %d(%lu)",
		  shmid, cmd, client->cygpid (), client->winpid ());
d471 1
a471 1
	      segptr->_ds.shm_lpid = client->cygpid ();
d518 1
a518 1
		     "shmctl (shmid = %d, cmd = 0x%x) for %d(%lu)"),
d520 1
a520 1
		    shmid, cmd, client->cygpid (), client->winpid ());
d523 1
a523 1
		     "shmctl (shmid = %d, cmd = 0x%x) for %d(%lu)"),
d527 1
a527 1
		    shmid, cmd, client->cygpid (), client->winpid ());
d539 2
a540 2
  syscall_printf ("shmdt (shmid = %d) for %d(%lu)",
		  shmid, client->cygpid (), client->winpid ());
d561 2
a562 2
    syscall_printf ("-1 [%d] = shmdt (shmid = %d) for %d(%lu)",
		    -result, shmid, client->cygpid (), client->winpid ());
d564 2
a565 2
    syscall_printf ("%d = shmdt (shmid = %d) for %d(%lu)",
		    result, shmid, client->cygpid (), client->winpid ());
d577 1
a577 2
		       const uid_t uid, const gid_t gid,
		       class process *const client)
d579 1
a579 2
  syscall_printf (("shmget (key = 0x%016llx, size = %u, shmflg = 0%o) "
		   "for %d(%lu)"),
d581 1
a581 1
		  client->cygpid (), client->winpid ());
d587 1
a587 2
    result = new_segment (key, size, shmflg,
			  client->cygpid (), uid, gid);
d594 1
a594 2
	  result = new_segment (key, size, shmflg,
				client->cygpid (), uid, gid);
d620 1
a620 1
		     "for %d(%lu)"),
d623 1
a623 1
		    client->cygpid (), client->winpid ());
d627 1
a627 1
		     "for %d(%lu)"),
d630 1
a630 1
		    client->cygpid (), client->winpid ());
d892 2
a893 3
			      _parameters.in.shmflg,
			      _parameters.in.uid, _parameters.in.gid,
			      client);
d911 1
a911 2
			      _parameters.in.ds,
			      client);
@


1.1.2.26
log
@	* cygserver_shm.cc (server_shmmgr::shmdt): Only call
	delete_segment if the segment exists [sic].
@
text
@d561 1
a561 1
  if (!result && segptr->is_pending_delete ())
@


1.1.2.27
log
@	* cygserver_shm.cc (with_strerr): Fix use of %p format.
	* shm.cc (client_shmmgr::shmat): Ditto.
	(client_shmmgr::shmctl): Ditto.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::attach): Ditto.
@
text
@d66 1
a66 1
	  system_printf ("failed to free memory at %p, error = %lu",	\
@


1.1.2.28
log
@	* cygserver.cc (client_request_shutdown::client_request_shutdown):
	Comment out verbose tracing statement.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Ditto.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	* cygserver_shm.cc (client_request_shm::client_request_shm):
	Ditto.
@
text
@d858 1
a858 1
  // verbose: syscall_printf ("created");
@


1.1.2.29
log
@	* include/cygwin/cygserver_process.h
	(cleanup_routine::_key): New field.
	(cleanup_routine::cleanup_routine): Initialise new field with new
	argument.
	(cleanup_routine::operator==): New method.
	(cleanup_routine::cleanup): Make argument non-const.
	(process::is_active): New method.
	(process::remove): Ditto.
	(process::check_exit_code): Rename method.
	* cygserver_process.cc (process::add): Reorganize code.
	(process::remove): New method.
	(process::check_exit_code): Rename method.
	(process::cleanup): Use new `process::is_active' method.
	(process_cache::process): Ditto.
	(process_cache::sync_wait_array): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr): Make `cleanup_t' a friend.
	(segment_t::detach): Make argument non-const.  Remove cleanup
	object from client if appropriate.
	(cleanup_t::_segptr): Remove field.
	(cleanup_t::cleanup_t): Initialise parent explicitly.  Remove
	field.
	(cleanup_t::segptr): New method.
	(cleanup_t::cleanup): Add error checking and reporting.
	(server_shmmgr::shmdt): Make argument non-const.
	(server_shmmgr::find): New method.
@
text
@a81 3
  class cleanup_t;
  friend class cleanup_t;

d132 1
a132 1
    int detach (class process *);
d148 1
a148 1
      : cleanup_routine (segptr)
d150 1
a150 1
      assert (key ());
d153 1
a153 3
    segment_t *segptr () { return static_cast<segment_t *>(key ()); }

    virtual void cleanup (class process *const client)
d155 1
a155 1
      assert (segptr ());
d157 2
a158 5
      if (!shmmgr.find (segptr ()))
	debug_printf ("process cleanup called for non-existent segment");
      else
	{
	  const int res = shmmgr.shmdt (segptr ()->_shmid, client);
d160 2
a161 4
	  if (res != 0)
	    debug_printf ("process cleanup failed: %s", strerror (-res));
	}
    }
d173 1
a173 1
  int shmdt (int shmid, class process *);
a200 2
  const segment_t *find (const segment_t *) const;

d319 1
a319 1
server_shmmgr::segment_t::detach (class process *const client)
a326 11
  if (client->is_active ())
    {
      const cleanup_t key (this);

      if (!client->remove (&key))
	syscall_printf (("failed to remove cleanup routine for %d(%lu) "
			 "[shmid = %d]"),
			client->cygpid (), client->winpid (),
			_shmid);
    }

d543 1
a543 1
server_shmmgr::shmdt (const int shmid, class process *const client)
a712 21

  return NULL;
}


/*---------------------------------------------------------------------------*
 * server_shmmgr::find ()
 *
 * Used to check that a segptr is still valid.  Since it may just be a
 * random blob of memory, the routine doesn't try to access any of the
 * "object's" fields.
 *---------------------------------------------------------------------------*/

const server_shmmgr::segment_t *
server_shmmgr::find (const segment_t *segptr) const
{
  assert (segptr);

  for (segment_t *ptr = _segments_head; ptr; ptr = ptr->_next)
    if (ptr == segptr)
      return segptr;
@


1.1.2.30
log
@	* cygserver_shm.cc (class server_shmmgr): Remove `cleanup_t'
	friend declaration.
	(cleanup_t::cleanup_t): Use the segment's shmid as the key rather
	than the segment pointer itself.
	(cleanup_t::segptr): Remove method.
	(cleanup_t::shmid): New method.
	(cleanup_t::cleanup): Update for new key value.
	(server_shmmgr::find (segment_t *)): Remove method.
	* include/cygwin/cygserver_process.h (cleanup_routine::key): Make
	method const.
@
text
@d82 3
d150 2
a151 2
    cleanup_t (const segment_t *const segptr)
      : cleanup_routine (reinterpret_cast<void *>(segptr->_shmid))
d156 1
a156 1
    int shmid () const { return reinterpret_cast<int>(key ()); }
d160 1
a160 1
      const int res = shmmgr.shmdt (shmid (), client);
d162 9
a170 3
      if (res != 0)
	debug_printf ("process cleanup failed [shmid = %d]: %s",
		      shmid (), strerror (-res));
d211 2
d736 21
@


1.1.2.31
log
@	* safe_memory.h (safe_delete): Make a templated function.
	* cygserver.cc (~server_request): Update use of safe_delete.
	(main): Ditto.
	* cygserver_client.cc (client_request::handle_request): Ditto.
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::remove): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	* cygserver_shm.cc (server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* shm.cc (client_shmmgr::shmdt): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.
@
text
@d350 1
a350 1
      safe_delete (attptr);
d859 1
a859 1
  safe_delete (segptr);
@


1.1.2.32
log
@	* cygserver_shm.cc (with_strerr): Remove macro.
	(server_shmmgr::segment_t::~segment_t): Remove calls to with_strerr.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::new_segment): Ditto.
	* shm.cc (with_strerr): Remove macro.
	(client_shmmgr::shmdt): Remove calls to with_strerr.
	(client_shmmgr::attach): Ditto.
@
text
@d31 42
d242 4
a245 1
    syscall_printf ("failed to close file map [handle = 0x%x]: %E", _hFileMap);
d266 7
a272 3
      syscall_printf (("failed to duplicate handle for client "
		       "[key = 0x%016llx, shmid = %d, handle = 0x%x]: %E"),
		      _ds.shm_perm.key, _shmid, _hFileMap);
d751 5
a755 1
      syscall_printf ("failed to create file mapping [size = %lu]: %E", size);
@


1.1.2.33
log
@	GNUify non-GNU formatted functions calls throughout.
@
text
@d106 1
a106 1
      : cleanup_routine (reinterpret_cast<void *> (segptr->_shmid))
d111 1
a111 1
    int shmid () const { return reinterpret_cast<int> (key ()); }
@


