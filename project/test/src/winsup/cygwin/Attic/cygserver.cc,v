head	1.7;
access;
symbols
	Z-emcb-cygwin_daemon:1.6.0.2
	w32api-2_2:1.5
	mingw-runtime-2_4:1.5
	pre-cgf-merge:1.6
	cgf-dev-branch:1.5.0.16
	cygwin_daemon_merge_HEAD:1.1
	Z-cygwin_daemon_merge_HEAD:1.5
	Z-cygwin_daemon_merge-new_HEAD:1.5
	cygwin_daemon:1.1.0.2;
locks; strict;
comment	@// @;


1.7
date	2003.08.30.16.31.10;	author cgf;	state dead;
branches;
next	1.6;

1.6
date	2003.06.16.03.24.09;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.22.12.04.15;	author scottc;	state Exp;
branches
	1.5.16.1;
next	1.4;

1.4
date	2002.03.15.21.52.05;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.13.02.34.03;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.28.14.30.26;	author rbcollins;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.25.06.31.03;	author rbcollins;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.25.06.31.04;	author rbcollins;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.09.29.10.47.57;	author rbcollins;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.09.30.13.56.37;	author rbcollins;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.01.02.49.18;	author rbcollins;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.10.02.00.02.20;	author rbcollins;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2001.10.02.06.46.05;	author rbcollins;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2001.10.03.04.57.08;	author rbcollins;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2001.10.04.04.21.06;	author rbcollins;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2001.10.07.21.58.20;	author rbcollins;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2002.01.15.14.29.10;	author rbcollins;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2002.01.17.06.37.29;	author rbcollins;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2002.06.13.14.34.00;	author rbcollins;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2002.06.15.21.01.44;	author scottc;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2002.06.15.23.39.46;	author scottc;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	2002.06.16.14.44.56;	author scottc;	state Exp;
branches;
next	1.1.2.16;

1.1.2.16
date	2002.06.16.17.56.15;	author scottc;	state Exp;
branches;
next	1.1.2.17;

1.1.2.17
date	2002.06.16.18.53.08;	author scottc;	state Exp;
branches;
next	1.1.2.18;

1.1.2.18
date	2002.06.16.21.03.11;	author scottc;	state Exp;
branches;
next	1.1.2.19;

1.1.2.19
date	2002.06.17.21.35.32;	author scottc;	state Exp;
branches;
next	1.1.2.20;

1.1.2.20
date	2002.06.17.23.21.25;	author scottc;	state Exp;
branches;
next	1.1.2.21;

1.1.2.21
date	2002.06.18.21.16.11;	author scottc;	state Exp;
branches;
next	1.1.2.22;

1.1.2.22
date	2002.06.21.10.55.50;	author scottc;	state Exp;
branches;
next	1.1.2.23;

1.1.2.23
date	2002.06.24.12.31.24;	author scottc;	state Exp;
branches;
next	1.1.2.24;

1.1.2.24
date	2002.06.28.12.23.27;	author scottc;	state Exp;
branches;
next	1.1.2.25;

1.1.2.25
date	2002.06.30.21.01.48;	author scottc;	state Exp;
branches;
next	1.1.2.26;

1.1.2.26
date	2002.07.03.15.35.42;	author scottc;	state Exp;
branches;
next	1.1.2.27;

1.1.2.27
date	2002.07.11.18.15.40;	author scottc;	state Exp;
branches;
next	1.1.2.28;

1.1.2.28
date	2002.07.27.17.00.16;	author scottc;	state Exp;
branches;
next	1.1.2.29;

1.1.2.29
date	2002.07.27.22.10.50;	author scottc;	state Exp;
branches;
next	1.1.2.30;

1.1.2.30
date	2002.09.21.09.52.33;	author scottc;	state Exp;
branches;
next	1.1.2.31;

1.1.2.31
date	2002.09.22.10.54.38;	author scottc;	state Exp;
branches;
next	;

1.5.16.1
date	2003.07.06.05.10.42;	author cgf;	state Exp;
branches;
next	1.5.16.2;

1.5.16.2
date	2003.09.02.02.31.07;	author cgf;	state dead;
branches;
next	;


desc
@@


1.7
log
@Remove some cygserver files.
@
text
@/* cygserver.cc

   Copyright 2001, 2002 Red Hat Inc.

   Written by Egor Duda <deo@@logos-m.ru>

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "woutsup.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <getopt.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "cygerrno.h"
#include "cygwin_version.h"

#include "cygwin/cygserver.h"
#include "cygwin/cygserver_process.h"
#include "cygwin/cygserver_transport.h"

// Version string.
static const char version[] = "$Revision: 1.6 $";

/*
 * Support function for the XXX_printf () macros in "woutsup.h".
 * Copied verbatim from "strace.cc".
 */
static int
getfunc (char *in_dst, const char *func)
{
  const char *p;
  const char *pe;
  char *dst = in_dst;
  for (p = func; (pe = strchr (p, '(')); p = pe + 1)
    if (isalnum ((int)pe[-1]) || pe[-1] == '_')
      break;
    else if (isspace ((int)pe[-1]))
      {
	pe--;
	break;
      }
  if (!pe)
    pe = strchr (func, '\0');
  for (p = pe; p > func; p--)
    if (p != pe && *p == ' ')
      {
	p++;
	break;
      }
  if (*p == '*')
    p++;
  while (p < pe)
    *dst++ = *p++;

  *dst++ = ':';
  *dst++ = ' ';
  *dst = '\0';

  return dst - in_dst;
}

/*
 * Support function for the XXX_printf () macros in "woutsup.h".
 */
extern "C" void
__cygserver__printf (const char *const function, const char *const fmt, ...)
{
  const DWORD lasterror = GetLastError ();
  const int lasterrno = errno;

  va_list ap;

  char *const buf = (char *) alloca (BUFSIZ);

  assert (buf);

  int len = 0;

  if (function)
    len += getfunc (buf, function);

  va_start (ap, fmt);
  len += vsnprintf (buf + len, BUFSIZ - len, fmt, ap);
  va_end (ap);

  len += snprintf (buf + len, BUFSIZ - len, "\n");

  const int actual = (len > BUFSIZ ? BUFSIZ : len);

  write (2, buf, actual);

  errno = lasterrno;
  SetLastError (lasterror);

  return;
}

#ifdef DEBUGGING

int __stdcall
__set_errno (const char *func, int ln, int val)
{
  debug_printf ("%s:%d val %d", func, ln, val);
  return _impure_ptr->_errno = val;
}

#endif /* DEBUGGING */

GENERIC_MAPPING access_mapping;

static BOOL
setup_privileges ()
{
  BOOL rc, ret_val;
  HANDLE hToken = NULL;
  TOKEN_PRIVILEGES sPrivileges;

  rc = OpenProcessToken (GetCurrentProcess () , TOKEN_ALL_ACCESS , &hToken) ;
  if (!rc)
    {
      system_printf ("error opening process token (%lu)", GetLastError ());
      ret_val = FALSE;
      goto out;
    }
  rc = LookupPrivilegeValue (NULL, SE_DEBUG_NAME, &sPrivileges.Privileges[0].Luid);
  if (!rc)
    {
      system_printf ("error getting privilege luid (%lu)", GetLastError ());
      ret_val = FALSE;
      goto out;
    }
  sPrivileges.PrivilegeCount = 1 ;
  sPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;
  rc = AdjustTokenPrivileges (hToken, FALSE, &sPrivileges, 0, NULL, NULL) ;
  if (!rc)
    {
      system_printf ("error adjusting privilege level. (%lu)",
		     GetLastError ());
      ret_val = FALSE;
      goto out;
    }

  access_mapping.GenericRead = FILE_READ_DATA;
  access_mapping.GenericWrite = FILE_WRITE_DATA;
  access_mapping.GenericExecute = 0;
  access_mapping.GenericAll = FILE_READ_DATA | FILE_WRITE_DATA;

  ret_val = TRUE;

out:
  CloseHandle (hToken);
  return ret_val;
}

int
check_and_dup_handle (HANDLE from_process, HANDLE to_process,
		      HANDLE from_process_token,
		      DWORD access,
		      HANDLE from_handle,
		      HANDLE *to_handle_ptr, BOOL bInheritHandle = FALSE)
{
  HANDLE local_handle = NULL;
  int ret_val = EACCES;

  if (from_process != GetCurrentProcess ())
    {
      if (!DuplicateHandle (from_process, from_handle,
			    GetCurrentProcess (), &local_handle,
			    0, bInheritHandle,
			    DUPLICATE_SAME_ACCESS))
	{
	  system_printf ("error getting handle(%u) to server (%lu)",
			 (unsigned int)from_handle, GetLastError ());
	  goto out;
	}
    } else
      local_handle = from_handle;

  if (!wincap.has_security ())
    assert (!from_process_token);
  else
    {
      char sd_buf [1024];
      PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR) &sd_buf;
      DWORD bytes_needed;
      PRIVILEGE_SET ps;
      DWORD ps_len = sizeof (ps);
      BOOL status;

      if (!GetKernelObjectSecurity (local_handle,
				    (OWNER_SECURITY_INFORMATION
				     | GROUP_SECURITY_INFORMATION
				     | DACL_SECURITY_INFORMATION),
				    sd, sizeof (sd_buf), &bytes_needed))
	{
	  system_printf ("error getting handle SD (%lu)", GetLastError ());
	  goto out;
	}

      MapGenericMask (&access, &access_mapping);

      if (!AccessCheck (sd, from_process_token, access, &access_mapping,
			&ps, &ps_len, &access, &status))
	{
	  system_printf ("error checking access rights (%lu)",
			 GetLastError ());
	  goto out;
	}

      if (!status)
	{
	  system_printf ("access to object denied");
	  goto out;
	}
    }

  if (!DuplicateHandle (from_process, from_handle,
			to_process, to_handle_ptr,
			access, bInheritHandle, 0))
    {
      system_printf ("error getting handle to client (%lu)", GetLastError ());
      goto out;
    }

  // verbose: debug_printf ("Duplicated %p to %p", from_handle, *to_handle_ptr);

  ret_val = 0;

 out:
  if (local_handle && from_process != GetCurrentProcess ())
    CloseHandle (local_handle);

  return (ret_val);
}

/*
 * client_request_attach_tty::serve ()
 */

void
client_request_attach_tty::serve (transport_layer_base *const conn,
				  process_cache *)
{
  assert (conn);

  assert (!error_code ());

  if (!wincap.has_security ())
    {
      syscall_printf ("operation only supported on systems with security");
      error_code (EINVAL);
      msglen (0);
      return;
    }

  if (msglen () != sizeof (req))
    {
      syscall_printf ("bad request body length: expecting %lu bytes, got %lu",
		      sizeof (req), msglen ());
      error_code (EINVAL);
      msglen (0);
      return;
    }

  msglen (0);			// Until we fill in some fields.

  // verbose: debug_printf ("pid %ld:(%p,%p) -> pid %ld",
  //			    req.master_pid, req.from_master, req.to_master,
  //			    req.pid);

  // verbose: debug_printf ("opening process %ld", req.master_pid);

  const HANDLE from_process_handle =
    OpenProcess (PROCESS_DUP_HANDLE, FALSE, req.master_pid);

  if (!from_process_handle)
    {
      system_printf ("error opening `from' process, error = %lu",
		     GetLastError ());
      error_code (EACCES);
      return;
    }

  // verbose: debug_printf ("opening process %ld", req.pid);

  const HANDLE to_process_handle =
    OpenProcess (PROCESS_DUP_HANDLE, FALSE, req.pid);

  if (!to_process_handle)
    {
      system_printf ("error opening `to' process, error = %lu",
		     GetLastError ());
      CloseHandle (from_process_handle);
      error_code (EACCES);
      return;
    }

  // verbose: debug_printf ("Impersonating client");
  conn->impersonate_client ();

  HANDLE token_handle = NULL;

  // verbose: debug_printf ("about to open thread token");
  const DWORD rc = OpenThreadToken (GetCurrentThread (),
				    TOKEN_QUERY,
				    TRUE,
				    &token_handle);

  // verbose: debug_printf ("opened thread token, rc=%lu", rc);
  conn->revert_to_self ();

  if (!rc)
    {
      system_printf ("error opening thread token, error = %lu",
		     GetLastError ());
      CloseHandle (from_process_handle);
      CloseHandle (to_process_handle);
      error_code (EACCES);
      return;
    }

  // From this point on, a reply body is returned to the client.

  const HANDLE from_master = req.from_master;
  const HANDLE to_master = req.to_master;

  req.from_master = NULL;
  req.to_master = NULL;

  msglen (sizeof (req));

  if (from_master)
    if (check_and_dup_handle (from_process_handle, to_process_handle,
			      token_handle,
			      GENERIC_READ,
			      from_master,
			      &req.from_master, TRUE) != 0)
      {
	system_printf ("error duplicating from_master handle, error = %lu",
		       GetLastError ());
	error_code (EACCES);
      }

  if (to_master)
    if (check_and_dup_handle (from_process_handle, to_process_handle,
			      token_handle,
			      GENERIC_WRITE,
			      to_master,
			      &req.to_master, TRUE) != 0)
      {
	system_printf ("error duplicating to_master handle, error = %lu",
		       GetLastError ());
	error_code (EACCES);
      }

  CloseHandle (from_process_handle);
  CloseHandle (to_process_handle);
  CloseHandle (token_handle);

  debug_printf ("%lu(%lu, %lu) -> %lu(%lu,%lu)",
		req.master_pid, from_master, to_master,
		req.pid, req.from_master, req.to_master);

  return;
}

void
client_request_get_version::serve (transport_layer_base *, process_cache *)
{
  assert (!error_code ());

  if (msglen ())
    syscall_printf ("unexpected request body ignored: %lu bytes", msglen ());

  msglen (sizeof (version));

  version.major = CYGWIN_SERVER_VERSION_MAJOR;
  version.api   = CYGWIN_SERVER_VERSION_API;
  version.minor = CYGWIN_SERVER_VERSION_MINOR;
  version.patch = CYGWIN_SERVER_VERSION_PATCH;
}

class server_request : public queue_request
{
public:
  server_request (transport_layer_base *const conn, process_cache *const cache)
    : _conn (conn), _cache (cache)
  {}

  virtual ~server_request ()
  {
    safe_delete (_conn);
  }

  virtual void process ()
  {
    client_request::handle_request (_conn, _cache);
  }

private:
  transport_layer_base *const _conn;
  process_cache *const _cache;
};

class server_submission_loop : public queue_submission_loop
{
public:
  server_submission_loop (threaded_queue *const queue,
			  transport_layer_base *const transport,
			  process_cache *const cache)
    : queue_submission_loop (queue, false),
      _transport (transport),
      _cache (cache)
  {
    assert (_transport);
    assert (_cache);
  }

private:
  transport_layer_base *const _transport;
  process_cache *const _cache;

  virtual void request_loop ();
};

/* FIXME: this is a little ugly.  What we really want is to wait on
 * two objects: one for the pipe/socket, and one for being told to
 * shutdown.  Otherwise this will stay a problem (we won't actually
 * shutdown until the request _AFTER_ the shutdown request.  And
 * sending ourselves a request is ugly
 */
void
server_submission_loop::request_loop ()
{
  /* I'd like the accepting thread's priority to be above any "normal"
   * thread in the system to avoid overflowing the listen queue (for
   * sockets; similar issues exist for named pipes); but, for example,
   * a normal priority thread in a foregrounded process is boosted to
   * THREAD_PRIORITY_HIGHEST (AFAICT).  Thus try to set the current
   * thread's priority to a level one above that.  This fails on
   * win9x/ME so assume any failure in that call is due to that and
   * simply call again at one priority level lower.
   */
  if (!SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_HIGHEST + 1))
    if (!SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_HIGHEST))
      debug_printf ("failed to raise accept thread priority, error = %lu",
		    GetLastError ());

  while (_running)
    {
      bool recoverable = false;
      transport_layer_base *const conn = _transport->accept (&recoverable);
      if (!conn && !recoverable)
	{
	  system_printf ("fatal error on IPC transport: closing down");
	  return;
	}
      // EINTR probably implies a shutdown request; so back off for a
      // moment to let the main thread take control, otherwise the
      // server spins here receiving EINTR repeatedly since the signal
      // handler in the main thread doesn't get a chance to be called.
      if (!conn && errno == EINTR)
	{
	  if (!SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_NORMAL))
	    debug_printf ("failed to reset thread priority, error = %lu",
			  GetLastError ());

	  Sleep (0);
	  if (!SetThreadPriority (GetCurrentThread (),
				  THREAD_PRIORITY_HIGHEST + 1))
	    if (!SetThreadPriority (GetCurrentThread (),
				    THREAD_PRIORITY_HIGHEST))
	      debug_printf ("failed to raise thread priority, error = %lu",
			    GetLastError ());
	}
      if (conn)
	_queue->add (safe_new (server_request, conn, _cache));
    }
}

client_request_shutdown::client_request_shutdown ()
  : client_request (CYGSERVER_REQUEST_SHUTDOWN)
{
  // verbose: syscall_printf ("created");
}

void
client_request_shutdown::serve (transport_layer_base *, process_cache *)
{
  assert (!error_code ());

  if (msglen ())
    syscall_printf ("unexpected request body ignored: %lu bytes", msglen ());

  /* FIXME: link upwards, and then this becomes a trivial method call to
   * only shutdown _this queue_
   */

  kill (getpid (), SIGINT);

  msglen (0);
}

static sig_atomic_t shutdown_server = false;

static void
handle_signal (const int signum)
{
  /* any signal makes us die :} */

  shutdown_server = true;
}

/*
 * print_usage ()
 */

static void
print_usage (const char *const pgm)
{
  printf ("Usage: %s [OPTIONS]\n", pgm);
  printf ("  -c, --cleanup-threads   number of cleanup threads to use\n");
  printf ("  -h, --help              output usage information and exit\n");
  printf ("  -r, --request-threads   number of request threads to use\n");
  printf ("  -s, --shutdown          shutdown the daemon\n");
  printf ("  -v, --version           output version information and exit\n");
}

/*
 * print_version ()
 */

static void
print_version (const char *const pgm)
{
  char *vn = NULL;

  const char *const colon = strchr (version, ':');

  if (!colon)
    {
      vn = strdup ("?");
    }
  else
    {
      vn = strdup (colon + 2);	// Skip ": "

      char *const spc = strchr (vn, ' ');

      if (spc)
	*spc = '\0';
    }

  char buf[200];
  snprintf (buf, sizeof (buf), "%d.%d.%d(%d.%d/%d/%d)-(%d.%d.%d.%d) %s",
	    cygwin_version.dll_major / 1000,
	    cygwin_version.dll_major % 1000,
	    cygwin_version.dll_minor,
	    cygwin_version.api_major,
	    cygwin_version.api_minor,
	    cygwin_version.shared_data,
	    CYGWIN_SERVER_VERSION_MAJOR,
	    CYGWIN_SERVER_VERSION_API,
	    CYGWIN_SERVER_VERSION_MINOR,
	    CYGWIN_SERVER_VERSION_PATCH,
	    cygwin_version.mount_registry,
	    cygwin_version.dll_build_date);

  printf ("%s (cygwin) %s\n", pgm, vn);
  printf ("API version %s\n", buf);
  printf ("Copyright 2001, 2002 Red Hat, Inc.\n");
  printf ("Compiled on %s\n", __DATE__);

  free (vn);
}

/*
 * main ()
 */

int
main (const int argc, char *argv[])
{
  const struct option longopts[] = {
    {"cleanup-threads", required_argument, NULL, 'c'},
    {"help", no_argument, NULL, 'h'},
    {"request-threads", required_argument, NULL, 'r'},
    {"shutdown", no_argument, NULL, 's'},
    {"version", no_argument, NULL, 'v'},
    {0, no_argument, NULL, 0}
  };

  const char opts[] = "c:hr:sv";

  int cleanup_threads = 2;
  int request_threads = 10;
  bool shutdown = false;

  const char *pgm = NULL;

  if (!(pgm = strrchr (*argv, '\\')) && !(pgm = strrchr (*argv, '/')))
    pgm = *argv;
  else
    pgm++;

  wincap.init ();
  if (wincap.has_security ())
    setup_privileges ();

  int opt;

  while ((opt = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (opt)
      {
      case 'c':
	cleanup_threads = atoi (optarg);
	if (cleanup_threads <= 0)
	  {
	    fprintf (stderr,
		     "%s: number of cleanup threads must be positive\n",
		     pgm);
	    exit (1);
	  }
	break;

      case 'h':
	print_usage (pgm);
	return 0;

      case 'r':
	request_threads = atoi (optarg);
	if (request_threads <= 0)
	  {
	    fprintf (stderr,
		     "%s: number of request threads must be positive\n",
		     pgm);
	    exit (1);
	  }
	break;

      case 's':
	shutdown = true;
	break;

      case 'v':
	print_version (pgm);
	return 0;

      case '?':
	fprintf (stderr, "Try `%s --help' for more information.\n", pgm);
	exit (1);
      }

  if (optind != argc)
    {
      fprintf (stderr, "%s: too many arguments\n", pgm);
      exit (1);
    }

  if (shutdown)
    {
      /* Setting `cygserver_running' stops the request code making a
       * version request, which is not much to the point.
       */
      cygserver_running = CYGSERVER_OK;

      client_request_shutdown req;

      if (req.make_request () == -1 || req.error_code ())
	{
	  fprintf (stderr, "%s: shutdown request failed: %s\n",
		   pgm, strerror (req.error_code ()));
	  exit (1);
	}

      // FIXME: It would be nice to wait here for the daemon to exit.

      return 0;
    }

#define SIGHANDLE(SIG)							\
  do									\
    {									\
      struct sigaction act;						\
									\
      act.sa_handler = &handle_signal;					\
      act.sa_mask = 0;							\
      act.sa_flags = 0;							\
									\
      if (sigaction (SIG, &act, NULL) == -1)				\
	{								\
	  system_printf ("failed to install handler for " #SIG ": %s",	\
			 strerror (errno));				\
	  exit (1);							\
	}								\
    } while (false)

  SIGHANDLE (SIGHUP);
  SIGHANDLE (SIGINT);
  SIGHANDLE (SIGTERM);

  print_version (pgm);
  setbuf (stdout, NULL);
  printf ("daemon starting up");

  threaded_queue request_queue (request_threads);
  printf (".");

  transport_layer_base *const transport = create_server_transport ();
  assert (transport);
  printf (".");

  process_cache cache (cleanup_threads);
  printf (".");

  server_submission_loop submission_loop (&request_queue, transport, &cache);
  printf (".");

  request_queue.add_submission_loop (&submission_loop);
  printf (".");

  if (transport->listen () == -1)
    {
      exit (1);
    }
  printf (".");

  cache.start ();
  printf (".");

  request_queue.start ();
  printf (".");

  printf ("complete\n");

  /* TODO: wait on multiple objects - the thread handle for each
   * request loop + all the process handles. This should be done by
   * querying the request_queue and the process cache for all their
   * handles, and then waiting for (say) 30 seconds.  after that we
   * recreate the list of handles to wait on, and wait again.  the
   * point of all this abstraction is that we can trivially server
   * both sockets and pipes simply by making a new transport, and then
   * calling request_queue.process_requests (transport2);
   */
  /* WaitForMultipleObjects abort && request_queue && process_queue && signal
     -- if signal event then retrigger it
  */
  while (!shutdown_server && request_queue.running () && cache.running ())
    pause ();

  printf ("\nShutdown request received - new requests will be denied\n");
  request_queue.stop ();
  printf ("All pending requests processed\n");
  safe_delete (transport);
  printf ("No longer accepting requests - cygwin will operate in daemonless mode\n");
  cache.stop ();
  printf ("All outstanding process-cache activities completed\n");
  printf ("daemon shutdown\n");

  return 0;
}
@


1.6
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d34 1
a34 1
static const char version[] = "$Revision: 1.5 $";
@


1.5
log
@2002-09-22  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	GNUify non-GNU formatted functions calls throughout.

2002-09-22  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (with_strerr): Remove macro.
	(server_shmmgr::segment_t::~segment_t): Remove calls to with_strerr.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::new_segment): Ditto.
	* shm.cc (with_strerr): Remove macro.
	(client_shmmgr::shmdt): Remove calls to with_strerr.
	(client_shmmgr::attach): Ditto.

2002-09-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/sys/ipc.h: Move to "include/cygwin/ipc.h".
	* include/sys/msg.h: Move to "include/cygwin/msg.h".
	* include/sys/sem.h: Move to "include/cygwin/sem.h".
	* include/sys/shm.h: Move to "include/cygwin/shm.h".
	* include/cygwin/ipc.h: New file.
	* include/cygwin/msg.h: Ditto.
	* include/cygwin/sem.h: Ditto.
	* include/cygwin/shm.h: Ditto.
	* cygserver_shm.h: Update includes.
	* msg.cc: Ditto.
	* sem.cc: Ditto.

2002-09-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h (safe_delete): Make a templated function.
	* cygserver.cc (~server_request): Update use of safe_delete.
	(main): Ditto.
	* cygserver_client.cc (client_request::handle_request): Ditto.
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::remove): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	* cygserver_shm.cc (server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* shm.cc (client_shmmgr::shmdt): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.

2002-08-29  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: Replace #include <new> with an explicit
	definition of the placement new operator.
	(safe_delete): Remove unnecessary ## operator.

2002-07-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (class server_shmmgr): Remove `cleanup_t'
	friend declaration.
	(cleanup_t::cleanup_t): Use the segment's shmid as the key rather
	than the segment pointer itself.
	(cleanup_t::segptr): Remove method.
	(cleanup_t::shmid): New method.
	(cleanup_t::cleanup): Update for new key value.
	(server_shmmgr::find (segment_t *)): Remove method.
	* include/cygwin/cygserver_process.h (cleanup_routine::key): Make
	method const.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_process.h
	(cleanup_routine::_key): New field.
	(cleanup_routine::cleanup_routine): Initialise new field with new
	argument.
	(cleanup_routine::operator==): New method.
	(cleanup_routine::key): New method.
	(cleanup_routine::cleanup): Make argument non-const.
	(process::is_active): New method.
	(process::remove): Ditto.
	(process::check_exit_code): Rename method.
	* cygserver_process.cc (process::add): Reorganize code.
	(process::remove): New method.
	(process::check_exit_code): Rename method.
	(process::cleanup): Use new `process::is_active' method.
	(process_cache::process): Ditto.
	(process_cache::sync_wait_array): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr): Make `cleanup_t' a friend.
	(segment_t::detach): Make argument non-const.  Remove cleanup
	object from client if appropriate.
	(cleanup_t::_segptr): Remove field.
	(cleanup_t::cleanup_t): Initialise parent explicitly.  Remove
	field.
	(cleanup_t::segptr): New method.
	(cleanup_t::cleanup): Add error checking and reporting.
	(server_shmmgr::shmdt): Make argument non-const.
	(server_shmmgr::find (segment_t *)): New method.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (client_request_shutdown::client_request_shutdown):
	Comment out verbose tracing statement.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Ditto.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	* cygserver_shm.cc (client_request_shm::client_request_shm):
	Ditto.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc (transport_layer_pipes::listen):
	Set `_is_listening_endpoint' appropriately.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(transport_layer_base::listen): Change return type.
	(transport_layer_base::connect): Ditto.
	* include/cygwin/cygserver_transport_pipes.h
	(transport_layer_pipes::listen): Change return type.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::_sec_none_nih): Remove unused field.
	(transport_layer_pipes::_is_listening_endpoint): New field.
	* cygserver_transport_pipes.cc: Synchronize with sockets code.
	(transport_layer_pipes::transport_layer_pipes): Initialise new
	field.  Separate out asserts.
	(transport_layer_pipes::listen): Change return type.  Add asserts.
	(transport_layer_pipes::accept): Add asserts.
	(transport_layer_pipes::read): Change conditional to an assert.
	Add assert.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Change return type.  Change
	conditional to an assert.  Add asserts.  Rationalize error code
	slightly.
	(transport_layer_pipes::impersonate_client): Add asserts.
	* include/cygwin/cygserver_transport_sockets.h
	(transport_layer_sockets::listen): Change return type.
	(transport_layer_sockets::connect): Ditto.
	(transport_layer_sockets::_addr): Change type of field.
	(transport_layer_sockets::_addr_len): Ditto.
	(transport_layer_sockets::_is_accepted_endpoint): New field.
	(transport_layer_sockets::_is_listening_endpoint): Ditto.
	* cygserver_transport_sockets.cc
	(MAX_CONNECT_RETRY): New constant.
	(transport_layer_sockets::transport_layer_sockets): Initialise new
	fields.  Only initialise the socket address where necessary.
	(transport_layer_sockets::listen): Change return type.  Rewrite.
	(transport_layer_sockets::accept): Add asserts.  Add tracing
	statements.  Use a local variable to hold the accepted address.
	(transport_layer_sockets::close): Add tracing statements.  Unlink
	the UNIX domain socket file as appropriate.  Close the socket
	cleanly.
	(transport_layer_sockets::read): Rewrite method.
	(transport_layer_sockets::write): Ditto.
	(transport_layer_sockets::connect): Change return type.  Rewrite.
	* cygserver.cc (server_submission_loop::request_loop): Run the
	listening thread at high priority with special handling for
	shutdown.
	(main): Print the request error code rather than errno in shutdown
	request code.  Install signal handlers with sigaction(2) to avoid
	setting SA_RESTART.  Check value of the listen method call, now it
	has one.
	* cygserver_client.cc (client_request::make_request): Check new
	return value on connect method call.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport_pipes.h
	(cygserver_transport_pipes::_sd): Rename field.
	(cygserver_transport_pipes::_sec_none_nih): Ditto.
	(cygserver_transport_pipes::_sec_all_nih): Ditto.
	(cygserver_transport_pipes::_pipe_name): Ditto.
	(cygserver_transport_pipes::_hPipe): Ditto.
	(cygserver_transport_pipes::_is_accepted_endpoint): Ditto.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::transport_layer_pipes): Rename fields.
	(transport_layer_pipes::init_security): Ditto.
	(transport_layer_pipes::listen): Ditto.
	(transport_layer_pipes::accept): Ditto.
	(transport_layer_pipes::close): Ditto.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.
	(transport_layer_pipes::revert_to_self): Ditto.
	* include/cygwin/cygserver_transport_sockets.h
	(cygserver_transport_sockets::_fd): Rename field.
	(cygserver_transport_sockets::_addr): Ditto.
	(cygserver_transport_sockets::_addr_len): Ditto.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::transport_layer_sockets): Rename fields.
	(transport_layer_sockets::listen): Ditto.
	(transport_layer_sockets::accept): Ditto.
	(transport_layer_sockets::close): Ditto.
	(transport_layer_sockets::read): Ditto.
	(transport_layer_sockets::write): Ditto.
	(transport_layer_sockets::connect): Ditto.

2002-07-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (with_strerr): Fix use of %p format.
	* shm.cc (client_shmmgr::shmat): Ditto.
	(client_shmmgr::shmctl): Ditto.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::attach): Ditto.

2002-07-14  Christopher Faylor  <cgf@@redhat.com>

	* woutsup.h (system_printf): Remove extraneous semicolon from macro
	definition.

2002-07-14  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc
	(transport_layer_pipes::connect): Use ProtectHandle in DLL code.
	(transport_layer_pipes::close): Use ForceCloseHandle in DLL code.

2002-07-13  Nicholas Wourms  <nwourms@@netscape.com>

	* threaded_queue.h (class queue_submission_loop): Correct friend
	declaration for GCC 3.1.1.
	* include/cygwin/cygserver_process.h (class process): Ditto.
	(class process_cache): Ditto.

2002-07-12  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::shmdt): Only call
	delete_segment if the segment exists [sic].

2002-07-12  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: Include <new> rather than <new.h> for gcc 3.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* safe_memory.h: New file extracted from "woutsup.h".
	* woutsup.h: Move the "safe" new/delete macros into the new
	"safe_memory.h" header file and include that here.
	* cygserver_client.cc: Explicitly include "safe_memory.h" for
	client-side code.
	(client_request::make_request): Use the "safe" new/delete macros
	unconditionally, i.e. use them on the client side as well as on
	the server side.
	* cygserver_transport.cc: Explicitly include "safe_memory.h" for
	client-side code.
	(create_server_transport): Use the "safe" new/delete macros
	unconditionally, i.e. use them on the client side as well as on
	the server side.
	* shm.cc: Include "safe_memory.h".
	(client_shmmgr::instance): Use the "safe" new/delete macros.
	(client_shmmgr::shmdt): Ditto.
	(client_shmmgr::new_segment): Ditto.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_process (process::process): Add the client's cygpid
	and winpid to all tracing statements as appropriate.
	(process::exit_code): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::shmat): Ditto.
	(server_shmmgr::shmdt): Ditto.
	(server_shmmgr::shmctl): Add a process object argument and remove
	the explicit cygpid argument.  Add the client's cygpid and winpid
	to all tracing statements as appropriate.
	(server_shmmgr::shmget): Ditto.
	(client_request_shm::serve): Update for the new signature of the
	shmctl and shmget methods.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (client_request_shutdown::serve): Don't set the
	shutdown flag directly, but send a SIGINT, as the signal handler
	sets the flag and the signal breaks the pause(2) in the main loop.
	(print_usage): Add new options.
	(main): Add new --cleanup-threads and --request-threads options to
	set the number of threads used by the daemon.  Use pause(2) rather
	the win32 Sleep in the main loop.
	* shm.cc (shmat): Add sigframe.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Automatically detach processes from any
	segments they are attached to at exit.
	(class server_shmmgr::attach_t): New class.
	(server_shmmgr::segment_t::IS_DELETED): Rename and make private.
	(server_shmmgr::segment_t::_sequence): Make private.
	(server_shmmgr::segment_t::_flg): Ditto.
	(server_shmmgr::segment_t::_hFileMap): Ditto.
	(server_shmmgr::segment_t::_attach_head): New private field.
	(server_shmmgr::segment_t::segment_t): Initialise new fields.
	Make non-inline.
	(server_shmmgr::segment_t::~segment_t): New method.
	(server_shmmgr::segment_t::is_deleted): Ditto.
	(server_shmmgr::segment_t::is_pending_delete): Ditto.
	(server_shmmgr::segment_t::mark_deleted): Ditto.
	(server_shmmgr::segment_t::attach): Ditto.
	(server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::segment_t::find): Ditto.
	(class server_shmmgr::cleanup_t): New class.
	(server_shmmgr::_shm_atts): New private field.
	(server_shmmgr::shmat): Add a process object argument to replace
	the removed process_cache, cygpid and winpid arguments.  Remove
	the process_cache manipulations.  Move body of code to the
	segment_t::attach method.  Increment _shm_atts when required.
	Update tracing statements.
	(server_shmmgr::shmdt): Add a process object argument to replace
	the removed cygpid argument.  Move body of code to the
	segment_t::detach method.  Decrement _shm_atts when required.
	Update tracing statements.
	(server_shmmgr::shmget): Use the new segment_t::is_deleted method.
	(server_shmmgr::server_shmmgr): Initialise the new _shm_atts
	field.
	(server_shmmgr::delete_segment): Remove the CloseHandle code, as
	this is now done in the segment_t destructor.
	(client_request_shm::serve): Look up the client's process object
	and pass to the server_shmmgr::shmat and server_shmmgr::shmdt
	methods rather than passing the cache, winpid and cygpid.
	* cygserver_process.h: Add a cygpid to the process object to make
	it more useful and then pass process objects rather than winpids
	where possible.
	(cleanup_routine::cleanup): Change argument to be a pointer to a
	process object.
	(class process): Re-order fields for no discernible reason.
	(process::_cygpid): New field.
	(process::process): Add a cygpid argument.
	(process::winpid): New method.
	(process::cygpid): Ditto.
	(process::add): Make public, as it always should have been.
	(process_cache::process): Add a cygpid argument.
	* cygserver_process.cc (process::process): Add a cygpid argument
	and use it to initialise the `_cygpid' field.  Re-order
	initialisers to match new field order.
	(process::cleanup): Pass `this' rather than just the winpid to
	cleanup_routine::cleanup.
	(process_cache::process): Add a cygpid argument and pass it to the
	process object constructor.
	* include/sys/shm.h (shmatt_t): Make unsigned as per SUSv3.
	(shm_info::shm_atts): New field.

2002-07-11  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (class server_shmmgr::segment_t): Add `_'
	prefix to the names of all fields.

2002-07-10  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* msg.cc: New file of stub functions, no functionality.
	* sem.cc: Ditto.
	* shm.cc (client_shmmgr::shmctl): Add support for an out shm_info
	buffer for the SHM_INFO command.
	(client_shmmgr::shmget): Use %X to print keys.
	* include/sys/ipc.h: Comment all fields and values.
	(IPC_PRIVATE): Change to be non-negative.
	* include/sys/msg.h: New file with SUSv3 and ipcs(8) interfaces.
	* include/sys/sem.h: Ditto.
	* include/sys/shm.h: Comment all fields and values.
	(struct shm_info): New struct.
	* cygserver_shm.h (client_request_shm::shminfo): Rename.
	(client_request_shm::shm_info): New method.
	(client_request_shm::_parameters.out.hFileMap): Move into union.
	(client_request_shm::_parameters.out.shminfo): Rename.
	(client_request_shm::_parameters.out.shm_info): New field.
	* cygserver_shm.cc (server_shmmgr::_shm_ids): Rename.
	(server_shmmgr::_shm_tot): New field.
	(server_shmmgr::shmctl): Rename `out_shminfo' argument.  Add
	`out_shm_info' argument.  Fill in the `out_shm_info' argument in
	the SHM_INFO command.
	(server_shmmgr::shmget): Check `shmflg' against the mode of
	existing segments as per Stevens 1990, p. 123.
	(server_shmmgr::server_shmmgr): Initialise the new `_shm_tot'
	field.
	(server_shmmgr::new_segment): Set ENOMEM if CreateFileMapping
	fails.  Pass `size' to new_segment.
	(server_shmmgr::new_segment): Add size argument and use it to
	check against and update the new `_shm_tot' field.
	(server_shmmgr::delete_segment): Update the new `_shm_tot' field.
	* Makefile.in (DLL_OFILES): Add new DLL object files.

2002-07-09  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc: The main change is to make the
	client try harder to connect to the server if it's previously
	connected, and so has good grounds for believing that the server
	is running.
	(MAX_WAIT_NAMED_PIPE_RETRY): Change to be an enumerator.
	(WAIT_NAMED_PIPE_TIMEOUT): Ditto.
	(transport_layer_pipes::accept): Use interlocked operators on
	`pipe_instance'.
	(transport_layer_pipes::close): Rearrange so that FlushFileBuffers
	and DisconnectNamedPipe are only called for accepted endpoints.
	Use interlocked operators on `pipe_instance'.
	(transport_layer_pipes::read): Use set_errno where required.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Add local static variable
	`assume_cygserver'.  Set it if a connection is made to cygserver,
	clear it if a connection is not made even after retrying.  If set,
	ignore all errors from CreateFile and retry the connection.  Catch
	the situation where WaitNamedPipe fails to wait [sic] and add a
	`Sleep (0)' so that the server gets a chance to run.

2002-07-03  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* dcrt0.cc: Only check for cygserver if and when required.
	(dll_crt0_1): Remove call to `cygserver_init ()'.
	* fhandler_tty.cc (fhandler_tty_slave::open): Change the cygserver
	logic to allow for the fact that `cygserver_init ()' may not yet
	have been called.
	(fhandler_tty_slave::cygserver_attach_tty): Tweak the cygserver
	request logic to conform to the practice elsewhere in the code.
	* tty.cc (tty::common_init): Add an explicit call to
	`cygserver_init ()' if it hasn't already been called.
	* include/cygwin/cygserver.h (CYGSERVER_UNAVAIL): Rename from
	`CYGSERVER_DEAD'.
	(client_request_get_version::check_version): Make available in
	cygserver as well the DLL.
	(check_cygserver_available): Ditto.  Remove `check_version_too'
	argument.
	(cygserver_init): Ditto.  And likewise.
	* cygserver_client.cc (client_request_get_version::check_version):
	Make available in cygserver as well the DLL.
	(client_request::make_request): This may now be called without
	`cygserver_init ()' having been called first.  Detect this and
	call it as required.  Add tracing.
	(check_cygserver_available): Make available in cygserver as well
	the DLL.  Remove `check_version_too' argument and always check the
	version information.  And since this is called from within
	`cygserver_init ()', force `cygserver_running' before calling
	`client_request::make_request ()'.
	(cygserver_init): Make available in cygserver as well the DLL.
	Remove `check_version_too' argument.

2002-07-03  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Implement the ipcs(8) interfaces, IPC_INFO,
	SHM_STAT and SHM_INFO.
	(server_shmmgr::segment_t::sequence): New static field.
	(server_shmmgr::segment_t::key): Remove field, use the new
	ds.shm_perm.key field instead.
	(server_shmmgr::segment_t::shmid): Remove field.
	(server_shmmgr::segment_t::intid): New field.
	(server_shmmgr::segment_t::segment_t): Use the `key' argument to
	initialise `ds.shm_perm.key'.  Change from using `shmid' to
	`intid'.
	(server_shmmgr::_shmseg_cnt): Renamed from `_shmid_cnt'.
	(server_shmmgr::_intid_max): Renamed from `_shmid_max.
	(server_shmmgr::shmat): Move the out arguments to the start of the
	argument list.  Rename the `pid' argument as `cygpid'.  Add
	tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmctl): Add separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add support for the ipcs(8)
	interfaces.  Add tracing.  Pass an intid to `find ()', not a
	shmid.
	(server_shmmgr::shmdt): Rename the `pid' argument as `cygpid'.
	Add tracing.  Pass an intid to `find ()', not a shmid.
	(server_shmmgr::shmget): Add a separate out arguments.  Rename the
	`pid' argument as `cygpid'.  Add tracing.
	(server_shmmgr::server_shmmgr): Update for new field names.
	(server_shmmgr::find_by_key): Update for the new `ds.shm_perm.key'
	field.
	(server_shmmgr::find): Update to use the new `segment_t::intid'
	field.
	(server_shmmgr::new_segment): Rename the `pid' argument as
	`cygpid'.  Check that the requested size is within bounds.  Handle
	new error result from `new_segment (key, HANDLE)'.
	(server_shmmgr::new_segment): Work with intids, not shmids.  Check
	that the new intid is within bounds.  Update for new field names.
	(server_shmmgr::delete_segment): Pass an intid to `find ()', not a
	shmid.  Update for new field names.
	(client_request_shm::serve): Check that the incoming message
	length is the size of the `_parameters.in' struct, not of the
	whole in/out parameter union.  Likewise, set the outgoing message
	length to the size of the `_parameters.out' struct.  Update for
	the new server_shmmgr interfaces.
	* include/sys/ipc.h (ipc_perm::key): New field.
	* include/sys/shm.h (SHM_INFO): New constant.
	* cygserver_ipc.h (IPCMNI): New constant.
	(ipc_int2ext): Add `sequence' argument and munge this into the
	external ipc id.
	(ipc_ext2int_subsys): Unmunge the sequence number from the
	external ipc id.
	(ipc_ext2int): Ditto.
	(ipc_inc_id): Remove.
	(ipc_dec_id): Remove.
	* cygserver_shm.h (SHMMAX): New constant.
	(SHMMIN): Ditto.
	(SHMMNI): Ditto.
	(SHMSEG): Ditto.
	(SHMALL): Ditto.
	(client_request_shm::_parameters): Re-arrange as a union of two
	separate structs, one for in arguments, the other for out.
	(client_request_shm::shmid): Update for the new parameter layout.
	(client_request_shm::ds): Ditto.
	(client_request_shm::info): New method.
	* shm.cc (client_shmmgr::_shmat_cnt): New static field.
	(client_shmmgr::shmat): Add locking.  Add tracing.
	(client_shmmgr::shmctl): Update for ipcs(8) commands.  Add
	tracing.  Add more argument checking.
	(client_shmmgr::shmdt): Add locking.  Add tracing.  Update the new
	`_shmat_cnt' field.
	(client_shmmgr::shmget): Add tracing.
	(client_shmmgr::fixup_shms_after_fork): Add tracing.  Add
	consistency checking.
	(client_shmmgr::attach): Add more tracing.
	(client_shmmgr::new_segment): Update the new `_shmat_cnt' field.
	(client_request_shm::client_request_shm): Update for the new
	parameter layout.  Set the outgoing message length to the size of
	the `_parameters.in' struct, not of the whole in/out parameter
	union.

2002-07-02  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* shm.cc: Remove the use of a static client_shmmgr object.
	(client_shmmgr::_instance): New static variable.
	(client_shmmgr::instance): Allocate a new shmmgr on the heap,
	rather than using a local static object.

2002-07-01  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport.cc (create_server_transport): Fix
	cut-and-paste error.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::handle_request): Don't
	bother with the client request activity marker when compiled with
	debugging output.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_pipes.cc
	(MAX_WAIT_NAMED_PIPE_RETRY): New constant.
	(WAIT_NAMED_PIPE_TIMEOUT): Ditto.
	(transport_layer_pipes::close): The `pipe' field is now either
	NULL or a valid handle, and it should never have the value
	`INVALID_HANDLE_VALUE'.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.
	(transport_layer_pipes::connect): Ditto.  New, but still bogus,
	retry logic.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::server_shmmgr): All fields have
	to be initialized now that the singleton is no longer static.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc (server_shmmgr::_instance): New static field.
	(server_shmmgr::_instance_once): Ditto.
	(server_shmmgr::initialise_instance): New static method.
	(server_shmmgr::instance): Use a pthread_once_t rather than
	relying on a local static variable.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h: Remove all uses of the C++ new and delete operators
	throughout cygserver until they are fully thread-safe.
	(safe_new0): New macro to replace the C++ new operator.
	(safe_new): Ditto.
	(safe_delete): New macro to replace the C++ delete operator.
	* cygserver_client.cc (client_request::handle_request): Replace
	all uses of the C++ new and delete operators with the new macros
	from "woutsup.h".
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::new_segment): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* cygserver_transport.cc (create_server_transport): Ditto.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::accept): Ditto.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::accept): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.
	(threaded_queue::stop): Replace sleep(3) with win32 Sleep.
	* cygserver.cc (~server_request): Replace all uses of the C++ new
	and delete operators with the new macros from "woutsup.h".
	(server_submission_loop::request_loop): Ditto.
	(main): Ditto.  Replace sleep(3) with win32 Sleep.  Replace
	iostreams with FILEs.
	(print_usage): Replace iostreams with FILEs.
	(print_version): Ditto.

2002-06-30  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_transport_sockets.cc
	(transport_layer_sockets::accept): Rename local variable
	`accept_fd' to avoid shadowing the `fd' field.

2002-06-29  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygwin_ipc.h: Moved (back) to "include/sys/ipc.h".
	* cygwin_shm.h: Moved (back) to "include/sys/shm.h".
	* include/sys/ipc.h: New file.
	* include/sys/shm.h: New file.
	* cygserver_shm.h: Update for new header file locations.
	* ipc.cc: Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::make_request): Comment out
	a verbose tracing statement.
	* cygserver_process.cc (process_cache::sync_wait_array): Fix
	broken assert.
	* include/cygwin/cygserver.h (class client_request): Remove excess
	use of `class' qualifier in declarations.
	(class client_request_get_version): Ditto.
	(class client_request_shutdown): Ditto.
	(class client_request_attach_tty): Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_ipc.h: New file.
	* cygserver_shm.h: Re-written from scratch.
	* cygserver_shm.cc: Ditto.
	* shm.cc: Ditto.

2002-06-28  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* threaded_queue.h (class queue_request): Re-write.
	(threaded_queue_thread_function): Remove.
	(class queue_process_param): Remove.
	(class threaded_queue): Re-write.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	(TInterlockedExchangePointer): New templated function.
	(TInterlockedCompareExchangePointer): Ditto.
	* threaded_queue.cc (worker_function): Remove.
	(class threaded_queue): Re-write.
	(class queue_process_param): Remove.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	* include/cygwin/cygserver_process.h (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver_process.cc (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver.cc (request_count): Remove unused variable.
	(class server_request): Move methods inline.
	(class server_process_param): Remove.
	(class server_request_queue): Remove.
	(request_queue): Move into `main ()' and change type to
	`threaded_queue'.
	(request_loop): Remove.
	(class server_submission_loop): New version of the old
	`server_process_param' class.
	(shutdown_server): New variable.
	(client_request_shutdown::serve): Set `shutdown_server' to trigger
	shutdown.
	(handle_signal): Ditto.
	(main): Install signal handler for SIGINT rather than SIGQUIT.
	Use new interfaces for the `request_queue' and the `cache'.
	Create a `server_submission_loop' and add to the `request_queue'.
	Add check for the `shutdown_server' variable to the main loop.
	* cygserver_shm.cc (client_request_shm::serve): Release the
	process object after use.

2002-06-27  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client.cc (client_request::handle_request): Correct
	tracing statement.
	* cygserver_transport_pipes.cc: Remove local definition of
	FILE_FLAG_FIRST_PIPE_INSTANCE constant.
	* cygwin_ipc.h: Update copyright notice.
	* cygwin_shm.h: Ditto.
	* woutsup.h: Add definition of _WIN32_WINNT.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_client (client_request::make_request): Replace my
	inappropriate use of set_errno () with error_code () throughout.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h: Add forward declarations of class
	transport_layer_base and class process_cache to reduce
	dependencies between header files.
	* include/cygwin/cygserver_process.h: Add include of
	"threaded_queue.h".
	* cygserver.cc: Remove unnecessary cygserver header files.
	* cygserver_client.cc: Ditto.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_shm.h: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* dcrt0.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.

2002-06-24  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.h: Replace <sys/shm.h> with "cygwin_shm.h" after
	merge from HEAD.
	* cygwin_ipc.h: Update with changes to include/sys/ipc.h lost in
	merge from HEAD.
	* cygwin_shm.h: Ditto.

2002-06-21  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc: The tests for a duplicate server instance are now
	the responsibility of the transport layer.
	(request_loop): Use new `recoverable' flag in call to
	`cygserver_transport::accept ()' and shutdown on an unrecoverable
	error.
	(main): Never call `cygserver_init ()'.  Fake `cygserver_running'
	just for sending a shutdown request.
	* cygserver_client.cc (client_request::send): Comment out
	message-size tracing statements as verbose.
	(client_request::handle): Ditto.
	(client_request_get_version::check_version): #ifdef as DLL-only.
	(check_cygserver_available): Ditto.
	(cygserver_init): Ditto.
	* include/cygwin/cygserver.h
	(client_request_get_version::check_version): #ifdef as DLL-only.
	(check_cygserver_available): Ditto.
	(cygserver_init): Ditto.
	* include/cygwin/cygserver_transport.h
	(transport_layer_base::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_base::revert_to_self): Ditto.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.  Add a `recoverable' out
	flag for error handling.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	(transport_layer_pipes): Change type of the `pipe_name' field.
	Remove the `inited' field, as unnecessary.  Add new
	`is_accepted_endpoint' field.
	* include/cygwin/cygserver_transport.cc
	(transport_layer_base::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_base::revert_to_self): Ditto.
	* include/cygwin/cygserver_transport_sockets.cc
	(transport_layer_sockets::listen): #ifdef as cygserver-only.
	(transport_layer_sockets::accept): #ifdef as cygserver-only.
	Analyse any errno from `accept ()' and set `recoverable' as
	appropriate.
	* cygserver_transport_pipes.cc: Add local #define of
	`FILE_FLAG_FIRST_PIPE_INSTANCE'.
	(pipe_instance_lock_once): New variable.
	(pipe_instance_lock): Ditto.
	(pipe_instance): Ditto.
	(initialise_pipe_instance_lock): New function.
	(transport_layer_pipes::transport_layer_pipes): Change
	initialization of `pipe_name'.  Initialize `is_accepted_endpoint'
	as appropriate.  Remove use of `inited'.
	(transport_layer_pipes::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_pipes::revert_to_self): Ditto.
	(transport_layer_pipes::listen): Ditto.
	(transport_layer_pipes::accept): Ditto.  Keep track of how often
	many named pipes have been created, in the `pipe_instance'
	variable, and pass the `FILE_FLAG_FIRST_PIPE_INSTANCE' flag on the
	open of the first instance.  Analyse the error code from
	`CreateNamedPipe ()' and set the `recoverable' flag as
	appropriate.
	(transport_layer_pipes::close): Update the `pipe_instance' count.

2002-06-18  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h (cygserver_running): Add declaration.
	(api_fatal): Eliminate.
	* include/cygwin/cygserver.h
	(client_request_get_version::check_version): Change return type to
	bool.
	(check_cygserver_available): New function.
	(cygserver_init): Add check_version_too argument.
	* cygserver_client.cc (allow_daemon): Make a bool.
	(client_request_get_version::make_request): See errno on error.
	Remove special case for CYGSERVER_REQUEST_GET_VERSION; this is now
	handled in cygserver_init().
	(client_request_get_version::check_version): Use syscall_printf()
	instead of api_fatal(). Return true if cygserver version is
	compatible.
	(check_cygserver_available): New function; code moved here from
	cygserver_init().
	(cygserver_init): Move some code into check_cygserver_available().
	* cygserver.cc (__set_errno): Copy from debug.cc so that
	set_errno() can be used when __OUTSIDE_CYGWIN__.
	(main): Call cygserver_init() to set up cygserver_running and add
	checks against this to (try and) prevent multiple copies of
	cygserver running simultaneously.  Remember to delete all
	transport connections so that (one day) the transport classes can
	tidy up on cygserver shutdown.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (main): Adjust tracing output for a cleaner display
	when compiled without --enable-debugging.
	* threaded_queue.cc (threaded_queue::cleanup): Ditto.
	(queue_process_param::stop): Ditto.
	* include/cygwin/cygserver.h
	(client_request::make_request): Make non-virtual.
	(client_request::send): Make virtual and protected, not private.
	(client_request_attach_tty::send): New virtual method.
	* cygserver_client.cc: Use the `msglen()' accessor rather than
	`_header.msglen' throughout.
	(client_request_attach_tty::send): New method.
	(client_request::make_request): Remove the explicit close of
	`transport' as it is closed on deletion.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h: Change the client_request classes to
	give greater encapsulation and to allow variable length requests
	and replies.
	(enum cygserver_request_code): Now client_request::request_code_t.
	(class request_header): Now client_request::header_t.  Make a
	union of the request_code and the error_code.  The `cb' field,
	which was the buffer length, is now the `size_t msglen' field.
	(struct request_get_version): Now
	client_request_get_version::request_get_version.
	(struct request_shutdown): Remove unused type.
	(struct request_attach_tty): Now
	client_request_attach_tty::request_attach_tty.
	(client_request::_buf): Make field const.
	(client_request::_buflen): New const private field.
	(client_request::request_code): New accessor.
	(client_request::error_code): Ditto.
	(client_request::msglen): Ditto.
	(client_request::handle_request): New static method.
	(client_request::make_request): New virtual method.
	(client_request::handle): New method.
	(client_request::send): Make private.
	(client_request_get_version::check_version): New method.
	(client_request_get_version::serve): Make private.
	(client_request_get_version::version): Ditto.
	(client_request_shutdown::serve): Ditto.
	(client_request_attach_tty::req): Ditto.
	(client_request_attach_tty::serve): Ditto.
	(client_request_attach_tty::from_master): Make method const.
	(client_request_attach_tty::from_master): Ditto.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Track
	changes to the client_request classes.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	(client_request_get_version::check_version): New method to
	encapsulate code from cygserver_init().
	(client_request_shutdown::client_request_shutdown): Move into
	"cygserver.cc".
	(client_request::send): Track changes to the client_request
	classes.  Add more error checking.
	(client_request::handle_request): New static method containing the
	first half of the old server_request::process() code.
	(client_request::make_request): New method to replace the old
	cygserver_request() function.
	(client_request::handle): New method containing the second half of
	the old server_request::process() code.
	(cygserver_init): Track changes to the client_request classes.  In
	particular, some code moved into the
	client_request_get_version::check_version() method.
	* cygserver.cc (client_request_attach_tty::serve): Track changes
	to the client_request classes.  In particular, only return a reply
	body if some handles are successfully duplicated for the client.
	And remove goto's.
	(client_request_get_version::serve): Track changes to the
	client_request classes.
	(client_request_shutdown::serve): Ditto.
	(class client_request_invalid): Dead, and so young too.
	(server_request::request_buffer): Remove unnecessary field.
	(client_request_shutdown::client_request_shutdown): Moved here
	from "cygserver_client.cc".
	(server_request::process): Implementation moved into the new
	client_request::handle_request() and client_request::handle()
	methods.
	* cygserver_shm.h (class client_request_shm): Put client- and
	server-specific interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__
	guards.
	(client_request_shm::serve): Make private.
	* cygserver_shm.cc
	(client_request_shm::client_request_shm): Track changes to the
	client_request classes.
	(client_request_shm::serve): Ditto
	* shm.cc (client_request_shm::client_request_shm): Ditto.  Use
	alloc_sd() rather than set_security_attribute() to get access to
	the SECURITY_DESCRIPTOR length, so that we can use it to set the
	request body length.
	(shmat): Track changes to the client_request classes. In
	particular, allocate client_request objects on the stack rather
	than on the heap, and use the client_request::make_request()
	method rather than the old cygserver_request() function.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::cygserver_attach_tty): Ditto.

2002-06-17  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(cygserver_transport::read): Change buffer type to void *.
	(cygserver_transport::write): Ditto.
	* include/cygwin/cygserver_transport_sockets.h
	(cygserver_transport_sockets::read): Ditto.
	(cygserver_transport_sockets::write): Ditto.
	* include/cygwin/cygserver_transport_pipes.h
	(cygserver_transport_pipes::read): Ditto.
	(cygserver_transport_pipes::write): Ditto.
	* cygserver_transport_sockets.cc
	(cygserver_transport_sockets::read): Ditto.
	(cygserver_transport_sockets::write): Ditto.
	* cygserver_transport_pipes.cc
	(cygserver_transport_pipes::read): Ditto. Set errno on error, to
	match behaviour of cygserver_transport_sockets class.
	(cygserver_transport_pipes::write): Ditto.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (version): New static variable.
	(server_request_queue::add_connection): Remove my gratuitous use
	of studly caps.
	(setup_privileges): Declare static.
	(handle_signal): Ditto.
	(longopts): Make a local variable of main().
	(opts): Ditto.
	(print_usage): New function.
	(print_version): Ditto (tip of the hat to Joshua Daniel Franklin
	for inspiration here).
	(main): More argument checking.  Add --help and --version options.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h (client_request::serve): Make pure
	virtual.
	* cygserver.cc (client_request::serve): Remove definition of pure
	virtual method.
	(class client_request_invalid): New class.
	(server_request::process): Use new client_request_invalid
	class. And remove goto's.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (class server_request): Add virtual destructor.
	(server_request_queue::addConnection): New method to replace bad
	virtual add() method.
	(request_loop): Replace call to queue->add() with call to
	queue->addConnection().
	(server_request::server_request): Use field initialization.
	(server_request::~server_request): New virtual destructor.
	(server_request::process): Remove close and delete of
	transport_layer_base object. It is deleted by the server_request's
	own destructor and closed by its own destructor.
	* include/cygwin/cygserver.h
	(client_request::operator request_header): Remove unused method.
	* cygserver_client.cc: Ditto.
	* include/cygwin/cygserver_process.h
	(class cleanup_routine): Add virtual destructor.
	(cleanup_routine::cleanup): Make pure virtual.
	(class process_cache): Make destructor non-virtual.
	(process_cache::add): Ditto.
	* cygserver_process.cc
	(cleanup_routine::~cleanup_routine): New virtual destructor.
	* include/cygwin/cygserver_transport.h
	(class transport_layer_base): Add virtual destructor.
	* cygserver_transport.cc
	(transport_layer_base::~transport_layer_base): New virtual
	destructor.
	* include/cygwin/cygserver_transport_pipes.h
	(class transport_layer_pipes): Add virtual destructor.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::~transport_layer_pipes): New virtual
	destructor.
	(transport_layer_pipes::close): Null out handle after closing.
	* include/cygwin/cygserver_transport_sockets.h
	(class transport_layer_sockets): Add virtual destructor.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::~transport_layer_sockets): New virtual
	destructor.
	(transport_layer_sockets::close): Null out fd after closing.
	* threaded_queue.h (class queue_request): Add virtual destructor.
	(queue_request::process): Make pure virtual.
	* threaded_queue.cc (~queue_request): New virtual destructor.
	(queue_request::process): Remove definition of pure virtual
	method.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver.h (client_request::send): Make
	non-virtual.
	(class client_request_attach_tty): Put client- and server-specific
	interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__ guards.
	* cygserver_client.cc: Ditto.
	(cygserver_init): Fix error handling.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc: Throughout the code, check and correct level of
	the XXX_printf() functions used. Comment out several of the
	debug_printf() calls with "// verbose:".  Reformat and correct
	typos of some of the XXX_printf() formats.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* shm.cc (hi_ulong): New function to allow printing of a 64-bit
	key with current small_printf implementation.
	(lo_ulong): Ditto.
	(client_request_shm::client_request_shm): Use hi_ulong() and
	lo_ulong() in call to debug_printf().

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver_shm.cc: Remove #define __INSIDE_CYGWIN__ from around
	<sys/shm.h> as it no longer contains any internal code.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/sys/ipc.h (IPC_PRIVATE): Add cast to key_t.
	(IPC_INFO): New flag for ipcs(8).
	(IPC_RMID IPC_SET IPC_STAT): Renumber.
	* include/sys/shm.h (SHM_RDONLY SHM_RND): Renumber with distinct
	values [sic].
	(class _shmattach): Internal type moved to "cygserver_shm.h".
	(class shmnode): Ditto.
	(class shmid_ds): Ditto.
	(struct shmid_ds): Add spare fields.
	(struct shminfo): New type for IPC_INFO interface.
	* cygserver_shm.h: Remove obsolete #if 0 ... #endif block.
	(class shm_cleanup): Remove unused class.
	(struct _shmattach): Internal type moved from <sys/shm.h>.
	(struct shmnode): Ditto.
	(struct int_shmid_ds): Ditto. Renamed to avoid name clash with
	public interface struct shmid_ds. Use the shmid_bs structure as a
	field.
	* cygserver_shm.cc: Remove obsolete #if 0 ... #endif block.
	(client_request_shm::serve): Update for redefinition of
	int_shmid_ds structure.
	* shm.cc (build_inprocess_shmds): Ditto.
	(fixup_shms_after_fork): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove obsolete #if 0 ... #endif code.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* include/cygwin/cygserver_transport.h
	(transport_layer_base::transport_layer_base): Remove since it is
	now redundant.
	(transport_layer_base::listen): Make a pure virtual method.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.
	* cygserver_transport.cc
	(transport_layer_base::transport_layer_base): Remove since it is
	now redundant.
	(transport_layer_base::listen): Remove since it is now a pure
	virtual method.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.

2002-06-16  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* cygserver.cc (check_and_dup_handle): Only use security code if
	running on NT, i.e. if wincap.has_security().
	(client_request_attach_tty::serve): Add check for has_security().
	* cygserver_process.cc (process_cache::process): Use DWORD winpid
	throughout to avoid win32 vs. cygwin pid confusion.
	(process::process): Ditto.
	* cygserver_shm.cc (client_request_shm::serve): Only use security
	code if running on NT, i.e. if wincap.has_security().
	* cygserver_shm.h (client_request_shm::parameters.in): Replace the
	ambiguous pid field with cygpid and winpid fields.
	(client_request_shm::client_request_shm): Reduce to only two
	client-side constructors: one for SHM_CREATE, another for all the
	other requests.
	* shm.cc (client_request_shm::client_request_shm):
	Ditto. Initialize cygpid and winpid fields here. On NT initialize
	sd_buf here using set_security_attribute() to make use of the euid
	and egid.
	(shmat): Use new client_request_shm constructor.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove security code, now performed in the
	relevant client_request_shm constructor.
	* include/cygwin/cygserver_process.h: (class cleanup_routine):
	Change winpid type to DWORD.
	(class process): Ditto.

2002-06-15  Conrad Scott  <conrad.scott@@dsl.pipex.com>

	* woutsup.h: New file.
	* cygserver.cc: Use "woutsup.h" and new XXX_printf macros.
	(getfunc): New function, copied verbatim from "strace.cc".
	(__cygserver__printf): New function.
	* cygserver_client.cc: Use "woutsup.h" and new XXX_printf macros.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* threaded_queue.cc: Ditto.
	* shm.cc: Remove trailing \n from XXX_printf format strings.
	* Makefile.in: Remove special __OUTSIDE_CYGWIN__ case for
	cygserver_shm.cc.
@
text
@a18 1
#include <errno.h>
d34 1
a34 1
static const char version[] = "$Revision$";
@


1.5.16.1
log
@merge from trunk
@
text
@d19 1
d35 1
a35 1
static const char version[] = "$Revision: 1.6 $";
@


1.5.16.2
log
@merge from trunk
@
text
@d34 1
a34 1
static const char version[] = "$Revision: 1.5.16.1 $";
@


1.4
log
@* cygserver.cc: Include stdlib.h for exit declaration.
* threaded_queue.cc: Ditto.
@
text
@d7 1
a7 1
   This file is part of Cygwin.
d9 3
a11 3
   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */
d13 6
d20 2
d23 2
d26 2
a27 7
#include <windows.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <signal.h>
#include <stdlib.h>
#include "wincap.h"
d30 61
a90 1
#include "getopt.h"
d92 27
a118 7
#include "cygwin/cygserver_transport.h"
#include "cygwin/cygserver_transport_pipes.h"
#include "cygwin/cygserver_transport_sockets.h"
#include "threaded_queue.h"
#include "cygwin/cygserver_process.h"
#include "cygwin/cygserver.h"
#include "cygserver_shm.h"
d120 1
a120 3
/* for quieter operation, set to 0 */
#define DEBUG 0
#define debug_printf if (DEBUG) printf
a122 1
static class transport_layer_base *transport;
d124 1
a124 3
DWORD request_count = 0;

BOOL
d131 1
a131 1
  rc = OpenProcessToken (GetCurrentProcess() , TOKEN_ALL_ACCESS , &hToken) ;
d134 1
a134 1
      printf ("error opening process token (%lu)\n", GetLastError ());
d141 1
a141 1
      printf ("error getting prigilege luid (%lu)\n", GetLastError ());
d150 2
a151 1
      printf ("error adjusting prigilege level. (%lu)\n", GetLastError ());
d173 1
a173 1
		      HANDLE* to_handle_ptr, BOOL bInheritHandle = FALSE)
a176 6
  char sd_buf [1024];
  PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR) &sd_buf;
  DWORD bytes_needed;
  PRIVILEGE_SET ps;
  DWORD ps_len = sizeof (ps);
  BOOL status;
d180 11
d192 20
a211 18
  if (!DuplicateHandle (from_process, from_handle,
			GetCurrentProcess (), &local_handle,
			0, bInheritHandle,
			DUPLICATE_SAME_ACCESS))
    {
      printf ("error getting handle(%u) to server (%lu)\n", (unsigned int)from_handle, GetLastError ());
      goto out;
    }
} else
 local_handle = from_handle;

  if (!GetKernelObjectSecurity (local_handle,
				OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION	| DACL_SECURITY_INFORMATION,
				sd, sizeof (sd_buf), &bytes_needed))
    {
      printf ("error getting handle SD (%lu)\n", GetLastError ());
      goto out;
    }
d213 1
a213 1
  MapGenericMask (&access, &access_mapping);
d215 7
a221 6
  if (!AccessCheck (sd, from_process_token, access, &access_mapping,
		    &ps, &ps_len, &access, &status))
    {
      printf ("error checking access rights (%lu)\n", GetLastError ());
      goto out;
    }
d223 5
a227 4
  if (!status)
    {
      printf ("access to object denied\n");
      goto out;
d234 1
a234 1
      printf ("error getting handle to client (%lu)\n", GetLastError ());
d237 2
a238 1
  debug_printf ("Duplicated %p to %p\n", from_handle, *to_handle_ptr);
d242 1
a242 1
out:
d249 4
d254 2
a255 1
client_request::serve (transport_layer_base *conn, class process_cache *cache)
d257 1
a257 5
  printf ("*****************************************\n"
	  "A call to the base client_request class has occured\n"
	  "This indicates a mismatch in a virtual function definition somewhere\n");
  exit (1);
}
d259 1
a259 7
void
client_request_attach_tty::serve(transport_layer_base *conn, class process_cache *cache)
{
  HANDLE from_process_handle = NULL;
  HANDLE to_process_handle = NULL;
  HANDLE token_handle = NULL;
  DWORD rc;
d261 1
a261 1
  if (header.cb != sizeof (req))
d263 3
a265 1
      header.error_code = EINVAL;
d269 1
a269 9
  debug_printf ("pid %ld:(%p,%p) -> pid %ld\n", req.master_pid,
				req.from_master, req.to_master,
				req.pid);

  debug_printf ("opening process %ld\n", req.master_pid);
  from_process_handle = OpenProcess (PROCESS_DUP_HANDLE, FALSE, req.master_pid);
  debug_printf ("opening process %ld\n", req.pid);
  to_process_handle = OpenProcess (PROCESS_DUP_HANDLE, FALSE, req.pid);
  if (!from_process_handle || !to_process_handle)
d271 5
a275 3
      printf ("error opening process (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      goto out;
d278 5
a282 2
  debug_printf ("Impersonating client\n");
  conn->impersonate_client ();
d284 1
a284 5
  debug_printf ("about to open thread token\n");
  rc = OpenThreadToken (GetCurrentThread (),
			TOKEN_QUERY,
			TRUE,
			&token_handle);
d286 2
a287 2
  debug_printf ("opened thread token, rc=%lu\n", rc);
  conn->revert_to_self ();
d289 1
a289 1
  if (!rc)
d291 4
a294 3
      printf ("error opening thread token (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      goto out;
d297 6
a302 5
  if (check_and_dup_handle (from_process_handle, to_process_handle,
			    token_handle,
			    GENERIC_READ,
			    req.from_master,
			    &req.from_master, TRUE) != 0)
d304 5
a308 3
      printf ("error duplicating from_master handle (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      goto out;
d311 15
a325 1
  if (req.to_master)
d327 6
a332 10
      if (check_and_dup_handle (from_process_handle, to_process_handle,
				token_handle,
				GENERIC_WRITE,
				req.to_master,
				&req.to_master, TRUE) != 0)
	{
	  printf ("error duplicating to_master handle (%lu)\n", GetLastError ());
	  header.error_code = EACCES;
	  goto out;
	}
d335 1
a335 4
#if DEBUG
  printf ("%ld -> %ld(%p,%p)\n", req.master_pid, req.pid,
				req.from_master, req.to_master);
#endif
d337 2
a338 1
  header.error_code = 0;
d340 38
a377 7
out:
  if (from_process_handle)
    CloseHandle (from_process_handle);
  if (to_process_handle)
    CloseHandle (to_process_handle);
  if (token_handle)
    CloseHandle (token_handle);
d381 1
a381 1
client_request_get_version::serve(transport_layer_base *conn, class process_cache *cache)
d383 7
a389 6
  if (header.cb != sizeof (version))
    {
      header.error_code = EINVAL;
      return;
    }
  header.error_code = 0;
d398 18
a415 7
  public:
  server_request (transport_layer_base *newconn, class process_cache *newcache);
  virtual void process ();
  private:
    char request_buffer [MAX_REQUEST_SIZE];
    transport_layer_base *conn;
    class process_cache *cache;
d418 1
a418 1
class server_process_param : public queue_process_param
d420 15
a434 4
  public:
    transport_layer_base *transport;
    server_process_param () : queue_process_param (false) {};
};
d436 1
a436 6
class server_request_queue : public threaded_queue
{
  public:
    class process_cache *cache;
    void process_requests (transport_layer_base *transport);
    virtual void add (transport_layer_base *conn);
a437 1
class server_request_queue request_queue;
d439 8
a446 2
static DWORD WINAPI
request_loop (LPVOID LpParam)
d448 44
a491 15
  class server_process_param *params = (server_process_param *) LpParam;
  class server_request_queue *queue = (server_request_queue *) params->queue;
  class transport_layer_base * transport = params->transport;
  while (queue->active)
  {
    transport_layer_base * new_conn = transport->accept ();
    /* FIXME: this is a little ugly. What we really want is to wait on two objects:
     * one for the pipe/socket, and one for being told to shutdown. Otherwise
     * this will stay a problem (we won't actually shutdown until the request
     * _AFTER_ the shutdown request. And sending ourselves a request is ugly
     */
     if (new_conn && queue->active)
	 queue->add (new_conn);
  }
  return 0;
d494 2
a495 3
/* TODO: check we are not being asked to service a already serviced transport */
void
server_request_queue::process_requests (transport_layer_base *transport)
d497 1
a497 3
  class server_process_param *params = new server_process_param;
  params->transport = transport;
  threaded_queue::process_requests (params, request_loop);
d501 1
a501 1
client_request_shutdown::serve (transport_layer_base *conn, class process_cache *cache)
d503 5
d511 4
a514 2
  /* tell the main thread to shutdown */
  request_queue.active=false;
d517 4
a520 1
server_request::server_request (transport_layer_base *newconn, class process_cache *newcache)
d522 3
a524 2
  conn = newconn;
  cache = newcache;
d527 21
a547 2
void
server_request::process ()
d549 1
a549 4
  ssize_t bytes_read, bytes_written;
  struct request_header* req_ptr = (struct request_header*) &request_buffer;
  client_request *req = NULL;
  debug_printf ("about to read\n");
d551 1
a551 7
  bytes_read = conn->read (request_buffer, sizeof (struct request_header));
  if (bytes_read != sizeof (struct request_header))
    {
      printf ("error reading from connection (%lu)\n", GetLastError ());
      goto out;
    }
  debug_printf ("got header (%ld)\n", bytes_read);
d553 1
a553 1
  switch (req_ptr->req_id)
d555 1
a555 12
    case CYGSERVER_REQUEST_GET_VERSION:
      req = new client_request_get_version (); break;
    case CYGSERVER_REQUEST_ATTACH_TTY:
      req = new client_request_attach_tty (); break;
    case CYGSERVER_REQUEST_SHUTDOWN:
      req = new client_request_shutdown (); break;
    case CYGSERVER_REQUEST_SHM_GET:
     req = new client_request_shm (); break;
    default:
      req = new client_request (CYGSERVER_REQUEST_INVALID, 0);
      req->header.error_code = ENOSYS;
      debug_printf ("Bad client request - returning ENOSYS\n");
d557 1
a557 2

  if (req->header.cb != req_ptr->cb)
d559 1
a559 3
      debug_printf ("Mismatch in request buffer sizes\n");
      goto out;
    }
d561 1
a561 2
  if (req->header.cb)
    {
d563 2
a564 7
      bytes_read = conn->read (req->buffer, req->header.cb);
      if (bytes_read != req->header.cb)
	{
	  debug_printf ("error reading from connection (%lu)\n", GetLastError ());
	  goto out;
	}
      debug_printf ("got body (%ld)\n",bytes_read);
d567 14
a580 11
  /* this is not allowed to fail. We must return ENOSYS at a minimum to the client */
  req->serve (conn, cache);

  if ((bytes_written = conn->write ((char *)&req->header, sizeof (req->header)))
    != sizeof(req->header) || (req->header.cb &&
    (bytes_written = conn->write (req->buffer, req->header.cb)) != req->header.cb))
    {
      req->header.error_code = -1;
      printf ("error writing to connection (%lu)\n", GetLastError ());
      goto out;
    }
d582 4
a585 2
  debug_printf("Sent reply, size (%ld)\n",bytes_written);
  printf (".");
d587 1
a587 5
out:
  conn->close ();
  delete conn;
  if (req)
    delete (req);
d590 6
a595 2
void
server_request_queue::add (transport_layer_base *conn)
d597 21
a617 15
  /* safe to not "Try" because workers don't hog this, they wait on the event
   */
  /* every derived ::add must enter the section! */
  EnterCriticalSection (&queuelock);
  if (!running)
    {
      conn->close ();
      delete conn;
      LeaveCriticalSection (&queuelock);
      return;
    }
  queue_request * listrequest = new server_request (conn, cache);
  threaded_queue::add (listrequest);
  LeaveCriticalSection (&queuelock);
}
d619 3
a621 10
void
handle_signal (int signal)
{
  /* any signal makes us die :} */
  /* FIXME: link upwards, and then this becomes a trivial method call to
   * only shutdown _this queue_
   */
  /* tell the main thread to shutdown */
  request_queue.active=false;
}
d623 1
a623 4
struct option longopts[] = {
  {"shutdown", no_argument, NULL, 's'},
  {0, no_argument, NULL, 0}
};
d625 13
a637 1
char opts[] = "s";
d639 14
a652 5
int
main (int argc, char **argv)
{
  int shutdown=0;
  char i;
a653 3
  while ((i = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (i)
      {
d655 1
a655 1
	shutdown = 1;
d657 8
a664 3
      default:
	break;
       /*NOTREACHED*/
d667 5
a671 4
  wincap.init();
  if (wincap.has_security ())
    setup_privileges ();
  transport = create_server_transport ();
d675 8
a682 1
      if (!transport->connect())
d684 2
a685 1
	  printf ("couldn't establish connection with server\n");
d688 28
a715 24
      client_request_shutdown *request =
	new client_request_shutdown ();
      request->send (transport);
      transport->close();
      delete transport;
      delete request;
      exit(0);
    }

  char version[200];
  /* Cygwin dll release */
  snprintf (version, 200, "%d.%d.%d(%d.%d/%d/%d)-(%d.%d.%d.%d) %s",
		 cygwin_version.dll_major / 1000,
		 cygwin_version.dll_major % 1000,
		 cygwin_version.dll_minor,
		 cygwin_version.api_major,
		 cygwin_version.api_minor,
		 cygwin_version.shared_data,
		 CYGWIN_SERVER_VERSION_MAJOR,
		 CYGWIN_SERVER_VERSION_API,
		 CYGWIN_SERVER_VERSION_MINOR,
		 CYGWIN_SERVER_VERSION_PATCH,
		 cygwin_version.mount_registry,
		 cygwin_version.dll_build_date);
d717 19
a735 2
  printf ("daemon version %s starting up", version);
  if (signal (SIGQUIT, handle_signal) == SIG_ERR)
a736 1
      printf ("\ncould not install signal handler (%d)- aborting startup\n", errno);
d740 2
a741 1
  transport->listen ();
d743 2
a744 4
  class process_cache cache (2);
  request_queue.initial_workers = 10;
  request_queue.cache = &cache;
  request_queue.create_workers ();
d746 11
a756 13
  request_queue.process_requests (transport);
  printf (".");
  cache.create_workers ();
  printf (".");
  cache.process_requests ();
  printf (".complete\n");
  /* TODO: wait on multiple objects - the thread handle for each request loop +
   * all the process handles. This should be done by querying the request_queue and
   * the process cache for all their handles, and then waiting for (say) 30 seconds.
   * after that we recreate the list of handles to wait on, and wait again.
   * the point of all this abstraction is that we can trivially server both sockets
   * and pipes simply by making a new transport, and then calling
   * request_queue.process_requests (transport2);
d760 6
a765 7
   */
  while (1 && request_queue.active)
    {
      sleep (1);
    }
  printf ("\nShutdown request recieved - new requests will be denied\n");
  request_queue.cleanup ();
d767 1
a767 1
  transport->close ();
d769 1
a769 1
  cache.cleanup ();
d772 2
@


1.3
log
@whitespace cleanup, update copyright
@
text
@d21 1
@


1.2
log
@2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* Merged cygwin_daemon into head minus the new shm and ipc exports.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* fhandler_tty.cc (fhandler_tty_slave::open): More debugging.
	(fhandler_tty_slave::read): Fix printf type for the handle.
	* tty.cc (tty::common_init): Add a FIXME for security.

2002-01-29  Robert Collins  <rbtcollins@@hotmail.com>

	* Makefile.in (OBJS): Remove duplicate localtime.o.

2002-01-17  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (check_and_dup_handle): Consolidate the two variants for
	simplicity.
	Add Some basic debug output.
	(client_request_attach_tty::serve): Use the new debug_printf for clarity.
	Mark the duplicated handles as inheritable - fixup_after_fork() doesn't reopen
	tty's.

2002-01-16  Robert Collins  <rbtcollins@@hotmail.com>

	* cygserver.cc (transport): Correct scope.
	(client_request_attach_tty::serve): Add more debug information.
	Fix erroneous use of transport instead of conn.
	* cygserver_transport_pipes.cc (transport_layer_pipes::close): More debug.
	(transport_layer_pipes::read): Ditto.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::impersonate_client): Ditto.

Mon Oct  8  7:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (server_request::process): Rename client_request_shm_get to
	client_request_shm.
	* cygserver_process.cc (process_cache::add): Rename to add_task.
	Use process_cleanup instead of process_request.
	(process_cache::remove_process): New method.
	(process::process): Initialize new members.
	(process::~process): New member.
	(process::cleanup): New method.
	(process::add_cleanup_routine): New method.
	(process_request::process): Rename to process_cleanup.
	Call the process object's cleanup method and then delete it.
	(process_process_param::request_loop): Remove the signalling process.
	* cygserver_shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm_get::serve): Handle attach request counting.
	* cygserver_shm.h: Globally rename client_request_shm_get to client_request_shm.
	(class shm_cleanup): New class.
	* shm.cc: Globally rename client_request_shm_get to client_request_shm.
	(client_request_shm::client_request_shm): New constructor for attach requests.
	(shmat): Use it.
	* include/cygwin/cygserver_process.h (class process_request): Rename to
	process_cleanup.
	(class cleanup_routine): New class.
	(class process): New members and methods to allow calling back when the process
	terminates.

Thu Oct  4 14:12:00 2001  Robert Collins <rbtcollins@@hotmail.com>
	* cygserver.cc (request_loop): Make static.
	(main): Use new cache constructor syntax.
	Start cache worker threads.
	Cleanup the cache at shutdown.
	* cygserver_process.cc: Run indent.
	(process_cache::process_cache): Add a trigger to use when adding a process.
	(process_cache::process): Move process_entry to process.
	Insert at the end of the list.
	Trigger the request loop when new process's inserted.
	(process_cache::process_requests): Do it.
	(process_cache::add): New method.
	(process_cache::handle_snapshot): New method.
	(process::process): Merge in the process_entry fields.
	(process::handle): Make a stub function.
	(process::exit_code): New method.
	(process_request::process): New method.
	(process_process_param::request_loop): New method.
	* cygserver_shm.cc: New header dependency - threaded_queue.h.
	* threaded_queue.cc (threaded_queue::cleanup): Clearer messages.
	(queue_process_param::stop): Short spinlock on interruptible threads.
	* threaded_queue.h (class threaded_queue): New constructor.
	* include/cygwin/cygserver_process.h (process_request): New class.
	(process_entry): Remove.
	(process): Merge in process_entry.
	(process_cache): Inherit from threaded_queue.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (class server_process_param): Use new constructor syntax.
	* cygserver_process.cc (process_cache::~process_cache): New function.
	* threaded_queue.cc: Define condition debug_printf.
	Run indent.
	(threaded_queue::cleanup): Move queue_process_param guts to a method.
	(threaded_queue::process_requests): Ditto.
	(queue_process_param::queue_process_param): New method.
	(queue_process_param::~queue_process_param): Ditto.
	(queue_process_param::start): Ditto.
	(queue_process_param::stop): Ditto.
	* threaded_queue.h (class queue_process_param): Add support for
	interruptible request loops.
	* cygwin/include/cygwin/cygserver_process.h (class process_cache): Add
	destructor.

Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver_client.cc: New flag allow_daemon to disable the daemon completely.
	(cygserver_request): Check it.
	(cygserver_init): Ditto.
	* environ.cc (parse_thing): Add (no)daemon option.

Tue Oct  2 23:00:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* shm.cc: Update to handle include changes from HEAD.

Tue Oct  2 16:06:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Remove cygserver_shm.o from cygwin1.dll.
	Rename cygserver_shm_outside.o to cygserver_shm.o.
	* cygserver.cc (server_request::process): Use the new client_request
	constructor.
	* cygserver_client.cc: Remove the #ifdef's stubs for the server method
	within cygwin.
	(client_request_attach_tty::client_request_attach_tty): Use the new
	client_request constructor.
	(client_request_shutdown::client_request_shutdown): Ditto.
	(client_request::client_request): Ditto.
	* cygserver_shm.cc (client_request_shm_get::serve): Remove the
	#ifdef'd stub for in-cygwin builds.
	(client_request_shm_get::client_request_shm_get): Use the new
	client_request constructor, and remove the in-cygwin variants.
	* cygserver_shm.h (class client_request_shm_get): #ifndef test the
	serve method - it's only used in cygserver.
	* shm.cc (client_request_shm_get::client_request_shm_get): New function.
	* include/cygwin/cygserver.h (request_header): New constructor.
	(class client_request): Use it.
	New constructor accepting the header size.
	#ifndef test the server method - it's only used within cygserver.
	(client_request_get_version): #ifdef test the server method.
	(client_request_shutdown): Ditto.
	(client_request_attach_tty): Ditto.

Tue Oct  2  9:57:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: add threaded_queue.o to cygserver.exe.
	* cygserver.cc: Include threaded_queue.h
	(class server_request): Inherit from queue_request.
	(class server_process_param): Inherit from queue_process_param.
	(class server_request_queue): Inherit from threaded_queue.
	(request_loop): Adjust for new types.
	(server_request_queue::process_requests): Remove guts to
	threaded_queue::process_requests.
	(server_request::server_request): Adjust for new types.
	(worker_function): Delete.
	(server_request_queue::create_workers): Delete.
	(server_request_queue::cleanup): Delete.
	(server_request_queue::add): Move guts to threaded_queue::add.
	* threaded_queue.cc: New file.
	* threaded_queue.h: New file.

Mon Oct  1 12:38:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* cygserver.cc (client_request::serve): New function.
	* cygserver_process.cc: Inlude <pthread.h> for pthread_once.
	(process_cache::process_cache): Initialise a crtiical section for write access.
	(process_cache::process): Use the critical section. Also add missing entries to
	the cache.
	(do_process_init): New function to initalise class process static variables.
	(process::process): Ensure that the process access critical section is
	initialised.
	(process::handle): Close the handle of old process's when they have terminated
	and we are returning the handle for a process with the same pid.
	* cygserver_shm.cc: Run indent.
	Include cygserver_process.h to allow process cache functionality.
	(client_request_shm_get::serve): New parameter for process cache support.
	Use the process cache, not OpenProcess to get a handle to the originating process.
	Fix a handle leak with token_handle.
	* cygserver_shm.h (class client_request_shm_get): Update ::serve for process
	cache support.
	* cygserver_transport_pipes.cc: Redefine debug_printf to be conditional on DEBUG.
	* include/cygwin/cygserver.h: Do not implement client_request::serve in the
	header.
	* include/cygwin/cygserver_process.h (class process_cache): Add a write access
	critical section to prevent races when requests from a  multithreaded
	application arrive.

Sun Sep 30 23:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_process.o to cygserver.exe.
	* cygserver.cc: Include signal.h and cygwin_version.h.
	Define debug_printf as a macro.
	Define DEBUG to a value.
	(client_request_attach_tty::serve): Add beginning of process cache support.
	Change from #ifdef DEBUG to work with new DEBUG style.
	(client_request_get_version::serve): Add beginning of process cache support.
	(class server_request): New prototype for support of process cache.
	(class queue_process_param): New class to allow request loop threading.
	(class server_request_queue): Add beginning of process cache support.
	Allow request loop threading.
	(request_loop): Thread function for request loops.
	(server_request_queue::process_requests): Initiator for threaded request loops.
	(client_request_shutdown::serve): Add beginning of process cache support.
	(server_request::server_request): Ditto.
	(server_request::process): Use debug_printf. Add beginning of process cache
	support.
	(server_request_queue::cleanup): Kill off any request loop threads.
	(server_request_queue::add): Add beginning of process cache support.
	(handle_signal): Trigger a shutdown.
	(main): Print out some useful info at startup - version, date time.
	Add process cache support.
	Spawn a separate thread for the transport request loop, thus allowing concurrent
	support for multiple transports.
	* cygserver_client.cc (client_request_get_version::serve): Add process cache
	support.
	(client_request_attach_tty::serve): Add process cache support.
	(client_request_shutdown::serve): Add process cache support.
	* cygsserver_process.cc: New file with the process cache support.
	* cygserver_shm.cc: Redefine debug_printf to allow conditional output.
	* cygwin.din: Export shmdt().
	* shm.cc: Run indent.
	Update FIXME's.
	(shmdt): New function.
	* include/cygwin/cygserver.h (class client_request): Add process cache support.
	(class client_request_get_version): Ditto.
	(class client_request_shutdown): Ditto.
	(class client_request_attach_tty): Ditto.
	* include/cygwin/cygserver_process.h: New header for process cache support.

Sun Sep 30  8:52:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* include/cygwin/cygserver_transport.h: Add copyright header.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.

Sat Sep 29 20:40:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* Makefile.in: Add cygserver_transport_sockets.o to DLL_OFILES.
	Add cygserver_transport_sockets_outside.o to cygserver.exe.
	* cygserver.cc: Include new include files.
	* cygserver_client.cc: Ditto.
	* cygserver_shm.h: No need to include <sys/socket.h> now.
	* cygerver_transport.cc: Include new include files.
	(transport_layer_base::transport_layer_base): Strip back to a stub.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.
	(transport_layer_base::close): Ditto.
	(transport_layer_base::read): Ditto.
	(transport_layer_base::write): Ditto.
	(transport_layer_base::connect): Ditto.
	* cygserver_transport_pipes.cc: Include new header
	"cygwin/cygserver_transport_pipes.h".
	* cygserver_transport_sockets.cc: New file.
	* dcrt0.cc: No need to include <sys/socket.h> now.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.
	* include/cygwin/cygserver_transport.h: Strip the base class to a stub.
	Remove the cygserver_transport_pipes class.
	* include/cygwin/cygserver_transport_pipes.h: New file.
	* include/cygwin/cygserver_transport_sockets.h: New file.

Tue Sep 25 16:22:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* autoload.cc: Add dynamic load statement for 'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when obtaining
	handles from the parent process. On failure or 9x use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
	* cygserver.cc: New file.
	* cygserver_client.cc: New file.
	* cygserver_shm.cc: New file.
	* cygserver_shm.h: New file.
	* cygserver_transport.cc: New file.
	* cygserver_transport_pipes.cc: New file.
	* ipc.cc: New file.
	* shm.cc: New file.
	* include/cygwin/cygserver.h: New file.
	* include/cygwin/cygserver_transport.h: New file.
	* include/sys/ipc.h: New file.
	* include/sys/shm.h: New file.

2002-02-28  Robert Collins  <rbtcollins@@hotmail.com>

	* thread.cc (semaphore::TryWait): Set errno as required by posix 1003.1.
	(__sem_wait): Ditto.
	(__sem_trywait): Ditto.
@
text
@d3 1
a3 1
   Copyright 2001 Red Hat Inc.
d50 2
a51 2
  rc = OpenProcessToken ( GetCurrentProcess() , TOKEN_ALL_ACCESS , &hToken ) ;
  if ( !rc )
d53 1
a53 1
      printf ( "error opening process token (%lu)\n", GetLastError () );
d57 2
a58 2
  rc = LookupPrivilegeValue ( NULL, SE_DEBUG_NAME, &sPrivileges.Privileges[0].Luid );
  if ( !rc )
d60 1
a60 1
      printf ( "error getting prigilege luid (%lu)\n", GetLastError () );
d66 2
a67 2
  rc = AdjustTokenPrivileges ( hToken, FALSE, &sPrivileges, 0, NULL, NULL ) ;
  if ( !rc )
d69 1
a69 1
      printf ( "error adjusting prigilege level. (%lu)\n", GetLastError () );
d82 1
a82 1
  CloseHandle ( hToken );
d89 3
a91 3
                      DWORD access,
                      HANDLE from_handle,
                      HANDLE* to_handle_ptr, BOOL bInheritHandle = FALSE)
d103 1
a103 1
{ 
d106 3
a108 3
	                GetCurrentProcess (), &local_handle,
                        0, bInheritHandle,
                        DUPLICATE_SAME_ACCESS))
d110 1
a110 1
      printf ( "error getting handle(%u) to server (%lu)\n", (unsigned int)from_handle, GetLastError ());
d117 1
a117 1
  			        OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION	| DACL_SECURITY_INFORMATION,
d120 1
a120 1
      printf ( "error getting handle SD (%lu)\n", GetLastError ());
d127 1
a127 1
  		    &ps, &ps_len, &access, &status))
d129 1
a129 1
      printf ( "error checking access rights (%lu)\n", GetLastError ());
d135 1
a135 1
      printf ( "access to object denied\n");
d140 2
a141 2
	                to_process, to_handle_ptr,
                        access, bInheritHandle, 0))
d143 1
a143 1
      printf ( "error getting handle to client (%lu)\n", GetLastError ());
d149 1
a149 1
                    
d181 1
a181 1
  	  			req.from_master, req.to_master,
d197 1
a197 1
  
d200 2
a201 2
  			TOKEN_QUERY,
                        TRUE,
d215 4
a218 4
                            token_handle,
                            GENERIC_READ,
                            req.from_master,
                            &req.from_master, TRUE) != 0)
d241 1
a241 1
  	  			req.from_master, req.to_master);
d312 1
a312 1
         queue->add (new_conn);
d385 4
a388 4
        {
          debug_printf ("error reading from connection (%lu)\n", GetLastError ());
          goto out;
        }
d461 2
a462 2
        shutdown = 1;
        break;
d464 1
a464 1
        break;
d492 6
a497 6
                 cygwin_version.dll_major / 1000,
                 cygwin_version.dll_major % 1000,
                 cygwin_version.dll_minor,
                 cygwin_version.api_major,
                 cygwin_version.api_minor,
                 cygwin_version.shared_data,
d502 1
a502 1
                 cygwin_version.mount_registry,
d536 1
a536 1
  while (1 && request_queue.active) 
@


1.1
log
@file cygserver.cc was initially added on branch cygwin_daemon.
@
text
@d1 548
@


1.1.2.1
log
@Tue Sep 25 16:22:00 2001 Robert Collins <rbtcollins@@hotmail.com>

        * autoload.cc: Add dynamic load statement for
	'ImpersonateNamedPipeClient'.
	* Makefile.in: Add new object files, and build
	instructions for cygserver.exe.
	* cygwin.din: Export ftok, shmat, shmctl and shmget.
	* dcrt0.cc: Additional includes for cygserver support.
	(dll_crt0_1): Initialise the cygserver client.
	* fhandler.h (fhandler_tty): New method cygserver_attach_tty.
	* fhandler_tty.cc: Additional includes for cygserver support.
	(fhandler_tty_slave::open): Attempt to use the cygserver when
	obtaining handles from the parent process. On failure or 9x
	use the current method.
	(fhandler_tty_slave::cygserver_attach_tty): New function.
	* fork.cc (fork_child): Fixup shm memory mapped areas.
	* pinfo.h: Declare fixup_shms_after_fork().
	* security.h: Declare alloc_sd().
	* tty.cc: Additonal includes to support cygserver.
	(tty::common_init): Don't allow others to open us if the cygserver is running.
	* winsup.h: Declare cygserver_running.
										CVS: ----------------------------------------------------------------------
@
text
@a0 546
/* cygserver.cc

   Copyright 2001 Red Hat Inc.

   Written by Egor Duda <deo@@logos-m.ru>

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */

#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <windows.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include "wincap.h"

#include "getopt.h"

#include "cygwin/cygserver_transport.h"
#include "cygwin/cygserver.h"
#include "cygserver_shm.h"


GENERIC_MAPPING access_mapping;
class transport_layer_base *transport;

DWORD request_count = 0;

BOOL
setup_privileges ()
{
  BOOL rc, ret_val;
  HANDLE hToken = NULL;
  TOKEN_PRIVILEGES sPrivileges;

  rc = OpenProcessToken ( GetCurrentProcess() , TOKEN_ALL_ACCESS , &hToken ) ;
  if ( !rc )
    {
      printf ( "error opening process token (%lu)\n", GetLastError () );
      ret_val = FALSE;
      goto out;
    }
  rc = LookupPrivilegeValue ( NULL, SE_DEBUG_NAME, &sPrivileges.Privileges[0].Luid );
  if ( !rc )
    {
      printf ( "error getting prigilege luid (%lu)\n", GetLastError () );
      ret_val = FALSE;
      goto out;
    }
  sPrivileges.PrivilegeCount = 1 ;
  sPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;
  rc = AdjustTokenPrivileges ( hToken, FALSE, &sPrivileges, 0, NULL, NULL ) ;
  if ( !rc )
    {
      printf ( "error adjusting prigilege level. (%lu)\n", GetLastError () );
      ret_val = FALSE;
      goto out;
    }

  access_mapping.GenericRead = FILE_READ_DATA;
  access_mapping.GenericWrite = FILE_WRITE_DATA;
  access_mapping.GenericExecute = 0;
  access_mapping.GenericAll = FILE_READ_DATA | FILE_WRITE_DATA;

  ret_val = TRUE;

out:
  CloseHandle ( hToken );
  return ret_val;
}

int
check_and_dup_handle (HANDLE from_process, HANDLE to_process,
		      HANDLE from_process_token,
                      DWORD access,
                      HANDLE from_handle,
                      HANDLE* to_handle_ptr, BOOL bInheritHandle)
{
  HANDLE local_handle = NULL;
  int ret_val = EACCES;
  char sd_buf [1024];
  PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR) &sd_buf;
  DWORD bytes_needed;
  PRIVILEGE_SET ps;
  DWORD ps_len = sizeof (ps);
  BOOL status;

  if (from_process != GetCurrentProcess ())
{ 

  if (!DuplicateHandle (from_process, from_handle,
	                GetCurrentProcess (), &local_handle,
                        0, bInheritHandle,
                        DUPLICATE_SAME_ACCESS))
    {
      printf ( "error getting handle(%u) to server (%lu)\n", (unsigned int)from_handle, GetLastError ());
      goto out;
    }
} else
 local_handle = from_handle;

  if (!GetKernelObjectSecurity (local_handle,
  			        OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION	| DACL_SECURITY_INFORMATION,
				sd, sizeof (sd_buf), &bytes_needed))
    {
      printf ( "error getting handle SD (%lu)\n", GetLastError ());
      goto out;
    }

  MapGenericMask (&access, &access_mapping);

  if (!AccessCheck (sd, from_process_token, access, &access_mapping,
  		    &ps, &ps_len, &access, &status))
    {
      printf ( "error checking access rights (%lu)\n", GetLastError ());
      goto out;
    }

  if (!status)
    {
      printf ( "access to object denied\n");
      goto out;
    }

  if (!DuplicateHandle (from_process, from_handle,
	                to_process, to_handle_ptr,
                        access, bInheritHandle, 0))
    {
      printf ( "error getting handle to client (%lu)\n", GetLastError ());
      goto out;
    }

  ret_val = 0;
                    
out:
  if (local_handle && from_process != GetCurrentProcess ())
    CloseHandle (local_handle);

  return (ret_val);
}

int
check_and_dup_handle (HANDLE from_process, HANDLE to_process,
                      HANDLE from_process_token,
                      DWORD access,
                      HANDLE from_handle,
                      HANDLE* to_handle_ptr)
{
  return check_and_dup_handle(from_process,to_process,from_process_token,access,from_handle,to_handle_ptr,FALSE);
}

void
client_request_attach_tty::serve(transport_layer_base *conn)
{
  HANDLE from_process_handle = NULL;
  HANDLE to_process_handle = NULL;
  HANDLE token_handle = NULL;
  DWORD rc;

  if (header.cb != sizeof (req))
    {
      header.error_code = EINVAL;
      return;
    }

#ifdef DEBUG
  printf ("%d:(%d,%d) -> %d\n", req.master_pid,
  	  			req.from_master, req.to_master,
				req.pid);
#endif

  from_process_handle = OpenProcess (PROCESS_DUP_HANDLE, FALSE, req.master_pid);
  to_process_handle = OpenProcess (PROCESS_DUP_HANDLE, FALSE, req.pid);
  if (!from_process_handle || !to_process_handle)
    {
      printf ("error opening process (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      goto out;
    }

  transport->impersonate_client ();
  
  rc = OpenThreadToken (GetCurrentThread (),
  			TOKEN_QUERY,
                        TRUE,
			&token_handle);

  transport->revert_to_self ();

  if (!rc)
    {
      printf ("error opening thread token (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      goto out;
    }

  if (check_and_dup_handle (from_process_handle, to_process_handle,
                            token_handle,
                            GENERIC_READ,
                            req.from_master,
                            &req.from_master) != 0)
    {
      printf ("error duplicating from_master handle (%lu)\n", GetLastError ());
      header.error_code = EACCES;
      goto out;
    }

  if (req.to_master)
    {
      if (check_and_dup_handle (from_process_handle, to_process_handle,
				token_handle,
				GENERIC_WRITE,
				req.to_master,
				&req.to_master) != 0)
	{
	  printf ("error duplicating to_master handle (%lu)\n", GetLastError ());
	  header.error_code = EACCES;
	  goto out;
	}
    }

#ifdef DEBUG
  printf ("%d -> %d(%d,%d)\n", req.master_pid, req.pid,
  	  			req.from_master, req.to_master);
#endif

  header.error_code = 0;

out:
  if (from_process_handle)
    CloseHandle (from_process_handle);
  if (to_process_handle)
    CloseHandle (to_process_handle);
  if (token_handle)
    CloseHandle (token_handle);
}

void
client_request_get_version::serve(transport_layer_base *conn)
{
  if (header.cb != sizeof (version))
    {
      header.error_code = EINVAL;
      return;
    }
  header.error_code = 0;
  version.major = CYGWIN_SERVER_VERSION_MAJOR;
  version.api   = CYGWIN_SERVER_VERSION_API;
  version.minor = CYGWIN_SERVER_VERSION_MINOR;
  version.patch = CYGWIN_SERVER_VERSION_PATCH;
}

class server_request
{
  public:
  class server_request *next;
  server_request (transport_layer_base *newconn);
  void process ();
  private:
    char request_buffer [MAX_REQUEST_SIZE];
    transport_layer_base *conn;
};

class server_request_queue
{
  public:
  CRITICAL_SECTION queuelock;
  HANDLE event;
  server_request * request;
  bool active;
  unsigned int initial_workers;
  unsigned int running;
  void create_workers ();
  void cleanup ();
  void add (transport_layer_base *conn);
};
class server_request_queue request_queue;

void
client_request_shutdown::serve (transport_layer_base *conn)
{
  /* FIXME: link upwards, and then this becomes a trivial method call to
   * only shutdown _this queue_
   */
  /* tell the main thread to shutdown */
  request_queue.active=false;
}

server_request::server_request (transport_layer_base *newconn)
{
  conn = newconn;
  next = NULL;
}

void
server_request::process ()
{
  ssize_t bytes_read, bytes_written;
  struct request_header* req_ptr = (struct request_header*) &request_buffer;
  client_request *req = NULL;
  printf ("about to read\n");

  bytes_read = conn->read (request_buffer, sizeof (struct request_header));
  if (bytes_read != sizeof (struct request_header))
    {
      printf ("error reading from connection (%lu)\n", GetLastError ());
      goto out;
    }
  printf ("got header (%ld)\n", bytes_read);

  switch (req_ptr->req_id)
    {
    case CYGSERVER_REQUEST_GET_VERSION:
      req = new client_request_get_version (); break;
    case CYGSERVER_REQUEST_ATTACH_TTY:
      req = new client_request_attach_tty (); break;
    case CYGSERVER_REQUEST_SHUTDOWN:
      req = new client_request_shutdown (); break;
    case CYGSERVER_REQUEST_SHM_GET:
     req = new client_request_shm_get (); break;
    default:
      req = new client_request (CYGSERVER_REQUEST_INVALID);
      req->header.error_code = ENOSYS;
      printf ("Bad client request - returning ENOSYS\n");
    }

  if (req->header.cb != req_ptr->cb)
    {
      printf ("Mismatch in request buffer sizes\n");
      goto out;
    }

  if (req->header.cb)
    {

      bytes_read = conn->read (req->buffer, req->header.cb);
      if (bytes_read != req->header.cb)
        {
          printf ("error reading from connection (%lu)\n", GetLastError ());
          goto out;
        }
      printf ("got body (%ld)\n",bytes_read);
    }

  /* this is not allowed to fail. We must return ENOSYS at a minimum to the client */
  req->serve (conn);

  if ((bytes_written = conn->write ((char *)&req->header, sizeof (req->header)))
    != sizeof(req->header) ||
    (bytes_written = conn->write (req->buffer, req->header.cb)) != req->header.cb)
    {
      req->header.error_code = -1;
      printf ("error writing to connection (%lu)\n", GetLastError ());
      goto out;
    }

  printf("Sent reply, size (%ld)\n",bytes_written);

out:
  conn->close ();
  delete conn;
  if (req)
    delete (req);
}

DWORD WINAPI
worker_function( LPVOID LpParam )
{
  class server_request_queue *queue = (class server_request_queue *) LpParam;
  class server_request *request;
  /* FIXME use a threadsafe pop instead for speed? */
  while (queue->active)
    {
      EnterCriticalSection (&queue->queuelock);
      while (!queue->request && queue->active)
        {
	  LeaveCriticalSection (&queue->queuelock);
          DWORD rc = WaitForSingleObject (queue->event,INFINITE);
          if (rc == WAIT_FAILED)
	    {
	      printf("Wait for event failed\n");
	      queue->running--;
	      ExitThread (0);
	    }
	  EnterCriticalSection (&queue->queuelock);
        }
      if (!queue->active)
	{
	  queue->running--;
	  LeaveCriticalSection (&queue->queuelock);
	  ExitThread (0);
	}
      /* not needed, but it is efficient */
      request = (class server_request *)InterlockedExchangePointer (&queue->request, queue->request->next);
      LeaveCriticalSection (&queue->queuelock);
      request->process ();
      delete request;
    }
  queue->running--;
  ExitThread (0);
}

void
server_request_queue::create_workers()
{
  InitializeCriticalSection (&queuelock);
  if ((event = CreateEvent (NULL, FALSE, FALSE, NULL)) == NULL)
    {
      printf ("Failed to create event queue (%lu), terminating\n", GetLastError ());
      exit (1);
    }
  active = true;
  
  /* FIXME: Use a stack pair and create threads on the fly whenever
   * we have to to service a request.
   */
  for (unsigned int i=0; i<initial_workers; i++)
    {
      HANDLE hThread;
      DWORD tid;
      hThread = CreateThread (NULL, 0, worker_function, this, 0, &tid);
      if (hThread == NULL)
        {
	  printf ("Failed to create thread (%lu), terminating\n", GetLastError ());
	  exit (1);
	}
      CloseHandle (hThread);
      running++;
    }
}

void
server_request_queue::cleanup ()
{
  /* harvest the threads */
  active = false;
  if (!running)
    return;
  printf ("Waiting for current connections to terminate\n");
  for (int n=running; n; n--)
    PulseEvent (event);
  while (running)
    sleep (1);
  DeleteCriticalSection (&queuelock);
  CloseHandle (event);
}

void
server_request_queue::add (transport_layer_base *conn)
{
  /* safe to not "Try" because workers don't hog this, they wait on the event
   */
  EnterCriticalSection (&queuelock);
  if (!running)
    {
      printf ("No worker threads to handle request!\n");
      conn->close ();
      delete conn;
    }
  server_request * listrequest;
  if (!request)
    {
      request = new server_request (conn);
      listrequest = request;
    }
  else
    {
      /* add to the queue end. */
      listrequest = request;
      while (listrequest->next)
	listrequest = listrequest->next;
      listrequest->next = new server_request (conn);
      listrequest = listrequest->next;
    }
  PulseEvent (event);
  LeaveCriticalSection (&queuelock);
}

struct option longopts[] = {
  {"shutdown", no_argument, NULL, 's'},
  {0, no_argument, NULL, 0}
};

char opts[] = "s";

int
main (int argc, char **argv)
{
  int shutdown=0;
  char i;

  while ((i = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (i)
      {
      case 's':
        shutdown = 1;
        break;
      default:
        break;
       /*NOTREACHED*/
      }

  wincap.init();
  if (wincap.has_security ())
    setup_privileges ();
  transport = create_server_transport ();

  if (shutdown)
    {
      if (!transport->connect())
	{
	  printf ("couldn't establish connection with server\n");
	  exit (1);
	}
      client_request_shutdown *request =
	new client_request_shutdown ();
      request->send (transport);
      transport->close();
      delete transport;
      delete request;
      exit(0);
    }

  transport->listen ();
  request_queue.initial_workers = 10;
  request_queue.create_workers();
  while (request_queue.active)
    {
      transport_layer_base * new_conn = transport->accept ();
      /* FIXME: this is a little ugly. What we really want is to wait on two objects:
       * one for the pipe/socket, and one for being told to shutdown. Otherwise
       * this will stay a problem (we won't actually shutdown until the request
       * _AFTER_ the shutdown request. And sending ourselves a request is ugly 
       */
      if (new_conn && request_queue.active)
          request_queue.add (new_conn);
    }
  printf ("No longer accepting requests.\n");
  request_queue.cleanup ();
  transport->close ();
}
@


1.1.2.2
log
@Sat Sep 29 20:40:00 2001 Robert Collins <rbtcollins@@hotmail.com>

        * Makefile.in: Add cygserver_transport_sockets.o to DLL_OFILES.
        Add cygserver_transport_sockets_outside.o to cygserver.exe.
        * cygserver.cc: Include new include files.
        * cygserver_client.cc: Ditto.
        * cygserver_shm.h: No need to include <sys/socket.h> now.
        * cygerver_transport.cc: Include new include files.
        (transport_layer_base::transport_layer_base): Strip back to a stub.
        (transport_layer_base::listen): Ditto.
        (transport_layer_base::accept): Ditto.
        (transport_layer_base::close): Ditto.
        (transport_layer_base::read): Ditto.
        (transport_layer_base::write): Ditto.
        (transport_layer_base::connect): Ditto.
        * cygserver_transport_pipes.cc: Include new header
        "cygwin/cygserver_transport_pipes.h".
        * cygserver_transport_sockets.cc: New file.
        * dcrt0.cc: No need to include <sys/socket.h> now.
        * fhandler_tty.cc: Ditto.
        * tty.cc: Ditto.
        * include/cygwin/cygserver_transport.h: Strip the base class to a stub.
        Remove the cygserver_transport_pipes class.
        * include/cygwin/cygserver_transport_pipes.h: New file.
        * include/cygwin/cygserver_transport_sockets.h: New file.
@
text
@a24 2
#include "cygwin/cygserver_transport_pipes.h"
#include "cygwin/cygserver_transport_sockets.h"
@


1.1.2.3
log
@Sun Sep 30 23:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * Makefile.in: Add cygserver_process.o to cygserver.exe.
        * cygserver.cc: Include signal.h and cygwin_version.h.
        Define debug_printf as a macro.
        Define DEBUG to a value.
        (client_request_attach_tty::serve): Add beginning of process cache support.
        Change from #ifdef DEBUG to work with new DEBUG style.
        (client_request_get_version::serve): Add beginning of process cache support.
        (class server_request): New prototype for support of process cache.
        (class queue_process_param): New class to allow request loop threading.
        (class server_request_queue): Add beginning of process cache support.
        Allow request loop threading.
        (request_loop): Thread function for request loops.
        (server_request_queue::process_requests): Initiator for threaded request loops.
        (client_request_shutdown::serve): Add beginning of process cache support.
        (server_request::server_request): Ditto.
        (server_request::process): Use debug_printf. Add beginning of process cache support.
        (server_request_queue::cleanup): Kill off any request loop threads.
        (server_request_queue::add): Add beginning of process cache support.
        (handle_signal): Trigger a shutdown.
        (main): Print out some useful info at startup - version, date time.
        Add process cache support.
        Spawn a separate thread for the transport request loop, thus allowing concurrent
        support for multiple transports.
        * cygserver_client.cc (client_request_get_version::serve): Add process cache support.
        (client_request_attach_tty::serve): Add process cache support.
        (client_request_shutdown::serve): Add process cache support.
        * cygsserver_process.cc: New file with the process cache support.
        * cygserver_shm.cc: Redefine debug_printf to allow conditional output.
        * cygwin.din: Export shmdt().
        * shm.cc: Run indent.
        Update FIXME's.
        (shmdt): New function.
        * include/cygwin/cygserver.h (class client_request): Add process cache support.
        (class client_request_get_version): Ditto.
        (class client_request_shutdown): Ditto.
        (class client_request_attach_tty): Ditto.
        * include/cygwin/cygserver_process.h: New header for process cache support.
@
text
@a19 1
#include <signal.h>
a20 1
#include "cygwin_version.h"
a26 1
#include "cygwin/cygserver_process.h"
a29 3
/* for quieter operation, set to 0 */
#define DEBUG 0
#define debug_printf if (DEBUG) printf
d160 1
a160 1
client_request_attach_tty::serve(transport_layer_base *conn, class process_cache *cache)
d173 2
a174 2
#if DEBUG
  printf ("%ld:(%p,%p) -> %ld\n", req.master_pid,
d229 2
a230 2
#if DEBUG
  printf ("%ld -> %ld(%p,%p)\n", req.master_pid, req.pid,
d246 1
a246 1
client_request_get_version::serve(transport_layer_base *conn, class process_cache *cache)
d264 1
a264 1
  server_request (transport_layer_base *newconn, class process_cache *newcache);
a268 11
    class process_cache *cache;
};

class queue_process_param
{
  public:
  class queue_process_param * next;
  class server_request_queue *queue;
  transport_layer_base *transport;
  HANDLE hThread;
  DWORD tid;
a279 1
  class process_cache *cache;
a281 1
  void process_requests (transport_layer_base *transport);
a282 2
  private:
    class queue_process_param * process_head;
a285 21
DWORD WINAPI
request_loop (LPVOID LpParam)
{
  class queue_process_param *params = (queue_process_param *) LpParam;
  class server_request_queue *queue = params->queue;
  class transport_layer_base * transport = params->transport;
  while (queue->active)
  {
    transport_layer_base * new_conn = transport->accept ();
    /* FIXME: this is a little ugly. What we really want is to wait on two objects:
     * one for the pipe/socket, and one for being told to shutdown. Otherwise
     * this will stay a problem (we won't actually shutdown until the request
     * _AFTER_ the shutdown request. And sending ourselves a request is ugly
     */
     if (new_conn && queue->active)
         queue->add (new_conn);
  }
  return 0;
}

/* TODO: check we are not being asked to service a already serviced transport */
d287 1
a287 18
server_request_queue::process_requests (transport_layer_base *transport)
{
  class queue_process_param *params;
  params = new queue_process_param;
  params->transport = transport;
  params->queue = this;
  params->hThread = CreateThread (NULL, 0, request_loop, params, 0, &params->tid);
  if (params->hThread == NULL)
    {
      printf ("Failed to create thread (%lu), terminating\n", GetLastError ());
      delete params;
      exit (1);
    }
  params->next = (queue_process_param *) InterlockedExchangePointer (&process_head, params);
}

void
client_request_shutdown::serve (transport_layer_base *conn, class process_cache *cache)
d296 1
a296 1
server_request::server_request (transport_layer_base *newconn, class process_cache *newcache)
a298 1
  cache = newcache;
d308 1
a308 1
  debug_printf ("about to read\n");
d316 1
a316 1
  debug_printf ("got header (%ld)\n", bytes_read);
d331 1
a331 1
      debug_printf ("Bad client request - returning ENOSYS\n");
d336 1
a336 1
      debug_printf ("Mismatch in request buffer sizes\n");
d346 1
a346 1
          debug_printf ("error reading from connection (%lu)\n", GetLastError ());
d349 1
a349 1
      debug_printf ("got body (%ld)\n",bytes_read);
d353 1
a353 1
  req->serve (conn, cache);
d356 2
a357 2
    != sizeof(req->header) || (req->header.cb &&
    (bytes_written = conn->write (req->buffer, req->header.cb)) != req->header.cb))
d364 1
a364 2
  debug_printf("Sent reply, size (%ld)\n",bytes_written);
  printf (".");
a443 19
  /* kill the request processing loops */
  queue_process_param * reqloop;
  /* make sure we don't race with a incoming request creation */
  EnterCriticalSection (&queuelock);
  reqloop = (queue_process_param *) InterlockedExchangePointer (&process_head, NULL);
  while (reqloop)
    {
      printf ("killing request loop thread %ld\n", reqloop->tid);
      int rc;
      if (!(rc = TerminateThread (reqloop->hThread, 0)))
	{
	  printf ("error shutting down request loop worker thread\n");
	}
      CloseHandle (reqloop->hThread);
      queue_process_param *t = reqloop;
      reqloop = reqloop->next;
      delete t;
    }
  LeaveCriticalSection (&queuelock);
d470 1
a470 1
      request = new server_request (conn, cache);
d479 1
a479 1
      listrequest->next = new server_request (conn, cache);
a485 11
void
handle_signal (int signal)
{
  /* any signal makes us die :} */
  /* FIXME: link upwards, and then this becomes a trivial method call to
   * only shutdown _this queue_
   */
  /* tell the main thread to shutdown */
  request_queue.active=false;
}

d531 4
a534 18
  char version[200];
  /* Cygwin dll release */
  snprintf (version, 200, "%d.%d.%d(%d.%d/%d/%d)-(%d.%d.%d.%d) %s",
                 cygwin_version.dll_major / 1000,
                 cygwin_version.dll_major % 1000,
                 cygwin_version.dll_minor,
                 cygwin_version.api_major,
                 cygwin_version.api_minor,
                 cygwin_version.shared_data,
		 CYGWIN_SERVER_VERSION_MAJOR,
		 CYGWIN_SERVER_VERSION_API,
		 CYGWIN_SERVER_VERSION_MINOR,
		 CYGWIN_SERVER_VERSION_PATCH,
                 cygwin_version.mount_registry,
		 cygwin_version.dll_build_date);
  setbuf (stdout, NULL);
  printf ("daemon version %s starting up", version);
  if (signal (SIGQUIT, handle_signal) == SIG_ERR)
d536 8
a543 2
      printf ("\ncould not install signal handler (%d)- aborting startup\n", errno);
      exit (1);
d545 1
a545 21
  printf (".");
  transport->listen ();
  printf (".");
  class process_cache cache;
  request_queue.initial_workers = 10;
  request_queue.cache = &cache;
  request_queue.create_workers ();
  printf (".");
  request_queue.process_requests (transport);
  printf (".complete\n");
  /* TODO: wait on multiple objects - the thread handle for each request loop +
   * all the process handles. This should be done by querying the request_queue and
   * the process cache for all their handles, and then waiting for (say) 30 seconds.
   * after that we recreate the list of handles to wait on, and wait again.
   * the point of all this abstraction is that we can trivially server both sockets
   * and pipes simply by making a new transport, and then calling
   * request_queue.process_requests (transport2);
   */
  while (1 && request_queue.active) 
    sleep (1);
  printf ("\nShutdown request recieved. No longer accepting requests.\n");
a546 1
  printf ("All pending requests processed\n");
a547 2
  printf ("request port closed\n");
  printf ("daemon shutdown\n");
@


1.1.2.4
log
@Mon Oct  1 12:38:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * cygserver.cc (client_request::serve): New function.
        * cygserver_process.cc: Inlude <pthread.h> for pthread_once.
        (process_cache::process_cache): Initialise a crtiical section for write access.
        (process_cache::process): Use the critical section. Also add missing entries to
        the cache.
        (do_process_init): New function to initalise class process static variables.
        (process::process): Ensure that the process access critical section is initialised.
        (process::handle): Close the handle of old process's when they have terminated
        and we are returning the handle for a process with the same pid.
        * cygserver_shm.cc: Run indent.
        Include cygserver_process.h to allow process cache functionality.
        (client_request_shm_get::serve): New parameter for process cache support.
        Use the process cache, not OpenProcess to get a handle to the originating process.
        Fix a handle leak with token_handle.
        * cygserver_shm.h (class client_request_shm_get): Update ::serve for process cache support.
        * cygserver_transport_pipes.cc: Redefine debug_printf to be conditional on DEBUG.
        * include/cygwin/cygserver.h: Do not implement client_request::serve in the header.
        * include/cygwin/cygserver_process.h (class process_cache): Add a write access cri
tical section to prevent races when requests from a  multithreaded application arrive.
@
text
@a165 9
client_request::serve (transport_layer_base *conn, class process_cache *cache)
{
  printf ("*****************************************\n"
	  "A call to the base client_request class has occured\n"
	  "This indicates a mismatch in a virtual function definition somewhere\n");
  exit (1);
}

void
@


1.1.2.5
log
@Tue Oct  2  9:57:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * Makefile.in: add threaded_queue.o to cygserver.exe.
        * cygserver.cc: Include threaded_queue.h
        (class server_request): Inherit from queue_request.
        (class server_process_param): Inherit from queue_process_param.
        (class server_request_queue): Inherit from threaded_queue.
        (request_loop): Adjust for new types.
        (server_request_queue::process_requests): Remove guts to
        threaded_queue::process_requests.
        (server_request::server_request): Adjust for new types.
        (worker_function): Delete.
        (server_request_queue::create_workers): Delete.
        (server_request_queue::cleanup): Delete.
        (server_request_queue::add): Move guts to threaded_queue::add.
        * threaded_queue.cc: New file.
        * threaded_queue.h: New file.
@
text
@a32 2
#include "threaded_queue.h"

d275 1
a275 1
class server_request : public queue_request
d278 1
d280 1
a280 1
  virtual void process ();
d287 1
a287 1
class server_process_param : public queue_process_param
d290 5
a294 1
    transport_layer_base *transport;
d297 1
a297 1
class server_request_queue : public threaded_queue
d300 13
a312 3
    class process_cache *cache;
    void process_requests (transport_layer_base *transport);
    virtual void add (transport_layer_base *conn);
d319 2
a320 2
  class server_process_param *params = (server_process_param *) LpParam;
  class server_request_queue *queue = (server_request_queue *) params->queue;
d340 2
a341 1
  class server_process_param *params = new server_process_param;
d343 9
a351 1
  threaded_queue::process_requests (params, request_loop);
d368 1
d443 101
a548 1
  /* every derived ::add must enter the section! */
d552 1
d556 16
a571 2
  queue_request * listrequest = new server_request (conn, cache);
  threaded_queue::add (listrequest);
@


1.1.2.6
log
@Tue Oct  2 16:06:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * Makefile.in: Remove cygserver_shm.o from cygwin1.dll.
        Rename cygserver_shm_outside.o to cygserver_shm.o.
        * cygserver.cc (server_request::process): Use the new client_request
        constructor.
        * cygserver_client.cc: Remove the #ifdef's stubs for the server method
        within cygwin.
        (client_request_attach_tty::client_request_attach_tty): Use the new
        client_request constructor.
        (client_request_shutdown::client_request_shutdown): Ditto.
        (client_request::client_request): Ditto.
        * cygserver_shm.cc (client_request_shm_get::serve): Remove the
        #ifdef'd stub for in-cygwin builds.
        (client_request_shm_get::client_request_shm_get): Use the new
        client_request constructor, and remove the in-cygwin variants.
        * cygserver_shm.h (class client_request_shm_get): #ifndef test the
        serve method - it's only used in cygserver.
        * shm.cc (client_request_shm_get::client_request_shm_get): New function.
        * include/cygwin/cygserver.h (request_header): New constructor.
        (class client_request): Use it.
        New constructor accepting the header size.
        #ifndef test the server method - it's only used within cygserver.
        (client_request_get_version): #ifdef test the server method.
        (client_request_shutdown): Ditto.
        (client_request_attach_tty): Ditto.
@
text
@d375 1
a375 1
      req = new client_request (CYGSERVER_REQUEST_INVALID, 0);
@


1.1.2.7
log
@Tue Oct  2 23:24:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * cygserver.cc (class server_process_param): Use new constructor syntax.
        * cygserver_process.cc (process_cache::~process_cache): New function.
        * threaded_queue.cc: Define condition debug_printf.
        Run indent.
        (threaded_queue::cleanup): Move queue_process_param guts to a method.
        (threaded_queue::process_requests): Ditto.
        (queue_process_param::queue_process_param): New method.
        (queue_process_param::~queue_process_param): Ditto.
        (queue_process_param::start): Ditto.
        (queue_process_param::stop): Ditto.
        * threaded_queue.h (class queue_process_param): Add support for
        interruptible request loops.
        * cygwin/include/cygwin/cygserver_process.h (class process_cache): Add
        destructor.
@
text
@a291 1
    server_process_param () : queue_process_param (false) {};
@


1.1.2.8
log
@Thu Oct  4 14:12:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * cygserver.cc (request_loop): Make static.
        (main): Use new cache constructor syntax.
        Start cache worker threads.
        Cleanup the cache at shutdown.
        * cygserver_process.cc: Run indent.
        (process_cache::process_cache): Add a trigger to use when adding a process.
        (process_cache::process): Move process_entry to process.
        Insert at the end of the list.
        Trigger the request loop when new process's inserted.
        (process_cache::process_requests): Do it.
        (process_cache::add): New method.
        (process_cache::handle_snapshot): New method.
        (process::process): Merge in the process_entry fields.
        (process::handle): Make a stub function.
        (process::exit_code): New method.
        (process_request::process): New method.
        (process_process_param::request_loop): New method.
        * cygserver_shm.cc: New header dependency - threaded_queue.h.
        * threaded_queue.cc (threaded_queue::cleanup): Clearer messages.
        (queue_process_param::stop): Short spinlock on interruptible threads.
        * threaded_queue.h (class threaded_queue): New constructor.
        * include/cygwin/cygserver_process.h (process_request): New class.
        (process_entry): Remove.
        (process): Merge in process_entry.
        (process_cache): Inherit from threaded_queue.
@
text
@a28 1
#include "threaded_queue.h"
d33 2
d304 1
a304 1
static DWORD WINAPI
a431 2
      LeaveCriticalSection (&queuelock);
      return;
d519 1
a519 1
  class process_cache cache (2);
a524 4
  printf (".");
  cache.create_workers ();
  printf (".");
  cache.process_requests ();
a533 3
  /* WaitForMultipleObjects abort && request_queue && process_queue && signal
     -- if signal event then retrigger it
   */
d535 2
a536 4
    {
      sleep (1);
    }
  printf ("\nShutdown request recieved - new requests will be denied\n");
d540 1
a540 3
  printf ("No longer accepting requests - cygwin will operate in daemonless mode\n");
  cache.cleanup ();
  printf ("All outstanding process-cache activities completed\n");
@


1.1.2.9
log
@Mon Oct  8  7:41:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * cygserver.cc (server_request::process): Rename client_request_shm_get to
        client_request_shm.
        * cygserver_process.cc (process_cache::add): Rename to add_task.
        Use process_cleanup instead of process_request.
        (process_cache::remove_process): New method.
        (process::process): Initialize new members.
        (process::~process): New member.
        (process::cleanup): New method.
        (process::add_cleanup_routine): New method.
        (process_request::process): Rename to process_cleanup.
        Call the process object's cleanup method and then delete it.
        (process_process_param::request_loop): Remove the signalling process.
        * cygserver_shm.cc: Globally rename client_request_shm_get to client_request_shm.
        (client_request_shm_get::serve): Handle attach request counting.
        * cygserver_shm.h: Globally rename client_request_shm_get to client_request_shm.
        (class shm_cleanup): New class.
        * shm.cc: Globally rename client_request_shm_get to client_request_shm.
        (client_request_shm::client_request_shm): New constructor for attach requests.
        (shmat): Use it.
        * include/cygwin/cygserver_process.h (class process_request): Rename to
        process_cleanup.
        (class cleanup_routine): New class.
        (class process): New members and methods to allow calling back when the process
        terminates.
@
text
@d373 1
a373 1
     req = new client_request_shm (); break;
@


1.1.2.10
log
@2002-01-16  Robert Collins  <rbtcollins@@hotmail.com>

        * cygserver.cc (transport): Correct scope.
        (client_request_attach_tty::serve): Add more debug information.
        Fix erroneous use of transport instead of conn.
        * cygserver_transport_pipes.cc (transport_layer_pipes::close): More debug.
        (transport_layer_pipes::read): Ditto.
        (transport_layer_pipes::write): Ditto.
        (transport_layer_pipes::impersonate_client): Ditto.
@
text
@d39 1
a39 1
static class transport_layer_base *transport;
d190 1
a190 1
  printf ("pid %ld:(%p,%p) -> pid %ld\n", req.master_pid,
a194 1
  debug_printf ("opening process %ld\n", req.master_pid);
a195 1
  debug_printf ("opening process %ld\n", req.pid);
d204 1
a204 2
  debug_printf ("Impersonating client\n");
  conn->impersonate_client ();
a205 1
  debug_printf ("about to open thread token\n");
d211 1
a211 2
  debug_printf ("opened thread token, rc=%lu\n", rc);
  conn->revert_to_self ();
@


1.1.2.11
log
@2002-01-17  Robert Collins  <rbtcollins@@hotmail.com>

        * cygserver.cc (check_and_dup_handle): Consolidate the two variants for
        simplicity.
        Add Some basic debug output.
        (client_request_attach_tty::serve): Use the new debug_printf for clarity.
        Mark the duplicated handles as inheritable - fixup_after_fork() doesn't reopen
        tty's.
@
text
@d91 1
a91 1
                      HANDLE* to_handle_ptr, BOOL bInheritHandle = FALSE)
a145 1
  debug_printf ("Duplicated %p to %p\n", from_handle, *to_handle_ptr);
d156 10
d189 2
a190 1
  debug_printf ("pid %ld:(%p,%p) -> pid %ld\n", req.master_pid,
d193 1
d229 1
a229 1
                            &req.from_master, TRUE) != 0)
d242 1
a242 1
				&req.to_master, TRUE) != 0)
@


1.1.2.12
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 2001, 2002 Red Hat Inc.
a20 1
#include <stdlib.h>
d50 2
a51 2
  rc = OpenProcessToken (GetCurrentProcess() , TOKEN_ALL_ACCESS , &hToken) ;
  if (!rc)
d53 1
a53 1
      printf ("error opening process token (%lu)\n", GetLastError ());
d57 2
a58 2
  rc = LookupPrivilegeValue (NULL, SE_DEBUG_NAME, &sPrivileges.Privileges[0].Luid);
  if (!rc)
d60 1
a60 1
      printf ("error getting prigilege luid (%lu)\n", GetLastError ());
d66 2
a67 2
  rc = AdjustTokenPrivileges (hToken, FALSE, &sPrivileges, 0, NULL, NULL) ;
  if (!rc)
d69 1
a69 1
      printf ("error adjusting prigilege level. (%lu)\n", GetLastError ());
d82 1
a82 1
  CloseHandle (hToken);
d89 3
a91 3
		      DWORD access,
		      HANDLE from_handle,
		      HANDLE* to_handle_ptr, BOOL bInheritHandle = FALSE)
d103 1
a103 1
    {
d106 3
a108 3
			GetCurrentProcess (), &local_handle,
			0, bInheritHandle,
			DUPLICATE_SAME_ACCESS))
d110 1
a110 1
      printf ("error getting handle(%u) to server (%lu)\n", (unsigned int)from_handle, GetLastError ());
d117 1
a117 1
				OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION	| DACL_SECURITY_INFORMATION,
d120 1
a120 1
      printf ("error getting handle SD (%lu)\n", GetLastError ());
d127 1
a127 1
		    &ps, &ps_len, &access, &status))
d129 1
a129 1
      printf ("error checking access rights (%lu)\n", GetLastError ());
d135 1
a135 1
      printf ("access to object denied\n");
d140 2
a141 2
			to_process, to_handle_ptr,
			access, bInheritHandle, 0))
d143 1
a143 1
      printf ("error getting handle to client (%lu)\n", GetLastError ());
d149 1
a149 1

d181 1
a181 1
				req.from_master, req.to_master,
d197 1
a197 1

d200 2
a201 2
			TOKEN_QUERY,
			TRUE,
d215 4
a218 4
			    token_handle,
			    GENERIC_READ,
			    req.from_master,
			    &req.from_master, TRUE) != 0)
d241 1
a241 1
				req.from_master, req.to_master);
d312 1
a312 1
	 queue->add (new_conn);
d385 4
a388 4
	{
	  debug_printf ("error reading from connection (%lu)\n", GetLastError ());
	  goto out;
	}
d461 2
a462 2
	shutdown = 1;
	break;
d464 1
a464 1
	break;
d492 6
a497 6
		 cygwin_version.dll_major / 1000,
		 cygwin_version.dll_major % 1000,
		 cygwin_version.dll_minor,
		 cygwin_version.api_major,
		 cygwin_version.api_minor,
		 cygwin_version.shared_data,
d502 1
a502 1
		 cygwin_version.mount_registry,
d536 1
a536 1
  while (1 && request_queue.active)
@


1.1.2.13
log
@	* woutsup.h: New file.
	* cygserver.cc: Use "woutsup.h" and new XXX_printf macros.
	(getfunc): New function, copied verbatim from "strace.cc".
	(__cygserver__printf): New function.
	* cygserver_client.cc: Use "woutsup.h" and new XXX_printf macros.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* threaded_queue.cc: Ditto.
	* shm.cc: Remove trailing \n from XXX_printf format strings.
	* Makefile.in: Remove redundant __OUTSIDE_CYGWIN__ case for
	cygserver_shm.cc.
@
text
@a12 4
#include "woutsup.h"

#include <assert.h>
#include <ctype.h>
d16 1
d22 1
d35 4
a43 74
/*
 * Support function for the XXX_printf() macros in "woutsup.h".
 * Copied verbatim from "strace.cc".
 */
static int
getfunc (char *in_dst, const char *func)
{
  const char *p;
  const char *pe;
  char *dst = in_dst;
  for (p = func; (pe = strchr (p, '(')); p = pe + 1)
    if (isalnum ((int)pe[-1]) || pe[-1] == '_')
      break;
    else if (isspace((int)pe[-1]))
      {
	pe--;
	break;
      }
  if (!pe)
    pe = strchr (func, '\0');
  for (p = pe; p > func; p--)
    if (p != pe && *p == ' ')
      {
	p++;
	break;
      }
  if (*p == '*')
    p++;
  while (p < pe)
    *dst++ = *p++;

  *dst++ = ':';
  *dst++ = ' ';
  *dst = '\0';

  return dst - in_dst;
}

/*
 * Support function for the XXX_printf() macros in "woutsup.h".
 */
extern "C" void
__cygserver__printf (const char * const function, const char * const fmt, ...)
{
  const DWORD lasterror = GetLastError ();
  const int lasterrno = errno;

  va_list ap;

  char * const buf = (char *) alloca(BUFSIZ);

  assert (buf);

  int len = 0;

  if (function)
    len += getfunc(buf, function);

  va_start (ap, fmt);
  len += vsnprintf (buf + len, BUFSIZ - len, fmt, ap);
  va_end (ap);

  len += snprintf (buf + len, BUFSIZ - len, "\n");

  const int actual = (len > BUFSIZ ? BUFSIZ : len);

  write (2, buf, actual);

  errno = lasterrno;
  SetLastError (lasterror);

  return;
}

d54 1
a54 1
      system_printf ("error opening process token (%lu)", GetLastError ());
d61 1
a61 1
      system_printf ("error getting privilege luid (%lu)", GetLastError ());
d70 1
a70 2
      system_printf ("error adjusting privilege level. (%lu)",
		     GetLastError ());
d111 1
a111 2
      system_printf ("error getting handle(%u) to server (%lu)",
		     (unsigned int)from_handle, GetLastError ());
d121 1
a121 1
      system_printf ("error getting handle SD (%lu)", GetLastError ());
d130 1
a130 1
      system_printf ("error checking access rights (%lu)", GetLastError ());
d136 1
a136 1
      system_printf ("access to object denied");
d144 1
a144 1
      system_printf ("error getting handle to client (%lu)", GetLastError ());
d147 1
a147 1
  debug_printf ("Duplicated %p to %p", from_handle, *to_handle_ptr);
d161 3
a163 3
  system_printf ("*****************************************\n"
		 "A call to the base client_request class has occurred\n"
		 "This indicates a mismatch in a virtual function definition somewhere");
d181 1
a181 1
  debug_printf ("pid %ld:(%p,%p) -> pid %ld", req.master_pid,
d185 1
a185 1
  debug_printf ("opening process %ld", req.master_pid);
d187 1
a187 1
  debug_printf ("opening process %ld", req.pid);
d191 1
a191 1
      system_printf ("error opening process (%lu)", GetLastError ());
d196 1
a196 1
  debug_printf ("Impersonating client");
d199 1
a199 1
  debug_printf ("about to open thread token");
d205 1
a205 1
  debug_printf ("opened thread token, rc=%lu", rc);
d210 1
a210 1
      system_printf ("error opening thread token (%lu)", GetLastError ());
d221 1
a221 2
      system_printf ("error duplicating from_master handle (%lu)",
		     GetLastError ());
d234 1
a234 2
	  system_printf ("error duplicating to_master handle (%lu)",
			 GetLastError ());
d240 4
a243 2
  debug_printf ("%ld -> %ld(%p,%p)", req.master_pid, req.pid,
		req.from_master, req.to_master);
d349 1
a349 1
  debug_printf ("about to read");
d354 1
a354 1
      system_printf ("error reading from connection (%lu)", GetLastError ());
d357 1
a357 1
  debug_printf ("got header (%ld)", bytes_read);
d372 1
a372 1
      debug_printf ("Bad client request - returning ENOSYS");
d377 1
a377 1
      debug_printf ("Mismatch in request buffer sizes");
d387 1
a387 1
	  debug_printf ("error reading from connection (%lu)", GetLastError ());
d390 1
a390 1
      debug_printf ("got body (%ld)",bytes_read);
d401 1
a401 1
      system_printf ("error writing to connection (%lu)", GetLastError ());
d405 1
a405 1
  debug_printf("Sent reply, size (%ld)",bytes_written);
d478 1
a478 1
	  system_printf ("couldn't establish connection with server");
d509 1
a509 2
      system_printf ("could not install signal handler (%d)- aborting startup",
		     errno);
d541 1
a541 1
  printf ("\nShutdown request received - new requests will be denied\n");
@


1.1.2.14
log
@	* cygserver.cc (check_and_dup_handle): Only use security code if
	running on NT, i.e. if wincap.has_security().
	(client_request_attach_tty::serve): Add check for has_security().
	* cygserver_process.cc (process_cache::process): Use DWORD winpid
	throughout to avoid win32 vs. cygwin pid confusion.
	(process::process): Ditto.
	* cygserver_shm.cc (client_request_shm::serve): Only use security
	code if running on NT, i.e. if wincap.has_security().
	* cygserver_shm.h (client_request_shm::parameters.in): Replace the
	ambiguous pid field with cygpid and winpid fields.
	(client_request_shm::client_request_shm): Reduce to only two
	client-side constructors: one for SHM_CREATE, another for all the
	other requests.
	* shm.cc (client_request_shm::client_request_shm):
	Ditto. Initialize cygpid and winpid fields here. On NT initialize
	sd_buf here using set_security_attribute() to make use of the euid
	and egid.
	(shmat): Use new client_request_shm constructor.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto. Remove security code, now performed in the
	relevant client_request_shm constructor.
	* include/cygwin/cygserver_process.h: (class cleanup_routine):
	Change winpid type to DWORD.
	(class process): Ditto.
@
text
@d169 6
d178 34
a211 48
      if (!DuplicateHandle (from_process, from_handle,
			    GetCurrentProcess (), &local_handle,
			    0, bInheritHandle,
			    DUPLICATE_SAME_ACCESS))
	{
	  system_printf ("error getting handle(%u) to server (%lu)",
			 (unsigned int)from_handle, GetLastError ());
	  goto out;
	}
    } else
      local_handle = from_handle;

  if (!wincap.has_security ())
    assert (!from_process_token);
  else
    {
      char sd_buf [1024];
      PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR) &sd_buf;
      DWORD bytes_needed;
      PRIVILEGE_SET ps;
      DWORD ps_len = sizeof (ps);
      BOOL status;

      if (!GetKernelObjectSecurity (local_handle,
				    (OWNER_SECURITY_INFORMATION
				     | GROUP_SECURITY_INFORMATION
				     | DACL_SECURITY_INFORMATION),
				    sd, sizeof (sd_buf), &bytes_needed))
	{
	  system_printf ("error getting handle SD (%lu)", GetLastError ());
	  goto out;
	}

      MapGenericMask (&access, &access_mapping);

      if (!AccessCheck (sd, from_process_token, access, &access_mapping,
			&ps, &ps_len, &access, &status))
	{
	  system_printf ("error checking access rights (%lu)",
			 GetLastError ());
	  goto out;
	}

      if (!status)
	{
	  system_printf ("access to object denied");
	  goto out;
	}
d225 1
a225 1
 out:
a247 7

  if (!wincap.has_security ())
    {
      debug_printf ("this should not be called in a system without security");
      header.error_code = EINVAL;
      return;
    }
@


1.1.2.15
log
@	* cygserver.cc: Throughout the code, check and correct level of
	the XXX_printf() functions used. Comment out several of the
	debug_printf() calls with "// verbose:".  Reformat and correct
	typos of some of the XXX_printf() formats.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* cygserver_transport_sockets.cc: Ditto.
	* shm.cc (hi_ulong): New function to allow printing of a 64-bit
	key with current small_printf implementation.
	(lo_ulong): Ditto.
	(client_request_shm::client_request_shm): Use hi_ulong() and
	lo_ulong() in call to debug_printf().
@
text
@d229 1
a229 2

  // verbose: debug_printf ("Duplicated %p to %p", from_handle, *to_handle_ptr);
d259 1
a259 1
      system_printf ("this should not be called in a system without security");
d270 3
a272 6
  const HANDLE from_master_orig = req.from_master;
  const HANDLE to_master_orig = req.to_master;

  // verbose: debug_printf ("pid %ld:(%p,%p) -> pid %ld", req.master_pid,
  //				req.from_master, req.to_master,
  //				req.pid);
d274 1
a274 1
  // verbose: debug_printf ("opening process %ld", req.master_pid);
d276 1
a276 1
  // verbose: debug_printf ("opening process %ld", req.pid);
d285 1
a285 1
  // verbose: debug_printf ("Impersonating client");
d288 1
a288 1
  // verbose: debug_printf ("about to open thread token");
d294 1
a294 1
  // verbose: debug_printf ("opened thread token, rc=%lu", rc);
d331 2
a332 3
  debug_printf ("%lu(%lu, %lu) -> %lu(%lu,%lu)",
		req.master_pid, from_master_orig, to_master_orig,
		req.pid, req.from_master, req.to_master);
d438 1
a438 1
  // verbose: debug_printf ("about to read");
d446 1
a446 1
  // verbose: debug_printf ("got header (%ld)", bytes_read);
d461 1
a461 1
      system_printf ("Bad client request - returning ENOSYS");
d466 1
a466 1
      system_printf ("Mismatch in request buffer sizes");
d476 1
a476 1
	  system_printf ("error reading from connection (%lu)", GetLastError ());
d479 1
a479 1
      // verbose: debug_printf ("got body (%ld)",bytes_read);
d494 1
a494 1
  // verbose: debug_printf("Sent reply, size (%ld)",bytes_written);
@


1.1.2.16
log
@	* cygserver.cc (class server_request): Add virtual destructor.
	(server_request_queue::addConnection): New method to replace bad
	virtual add() method.
	(request_loop): Replace call to queue->add() with call to
	queue->addConnection().
	(server_request::server_request): Use field initialization.
	(server_request::~server_request): New virtual destructor.
	(server_request::process): Remove close and delete of
	transport_layer_base object. It is deleted by the server_request's
	own destructor and closed by its own destructor.
	* include/cygwin/cygserver.h
	(client_request::operator request_header): Remove unused method.
	* cygserver_client.cc: Ditto.
	* include/cygwin/cygserver_process.h
	(class cleanup_routine): Add virtual destructor.
	(cleanup_routine::cleanup): Make pure virtual.
	(class process_cache): Make destructor non-virtual.
	(process_cache::add): Ditto.
	* cygserver_process.cc
	(cleanup_routine::~cleanup_routine): New virtual destructor.
	* include/cygwin/cygserver_transport.h
	(class transport_layer_base): Add virtual destructor.
	* cygserver_transport.cc
	(transport_layer_base::~transport_layer_base): New virtual
	destructor.
	* include/cygwin/cygserver_transport_pipes.h
	(class transport_layer_pipes): Add virtual destructor.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::~transport_layer_pipes): New virtual
	destructor.
	(transport_layer_pipes::close): Null out handle after closing.
	* include/cygwin/cygserver_transport_sockets.h
	(class transport_layer_sockets): Add virtual destructor.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::~transport_layer_sockets): New virtual
	destructor.
	(transport_layer_sockets::close): Null out fd after closing.
	* threaded_queue.h (class queue_request): Add virtual destructor.
	(queue_request::process): Make pure virtual.
	* threaded_queue.cc (~queue_request): New virtual destructor.
	(queue_request::process): Remove definition of pure virtual
	method.
@
text
@d368 2
a369 4
    server_request (transport_layer_base *newconn,
		    class process_cache *newcache);
    virtual ~server_request();
    virtual void process ();
d388 1
a388 1
    void addConnection (transport_layer_base *conn);
d407 1
a407 1
	 queue->addConnection (new_conn);
d431 1
a431 6
server_request::server_request (transport_layer_base *newconn,
				class process_cache *newcache)
  : conn(newconn), cache(newcache)
{}

server_request::~server_request ()
d433 2
a434 1
  delete conn;
d503 2
d510 1
a510 1
server_request_queue::addConnection (transport_layer_base *conn)
d518 1
d524 1
a524 1
  add (listrequest);
@


1.1.2.17
log
@	* include/cygwin/cygserver.h (client_request::serve): Make pure
	virtual.
	* cygserver.cc (client_request::serve): Remove definition of pure
	virtual method.
	(class client_request_invalid): New class.
	(server_request::process): Use new client_request_invalid
	class. And remove goto's.
@
text
@d242 9
a364 25
/*
 * class client_request_invalid
 *
 * Used by server_request::process() to handle unrecognised client
 * requests.  Apart from error reporting (to the log and to the
 * client), its main purpose is to provide an implementation of the
 * (pure virtual) serve() method that server_request::process() can
 * call.
 */

class client_request_invalid : public client_request
{
public:
  client_request_invalid (const request_header * const hdr)
    : client_request (CYGSERVER_REQUEST_INVALID, 0)
  {
      header.error_code = ENOSYS;
      system_printf ("invalid request [type = %d]: returning ENOSYS",
		     hdr->req_id);
  };

  virtual void serve (transport_layer_base *, class process_cache *)
  {};
};

d455 1
a455 1
      return;
d468 1
a468 1
      req = new client_request_shm (); break;
d470 3
a472 1
      req = new client_request_invalid (req_ptr); break;
a474 2
  assert (req);

d478 1
a478 2
      delete req;
      return;
d483 1
d488 1
a488 2
	  delete req;
	  return;
d502 1
a502 2
      delete req;
      return;
d508 3
a510 1
  delete (req);
@


1.1.2.18
log
@	* cygserver.cc (version): New static variable.
	(server_request_queue::add_connection): Remove my gratuitous use
	of studly caps.
	(setup_privileges): Declare static.
	(handle_signal): Ditto.
	(longopts): Make a local variable of main().
	(opts): Ditto.
	(print_usage): New function.
	(print_version): Ditto (tip of the hat to Joshua Daniel Franklin
	for inspiration here).
	(main): More argument checking.  Add --help and --version options.
@
text
@d7 1
a7 1
This file is part of Cygwin.
d9 3
a11 3
This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */
a14 3
#include <sys/socket.h>
#include <sys/types.h>

d18 4
a21 1
#include <getopt.h>
a23 1
#include <stdio.h>
d25 1
a25 4
#include <string.h>
#include <unistd.h>

#include <ostream.h>
d27 1
a27 1
#include "cygwin_version.h"
a28 3
#include "cygserver_shm.h"
#include "cygwin/cygserver.h"
#include "cygwin/cygserver_process.h"
d33 3
d38 1
a41 3
// Version string.
static const char version[] = "$Revision$";

d116 1
a116 1
static BOOL
d406 1
a406 1
    void add_connection (transport_layer_base *conn);
d425 1
a425 1
	 queue->add_connection (new_conn);
d530 1
a530 1
server_request_queue::add_connection (transport_layer_base *conn)
d547 1
a547 1
static void
d558 4
a561 38
/*
 * print_usage()
 */

static void
print_usage (const char * const pgm)
{
  cout << "Usage: " << pgm << "[OPTIONS]\n"
       << ( "  -h, --help       output usage information and exit\n"
	    "  -s, --shutdown   shutdown the current instance of the daemon\n"
	    "  -v, --version    output version information and exit\n" )
       << flush;
}

/*
 * print_version()
 */

static void
print_version (const char * const pgm)
{
  char * vn = NULL;

  const char * colon = strchr (version, ':');

  if (!colon)
    {
      vn = strdup ("?");
    }
  else
    {
      vn = strdup (colon + 2);	// Skip ": "

      char * const spc = strchr (vn, ' ');

      if (spc)
	*spc = '\0';
    }
d563 1
a563 26
  char buf[200];
  snprintf (buf, sizeof (buf), "%d.%d.%d(%d.%d/%d/%d)-(%d.%d.%d.%d) %s",
	    cygwin_version.dll_major / 1000,
	    cygwin_version.dll_major % 1000,
	    cygwin_version.dll_minor,
	    cygwin_version.api_major,
	    cygwin_version.api_minor,
	    cygwin_version.shared_data,
	    CYGWIN_SERVER_VERSION_MAJOR,
	    CYGWIN_SERVER_VERSION_API,
	    CYGWIN_SERVER_VERSION_MINOR,
	    CYGWIN_SERVER_VERSION_PATCH,
	    cygwin_version.mount_registry,
	    cygwin_version.dll_build_date);

  cout << pgm << " (cygwin) " << vn << endl
       << "API version " << buf << endl
       << "Copyright 2001, 2002 Red Hat, Inc." << endl
       << "Compiled on " __DATE__ << endl;

  free (vn);
}

/*
 * main()
 */
d566 1
a566 1
main (const int argc, char *argv[])
d568 2
a569 12
  const struct option longopts[] = {
    {"help", no_argument, NULL, 'h'},
    {"shutdown", no_argument, NULL, 's'},
    {"version", no_argument, NULL, 'v'},
    {0, no_argument, NULL, 0}
  };

  const char opts[] = "hsv";

  bool shutdown = false;

  const char * pgm = NULL;
d571 2
a572 13
  if (!(pgm = strrchr (*argv, '\\')) && !(pgm = strrchr (*argv, '/')))
    pgm = *argv;
  else
    pgm++;

  wincap.init();
  if (wincap.has_security ())
    setup_privileges ();

  int opt;

  while ((opt = getopt_long (argc, argv, opts, longopts, NULL)) != EOF)
    switch (opt)
a573 4
      case 'h':
	print_usage (pgm);
	return 0;

d575 3
a577 1
	shutdown = true;
d579 1
a579 8

      case 'v':
	print_version (pgm);
	return 0;

      case '?':
	cerr << "Try `" << pgm << " --help' for more information." << endl;
	return 1;
d582 4
a585 9
  if (optind != argc)
    {
      cerr << pgm << ": too many arguments" << endl;
      return 1;
    }

  transport_layer_base * const transport = create_server_transport ();

  assert (transport);
d592 1
a592 1
	  return 1;
d594 3
a596 3

      client_request_shutdown request;
      request.send (transport);
d598 20
a617 3
      return 0;
    }

d619 1
a619 2
  printf ("daemon starting up");
  print_version (pgm);
d650 1
a650 1
  */
@


1.1.2.19
log
@	* include/cygwin/cygserver.h: Change the client_request classes to
	give greater encapsulation and to allow variable length requests
	and replies.
	(enum cygserver_request_code): Now client_request::request_code_t.
	(class request_header): Now client_request::header_t.  Make a
	union of the request_code and the error_code.  The `cb' field,
	which was the buffer length, is now the `size_t msglen' field.
	(struct request_get_version): Now
	client_request_get_version::request_get_version.
	(struct request_shutdown): Remove unused type.
	(struct request_attach_tty): Now
	client_request_attach_tty::request_attach_tty.
	(client_request::_buf): Make field const.
	(client_request::_buflen): New const private field.
	(client_request::request_code): New accessor.
	(client_request::error_code): Ditto.
	(client_request::msglen): Ditto.
	(client_request::handle_request): New static method.
	(client_request::make_request): New virtual method.
	(client_request::handle): New method.
	(client_request::send): Make private.
	(client_request_get_version::check_version): New method.
	(client_request_get_version::serve): Make private.
	(client_request_get_version::version): Ditto.
	(client_request_shutdown::serve): Ditto.
	(client_request_attach_tty::req): Ditto.
	(client_request_attach_tty::serve): Ditto.
	(client_request_attach_tty::from_master): Make method const.
	(client_request_attach_tty::from_master): Ditto.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Track
	changes to the client_request classes.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	(client_request_get_version::check_version): New method to
	encapsulate code from cygserver_init().
	(client_request_shutdown::client_request_shutdown): Move into
	"cygserver.cc".
	(client_request::send): Track changes to the client_request
	classes.  Add more error checking.
	(client_request::handle_request): New static method containing the
	first half of the old server_request::process() code.
	(client_request::make_request): New method to replace the old
	cygserver_request() function.
	(client_request::handle): New method containing the second half of
	the old server_request::process() code.
	(cygserver_init): Track changes to the client_request classes.  In
	particular, some code moved into the
	client_request_get_version::check_version() method.
	* cygserver.cc (client_request_attach_tty::serve): Track changes
	to the client_request classes.  In particular, only return a reply
	body if some handles are successfully duplicated for the client.
	And remove goto's.
	(client_request_get_version::serve): Track changes to the
	client_request classes.
	(client_request_shutdown::serve): Ditto.
	(class client_request_invalid): Dead, and so young too.
	(server_request::request_buffer): Remove unnecessary field.
	(client_request_shutdown::client_request_shutdown): Moved here
	from "cygserver_client.cc".
	(server_request::process): Implementation moved into the new
	client_request::handle_request() and client_request::handle()
	methods.
	* cygserver_shm.h (class client_request_shm): Put client- and
	server-specific interfaces inside #ifdef/#ifndef __INSIDE_CYGWIN__
	guards.
	(client_request_shm::serve): Make private.
	* cygserver_shm.cc
	(client_request_shm::client_request_shm): Track changes to the
	client_request classes.
	(client_request_shm::serve): Ditto
	* shm.cc (client_request_shm::client_request_shm): Ditto.  Use
	alloc_sd() rather than set_security_attribute() to get access to
	the SECURITY_DESCRIPTOR length, so that we can use it to set the
	request body length.
	(shmat): Track changes to the client_request classes. In
	particular, allocate client_request objects on the stack rather
	than on the heap, and use the client_request::make_request()
	method rather than the old cygserver_request() function.
	(shmdt): Ditto.
	(shmctl): Ditto.
	(shmget): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::cygserver_attach_tty): Ditto.
@
text
@d46 1
a46 1
static const char version[] = "$Revision: 1.1.2.18 $";
a246 4
/*
 * client_request_attach_tty::serve ()
 */

d248 1
a248 2
client_request_attach_tty::serve (transport_layer_base * const conn,
				  process_cache *)
d250 4
a253 3
  assert (conn);

  assert (!error_code ());
d257 2
a258 3
      syscall_printf ("operation only supported on systems with security");
      error_code (EINVAL);
      msglen (0);
d262 1
a262 1
  if (msglen () != sizeof (req))
d264 1
a264 4
      syscall_printf ("bad request body length: expecting %lu bytes, got %lu",
		      sizeof (req), msglen ());
      error_code (EINVAL);
      msglen (0);
d268 2
a269 1
  msglen (0);			// Until we fill in some fields.
d272 1
a272 1
  //				from_master, to_master,
d276 1
a276 12

  const HANDLE from_process_handle =
    OpenProcess (PROCESS_DUP_HANDLE, FALSE, req.master_pid);

  if (!from_process_handle)
    {
      system_printf ("error opening `from' process, error = %lu",
		     GetLastError ());
      error_code (EACCES);
      return;
    }

d278 2
a279 5

  const HANDLE to_process_handle =
    OpenProcess (PROCESS_DUP_HANDLE, FALSE, req.pid);

  if (!to_process_handle)
d281 3
a283 5
      system_printf ("error opening `to' process, error = %lu",
		     GetLastError ());
      CloseHandle (from_process_handle);
      error_code (EACCES);
      return;
a288 2
  HANDLE token_handle = NULL;

d290 4
a293 4
  const DWORD rc = OpenThreadToken (GetCurrentThread (),
				    TOKEN_QUERY,
				    TRUE,
				    &token_handle);
d300 12
a311 1
      system_printf ("error opening thread token, error = %lu",
d313 2
a314 4
      CloseHandle (from_process_handle);
      CloseHandle (to_process_handle);
      error_code (EACCES);
      return;
d317 14
a330 37
  // From this point on, a reply body is returned to the client.

  const HANDLE from_master = req.from_master;
  const HANDLE to_master = req.to_master;

  req.from_master = NULL;
  req.to_master = NULL;

  msglen (sizeof (req));

  if (from_master)
    if (check_and_dup_handle (from_process_handle, to_process_handle,
			      token_handle,
			      GENERIC_READ,
			      from_master,
			      &req.from_master, TRUE) != 0)
      {
	system_printf ("error duplicating from_master handle, error = %lu",
		       GetLastError ());
	error_code (EACCES);
      }

  if (to_master)
    if (check_and_dup_handle (from_process_handle, to_process_handle,
			      token_handle,
			      GENERIC_WRITE,
			      to_master,
			      &req.to_master, TRUE) != 0)
      {
	system_printf ("error duplicating to_master handle, error = %lu",
		       GetLastError ());
	error_code (EACCES);
      }

  CloseHandle (from_process_handle);
  CloseHandle (to_process_handle);
  CloseHandle (token_handle);
d333 1
a333 1
		req.master_pid, from_master, to_master,
d336 9
a344 1
  return;
d348 1
a348 1
client_request_get_version::serve(transport_layer_base *, process_cache *)
d350 6
a355 7
  assert (!error_code ());

  if (msglen ())
    syscall_printf ("unexpected request body ignored: %lu bytes", msglen ());

  msglen (sizeof (version));

d362 25
d395 1
a413 1

a444 6
client_request_shutdown::client_request_shutdown ()
  : client_request (CYGSERVER_REQUEST_SHUTDOWN)
{
  syscall_printf ("created");
}

d446 1
a446 1
client_request_shutdown::serve (transport_layer_base *, process_cache *)
a447 5
  assert (!error_code ());

  if (msglen ())
    syscall_printf ("unexpected request body ignored: %lu bytes", msglen ());

d452 1
a452 3
  request_queue.active = false;

  msglen (0);
d468 65
a532 1
  client_request::handle_request (conn, cache);
d683 4
d689 5
a693 4
      client_request_shutdown req;

      if (req.make_request () == -1 || req.error_code ())
	return 1;
d695 3
a699 4

  transport_layer_base * const transport = create_server_transport ();

  assert (transport);
@


1.1.2.20
log
@	* cygserver.cc (main): Adjust tracing output for a cleaner display
	when compiled without --enable-debugging.
	* threaded_queue.cc (threaded_queue::cleanup): Ditto.
	(queue_process_param::stop): Ditto.
	* include/cygwin/cygserver.h
	(client_request::make_request): Make non-virtual.
	(client_request::send): Make virtual and protected, not private.
	(client_request_attach_tty::send): New virtual method.
	* cygserver_client.cc: Use the `msglen()' accessor rather than
	`_header.msglen' throughout.
	(client_request_attach_tty::send): New method.
	(client_request::make_request): Remove the explicit close of
	`transport' as it is closed on deletion.
@
text
@d46 1
a46 1
static const char version[] = "$Revision: 1.1.2.19 $";
a652 1
  print_version (pgm);
d655 1
@


1.1.2.21
log
@	* woutsup.h (cygserver_running): Add declaration.
	(api_fatal): Eliminate.
	* include/cygwin/cygserver.h
	(client_request_get_version::check_version): Change return type to
	bool.
	(check_cygserver_available): New function.
	(cygserver_init): Add check_version_too argument.
	* cygserver_client.cc (allow_daemon): Make a bool.
	(client_request_get_version::make_request): See errno on error.
	Remove special case for CYGSERVER_REQUEST_GET_VERSION; this is now
	handled in cygserver_init().
	(client_request_get_version::check_version): Use syscall_printf()
	instead of api_fatal(). Return true if cygserver version is
	compatible.
	(check_cygserver_available): New function; code moved here from
	cygserver_init().
	(cygserver_init): Move some code into check_cygserver_available().
	* cygserver.cc (__set_errno): Copy from debug.cc so that
	set_errno() can be used when __OUTSIDE_CYGWIN__.
	(main): Call cygserver_init() to set up cygserver_running and add
	checks against this to (try and) prevent multiple copies of
	cygserver running simultaneously.  Remember to delete all
	transport connections so that (one day) the transport classes can
	tidy up on cygserver shutdown.
@
text
@a31 1
#include "cygerrno.h"
d46 1
a46 1
static const char version[] = "$Revision$";
a121 11
#ifdef DEBUGGING

int __stdcall
__set_errno (const char *func, int ln, int val)
{
  debug_printf ("%s:%d val %d", func, ln, val);
  return _impure_ptr->_errno = val;
}

#endif /* DEBUGGING */

d630 1
a630 1
	exit (1);
d636 1
a636 1
      exit (1);
a638 10
  /*
   * This has been run in the cygwin DLL but we use some of the DLL
   * functions, e.g. client_request::make_request() in the server so
   * we need to duplicate it all up here.  Sigh.
   */
  cygserver_init (false);		// false == don't check version

  assert (   cygserver_running == CYGSERVER_OK		\
	  || cygserver_running == CYGSERVER_DEAD);

a640 6
      if (cygserver_running != CYGSERVER_OK)
	{
	  cout << pgm << ": cygserver is not running" << endl;
	  exit (1);
	}

d644 1
a644 7
	{
	  cout << pgm << ": shutdown request failed: "
	       << strerror(errno) << endl;
	  exit (1);
	}

      // FIXME: It would be nice to wait here for the daemon to exit.
d649 3
a651 5
  if (cygserver_running == CYGSERVER_OK)
    {
      cout << pgm << ": cygserver is already running" << endl;
      exit (1);
    }
d653 3
d662 1
a662 7

  transport_layer_base * const transport = create_server_transport ();
  assert (transport);

  print_version (pgm);
  setbuf (stdout, NULL);
  printf ("daemon starting up");
d694 1
a694 1
  delete transport;
a698 2

  return 0;
@


1.1.2.22
log
@	* cygserver.cc: The tests for a duplicate server instance are now
	the responsibility of the transport layer.
	(request_loop): Use new `recoverable' flag in call to
	`cygserver_transport::accept ()' and shutdown on an unrecoverable
	error.
	(main): Never call `cygserver_init ()'.  Fake `cygserver_running'
	just for sending a shutdown request.
	* cygserver_client.cc (client_request::send): Comment out
	message-size tracing statements as verbose.
	(client_request::handle): Ditto.
	(client_request_get_version::check_version): #ifdef as DLL-only.
	(check_cygserver_available): Ditto.
	(cygserver_init): Ditto.
	* include/cygwin/cygserver.h
	(client_request_get_version::check_version): #ifdef as DLL-only.
	(check_cygserver_available): Ditto.
	(cygserver_init): Ditto.
	* include/cygwin/cygserver_transport.h
	(transport_layer_base::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_base::revert_to_self): Ditto.
	(transport_layer_base::listen): Ditto.
	(transport_layer_base::accept): Ditto.  Add a `recoverable' out
	flag for error handling.
	* include/cygwin/cygserver_transport_sockets.h: Ditto.
	* include/cygwin/cygserver_transport_pipes.h: Ditto.
	(transport_layer_pipes): Change type of the `pipe_name' field.
	Remove the `inited' field, as unnecessary.  Add new
	`is_accepted_endpoint' field.
	* include/cygwin/cygserver_transport.cc
	(transport_layer_base::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_base::revert_to_self): Ditto.
	* include/cygwin/cygserver_transport_sockets.cc
	(transport_layer_sockets::listen): #ifdef as cygserver-only.
	(transport_layer_sockets::accept): #ifdef as cygserver-only.
	Analyse any errno from `accept ()' and set `recoverable' as
	appropriate.
	* cygserver_transport_pipes.cc: Add local #define of
	`FILE_FLAG_FIRST_PIPE_INSTANCE'.
	(pipe_instance_lock_once): New variable.
	(pipe_instance_lock): Ditto.
	(pipe_instance): Ditto.
	(initialise_pipe_instance_lock): New function.
	(transport_layer_pipes::transport_layer_pipes): Change
	initialization of `pipe_name'.  Initialize `is_accepted_endpoint'
	as appropriate.  Remove use of `inited'.
	(transport_layer_pipes::impersonate_client): #ifdef as
	cygserver-only.
	(transport_layer_pipes::revert_to_self): Ditto.
	(transport_layer_pipes::listen): Ditto.
	(transport_layer_pipes::accept): Ditto.  Keep track of how often
	many named pipes have been created, in the `pipe_instance'
	variable, and pass the `FILE_FLAG_FIRST_PIPE_INSTANCE' flag on the
	open of the first instance.  Analyse the error code from
	`CreateNamedPipe ()' and set the `recoverable' flag as
	appropriate.
	(transport_layer_pipes::close): Update the `pipe_instance' count.
@
text
@d443 1
a443 7
    bool recoverable = false;
    transport_layer_base * const new_conn = transport->accept (&recoverable);
    if (!new_conn && !recoverable)
      {
	system_printf ("fatal error on IPC transport: closing down");
	queue->active = false;
      }
d651 10
d663 5
a667 2
      // Needed for client_request::make_request ().
      cygserver_running = CYGSERVER_OK;
d681 6
@


1.1.2.23
log
@	* include/cygwin/cygserver.h: Add forward declarations of class
	transport_layer_base and class process_cache to reduce
	dependencies between header files.
	* include/cygwin/cygserver_process.h: Add include of
	"threaded_queue.h".
	* cygserver.cc: Remove unnecessary cygserver header files.
	* cygserver_client.cc: Ditto.
	* cygserver_process.cc: Ditto.
	* cygserver_shm.cc: Ditto.
	* cygserver_shm.h: Ditto.
	* cygserver_transport_pipes.cc: Ditto.
	* dcrt0.cc: Ditto.
	* fhandler_tty.cc: Ditto.
	* tty.cc: Ditto.
@
text
@d31 1
a32 1
#include "cygwin_version.h"
d34 1
d38 3
@


1.1.2.24
log
@	* threaded_queue.h (class queue_request): Re-write.
	(threaded_queue_thread_function): Remove.
	(class queue_process_param): Remove.
	(class threaded_queue): Re-write.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	(TInterlockedExchangePointer): New templated function.
	(TInterlockedCompareExchangePointer): Ditto.
	* threaded_queue.cc (worker_function): Remove.
	(class threaded_queue): Re-write.
	(class queue_process_param): Remove.
	(class queue_submission_loop): New version of the old
	`queue_process_param' class.
	* include/cygwin/cygserver_process.h (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver_process.cc (process_cleanup): Re-write.
	(class process_process_param): Remove.
	(class cleanup_routine): Re-write.
	(class process): Re-write.
	(class process_cache): Re-write.
	* cygserver.cc (request_count): Remove unused variable.
	(class server_request): Move methods inline.
	(class server_process_param): Remove.
	(class server_request_queue): Remove.
	(request_queue): Move into `main ()' and change type to
	`threaded_queue'.
	(request_loop): Remove.
	(class server_submission_loop): New version of the old
	`server_process_param' class.
	(shutdown_server): New variable.
	(client_request_shutdown::serve): Set `shutdown_server' to trigger
	shutdown.
	(handle_signal): Ditto.
	(main): Install signal handler for SIGINT rather than SIGQUIT.
	Use new interfaces for the `request_queue' and the `cache'.
	Create a `server_submission_loop' and add to the `request_queue'.
	Add check for the `shutdown_server' variable to the main loop.
	* cygserver_shm.cc (client_request_shm::serve): Release the
	process object after use.
@
text
@d15 1
d22 1
d38 4
a129 2
GENERIC_MAPPING access_mapping;

d260 1
a260 1
client_request_attach_tty::serve (transport_layer_base *const conn,
d286 3
a288 3
  // verbose: debug_printf ("pid %ld:(%p,%p) -> pid %ld",
  //			    req.master_pid, req.from_master, req.to_master,
  //			    req.pid);
d404 9
a412 4
public:
  server_request (transport_layer_base *const conn, process_cache *const cache)
    : _conn (conn), _cache (cache)
  {}
d414 6
a419 4
  virtual ~server_request()
  {
    delete _conn;
  }
d421 7
a427 4
  virtual void process ()
  {
    client_request::handle_request (_conn, _cache);
  }
d429 1
a429 4
private:
  transport_layer_base *const _conn;
  process_cache *const _cache;
};
d431 2
a432 1
class server_submission_loop : public queue_submission_loop
d434 4
a437 7
public:
  server_submission_loop (threaded_queue *const queue,
			  transport_layer_base *const transport,
			  process_cache *const cache)
    : queue_submission_loop (queue, false),
      _transport (transport),
      _cache (cache)
d439 14
a452 2
    assert (_transport);
    assert (_cache);
d454 2
d457 1
a457 13
private:
  transport_layer_base *const _transport;
  process_cache *const _cache;

  virtual void request_loop ();
};

/* FIXME: this is a little ugly.  What we really want is to wait on
 * two objects: one for the pipe/socket, and one for being told to
 * shutdown.  Otherwise this will stay a problem (we won't actually
 * shutdown until the request _AFTER_ the shutdown request.  And
 * sending ourselves a request is ugly
 */
d459 1
a459 1
server_submission_loop::request_loop ()
d461 3
a463 12
  while (_running)
    {
      bool recoverable = false;
      transport_layer_base *const conn = _transport->accept (&recoverable);
      if (!conn && !recoverable)
	{
	  system_printf ("fatal error on IPC transport: closing down");
	  return;
	}
      if (conn)
	_queue->add (new server_request (conn, _cache));
    }
a471 2
static volatile sig_atomic_t shutdown_server = false;

d483 2
d486 12
a497 1
  shutdown_server = true;
d499 22
a520 1
  msglen (0);
d527 5
a531 2

  shutdown_server = true;
d672 1
a672 1
  if (signal (SIGINT, handle_signal) == SIG_ERR)
d679 2
d685 1
a685 6

  threaded_queue request_queue (10);
  printf (".");

  transport_layer_base *const transport = create_server_transport ();
  assert (transport);
d687 4
a690 2

  process_cache cache (2);
d692 1
a692 2

  server_submission_loop submission_loop (&request_queue, transport, &cache);
d694 1
a694 2

  request_queue.add_submission_loop (&submission_loop);
d696 9
a704 20

  transport->listen ();
  printf (".");

  cache.start ();
  printf (".");

  request_queue.start ();
  printf (".");

  printf ("complete\n");

  /* TODO: wait on multiple objects - the thread handle for each
   * request loop + all the process handles. This should be done by
   * querying the request_queue and the process cache for all their
   * handles, and then waiting for (say) 30 seconds.  after that we
   * recreate the list of handles to wait on, and wait again.  the
   * point of all this abstraction is that we can trivially server
   * both sockets and pipes simply by making a new transport, and then
   * calling request_queue.process_requests (transport2);
d709 4
a712 3
  while (!shutdown_server && request_queue.running () && cache.running ())
    sleep (1);

d714 1
a714 1
  request_queue.stop ();
d718 1
a718 1
  cache.stop ();
@


1.1.2.25
log
@	* woutsup.h: Remove all uses of the C++ new and delete operators
	throughout cygserver until they are fully thread-safe.
	(safe_new0): New macro to replace the C++ new operator.
	(safe_new): Ditto.
	(safe_delete): New macro to replace the C++ delete operator.
	* cygserver_client.cc (client_request::handle_request): Replace
	all uses of the C++ new and delete operators with the new macros
	from "woutsup.h".
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	(process_cache::check_and_remove_process): Ditto.
	* cygserver_shm.cc (server_shmmgr::new_segment): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* cygserver_transport.cc (create_server_transport): Ditto.
	* cygserver_transport_pipes.cc
	(transport_layer_pipes::accept): Ditto.
	* cygserver_transport_sockets.cc
	(transport_layer_sockets::accept): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.
	(threaded_queue::stop): Replace sleep(3) with win32 Sleep.
	* cygserver.cc (~server_request): Replace all uses of the C++ new
	and delete operators with the new macros from "woutsup.h".
	(server_submission_loop::request_loop): Ditto.
	(main): Ditto.  Replace sleep(3) with win32 Sleep.  Replace
	iostreams with FILEs.
	(print_usage): Replace iostreams with FILEs.
	(print_version): Ditto.
@
text
@d27 2
d81 1
a81 1
__cygserver__printf (const char *const function, const char *const fmt, ...)
d88 1
a88 1
  char *const buf = (char *) alloca(BUFSIZ);
d175 1
a175 1
		      HANDLE *to_handle_ptr, BOOL bInheritHandle = FALSE)
d407 1
a407 1
    safe_delete (transport_layer_base, _conn);
d460 1
a460 1
	_queue->add (safe_new (server_request, conn, _cache));
d490 1
a490 1
handle_signal (const int signum)
d502 1
a502 1
print_usage (const char *const pgm)
d504 5
a508 4
  printf ("Usage: %s [OPTIONS]\n", pgm);
  printf ("  -h, --help       output usage information and exit\n");
  printf ("  -s, --shutdown   shutdown the current instance of the daemon\n");
  printf ("  -v, --version    output version information and exit\n");
d516 1
a516 1
print_version (const char *const pgm)
d518 1
a518 1
  char *vn = NULL;
d520 1
a520 1
  const char *const colon = strchr (version, ':');
d530 1
a530 1
      char *const spc = strchr (vn, ' ');
d551 4
a554 4
  printf ("%s (cygwin) %s\n", pgm, vn);
  printf ("API version %s\n", buf);
  printf ("Copyright 2001, 2002 Red Hat, Inc.\n");
  printf ("Compiled on %s\n", __DATE__);
d577 1
a577 1
  const char *pgm = NULL;
d606 1
a606 1
	fprintf (stderr, "Try `%s --help' for more information.\n", pgm);
d612 1
a612 1
      fprintf (stderr, "%s: too many arguments\n", pgm);
d625 2
a626 2
	  fprintf (stderr, "%s: shutdown request failed: %s\n",
		   pgm, strerror (errno));
d642 1
d687 1
a687 1
    Sleep (1000);
d692 1
a692 1
  safe_delete (transport_layer_base, transport);
@


1.1.2.26
log
@	* dcrt0.cc: Only check for cygserver if and when required.
	(dll_crt0_1): Remove call to `cygserver_init ()'.
	* fhandler_tty.cc (fhandler_tty_slave::open): Change the cygserver
	logic to allow for the fact that `cygserver_init ()' may not yet
	have been called.
	(fhandler_tty_slave::cygserver_attach_tty): Tweak the cygserver
	request logic to conform to the practice elsewhere in the code.
	* tty.cc (tty::common_init): Add an explicit call to
	`cygserver_init ()' if it hasn't already been called.
	* include/cygwin/cygserver.h (CYGSERVER_UNAVAIL): Rename from
	`CYGSERVER_DEAD'.
	(client_request_get_version::check_version): Make available in
	cygserver as well the DLL.
	(check_cygserver_available): Ditto.  Remove `check_version_too'
	argument.
	(cygserver_init): Ditto.  And likewise.
	* cygserver_client.cc (client_request_get_version::check_version):
	Make available in cygserver as well the DLL.
	(client_request::make_request): This may now be called without
	`cygserver_init ()' having been called first.  Detect this and
	call it as required.  Add tracing.
	(check_cygserver_available): Make available in cygserver as well
	the DLL.  Remove `check_version_too' argument and always check the
	version information.  And since this is called from within
	`cygserver_init ()', force `cygserver_running' before calling
	`client_request::make_request ()'.
	(cygserver_init): Make available in cygserver as well the DLL.
	Remove `check_version_too' argument.
@
text
@d615 1
a615 3
      /* Setting `cygserver_running' stops the request code making a
       * version request, which is not much to the point.
       */
@


1.1.2.27
log
@	* cygserver.cc (client_request_shutdown::serve): Don't set the
	shutdown flag directly, but send a SIGINT, as the signal handler
	sets the flag and the signal breaks the pause(2) in the main loop.
	(print_usage): Add new options.
	(main): Add new --cleanup-threads and --request-threads options to
	set the number of threads used by the daemon.  Use pause(2) rather
	the win32 Sleep in the main loop.
	* shm.cc (shmat): Add sigframe.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.
@
text
@d468 2
d482 1
a482 1
  kill (getpid (), SIGINT);
a486 2
static sig_atomic_t shutdown_server = false;

d503 3
a505 5
  printf ("  -c, --cleanup-threads   number of cleanup threads to use\n");
  printf ("  -h, --help              output usage information and exit\n");
  printf ("  -r, --request-threads   number of request threads to use\n");
  printf ("  -s, --shutdown          shutdown the daemon\n");
  printf ("  -v, --version           output version information and exit\n");
a563 1
    {"cleanup-threads", required_argument, NULL, 'c'},
a564 1
    {"request-threads", required_argument, NULL, 'r'},
d570 1
a570 1
  const char opts[] = "c:hr:sv";
a571 2
  int cleanup_threads = 2;
  int request_threads = 10;
a589 11
      case 'c':
	cleanup_threads = atoi (optarg);
	if (cleanup_threads <= 0)
	  {
	    fprintf (stderr,
		     "%s: number of cleanup threads must be positive\n",
		     pgm);
	    exit (1);
	  }
	break;

a593 11
      case 'r':
	request_threads = atoi (optarg);
	if (request_threads <= 0)
	  {
	    fprintf (stderr,
		     "%s: number of request threads must be positive\n",
		     pgm);
	    exit (1);
	  }
	break;

d645 1
a645 1
  threaded_queue request_queue (request_threads);
d652 1
a652 1
  process_cache cache (cleanup_threads);
d685 1
a685 1
    pause ();
@


1.1.2.28
log
@	* include/cygwin/cygserver_transport.h
	(transport_layer_base::listen): Change return type.
	(transport_layer_base::connect): Ditto.
	* include/cygwin/cygserver_transport_pipes.h
	(transport_layer_pipes::listen): Change return type.
	(transport_layer_pipes::connect): Ditto.
	(transport_layer_pipes::_sec_none_nih): Remove unused field.
	(transport_layer_pipes::_is_listening_endpoint): New field.
	* cygserver_transport_pipes.cc: Synchronize with sockets code.
	(transport_layer_pipes::transport_layer_pipes): Initialise new
	field.  Separate out asserts.
	(transport_layer_pipes::listen): Change return type.  Add asserts.
	(transport_layer_pipes::accept): Add asserts.
	(transport_layer_pipes::read): Change conditional to an assert.
	Add assert.
	(transport_layer_pipes::write): Ditto.
	(transport_layer_pipes::connect): Change return type.  Change
	conditional to an assert.  Add asserts.  Rationalize error code
	slightly.
	(transport_layer_pipes::impersonate_client): Add asserts.
	* include/cygwin/cygserver_transport_sockets.h
	(transport_layer_sockets::listen): Change return type.
	(transport_layer_sockets::connect): Ditto.
	(transport_layer_sockets::_addr): Change type of field.
	(transport_layer_sockets::_addr_len): Ditto.
	(transport_layer_sockets::_is_accepted_endpoint): New field.
	(transport_layer_sockets::_is_listening_endpoint): Ditto.
	* cygserver_transport_sockets.cc
	(MAX_CONNECT_RETRY): New constant.
	(transport_layer_sockets::transport_layer_sockets): Initialise new
	fields.  Only initialise the socket address where necessary.
	(transport_layer_sockets::listen): Change return type.  Rewrite.
	(transport_layer_sockets::accept): Add asserts.  Add tracing
	statements.  Use a local variable to hold the accepted address.
	(transport_layer_sockets::close): Add tracing statements.  Unlink
	the UNIX domain socket file as appropriate.  Close the socket
	cleanly.
	(transport_layer_sockets::read): Rewrite method.
	(transport_layer_sockets::write): Ditto.
	(transport_layer_sockets::connect): Change return type.  Rewrite.
	* cygserver.cc (server_submission_loop::request_loop): Run the
	listening thread at high priority with special handling for
	shutdown.
	(main): Print the request error code rather than errno in shutdown
	request code.  Install signal handlers with sigaction(2) to avoid
	setting SA_RESTART.  Check value of the listen method call, now it
	has one.
	* cygserver_client.cc (client_request::make_request): Check new
	return value on connect method call.
@
text
@a447 14
  /* I'd like the accepting thread's priority to be above any "normal"
   * thread in the system to avoid overflowing the listen queue (for
   * sockets; similar issues exist for named pipes); but, for example,
   * a normal priority thread in a foregrounded process is boosted to
   * THREAD_PRIORITY_HIGHEST (AFAICT).  Thus try to set the current
   * thread's priority to a level one above that.  This fails on
   * win9x/ME so assume any failure in that call is due to that and
   * simply call again at one priority level lower.
   */
  if (!SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_HIGHEST + 1))
    if (!SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_HIGHEST))
      debug_printf ("failed to raise accept thread priority, error = %lu",
		    GetLastError ());

a456 18
      // EINTR probably implies a shutdown request; so back off for a
      // moment to let the main thread take control, otherwise the
      // server spins here receiving EINTR repeatedly since the signal
      // handler in the main thread doesn't get a chance to be called.
      if (!conn && errno == EINTR)
	{
	  if (!SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_NORMAL))
	    debug_printf ("failed to reset thread priority, error = %lu",
			  GetLastError ());

	  Sleep (0);
	  if (!SetThreadPriority (GetCurrentThread (),
				  THREAD_PRIORITY_HIGHEST + 1))
	    if (!SetThreadPriority (GetCurrentThread (),
				    THREAD_PRIORITY_HIGHEST))
	      debug_printf ("failed to raise thread priority, error = %lu",
			    GetLastError ());
	}
d653 1
a653 1
		   pgm, strerror (req.error_code ()));
d662 6
a667 20
#define SIGHANDLE(SIG)							\
  do									\
    {									\
      struct sigaction act;						\
									\
      act.sa_handler = &handle_signal;					\
      act.sa_mask = 0;							\
      act.sa_flags = 0;							\
									\
      if (sigaction (SIG, &act, NULL) == -1)				\
	{								\
	  system_printf ("failed to install handler for " #SIG ": %s",	\
			 strerror (errno));				\
	  exit (1);							\
	}								\
    } while (false)

  SIGHANDLE (SIGHUP);
  SIGHANDLE (SIGINT);
  SIGHANDLE (SIGTERM);
d689 1
a689 4
  if (transport->listen () == -1)
    {
      exit (1);
    }
@


1.1.2.29
log
@	* cygserver.cc (client_request_shutdown::client_request_shutdown):
	Comment out verbose tracing statement.
	* cygserver_client.cc
	(client_request_get_version::client_request_get_version): Ditto.
	(client_request_attach_tty::client_request_attach_tty): Ditto.
	* cygserver_shm.cc (client_request_shm::client_request_shm):
	Ditto.
@
text
@d497 1
a497 1
  // verbose: syscall_printf ("created");
@


1.1.2.30
log
@	* safe_memory.h (safe_delete): Make a templated function.
	* cygserver.cc (~server_request): Update use of safe_delete.
	(main): Ditto.
	* cygserver_client.cc (client_request::handle_request): Ditto.
	(client_request::make_request): Ditto.
	* cygserver_process.cc (~process_cleanup): Ditto.
	(process::remove): Ditto.
	(process::cleanup): Ditto.
	(process_cache::process): Ditto.
	* cygserver_shm.cc (server_shmmgr::segment_t::detach): Ditto.
	(server_shmmgr::delete_segment): Ditto.
	* shm.cc (client_shmmgr::shmdt): Ditto.
	* threaded_queue.cc (~threaded_queue): Ditto.
	(threaded_queue::worker_loop): Ditto.
@
text
@d405 1
a405 1
    safe_delete (_conn);
d767 1
a767 1
  safe_delete (transport);
@


1.1.2.31
log
@	GNUify non-GNU formatted functions calls throughout.
@
text
@d38 1
a38 1
 * Support function for the XXX_printf () macros in "woutsup.h".
d50 1
a50 1
    else if (isspace ((int)pe[-1]))
d76 1
a76 1
 * Support function for the XXX_printf () macros in "woutsup.h".
d86 1
a86 1
  char *const buf = (char *) alloca (BUFSIZ);
d93 1
a93 1
    len += getfunc (buf, function);
d131 1
a131 1
  rc = OpenProcessToken (GetCurrentProcess () , TOKEN_ALL_ACCESS , &hToken) ;
d381 1
a381 1
client_request_get_version::serve (transport_layer_base *, process_cache *)
d403 1
a403 1
  virtual ~server_request ()
d528 1
a528 1
 * print_usage ()
d543 1
a543 1
 * print_version ()
d591 1
a591 1
 * main ()
d619 1
a619 1
  wincap.init ();
@


