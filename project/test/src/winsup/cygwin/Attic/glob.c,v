head	1.19;
access;
symbols
	cr-0x5f1:1.18.0.8
	cv-branch:1.18.0.6
	pre-ptymaster-archetype:1.18
	cr-0x3b58:1.18.0.4
	cr-0x5ef:1.18.0.2
	after-mmap-privanon-noreserve:1.18
	after-mmap-revamp:1.18
	before-mmap-revamp:1.18
	cgf-more-exit-sync:1.18
	post_wait_sig_exit:1.18
	pre_wait_sig_exit:1.18
	reparent-point:1.17
	noreparent:1.17.0.16
	cr-0x5e6:1.17.0.14
	cr-0x9e:1.17.0.12
	cr-0x9d:1.17.0.10
	cgf-deleteme:1.17.0.8
	pre-sigrewrite:1.17
	corinna-01:1.17
	cr-0x9c:1.17.0.6
	cr-0x9b:1.17.0.4
	cr-0x99:1.17
	Z-emcb-cygwin_daemon:1.17.0.2
	w32api-2_2:1.13
	mingw-runtime-2_4:1.13
	pre-cgf-merge:1.17
	cgf-dev-branch:1.13.0.4
	predaemon:1.10
	cygwin_daemon_merge_HEAD:1.10
	pregp02r1:1.9.0.10
	cygnus_cvs_20020108_pre:1.9
	Z-cygwin_daemon_merge-new_HEAD:1.12
	Z-cygwin_daemon_merge_HEAD:1.12
	cygwin_daemon:1.7.0.4;
locks; strict;
comment	@ * @;
expand	@o@;


1.19
date	2006.10.17.17.34.55;	author corinna;	state dead;
branches;
next	1.18;

1.18
date	2005.06.18.19.04.24;	author corinna;	state Exp;
branches
	1.18.8.1;
next	1.17;

1.17
date	2003.03.19.21.38.25;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.19.20.13.56;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.17.20.44.10;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.09.21.51.00;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.12.03.09.38;	author cgf;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2002.06.06.15.35.06;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.15.10.12.30;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.25.17.47.47;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.19.20.10.02;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.28.23.05.49;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.01.08.04.02.01;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.11.05.36.34;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.28.05.41.43;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.01.17.30.35;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;

1.7.4.1
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.02.28.12.53.24;	author rbcollins;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2002.06.13.14.34.06;	author rbcollins;	state Exp;
branches;
next	;

1.13.4.1
date	2003.03.10.00.07.01;	author cgf;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2003.03.19.19.59.54;	author cgf;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2003.03.21.15.15.18;	author cgf;	state Exp;
branches;
next	;

1.18.8.1
date	2006.10.19.08.57.48;	author corinna;	state dead;
branches;
next	;


desc
@@


1.19
log
@	* glob.c: Remove.
	* glob.cc: New file.  Latest glob version from FreeBSD plus Cygwin
	specific changes (__stat64/__stat32, ignore_case_with_glob,
	drop collate functions).
	(glob3): Return GLOB_ABORTED in case directory is unreadable and
	GLOB_ERR is set, as demanded by SUSv3.
	* glob.h: Import latest version from FreeBSD.
@
text
@/*	$NetBSD: __glob13.c,v 1.1.2.1 1997/10/22 06:41:27 thorpej Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Guido van Rossum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/cdefs.h>

/*
 * glob(3) -- a superset of the one defined in POSIX 1003.2.
 *
 * The [!...] convention to negate a range is supported (SysV, Posix, ksh).
 *
 * Optional extra services, controlled by flags not defined by POSIX:
 *
 * GLOB_QUOTE:
 *	Escaping convention: \ inhibits any special meaning the following
 *	character might have (except \ at end of string is retained).
 * GLOB_MAGCHAR:
 *	Set in gl_flags if pattern contained a globbing character.
 * GLOB_NOMAGIC:
 *	Same as GLOB_NOCHECK, but it will only append pattern if it did
 *	not contain any magic characters.  [Used in csh style globbing]
 * GLOB_ALTDIRFUNC:
 *	Use alternately specified directory access functions.
 * GLOB_TILDE:
 *	expand ~user/foo to the /home/dir/of/user/foo
 * GLOB_BRACE:
 *	expand {1,2}{a,b} to 1a 1b 2a 2b
 * gl_matchc:
 *	Number of matches in the current invocation of glob.
 */

#include "winsup.h"

#include <sys/param.h>
#include <sys/stat.h>

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <glob.h>

#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <windows.h>

#include "perprocess.h"
#include "cygwin/version.h"

#ifndef ARG_MAX
#define ARG_MAX 32000	/* See CreateProcess */
#endif

#ifdef __weak_alias
#ifdef __LIBC12_SOURCE__
__weak_alias(glob,_glob);
__weak_alias(globfree,_globfree);
#else
#error "XXX THESE ARE NOT RIGHT!"
__weak_alias(__glob13,___glob13);
__weak_alias(__globfree13,___globfree13);
#endif /* __LIBC12_SOURCE__ */
#endif /* __weak_alias */

#ifdef __LIBC12_SOURCE__
#define	STAT	stat12
#else
#define STAT	__stat64
#endif

#define	DOLLAR		'$'
#define	DOT		'.'
#define	EOS		'\0'
#define	LBRACKET	'['
#define	NOT		'!'
#define	QUESTION	'?'
#define	QUOTE		'\\'
#define	RANGE		'-'
#define	RBRACKET	']'
#define	SEP		'/'
#define	STAR		'*'
#define	TILDE		'~'
#define	UNDERSCORE	'_'
#define	LBRACE		'{'
#define	RBRACE		'}'
#define	SLASH		'/'
#define	COMMA		','

#ifndef DEBUG

#define	M_QUOTE		0x8000
#define	M_PROTECT	0x4000
#define	M_MASK		0xffff
#define	M_ASCII		0x00ff

typedef u_short Char;

#else

#define	M_QUOTE		0x80
#define	M_PROTECT	0x40
#define	M_MASK		0xff
#define	M_ASCII		0x7f

typedef char Char;

#endif


#define	CHAR(c)		((Char)((c)&M_ASCII))
#define	META(c)		((Char)((c)|M_QUOTE))
#define	M_ALL		META('*')
#define	M_END		META(']')
#define	M_NOT		META('!')
#define	M_ONE		META('?')
#define	M_RNG		META('-')
#define	M_SET		META('[')
#define	ismeta(c)	(((c)&M_QUOTE) != 0)


static int	 compare __P((const void *, const void *));
static void	 g_Ctoc __P((const Char *, char *));
static int	 g_lstat __P((Char *, struct STAT *, glob_t *));
static DIR	*g_opendir __P((Char *, glob_t *));
static Char	*g_strchr __P((Char *, int));
#ifdef notdef
static Char	*g_strcat __P((Char *, const Char *));
#endif
static int	 g_stat __P((Char *, struct STAT *, glob_t *));
static int	 glob0 __P((const Char *, glob_t *));
static int	 glob1 __P((Char *, glob_t *, size_t *));
static int	 glob2 __P((Char *, Char *, Char *, glob_t *, size_t *));
static int	 glob3 __P((Char *, Char *, Char *, Char *, glob_t *, size_t *));
static int	 globextend __P((const Char *, glob_t *, size_t *));
static const Char *	 globtilde __P((const Char *, Char *, glob_t *));
static int	 globexp1 __P((const Char *, glob_t *));
static int	 globexp2 __P((const Char *, const Char *, glob_t *, int *));
static int	 match __P((Char *, Char *, Char *));
#ifdef DEBUG
static void	 qprintf __P((const char *, Char *));
#endif

#undef MAXPATHLEN
#define MAXPATHLEN 16384

extern BOOL ignore_case_with_glob;

int
glob(pattern, flags, errfunc, pglob)
	const char *pattern;
	int flags, (*errfunc) __P((const char *, int));
	glob_t *pglob;
{
	const u_char *patnext;
	int c;
	Char *bufnext, *bufend, patbuf[MAXPATHLEN+1];

	patnext = (u_char *) pattern;
	if (!(flags & GLOB_APPEND)) {
		pglob->gl_pathc = 0;
		pglob->gl_pathv = NULL;
		if (!(flags & GLOB_DOOFFS))
			pglob->gl_offs = 0;
	}
	pglob->gl_flags = flags & ~GLOB_MAGCHAR;
	pglob->gl_errfunc = errfunc;
	pglob->gl_matchc = 0;

	bufnext = patbuf;
	bufend = bufnext + MAXPATHLEN;
	if (flags & GLOB_QUOTE) {
		/* Protect the quoted characters. */
		while (bufnext < bufend && (c = *patnext++) != EOS)
			if (c == QUOTE) {
				if ((c = *patnext++) == EOS) {
					c = QUOTE;
					--patnext;
				}
				*bufnext++ = c | M_PROTECT;
			}
			else
				*bufnext++ = c;
	}
	else
	    while (bufnext < bufend && (c = *patnext++) != EOS)
		    *bufnext++ = c;
	*bufnext = EOS;

	if (flags & GLOB_BRACE)
	    return globexp1(patbuf, pglob);
	else
	    return glob0(patbuf, pglob);
}

/*
 * Expand recursively a glob {} pattern. When there is no more expansion
 * invoke the standard globbing routine to glob the rest of the magic
 * characters
 */
static int globexp1(pattern, pglob)
	const Char *pattern;
	glob_t *pglob;
{
	const Char* ptr = pattern;
	int rv;

	/* Protect a single {}, for find(1), like csh */
	if (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS)
		return glob0(pattern, pglob);

	while ((ptr = (const Char *) g_strchr((Char *) ptr, LBRACE)) != NULL)
		if (!globexp2(ptr, pattern, pglob, &rv))
			return rv;

	return glob0(pattern, pglob);
}


/*
 * Recursive brace globbing helper. Tries to expand a single brace.
 * If it succeeds then it invokes globexp1 with the new pattern.
 * If it fails then it tries to glob the rest of the pattern and returns.
 */
static int globexp2(ptr, pattern, pglob, rv)
	const Char *ptr, *pattern;
	glob_t *pglob;
	int *rv;
{
	int     i;
	Char   *lm, *ls;
	const Char *pe, *pm, *pl;
	Char    patbuf[MAXPATHLEN + 1];

	/* copy part up to the brace */
	for (lm = patbuf, pm = pattern; pm != ptr; *lm++ = *pm++)
		continue;
	ls = lm;

	/* Find the balanced brace */
	for (i = 0, pe = ++ptr; *pe; pe++)
		if (*pe == LBRACKET) {
			/* Ignore everything between [] */
			for (pm = pe++; *pe != RBRACKET && *pe != EOS; pe++)
				continue;
			if (*pe == EOS) {
				/*
				 * We could not find a matching RBRACKET.
				 * Ignore and just look for RBRACE
				 */
				pe = pm;
			}
		}
		else if (*pe == LBRACE)
			i++;
		else if (*pe == RBRACE) {
			if (i == 0)
				break;
			i--;
		}

	/* Non matching braces; just glob the pattern */
	if (i != 0 || *pe == EOS) {
		*rv = glob0(patbuf, pglob);
		return 0;
	}

	for (i = 0, pl = pm = ptr; pm <= pe; pm++)
		switch (*pm) {
		case LBRACKET:
			/* Ignore everything between [] */
			for (pl = pm++; *pm != RBRACKET && *pm != EOS; pm++)
				continue;
			if (*pm == EOS) {
				/*
				 * We could not find a matching RBRACKET.
				 * Ignore and just look for RBRACE
				 */
				pm = pl;
			}
			break;

		case LBRACE:
			i++;
			break;

		case RBRACE:
			if (i) {
			    i--;
			    break;
			}
			/* FALLTHROUGH */
		case COMMA:
			if (i && *pm == COMMA)
				break;
			else {
				/* Append the current string */
				for (lm = ls; (pl < pm); *lm++ = *pl++)
					continue;
				/*
				 * Append the rest of the pattern after the
				 * closing brace
				 */
				for (pl = pe + 1; (*lm++ = *pl++) != EOS;)
					continue;

				/* Expand the current pattern */
#ifdef DEBUG
				qprintf("globexp2:", patbuf);
#endif
				*rv = globexp1(patbuf, pglob);

				/* move after the comma, to the next string */
				pl = pm + 1;
			}
			break;

		default:
			break;
		}
	*rv = 0;
	return 0;
}



/*
 * expand tilde from the passwd file.
 */
static const Char *
globtilde(pattern, patbuf, pglob)
	const Char *pattern;
	Char *patbuf;
	glob_t *pglob;
{
	struct passwd *pwd;
	char *h;
	const Char *p;
	Char *b;

	if (*pattern != TILDE || !(pglob->gl_flags & GLOB_TILDE))
		return pattern;

	/* Copy up to the end of the string or / */
	for (p = pattern + 1, h = (char *) patbuf; *p && *p != SLASH;
	     *h++ = *p++)
		continue;

	*h = EOS;

	if (((char *) patbuf)[0] == EOS) {
		/*
		 * handle a plain ~ or ~/ by expanding $HOME
		 * first and then trying the password file
		 */
		if ((h = getenv("HOME")) == NULL) {
			if ((pwd = getpwuid32(getuid32())) == NULL)
				return pattern;
			else
				h = pwd->pw_dir;
		}
	}
	else {
		/*
		 * Expand a ~user
		 */
		if ((pwd = getpwnam((char*) patbuf)) == NULL)
			return pattern;
		else
			h = pwd->pw_dir;
	}

	/* Copy the home directory */
	for (b = patbuf; *h; *b++ = *h++)
		continue;

	/* Append the rest of the pattern */
	while ((*b++ = *p++) != EOS)
		continue;

	return patbuf;
}


/*
 * The main glob() routine: compiles the pattern (optionally processing
 * quotes), calls glob1() to do the real pattern matching, and finally
 * sorts the list (unless unsorted operation is requested).  Returns 0
 * if things went well, nonzero if errors occurred.  It is not an error
 * to find no matches.
 */
static int
glob0(pattern, pglob)
	const Char *pattern;
	glob_t *pglob;
{
	const Char *qpatnext;
	int c, err, oldpathc;
	Char *bufnext, patbuf[MAXPATHLEN+1];
	size_t limit = 0;

	qpatnext = globtilde(pattern, patbuf, pglob);
	oldpathc = pglob->gl_pathc;
	bufnext = patbuf;

	/* We don't need to check for buffer overflow any more. */
	while ((c = *qpatnext++) != EOS) {
		switch (c) {
		case LBRACKET:
			c = *qpatnext;
			if (c == NOT)
				++qpatnext;
			if (*qpatnext == EOS ||
			    g_strchr((Char *) qpatnext+1, RBRACKET) == NULL) {
				*bufnext++ = LBRACKET;
				if (c == NOT)
					--qpatnext;
				break;
			}
			*bufnext++ = M_SET;
			if (c == NOT)
				*bufnext++ = M_NOT;
			c = *qpatnext++;
			do {
				*bufnext++ = CHAR(c);
				if (*qpatnext == RANGE &&
				    (c = qpatnext[1]) != RBRACKET) {
					*bufnext++ = M_RNG;
					*bufnext++ = CHAR(c);
					qpatnext += 2;
				}
			} while ((c = *qpatnext++) != RBRACKET);
			pglob->gl_flags |= GLOB_MAGCHAR;
			*bufnext++ = M_END;
			break;
		case QUESTION:
			pglob->gl_flags |= GLOB_MAGCHAR;
			*bufnext++ = M_ONE;
			break;
		case STAR:
			pglob->gl_flags |= GLOB_MAGCHAR;
			/* collapse adjacent stars to one,
			 * to avoid exponential behavior
			 */
			if (bufnext == patbuf || bufnext[-1] != M_ALL)
			    *bufnext++ = M_ALL;
			break;
		default:
			*bufnext++ = CHAR(c);
			break;
		}
	}
	*bufnext = EOS;
#ifdef DEBUG
	qprintf("glob0:", patbuf);
#endif

	if ((err = glob1(patbuf, pglob, &limit)) != 0)
		return(err);

	/*
	 * If there was no match we are going to append the pattern
	 * if GLOB_NOCHECK was specified or if GLOB_NOMAGIC was specified
	 * and the pattern did not contain any magic characters
	 * GLOB_NOMAGIC is there just for compatibility with csh.
	 */
	if (pglob->gl_pathc == oldpathc &&
	    ((pglob->gl_flags & GLOB_NOCHECK) ||
	      ((pglob->gl_flags & GLOB_NOMAGIC) &&
	       !(pglob->gl_flags & GLOB_MAGCHAR))))
		return(globextend(pattern, pglob, &limit));
	else if (!(pglob->gl_flags & GLOB_NOSORT))
		qsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,
		    pglob->gl_pathc - oldpathc, sizeof(char *), compare);
	return(0);
}

static int
compare(p, q)
	const void *p, *q;
{
	return(strcmp(*(char **)p, *(char **)q));
}

static int
glob1(pattern, pglob, limit)
	Char *pattern;
	glob_t *pglob;
	size_t *limit;
{
	Char pathbuf[MAXPATHLEN+1];

	/* A null pathname is invalid -- POSIX 1003.1 sect. 2.4. */
	if (*pattern == EOS)
		return(0);
	return(glob2(pathbuf, pathbuf, pattern, pglob, limit));
}

/*
 * The functions glob2 and glob3 are mutually recursive; there is one level
 * of recursion for each segment in the pattern that contains one or more
 * meta characters.
 */
static int
glob2(pathbuf, pathend, pattern, pglob, limit)
	Char *pathbuf, *pathend, *pattern;
	glob_t *pglob;
	size_t *limit;
{
	struct STAT sb;
	Char *p, *q;
	int anymeta;

	/*
	 * Loop over pattern segments until end of pattern or until
	 * segment with meta character found.
	 */
	for (anymeta = 0;;) {
		if (*pattern == EOS) {		/* End of pattern? */
			*pathend = EOS;
			if (g_lstat(pathbuf, &sb, pglob))
				return(0);

			if (((pglob->gl_flags & GLOB_MARK) &&
			    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode)
			    || (S_ISLNK(sb.st_mode) &&
			    (g_stat(pathbuf, &sb, pglob) == 0) &&
			    S_ISDIR(sb.st_mode)))) {
				*pathend++ = SEP;
				*pathend = EOS;
			}
			++pglob->gl_matchc;
			return(globextend(pathbuf, pglob, limit));
		}

		/* Find end of next segment, copy tentatively to pathend. */
		q = pathend;
		p = pattern;
		while (*p != EOS && *p != SEP) {
			if (ismeta(*p))
				anymeta = 1;
			*q++ = *p++;
		}

		if (!anymeta) {		/* No expansion, do next segment. */
			pathend = q;
			pattern = p;
			while (*pattern == SEP)
				*pathend++ = *pattern++;
		} else			/* Need expansion, recurse. */
			return(glob3(pathbuf, pathend, pattern, p, pglob,
				limit));
	}
	/* NOTREACHED */
}

static int
glob3(pathbuf, pathend, pattern, restpattern, pglob, limit)
	Char *pathbuf, *pathend, *pattern, *restpattern;
	glob_t *pglob;
	size_t *limit;
{
	register struct dirent *dp;
	DIR *dirp;
	int err;
	char buf[MAXPATHLEN];

	/*
	 * The readdirfunc declaration can't be prototyped, because it is
	 * assigned, below, to two functions which are prototyped in glob.h
	 * and dirent.h as taking pointers to differently typed opaque
	 * structures.
	 */
	struct dirent *(*readdirfunc) __P((void *));

	*pathend = EOS;
	errno = 0;

	if ((dirp = g_opendir(pathbuf, pglob)) == NULL) {
		/* TODO: don't call for ENOENT or ENOTDIR? */
		if (pglob->gl_errfunc) {
			g_Ctoc(pathbuf, buf);
			if (pglob->gl_errfunc(buf, errno) ||
			    pglob->gl_flags & GLOB_ERR)
				return (GLOB_ABEND);
		}
		return(0);
	}

	err = 0;

	/* Search directory for matching names. */
	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
		readdirfunc = pglob->gl_readdir;
	else
		readdirfunc = (struct dirent *(*)__P((void *))) readdir;
	while ((dp = (*readdirfunc)(dirp))) {
		register u_char *sc;
		register Char *dc;

		/* Initial DOT must be matched literally. */
		if (dp->d_name[0] == DOT && *pattern != DOT)
			continue;
		for (sc = (u_char *) dp->d_name, dc = pathend;
		     (*dc++ = *sc++) != EOS;)
			continue;
		if (!match(pathend, pattern, restpattern)) {
			*pathend = EOS;
			continue;
		}
		err = glob2(pathbuf, --dc, restpattern, pglob, limit);
		if (err)
			break;
	}

	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
		(*pglob->gl_closedir)(dirp);
	else
		closedir(dirp);
	return(err);
}


/*
 * Extend the gl_pathv member of a glob_t structure to accommodate a new item,
 * add the new item, and update gl_pathc.
 *
 * This assumes the BSD realloc, which only copies the block when its size
 * crosses a power-of-two boundary; for v7 realloc, this would cause quadratic
 * behavior.
 *
 * Return 0 if new item added, error code if memory couldn't be allocated.
 *
 * Invariant of the glob_t structure:
 *	Either gl_pathc is zero and gl_pathv is NULL; or gl_pathc > 0 and
 *	gl_pathv points to (gl_offs + gl_pathc + 1) items.
 */
static int
globextend(path, pglob, limit)
	const Char *path;
	glob_t *pglob;
	size_t *limit;
{
	register char **pathv;
	register int i;
	size_t newsize, len;
	char *copy;
	const Char *p;

	newsize = sizeof(*pathv) * (2 + pglob->gl_pathc + pglob->gl_offs);
	pathv = pglob->gl_pathv ?
		    realloc((char *)pglob->gl_pathv, newsize) :
		    malloc(newsize);
	if (pathv == NULL)
		return(GLOB_NOSPACE);

	if (pglob->gl_pathv == NULL && pglob->gl_offs > 0) {
		/* first time around -- clear initial gl_offs items */
		pathv += pglob->gl_offs;
		for (i = pglob->gl_offs; --i >= 0;)
			*--pathv = NULL;
	}
	pglob->gl_pathv = pathv;

	for (p = path; *p++;)
		continue;
	len = (size_t)(p - path);
	*limit += len;
	if ((copy = malloc(len)) != NULL) {
		g_Ctoc(path, copy);
		pathv[pglob->gl_offs + pglob->gl_pathc++] = copy;
	}
	pathv[pglob->gl_offs + pglob->gl_pathc] = NULL;

	if ((pglob->gl_flags & GLOB_LIMIT) && (newsize + *limit) >= ARG_MAX) {
		errno = 0;
		return(GLOB_NOSPACE);
	}

	return(copy == NULL ? GLOB_NOSPACE : 0);
}


/*
 * pattern matching function for filenames.  Each occurrence of the *
 * pattern causes a recursion level.
 */
static int
match(name, pat, patend)
	register Char *name, *pat, *patend;
{
	int ok, negate_range;
	Char c, k;

	while (pat < patend) {
		c = *pat++;
		switch (c & M_MASK) {
		case M_ALL:
			if (pat == patend)
				return(1);
			do
			    if (match(name, pat, patend))
				    return(1);
			while (*name++ != EOS);
			return(0);
		case M_ONE:
			if (*name++ == EOS)
				return(0);
			break;
		case M_SET:
			ok = 0;
			if ((k = *name++) == EOS)
				return(0);
			if ((negate_range = ((*pat & M_MASK) == M_NOT)) != EOS)
				++pat;
			if (ignore_case_with_glob)
			  {
			    while (((c = *pat++) & M_MASK) != M_END)
			      if ((*pat & M_MASK) == M_RNG) {
				if (tolower(c) <= tolower(k) && tolower(k) <= tolower(pat[1]))
				  ok = 1;
				pat += 2;
			      } else if (tolower(c) == tolower(k))
				ok = 1;
			  }
			else
			  {
			    while (((c = *pat++) & M_MASK) != M_END)
			      if ((*pat & M_MASK) == M_RNG) {
				if (c <= k && k <= pat[1])
				  ok = 1;
				pat += 2;
			      } else if (c == k)
				ok = 1;
			  }
			if (ok == negate_range)
				return(0);
			break;
		default:
			if (ignore_case_with_glob)
			  {
			    if (tolower(*name) != tolower(c))
			      return(0);
			    ++name;
			  }
			else
			  {
			    if (*name++ != c)
			      return(0);
			  }
			break;
		}
	}
	return(*name == EOS);
}

/* Free allocated data belonging to a glob_t structure. */
void
globfree(pglob)
	glob_t *pglob;
{
	register int i;
	register char **pp;

	if (pglob->gl_pathv != NULL) {
		pp = pglob->gl_pathv + pglob->gl_offs;
		for (i = pglob->gl_pathc; i--; ++pp)
			if (*pp)
				free(*pp);
		free(pglob->gl_pathv);
	}
}

static DIR *
g_opendir(str, pglob)
	register Char *str;
	glob_t *pglob;
{
	char buf[MAXPATHLEN];

	if (!*str)
		strcpy(buf, ".");
	else
		g_Ctoc(str, buf);

	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
		return((*pglob->gl_opendir)(buf));

	return(opendir(buf));
}

static void
stat32_to_STAT (struct __stat32 *src, struct STAT *dst)
{
  dst->st_dev = src->st_dev;
  dst->st_ino = src->st_ino;
  dst->st_mode = src->st_mode;
  dst->st_nlink = src->st_nlink;
  dst->st_uid = src->st_uid;
  dst->st_gid = src->st_gid;
  dst->st_rdev = src->st_rdev;
  dst->st_size = src->st_size;
  dst->st_atim = src->st_atim;
  dst->st_mtim = src->st_mtim;
  dst->st_ctim = src->st_ctim;
  dst->st_blksize = src->st_blksize;
  dst->st_blocks = src->st_blocks;
}

static int
g_lstat(fn, sb, pglob)
	register Char *fn;
	struct STAT *sb;
	glob_t *pglob;
{
	char buf[MAXPATHLEN];

	g_Ctoc(fn, buf);
	if (pglob->gl_flags & GLOB_ALTDIRFUNC) {
		struct __stat32 lsb;
		int ret;

		if (CYGWIN_VERSION_CHECK_FOR_USING_BIG_TYPES)
		  ret = (*pglob->gl_lstat)(buf, &sb);
		else if (!(ret = (*pglob->gl_lstat)(buf, &lsb)))
			stat32_to_STAT (&lsb, sb);
		return ret;
	}
	return(lstat64(buf, sb));
}

static int
g_stat(fn, sb, pglob)
	register Char *fn;
	struct STAT *sb;
	glob_t *pglob;
{
	char buf[MAXPATHLEN];

	g_Ctoc(fn, buf);
	if (pglob->gl_flags & GLOB_ALTDIRFUNC) {
		struct __stat32 lsb;
		int ret;

		if (CYGWIN_VERSION_CHECK_FOR_USING_BIG_TYPES)
		  ret = (*pglob->gl_stat)(buf, &sb);
		if (!(ret = (*pglob->gl_stat)(buf, &lsb)))
			stat32_to_STAT (&lsb, sb);
		return ret;
	}
	return(stat64(buf, sb));
}

static Char *
g_strchr(str, ch)
	Char *str;
	int ch;
{
	do {
		if (*str == ch)
			return (str);
	} while (*str++);
	return (NULL);
}

#ifdef notdef
static Char *
g_strcat(dst, src)
	Char *dst;
	const Char* src;
{
	Char *sdst = dst;

	while (*dst++)
		continue;
	--dst;
	while((*dst++ = *src++) != EOS)
	    continue;

	return (sdst);
}
#endif

static void
g_Ctoc(str, buf)
	register const Char *str;
	char *buf;
{
	register char *dc;

	for (dc = buf; (*dc++ = *str++) != EOS;)
		continue;
}

#ifdef DEBUG
static void
qprintf(str, s)
	const char *str;
	register Char *s;
{
	register Char *p;

	(void)printf("%s:\n", str);
	for (p = s; *p; p++)
		(void)printf("%c", CHAR(*p));
	(void)printf("\n");
	for (p = s; *p; p++)
		(void)printf("%c", *p & M_PROTECT ? '"' : ' ');
	(void)printf("\n");
	for (p = s; *p; p++)
		(void)printf("%c", ismeta(*p) ? '_' : ' ');
	(void)printf("\n");
}
#endif
@


1.18
log
@	* glob.c: (glob0): New local variable `limit`. Use in calls to glob1
	and globextend.
	(glob1): Add `limit' parameter.
	(glob2): Ditto.
	(glob3): Ditto.
	(globextend): Ditto. Implement GLOB_LIMIT handling.
	* include/glob.h (GLOB_LIMIT): New define.
	* include/cygwin/version.h: Bump API minor number.
@
text
@@


1.18.8.1
log
@	* glob.c: Remove.
	* glob.cc: New file.  Latest glob version from FreeBSD plus Cygwin
	specific changes (__stat64/__stat32, ignore_case_with_glob,
	drop collate functions).
	(glob3): Return GLOB_ABORTED in case directory is unreadable and
	GLOB_ERR is set, as demanded by SUSv3.
	* glob.h: Import latest version from FreeBSD.
@
text
@@


1.17
log
@	* glob.c: Eliminate __INSIDE_CYGWIN__ preprocessor conditionals
	throughout.
@
text
@d86 4
d167 4
a170 4
static int	 glob1 __P((Char *, glob_t *));
static int	 glob2 __P((Char *, Char *, Char *, glob_t *));
static int	 glob3 __P((Char *, Char *, Char *, Char *, glob_t *));
static int	 globextend __P((const Char *, glob_t *));
d435 1
d493 1
a493 1
	if ((err = glob1(patbuf, pglob)) != 0)
d506 1
a506 1
		return(globextend(pattern, pglob));
d521 1
a521 1
glob1(pattern, pglob)
d524 1
d531 1
a531 1
	return(glob2(pathbuf, pathbuf, pattern, pglob));
d540 1
a540 1
glob2(pathbuf, pathend, pattern, pglob)
d543 1
d568 1
a568 1
			return(globextend(pathbuf, pglob));
d586 2
a587 1
			return(glob3(pathbuf, pathend, pattern, p, pglob));
d593 1
a593 1
glob3(pathbuf, pathend, pattern, restpattern, pglob)
d596 1
d646 1
a646 1
		err = glob2(pathbuf, --dc, restpattern, pglob);
d674 1
a674 1
globextend(path, pglob)
d677 1
d681 1
a681 1
	u_int newsize;
d702 3
a704 1
	if ((copy = malloc(p - path)) != NULL) {
d709 6
@


1.16
log
@	* include/cygwin/version.h (CYGWIN_VERSION_CHECK_FOR_USING_BIG_TYPES):
	Define.
	* glob.c (g_lstat): Use CYGWIN_VERSION_CHECK_FOR_USING_BIG_TYPES
	instead of numerical constants.
	(g_stat): Ditto.
@
text
@a99 1
#if defined (__INSIDE_CYGWIN__)
a100 3
#else
#define	STAT	stat
#endif
a845 1
#ifdef __INSIDE_CYGWIN__
a846 3
#else
	return(lstat(buf, sb));
#endif
a867 1
#ifdef __INSIDE_CYGWIN__
a868 3
#else
	return(stat(buf, sb));
#endif
@


1.15
log
@	* glob.c (g_lstat): Change API minor test to match API minor number
	change in previous patch.
	(g_stat): Ditto.
@
text
@d84 1
d844 1
a844 1
		if (user_data->api_major > 0 || user_data->api_minor > 78)
d870 1
a870 1
		if (user_data->api_major > 0 || user_data->api_minor > 78)
@


1.14
log
@	Switch to 32/64 datatypes:
	* Makefile.in (OBSOLETE_FUNCTIONS): Add open acl aclcheck aclfrommode
	aclfrompbits aclfromtext aclsort acltomode acltopbits acltotext chown
	facl fchown fgetpos fopen freopen fseeko fsetpos fstat ftello
	ftruncate getegid geteuid getgid getgrent getgrgid getgrnam getgroups
	getpwuid getpwuid_r getuid initgroups lchown lseek lstat mknod mmap
	seekdir setegid seteuid setgid setgroups setregid setreuid setuid stat
	telldir truncate.
	(NEW_FUNCTIONS): Add _open64 acl32 aclcheck32 aclfrommode32
	aclfrompbits32 aclfromtext32 aclsort32 acltomode32 acltopbits32
	acltotext32 chown32 facl32 fchown32 fgetpos64 fopen64 freopen64
	fseeko64 fsetpos64 fstat64 ftello64 ftruncate64 getegid32 geteuid32
	getgid32 getgrent32 getgrgid32 getgrnam32 getgroups32 getpwuid32
	getpwuid_r32 getuid32 initgroups32 lchown32 lseek64 lstat64 mknod32
	mmap64 seekdir64 setegid32 seteuid32 setgid32 setgroups32 setregid32
	setreuid32 setuid32 stat64 telldir64 truncate64 to substitute the
	above.
	* cygserver_shm.h (class client_request_shm): Change uid_t and gid_t
	members to __uid32_t and __gid32_t.
	* cygwin.din: Add symbols acl32 aclcheck32 aclfrommode32
	aclfrompbits32 aclfromtext32 aclsort32 acltomode32 acltopbits32
	acltotext32 facl32 fgetpos64 fopen64 freopen64 fseeko64 fsetpos64
	_fstat64 ftello64 _lseek64 mknod32 _open64.
	* glob.c: Include perprocess.h.
	(globtilde): Call getpwuid32 and getuid32 instead of getpwuid and
	getuid.
	(g_lstat): Check for applications API version to call the appropriate
	typed gl_lstat function.
	(g_stat): Ditto for gl_stat.
	* shm.cc (client_request_shm::client_request_shm): Call geteuid32
	and getegid32 instead of geteuid and getegid throughout.
	* syscalls.cc (_open64): New alias for open.
	(_lseek64): New alias for lseek64.
	(_fstat64): New alias for fseek64.
	(mknod32): New function.
	(mknod): Calls mknod32 now.
	* winsup.h: Make function declarations for getuid32, geteuid32,
	and getpwuid32 accessible for plain C sources.  Add declarations
	for getegid32 and getpwnam.
	* include/cygwin/version.h: Bum API minor number to 78.
	* include/sys/cygwin.h: Guard C++ specific members of struct
	per_process against inclusion in plain C sources.
	* include/sys/mman.h (mman): Add guard to avoid type clash when
	compiling Cygwin.
@
text
@d843 1
a843 1
		if (user_data->api_major > 0 || user_data->api_minor > 77)
d869 1
a869 1
		if (user_data->api_major > 0 || user_data->api_minor > 77)
@


1.13
log
@whitespace
@
text
@d83 2
d391 1
a391 1
			if ((pwd = getpwuid(getuid())) == NULL)
a835 10
	/* FIXME: This only works as long as the application uses the old
	   struct stat with 32 bit off_t types!!!

	   As soon as we switch over to 64 bit, we have to decide by
	   the applications API minor version number, whether to use
	   a pointer to a __stat64 or a _stat32 struct to the
	   pglob->gl_lstat function. */
#ifdef __CYGWIN_USE_BIG_TYPES__
#error FIXME check apps API minor and use correct struct stat
#endif
d843 3
a845 1
		if (!(ret = (*pglob->gl_lstat)(buf, &lsb)))
a861 10
	/* FIXME: This only works as long as the application uses the old
	   struct stat with 32 bit off_t types!!!

	   As soon as we switch over to 64 bit, we have to decide by
	   the applications API minor version number, whether to use
	   a pointer to a __stat64 or a _stat32 struct to the
	   pglob->gl_stat function. */
#ifdef __CYGWIN_USE_BIG_TYPES__
#error FIXME check apps API minor and use correct struct stat
#endif
d869 2
@


1.13.4.1
log
@merge from trunk
@
text
@a82 2
#include "perprocess.h"

d389 1
a389 1
			if ((pwd = getpwuid32(getuid32())) == NULL)
d834 10
d851 1
a851 3
		if (user_data->api_major > 0 || user_data->api_minor > 77)
		  ret = (*pglob->gl_lstat)(buf, &sb);
		else if (!(ret = (*pglob->gl_lstat)(buf, &lsb)))
d868 10
a884 2
		if (user_data->api_major > 0 || user_data->api_minor > 77)
		  ret = (*pglob->gl_stat)(buf, &sb);
@


1.13.4.2
log
@merge from trunk
@
text
@d843 1
a843 1
		if (user_data->api_major > 0 || user_data->api_minor > 78)
d869 1
a869 1
		if (user_data->api_major > 0 || user_data->api_minor > 78)
@


1.13.4.3
log
@merge from trunk
@
text
@a83 1
#include "cygwin/version.h"
d99 1
d101 3
d843 1
a843 1
		if (CYGWIN_VERSION_CHECK_FOR_USING_BIG_TYPES)
d849 1
d851 3
d869 1
a869 1
		if (CYGWIN_VERSION_CHECK_FOR_USING_BIG_TYPES)
d875 1
d877 3
@


1.12
log
@	* fhandler.cc (fhandler_base::fstat): Initialise tv_nsec member of
	st_atim, st_mtim, and st_ctim fields.
	* fhandler_disk_file.cc (fhandler_disk_file::fstat_helper): Ditto.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	* glob.c (stat32_to_STAT): Copy across the whole st_atim,
	st_mtime, and st_ctim fields.
	* syscalls.cc (stat64_to_stat32): Ditto.
	* times.cc (to_timestruc_t): New function.
	(time_as_timestruc_t): New function.
	* winsup.h: Add to_timestruc_t and time_as_timestruc_t functions.
	* include/cygwin/stat.h: Replace time_t with timestruc_t
	throughout for all file times, removing the st_spare1, st_spare2,
	and st_spare3 fields in the process. Add macros to access tv_sec
	fields by old names.
	* include/cygwin/types.h: Typedef timespec_t and timestruc_t as
	struct timespec.
@
text
@d836 1
a836 1
	   
d870 1
a870 1
	   
@


1.11
log
@	* glob.c (stat32_to_STAT): New function.
	(g_lstat): Call user space functions always with 32 bit struct stat
	as a workaround.
	(g_stat): Ditto.
	* include/glob.h (struct glob): Don't prototype function pointers
	when compiling Cygwin.
@
text
@d821 3
a823 3
  dst->st_atime = src->st_atime;
  dst->st_mtime = src->st_mtime;
  dst->st_ctime = src->st_ctime;
@


1.10
log
@	* cygwin.din (fstat64): New symbol.
	(ftruncate64): Ditto.
	(lseek64): Ditto.
	(lstat64): Ditto.
	(mmap64): Ditto.
	(seekdir64): Ditto.
	(stat64): Ditto.
	(telldir64): Ditto.
	(truncate64): Ditto.
	* dir.cc (telldir64): New function.
	(telldir): Call telldir64().
	(seekdir64): New function.
	(seekdir): Call seekdir64().
	* fhandler.h: Redefine all methods using __off32_t to use __off64_t.
	* fhandler.cc: Use __off64_t and struct __stat64 throughout.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* pipe.cc: Ditto.
	* glob.c: Ditto, call lstat64 and stat64 in Cygwin.
	* mmap.cc: Use __off64_t throughout.
	(mmap64): New function.
	* sec_acl.cc (acl_worker): Use struct __stat64, call stat64 and lstat64.
	* syscalls.cc (lseek64): New function.
	(stat64_to_stat32): Ditto.
	(fstat64): Ditto.
	(stat64): Ditto.
	(lstat64): Ditto.
	(ftruncate64): Ditto.
	(truncate64): Ditto.
	(_fstat): Call fstat64.
	(_stat): Call stat64.
	(cygwin_lstat): Rename to avoid declaration problem.  Call lstat64.
	(stat_worker): Use struct __stat64.
	(access): Ditto.
	(ftruncate): Call ftruncate64.
	(truncate): Call truncate64.
	* wincap.cc: Set flag has_64bit_file_access appropriately.
	* wincap.h: Add flag has_64bit_file_access.
	* winsup.h (ILLEGAL_SEEK): Define as __off64_t.
	(stat_dev): Declare using struct __stat64.
	(stat_worker): Ditto.
	* include/cygwin/stat.h (struct __stat32): Define if compiling Cygwin.
	(struct __stat64): Ditto.
	(struct stat): Revert definition with explicitly sized datatypes.
	Eliminate sized field names.
	* include/cygwin/types.h (blksize_t): New type.
	(__blkcnt32_t): Ditto.
	(__blkcnt64_t): Ditto.
	(blkcnt_t): Ditto.
@
text
@d810 18
d834 10
d847 8
a854 2
	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
		return((*pglob->gl_lstat)(buf, sb));
d868 10
d881 8
a888 2
	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
		return((*pglob->gl_stat)(buf, sb));
@


1.9
log
@Fix up comments.
@
text
@d97 3
d102 1
d821 3
d825 1
d839 3
d843 1
@


1.8
log
@fix spelling errors
@
text
@a65 4
/* CYGNUS LOCAL: don't include */
/* #include "namespace.h" */
/* end CYGNUS LOCAL */

@


1.7
log
@forced commit
@
text
@d652 1
a652 1
 * Extend the gl_pathv member of a glob_t structure to accomodate a new item,
@


1.7.4.1
log
@Merged changes from HEAD
@
text
@d66 4
d652 1
a652 1
 * Extend the gl_pathv member of a glob_t structure to accommodate a new item,
@


1.7.4.2
log
@Merged changes from HEAD
@
text
@a96 3
#if defined (__INSIDE_CYGWIN__)
#define STAT	__stat64
#else
a98 1
#endif
a816 3
#ifdef __INSIDE_CYGWIN__
	return(lstat64(buf, sb));
#else
a817 1
#endif
a830 3
#ifdef __INSIDE_CYGWIN__
	return(stat64(buf, sb));
#else
a831 1
#endif
@


1.7.4.3
log
@Merged changes from HEAD
@
text
@a809 18
static void
stat32_to_STAT (struct __stat32 *src, struct STAT *dst)
{
  dst->st_dev = src->st_dev;
  dst->st_ino = src->st_ino;
  dst->st_mode = src->st_mode;
  dst->st_nlink = src->st_nlink;
  dst->st_uid = src->st_uid;
  dst->st_gid = src->st_gid;
  dst->st_rdev = src->st_rdev;
  dst->st_size = src->st_size;
  dst->st_atim = src->st_atim;
  dst->st_mtim = src->st_mtim;
  dst->st_ctim = src->st_ctim;
  dst->st_blksize = src->st_blksize;
  dst->st_blocks = src->st_blocks;
}

a815 10
	/* FIXME: This only works as long as the application uses the old
	   struct stat with 32 bit off_t types!!!
	   
	   As soon as we switch over to 64 bit, we have to decide by
	   the applications API minor version number, whether to use
	   a pointer to a __stat64 or a _stat32 struct to the
	   pglob->gl_lstat function. */
#ifdef __CYGWIN_USE_BIG_TYPES__
#error FIXME check apps API minor and use correct struct stat
#endif
d819 2
a820 8
	if (pglob->gl_flags & GLOB_ALTDIRFUNC) {
		struct __stat32 lsb;
		int ret;

		if (!(ret = (*pglob->gl_lstat)(buf, &lsb)))
			stat32_to_STAT (&lsb, sb);
		return ret;
	}
a833 10
	/* FIXME: This only works as long as the application uses the old
	   struct stat with 32 bit off_t types!!!
	   
	   As soon as we switch over to 64 bit, we have to decide by
	   the applications API minor version number, whether to use
	   a pointer to a __stat64 or a _stat32 struct to the
	   pglob->gl_stat function. */
#ifdef __CYGWIN_USE_BIG_TYPES__
#error FIXME check apps API minor and use correct struct stat
#endif
d837 2
a838 8
	if (pglob->gl_flags & GLOB_ALTDIRFUNC) {
		struct __stat32 lsb;
		int ret;

		if (!(ret = (*pglob->gl_stat)(buf, &lsb)))
			stat32_to_STAT (&lsb, sb);
		return ret;
	}
@


1.6
log
@* pinfo.cc (codepage_init): Move function.
* environ.cc (codepage_init): To here.
* exceptoins.cc (SIG_NONMASKABLE): Remove SIGCONT from consideration since it
is supposed to be maskable.
* signal.cc (sigaction): Ditto.
* sigproc.cc (wait_sig): Ditto.
* winsup.h: Eliminate global declaration of codepage_init.
@
text
@@


1.5
log
@* dcrt0.cc: New global variable `ignore_case_with_glob'.
(dll_crt0_1): Disable case-insensitive globbing before calling `main'.
* environ.cc (glob_init): New static function to set or clear
`ignore_case_with_glob'.
(known): Changed "glob" entry to call `glob_init'.
* glob.c (match): Use case-insensitive globbing if needed.
@
text
@d686 1
a686 1
		for (i = pglob->gl_offs; --i >= 0; )
@


1.4
log
@Whitespace cleanup.

* configure.in: Eliminate subdir stuff.
* configure: Regenerate.
* include/getopt.h (option): Make name field 'const'.
@
text
@d75 1
d85 1
d179 2
d734 20
a753 7
			while (((c = *pat++) & M_MASK) != M_END)
				if ((*pat & M_MASK) == M_RNG) {
					if (c <= k && k <= pat[1])
						ok = 1;
					pat += 2;
				} else if (c == k)
					ok = 1;
d758 11
a768 2
			if (*name++ != c)
				return(0);
@


1.3
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d61 1
a61 1
 *	expand {1,2}{a,b} to 1a 1b 2a 2b 
d202 1
a202 1
		while (bufnext < bufend && (c = *patnext++) != EOS) 
d213 2
a214 2
	else 
	    while (bufnext < bufend && (c = *patnext++) != EOS) 
d275 1
a275 1
				/* 
d303 1
a303 1
				/* 
d328 1
a328 1
				/* 
d373 1
a373 1
	for (p = pattern + 1, h = (char *) patbuf; *p && *p != SLASH; 
d380 2
a381 2
		/* 
		 * handle a plain ~ or ~/ by expanding $HOME 
d404 1
a404 1
	
d411 1
a411 1
	
d469 1
a469 1
			/* collapse adjacent stars to one, 
d489 1
a489 1
	 * If there was no match we are going to append the pattern 
d494 2
a495 2
	if (pglob->gl_pathc == oldpathc && 
	    ((pglob->gl_flags & GLOB_NOCHECK) || 
d499 1
a499 1
	else if (!(pglob->gl_flags & GLOB_NOSORT)) 
d548 1
a548 1
		
d601 1
a601 1
	    
d627 1
a627 1
		for (sc = (u_char *) dp->d_name, dc = pathend; 
d673 1
a673 1
	pathv = pglob->gl_pathv ? 
d715 1
a715 1
			do 
d854 1
a854 1
static void 
@


1.2
log
@Changes by  Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>
        * assert.cc (__assert): Reduce dependency on newlib.
        * exec.cc: Eliminate unnecessary inclusion of ctype.h.
        * glob.c: Ditto.
        * hinfo.cc: Ditto.
        * init.cc: Ditto.
        * strace.cc: Ditto.
        * tty.cc: Ditto.
        * grp.cc (parse_grp): Eliminate atoi.
        * passwd.cc (grab_int): Ditto.
        * grp.cc (getgroups): Eliminate str{n,}casecmp.
        * path.cc (get_raw_device_number): Ditto.
        * path.cc (sort_by_native_name): Ditto.
        * spawn.cc (iscmd): Ditto.
        * uinfo.cc (internal_getlogin): Ditto.
@
text
@d70 2
@


1.1
log
@Initial revision
@
text
@a72 1
#include <ctype.h>
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
