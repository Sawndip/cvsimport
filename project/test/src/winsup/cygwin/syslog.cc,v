head	1.56;
access;
symbols
	cygwin-1_7_35-release:1.56
	cygwin-1_7_34-release:1.56
	cygwin-1_7_33-release:1.56
	cygwin-1_7_32-release:1.56
	cygwin-1_7_31-release:1.56
	cygwin-1_7_30-release:1.56
	cygwin-1_7_29-release:1.56
	cygwin-1_7_29-release-branchpoint:1.56.0.2
	cygwin-pre-user-db:1.56
	cygwin-1_7_28-release:1.56
	cygwin-1_7_27-release:1.56
	cygwin-1_7_26-release:1.56
	cygwin-1_7_25-release:1.56
	cygwin-1_7_24-release:1.56
	cygwin-1_7_23-release:1.56
	cygwin-1_7_22-release:1.56
	cygwin-1_7_21-release:1.56
	cygwin-1_7_20-release:1.56
	cygwin-1_7_19-release:1.56
	cygwin-64bit-postmerge:1.56
	cygwin-64bit-premerge-branch:1.55.0.2
	cygwin-64bit-premerge:1.55
	cygwin-1_7_18-release:1.55
	post-ptmalloc3:1.54.2.3
	pre-ptmalloc3:1.54.2.3
	cygwin-1_7_17-release:1.54
	cygwin-64bit-branch:1.54.0.2
	cygwin-1_7_16-release:1.54
	cygwin-1_7_15-release:1.52
	cygwin-1_7_14_2-release:1.52
	cygwin-1_7_14-release:1.52
	cygwin-1_7_12-release:1.52
	cygwin-1_7_11-release:1.52
	cygwin-1_7_10-release:1.52
	signal-rewrite:1.52.0.2
	pre-notty:1.52
	cygwin-1_7_9-release:1.48
	cv-post-1_7_9:1.48.0.4
	cygwin-1_7_8-release:1.48
	cygwin-1_7_7-release:1.48
	cygwin-1_7_5-release:1.48
	cygwin-1_7_4-release:1.48
	cygwin-1_7_3-release:1.48
	cygwin-1_7_2-release:1.48
	fifo_doover3:1.48.0.2
	cygwin-1_7_1-release:1.48
	prefifo:1.47
	cv-branch-2:1.47.0.2
	pre-ripout-set_console_state_for_spawn:1.47
	EOL_registry_mounts:1.46
	preoverlapped:1.45
	drop_9x_support_start:1.43
	cr-0x5f1:1.43.0.4
	cv-branch:1.43.0.2
	pre-ptymaster-archetype:1.43
	cr-0x3b58:1.42.0.4
	cr-0x5ef:1.42.0.2
	after-mmap-privanon-noreserve:1.37
	after-mmap-revamp:1.37
	before-mmap-revamp:1.37
	cgf-more-exit-sync:1.36
	post_wait_sig_exit:1.35
	pre_wait_sig_exit:1.35
	reparent-point:1.29
	noreparent:1.29.0.10
	cr-0x5e6:1.29.0.8
	cr-0x9e:1.29.0.6
	cr-0x9d:1.29.0.4
	cgf-deleteme:1.29.0.2
	pre-sigrewrite:1.28
	corinna-01:1.28
	cr-0x9c:1.26.0.6
	cr-0x9b:1.26.0.4
	cr-0x99:1.26
	Z-emcb-cygwin_daemon:1.26.0.2
	w32api-2_2:1.21
	mingw-runtime-2_4:1.21
	pre-cgf-merge:1.26
	cgf-dev-branch:1.21.0.16
	predaemon:1.20
	cygwin_daemon_merge_HEAD:1.20
	pregp02r1:1.20.0.30
	cygnus_cvs_20020108_pre:1.20
	Z-cygwin_daemon_merge-new_HEAD:1.21
	Z-cygwin_daemon_merge_HEAD:1.21
	cygwin_daemon:1.17.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.56
date	2013.04.23.09.44.34;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2013.01.21.04.38.28;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2012.07.06.13.56.36;	author corinna;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2012.07.06.13.52.18;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2011.05.11.08.20.17;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2011.04.21.08.10.28;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2011.03.29.11.18.10;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2011.03.29.11.07.23;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.02.15.23.03;	author corinna;	state Exp;
branches
	1.48.4.1;
next	1.47;

1.47
date	2008.04.07.18.45.59;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2008.04.01.10.22.33;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2007.02.26.12.39.25;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.22.17.09.46;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.02.13.05.57;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.01.16.17.55;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.31.14.16.49;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.27.18.10.49;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.22.05.57.54;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.10.10.34.49;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.11.16.28.08;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.10.20.56.07;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.02.03.50.08;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.07.20.42.20;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.07.20.16.46;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.16.17.07.32;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.12.22.40.46;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.29.12.31.22;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.16.03.24.12;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.06.08.11.18;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.09.20.10.25;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.23.19.12.55;	author phumblet;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.22.19.35.03;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches
	1.21.16.1;
next	1.20;

1.20
date	2001.10.15.23.39.33;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.05.00.17.57;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.01.04.10.07;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.09.11.20.01.01;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.24.22.26.53;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.18.21.10.14;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.22.15.55.34;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.17.11.30.14;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.24.21.19.14;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.11.13.49.42;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.11.01.56.05;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.02.16.28.18;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.54.2.1
date	2012.11.16.13.48.24;	author corinna;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2012.12.10.11.45.51;	author corinna;	state Exp;
branches;
next	1.54.2.3;

1.54.2.3
date	2013.01.21.13.52.11;	author corinna;	state Exp;
branches;
next	;

1.48.4.1
date	2011.03.16.12.20.17;	author corinna;	state Exp;
branches;
next	1.48.4.2;

1.48.4.2
date	2011.03.17.16.14.50;	author corinna;	state Exp;
branches;
next	;

1.21.16.1
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.21.16.2;

1.21.16.2
date	2003.02.23.06.00.22;	author cgf;	state Exp;
branches;
next	1.21.16.3;

1.21.16.3
date	2003.02.27.15.10.22;	author cgf;	state Exp;
branches;
next	1.21.16.4;

1.21.16.4
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.21.16.5;

1.21.16.5
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.17.2.1
date	2001.10.02.12.09.56;	author rbcollins;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.01.04.03.56.11;	author rbcollins;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.09.22.10.01.29;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.56
log
@	* Merge in cygwin-64bit-branch.
@
text
@/* syslog.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2011, 2012 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#define  __INSIDE_CYGWIN_NET__
#define USE_SYS_TYPES_FD_SET
#include "winsup.h"
#include <ws2tcpip.h>
#include <iphlpapi.h>
#include <stdlib.h>
#include <stdio.h>
#include <syslog.h>
#include <unistd.h>
#include <sys/un.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "cygtls.h"
#include "tls_pbuf.h"

#define CYGWIN_LOG_NAME L"Cygwin"

static struct
{
  wchar_t *process_ident;
  int process_logopt;
  int process_facility;
  int process_logmask;
} syslog_globals = { NULL, 0, 0, LOG_UPTO (LOG_DEBUG) };

/* openlog: save the passed args. Don't open the system log or /dev/log yet.  */
extern "C" void
openlog (const char *ident, int logopt, int facility)
{
    wchar_t *new_ident = NULL;

    debug_printf ("openlog called with (%s, %d, %d)",
		  ident ? ident : "<NULL>", logopt, facility);

    if (ident)
      {
	sys_mbstowcs_alloc (&new_ident, HEAP_NOTHEAP, ident);
	if (!new_ident)
	    debug_printf ("failed to allocate memory for "
			  "syslog_globals.process_ident");
	else
	  {
	    wchar_t *old_ident = syslog_globals.process_ident;
	    syslog_globals.process_ident = new_ident;
	    if (old_ident)
	      free (old_ident);
	  }
      }
    syslog_globals.process_logopt = logopt;
    syslog_globals.process_facility = facility;
}

/* setlogmask: set the log priority mask and return previous mask.
   If maskpri is zero, just return previous. */
int
setlogmask (int maskpri)
{
  if (maskpri == 0)
    return syslog_globals.process_logmask;

  int old_mask = syslog_globals.process_logmask;
  syslog_globals.process_logmask = maskpri;

  return old_mask;
}

/* Private class used to handle formatting of syslog message
   It is named pass_handler because it does a two-pass handling of log
   strings.  The first pass counts the length of the string, and the second
   one builds the string. */

class pass_handler
{
  private:
    FILE *fp_;
    char *message_;
    int total_len_;

    void shutdown ();

    /* Explicitly disallow copies */
    pass_handler (const pass_handler &);
    pass_handler & operator = (const pass_handler &);

  public:
    pass_handler ();
    ~pass_handler ();

    int initialize (int);

    int print (const char *,...);
    int print_va (const char *, va_list);
    char *get_message () const { return message_; }
    void set_message (char *s) { message_ = s; *message_ = '\0'; }
};

pass_handler::pass_handler () : fp_ (0), message_ (0), total_len_ (0)
{
  ;
}

pass_handler::~pass_handler ()
{
  shutdown ();
}

void
pass_handler::shutdown ()
{
  if (fp_ != NULL)
    {
      fclose (fp_);
      fp_ = 0;
    }
}

int
pass_handler::initialize (int pass_number)
{
    shutdown ();
    if (pass_number)
      return total_len_ + 1;

    fp_ = fopen ("/dev/null", "wb");
    setbuf (fp_, NULL);
    if (fp_ == NULL)
      {
	debug_printf ("failed to open /dev/null");
	return -1;
      }
    total_len_ = 0;
    return 0;
}

int
pass_handler::print (const char *fmt, ...)
{
    va_list ap;
    va_start (ap, fmt);
    int ret = print_va (fmt, ap);
    va_end (ap);
    return ret;
}

int
pass_handler::print_va (const char *fmt, va_list list)
{
    if (fp_ != NULL)
      {
	int len = vfprintf (fp_, fmt, list);
	if (len < 0)
	  return -1;
	total_len_ += len;
	return 0;
      }
    else if (message_ != NULL)
      {
	char *printpos = &message_[strlen (message_)];
	vsprintf (printpos, fmt, list);
	return 0;
      }
    debug_printf ("FAILURE ! fp_ and message_ both 0!! ");
    return -1;
}

static NO_COPY muto try_connect_guard;
static enum {
  not_inited,
  inited_failed,
  inited_dgram,
  inited_stream
} syslogd_inited;
static int syslogd_sock = -1;
extern "C" int cygwin_socket (int, int, int);
extern "C" int cygwin_connect (int, const struct sockaddr *, int);
extern int get_inet_addr (const struct sockaddr *, int,
			  struct sockaddr_storage *, int *,
			  int * = NULL, int * = NULL);

static void
connect_syslogd ()
{
  int fd;
  struct sockaddr_un sun;
  struct sockaddr_storage sst;
  int len, type;

  if (syslogd_inited != not_inited && syslogd_sock >= 0)
    close (syslogd_sock);
  syslogd_inited = inited_failed;
  syslogd_sock = -1;
  sun.sun_family = AF_LOCAL;
  strncpy (sun.sun_path, _PATH_LOG, sizeof sun.sun_path);
  if (get_inet_addr ((struct sockaddr *) &sun, sizeof sun, &sst, &len, &type))
    return;
  if ((fd = cygwin_socket (AF_LOCAL, type, 0)) < 0)
    return;
  if (cygwin_connect (fd, (struct sockaddr *) &sun, sizeof sun) == 0)
    {
      /* connect on a dgram socket always succeeds.  We still don't know
	 if syslogd is actually listening. */
      if (type == SOCK_DGRAM)
	{
	  tmp_pathbuf tp;
	  PMIB_UDPTABLE tab = (PMIB_UDPTABLE) tp.w_get ();
	  DWORD size = 65536;
	  bool found = false;
	  struct sockaddr_in *sa = (struct sockaddr_in *) &sst;

	  if (GetUdpTable (tab, &size, FALSE) == NO_ERROR)
	    {
	      for (DWORD i = 0; i < tab->dwNumEntries; ++i)
		if (tab->table[i].dwLocalAddr == sa->sin_addr.s_addr
		    && tab->table[i].dwLocalPort == sa->sin_port)
		  {
		    found = true;
		    break;
		  }
	      if (!found)
		{
		  /* No syslogd is listening. */
		  close (fd);
		  return;
		}
	    }
	}
      syslogd_inited = type == SOCK_DGRAM ? inited_dgram : inited_stream;
    }
  syslogd_sock = fd;
  fcntl64 (syslogd_sock, F_SETFD, FD_CLOEXEC);
  debug_printf ("found /dev/log, fd = %d, type = %s",
		fd, syslogd_inited == inited_stream ? "STREAM" : "DGRAM");
  return;
}

static int
try_connect_syslogd (int priority, const char *msg, size_t len)
{
  ssize_t ret = -1;

  try_connect_guard.init ("try_connect_guard")->acquire ();
  if (syslogd_inited == not_inited)
    connect_syslogd ();
  if (syslogd_inited != inited_failed)
    {
      char pribuf[16];
      sprintf (pribuf, "<%d>", priority);
      struct iovec iv[2] =
      {
	{ pribuf, strlen (pribuf) },
	{ (char *) msg, len }
      };

      ret = writev (syslogd_sock, iv, 2);
      /* If the syslog daemon has been restarted and /dev/log was
	 a stream socket, the connection is broken.  In this case,
	 try to reopen the socket and try again. */
      if (ret < 0 && syslogd_inited == inited_stream)
	{
	  connect_syslogd ();
	  if (syslogd_sock >= 0)
	    ret = writev (syslogd_sock, iv, 2);
	}
      /* If write fails and LOG_CONS is set, return failure to vsyslog so
	 it falls back to the usual logging method for this OS. */
      if (ret >= 0 || !(syslog_globals.process_logopt & LOG_CONS))
	ret = syslogd_sock;
    }
  try_connect_guard.release ();
  return ret;
}

/* syslog: creates the log message and writes to /dev/log, or to the
   NT system log if /dev/log isn't available.

   FIXME. WinNT system log messages don't look pretty, but in order to
   fix this we have to embed resources in the code and tell the NT
   registry where we are, blech (what happens if we move ?).  We could,
   however, add the resources in Cygwin and always point to that. */

extern "C" void
vsyslog (int priority, const char *message, va_list ap)
{
  debug_printf ("%y %s", priority, message);
  /* If the priority fails the current mask, reject */
  if ((LOG_MASK (LOG_PRI (priority)) & syslog_globals.process_logmask) == 0)
    {
      debug_printf ("failing message %y due to priority mask %y",
		    priority, syslog_globals.process_logmask);
      return;
    }

  /* Set default facility to LOG_USER if not yet set via openlog. */
  if (!syslog_globals.process_facility)
    syslog_globals.process_facility = LOG_USER;

  /* Add default facility if not in the given priority. */
  if (!(priority & LOG_FACMASK))
    priority |= syslog_globals.process_facility;

  /* Translate %m in the message to error text */
  char *errtext = strerror (get_errno ());
  int errlen = strlen (errtext);
  int numfound = 0;

  for (const char *cp = message; *cp; cp++)
    if (*cp == '%' && cp[1] == 'm')
      numfound++;

  char *newmessage = (char *) alloca (strlen (message) +
				      (errlen * numfound) + 1);

  if (newmessage == NULL)
    {
      debug_printf ("failed to allocate newmessage");
      return;
    }

  char *dst = newmessage;
  for (const char *cp2 = message; *cp2; cp2++)
    if (*cp2 == '%' && cp2[1] == 'm')
      {
	cp2++;
	strcpy (dst, errtext);
	while (*dst)
	  dst++;
      }
    else
      *dst++ = *cp2;

  *dst = '\0';
  message = newmessage;

  /* Work out the priority type - we ignore the facility for now.. */
  WORD eventType;
  switch (LOG_PRI (priority))
    {
    case LOG_EMERG:
    case LOG_ALERT:
    case LOG_CRIT:
    case LOG_ERR:
      eventType = EVENTLOG_ERROR_TYPE;
      break;
    case LOG_WARNING:
      eventType = EVENTLOG_WARNING_TYPE;
      break;
    case LOG_NOTICE:
    case LOG_INFO:
    case LOG_DEBUG:
      eventType = EVENTLOG_INFORMATION_TYPE;
      break;
    default:
      eventType = EVENTLOG_ERROR_TYPE;
      break;
    }

  /* We need to know how long the buffer needs to be.
     The only legal way I can see of doing this is to
     do a vfprintf to /dev/null, and count the bytes
     output, then do it again to a malloc'ed string. This
     is ugly, slow, but prevents core dumps :-).
   */
  pass_handler pass;
  for (int pass_number = 0; pass_number < 2; ++pass_number)
    {
      int n = pass.initialize (pass_number);
      if (n == -1)
	return;
      else if (n > 0)
	pass.set_message ((char *) alloca (n));

      /* Deal with ident_string */
      if (syslog_globals.process_ident != NULL)
	{
	  if (pass.print ("%ls: ", syslog_globals.process_ident) == -1)
	    return;
	}
      if (syslog_globals.process_logopt & LOG_PID)
	{
	  if (pass.print ("PID %u: ", getpid ()) == -1)
	    return;
	}

      /* Print out the variable part */
      if (pass.print_va (message, ap) == -1)
	return;

    }
  char *total_msg = pass.get_message ();
  size_t len = strlen (total_msg);
  if (len != 0 && (total_msg[len - 1] == '\n'))
    total_msg[--len] = '\0';

  if (syslog_globals.process_logopt & LOG_PERROR)
    {
      write (STDERR_FILENO, total_msg, len);
      write (STDERR_FILENO, "\n", 1);
    }

  int fd;
  if ((fd = try_connect_syslogd (priority, total_msg, len + 1)) < 0)
    {
      /* If syslogd isn't present, open the event log and send the message */
      HANDLE hEventSrc;

      hEventSrc = RegisterEventSourceW (NULL, syslog_globals.process_ident
					      ?: CYGWIN_LOG_NAME);
      if (!hEventSrc)
	debug_printf ("RegisterEventSourceW, %E");
      else
	{
	  wchar_t *msg_strings[1];
	  tmp_pathbuf tp;
	  msg_strings[0] = tp.w_get ();
	  sys_mbstowcs (msg_strings[0], NT_MAX_PATH, total_msg);
	  if (!ReportEventW (hEventSrc, eventType, 0, 0, cygheap->user.sid (),
			     1, 0, (const wchar_t **) msg_strings, NULL))
	    debug_printf ("ReportEventW, %E");
	  DeregisterEventSource (hEventSrc);
	}
    }
}

extern "C" void
syslog (int priority, const char *message, ...)
{
  va_list ap;
  va_start (ap, message);
  vsyslog (priority, message, ap);
  va_end (ap);
}

static NO_COPY muto klog_guard;
fhandler_mailslot *dev_kmsg;

extern "C" void
vklog (int priority, const char *message, va_list ap)
{
  /* TODO: kernel messages are under our control entirely and they should
     be quick.  No playing with /dev/null, but a fixed upper size for now. */
  char buf[2060];	/* 2048 + a prority */
  if (!(priority & ~LOG_PRIMASK))
    priority = LOG_KERN | LOG_PRI (priority);
  __small_sprintf (buf, "<%d>", priority);
  __small_vsprintf (buf + strlen (buf), message, ap);
  klog_guard.init ("klog_guard")->acquire ();
  if (!dev_kmsg)
    dev_kmsg = (fhandler_mailslot *) build_fh_name ("/dev/kmsg");
  if (dev_kmsg && !dev_kmsg->get_handle ())
    dev_kmsg->open (O_WRONLY, 0);
  if (dev_kmsg && dev_kmsg->get_handle ())
    dev_kmsg->write (buf, strlen (buf) + 1);
  klog_guard.release ();
}

extern "C" void
klog (int priority, const char *message, ...)
{
  va_list ap;
  va_start (ap, message);
  vklog (priority, message, ap);
  va_end (ap);
}

extern "C" void
closelog (void)
{
  try_connect_guard.init ("try_connect_guard")->acquire ();
  if (syslogd_inited != not_inited && syslogd_sock >= 0)
    {
      close (syslogd_sock);
      syslogd_sock = -1;
      syslogd_inited = not_inited;
    }
  try_connect_guard.release ();
}
@


1.55
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d48 1
a48 1
		       ident ? ident : "<NULL>", logopt, facility);
d252 1
a252 1
try_connect_syslogd (int priority, const char *msg, int len)
d299 1
a299 1
  debug_printf ("%x %s", priority, message);
d303 1
a303 1
      debug_printf ("failing message %x due to priority mask %x",
d405 1
a405 1
  int len = strlen (total_msg);
@


1.54
log
@	* fhandler_procnet.cc: Fix copyright.
	* syslog.cc: Ditto.
	* libc/minires-os-if.c: Ditto.
	* libc/minires.h: Ditto.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2009, 2011, 2012 Red Hat, Inc.
@


1.54.2.1
log
@	* fhandler_netdrive.cc: Use UINT32_MAX rather than UINT_MAX to make
	absolutely clear that we mean the 32 bit maximum.
	* fhandler_socket.cc: Ditto.
	* pinfo.cc: Ditto with INT32_MAX.
	* select.cc (fd_mask): Drop gratuitious definition.
	(sizeof_fd_set): Cast to size_t.
	* shared.cc (pround): Cast to ptrdiff_t.
	* strace.cc (strace::activate): Fix format string.
	(strace::write_childpid): Take pid_t as parameter.
	* include/sys/strace.h (strace::write_childpid): Change declaration
	accordingly.
	* sync.cc (muto::init): Cast in call to InterlockedExchangePointer to
	make compiler happy.
	* sync.h (class muto): De-const name.
	* syslog.cc (try_connect_syslogd): Take size_t as third argument.
	(vsyslog): Convert len to size_t.
	* thread.cc: Use {U}INT32_MAX rather than {U}LONG_MAX.  Througout change
	types used in Windows calls to matching Windows types.
	(pthread::cancel): Fix access to instruction pointer for x86_64.
	(pthread_attr_getstack): Cast to ptrdiff_t for pointer arithmetic.
	* thread.h: Throughout convert 'long' types to uint32_t or LONG.
@
text
@d252 1
a252 1
try_connect_syslogd (int priority, const char *msg, size_t len)
d405 1
a405 1
  size_t len = strlen (total_msg);
@


1.54.2.2
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d48 1
a48 1
		  ident ? ident : "<NULL>", logopt, facility);
d299 1
a299 1
  debug_printf ("%y %s", priority, message);
d303 1
a303 1
      debug_printf ("failing message %y due to priority mask %y",
@


1.54.2.3
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2011, 2012 Red Hat, Inc.
@


1.53
log
@	In terms of network related functionality, rely on Winsock definitions
	as much as possible:
	* dtable.cc: Drop including sys/socket.h.
	* fhandler_procnet.cc: Change includes accordingly.
	* fhandler_socket.cc: Ditto.
	(fhandler_socket::listen): Avoid gcc error message initializing sin6.
	(LPFN_WSARECVMSG): Only define when building against w32api headers.
	* net.cc: Change includes accordingly.  Define USE_SYS_TYPES_FD_SET
	and __WSA_ERR_MACROS_DEFINED.  Define _INC_NETIOAPI temporarily and
	explain why.
	(struct _IP_ADAPTER_UNICAST_ADDRESS_LH): Only define when building
	against w32api headers.
	(struct _IP_ADAPTER_ADDRESSES_LH): Ditto.
	(SIO_GET_INTERFACE_LIST): Ditto.
	(ws_freeaddrinfo): Rename from freeaddrinfo so as not to collide with
	Winsock declaration.  Change througout.
	(ws_getaddrinfo): Ditto.
	(ws_getnameinfo): Ditto.
	* select.cc: Include netdb.h after defining USE_SYS_TYPES_FD_SET.
	* syslog.cc: Drop including netinet/in.h.  Define USE_SYS_TYPES_FD_SET
	and include ws2tcpip.h.
	* include/netdb.h (struct addrinfo): Don't define when building Cygwin.
	* include/cygwin/if.h: Don't declare if_xxx functions when building
	Cygwin.
	* include/cygwin/in.h: Disable most definitions when building Cygwin.
	* include/cygwin/socket.h: Disable sockaddr and sockaddr_storage
	definitions when building Cygwin.  Same for MCAST_INCLUDE/MCAST_EXCLUDE.
	* libc/inet_addr.c: Don't define __INSIDE_CYGWIN__ nor
	__INSIDE_CYGWIN_NET__.
	* libc/inet_network.c: Ditto.
	* libc/minires.h: Drop redundant inclusion of netdb.h.  Define
	__INSIDE_CYGWIN_NET__ only before including netdb.h and resolver
	headers.
@
text
@d4 1
a4 1
   2006, 2007, 2009, 2011 Red Hat, Inc.
@


1.52
log
@	* fhandler_socket.cc (get_inet_addr): Rearrange for better readability.
	Make waiting loop interruptible and cancelable.  Check for SYSTEM DOS
	flag before reading the file.  Change return value to return 0 on
	success, SOCKET_ERROR on failure.
	(fhandler_socket::bind): Only set R/O DOS flag on filesystems not
	supporting ACLs.
	(fhandler_socket::connect): Accommodate changed return values from
	get_inet_addr.  Use SOCKET_ERROR instead of -1.
	(fhandler_socket::sendto): Accommodate changed return values from
	get_inet_addr.
	* syslog.cc (connect_syslogd): Ditto.
@
text
@d13 1
a13 1

d15 2
a21 2
#include <netinet/in.h>
#include <iphlpapi.h>
@


1.51
log
@	* cygtls.cc (_cygtls::init_thread): Drop setting locals.process_logmask.
	* cygtls.cc (_cygtls::remove): Always free mallocated TLS storage on
	thread exit.  Drop freeing locals.process_ident.
	* cygtls.h (struct _local_storage): Remove syslog-related members.
	* syslog.cc (syslog_globals): New static storage for global syslog
	settings.  Use throughout instead of _my_tls.locals.
	(openlog): Set new syslog_globals.process_ident value more carefully.
	* tlsoffsets.h: Regenerate.
@
text
@d209 1
a209 1
  if (!get_inet_addr ((struct sockaddr *) &sun, sizeof sun, &sst, &len, &type))
@


1.50
log
@	* cygtls.h (struct _local_storage): Redefine process_ident as wchar_t
	pointer.
	* syslog.cc (CYGWIN_LOG_NAME): Convert to wide char constant.
	(openlog): Convert incoming ident string to wide char.  Fix formatting.
	(vsyslog): Print ident string as wide char string.  Convert message
	string to wide char and call UNICODE Win32 Event functions to make sure
	to use correct codeset.
	* tlsoffset.h: Regenerate.
@
text
@d33 8
d45 2
a49 5
    if (_my_tls.locals.process_ident != NULL)
      {
	free (_my_tls.locals.process_ident);
	_my_tls.locals.process_ident = NULL;
      }
d52 5
a56 2
	sys_mbstowcs_alloc (&_my_tls.locals.process_ident, HEAP_NOTHEAP, ident);
	if (!_my_tls.locals.process_ident)
d58 4
a61 3
	    debug_printf ("failed to allocate memory for "
			  "_my_tls.locals.process_ident");
	    return;
d64 2
a65 2
    _my_tls.locals.process_logopt = logopt;
    _my_tls.locals.process_facility = facility;
d74 1
a74 1
    return _my_tls.locals.process_logmask;
d76 2
a77 2
  int old_mask = _my_tls.locals.process_logmask;
  _my_tls.locals.process_logmask = maskpri;
d281 1
a281 1
      if (ret >= 0 || !(_my_tls.locals.process_logopt & LOG_CONS))
d301 1
a301 1
  if ((LOG_MASK (LOG_PRI (priority)) & _my_tls.locals.process_logmask) == 0)
d304 1
a304 1
		    priority, _my_tls.locals.process_logmask);
d309 2
a310 2
  if (!_my_tls.locals.process_facility)
    _my_tls.locals.process_facility = LOG_USER;
d314 1
a314 1
    priority |= _my_tls.locals.process_facility;
d388 1
a388 1
      if (_my_tls.locals.process_ident != NULL)
d390 1
a390 1
	  if (pass.print ("%ls: ", _my_tls.locals.process_ident) == -1)
d393 1
a393 1
      if (_my_tls.locals.process_logopt & LOG_PID)
d409 1
a409 1
  if (_my_tls.locals.process_logopt & LOG_PERROR)
d421 1
a421 1
      hEventSrc = RegisterEventSourceW (NULL, _my_tls.locals.process_ident
@


1.49
log
@	* fhandler_socket.cc (get_inet_addr): Make externally available.
	* autoload.cc (GetUdpTable): Define.
	* syslog.cc (connect_syslogd): Use get_inet_addr rather than _stat64
	to check for local socket file.  Create socket with type returned by
	get_inet_addr.  If connect on UDP socket works, test if there's
	really a listening peer, otherwise fall back to Windows event log.
	(try_connect_syslogd): Use syslogd_inited flag to check if syslogd
	is available.
@
text
@d31 1
a31 1
#define CYGWIN_LOG_NAME "Cygwin"
d47 1
a47 1
	_my_tls.locals.process_ident = (char *) malloc (strlen (ident) + 1);
d50 2
a51 1
	    debug_printf ("failed to allocate memory for _my_tls.locals.process_ident");
a53 1
	strcpy (_my_tls.locals.process_ident, ident);
d381 1
a381 1
	  if (pass.print ("%s: ", _my_tls.locals.process_ident) == -1)
a394 1
  const char *msg_strings[1];
a399 2
  msg_strings[0] = total_msg;

d410 7
a416 3
      HANDLE hEventSrc = RegisterEventSourceA (NULL, (_my_tls.locals.process_ident != NULL) ?
				       _my_tls.locals.process_ident : CYGWIN_LOG_NAME);
      if (hEventSrc == NULL)
d418 8
a425 2
	  debug_printf ("RegisterEventSourceA failed with %E");
	  return;
a426 4
      if (!ReportEventA (hEventSrc, eventType, 0, 0,
			 cygheap->user.sid (), 1, 0, msg_strings, NULL))
	debug_printf ("ReportEventA failed with %E");
      DeregisterEventSource (hEventSrc);
@


1.48
log
@	* fhandler_socket.cc (send_internal): Don't split datagram messages
	into pieces.

	* syslog.cc (vsyslog): Set default facility to LOG_USER if it hasn't
	been set yet.
@
text
@d4 1
a4 1
   2006, 2007, 2009 Red Hat, Inc.
d20 2
d29 1
d182 3
a188 1
  struct __stat64 st;
d191 2
d198 3
a200 1
  if (stat64 (_PATH_LOG, &st) || !S_ISSOCK (st.st_mode))
d202 1
a202 1
  if ((fd = cygwin_socket (AF_LOCAL, SOCK_DGRAM, 0)) < 0)
d204 1
a204 3
  sun.sun_family = AF_LOCAL;
  strncpy (sun.sun_path, _PATH_LOG, sizeof sun.sun_path);
  if (cygwin_connect (fd, (struct sockaddr *) &sun, sizeof sun))
d206 3
a208 1
      if (get_errno () != EPROTOTYPE)
d210 22
a231 10
	  close (fd);
	  return;
	}
      /* Retry with SOCK_STREAM. */
      if ((fd = cygwin_socket (AF_LOCAL, SOCK_STREAM, 0)) < 0)
	return;
      if (cygwin_connect (fd, (struct sockaddr *) &sun, sizeof sun))
	{
	  close (fd);
	  return;
d233 1
a233 1
      syslogd_inited = inited_stream;
a234 2
  else
    syslogd_inited = inited_dgram;
d237 2
d250 1
a250 1
  if (syslogd_sock >= 0)
@


1.48.4.1
log
@	* cygtls.h (struct _local_storage): Redefine process_ident as wchar_t
	pointer.
	* syslog.cc (CYGWIN_LOG_NAME): Convert to wide char constant.
	(openlog): Convert incoming ident string to wide char.  Fix formatting.
	(vsyslog): Print ident string as wide char string.  Convert message
	string to wide char and call UNICODE Win32 Event functions to make sure
	to use correct codeset.
	* tlsoffset.h: Regenerate.
@
text
@a26 1
#include "tls_pbuf.h"
d28 1
a28 1
#define CYGWIN_LOG_NAME L"Cygwin"
d44 1
a44 1
	sys_mbstowcs_alloc (&_my_tls.locals.process_ident, HEAP_NOTHEAP, ident);
d47 1
a47 2
	    debug_printf ("failed to allocate memory for "
			  "_my_tls.locals.process_ident");
d50 1
d360 1
a360 1
	  if (pass.print ("%ls: ", _my_tls.locals.process_ident) == -1)
d374 1
d380 2
d392 3
a394 7
      HANDLE hEventSrc;

      hEventSrc = RegisterEventSourceW (NULL, _my_tls.locals.process_ident
					      ?: CYGWIN_LOG_NAME);
      if (!hEventSrc)
	debug_printf ("RegisterEventSourceW, %E");
      else
d396 2
a397 8
	  wchar_t *msg_strings[1];
	  tmp_pathbuf tp;
	  msg_strings[0] = tp.w_get ();
	  sys_mbstowcs (msg_strings[0], NT_MAX_PATH, total_msg);
	  if (!ReportEventW (hEventSrc, eventType, 0, 0, cygheap->user.sid (),
			     1, 0, (const wchar_t **) msg_strings, NULL))
	    debug_printf ("ReportEventW, %E");
	  DeregisterEventSource (hEventSrc);
d399 4
@


1.48.4.2
log
@	* fhandler_socket.cc (get_inet_addr): Make externally available.
	* autoload.cc (GetUdpTable): Define.
	* syslog.cc (connect_syslogd): Use get_inet_addr rather than _stat64
	to check for local socket file.  Create socket with type returned by
	get_inet_addr.  If connect on UDP socket works, test if there's
	really a listening peer, otherwise fall back to Windows event log.
	(try_connect_syslogd): Use syslogd_inited flag to check if syslogd
	is available.
@
text
@d4 1
a4 1
   2006, 2007, 2009, 2011 Red Hat, Inc.
a19 2
#include <netinet/in.h>
#include <iphlpapi.h>
a179 3
extern int get_inet_addr (const struct sockaddr *, int,
			  struct sockaddr_storage *, int *,
			  int * = NULL, int * = NULL);
d184 1
a186 2
  struct sockaddr_storage sst;
  int len, type;
d192 4
d198 1
a198 5
  if (!get_inet_addr ((struct sockaddr *) &sun, sizeof sun, &sst, &len, &type))
    return;
  if ((fd = cygwin_socket (AF_LOCAL, type, 0)) < 0)
    return;
  if (cygwin_connect (fd, (struct sockaddr *) &sun, sizeof sun) == 0)
d200 1
a200 3
      /* connect on a dgram socket always succeeds.  We still don't know
	 if syslogd is actually listening. */
      if (type == SOCK_DGRAM)
d202 10
a211 22
	  tmp_pathbuf tp;
	  PMIB_UDPTABLE tab = (PMIB_UDPTABLE) tp.w_get ();
	  DWORD size = 65536;
	  bool found = false;
	  struct sockaddr_in *sa = (struct sockaddr_in *) &sst;

	  if (GetUdpTable (tab, &size, FALSE) == NO_ERROR)
	    {
	      for (DWORD i = 0; i < tab->dwNumEntries; ++i)
		if (tab->table[i].dwLocalAddr == sa->sin_addr.s_addr
		    && tab->table[i].dwLocalPort == sa->sin_port)
		  {
		    found = true;
		    break;
		  }
	      if (!found)
		{
		  /* No syslogd is listening. */
		  close (fd);
		  return;
		}
	    }
d213 1
a213 1
      syslogd_inited = type == SOCK_DGRAM ? inited_dgram : inited_stream;
d215 2
a218 2
  debug_printf ("found /dev/log, fd = %d, type = %s",
		fd, syslogd_inited == inited_stream ? "STREAM" : "DGRAM");
d230 1
a230 1
  if (syslogd_inited != inited_failed)
@


1.47
log
@Remove unneeded header files from source files throughout.
@
text
@d4 1
a4 1
   2006, 2007 Red Hat, Inc.
d278 4
@


1.46
log
@	Throughout, call fcntl64 instead of fcntl or fcntl_worker.
	* fcntl.cc (fcntl_worker): Remove.
	(fcntl64): Add fault handler.  Move fcntl_worker stuff here.  Add case
	for locking and call fhandler's lock method directly.  Make sure that
	F_FLOCK flag isn't set in lock call.
	(_fcntl): Add fault handler.
	* fhandler.cc (fhandler_base::fcntl): Drop lock cases.
	* flock.cc (flock): Add fault handler.  Simplify code.  Call fhandlers
	lock method directly instead of fcntl_worker.  Add debug output.
	(lockf): Add fault handler.  Call fhandlers lock method directly
	instead of fcntl_worker.  Add debug output.
	* winsup.h (fcntl_worker): Drop declaration.
	(fcntl64): Declare.
@
text
@a17 1
#include <stdarg.h>
a19 1
#include <sys/uio.h>
a25 1
#include "thread.h"
@


1.45
log
@	* fhandler_registry.cc (registry_listing): Drop name of HKEY_DYN_DATA.
	(registry_keys): Drop HKEY_DYN_DATA.
	* net.cc: Fix comment.
	* syslog.cc: Ditto.
@
text
@d220 1
a220 1
  fcntl (syslogd_sock, F_SETFD, FD_CLOEXEC);
@


1.44
log
@	* fhandler.cc (fhandler_base::set_no_inheritance): Always use
	SetHandleInformation.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Always use
	UnlockFileEx/LockFileEx functions.
	* net.cc (fdsock): Don't bother to duplicate socket for inheritance.
	* sysconf.cc (get_nproc_values): Take NT for granted.
	(get_avphys): Ditto.
	* syslog.cc (WIN95_EVENT_LOG_PATH): Remove define.
	(get_win95_event_log_path): Remove.
	(vsyslog): Fix formatting.  Take NT for granted.
	* wincap.cc: Remove has_lock_file_ex, has_signal_object_and_wait,
	has_eventlog, has_set_handle_information,
	has_set_handle_information_on_console_handles and supports_smp
	throughout.
	* wincap.h: Ditto.
@
text
@d33 1
a33 2
/* openlog: save the passed args. Don't open the
   system log (NT) or log file (95) yet.  */
d261 7
a267 9
/*
 * syslog: creates the log message and writes to system
 * log (NT) or log file (95). FIXME. WinNT log error messages
 * don't look pretty, but in order to fix this we have to
 * embed resources in the code and tell the NT registry
 * where we are, blech (what happens if we move ?).
 * We could, however, add the resources in Cygwin and
 * always point to that.
 */
@


1.43
log
@white space
@
text
@d4 1
a4 1
   2006 Red Hat, Inc.
a30 4
/* FIXME: These should probably be in the registry. */
/* FIXME: The Win95 path should be whatever slash is */

#define WIN95_EVENT_LOG_PATH "C:\\CYGWIN_SYSLOG.TXT"
a32 10
/*
 * Utility function to help enable moving
 * WIN95_EVENT_LOG_PATH into registry later.
 */
static const char *
get_win95_event_log_path ()
{
  return WIN95_EVENT_LOG_PATH;
}

d275 39
a313 7
    debug_printf ("%x %s", priority, message);
    /* If the priority fails the current mask, reject */
    if ((LOG_MASK (LOG_PRI (priority)) & _my_tls.locals.process_logmask) == 0)
      {
	debug_printf ("failing message %x due to priority mask %x",
		      priority, _my_tls.locals.process_logmask);
	return;
d315 2
d318 2
a319 12
    /* Add default facility if not in the given priority. */
    if (!(priority & LOG_FACMASK))
      priority |= _my_tls.locals.process_facility;

    /* Translate %m in the message to error text */
    char *errtext = strerror (get_errno ());
    int errlen = strlen (errtext);
    int numfound = 0;

    for (const char *cp = message; *cp; cp++)
      if (*cp == '%' && cp[1] == 'm')
	numfound++;
d321 22
a342 2
    char *newmessage = (char *) alloca (strlen (message) +
					(errlen * numfound) + 1);
d344 11
a354 3
    if (newmessage == NULL)
      {
	debug_printf ("failed to allocate newmessage");
d356 2
a357 1
      }
d359 7
a365 3
    char *dst = newmessage;
    for (const char *cp2 = message; *cp2; cp2++)
      if (*cp2 == '%' && cp2[1] == 'm')
d367 2
a368 4
	  cp2++;
	  strcpy (dst, errtext);
	  while (*dst)
	    dst++;
a369 2
      else
	*dst++ = *cp2;
d371 3
a373 2
    *dst = '\0';
    message = newmessage;
d375 6
a380 22
    /* Work out the priority type - we ignore the facility for now.. */
    WORD eventType;
    switch (LOG_PRI (priority))
      {
      case LOG_EMERG:
      case LOG_ALERT:
      case LOG_CRIT:
      case LOG_ERR:
	eventType = EVENTLOG_ERROR_TYPE;
	break;
      case LOG_WARNING:
	eventType = EVENTLOG_WARNING_TYPE;
	break;
      case LOG_NOTICE:
      case LOG_INFO:
      case LOG_DEBUG:
	eventType = EVENTLOG_INFORMATION_TYPE;
	break;
      default:
	eventType = EVENTLOG_ERROR_TYPE;
	break;
      }
d382 1
a382 14
    /* We need to know how long the buffer needs to be.
       The only legal way I can see of doing this is to
       do a vfprintf to /dev/null, and count the bytes
       output, then do it again to a malloc'ed string. This
       is ugly, slow, but prevents core dumps :-).
     */
    pass_handler pass;
    for (int pass_number = 0; pass_number < 2; ++pass_number)
      {
	int n = pass.initialize (pass_number);
	if (n == -1)
	  return;
	else if (n > 0)
	  pass.set_message ((char *) alloca (n));
d384 5
a388 11
	/* Deal with ident_string */
	if (_my_tls.locals.process_ident != NULL)
	  {
	    if (pass.print ("%s: ", _my_tls.locals.process_ident) == -1)
	      return;
	  }
	if (_my_tls.locals.process_logopt & LOG_PID)
	  {
	    if (pass.print ("PID %u: ", getpid ()) == -1)
	      return;
	  }
d390 9
a398 38
	if (!wincap.has_eventlog ())
	  {
	    /* Add a priority string - not needed for systems with
	       eventlog capability. */
	    switch (LOG_PRI (priority))
	      {
	     case LOG_EMERG:
	       pass.print ("%s: ", "LOG_EMERG");
	       break;
	     case LOG_ALERT:
	       pass.print ("%s: ", "LOG_ALERT");
	       break;
	     case LOG_CRIT:
	       pass.print ("%s: ", "LOG_CRIT");
	       break;
	      case LOG_ERR:
		pass.print ("%s: ", "LOG_ERR");
		break;
	      case LOG_WARNING:
		pass.print ("%s: ", "LOG_WARNING");
		break;
	     case LOG_NOTICE:
	       pass.print ("%s: ", "LOG_NOTICE");
	       break;
	      case LOG_INFO:
		pass.print ("%s: ", "LOG_INFO");
	       break;
	     case LOG_DEBUG:
	       pass.print ("%s: ", "LOG_DEBUG");
		break;
	      default:
		pass.print ("%s: ", "LOG_ERR");
		break;
	      }
	  }

	/* Print out the variable part */
	if (pass.print_va (message, ap) == -1)
d400 6
a405 71

      }
    const char *msg_strings[1];
    char *total_msg = pass.get_message ();
    int len = strlen (total_msg);
    if (len != 0 && (total_msg[len - 1] == '\n'))
      total_msg[--len] = '\0';

    msg_strings[0] = total_msg;

    if (_my_tls.locals.process_logopt & LOG_PERROR)
      {
	write (STDERR_FILENO, total_msg, len);
	write (STDERR_FILENO, "\n", 1);
      }

    int fd;
    if ((fd = try_connect_syslogd (priority, total_msg, len + 1)) >= 0)
      ;
    else if (wincap.has_eventlog ())
      {
	/* For NT, open the event log and send the message */
	HANDLE hEventSrc = RegisterEventSourceA (NULL, (_my_tls.locals.process_ident != NULL) ?
					 _my_tls.locals.process_ident : CYGWIN_LOG_NAME);
	if (hEventSrc == NULL)
	  {
	    debug_printf ("RegisterEventSourceA failed with %E");
	    return;
	  }
	if (!ReportEventA (hEventSrc, eventType, 0, 0,
			   cygheap->user.sid (), 1, 0, msg_strings, NULL))
	  debug_printf ("ReportEventA failed with %E");
	DeregisterEventSource (hEventSrc);
      }
    else
      {
	/* Under Windows 95, append the message to the log file */
	char timestamp[24];
	time_t ctime;
	FILE *fp = fopen (get_win95_event_log_path (), "a");
	if (fp == NULL)
	  {
	    debug_printf ("failed to open file %s",
			  get_win95_event_log_path ());
	    return;
	  }
	strftime (timestamp, sizeof timestamp, "%Y-%m-%d %H:%M:%S : ",
		  localtime (&(ctime = time (NULL))));

	/* Now to prevent several syslog messages from being
	   interleaved, we must lock the first byte of the file
	   This works on Win32 even if we created the file above.
	*/
	HANDLE fHandle = cygheap->fdtab[fileno (fp)]->get_handle ();
	for (int i = 0;; i++)
	  if (LockFile (fHandle, 0, 0, 1, 0) == FALSE)
	    if (i == 3)
	      {
		debug_printf ("failed to lock file %s", get_win95_event_log_path ());
		fclose (fp);
		return;
	      }
	    else
	      usleep (1000);
	  else
	    break;
	fputs (timestamp, fp);
	fputs (msg_strings[0], fp);
	fputc ('\n', fp);
	fclose (fp);
      }
@


1.42
log
@	* syslog.cc: Include sys/un.h instead of sys/socket.h.
	(syslogd_inited): Convert to enum type noting the exact result of
	trying to connect to syslog daemon.  Use this way throughout.
	(connect_syslogd): New static function taking over the task to
	connect to syslog socket.  Use correct struct sockaddr_un instead of
	struct sockaddr.
	(try_connect_syslogd): Call connect_syslogd.  If write fails on
	connection oriented socket, try to reconnect to syslog socket and
	try to write again.
@
text
@d259 1
a259 1
         a stream socket, the connection is broken.  In this case,
@


1.41
log
@	* syslog.cc (vklog): Never log kernel messages using the vsyslog
	interface.
@
text
@d20 1
a20 1
#include <sys/socket.h>
d188 6
a193 1
static bool syslogd_inited;
d198 2
a199 2
static int
try_connect_syslogd (int priority, const char *msg, int len)
d201 15
a215 2
  try_connect_guard.init ("try_connect_guard")->acquire ();
  if (!syslogd_inited)
d217 1
a217 11
      struct __stat64 st;
      int fd;
      struct sockaddr sa;

      if (stat64 (_PATH_LOG, &st) || !S_ISSOCK (st.st_mode))
	goto out;
      if ((fd = cygwin_socket (AF_LOCAL, SOCK_DGRAM, 0)) < 0)
	goto out;
      sa.sa_family = AF_LOCAL;
      strncpy (sa.sa_data, _PATH_LOG, sizeof sa.sa_data);
      if (cygwin_connect (fd, &sa, sizeof sa))
d219 2
a220 13
	  if (get_errno () != EPROTOTYPE)
	    {
	      close (fd);
	      goto out;
	    }
	  /* Retry with SOCK_STREAM. */
	  if ((fd = cygwin_socket (AF_LOCAL, SOCK_STREAM, 0)) < 0)
	    goto out;
	  if (cygwin_connect (fd, &sa, sizeof sa))
	    {
	      close (fd);
	      goto out;
	    }
d222 9
a230 3
      syslogd_sock = fd;
      fcntl (syslogd_sock, F_SETFD, FD_CLOEXEC);
      syslogd_inited = true;
d232 10
a241 1
out:
d243 4
a256 1

d258 9
d542 1
a542 1
  if (syslogd_inited && syslogd_sock >= 0)
d546 1
a546 1
      syslogd_inited = false;
@


1.40
log
@	* syslog.cc (vsyslog): Decrement len if trailing \n has been removed.
	Add \n when writing to stderr if LOG_PERROR option is set.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
a501 2
  else
    vsyslog (priority, message, ap);
@


1.39
log
@	* path.cc (path_conv::check): Rework loop removing trailing dots
	and spaces.

	* syslog.cc (vklog): Set facility to LOG_KERN if not set.
@
text
@d405 1
a405 1
      total_msg[len - 1] = '\0';
d410 4
a413 1
      write (STDERR_FILENO, total_msg, len + 1);
@


1.38
log
@whitespace cleanup to force snapshot.
@
text
@d487 2
@


1.37
log
@	* syslog.cc (setlogmask): Don't mask the mask.
	(vsyslog): Fix priority check.
@
text
@d236 1
a236 1
        { pribuf, strlen (pribuf) },
@


1.36
log
@	* syslog.cc (try_connect_syslogd): Add priority parameter. Use writev
	to add the priority to the message in a syslog conformant way.
	(vsyslog): If facility isn't set in the priority, use default facility
	as given in call to openlog. Fix agressive use of spaces in syslog
	output. Call try_connect_syslogd with priority parameter.
@
text
@d82 1
a82 1
  _my_tls.locals.process_logmask = maskpri & LOG_PRIMASK;
d266 1
a266 1
    if (((priority & LOG_PRIMASK) & _my_tls.locals.process_logmask) == 0)
@


1.35
log
@	* Makefile.in (DLL_OFILES): Add fhandler_mailslot.o.
	* devices.h (FH_KMSG): Define new device.
	* devices.in: Add "/dev/kmsg" entry.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Handle case FH_KMSG.
	* fhandler.h (class fhandler_mailslot): New class.
	(class select_stuff): Add device_specific_mailslot pointer.
	* fhandler_mailslot.cc: New file.
	* select.cc (peek_mailslot): New function.
	(verify_mailslot): Ditto.
	(struct mailslotinf): New stuct to handle select on mailslots.
	(thread_mailslot): New function.
	(start_thread_mailslot): Ditto.
	(mailslot_cleanup): Ditto.
	(fhandler_mailslot::select_read): New method.
	* syslog.cc (klog_guard): New muto.
	(dev_kmsg): Local mailslot for kernel message device.
	(vklog): New function.
	(klog): Ditto.
	* winsup.h (vklog): Declare.
	(klog): Ditto.
	* include/sys/syslog.h: Define _PATH_KLOG.
@
text
@d20 1
d193 1
a193 1
try_connect_syslogd (const char *msg, int len)
d229 1
a229 1
  int ret = -1;
d232 10
a241 1
      ret = write (syslogd_sock, msg, len);
d273 4
d351 1
a351 1
	    if (pass.print ("%s : ", _my_tls.locals.process_ident) == -1)
d356 1
a356 1
	    if (pass.print ("PID %u : ", getpid ()) == -1)
d367 1
a367 1
	       pass.print ("%s : ", "LOG_EMERG");
d370 1
a370 1
	       pass.print ("%s : ", "LOG_ALERT");
d373 1
a373 1
	       pass.print ("%s : ", "LOG_CRIT");
d376 1
a376 1
		pass.print ("%s : ", "LOG_ERR");
d379 1
a379 1
		pass.print ("%s : ", "LOG_WARNING");
d382 1
a382 1
	       pass.print ("%s : ", "LOG_NOTICE");
d385 1
a385 1
		pass.print ("%s : ", "LOG_INFO");
d388 1
a388 1
	       pass.print ("%s : ", "LOG_DEBUG");
d391 1
a391 1
		pass.print ("%s : ", "LOG_ERR");
d413 1
a413 1
    if ((fd = try_connect_syslogd (total_msg, len + 1)) >= 0)
@


1.34
log
@white space and minor comment cleanup.
@
text
@d464 32
@


1.33
log
@	* syslog.cc (try_connect_guard): Remove useless conditionalized code.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
d204 1
a204 1
        goto out;
d208 1
a208 1
        {
d233 1
a233 1
         it falls back to the usual logging method for this OS. */
d235 1
a235 1
        ret = syslogd_sock;
@


1.32
log
@	* syslog.cc: Include sys/socket.h.
	(try_connect_guard): New static variable.
	(syslogd_inited): Ditto.
	(syslogd_sock): Ditto.
	(try_connect_syslogd): New function to connect and write syslog to
	local syslogd.
	(vsyslog): Log to stderr if LOG_PERROR flag has been given to openlog.
	Try logging to syslogd.  Use Event Log resp. log file as fallback.
	(closelog): Close socket to syslogd.
	* include/sys/syslog.h (_PATH_LOG): Define.
	(INTERNAL_NOPRI): Define if SYSLOG_NAMES is defined.
	(INTERNAL_MARK): Ditto.
	(struct _code): Ditto.
	(prioritynames): Ditto.
	(facilitynames): Ditto.
@
text
@a236 3
#ifdef EXC_GUARD
  InterlockedExchange (&try_connect_guard, 2);
#else
a237 1
#endif
@


1.31
log
@* cygtls.cc (free_local): New macro.
(_cygtls::remove): Use free_local to free known-malloced local variables.
* cygtls.h: Mark some variables as "malloced".
* net.cc (enum struct_type): Rename from is_* to t_* for clarity.
(dump_protoent): Delete.
(dup_ent): New macro.
(__dup_ent): Renamed from dup_ent.  Change arguments for convenience.  Replace
first argument with newly alloced value.  Allocate a rounded number of bytes in
an attempt to try to reuse space.  Subsume "dump_protent".
(cygwin_getprotobyname): Simplify using new dup_ent functionality.
(cygwin_getprotobynumber): Ditto.
(cygwin_getservbyname): Ditto.
(cygwin_getservbyport): Ditto.
(cygwin_gethostname): Ditto.
(cygwin_gethostbyname): Ditto.
* tlsoffsets.h: Regenerate.
* syslog.cc (openlog): Use NULL rather than 0, for consistency with the rest of
cygwin.
(pass_handler::initialize): Use unbuffered I/O in pass one.
@
text
@d11 2
d19 1
d185 60
d399 7
a405 1
    if (wincap.has_eventlog ())
d471 8
a478 1
  ;
@


1.30
log
@Reorganize header file inclusion throughout so that cygerrno.h comes first.
* fhandler.h (select_record::thread_errno): Save any encountered errno here.
(select_record::set_select_errno): New function.
(select_record::saw_error): New function.
(select_record::select_record): Initialize thread_errno to zero.
* select.cc (set_handle_or_return_if_not_open): Set thread_errno on failure.
(select_stuff::wait): Record errno for later resurrection in calling thread.
(peek_serial): Ditto.
@
text
@d53 1
a53 1
	_my_tls.locals.process_ident = 0;
d58 1
a58 1
	if (_my_tls.locals.process_ident == NULL)
d141 1
@


1.29
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d17 1
a21 1
#include "cygerrno.h"
@


1.28
log
@	* syslog.cc (vsyslog): Print debug message if ReportEventA fails.
@
text
@d24 1
d42 2
a43 21
/* FIXME: For MT safe code these will need to be replaced */

#ifdef _MT_SAFE
#define process_ident  _reent_winsup ()->_process_ident
#define process_logopt  _reent_winsup ()->_process_logopt
#define process_facility  _reent_winsup ()->_process_facility
  /* Default priority logmask */
#define process_logmask _reent_winsup ()->_process_logmask
#else
static char *process_ident = 0;
static int process_logopt = 0;
static int process_facility = 0;

/* Default priority logmask */
static int process_logmask = LOG_UPTO (LOG_DEBUG);
#endif

/*
 * openlog: save the passed args. Don't open the
 * system log (NT) or log file (95) yet.
 */
d50 1
a50 1
    if (process_ident != NULL)
d52 2
a53 2
	free (process_ident);
	process_ident = 0;
d57 2
a58 2
	process_ident = (char *) malloc (strlen (ident) + 1);
	if (process_ident == NULL)
d60 1
a60 1
	    debug_printf ("failed to allocate memory for process_ident");
d63 1
a63 1
	strcpy (process_ident, ident);
d65 2
a66 2
    process_logopt = logopt;
    process_facility = facility;
d75 1
a75 1
    return process_logmask;
d77 2
a78 2
  int old_mask = process_logmask;
  process_logmask = maskpri & LOG_PRIMASK;
d83 2
a84 2
/* Private class used to handle formatting of syslog message */
/* It is named pass_handler because it does a two-pass handling of log
d196 1
a196 1
    if (((priority & LOG_PRIMASK) & process_logmask) == 0)
d199 1
a199 1
		      priority, process_logmask);
d275 1
a275 1
	if (process_ident != NULL)
d277 1
a277 1
	    if (pass.print ("%s : ", process_ident) == -1)
d280 1
a280 1
	if (process_logopt & LOG_PID)
d338 2
a339 2
	HANDLE hEventSrc = RegisterEventSourceA (NULL, (process_ident != NULL) ?
					 process_ident : CYGWIN_LOG_NAME);
@


1.27
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d363 3
a365 2
	ReportEventA (hEventSrc, eventType, 0, 0,
		      cygheap->user.sid (), 1, 0, msg_strings, NULL);
@


1.26
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d18 1
a19 1
#include "path.h"
@


1.25
log
@	* cygwin.din: Add vsyslog.
	* fhandler.cc (fhandler_base::write): Only make file sparse if the
	seeked area is >= 128K.
	* syslog.cc (vsyslog): New function, overtaking functionality from
	syslog.
	(syslog): Just call vsyslog.
	* include/cygwin/version.h: Bump API minor.
	* include/sys/syslog.h: Add vsyslog declaration.
@
text
@a16 1
#include <errno.h>
@


1.24
log
@Do some minor reformatting of 'extern "C"' use throughout.
* autoload.cc (GetSystemTimes): Define new autoload function.
* fhandler_proc.cc (proc_listing): Add cpuinfo and partitions entries.
(fhandler_proc::fill_filebuf): Add PROC_CPUINFO and PROC_PARTITIONS cases.
(format_proc_uptime): Use GetSystemTimes if available.
(read_value): New macro.
(print): New macro.
(cpuid): New function.
(can_set_flag): New function.
(format_proc_cpuinfo): New function.
(format_proc_partitions): New function.
@
text
@d211 1
a211 1
syslog (int priority, const char *message, ...)
a283 2
    va_list ap;

a341 1
	va_start (ap, message);
a343 1
	va_end (ap);
d405 9
@


1.23
log
@
 2003-02-23  Pierre Humblet  <pierre.humblet@@ieee.org>

       * syslog.cc (syslog): Do not unlock the file before closing it
       and remove debug_printf about stream errors.
@
text
@d63 1
a63 2
extern "C"
void
d210 1
a210 2
extern "C"
void
d411 1
a411 2
extern "C"
void
@


1.22
log
@* syslog.cc (syslog): Do not print the Windows pid.  Print the Cygwin pid as an
unsigned decimal.  On Win95 print a timestamp and attempt to lock the file up
to four times in 3 ms.
@
text
@a408 3
	UnlockFile (fHandle, 0, 0, 1, 0);
	if (ferror (fp))
	  debug_printf ("error in writing syslog");
@


1.21
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d305 1
a305 2
	    if (pass.print ("Win32 Process Id = 0x%X : Cygwin Process Id = 0x%X : ",
			GetCurrentProcessId (),  getpid ()) == -1)
d377 2
d386 3
d394 13
a406 6
	if (LockFile (fHandle, 0, 0, 1, 0) == FALSE)
	  {
	    debug_printf ("failed to lock file %s", get_win95_event_log_path ());
	    fclose (fp);
	    return;
	  }
d411 1
a411 3
	  {
	    debug_printf ("error in writing syslog");
	  }
@


1.21.16.1
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d19 1
a20 1
#include "fhandler.h"
@


1.21.16.2
log
@merge from trunk
@
text
@d305 2
a306 1
	    if (pass.print ("PID %u : ", getpid ()) == -1)
a377 2
	char timestamp[24];
	time_t ctime;
a384 3
	strftime (timestamp, sizeof timestamp, "%Y-%m-%d %H:%M:%S : ",
		  localtime (&(ctime = time (NULL))));

d390 6
a395 13
	for (int i = 0;; i++)
	  if (LockFile (fHandle, 0, 0, 1, 0) == FALSE)
	    if (i == 3)
	      {
		debug_printf ("failed to lock file %s", get_win95_event_log_path ());
		fclose (fp);
		return;
	      }
	    else
	      usleep (1000);
	  else
	    break;
	fputs (timestamp, fp);
d400 3
a402 1
	  debug_printf ("error in writing syslog");
@


1.21.16.3
log
@merge from trunk
@
text
@d409 3
@


1.21.16.4
log
@merge from trunk
@
text
@d63 2
a64 1
extern "C" void
d211 2
a212 1
extern "C" void
d413 2
a414 1
extern "C" void
@


1.21.16.5
log
@merge from trunk
@
text
@d17 1
d211 1
a211 1
vsyslog (int priority, const char *message, va_list ap)
d284 2
d344 1
d347 1
a408 9
}

extern "C" void
syslog (int priority, const char *message, ...)
{
  va_list ap;
  va_start (ap, message);
  vsyslog (priority, message, ap);
  va_end (ap);
@


1.20
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d45 3
a47 3
#define process_ident  _reent_winsup()->_process_ident
#define process_logopt  _reent_winsup()->_process_logopt
#define process_facility  _reent_winsup()->_process_facility
d49 1
a49 1
#define process_logmask _reent_winsup()->_process_logmask
d306 1
a306 1
			GetCurrentProcessId(),  getpid ()) == -1)
d392 1
a392 1
	    debug_printf ("failed to lock file %s", get_win95_event_log_path());
@


1.19
log
@* syscalls.cc (stat_worker): Make global.  Accept path_conv parameter for
passing information back to caller.
* winsup.h: Declare stat_worker.
* dir.cc (opendir): Use stat_worker rather than stat and pass path_conv
parameter to stat_worker for later inspection.
* syslog.cc (syslog): Teach syslog about syslog priorities other than LOG_ERR,
LOG_WARNING and LOG_INFO
* path.cc (path_conv::check): Don't perform file system or rootdir checks on
devices.
@
text
@d17 1
@


1.18
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d260 3
d269 1
d271 1
d315 9
d330 3
d335 3
@


1.17
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d19 1
@


1.17.2.1
log
@Merged changes from HEAD
@
text
@a18 1
#include "path.h"
@


1.17.2.2
log
@Merged changes from HEAD
@
text
@a16 1
#include <errno.h>
a259 3
      case LOG_EMERG:
      case LOG_ALERT:
      case LOG_CRIT:
a265 1
      case LOG_NOTICE:
a266 1
      case LOG_DEBUG:
a309 9
	     case LOG_EMERG:
	       pass.print ("%s : ", "LOG_EMERG");
	       break;
	     case LOG_ALERT:
	       pass.print ("%s : ", "LOG_ALERT");
	       break;
	     case LOG_CRIT:
	       pass.print ("%s : ", "LOG_CRIT");
	       break;
a315 3
	     case LOG_NOTICE:
	       pass.print ("%s : ", "LOG_NOTICE");
	       break;
a317 3
	       break;
	     case LOG_DEBUG:
	       pass.print ("%s : ", "LOG_DEBUG");
@


1.17.2.3
log
@Merged changes from HEAD
@
text
@d45 3
a47 3
#define process_ident  _reent_winsup ()->_process_ident
#define process_logopt  _reent_winsup ()->_process_logopt
#define process_facility  _reent_winsup ()->_process_facility
d49 1
a49 1
#define process_logmask _reent_winsup ()->_process_logmask
d306 1
a306 1
			GetCurrentProcessId (),  getpid ()) == -1)
d392 1
a392 1
	    debug_printf ("failed to lock file %s", get_win95_event_log_path ());
@


1.16
log
@Update copyrights.
@
text
@d303 1
a303 1
	if (!iswinnt)
d305 2
a306 2
	    /* Add a priority string - not needed for NT
	       as NT has its own priority codes. */
d339 1
a339 1
    if (iswinnt)
@


1.15
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998 Cygnus Solutions.
@


1.14
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d303 1
a303 1
	if (os_being_run != winNT)
d339 1
a339 1
    if (os_being_run == winNT)
@


1.13
log
@forced commit
@
text
@d17 1
@


1.12
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@@


1.11
log
@* cygwin.din: Add export for setlogmask().
* syslog.cc (setlogmask): New function.
@
text
@d366 1
a366 1
	HANDLE fHandle = fdtab[fileno (fp)]->get_handle ();
@


1.10
log
@        * syslog.cc (syslog): Add users SID to NT syslog entry.
@
text
@a87 2
#if 0
/* FIXME: nobody calls setlogmask? */
a98 1
#endif
@


1.9
log
@* select.cc (cygwin_select): Correct logic for "always_ready" fds or when there
is no wait specified.
* syslog.cc (pass_handler::set_message): Zero the buffer prior to setting it.
@
text
@d20 1
d352 1
a352 1
		      NULL, 1, 0, msg_strings, NULL);
@


1.8
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d74 1
a74 1
	if (process_ident == 0)
d129 1
a129 1
    void set_message (char *s) { message_ = s; }
d182 1
a182 1
    if (fp_ != 0)
d190 1
a190 1
    else if (message_ != 0)
d292 1
a292 1
	if (process_ident != 0)
d343 1
a343 1
	HANDLE hEventSrc = RegisterEventSourceA (NULL, (process_ident != 0) ?
d345 1
a345 1
	if (hEventSrc == 0)
d358 1
a358 1
	if (fp == 0)
@


1.7
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d17 1
d20 1
@


1.6
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d18 1
@


1.5
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d17 1
@


1.4
log
@Fix premature use of fdtab.
@
text
@d364 1
a364 1
	HANDLE fHandle = dtable[fileno (fp)]->get_handle ();
@


1.3
log
@* syslog.cc (syslog): Use a less malloc-intensive method for allocating the
buffer.  Also fix a buffer overrun.
@
text
@d364 1
a364 1
	HANDLE fHandle = fdtab[fileno (fp)]->get_handle ();
@


1.2
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d62 1
a62 1
    if (process_ident != 0)
d125 1
d141 1
a141 1
  if (fp_ != 0)
a145 2
  if (message_ != 0)
      delete[] message_;
d152 5
a156 1
    if (pass_number == 0)
d158 2
a159 17
	fp_ = fopen ("/dev/null", "wb");
	if (fp_ == 0)
	  {
	    debug_printf ("failed to open /dev/null");
	    return -1;
	  }
	total_len_ = 0;
      }
    else
      {
	message_ = new char[total_len_ + 1];
	if (message_ == 0)
	  {
	    debug_printf ("failed to allocate message_");
	    return -1;
	  }
	message_[0] = '\0';
d161 1
d182 3
a184 3
	    return -1;
	  total_len_ += len;
	  return 0;
d228 2
a229 1
    char *newmessage = new char [strlen (message) + (errlen * numfound)];
d231 1
a231 1
    if (newmessage == 0)
a275 1
    int pass_number = 0;
d279 1
a279 1
    for (; pass_number < 2; ++pass_number)
d281 2
a282 1
	if (pass.initialize (pass_number) == -1)
d284 2
d364 1
a364 1
	HANDLE fHandle = dtable[fileno (fp)]->get_handle ();
@


1.1
log
@Initial revision
@
text
@d11 1
a16 1
#include "winsup.h"
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
