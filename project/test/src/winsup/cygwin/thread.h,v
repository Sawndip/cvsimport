head	1.140;
access;
symbols
	cygwin-1_7_35-release:1.140
	cygwin-1_7_34-release:1.139
	cygwin-1_7_33-release:1.139
	cygwin-1_7_32-release:1.139
	cygwin-1_7_31-release:1.139
	cygwin-1_7_30-release:1.139
	cygwin-1_7_29-release:1.139
	cygwin-1_7_29-release-branchpoint:1.139.0.2
	cygwin-pre-user-db:1.139
	cygwin-1_7_28-release:1.139
	cygwin-1_7_27-release:1.139
	cygwin-1_7_26-release:1.139
	cygwin-1_7_25-release:1.139
	cygwin-1_7_24-release:1.139
	cygwin-1_7_23-release:1.139
	cygwin-1_7_22-release:1.138
	cygwin-1_7_21-release:1.138
	cygwin-1_7_20-release:1.138
	cygwin-1_7_19-release:1.138
	cygwin-64bit-postmerge:1.138
	cygwin-64bit-premerge-branch:1.137.0.2
	cygwin-64bit-premerge:1.137
	cygwin-1_7_18-release:1.137
	post-ptmalloc3:1.131.2.6
	pre-ptmalloc3:1.131.2.6
	cygwin-1_7_17-release:1.132
	cygwin-64bit-branch:1.131.0.2
	cygwin-1_7_16-release:1.130
	cygwin-1_7_15-release:1.127
	cygwin-1_7_14_2-release:1.127
	cygwin-1_7_14-release:1.127
	cygwin-1_7_12-release:1.127
	cygwin-1_7_11-release:1.127
	cygwin-1_7_10-release:1.125
	signal-rewrite:1.123.0.2
	pre-notty:1.121
	cygwin-1_7_9-release:1.115
	cv-post-1_7_9:1.114.0.2
	cygwin-1_7_8-release:1.114
	cygwin-1_7_7-release:1.114
	cygwin-1_7_5-release:1.114
	cygwin-1_7_4-release:1.114
	cygwin-1_7_3-release:1.114
	cygwin-1_7_2-release:1.114
	fifo_doover3:1.111.0.2
	cygwin-1_7_1-release:1.111
	prefifo:1.111
	cv-branch-2:1.110.0.2
	pre-ripout-set_console_state_for_spawn:1.108
	EOL_registry_mounts:1.108
	preoverlapped:1.105
	drop_9x_support_start:1.104
	cr-0x5f1:1.103.0.8
	cv-branch:1.103.0.6
	pre-ptymaster-archetype:1.103
	cr-0x3b58:1.103.0.4
	cr-0x5ef:1.103.0.2
	after-mmap-privanon-noreserve:1.103
	after-mmap-revamp:1.103
	before-mmap-revamp:1.103
	cgf-more-exit-sync:1.103
	post_wait_sig_exit:1.103
	pre_wait_sig_exit:1.103
	reparent-point:1.92
	noreparent:1.92.0.2
	cr-0x5e6:1.91.0.2
	cr-0x9e:1.85.0.4
	cr-0x9d:1.85.0.2
	cgf-deleteme:1.84.0.2
	pre-sigrewrite:1.77
	corinna-01:1.76
	cr-0x9c:1.71.4.1.0.2
	cr-0x9b:1.71.0.4
	cr-0x99:1.71
	Z-emcb-cygwin_daemon:1.71.0.2
	w32api-2_2:1.60
	mingw-runtime-2_4:1.60
	pre-cgf-merge:1.72
	cgf-dev-branch:1.60.0.2
	predaemon:1.33
	cygwin_daemon_merge_HEAD:1.33
	pregp02r1:1.33.0.2
	cygnus_cvs_20020108_pre:1.31
	Z-cygwin_daemon_merge-new_HEAD:1.48
	Z-cygwin_daemon_merge_HEAD:1.48
	cygwin_daemon:1.27.0.4;
locks; strict;
comment	@ * @;
expand	@o@;


1.140
date	2015.02.25.17.50.13;	author corinna;	state Exp;
branches;
next	1.139;

1.139
date	2013.07.23.14.15.20;	author corinna;	state Exp;
branches;
next	1.138;

1.138
date	2013.04.23.09.44.34;	author corinna;	state Exp;
branches;
next	1.137;

1.137
date	2013.03.31.12.35.44;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2013.01.21.04.38.29;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2013.01.07.19.34.44;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2013.01.07.16.01.10;	author cgf;	state Exp;
branches;
next	1.133;

1.133
date	2012.10.23.10.17.29;	author corinna;	state Exp;
branches;
next	1.132;

1.132
date	2012.08.15.19.07.42;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2012.07.21.22.58.20;	author cgf;	state Exp;
branches
	1.131.2.1;
next	1.130;

1.130
date	2012.06.19.00.52.59;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2012.06.19.00.38.02;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2012.06.17.20.50.24;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2012.02.13.13.12.37;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2012.02.11.17.37.02;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2012.01.11.19.07.10;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2011.08.24.15.18.17;	author corinna;	state Exp;
branches;
next	1.123;

1.123
date	2011.08.03.16.40.48;	author yselkowitz;	state Exp;
branches;
next	1.122;

1.122
date	2011.07.21.09.39.22;	author yselkowitz;	state Exp;
branches;
next	1.121;

1.121
date	2011.05.15.18.49.40;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2011.05.04.06.16.58;	author cgf;	state Exp;
branches;
next	1.119;

1.119
date	2011.05.03.01.13.37;	author yselkowitz;	state Exp;
branches;
next	1.118;

1.118
date	2011.05.01.17.42.41;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2011.04.30.10.20.25;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2011.03.29.10.32.40;	author corinna;	state Exp;
branches;
next	1.115;

1.115
date	2011.03.29.07.49.25;	author corinna;	state Exp;
branches;
next	1.114;

1.114
date	2010.02.22.20.36.04;	author cgf;	state Exp;
branches
	1.114.2.1;
next	1.113;

1.113
date	2010.02.12.20.07.13;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2010.02.10.07.25.26;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2009.06.30.21.18.44;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2009.01.20.12.40.31;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2009.01.03.05.12.22;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2008.04.01.13.22.47;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2008.02.15.17.53.11;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2007.11.27.14.45.14;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2007.02.22.12.34.55;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2007.02.20.15.48.04;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2005.09.06.19.22.54;	author corinna;	state Exp;
branches
	1.103.8.1;
next	1.102;

1.102
date	2005.09.05.15.17.03;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2005.08.05.16.14.41;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2005.07.05.03.16.46;	author cgf;	state Exp;
branches;
next	1.99;

1.99
date	2005.07.03.03.25.19;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2005.07.03.02.40.30;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2005.06.11.04.56.35;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2005.06.09.05.11.51;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2005.06.01.14.55.45;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2005.05.30.18.37.41;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2005.05.29.02.42.36;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2004.05.28.19.50.07;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2004.04.10.00.53.25;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2004.03.30.21.27.50;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2004.03.04.21.04.13;	author tpfaff;	state Exp;
branches;
next	1.88;

1.88
date	2004.02.24.11.33.15;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2004.02.12.03.01.58;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2004.02.09.04.04.24;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2004.01.14.15.45.37;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2003.12.14.07.09.22;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2003.12.12.04.15.32;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2003.12.03.05.21.55;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2003.12.02.01.36.08;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2003.12.01.22.10.57;	author tpfaff;	state Exp;
branches;
next	1.78;

1.78
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.76;

1.76
date	2003.10.31.20.42.56;	author tpfaff;	state Exp;
branches;
next	1.75;

1.75
date	2003.10.27.21.12.42;	author tpfaff;	state Exp;
branches;
next	1.74;

1.74
date	2003.10.27.11.48.29;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2003.10.24.19.34.47;	author tpfaff;	state Exp;
branches;
next	1.72;

1.72
date	2003.09.20.02.43.18;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.24.20.14.01;	author tpfaff;	state Exp;
branches
	1.71.4.1;
next	1.70;

1.70
date	2003.06.16.03.24.12;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2003.05.15.19.42.51;	author tpfaff;	state Exp;
branches;
next	1.68;

1.68
date	2003.04.17.19.57.01;	author tpfaff;	state Exp;
branches;
next	1.67;

1.67
date	2003.04.15.20.14.12;	author tpfaff;	state Exp;
branches;
next	1.66;

1.66
date	2003.03.27.19.52.20;	author tpfaff;	state Exp;
branches;
next	1.65;

1.65
date	2003.03.23.10.52.02;	author tpfaff;	state Exp;
branches;
next	1.64;

1.64
date	2003.03.18.20.12.05;	author tpfaff;	state Exp;
branches;
next	1.63;

1.63
date	2003.03.18.20.01.06;	author tpfaff;	state Exp;
branches;
next	1.62;

1.62
date	2003.03.18.19.49.38;	author tpfaff;	state Exp;
branches;
next	1.61;

1.61
date	2003.03.18.19.39.21;	author tpfaff;	state Exp;
branches;
next	1.60;

1.60
date	2003.01.10.12.32.47;	author corinna;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2003.01.09.20.57.54;	author tpfaff;	state Exp;
branches;
next	1.58;

1.58
date	2003.01.09.20.50.22;	author tpfaff;	state Exp;
branches;
next	1.57;

1.57
date	2003.01.09.20.40.44;	author tpfaff;	state Exp;
branches;
next	1.56;

1.56
date	2002.12.12.03.09.38;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2002.11.24.13.54.14;	author rbcollins;	state Exp;
branches;
next	1.54;

1.54
date	2002.10.17.08.44.18;	author rbcollins;	state Exp;
branches;
next	1.53;

1.53
date	2002.09.30.11.43.43;	author rbcollins;	state Exp;
branches;
next	1.52;

1.52
date	2002.09.30.02.51.21;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2002.09.29.23.47.45;	author rbcollins;	state Exp;
branches;
next	1.50;

1.50
date	2002.09.29.02.19.35;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.27.15.08.50;	author rbcollins;	state Exp;
branches;
next	1.48;

1.48
date	2002.09.21.03.59.58;	author rbcollins;	state Exp;
branches;
next	1.47;

1.47
date	2002.09.21.03.20.27;	author rbcollins;	state Exp;
branches;
next	1.46;

1.46
date	2002.09.21.01.59.46;	author rbcollins;	state Exp;
branches;
next	1.45;

1.45
date	2002.09.20.23.46.12;	author rbcollins;	state Exp;
branches;
next	1.44;

1.44
date	2002.09.20.22.34.05;	author rbcollins;	state Exp;
branches;
next	1.43;

1.43
date	2002.09.17.09.12.36;	author rbcollins;	state Exp;
branches;
next	1.42;

1.42
date	2002.09.16.16.09.54;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.16.10.53.29;	author rbcollins;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.04.14.17.29;	author rbcollins;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.23.07.36.21;	author rbcollins;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.13.17.28.11;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.11.16.06.16;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.10.02.40.13;	author rbcollins;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.10.01.10.44;	author rbcollins;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.05.12.39.55;	author rbcollins;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.26.12.46.26;	author rbcollins;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.05.06.09.09;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.29.09.01.01;	author rbcollins;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.25.11.45.25;	author rbcollins;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.12.03.18.05;	author rbcollins;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2001.09.11.20.01.01;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.11.08.15.39;	author rbcollins;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.09.22.39.35;	author rbcollins;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.22.21.51.48;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.26.14.47.48;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.24.22.26.53;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.06.22.23.43;	author rbcollins;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.30.18.21.48;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.21.14.23.47;	author rbcollins;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.14.07.06.02;	author rbcollins;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.13.15.28.20;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.12.04.04.53;	author rbcollins;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.02.04.27.12;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.01.03.06.02;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.21.02.17.58;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.19.22.48.26;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.18.02.49.29;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.17.01.14.57;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.15.01.37.06;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.25.16.36.12;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.13.04.40.36;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.24.02.49.44;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.131.2.1
date	2012.08.14.19.29.32;	author corinna;	state Exp;
branches;
next	1.131.2.2;

1.131.2.2
date	2012.08.16.09.41.45;	author corinna;	state Exp;
branches;
next	1.131.2.3;

1.131.2.3
date	2012.10.23.10.21.21;	author corinna;	state Exp;
branches;
next	1.131.2.4;

1.131.2.4
date	2012.11.16.13.48.24;	author corinna;	state Exp;
branches;
next	1.131.2.5;

1.131.2.5
date	2013.01.09.16.27.22;	author corinna;	state Exp;
branches;
next	1.131.2.6;

1.131.2.6
date	2013.01.21.13.52.11;	author corinna;	state Exp;
branches;
next	1.131.2.7;

1.131.2.7
date	2013.04.11.12.13.01;	author corinna;	state Exp;
branches;
next	;

1.114.2.1
date	2011.03.11.11.37.49;	author corinna;	state Exp;
branches;
next	;

1.103.8.1
date	2007.11.29.11.14.52;	author corinna;	state Exp;
branches;
next	1.103.8.2;

1.103.8.2
date	2008.02.18.14.08.37;	author corinna;	state Exp;
branches;
next	;

1.84.2.1
date	2004.01.11.18.13.52;	author cgf;	state Exp;
branches;
next	;

1.71.4.1
date	2003.09.20.02.48.14;	author cgf;	state Exp;
branches;
next	;

1.60.2.1
date	2003.03.19.19.59.56;	author cgf;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2003.04.03.01.32.33;	author cgf;	state Exp;
branches;
next	1.60.2.3;

1.60.2.3
date	2003.05.10.17.20.54;	author cgf;	state Exp;
branches;
next	1.60.2.4;

1.60.2.4
date	2003.05.26.19.39.07;	author cgf;	state Exp;
branches;
next	1.60.2.5;

1.60.2.5
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.27.4.1
date	2001.09.27.12.33.43;	author rbcollins;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2001.09.29.09.35.31;	author rbcollins;	state Exp;
branches;
next	1.27.4.3;

1.27.4.3
date	2002.01.04.03.56.11;	author rbcollins;	state Exp;
branches;
next	1.27.4.4;

1.27.4.4
date	2002.02.28.12.53.28;	author rbcollins;	state Exp;
branches;
next	1.27.4.5;

1.27.4.5
date	2002.06.13.14.34.14;	author rbcollins;	state Exp;
branches;
next	1.27.4.6;

1.27.4.6
date	2002.06.15.10.26.32;	author rbcollins;	state Exp;
branches;
next	1.27.4.7;

1.27.4.7
date	2002.06.23.08.05.46;	author rbcollins;	state Exp;
branches;
next	1.27.4.8;

1.27.4.8
date	2002.07.04.20.09.47;	author scottc;	state Exp;
branches;
next	1.27.4.9;

1.27.4.9
date	2002.09.16.17.24.17;	author scottc;	state Exp;
branches;
next	1.27.4.10;

1.27.4.10
date	2002.09.17.09.54.50;	author scottc;	state Exp;
branches;
next	1.27.4.11;

1.27.4.11
date	2002.09.20.22.53.14;	author scottc;	state Exp;
branches;
next	1.27.4.12;

1.27.4.12
date	2002.09.21.08.13.47;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.140
log
@	* fhandler_tape.cc (fhandler_dev_tape::_lock): Add cw_sig_restart to
	cygwait call.
	* thread.cc (pthread_mutex::lock): Ditto.
	(semaphore::_timedwait): Fix formatting.
	(semaphore::_wait): Ditto.
	* thread.h (fast_mutex::lock): Ditto.

	...and fix ChangeLog accordingly.
@
text
@/* thread.h: Locking and threading module definitions

   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009,
   2010, 2011, 2012, 2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#pragma once

#define LOCK_MMAP_LIST   1

#define WRITE_LOCK 1
#define READ_LOCK  2

/* Default is a 1 Megs stack with a 4K guardpage.  The pthread stacksize
   does not include the guardpage size, so we subtract the default guardpage
   size. Additionally, the Windows stack handling disallows to use the last
   two pages as guard page  (tested on XP and W7).  That results in a zone of
   three pages which have to be subtract to get the actual stack size. */
#define PTHREAD_DEFAULT_STACKSIZE (1024 * 1024 - 3 * wincap.page_size ())
#define PTHREAD_DEFAULT_GUARDSIZE (wincap.page_size ())

#include <pthread.h>
#include <limits.h>
#include "security.h"
#include <errno.h>
#include "cygerrno.h"
#include "cygwait.h"

class fast_mutex
{
public:
  fast_mutex () :
    lock_counter (0), win32_obj_id (0)
  {
  }

  ~fast_mutex ()
  {
    if(win32_obj_id)
      CloseHandle (win32_obj_id);
  }

  bool init ()
  {
    lock_counter = 0;
    win32_obj_id = ::CreateEvent (&sec_none_nih, false, false, NULL);
    if (!win32_obj_id)
      {
	debug_printf ("CreateEvent failed. %E");
	return false;
      }
    return true;
  }

  void lock ()
  {
    if (InterlockedIncrement (&lock_counter) != 1)
      cygwait (win32_obj_id, cw_infinite, cw_sig | cw_sig_restart);
  }

  void unlock ()
  {
    if (InterlockedDecrement (&lock_counter))
      ::SetEvent (win32_obj_id);
  }

private:
  LONG lock_counter;
  HANDLE win32_obj_id;
};

class per_process;
class pinfo;

#define PTHREAD_MAGIC 0xdf0df045
#define PTHREAD_MUTEX_MAGIC PTHREAD_MAGIC+1
#define PTHREAD_KEY_MAGIC PTHREAD_MAGIC+2
#define PTHREAD_ATTR_MAGIC PTHREAD_MAGIC+3
#define PTHREAD_MUTEXATTR_MAGIC PTHREAD_MAGIC+4
#define PTHREAD_COND_MAGIC PTHREAD_MAGIC+5
#define PTHREAD_CONDATTR_MAGIC PTHREAD_MAGIC+6
#define SEM_MAGIC PTHREAD_MAGIC+7
#define PTHREAD_ONCE_MAGIC PTHREAD_MAGIC+8
#define PTHREAD_RWLOCK_MAGIC PTHREAD_MAGIC+9
#define PTHREAD_RWLOCKATTR_MAGIC PTHREAD_MAGIC+10
#define PTHREAD_SPINLOCK_MAGIC PTHREAD_MAGIC+11

#define MUTEX_OWNER_ANONYMOUS ((pthread_t) -1)

typedef uint32_t thread_magic_t;

/* verifyable_object should not be defined here - it's a general purpose class */

class verifyable_object
{
public:
  thread_magic_t magic;

  verifyable_object (thread_magic_t verifyer): magic (verifyer) {}
  virtual ~verifyable_object () { magic = 0; }
};

typedef enum
{
  VALID_OBJECT,
  INVALID_OBJECT,
  VALID_STATIC_OBJECT
} verifyable_object_state;

template <class list_node> inline void
List_insert (list_node *&head, list_node *node)
{
  if (!node)
    return;
  do
    node->next = head;
  while (InterlockedCompareExchangePointer ((PVOID volatile *) &head,
					    node, node->next) != node->next);
}

template <class list_node> inline void
List_remove (fast_mutex &mx, list_node *&head, list_node *node)
{
  if (!node)
    return;
  mx.lock ();
  if (head)
    {
      if (InterlockedCompareExchangePointer ((PVOID volatile *) &head,
					     node->next, node) != node)
	{
	  list_node *cur = head;

	  while (cur->next && node != cur->next)
	    cur = cur->next;
	  if (node == cur->next)
	    cur->next = cur->next->next;
	}
    }
  mx.unlock ();
}


template <class list_node> class List
{
 public:
  List() : head(NULL)
  {
    mx_init ();
  }

  ~List()
  {
  }

  void fixup_after_fork ()
  {
    mx_init ();
  }

  void insert (list_node *node)
  {
    List_insert (head, node);
  }

  void remove (list_node *node)
  {
    List_remove (mx, head, node);
  }

  void for_each (void (list_node::*callback) ())
  {
    mx.lock ();
    list_node *cur = head;
    while (cur)
      {
	(cur->*callback) ();
	cur = cur->next;
      }
    mx.unlock ();
  }

  fast_mutex mx;
  list_node *head;

protected:
  void mx_init ()
  {
    if (!mx.init ())
      api_fatal ("Could not create mutex for list synchronisation.");
  }
};

class pthread_key: public verifyable_object
{
  DWORD tls_index;
public:
  static bool is_good_object (pthread_key_t const *);

  int set (const void *value) {TlsSetValue (tls_index, (void *) value); return 0;}
  void *get () const {return TlsGetValue (tls_index);}

  pthread_key (void (*)(void *));
  ~pthread_key ();
  static void fixup_before_fork ()
  {
    keys.for_each (&pthread_key::_fixup_before_fork);
  }

  static void fixup_after_fork ()
  {
    keys.fixup_after_fork ();
    keys.for_each (&pthread_key::_fixup_after_fork);
  }

  static void run_all_destructors ()
  {
    keys.for_each (&pthread_key::run_destructor);
  }

  /* List support calls */
  class pthread_key *next;
private:
  static List<pthread_key> keys;
  void _fixup_before_fork ();
  void _fixup_after_fork ();
  void (*destructor) (void *);
  void run_destructor ();
  void *fork_buf;
};

class pthread_attr: public verifyable_object
{
public:
  static bool is_good_object(pthread_attr_t const *);
  int joinable;
  int contentionscope;
  int inheritsched;
  struct sched_param schedparam;
  void *stackaddr;
  size_t stacksize;
  size_t guardsize;

  pthread_attr ();
  ~pthread_attr ();
};

class pthread_mutexattr: public verifyable_object
{
public:
  static bool is_good_object(pthread_mutexattr_t const *);
  int pshared;
  int mutextype;
  pthread_mutexattr ();
  ~pthread_mutexattr ();
};

class pthread_mutex: public verifyable_object
{
public:
  static void init_mutex ();
  static int init (pthread_mutex_t *, const pthread_mutexattr_t *attr,
		   const pthread_mutex_t);
  static bool is_good_object (pthread_mutex_t const *);
  static bool is_initializer (pthread_mutex_t const *);
  static bool is_initializer_or_object (pthread_mutex_t const *);
  static bool is_initializer_or_bad_object (pthread_mutex_t const *);

  int lock ();
  int trylock ();
  int unlock ();
  int destroy ();
  void set_type (int in_type) {type = in_type;}

  int lock_recursive ()
  {
    if (recursion_counter == UINT_MAX)
      return EAGAIN;
    recursion_counter++;
    return 0;
  }

  bool can_be_unlocked ();

  pthread_mutex (pthread_mutexattr * = NULL);
  pthread_mutex (pthread_mutex_t *, pthread_mutexattr *);
  ~pthread_mutex ();

  class pthread_mutex *next;
  static void fixup_after_fork ()
  {
    mutexes.fixup_after_fork ();
    mutexes.for_each (&pthread_mutex::_fixup_after_fork);
  }

protected:
  LONG lock_counter;
  HANDLE win32_obj_id;
  pthread_t owner;
#ifdef DEBUGGING
  DWORD tid;		/* the thread id of the owner */
#endif

  void set_shared (int in_shared) { pshared = in_shared; }
  void set_owner (pthread_t self)
  {
    recursion_counter = 1;
    owner = self;
#ifdef DEBUGGING
    tid = GetCurrentThreadId ();
#endif
  }

  static const pthread_t _new_mutex;
  static const pthread_t _unlocked_mutex;
  static const pthread_t _destroyed_mutex;

private:
  unsigned int recursion_counter;
  LONG condwaits;
  int type;
  int pshared;

  bool no_owner ();
  void _fixup_after_fork ();

  static List<pthread_mutex> mutexes;
  static fast_mutex mutex_initialization_lock;
  friend class pthread_cond;
};

class pthread_spinlock: public pthread_mutex
{
public:
  static bool is_good_object (pthread_spinlock_t const *);
  static int init (pthread_spinlock_t *, int);

  int lock ();
  int unlock ();

  pthread_spinlock (int);
};

class _cygtls;
class pthread: public verifyable_object
{
public:
  HANDLE win32_obj_id;
  class pthread_attr attr;
  void *(*function) (void *);
  void *arg;
  void *return_ptr;
  bool valid;
  bool suspended;
  bool canceled;
  int cancelstate, canceltype;
  _cygtls *cygtls;
  HANDLE cancel_event;
  pthread_t joiner;

  virtual bool create (void *(*)(void *), pthread_attr *, void *);

  pthread ();
  virtual ~pthread ();

  static void init_mainthread ();
  static bool is_good_object(pthread_t const *);
  static void atforkprepare();
  static void atforkparent();
  static void atforkchild();

  /* API calls */
  static int cancel (pthread_t);
  static int join (pthread_t * thread, void **return_val);
  static int detach (pthread_t * thread);
  static int create (pthread_t * thread, const pthread_attr_t * attr,
			      void *(*start_routine) (void *), void *arg);
  static int once (pthread_once_t *, void (*)(void));
  static int atfork(void (*)(void), void (*)(void), void (*)(void));
  static int suspend (pthread_t * thread);
  static int resume (pthread_t * thread);

  virtual void exit (void *value_ptr) __attribute__ ((noreturn));

  virtual int cancel ();

  virtual void testcancel ();
  static HANDLE get_cancel_event ();
  static void static_cancel_self () __attribute__ ((noreturn));

  virtual int setcancelstate (int state, int *oldstate);
  virtual int setcanceltype (int type, int *oldtype);

  virtual void push_cleanup_handler (__pthread_cleanup_handler *handler);
  virtual void pop_cleanup_handler (int const execute);

  static pthread* self ();
  static DWORD WINAPI thread_init_wrapper (void *);

  virtual unsigned long getsequence_np();

  static int equal (pthread_t t1, pthread_t t2)
  {
    return t1 == t2;
  }

  /* List support calls */
  class pthread *next;
  static void fixup_after_fork ()
  {
    threads.fixup_after_fork ();
    threads.for_each (&pthread::_fixup_after_fork);
  }

  static void suspend_all_except_self ()
  {
    threads.for_each (&pthread::suspend_except_self);
  }

  static void resume_all ()
  {
    threads.for_each (&pthread::resume);
  }

private:
  static List<pthread> threads;
  DWORD thread_id;
  __pthread_cleanup_handler *cleanup_stack;
  pthread_mutex mutex;
  sigset_t parent_sigmask;

  void suspend_except_self ();
  void resume ();

  void _fixup_after_fork ();

  void pop_all_cleanup_handlers ();
  void precreate (pthread_attr *);
  void postcreate ();
  bool create_cancel_event ();
  void set_tls_self_pointer ();
  void cancel_self () __attribute__ ((noreturn));
  DWORD get_thread_id ();
};

class pthread_null : public pthread
{
  public:
  static pthread *get_null_pthread();
  ~pthread_null();

  /* From pthread These should never get called
  * as the ojbect is not verifyable
  */
  bool create (void *(*)(void *), pthread_attr *, void *);
  void exit (void *value_ptr) __attribute__ ((noreturn));
  int cancel ();
  void testcancel ();
  int setcancelstate (int state, int *oldstate);
  int setcanceltype (int type, int *oldtype);
  void push_cleanup_handler (__pthread_cleanup_handler *handler);
  void pop_cleanup_handler (int const execute);
  unsigned long getsequence_np();

  private:
  pthread_null ();
  static pthread_null _instance;
};

class pthread_condattr: public verifyable_object
{
public:
  static bool is_good_object(pthread_condattr_t const *);
  int shared;
  clockid_t clock_id;

  pthread_condattr ();
  ~pthread_condattr ();
};

class pthread_cond: public verifyable_object
{
public:
  static bool is_good_object (pthread_cond_t const *);
  static bool is_initializer (pthread_cond_t const *);
  static bool is_initializer_or_object (pthread_cond_t const *);
  static bool is_initializer_or_bad_object (pthread_cond_t const *);
  static void init_mutex ();
  static int init (pthread_cond_t *, const pthread_condattr_t *);

  int shared;
  clockid_t clock_id;

  LONG waiting;
  LONG pending;
  HANDLE sem_wait;

  pthread_mutex mtx_in;
  pthread_mutex mtx_out;

  pthread_mutex_t mtx_cond;

  void unblock (const bool all);
  int wait (pthread_mutex_t mutex, PLARGE_INTEGER timeout = NULL);

  pthread_cond (pthread_condattr *);
  ~pthread_cond ();

  class pthread_cond * next;
  static void fixup_after_fork ()
  {
    conds.fixup_after_fork ();
    conds.for_each (&pthread_cond::_fixup_after_fork);
  }

private:
  void _fixup_after_fork ();

  static List<pthread_cond> conds;
  static fast_mutex cond_initialization_lock;
};

class pthread_rwlockattr: public verifyable_object
{
public:
  static bool is_good_object(pthread_rwlockattr_t const *);
  int shared;

  pthread_rwlockattr ();
  ~pthread_rwlockattr ();
};

class pthread_rwlock: public verifyable_object
{
public:
  static bool is_good_object (pthread_rwlock_t const *);
  static bool is_initializer (pthread_rwlock_t const *);
  static bool is_initializer_or_object (pthread_rwlock_t const *);
  static bool is_initializer_or_bad_object (pthread_rwlock_t const *);
  static void init_mutex ();
  static int init (pthread_rwlock_t *, const pthread_rwlockattr_t *);

  int shared;

  uint32_t waiting_readers;
  uint32_t waiting_writers;
  pthread_t writer;
  struct RWLOCK_READER
  {
    struct RWLOCK_READER *next;
    pthread_t thread;
    uint32_t n;
    RWLOCK_READER (): next (NULL), thread (pthread::self ()), n (0) {}
  } *readers;
  fast_mutex readers_mx;

  int rdlock ();
  int tryrdlock ();

  int wrlock ();
  int trywrlock ();

  int unlock ();

  pthread_mutex mtx;
  pthread_cond cond_readers;
  pthread_cond cond_writers;

  pthread_rwlock (pthread_rwlockattr *);
  ~pthread_rwlock ();

  class pthread_rwlock * next;
  static void fixup_after_fork ()
  {
    rwlocks.fixup_after_fork ();
    rwlocks.for_each (&pthread_rwlock::_fixup_after_fork);
  }

private:
  static List<pthread_rwlock> rwlocks;

  RWLOCK_READER *add_reader ();
  void remove_reader (struct RWLOCK_READER *rd);
  struct RWLOCK_READER *lookup_reader ();

  void release ()
  {
    if (waiting_writers)
      {
	if (!readers)
	  cond_writers.unblock (false);
      }
    else if (waiting_readers)
      cond_readers.unblock (true);
  }


  static void rdlock_cleanup (void *arg);
  static void wrlock_cleanup (void *arg);

  void _fixup_after_fork ();

  static fast_mutex rwlock_initialization_lock;
};

class pthread_once
{
public:
  pthread_mutex_t mutex;
  int state;
};

/* shouldn't be here */
class semaphore: public verifyable_object
{
public:
  static bool is_good_object(sem_t const *);
  /* API calls */
  static int init (sem_t *sem, int pshared, unsigned int value);
  static int destroy (sem_t *sem);
  static sem_t *open (unsigned long long hash, LUID luid, int fd, int oflag,
		      mode_t mode, unsigned int value, bool &wasopen);
  static int close (sem_t *sem);
  static int wait (sem_t *sem);
  static int post (sem_t *sem);
  static int getvalue (sem_t *sem, int *sval);
  static int trywait (sem_t *sem);
  static int timedwait (sem_t *sem, const struct timespec *abstime);

  static int getinternal (sem_t *sem, int *sfd, unsigned long long *shash,
			  LUID *sluid, unsigned int *sval);

  HANDLE win32_obj_id;
  int shared;
  LONG currentvalue;
  LONG startvalue;
  int fd;
  unsigned long long hash;
  LUID luid;
  sem_t *sem;

  semaphore (int, unsigned int);
  semaphore (unsigned long long, LUID, int, sem_t *, int, mode_t, unsigned int);
  ~semaphore ();

  class semaphore * next;
  static void fixup_before_fork ()
  {
    semaphores.for_each (&semaphore::_fixup_before_fork);
  }
  static void fixup_after_fork ()
  {
    semaphores.fixup_after_fork ();
    semaphores.for_each (&semaphore::_fixup_after_fork);
  }
  static void terminate ()
  {
    save_errno save;
    semaphores.for_each (&semaphore::_terminate);
  }

private:
  int _wait ();
  void _post ();
  int _getvalue (int *sval);
  int _trywait ();
  int _timedwait (const struct timespec *abstime);

  void _fixup_before_fork ();
  void _fixup_after_fork ();
  void _terminate ();

  static List<semaphore> semaphores;
};

class callback
{
public:
  void (*cb)(void);
  class callback * next;
};

struct MTinterface
{
  // General
  int concurrency;
  LONG threadcount;

  callback *pthread_prepare;
  callback *pthread_child;
  callback *pthread_parent;

  void Init ();
  void fixup_before_fork ();
  void fixup_after_fork ();

#if 0 // avoid initialization since zero is implied and
  MTinterface () :
    concurrency (0), threadcount (0),
    pthread_prepare (NULL), pthread_child (NULL), pthread_parent (NULL)
  {
  }
#endif
};

#define MT_INTERFACE user_data->threadinterface
@


1.139
log
@	* ntdll.h (struct _SEMAPHORE_BASIC_INFORMATION): Define.
	(enum _SEMAPHORE_INFORMATION_CLASS): Define.
	(NtQuerySemaphore): Declare.
	* thread.h (class semaphore): Add member startvalue.
	(semaphore::fixup_before_fork): New inline method.
	(semaphore::_fixup_before_fork): Declare.
	* thread.cc (MTinterface::fixup_before_fork): Additionally call
	semaphore::fixup_before_fork.
	(semaphore::semaphore): Set currentvalue to -1.  Set startvalue to
	incoming initializer value.
	(semaphore::_getvalue): Just query semaphore using NtQuerySemaphore
	rather then using WFSO/Release.
	(semaphore::_post): Drop setting currentvalue.  It's not thread-safe.
	(semaphore::_trywait): Ditto.
	(semaphore::_timedwait): Ditto.
	(semaphore::_wait): Ditto.
	(semaphore::_fixup_before_fork): New method, setting currentvalue from
	actual windows semaphore right before fork.
	(semaphore::_fixup_after_fork): Drop kludge from 2013-07-10.  Drop
	FIXME comment.
@
text
@d4 1
a4 1
   2010, 2011, 2012, 2013 Red Hat, Inc.
d63 1
a63 1
      cygwait (win32_obj_id, cw_infinite, cw_sig);
@


1.138
log
@	* Merge in cygwin-64bit-branch.
@
text
@d641 1
d652 4
d674 1
@


1.137
log
@* child_info.h (cygheap_exec_info::sigmask): Declare new field.
* cygheap.cc (init_cygheap::find_tls): Rename threadlist_ix -> ix.  Only take
one pass through thread list, looking for eligible threads to signal.  Set a
new param indicating that function has found a sigwait* mask.
* cygheap.h (init_cygheap::find_tls): Reflect new parameter.
* dcrt0.cc (parent_sigmask): New variable.
(child_info_spawn::handle_spawn): Save parent's signal mask here.
(dll_crt0_1): Restore parent's signal mask to tls sigmask as appropriate.  Call
sig_dispatch_pending to flush signal queue when we can finally do something
with signals.
* exceptions.cc (sigpacket::process): Avoid attempting to handle signals if we
haven't finished initializing.  Rely on the fact that find_tls will do mask
checking and don't do it again.  Delete ill-named 'dummy' variable.
* sigproc.cc (cygheap_exec_info::alloc): Save calling thread's signal mask in
new sigmask field.
(wait_sig): Try to debug when WFSO fails and DEBUGGING is defined.
* thread.cc (pthread::set_tls_self_pointer): Make this a true automatic method
rather than inexplicably relying on a thread parameter.
(pthread::thread_init_wrapper): Accommodate set_tls_self_pointer change to
non-static.  Initialize sigmask before setting tid or suffer signal races.
* ehread.h (pthread::set_tls_self_pointer): Make non-static, delete parameter.
@
text
@d95 1
a95 1
typedef unsigned long thread_magic_t;
d499 2
a500 2
  unsigned long waiting;
  unsigned long pending;
d550 2
a551 2
  unsigned long waiting_readers;
  unsigned long waiting_writers;
d557 1
a557 1
    unsigned long n;
d640 1
a640 1
  long currentvalue;
@


1.136
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d446 1
a446 1
  static void set_tls_self_pointer (pthread *);
@


1.135
log
@* thread.cc (pthread_rwlock::lookup_reader): Remove parameter: always assume
that we're looking for the current thread.
(pthread_rwlock::tryrdlock): Eliminate self variable.  Accommodate change in
lookup_reader().
(pthread_rwlock::unlock): Ditto.
(pthread_rwlock::rdlock): Ditto.  Move add_reader call after writer tests to
more closely mimic old behavior.
(pthread_rwlock::wrlock): Accommodate change in lookup_reader().
* thread.h ((pthread_rwlock::lookup_reader): Eliminate argument.
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007,
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.134
log
@* thread.cc (pthread_rwlock::add_reader): Perform new operation here and return
pointer to allocated RWLOCK_READER structure.
(pthread_rwlock::rdlock): Reorganize to reflect new add_reader functionality.
(pthread_rwlock::tryrdlock): Ditto.  Remove unneeded call to lookup_reader().
* thread.h (pthread_rwlock::RWLOCK_READER::RWLOCK_READER): New constructor.
(pthread_rwlock::add_reader): Reflect new functionality.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d589 1
a589 1
  struct RWLOCK_READER *lookup_reader (pthread_t thread);
@


1.133
log
@	* thread.h (List_insert): Cast first parameter in
	InterlockedCompareExchangePointer call to avoid compiler warnings.
	(List_remove): Ditto.
@
text
@d558 1
d587 1
a587 1
  void add_reader (struct RWLOCK_READER *rd);
@


1.132
log
@Rename cancelable_wait -> cygwait throughout.
* DevNotes: Add entry cgf-000015.
* cygwait.h (cygwait): Don't allow an optional PLARGE_INTERGER argument.
@
text
@d62 1
a62 1
    if (InterlockedIncrement ((long *) &lock_counter) != 1)
d68 1
a68 1
    if (InterlockedDecrement ((long *) &lock_counter))
d73 1
a73 1
  unsigned long lock_counter;
d122 2
a123 1
  while (InterlockedCompareExchangePointer (&head, node, node->next) != node->next);
d127 1
a127 1
List_remove (fast_mutex &mx, list_node *&head, list_node const *node)
d134 2
a135 1
      if (InterlockedCompareExchangePointer (&head, node->next, node) != node)
d302 1
a302 1
  unsigned long lock_counter;
d685 1
a685 1
  long int threadcount;
@


1.131
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d63 1
a63 1
      cancelable_wait (win32_obj_id, cw_infinite, cw_sig);
@


1.131.2.1
log
@	* advapi32.cc (DuplicateTokenEx): Make ?: expression type-safe.
	* ntdll.h (KAFFINITY): Don't define if building with Mingw64 headers.
	* thread.cc: Throughout drop casts in calls to Interlocked functions.
	* thread.h (class fast_mutex): Ditto.  Define lock_counter as LONG.
	(class pthread_mutex): Define lock_counter as LONG.
	(struct MTinterface): Define threadcount as LONG.
@
text
@d62 1
a62 1
    if (InterlockedIncrement (&lock_counter) != 1)
d68 1
a68 1
    if (InterlockedDecrement (&lock_counter))
d73 1
a73 1
  LONG lock_counter;
d300 1
a300 1
  LONG lock_counter;
d683 1
a683 1
  LONG threadcount;
@


1.131.2.2
log
@Pull in changes from HEAD
@
text
@d63 1
a63 1
      cygwait (win32_obj_id, cw_infinite, cw_sig);
@


1.131.2.3
log
@Pull thread.h change from HEAD
@
text
@d122 1
a122 2
  while (InterlockedCompareExchangePointer ((PVOID volatile *) &head,
					    node, node->next) != node->next);
d126 1
a126 1
List_remove (fast_mutex &mx, list_node *&head, list_node *node)
d133 1
a133 2
      if (InterlockedCompareExchangePointer ((PVOID volatile *) &head,
					     node->next, node) != node)
@


1.131.2.4
log
@	* fhandler_netdrive.cc: Use UINT32_MAX rather than UINT_MAX to make
	absolutely clear that we mean the 32 bit maximum.
	* fhandler_socket.cc: Ditto.
	* pinfo.cc: Ditto with INT32_MAX.
	* select.cc (fd_mask): Drop gratuitious definition.
	(sizeof_fd_set): Cast to size_t.
	* shared.cc (pround): Cast to ptrdiff_t.
	* strace.cc (strace::activate): Fix format string.
	(strace::write_childpid): Take pid_t as parameter.
	* include/sys/strace.h (strace::write_childpid): Change declaration
	accordingly.
	* sync.cc (muto::init): Cast in call to InterlockedExchangePointer to
	make compiler happy.
	* sync.h (class muto): De-const name.
	* syslog.cc (try_connect_syslogd): Take size_t as third argument.
	(vsyslog): Convert len to size_t.
	* thread.cc: Use {U}INT32_MAX rather than {U}LONG_MAX.  Througout change
	types used in Windows calls to matching Windows types.
	(pthread::cancel): Fix access to instruction pointer for x86_64.
	(pthread_attr_getstack): Cast to ptrdiff_t for pointer arithmetic.
	* thread.h: Throughout convert 'long' types to uint32_t or LONG.
@
text
@d95 1
a95 1
typedef uint32_t thread_magic_t;
d499 2
a500 2
  LONG waiting;
  LONG pending;
d550 2
a551 2
  uint32_t waiting_readers;
  uint32_t waiting_writers;
d557 1
a557 1
    uint32_t n;
d639 1
a639 1
  LONG currentvalue;
@


1.131.2.5
log
@Pull in changes from HEAD
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
a557 1
    RWLOCK_READER (): next (NULL), thread (pthread::self ()), n (0) {}
d586 1
a586 1
  RWLOCK_READER *add_reader ();
d588 1
a588 1
  struct RWLOCK_READER *lookup_reader ();
@


1.131.2.6
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009,
   2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.131.2.7
log
@Pull in changes from HEAD
@
text
@d446 1
a446 1
  void set_tls_self_pointer ();
@


1.130
log
@* cygwait.h (LARGE_NULL): Define.
(cancelable_wait): Define variant which accepts DWORD time argument.
(cygwait): Use cancelable_wait with DWORD argument.
(cygwait): Use cancelable_wait with DWORD argument and cw_sig_eintr for
timeout-only case.
* exceptions.cc (handle_sigsuspend): Use LARGE_NULL as second argument to
distinguish between cancelable_wait variants.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_timedwait): Ditto.
* thread.h (fast_mutex::lock): Ditto.
* wait.cc (wait4): Ditto.
@
text
@d63 1
a63 1
      cancelable_wait (win32_obj_id, LARGE_NULL, cw_sig);
@


1.129
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@d63 1
a63 1
      cancelable_wait (win32_obj_id, NULL, cw_sig);
@


1.128
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@a346 3
#define WAIT_CANCELED   (WAIT_OBJECT_0 + 1)
#define WAIT_SIGNALED  (WAIT_OBJECT_0 + 2)

@


1.127
log
@	* Makefile.in (clean): Remove non-existant regexp dir.

	* collate.h: New header.
	(__collate_range_cmp): Declare.
	(__collate_load_error): Define.
	* glob.cc: Pull in latest version from FreeBSD.  Simplify and reduce
	Cygwin-specific changes.
	* regex/regcomp.c: Include collate.h on Cygwin as well.
	(__collate_range_cmp): Move from here...
	* nlsfuncs.cc (__collate_range_cmp): ...to here.

	* miscfuncs.cc (thread_wrapper): Fix typo in comment.
	(CygwinCreateThread): Take dead zone of Windows stack into account.
	Change the way how the stack is commited and how to handle guardpages.
	Explain how and why.
	* thread.h (PTHREAD_DEFAULT_STACKSIZE): Change definition.  Explain why.
@
text
@d32 1
a32 19

enum cw_sig_wait
{
  cw_sig_nosig,
  cw_sig_eintr,
  cw_sig_resume
};

enum cw_cancel_action
{
  cw_cancel_self,
  cw_no_cancel_self,
  cw_no_cancel
};

DWORD cancelable_wait (HANDLE, PLARGE_INTEGER timeout = NULL,
		       const cw_cancel_action = cw_cancel_self,
		       const enum cw_sig_wait = cw_sig_nosig)
  __attribute__ ((regparm (3)));
d63 1
a63 1
      cancelable_wait (win32_obj_id, NULL, cw_no_cancel, cw_sig_resume);
@


1.126
log
@	* miscfuncs.cc (DEFAULT_STACKSIZE): Remove.
	(CygwinCreateThread): Simplify code by assuming that now stack-related
	input values are undefined.  Set stack protection to PAGE_READWRITE,
	as is default on Windows.  Add lengthy comment to explain POSIX
	guardpage.
	* thread.cc (pthread_attr::pthread_attr): Initialize stacksize as
	PTHREAD_DEFAULT_STACKSIZE.  Initialize guardsize as
	PTHREAD_DEFAULT_GUARDSIZE.
	* thread.h (PTHREAD_DEFAULT_STACKSIZE): Define.  Add comment to explain.
	(PTHREAD_DEFAULT_GUARDSIZE): Define.
@
text
@d19 6
a24 4
/* Default is a 1 Megs stack with a 4K guardpage.  Since the pthread stacksize
   does not include the guardpage size, but we don't want to waste another 64K,
   subtract the default guardpage size from the stacksize. */
#define PTHREAD_DEFAULT_STACKSIZE (1024 * 1024 - wincap.page_size ())
@


1.125
log
@Update copyright on all files checked in so far this year.
* fhandler.h: Use #pragma once rather than ifdef guards.
(fhandler_console::tc_getpgid): Return our pgid if we have never opened a
console.
* fork.cc: Rearrange includes to accommodate fhandler.h use of pinfo.h.
* sigproc.cc: Ditto.
* spawn.cc: Ditto.
(child_info_spawn::worker): Query myself->pgid rather than calling expensive
function.
* thread.h: Use #pragma once rather than ifdef guards.
* pinfo.h: Use #pragma once rather than ifdef guards.
(pinfo::remember): Don't define if sigproc.h has not been included.
(pinfo::reattach): Ditto.
* sigproc.h: Use #pragma once rather than ifdef guards.  Use different test to
see if pinfo.h has been included.
@
text
@d19 6
@


1.124
log
@	* thread.cc (pthread::pthread): Drop setting parent_tls.  Call
	sigprocmask to copy parent thread signal mask into new parent_sigmask
	member.
	(pthread::thread_init_wrapper): Copy _my_tls.sigmask from new
	parent_sigmask member.
	* thread.h (class pthread): Drop parent_tls.  Add parent_sigmask.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011 Red Hat, Inc.
d12 1
a12 2
#ifndef _THREAD_H
#define _THREAD_H
a715 1
#endif // _THREAD_H
@


1.123
log
@* cygtls.h (struct _local_storage): Add cw_timer member.
* cygtls.cc (_cygtls::init_thread): Initialize locals.cw_timer.
(_cygtls::fixup_after_fork): Ditto.
* tlsoffsets.h: Regenerate.
* ntdll.h (enum _TIMER_INFORMATION_CLASS): Define.
(struct _TIMER_BASIC_INFORMATION): Define.
(NtQueryTimer): Declare function.
* thread.h (cancelable_wait): Change timeout argument to
PLARGE_INTEGER and provide NULL default.
(fast_mutex::lock): Adjust accordingly.
(pthread_cond::wait): Change timeout argument to PLARGE_INTEGER
and default to NULL.
* thread.cc (cancelable_wait): Change timeout argument to
PLARGE_INTEGER.  Initialize _cygtls.locals.cw_timer if needed.
Use NT waitable timers for handling timeout.  Return remaining time
to timeout argument if timeout was relative.
(pthread_cond::wait): Change timeout argument to PLARGE_INTEGER.
Adjust to change in cancelable_wait.
(pthread_mutex::lock): Adjust to change in cancelable_wait.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(__pthread_cond_dowait): Change waitlength argument to PLARGE_INTEGER.
Adjust to changes in cancelable_wait and pthread_cond::wait.
(pthread_cond_timedwait): Adjust to change in __pthread_cond_dowait.
(pthread_cond_wait): Ditto.
(semaphore::_timedwait): Adjust to change in cancelable_wait.
(semaphore::_wait): Ditto.
* exceptions.cc (handle_sigsuspend): Ditto.
* signal.cc (nanosleep): Ditto.
* wait.cc (wait4): Ditto. Fix copyright dates.
* times.cc (FACTOR, NSPERSEC): Move from here...
* hires.h (FACTOR, NSPERSEC): ...to here.
@
text
@d447 1
a447 1
  _cygtls *parent_tls;
@


1.122
log
@* cygwin.din (pthread_condattr_getclock): Export.
(pthread_condattr_setclock): Export.
* posix.sgml (std-notimpl): Move pthread_condattr_getclock and
pthread_condattr_setclock from here...
(std-susv4): ... to here.
* sysconf.cc (sca): Set _SC_CLOCK_SELECTION to _POSIX_CLOCK_SELECTION.
* thread.cc: (pthread_condattr::pthread_condattr): Initialize clock_id.
(pthread_cond::pthread_cond): Initialize clock_id.
(pthread_cond_timedwait): Use clock_gettime() instead of gettimeofday()
in order to support all allowed clocks.
(pthread_condattr_getclock): New function.
(pthread_condattr_setclock): New function.
* thread.h (class pthread_condattr): Add clock_id member.
(class pthread_cond): Ditto.
* include/pthread.h: Remove obsolete comment.
(pthread_condattr_getclock): Declare.
(pthread_condattr_setclock): Declare.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d40 2
a41 1
DWORD cancelable_wait (HANDLE, DWORD, const cw_cancel_action = cw_cancel_self,
d74 1
a74 1
      cancelable_wait (win32_obj_id, INFINITE, cw_no_cancel, cw_sig_resume);
d521 1
a521 1
  int wait (pthread_mutex_t mutex, DWORD dwMilliseconds = INFINITE);
@


1.121
log
@	* cygwin.din (pthread_attr_getguardsize): Export.
	(pthread_attr_setguardsize): Export.
	(pthread_attr_setstack): Export.
	(pthread_attr_setstackaddr): Export.
	* init.cc (dll_entry): Remove wow64_test_stack_marker.  Check for
	unusual stack address by testing stack addresses from current TEB.
	Check validity of _my_tls by testing if it's within the stack as
	given in current TEB.
	* miscfuncs.cc (struct thread_wrapper_arg): New structure used to
	push all required information to thread_wrapper function.
	(thread_wrapper): Wrapper function for actual thread function.
	If an application stack has been given, change %ebp and %esp so that
	the thread function runs on that stack.  If the thread has been created
	by CygwinCreateThread, set up the POSIX guard pages if necessary.
	(CygwinCreateThread): New function.
	* miscfuncs.h (CygwinCreateThread): Declare.
	* ntdll.h (struct _TEB): Define all members up to Peb.
	* posix.sgml (std-susv4): Move pthread_attr_getguardsize,
	pthread_attr_setguardsize and pthread_attr_setstack here.
	(std-deprec): Add pthread_attr_setstackaddr.
	* sysconf.cc (sca): Set _SC_THREAD_ATTR_STACKADDR to
	_POSIX_THREAD_ATTR_STACKADDR.
	* thread.cc (pthread::precreate): Copy pthread_attr stackaddr and
	guardsize members.
	(pthread::create): Call CygwinCreateThread.
	(pthread_attr::pthread_attr): Initialize guardsize.
	(pthread_attr_setstack): New function.
	(pthread_attr_setstackaddr): New function.
	(pthread_attr_setguardsize): New function.
	(pthread_attr_getguardsize): New function.
	(pthread_getattr_np): Copy attr.guardsize.
	* thread.h (pthread_attr): Add member guardsize.
	* include/pthread.h (pthread_attr_getguardsize): Declare.
	(pthread_attr_setguardsize): Declare.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d491 1
d508 1
@


1.120
log
@* thread.h (pthread::static_cancel_self): Mark as noreturn.
(pthread::cancel_self): Ditto.
* thread.cc (pthread::cancel_self): Explicitly use pthread::exit to avoid a
"function returns" error.
@
text
@d255 1
@


1.119
log
@* cygwin.din (pthread_attr_getstack): Export.
(pthread_attr_getstackaddr): Export.
(pthread_getattr_np): Export.
* ntdll.h (enum _THREAD_INFORMATION_CLASS): Add ThreadBasicInformation.
(struct _THREAD_BASIC_INFORMATION): Define.
(NtQueryInformationThread): Declare.
* posix.sgml (std-susv4): Add pthread_attr_getstack.
(std-gnu): Add pthread_getattr_np.
(std-deprec): Add pthread_attr_getstackaddr.
(std-notimpl): Remove pthread_attr_[gs]etstackaddr, as they were
removed from SUSv4.
* thread.cc (pthread_attr::pthread_attr): Initialize stackaddr.
(pthread_attr_getstack): New function.
(pthread_attr_getstackaddr): New function.
(pthread_attr_setstacksize): Return EINVAL if passed size less than
PTHREAD_STACK_MIN, as required by POSIX.
(pthread_getattr_np): New function.
* thread.h (class pthread_attr): Add stackaddr member.
* include/pthread.h (pthread_attr_getstack): Declare.
(pthread_attr_getstackaddr): Declare unconditionally.
(pthread_attr_setstack): Declare inside false conditional for reference.
(pthread_getattr_np): Declare.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d404 1
a404 1
  static void static_cancel_self ();
d457 1
a457 1
  void cancel_self ();
@


1.118
log
@	* fhandler_windows.cc (fhandler_windows::read): Use
	pthread::get_cancel_event to fetch thread's cancel event.
	* flock.cc (lf_setlock): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Ditto.
	* thread.cc (pthread::get_cancel_event): New static method.
	* thread.h (pthread::get_cancel_event): Declare.
@
text
@d253 1
@


1.117
log
@	* thread.h (class pthread): Add bool member canceled.
	* thread.cc (pthread::pthread): Initialize canceled to false.
	(pthread::cancel): Set canceled before setting cancel_event.
	(pthread::testcancel): Check for canceled.  Only wait for cancel_event
	if canceled is true.  Explain why.
	(pthread::_fixup_after_fork): Set canceled to false.
@
text
@d402 1
@


1.116
log
@	* cygwin.din (pthread_spin_destroy): Export.
	(pthread_spin_init): Export.
	(pthread_spin_lock): Export.
	(pthread_spin_trylock): Export.
	(pthread_spin_unlock): Export.
	* posix.sgml (std-susv4): Add pthread_spin_destroy, pthread_spin_init,
	pthread_spin_lock, pthread_spin_trylock, pthread_spin_unlock.
	(std-notimpl): Remove pthread_spin_[...].
	* pthread.cc (pthread_spin_init): New function.
	* thread.cc (pthread_spinlock::is_good_object): New function.
	(pthread_mutex::pthread_mutex): Rearrange initializers to accommodate
	protected data in pthread_mutex.
	(pthread_spinlock::pthread_spinlock): New constructor.
	(pthread_spinlock::lock): New method.
	(pthread_spinlock::unlock): New method.
	(pthread_spinlock::init): New method.
	(pthread_spin_lock): New function.
	(pthread_spin_trylock): New function.
	(pthread_spin_unlock): New function.
	(pthread_spin_destroy): New function.
	* thread.h (PTHREAD_SPINLOCK_MAGIC): Define.
	(class pthread_mutex): Change access level of members shared with
	derived classes to protected.
	(pthread_mutex::set_shared): New protected method.
	(class pthread_spinlock): New class, derived class of pthread_mutex.
	* include/pthread.h (pthread_spin_destroy): Declare.
	(pthread_spin_init): Declare.
	(pthread_spin_lock): Declare.
	(pthread_spin_trylock): Declare.
	(pthread_spin_unlock): Declare.
	* include/cygwin/types.h (pthread_spinlock_t): New typedef.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d369 1
@


1.115
log
@	* thread.cc (semaphore::init, destroy, close): Standards conformance
	fix.  On a failure, return -1 and set errno.
	* thread.h (semaphore::terminate): Save errno since semaphore::close()
	may now modify it.
@
text
@d4 1
a4 1
   2008, 2009, 2010 Red Hat, Inc.
d101 1
d307 1
a307 1
private:
a309 2
  unsigned int recursion_counter;
  LONG condwaits;
a313 2
  int type;
  int pshared;
d315 1
d324 1
d329 6
d343 12
@


1.114
log
@* include/sys/strace.h: Define _STRACE_SPECIAL.
(strace_printf_wrap): Fix NOSTRACE definitions.
(strace_printf_wrap1): Fix NOSTRACE definitions.
(special_printf): Define.
* thread.cc: Perform minor syntax fix in a comment.  Rename
"is_good_initialzer*" to "is_initializer*" throughout.  Use pthread_printf
rather than debug_printf throughout.  Add extra pthread_printf debugging
throughout.
(pthread_mutex::_new_mutex): New constant value.
(pthread_mutex::_unlocked_mutex): Ditto.
(pthread_mutex::_destroyed_mutex): Ditto.
(pthread_mutex::no_owner): Define new function.
(pthread_mutex::can_be_unlocked): Detect no_owner situation.  Handle
PTHREAD_MUTEX_NORMAL as a special case.
(pthread::create_cancel_event): Use C++ boolean values.
(pthread::precreate): Use method to set mutex type.
(pthread_cond::pthread_cond): Ditto.
(pthread_rwlock::pthread_rwlock): Ditto.
(pthread_mutex::pthread_mutex): Set owner to _new_mutex initially.
(pthread_mutex::~pthread_mutex): Reset various elements to make it clearer if
they are incorrectly reused.
(pthread_mutex::lock): Add clarifying comment.
(pthread_mutex::unlock): Attempt to handle various mutex types correctly.  In
particular, reinstate ability to have one thread unlock another thread's mutex
if type == PTHREAD_MUTEX_NORMAL.
(semaphore::_fixup_after_fork): Avoid redundancy.
(pthread_mutex::_fixup_after_fork): Ditto.  Fix debugging statement.
(__pthread_cond_dowait): Accommodate changes to remove previously inexplicable
use can_be_unblocked() as a static function.
* thread.h: Rename "is_good_initialzer*" to "is_initializer*" throughout.
(pthread_mutex): Reorganize.  Make many things private.
(pthread_mutex::no_owner): Define new method.
(pthread_mutex::_new_mutex): Define new constant.
(pthread_mutex::_unlocked_mutex): Ditto.
(pthread_mutex::_destroyed_mutex): Ditto.
@
text
@d24 1
d645 1
@


1.114.2.1
log
@	* cygwin.din (pthread_spin_destroy): Export.
	(pthread_spin_init): Export.
	(pthread_spin_lock): Export.
	(pthread_spin_trylock): Export.
	(pthread_spin_unlock): Export.
	* posix.sgml (std-susv4): Add pthread_spin_destroy, pthread_spin_init,
	pthread_spin_lock, pthread_spin_trylock, pthread_spin_unlock.
	(std-notimpl): Remove pthread_spin_[...].
	* pthread.cc (pthread_spin_init): New function.
	* thread.cc (pthread_spinlock::is_good_object): New function.
	(pthread_mutex::pthread_mutex): Rearrange initializers to accommodate
	protected data in pthread_mutex.
	(pthread_spinlock::pthread_spinlock): New constructor.
	(pthread_spinlock::lock): New method.
	(pthread_spinlock::unlock): New method.
	(pthread_spinlock::init): New method.
	(pthread_spin_lock): New function.
	(pthread_spin_trylock): New function.
	(pthread_spin_unlock): New function.
	(pthread_spin_destroy): New function.
	* thread.h (PTHREAD_SPINLOCK_MAGIC): Define.
	(class pthread_mutex): Change access level of members shared with
	derived classes to protected.
	(pthread_mutex::set_shared): New protected method.
	(class pthread_spinlock): New class, derived class of pthread_mutex.
	* include/pthread.h (pthread_spin_destroy): Declare.
	(pthread_spin_init): Declare.
	(pthread_spin_lock): Declare.
	(pthread_spin_trylock): Declare.
	(pthread_spin_unlock): Declare.
	* include/cygwin/types.h (pthread_spinlock_t): New typedef.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@d4 1
a4 1
   2008, 2009, 2010, 2011 Red Hat, Inc.
a99 1
#define PTHREAD_SPINLOCK_MAGIC PTHREAD_MAGIC+11
d305 1
a305 1
protected:
d308 2
d314 2
a316 1
  void set_shared (int in_shared) { pshared = in_shared; }
a324 1

a328 6
private:
  unsigned int recursion_counter;
  LONG condwaits;
  int type;
  int pshared;

a336 12
class pthread_spinlock: public pthread_mutex
{
public:
  static bool is_good_object (pthread_spinlock_t const *);
  static int init (pthread_spinlock_t *, int);

  int lock ();
  int unlock ();

  pthread_spinlock (int);
};

@


1.113
log
@* pthread.cc (pthread_mutex_init): Explicitly fill out third arg to
pthread_mutex::init.
* thread.cc: Remov some obsolete comments.
(verifyable_object_isvalid): Reflect change to use thread_magic_t for magic
numbers.
(pthread_mutex::pthread_mutex): Set magic number to invalid initially until
we've verified that everything is valid.
(pthread_mutex::unlock): Fix a comment.
(verifyable_object::verifyable_object): Delete here.
(~verifyable_object::~verifyable_object): Ditto.
(pthread_mutex::init): Don't run is_good_initializer for non-static objects.
* thread.h (thread_magic_t): New typedef.
(verifyable_object::verifyable_object): Use thread_magic_t;
(verifyable_object::magic): Ditto.
(pthread_mutex::is_good_initializer_or_bad_object): Remove unneeded variable
names.
(pthread_mutex::can_be_unlocked): Ditto.
(pthread_mutex::init): Ditto.  Remove default for third argument.
@
text
@a269 5
  static bool is_good_object (pthread_mutex_t const *);
  static bool is_good_initializer (pthread_mutex_t const *);
  static bool is_good_initializer_or_object (pthread_mutex_t const *);
  static bool is_good_initializer_or_bad_object (pthread_mutex_t const *);
  static bool can_be_unlocked (pthread_mutex_t const *);
d273 4
a276 11

  unsigned long lock_counter;
  HANDLE win32_obj_id;
  unsigned int recursion_counter;
  LONG condwaits;
  pthread_t owner;
#ifdef DEBUGGING
  DWORD tid;		/* the thread id of the owner */
#endif
  int type;
  int pshared;
d282 1
a282 8
  void set_owner (pthread_t self)
  {
    recursion_counter = 1;
    owner = self;
#ifdef DEBUGGING
    tid = GetCurrentThreadId ();
#endif
  }
d286 1
a286 1
    if (UINT_MAX == recursion_counter)
d288 1
a288 1
    ++recursion_counter;
d292 2
d298 1
a298 1
  class pthread_mutex * next;
d306 24
d334 1
d478 3
a480 3
  static bool is_good_initializer (pthread_cond_t const *);
  static bool is_good_initializer_or_object (pthread_cond_t const *);
  static bool is_good_initializer_or_bad_object (pthread_cond_t const *);
d529 3
a531 3
  static bool is_good_initializer (pthread_rwlock_t const *);
  static bool is_good_initializer_or_object (pthread_rwlock_t const *);
  static bool is_good_initializer_or_bad_object (pthread_rwlock_t const *);
@


1.112
log
@* dcrt0.cc (_dll_crt0): Set _main_tls as early as possible.
* thread.cc (pthread_mutex::can_be_unlocked): Remove check for
MUTEX_OWNER_ANONYMOUS since it is racy and unsafe.
(pthread::init_mainthread): Initialize thread directly from _my_tls.
(pthread::self): Ditto.
(pthread::get_tls_self_pointer): Delete.
(pthread_mutex::pthread_mutex): Use an event rather than a semaphore.
(pthread_mutex::lock): Rename from _<func>.  Derive self directly.
(pthread_mutex::tryunlock): Ditto.
(pthread_mutex::destroy): Ditto.
(pthread_mutex::unlock): Ditto.  Accommodate change from semaphore to event.
(pthread_mutex::_fixup_after_fork): Accommodate change from semaphore to event.
(pthread_mutex::init): Don't attempt to initialize a semaphore unless it is in
an initialized state.  Do this check under mutex_initialization_lock.lock
* thread.h (fast_mutex::init): Use event rather than semaphore.
(fast_mutex::lock): Ditto.
(pthread_mutex::_lock): Delete.
(pthread_mutex::_unlock): Ditto.
(pthread_mutex::_trylock): Ditto.
(pthread_mutex::_destroy): Ditto.
(pthread_mutex::get_pthread_self): Ditto.
(pthread_mutex::get_tls_self_pointer): Ditto.
(pthread_mutex::lock): Un-inline.
(pthread_mutex::unlock): Ditto.
(pthread_mutex::trylock): Ditto.
(pthread_mutex::destroy): Ditto.
@
text
@d103 2
d110 1
a110 1
  long magic;
d112 2
a113 2
  verifyable_object (long);
  virtual ~verifyable_object ();
d273 2
a274 2
  static bool is_good_initializer_or_bad_object (pthread_mutex_t const *mutex);
  static bool can_be_unlocked (pthread_mutex_t const *mutex);
d276 2
a277 2
  static int init (pthread_mutex_t *mutex, const pthread_mutexattr_t *attr,
		   const pthread_mutex_t initializer = NULL);
@


1.111
log
@* select.h: New file split from fhandler.h.
(select_record::select_record): Define do-nothing constructor for "new" to
avoid gratuitous zeroing.
(select_info): New base class.
(select_pipe_info): New class with methods for dealing with pipes.
(select_socket_info): New class with methods for dealing with sockets.
(select_serial_info): Dummy class for serial.
(select_mailslot_info): Dummy class for mailslots.
(select_stuff): Define device_specific_* as actual classes rather than void *.
* dtable.h (dtable::select_read): Accommodate return value change to 'bool' and
argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* dtable.cc (dtable::select_read): Accommodate return value change to 'bool'
and argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* fhandler.h: Excise select-related classes.
(fhandler_*::select_read): Change argument to select_stuff.
(fhandler_*::select_write): Ditto.
(fhandler_*::select_except): Ditto.
* select.cc (UNIX_FD_ZERO): Use memset rather than bzero.
(select_stuff::test_and_set): Change return type to bool.  Allocate
select_record on entry and let fhandler_*::select_* operate on the start.next
field of select_stuff.
(pipeinf): Delete.
(select_pipe_info::select_pipe_info): New constructor.  Allocates event for
controlling pipe waits.
(select_pipe_info::~select_pipe_info): New destructor.  Destroy event.  Stop
thread.
(select_pipe_info::add_watch_handle): New function.
(thread_pipe): Wait for the hEvent part of any overlapped pipes before peeking.
(start_thread_pipe): Don't allocate device_specific_pipe stuff here.  Assume
that it has been allocated earlier.
(pipe_cleanup): Rely on select_pipe_info destructor to clean up pipe
paraphenalia.
(fhandler_*::select_*): Derive select_record from new select_stuff argument.
(fhandler_pipe::select_*): Ditto.  Allocate pipe-specific field if not already
allocated.
(serialinf): Delete.
(thread_serial): serialinf -> select_serial_info.
(fhandler_base::ready_for_read): Rewrite to accommodate change in argument to
fhandler_*::select_*.
(socketinf): Delete.
(thread_socket): socketinf -> select_socket_info.
(mailslotinf): Delete.
(thread_mailslot): mailslotinf -> select_mailslot_info.
@
text
@d4 1
a4 1
   2008, 2009 Red Hat, Inc.
d60 1
a60 1
    win32_obj_id = ::CreateSemaphore (&sec_none_nih, 0, LONG_MAX, NULL);
d63 1
a63 1
	debug_printf ("CreateSemaphore failed. %E");
d78 1
a78 1
      ::ReleaseSemaphore (win32_obj_id, 1, NULL);
d288 4
a291 23
  pthread_t get_pthread_self () const
  {
    return PTHREAD_MUTEX_NORMAL == type ? MUTEX_OWNER_ANONYMOUS :
      ::pthread_self ();
  }

  int lock ()
  {
    return _lock (get_pthread_self ());
  }
  int trylock ()
  {
    return _trylock (get_pthread_self ());
  }
  int unlock ()
  {
    return _unlock (get_pthread_self ());
  }
  int destroy ()
  {
    return _destroy (get_pthread_self ());
  }

a320 5
  int _lock (pthread_t self);
  int _trylock (pthread_t self);
  int _unlock (pthread_t self);
  int _destroy (pthread_t self);

a424 1
  static pthread *get_tls_self_pointer ();
@


1.110
log
@	* thread.h (struct pthread_rwlock::RWLOCK_READER): Add counter n.
	* thread.cc (pthread_rwlock::rdlock): If a thread already owns a
	read lock, just count the number of locks for it, per SUSv4.
	(pthread_rwlock::tryrdlock): Ditto.
	(pthread_rwlock::unlock): If a thread has more than one concurrent
	read locks, just count down.
@
text
@d101 1
a101 1
#define MUTEX_OWNER_ANONYMOUS        ((pthread_t) -1)
@


1.109
log
@Remove unneeded header files from source files throughout.  Update copyrights
where appropriate.
* globals.cc: New file for generic global variables.
* mkglobals_h: New file to generate globals.h.
* mkstatic: New Script used to build a (currently non-working) static
libcygwin_s.a.
* Makefile.in: Add unused rule to build a non-working libcygwin_s.a.
(DLL_OFILES): Add globals.o.  Make all objects rely on globals.h.
(globals.h): New target.  Generate globals.h.
* cygtls.h: Honor new CYGTLS_HANDLE define to control when the HANDLE operator
is allowed in _cygtls.
* dcrt0.cc: Move most globals to globals.cc.
* init.cc: Ditto.
* environ.cc (strip_title_path): Remove now-unneeded extern.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* pinfo.cc: Ditto.
(commune_process): Ditto.
* shared.cc: Ditto.
* glob.cc: Ditto.
* strace.cc: Ditto.
* exceptions.cc: Define CYGTLS_HANDLE before including winsup.h.
* path.cc (stat_suffixes): Move here.
* security.h: Add forward class path_conv declaration.
* smallprint.cc (__small_vsprintf): Make a true c++ function.
(__small_sprintf): Ditto.
(small_printf): Ditto.
(console_printf): Ditto.
(__small_vswprintf): Ditto.
(__small_swprintf): Ditto.
* spawn.cc (spawn_guts): Remove _stdcall decoration in favor of regparm.
(hExeced): Move to globals.cc
* strfuncs.cc (current_codepage): Ditto.
(active_codepage): Ditto.
* sync.cc (lock_process::locker): Move here from dcrt0.cc.
* syscalls.cc (stat_suffixes): Move to path.cc.
* tty.cc (tty::create_master): Uncapitalize fatal warning for consistency.
* winsup.h: Include globals.h to declare most of the grab bag list of globals
which were previously defined here.
* mount.h: Move USER_* defines back to shared_info.h.
* speclib: Force temporary directory cleanup.
@
text
@d559 1
@


1.108
log
@	* Fix copyright dates.
@
text
@d4 1
a4 1
   2008 Red Hat, Inc.
d22 1
a22 1
#include <security.h>
@


1.107
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d3 2
a4 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007 Red Hat, Inc.
@


1.106
log
@	Drop old SetResourceLock stuff in favor of mutos.
	* dcrt0.cc (_reslock): Remove.
	(__cygwin_user_data): Accommodate removal of resourcelocks member.
	(dll_crt0_0): Don't initialize resourcelocks.
	* exceptions.cc (_cygtls::signal_exit): Drop resourcelocks handling.
	* mmap.cc (mmap_guard): New muto.
	(LIST_LOCK): Define.
	(LIST_UNLOCK): Define.
	(mmap_list::search_record): Remove.
	(mmap_list::try_map): Include code for anonymous case from
	mmap_list::search_record.
	(mmap_is_attached_or_noreserve): Access bookkeeping lists in a thread
	safe way.
	(mmap64): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.  Lock at the latest possible point.
	(munmap): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.
	(msync): Ditto.
	(mprotect): Ditto.
	* thread.cc (ResourceLocks::Lock): Remove.
	(SetResourceLock): Remove.
	(ReleaseResourceLock): Remove.
	(ResourceLocks::Init): Remove.
	(ResourceLocks::Delete): Remove.
	* thread.h (SetResourceLock): Drop declaration.
	(ReleaseResourceLock): Ditto.
	(class ResourceLocks): Drop definition.
	* include/sys/cygwin.h (class ResourceLocks): Drop forward declaration.
	(struct per_process): Replace resourcelocks with additional unused2
	element.
	(per_process_overwrite): Accommodate above change.
@
text
@d437 1
@


1.105
log
@* dcrt0.cc (child_info_fork::alloc_stack_hard_way): Change sense of guard test.
Increase size of stack reserved and increase size before the current stack
pointer.  Use pointers when doing arithmetic.
(dll_crt0_1): Initialize exception handler when we notice we're the child of a
fork from non-main thread.
* fork.cc (frok::parent): Make argument volatile.
(frok::child): Ditto.
(lock_signals): New class.
(lock_pthread): Ditto.
(hold_everhthing): Ditto.
(frok::parent): Move atforkprepare and atforkparent to lock_pthread class.
(fork): Make ischild boolean.  Use hold_everything variable within limited
scope to set various mutexes in such a way as to avoid deadlocks.
* thread.h (pthread_mutex::tid): New variable, active when debugging for
tracking thread id of owner.
(pthread_mutex::set_owner): Set tid when debugging.
* thread.cc (pthread_mutex::pthread_mutex): Clear tid.
(pthread_mutex::_unlock): Ditto when unlocking.
(pthread_mutex::fixup_after_fork): Set tid to special value after forking since
owner is unknown.
@
text
@a37 7
extern "C"
{
void SetResourceLock (int, int, const char *) __attribute__ ((regparm (3)));
void ReleaseResourceLock (int, int, const char *)
  __attribute__ ((regparm (3)));
}

a87 11
class ResourceLocks
{
public:
  LPCRITICAL_SECTION Lock (int);
  void Init ();
  void Delete ();
private:
  CRITICAL_SECTION lock;
  bool inited;
};

@


1.104
log
@	* cygwin.din (sem_unlink): Export.
	* posix_ipc.cc: Include thread.h and semaphore.h.  Remove TODO
	comment.
	(ipc_names): Add max_len member.  Set to maximum length of the path
	before tacking on the prefix path.  Set prefix path for named semaphors
	to /dev/shm, as on Linux.
	(enum ipc_type_t): Change sem to semaphore to avoid name conflicts.
	(check_path): Detect empty paths.  Use ipc_names's max_len member.
	Use __small_sprintf to create full object path name.  Special case
	semaphores.
	(ipc_cond_init): Drop superfluous strcpy.
	(class ipc_flock): New class to simplify file locking in subsequent
	code.
	(struct mq_hdr): Raise size of mqh_uname to allow adding a unique
	LUID to the name.
	(mq_open): Fix formatting.  Create unique synchronization object names
	using AllocateLocallyUniqueId.
	(struct sem_finfo): New structure defining named semaphore file content.
	(sem_open): Move here.  Rework implementation to allow kernel
	persistent implementation of POSIX named semaphores.
	(_sem_close): Implement sem_close.
	(sem_close): Move here.  Just call _sem_close with do_close parameter
	set to true.
	(sem_unlink): New function.
	* pthread.cc (mangle_sem_name): Remove.
	(sem_open): Move to posix_ipc.cc.
	(sem_close): Ditto.
	* syscalls.cc (close_all_files): Call semaphore::terminate here.
	* thread.cc: Fix formatting.  Rearrange semaphore functions so that
	they are close together.
	(semaphore::semaphore): Rework to play nicely with new named semaphore
	implementation.
	(semaphore::_terminate): Call _sem_close if semaphore is a named
	semaphore.
	(semaphore::destroy): Don't destroy named semaphores.  Return EINVAL
	instead.
	(semaphore::close): Only destroy named semaphores.  Return EINVAL
	otherwise.
	(semaphore::open): Rework to play nicely with new named semaphore
	implementation.  Loop through existing semaphores to be able to
	return same sem_t pointer as a former call on the same named semaphore.
	(semaphore::getinternal): New function called from _sem_close.
	* thread.h (class List): Make mx and head public.
	(class semaphore): Fix formatting.  Align method declarations with
	implementation in thread.cc.  Add members used for named semaphores.
	(semaphore::terminate): New static method.
	* include/semaphore.h: Redefine SEM_FAILED.  Fix formatting.
	(sem_unlink): Add declaration.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d3 1
a3 4
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007 Red Hat, Inc.

   Written by Marco Fuykschot <marco@@ddi.nl>
   Major update 2001 Robert Collins <rbtcollins@@hotmail.com>
d45 2
a46 1
DWORD cancelable_wait (HANDLE, DWORD, const cw_cancel_action = cw_cancel_self, const enum cw_sig_wait = cw_sig_nosig)
d299 3
d332 3
@


1.103
log
@	* thread.h: Revert patch from 2005-09-05.
	* thread.cc (pthread_mutex::can_be_unlocked): Return true also if
	mutex is owned by MUTEX_OWNER_ANONYMOUS.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d211 3
a219 3

  fast_mutex mx;
  list_node *head;
d636 13
a648 9
  static int init (sem_t * sem, int pshared, unsigned int value);
  static int destroy (sem_t * sem);
  static sem_t *open (const char *name, int oflag, mode_t mode,
		      unsigned int value);
  static int wait (sem_t * sem);
  static int post (sem_t * sem);
  static int getvalue (sem_t * sem, int *sval);
  static int trywait (sem_t * sem);
  static int timedwait (sem_t * sem, const struct timespec *abstime);
d653 4
a656 1
  char *name;
d659 1
a659 1
  semaphore (const char *name, int oflag, mode_t mode, unsigned int value);
d668 4
d681 1
@


1.103.8.1
log
@	Drop old SetResourceLock stuff in favor of mutos.
	* dcrt0.cc (_reslock): Remove.
	(__cygwin_user_data): Accommodate removal of resourcelocks member.
	(dll_crt0_0): Don't initialize resourcelocks.
	* exceptions.cc (_cygtls::signal_exit): Drop resourcelocks handling.
	* mmap.cc (mmap_guard): New muto.
	(LIST_LOCK): Define.
	(LIST_UNLOCK): Define.
	(mmap_list::search_record): Remove.
	(mmap_list::try_map): Include code for anonymous case from
	mmap_list::search_record.
	(mmap_is_attached_or_noreserve): Access bookkeeping lists in a thread
	safe way.
	(mmap64): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.  Lock at the latest possible point.
	(munmap): Replace SetResourceLock/ReleaseResourceLock by
	LIST_LOCK/LIST_UNLOCK.
	(msync): Ditto.
	(mprotect): Ditto.
	* thread.cc (ResourceLocks::Lock): Remove.
	(SetResourceLock): Remove.
	(ReleaseResourceLock): Remove.
	(ResourceLocks::Init): Remove.
	(ResourceLocks::Delete): Remove.
	* thread.h (SetResourceLock): Drop declaration.
	(ReleaseResourceLock): Ditto.
	(class ResourceLocks): Drop definition.
	* include/sys/cygwin.h (class ResourceLocks): Drop forward declaration.
	(struct per_process): Replace resourcelocks with additional unused2
	element.
	(per_process_overwrite): Accommodate above change.

	* mmap.cc: Convert usage of dynamically growing cmalloced arrays to
	cmalloced linked lists throughout.
	(class mmap_record): Add LIST_ENTRY element.
	(mmap_record::match): New method, taking over match algorithm from
	list::search_record.
	(class mmap_list): Rename from class list.  Add LIST_ENTRY.  Convert
	recs to a LIST_HEAD.  Drop nrecs and maxrecs members.
	(mmap_list::get_record): Drop entirely.
	(mmap_list::free_recs): Drop entirely.
	(mmap_list::del_record): Take mmap_record to delete as parameter.
	(mmap_list::search_record): Convert to mmap_record::match.
	(class mmap_areas): Rename from class map.  Convert lists to LIST_HEAD.
	(mmap_areas::get_list): Drop entirely.
	(mmap_areas::del_list): Take mmap_list to delete as parameter.
	(mprotect): Fix indentation.
@
text
@d41 7
d97 11
@


1.103.8.2
log
@	* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and
	use either main sigmask or current thread sigmask.
	(set_process_mask): Ditto.
	(sighold): Ditto.
	(sigrelse): Ditto.
	(sigset): Ditto.
	(set_process_mask_delta): Ditto.
	(_cygtls::call_signal_handler): Ditto.
	* fhandler_process.cc (format_process_status): Ditto.
	* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
	* pinfo.h (class pinfo): Ditto.
	* select.cc (pselect): Ditto.
	* signal.cc (sigprocmask): Ditto.
	(abort): Ditto.
	(sigpause): Ditto.
	(sigsend): Ditto.
	(wait_sig): Ditto.
	* sigproc.cc (sig_send): Ditto.
	(pending_signals::add): Ditto.
	(wait_sig): Ditto.
	* thread.h (pthread::parent_tls): New member.
	* thread.cc (pthread::pthread): Record parent_tls here.
	(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@a432 1
  _cygtls *parent_tls;
@


1.102
log
@	* thread.h (pthread_mutex::get_pthread_self): Remove.
	(pthread_mutex::lock): Use ::pthread_self as self parameter.
	(pthread_mutex::trylock): Ditto.
	(pthread_mutex::unlock): Ditto.
	(pthread_mutex::destroy): Ditto.
@
text
@d304 6
d312 1
a312 1
    return _lock (::pthread_self ());
d316 1
a316 1
    return _trylock (::pthread_self ());
d320 1
a320 1
    return _unlock (::pthread_self ());
d324 1
a324 1
    return _destroy (::pthread_self ());
@


1.101
log
@	* thread.cc (pthread::create(3 args)): Make bool.
	(pthread_null::create): Ditto.
	(pthread::create(4 args)): Check return of inner create rather than
	calling is_good_object().
	* thread.h: Ditto.
@
text
@a303 6
  pthread_t get_pthread_self () const
  {
    return PTHREAD_MUTEX_NORMAL == type ? MUTEX_OWNER_ANONYMOUS :
      ::pthread_self ();
  }

d306 1
a306 1
    return _lock (get_pthread_self ());
d310 1
a310 1
    return _trylock (get_pthread_self ());
d314 1
a314 1
    return _unlock (get_pthread_self ());
d318 1
a318 1
    return _destroy (get_pthread_self ());
@


1.100
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d383 1
a383 1
  virtual void create (void *(*)(void *), pthread_attr *, void *);
d476 1
a476 1
  void create (void *(*)(void *), pthread_attr *, void *);
@


1.99
log
@* thread.h (verifyable_object_state verifyable_object_isvalid): Delete function
declaration that should have been static.
* thread.cc (verifyable_object_state verifyable_object_isvalid): Make inline
static.
(pthread*::is_good_object): Move to directly after verifyable_object_state
verifyable_object_isvalid and make inline.
@
text
@d457 1
a457 1
  void pop_all_cleanup_handlers (void);
d692 2
a693 2
  void fixup_before_fork (void);
  void fixup_after_fork (void);
@


1.98
log
@Replace valid memory checks with new myfault class "exception handling", almost
everywhere.  Leave some thread.cc stuff alone for now.
* cygtls.h: Kludge some definitions to avoid including a problematic windows
header.
(_cygtls::_myfault): New entry.
(_cygtls::_myfault_errno): Ditto.
(_cygtls::fault_guarded): New function.
(_cygtls::setup_fault): Ditto.
(_cygtls::return_from_fault): Ditto.
(_cygtls::clear_fault): Ditto.
(myfault): New class.
* exceptions.cc (handle_exceptions): Handle case of guarded fault in system
routine.
* gendef: Add another entry point for setjmp that the compiler doesn't know
about and won't complain about.
* gentls_offsets: Just include windows.h rather than kludging a HANDLE def.
* miscfuncs.cc (check_null_str): Delete.
(check_null_empty_str): Ditto.
(check_null_empty_str_errno): Ditto.
(check_null_str_errno): Ditto.
(__check_null_invalid_struct): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
(dummytest): New function.
(check_iovec_for_read): Delete.
(chec_iovec): Rename from check_iovec_for_write.  Take a read/write parameter.
* tlsoffsets.h: Regenerate.
* winsup.h: Remove check_* declarations.
(check_iovec_for_read): Delete declaration.  Turn into a define instead.
(check_iovec_for_write): Ditto.
(check_iovec): New declaration.
* thread.h: Use ifdef guard name consistent with other header files.
@
text
@a139 5
verifyable_object_state verifyable_object_isvalid (void const * objectptr, long magic,
						   void *static_ptr1 = NULL,
						   void *static_ptr2 = NULL,
						   void *static_ptr3 = NULL);

@


1.97
log
@* include/pthread.h: Change PTHREAD_MUTEX_DEFAULT to PTHREAD_MUTEX_NORMAL.
Revert PTHREAD_MUTEX_INITIALIZER to PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
since that is actually closer to what linux does.
* thread.h (cw_cancel_action): New enum.
(cancelable_wait): Use cw_cancel_action as third argument.
* thread.cc (cancelable_wait): Ditto.  Don't wait for cancel if cancel_action
== cw_no_cancel.
(pthread::create): Don't wait for cancel event since that is racy.
(pthread_mutex::pthread_mutex): Set default to PTHREAD_MUTEX_ERRORCHECK.
(pthread_mutexattr::pthread_mutexattr): Ditto.
(pthread_mutex::_lock): Tell cancelable_wait not to wait for cancellation
event.
(semaphore::_timedwait): Accommodate change in cancelable_wait args.
(pthread::join): Ditto.
@
text
@d14 2
a15 2
#ifndef _CYGNUS_THREADS_
#define _CYGNUS_THREADS_
d710 1
a710 1
#endif // _CYGNUS_THREADS_
@


1.96
log
@Change pthread::cancelable_wait to just cancelable_wait, throughout.
* thread.h (cw_sig_wait): New enum.
(fast_mutex::lock): Use cancelable_wait with resumable signal.
(cancelable_wait): Change fourth argument to cw_sig_wait enum.
* thread.cc (cancelable_wait): Ditto.  Loop on signal detection if fourth
argument == cw_sig_resume.
@
text
@d34 7
d48 1
a48 1
DWORD cancelable_wait (HANDLE, DWORD, const bool = true, const enum cw_sig_wait = cw_sig_nosig)
d80 1
a80 1
      cancelable_wait (win32_obj_id, INFINITE, false, cw_sig_resume);
@


1.95
log
@* thread.h (List_remove): Revert most of 2005-05-30 change.
@
text
@d27 7
d41 3
d72 2
a73 2
    if (InterlockedIncrement ((long *)&lock_counter) != 1)
      WaitForSingleObject (win32_obj_id, INFINITE);
d78 1
a78 1
    if (InterlockedDecrement ((long *)&lock_counter))
a409 2
  static DWORD cancelable_wait (HANDLE object, DWORD timeout, const bool do_cancel = true, const bool do_sig_wait = false);

@


1.94
log
@* thread.h (List_remove): Make node parameter const.  Use simple comparison and
assignment rather than InterlockedCompareExchangePointer since access is
already synchronized.
@
text
@d146 1
a146 3
      if (head == node)
        head = head->next;
      else
@


1.93
log
@* thread.h (pthread_key::set): Inline.
(pthread_key::get): Ditto.
* thread.cc (pthread::set): Delete.
(pthread::get): Ditto.
@
text
@d139 1
a139 1
List_remove (fast_mutex &mx, list_node *&head, list_node *node)
d146 3
a148 1
      if (InterlockedCompareExchangePointer (&head, node->next, node) != node)
@


1.92
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d212 1
a214 1
  DWORD tls_index;
d216 2
a217 2
  int set (const void *);
  void *get () const;
@


1.91
log
@* thread.h (pthread::init_mainthread): Remove parameter forked.
(pthread::set_tls_self_pointer): New static function.
* thread.cc (MTinterface::fixup_after_fork): Change call to
pthread::init_mainthread.
(pthread::init_mainthread): Remove parameter forked.  Simplify thread self
pointer handling.
(pthread::self): Set thread self pointer to null_pthread if thread has not been
initialized.
(pthread::set_tls_self_pointer): New static function.
@
text
@d124 3
a126 3
                                                   void *static_ptr1 = NULL,
                                                   void *static_ptr2 = NULL,
                                                   void *static_ptr3 = NULL);
d282 1
a282 1
                   const pthread_mutex_t initializer = NULL);
@


1.90
log
@* thread.h (pthread::init_mainthread): Add parameter forked.  Set forked
default to false..
* thread.cc (MTinterface::fixup_after_fork): Call pthread::init_mainthread with
forked = true.
(pthread::init_mainthread): Add parameter forked.  Do not change thread self
pointer when forked.
@
text
@d376 1
a376 1
  static void init_mainthread (const bool forked = false);
a449 1
  void set_tls_self_pointer ();
d452 1
@


1.89
log
@* include/pthread.h (PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP):
New define.
(PTHREAD_NORMAL_MUTEX_INITIALIZER_NP): Ditto.
(PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP): Ditto.
* thread.cc (pthread_mutex::is_good_initializer):
Check for all posssible initializers
(pthread_mutex::is_good_initializer_or_object): Ditto.
(pthread_mutex::is_good_initializer_or_bad_object): Ditto.
(verifyable_object_isvalid): Support up to three static
initializers.
(verifyable_object_isvalid (void const *,long)): Remove.
(pthread_cond::is_good_initializer_or_bad_object): Remove
unneeded objectState var.
(pthread_cond::init): Condition remains unchanged when creation
has failed.
(pthread_rwlock::is_good_initializer_or_bad_object): Remove
unneeded objectState var.
(pthread_rwlock::init): Rwlock remains unchanged when creation
has failed.
(pthread_mutex::init): Remove obsolete comment.
Mutex remains unchanged when creation has failed. Add support
for new initializers.
(pthread_mutex_getprioceiling): Do not create mutex,
just return ENOSYS.
(pthread_mutex_lock): Simplify.
(pthread_mutex_trylock): Remove unneeded local themutex.
(pthread_mutex_unlock): Just return EPERM if mutex is not
initialized.
(pthread_mutex_setprioceiling): Do not create mutex,
just return ENOSYS.
* thread.h (verifyable_object_isvalid): Support up to three
static initializers.
(verifyable_object_isvalid (void const *,long)): Remove
prototype.
(pthread_mutex::init): Add optional initializer to parameter
list.
@
text
@d376 1
a376 1
  static void init_mainthread ();
@


1.88
log
@	* thread.cc (pthread::cancelable_wait): Rearrange slightly.
	Add do_sig_wait parameter.  Wait for signal_arrived if set to true.
	Return WAIT_SIGNALED if signal arrived.
	(pthread_cond::wait): Accomodate change to pthread::cancelable_wait.
	(pthread::join): Ditto.
	(semaphore::_timedwait): Ditto.
	(semaphore::_wait): Ditto.  Change to return int to allow status
	feedback.
	(semaphore::wait): Return return value from semaphore::_wait.
	* thread.h (WAIT_SIGNALED): New definition.
	(pthread::cancelable_wait): Change declaration.  Define do_sig_wait
	as false by default to not interfere with existing calls accidentally.
	(semaphore::_wait): Declare int.
@
text
@d123 4
a126 2
verifyable_object_state verifyable_object_isvalid (void const *, long);
verifyable_object_state verifyable_object_isvalid (void const *, long, void *);
d281 2
a282 1
  static int init (pthread_mutex_t *, const pthread_mutexattr_t *);
@


1.87
log
@Rename _threadinfo to _cygtls, throughout.
* cygtls.h (_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::push): Make second argument mandatory.
(_cygtls::fixup_after_fork): Declare new function.
(_cygtls::lock): Ditto.
* cygtls.cc (_cygtls::fixup_after_fork): Define new function.
* dcrt0.cc (cygwin_finished_initializing): Define as bool.
(alloc_stack): Use _tlstop rather than arbitrary variable in probably vain
attempt to avoid strange fork problem on CTRL-C.
(dll_crt0_0): Remove obsolete winpids::init call.
* dll_init.cc (dll_dllcrt0): Detect forkee condition as equivalent to
initializing.
* winsup.h (cygwin_finished_initializing): Declare as bool.
* exceptions.cc (handle_exceptions): Rely on cygwin_finished_initializing to
determine how to handle exception during process startup.
(_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::interrupt_now): Fill in second argument to push.
(signal_fixup_after_fork): Eliminate.
(setup_handler): Initialize locked to avoid potential inappropriate unlock.
Resume thread if it has acquired the stack lock.
(ctrl_c_handler): Just exit if ctrl-c is hit before cygiwn has finished
initializing.
* fork.cc (sync_with_child): Don't call abort since it can cause exit
deadlocks.
(sync_with_child): Change debugging output slightly.
(fork_child): Set cygwin_finished_initializing here.  Call _cygtls fork fixup
and explicitly call sigproc_init.
(fork_parent): Release malloc lock on fork failure.
(vfork): Call signal handler via _my_tls.
* sigproc.cc (sig_send): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* signal.cc (nanosleep): Ditto.
(abort): Ditto.
(kill_pgrp): Avoid killing self if exiting.
* sync.cc (muto::acquire): Remove (temporarily?) ill-advised exiting_thread
check.
* gendef (_sigfe): Be more agressive in protecting stack pointer from other
access by signal thread.
(_cygtls::locked): Define new function.
(_sigbe): Ditto.
(_cygtls::pop): Protect edx.
(_cygtls::lock): Use guaranteed method to set eax to 1.
(longjmp): Aggressively protect signal stack.
* miscfuncs.cc (low_priority_sleep): Reduce "sleep time" for secs == 0.
* pinfo.cc (winpids::set): Counterintuitively use malloc's lock to protect
simultaneous access to the pids list since there are pathological conditions
which can cause malloc to call winpid.
(winpids::init): Eliminate.
* pinfo.h (winpids::cs): Eliminate declaration.
* pinfo.h (winpids::init): Eliminate definition.
@
text
@d350 1
d397 1
a397 1
  static DWORD cancelable_wait (HANDLE object, DWORD timeout, const bool do_cancel = true);
d650 1
a650 1
  void _wait ();
@


1.86
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d351 1
a351 1
class _threadinfo;
d363 1
a363 1
  _threadinfo *cygtls;
@


1.85
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.84
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d17 1
a17 4
#define LOCK_FD_LIST     1
#define LOCK_MEMORY_LIST 2
#define LOCK_MMAP_LIST   3
#define LOCK_DLL_LIST    4
@


1.84.2.1
log
@* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d17 4
a20 1
#define LOCK_MMAP_LIST   1
@


1.83
log
@* cygthread.cc (cygthread::stub): Revert previous change and again subsume
cygthread::stub2.  Just return from function now since ExitThread is guaranteed
by automatic _threadinfo wrapper.  Define as per ThreadProc convention.
(cygthread::stub2): Remove.
(cygthread::simplestub): Perform similar operations to cygthread::stub.
(cygthread::simplestub2): Remove.
* cygthread.h (cygthread::stub): Declare as per ThreadProc convention.
(cygthread::stub2): Remove declaration.
(cygthread::simplestub): Declare as per ThreadProc convention.
(cygthread::simplestub2): Remove declaration.
* cygtls.h (_threadinfo::call): Define first argument as per ThreadProc
convention.
(_threadinfo::call2): Ditto.
(_tlsbase): Define as char * pointer.
(_tlstop): New definition.
(_main_tls): Define here.
* dcrt0.cc (alloc_stack): Revert previous change which called init_thread since
information would be overwritten by fork later anyway.
(dll_crt0_1): Use _tlsbase and _tlstop for setting stack bottom, top.
* exceptions.cc: Move _main_tls declaration to cygtls.h.
(_threadinfo::call): Define first argument as per ThreadProc convention.
(_threadinfo::call2): Call ExitThread with thread function return value.
(_threadinfo::init_thread): Don't initialize cygtls to zero if input arg is
NULL.
* fork.cc (fork_child): Reset _main_tls here.  Reinitialize parts of _my_tls
after copying data from parent.
* init.cc (threadfunc_fe): New function.  Front-end for all threads created in
cygwin processes.
(munge_threadfunc): New function.
(dll_entry): Call munge_threadfunc to force the call of a thread wrapper.
* thread.cc (pthread::thread_init_wrapper): Perform similar operations to
cygthread::stub.
(pthread::thread_init_wrapper2): Remove.
* thread.h (pthread::thread_init_wrapper): Declare as per ThreadProc
convention.
(pthread::thread_init_wrapper2): Remove declaration.
* window.cc (Winmain): Just return from function now since ExitThread is
guaranteed by automatic _threadinfo wrapper.
@
text
@a24 16
extern "C"
{
#if defined (_CYG_THREAD_FAILSAFE) && defined (_MT_SAFE)
  void AssertResourceOwner (int, int);
#else
#define AssertResourceOwner(i,ii)
#endif
}

#ifndef _MT_SAFE

#define SetResourceLock(i,n,c)
#define ReleaseResourceLock(i,n,c)

#else

d27 1
a28 6
#include <signal.h>
#include <pwd.h>
#include <grp.h>
#include <security.h>
#define _NOMNTENT_FUNCS
#include <mntent.h>
a31 63

struct _winsup_t
{
  /*
     Needed for the group functions
   */
  struct __group16 _grp;
  char *_namearray[2];
  int _grp_pos;

  /* console.cc */
  unsigned _rarg;

  /* dlfcn.cc */
  int _dl_error;
  char _dl_buffer[256];

  /* passwd.cc */
  struct passwd _res;
  char _pass[_PASSWORD_LEN];
  int _pw_pos;

  /* path.cc */
  struct mntent mntbuf;
  int _iteration;
  DWORD available_drives;
  char mnt_type[80];
  char mnt_opts[80];
  char mnt_fsname[CYG_MAX_PATH];
  char mnt_dir[CYG_MAX_PATH];

  /* strerror */
  char _strerror_buf[20];

  /* sysloc.cc */
  char *_process_ident;
  int _process_logopt;
  int _process_facility;
  int _process_logmask;

  /* times.cc */
  char timezone_buf[20];
  struct tm _localtime_buf;

  /* uinfo.cc */
  char _username[UNLEN + 1];

  /* net.cc */
  char *_ntoa_buf;
  struct protoent *_protoent_buf;
  struct servent *_servent_buf;
  struct hostent *_hostent_buf;
};


struct __reent_t
{
  struct _reent *_clib;
  struct _winsup_t *_winsup;
  void init_clib (_reent&);
};

_winsup_t *_reent_winsup ();
a34 6

#ifdef _CYG_THREAD_FAILSAFE
void AssertResourceOwner (int, int);
#else
#define AssertResourceOwner(i,ii)
#endif
a85 3
  ResourceLocks ()
  {
  }
a88 4
#ifdef _CYG_THREAD_FAILSAFE
  DWORD owner;
  DWORD count;
#endif
a675 4
  // Used for main thread data, and sigproc thread
  struct __reent_t reents;
  struct _winsup_t winsup_reent;

a679 3
  pthread_key reent_key;
  pthread_key thread_self_key;

d684 1
a684 4
#if 1 // avoid initialization since zero is implied and
      // only use of this class is static
  MTinterface () : reent_key (NULL), thread_self_key (NULL) {}
#else
d687 1
a687 2
    pthread_prepare (NULL), pthread_child (NULL), pthread_parent (NULL),
    reent_key (NULL), thread_self_key (NULL)
a693 3

#endif // MT_SAFE

@


1.82
log
@* miscfuncs.cc (low_priority_sleep): Correct thinko which caused SetPriority to
be called unnecessarily.
* thread.cc (pthread::init_main_thread): Call new create_cancel_event function.
(pthread::precreate): Ditto.
(pthread::postcreate): Remove cancel_event creation.
(pthread::create_cancel_event): Define new function.
* thread.h (pthread::create_cancel_event): Declare new function.
@
text
@d505 1
a505 2
  static void thread_init_wrapper (void *);
  static void thread_init_wrapper2 (void *, void *);
@


1.81
log
@* cygthread.cc (cygthread::stub): Properly establish _threadinfo environment.
(cygthread::stub2): New function.
(cygthread::simplestub): Ditto.
(cygthread::simplestub2): New function.
* cygthread.h (cygthread::stub2): Declare new function.
(cygthread::simplestub2): Ditto.
* cygtls.h (_threadinfo::call): Declare new function.
(_threadinfo::call2): Ditto.
* dcrt0.cc (dll_crt0_1): Accommodate new _threadinfo::init which doesn't return
pointer to tls.
(_dll_crt0): Remove obsolete DECLARE_TLS_STORAGE.
(dll_crt0): Ditto.
* exceptions.cc (_threadinfo::call): New function.
(_threadinfo::call2): Ditto.
(_threadinfo::init): Don't return pointer.
* thread.cc (pthread::thread_init_wrapper): Properly establish _threadinfo
environment.
(pthread::thread_init_wrapper2): New function.
* thread.h (pthread::thread_init_wrapper): Remove noreturn attribute
(pthread::thread_init_wrapper2): Declare new function.
* winbase.h: Remove obsolete code.
@
text
@d548 1
@


1.80
log
@white space
@
text
@d505 2
a506 1
  static void *thread_init_wrapper (void *) __attribute__ ((noreturn));
@


1.79
log
@
* thread.cc (pthread_rwlock::add_reader): Remove mx parameter for
List_insert call.
(pthread::prepare): Ensure race safeness when adding function
pointers to atfork lists by using List_insert.
* thread.h (List_insert): Use InterlockedCompareExchangePointer to
ensure race safeness without using a mutex.
(List_remove): Use InterlockedCompareExchangePointer to
ensure race safeness with List_insert.
(List::insert): Remove mx parameter for	List_insert call.
@
text
@d147 2
a148 2
        debug_printf ("CreateSemaphore failed. %E");
        return false;
d245 2
a246 2
        {
          list_node *cur = head;
d248 5
a252 5
          while (cur->next && node != cur->next)
            cur = cur->next;
          if (node == cur->next)
            cur->next = cur->next->next;
        }
d291 2
a292 2
        (cur->*callback) ();
        cur = cur->next;
d692 2
a693 2
        if (!readers)
          cond_writers.unblock (false);
@


1.78
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@d227 1
a227 1
List_insert (fast_mutex &mx, list_node *&head, list_node *node)
d231 3
a233 4
  mx.lock ();
  node->next = head;
  head = node;
  mx.unlock ();
d242 1
a242 3
  if (node == head)
    head = head->next;
  else if (head)
d244 9
a252 6
      list_node *cur = head;

      while (cur->next && node != cur->next)
        cur = cur->next;
      if (node == cur->next)
        cur->next = cur->next->next;
d277 1
a277 1
    List_insert (mx, head, node);
@


1.77
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d256 1
a256 1
 
d308 1
a308 1
class pthread_key:public verifyable_object
d346 1
a346 1
class pthread_attr:public verifyable_object
d360 1
a360 1
class pthread_mutexattr:public verifyable_object
d370 1
a370 1
class pthread_mutex:public verifyable_object
d451 2
a452 1
class pthread:public verifyable_object
d463 1
a466 4
  /* signal handling */
  struct sigaction *sigs;
  sigset_t *sigmask;
  LONG *sigtodo;
d489 1
a489 1
  virtual void exit (void *value_ptr);
d505 1
a505 1
  static void *thread_init_wrapper (void *);
d546 1
a546 2
  void set_thread_id_to_current ();
  static void set_tls_self_pointer (pthread *);
a549 1
  void init_current_thread ();
d562 1
a562 1
  void exit (void *value_ptr);
d576 1
a576 1
class pthread_condattr:public verifyable_object
d586 1
a586 1
class pthread_cond:public verifyable_object
d627 1
a627 1
class pthread_rwlockattr:public verifyable_object
d637 1
a637 1
class pthread_rwlock:public verifyable_object
d716 1
a716 1
class semaphore:public verifyable_object
d766 1
a766 1
class MTinterface
a767 1
public:
d787 4
d792 1
a792 1
    concurrency (0), threadcount (1),
d797 1
@


1.76
log
@
Rename pthread::running to pthread::valid throughout.

* thread.h: (pthread::suspend_all_except_self): New static method.
(pthread::resume_all): Ditto.
(pthread::suspend_except_self): New method.
(pthread::resume): Ditto.
* thread.cc (pthread::suspend_except_self): Implement.
(pthread::resume): Ditto.
@
text
@d81 2
a82 2
  char mnt_fsname[MAX_PATH];
  char mnt_dir[MAX_PATH];
@


1.75
log
@
* thread.h (fast_mutex::init): Initialize lock_counter.
@
text
@d459 1
a459 1
  bool running;
d524 10
d539 3
@


1.74
log
@	* cygwin.din: Add sem_close, sem_getvalue, sem_open and sem_timedwait.
	* pthread.cc (+mangle_sem_name): New function.
	(sem_open): Ditto.
	(sem_close: Ditto.
	(sem_timedwait): Ditto.
	(sem_getvalue): Ditto.
	* thread.cc (semaphore::semaphore): Rearrange member initialization.
	Use appropriate security attribute for process shared semaphores.
	(semaphore::semaphore): New constructor for named semaphores.
	(semaphore::~semaphore): Care for semaphore name.
	(semaphore::_post): Accomodate failing ReleaseSemaphore. Use value
	returned by ReleaseSemaphore vor currentvalue.
	(semaphore::_getvalue): New method.
	(semaphore::_timedwait): Ditto.
	(semaphore::_fixup_after_fork): Rearrange. Don't fail for process
	shared semaphores.
	(semaphore::open): New method.
	(semaphore::timedwait): Ditto.
	(semaphore::post): Fix return value.  Set errno appropriately.
	(semaphore::getvalue): New method.
	* thread.h (class semaphore): Add prototypes for open, getvalue,
	timedwait, _getvalue, _timedwait.  Add prototypes for new constructor.
	Add name member.
	* include/semaphore.h: Add prototypes for sem_open, sem_close,
	sem_timedwait and sem_getvalue.
	include/cygwin/version.h: Bump API minor number.
@
text
@d143 1
@


1.73
log
@Rename native_mutex to fast_mutex throughout.
Rename pthread_key::save_key_to_buffer to
pthread_key::_fixup_before_fork throughout.
Rename pthread_key::recreate_key_from_buffer to
pthread_key::_fixup_after_fork throughout.

* thread.cc (native_mutex::init): Remove.
(native_mutex::lock): Ditto.
(native_mutex::unlock): Ditto.
(pthread::push_cleanup_handler): InterlockedExchangePointer
is not needed here.
(pthread_rwlock::pthread_rwlock): Initialize readers list mutex.
(pthread_rwlock::add_reader): Add reader via List_insert.
(pthread_rwlock::lookup_reader): Lock list while walking through.
(pthread_cond::init): Locking the init mutex is now void.
(pthread_rwlock::init): Ditto.
(pthread_mutex::init): Ditto.
* thread.h: Include security.h.
(fast_mutex): New class. Replacement for native_mutex.
(List_insert): New template function.
(List_remove): Ditto.
(List::List): Initialize synchronising mutex.
(List::fixup_after_fork): New method.
(List::insert): Add node via List_insert.
(List::remove): Remove node via List_remove.
(List::pop): Remove.
(List::for_each): Lock list while walking through.
(List::mx_init): New method.
(pthread_mutex::fixup_after_fork): Fixup mutex list after fork.
(pthread::fixup_after_fork): Ditto.
(pthread_conds::fixup_after_fork): Ditto.
(pthread_rwlock::fixup_after_fork): Ditto.
(semaphore::fixup_after_fork): Ditto.
(pthread_rwlock::readers_mx): New member.
@
text
@d713 2
d716 2
d719 1
a719 1
  static int post (sem_t * sem);
d724 1
d727 1
d740 1
d742 1
@


1.72
log
@* thread.h (__reent_t::init_clib): Declare new function.
* thread.cc (__reent_t::init_clib): Define new function.
(pthread::thread_init_wrapper): Use __reent_t::init_clib to init local clib
storage and set std{in,out,err} appropriately.
@
text
@d47 1
d127 1
a127 1
class native_mutex
d130 34
a163 3
  bool init ();
  bool lock ();
  void unlock ();
d165 2
a166 1
  HANDLE theHandle;
d225 35
a259 2
template <class list_node> class List {
public:
d262 1
d265 1
a265 1
  void insert (list_node *node)
a266 3
    if (!node)
      return;
    node->next = (list_node *) InterlockedExchangePointer (&head, node);
d269 1
a269 1
  list_node *remove ( list_node *node)
d271 2
a272 4
    if (!node || !head)
      return NULL;
    if (node == head)
      return pop ();
d274 3
a276 6
    list_node *result_prev = head;
    while (result_prev && result_prev->next && !(node == result_prev->next))
      result_prev = result_prev->next;
    if (result_prev)
      return (list_node *)InterlockedExchangePointer (&result_prev->next, result_prev->next->next);
    return NULL;
d279 1
a279 1
  list_node *pop ()
d281 1
a281 1
    return (list_node *) InterlockedExchangePointer (&head, head->next);
a283 1
  /* poor mans generic programming. */
d286 3
a288 2
    list_node *node = head;
    while (node)
d290 2
a291 2
        (node->*callback) ();
        node = node->next;
d293 1
d297 7
d318 1
a318 1
  static void fixup_before_fork()
d320 1
a320 1
    keys.for_each (&pthread_key::save_key_to_buffer);
d323 1
a323 1
  static void fixup_after_fork()
d325 2
a326 1
    keys.for_each (&pthread_key::recreate_key_from_buffer);
d338 2
a339 2
  void save_key_to_buffer ();
  void recreate_key_from_buffer ();
d432 1
d445 1
a445 1
  static native_mutex mutex_initialization_lock;
d519 1
d606 1
d614 1
a614 1
  static native_mutex cond_initialization_lock;
d647 1
d667 1
d695 1
a695 1
  static native_mutex rwlock_initialization_lock;
d727 1
@


1.71
log
@
* thread.cc (MTinterface::fixup_after_fork): Fix thread list after fork.
(pthread::threads): Instantiate.
(pthread::pthread): Initialize running and suspendend.
Initialize next with NULL.
Add thread to thread list if it is not the null_pthread.
(pthread::~pthread): Remove thread from thread list if it is not the null_pthread.
(pthread::postcreate): Set running flag.
(pthread::exit): Reset running flag.
(pthread::cancel): Try to cancel thread only if still running.
(pthread::_fixup_after_fork): Implement.
(pthread::detach): Check if thread is still running before detach.
* thread.h (pthread::running): New member.
(pthread::next): Ditto.
(pthread::fixup_after_fork): New static method.
(pthread::threads): New static method.
(pthread::_fixup_after_fork): New method.
@
text
@d111 1
@


1.71.4.1
log
@* thread.h (__reent_t::init_clib): Declare new function.
* thread.cc (__reent_t::init_clib): Define new function.
(pthread::thread_init_wrapper): Use __reent_t::init_clib to init local clib
storage and set std{in,out,err} appropriately.
* syscalls.cc (system): Strip signal considerations from here so that they are
not inherited by a child process.
* spawn.cc (spawn_guts): Handle system() signal stuff here.
* winsup.h (_P_SYSTEM): Define.
@
text
@a110 1
  void init_clib (_reent&);
@


1.70
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d388 1
a392 1
  // int joinable;
d445 7
d453 1
d457 2
@


1.69
log
@
* thread.h (pthread::init_mainthread): Remove function parameter.
(MTinterface::Init): Ditto.
* thread.cc (MTinterface::Init): Remove function parameter.
Always initialize reent_key.
(pthread::init_mainthread): Remove function parameter.
(MTinterface::fixup_after_fork): Fix pthread::init_mainthread call.
* dcrt0.cc (dll_crt_0_1) Fix calls to MTinterface::Init and
pthread::init_mainthread.
Call pthread::init_mainthread only when not forked.
@
text
@a112 1
_reent *_reent_clib ();
@


1.68
log
@
* thread.h (pthread::equal): New static method.
* thread.cc: Rename pthread_equal to pthread::equal throughout.
(pthread_equal): Use pthread::equal to compare threads ids.
@
text
@d404 1
a404 1
  static void init_mainthread (bool);
d682 1
a682 1
  void Init (int);
@


1.67
log
@
Fix a race in pthread_rwlock caused by simultanoues unlock and cancelation.

* thread.h (pthread_rwlock::release): New method.
* thread.cc (pthread_rwlock::unlock): Use release to signal
waiting threads.
(pthread_rwlock::rdlock_cleanup): Signal waiting threads after a
cancelation.
(pthread_rwlock::wrlock_cleanup): Ditto.
@
text
@d441 5
@


1.66
log
@
* thread.h: Change class names, methods, members and local vars
according to the GNU coding style.
* thread.cc: Ditto.
* dcrt0.cc (dll_crt0_1): Rename pthread::initMainThread call to
pthread::init_mainthread.
* pthread.cc (pthead_getsequence_np): Rename pthread::isGoodObject
call to pthread::is_good_object.
@
text
@d590 12
@


1.65
log
@
* thread.h (class List): Move inline code inside class
declaration.
(List::forEach): Change callback parameter to template class
member functionpointer.
(pthread_keys::fixup_before_fork): Change to inline. Use
List::forEach to fixup keys.
(pthread_keys::fixup_after_fork): Ditto.
(pthread_keys::runAllDestructors): Ditto.
(pthread_key::saveAKey): Remove.
(pthread_key::restoreAKey): Ditto.
(pthread_key::destroyAKey): Ditto.
(pthread_key::run_destructor): Rename to runDestructor.
(pthread_mutex::fixup_after_fork): Change to inline. Use
List::forEach to fixup mutexes after a fork.
(pthread_mutex::FixupAfterFork): New method.
(pthread_mutex::mutexes): New member.
(pthread_cond::fixup_after_fork): Change to inline. Use
List::forEach to fixup conds after a fork.
(pthread_cond::FixupAfterFork): New method.
(pthread_cond::conds): New member.
(pthread_rwlock::fixup_after_fork): Change to inline. Use
List::forEach to fixup rwlocks after a fork.
(pthread_rwlock::FixupAfterFork): New method.
(pthread_rwlock::rwlocks): New member.
(semaphore::fixup_after_fork): Change to inline. Use
List::forEach to fixup mutexes after a fork.
(semaphore::FixupAfterFork): New method.
(semaphore::semaphores): New member.
(MTinterface::mutexs): Remove.
(MTinterface::conds): Ditto.
(MTinterface::rwlocks): Ditto.
(MTinterface::semaphores): Ditto.
(pthread_equal): Add extern "C".
(pthread_mutex_lock): Ditto.

* thread.cc (MTinterface::fixup_after_fork): Change
fixup_after_fork calls for pthread objects.
(semaphore::conds): Instantiate.
(pthread_cond::pthread_cond): Use List::Insert rather than
custom list code.
(pthread_cond::~pthread_cond): Use List::Remove rather than
custom list code.
(pthread_cond::fixup_after_fork): Rename to FixupAfterFork.
(pthread_rwlock::rwlocks): Instantiate.
(pthread_rwlock::pthread_crwlock): Use List::Insert rather than
custom list code.
(pthread_rwlock::~pthread_rwlock): Use List::Remove rather than
custom list code.
(pthread_rwlock::fixup_after_fork): Rename to FixupAfterFork.
(pthread_key::saveAKey): Remove.
(pthread_key::fixup_before_fork): Ditto.
(pthread_key::restoreAKey): Ditto.
(pthread_key::fixup_after_fork): Ditto.
(pthread_key::destroyAKey): Ditto.
(pthread_key::runAllDestructors): Ditto.
(pthread_key::run_destructor): Rename to runDestructor.
(pthread_mutex::mutexes): Instantiate.
(pthread_mutex::pthread_mutex): Use List::Insert rather than
custom list code.
(pthread_mutex::~pthread_mutex): Use List::Remove rather than
custom list code.
(pthread_mutex::fixup_after_fork): Rename to FixupAfterFork.
(semaphore::conds): Instantiate.
(semaphore::semaphore): Use List::Insert rather than custom list
code.
(semaphores::~semaphore): Use List::Remove rather than custom
list code.
(semaphore::fixup_after_fork): Rename to FixupAfterFork.
@
text
@d126 1
a126 1
class nativeMutex
d192 1
a192 1
template <class ListNode> class List {
d198 1
a198 1
  void Insert (ListNode *aNode)
d200 1
a200 1
    if (!aNode)
d202 1
a202 1
    aNode->next = (ListNode *) InterlockedExchangePointer (&head, aNode);
d205 1
a205 1
  ListNode *Remove ( ListNode *aNode)
d207 1
a207 1
    if (!aNode || !head)
d209 2
a210 2
    if (aNode == head)
      return Pop ();
d212 5
a216 5
    ListNode *resultPrev = head;
    while (resultPrev && resultPrev->next && !(aNode == resultPrev->next))
      resultPrev = resultPrev->next;
    if (resultPrev)
      return (ListNode *)InterlockedExchangePointer (&resultPrev->next, resultPrev->next->next);
d220 1
a220 1
  ListNode *Pop ()
d222 1
a222 1
    return (ListNode *) InterlockedExchangePointer (&head, head->next);
d226 1
a226 1
  void forEach (void (ListNode::*callback) ())
d228 2
a229 2
    ListNode *aNode = head;
    while (aNode)
d231 2
a232 2
        (aNode->*callback) ();
        aNode = aNode->next;
d237 1
a237 1
  ListNode *head;
d243 2
a244 2
  static bool isGoodObject (pthread_key_t const *);
  DWORD dwTlsIndex;
d253 1
a253 1
    keys.forEach (&pthread_key::saveKeyToBuffer);
d258 1
a258 1
    keys.forEach (&pthread_key::recreateKeyFromBuffer);
d261 1
a261 1
  static void runAllDestructors ()
d263 1
a263 1
    keys.forEach (&pthread_key::runDestructor);
d270 2
a271 2
  void saveKeyToBuffer ();
  void recreateKeyFromBuffer ();
d273 1
a273 1
  void runDestructor ();
d280 1
a280 1
  static bool isGoodObject(pthread_attr_t const *);
d294 1
a294 1
  static bool isGoodObject(pthread_mutexattr_t const *);
d304 6
a309 6
  static bool isGoodObject (pthread_mutex_t const *);
  static bool isGoodInitializer (pthread_mutex_t const *);
  static bool isGoodInitializerOrObject (pthread_mutex_t const *);
  static bool isGoodInitializerOrBadObject (pthread_mutex_t const *mutex);
  static bool canBeUnlocked (pthread_mutex_t const *mutex);
  static void initMutex ();
d320 1
a320 1
  pthread_t GetPthreadSelf () const
d326 1
a326 1
  int Lock ()
d328 1
a328 1
    return _Lock (GetPthreadSelf ());
d330 1
a330 1
  int TryLock ()
d332 1
a332 1
    return _TryLock (GetPthreadSelf ());
d334 1
a334 1
  int UnLock ()
d336 1
a336 1
    return _UnLock (GetPthreadSelf ());
d338 1
a338 1
  int Destroy ()
d340 1
a340 1
    return _Destroy (GetPthreadSelf ());
d343 1
a343 1
  void SetOwner (pthread_t self)
d349 1
a349 1
  int LockRecursive ()
d364 1
a364 1
    mutexes.forEach (&pthread_mutex::FixupAfterFork);
d367 5
a371 1
  void FixupAfterFork ();
d373 1
a373 5
private:
  int _Lock (pthread_t self);
  int _TryLock (pthread_t self);
  int _UnLock (pthread_t self);
  int _Destroy (pthread_t self);
d376 1
a376 1
  static nativeMutex mutexInitializationLock;
d404 2
a405 2
  static void initMainThread (bool);
  static bool isGoodObject(pthread_t const *);
d449 3
a451 3
  void setThreadIdtoCurrent ();
  static void setTlsSelfPointer (pthread *);
  static pthread *getTlsSelfPointer ();
d453 2
a454 2
  DWORD getThreadId ();
  void initCurrentThread ();
d457 1
a457 1
class pthreadNull : public pthread
d460 2
a461 2
  static pthread *getNullpthread();
  ~pthreadNull();
d477 2
a478 2
  pthreadNull ();
  static pthreadNull _instance;
d484 1
a484 1
  static bool isGoodObject(pthread_condattr_t const *);
d494 5
a498 5
  static bool isGoodObject (pthread_cond_t const *);
  static bool isGoodInitializer (pthread_cond_t const *);
  static bool isGoodInitializerOrObject (pthread_cond_t const *);
  static bool isGoodInitializerOrBadObject (pthread_cond_t const *);
  static void initMutex ();
d505 1
a505 1
  HANDLE semWait;
d507 2
a508 2
  pthread_mutex mtxIn;
  pthread_mutex mtxOut;
d510 1
a510 1
  pthread_mutex_t mtxCond;
d512 2
a513 2
  void UnBlock (const bool all);
  int Wait (pthread_mutex_t mutex, DWORD dwMilliseconds = INFINITE);
d521 1
a521 1
    conds.forEach (&pthread_cond::FixupAfterFork);
d524 2
a525 1
  void FixupAfterFork ();
a526 1
private:
d528 1
a528 1
  static nativeMutex condInitializationLock;
d534 1
a534 1
  static bool isGoodObject(pthread_rwlockattr_t const *);
d544 5
a548 5
  static bool isGoodObject (pthread_rwlock_t const *);
  static bool isGoodInitializer (pthread_rwlock_t const *);
  static bool isGoodInitializerOrObject (pthread_rwlock_t const *);
  static bool isGoodInitializerOrBadObject (pthread_rwlock_t const *);
  static void initMutex ();
d553 2
a554 2
  unsigned long waitingReaders;
  unsigned long waitingWriters;
d562 2
a563 2
  int RdLock ();
  int TryRdLock ();
d565 2
a566 2
  int WrLock ();
  int TryWrLock ();
d568 1
a568 1
  int UnLock ();
d571 2
a572 2
  pthread_cond condReaders;
  pthread_cond condWriters;
d580 1
a580 1
    rwlocks.forEach (&pthread_rwlock::FixupAfterFork);
a582 2
  void FixupAfterFork ();

d586 3
a588 3
  void addReader (struct RWLOCK_READER *rd);
  void removeReader (struct RWLOCK_READER *rd);
  struct RWLOCK_READER *lookupReader (pthread_t thread);
d590 2
a591 2
  static void RdLockCleanup (void *arg);
  static void WrLockCleanup (void *arg);
d593 3
a595 1
  static nativeMutex rwlockInitializationLock;
d609 1
a609 1
  static bool isGoodObject(sem_t const *);
a619 3
  void Wait ();
  void Post ();
  int TryWait ();
d627 1
a627 1
    semaphores.forEach (&semaphore::FixupAfterFork);
d630 6
a635 1
  void FixupAfterFork ();
a636 1
private:
@


1.64
log
@
* pthread.cc (pthread_attr_init): Remove
(pthread_attr_destroy): Ditto.
(pthread_attr_setdetachstate): Ditto.
(pthread_attr_getdetachstate): Ditto.
(pthread_attr_setstacksize): Ditto.
(pthread_attr_getstacksize): Ditto.
(pthread_attr_setinheritsched): Ditto.
(pthread_attr_getinheritsched): Ditto.
(pthread_attr_setschedparam): Ditto.
(pthread_attr_getschedparam): Ditto.
(pthread_attr_setschedpolicy): Ditto.
(pthread_attr_getschedpolicy): Ditto.
(pthread_attr_setscope): Ditto.
(pthread_attr_getscope): Ditto.
(pthread_attr_setstackaddr): Ditto.
(pthread_attr_getstackaddr): Ditto.
(pthread_key_create): Ditto.
(pthread_key_delete): Ditto.
(pthread_setspecific): Ditto.
(pthread_getspecific): Ditto.
(pthread_kill): Ditto.
(pthread_sigmask): Ditto.
(pthread_equal): Ditto.
(pthread_mutex_lock): Ditto.
(pthread_mutex_trylock): Ditto.
(pthread_mutex_unlock): Ditto.
(pthread_mutex_destroy): Ditto.
(pthread_mutex_setprioceiling): Ditto.
(pthread_mutex_getprioceiling): Ditto.
(pthread_mutexattr_destroy): Ditto.
(pthread_mutexattr_getprioceiling): Ditto.
(pthread_mutexattr_getprotocol): Ditto.
(pthread_mutexattr_getpshared): Ditto.
(pthread_mutexattr_gettype): Ditto.
(pthread_mutexattr_init): Ditto.
(pthread_mutexattr_setprioceiling): Ditto.
(pthread_mutexattr_setprotocol): Ditto.
(pthread_mutexattr_setpshared): Ditto.
(pthread_mutexattr_settype): Ditto.
(pthread_cond_destroy): Ditto.
(pthread_cond_signal): Ditto.
(pthread_cond_broadcast): Ditto.
(pthread_condattr_init): Ditto.
(pthread_condattr_destroy): Ditto.
(pthread_condattr_getpshared): Ditto.
(pthread_condattr_setpshared): Ditto.
(pthread_rwlock_destroy): Ditto.
(pthread_rwlock_rdlock): Ditto.
(pthread_rwlock_tryrdlock): Ditto.
(pthread_rwlock_wrlock): Ditto.
(pthread_rwlock_trywrlock): Ditto.
(pthread_rwlock_unlock): Ditto.
(pthread_rwlockattr_init): Ditto.
(pthread_rwlockattr_getpshared): Ditto.
(pthread_rwlockattr_setpshared): Ditto.
(pthread_rwlockattr_destroy): Ditto.
(pthread_getconcurrency): Ditto.
(pthread_setconcurrency): Ditto.
(pthread_getschedparam): Ditto.
(pthread_setschedparam): Ditto.

* thread.h (__pthread_attr_init): Remove prototype.
(__pthread_attr_destroy): Ditto.
(__pthread_attr_setdetachstate): Ditto.
(__pthread_attr_getdetachstate): Ditto.
(__pthread_attr_setstacksize): Ditto.
(__pthread_attr_getstacksize): Ditto.
(__pthread_attr_setinheritsched): Ditto.
(__pthread_attr_getinheritsched): Ditto.
(__pthread_attr_setschedparam): Ditto.
(__pthread_attr_getschedparam): Ditto.
(__pthread_attr_setschedpolicy): Ditto.
(__pthread_attr_getschedpolicy): Ditto.
(__pthread_attr_setscope): Ditto.
(__pthread_attr_getscope): Ditto.
(__pthread_attr_setstackaddr): Ditto.
(__pthread_attr_getstackaddr): Ditto.
(__pthread_key_create): Ditto.
(__pthread_key_delete): Ditto.
(__pthread_setspecific): Ditto.
(__pthread_getspecific): Ditto.
(__pthread_kill): Ditto.
(__pthread_sigmask): Ditto.
(__pthread_equal): Ditto.
(__pthread_mutex_lock): Ditto.
(__pthread_mutex_trylock): Ditto.
(__pthread_mutex_unlock): Ditto.
(__pthread_mutex_destroy): Ditto.
(__pthread_mutex_setprioceiling): Ditto.
(__pthread_mutex_getprioceiling): Ditto.
(__pthread_mutexattr_destroy): Ditto.
(__pthread_mutexattr_getprioceiling): Ditto.
(__pthread_mutexattr_getprotocol): Ditto.
(__pthread_mutexattr_getpshared): Ditto.
(__pthread_mutexattr_gettype): Ditto.
(__pthread_mutexattr_init): Ditto.
(__pthread_mutexattr_setprioceiling): Ditto.
(__pthread_mutexattr_setprotocol): Ditto.
(__pthread_mutexattr_setpshared): Ditto.
(__pthread_mutexattr_settype): Ditto.
(__pthread_cond_destroy): Ditto.
(__pthread_cond_signal): Ditto.
(__pthread_cond_broadcast): Ditto.
(__pthread_condattr_init): Ditto.
(__pthread_condattr_destroy): Ditto.
(__pthread_condattr_getpshared): Ditto.
(__pthread_condattr_setpshared): Ditto.
(__pthread_rwlock_destroy): Ditto.
(__pthread_rwlock_rdlock): Ditto.
(__pthread_rwlock_tryrdlock): Ditto.
(__pthread_rwlock_wrlock): Ditto.
(__pthread_rwlock_trywrlock): Ditto.
(__pthread_rwlock_unlock): Ditto.
(__pthread_rwlockattr_init): Ditto.
(__pthread_rwlockattr_getpshared): Ditto.
(__pthread_rwlockattr_setpshared): Ditto.
(__pthread_rwlockattr_destroy): Ditto.
(__pthread_getconcurrency): Ditto.
(__pthread_setconcurrency): Ditto.
(__pthread_getschedparam): Ditto.
(__pthread_setschedparam): Ditto.

* thread.cc: Rename __pthread_equal to pthread_equal throughout.
Change pthread_self parameter appropriate.
(__pthread_attr_init): Remove __ prefix. Change to extern "C".
(__pthread_attr_destroy): Ditto.
(__pthread_attr_setdetachstate): Ditto.
(__pthread_attr_getdetachstate): Ditto.
(__pthread_attr_setstacksize): Ditto.
(__pthread_attr_getstacksize): Ditto.
(__pthread_attr_setinheritsched): Ditto.
(__pthread_attr_getinheritsched): Ditto.
(__pthread_attr_setschedparam): Ditto.
(__pthread_attr_getschedparam): Ditto.
(__pthread_attr_setschedpolicy): Ditto.
(__pthread_attr_getschedpolicy): Ditto.
(__pthread_attr_setscope): Ditto.
(__pthread_attr_getscope): Ditto.
(__pthread_attr_setstackaddr): Ditto.
(__pthread_attr_getstackaddr): Ditto.
(__pthread_key_create): Ditto.
(__pthread_key_delete): Ditto.
(__pthread_setspecific): Ditto.
(__pthread_getspecific): Ditto.
(__pthread_kill): Ditto.
(__pthread_sigmask): Ditto.
(__pthread_equal): Ditto.
(__pthread_mutex_lock): Ditto.
(__pthread_mutex_trylock): Ditto.
(__pthread_mutex_unlock): Ditto.
(__pthread_mutex_destroy): Ditto.
(__pthread_mutex_setprioceiling): Ditto.
(__pthread_mutex_getprioceiling): Ditto.
(__pthread_mutexattr_destroy): Ditto.
(__pthread_mutexattr_getprioceiling): Ditto.
(__pthread_mutexattr_getprotocol): Ditto.
(__pthread_mutexattr_getpshared): Ditto.
(__pthread_mutexattr_gettype): Ditto.
(__pthread_mutexattr_init): Ditto.
(__pthread_mutexattr_setprioceiling): Ditto.
(__pthread_mutexattr_setprotocol): Ditto.
(__pthread_mutexattr_setpshared): Ditto.
(__pthread_mutexattr_settype): Ditto.
(__pthread_cond_destroy): Ditto.
(__pthread_cond_signal): Ditto.
(__pthread_cond_broadcast): Ditto.
(__pthread_condattr_init): Ditto.
(__pthread_condattr_destroy): Ditto.
(__pthread_condattr_getpshared): Ditto.
(__pthread_condattr_setpshared): Ditto.
(__pthread_rwlock_destroy): Ditto.
(__pthread_rwlock_rdlock): Ditto.
(__pthread_rwlock_tryrdlock): Ditto.
(__pthread_rwlock_wrlock): Ditto.
(__pthread_rwlock_trywrlock): Ditto.
(__pthread_rwlock_unlock): Ditto.
(__pthread_rwlockattr_init): Ditto.
(__pthread_rwlockattr_getpshared): Ditto.
(__pthread_rwlockattr_setpshared): Ditto.
(__pthread_rwlockattr_destroy): Ditto.
(__pthread_getconcurrency): Ditto.
(__pthread_setconcurrency): Ditto.
(__pthread_getschedparam): Ditto.
(__pthread_setschedparam): Ditto.
@
text
@a191 1
/* interface */
d194 42
a235 5
  List();
  void Insert (ListNode *aNode);
  ListNode *Remove ( ListNode *aNode);
  ListNode *Pop ();
  void forEach (void (*)(ListNode *aNode));
a243 2
  static void runAllDestructors ();

d251 14
a264 2
  static void fixup_before_fork();
  static void fixup_after_fork();
a268 1
  // lists of objects. USE THREADSAFE INSERTS AND DELETES.
a269 3
  static void saveAKey (pthread_key *);
  static void restoreAKey (pthread_key *);
  static void destroyAKey (pthread_key *);
d273 1
a273 1
  void run_destructor ();
a276 45
/* implementation */
template <class ListNode>
List<ListNode>::List<ListNode> () : head(NULL)
{
}
template <class ListNode> void
List<ListNode>::Insert (ListNode *aNode)
{
  if (!aNode)
  return;
  aNode->next = (ListNode *) InterlockedExchangePointer (&head, aNode);
}
template <class ListNode> ListNode *
List<ListNode>::Remove ( ListNode *aNode)
{
  if (!aNode)
  return NULL;
  if (!head)
  return NULL;
  if (aNode == head)
  return Pop ();
  ListNode *resultPrev = head;
  while (resultPrev && resultPrev->next && !(aNode == resultPrev->next))
  resultPrev = resultPrev->next;
  if (resultPrev)
  return (ListNode *)InterlockedExchangePointer (&resultPrev->next, resultPrev->next->next);
  return NULL;
}
template <class ListNode> ListNode *
List<ListNode>::Pop ()
{
  return (ListNode *) InterlockedExchangePointer (&head, head->next);
}
/* poor mans generic programming. */
template <class ListNode> void
List<ListNode>::forEach (void (*callback)(ListNode *))
{
  ListNode *aNode = head;
  while (aNode)
  {
    callback (aNode);
    aNode = aNode->next;
  }
}

a318 1
  class pthread_mutex * next;
a356 2
  void fixup_after_fork ();

d361 8
d375 1
a511 2
  class pthread_cond * next;

a513 1
  void fixup_after_fork ();
d518 8
d527 1
d574 3
d578 4
d583 1
a583 1
  void fixup_after_fork ();
d585 2
a586 2
  pthread_rwlock (pthread_rwlockattr *);
  ~pthread_rwlock ();
a587 1
private:
a617 1
  class semaphore * next;
a622 1
  void fixup_after_fork ();
d626 11
a660 6
  // lists of pthread objects. USE THREADSAFE INSERTS AND DELETES.
  class pthread_mutex * mutexs;
  class pthread_cond  * conds;
  class pthread_rwlock * rwlocks;
  class semaphore     * semaphores;

a670 1
    mutexs (NULL), conds (NULL), rwlocks (NULL), semaphores (NULL),
@


1.63
log
@
* cygwin.din: Add pthread_rwlock_destroy, pthread_rwlock_init,
pthread_rwlock_rdlock, pthread_rwlock_tryrdlock,
pthread_rwlock_wrlock, pthread_rwlock_trywrlock,
pthread_rwlock_unlock, pthread_rwlockattr_init,
pthread_rwlockattr_getpshared, pthread_rwlockattr_setpshared,
and pthread_rwlockattr_destroy.
* include/cygwin/version.h: Bump API minor number.
* include/pthread.h (PTHREAD_RWLOCK_INITIALIZER): Define a
reasonable value.
Add prototypes for pthread_rwlock_destroy, pthread_rwlock_init,
pthread_rwlock_rdlock, pthread_rwlock_tryrdlock,
pthread_rwlock_wrlock, pthread_rwlock_trywrlock,
pthread_rwlock_unlock, pthread_rwlockattr_init,
pthread_rwlockattr_getpshared, pthread_rwlockattr_setpshared,
and pthread_rwlockattr_destroy.
* thread.h (PTHREAD_ONCE_MAGIC): Remove superflous semicolon.
(PTHREAD_RWLOCK_MAGIC): New define.
(PTHREAD_RWLOCKATTR_MAGIC): Ditto.
(pthread_rwlockattr): New class.
(pthread_rwlock): Ditto.
(MTinterface::rwlocks): New member.
(MTinterface::MTinterface): Initialize rwlocks.
Add prototypes for __pthread_rwlock_destroy,
__pthread_rwlock_wrlock, __pthread_rwlock_trywrlock,
__pthread_rwlock_unlock, __pthread_rwlockattr_init,
__pthread_rwlockattr_getpshared, __pthread_rwlockattr_setpshared,
and __pthread_rwlockattr_destroy.
* thread.cc (MTinterface::Init): Initialize rwlock internal mutex.
(MTinterface::fixup_after_fork): Fixup rwlocks after fork.
(pthread_rwlockattr::isGoodObject): Implement.
(pthread_rwlockattr::pthread_rwlockattr): Ditto.
(pthread_rwlockattr::~pthread_rwlockattr): Ditto.
(pthread_rwlock::initMutex): Ditto.
(pthread_rwlock::pthread_rwlock): Ditto.
(pthread_rwlock::~pthread_rwlock): Ditto.
(pthread_rwlock::RdLock): Ditto.
(pthread_rwlock::TryRdLock): Ditto.
(pthread_rwlock::WrLock): Ditto.
(pthread_rwlock::TryWrLock): Ditto.
(pthread_rwlock::UnLock): Ditto.
(pthread_rwlock::addReader): Ditto.
(pthread_rwlock::removeReader): Ditto.
(pthread_rwlock::lookupReader): Ditto.
(pthread_rwlock::RdLockCleanup): Ditto.
(pthread_rwlock::WrLockCleanup): Ditto.
(pthread_rwlock::fixup_after_fork): Ditto.
(pthread_rwlock::isGoodObject): Ditto.
(pthread_rwlock::isGoodInitializer): Ditto.
(pthread_rwlock::isGoodInitializerOrObject): Ditto.
(pthread_rwlock::isGoodInitializerOrBadObject): Ditto.
(__pthread_rwlock_destroy): Ditto.
(pthread_rwlock::init): Ditto.
(__pthread_rwlock_rdlock): Ditto.
(__pthread_rwlock_tryrdlock): Ditto.
(__pthread_rwlock_wrlock): Ditto.
(__pthread_rwlock_trywrlock): Ditto.
@
text
@a660 91
extern "C"
{
int __pthread_attr_init (pthread_attr_t * attr);
int __pthread_attr_destroy (pthread_attr_t * attr);
int __pthread_attr_setdetachstate (pthread_attr_t *, int);
int __pthread_attr_getdetachstate (const pthread_attr_t *, int *);
int __pthread_attr_setstacksize (pthread_attr_t * attr, size_t size);
int __pthread_attr_getstacksize (const pthread_attr_t * attr, size_t * size);

int __pthread_attr_getinheritsched (const pthread_attr_t *, int *);
int __pthread_attr_getschedparam (const pthread_attr_t *,
				  struct sched_param *);
int __pthread_attr_getschedpolicy (const pthread_attr_t *, int *);
int __pthread_attr_getscope (const pthread_attr_t *, int *);
int __pthread_attr_getstackaddr (const pthread_attr_t *, void **);
int __pthread_attr_setinheritsched (pthread_attr_t *, int);
int __pthread_attr_setschedparam (pthread_attr_t *,
				  const struct sched_param *);
int __pthread_attr_setschedpolicy (pthread_attr_t *, int);
int __pthread_attr_setscope (pthread_attr_t *, int);
int __pthread_attr_setstackaddr (pthread_attr_t *, void *);

/* Thread SpecificData */
int __pthread_key_create (pthread_key_t * key, void (*destructor) (void *));
int __pthread_key_delete (pthread_key_t key);
int __pthread_setspecific (pthread_key_t key, const void *value);
void *__pthread_getspecific (pthread_key_t key);

/* Thead synchroniation */
int __pthread_cond_destroy (pthread_cond_t * cond);
int __pthread_cond_signal (pthread_cond_t * cond);
int __pthread_cond_broadcast (pthread_cond_t * cond);
int __pthread_condattr_init (pthread_condattr_t * condattr);
int __pthread_condattr_destroy (pthread_condattr_t * condattr);
int __pthread_condattr_getpshared (const pthread_condattr_t * attr,
				   int *pshared);
int __pthread_condattr_setpshared (pthread_condattr_t * attr, int pshared);

/* RW locks */
int __pthread_rwlock_destroy (pthread_rwlock_t *rwlock);
int __pthread_rwlock_rdlock (pthread_rwlock_t *rwlock);
int __pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock);
int __pthread_rwlock_wrlock (pthread_rwlock_t *rwlock);
int __pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock);
int __pthread_rwlock_unlock (pthread_rwlock_t *rwlock);
int __pthread_rwlockattr_init (pthread_rwlockattr_t *rwlockattr);
int __pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr,
                                     int *pshared);
int __pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared);
int __pthread_rwlockattr_destroy (pthread_rwlockattr_t *rwlockattr);

/* Thread signal */
int __pthread_kill (pthread_t thread, int sig);
int __pthread_sigmask (int operation, const sigset_t * set,
		       sigset_t * old_set);

/*  ID */
int __pthread_equal (pthread_t * t1, pthread_t * t2);

/* Mutexes  */
int __pthread_mutex_lock (pthread_mutex_t *);
int __pthread_mutex_trylock (pthread_mutex_t *);
int __pthread_mutex_unlock (pthread_mutex_t *);
int __pthread_mutex_destroy (pthread_mutex_t *);
int __pthread_mutex_setprioceiling (pthread_mutex_t * mutex,
				    int prioceiling, int *old_ceiling);
int __pthread_mutex_getprioceiling (const pthread_mutex_t * mutex,
				    int *prioceiling);


int __pthread_mutexattr_destroy (pthread_mutexattr_t *);
int __pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *, int *);
int __pthread_mutexattr_getprotocol (const pthread_mutexattr_t *, int *);
int __pthread_mutexattr_getpshared (const pthread_mutexattr_t *, int *);
int __pthread_mutexattr_gettype (const pthread_mutexattr_t *, int *);
int __pthread_mutexattr_init (pthread_mutexattr_t *);
int __pthread_mutexattr_setprioceiling (pthread_mutexattr_t *, int);
int __pthread_mutexattr_setprotocol (pthread_mutexattr_t *, int);
int __pthread_mutexattr_setpshared (pthread_mutexattr_t *, int);
int __pthread_mutexattr_settype (pthread_mutexattr_t *, int);


/* Scheduling */
int __pthread_getconcurrency (void);
int __pthread_setconcurrency (int new_level);
int __pthread_getschedparam (pthread_t thread, int *policy,
			     struct sched_param *param);
int __pthread_setschedparam (pthread_t thread, int policy,
			     const struct sched_param *param);

};
@


1.62
log
@
* thread.h (pthread_cond::ExitingWait): Remove.
(pthread_cond::mutex): Ditto.
(pthread_cond::cond_access): Ditto.
(pthread_cond::win32_obj_id): Ditto.
(pthread_cond::TimedWait): Ditto.
(pthread_cond::BroadCast): Ditto.
(pthread_cond::Signal): Ditto.
(pthread_cond::waiting): Change type to unsigned long.
(pthread_cond::pending): New member.
(pthread_cond::semWait): Ditto.
(pthread_cond::mtxIn): Ditto.
(pthread_cond::mtxOut): Ditto.
(pthread_cond::mtxCond): Ditto.
(pthread_cond::UnBlock): New method.
(pthread_cond::Wait): Ditto.
* thread.cc: Update list of cancellation points.
(pthread_cond::pthread_cond): Rewrite.
(pthread_cond::~pthread_cond): Ditto.
(pthread_cond::TimedWait): Remove.
(pthread_cond::BroadCast): Ditto.
(pthread_cond::Signal): Ditto.
(pthread_cond::UnBlock): Implement.
(pthread_cond::Wait): Ditto.
(pthread_cond::fixup_after_fork): Rewrite.
(pthread_mutex::fixup_after_fork): Remove DETECT_BAD_APP
conditional.
(__pthread_cond_broadcast): Just return 0 if the condition is
not initialized. Call pthread_cond::UnBlock to release blocked
threads.
(__pthread_cond_signal): Ditto.
(__pthread_cond__dowait): Rewrite.
(pthread_cond_timedwait): Add pthread_testcancel call. Fix
waitlength calculation.
(pthread_cond_wait): Add pthread_testcancel call.
@
text
@d166 2
d522 61
d640 1
d653 1
a653 1
    mutexs (NULL), conds (NULL), semaphores (NULL),
d698 13
@


1.61
log
@

* include/pthread.h (PTHREAD_MUTEX_NORMAL): New define.
* thread.cc: Remove errno.h include.
(pthread::precreate): Change internal mutex type to normal.
(pthread_mutex::canBeUnlocked): Implement.
(pthread_mutex::pthread_mutex): Initialize lock_counter with 0.
(pthread_mutex::Lock): Rename to _Lock. Add self parameter.
Change lock_counter logic. Update SetOwner call.
(pthread_mutex::TryLock): Rename to _TryLock. Add self parameter.
Change lock_counter logic. Update SetOwner call.
(pthread_mutex::UnLock): Rename to _UnLock. Add self parameter.
Change lock_counter logic.
(pthread_mutex::Destroy): Rename to _Destroy. Update TryLock call.
(pthread_mutex::SetOwner): Move to thread.h as inline.
(pthread_mutex::LockRecursive): Ditto.
(pthread_mutex::fixup_after_fork): Change lock_counter logic.
(__pthread_mutexattr_settype): Add PTHREAD_MUTEX_NORMAL to valid
types check.
* thread.h: Include errno.h and limits.h.
(MUTEX_LOCK_COUNTER_INITIAL): Remove.
(MUTEX_OWNER_ANONYMOUS): New define.
(pthread_mutex::canBeUnlocked): New static method.
(pthread_mutex::lock_counter): Change type to unsigned long.
(pthread_mutex::GetPthreadSelf): New method.
(pthread_mutex::Lock): Call _Lock with pthread_self pointer.
(pthread_mutex::TryLock): Call _TryLock with pthread_self pointer.
(pthread_mutex::UnLock): Call _UnLock with pthread_self pointer.
(pthread_mutex::Destroy): Call _Destroy with pthread_self pointer.
(pthread_mutex::SetOwner): Moved from thread.cc as inline.
(pthread_mutex::LockRecursive): Ditto.
(pthread_mutex::_Lock): New method.
(pthread_mutex::_TryLock): New method.
(pthread_mutex::_UnLock): New method.
(pthread_mutex::_Destroy): New method.
@
text
@d497 10
a506 6
  LONG waiting;
  LONG ExitingWait;
  pthread_mutex *mutex;
  /* to allow atomic behaviour for cond_broadcast */
  pthread_mutex_t cond_access;
  HANDLE win32_obj_id;
d508 3
a510 3
  int TimedWait (DWORD dwMilliseconds);
  void BroadCast ();
  void Signal ();
@


1.60
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d42 2
d165 1
a165 1
#define PTHREAD_ONCE_MAGIC PTHREAD_MAGIC+8;
d167 1
a167 1
#define MUTEX_LOCK_COUNTER_INITIAL   (-1)
d309 1
d313 1
a313 1
  LONG lock_counter;
d322 37
a358 6
  int Lock ();
  int TryLock ();
  int UnLock ();
  int Destroy ();
  void SetOwner ();
  int LockRecursive ();
d366 5
@


1.60.2.1
log
@merge from trunk
@
text
@a41 2
#include <limits.h>
#include <errno.h>
d163 1
a163 3
#define PTHREAD_ONCE_MAGIC PTHREAD_MAGIC+8
#define PTHREAD_RWLOCK_MAGIC PTHREAD_MAGIC+9
#define PTHREAD_RWLOCKATTR_MAGIC PTHREAD_MAGIC+10
d165 1
a165 1
#define MUTEX_OWNER_ANONYMOUS        ((pthread_t) -1)
a306 1
  static bool canBeUnlocked (pthread_mutex_t const *mutex);
d310 1
a310 1
  unsigned long lock_counter;
d319 6
a324 37
  pthread_t GetPthreadSelf () const
  {
    return PTHREAD_MUTEX_NORMAL == type ? MUTEX_OWNER_ANONYMOUS :
      ::pthread_self ();
  }

  int Lock ()
  {
    return _Lock (GetPthreadSelf ());
  }
  int TryLock ()
  {
    return _TryLock (GetPthreadSelf ());
  }
  int UnLock ()
  {
    return _UnLock (GetPthreadSelf ());
  }
  int Destroy ()
  {
    return _Destroy (GetPthreadSelf ());
  }

  void SetOwner (pthread_t self)
  {
    recursion_counter = 1;
    owner = self;
  }

  int LockRecursive ()
  {
    if (UINT_MAX == recursion_counter)
      return EAGAIN;
    ++recursion_counter;
    return 0;
  }

a331 5
  int _Lock (pthread_t self);
  int _TryLock (pthread_t self);
  int _UnLock (pthread_t self);
  int _Destroy (pthread_t self);

d458 6
a463 10

  unsigned long waiting;
  unsigned long pending;
  HANDLE semWait;

  pthread_mutex mtxIn;
  pthread_mutex mtxOut;

  pthread_mutex_t mtxCond;

d465 3
a467 3

  void UnBlock (const bool all);
  int Wait (pthread_mutex_t mutex, DWORD dwMilliseconds = INFINITE);
a476 61
class pthread_rwlockattr:public verifyable_object
{
public:
  static bool isGoodObject(pthread_rwlockattr_t const *);
  int shared;

  pthread_rwlockattr ();
  ~pthread_rwlockattr ();
};

class pthread_rwlock:public verifyable_object
{
public:
  static bool isGoodObject (pthread_rwlock_t const *);
  static bool isGoodInitializer (pthread_rwlock_t const *);
  static bool isGoodInitializerOrObject (pthread_rwlock_t const *);
  static bool isGoodInitializerOrBadObject (pthread_rwlock_t const *);
  static void initMutex ();
  static int init (pthread_rwlock_t *, const pthread_rwlockattr_t *);

  int shared;

  unsigned long waitingReaders;
  unsigned long waitingWriters;
  pthread_t writer;
  struct RWLOCK_READER
  {
    struct RWLOCK_READER *next;
    pthread_t thread;
  } *readers;

  int RdLock ();
  int TryRdLock ();

  int WrLock ();
  int TryWrLock ();

  int UnLock ();

  pthread_mutex mtx;
  pthread_cond condReaders;
  pthread_cond condWriters;

  class pthread_rwlock * next;

  void fixup_after_fork ();

  pthread_rwlock (pthread_rwlockattr *);
  ~pthread_rwlock ();

private:
  void addReader (struct RWLOCK_READER *rd);
  void removeReader (struct RWLOCK_READER *rd);
  struct RWLOCK_READER *lookupReader (pthread_t thread);

  static void RdLockCleanup (void *arg);
  static void WrLockCleanup (void *arg);

  static nativeMutex rwlockInitializationLock;
};

a533 1
  class pthread_rwlock * rwlocks;
d546 1
a546 1
    mutexs (NULL), conds (NULL), rwlocks (NULL), semaphores (NULL),
d554 78
@


1.60.2.2
log
@merge from trunk
@
text
@d126 1
a126 1
class native_mutex
d192 2
a193 1
template <class list_node> class List {
d195 5
a199 42
  List() : head(NULL)
  {
  }

  void insert (list_node *node)
  {
    if (!node)
      return;
    node->next = (list_node *) InterlockedExchangePointer (&head, node);
  }

  list_node *remove ( list_node *node)
  {
    if (!node || !head)
      return NULL;
    if (node == head)
      return pop ();

    list_node *result_prev = head;
    while (result_prev && result_prev->next && !(node == result_prev->next))
      result_prev = result_prev->next;
    if (result_prev)
      return (list_node *)InterlockedExchangePointer (&result_prev->next, result_prev->next->next);
    return NULL;
  }

  list_node *pop ()
  {
    return (list_node *) InterlockedExchangePointer (&head, head->next);
  }

  /* poor mans generic programming. */
  void for_each (void (list_node::*callback) ())
  {
    list_node *node = head;
    while (node)
      {
        (node->*callback) ();
        node = node->next;
      }
  }

d201 1
a201 1
  list_node *head;
d207 4
a210 2
  static bool is_good_object (pthread_key_t const *);
  DWORD tls_index;
d217 2
a218 14
  static void fixup_before_fork()
  {
    keys.for_each (&pthread_key::save_key_to_buffer);
  }

  static void fixup_after_fork()
  {
    keys.for_each (&pthread_key::recreate_key_from_buffer);
  }

  static void run_all_destructors ()
  {
    keys.for_each (&pthread_key::run_destructor);
  }
d223 1
d225 5
a229 2
  void save_key_to_buffer ();
  void recreate_key_from_buffer ();
d235 45
d283 1
a283 1
  static bool is_good_object(pthread_attr_t const *);
d297 1
a297 1
  static bool is_good_object(pthread_mutexattr_t const *);
d307 6
a312 6
  static bool is_good_object (pthread_mutex_t const *);
  static bool is_good_initializer (pthread_mutex_t const *);
  static bool is_good_initializer_or_object (pthread_mutex_t const *);
  static bool is_good_initializer_or_bad_object (pthread_mutex_t const *mutex);
  static bool can_be_unlocked (pthread_mutex_t const *mutex);
  static void init_mutex ();
d322 1
d324 1
a324 1
  pthread_t get_pthread_self () const
d330 1
a330 1
  int lock ()
d332 1
a332 1
    return _lock (get_pthread_self ());
d334 1
a334 1
  int trylock ()
d336 1
a336 1
    return _trylock (get_pthread_self ());
d338 1
a338 1
  int unlock ()
d340 1
a340 1
    return _unlock (get_pthread_self ());
d342 1
a342 1
  int destroy ()
d344 1
a344 1
    return _destroy (get_pthread_self ());
d347 1
a347 1
  void set_owner (pthread_t self)
d353 1
a353 1
  int lock_recursive ()
d361 2
a366 6
  class pthread_mutex * next;
  static void fixup_after_fork ()
  {
    mutexes.for_each (&pthread_mutex::_fixup_after_fork);
  }

d368 4
a371 6
  int _lock (pthread_t self);
  int _trylock (pthread_t self);
  int _unlock (pthread_t self);
  int _destroy (pthread_t self);

  void _fixup_after_fork ();
d373 1
a373 2
  static List<pthread_mutex> mutexes;
  static native_mutex mutex_initialization_lock;
d401 2
a402 2
  static void init_mainthread (bool);
  static bool is_good_object(pthread_t const *);
d446 3
a448 3
  void set_thread_id_to_current ();
  static void set_tls_self_pointer (pthread *);
  static pthread *get_tls_self_pointer ();
d450 2
a451 2
  DWORD get_thread_id ();
  void init_current_thread ();
d454 1
a454 1
class pthread_null : public pthread
d457 2
a458 2
  static pthread *get_null_pthread();
  ~pthread_null();
d474 2
a475 2
  pthread_null ();
  static pthread_null _instance;
d481 1
a481 1
  static bool is_good_object(pthread_condattr_t const *);
d491 5
a495 5
  static bool is_good_object (pthread_cond_t const *);
  static bool is_good_initializer (pthread_cond_t const *);
  static bool is_good_initializer_or_object (pthread_cond_t const *);
  static bool is_good_initializer_or_bad_object (pthread_cond_t const *);
  static void init_mutex ();
d502 1
a502 1
  HANDLE sem_wait;
d504 2
a505 2
  pthread_mutex mtx_in;
  pthread_mutex mtx_out;
d507 1
a507 1
  pthread_mutex_t mtx_cond;
d509 5
a513 2
  void unblock (const bool all);
  int wait (pthread_mutex_t mutex, DWORD dwMilliseconds = INFINITE);
a517 6
  class pthread_cond * next;
  static void fixup_after_fork ()
  {
    conds.for_each (&pthread_cond::_fixup_after_fork);
  }

d519 1
a519 4
  void _fixup_after_fork ();

  static List<pthread_cond> conds;
  static native_mutex cond_initialization_lock;
d525 1
a525 1
  static bool is_good_object(pthread_rwlockattr_t const *);
d535 5
a539 5
  static bool is_good_object (pthread_rwlock_t const *);
  static bool is_good_initializer (pthread_rwlock_t const *);
  static bool is_good_initializer_or_object (pthread_rwlock_t const *);
  static bool is_good_initializer_or_bad_object (pthread_rwlock_t const *);
  static void init_mutex ();
d544 2
a545 2
  unsigned long waiting_readers;
  unsigned long waiting_writers;
d553 2
a554 2
  int rdlock ();
  int tryrdlock ();
d556 2
a557 2
  int wrlock ();
  int trywrlock ();
d559 1
a559 1
  int unlock ();
d562 6
a567 2
  pthread_cond cond_readers;
  pthread_cond cond_writers;
a571 6
  class pthread_rwlock * next;
  static void fixup_after_fork ()
  {
    rwlocks.for_each (&pthread_rwlock::_fixup_after_fork);
  }

d573 3
a575 5
  static List<pthread_rwlock> rwlocks;

  void add_reader (struct RWLOCK_READER *rd);
  void remove_reader (struct RWLOCK_READER *rd);
  struct RWLOCK_READER *lookup_reader (pthread_t thread);
d577 2
a578 2
  static void rdlock_cleanup (void *arg);
  static void wrlock_cleanup (void *arg);
d580 1
a580 3
  void _fixup_after_fork ();

  static native_mutex rwlock_initialization_lock;
d594 1
a594 1
  static bool is_good_object(sem_t const *);
d603 1
d606 4
a612 15

  class semaphore * next;
  static void fixup_after_fork ()
  {
    semaphores.for_each (&semaphore::_fixup_after_fork);
  }

private:
  void _wait ();
  void _post ();
  int _trywait ();

  void _fixup_after_fork ();

  static List<semaphore> semaphores;
d637 6
d653 1
@


1.60.2.3
log
@merge from trunk
@
text
@a440 5
  static int equal (pthread_t t1, pthread_t t2)
  {
    return t1 == t2;
  }

a588 12

  void release ()
  {
    if (waiting_writers)
      {
        if (!readers)
          cond_writers.unblock (false);
      }
    else if (waiting_readers)
      cond_readers.unblock (true);
  }

@


1.60.2.4
log
@merge from trunk
@
text
@d404 1
a404 1
  static void init_mainthread ();
d682 1
a682 1
  void Init ();
@


1.60.2.5
log
@merge from trunk
@
text
@d113 1
a388 1
  bool running;
d393 1
a445 7
  /* List support calls */
  class pthread *next;
  static void fixup_after_fork ()
  {
    threads.for_each (&pthread::_fixup_after_fork);
  }

a446 1
  static List<pthread> threads;
a449 2

  void _fixup_after_fork ();
@


1.59
log
@Apply pthread_cancel_patch
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.58
log
@Applied pthread_mutex patch
@
text
@d335 2
d383 2
@


1.57
log
@Applied cond_init patch
@
text
@d165 2
d310 1
a310 1
  CRITICAL_SECTION criticalsection;
d312 1
d314 2
d322 3
@


1.56
log
@whitespace
@
text
@d124 10
d301 3
a303 3
  static bool isGoodObject(pthread_mutex_t const *);
  static bool isGoodInitializer(pthread_mutex_t const *);
  static bool isGoodInitializerOrObject(pthread_mutex_t const *);
d322 1
a323 8
  class nativeMutex {
    public:
      bool init();
      bool lock();
      void unlock();
    private:
      HANDLE theHandle;
  };
d438 7
a444 3
  static bool isGoodObject(pthread_cond_t const *);
  static bool isGoodInitializer(pthread_cond_t const *);
  static bool isGoodInitializerOrObject(pthread_cond_t const *);
d460 3
a571 2
int __pthread_cond_init (pthread_cond_t * cond,
			 const pthread_condattr_t * attr);
@


1.55
log
@2002-11-05  Thomas Pfaff  <tpfaff@@gmx.net>

        * dcrt0.cc (dll_crt0_1): Add call to pthread::initMainThread to
        initialize mainthread when it is safe to call new.
        * init.cc (dll_entry): Change call to store reents in tls key.
        * thread.cc (_reent_clib) : Change call to get reents from tls
        key.
        (_reent_winsup): Ditto.
        (MTinterface::Init): Key handling changed. Remove initialization
        of member variables.
        (MTinterface::fixup_after_fork): Reinitialize mainthread object
        after fork. Reset threadount to 1.
        (pthread::initMainThread): Create mainthread object dynamically.
        and initialize with valid handles.
        (pthread::self): Remove calls to create thread objects.
        (pthread::setTlsSelfPointer): Change call to store thread self
        handle in tls key.
        (pthread::getTlsSelfPointer): New static method.
        (pthread::exit): Remove setTlsSelfPointer call.
        (pthread::initCurrentThread): New method.
        (pthread::thread_init_wrapper): Change call to store thread self
        handle in tls key.
        (pthread::join): Check for a valid joiner.
        (pthreadNull::pthreadNull): Mark Null object as detached.
        (pthreadNull::exit): Terminate thread via ExitThread.
        * thread.h (pthread::initMainThread): Change parameter in function
        call.
        (pthread::getTlsSelfPointer): New static method.
        (pthread::initCurrentThread): New method.
        (MTinterface::reent_key): Remove.
        (MTinterface::thread_self_dwTlsIndex): Ditto..
        (MTinterface::indexallocated): Ditto.
        (MTinterface::mainthread): Ditto.
        (MTinterface::reent_key): New member.
        (MTinterface::thread_self_key): Ditto.
        (MTinterface::MTinterface): Initialize all members.
@
text
@a529 1
 
@


1.54
log
@2002-10-17  Robert Collins  <rbtcollins@@hotmail.com>

        * thread.h (pthread_mutex::isGoodInitializerOrBadObject): Declare.
        * thread.cc (pthread_mutex::isGoodInitializerOrBadObject): Implement.
        (pthread_mutex::init): Use isGoodInitializerOrBadObject to avoid
        unneeded SEGV's during debugging.
@
text
@d347 1
a347 1
  static void initMainThread(pthread *, HANDLE);
d390 3
a392 2
  void setThreadIdtoCurrent();
  static void setTlsSelfPointer(pthread *);
d395 1
a497 4
  DWORD reent_index;
  DWORD thread_self_dwTlsIndex;
  /* we may get 0 for the Tls index.. grrr */
  int indexallocated;
a503 1
  pthread mainthread;
d514 3
d521 5
a525 1
  MTinterface ():reent_index (0), indexallocated (0), threadcount (1)
a526 3
    pthread_prepare = NULL;
    pthread_child   = NULL;
    pthread_parent  = NULL;
d529 3
@


1.53
log
@2002-09-30  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc (pthread_mutex::initMutex): Use the wrapper init call.
        (pthread_mutex::nativeMutex::init): Implement.
        (pthread_mutex::nativeMutex::lock): Ditto.
        (pthread_mutex::nativeMutex::unlock): Ditto.
        (pthread_mutex::init): Use the wrapper lock and unlockcalls.
        * thread.h (pthread_mutex): Move mutexInitializationLock into a
        nativeMutex wrapper class.
@
text
@d294 1
@


1.52
log
@* environ.cc (environ_init): Avoid a compiler warning.
* path.cc (path_conv::check): Ditto.
* path.h (path_conv::operator int): Ditto.
* regex/engine.c: Ditto throughout.
* regex/regcomp.c: Ditto throughout.
* regex/regexec.c: Ditto throughout.
@
text
@d312 9
a320 1
  static HANDLE mutexInitializationLock;
@


1.51
log
@2002-09-30  Robert Collins <rbtcollins@@hotmail.com>

        * pthread.cc (pthread_mutex_init): Use new pthread_mutex::init.
        * thread.cc: Change __pthread_mutex_init to pthread_mutex::init
        throughout.
        (MTinterface::Init): Initialise pthread_mutex support.
        (pthread_mutex::mutexInitializationLock): Instantiate.
        (pthread_mutex::initMutex): New method.
        (__pthread_cond_dowait): Don't dereference untrusted pointers.
        Use the new pthread_mutex::init method.
        (__pthread_condattr_init): Don't dereference untrusted pointers.
        (__pthread_mutex_init): Rename to pthread_mutex::init.
        Lock and release mutexInitializationLock to prevent races on
        mutex initialisation.
        * thread.h (pthread_mutex::initMutex): New method, initialise
        pthread_mutex supporting state on process initialisation.
        (pthread_mutex::init): Initialise a single mutex.
        (pthread_mutex::mutexInitializationLock): A win32 mutex for
        syncronising pthread mutex initialisation.
        (__pthread_mutex_init): Remove this.
@
text
@d257 1
a257 1
  while (aNode) 
d296 1
a296 1
  
d358 1
a358 1
  
d462 1
a462 1
  
@


1.50
log
@* cygthread.h (cygthread::terminate): Declare new function.
(cygthread::initialized): Change to 'int'.
* cygthread.cc (cygthread::stub): Exit thread if initialized < 0.
(cygthread::new): Ditto.
(cygthread::runner): Ditto.  Set initialized using xor to preserve sign.
(cygthread::terminate): New function.
* dcrt0.cc (do_exit): Call cygthread::terminate.
@
text
@d294 3
d311 2
a568 1
int __pthread_mutex_init (pthread_mutex_t *, const pthread_mutexattr_t *);
@


1.49
log
@2002-09-27  Robert Collins <rbtcollins@@hotmail.com>

       * thread.cc (pthread_key::run_destructor): Run_destructor is not
       const as it needs to set the key value.
       * thread.h (pthread_key::run_destructor): Ditto.

2002-09-27  Robert Collins <rbtcollins@@hotmail.com>

       * thread.cc (pthread_key::run_destructor): Follow opengroup algorithm.
       I.e. only run the destructor NON-NULL key values, and reset the key
       to NULL before running the destructor. Reported by Thomas Pfaff.
@
text
@d162 2
a163 2
    verifyable_object (long);
   ~verifyable_object ();
d200 1
a200 1
   ~pthread_key ();
d228 1
a228 1
    return;
d235 1
a235 1
    return NULL;
d237 1
a237 1
    return NULL;
d239 1
a239 1
    return Pop ();
d242 1
a242 1
    resultPrev = resultPrev->next;
d244 1
a244 1
    return (ListNode *)InterlockedExchangePointer (&resultPrev->next, resultPrev->next->next);
d258 4
a261 4
    {
      callback (aNode);
      aNode = aNode->next;
    }
d274 2
a275 2
    pthread_attr ();
   ~pthread_attr ();
d284 2
a285 2
    pthread_mutexattr ();
   ~pthread_mutexattr ();
d330 8
a337 2
   pthread ();
   virtual ~pthread ();
d339 5
a343 11
   static void initMainThread(pthread *, HANDLE);
   static bool isGoodObject(pthread_t const *);
   static void atforkprepare();
   static void atforkparent();
   static void atforkchild();

   /* API calls */
   static int cancel (pthread_t);
   static int join (pthread_t * thread, void **return_val);
   static int detach (pthread_t * thread);
   static int create (pthread_t * thread, const pthread_attr_t * attr,
d345 4
a348 4
   static int once (pthread_once_t *, void (*)(void));
   static int atfork(void (*)(void), void (*)(void), void (*)(void));
   static int suspend (pthread_t * thread);
   static int resume (pthread_t * thread);
d350 1
a350 1
   virtual void exit (void *value_ptr);
d352 4
a355 4
   virtual int cancel ();
   
   virtual void testcancel ();
   static void static_cancel_self ();
d357 2
a358 2
   virtual int setcancelstate (int state, int *oldstate);
   virtual int setcanceltype (int type, int *oldtype);
d360 2
a361 2
   virtual void push_cleanup_handler (__pthread_cleanup_handler *handler);
   virtual void pop_cleanup_handler (int const execute);
d363 2
a364 2
   static pthread* self ();
   static void *thread_init_wrapper (void *);
d366 1
a366 1
   virtual unsigned long getsequence_np();
d369 11
a379 11
    DWORD thread_id;
    __pthread_cleanup_handler *cleanup_stack;
    pthread_mutex mutex;

    void pop_all_cleanup_handlers (void);
    void precreate (pthread_attr *);
    void postcreate ();
    void setThreadIdtoCurrent();
    static void setTlsSelfPointer(pthread *);
    void cancel_self ();
    DWORD getThreadId ();
d385 2
a386 2
    static pthread *getNullpthread();
    ~pthreadNull();
d388 12
a399 12
    /* From pthread These should never get called
     * as the ojbect is not verifyable
     */
    void create (void *(*)(void *), pthread_attr *, void *);
    void exit (void *value_ptr);
    int cancel ();
    void testcancel ();
    int setcancelstate (int state, int *oldstate);
    int setcanceltype (int type, int *oldtype);
    void push_cleanup_handler (__pthread_cleanup_handler *handler);
    void pop_cleanup_handler (int const execute);
    unsigned long getsequence_np();
d402 2
a403 2
    pthreadNull ();
    static pthreadNull _instance;
d435 2
a436 2
    pthread_cond (pthread_condattr *);
   ~pthread_cond ();
d467 2
a468 2
    semaphore (int, unsigned int);
   ~semaphore ();
d508 5
a512 5
    {
      pthread_prepare = NULL;
      pthread_child   = NULL;
      pthread_parent  = NULL;
    }
@


1.48
log
@2002-09-21  Robert Collins <rbtcollins@@hotmail.com>

        * pthread.cc: Use class::call for converted pthread and semaphore
        calls.
        * thread.cc: Convert various __pthread_call and __sem_call to
        pthread::call and sem::call throughout.
        * pthread.h (__pthread_cancel): Convert to pthread::cancel.
        (__pthread_join): Convert to pthread::join.
        (__pthread_detach): Convert to pthread::detach.
        (__pthread_create): Convert to pthread::create.
        (__pthread_once): Convert to pthread::once.
        (__pthread_atfork): Convert to pthread::atfork.
        (__pthread_suspend): Convert to pthread::suspend.
        (__pthread_continue): Convert to pthread::resume.
        (__sem_init): Convert to semaphore::init.
        (__sem_destroy): Convert to semaphore::destroy.
        (__sem_wait): Convert to semaphore::wait.
        (__sem_trywait): Convert to semaphore::trywait.
        (__sem_post): Convert to semaphore::post.
@
text
@d215 1
a215 1
  void run_destructor () const;
@


1.47
log
@2002-09-21  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc: Finish the removal of the separate pthread_key
        destructor list.
        Remove all pthread_key_destructor and pthread_key_destructor_list
        references throughout.
        (pthread::exit): Call the new pthread_key interface to activate
        destructors.
        (pthread_key::keys): Change into a list.
        (pthread_key::saveAKey): New method, used via forEach.
        (pthread_key::restoreAKey): Ditto.
        (pthread_key::destroyAKey): Ditto.
        (pthread_key::fixup_before_fork): Use the List::forEach functionality.
        (pthread_key::fixup_after_fork): Ditto.
        (pthread_key::runAllDestructors): New method implementation.
        (pthread_key::pthread_key): Use List::Insert rather than custom list
        code.
        (pthread_key::~pthread_key): Use List::Remove for the same reason.
        * thread.h: Remove all pthread_key_destructor and
        pthread_key_destructor_list references throughout.
        (List): Move the interface above pthread_key in the header.
        Use atomic operations during insert and delete.
        (List::forEach): A generic interface for doing something on each node.
        (pthread_key::runAllDestructors): New method, run all destructors.
        (pthread_key::fork_buf): Make private.
        (pthread_key::run_destructor): Ditto.
        (pthread_key::saveAKey): New method for clearer source.
        (pthread_key::restoreAKey): Ditto.
        (pthread_key::destroyAKey): Ditto.
        (MTinterface::destructors): Remove.
@
text
@d339 11
d353 1
a372 3
    friend int __pthread_join (pthread_t * thread, void **return_val);
    friend int __pthread_detach (pthread_t * thread);

d451 7
a514 7
/* Cancellation */
int __pthread_cancel (pthread_t thread);

/* Thread Exit */
int __pthread_join (pthread_t * thread, void **return_val);
int __pthread_detach (pthread_t * thread);

a516 6
/*  ThreadCreation */
int __pthread_create (pthread_t * thread, const pthread_attr_t * attr,
		      void *(*start_routine) (void *), void *arg);
int __pthread_once (pthread_once_t *, void (*)(void));
int __pthread_atfork(void (*)(void), void (*)(void), void (*)(void));

a536 4
/* Thread suspend */
int __pthread_suspend (pthread_t * thread);
int __pthread_continue (pthread_t * thread);

a594 8
/* cancelability states */

/* Semaphores */
int __sem_init (sem_t * sem, int pshared, unsigned int value);
int __sem_destroy (sem_t * sem);
int __sem_wait (sem_t * sem);
int __sem_trywait (sem_t * sem);
int __sem_post (sem_t * sem);
a595 1

@


1.46
log
@2002-09-21  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc: Partial refactoring of pthread_key destructor
        handling. Loosely based on Thomas Pfaff's work.
        (pthread_key_destructor_list::Insert): Remove.
        (pthread_key_destructor_list::Pop): Remove.
        (pthread_key_destructor_list::IterateNull): Call the key's
        run_destructor method.
        (pthread_key::pthread_key): Initialize new member.
        (pthread_key::get): Mark as const for correctness.
        (pthread_key::run_destructor): Implement.
        * thread.h (pthread_key::get): Mark as const for correctness.
        (pthread_key::run_destructor): Declare.
        (List): New template class that implements a generic list.
        (pthread_key_destructor_list): Inherit from List, and remove
        now duplicate functions.
@
text
@d176 12
d192 1
a194 2
  void *fork_buf;
  class pthread_key *next;
a197 1
  void run_destructor () const;
d203 3
d208 4
a211 1
  static pthread_key * keys;
d215 2
a218 9
/* interface */
template <class ListNode> class List {
public:
  void Insert (ListNode *aNode);
  ListNode *Remove ( ListNode *aNode);
  ListNode *Pop ();
protected:
  ListNode *head;
};
d220 4
d229 1
a229 3
  head = aNode->InsertAfter (head);
  if (!head)
    head = aNode;                /*first node special case */
d241 2
a242 2
  while (resultPrev && resultPrev->Next() && !(aNode == resultPrev->Next()))
    resultPrev = resultprev->Next();
d244 1
a244 1
    return resultPrev->UnlinkNext ();
d250 1
a250 3
  ListNode *result = head;
  head = head->Next();
  return result;
d252 3
a254 5


/* FIXME: test using multiple inheritance and merging key_destructor into pthread_key
 * for efficiency */
class pthread_key_destructor
d256 7
a262 17
public:
  void (*destructor) (void *);
  pthread_key_destructor *InsertAfter (pthread_key_destructor * node);
  pthread_key_destructor *UnlinkNext ();
  pthread_key_destructor *Next ();

    pthread_key_destructor (void (*thedestructor) (void *), pthread_key * key);
  pthread_key_destructor *next;
  pthread_key *key;
};

class pthread_key_destructor_list : public List<pthread_key_destructor>
{
public:
  pthread_key_destructor *Remove (pthread_key * key);
  void IterateNull ();
};
a477 1
  pthread_key_destructor_list destructors;
@


1.45
log
@2002-09-21  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc: Change verifyable_object_isvalid calls with
        PTHREAD_CONDATTR_MAGIC, PTHREAD_MUTEXATTR_MAGIC, PTHREAD_COND_MAGIC,
        SEM_MAGIC to objecttype::isGoodObject() calls throughout.
        (pthread_condattr::isGoodObject): Implement.
        (pthread_mutex::isGoodInitializer): Implement.
        (pthread_mutex::isGoodInitializerOrObject): Minor bugfix in the
        check for verifyable_object_isvalid result.
        (pthread_mutexattr::isGoodObject): Implement.
        (pthread_cond::isGoodObject): Ditto.
        (pthread_cond::isGoodInitializer): Ditto.
        (pthread_cond::isGoodInitializerOrObject): Ditto.
        (semaphore::isGoodObject): Ditto.
        * thread.h (pthread_mutex::isGoodInitializer): Declare.
        (pthread_condattr::isGoodObject): Ditto.
        (pthread_cond::isGoodObject): Const correctness.
        (pthread_cond::isGoodInitializer): Declare.
        (pthread_cond::isGoodInitializerOrObject): Ditto.
        (semaphore::isGoodObject): Const correctness.
@
text
@d186 2
a187 1
  void *get ();
d189 1
a189 1
    pthread_key (void (*)(void *));
d198 1
d201 44
d260 1
a260 1
class pthread_key_destructor_list
a262 5
  void Insert (pthread_key_destructor * node);
/* remove a given dataitem, wherever in the list it is */
  pthread_key_destructor *Remove (pthread_key_destructor * item);
/* get the first item and remove at the same time */
  pthread_key_destructor *Pop ();
a264 2
private:
    pthread_key_destructor * head;
a265 1

@


1.44
log
@2002-09-21  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc: Change verifyable_object_isvalid calls with
        PTHREAD_MUTEX_MAGIC and PTHREAD_KEY_MAGIC and PTHREAD_ATTR_MAGIC to
        ::isGoodObject() calls throughout.
        (MTinterface::Init): Remove dead code.
        (pthread_attr::isGoodObject): Implement.
        (pthread_key::isGoodObject): Implement.
        (pthread_mutex::isGoodObject): Implement.
        (pthread_mutex::isGoodInitializerOrObject): Implement.
        (pthread::isGoodObject): Update signature.
        * thread.h (pthread_key::isGoodObject): Declare.
        (pthread_attr::isGoodObject): Ditto.
        (pthread_mutex::isGoodObject): Ditto.
        (pthread_mutex::isGoodInitializerOrObject): Ditto.
        (pthread::isGoodObject): Change to a const parameter for const
        correctness.
        (pthread_mutexattr::isGoodObject): Declare.
        (pthread_condattr::isGoodObject): Ditto.
        (pthread_cond::isGoodObject): Ditto.
        (semaphore::isGoodObject): Ditto.
@
text
@d257 1
d365 1
a365 1
  static bool isGoodObject(pthread_condattr_t *);
d375 3
a377 1
  static bool isGoodObject(pthread_cond_t *);
d406 1
a406 1
  static bool isGoodObject(semaphore **);
@


1.43
log
@2002-09-17  Robert Collins  <rbtcollins@@hotmail.com>

        This work inspires by Thomas Pfaff's pthread_fork patch (1).
        * fork.cc (fork_child): Remove MTinterface fixup call, it's
        adsorbed by pthread::atforkchild.
        Rename __pthread_atforkchild to pthread::atforkchild to give
        access to private members.
        (fork_parent): Rename __pthread_atforkparent to
        pthread::atforkparent to give it access to private members.
        Ditto for __pthread_atforkprepare.
        * thread.cc: Fix some formatting problems throughout.
        (MTinterface::fixup_before_fork): Implement.
        (MTinterface::fixup_after_fork): Fix pthread_keys.
        (pthread_key::keys): Implement.
        (pthread_key::fixup_before_fork): Ditto.
        (pthread_key::fixup_after_fork): Ditto.
        (pthread_key::pthread_key): Add to pthread_key::keys.
        (pthread_key::~pthread_key): Remove from pthread_key::keys.
        (pthread_key::saveKeyToBuffer): Implement.
        (pthread_key::recreateKeyFromBuffer): Ditto.
        (pthread::atforkprepare): Prepare all MT classes for fork.
        (pthread::atforkchild): And fix them up afterwards.
        * thread.h (pthread_key): Buffer the key value during
        fork in fork_buf.
        List the keys needing to be fixed up in a linked list with
        head pthread_key::keys.
        (pthread): Move atfork cygwin internal calls into the class.
        (MTInterface): Provide a fixup_before_fork for objecst that
        need to save state.
        (__pthread_atforkprepare): Remove.
        (__pthread_atforkparent): Remove.
        (__pthread_atforkchild): Remove.
@
text
@d179 1
d232 1
d246 1
d256 2
d298 1
a298 1
   static bool isGoodObject(pthread_t *);
d364 1
d374 1
d403 1
@


1.42
log
@* init.cc: Cleanup slightly and remove obsolete code.
@
text
@d181 3
d189 7
d294 3
d437 1
a437 1
  // list of mutex's. USE THREADSAFE INSERTS AND DELETES.
d443 1
a452 4

void __pthread_atforkprepare(void);
void __pthread_atforkparent(void);
void __pthread_atforkchild(void);
@


1.41
log
@2002-09-11  Robert Collins  <rbtcollins@@hotmail.com>

        * init.cc (dll_entry): On thread detach, if the thread hasn't
        exit()ed, do so.
        * pthread.cc (pthread_getsequence_np): Remove the
        __pthread_getsequence_np wrapper. This requires errno.h.
        * thread.cc (pthread::self): Instantiate a new pthread object
        when called and none exists. return a NULL object if instantiation
        fails.
        (pthread::precreate): Factor out common code.
        (pthread::postcreate): Ditto.
        (pthread::create): Ditto.
        (pthread::exit): Remove the TLS value when we exit to prevent
        double exits.
        (MTinterface::Init): Bugfix - don't mark the TLS index as created
        if one was not allocated.
        Apply Extract Method to move pthread specific initialisation into
        pthread.
        (pthread::initMainThread): Extracted method from MTinterface::Init.
        (pthread::setTlsSelfPointer): Extracted method from various pthread
        calls, to make reading those functions easier.
        (pthread::setThreadIdtoCurrent): Ditto.
        (pthread::cancel_self): Bring into the .cc file, it's only used
        within the class.
        (pthread::getThreadId): Ditto.
        (pthread::thread_init_wrapper): Apply Extract Method to the TLS
        setting logic.
        (pthread::isGoodObject): Extracted method from various pthread
        wrapper calls, for clarity of reading.
        (pthread::getsequence_np): Converted from __pthread_getsquence_np.
        (__pthread_create): Apply Extract Method to the object validation.
        (__pthread_cancel): Ditto.
        (__pthread_join): Ditto.
        (__pthread_detach): Ditto.
        (__pthread_suspend): Ditto.
        (__pthread_continue): Ditto.
        (__pthread_getschedparam): Ditto.
        (__pthread_getsequence_np): Remove.
        (__pthread_setschedparam): Apply Extract Method to the object
        validation.
        (pthreadNull::getNullpthread): New method, return the pthreadNull
        object.
        (pthreadNull::pthreadNull): Private constructor to prevent accidental
        use.
        (pthreadNull::~pthreadNull): Prevent compile warnings.
        (pthreadNull::create): Override pthread behaviour.
        (pthreadNull::exit): Ditto.
        (pthreadNull::cancel): Ditto.
        (pthreadNull::testcancel): Ditto.
        (pthreadNull::setcancelstate): Ditto.
        (pthreadNull::setcanceltype): Ditto.
        (pthreadNull::push_cleanup_handler): Ditto.
        (pthreadNull::pop_cleanup_handler): Ditto.
        (pthreadNull::getsequence_np): Ditto.
        (pthreadNull::_instance): Ditto.
        * thread.h (pthread): Declare pre- and post-create.
        Move GetThreadId to private scope and rename to getThreadId.
        Move setThreadIdtoCurrent to private scope.
        Make create virtual.
        Make ~pthread virtual.
        Declare initMainThread.
        Declare isGoodObject.
        Make exit virtual.
        Make cancel virtual.
        Make testcancel virtual.
        Make setcancelstate virtual.
        Make setcanceltype virtual.
        Make push_cleanup_handler virtual.
        Make pop_cleanup_handler virtual.
        Declare getsequence_np.
        Declare setTlsSelfPointer.
        (pthreadNull): New null object class for pthread.
        (__pthread_getsequence_np): Remove.
@
text
@d321 1
a321 1
  public: 
@


1.40
log
@2002-06-25  Thomas Pfaff  <tpfaff@@gmx.net>

        * include/pthread.h (PTHREAD_CANCELED): Defined a reasonable
        value.
	* pthread.cc (pthread_exit): Call method instead of function.
	(pthread_setcancelstate): Ditto.
	(pthread_setcanceltype): Ditto.
	(pthread_testcancel): Ditto.
	* thread.h (pthread::cancel_event): New member.
        (__pthread_cancel_self): New prototype.
	(pthread::exit): New Method.
	(pthread::cancel): Ditto.
	(pthread::testcancel): Ditto.
	(pthread::cancel_self): Ditto.
	(pthread::static_cancel_self): Ditto.
	(pthread::setcancelstate): Ditto.
	(pthread::setcanceltype): Ditto.
	(__pthread_cancel): Give c++ linkage.
	(__pthread_exit): Remove.
	(__pthread_setcancelstate): Ditto.
	(__pthread_setcanceltype): Ditto.
	(__pthread_testcancel): Ditto.
	 * thread.cc (pthread::pthread): Inititialize cancel_event.
	(pthread::~pthread): Close cancel_event if needed.
	(pthread::create): Create cancel_event.
	(pthread::exit): New method. Replacement for __pthread_exit.
	(pthread::cancel): New method.
	(pthread::testcancel): Ditto.
	(pthread::static_cancel_self); New static method.
	(pthread::setcancelstate): New method. Replacement for
	__pthread_setcancelstate.
	(pthread::setcanceltype): New method. Replacement for
	__pthread_setcanceltype.
	(pthread::pop_cleanup_handler): Added lock for async cancel safe
	cancellation.
	(pthread::thread_init_wrapper): Change __pthread_exit to
	thread->exit().
	(__pthread_cancel): Call method thread->cancel().
	(__pthread_exit): Remove.
	(__pthread_setcancelstate): Ditto.
	(__pthread_setcanceltype): Ditto.
	(__pthread_testcancel): Ditto.
@
text
@a272 9
  DWORD GetThreadId ()
  {
    return thread_id;
  }
  void setThreadIdtoCurrent ()
  {
    thread_id = GetCurrentThreadId ();
  }

d277 4
a280 1
  void create (void *(*)(void *), pthread_attr *, void *);
d282 2
a283 2
    pthread ();
   ~pthread ();
d285 1
a285 1
   void exit (void *value_ptr);
d287 2
a288 6
   int cancel ();
   void testcancel ();
   void cancel_self ()
   {
     exit (PTHREAD_CANCELED);
   }
d291 2
a292 2
   int setcancelstate (int state, int *oldstate);
   int setcanceltype (int type, int *oldtype);
d294 2
a295 2
   void push_cleanup_handler (__pthread_cleanup_handler *handler);
   void pop_cleanup_handler (int const execute);
d300 2
d311 30
a481 2

unsigned long __pthread_getsequence_np (pthread_t * thread);
@


1.39
log
@2002-06-12  Thomas Pfaff  <tpfaff@@gmx.net>

	* thread.h (pthread::cleanup_stack): Renamed cleanup_handlers to
	cleanup_stack.
	* thread.cc (pthread::pthread): Ditto.
	(pthread::create): Fixed mutex verification.
	(pthread::push_cleanup_handler): Renamed cleanup_handlers to
	cleanup_stack.
	Mutex calls removed, used InterlockedExchangePointer instead.
	(pthread::pop_cleanup_handler): Renamed cleanup_handlers to
	cleanup_stack.
	(pthread::pop_all_cleanup_handlers): Ditto.
	(__pthread_once): Check state first and return if already done.
	(__pthread_join): DEADLOCK test reverted to __pthread_equal
	call.
	(__pthread_detach): Unlock mutex before deletion.
@
text
@d269 1
d291 13
a314 1
    friend void __pthread_exit (void *value_ptr);
d422 3
a425 1
void __pthread_exit (void *value_ptr);
a521 4
int __pthread_cancel (pthread_t thread);
int __pthread_setcancelstate (int state, int *oldstate);
int __pthread_setcanceltype (int type, int *oldtype);
void __pthread_testcancel (void);
@


1.38
log
@* winver.rc: Add more words to copyright.
@
text
@d298 1
a298 1
    __pthread_cleanup_handler *cleanup_handlers;
@


1.37
log
@* spawn.cc (spawn_guts): More hToken removal cleanup.
@
text
@a3 1
   Copyright 2001 Red Hat, Inc.
@


1.36
log
@/tmp/cvs610a0a90.1
@
text
@d305 1
a305 1
    
d398 6
a403 6
    MTinterface ():reent_index (0), indexallocated (0), threadcount (1)
  {
    pthread_prepare = NULL;
    pthread_child   = NULL;
    pthread_parent  = NULL;
  }
@


1.35
log
@2002-06-10  Robert Collins  <rbtcollins@@hotmail.com>

        * cygwin.din: Add _pthread_cleanup_push and _pthread_cleanup_pop.
        * pthread.cc: Change __pthread_self to pthread::self() thruoghout.
        (_pthread_cleanup_push): New function.
        (_pthread_cleanup_pop): Ditto.
        * thread.cc: Thanks to Thomas Pfaff for the pthread cleanup_push,_pop
        patch, this work is derived from that.
        Change __pthread_self to pthread::self() thruoghout.
        (__pthread_self): Rename to pthread::self.
        (pthread::self): New method.
        (pthread::pthread): Initialize new member.
        (pthread::push_cleanup_handler): New method.
        (pthread::pop_cleanup_handler): New method.
        (pthread::pop_all_cleanup_handlers): New method.
        (__pthread_exit): Pop all cleanup handlers.
        * thread.h (pthread::push_cleanup_handler): Declare.
        (pthread::pop_cleanup_handler): Ditto.
        (pthread::pop_all_cleanup_handlers): Ditto.
        (pthread::self): New static method.
        (__pthread_exit): Give C++ linkage.
        (__pthread_join): Ditto.
        (__pthread_detach): Ditto.
        (__pthread_self): Remove.

2002-04-24  Thomas Pfaff  <tpfaff@@gmx.net>

        * include/pthread.h (__pthread_cleanup_handler): New structure
        (pthread_cleanup_push): Rewritten .
        (pthread_cleanup_pop): Ditto.
        (_pthread_cleanup_push): New prototype.
        (_pthread_cleanup_pop) Ditto.

2002-04-24  Thomas Pfaff  <tpfaff@@gmx.net>

        * thread.cc (thread_init_wrapper): Check if thread is already joined.
        (__pthread_join): Set joiner first.
        (__pthread_detach): Ditto.
@
text
@d232 28
d295 1
d300 1
d303 3
a308 29
class pthread_mutexattr:public verifyable_object
{
public:
  int pshared;
  int mutextype;
    pthread_mutexattr ();
   ~pthread_mutexattr ();
};

class pthread_mutex:public verifyable_object
{
public:
  CRITICAL_SECTION criticalsection;
  HANDLE win32_obj_id;
  LONG condwaits;
  int pshared;
  class pthread_mutex * next;

  int Lock ();
  int TryLock ();
  int UnLock ();
  void fixup_after_fork ();

  pthread_mutex (unsigned short);
  pthread_mutex (pthread_mutexattr *);
  pthread_mutex (pthread_mutex_t *, pthread_mutexattr *);
  ~pthread_mutex ();
};

a416 2
void *thread_init_wrapper (void *);

@


1.34
log
@/tmp/cvs610a0efc.1
@
text
@d263 5
d270 4
d406 5
a440 7


/* Thread Exit */
void __pthread_exit (void *value_ptr);
int __pthread_join (pthread_t * thread, void **return_val);
int __pthread_detach (pthread_t * thread);

a441 1

a470 1
pthread_t __pthread_self ();
a472 1

a509 1

@


1.33
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d242 1
@


1.32
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.31
log
@2001-12-26  Robert Collins  <rbtcollins@@hotmail.com>

        * thread.cc (pthread_cond::Signal): Use a separate flag for signal detection
        and broadcast semantics.
        (__pthread_cond_dowait): Ditto.
        * thread.h (pthread_cond): New flag for testing when a waiter has woken.
@
text
@d57 1
a57 1
  struct group _grp;
@


1.30
log
@Eliminate excess whitespace.
@
text
@d309 1
@


1.29
log
@Sat Sep 29 18:26:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * pthread.cc (pthread_cond_timedwait): Deleted - exported from thread.cc.
        (pthread_cond_wait): Deleted - exported from thread.cc.
        * thread.cc (pthread_cond::BroadCast): Update to use the new syntax for
        verifyable_object_isvalid ().
        (pthread_cond::Signal): Ditto. Also attempt to fix the lost signal race
        with pthread_cond::TimedWait().
        (check_valid_pointer): Change definiton to void const *.
        (verifyable_object_isvalid): Add new parameter to allow identification of
        static initializers, and return a enum rather than magic numbers.
        (__pthread_create): Ditto.
        (__pthread_cleanup): Ditto.
        (__pthread_attr_init): Ditto.
        (__pthread_attr_getinheritsched): Ditto.
        (__pthread_attr_getschedparam): Ditto.
        (__pthread_attr_getschedpolicy): Ditto.
        (__pthread_attr_getscope): Ditto.
        (__pthread_attr_setdetachstate): Ditto.
        (__pthread_attr_getdetachstate): Ditto.
        (__pthread_attr_setinheritsched): Ditto.
        (__pthread_attr_setschedparam): Ditto.
        (__pthread_attr_setschedpolicy): Ditto.
        (__pthread_attr_setscope): Ditto.
        (__pthread_attr_setstacksize): Ditto.
        (__pthread_attr_getstacksize): Ditto.
        (__pthread_attr_destroy): Ditto.
        (__pthread_join): Ditto.
        (__pthread_detach): Ditto.
        (__pthread_suspend): Ditto.
        (__pthread_continue): Ditto.
        (__pthread_getschedparam): Ditto.
        (__pthread_getsequence_np): Ditto.
        (__pthread_key_create): Ditto.
        (__pthread_key_delete): Ditto.
        (__pthread_setschedparam): Ditto.
        (__pthread_setspecific): Ditto.
        (__pthread_getspecific): Ditto.
        (__pthread_cond_destroy): Ditto.
        (__pthread_cond_init): Ditto.
        (__pthread_cond_broadcast): Ditto.
        (__pthread_cond_signal): Ditto.
        (__pthread_condattr_init): Ditto.
        (__pthread_condattr_getpshared): Ditto.
        (__pthread_condattr_setpshared): Ditto.
        (__pthread_condattr_destroy): Ditto.
        (__pthread_kill): Ditto.
        (__pthread_mutex_init): Ditto.
        (__pthread_mutex_getprioceiling): Ditto.
        (__pthread_mutex_lock): Ditto.
        (__pthread_mutex_trylock): Ditto.
        (__pthread_mutex_unlock): Ditto.
        (__pthread_mutex_destroy): Ditto.
        (__pthread_mutex_setprioceiling): Ditto.
        (__pthread_mutexattr_getprotocol): Ditto.
        (__pthread_mutexattr_getpshared): Ditto.
        (__pthread_mutexattr_gettype): Ditto.
        (__pthread_mutexattr_init): Ditto.
        (__pthread_mutexattr_destroy): Ditto.
        (__pthread_mutexattr_setprotocol): Ditto.
        (__pthread_mutexattr_setprioceiling): Ditto.
        (__pthread_mutexattr_getprioceiling): Ditto.
        (__pthread_mutexattr_setpshared): Ditto.
        (__pthread_mutexattr_settype): Ditto.
        (__sem_init): Ditto.
        (__sem_destroy): Ditto.
        (__sem_wait): Ditto.
        (__sem_trywait): Ditto.
        (__sem_post): Ditto.
        (__pthread_cond_dowait): New function, contains core logic from
        __pthread_cond_wait and __pthread_cond_timedwait. Decrement (*cond)->waiting
        before reentering the cond access mutex to allow detection of lost signals.
        (__pthread_cond_timedwait): Rename to pthread_cond_timedwait, and call
        __pthread_cond_dowait after calculating the wait length.
        (__pthread_cond_wait): Rename to pthread_cond_wait, and call
        __pthread_cond_dowait.
        * thread.h: New enum for use with verifyable_object_isvalid.
        Remove the extern exporting of __pthread_cond_timedwait and __pthread_cond_wait.
@
text
@d167 1
a167 1
typedef enum 
@


1.28
log
@Tue Sep 25 21:25:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * thread.cc (pthread_cond::BroadCast): Use address with verifyable_object_isvalid().
        (pthread_cond::Signal): Ditto.
        (__pthread_create): Ditto.
        (__pthread_cleanup): Ditto.
        (__pthread_attr_init): Ditto.
        (__pthread_attr_getinheritsched): Ditto.
        (__pthread_attr_getschedparam): Ditto.
        (__pthread_attr_getschedpolicy): Ditto.
        (__pthread_attr_getscope): Ditto.
        (__pthread_attr_setdetachstate): Ditto.
        (__pthread_attr_getdetachstate): Ditto.
        (__pthread_attr_setinheritsched): Ditto.
        (__pthread_attr_setschedparam): Ditto.
        (__pthread_attr_setschedpolicy): Ditto.
        (__pthread_attr_setscope): Ditto.
        (__pthread_attr_setstacksize): Ditto.
        (__pthread_attr_getstacksize): Ditto.
        (__pthread_attr_destroy): Ditto.
        (__pthread_join): Ditto.
        (__pthread_detach): Ditto.
        (__pthread_suspend): Ditto.
        (__pthread_continue): Ditto.
        (__pthread_getschedparam): Ditto.
        (__pthread_getsequence_np): Ditto.
        (__pthread_key_create): Ditto.
        (__pthread_key_delete): Ditto.
        (__pthread_setschedparam): Ditto.
        (__pthread_setspecific): Ditto.
        (__pthread_getspecific): Ditto.
        (__pthread_cond_destroy): Ditto.
        (__pthread_cond_init): Ditto.
        (__pthread_cond_broadcast): Ditto.
        (__pthread_cond_signal): Ditto.
        (__pthread_cond_timedwait): Ditto.
        (__pthread_cond_wait): Ditto.
        (__pthread_condattr_init): Ditto.
        (__pthread_condattr_getpshared): Ditto.
        (__pthread_condattr_setpshared): Ditto.
        (__pthread_condattr_destroy): Ditto.
        (__pthread_kill): Ditto.
        (__pthread_mutex_init): Ditto.
        (__pthread_mutex_getprioceiling): Ditto.
        (__pthread_mutex_lock): Ditto.
        (__pthread_mutex_trylock): Ditto.
        (__pthread_mutex_unlock): Ditto.
        (__pthread_mutex_destroy): Ditto.
        (__pthread_mutex_setprioceiling): Ditto.
        (__pthread_mutexattr_getprotocol): Ditto.
        (__pthread_mutexattr_getpshared): Ditto.
        (__pthread_mutexattr_gettype): Ditto.
        (__pthread_mutexattr_init): Ditto.
        (__pthread_mutexattr_destroy): Ditto.
        (__pthread_mutexattr_setprotocol): Ditto.
        (__pthread_mutexattr_setprioceiling): Ditto.
        (__pthread_mutexattr_getprioceiling): Ditto.
        (__pthread_mutexattr_setpshared): Ditto.
        (__pthread_mutexattr_settype): Ditto.
        (__sem_init): Ditto.
        (__sem_destroy): Ditto.
        (__sem_wait): Ditto.
        (__sem_trywait): Ditto.
        (__sem_post): Ditto.
        (verifyable_object_isvalid): Recieve a pointer to a pointer for verification.
        (__pthread_mutexattr_getprotocol): Fix typo in magic number.
        (__pthread_mutexattr_getpshared): Ditto.
        (__pthread_mutexattr_gettype): Ditto.
        * thread.h (verifyable_object_isvalid): Change prototype to recieve a pointer to a
        pointer for verification.
        * include/pthread.h: Fix typo for __cleanup_routine_type typedef. (Contrib from Net).
@
text
@d167 9
a175 1
int verifyable_object_isvalid (void const *, long);
a450 4
int __pthread_cond_timedwait (pthread_cond_t * cond,
			      pthread_mutex_t * mutex,
			      const struct timespec *abstime);
int __pthread_cond_wait (pthread_cond_t * cond, pthread_mutex_t * mutex);
@


1.27
log
@Wed Sep 12 13:03:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * autoload.cc (LoadDLLfuncEx): Auto load TryEnterCriticalSection - its a
n NT only call.
        * thread.cc (pthread_cond::TimedWait): Use critical sections for NT.
        (pthread_cond::fixup_after_fork): Don't detect bad apps.
        (pthread_mutex::pthread_mutex): Use critical sections for NT.
        (pthread_mutex::~pthread_mutex): Ditto.
        (pthread_mutex::Lock): Ditto.
        (pthread_mutex::TryLock): Ditto.
        (pthread_mutex::UnLock): Ditto.
        (pthread_mutex::fixup_after_fork): Ditto. Also do not detect bad apps.
        (__pthread_mutex_trylock): Move WIN32 specific test into the class metho
d.
        (__pthread_mutex_destroy): Prevent dereferencing passed pointer without
valid address.
        * thread.h (pthread_mutex): Use critical sections for NT.
@
text
@d167 1
a167 1
int verifyable_object_isvalid (verifyable_object *, long);
@


1.27.4.1
log
@Merged changes from HEAD
@
text
@d167 1
a167 1
int verifyable_object_isvalid (void const *, long);
@


1.27.4.2
log
@Merged changes from HEAD
@
text
@d167 1
a167 9
typedef enum 
{
  VALID_OBJECT,
  INVALID_OBJECT,
  VALID_STATIC_OBJECT
} verifyable_object_state;

verifyable_object_state verifyable_object_isvalid (void const *, long);
verifyable_object_state verifyable_object_isvalid (void const *, long, void *);
d443 4
@


1.27.4.3
log
@Merged changes from HEAD
@
text
@d167 1
a167 1
typedef enum
a308 1
  LONG ExitingWait;
@


1.27.4.4
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d57 1
a57 1
  struct __group16 _grp;
@


1.27.4.5
log
@Merged changes from HEAD
@
text
@a231 28
class pthread_mutexattr:public verifyable_object
{
public:
  int pshared;
  int mutextype;
    pthread_mutexattr ();
   ~pthread_mutexattr ();
};

class pthread_mutex:public verifyable_object
{
public:
  CRITICAL_SECTION criticalsection;
  HANDLE win32_obj_id;
  LONG condwaits;
  int pshared;
  class pthread_mutex * next;

  int Lock ();
  int TryLock ();
  int UnLock ();
  void fixup_after_fork ();

  pthread_mutex (pthread_mutexattr * = NULL);
  pthread_mutex (pthread_mutex_t *, pthread_mutexattr *);
  ~pthread_mutex ();
};

a241 1
  pthread_t joiner;
d262 3
a264 2
   void push_cleanup_handler (__pthread_cleanup_handler *handler);
   void pop_cleanup_handler (int const execute);
d266 8
a273 2
   static pthread* self ();
   static void *thread_init_wrapper (void *);
d275 8
a282 4
private:
    DWORD thread_id;
    __pthread_cleanup_handler *cleanup_handlers;
    pthread_mutex mutex;
d284 4
a287 3
    friend void __pthread_exit (void *value_ptr);
    friend int __pthread_join (pthread_t * thread, void **return_val);
    friend int __pthread_detach (pthread_t * thread);
d289 4
a292 1
    void pop_all_cleanup_handlers (void);
d384 6
a389 6
  MTinterface ():reent_index (0), indexallocated (0), threadcount (1)
    {
      pthread_prepare = NULL;
      pthread_child   = NULL;
      pthread_parent  = NULL;
    }
a395 5
/* Thread Exit */
void __pthread_exit (void *value_ptr);
int __pthread_join (pthread_t * thread, void **return_val);
int __pthread_detach (pthread_t * thread);

d398 2
d426 7
d434 1
d464 1
d467 1
d505 1
@


1.27.4.6
log
@Merged changes from HEAD
@
text
@d4 1
@


1.27.4.7
log
@correct merge
@
text
@d298 1
a298 1
    __pthread_cleanup_handler *cleanup_stack;
@


1.27.4.8
log
@Merged changes from HEAD
@
text
@a268 1
  HANDLE cancel_event;
a289 13
   void exit (void *value_ptr);

   int cancel ();
   void testcancel ();
   void cancel_self ()
   {
     exit (PTHREAD_CANCELED);
   }
   static void static_cancel_self ();

   int setcancelstate (int state, int *oldstate);
   int setcanceltype (int type, int *oldtype);

d301 1
a408 3
/* Cancellation */
int __pthread_cancel (pthread_t thread);

d410 1
d507 4
@


1.27.4.9
log
@Merged changes from HEAD
@
text
@d273 9
d286 1
a286 4
  virtual void create (void *(*)(void *), pthread_attr *, void *);

   pthread ();
   virtual ~pthread ();
d288 2
a289 2
   static void initMainThread(pthread *, HANDLE);
   static bool isGoodObject(pthread_t *);
d291 1
a291 1
   virtual void exit (void *value_ptr);
d293 6
a298 2
   virtual int cancel ();
   virtual void testcancel ();
d301 2
a302 2
   virtual int setcancelstate (int state, int *oldstate);
   virtual int setcanceltype (int type, int *oldtype);
d304 2
a305 2
   virtual void push_cleanup_handler (__pthread_cleanup_handler *handler);
   virtual void pop_cleanup_handler (int const execute);
a309 2
   virtual unsigned long getsequence_np();

a318 30
    void precreate (pthread_attr *);
    void postcreate ();
    void setThreadIdtoCurrent();
    static void setTlsSelfPointer(pthread *);
    void cancel_self ();
    DWORD getThreadId ();
};

class pthreadNull : public pthread
{
  public:
    static pthread *getNullpthread();
    ~pthreadNull();

    /* From pthread These should never get called
     * as the ojbect is not verifyable
     */
    void create (void *(*)(void *), pthread_attr *, void *);
    void exit (void *value_ptr);
    int cancel ();
    void testcancel ();
    int setcancelstate (int state, int *oldstate);
    int setcanceltype (int type, int *oldtype);
    void push_cleanup_handler (__pthread_cleanup_handler *handler);
    void pop_cleanup_handler (int const execute);
    unsigned long getsequence_np();

  private:
    pthreadNull ();
    static pthreadNull _instance;
d460 2
@


1.27.4.10
log
@Merged changes from HEAD
@
text
@a180 3
  void *fork_buf;
  class pthread_key *next;

a185 7
  static void fixup_before_fork();
  static void fixup_after_fork();
private:
  // lists of objects. USE THREADSAFE INSERTS AND DELETES.
  static pthread_key * keys;
  void saveKeyToBuffer ();
  void recreateKeyFromBuffer ();
a283 3
   static void atforkprepare();
   static void atforkparent();
   static void atforkchild();
d424 1
a424 1
  // lists of pthread objects. USE THREADSAFE INSERTS AND DELETES.
a429 1
  void fixup_before_fork (void);
d439 4
@


1.27.4.11
log
@Merged changes from HEAD
@
text
@a178 1
  static bool isGoodObject (pthread_key_t const *);
a230 1
  static bool isGoodObject(pthread_attr_t const *);
a243 1
  static bool isGoodObject(pthread_mutexattr_t const *);
a252 2
  static bool isGoodObject(pthread_mutex_t const *);
  static bool isGoodInitializerOrObject(pthread_mutex_t const *);
d293 1
a293 1
   static bool isGoodObject(pthread_t const *);
a358 1
  static bool isGoodObject(pthread_condattr_t *);
a367 1
  static bool isGoodObject(pthread_cond_t *);
a395 1
  static bool isGoodObject(semaphore **);
@


1.27.4.12
log
@Merged changes from HEAD
@
text
@a175 12
/* interface */
template <class ListNode> class List {
public:
  List();
  void Insert (ListNode *aNode);
  ListNode *Remove ( ListNode *aNode);
  ListNode *Pop ();
  void forEach (void (*)(ListNode *aNode));
protected:
  ListNode *head;
};

a179 1
  static void runAllDestructors ();
d182 2
d186 1
a186 1
  void *get () const;
d188 1
a188 1
  pthread_key (void (*)(void *));
a191 3

  /* List support calls */
  class pthread_key *next;
d194 1
a194 4
  static List<pthread_key> keys;
  static void saveAKey (pthread_key *);
  static void restoreAKey (pthread_key *);
  static void destroyAKey (pthread_key *);
d197 7
d205 7
a211 2
  void run_destructor () const;
  void *fork_buf;
d214 1
a214 36
/* implementation */
template <class ListNode>
List<ListNode>::List<ListNode> () : head(NULL)
{
}
template <class ListNode> void
List<ListNode>::Insert (ListNode *aNode)
{
  if (!aNode)
    return;
  aNode->next = (ListNode *) InterlockedExchangePointer (&head, aNode);
}
template <class ListNode> ListNode *
List<ListNode>::Remove ( ListNode *aNode)
{
  if (!aNode)
    return NULL;
  if (!head)
    return NULL;
  if (aNode == head)
    return Pop ();
  ListNode *resultPrev = head;
  while (resultPrev && resultPrev->next && !(aNode == resultPrev->next))
    resultPrev = resultPrev->next;
  if (resultPrev)
    return (ListNode *)InterlockedExchangePointer (&resultPrev->next, resultPrev->next->next);
  return NULL;
}
template <class ListNode> ListNode *
List<ListNode>::Pop ()
{
  return (ListNode *) InterlockedExchangePointer (&head, head->next);
}
/* poor mans generic programming. */
template <class ListNode> void
List<ListNode>::forEach (void (*callback)(ListNode *))
d216 12
a227 7
  ListNode *aNode = head;
  while (aNode) 
    {
      callback (aNode);
      aNode = aNode->next;
    }
}
a256 1
  static bool isGoodInitializer(pthread_mutex_t const *);
a302 11
   /* API calls */
   static int cancel (pthread_t);
   static int join (pthread_t * thread, void **return_val);
   static int detach (pthread_t * thread);
   static int create (pthread_t * thread, const pthread_attr_t * attr,
			      void *(*start_routine) (void *), void *arg);
   static int once (pthread_once_t *, void (*)(void));
   static int atfork(void (*)(void), void (*)(void), void (*)(void));
   static int suspend (pthread_t * thread);
   static int resume (pthread_t * thread);

a305 1
   
d325 3
d364 1
a364 1
  static bool isGoodObject(pthread_condattr_t const *);
d374 1
a374 3
  static bool isGoodObject(pthread_cond_t const *);
  static bool isGoodInitializer(pthread_cond_t const *);
  static bool isGoodInitializerOrObject(pthread_cond_t const *);
d403 1
a403 8
  static bool isGoodObject(sem_t const *);
  /* API calls */
  static int init (sem_t * sem, int pshared, unsigned int value);
  static int destroy (sem_t * sem);
  static int wait (sem_t * sem);
  static int trywait (sem_t * sem);
  static int post (sem_t * sem);
  
d440 1
d462 7
d471 6
d497 4
d559 8
d568 1
@


1.26
log
@Update copyrights.
@
text
@d270 1
@


1.25
log
@Tue Sep 11 18:15:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * dcrt0.cc (cygwin_finished_initializing): Copy _mtinterf on fork;
        * fork.cc (fork_child): fixup thread-related structures after fork;
        * thread.cc (MTinterface::Init): Initialise the new mutex, condition and semaphore lists.
        (MTinterface::fixup_after_fork): Iterate through each list and fixup the objects.
        (pthread_cond::pthread_cond): Add this to the condition list.
        (pthread_cond::~pthread_cond): Remove this from the condition list.
        (pthread_cond::fixup_after_fork): Recreate as best we can the pre-fork state.
        (pthread_mutex::pthread_mutex): Add this to the mutex list.
        (pthread_mutex::~pthread_mutex): Remove this from the mutex list.
        (pthread_mutex::fixup_after_fork): Recreate as best we can the pre-fork state.
        (semaphore::semaphore): Store the initial value, and add this to the semaphore list.
        (semaphore::~semaphore): Remove this from the semaphore list.
        (semaphore::Post): Increment the current semaphore value.
        (semaphore::TryWait): Decrement the current semaphore value.
        (semaphore::Wait): Ditto.
        (semaphote::fixup_after_fork): Recreate the pre-fork state as best we can.
        * thread.h (pthread_mutex): New members to allow fixup_after_fork.
        (pthread_cond): Ditto.
        (semaphore): Ditto.
        (MTinterface): New list heads for tracking conds and semaphores.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000 Cygnus Solutions.
@


1.24
log
@Mon Sep 10 08:28:00 2001  Robert Collins <rbtcollins@@hotmail.com>

        * thread.h (MT_Interface): Remove pshared mutex array.
        Add a threadsafe list for mutex tracking (for fixupafter fork).
        * thread.cc (MTInterface::Init): Remove pshared mutex array.
        (pthread_mutex::pthread_mutex): Remove pshared mutex functionality.
        Fail with EINVAL on attempts to use pshared functionality.
        (__pthread_mutex_getpshared): Remove.
        (__pthread_cond_timedwait): Remove pshared mutex functionality.
        (__pthread_cond_wait): Ditto.
        (__pthread_mutex_init): Ditto.
        (__pthread_mutex_getprioceiling): Ditto.
        (__pthread_mutex_lock): Ditto.
        (__pthread_mutex_trylock): Ditto.
        (__pthread_mutex_unlock): Ditto.
        (__pthread_mutex_destroy): Ditto.
        (__pthread_mutex_setprioceiling): Ditto.
        (__pthread_mutexattr_setpshared): Ditto.
@
text
@d273 1
d278 1
d304 1
d308 1
d326 1
d328 1
d332 1
d368 2
d372 1
@


1.23
log
@        * net.cc (cygwin_inet_ntoa): Rearrange previous patch to use
        thread local buffer space when compiled thread safe.
        (cygwin_getprotobyname): Ditto.
        (cygwin_getprotobynumber): Ditto.
        (cygwin_getservbyname): Ditto.
        (cygwin_getservbyport): Ditto.
        (cygwin_gethostbyname): Ditto.
        (cygwin_gethostbyaddr): Ditto. Move near to cygwin_gethostbyname.
        * thread.h (struct _winsup_t): Add pointers for above used buffer space.
        * passwd.cc (getpwduid): Remove initializing passwd.
        (setpwent): Ditto.
        (endpwent): Ditto.
        (setpassent): Ditto.
@
text
@d359 2
a360 4
  /* this is an associative array for the _exclusive_ use of pshared mutex's
   * normal mutex's don't go here to reduce overhead and prevent serialisation.
   */
  class pthread_mutex * pshared_mutexs[256];
@


1.22
log
@* mmap.cc: Clean up *ResourceLock calls throughout.
* thread.cc (pthread_cond::TimedWait): Check for WAIT_TIMEOUT as well as
WAIT_ABANDONED.
(__pthread_cond_timedwait): Calculate a relative wait from the abstime
parameter.
@
text
@d97 6
@


1.21
log
@forced commit
@
text
@d8 1
a8 1
   
d271 5
a275 5
 
    pthread_mutex (unsigned short);
    pthread_mutex (pthread_mutexattr *);
    pthread_mutex (pthread_mutex_t *, pthread_mutexattr *);
   ~pthread_mutex ();
d283 2
a284 2
    pthread_condattr ();
   ~pthread_condattr ();
@


1.20
log
@Sun May  6 17:05:00 2001  Robert Collins <rbtcollins@@hotmail.com>
	* thread.h (pthread_cond): New element cond_access to allow atomic broadcasts.
	* thread.cc (pthread_cond::pthread_cond): Initialise cond_access.
	(pthread_cond::~pthread_cond): Destroy cond_access.
	(pthread_cond::Broadcast): Use cond_access.
	(pthread_cond::Signal): Use cond_access.
	(pthread_cond_wait): Use cond_access.
	(pthread_cond_timedwait): Use cond_access.
@
text
@@


1.19
log
@        * grp.cc: Eliminate MAX_DOMAIN_NAME define.
        (read_etc_group): Substitute MAX_DOMAIN_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * passwd.cc (parse_pwd): Don't force pw_name to be lower case.
        * sec_helper.cc: Substitute MAX_USER_NAME by UNLEN,
        MAX_COMPUTERNAME_LENGTH by INTERNET_MAX_HOST_NAME_LENGTH throughout.
        (lookup_name): Slight cleanup.
        * security.cc (alloc_sd): Substitute MAX_USER_NAME by UNLEN.
        * security.h: Define DEFAULT_UID as DOMAIN_USER_RID_ADMIN and
        DEFAULT_GID as DOMAIN_ALIAS_RID_ADMINS.
        * shared.cc (memory_init): Substitute MAX_USER_NAME by UNLEN.
        * thread.h: Ditto.
        * uinfo.cc (internal_getlogin): Substitute MAX_USER_NAME by UNLEN.
        Substitute MAX_COMPUTERNAME_LENGTH and MAX_HOST_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * winsup.h: Include lmcons.h. Eliminate MAX_USER_NAME and
        MAX_HOST_NAME. Move DEFAULT_UID and DEFAULT_GID to security.h.
@
text
@d293 2
@


1.18
log
@Sun Apr 22 20:22:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* passwd.cc (getpwuid): Check for thread cancellation.
	(getpwuid_r): Ditto.
	(getpwname): Ditto.
	(getpwnam_r): Ditto.
	* thread.h (pthread_mutex): New constructors for pshared operation.
	(MTinterface): Associative array for pshared mutex's.
	* thread.cc (MTinterface::Init): Initailize pshared mutex array.
	(pthread_cond::BroadCast): Implementation notes.
	(pthread_cond::TimedWait): Remove use of SignalObjectAndWait on non-NT systems.
	(pthread_mutex::pthread_mutex(unsigned short)): New function.
	(pthread_mutex::pthread_mutex (pthread_mutex_t *, pthread_mutexattr *)):New function.
	(pthread_mutex::pthread_mutex(pthread_mutexattr *)): Fail on pshared mutex's.
	(__pthread_mutex_getpshared): New function.
	(__pthread_join): Check for thread cancellation.
	(__pthread_cond_timedwait): Support pshared mutex's.
	(__pthread_cond_wait): Ditto.
	(__pthread_condattr_setpshared): Error on PROCESS_SHARED requests.
	(__pthread_mutex_init): Support pshared mutex's.
	(__pthread_mutex_getprioceiling): Ditto.
	(__pthread_mutex_lock): Ditto.
	(__pthread_mutex_trylock): Ditto.
	(__pthread_mutex_unlock): Ditto.
	(__pthread_mutex_destroy): Ditto.
	(__pthread_mutex_setprioceiling): Ditto.
	(__pthread_mutexattr_setpshared): Support PTHREAD_PROCESS_PSHARED requests.
@
text
@d96 1
a96 1
  char _username[MAX_USER_NAME];
@


1.17
log
@Sat Apr 14 17:04:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* thread.h (MTinterface): Add threadcount.
	* thread.cc (MTinterface::Init): Set threadcount to 1.
	(__pthread_create): Increment threadcount.
	(__pthread_exit): Decrement threadcount and call exit() from the last thread.
@
text
@d266 1
d271 2
a272 1

d274 1
d350 5
@


1.16
log
@* fork.cc (fork_child): Call the __pthread_atforkchild function.
(fork_parent): Call the __pthread_atforkparent function.
* cygwin.din: Export pthread_atfork.
* thread.h (callback): New class.
(MTinterface): Use it.
* thread.cc (__pthread_atforkprepare): New function.
(__pthread_atforkparent): New function.
(__pthread_atforkchild): New function.
(__pthread_atfork): New function.
* pthread.cc (pthread_atfork): New function.
@
text
@d336 1
d350 1
a350 1
    MTinterface ():reent_index (0), indexallocated (0) 
@


1.15
log
@	* configure.in: Remove PTH_ALLOW.
	* cygwin.din: Remove @@PTH_ALLOW@@ prefixes to pthread functions.
	Add new pthread exports.
	* pthread.cc: New wrapper functions for the above new exports.
	* sched.cc (valid_sched_parameters): New function.
	(sched_setparam): Use it.
	(sched_set_thread_priority): New function. Used by pthread_sched*.
	* thread.cc (pthread_key_destructor::InsertAfter): New function.
	(pthread_key_destructor::UnlinkNext): New function.
	(pthread_key_destructor::Next): New function.
	(pthread_key_destructor_list::Insert): New function.
	(pthread_key_destructor_list::Remove): New function.
	(pthread_key_destructor_list::Pop): New function.
	(pthread_key_destructor::pthread_key_destructor): New function.
	(pthread_key_destructor_list::IterateNull): New function.
	(MTinterface::Init): Initialise new member.
	(pthread::pthread): Initialise new members.
	(pthread::create): Copy new attributes. Set the new thread priority.
	(pthread_attr::pthread_attr): Initialise new members.
	(pthread_key::pthread_key): Setup destructor function.
	(pthread_key::~pthread_key): Remove destructor function.
	(pthread_mutexattr::pthread_mutexattr): New function.
	(pthread_mutexattr::~pthread_mutexattr): New function.
	(__pthread_once): New function.
	(__pthread_cleanup): New function.
	(__pthread_cancel): New function.
	(__pthread_setcancelstate): New function.
	(__pthread_setcanceltype): New function.
	(__pthread_testcancel): New function.
	(__pthread_attr_getinheritsched): New function.
	(__pthread_attr_getschedparam): New function.
	(__pthread_attr_getschedpolicy): New function.
	(__pthread_attr_getscope): New function.
	(__pthread_attr_setinheritsched): New function.
	(__pthread_attr_setschedparam): New function.
	(__pthread_attr_setschedpolicy): New function.
	(__pthread_attr_setscope): New function.
	(__pthread_exit): Call any key destructors on thread exit.
	(__pthread_join): Use the embedded attr values.
	(__pthread_detach): Use the embedded attr values.
	(__pthread_getconcurrency): New function.
	(__pthread_getschedparam): New function.
	(__pthread_key_create): Pass the destructor on object creation.
	(__pthread_key_delete): Correct incorrect prototype.
	(__pthread_setconcurrency): New function.
	(__pthread_setschedparam): New function.
	(__pthread_cond_timedwait): Support static mutex initialisers.
	(__pthread_cond_wait): Ditto.
	(__pthread_mutex_getprioceiling): New function.
	(__pthread_mutex_lock): Support static mutex initialisers.
	(__pthread_mutex_trylock): Ditto.
	(__pthread_mutex_unlock): Ditto.
	(__pthread_mutex_destroy): Ditto.
	(__pthread_mutex_setprioceiling): New function.
	(__pthread_mutexattr_getprotocol): New function.
	(__pthread_mutexattr_getpshared): New function.
	(__pthread_mutexattr_gettype): New function.
	(__pthread_mutexattr_init): New function.
	(__pthread_mutexattr_destroy): New function.
	(__pthread_mutexattr_setprotocol): New function.
	(__pthread_mutexattr_setprioceiling): New function.
	(__pthread_mutexattr_getprioceiling): New function.
	(__pthread_mutexattr_setpshared): New function.
	(__pthread_mutexattr_settype): New function.
	Remove stubs for non MT_SAFE compilation.
	* thread.h: Remove duplicate #defines.
	Add prototypes for new functions in thread.cc.
	(pthread_key_destructor): New class.
	(pthread_key_destructor_list): New class.
	(pthread_attr): Add new members.
	(pthread): Remove members that are duplicated in the pthread_attr class.
	(pthread_mutex_attr): Add new members.
	(pthread_once): New class.
	* include/pthread.h: Add prototypes for new functions exported from cygwin1.dll.
	Remove typedefs.
	* include/sched.h: Add prototypes for new functions in sched.cc.
	* include/cygwin/types.h: Add typedefs from pthread.h
@
text
@d320 7
d343 3
d349 1
a349 1
    MTinterface ():reent_index (0), indexallocated (0)
d351 3
d357 3
d369 1
@


1.14
log
@* shared_info.h (mount_info): Remove mnt_ elements.
* thread.h (struct _winsup_t): Add mnt_ elements.
* path.cc (fillout_mntent): Use mnt_ elements from reent_winsup ().
@
text
@d29 1
a29 1
void AssertResourceOwner (int, int);
d42 1
a42 15
//#include <pthread.h>
/* FIXME: these are defined in pthread.h, but pthread.h defines symbols it shouldn't -
 * all the types.
 */
#define PTHREAD_PROCESS_PRIVATE 0
#define PTHREAD_PROCESS_SHARED  1
#define PTHREAD_DESTRUCTOR_ITERATIONS 1
/* Tls has 64 items for pre win2000 - and we don't want to use them all :]
 * Before committing discuss this with the list
 */
#define PTHREAD_KEYS_MAX 32
#define PTHREAD_CREATE_DETACHED 1
/* the default : joinable */
#define PTHREAD_CREATE_JOINABLE 0

d55 2
a56 2
  Needed for the group functions
  */
d125 3
a127 1
  ResourceLocks () {}
d148 3
d157 2
a158 2
  verifyable_object (long);
  ~verifyable_object ();
d163 42
d209 3
d214 2
a215 2
  pthread_attr ();
  ~pthread_attr ();
d227 3
a229 1
  int joinable;
d245 2
a246 2
  pthread ();
  ~pthread ();
d249 1
a249 1
  DWORD thread_id;
d255 4
a258 2
  pthread_mutexattr ();
  ~pthread_mutexattr ();
d271 2
a272 14
  pthread_mutex (pthread_mutexattr *);
  ~pthread_mutex ();
};

class pthread_key:public verifyable_object
{
public:

  DWORD dwTlsIndex;
  int set (const void *);
  void *get ();

  pthread_key ();
  ~pthread_key ();
d280 2
a281 2
  pthread_condattr ();
  ~pthread_condattr ();
d295 9
a303 2
  pthread_cond (pthread_condattr *);
  ~pthread_cond ();
d316 2
a317 2
  semaphore (int, unsigned int);
  ~semaphore ();
a319 11
typedef class pthread *pthread_t;
typedef class pthread_mutex *pthread_mutex_t;
/* sem routines belong in semaphore.cc */
typedef class semaphore *sem_t;

typedef class pthread_key *pthread_key_t;
typedef class pthread_attr *pthread_attr_t;
typedef class pthread_mutexattr *pthread_mutexattr_t;
typedef class pthread_condattr *pthread_condattr_t;
typedef class pthread_cond *pthread_cond_t;

d328 1
d335 2
d339 3
a341 2
  MTinterface ():reent_index (0), indexallocated (0)
  {}
d347 1
a347 1
  void *thread_init_wrapper (void *);
d350 25
a374 12
  int __pthread_create (pthread_t * thread, const pthread_attr_t * attr,
			void *(*start_routine) (void *), void *arg);
  int __pthread_attr_init (pthread_attr_t * attr);
  int __pthread_attr_destroy (pthread_attr_t * attr);
  int __pthread_attr_setdetachstate (pthread_attr_t *, int);
  int __pthread_attr_getdetachstate (const pthread_attr_t *, int *);
  int __pthread_attr_setstacksize (pthread_attr_t * attr, size_t size);
  int __pthread_attr_getstacksize (pthread_attr_t * attr, size_t * size);
/*
__pthread_attr_setstackaddr(...);
__pthread_attr_getstackaddr(...);
*/
d377 3
a379 3
  void __pthread_exit (void *value_ptr);
  int __pthread_join (pthread_t * thread, void **return_val);
  int __pthread_detach (pthread_t * thread);
d383 2
a384 2
  int __pthread_suspend (pthread_t * thread);
  int __pthread_continue (pthread_t * thread);
d386 1
a386 1
  unsigned long __pthread_getsequence_np (pthread_t * thread);
d389 4
a392 4
  int __pthread_key_create (pthread_key_t * key, void (*destructor) (void *));
  int __pthread_key_delete (pthread_key_t * key);
  int __pthread_setspecific (pthread_key_t key, const void *value);
  void *__pthread_getspecific (pthread_key_t key);
d395 14
a408 14
  int __pthread_cond_destroy (pthread_cond_t * cond);
  int __pthread_cond_init (pthread_cond_t * cond,
			   const pthread_condattr_t * attr);
  int __pthread_cond_signal (pthread_cond_t * cond);
  int __pthread_cond_broadcast (pthread_cond_t * cond);
  int __pthread_cond_timedwait (pthread_cond_t * cond,
				pthread_mutex_t * mutex,
				const struct timespec *abstime);
  int __pthread_cond_wait (pthread_cond_t * cond, pthread_mutex_t * mutex);
  int __pthread_condattr_init (pthread_condattr_t * condattr);
  int __pthread_condattr_destroy (pthread_condattr_t * condattr);
  int __pthread_condattr_getpshared (const pthread_condattr_t * attr,
				     int *pshared);
  int __pthread_condattr_setpshared (pthread_condattr_t * attr, int pshared);
d411 3
a413 3
  int __pthread_kill (pthread_t * thread, int sig);
  int __pthread_sigmask (int operation, const sigset_t * set,
			 sigset_t * old_set);
d416 2
a417 2
  pthread_t __pthread_self ();
  int __pthread_equal (pthread_t * t1, pthread_t * t2);
d421 37
a457 5
  int __pthread_mutex_init (pthread_mutex_t *, const pthread_mutexattr_t *);
  int __pthread_mutex_lock (pthread_mutex_t *);
  int __pthread_mutex_trylock (pthread_mutex_t *);
  int __pthread_mutex_unlock (pthread_mutex_t *);
  int __pthread_mutex_destroy (pthread_mutex_t *);
d460 5
a464 5
  int __sem_init (sem_t * sem, int pshared, unsigned int value);
  int __sem_destroy (sem_t * sem);
  int __sem_wait (sem_t * sem);
  int __sem_trywait (sem_t * sem);
  int __sem_post (sem_t * sem);
@


1.13
log
@* thread.h (struct _winsup_t): Remove obsolete elements.  Add available_drives
element.
* path.cc (mount_info::getmntent): Report "/cygdrive" drives when mounted
drives are exhausted.
(fillout_mntent): New function.
(mount_item::getmntent): Use fillout_mntent.
(cygdrives_mntent): New function.  Returns next available "/cygdrive".
(setmntent): Initialize available "/cygdrives".
* syscalls.cc: Remove some if 0'ed code.
* times.cc (timezone): Use more descriptive variable name.
@
text
@d91 4
@


1.12
log
@* sched.cc: New file.  Implement sched*.
* include/sched.h: New file.  User land includes for sched*.
* Makefile.in: Add sched.o
* cygwin.din: Add exports for sched*.
@
text
@d29 1
a29 1
  void AssertResourceOwner (int, int);
d31 1
a31 1
# define AssertResourceOwner(i,ii)
d66 43
a108 51
  struct _winsup_t
  {
/*
 Needed for the group functions
*/
    struct group _grp;
    char *_namearray[2];
    char _linebuf[100];
    int _grp_pos;

/* console.cc */
    unsigned _rarg;

/* dlfcn.cc */
    int _dl_error;
    char _dl_buffer[256];

/* passwd.cc */
    struct passwd _res;
    char _tmpbuf[100];
    char _pass[_PASSWORD_LEN];
    int _pw_pos;

/* path.cc */
    struct mntent _ret;
    int _iteration;

/* strerror */
    char _strerror_buf[20];

/* syscalls.cc */
    char _dacl_buf[1024];
    char _sacl_buf[1024];
    char _ownr_buf[1024];
    char _grp_buf[1024];

/* sysloc.cc */
    char *_process_ident;
    int _process_logopt;
    int _process_facility;
    int _process_logmask;

/* times.cc */
    char _b[20];
    struct tm _localtime_buf;
    char _buf1[33];
    char _buf2[33];

/* uinfo.cc */
    char _username[MAX_USER_NAME];
  };
d110 5
d116 5
a120 11
  struct __reent_t
  {
    struct _reent *_clib;
    struct _winsup_t *_winsup;
  };

  _reent *_reent_clib ();
  _winsup_t *_reent_winsup ();
  void SetResourceLock (int, int, const char *) __attribute__ ((regparm (3)));
  void ReleaseResourceLock (int, int, const char *)
    __attribute__ ((regparm (3)));
d123 1
a123 1
  void AssertResourceOwner (int, int);
d135 1
a135 3
  ResourceLocks ()
  {
  };
d162 2
a163 2
    verifyable_object (long);
   ~verifyable_object ();
d174 2
a175 2
    pthread_attr ();
   ~pthread_attr ();
d203 2
a204 2
    pthread ();
   ~pthread ();
d207 1
a207 2
    DWORD thread_id;

a212 1

d227 2
a228 2
    pthread_mutex (pthread_mutexattr *);
   ~pthread_mutex ();
d239 2
a240 2
    pthread_key ();
   ~pthread_key ();
d248 2
a249 2
    pthread_condattr ();
   ~pthread_condattr ();
d263 2
a264 2
    pthread_cond (pthread_condattr *);
   ~pthread_cond ();
d277 2
a278 2
    semaphore (int, unsigned int);
   ~semaphore ();
d308 2
a309 3
    MTinterface ():reent_index (0), indexallocated (0)
  {
  }
a314 1

a387 1

@


1.11
log
@* exceptions.cc (interruptible): Update debugging output.
(setup_handler): Ensure that wait_sig loop wakes up when we punt on sending a
signal.
* poll.cc (poll): Add signal guard here.
@
text
@d4 1
d7 2
a8 1

a21 4
#define LOCK_THREAD_LIST 5
#define LOCK_MUTEX_LIST  6
#define LOCK_SEM_LIST    7
#define LOCK_COND_LIST   8
d42 16
a57 1
#include <pthread.h>
d63 2
a64 1
extern "C" {
d66 2
a67 2
struct _winsup_t
{
d71 4
a74 4
  struct group _grp;
  char *_namearray[2];
  char _linebuf[100];
  int _grp_pos;
d77 1
a77 1
  unsigned _rarg;
d80 2
a81 2
  int _dl_error;
  char _dl_buffer[256];
d84 4
a87 4
  struct passwd _res;
  char _tmpbuf[100];
  char _pass[_PASSWORD_LEN];
  int _pw_pos;
d90 2
a91 2
  struct mntent _ret;
  int _iteration;
d94 1
a94 1
  char _strerror_buf[20];
d97 4
a100 4
  char _dacl_buf[1024];
  char _sacl_buf[1024];
  char _ownr_buf[1024];
  char _grp_buf[1024];
d103 4
a106 4
  char *_process_ident;
  int _process_logopt;
  int _process_facility;
  int _process_logmask;
d109 4
a112 4
  char _b[20];
  struct tm _localtime_buf;
  char _buf1[33];
  char _buf2[33];
d115 2
a116 2
  char _username[MAX_USER_NAME];
};
d119 11
a129 10
struct __reent_t
{
  struct _reent *_clib;
  struct _winsup_t *_winsup;
};

_reent *_reent_clib ();
_winsup_t *_reent_winsup ();
void SetResourceLock (int, int, const char *) __attribute__ ((regparm(3)));
void ReleaseResourceLock (int, int, const char *) __attribute__ ((regparm(3)));
d132 1
a132 1
void AssertResourceOwner (int, int);
d144 3
a146 1
  ResourceLocks () {};
d154 1
a154 1
  private:
d159 13
d173 3
a175 1
#define MT_MAX_ITEMS 128
d177 1
a177 1
// thread classes\lists
d179 1
a179 1
class MTitem
d181 6
a186 8
  public:
  HANDLE win32_obj_id;
  UINT return_value;
  bool used;
  char joinable;       // for thread only
  bool HandleOke () {return win32_obj_id;}
  virtual void Destroy ();
  virtual int Id () {return (int) win32_obj_id;}
d189 1
a189 1
class ThreadItem: public MTitem
d192 3
a194 2
  pthread_attr_t attr;
  TFD (function);
d198 9
a206 2
  DWORD thread_id;
  DWORD GetThreadId () {return thread_id;}
d212 8
d222 1
a222 1
class MutexItem: public MTitem
d225 11
d239 3
d244 13
a256 1
class SemaphoreItem: public MTitem
d260 3
a262 3
  int Wait ();
  int Post ();
  int TryWait ();
d265 1
a265 1
class CondItem: public MTitem
d270 2
a271 2
  MutexItem *mutexitem;
  int Wait ();
d273 5
a277 2
  int BroadCast ();
  int Signal ();
d280 2
a281 1
typedef struct
d283 21
a303 3
  MTitem *items[MT_MAX_ITEMS];
  int index;
} MTList;
d310 3
a312 1
  DWORD thread_key;
d317 1
a317 1
  ThreadItem mainthread;
d321 3
a323 31
  void ReleaseItem (MTitem *);

  // Thread functions
  ThreadItem *CreateThread (pthread_t *, TFD (func), void *, pthread_attr_t);
  ThreadItem *GetCallingThread ();
  ThreadItem *GetThread (pthread_t *);

  // Mutex functions
  MutexItem *CreateMutex (pthread_mutex_t *);
  MutexItem *GetMutex (pthread_mutex_t *);

  // Semaphore functions
  SemaphoreItem *CreateSemaphore (sem_t *, int, int);
  SemaphoreItem *GetSemaphore (sem_t * t);

  // Condition functions
  CondItem *CreateCond (pthread_cond_t *, const pthread_condattr_t *);
  CondItem *GetCond (pthread_cond_t *);

private:
  // General Administration
  MTitem * Find (void *, int (*compare) (void *, void *), int &, MTList *);
  MTitem *GetItem (int, MTList *);
  MTitem *SetItem (int, MTitem *, MTList *);
  int Find (MTitem &, MTList *);
  int FindNextUnused (MTList *);

  MTList threadlist;
  MTList mutexlist;
  MTList semalist;
  MTList condlist;
d330 1
a330 1
void *thread_init_wrapper (void *);
d333 8
a340 5
int __pthread_create (pthread_t * thread, const pthread_attr_t * attr, TFD (start_routine), void *arg);
int __pthread_attr_init (pthread_attr_t * attr);
int __pthread_attr_destroy (pthread_attr_t * attr);
int __pthread_attr_setstacksize (pthread_attr_t * attr, size_t size);
int __pthread_attr_getstacksize (pthread_attr_t * attr, size_t * size);
d347 3
a349 3
int __pthread_exit (void *value_ptr);
int __pthread_join(pthread_t *thread, void **return_val);
int __pthread_detach(pthread_t *thread);
d353 2
a354 2
int __pthread_suspend(pthread_t *thread);
int __pthread_continue(pthread_t *thread);
d356 1
a356 1
unsigned long __pthread_getsequence_np (pthread_t * thread);
d359 4
a362 4
int __pthread_key_create (pthread_key_t * key);
int __pthread_key_delete (pthread_key_t * key);
int __pthread_setspecific (pthread_key_t * key, const void *value);
void *__pthread_getspecific (pthread_key_t * key);
d365 14
a378 10
int __pthread_cond_destroy(pthread_cond_t *cond);
int __pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);
int __pthread_cond_signal(pthread_cond_t *cond);
int __pthread_cond_broadcast(pthread_cond_t *cond);
int __pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
int __pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int __pthread_condattr_init (pthread_condattr_t * condattr);
int __pthread_condattr_destroy (pthread_condattr_t * condattr);
int __pthread_condattr_getpshared (const pthread_condattr_t *attr, int *pshared);
int __pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared);
d381 3
a383 2
int __pthread_kill (pthread_t * thread, int sig);
int __pthread_sigmask (int operation, const sigset_t * set, sigset_t * old_set);
d386 2
a387 2
pthread_t __pthread_self ();
int __pthread_equal (pthread_t * t1, pthread_t * t2);
d391 5
a395 5
int __pthread_mutex_init (pthread_mutex_t *, const pthread_mutexattr_t *);
int __pthread_mutex_lock (pthread_mutex_t *);
int __pthread_mutex_trylock (pthread_mutex_t *);
int __pthread_mutex_unlock (pthread_mutex_t *);
int __pthread_mutex_destroy (pthread_mutex_t *);
d398 5
a402 5
int __sem_init (sem_t * sem, int pshared, unsigned int value);
int __sem_destroy (sem_t * sem);
int __sem_wait (sem_t * sem);
int __sem_trywait (sem_t * sem);
int __sem_post (sem_t * sem);
@


1.10
log
@* external.cc (fillout_pinfo): Match windows pid, as well as cygwin pid when
passed in pid.  Don't prematurely break when searching for a pid.
* thread.h (_winsup_t): Eliminate unneeded field.
@
text
@d241 1
a241 1
  CondItem *CreateCond (pthread_cond_t *, const pthread_condattr_t *); 
@


1.9
log
@* cygwin.din: Export the new functions.
* pthread.cc (pthread_cond_*): Add wrapper functions that call __pthread_cond*
functions.
* thread.cc (__pthread_cond_*): Implement the pthread_cond* functions.
* thread.h: Add new class entries and prototypes for __pthread_cond* functions.
* include/pthread.h: user land header prototypes for pthread_cond* functions
and related defines.
@
text
@a63 1
  char _my_title_buf[TITLESIZE + 1];
@


1.8
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d23 1
d194 11
d241 4
d256 1
d294 11
@


1.7
log
@* exceptions.cc (set_console_handler): Don't allocate
console_handler_thread_waiter.  It is obsolete.
(ctrl_c_handler): Don't use console_handler_thread_waiter.
* path.cc (hash_path_name): Fix handling of relative names.  Make case
insensitive.
* path.h (suffix_info): Use initializers.
* pinfo.h (_pinfo): Avoid initializers for null case.
* resource.cc (fill_rusage): Zero rest of rusage structure.
* security.cc (set_process_privileges): Don't reopen parent process.  Just use
hMainProc.
* signal.cc (signal): Track when a signal handler has been used.
(sigaction): Ditto.
* sigproc.cc (pchildren): Use default initializer.
(zombies): Ditto.
(sigproc_terminate): Avoid closing handles that will be closed on exit anyway.
(wait_sig): Send signal to "parent" on EXECing, not FORKing.
(wait_subproc): Send SIGCHLD here rather than in proc_wait to avoid potential
muto conflicts.
* sigproc.h (sigthread): Don't initialize to zero.  It's the default.
* spawn.cc (spawn_guts): Fill in resources from exec parent prior to
termination.
* sync.h (muto): Don't initialize to zero.
* syscalls.cc (close_all_files): Use one lock around entire loop and call
fhandler close/release stuff directly.
(_read): Don't use ready_for_read if there are not signal handlers active.
* dcrt0.cc (dll_crt0_1): Fix display of "title".
(do_exit): Use pinfo exit method to exit.
(__api_fatal): Ditto.
* exceptions.cc (signal_exit): Ditto.
* fork.cc (fork_child): Remove debugging stuff.  Use pinfo_fixup_after fork in
place of exec_fixup_after_fork.
* pinfo.cc (pinfo_fixup_after_fork): New method.
(pinfo_fixup_in_spawned_child): Ditto.
(_pinfo::exit): New method.
(_pinfo::init): Remove recursion.  Detect pathological case where pinfo
structure already exists for new pid.
* pinfo.h (_pinfo): Reorganize slightly.  Add new method and new function
declarations.
* sigproc.cc (proc_exists): Previous simplification was a little to simple.
Try harder to detect if a process exists.
(proc_terminate): Use PID_EXITED setting to determine if process is still
around.
(WFSO): Remove debugging statement.
(WFMO): Ditto.
* spawn.cc (exec_fixup_after_fork): Eliminate.
(spawn_guts): Always set old_title to NULL.  Is it really needed?  Move
hexec_proc to pinfo.cc.  Call pinfo_fixup_in_spawned_child to eliminate handle
link after a spawn.
* include/sys/cygwin.h: Remove PID_NOT_IN_USE.  Add PID_EXITED.
@
text
@d113 2
a114 2
void SetResourceLock (int, int, const char *);
void ReleaseResourceLock (int, int, const char *);
d212 1
a212 3
  void Init0 ();
  void Init1 ();
  void ClearReent ();
@


1.6
log
@* spawn.cc (av::dup_maybe): Make function void rather than void *.
* environ.cc (environ_init): Remember to reparse CYGWIN if envp is
supplied.
* heap.cc (_sbrk): Remember frame for signal handling.
* syscalls.cc (read_handler): Eliminate.
(_read): Move read_handler code here.  Reorganize for one path through
'ready_for_read'.
@
text
@d32 1
a32 1
#define AssertResourceOwner(i,ii)
d129 4
a132 4
ResourceLocks ():inited (false) {};
LPCRITICAL_SECTION Lock (int);
void Init ();
void Delete ();
d134 2
a135 2
DWORD owner;
DWORD count;
d137 3
a139 3
private:
CRITICAL_SECTION lock;
bool inited;
d149 8
a156 8
public:
HANDLE win32_obj_id;
UINT return_value;
bool used;
char joinable;       // for thread only
bool HandleOke () {return win32_obj_id;}
virtual void Destroy ();
virtual int Id () {return (int) win32_obj_id;}
d159 1
a159 1
class ThreadItem:public MTitem
d162 12
a173 12
pthread_attr_t attr;
TFD (function);
void *arg;
void *return_ptr;
bool suspended;
DWORD thread_id;
DWORD GetThreadId () {return thread_id;}

/* signal handling */
struct sigaction *sigs;
sigset_t *sigmask;
LONG *sigtodo;
d176 1
a176 1
class MutexItem:public MTitem
d179 3
a181 3
int Lock ();
int TryLock ();
int UnLock ();
d184 1
a184 1
class SemaphoreItem:public MTitem
d187 4
a190 4
int shared;
int Wait ();
int Post ();
int TryWait ();
d196 3
a198 4
MTitem *items[MT_MAX_ITEMS];
int index;
}
MTList;
d203 27
a229 27
// General
DWORD reent_index;
DWORD thread_key;

// Used for main thread data, and sigproc thread
struct __reent_t reents;
struct _winsup_t winsup_reent;
ThreadItem mainthread;

void Init0 ();
void Init1 ();
void ClearReent ();

void ReleaseItem (MTitem *);

// Thread functions
ThreadItem *CreateThread (pthread_t *, TFD (func), void *, pthread_attr_t);
ThreadItem *GetCallingThread ();
ThreadItem *GetThread (pthread_t *);

// Mutex functions
MutexItem *CreateMutex (pthread_mutex_t *);
MutexItem *GetMutex (pthread_mutex_t *);

// Semaphore functions
SemaphoreItem *CreateSemaphore (sem_t *, int, int);
SemaphoreItem *GetSemaphore (sem_t * t);
d232 10
a241 10
// General Administration
MTitem * Find (void *, int (*compare) (void *, void *), int &, MTList *);
MTitem *GetItem (int, MTList *);
MTitem *SetItem (int, MTitem *, MTList *);
int Find (MTitem &, MTList *);
int FindNextUnused (MTList *);

MTList threadlist;
MTList mutexlist;
MTList semalist;
@


1.5
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d154 1
a154 1
bool HandleOke () {return win32_obj_id;};
d156 1
a156 1
virtual int Id () {return (int) win32_obj_id;};
d168 1
a168 1
DWORD GetThreadId () {return thread_id;};
@


1.4
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@a76 3
  char *_cwd_win32;
  char *_cwd_posix;
  unsigned long _cwd_hash;
d306 1
a306 1
#endif                          // MT_SAFE
d308 1
a308 1
#endif                          // _CYGNUS_THREADS_
@


1.3
log
@* thread.h: Shorten "current_directory" variables to "cwd_*" throughout.
* path.cc: Ditto.
(normalize_posix_path): Add some extra debugging info.
(chdir): Ditto.  Store chdir'ed posix and MS-DOS directory names in "cache"
here rather than trying to derive them later.
@
text
@d46 1
a46 1
#include <stdio.h>
a47 1
#include <time.h>
@


1.2
log
@* exceptions.cc (interruptible): Change method for determining if something is
interruptible.
(call_handler): Avoid suspending a thread if it owns a mutex.  Only set
signal_arrived if the thread was actually interrupted.
(events_init): Initialize module information needed by interruptible().
(sigdelayed): Don't call sig_dispatch_pending since it could screw up
* init.cc (dll_entry): Record module handle of main for use by interruptible().
(proc_subproc): Reorganize handling of terminated child so that the bulk of the
processing comes from the signal thread.
(wait_sig): Force processing of waiting threads if SIGCHLD is not processed.
* sync.cc (muto::release): Set tid == 0 after lock is released or signal
processor will be confused.
@
text
@d78 3
a80 3
  char *_current_directory_name;
  char *_current_directory_posix_name;
  unsigned long _current_directory_hash;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright 1998, 1999 Cygnus Solutions.
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
