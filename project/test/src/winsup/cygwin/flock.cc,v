head	1.63;
access;
symbols
	cygwin-1_7_35-release:1.63
	cygwin-1_7_34-release:1.62
	cygwin-1_7_33-release:1.58.2.3
	cygwin-1_7_32-release:1.58.2.2
	cygwin-1_7_31-release:1.58.2.2
	cygwin-1_7_30-release:1.58.2.1
	cygwin-1_7_29-release:1.58.2.1
	cygwin-1_7_29-release-branchpoint:1.58.0.2
	cygwin-pre-user-db:1.58
	cygwin-1_7_28-release:1.58
	cygwin-1_7_27-release:1.58
	cygwin-1_7_26-release:1.58
	cygwin-1_7_25-release:1.56
	cygwin-1_7_24-release:1.55
	cygwin-1_7_23-release:1.55
	cygwin-1_7_22-release:1.55
	cygwin-1_7_21-release:1.55
	cygwin-1_7_20-release:1.55
	cygwin-1_7_19-release:1.55
	cygwin-64bit-postmerge:1.53
	cygwin-64bit-premerge-branch:1.52.0.2
	cygwin-64bit-premerge:1.52
	cygwin-1_7_18-release:1.52
	post-ptmalloc3:1.51.2.2
	pre-ptmalloc3:1.51.2.2
	cygwin-1_7_17-release:1.52
	cygwin-64bit-branch:1.51.0.2
	cygwin-1_7_16-release:1.49
	cygwin-1_7_15-release:1.46
	cygwin-1_7_14_2-release:1.46
	cygwin-1_7_14-release:1.46
	cygwin-1_7_12-release:1.46
	cygwin-1_7_11-release:1.43
	cygwin-1_7_10-release:1.40
	signal-rewrite:1.35.0.2
	pre-notty:1.35
	cygwin-1_7_9-release:1.29
	cv-post-1_7_9:1.29.0.2
	cygwin-1_7_8-release:1.29
	cygwin-1_7_7-release:1.28
	cygwin-1_7_5-release:1.26
	cygwin-1_7_4-release:1.26
	cygwin-1_7_3-release:1.26
	cygwin-1_7_2-release:1.26
	fifo_doover3:1.26.0.2
	cygwin-1_7_1-release:1.25
	prefifo:1.24
	cv-branch-2:1.21.0.2
	pre-ripout-set_console_state_for_spawn:1.14
	EOL_registry_mounts:1.11
	preoverlapped:1.2
	drop_9x_support_start:1.2
	cr-0x5f1:1.2.0.18
	cv-branch:1.2.0.16
	pre-ptymaster-archetype:1.2
	cr-0x3b58:1.2.0.14
	cr-0x5ef:1.2.0.12
	after-mmap-privanon-noreserve:1.2
	after-mmap-revamp:1.2
	before-mmap-revamp:1.2
	cgf-more-exit-sync:1.2
	post_wait_sig_exit:1.2
	pre_wait_sig_exit:1.2
	reparent-point:1.2
	noreparent:1.2.0.10
	cr-0x5e6:1.2.0.8
	cr-0x9e:1.2.0.6
	cr-0x9d:1.2.0.4
	cgf-deleteme:1.2.0.2;
locks; strict;
comment	@// @;


1.63
date	2015.02.11.21.45.47;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2014.12.02.15.39.57;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2014.08.22.09.21.30;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2014.05.20.14.54.06;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2014.02.10.10.45.51;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2013.10.25.18.40.57;	author corinna;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2013.10.24.09.41.17;	author corinna;	state Exp;
branches;
next	1.56;

1.56
date	2013.08.23.20.40.27;	author corinna;	state Exp;
branches;
next	1.55;

1.55
date	2013.06.04.10.24.42;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2013.06.02.10.22.14;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2012.08.16.23.34.44;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2012.07.23.04.36.48;	author cgf;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2012.07.21.22.58.19;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2012.06.28.19.25.22;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2012.06.19.00.38.02;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2012.06.19.00.31.15;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2012.03.02.17.20.11;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2012.03.02.17.07.17;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2012.02.26.12.34.17;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2012.02.20.14.08.37;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2012.02.15.14.43.07;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2012.02.14.13.55.45;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2011.12.17.23.39.46;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2011.08.31.16.35.19;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2011.08.29.13.50.25;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2011.08.27.20.01.29;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.06.05.02.11;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2011.05.01.17.42.41;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.30.16.34.48;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.29.10.38.11;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.28.12.13.41;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.28.09.30.36;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2010.09.10.14.53.44;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.22.14.53.05;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.21.19.55.12;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.18.20.32.04;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.18.20.05.46;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.22.15.46.36;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.14.17.37.42;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.30.21.18.43;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.20.17.13.19;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.17.13.29.08;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.13.09.33.55;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.12.18.30.29;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.26.17.21.03;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.29.17.03.49;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.21.12.46.57;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.18.20.13.37;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.02.10.53.55;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.01.10.22.33;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.31.18.03.25;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.28.12.36.19;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.27.20.03.32;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.24.20.11.55;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2008.03.24.15.36.17;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2008.03.24.15.12.24;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2008.03.24.14.48.58;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.03.09.55.42;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.30.10.43.04;	author corinna;	state Exp;
branches;
next	;

1.58.2.1
date	2014.02.19.18.39.45;	author cgf;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2014.07.16.09.54.55;	author corinna;	state Exp;
branches;
next	1.58.2.3;

1.58.2.3
date	2014.11.13.12.53.02;	author corinna;	state Exp;
branches;
next	;

1.51.2.1
date	2012.08.13.20.04.34;	author corinna;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2012.12.10.11.45.49;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.63
log
@	* flock.cc (fhandler_base::lock): Convert accidental system_printf to
	debug_printf in case of non-matching file modes.  Clear up debug output.
@
text
@/* flock.cc.  NT specific implementation of advisory file locking.

   Copyright 2003, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

   This file is part of Cygwin.

   This software is a copyrighted work licensed under the terms of the
   Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
   details. */

/* The basic mechanism as well as the datastructures used in the below
   implementation are taken from the FreeBSD repository on 2008-03-18.
   The essential code of the lf_XXX functions has been taken from the
   module src/sys/kern/kern_lockf.c.  It has been adapted to use NT
   global namespace subdirs and event objects for synchronization
   purposes.

   So, the following copyright applies to most of the code in the lf_XXX
   functions.

 * Copyright (c) 1982, 1986, 1989, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Scooter Morris at Genentech Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)ufs_lockf.c 8.3 (Berkeley) 1/6/94
*/

/*
 * The flock() function is based upon source taken from the Red Hat
 * implementation used in their imap-2002d SRPM.
 *
 * $RH: flock.c,v 1.2 2000/08/23 17:07:00 nalin Exp $
 */

/* The lockf function is based upon FreeBSD sources with the following
 * copyright.
 */
/*
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Klaus Klein.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "winsup.h"
#include <assert.h>
#include <sys/file.h>
#include <unistd.h>
#include <stdlib.h>
#include "cygerrno.h"
#include "security.h"
#include "shared_info.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "pinfo.h"
#include "sigproc.h"
#include "cygtls.h"
#include "tls_pbuf.h"
#include "miscfuncs.h"
#include "ntdll.h"
#include <sys/queue.h>
#include <wchar.h>

#define F_WAIT 0x10	/* Wait until lock is granted */
#define F_FLOCK 0x20	/* Use flock(2) semantics for lock */
#define F_POSIX	0x40	/* Use POSIX semantics for lock */

#ifndef OFF_MAX
#define OFF_MAX LLONG_MAX
#endif

static NO_COPY muto lockf_guard;

#define INODE_LIST_LOCK()	(lockf_guard.init ("lockf_guard")->acquire ())
#define INODE_LIST_UNLOCK()	(lockf_guard.release ())

#define LOCK_DIR_NAME_FMT	L"flock-%08x-%016X"
#define LOCK_DIR_NAME_LEN	31	/* Length of the resulting name */
#define LOCK_DIR_NAME_DEV_OFF	 6	/* Offset to device number */
#define LOCK_DIR_NAME_INO_OFF	15	/* Offset to inode number */

/* Don't change format without also changing lockf_t::from_obj_name! */
#define LOCK_OBJ_NAME_FMT	L"%02x-%01x-%016X-%016X-%016X-%08x-%04x"
#define LOCK_OBJ_NAME_LEN	69	/* Length of the resulting name */

#define FLOCK_INODE_DIR_ACCESS	(DIRECTORY_QUERY \
				 | DIRECTORY_TRAVERSE \
				 | DIRECTORY_CREATE_OBJECT \
				 | READ_CONTROL)

#define FLOCK_EVENT_ACCESS	(EVENT_QUERY_STATE \
				 | SYNCHRONIZE \
				 | READ_CONTROL)

/* This function takes the own process security descriptor DACL and adds
   SYNCHRONIZE permissions for everyone.  This allows all processes
   to wait for this process to die when blocking in a F_SETLKW on a lock
   which is hold by this process. */
static void
allow_others_to_sync ()
{
  static NO_COPY bool done;

  if (done)
    return;

  NTSTATUS status;
  PACL dacl;
  LPVOID ace;
  ULONG len;

  /* Get this process DACL.  We use a rather small stack buffer here which
     should be more than sufficient for process ACLs.  Can't use tls functions
     at this point because this gets called during initialization when the tls
     is not really available.  */
#define MAX_PROCESS_SD_SIZE	3072
  PISECURITY_DESCRIPTOR sd = (PISECURITY_DESCRIPTOR) alloca (MAX_PROCESS_SD_SIZE);
  status = NtQuerySecurityObject (NtCurrentProcess (),
				  DACL_SECURITY_INFORMATION, sd,
				  MAX_PROCESS_SD_SIZE, &len);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtQuerySecurityObject: %y", status);
      return;
    }
  /* Create a valid dacl pointer and set its size to be as big as
     there's room in the temporary buffer.  Note that the descriptor
     is in self-relative format. */
  BOOLEAN present, defaulted;
  RtlGetDaclSecurityDescriptor (sd, &present, &dacl, &defaulted);
  if (!present) /* If so, dacl has undefined value. */
    {
      dacl = (PACL) (sd + 1);
      RtlCreateAcl (dacl, MAX_PROCESS_SD_SIZE - sizeof *sd, ACL_REVISION);
    }
  else if (dacl == NULL) /* Everyone has all access anyway */
    {
      done = true;
      return;
    }
  else
    {
      dacl->AclSize = MAX_PROCESS_SD_SIZE - ((PBYTE) dacl - (PBYTE) sd);
    }
  /* Allow everyone to SYNCHRONIZE with this process. */
  status = RtlAddAccessAllowedAce (dacl, ACL_REVISION, SYNCHRONIZE,
				   well_known_world_sid);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("RtlAddAccessAllowedAce: %y", status);
      return;
    }
  /* Set the size of the DACL correctly. */
  status = RtlFirstFreeAce (dacl, &ace);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("RtlFirstFreeAce: %y", status);
      return;
    }
  dacl->AclSize = (char *) ace - (char *) dacl;
  /* Write the DACL back. */
  status = NtSetSecurityObject (NtCurrentProcess (), DACL_SECURITY_INFORMATION, sd);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtSetSecurityObject: %y", status);
      return;
    }
  done = true;
}

/* Get the handle count of an object. */
static ULONG
get_obj_handle_count (HANDLE h)
{
  OBJECT_BASIC_INFORMATION obi;
  NTSTATUS status;
  ULONG hdl_cnt = 0;

  status = NtQueryObject (h, ObjectBasicInformation, &obi, sizeof obi, NULL);
  if (!NT_SUCCESS (status))
    debug_printf ("NtQueryObject: %y", status);
  else
    hdl_cnt = obi.HandleCount;
  return hdl_cnt;
}

/* Helper struct to construct a local OBJECT_ATTRIBUTES on the stack. */
struct lockfattr_t
{
  OBJECT_ATTRIBUTES attr;
  UNICODE_STRING uname;
  WCHAR name[LOCK_OBJ_NAME_LEN + 1];
};

/* Per lock class. */
class lockf_t
{
  public:
    uint16_t	    lf_flags; /* Semantics: F_POSIX, F_FLOCK, F_WAIT */
    uint16_t	    lf_type;  /* Lock type: F_RDLCK, F_WRLCK */
    off_t	    lf_start; /* Byte # of the start of the lock */
    off_t	    lf_end;   /* Byte # of the end of the lock (-1=EOF) */
    int64_t         lf_id;    /* Cygwin PID for POSIX locks, a unique id per
				 file table entry for BSD flock locks. */
    DWORD	    lf_wid;   /* Win PID of the resource holding the lock */
    uint16_t	    lf_ver;   /* Version number of the lock.  If a released
				 lock event yet exists because another process
				 is still waiting for it, we use the version
				 field to distinguish old from new locks. */
    class lockf_t **lf_head;  /* Back pointer to the head of the lockf_t list */
    class inode_t  *lf_inode; /* Back pointer to the inode_t */
    class lockf_t  *lf_next;  /* Pointer to the next lock on this inode_t */
    HANDLE	    lf_obj;   /* Handle to the lock event object. */

    lockf_t ()
    : lf_flags (0), lf_type (0), lf_start (0), lf_end (0), lf_id (0),
      lf_wid (0), lf_ver (0), lf_head (NULL), lf_inode (NULL),
      lf_next (NULL), lf_obj (NULL)
    {}
    lockf_t (class inode_t *node, class lockf_t **head,
	     short flags, short type, off_t start, off_t end,
	     long long id, DWORD wid, uint16_t ver)
    : lf_flags (flags), lf_type (type), lf_start (start), lf_end (end),
      lf_id (id), lf_wid (wid), lf_ver (ver), lf_head (head), lf_inode (node),
      lf_next (NULL), lf_obj (NULL)
    {}
    ~lockf_t ();

    bool from_obj_name (class inode_t *node, class lockf_t **head,
			const wchar_t *name);

    /* Used to create all locks list in a given TLS buffer. */
    void *operator new (size_t size, void *p)
    { return p; }
    /* Used to store own lock list in the cygheap. */
    void *operator new (size_t size)
    { return cmalloc (HEAP_FHANDLER, sizeof (lockf_t)); }
    /* Never call on node->i_all_lf! */
    void operator delete (void *p)
    { cfree (p); }

    POBJECT_ATTRIBUTES create_lock_obj_attr (lockfattr_t *attr,
					     ULONG flags);

    void create_lock_obj ();
    bool open_lock_obj ();
    void close_lock_obj () { NtClose (lf_obj); lf_obj = NULL; }
    void del_lock_obj (HANDLE fhdl, bool signal = false);
};

/* Per inode_t class */
class inode_t
{
  friend class lockf_t;

  public:
    LIST_ENTRY (inode_t) i_next;
    lockf_t		*i_lockf;  /* List of locks of this process. */
    lockf_t		*i_all_lf; /* Temp list of all locks for this file. */

    dev_t		 i_dev;    /* Device ID */
    ino_t		 i_ino;    /* inode number */

  private:
    HANDLE		 i_dir;
    HANDLE		 i_mtx;
    uint32_t		 i_cnt;    /* # of threads referencing this instance. */

  public:
    inode_t (dev_t dev, ino_t ino);
    ~inode_t ();

    void *operator new (size_t size)
    { return cmalloc (HEAP_FHANDLER, sizeof (inode_t)); }
    void operator delete (void *p)
    { cfree (p); }

    static inode_t *get (dev_t dev, ino_t ino,
			 bool create_if_missing, bool lock);

    void LOCK () { WaitForSingleObject (i_mtx, INFINITE); }
    void UNLOCK () { ReleaseMutex (i_mtx); }

    void use () { ++i_cnt; }
    void unuse () { if (i_cnt > 0) --i_cnt; }
    bool inuse () { return i_cnt > 0; }
    void notused () { i_cnt = 0; }

    void unlock_and_remove_if_unused ();

    lockf_t *get_all_locks_list ();

    bool del_my_locks (long long id, HANDLE fhdl);
};

inode_t::~inode_t ()
{
  lockf_t *lock, *n_lock;
  for (lock = i_lockf; lock && (n_lock = lock->lf_next, 1); lock = n_lock)
    delete lock;
  NtClose (i_mtx);
  NtClose (i_dir);
}

void
inode_t::unlock_and_remove_if_unused ()
{
  UNLOCK ();
  INODE_LIST_LOCK ();
  unuse ();
  if (i_lockf == NULL && !inuse ())
    {
      LIST_REMOVE (this, i_next);
      delete this;
    }
  INODE_LIST_UNLOCK ();
}

bool
inode_t::del_my_locks (long long id, HANDLE fhdl)
{
  lockf_t *lock, *n_lock;
  lockf_t **prev = &i_lockf;
  for (lock = *prev; lock && (n_lock = lock->lf_next, 1); lock = n_lock)
    {
      if (lock->lf_flags & F_POSIX)
	{
	  /* Delete all POSIX locks. */
	  *prev = n_lock;
	  /* When called during fork, the POSIX lock must get deleted but
	     *not* signalled.  The lock is still active and locked in the
	     parent.  So in case of fork, we call close_lock_obj explicitely,
	     since del_lock_obj is called from the destructor. */
	  if (!id)
	    lock->close_lock_obj ();
	  delete lock;
	}
      else if (id && lock->lf_id == id)
	{
	  int cnt = 0;
	  cygheap_fdenum cfd (true);
	  while (cfd.next () >= 0)
	    if (cfd->get_unique_id () == lock->lf_id && ++cnt > 1)
	      break;
	  /* Delete BSD flock lock when no other fd in this process references
	     it anymore. */
	  if (cnt <= 1)
	    {
	      *prev = n_lock;
	      lock->del_lock_obj (fhdl);
	      delete lock;
	    }
	}
      else
	prev = &lock->lf_next;
    }
  return i_lockf == NULL;
}

/* Used to delete the locks on a file hold by this process.  Called from
   close(2) and fixup_after_fork, as well as from fixup_after_exec in
   case the close_on_exec flag is set.  The whole inode is deleted as
   soon as no lock exists on it anymore. */
void
fhandler_base::del_my_locks (del_lock_called_from from)
{
  inode_t *node = inode_t::get (get_dev (), get_ino (), false, true);
  if (node)
    {
      /* When we're called from fixup_after_exec, the fhandler is a
	 close-on-exec fhandler.  In this case our io handle is already
	 invalid.  We can't use it to test for the object reference count.
	 However, that shouldn't be necessary for the following reason.
	 After exec, there are no threads in the current process waiting for
	 the lock.  So, either we're the only process accessing the file table
	 entry and there are no threads which require signalling, or we have
	 a parent process still accessing the file object and signalling the
	 lock event would be premature. */
      node->del_my_locks (from == after_fork ? 0 : get_unique_id (),
			  from == after_exec ? NULL : get_handle ());
      node->unlock_and_remove_if_unused ();
    }
}

/* Called in an execed child.  The exec'ed process must allow SYNCHRONIZE
   access to everyone if at least one inode exists.
   The lock owner's Windows PID changed and all POSIX lock event objects
   have to be relabeled so that waiting processes know which process to
   wait on.  If the node has been abandoned due to close_on_exec on the
   referencing fhandlers, remove the inode entirely. */
void
fixup_lockf_after_exec (bool exec)
{
  inode_t *node, *next_node;

  INODE_LIST_LOCK ();
  if (LIST_FIRST (&cygheap->inode_list))
    allow_others_to_sync ();
  LIST_FOREACH_SAFE (node, &cygheap->inode_list, i_next, next_node)
    {
      node->notused ();
      int cnt = 0;
      cygheap_fdenum cfd (true);
      while (cfd.next () >= 0)
	if (cfd->get_dev () == node->i_dev
	    && cfd->get_ino () == node->i_ino
	    && ++cnt >= 1)
	  break;
      if (cnt == 0)
	{
	  LIST_REMOVE (node, i_next);
	  delete node;
	}
      else
	{
	  node->LOCK ();
	  lockf_t *lock, *n_lock;
	  lockf_t **prev = &node->i_lockf;
	  for (lock = *prev; lock && (n_lock = lock->lf_next, 1); lock = n_lock)
	    if (lock->lf_flags & F_POSIX)
	      {
		if (exec)
		  {
		    /* The parent called exec.  The lock is passed to the child.
		       Recreate lock object with changed ownership. */
		    lock->del_lock_obj (NULL);
		    lock->lf_wid = myself->dwProcessId;
		    lock->lf_ver = 0;
		    lock->create_lock_obj ();
		  }
		else
		  {
		    /* The parent called spawn.  The parent continues to hold
		       the POSIX lock, ownership is not passed to the child.
		       Give up the lock in the child. */
		    *prev = n_lock;
		    lock->close_lock_obj ();
		    delete lock;
		  }
	      }
	  node->UNLOCK ();
	}
    }
  INODE_LIST_UNLOCK ();
}

/* static method to return a pointer to the inode_t structure for a specific
   file.  The file is specified by the device and inode_t number.  If inode_t
   doesn't exist, create it. */
inode_t *
inode_t::get (dev_t dev, ino_t ino, bool create_if_missing, bool lock)
{
  inode_t *node;

  INODE_LIST_LOCK ();
  LIST_FOREACH (node, &cygheap->inode_list, i_next)
    if (node->i_dev == dev && node->i_ino == ino)
      break;
  if (!node && create_if_missing)
    {
      node = new inode_t (dev, ino);
      if (node)
	LIST_INSERT_HEAD (&cygheap->inode_list, node, i_next);
    }
  if (node)
    node->use ();
  INODE_LIST_UNLOCK ();
  if (node && lock)
    node->LOCK ();
  return node;
}

inode_t::inode_t (dev_t dev, ino_t ino)
: i_lockf (NULL), i_all_lf (NULL), i_dev (dev), i_ino (ino), i_cnt (0L)
{
  HANDLE parent_dir;
  WCHAR name[48];
  UNICODE_STRING uname;
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;

  parent_dir = get_shared_parent_dir ();
  /* Create a subdir which is named after the device and inode_t numbers
     of the given file, in hex notation. */
  int len = __small_swprintf (name, LOCK_DIR_NAME_FMT, dev, ino);
  RtlInitCountedUnicodeString (&uname, name, len * sizeof (WCHAR));
  InitializeObjectAttributes (&attr, &uname, OBJ_INHERIT | OBJ_OPENIF,
			      parent_dir, everyone_sd (FLOCK_INODE_DIR_ACCESS));
  status = NtCreateDirectoryObject (&i_dir, FLOCK_INODE_DIR_ACCESS, &attr);
  if (!NT_SUCCESS (status))
    api_fatal ("NtCreateDirectoryObject(inode): %y", status);
  /* Create a mutex object in the file specific dir, which is used for
     access synchronization on the dir and its objects. */
  InitializeObjectAttributes (&attr, &ro_u_mtx, OBJ_INHERIT | OBJ_OPENIF, i_dir,
			      everyone_sd (CYG_MUTANT_ACCESS));
  status = NtCreateMutant (&i_mtx, CYG_MUTANT_ACCESS, &attr, FALSE);
  if (!NT_SUCCESS (status))
    api_fatal ("NtCreateMutant(inode): %y", status);
}

/* Enumerate all lock event objects for this file and create a lockf_t
   list in the i_all_lf member.  This list is searched in lf_getblock
   for locks which potentially block our lock request. */

/* Number of lockf_t structs which fit in the temporary buffer. */
#define MAX_LOCKF_CNT	((intptr_t)((NT_MAX_PATH * sizeof (WCHAR)) \
				    / sizeof (lockf_t)))

bool
lockf_t::from_obj_name (inode_t *node, lockf_t **head, const wchar_t *name)
{
  wchar_t *endptr;

  /* "%02x-%01x-%016X-%016X-%016X-%08x-%04x",
     lf_flags, lf_type, lf_start, lf_end, lf_id, lf_wid, lf_ver */
  lf_flags = wcstol (name, &endptr, 16);
  if ((lf_flags & ~(F_FLOCK | F_POSIX)) != 0
      || ((lf_flags & (F_FLOCK | F_POSIX)) == (F_FLOCK | F_POSIX)))
    return false;
  lf_type = wcstol (endptr + 1, &endptr, 16);
  if ((lf_type != F_RDLCK && lf_type != F_WRLCK) || !endptr || *endptr != L'-')
    return false;
  lf_start = (off_t) wcstoull (endptr + 1, &endptr, 16);
  if (lf_start < 0 || !endptr || *endptr != L'-')
    return false;
  lf_end = (off_t) wcstoull (endptr + 1, &endptr, 16);
  if (lf_end < -1LL
      || (lf_end > 0 && lf_end < lf_start)
      || !endptr || *endptr != L'-')
    return false;
  lf_id = wcstoll (endptr + 1, &endptr, 16);
  if (!endptr || *endptr != L'-'
      || ((lf_flags & F_POSIX) && (lf_id < 1 || lf_id > UINT32_MAX)))
    return false;
  lf_wid = wcstoul (endptr + 1, &endptr, 16);
  if (!endptr || *endptr != L'-')
    return false;
  lf_ver = wcstoul (endptr + 1, &endptr, 16);
  if (endptr && *endptr != L'\0')
    return false;
  lf_head = head;
  lf_inode = node;
  lf_next = NULL;
  lf_obj = NULL;
  return true;
}

lockf_t *
inode_t::get_all_locks_list ()
{
  struct fdbi
  {
    DIRECTORY_BASIC_INFORMATION dbi;
    WCHAR buf[2][NAME_MAX + 1];
  } f;
  ULONG context;
  NTSTATUS status;
  lockf_t newlock, *lock = i_all_lf;

  for (BOOLEAN restart = TRUE;
       NT_SUCCESS (status = NtQueryDirectoryObject (i_dir, &f, sizeof f, TRUE,
						    restart, &context, NULL));
       restart = FALSE)
    {
      if (f.dbi.ObjectName.Length != LOCK_OBJ_NAME_LEN * sizeof (WCHAR))
	continue;
      f.dbi.ObjectName.Buffer[LOCK_OBJ_NAME_LEN] = L'\0';
      if (!newlock.from_obj_name (this, &i_all_lf, f.dbi.ObjectName.Buffer))
	continue;
      if (lock - i_all_lf >= MAX_LOCKF_CNT)
	{
	  system_printf ("Warning, can't handle more than %d locks per file.",
			 MAX_LOCKF_CNT);
	  break;
	}
      if (lock > i_all_lf)
	lock[-1].lf_next = lock;
      new (lock++) lockf_t (newlock);
    }
  /* If no lock has been found, return NULL. */
  if (lock == i_all_lf)
    return NULL;
  return i_all_lf;
}

/* Create the lock object name.  The name is constructed from the lock
   properties which identify it uniquely, all values in hex. */
POBJECT_ATTRIBUTES
lockf_t::create_lock_obj_attr (lockfattr_t *attr, ULONG flags)
{
  __small_swprintf (attr->name, LOCK_OBJ_NAME_FMT,
		    lf_flags & (F_POSIX | F_FLOCK), lf_type, lf_start, lf_end,
		    lf_id, lf_wid, lf_ver);
  RtlInitCountedUnicodeString (&attr->uname, attr->name,
			       LOCK_OBJ_NAME_LEN * sizeof (WCHAR));
  InitializeObjectAttributes (&attr->attr, &attr->uname, flags, lf_inode->i_dir,
			      everyone_sd (FLOCK_EVENT_ACCESS));
  return &attr->attr;
}

DWORD WINAPI
create_lock_in_parent (PVOID param)
{
  HANDLE lf_obj;
  ULONG size;
  OBJECT_NAME_INFORMATION *ntfn;
  NTSTATUS status;
  wchar_t *lockname, *inodename, *endptr;
  dev_t dev;
  ino_t ino;
  inode_t *node;
  lockf_t newlock, *lock;
  int cnt;

  /* param is the handle to the lock object, created by caller. */
  lf_obj = (HANDLE) param;
  /* Fetch object path from handle.  Typically the length of the path
     is 146 characters, starting with
     "\BaseNamedObject\cygwin-1S5-<16-hex-digits>\..." */
  size = sizeof (OBJECT_NAME_INFORMATION) + 256 * sizeof (WCHAR);
  ntfn = (OBJECT_NAME_INFORMATION *) alloca (size);
  memset (ntfn, 0, size);
  status = NtQueryObject (lf_obj, ObjectNameInformation, ntfn, size, &size);
  if (!NT_SUCCESS (status))
    goto err;
  ntfn->Name.Buffer[ntfn->Name.Length / sizeof (WCHAR)] = L'\0';
  /* Sanity check so that we don't peek into unchartered territory. */
  if (ntfn->Name.Length < LOCK_OBJ_NAME_LEN + LOCK_DIR_NAME_LEN + 1)
    goto err;
  /* The names have fixed size, so we know where the substrings start. */
  lockname = ntfn->Name.Buffer + ntfn->Name.Length / sizeof (WCHAR)
			       - LOCK_OBJ_NAME_LEN;
  inodename = lockname - LOCK_DIR_NAME_LEN - 1;
  dev = wcstoul (inodename + LOCK_DIR_NAME_DEV_OFF, &endptr, 16);
  if (*endptr != L'-')
    goto err;
  ino = wcstoull (inodename + LOCK_DIR_NAME_INO_OFF, &endptr, 16);
  if (*endptr != L'\\')
    goto err;
  if (!newlock.from_obj_name (NULL, NULL, lockname))
    goto err;
  /* Check if we have an open file handle with the same unique id. */
  {
    cnt = 0;
    cygheap_fdenum cfd (true);
    while (cfd.next () >= 0)
      if (cfd->get_unique_id () == newlock.lf_id && ++cnt > 0)
	break;
  }
  /* If not, close handle and return. */
  if (!cnt)
    {
      NtClose (lf_obj);
      return 0;
    }
  /* The handle gets created non-inheritable.  That's fine, unless the parent
     starts another process accessing this object.  So, after it's clear we
     have to store the handle for further use, make sure it gets inheritable
     by child processes. */
  if (!SetHandleInformation (lf_obj, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT))
    goto err;
  /* otherwise generate inode from directory name... */
  node = inode_t::get (dev, ino, true, false);
  /* ...and generate lock from object name. */
  lock = new lockf_t (newlock);
  lock->lf_inode = node;
  lock->lf_head = &node->i_lockf;
  lock->lf_next = node->i_lockf;
  lock->lf_obj = lf_obj;
  node->i_lockf = lock;
  node->unuse ();
  return 0;

err:
  system_printf ("Adding <%S> lock failed", &ntfn->Name);
  NtClose (lf_obj);
  return 1;
}

DWORD WINAPI
delete_lock_in_parent (PVOID param)
{
  inode_t *node, *next_node;
  lockf_t *lock, **prev;

  /* Scan list of all inodes, and reap stale BSD lock if lf_id matches.
     Remove inode if empty. */
  INODE_LIST_LOCK ();
  LIST_FOREACH_SAFE (node, &cygheap->inode_list, i_next, next_node)
    if (!node->inuse ())
      {
	for (prev = &node->i_lockf, lock = *prev; lock; lock = *prev)
	  {
	    if ((lock->lf_flags & F_FLOCK) && IsEventSignalled (lock->lf_obj))
	      {
		*prev = lock->lf_next;
		delete lock;
	      }
	    else
	      prev = &lock->lf_next;
	  }
	if (node->i_lockf == NULL)
	  {
	    LIST_REMOVE (node, i_next);
	    delete node;
	  }
      }
  INODE_LIST_UNLOCK ();
  return 0;
}

/* Create the lock event object in the file's subdir in the NT global
   namespace. */
void
lockf_t::create_lock_obj ()
{
  lockfattr_t attr;
  NTSTATUS status;

  do
    {
      status = NtCreateEvent (&lf_obj, CYG_EVENT_ACCESS,
			      create_lock_obj_attr (&attr, OBJ_INHERIT),
			      NotificationEvent, FALSE);
      if (!NT_SUCCESS (status))
	{
	  if (status != STATUS_OBJECT_NAME_COLLISION)
	    api_fatal ("NtCreateEvent(lock): %y", status);
	  /* If we get a STATUS_OBJECT_NAME_COLLISION, the event still exists
	     because some other process is waiting for it in lf_setlock.
	     If so, check the event's signal state.  If we can't open it, it
	     has been closed in the meantime, so just try again.  If we can
	     open it and the object is not signalled, it's surely a bug in the
	     code somewhere.  Otherwise, close the event and retry to create
	     a new event with another name. */
	  if (open_lock_obj ())
	    {
	      if (!IsEventSignalled (lf_obj))
		api_fatal ("NtCreateEvent(lock): %y", status);
	      close_lock_obj ();
	      /* Increment the lf_ver field until we have no collision. */
	      ++lf_ver;
	    }
	}
    }
  while (!NT_SUCCESS (status));
  /* For BSD locks, notify the parent process. */
  if (lf_flags & F_FLOCK)
    {
      HANDLE parent_proc, parent_thread, parent_lf_obj;

      pinfo p (myself->ppid);
      if (!p)	/* No access or not a Cygwin parent. */
      	return;

      parent_proc = OpenProcess (PROCESS_DUP_HANDLE
				 | PROCESS_CREATE_THREAD
				 | PROCESS_QUERY_INFORMATION
				 | PROCESS_VM_OPERATION
				 | PROCESS_VM_WRITE
				 | PROCESS_VM_READ,
				 FALSE, p->dwProcessId);
      if (!parent_proc)
	{
	  debug_printf ("OpenProcess (%u): %E", p->dwProcessId);
	  return;
	}
      if (!DuplicateHandle (GetCurrentProcess (), lf_obj, parent_proc,
			    &parent_lf_obj, TRUE, FALSE, DUPLICATE_SAME_ACCESS))
	debug_printf ("DuplicateHandle (lf_obj): %E");
      else
	{
	  parent_thread = CreateRemoteThread (parent_proc, NULL, 256 * 1024,
					      create_lock_in_parent,
					      parent_lf_obj,
					      STACK_SIZE_PARAM_IS_A_RESERVATION,
					      NULL);
	  if (!parent_thread)
	    {
	      debug_printf ("CreateRemoteThread: %E");
	      /* If thread didn't get started, close object handle in parent,
		 otherwise suffer handle leaks. */
	      DuplicateHandle (parent_proc, parent_lf_obj, parent_proc,
			       NULL, 0, FALSE, DUPLICATE_CLOSE_SOURCE);
	    }
	  else
	    {
	      /* Must wait to avoid race conditions. */
	      WaitForSingleObject (parent_thread, INFINITE);
	      CloseHandle (parent_thread);
	    }
	}
      CloseHandle (parent_proc);
    }
}

/* Open a lock event object for SYNCHRONIZE access (to wait for it). */
bool
lockf_t::open_lock_obj ()
{
  lockfattr_t attr;
  NTSTATUS status;

  status = NtOpenEvent (&lf_obj, FLOCK_EVENT_ACCESS,
			create_lock_obj_attr (&attr, 0));
  if (!NT_SUCCESS (status))
    {
      SetLastError (RtlNtStatusToDosError (status));
      lf_obj = NULL; /* Paranoia... */
    }
  return lf_obj != NULL;
}

/* Delete a lock event handle.  The important thing here is to signal it
   before closing the handle.  This way all threads waiting for this lock
   can wake up. */
void
lockf_t::del_lock_obj (HANDLE fhdl, bool signal)
{
  if (lf_obj)
    {
      /* Only signal the event if it's either a POSIX lock, or, in case of
	 BSD flock locks, if it's an explicit unlock or if the calling fhandler
	 holds the last reference to the file table entry.  The file table
	 entry in UNIX terms is equivalent to the FILE_OBJECT in Windows NT
	 terms.  It's what the handle/descriptor references when calling
	 CreateFile/open.  Calling DuplicateHandle/dup only creates a new
	 handle/descriptor to the same FILE_OBJECT/file table entry. */
      if ((lf_flags & F_POSIX) || signal
	  || (fhdl && get_obj_handle_count (fhdl) <= 1))
	{
	  NTSTATUS status = NtSetEvent (lf_obj, NULL);
	  if (!NT_SUCCESS (status))
	    system_printf ("NtSetEvent, %y", status);
	  /* For BSD locks, notify the parent process. */
	  if (lf_flags & F_FLOCK)
	    {
	      HANDLE parent_proc, parent_thread;

	      pinfo p (myself->ppid);
	      if (p && (parent_proc = OpenProcess (PROCESS_CREATE_THREAD
					     | PROCESS_QUERY_INFORMATION
					     | PROCESS_VM_OPERATION
					     | PROCESS_VM_WRITE
					     | PROCESS_VM_READ,
					     FALSE, p->dwProcessId)))
		{
		  parent_thread = CreateRemoteThread (parent_proc, NULL,
					      256 * 1024, delete_lock_in_parent,
					      NULL,
					      STACK_SIZE_PARAM_IS_A_RESERVATION,
					      NULL);
		  if (parent_thread)
		    {
		      /* Must wait to avoid race conditions. */
		      WaitForSingleObject (parent_thread, INFINITE);
		      CloseHandle (parent_thread);
		    }
		  CloseHandle (parent_proc);
		}
	    }
	}
      close_lock_obj ();
    }
}

lockf_t::~lockf_t ()
{
  del_lock_obj (NULL);
}

/*
 * This variable controls the maximum number of processes that will
 * be checked in doing deadlock detection.
 */
#ifndef __CYGWIN__
#define MAXDEPTH 50
static int maxlockdepth = MAXDEPTH;
#endif

#define NOLOCKF (struct lockf_t *)0
#define SELF    0x1
#define OTHERS  0x2
static int      lf_clearlock (lockf_t *, lockf_t **, HANDLE);
static int      lf_findoverlap (lockf_t *, lockf_t *, int, lockf_t ***, lockf_t **);
static lockf_t *lf_getblock (lockf_t *, inode_t *node);
static int      lf_getlock (lockf_t *, inode_t *, struct flock *);
static int      lf_setlock (lockf_t *, inode_t *, lockf_t **, HANDLE);
static void     lf_split (lockf_t *, lockf_t *, lockf_t **);
static void     lf_wakelock (lockf_t *, HANDLE);

/* This is the fcntl advisory lock implementation.  For the implementation
   of mandatory locks using the Windows mandatory locking functions, see the
   fhandler_disk_file::mand_lock method at the end of this file. */
int
fhandler_base::lock (int a_op, struct flock *fl)
{
  off_t start, end, oadd;
  int error = 0;

  short a_flags = fl->l_type & (F_POSIX | F_FLOCK);
  short type = fl->l_type & (F_RDLCK | F_WRLCK | F_UNLCK);

  if (!a_flags)
    a_flags = F_POSIX; /* default */

  /* FIXME: For BSD flock(2) we need a valid, per file table entry OS handle.
     Therefore we can't allow using flock(2) on nohandle devices and
     pre-Windows 8 console handles (recognized by their odd handle value). */
  if ((a_flags & F_FLOCK)
      && (nohandle () || (((uintptr_t) get_handle () & 0x3) == 0x3)))
    {
      set_errno (EINVAL);
      debug_printf ("BSD locking on nohandle and old-style console devices "
		    "not supported");
      return -1;
    }

  if (a_op == F_SETLKW)
    {
      a_op = F_SETLK;
      a_flags |= F_WAIT;
    }
  if (a_op == F_SETLK)
    switch (type)
      {
      case F_UNLCK:
	a_op = F_UNLCK;
	break;
      case F_RDLCK:
	/* flock semantics don't specify a requirement that the file has
	   been opened with a specific open mode, in contrast to POSIX locks
	   which require that a file is opened for reading to place a read
	   lock and opened for writing to place a write lock. */
	/* CV 2013-10-22: Test POSIX R/W mode flags rather than Windows R/W
	   access flags.  The reason is that POSIX mode flags are set for
	   all types of fhandlers, while Windows access flags are only set
	   for most of the actual Windows device backed fhandlers. */
	if ((a_flags & F_POSIX)
	    && ((get_flags () & O_ACCMODE) == O_WRONLY))
	  {
	    debug_printf ("request F_RDLCK on O_WRONLY file: EBADF");
	    set_errno (EBADF);
	    return -1;
	  }
	break;
      case F_WRLCK:
	/* See above comment. */
	if ((a_flags & F_POSIX)
	    && ((get_flags () & O_ACCMODE) == O_RDONLY))
	  {
	    debug_printf ("request F_WRLCK on O_RDONLY file: EBADF");
	    set_errno (EBADF);
	    return -1;
	  }
	break;
      default:
	set_errno (EINVAL);
	return -1;
      }

  /*
   * Convert the flock structure into a start and end.
   */
  switch (fl->l_whence)
    {
    case SEEK_SET:
      start = fl->l_start;
      break;

    case SEEK_CUR:
      if ((start = lseek (0, SEEK_CUR)) == ILLEGAL_SEEK)
	start = 0;
      break;

    case SEEK_END:
      if (get_device () != FH_FS)
      	start = 0;
      else
	{
	  NTSTATUS status;
	  IO_STATUS_BLOCK io;
	  FILE_STANDARD_INFORMATION fsi;

	  status = NtQueryInformationFile (get_handle (), &io, &fsi, sizeof fsi,
					   FileStandardInformation);
	  if (!NT_SUCCESS (status))
	    {
	      __seterrno_from_nt_status (status);
	      return -1;
	    }
	  if (fl->l_start > 0 && fsi.EndOfFile.QuadPart > OFF_MAX - fl->l_start)
	    {
	      set_errno (EOVERFLOW);
	      return -1;
	    }
	  start = fsi.EndOfFile.QuadPart + fl->l_start;
	}
      break;

    default:
      return (EINVAL);
    }
  if (start < 0)
    {
      set_errno (EINVAL);
      return -1;
    }
  if (fl->l_len < 0)
    {
      if (start == 0)
	{
	  set_errno (EINVAL);
	  return -1;
	}
      end = start - 1;
      start += fl->l_len;
      if (start < 0)
	{
	  set_errno (EINVAL);
	  return -1;
	}
    }
  else if (fl->l_len == 0)
    end = -1;
  else
    {
      oadd = fl->l_len - 1;
      if (oadd > OFF_MAX - start)
	{
	  set_errno (EOVERFLOW);
	  return -1;
	}
      end = start + oadd;
    }

restart:	/* Entry point after a restartable signal came in. */

  inode_t *node = inode_t::get (get_dev (), get_ino (), true, true);
  if (!node)
    {
      set_errno (ENOLCK);
      return -1;
    }

  /* Unlock the fd table which has been locked in fcntl_worker/lock_worker,
     otherwise a blocking F_SETLKW never wakes up on a signal. */
  cygheap->fdtab.unlock ();

  lockf_t **head = &node->i_lockf;

#if 0
  /*
   * Avoid the common case of unlocking when inode_t has no locks.
   *
   * This shortcut is invalid for Cygwin because the above inode_t::get
   * call returns with an empty lock list if this process has no locks
   * on the file yet.
   */
  if (*head == NULL)
    {
      if (a_op != F_SETLK)
	{
	  node->UNLOCK ();
	  fl->l_type = F_UNLCK;
	  return 0;
	}
    }
#endif
  /*
   * Allocate a spare structure in case we have to split.
   */
  lockf_t *clean = NULL;
  if (a_op == F_SETLK || a_op == F_UNLCK)
    {
      clean = new lockf_t ();
      if (!clean)
	{
	  node->unlock_and_remove_if_unused ();
	  set_errno (ENOLCK);
	  return -1;
	}
    }
  /*
   * Create the lockf_t structure
   */
  lockf_t *lock = new lockf_t (node, head, a_flags, type, start, end,
			       (a_flags & F_FLOCK) ? get_unique_id ()
						   : getpid (),
			       myself->dwProcessId, 0);
  if (!lock)
    {
      node->unlock_and_remove_if_unused ();
      set_errno (ENOLCK);
      return -1;
    }

  switch (a_op)
    {
    case F_SETLK:
      error = lf_setlock (lock, node, &clean, get_handle ());
      break;

    case F_UNLCK:
      error = lf_clearlock (lock, &clean, get_handle ());
      lock->lf_next = clean;
      clean = lock;
      break;

    case F_GETLK:
      error = lf_getlock (lock, node, fl);
      lock->lf_next = clean;
      clean = lock;
      break;

    default:
      lock->lf_next = clean;
      clean = lock;
      error = EINVAL;
      break;
    }
  for (lock = clean; lock != NULL; )
    {
      lockf_t *n = lock->lf_next;
      lock->del_lock_obj (get_handle (), a_op == F_UNLCK);
      delete lock;
      lock = n;
    }
  node->unlock_and_remove_if_unused ();
  switch (error)
    {
    case 0:		/* All is well. */
      need_fork_fixup (true);
      return 0;
    case EINTR:		/* Signal came in. */
      if (_my_tls.call_signal_handler ())
	goto restart;
      break;
    case ECANCELED:	/* The thread has been sent a cancellation request. */
      pthread::static_cancel_self ();
      /*NOTREACHED*/
    default:
      break;
    }
  set_errno (error);
  return -1;
}

/*
 * Set a byte-range lock.
 */
static int
lf_setlock (lockf_t *lock, inode_t *node, lockf_t **clean, HANDLE fhdl)
{
  lockf_t *block;
  lockf_t **head = lock->lf_head;
  lockf_t **prev, *overlap;
  int ovcase, priority, old_prio, needtolink;
  tmp_pathbuf tp;

  /*
   * Set the priority
   */
  priority = old_prio = GetThreadPriority (GetCurrentThread ());
  if (lock->lf_type == F_WRLCK && priority <= THREAD_PRIORITY_ABOVE_NORMAL)
    priority = THREAD_PRIORITY_HIGHEST;
  /*
   * Scan lock list for this file looking for locks that would block us.
   */
  /* Create temporary space for the all locks list. */
  node->i_all_lf = (lockf_t *) (void *) tp.w_get ();
  while ((block = lf_getblock(lock, node)))
    {
      HANDLE obj = block->lf_obj;
      block->lf_obj = NULL;

      /*
       * Free the structure and return if nonblocking.
       */
      if ((lock->lf_flags & F_WAIT) == 0)
	{
	  NtClose (obj);
	  lock->lf_next = *clean;
	  *clean = lock;
	  return EAGAIN;
	}
      /*
       * We are blocked. Since flock style locks cover
       * the whole file, there is no chance for deadlock.
       * For byte-range locks we must check for deadlock.
       *
       * Deadlock detection is done by looking through the
       * wait channels to see if there are any cycles that
       * involve us. MAXDEPTH is set just to make sure we
       * do not go off into neverland.
       */
      /* FIXME: We check the handle count of all the lock event objects
		this process holds.  If it's > 1, another process is
		waiting for one of our locks.  This method isn't overly
		intelligent.  If it turns out to be too dumb, we might
		have to remove it or to find another method. */
      if (lock->lf_flags & F_POSIX)
	for (lockf_t *lk = node->i_lockf; lk; lk = lk->lf_next)
	  if ((lk->lf_flags & F_POSIX) && get_obj_handle_count (lk->lf_obj) > 1)
	    {
	      NtClose (obj);
	      return EDEADLK;
	    }

      /*
       * For flock type locks, we must first remove
       * any shared locks that we hold before we sleep
       * waiting for an exclusive lock.
       */
      if ((lock->lf_flags & F_FLOCK) && lock->lf_type == F_WRLCK)
	{
	  lock->lf_type = F_UNLCK;
	  (void) lf_clearlock (lock, clean, fhdl);
	  lock->lf_type = F_WRLCK;
	}

      /*
       * Add our lock to the blocked list and sleep until we're free.
       * Remember who blocked us (for deadlock detection).
       */
      /* Cygwin:  No locked list.  See deadlock recognition above. */

      node->UNLOCK ();

      /* Create list of objects to wait for. */
      HANDLE w4[4] = { obj, NULL, NULL, NULL };
      DWORD wait_count = 1;

      DWORD timeout;
      HANDLE proc = NULL;
      if (lock->lf_flags & F_POSIX)
	{
	  proc = OpenProcess (SYNCHRONIZE, FALSE, block->lf_wid);
	  if (!proc)
	    timeout = 0L;
	  else
	    {
	      w4[wait_count++] = proc;
	      timeout = INFINITE;
	    }
	}
      else
	timeout = 100L;

      DWORD WAIT_SIGNAL_ARRIVED = WAIT_OBJECT_0 + wait_count;
      set_signal_arrived here (w4[wait_count++]);

      DWORD WAIT_THREAD_CANCELED = WAIT_TIMEOUT + 1;
      HANDLE cancel_event = pthread::get_cancel_event ();
      if (cancel_event)
	{
	  WAIT_THREAD_CANCELED = WAIT_OBJECT_0 + wait_count;
	  w4[wait_count++] = cancel_event;
	}

      /* Wait for the blocking object and, for POSIX locks, its holding process.
	 Unfortunately, since BSD flock locks are not attached to a specific
	 process, we can't recognize an abandoned lock by sync'ing with the
	 creator process.  We have to make sure the event object is in a
	 signalled state, or that it has gone away.  The latter we can only
	 recognize by retrying to fetch the block list, so we must not wait
	 infinitely.  For POSIX locks, if the process has already exited,
	 just check if a signal or a thread cancel request arrived. */
      SetThreadPriority (GetCurrentThread (), priority);
      DWORD ret = WaitForMultipleObjects (wait_count, w4, FALSE, timeout);
      SetThreadPriority (GetCurrentThread (), old_prio);
      if (proc)
	CloseHandle (proc);
      node->LOCK ();
      /* Never close lock object handle outside of node lock! */
      NtClose (obj);
      if (ret == WAIT_SIGNAL_ARRIVED)
	{
	  /* A signal came in. */
	  lock->lf_next = *clean;
	  *clean = lock;
	  return EINTR;
	}
      else if (ret == WAIT_THREAD_CANCELED)
	{
	  /* The thread has been sent a cancellation request. */
	  lock->lf_next = *clean;
	  *clean = lock;
	  return ECANCELED;
	}
      else
	/* The lock object has been set to signalled or ...
	   for POSIX locks, the process holding the lock has exited, or ...
	   just a timeout.  Just retry. */
	continue;
    }
  allow_others_to_sync ();
  /*
   * No blocks!!  Add the lock.  Note that we will
   * downgrade or upgrade any overlapping locks this
   * process already owns.
   *
   * Handle any locks that overlap.
   */
  prev = head;
  block = *head;
  needtolink = 1;
  for (;;)
    {
      ovcase = lf_findoverlap (block, lock, SELF, &prev, &overlap);
      if (ovcase)
	block = overlap->lf_next;
      /*
       * Six cases:
       *  0) no overlap
       *  1) overlap == lock
       *  2) overlap contains lock
       *  3) lock contains overlap
       *  4) overlap starts before lock
       *  5) overlap ends after lock
       */
      switch (ovcase)
	{
	case 0: /* no overlap */
	  if (needtolink)
	    {
	      *prev = lock;
	      lock->lf_next = overlap;
	      lock->create_lock_obj ();
	    }
	    break;

	case 1: /* overlap == lock */
	  /*
	   * If downgrading lock, others may be
	   * able to acquire it.
	   * Cygwin: Always wake lock.
	   */
	  lf_wakelock (overlap, fhdl);
	  overlap->lf_type = lock->lf_type;
	  overlap->create_lock_obj ();
	  lock->lf_next = *clean;
	  *clean = lock;
	  break;

	case 2: /* overlap contains lock */
	  /*
	   * Check for common starting point and different types.
	   */
	  if (overlap->lf_type == lock->lf_type)
	    {
	      lock->lf_next = *clean;
	      *clean = lock;
	      break;
	    }
	  if (overlap->lf_start == lock->lf_start)
	    {
	      *prev = lock;
	      lock->lf_next = overlap;
	      overlap->lf_start = lock->lf_end + 1;
	    }
	  else
	    lf_split (overlap, lock, clean);
	  lf_wakelock (overlap, fhdl);
	  overlap->create_lock_obj ();
	  lock->create_lock_obj ();
	  if (lock->lf_next && !lock->lf_next->lf_obj)
	    lock->lf_next->create_lock_obj ();
	  break;

	case 3: /* lock contains overlap */
	  /*
	   * If downgrading lock, others may be able to
	   * acquire it, otherwise take the list.
	   * Cygwin: Always wake old lock and create new lock.
	   */
	  lf_wakelock (overlap, fhdl);
	  /*
	   * Add the new lock if necessary and delete the overlap.
	   */
	  if (needtolink)
	    {
	      *prev = lock;
	      lock->lf_next = overlap->lf_next;
	      prev = &lock->lf_next;
	      lock->create_lock_obj ();
	      needtolink = 0;
	    }
	  else
	    *prev = overlap->lf_next;
	  overlap->lf_next = *clean;
	  *clean = overlap;
	  continue;

	case 4: /* overlap starts before lock */
	  /*
	   * Add lock after overlap on the list.
	   */
	  lock->lf_next = overlap->lf_next;
	  overlap->lf_next = lock;
	  overlap->lf_end = lock->lf_start - 1;
	  prev = &lock->lf_next;
	  lf_wakelock (overlap, fhdl);
	  overlap->create_lock_obj ();
	  lock->create_lock_obj ();
	  needtolink = 0;
	  continue;

	case 5: /* overlap ends after lock */
	  /*
	   * Add the new lock before overlap.
	   */
	  if (needtolink) {
	      *prev = lock;
	      lock->lf_next = overlap;
	  }
	  overlap->lf_start = lock->lf_end + 1;
	  lf_wakelock (overlap, fhdl);
	  lock->create_lock_obj ();
	  overlap->create_lock_obj ();
	  break;
	}
      break;
    }
  return 0;
}

/*
 * Remove a byte-range lock on an inode_t.
 *
 * Generally, find the lock (or an overlap to that lock)
 * and remove it (or shrink it), then wakeup anyone we can.
 */
static int
lf_clearlock (lockf_t *unlock, lockf_t **clean, HANDLE fhdl)
{
  lockf_t **head = unlock->lf_head;
  lockf_t *lf = *head;
  lockf_t *overlap, **prev;
  int ovcase;

  if (lf == NOLOCKF)
    return 0;
  prev = head;
  while ((ovcase = lf_findoverlap (lf, unlock, SELF, &prev, &overlap)))
    {
      /*
       * Wakeup the list of locks to be retried.
       */
      lf_wakelock (overlap, fhdl);

      switch (ovcase)
	{
	case 1: /* overlap == lock */
	  *prev = overlap->lf_next;
	  overlap->lf_next = *clean;
	  *clean = overlap;
	  break;

	case 2: /* overlap contains lock: split it */
	  if (overlap->lf_start == unlock->lf_start)
	    {
	      overlap->lf_start = unlock->lf_end + 1;
	      overlap->create_lock_obj ();
	      break;
	    }
	  lf_split (overlap, unlock, clean);
	  overlap->lf_next = unlock->lf_next;
	  overlap->create_lock_obj ();
	  if (overlap->lf_next && !overlap->lf_next->lf_obj)
	    overlap->lf_next->create_lock_obj ();
	  break;

	case 3: /* lock contains overlap */
	  *prev = overlap->lf_next;
	  lf = overlap->lf_next;
	  overlap->lf_next = *clean;
	  *clean = overlap;
	  continue;

	case 4: /* overlap starts before lock */
	    overlap->lf_end = unlock->lf_start - 1;
	    prev = &overlap->lf_next;
	    lf = overlap->lf_next;
	    overlap->create_lock_obj ();
	    continue;

	case 5: /* overlap ends after lock */
	    overlap->lf_start = unlock->lf_end + 1;
	    overlap->create_lock_obj ();
	    break;
	}
      break;
    }
  return 0;
}

/*
 * Check whether there is a blocking lock,
 * and if so return its process identifier.
 */
static int
lf_getlock (lockf_t *lock, inode_t *node, struct flock *fl)
{
  lockf_t *block;
  tmp_pathbuf tp;

  /* Create temporary space for the all locks list. */
  node->i_all_lf = (lockf_t *) (void * ) tp.w_get ();
  if ((block = lf_getblock (lock, node)))
    {
      if (block->lf_obj)
	block->close_lock_obj ();
      fl->l_type = block->lf_type;
      fl->l_whence = SEEK_SET;
      fl->l_start = block->lf_start;
      if (block->lf_end == -1)
	fl->l_len = 0;
      else
	fl->l_len = block->lf_end - block->lf_start + 1;
      if (block->lf_flags & F_POSIX)
	fl->l_pid = (pid_t) block->lf_id;
      else
	fl->l_pid = -1;
    }
  else
    fl->l_type = F_UNLCK;
  return 0;
}

/*
 * Walk the list of locks for an inode_t and
 * return the first blocking lock.
 */
static lockf_t *
lf_getblock (lockf_t *lock, inode_t *node)
{
  lockf_t **prev, *overlap;
  lockf_t *lf = node->get_all_locks_list ();
  int ovcase;

  prev = lock->lf_head;
  while ((ovcase = lf_findoverlap (lf, lock, OTHERS, &prev, &overlap)))
    {
      /*
       * We've found an overlap, see if it blocks us
       */
      if ((lock->lf_type == F_WRLCK || overlap->lf_type == F_WRLCK))
	{
	  /* Open the event object for synchronization. */
	  if (overlap->open_lock_obj ())
	    {
	      /* Check if the event object is signalled.  If so, the overlap
		 doesn't actually exist anymore.  There are just a few open
		 handles left. */
	      if (!IsEventSignalled (overlap->lf_obj))
		return overlap;
	      overlap->close_lock_obj ();
	    }
	}
      /*
       * Nope, point to the next one on the list and
       * see if it blocks us
       */
      lf = overlap->lf_next;
    }
  return NOLOCKF;
}

/*
 * Walk the list of locks for an inode_t to
 * find an overlapping lock (if any).
 *
 * NOTE: this returns only the FIRST overlapping lock.  There
 *   may be more than one.
 */
static int
lf_findoverlap (lockf_t *lf, lockf_t *lock, int type, lockf_t ***prev,
		lockf_t **overlap)
{
  off_t start, end;

  *overlap = lf;
  if (lf == NOLOCKF)
    return 0;

  start = lock->lf_start;
  end = lock->lf_end;
  while (lf != NOLOCKF)
    {
      if (((type & SELF) && lf->lf_id != lock->lf_id)
	  || ((type & OTHERS) && lf->lf_id == lock->lf_id)
	  /* As on Linux: POSIX locks and BSD flock locks don't interact. */
	  || (lf->lf_flags & (F_POSIX | F_FLOCK))
	     != (lock->lf_flags & (F_POSIX | F_FLOCK)))
	{
	  *prev = &lf->lf_next;
	  *overlap = lf = lf->lf_next;
	  continue;
	}
      /*
       * OK, check for overlap
       *
       * Six cases:
       *  0) no overlap
       *  1) overlap == lock
       *  2) overlap contains lock
       *  3) lock contains overlap
       *  4) overlap starts before lock
       *  5) overlap ends after lock
       */
      if ((lf->lf_end != -1 && start > lf->lf_end) ||
	  (end != -1 && lf->lf_start > end))
	{
	  /* Case 0 */
	  if ((type & SELF) && end != -1 && lf->lf_start > end)
	    return 0;
	  *prev = &lf->lf_next;
	  *overlap = lf = lf->lf_next;
	  continue;
	}
      if ((lf->lf_start == start) && (lf->lf_end == end))
	{
	  /* Case 1 */
	  return 1;
	}
      if ((lf->lf_start <= start) && (end != -1) &&
	  ((lf->lf_end >= end) || (lf->lf_end == -1)))
	{
	  /* Case 2 */
	  return 2;
	}
      if (start <= lf->lf_start && (end == -1 ||
	  (lf->lf_end != -1 && end >= lf->lf_end)))
	{
	  /* Case 3 */
	  return 3;
	}
      if ((lf->lf_start < start) &&
	  ((lf->lf_end >= start) || (lf->lf_end == -1)))
	{
	  /* Case 4 */
	  return 4;
	}
      if ((lf->lf_start > start) && (end != -1) &&
	  ((lf->lf_end > end) || (lf->lf_end == -1)))
	{
	  /* Case 5 */
	  return 5;
	}
      api_fatal ("lf_findoverlap: default\n");
    }
  return 0;
}

/*
 * Split a lock and a contained region into
 * two or three locks as necessary.
 */
static void
lf_split (lockf_t *lock1, lockf_t *lock2, lockf_t **split)
{
  lockf_t *splitlock;

  /*
   * Check to see if spliting into only two pieces.
   */
  if (lock1->lf_start == lock2->lf_start)
    {
      lock1->lf_start = lock2->lf_end + 1;
      lock2->lf_next = lock1;
      return;
    }
  if (lock1->lf_end == lock2->lf_end)
    {
      lock1->lf_end = lock2->lf_start - 1;
      lock2->lf_next = lock1->lf_next;
      lock1->lf_next = lock2;
      return;
    }
  /*
   * Make a new lock consisting of the last part of
   * the encompassing lock.  We use the preallocated
   * splitlock so we don't have to block.
   */
  splitlock = *split;
  assert (splitlock != NULL);
  *split = splitlock->lf_next;
  memcpy (splitlock, lock1, sizeof *splitlock);
  /* We have to unset the obj HANDLE here which has been copied by the
     above memcpy, so that the calling function recognizes the new object.
     See post-lf_split handling in lf_setlock and lf_clearlock. */
  splitlock->lf_obj = NULL;
  splitlock->lf_start = lock2->lf_end + 1;
  lock1->lf_end = lock2->lf_start - 1;
  /*
   * OK, now link it in
   */
  splitlock->lf_next = lock1->lf_next;
  lock2->lf_next = splitlock;
  lock1->lf_next = lock2;
}

/*
 * Wakeup a blocklist
 * Cygwin: Just signal the lock which gets removed.  This unblocks
 * all threads waiting for this lock.
 */
static void
lf_wakelock (lockf_t *listhead, HANDLE fhdl)
{
  listhead->del_lock_obj (fhdl, true);
}

extern "C" int
flock (int fd, int operation)
{
  int res = -1;
  int cmd;
  struct flock fl = { 0, SEEK_SET, 0, 0, 0 };

  __try
    {
      cygheap_fdget cfd (fd, true);
      if (cfd < 0)
	__leave;

      cmd = (operation & LOCK_NB) ? F_SETLK : F_SETLKW;
      switch (operation & (~LOCK_NB))
	{
	case LOCK_EX:
	  fl.l_type = F_WRLCK;
	  break;
	case LOCK_SH:
	  fl.l_type = F_RDLCK;
	  break;
	case LOCK_UN:
	  fl.l_type = F_UNLCK;
	  break;
	default:
	  set_errno (EINVAL);
	  __leave;
	}
      if (!cfd->mandatory_locking ())
	fl.l_type |= F_FLOCK;
      res = cfd->mandatory_locking () ? cfd->mand_lock (cmd, &fl)
				      : cfd->lock (cmd, &fl);
      if ((res == -1) && ((get_errno () == EAGAIN) || (get_errno () == EACCES)))
	set_errno (EWOULDBLOCK);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = flock(%d, %d)", res, fd, operation);
  return res;
}

extern "C" int
lockf (int filedes, int function, off_t size)
{
  int res = -1;
  int cmd;
  struct flock fl;

  pthread_testcancel ();

  __try
    {
      cygheap_fdget cfd (filedes, true);
      if (cfd < 0)
	__leave;

      fl.l_start = 0;
      fl.l_len = size;
      fl.l_whence = SEEK_CUR;

      switch (function)
	{
	case F_ULOCK:
	  cmd = F_SETLK;
	  fl.l_type = F_UNLCK;
	  break;
	case F_LOCK:
	  cmd = F_SETLKW;
	  fl.l_type = F_WRLCK;
	  break;
	case F_TLOCK:
	  cmd = F_SETLK;
	  fl.l_type = F_WRLCK;
	  break;
	case F_TEST:
	  fl.l_type = F_WRLCK;
	  if (cfd->lock (F_GETLK, &fl) == -1)
	    __leave;
	  if (fl.l_type == F_UNLCK || fl.l_pid == getpid ())
	    res = 0;
	  else
	    errno = EAGAIN;
	  __leave;
	  /* NOTREACHED */
	default:
	  errno = EINVAL;
	  __leave;
	  /* NOTREACHED */
	}
      res = cfd->mandatory_locking () ? cfd->mand_lock (cmd, &fl)
				      : cfd->lock (cmd, &fl);
    }
  __except (EFAULT) {}
  __endtry
  syscall_printf ("%R = lockf(%d, %d, %D)", res, filedes, function, size);
  return res;
}

/* This is the fcntl lock implementation for mandatory locks using the
   Windows mandatory locking functions.  For the UNIX-like advisory locking
   implementation see the fhandler_disk_file::lock method earlier in this
   file. */
struct lock_parms {
  HANDLE	   h;
  PIO_STATUS_BLOCK pio;
  PLARGE_INTEGER   poff;
  PLARGE_INTEGER   plen;
  BOOL		   type;
  NTSTATUS	   status;
};

static DWORD WINAPI
blocking_lock_thr (LPVOID param)
{
  struct lock_parms *lp = (struct lock_parms *) param;
  lp->status = NtLockFile (lp->h, NULL, NULL, NULL, lp->pio, lp->poff,
			   lp->plen, 0, FALSE, lp->type);
  return 0;
}

int
fhandler_base::mand_lock (int, struct flock *)
{
  set_errno (EINVAL);
  return -1;
}

int
fhandler_disk_file::mand_lock (int a_op, struct flock *fl)
{
  NTSTATUS status;
  IO_STATUS_BLOCK io;
  FILE_POSITION_INFORMATION fpi;
  FILE_STANDARD_INFORMATION fsi;
  off_t startpos;
  LARGE_INTEGER offset;
  LARGE_INTEGER length;

  /* Calculate where to start from, then adjust this by fl->l_start. */
  switch (fl->l_whence)
  {
    case SEEK_SET:
      startpos = 0;
      break;
    case SEEK_CUR:
      status = NtQueryInformationFile (get_handle (), &io, &fpi, sizeof fpi,
				       FilePositionInformation);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  return -1;
	}
      startpos = fpi.CurrentByteOffset.QuadPart;
      break;
    case SEEK_END:
      status = NtQueryInformationFile (get_handle (), &io, &fsi, sizeof fsi,
				       FileStandardInformation);
      if (!NT_SUCCESS (status))
	{
	  __seterrno_from_nt_status (status);
	  return -1;
	}
      startpos = fsi.EndOfFile.QuadPart;
      break;
    default:
      set_errno (EINVAL);
      return -1;
  }
  /* Adjust start and length until they make sense. */
  offset.QuadPart = startpos + fl->l_start;
  if (fl->l_len < 0)
    {
      offset.QuadPart -= fl->l_len;
      length.QuadPart = -fl->l_len;
    }
  else
    length.QuadPart = fl->l_len;
  if (offset.QuadPart < 0)
    {
      length.QuadPart -= -offset.QuadPart;
      if (length.QuadPart <= 0)
        {
          set_errno (EINVAL);
          return -1;
        }
      offset.QuadPart = 0;
    }
  /* Special case if len == 0.  For POSIX this means lock to the end of
     the entire file, even when file grows later. */
  if (length.QuadPart == 0)
    length.QuadPart = UINT64_MAX;
  /* Action! */
  if (fl->l_type == F_UNLCK)
    {
      status = NtUnlockFile (get_handle (), &io, &offset, &length, 0);
      if (status == STATUS_RANGE_NOT_LOCKED)	/* Not an error */
	status = STATUS_SUCCESS;
    }
  else if (a_op == F_SETLKW)
    {
      /* We open file handles synchronously.  To allow asynchronous operation
	 the file locking functions require a file handle opened in asynchronous
	 mode.  Since Windows locks are per-process/per-file object, we can't
	 open another handle asynchrously and lock/unlock using that handle:
	 The original file handle would not have placed the lock and would be
	 restricted by the lock like any other file handle.
	 So, what we do here is to start a thread which calls the potentially
	 blocking NtLockFile call.  Then we wait for thread completion in an
	 interruptible fashion. */
      OBJECT_ATTRIBUTES attr;
      HANDLE evt;
      struct lock_parms lp = { get_handle (), &io, &offset, &length,
			       fl->l_type == F_WRLCK, 0 };
      cygthread *thr = NULL;

      InitializeObjectAttributes (&attr, NULL, 0, NULL, NULL);
      status = NtCreateEvent (&evt, EVENT_ALL_ACCESS, &attr,
			      NotificationEvent, FALSE);
      if (evt)
	thr = new cygthread (blocking_lock_thr, &lp, "blk_lock", evt);
      if (!thr)
	{
	  /* Thread creation failed.  Fall back to blocking lock call. */
	  if (evt)
	    NtClose (evt);
	  status = NtLockFile (get_handle (), NULL, NULL, NULL, &io, &offset,
			       &length, 0, FALSE, fl->l_type == F_WRLCK);
	}
      else
	{
	  /* F_SETLKW and lock cannot be established.  Wait until the lock can
	     be established, or a signal request arrived.  We deliberately
	     don't handle thread cancel requests here. */
	  DWORD wait_res = cygwait (evt, INFINITE, cw_sig | cw_sig_eintr);
	  NtClose (evt);
	  switch (wait_res)
	    {
	    case WAIT_OBJECT_0:
	      /* Fetch completion status. */
	      status = lp.status;
	      thr->detach ();
	      break;
	    default:
	      /* Signal arrived. */
	      /* Starting with Vista, CancelSynchronousIo works, and we wait
		 for the thread to exit.  lp.status will be either
		 STATUS_SUCCESS, or STATUS_CANCELLED.  We only call
		 NtUnlockFile in the first case.
		 Prior to Vista, CancelSynchronousIo doesn't exist, so we
		 terminated the thread and always call NtUnlockFile since
		 lp.status was 0 to begin with. */
	      if (CancelSynchronousIo (thr->thread_handle ()))
		thr->detach ();
	      else
	      	thr->terminate_thread ();
	      if (NT_SUCCESS (lp.status))
		NtUnlockFile (get_handle (), &io, &offset, &length, 0);
	      /* Per SUSv4: If a signal is received while fcntl is waiting,
		 fcntl shall be interrupted.  Upon return from the signal
		 handler, fcntl shall return -1 with errno set to EINTR,
		 and the lock operation shall not be done. */
	      _my_tls.call_signal_handler ();
	      set_errno (EINTR);
	      return -1;
	    }
	}
    }
  else
    {
      status = NtLockFile (get_handle (), NULL, NULL, NULL, &io, &offset,
			   &length, 0, TRUE, fl->l_type == F_WRLCK);
      if (a_op == F_GETLK)
	{
	  /* This is non-atomic, but there's no other way on Windows to detect
	     if another lock is blocking our lock, other than trying to place
	     the lock, and then having to unlock it again. */
	  if (NT_SUCCESS (status))
	    {
	      NtUnlockFile (get_handle (), &io, &offset, &length, 0);
	      fl->l_type = F_UNLCK;
	    }
	  else
	    {
	      /* FAKE! FAKE! FAKE! */
	      fl->l_type = F_WRLCK;
	      fl->l_whence = SEEK_SET;
	      fl->l_start = offset.QuadPart;
	      fl->l_len = length.QuadPart;
	      fl->l_pid = (pid_t) -1;
	    }
	  status = STATUS_SUCCESS;
	}
    }
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return -1;
    }
  return 0;
}
@


1.62
log
@	* flock.cc (create_lock_in_parent): Make lf_obj handle inheritable.
	Explain why.
	(lockf_t::create_lock_obj): Use FALSE, rather than 0 for BOOL argument.
	(lockf_t::del_lock_obj): Check if NtSetEvent succeeded and print system
	message if not.
@
text
@d992 1
a992 1
	    system_printf ("get_access() == %x", get_access ());
d1002 1
a1002 1
	    system_printf ("get_access() == %x", get_access ());
@


1.61
log
@	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
@
text
@d706 6
d819 1
a819 1
			    &parent_lf_obj, TRUE, 0, DUPLICATE_SAME_ACCESS))
d882 3
a884 1
	  NtSetEvent (lf_obj, NULL);
@


1.60
log
@	* flock.cc (delete_lock_in_parent): Use LIST_FOREACH_SAFE to avoid
	dereferencing freed pointer (CID 60224).
@
text
@d1764 5
a1768 7
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  cygheap_fdget cfd (fd, true);
  if (cfd < 0)
    goto done;
d1770 22
a1791 15
  cmd = (operation & LOCK_NB) ? F_SETLK : F_SETLKW;
  switch (operation & (~LOCK_NB))
    {
    case LOCK_EX:
      fl.l_type = F_WRLCK;
      break;
    case LOCK_SH:
      fl.l_type = F_RDLCK;
      break;
    case LOCK_UN:
      fl.l_type = F_UNLCK;
      break;
    default:
      set_errno (EINVAL);
      goto done;
d1793 2
a1794 7
  if (!cfd->mandatory_locking ())
    fl.l_type |= F_FLOCK;
  res = cfd->mandatory_locking () ? cfd->mand_lock (cmd, &fl)
				  : cfd->lock (cmd, &fl);
  if ((res == -1) && ((get_errno () == EAGAIN) || (get_errno () == EACCES)))
    set_errno (EWOULDBLOCK);
done:
d1808 9
a1816 11
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  cygheap_fdget cfd (filedes, true);
  if (cfd < 0)
    goto done;

  fl.l_start = 0;
  fl.l_len = size;
  fl.l_whence = SEEK_CUR;
d1818 31
a1848 28
  switch (function)
    {
    case F_ULOCK:
      cmd = F_SETLK;
      fl.l_type = F_UNLCK;
      break;
    case F_LOCK:
      cmd = F_SETLKW;
      fl.l_type = F_WRLCK;
      break;
    case F_TLOCK:
      cmd = F_SETLK;
      fl.l_type = F_WRLCK;
      break;
    case F_TEST:
      fl.l_type = F_WRLCK;
      if (cfd->lock (F_GETLK, &fl) == -1)
	goto done;
      if (fl.l_type == F_UNLCK || fl.l_pid == getpid ())
	res = 0;
      else
	errno = EAGAIN;
      goto done;
      /* NOTREACHED */
    default:
      errno = EINVAL;
      goto done;
      /* NOTREACHED */
d1850 2
a1851 3
  res = cfd->mandatory_locking () ? cfd->mand_lock (cmd, &fl)
				  : cfd->lock (cmd, &fl);
done:
@


1.59
log
@	* dcrt0.cc (child_info_spawn::handle_spawn): Call fixup_lockf_after_exec
	with additional argument to specify if the process has been execed
	or spawned.
	* flock.cc (fixup_lockf_after_exec): Take bool parameter to handle
	exec and spawn differently.  In case of spawn, just give up POSIX
	locks in favor of the still running parent.  Add comments to explain.
@
text
@d3 1
a3 1
   Copyright 2003, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d727 1
a727 1
  inode_t *node;
d733 1
a733 1
  LIST_FOREACH (node, &cygheap->inode_list, i_next)
@


1.58
log
@	* flock.cc (fhandler_base::lock): Only refuse to lock nohandle and
	old-style console devices when called to perform BSD flock locking.
	Add a FIXME to comment and align description.

	* ntdll.h (THREADINFOCLASS): Following MSDN, rename throughout from
	THREAD_INFORMATION_CLASS.
@
text
@d442 1
a442 1
fixup_lockf_after_exec ()
d467 3
a469 1
	  for (lockf_t *lock = node->i_lockf; lock; lock = lock->lf_next)
d472 18
a489 4
		lock->del_lock_obj (NULL);
		lock->lf_wid = myself->dwProcessId;
		lock->lf_ver = 0;
		lock->create_lock_obj ();
@


1.58.2.1
log
@* dcrt0.cc (child_info_spawn::handle_spawn): Call fixup_lockf_after_exec with
additional argument to specify if the process has been execed or spawned.
* flock.cc (fixup_lockf_after_exec): Take bool parameter to handle exec and
spawn differently.  In case of spawn, just give up POSIX locks in favor of the
still running parent.  Add comments to explain.
@
text
@d442 1
a442 1
fixup_lockf_after_exec (bool exec)
d467 1
a467 3
	  lockf_t *lock, *n_lock;
	  lockf_t **prev = &node->i_lockf;
	  for (lock = *prev; lock && (n_lock = lock->lf_next, 1); lock = n_lock)
d470 4
a473 18
		if (exec)
		  {
		    /* The parent called exec.  The lock is passed to the child.
		       Recreate lock object with changed ownership. */
		    lock->del_lock_obj (NULL);
		    lock->lf_wid = myself->dwProcessId;
		    lock->lf_ver = 0;
		    lock->create_lock_obj ();
		  }
		else
		  {
		    /* The parent called spawn.  The parent continues to hold
		       the POSIX lock, ownership is not passed to the child.
		       Give up the lock in the child. */
		    *prev = n_lock;
		    lock->close_lock_obj ();
		    delete lock;
		  }
@


1.58.2.2
log
@Add more missing patches
@
text
@d3 1
a3 1
   Copyright 2003, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d727 1
a727 1
  inode_t *node, *next_node;
d733 1
a733 1
  LIST_FOREACH_SAFE (node, &cygheap->inode_list, i_next, next_node)
@


1.58.2.3
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d1764 10
a1773 1
  __try
d1775 12
a1786 26
      cygheap_fdget cfd (fd, true);
      if (cfd < 0)
	__leave;

      cmd = (operation & LOCK_NB) ? F_SETLK : F_SETLKW;
      switch (operation & (~LOCK_NB))
	{
	case LOCK_EX:
	  fl.l_type = F_WRLCK;
	  break;
	case LOCK_SH:
	  fl.l_type = F_RDLCK;
	  break;
	case LOCK_UN:
	  fl.l_type = F_UNLCK;
	  break;
	default:
	  set_errno (EINVAL);
	  __leave;
	}
      if (!cfd->mandatory_locking ())
	fl.l_type |= F_FLOCK;
      res = cfd->mandatory_locking () ? cfd->mand_lock (cmd, &fl)
				      : cfd->lock (cmd, &fl);
      if ((res == -1) && ((get_errno () == EAGAIN) || (get_errno () == EACCES)))
	set_errno (EWOULDBLOCK);
d1788 7
a1794 2
  __except (EFAULT) {}
  __endtry
d1808 13
a1820 1
  __try
d1822 26
a1847 39
      cygheap_fdget cfd (filedes, true);
      if (cfd < 0)
	__leave;

      fl.l_start = 0;
      fl.l_len = size;
      fl.l_whence = SEEK_CUR;

      switch (function)
	{
	case F_ULOCK:
	  cmd = F_SETLK;
	  fl.l_type = F_UNLCK;
	  break;
	case F_LOCK:
	  cmd = F_SETLKW;
	  fl.l_type = F_WRLCK;
	  break;
	case F_TLOCK:
	  cmd = F_SETLK;
	  fl.l_type = F_WRLCK;
	  break;
	case F_TEST:
	  fl.l_type = F_WRLCK;
	  if (cfd->lock (F_GETLK, &fl) == -1)
	    __leave;
	  if (fl.l_type == F_UNLCK || fl.l_pid == getpid ())
	    res = 0;
	  else
	    errno = EAGAIN;
	  __leave;
	  /* NOTREACHED */
	default:
	  errno = EINVAL;
	  __leave;
	  /* NOTREACHED */
	}
      res = cfd->mandatory_locking () ? cfd->mand_lock (cmd, &fl)
				      : cfd->lock (cmd, &fl);
d1849 3
a1851 2
  __except (EFAULT) {}
  __endtry
@


1.57
log
@	* devices.in (dev_storage): Map /dev/zero and /dev/full to \Device\Null.
	* devices.cc: Regenerate.
	* dtable.h (struct dtable): Make fhandler_base friend, rather
	than fhandler_disk_file.
	* fhandler.cc (fhandler_base::open_with_arch): Create unique id.
	(fhandler_base::cleanup): Call del_my_locks.
	(fhandler_base::fcntl): Handle F_GETLK, F_SETLK and F_SETLKW.
	* fhandler.h (fhandler_base::get_dev): Return real device number.
	(fhandler_base::set_unique_id): New inline method.
	(fhandler_disk_file::lock): Drop declaration.
	(fhandler_disk_file::get_dev): New method, return pc.fs_serial_number.
	(fhandler_dev_zero::open): Drop declaration.
	* fhandler_disk_file.cc (fhandler_disk_file::close): Move
	del_my_locks call to fhandler_base::open_with_arch.
	(fhandler_disk_file::fcntl): Move handling of locking commands to
	fhandler_base::fcntl.
	(fhandler_base::open_fs): Drop call to NtAllocateLocallyUniqueId.
	* fhandler_zero.cc (fhandler_dev_zero::open): Remove so that default
	fhandler_base::open is used to open \Device\Null.
	* flock.cc (fixup_lockf_after_exec): Finding a single fhandler is
	enough here.
	(fhandler_base::lock): Replace fhandler_disk_file::lock.  Refuse to lock
	nohandle devices.  Handle read/write test using POSIX flags.  Explain
	why.  Never fail on SEEK_CUR or SEEK_END, rather assume position 0,
	just as Linux.
	* net.cc (fdsock): Create unique id.
@
text
@d930 8
a937 1
  if (nohandle ())
d940 2
a941 1
      debug_printf ("Locking on nohandle device, return EINVAL.");
a944 2
  if (!a_flags)
    a_flags = F_POSIX; /* default */
@


1.56
log
@	* flock.cc (lockf_t::from_obj_name): Fix test for valid pid.
@
text
@d457 1
a457 1
	    && ++cnt > 1)
d922 1
a922 8
fhandler_base::lock (int, struct flock *)
{
  set_errno (EINVAL);
  return -1;
}

int
fhandler_disk_file::lock (int a_op, struct flock *fl)
d930 7
d955 6
a960 1
	if ((a_flags & F_POSIX) && !(get_access () & GENERIC_READ))
d962 1
d969 2
a970 1
	if ((a_flags & F_POSIX) && !(get_access () & GENERIC_WRITE))
d972 1
d993 1
a993 1
	return -1;
d997 22
a1018 19
      {
	NTSTATUS status;
	IO_STATUS_BLOCK io;
	FILE_STANDARD_INFORMATION fsi;

	status = NtQueryInformationFile (get_handle (), &io, &fsi, sizeof fsi,
					 FileStandardInformation);
	if (!NT_SUCCESS (status))
	  {
	    __seterrno_from_nt_status (status);
	    return -1;
	  }
	if (fl->l_start > 0 && fsi.EndOfFile.QuadPart > OFF_MAX - fl->l_start)
	  {
	    set_errno (EOVERFLOW);
	    return -1;
	  }
	start = fsi.EndOfFile.QuadPart + fl->l_start;
      }
@


1.55
log
@	* fhandler.cc (fhandler_base::lock): Move to flock.cc.
	(fhandler_base::fixup_after_exec): Reset mandatory_locking.
	* fhandler.h (class fhandler_base): Add mandatory_locking status flag.
	Add mandatory_locking accessor methods.  Accommodate change throughout.
	(fhandler_base::mand_lock): Declare.
	(class fhandler_disk_file): Drop in favor of new status flag.
	* (fhandler_disk_file::fcntl): Call need_fork_fixup if mandatory_locking
	flag gets set.
	* flock.cc (fhandler_base::lock): Define here.
	(flock): Handle mandatory_locking.
	(lockf): Ditto.
	(fhandler_base::mand_lock): Define.
@
text
@d567 1
a567 1
      || ((lf_flags & F_POSIX) && (lf_id < 1 || lf_id > ULONG_MAX)))
@


1.54
log
@	* autoload.cc (CancelSynchronousIo): Define.
	* fcntl.cc (fcntl64): Drop handling of locking commands.
	* fhandler.h (class fhandler_disk_file): Add mandatory_locking.
	(fhandler_disk_file::fcntl): Declare.
	(fhandler_disk_file::mand_lock): Declare.
	* fhandler_disk_file.cc (fhandler_disk_file::fhandler_disk_file):
	Initialize mandatory_locking.
	(fhandler_disk_file::fcntl): New method.  Handle F_LCK_MANDATORY and
	locking commands.
	(fhandler_disk_file::dup): Duplicate mandatory_locking.  Fix a bug
	when duplicating prw_handle failed.
	(fhandler_disk_file::fixup_after_fork): Reset mandatory_locking.
	* flock.cc (fhandler_disk_file::lock): Add comment.
	(struct lock_parms): New struct to pass parameters to blocking_lock_thr
	thread function.
	(blocking_lock_thr): New thread function.
	(fhandler_disk_file::mand_lock): New methof implementing mandatory
	locking with Windows semantics.
	* ntdll.h (NtLockFile): Declare.
	(NtUnlockFile): Declare.
	* include/fcntl.h: Fix a comment.
	(F_LCK_MANDATORY): Define.  Add lengthy comment to explain.
@
text
@d922 7
d1743 1
a1743 1
      fl.l_type = F_WRLCK | F_FLOCK;
d1746 1
a1746 1
      fl.l_type = F_RDLCK | F_FLOCK;
d1749 1
a1749 1
      fl.l_type = F_UNLCK | F_FLOCK;
d1755 4
a1758 1
  res = cfd->lock (cmd, &fl);
d1816 2
a1817 1
  res = cfd->lock (cmd, &fl);
d1846 7
@


1.53
log
@	* Merge in cygwin-64bit-branch.
@
text
@d3 1
a3 1
   Copyright 2003, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d918 3
d1811 196
@


1.52
log
@whitespace cleanup
@
text
@d173 1
a173 1
      debug_printf ("NtQuerySecurityObject: %p", status);
d200 1
a200 1
      debug_printf ("RtlAddAccessAllowedAce: %p", status);
d207 1
a207 1
      debug_printf ("RtlFirstFreeAce: %p", status);
d215 1
a215 1
      debug_printf ("NtSetSecurityObject: %p", status);
d231 1
a231 1
    debug_printf ("NtQueryObject: %p\n", status);
d251 3
a253 3
    _off64_t	    lf_start; /* Byte # of the start of the lock */
    _off64_t	    lf_end;   /* Byte # of the end of the lock (-1=EOF) */
    int64_t	    lf_id;    /* Cygwin PID for POSIX locks, a unique id per
d271 1
a271 1
	     short flags, short type, _off64_t start, _off64_t end,
d311 2
a312 2
    __dev32_t		 i_dev;    /* Device ID */
    __ino64_t		 i_ino;    /* inode number */
d320 1
a320 1
    inode_t (__dev32_t dev, __ino64_t ino);
d328 1
a328 1
    static inode_t *get (__dev32_t dev, __ino64_t ino,
d485 1
a485 1
inode_t::get (__dev32_t dev, __ino64_t ino, bool create_if_missing, bool lock)
d507 1
a507 1
inode_t::inode_t (__dev32_t dev, __ino64_t ino)
d525 1
a525 1
    api_fatal ("NtCreateDirectoryObject(inode): %p", status);
d532 1
a532 1
    api_fatal ("NtCreateMutant(inode): %p", status);
d557 1
a557 1
  lf_start = (_off64_t) wcstoull (endptr + 1, &endptr, 16);
d560 1
a560 1
  lf_end = (_off64_t) wcstoull (endptr + 1, &endptr, 16);
d643 2
a644 2
  __dev32_t dev;
  __ino64_t ino;
d756 1
a756 1
	    api_fatal ("NtCreateEvent(lock): %p", status);
d767 1
a767 1
		api_fatal ("NtCreateEvent(lock): %p", status);
d913 1
a913 1
static int      lf_getlock (lockf_t *, inode_t *, struct __flock64 *);
d919 1
a919 1
fhandler_disk_file::lock (int a_op, struct __flock64 *fl)
d921 1
a921 1
  _off64_t start, end, oadd;
d1502 1
a1502 1
lf_getlock (lockf_t *lock, inode_t *node, struct __flock64 *fl)
d1580 1
a1580 1
  _off64_t start, end;
d1719 1
a1719 1
  struct __flock64 fl = { 0, SEEK_SET, 0, 0, 0 };
d1754 1
a1754 1
lockf (int filedes, int function, _off64_t size)
d1758 1
a1758 1
  struct __flock64 fl;
@


1.51
log
@Change "set_thread_waiting" to "set_signal_arrived" throughout.
@
text
@d253 1
a253 1
    int64_t         lf_id;    /* Cygwin PID for POSIX locks, a unique id per
@


1.51.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d251 2
a252 2
    off_t	    lf_start; /* Byte # of the start of the lock */
    off_t	    lf_end;   /* Byte # of the end of the lock (-1=EOF) */
d271 1
a271 1
	     short flags, short type, off_t start, off_t end,
d311 2
a312 2
    dev_t		 i_dev;    /* Device ID */
    ino_t		 i_ino;    /* inode number */
d320 1
a320 1
    inode_t (dev_t dev, ino_t ino);
d328 1
a328 1
    static inode_t *get (dev_t dev, ino_t ino,
d485 1
a485 1
inode_t::get (dev_t dev, ino_t ino, bool create_if_missing, bool lock)
d507 1
a507 1
inode_t::inode_t (dev_t dev, ino_t ino)
d557 1
a557 1
  lf_start = (off_t) wcstoull (endptr + 1, &endptr, 16);
d560 1
a560 1
  lf_end = (off_t) wcstoull (endptr + 1, &endptr, 16);
d643 2
a644 2
  dev_t dev;
  ino_t ino;
d913 1
a913 1
static int      lf_getlock (lockf_t *, inode_t *, struct flock *);
d919 1
a919 1
fhandler_disk_file::lock (int a_op, struct flock *fl)
d921 1
a921 1
  off_t start, end, oadd;
d1502 1
a1502 1
lf_getlock (lockf_t *lock, inode_t *node, struct flock *fl)
d1580 1
a1580 1
  off_t start, end;
d1719 1
a1719 1
  struct flock fl = { 0, SEEK_SET, 0, 0, 0 };
d1754 1
a1754 1
lockf (int filedes, int function, off_t size)
d1758 1
a1758 1
  struct flock fl;
@


1.51.2.2
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d173 1
a173 1
      debug_printf ("NtQuerySecurityObject: %y", status);
d200 1
a200 1
      debug_printf ("RtlAddAccessAllowedAce: %y", status);
d207 1
a207 1
      debug_printf ("RtlFirstFreeAce: %y", status);
d215 1
a215 1
      debug_printf ("NtSetSecurityObject: %y", status);
d231 1
a231 1
    debug_printf ("NtQueryObject: %y", status);
d525 1
a525 1
    api_fatal ("NtCreateDirectoryObject(inode): %y", status);
d532 1
a532 1
    api_fatal ("NtCreateMutant(inode): %y", status);
d756 1
a756 1
	    api_fatal ("NtCreateEvent(lock): %y", status);
d767 1
a767 1
		api_fatal ("NtCreateEvent(lock): %y", status);
@


1.50
log
@* DevNotes: Add entry cgf-000013.
* cygserver_ipc.h (ipc_set_proc_info): Use _cygtls::ipc_set_proc_info to set
per-thread signal arrived value.
* cygthread.cc (cygthread::detach): Use per-thread signal_arrived via
set_thread_waiting.
* fork.cc (_cygtls::fixup_after_fork): Clear signal_arrived.
(_cygtls::remove): Close any signal_arrived handle when thread exists.
(_cygtls::find_tls): Remove unneeded function.
* cygtls.h: Update copyright.
(class _cygtls): Reorganize to help avoid rebuilding newlib when structure
changes.
(_cygtls::event): Delete.
(_cygtls::threadkill): Ditto.
(_cygtls::signal_waiting): Declare new bool.
(_cygtls::find_tls): Delete declaration.
(_cygtls::set_threadkill): Ditto.
(_cygtls::reset_threadkill): Ditto.
(_cygtls::set_signal_arrived): Declare new function.
(class set_thread_waiting): Declare new class.
* cygwait.cc (cw_nowait_storage): Define.
(cygwait): Set per-thread signal_arrived via set_thread_waiting.  Don't
special-case _main_tls.
* cygwait.h (cw_nowait): Define.
(cw_infinite): Ditto.
(cygwait): Redefine pathological wait-only case.
* dcrt0.cc (dll_crt0_0): Remove call to now-defunct events_init().
(dll_crt0_1): Remove call to now-defunct create_signal_arrived().
* exceptions.cc: Reflect set_signal_mask() argument reordering throughout.
Remove signal mask synchronization throughout.
(events_init): Delete definition.
(mask_sync): Delete now-unneeded mask synchronization.
(set_signal_mask): Reverse order of arguments to "standard" to, from layout.
Rename "newmask" argument to "setmask".  Remove debugging.
(sig_handle_tty_stop): Use cancelable_wait rather than WFMO.
(_cygtls::interrupt_setup): Don't treat "threadkill" events specially.
Conditionally set signal_arrived depending on whether the thread has created it
or not.
(sigpacket::process): Reorganize to reflect thread-specific sending of signals
which is more in line with the way it was actually supposed to work.
* fhandler_socket.cc (get_inet_addr): Use cancelable_wait rather than
IsEventSignalled to avoid potential race.
(fhandler_socket::wait_for_events): Set signal_arrived event using
set_thread_waiting().
(fhandler_socket::close): Use cygwait for the case of just waiting 10 ms for a
signal.
* fhandler_tape.cc (fhandler_dev_tape::_lock): Use cancelable_wait rather than
WFMO.  Redo switch/case tests accordingly.
* fhandler_termios.cc (fhandler_termios::bg_check): Use cygwait for case of
just waiting 0 ms for a potential signal.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Use
cancelable_wait rather than WFSO.
* fhandler_windows.cc (fhandler_windows::read): Set per-thread signal_arrived
via set_thread_waiting().
* flock.cc (lf_setlock): Ditto.
* select.cc (pselect): Ditto.  Set per-thread signal_arrived using
set_thread_waiting().
* gendef: Don't special case handling of _cygtls::sig for threads.
* gentls_offsets: Use #pragma once in tlsoffsets.h.
* ntdll.h: Use #pragma once.
* poll.cc: Reflect set_signal_mask() argument reordering.
* posix_ipc.cc (ipc_mutex_lock): Use cancelable_wait rather than WFMO.
(ipc_cond_timedwait): Set perl-thread signal arrived using
set_thread_waiting().
* security.h: Use #pragma once.
* signal.cc (abort): Reflect set_signal_mask() argument reordering.
(clock_nanosleep): Ditto.  Change call to cancelable_wait to properly specify
handling of cancel and interrupt.
(sigwaitinfo): Remove handling of per-thread event in favor of per-thread
signal_arrived.  Use cancelable_wait rather than WFSO.
* sigproc.cc (signal_arrived): Delete definition.
(create_signal_arrived): Ditto.
* sigproc.h (signal_arrived): Delete declaration.
(set_signal_mask): Avoid defining as a "C" function.  Don't conditionally
declare.
(create_signal_arrived): Delete declaration.
* syscalls.cc (rename): Use cygwait() rather than WFSO.
* thread.h (fast_mutex::lock): Use cw_infinite rather than LARGE_NULL.
* wait.cc (wait4): Ditto.
* thread.cc (pthread_mutex::lock): Ditto.
(pthread::join): Ditto.
(semaphore::_wait): Ditto.
(pthread_kill): Remove set_threadkill() accommodation.
* tlsoffsets.h: Regenerate.
@
text
@d1250 1
a1250 1
      set_thread_waiting here (w4[wait_count++]);
@


1.49
log
@	* fhandler_serial.cc: Fix includes for IOCTL codes to support Mingw64.
	* fhandler_tape.cc: Ditto.
	* flock.cc (allow_others_to_sync): Use PISECURITY_DESCRIPTOR since
	PSECURITY_DESCRIPTOR is supposed to be the opaque type.
	* ntdll.h: Remove CreateDisposition flags again, now that they are
	defined in Mingw64's ntdef.h.  Ditto for Create/Open flags.
@
text
@d1250 1
a1250 1
      w4[wait_count++] = signal_arrived;
@


1.48
log
@Revert errneous checkin.
Check in actual change associated with ChangeLog.
@
text
@d167 1
a167 1
  PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR) alloca (MAX_PROCESS_SD_SIZE);
@


1.47
log
@* cygwait.cc (cancelable_wait): Mimic old cygwait behavior more closely wrt
handling of call_signal_handler.
* cygwait.h (WAIT_CANCELED): Move here and redefine.
(WAIT_SIGNALED): Ditto.
* thread.h (WAIT_CANCELED): Delete.
(WAIT_SIGNALED): Ditto.
@
text
@d1250 1
a1250 1
      set_thread_waiting (w4[wait_count++]);
@


1.46
log
@	* flock.cc (allow_others_to_sync): Reorder conditional expression to
	check for DACL presence first, since otherwise dacl pointer value is
	undefined.  Add comment.
@
text
@d1250 1
a1250 1
      w4[wait_count++] = signal_arrived;
@


1.45
log
@	* flock.cc (allow_others_to_sync): Use RtlGetDaclSecurityDescriptor
	rather than accessing the SECURITY_DESCRIPTOR structure directly.
	Take no DACL and NULL DACL into account.
@
text
@d181 6
a186 1
  if (dacl == NULL) /* Everyone has all access anyway */
a190 5
  else if (!present)
    {
      dacl = (PACL) (sd + 1);
      RtlCreateAcl (dacl, MAX_PROCESS_SD_SIZE - sizeof *sd, ACL_REVISION);
    }
@


1.44
log
@	* flock.cc (LOCK_DIR_NAME_FMT): Define.
	(LOCK_DIR_NAME_LEN): Define.
	(LOCK_DIR_NAME_DEV_OFF): Define.
	(LOCK_DIR_NAME_INO_OFF): Define.
	(LOCK_OBJ_NAME_FMT): Define.  Add comment.
	(class lockf_t): Use bitsize-explicit types.  Declare from_obj_name,
	(class inode_t): Make use, unuse and inuse methods public.  Add a
	lock argument to get method declaration.
	(inode_t::get): Add lock argument.  Only lock node if lock arg is true.
	(inode_t::inode_t): Use LOCK_DIR_NAME_FMT as format string.
	(lockf_t::from_obj_name): New method to generate lockf_t content from
	lock event object basename.
	(inode_t::get_all_locks_list): Just call from_obj_name here and copy
	result into final lockf_t.
	(create_lock_obj_attr): Use LOCK_OBJ_NAME_FMT as format string.
	(create_lock_in_parent): New thread function to create lockf_t
	structure in parent process.
	(delete_lock_in_parent): New thread function to reap stale BSD locks in
	parent process.
	(lockf_t::create_lock_obj): Try to duplicate lock object handle into
	parent process and call create_lock_in_parent as parent remote thread.
	(lockf_t::del_lock_obj): Call delete_lock_in_parent as parent remote
	thread.
	(fhandler_disk_file::lock): Add lock arg to inode_t::get call.
@
text
@d179 16
a194 2
  dacl = (PACL) ((char *) sd + (uintptr_t) sd->Dacl);
  dacl->AclSize = NT_MAX_PATH * sizeof (WCHAR) - ((char *) dacl - (char *) sd);
@


1.43
log
@	* flock.cc (inode_t::del_my_locks): Drop useless counter lc.  Close
	lock object handle explicitely in case of called during fork.  Add
	comment to explain why.
	* fork.cc (frok::child): Drop declaration of fixup_lockf_after_fork.
@
text
@d127 8
a134 1
#define LOCK_OBJ_NAME_LEN	69
d235 2
a236 2
    short	    lf_flags; /* Semantics: F_POSIX, F_FLOCK, F_WAIT */
    short	    lf_type;  /* Lock type: F_RDLCK, F_WRLCK */
d239 1
a239 1
    long long       lf_id;    /* Cygwin PID for POSIX locks, a unique id per
d265 3
a304 4
    void use () { ++i_cnt; }
    void unuse () { if (i_cnt > 0) --i_cnt; }
    bool inuse () { return i_cnt > 0; }

d314 2
a315 1
    static inode_t *get (__dev32_t dev, __ino64_t ino, bool create_if_missing);
d320 3
d403 1
a403 1
  inode_t *node = inode_t::get (get_dev (), get_ino (), false);
d471 1
a471 1
inode_t::get (__dev32_t dev, __ino64_t ino, bool create_if_missing)
d488 1
a488 1
  if (node)
d505 1
a505 1
  int len = __small_swprintf (name, L"flock-%08x-%016X", dev, ino);
d529 39
d578 1
a578 1
  lockf_t *lock = i_all_lf;
d587 2
a588 26
      wchar_t *wc = f.dbi.ObjectName.Buffer, *endptr;
      /* "%02x-%01x-%016X-%016X-%016X-%08x-%04x",
	 lf_flags, lf_type, lf_start, lf_end, lf_id, lf_wid, lf_ver */
      wc[LOCK_OBJ_NAME_LEN] = L'\0';
      short flags = wcstol (wc, &endptr, 16);
      if ((flags & ~(F_FLOCK | F_POSIX)) != 0
	  || ((flags & (F_FLOCK | F_POSIX)) == (F_FLOCK | F_POSIX)))
	continue;
      short type = wcstol (endptr + 1, &endptr, 16);
      if ((type != F_RDLCK && type != F_WRLCK) || !endptr || *endptr != L'-')
	continue;
      _off64_t start = (_off64_t) wcstoull (endptr + 1, &endptr, 16);
      if (start < 0 || !endptr || *endptr != L'-')
	continue;
      _off64_t end = (_off64_t) wcstoull (endptr + 1, &endptr, 16);
      if (end < -1LL || (end > 0 && end < start) || !endptr || *endptr != L'-')
	continue;
      long long id = wcstoll (endptr + 1, &endptr, 16);
      if (!endptr || *endptr != L'-'
	  || ((flags & F_POSIX) && (id < 1 || id > ULONG_MAX)))
	continue;
      DWORD wid = wcstoul (endptr + 1, &endptr, 16);
      if (!endptr || *endptr != L'-')
	continue;
      uint16_t ver = wcstoul (endptr + 1, &endptr, 16);
      if (endptr && *endptr != L'\0')
d598 1
a598 2
      new (lock++) lockf_t (this, &i_all_lf,
			    flags, type, start, end, id, wid, ver);
d611 1
a611 1
  __small_swprintf (attr->name, L"%02x-%01x-%016X-%016X-%016X-%08x-%04x",
d621 105
d761 48
d845 30
a874 1
	NtSetEvent (lf_obj, NULL);
d1024 1
a1024 1
  inode_t *node = inode_t::get (get_dev (), get_ino (), true);
@


1.42
log
@	* flock.cc (lf_setlock): Add timeout variable and set before calling
	WFMO.  Drop debug output if process is not available.  Set timeout to
	0 instead.  Document timeout 0 in WFMO comment.
	(lf_getblock): Drop invalid F_POSIX lock type shortcut.  Only return
	overlap if event is not signalled.  Fix comment.
@
text
@d3 1
a3 1
   Copyright 2003, 2008, 2009, 2010, 2011 Red Hat, Inc.
a349 1
  int lc = 0;
d356 6
a361 1
	  ++lc;
@


1.41
log
@	* flock.cc (lf_setlock): Don't close waited lock object handle before
	we own the node lock.  Fix comment.
@
text
@d1009 1
d1015 1
a1015 2
	    debug_printf ("Can't sync with process holding a POSIX lock "
			  "(Win32 pid %lu): %E", block->lf_wid);
d1017 4
a1020 1
	    w4[wait_count++] = proc;
d1022 3
d1042 2
a1043 2
	 infinitely.  Same problem for POSIX locks if the process has already
	 exited at the time we're trying to open the process. */
d1045 1
a1045 2
      DWORD ret = WaitForMultipleObjects (wait_count, w4, FALSE,
					  proc ? INFINITE : 100L);
d1328 3
a1330 6
	      /* If we found a POSIX lock, it will block us. */
	      if (overlap->lf_flags & F_POSIX)
		return overlap;
	      /* In case of BSD flock locks, check if the event object is
		 signalled.  If so, the overlap doesn't actually exist anymore.
		 There are just a few open handles left. */
@


1.40
log
@Clean up whitespace.
@
text
@a1041 2
      /* Always close handles before locking the node. */
      NtClose (obj);
d1045 2
@


1.39
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d1031 1
a1031 1
         Unfortunately, since BSD flock locks are not attached to a specific
@


1.38
log
@	* flock.cc (inode_t::unlock_and_remove_if_unused): Rename from
	unlock_and_remove.
@
text
@d1523 1
a1523 1
  syscall_printf ("%d = flock (%d, %d)", res, fd, operation);
d1579 1
a1579 1
  syscall_printf ("%d = lockf (%d, %d, %D)", res, filedes, function, size);
@


1.37
log
@	* flock.cc (LOCK_OBJ_NAME_LEN): Change to accommodate extra lf_ver
	field.
	(class lockf_t): Add lf_ver field.
	(lockf_t::lockf_t): Initialize lf_ver to 0.
	(class inode_t): Change i_wait to i_cnt.  Change comment to explain
	change in usage.
	(inode_t:use): Rename from wait.  Make private.
	(inode_t::unuse): Rename from unwait.  Make private.
	(inode_t::inuse): Rename from waiting.  Make private.
	(inode_t::notused): New public method to set use count to 0.
	(inode_t::unlock_and_remove): New method to unlock node and to delete
	it if it's unused in current process.
	(fhandler_base::del_my_locks): Drop global list lock.  Drop variable
	no_locks_left.  Simpify unlocking and removing node by just calling
	unlock_and_remove.
	(fixup_lockf_after_exec): Call notused method for each node.
	(inode_t::get): Call use method.  Lock node only if outside of list
	lock.
	(inode_t::get_all_locks_list): Accommodate additional lf_ver field
	when creating lockf_t structure from object name.
	(lockf_t::create_lock_obj_attr): Accommodate additional lf_ver field
	when creating object name from lockf_t structure.  Handle
	STATUS_OBJECT_NAME_COLLISION gracefully in F_POSIX case as well.
	Change comment accordingly.  Increment lf_ver field rather than high
	byte of lf_wid field.  Simplify comment.
	(fhandler_disk_file::lock): Always call unlock_and_remove rather than
	just UNLOCK on node.
	(lf_setlock): Move ret definition where it's used.  Drop unneeded
	tests for obj being not NULL.  Only check for deadlock condition if the
	lock we're trying to establish is a POSIX lock.  Revamp object
	collecting and wait code to cover all cases.  Don't return with EDEADLK
	if blocking process can't be opened for synchronization in F_POSIX case,
	rather just wait like in F_FLOCK case.  Change system_printf to
	debug_printf in that case.  Only run WaitForMultipleObjects with high
	priority.  Close obj and process handles prior to locking node.
@
text
@d315 1
a315 1
    void unlock_and_remove ();
d332 1
a332 1
inode_t::unlock_and_remove ()
d403 1
a403 1
      node->unlock_and_remove ();
d854 1
a854 1
	  node->unlock_and_remove ();
d868 1
a868 1
      node->unlock_and_remove ();
d904 1
a904 1
  node->unlock_and_remove ();
@


1.36
log
@	* fhandler.cc (fhandler_base::open): Fix typo in comment.
	(fhandler_base::close): Move call to del_my_locks from here...
	* fhandler_disk_file.cc (fhandler_disk_file::open): ...to here.
	* flock.cc (struct lockfattr_t): New type.
	(lockf_t::close_lock_obj): New method, use throughout.
	(lockf_t::create_lock_obj_attr): New method.
	(lockf_t::create_lock_obj): Use create_lock_obj_attr method.  Handle
	STATUS_OBJECT_NAME_COLLISION in F_FLOCK case gracefully.  Add lengthy
	comments to explain why and how.
	(lockf_t::open_lock_obj): Use create_lock_obj_attr method.
	(lockf_t::del_lock_obj): Call NtSetEvent rather than SetEvent for
	symmetry.
	(fhandler_disk_file::lock): Define n only where it's used.  Call
	need_fork_fixup only if call was successful.  Handle EINTR and
	ECANCELED return values from lf_setlock.
	(lf_setlock): Drop WAIT_UNLOCKED and WAIT_PROC_EXITED.  Don't wait
	for event object handle count to become <= 1 in F_LOCK case.
	Simplify WFMO return value handling.  Don't handle signal and cancel
	events here; just return with appropriate error code instead.
	(lf_getblock): Ignore locks for which the handle can't be opened.
	Use IsEventSignalled.
	* ntdll.h (STATUS_INVALID_INFO_CLASS): Undef if defined elsewhere to
	make sure the definition is casted to NTSTATUS.
	(STATUS_INVALID_HANDLE): Define and ditto.
	(STATUS_OBJECT_NAME_COLLISION): Define.
	(NtSetEvent): Declare.
@
text
@d127 1
a127 1
#define LOCK_OBJ_NAME_LEN	64
d235 4
d246 1
a246 1
      lf_wid (0), lf_head (NULL), lf_inode (NULL),
d249 3
a251 2
    lockf_t (class inode_t *node, class lockf_t **head, short flags, short type,
	   _off64_t start, _off64_t end, long long id, DWORD wid)
d253 1
a253 1
      lf_id (id), lf_wid (wid), lf_head (head), lf_inode (node),
d283 3
a285 3
    LIST_ENTRY (inode_t)  i_next;
    lockf_t	     *i_lockf;  /* List of locks of this process. */
    lockf_t	     *i_all_lf; /* Temp list of all locks for this file. */
d287 2
a288 2
    __dev32_t	     i_dev;    /* Device ID */
    __ino64_t	     i_ino;    /* inode number */
d291 7
a297 4
    HANDLE	     i_dir;
    HANDLE	     i_mtx;
    unsigned long    i_wait;   /* Number of blocked threads waiting for
				  a blocking lock. */
d313 3
a315 3
    void wait () { ++i_wait; }
    void unwait () { if (i_wait > 0) --i_wait; }
    bool waiting () { return i_wait > 0; }
d331 14
a388 1
  INODE_LIST_LOCK ();
d401 3
a403 11
      bool no_locks_left =
	node->del_my_locks (from == after_fork ? 0 : get_unique_id (),
			    from == after_exec ? NULL : get_handle ());
      if (no_locks_left)
	{
	  LIST_REMOVE (node, i_next);
	  node->UNLOCK ();
	  delete node;
	}
      else
	node->UNLOCK ();
a404 1
  INODE_LIST_UNLOCK ();
d423 1
d444 1
d472 3
a475 1
  INODE_LIST_UNLOCK ();
d480 1
a480 1
: i_lockf (NULL), i_all_lf (NULL), i_dev (dev), i_ino (ino), i_wait (0L)
d535 2
a536 2
      /* "%02x-%01x-%016X-%016X-%016X-%08x",
	 lf_flags, lf_type, lf_start, lf_end, lf_id, lf_wid */
d556 3
d569 2
a570 1
      new (lock++) lockf_t (this, &i_all_lf, flags, type, start, end, id, wid);
d583 1
a583 1
  __small_swprintf (attr->name, L"%02x-%01x-%016X-%016X-%016X-%08x",
d585 1
a585 1
		    lf_id, lf_wid);
d608 1
a608 1
	  if (status != STATUS_OBJECT_NAME_COLLISION || (lf_flags & F_POSIX))
d610 7
a616 7
	  /* If we get a STATUS_OBJECT_NAME_COLLISION in the F_FLOCK case, the
	     event still exists because some other process is waiting for it
	     in lf_setlock.  If so, open the event and check the signal state.
	     If we can't open it, it has been closed in the meantime, so just
	     try again.  If we can open it and the object is not signalled,
	     it's surely a bug in the code somewhere.  Otherwise, close the
	     event and retry to create an event with another name. */
d622 2
a623 7
	      /* Change the lf_wid member to generate another name for the
		 event, so as not to colide with the still-in-use event.
		 Changing lf_wid is ok, because the Windows PID is not used
		 for synchronization in the F_FLOCK case.
		 What we do here is to increment the highest byte in lf_wid. */
	      lf_wid = ((lf_wid & 0xff000000) + (1 << 24))
		       | (lf_wid & 0xffffff);
d854 1
a854 1
	  node->UNLOCK ();
d865 1
a865 1
			       myself->dwProcessId);
d868 1
a868 1
      node->UNLOCK ();
d904 1
a904 10
  if (node->i_lockf == NULL && !node->waiting ())
    {
      INODE_LIST_LOCK ();
      LIST_REMOVE (node, i_next);
      node->UNLOCK ();
      delete node;
      INODE_LIST_UNLOCK ();
    }
  else
    node->UNLOCK ();
a948 1
      DWORD ret;
d957 1
a959 2
	  if (obj)
	    NtClose (obj);
d977 4
a980 4
      for (lockf_t *lk = node->i_lockf; lk; lk = lk->lf_next)
	if ((lk->lf_flags & F_POSIX) && get_obj_handle_count (lk->lf_obj) > 1)
	  {
	    if (obj)
d982 2
a983 2
	    return EDEADLK;
	  }
d1003 1
a1003 9
      /* Wait for the blocking object and its holding process. */
      if (!obj)
	{
	  /* We can't synchronize on the lock event object.
	     Treat this as a deadlock-like situation for now. */
	  system_printf ("Can't sync with lock object hold by "
			 "Win32 pid %lu: %E", block->lf_wid);
	  return EDEADLK;
	}
d1005 3
a1007 7
      HANDLE cancel_event = pthread::get_cancel_event ();

      int wait_count = 0;
      /* The lock event is always the first object, all other wait objects
	 are variable.  */
      DWORD WAIT_SIGNAL_ARRIVED = WAIT_TIMEOUT + 1;
      DWORD WAIT_THREAD_CANCELED = WAIT_TIMEOUT + 1;
d1009 1
a1009 1
      SetThreadPriority (GetCurrentThread (), priority);
d1012 1
a1012 1
	  HANDLE proc = OpenProcess (SYNCHRONIZE, FALSE, block->lf_wid);
d1014 7
a1020 9
	    {
	      /* If we can't synchronize on the process holding the lock,
		 we will never recognize when the lock has been abandoned.
		 Treat this as a deadlock-like situation for now. */
	      system_printf ("Can't sync with process holding a lock "
			     "(Win32 pid %lu): %E", block->lf_wid);
	      NtClose (obj);
	      return EDEADLK;
	    }
d1022 6
a1027 12
	  HANDLE w4[4] = { obj, proc, signal_arrived, cancel_event };
	  wait_count = 3;
	  WAIT_SIGNAL_ARRIVED = WAIT_OBJECT_0 + 2;
	  if (cancel_event)
	    {
	      wait_count = 4;
	      WAIT_THREAD_CANCELED = WAIT_OBJECT_0 + 3;
	    }
	  node->wait ();
	  node->UNLOCK ();
	  ret = WaitForMultipleObjects (wait_count, w4, FALSE, INFINITE);
	  CloseHandle (proc);
a1028 10
      else
	{
	  HANDLE w4[3] = { obj, signal_arrived, cancel_event };
	  wait_count = 2;
	  WAIT_SIGNAL_ARRIVED = WAIT_OBJECT_0 + 1;
	  if (cancel_event)
	    {
	      wait_count = 3;
	      WAIT_THREAD_CANCELED = WAIT_OBJECT_0 + 2;
	    }
d1030 16
a1045 9
	  node->wait ();
	  node->UNLOCK ();
	  /* Unfortunately, since BSD flock locks are not attached to a
	     specific process, we can't recognize an abandoned lock by
	     sync'ing with a process.  We have to make sure we're the only
	     process left accessing this event object, or that the event
	     object is in a signalled state. */
	  ret = WaitForMultipleObjects (wait_count, w4, FALSE, 100L);
	}
a1046 3
      node->unwait ();
      NtClose (obj);
      SetThreadPriority (GetCurrentThread (), old_prio);
d1064 1
a1064 1
	   Just a timeout.  Just retry. */
@


1.35
log
@whitespace elimination
@
text
@d109 1
d216 8
d228 2
a229 2
    short	   lf_flags; /* Semantics: F_POSIX, F_FLOCK, F_WAIT */
    short	   lf_type;  /* Lock type: F_RDLCK, F_WRLCK */
d234 1
a234 1
    DWORD	   lf_wid;   /* Win PID of the resource holding the lock */
d238 1
a238 1
    HANDLE	   lf_obj;   /* Handle to the lock event object. */
d263 3
d268 1
d558 15
d574 1
a574 3
   namespace.  The name is constructed from the lock properties which
   identify it uniquely, all values in hex.  See the __small_swprintf
   call right at the start.  */
d578 1
a578 3
  WCHAR name[LOCK_OBJ_NAME_LEN + 1];
  UNICODE_STRING uname;
  OBJECT_ATTRIBUTES attr;
d581 32
a612 11
  __small_swprintf (name, L"%02x-%01x-%016X-%016X-%016X-%08x",
			  lf_flags & (F_POSIX | F_FLOCK), lf_type, lf_start,
			  lf_end, lf_id, lf_wid);
  RtlInitCountedUnicodeString (&uname, name,
			       LOCK_OBJ_NAME_LEN * sizeof (WCHAR));
  InitializeObjectAttributes (&attr, &uname, OBJ_INHERIT, lf_inode->i_dir,
			      everyone_sd (FLOCK_EVENT_ACCESS));
  status = NtCreateEvent (&lf_obj, CYG_EVENT_ACCESS, &attr,
			  NotificationEvent, FALSE);
  if (!NT_SUCCESS (status))
    api_fatal ("NtCreateEvent(lock): %p", status);
d619 1
a619 3
  WCHAR name[LOCK_OBJ_NAME_LEN + 1];
  UNICODE_STRING uname;
  OBJECT_ATTRIBUTES attr;
d622 2
a623 7
  __small_swprintf (name, L"%02x-%01x-%016X-%016X-%016X-%08x",
			  lf_flags & (F_POSIX | F_FLOCK), lf_type, lf_start,
			  lf_end, lf_id, lf_wid);
  RtlInitCountedUnicodeString (&uname, name,
			       LOCK_OBJ_NAME_LEN * sizeof (WCHAR));
  InitializeObjectAttributes (&attr, &uname, 0, lf_inode->i_dir, NULL);
  status = NtOpenEvent (&lf_obj, FLOCK_EVENT_ACCESS, &attr);
d632 3
a634 3
/* Close a lock event handle.  The important thing here is to signal it
   before closing the handle.  This way all threads waiting for this
   lock can wake up. */
d649 2
a650 3
	SetEvent (lf_obj);
      NtClose (lf_obj);
      lf_obj = NULL;
a682 1
  lockf_t *n;
d797 2
a804 1
  need_fork_fixup (true);
d884 1
a884 1
      n = lock->lf_next;
d899 1
a899 1
  if (error)
d901 12
a912 2
      set_errno (error);
      return -1;
d914 2
a915 1
  return 0;
d1012 2
a1013 4
      /* The lock is always the first object. */
      const DWORD WAIT_UNLOCKED = WAIT_OBJECT_0;
      /* All other wait objects are variable.  */
      DWORD WAIT_PROC_EXITED = WAIT_TIMEOUT + 1;
a1033 1
	  WAIT_PROC_EXITED = WAIT_OBJECT_0 + 1;
d1060 4
a1063 13
	     sync'ing with a process.  We have to find out if we're the only
	     process left accessing this event object. */
	  do
	    {
	      ret = WaitForMultipleObjects (wait_count, w4, FALSE, 100L);
	    }
	  while (ret == WAIT_TIMEOUT && get_obj_handle_count (obj) > 1);
	  /* There's a good chance that the above loop is left with
	     ret == WAIT_TIMEOUT if another process closes the file handle
	     associated with this lock.  This is for all practical purposes
	     equivalent to a signalled lock object. */
	  if (ret == WAIT_TIMEOUT)
	    ret = WAIT_OBJECT_0;
d1069 1
a1069 5
      if (ret == WAIT_UNLOCKED)
	; /* The lock object has been set to signalled. */
      else if (ret == WAIT_PROC_EXITED)
	; /* For POSIX locks, the process holding the lock has exited. */
      else if (ret == WAIT_SIGNAL_ARRIVED)
d1072 3
a1074 2
	  if (!_my_tls.call_signal_handler ())
	    return EINTR;
d1079 3
a1081 1
	  pthread::static_cancel_self ();
d1084 4
a1087 5
	{
	  system_printf ("Shouldn't happen! ret = %lu, error: %lu\n",
			 ret, GetLastError ());
	  return geterrno_from_win_error ();
	}
d1305 1
a1305 1
	NtClose (block->lf_obj);
a1332 2
  NTSTATUS status;
  EVENT_BASIC_INFORMATION ebi;
d1343 12
a1354 11
	  if (!overlap->open_lock_obj () || (overlap->lf_flags & F_POSIX))
	    return overlap;
	  /* In case of BSD flock locks, check if the event object is
	     signalled.  If so, the overlap doesn't actually exist anymore.
	     There are just a few open handles left. */
	  status = NtQueryEvent (overlap->lf_obj, EventBasicInformation,
				 &ebi, sizeof ebi, NULL);
	  if (!NT_SUCCESS (status) || ebi.SignalState == 0)
	    return overlap;
	  NtClose (overlap->lf_obj);
	  overlap->lf_obj = NULL;
@


1.34
log
@	* fhandler_windows.cc (fhandler_windows::read): Use
	pthread::get_cancel_event to fetch thread's cancel event.
	* flock.cc (lf_setlock): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Ditto.
	* thread.cc (pthread::get_cancel_event): New static method.
	* thread.h (pthread::get_cancel_event): Declare.
@
text
@d219 4
a222 4
    short           lf_flags; /* Semantics: F_POSIX, F_FLOCK, F_WAIT */
    short           lf_type;  /* Lock type: F_RDLCK, F_WRLCK */
    _off64_t        lf_start; /* Byte # of the start of the lock */
    _off64_t        lf_end;   /* Byte # of the end of the lock (-1=EOF) */
d225 1
a225 1
    DWORD           lf_wid;   /* Win PID of the resource holding the lock */
d229 1
a229 1
    HANDLE          lf_obj;   /* Handle to the lock event object. */
d266 2
a267 2
    lockf_t              *i_lockf;  /* List of locks of this process. */
    lockf_t              *i_all_lf; /* Temp list of all locks for this file. */
d269 2
a270 2
    __dev32_t             i_dev;    /* Device ID */
    __ino64_t             i_ino;    /* inode number */
d273 4
a276 4
    HANDLE                i_dir;
    HANDLE                i_mtx;
    unsigned long	  i_wait;   /* Number of blocked threads waiting for
				       a blocking lock. */
@


1.33
log
@	* fcntl.cc (fcntl64): Call pthread_testcancel.
	* fhandler_socket.cc (fhandler_socket::connect): Ditto.
	(fhandler_socket::accept4): Ditto.
	(fhandler_socket::recvfrom): Ditto.
	(fhandler_socket::recvmsg): Ditto.
	(fhandler_socket::sendto): Ditto.
	(fhandler_socket::sendmsg): Ditto.
	* flock.cc (lf_setlock): Allow to cancel thread running blocking
	file lock.  Try to make code more readable.
	(lockf): Call pthread_testcancel.
	* mmap.cc (msync): Ditto.
	* posix_ipc.cc (ipc_cond_timedwait): Call pthread::static_cancel_self
	rather than pthread_testcancel.
	* select.cc (cygwin_select): Call pthread_testcancel.
	* syscalls.cc (pread): Ditto.
	(pwrite): Ditto.
	(readv): Ditto.
	(writev): Ditto.
	(open): Ditto.
	(close): Ditto.
	(fsync): Ditto.
	* termios.cc (tcdrain): Ditto.
	* thread.cc: Align list of cancellation points with above changes.
	Mark not-implemented functions, too.
	(cancelable_wait): Don't set unused object indices to WAIT_FAILED
	since that could result in wrong behaviour.  Set them to the invalid
	value WAIT_TIMEOUT + 1 instead.
@
text
@d961 1
a961 4
      pthread_t thread = pthread::self ();
      HANDLE cancel_event = (thread && thread->cancel_event
			     && thread->cancelstate != PTHREAD_CANCEL_DISABLE)
			    ? thread->cancel_event : NULL;
@


1.32
log
@	* advapi32.cc: Add comment.
	(EqualSid): Remove.
	(CopySid): Remove.
	(AddAccessAllowedAce): Remove.
	(AddAccessDeniedAce): Remove.
	(MakeSelfRelativeSD): Remove.
	* flock.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
	* security.h: Ditto.
	(RtlEqualSid): Declare.  Explain why.
	(RtlCopySid): Ditto.
@
text
@d960 14
d988 10
a997 1
	  HANDLE w4[3] = { obj, proc, signal_arrived };
d1000 1
a1000 1
	  ret = WaitForMultipleObjects (3, w4, FALSE, INFINITE);
d1005 9
a1013 1
	  HANDLE w4[2] = { obj, signal_arrived };
d1022 1
a1022 1
	      ret = WaitForMultipleObjects (2, w4, FALSE, 100L);
d1036 5
a1040 1
      switch (ret)
a1041 9
	case WAIT_OBJECT_0:
	  /* The lock object has been set to signalled. */
	  break;
	case WAIT_OBJECT_0 + 1:
	  /* For POSIX locks, the process holding the lock has exited. */
	  if (lock->lf_flags & F_POSIX)
	    break;
	  /*FALLTHRU*/
	case WAIT_OBJECT_0 + 2:
d1043 10
a1052 3
	  _my_tls.call_signal_handler ();
	  return EINTR;
	default:
d1526 2
@


1.31
log
@	* cygerrno.h (geterrno_from_nt_status): Declare.
	* errno.cc (geterrno_from_nt_status): Define.
	* flock.cc: Fix copyright dates.
	* ntdll.h (enum _TIMER_TYPE): Define.
	(PTIMER_APC_ROUTINE): Define.
	(NtCancelTimer): Declare.
	(NtCreateTimer): Declare.
	(NtSetTimer): Declare.
	* posix_ipc.cc (ipc_cond_timedwait): Rewrite to make interruptible and
	restartable.  Call pthread_testcancel in case of timeout to enable
	pthread_cancel on waiting thread.  Replace WFMO timeout with waiting
	for a waitable timer.  Explain why.  Replace single call to WFMO with
	two calls, one for the event, one for the mutex.  Don't lock mutex in
	case of error.
	(ipc_cond_signal): Make void function.
	(ipc_cond_close): Ditto.
	(_mq_send): Immediately return -1 in case of error from
	ipc_cond_timedwait.
	(_mq_receive): Ditto.
@
text
@d174 3
a176 2
  if (!AddAccessAllowedAce (dacl, ACL_REVISION, SYNCHRONIZE,
			    well_known_world_sid))
d178 1
a178 1
      debug_printf ("AddAccessAllowedAce: %lu", GetLastError ());
@


1.30
log
@	* advapi32.cc (InitializeAcl): Remove.
	(AddAce): Remove.
	(FindFirstFreeAce): Remove.
	(GetAce): Remove.
	(InitializeSecurityDescriptor): Remove.
	(OpenProcessToken): Remove.
	* dcrt0.cc: Replace above functions throughout with their ntdll.dll
	equivalent.
	* fhandler_tty.cc: Ditto.
	* flock.cc: Ditto.
	* pinfo.cc: Ditto.  Drop unnecessary error handling.
	* sec_acl.cc: Ditto.
	* sec_auth.cc: Ditto.
	* sec_helper.cc: Ditto.
	* security.cc: Ditto.
@
text
@d3 1
a3 1
   Copyright 2003, 2008, 2009 Red Hat, Inc.
@


1.29
log
@	* flock.cc (allow_others_to_sync): Define MAX_PROCESS_SD_SIZE.  Use
	instead of ACL_DEFAULT_SIZE.
	* sec_acl.cc (setacl): Use TLS buffer to allow maximum ACL size.
	* security.h (ACL_DEFAULT_SIZE): Drop definition.
	(ACL_MAXIMUM_SIZE): Define.
	(SD_MAXIMUM_SIZE): Define.
	* security.cc (get_file_sd): Allocate security_decscriptor with size
	SD_MAXIMUM_SIZE.
	(alloc_sd): Use TLS buffer to allow maximum ACL size.
@
text
@d181 2
a182 1
  if (!FindFirstFreeAce (dacl, &ace))
d184 1
a184 1
      debug_printf ("FindFirstFreeAce: %lu", GetLastError ());
@


1.28
log
@	* flock.cc (allow_others_to_sync): Use small stack buffer rather
	than big temp buffer.  Fix typo in comment.
	(lf_setlock): Revert to using tmp_pathbuf.
	(lf_getlock): Ditto.
@
text
@d158 2
a159 1
  PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR) alloca (ACL_DEFAULT_SIZE);
d162 1
a162 1
				  ACL_DEFAULT_SIZE, &len);
@


1.27
log
@* tmpbuf.h: New file.
* flock.cc: Include tmpbuf.h for new tmpbuf functionality.
(allow_others_to_sync): Use tmpbuf rather than tmp_pathbuf.  Explain why.
(lf_setlock): For consistency, use tmpbuf rather than tmp_pathbuf.
(lf_getlock): Ditto.
@
text
@d108 1
a108 1
#include "tmpbuf.h"
d154 5
a158 5
  /* Get this process DACL.  We use a temporary buffer to avoid having to
     alloc 64K from the stack.  Can't use tls functions at this point because
     this gets called during initialization when the tls is not really
     available.  */
  tmpbuf sd;
d161 1
a161 1
				  NT_MAX_PATH * sizeof (WCHAR), &len);
d167 1
a167 1
  /* Create a valid dacl pointer and set it's size to be as big as
d877 1
a877 1
  tmpbuf tp;
d889 1
a889 1
  node->i_all_lf = (lockf_t *) (void *) tp;
d1231 1
a1231 1
  tmpbuf tp;
d1234 1
a1234 1
  node->i_all_lf = (lockf_t *) (void * ) tp;
@


1.26
log
@	Throughout, replace hMainProc with GetCurrentProcess/NtCurrentProcess
	according to context.  Throughout, replace hMainThread with
	GetCurrentThread/NtCurrentThread according to context.
	* dcrt0.cc (dll_crt0_0): Drop duplication of GetCurrentProcess to
	hMainProc.  Drop duplication of GetCurrentThread to hMainThread.
	* dtable.cc (dtable::stdio_init): Remove useless comment.
	* globals.cc (hMainProc): Remove.
	(hMainThread): Remove.
	* ntdll.h (NtCurrentProcess): Define.
	(NtCurrentThread: Define.
@
text
@d108 1
a108 1
#include "tls_pbuf.h"
d154 5
a158 4
  /* Get this process DACL.  We use a temporary path buffer in TLS space
     to avoid having to alloc 64K from the stack. */
  tmp_pathbuf tp;
  PSECURITY_DESCRIPTOR sd = (PSECURITY_DESCRIPTOR) tp.w_get ();
d877 1
a877 1
  tmp_pathbuf tp;
d889 1
a889 1
  node->i_all_lf = (lockf_t *) tp.w_get ();
d1231 1
a1231 1
  tmp_pathbuf tp;
d1234 1
a1234 1
  node->i_all_lf = (lockf_t *) tp.w_get ();
@


1.25
log
@	* flock.cc (fhandler_disk_file::lock): Disable a shortcut from the
	original BSD code, but keep it in and documented why we can't use it.
@
text
@d158 2
a159 1
  status = NtQuerySecurityObject (hMainProc, DACL_SECURITY_INFORMATION, sd,
d186 1
a186 1
  status = NtSetSecurityObject (hMainProc, DACL_SECURITY_INFORMATION, sd);
@


1.24
log
@	* fhandler.h (enum del_lock_called_from): New enumeration.
	(fhandler_base::del_my_locks): Declare taking a del_lock_called_from
	as argument.
	* fhandler.cc (fhandler_base::close): Call del_my_locks with "on_close".
	(fhandler_base::fixup_after_fork): Call del_my_locks with "after_fork".
	(fhandler_base::fixup_after_exec): Call del_my_locks with "after_exec".
	* flock.cc (fhandler_base::del_my_locks): Take del_lock_called_from
	as argument.  Call node->del_my_locks with NULL handle in after_exec
	case.  Explain why.
@
text
@d770 1
d773 4
d787 1
@


1.23
log
@	Throughout avoid having to initialize constant UNICODE_STRINGs.
	* globals.cc: Define constant UNICODE_STRINGs and store in .rdata
	section.
	* fhandler_disk_file.cc: Throughout, use readonly UNICODE_STRINGs
	rather then initializing local UNICODE_STRING variable where
	applicable.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* flock.cc (inode_t::inode_t): Ditto.
	* mmap.cc: Ditto.
	* syscalls.cc: Ditto.
	* mount.cc (fs_info::update): Ditto.
	* path.cc: Ditto.

	* ntdll.h (RtlEqualUnicodePathPrefix): Redefine to take prefix as
	UNICODE_STRING.
	(RtlEqualUnicodePathSuffix): Redefine to take suffix as UNICODE_STRING.
	* fhandler_disk_file.cc: Accommodate throughout.
	* mount.cc (fs_info::update): Ditto.
	* path.cc (cwdstuff::set): Ditto.
	* syscalls.cc: Ditto.
@
text
@d347 1
a347 1
fhandler_base::del_my_locks (bool after_fork)
d353 9
d363 2
a364 1
	node->del_my_locks (after_fork ? 0 : get_unique_id (), get_handle ());
@


1.22
log
@* select.h: New file split from fhandler.h.
(select_record::select_record): Define do-nothing constructor for "new" to
avoid gratuitous zeroing.
(select_info): New base class.
(select_pipe_info): New class with methods for dealing with pipes.
(select_socket_info): New class with methods for dealing with sockets.
(select_serial_info): Dummy class for serial.
(select_mailslot_info): Dummy class for mailslots.
(select_stuff): Define device_specific_* as actual classes rather than void *.
* dtable.h (dtable::select_read): Accommodate return value change to 'bool' and
argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* dtable.cc (dtable::select_read): Accommodate return value change to 'bool'
and argument change to "select_stuff".
(dtable::select_write): Ditto.
(dtable::select_except): Ditto.
* fhandler.h: Excise select-related classes.
(fhandler_*::select_read): Change argument to select_stuff.
(fhandler_*::select_write): Ditto.
(fhandler_*::select_except): Ditto.
* select.cc (UNIX_FD_ZERO): Use memset rather than bzero.
(select_stuff::test_and_set): Change return type to bool.  Allocate
select_record on entry and let fhandler_*::select_* operate on the start.next
field of select_stuff.
(pipeinf): Delete.
(select_pipe_info::select_pipe_info): New constructor.  Allocates event for
controlling pipe waits.
(select_pipe_info::~select_pipe_info): New destructor.  Destroy event.  Stop
thread.
(select_pipe_info::add_watch_handle): New function.
(thread_pipe): Wait for the hEvent part of any overlapped pipes before peeking.
(start_thread_pipe): Don't allocate device_specific_pipe stuff here.  Assume
that it has been allocated earlier.
(pipe_cleanup): Rely on select_pipe_info destructor to clean up pipe
paraphenalia.
(fhandler_*::select_*): Derive select_record from new select_stuff argument.
(fhandler_pipe::select_*): Ditto.  Allocate pipe-specific field if not already
allocated.
(serialinf): Delete.
(thread_serial): serialinf -> select_serial_info.
(fhandler_base::ready_for_read): Rewrite to accommodate change in argument to
fhandler_*::select_*.
(socketinf): Delete.
(thread_socket): socketinf -> select_socket_info.
(mailslotinf): Delete.
(thread_mailslot): mailslotinf -> select_mailslot_info.
@
text
@d456 1
a456 2
  RtlInitUnicodeString (&uname, L"mtx");
  InitializeObjectAttributes (&attr, &uname, OBJ_INHERIT | OBJ_OPENIF, i_dir,
@


1.21
log
@	* flock.cc (lf_setlock): Handle border case which results in WFMO loop
	exiting with ret == WAIT_TIMEOUT gracefully.  Add a system_printf to
	uncover other potential problems with WFMO loop.
@
text
@d289 1
a289 1
    bool waiting () { return i_wait > 0; } 
@


1.20
log
@	* flock.cc (class inode_t): Add i_wait member and matching methods
	wait(), unwait(), and waiting().
	(inode_t::inode_t): Initialize i_wait to 0.
	(fhandler_disk_file::lock): Only remove node if no other thread is
	waiting for a blocking lock.
	(lf_setlock): Manipulate node->i_wait to signal that a thread is
	waiting for a blocking lock in this node.
	(lf_findoverlap): Reinstantiate SELF test as in original code.
@
text
@d974 6
d1000 2
@


1.19
log
@	* flock.cc: Fix lockf copyright to latest version.
@
text
@d3 1
a3 1
   Copyright 2003, 2008 Red Hat, Inc.
d270 2
d287 4
d436 1
a436 1
: i_lockf (NULL), i_all_lf (NULL), i_dev (dev), i_ino (ino)
d832 1
a832 1
  if (node->i_lockf == NULL)
d955 1
d963 1
d976 1
d1295 2
a1296 1
      if (((type & OTHERS) && lf->lf_id == lock->lf_id)
@


1.18
log
@	* flock.cc (fhandler_disk_file::lock): Don't test file open mode in
	case of flock-type locks.  Explain why.
@
text
@d63 2
a64 1
 *
a78 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d91 1
a91 4
 *
 *
 * $NetBSD: lockf.c,v 1.1 1997/12/20 20:23:18 kleink Exp $
*/
@


1.17
log
@Remove unneeded whitespace.
* fhandler_fifo.cc (fhandler_fifo::open): Rework to cause errno to be set to
ENXIO when opening a fifo write/nonblocking.
* environ.cc (ucreqenv): Rename to ucenv.  Move code from old ucenv here and
conditionalize it on create_upcaseenv.
(ucenv): Delete.
(environ_init): Fix compiler warning by moving create_upcaseenv test to ucenv.
Don't bother checking for child_proc_info when calling ucenv since it is
assumed to be NULL at the point where the function is called.
* path.cc (symlink_worker): Turn off MS-DOS path warnings when dealing with
devices since the device handler passes in a translated MS-DOS path.
* sec_auth.cc (lsaprivkeyauth): Avoid variable initialization which causes a
compiler error.
* fhandler_netdrive.cc: Update copyright.
@
text
@d655 5
a659 1
	if (!(get_access () & GENERIC_READ))
d666 2
a667 1
	if (!(get_access () & GENERIC_WRITE))
@


1.16
log
@	* flock.cc (inode_t::get_all_locks_list): Fix typo.
	* posix.sgml: Add cfmakeraw to list of implemented BSD functions.
@
text
@d16 2
a17 2
   purposes. 
   
d52 1
a52 1
*/   
d357 1
a357 1
      	node->del_my_locks (after_fork ? 0 : get_unique_id (), get_handle ());
d504 1
a504 1
        continue;
d507 1
a507 1
        continue;
d510 1
a510 1
      	continue;
d514 1
a514 1
      	continue;
d517 1
a517 1
      	continue;
d519 1
a519 1
        {
d525 1
a525 1
        lock[-1].lf_next = lock;
d640 1
a640 1
  
d655 1
a655 1
        if (!(get_access () & GENERIC_READ))
d662 1
a662 1
        if (!(get_access () & GENERIC_WRITE))
d669 1
a669 1
      	set_errno (EINVAL);
d779 1
a779 1
        {
d808 1
a808 1
      clean = lock; 
d810 1
a810 1
    
d853 1
a853 1
{ 
d899 1
a899 1
                this process holds.  If it's > 1, another process is
d940 1
a940 1
        {
d958 1
a958 1
        {
d980 1
a980 1
	  /* For POSIX locks, the process holding the lock has exited. */ 
d1019 1
a1019 1
        case 0: /* no overlap */
d1025 2
a1026 2
            }
            break;
d1028 1
a1028 1
        case 1: /* overlap == lock */
d1041 1
a1041 1
        case 2: /* overlap contains lock */
d1066 1
a1066 1
        case 3: /* lock contains overlap */
d1090 1
a1090 1
        case 4: /* overlap starts before lock */
d1104 1
a1104 1
        case 5: /* overlap ends after lock */
d1149 1
a1149 1
        case 1: /* overlap == lock */
d1155 1
a1155 1
        case 2: /* overlap contains lock: split it */
d1169 1
a1169 1
        case 3: /* lock contains overlap */
d1176 4
a1179 4
        case 4: /* overlap starts before lock */
            overlap->lf_end = unlock->lf_start - 1;
            prev = &overlap->lf_next;
            lf = overlap->lf_next;
d1181 1
a1181 1
            continue;
d1183 2
a1184 2
        case 5: /* overlap ends after lock */
            overlap->lf_start = unlock->lf_end + 1;
d1186 1
a1186 1
            break;
d1232 1
a1232 1
{   
d1275 1
a1275 1
 */ 
d1298 1
a1298 1
        }
d1319 1
a1319 1
        }
d1363 1
a1363 1
  /* 
@


1.15
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d503 1
a503 1
      if (type != (F_RDLCK && type != F_WRLCK) || !endptr || *endptr != L'-')
@


1.14
log
@	* Makefile.in (DLL_OFILES): Add kernel32.o.
	* autoload.cc (WSACloseEvent): Remove.
	(WSACreateEvent): Remove.
	* cygheap.cc (cygheap_init): Drop initializing shared_prefix.
	* cygheap.h (struct init_cygheap): Drop shared_prefix and
	shared_prefix_buf members.
	* fhandler_socket.cc (sock_shared_name): New static function.
	(search_wsa_event_slot): Convert name buffers to WCHAR.  Call
	NtCreateMutant/NtOpenMutant to create mutexes in session local
	namespace.
	(fhandler_socket::init_events): Ditto.  Fix debug output.
	(fhandler_socket::release_events): Close mutexes using NtClose.
	(fhandler_socket::dup): Ditto.
	* kernel32.cc: New file, implementing Win32 calls in a Cygwin-specific
	way.
	* mmap.cc (MapView): Make static.
	* ntdll.h: Fix status code sorting.
	(STATUS_OBJECT_NAME_EXISTS): Define.
	(SEMAPHORE_QUERY_STATE): Define.
	(CYG_SHARED_DIR_ACCESS): Define.
	(CYG_MUTANT_ACCESS): Define.
	(CYG_EVENT_ACCESS): Define.
	(CYG_SEMAPHORE_ACCESS): Define.
	(enum _PROCESSINFOCLASS): Define ProcessSessionInformation.
	(struct _PROCESS_SESSION_INFORMATION): Define.
	(NtCreateSemaphore): Declare.
	(NtOpenSemaphore): Declare.
	* flock.cc: Use CYG_xxx_ACCESS access masks where appropriate.
	* posix_ipc.cc (ipc_mutex_init): Use native functions to create mutex.
	Create in cygwin-shared subdir.
	(ipc_cond_init): Ditto for event.
	(ipc_mutex_close): Use NtClose.
	(ipc_cond_close): Ditto.
	(mq_open): Drop "cyg" prefix from mqh_uname.
	* shared.cc (CYG_SHARED_DIR_ACCESS): Drop definition here.
	(_cygwin_testing): Declare extern on file level.
	(get_shared_parent_dir): Change name of shared directory.  Add name
	to api_fatal output.
	(get_session_parent_dir): New function.
	(shared_name): Simplify.
	(shared_info::initialize): Call get_session_parent_dir.
	* shared_info.h (get_session_parent_dir): Declare.
	* smallprint.cc (__small_vswprintf): Fix bug in multibyte string
	conversion.
	* thread.cc (semaphore::semaphore): Align semaphore name to object
	names in posix IPC functions.
	* include/cygwin/version.h (CYGWIN_VERSION_SHARED_DATA): Bump.
@
text
@d500 1
a500 1
	  || (flags & (F_FLOCK | F_POSIX) == (F_FLOCK | F_POSIX)))
d503 1
a503 1
      if (type != F_RDLCK && type != F_WRLCK || !endptr || *endptr != L'-')
d1445 1
a1445 1
  if (res == -1 && (get_errno () == EAGAIN) || (get_errno () == EACCES))
@


1.13
log
@	* fhandler.h (-struct wsa_event): Move to wsa_event.h.  Include
	wsa_event.h instead.
	* fhandler_socket.cc (NUM_SOCKS): Move to wsa_event.h.
	(wsa_events): Move from DLL shared area to cygwin_shared shared
	memory.  Accommodate throughout.
	(socket_serial_number): Ditto.
	* fhandler_tape.cc (mt): Ditto.
	(mtinfo_init): Remove.
	(mt): Define as cygwin_shared->mt.
	* flock.cc (FLOCK_PARENT_DIR_ACCESS): Remove.
	(FLOCK_INODE_DIR_ACCESS): Move up in file.
	(FLOCK_MUTANT_ACCESS): Ditto.
	(FLOCK_EVENT_ACCESS): Ditto.
	(get_lock_parent_dir): Remove.
	(inode_t::inode_t): Call get_shared_parent_dir to get parent dir handle.
	Add a "flock-" prefix to file's lock directory name for clarity.
	* mtinfo.h (mtinfo_init): Drop declaration.
	* net.cc (last_used_bindresvport): Move from DLL shared area to
	cygwin_shared shared memory.
	(cygwin_bindresvport_sa): Accommodate above change.
	* sec_helper.cc (_everyone_sd): Move here from flock.cc.
	* security.h (SD_MIN_SIZE): Ditto.
	(everyone_sd): Ditto.
	* shared.cc (cygwin_shared_area): Remove.
	(cygwin_shared_h): New handle.
	(get_shared_parent_dir): New static function.
	(shared_name): Drop session_local argument.  Call get_shared_parent_dir
	here.  Add cygwin-shared subdir to object name.
	(offsets): Reinstantiate SH_CYGWIN_SHARED member.
	(open_shared): Revert change from 2007-03-29 for systems supporting
	SeCreateGlobalPrivilege.
	(shared_info::initialize): Call mtinfo's initialize here.
	(memory_init): Drop call to mtinfo_init.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add members for global socket and tape info
	sharing.
	(enum shared_locations): Reinstantiate SH_CYGWIN_SHARED.
	(get_shared_parent_dir): Declare.
	(shared_name): Drop session_local argument from declaration.
	* wsa_event.h: New file.  Move definitions of NUM_SOCKS and
	struct wsa_event here.
@
text
@a141 4
#define FLOCK_MUTANT_ACCESS	(MUTANT_QUERY_STATE \
				 | SYNCHRONIZE \
				 | READ_CONTROL)

d461 2
a462 2
			      everyone_sd (FLOCK_MUTANT_ACCESS));
  status = NtCreateMutant (&i_mtx, FLOCK_MUTANT_ACCESS, &attr, FALSE);
d553 1
a553 1
  status = NtCreateEvent (&lf_obj, EVENT_ALL_ACCESS, &attr,
@


1.12
log
@Remove unneeded header files from source files throughout.
@
text
@d109 1
d137 13
a206 78
/* Helper function to create an event security descriptor which only allows
   specific access to everyone.  Only the creating process has all access
   rights. */

#define FLOCK_PARENT_DIR_ACCESS	(DIRECTORY_QUERY \
				 | DIRECTORY_TRAVERSE \
				 | DIRECTORY_CREATE_SUBDIRECTORY \
				 | READ_CONTROL)

#define FLOCK_INODE_DIR_ACCESS	(DIRECTORY_QUERY \
				 | DIRECTORY_TRAVERSE \
				 | DIRECTORY_CREATE_OBJECT \
				 | READ_CONTROL)

#define FLOCK_MUTANT_ACCESS	(MUTANT_QUERY_STATE \
				 | SYNCHRONIZE \
				 | READ_CONTROL)

#define FLOCK_EVENT_ACCESS	(EVENT_QUERY_STATE \
				 | SYNCHRONIZE \
				 | READ_CONTROL)

#define SD_MIN_SIZE (sizeof (SECURITY_DESCRIPTOR) + MAX_DACL_LEN (1))

#define everyone_sd(access)	(_everyone_sd (alloca (SD_MIN_SIZE), (access)))

PSECURITY_DESCRIPTOR
_everyone_sd (void *buf, ACCESS_MASK access)
{
  PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR) buf;

  if (psd)
    {
      InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION);
      PACL dacl = (PACL) (psd + 1);
      InitializeAcl (dacl, MAX_DACL_LEN (1), ACL_REVISION);
      if (!AddAccessAllowedAce (dacl, ACL_REVISION, access, 
				well_known_world_sid))
	{
	  debug_printf ("AddAccessAllowedAce: %lu", GetLastError ());
	  return NULL;
	}
      LPVOID ace;
      if (!FindFirstFreeAce (dacl, &ace))
	{
	  debug_printf ("FindFirstFreeAce: %lu", GetLastError ());
	  return NULL;
	}
      dacl->AclSize = (char *) ace - (char *) dacl;
      SetSecurityDescriptorDacl (psd, TRUE, dacl, FALSE);
    }
  return psd;
}

/* This function returns a handle to the top-level directory in the global
   NT namespace used to implement advisory locking. */
static HANDLE
get_lock_parent_dir ()
{
  static HANDLE dir;
  UNICODE_STRING uname;
  OBJECT_ATTRIBUTES attr;
  NTSTATUS status;

  INODE_LIST_LOCK();
  if (!dir)
    {
      RtlInitUnicodeString (&uname, L"\\BaseNamedObjects\\cygwin-fcntl-lk");
      InitializeObjectAttributes (&attr, &uname, OBJ_INHERIT | OBJ_OPENIF,
				  NULL, everyone_sd (FLOCK_PARENT_DIR_ACCESS));
      status = NtCreateDirectoryObject (&dir, FLOCK_PARENT_DIR_ACCESS, &attr);
      if (!NT_SUCCESS (status))
	api_fatal ("NtCreateDirectoryObject(parent): %p", status);
    }
  INODE_LIST_UNLOCK ();
  return dir;
}

d446 1
a446 1
  WCHAR name[32];
d451 1
a451 1
  parent_dir = get_lock_parent_dir ();
d454 1
a454 1
  int len = __small_swprintf (name, L"%08x-%016X", dev, ino);
@


1.11
log
@	* flock.cc (get_lock_parent_dir): Drop call to NtOpenDirectoryObject
	and utilize OBJ_OPENIF flag in call to NtCreateDirectoryObject.
	(inode_t::inode_t): Ditto.  Same for NtOpenMutant/NtCreateMutant.
@
text
@a104 1
#include <fcntl.h>
a107 1
#include "perprocess.h"
a108 1
#include "cygwin/version.h"
a112 1
#include "shared_info.h"
@


1.10
log
@	Throughout, call fcntl64 instead of fcntl or fcntl_worker.
	* fcntl.cc (fcntl_worker): Remove.
	(fcntl64): Add fault handler.  Move fcntl_worker stuff here.  Add case
	for locking and call fhandler's lock method directly.  Make sure that
	F_FLOCK flag isn't set in lock call.
	(_fcntl): Add fault handler.
	* fhandler.cc (fhandler_base::fcntl): Drop lock cases.
	* flock.cc (flock): Add fault handler.  Simplify code.  Call fhandlers
	lock method directly instead of fcntl_worker.  Add debug output.
	(lockf): Add fault handler.  Call fhandlers lock method directly
	instead of fcntl_worker.  Add debug output.
	* winsup.h (fcntl_worker): Drop declaration.
	(fcntl64): Declare.
@
text
@d265 3
a267 3
      InitializeObjectAttributes (&attr, &uname, OBJ_INHERIT, NULL,
				  everyone_sd (FLOCK_PARENT_DIR_ACCESS));
      status = NtOpenDirectoryObject (&dir, FLOCK_PARENT_DIR_ACCESS, &attr);
d269 1
a269 6
	{
	  status = NtCreateDirectoryObject (&dir, FLOCK_PARENT_DIR_ACCESS,
					    &attr);
	  if (!NT_SUCCESS (status))
	    api_fatal ("NtCreateDirectoryObject(parent): %p", status);
	}
d524 3
a526 3
  InitializeObjectAttributes (&attr, &uname, OBJ_INHERIT, parent_dir,
			      everyone_sd (FLOCK_INODE_DIR_ACCESS));
  status = NtOpenDirectoryObject (&i_dir, FLOCK_INODE_DIR_ACCESS, &attr);
d528 1
a528 5
    {
      status = NtCreateDirectoryObject (&i_dir, FLOCK_INODE_DIR_ACCESS, &attr);
      if (!NT_SUCCESS (status))
	api_fatal ("NtCreateDirectoryObject(inode): %p", status);
    }
d532 1
a532 1
  InitializeObjectAttributes (&attr, &uname, OBJ_INHERIT, i_dir,
d534 1
a534 1
  status = NtOpenMutant (&i_mtx, FLOCK_MUTANT_ACCESS, &attr);
d536 1
a536 5
    {
      status = NtCreateMutant (&i_mtx, FLOCK_MUTANT_ACCESS, &attr, FALSE);
      if (!NT_SUCCESS (status))
	api_fatal ("NtCreateMutant(inode): %p", status);
    }
@


1.9
log
@	* smallprint.cc (__small_vswprintf): Fix uninitialized usage of `w'.

	Revamp advisory file locking to avoid cross reference pointers as well
	as to allow BSD flock semantics.  More agressively delete unused nodes
	and sync objects.
	* fhandler.h (fhandler_base::ino): Rename from namehash.  Fix comment.
	(fhandler_base::node): Remove.
	(fhandler_base::unique_id): Add.
	(fhandler_base::del_my_locks): New method.
	(get_ino): Rename from get_namehash.  Change usage throughout Cygwin.
	(get_unique_id): New method.
	* fhandler.cc (fhandler_base::close): Call own del_my_locks method.
	Fix comment.
	(fhandler_base::fhandler_base): Accommodate new and changed members.
	(fhandler_base::fixup_after_fork): Call del_my_locks.
	(fhandler_base::fixup_after_exec): Ditto for files with close-on-exec
	flag set.
	* fhandler_disk_file.cc (get_ino_by_handle): Rename from
	readdir_get_ino_by_handle.  Accommodate throughout.
	(fhandler_base::open_fs): Fill ino with inode number if FS has good
	inodes.  Allocate a LUID and store in unique_id to recognize file
	descriptors referencing the same file object.
	* flock.cc: Drop flock TODO comments.  Use explicit types __dev32_t
	and __ino64_t instead of dev_t and ino_t.
	(LOCK_OBJ_NAME_LEN): Change to reflect longer lf_id length.
	(get_obj_handle_count): New method.
	(lockf_t::lf_id): Change type to long long.
	(inode_t::get_lock_obj_handle_count): Drop in favor of static function
	get_obj_handle_count.
	(inode_t::del_locks): Remove.
	(inode_t::get): Add create_if_missing flag argument.
	(inode_t::del_my_locks): Reimplement to handle POSIX and BSD flock
	locks.  Return if node can be deleted or not.
	(inode_t::~inode_t): Ditto.  Close handles to i_dir and i_mtx.
	(fixup_lockf_after_fork): Remove.
	(fhandler_base::del_my_locks): New method.
	(fixup_lockf_after_exec): Check if node can be deleted.
	(inode_t::get): Only create node if create_if_missing is set.  Lock
	the returned node here before unlocking the node list.
	(inode_t::get_all_locks_list): Accommodate new lf_id length.
	(inode_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.  Change return type to bool.  De-const.
	Set lf_obj instead of returning a handle.
	(lockf_t::del_lock_obj): Call SetEvent only if new incoming parameters
	allow it.  Explain how it's supposed to work.
	(fhandler_disk_file::lock): Only fetch file length in SEEK_END case.
	Use NtQueryInformationFile(FileStandardInformation) instead of
	calling fstat_by_handle.  Always unlock node before returning.
	Use fhandler's unique id to create lf_id for BSD flock locks.
	Rely on node lock from inode_t::get.  Call del_lock_obj on removed
	locks here to allow explicit unlocking.  Delete node if no lock exists
	on the file anymore.
	(lf_setlock): Get file handle as additional parameter.  Handle the fact
	that lf_getblock now always opens the attached event object.  Reactivate
	erroneously applied patch which deactivates setting thread priority.
	Additionally handle blocking on BSD flock locks.
	(lf_clearlock): Get file handle as additional parameter.
	(lf_getlock): Close event handle opened by lf_getblock.
	(lf_getblock): Open potentially blocking event object here and check
	its signal state if it's a BSD flock lock.
	(lf_wakelock): Get file handle as additional parameter.
	* fork.cc (frok::child): Drop call to fixup_lockf_after_fork.
	* ntdll.h (struct _EVENT_BASIC_INFORMATION): Define.
	(enum _EVENT_INFORMATION_CLASS): Define.
	(NtQueryEvent): Declare.

	* fhandler.h (fhandler_base::fs_flags): Remove.
	(fhandler_base::set_fs_flags): Remove.
	(fhandler_base::get_fs_flags): Remove.
	* fhandler.cc (fhandler_base::write): Check for sparse file using
	pc.fs_flags().
	* fhandler_disk_file.cc (fhandler_disk_file::ftruncate): Ditto.

	The return of the volume serial number in fs_info.
	* fhandler.h (get_dev): New method.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Drop call to
	NtQueryVolumeInformationFile(FileFsVolumeInformation).  Just use
	get_dev() method.
	* fhandler_fifo.cc (fhandler_fifo::open) Use device ID and inode number
	to generate fifo name.
	* path.h (fs_info::sernum): New member.
	(fs_info::serial_number): New method.
	(path_conv::fs_serial_number): New method.
	* path.cc (fs_info::update): Fetch volume serial number and store in
	sernum.
@
text
@d61 1
a61 1
/* The lockf function has been taken from FreeBSD with the following
d838 2
a839 2
  /* Unlock the fd table which has been locked in fcntl_worker, otherwise
     a blocking F_SETLKW never wakes up on a signal. */
d1498 1
a1498 1
int
d1501 13
a1513 11
  int i, cmd;
  struct __flock64 l = { 0, 0, 0, 0, 0 };
  if (operation & LOCK_NB)
    {
      cmd = F_SETLK;
    }
  else
    {
      cmd = F_SETLKW;
    }
  l.l_whence = SEEK_SET;
d1517 1
a1517 9
      l.l_type = F_WRLCK | F_FLOCK;
      i = fcntl_worker (fd, cmd, &l);
      if (i == -1)
	{
	  if ((get_errno () == EAGAIN) || (get_errno () == EACCES))
	    {
	      set_errno (EWOULDBLOCK);
	    }
	}
d1520 1
a1520 9
      l.l_type = F_RDLCK | F_FLOCK;
      i = fcntl_worker (fd, cmd, &l);
      if (i == -1)
	{
	  if ((get_errno () == EAGAIN) || (get_errno () == EACCES))
	    {
	      set_errno (EWOULDBLOCK);
	    }
	}
d1523 1
a1523 9
      l.l_type = F_UNLCK | F_FLOCK;
      i = fcntl_worker (fd, cmd, &l);
      if (i == -1)
	{
	  if ((get_errno () == EAGAIN) || (get_errno () == EACCES))
	    {
	      set_errno (EWOULDBLOCK);
	    }
	}
a1525 1
      i = -1;
d1527 1
a1527 1
      break;
d1529 6
a1534 1
  return i;
d1540 1
a1540 1
  struct flock fl;
d1542 9
d1572 2
a1573 2
      if (fcntl_worker (filedes, F_GETLK, &fl) == -1)
	return -1;
d1575 4
a1578 3
	return 0;
      errno = EAGAIN;
      return -1;
d1582 1
a1582 1
      return -1;
d1585 4
a1588 2

  return fcntl_worker (filedes, cmd, &fl);
@


1.8
log
@	* flock.cc (lockf_t::operator new): Add operator taking a pointer.  Call
	cmalloc instead of ccalloc in the default operator.  Add comments.
	(inode_t::operator new): Call cmalloc instead of ccalloc.
	(inode_t::get_all_locks_list): Return lockf_t pointer.
	(inode_t::del_all_locks_list): Delete.  Remove calls throughout.
	(inode_t::get): Handle failing new gracefully.
	(MAX_LOCKF_CNT): Define.
	(inode_t::get_all_locks_list): Use pre-allocated buffer in i_all_lf
	instead of allocating every lock.  Return pointer to start of linked
	list of locks.
	(lockf_t::open_lock_obj): Create event object non-inheritable.
	(fhandler_disk_file::lock): Handle failing new gracefully.
	(lf_setlock): Allocate temporary buffer for node->i_all_lf from TLS.
	Remove erroneous NtClose call.
	(lf_getlock): Allocate temporary buffer for node->i_all_lf from TLS.
	(lf_getblock): Set lf to return value of get_all_locks_list.
@
text
@a124 21
/* Right now we implement flock(2) locks using the POSIX semantics
   in terms of inheritance and removal of locks.

   TODO: How to implement real BSD flock semantics?

	 From the Linux man page:

	 Locks created by flock() are associated with an open file table
	 entry.  This means that duplicate file descriptors (created by,
	 for example, fork(2) or dup(2)) refer to the same lock, and
	 this lock may be modified or released using any of these
	 descriptors.  Furthermore, the lock is released either by an
	 explicit LOCK_UN operation on any of these duplicate
	 descriptors, or when all such descriptors have been closed.

	 If a process uses open(2) (or similar) to obtain more than one
	 descriptor for the same file, these descriptors are treated
	 independently by flock().  An attempt to lock the file using
	 one of these file descriptors may be denied by a lock that the
	 calling process has already placed via another descriptor.  */

d138 1
a138 1
#define LOCK_OBJ_NAME_LEN	56
d280 16
d304 2
a305 2
    /* We need the Cygwin PID for F_GETLK, the Win PID for synchronization. */
    pid_t           lf_id;    /* (P)Id of the resource holding the lock */
d314 2
a315 1
      lf_wid (0), lf_head (NULL), lf_inode (NULL), lf_next (NULL), lf_obj (NULL)
d318 1
a318 1
	   _off64_t start, _off64_t end, pid_t id, DWORD wid)
d336 2
a337 3
    HANDLE open_lock_obj () const;
    ULONG get_lock_obj_handle_count () const;
    void del_lock_obj ();
d350 3
a352 2
    dev_t  i_dev;
    ino_t  i_ino;
d354 2
a355 4
    HANDLE i_dir; /* Not inherited! */
    HANDLE i_mtx; /* Not inherited! */

    void del_locks (lockf_t **head);
d358 1
a358 1
    inode_t (dev_t dev, ino_t ino);
d366 1
a366 1
    static inode_t *get (dev_t dev, ino_t ino);
d373 10
a382 1
    void del_my_locks () { LOCK (); del_locks (&i_lockf); UNLOCK ();
d385 36
a420 1
};
d422 4
a425 3
/* Used to delete all locks on a file hold by this process.  Called from
   close(2).  This implements fcntl semantics.
   TODO: flock(2) semantics. */
d427 1
a427 1
del_my_locks (inode_t *node)
d430 14
a443 2
  node->del_my_locks ();
  LIST_REMOVE (node, i_next);
a446 14
/* The global inode_t list header.  inode_t structs are created when a lock
   is requested on a file the first time from this process. */
/* Called in a forked child to get rid of all inodes and locks hold by the
   parent process.  Child processes don't inherit locks. */
void
fixup_lockf_after_fork ()
{
  inode_t *node, *next_node;

  LIST_FOREACH_SAFE (node, &cygheap->inode_list, i_next, next_node)
    delete node;
  LIST_INIT (&cygheap->inode_list);
}

d449 4
a452 2
   The lock owner's Windows PID changed and all lock event objects have to
   be relabeled so that waiting processes know which process to wait on. */
d456 1
a456 1
  inode_t *node;
d461 1
a461 1
  LIST_FOREACH (node, &cygheap->inode_list, i_next)
d463 13
a475 2
      node->LOCK ();
      for (lockf_t *lock = node->i_lockf; lock; lock = lock->lf_next)
d477 9
a485 3
	  lock->del_lock_obj ();
	  lock->lf_wid = myself->dwProcessId;
	  lock->create_lock_obj ();
a486 1
      node->UNLOCK ();
a487 1
  LIST_INIT (&cygheap->inode_list);
d495 1
a495 1
inode_t::get (dev_t dev, ino_t ino)
d503 1
a503 1
  if (!node)
d509 2
d515 1
a515 1
inode_t::inode_t (dev_t dev, ino_t ino)
a551 14
inode_t::~inode_t ()
{
  del_locks (&i_lockf);
}

void
inode_t::del_locks (lockf_t **head)
{
  lockf_t *lock, *n_lock;
  for (lock = *head; lock && (n_lock = lock->lf_next, 1); lock = n_lock)
    delete lock;
  *head = NULL;
}

d580 1
a580 1
      /* "%02x-%01x-%016X-%016X-%08x-%08x",
d596 3
a598 2
      pid_t id = wcstoul (endptr + 1, &endptr, 16);
      if (!endptr || *endptr != L'-')
d626 1
a626 1
  WCHAR name[LOCK_OBJ_NAME_LEN];
d631 1
a631 1
  __small_swprintf (name, L"%02x-%01x-%016X-%016X-%08x-%08x",
d645 2
a646 2
HANDLE
lockf_t::open_lock_obj () const
d648 1
a648 1
  WCHAR name[LOCK_OBJ_NAME_LEN];
a651 1
  HANDLE obj;
d653 1
a653 1
  __small_swprintf (name, L"%02x-%01x-%016X-%016X-%08x-%08x",
d659 1
a659 1
  status = NtOpenEvent (&obj, FLOCK_EVENT_ACCESS, &attr);
d663 1
a663 21
      return NULL;
    }
  return obj;
}

/* Get the handle count of a lock object. */
ULONG
lockf_t::get_lock_obj_handle_count () const
{
  OBJECT_BASIC_INFORMATION obi;
  NTSTATUS status;
  ULONG hdl_cnt = 0;

  if (lf_obj)
    {
      status = NtQueryObject (lf_obj, ObjectBasicInformation,
			      &obi, sizeof obi, NULL);
      if (!NT_SUCCESS (status))
	debug_printf ("NtQueryObject: %p\n", status);
      else
      	hdl_cnt = obi.HandleCount;
d665 1
a665 1
  return hdl_cnt;
d672 1
a672 1
lockf_t::del_lock_obj ()
d676 10
a685 1
      SetEvent (lf_obj);
d693 1
a693 1
  del_lock_obj ();
d700 1
a700 1
#if 0 /*TODO*/
d708 1
a708 1
static int      lf_clearlock (lockf_t *, lockf_t **);
d712 1
a712 1
static int      lf_setlock (lockf_t *, inode_t *, lockf_t **);
d714 1
a714 1
static void     lf_wakelock (lockf_t *);
a721 1
  struct __stat64 stat;
a757 3
  if (fstat_by_handle (&stat) == -1)
    return -1;

d773 19
a791 6
      if (fl->l_start > 0 && stat.st_size > OFF_MAX - fl->l_start)
	{
	  set_errno (EOVERFLOW);
	  return -1;
	}
      start = stat.st_size + fl->l_start;
d830 1
d833 2
a834 7
      node = inode_t::get (stat.st_dev, stat.st_ino);
      if (!node)
        {
	  set_errno (ENOLCK);
	  return -1;
	}
      need_fork_fixup (true);
d836 2
d851 1
d865 1
d874 3
a876 1
			       getpid (), myself->dwProcessId);
d879 1
a883 1
  node->LOCK ();
d887 1
a887 1
      error = lf_setlock (lock, node, &clean);
d891 1
a891 1
      error = lf_clearlock (lock, &clean);
d911 1
d915 10
a924 1
  node->UNLOCK ();
d937 1
a937 1
lf_setlock (lockf_t *lock, inode_t *node, lockf_t **clean)
d958 4
d969 2
d989 6
a994 2
	if ((lk->lf_flags & F_POSIX) && lk->get_lock_obj_handle_count () > 1)
	  return EDEADLK;
d1004 1
a1004 1
	  (void) lf_clearlock (lock, clean);
d1012 1
a1012 1
      /* FIXME?  See deadlock recognition above. */
a1014 1
      HANDLE obj = block->open_lock_obj ();
d1023 32
a1054 10
      HANDLE proc = OpenProcess (SYNCHRONIZE, FALSE, block->lf_wid);
      if (!proc)
	{
	  /* If we can't synchronize on the process holding the lock,
	     we will never recognize when the lock has been abandoned.
	     Treat this as a deadlock-like situation for now. */
	  system_printf ("Can't sync with process holding a lock "
			 "(Win32 pid %lu): %E", block->lf_wid);
	  NtClose (obj);
	  return EDEADLK;
d1056 1
a1056 5
      HANDLE w4[3] = { obj, proc, signal_arrived };
      //SetThreadPriority (GetCurrentThread (), priority);
      node->UNLOCK ();
      DWORD ret = WaitForMultipleObjects (3, w4, FALSE, INFINITE);
      CloseHandle (proc);
d1058 1
a1058 2
      node->LOCK ();
      //SetThreadPriority (GetCurrentThread (), old_prio);
d1062 2
d1065 4
a1068 3
	  /* The lock object has been set to signalled or the process
	     holding the lock has exited. */ 
	  break;
d1119 1
a1119 1
	  lf_wakelock (overlap);
d1144 1
a1144 1
	  lf_wakelock (overlap);
d1157 1
a1157 1
	  lf_wakelock (overlap);
d1183 1
a1183 1
	  lf_wakelock (overlap);
d1198 1
a1198 1
	  lf_wakelock (overlap);
d1215 1
a1215 1
lf_clearlock (lockf_t *unlock, lockf_t **clean)
d1230 1
a1230 1
      lf_wakelock (overlap);
d1292 2
d1302 1
a1302 1
	fl->l_pid = block->lf_id;
d1321 2
d1331 14
a1344 1
	  return overlap;
d1376 1
a1376 1
	  /* As on Linux: POSIX locks and flock locks don't interact. */
d1493 1
a1493 1
lf_wakelock (lockf_t *listhead)
d1495 1
a1495 1
  listhead->del_lock_obj ();
@


1.7
log
@	* flock.cc (FLOCK_PARENT_DIR_ACCESS): Define.
	(FLOCK_INODE_DIR_ACCESS): Define.
	(FLOCK_MUTANT_ACCESS): Define.
	(FLOCK_EVENT_ACCESS): Define.
	(SD_MIN_SIZE): Define.
	(everyone_sd): Define to simplify calling _everyone_sd.
	(_everyone_sd): Replace everyone_sync_sd.  Take SECURITY_DESCRIPTOR as
	argument and allow to specify access mask.
	(get_lock_parent_dir): Open/Create parent dir with
	FLOCK_PARENT_DIR_ACCESS.  Add text to api_fatal message.
	(inode_t::inode_t): Open/Create dir with FLOCK_INODE_DIR_ACCESS.
	Open/Create mutant with FLOCK_MUTANT_ACCESS.  Add text to api_fatal
	message.
	(lockf_t::create_lock_obj): Create event with FLOCK_EVENT_ACCESS.
	Add text to api_fatal message.
	(lockf_t::open_lock_obj): Open event with FLOCK_EVENT_ACCESS.
	On failure, just return NULL pointer instead of calling api_fatal.
	(lockf_t::get_lock_obj_handle_count): Replace call to small_printf
	with call to debug_printf.
	(lf_setlock): Handle a failure to open the lock event object as
	EDEADLK.  Call system_printf if opening sync objects fail.
	* ntdll.h (DIRECTORY_TRAVERSE): Define.
	(DIRECTORY_CREATE_OBJECT): Define.
	(DIRECTORY_CREATE_SUBDIRECTORY): Define.
	(EVENT_QUERY_STATE): Define.
@
text
@d329 4
d334 2
a335 1
    { return ccalloc (HEAP_FHANDLER, 1, sizeof (lockf_t)); }
d368 1
a368 1
    { return ccalloc (HEAP_FHANDLER, 1, sizeof (inode_t)); }
d377 1
a377 2
    void get_all_locks_list ();
    void del_all_locks_list () { del_locks (&i_all_lf); }
d452 2
a453 1
      LIST_INSERT_HEAD (&cygheap->inode_list, node, i_next);
d513 6
a518 1
void
d528 1
a529 1
  del_all_locks_list ();
d560 14
a573 6
      lockf_t *lock = new lockf_t (this, &i_all_lf, flags, type, start, end,
				   id, wid);
      if (i_all_lf)
	lock->lf_next = i_all_lf;
      i_all_lf = lock;
    }
d616 1
a616 2
  InitializeObjectAttributes (&attr, &uname, OBJ_INHERIT, lf_inode->i_dir,
			      NULL);
d679 1
a679 1
static lockf_t   *lf_getblock (lockf_t *, inode_t *node);
d793 5
d822 8
a829 1
    clean = new lockf_t ();
d835 5
d891 1
d902 2
a910 1
	  node->del_all_locks_list ();
a959 1
	  NtClose (obj);
a973 1
      node->del_all_locks_list ();
a995 1
  node->del_all_locks_list ();
d1205 1
d1207 2
a1224 1
  node->del_all_locks_list ();
d1235 2
a1236 2
  node->get_all_locks_list ();
  lockf_t **prev, *overlap, *lf = node->i_all_lf;
@


1.6
log
@	* flock.cc (inode_t::get_all_locks_list): Don't allow F_WAIT flag
	in lock event object name.
	(lockf_t::create_lock_obj): Ditto.
	(lockf_t::open_lock_obj): Ditto.
	(lf_setlock): Only check POSIX locks for deadlock condition.
	(lf_findoverlap): Don't let POSIX and flock locks interact.
@
text
@d219 1
a219 1
   SYNCHRONIZE access to everyone.  Only the creating process has all access
d221 25
a245 2
static PSECURITY_DESCRIPTOR
everyone_sync_sd ()
d247 1
a247 1
  static PSECURITY_DESCRIPTOR psd;
d249 1
a249 1
  if (!psd)
a250 4
      const size_t acl_len = sizeof (ACL) +
			     sizeof (ACCESS_ALLOWED_ACE) + MAX_SID_LEN;
      psd = (PSECURITY_DESCRIPTOR)
	    malloc (sizeof (SECURITY_DESCRIPTOR) + acl_len);
d253 2
a254 2
      InitializeAcl (dacl, acl_len, ACL_REVISION);
      if (!AddAccessAllowedAce (dacl, ACL_REVISION, SYNCHRONIZE, 
d287 2
a288 2
				  sec_all.lpSecurityDescriptor);
      status = NtOpenDirectoryObject (&dir, DIRECTORY_ALL_ACCESS, &attr);
d291 2
a292 1
	  status = NtCreateDirectoryObject (&dir, DIRECTORY_ALL_ACCESS, &attr);
d294 1
a294 1
	    api_fatal ("NtCreateDirectoryObject: %p", status);
d469 2
a470 2
			      sec_all.lpSecurityDescriptor);
  status = NtOpenDirectoryObject (&i_dir, DIRECTORY_ALL_ACCESS, &attr);
d473 1
a473 1
      status = NtCreateDirectoryObject (&i_dir, DIRECTORY_ALL_ACCESS, &attr);
d475 1
a475 1
	api_fatal ("NtCreateDirectoryObject: %p", status);
d481 2
a482 2
			      sec_all.lpSecurityDescriptor);
  status = NtOpenMutant (&i_mtx, MUTANT_ALL_ACCESS, &attr);
d485 1
a485 1
      status = NtCreateMutant (&i_mtx, MUTANT_ALL_ACCESS, &attr, FALSE);
d487 1
a487 1
	api_fatal ("NtCreateMutant: %p", status);
d576 1
a576 1
			      everyone_sync_sd ());
d580 1
a580 1
    api_fatal ("NtCreateEvent: %p", status);
d600 1
a600 1
  status = NtOpenEvent (&obj, SYNCHRONIZE, &attr);
d602 4
a605 1
    api_fatal ("NtOpenEvent: %p", status);
d622 1
a622 1
	small_printf ("NtQueryObject: %p\n", status);
d918 9
d933 2
a934 1
	  debug_printf ("OpenProcess: %E");
@


1.5
log
@	* flock.cc: Clarify a couple of comments.
	(lf_setlock): Treat not being able to sync on a process as a potential
	deadlock situation.  Close process handle using CloseHandle.
@
text
@d512 1
a512 1
      if ((flags & ~(F_WAIT | F_FLOCK | F_POSIX)) != 0
d551 2
a552 1
			  lf_flags, lf_type, lf_start, lf_end, lf_id, lf_wid);
d574 2
a575 1
			  lf_flags, lf_type, lf_start, lf_end, lf_id, lf_wid);
d872 1
a872 1
	if (lk->get_lock_obj_handle_count () > 1)
d1209 4
a1212 1
      if ((type & OTHERS) && lf->lf_id == lock->lf_id)
@


1.4
log
@	* flock.cc: Fix typo in comment.
@
text
@d162 3
a164 3
   SYNCHRONIZE permissions for everyone.  This allows to wait any process
   to wait for this process to set the event object to signalled in case
   the lock gets removed or replaced. */
d754 1
a754 1
     a F_SETLKW waits forever... */
d889 1
a889 1
      /* TODO */
d895 8
a902 1
        api_fatal ("OpenProcess: %E");
d908 1
a908 1
      NtClose (proc);
@


1.3
log
@	* fhandler.cc (fhandler_base::dup): Drop setting flags in the parent.

	Implement advisory file locking.
	* cygheap.h (struct init_cygheap): Add inode_list member.
	* cygwin.din (lockf): Export.
	* dcrt0.cc (child_info_spawn::handle_spawn): Call
	fixup_lockf_after_exec.
	* dtable.h (class dtable): Add fhandler_disk_file as friend class.
	* fhandler.cc (fhandler_base::close): Call del_my_locks if node is set.
	(fhandler_base::fhandler_base): Initialize node to NULL.
	(fhandler_base::fixup_after_fork): Ditto.
	* fhandler.h (class fhandler_base): Add member node.
	* fhandler_disk_file.cc (fhandler_disk_file::lock): Delete.
	* flock.cc: Implement all advisory file locking here.
	(fhandler_disk_file::lock): Implement here.
	(flock): Call fcntl with F_FLOCK bit set.  Remove test main function.
	(lockf): New function.
	* fork.cc (frok::child): Call fixup_lockf_after_fork.
	* ntdll.h (DIRECTORY_ALL_ACCESS): Define.
	(struct _OBJECT_BASIC_INFORMATION): Define.
	(enum _EVENT_TYPE): Define.
	(NtCreateDirectoryObject): Declare.
	(NtCreateEvent): Declare.
	(NtCreateMutant): Declare.
	(NtOpenEvent): Declare.
	(NtOpenMutant): Declare.
	* include/cygwin/version.h: Bump API minor number.
@
text
@d141 1
a141 1
	 descrip- tor for the same file, these descriptors are treated
@


1.2
log
@	* fcntl.cc (fcntl_worker): Remove static storage class.
	* flock.cc (flock): Use struct __flock64. Call fcntl_worker.
	Use Cygwin errno functions instead of accessing errno directly.
	* winsup.h: Declare fcntl_worker.
@
text
@d1 1
a1 8
/* One of many ways to emulate flock() on top of real (good) POSIX locks.
 *
 * This flock() emulation is based upon source taken from the Red Hat
 * implementation used in their imap-2002d SRPM.
 *
 * $RH: flock.c,v 1.2 2000/08/23 17:07:00 nalin Exp $
 */
/* flock.c
d3 1
a3 1
   Copyright 2003 Red Hat, Inc.
d11 91
d103 1
a103 1
#include "cygerrno.h"
d107 1212
d1337 1
a1337 1
      l.l_type = F_WRLCK;
d1348 1
a1348 1
      l.l_type = F_RDLCK;
d1359 1
a1359 1
      l.l_type = F_UNLCK;
d1377 2
a1378 3
#ifdef FLOCK_EMULATE_IS_MAIN
int
main (int argc, char **argv)
d1380 37
a1416 3
  int fd = open (argv[1], O_WRONLY);
  flock (fd, LOCK_EX);
  return 0;
a1417 1
#endif
@


1.1
log
@	* flock.cc: Renamed from flock.c.
@
text
@d18 2
a20 2
#include <sys/types.h>
#include <errno.h>
d28 1
a28 1
  struct flock l = { 0, 0, 0, 0, 0 };
d42 1
a42 1
      i = fcntl (fd, cmd, &l);
d45 1
a45 1
	  if ((errno == EAGAIN) || (errno == EACCES))
d47 1
a47 1
	      errno = EWOULDBLOCK;
d53 1
a53 1
      i = fcntl (fd, cmd, &l);
d56 1
a56 1
	  if ((errno == EAGAIN) || (errno == EACCES))
d58 1
a58 1
	      errno = EWOULDBLOCK;
d64 1
a64 1
      i = fcntl (fd, cmd, &l);
d67 1
a67 1
	  if ((errno == EAGAIN) || (errno == EACCES))
d69 1
a69 1
	      errno = EWOULDBLOCK;
d75 1
a75 1
      errno = EINVAL;
@

