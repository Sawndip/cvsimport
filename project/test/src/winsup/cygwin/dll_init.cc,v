head	1.111;
access;
symbols
	cygwin-1_7_35-release:1.111
	cygwin-1_7_34-release:1.111
	cygwin-1_7_33-release:1.108.2.3
	cygwin-1_7_32-release:1.108.2.2
	cygwin-1_7_31-release:1.108.2.1
	cygwin-1_7_30-release:1.108
	cygwin-1_7_29-release:1.108
	cygwin-1_7_29-release-branchpoint:1.108.0.2
	cygwin-pre-user-db:1.108
	cygwin-1_7_28-release:1.108
	cygwin-1_7_27-release:1.108
	cygwin-1_7_26-release:1.108
	cygwin-1_7_25-release:1.108
	cygwin-1_7_24-release:1.108
	cygwin-1_7_23-release:1.108
	cygwin-1_7_22-release:1.108
	cygwin-1_7_21-release:1.108
	cygwin-1_7_20-release:1.108
	cygwin-1_7_19-release:1.108
	cygwin-64bit-postmerge:1.107
	cygwin-64bit-premerge-branch:1.106.0.2
	cygwin-64bit-premerge:1.106
	cygwin-1_7_18-release:1.106
	post-ptmalloc3:1.104.2.4
	pre-ptmalloc3:1.104.2.4
	cygwin-1_7_17-release:1.105
	cygwin-64bit-branch:1.104.0.2
	cygwin-1_7_16-release:1.104
	cygwin-1_7_15-release:1.103
	cygwin-1_7_14_2-release:1.103
	cygwin-1_7_14-release:1.103
	cygwin-1_7_12-release:1.103
	cygwin-1_7_11-release:1.100
	cygwin-1_7_10-release:1.97
	signal-rewrite:1.95.0.2
	pre-notty:1.93
	cygwin-1_7_9-release:1.78
	cv-post-1_7_9:1.77.0.2
	cygwin-1_7_8-release:1.77
	cygwin-1_7_7-release:1.75
	cygwin-1_7_5-release:1.73
	cygwin-1_7_4-release:1.73
	cygwin-1_7_3-release:1.73
	cygwin-1_7_2-release:1.72
	fifo_doover3:1.66.0.2
	cygwin-1_7_1-release:1.66
	prefifo:1.64
	cv-branch-2:1.63.0.2
	pre-ripout-set_console_state_for_spawn:1.56
	EOL_registry_mounts:1.55
	preoverlapped:1.53
	drop_9x_support_start:1.53
	cr-0x5f1:1.53.0.4
	cv-branch:1.53.0.2
	pre-ptymaster-archetype:1.53
	cr-0x3b58:1.46.0.4
	cr-0x5ef:1.46.0.2
	after-mmap-privanon-noreserve:1.45
	after-mmap-revamp:1.45
	before-mmap-revamp:1.45
	cgf-more-exit-sync:1.45
	post_wait_sig_exit:1.45
	pre_wait_sig_exit:1.45
	reparent-point:1.43
	noreparent:1.43.0.4
	cr-0x5e6:1.43.0.2
	cr-0x9e:1.40.0.4
	cr-0x9d:1.40.0.2
	cgf-deleteme:1.39.0.2
	pre-sigrewrite:1.39
	corinna-01:1.38
	cr-0x9c:1.37.0.6
	cr-0x9b:1.37.0.4
	cr-0x99:1.37
	Z-emcb-cygwin_daemon:1.37.0.2
	w32api-2_2:1.33
	mingw-runtime-2_4:1.33
	pre-cgf-merge:1.37
	cgf-dev-branch:1.33.0.8
	predaemon:1.21
	cygwin_daemon_merge_HEAD:1.21
	pregp02r1:1.21.0.30
	cygnus_cvs_20020108_pre:1.21
	Z-cygwin_daemon_merge-new_HEAD:1.27
	Z-cygwin_daemon_merge_HEAD:1.27
	cygwin_daemon:1.18.0.4;
locks; strict;
comment	@// @;
expand	@o@;


1.111
date	2014.10.10.15.29.18;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2014.08.07.16.25.06;	author yselkowitz;	state Exp;
branches;
next	1.109;

1.109
date	2014.06.23.10.52.44;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2013.05.27.19.31.04;	author corinna;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2012.08.16.23.34.43;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2012.07.02.14.14.01;	author corinna;	state Exp;
branches
	1.104.2.1;
next	1.103;

1.103
date	2012.03.05.10.27.44;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2012.03.04.16.47.45;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2012.03.04.13.50.12;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2012.02.09.14.41.21;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2012.02.08.17.35.02;	author corinna;	state Exp;
branches;
next	1.98;

1.98
date	2012.02.08.14.41.51;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2011.12.08.06.17.49;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2011.11.29.17.26.57;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2011.08.03.17.58.59;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2011.08.01.13.11.37;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2011.06.06.05.02.09;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2011.05.30.17.16.24;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2011.05.30.16.09.29;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2011.05.30.06.52.12;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2011.05.28.20.55.34;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2011.05.28.20.41.51;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2011.05.28.20.27.56;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2011.05.28.20.17.09;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2011.05.28.20.09.03;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2011.05.04.19.19.46;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2011.05.04.16.02.45;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2011.05.02.15.28.34;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2011.04.21.00.53.55;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2011.04.06.13.58.00;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2011.03.27.19.14.02;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2011.02.15.15.56.00;	author corinna;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2011.02.08.20.14.37;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2010.05.07.21.25.18;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2010.05.03.16.40.33;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2010.03.28.17.27.52;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2010.02.28.15.54.25;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2010.02.26.21.36.31;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2010.02.05.15.05.22;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2010.02.02.02.00.01;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.29.18.34.09;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2010.01.29.17.37.54;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2009.08.21.21.32.06;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2009.08.13.07.35.49;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2009.07.17.18.17.11;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2009.06.08.03.53.40;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2009.06.07.07.26.07;	author corinna;	state Exp;
branches;
next	1.61;

1.61
date	2009.06.06.11.47.29;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2008.09.11.04.34.22;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2008.08.13.08.25.44;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2008.08.05.14.26.47;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2008.08.04.15.55.32;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.14.16.47.11;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.12.12.12.23;	author corinna;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.02.00.09.50;	author cgf;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.27.22.55.58;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.27.18.53.36;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.27.18.50.04;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.14.19.07.36;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.12.23.57.04;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.08.23.55.14;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.29.20.46.33;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.14.17.34.03;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.03.08.45.17;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.13.19.34.32;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.12.03.01.57;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.09.04.04.22;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.14.15.45.36;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.02.18.37.17;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2003.03.02.17.29.47;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2003.03.01.02.02.40;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.14.04.29.39;	author cgf;	state Exp;
branches
	1.33.8.1;
next	1.32;

1.32
date	2002.11.02.03.31.15;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2002.10.22.16.18.55;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.14.20.25.52;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.30.04.35.17;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.31.20.34.40;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.19.14.42.20;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.19.12.46.19;	author rbcollins;	state Exp;
branches;
next	1.21;

1.21
date	2001.10.21.03.38.41;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2001.10.15.23.39.32;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.24.22.26.49;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.28.05.41.43;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.04.17.52.42;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.18.02.26.46;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.17.19.18.21;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.16.04.10.33;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.15.04.36.10;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.15.02.48.10;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.12.04.49.07;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.05.23.46.44;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.108.2.1
date	2014.07.15.14.34.37;	author corinna;	state Exp;
branches;
next	1.108.2.2;

1.108.2.2
date	2014.08.13.17.39.10;	author corinna;	state Exp;
branches;
next	1.108.2.3;

1.108.2.3
date	2014.11.13.12.52.55;	author corinna;	state Exp;
branches;
next	;

1.104.2.1
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.104.2.2;

1.104.2.2
date	2012.10.23.14.23.49;	author corinna;	state Exp;
branches;
next	1.104.2.3;

1.104.2.3
date	2012.10.30.10.36.35;	author corinna;	state Exp;
branches;
next	1.104.2.4;

1.104.2.4
date	2013.01.21.13.52.04;	author corinna;	state Exp;
branches;
next	1.104.2.5;

1.104.2.5
date	2013.03.05.14.29.30;	author corinna;	state Exp;
branches;
next	1.104.2.6;

1.104.2.6
date	2013.03.05.16.44.26;	author corinna;	state Exp;
branches;
next	;

1.77.2.1
date	2011.03.28.20.16.56;	author corinna;	state Exp;
branches;
next	;

1.39.2.1
date	2004.01.11.18.13.52;	author cgf;	state Exp;
branches;
next	;

1.33.8.1
date	2003.02.14.03.03.27;	author cgf;	state Exp;
branches;
next	1.33.8.2;

1.33.8.2
date	2003.03.01.02.05.42;	author cgf;	state Exp;
branches;
next	1.33.8.3;

1.33.8.3
date	2003.03.02.18.57.51;	author cgf;	state Exp;
branches;
next	1.33.8.4;

1.33.8.4
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	;

1.18.4.1
date	2001.10.02.12.09.53;	author rbcollins;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2002.01.04.03.56.06;	author rbcollins;	state Exp;
branches;
next	1.18.4.3;

1.18.4.3
date	2002.06.13.14.34.02;	author rbcollins;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.111
log
@	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.
@
text
@/* dll_init.cc

   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "cygerrno.h"
#include "perprocess.h"
#include "sync.h"
#include "dll_init.h"
#include "environ.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "pinfo.h"
#include "child_info.h"
#include "cygtls.h"
#include "exception.h"
#include <wchar.h>
#include <sys/reent.h>
#include <assert.h>

extern void __stdcall check_sanity_and_sync (per_process *);

#define fabort fork_info->abort

dll_list dlls;

muto dll_list::protect;

static bool dll_global_dtors_recorded;

/* Run destructors for all DLLs on exit. */
void
dll_global_dtors ()
{
  /* Don't attempt to call destructors if we're still in fork processing
     since that likely means fork is failing and everything will not have been
     set up.  */
  if (in_forkee)
    return;
  int recorded = dll_global_dtors_recorded;
  dll_global_dtors_recorded = false;
  if (recorded && dlls.start.next)
    for (dll *d = dlls.end; d != &dlls.start; d = d->prev)
      d->run_dtors ();
}

/* Run all constructors associated with a dll */
void
per_module::run_ctors ()
{
  void (**pfunc)() = ctors;

  /* Run ctors backwards, so skip the first entry and find how many
    there are, then run them.  */

  if (pfunc)
    {
      int i;
      for (i = 1; pfunc[i]; i++);

      for (int j = i - 1; j > 0; j--)
	(pfunc[j]) ();
    }
}

/* Run all destructors associated with a dll */
void
per_module::run_dtors ()
{
  void (**pfunc)() = dtors;
  while (*++pfunc)
    (*pfunc) ();
}

/* Initialize an individual DLL */
int
dll::init ()
{
  int ret = 1;

#ifndef __x86_64__
  /* This should be a no-op.  Why didn't we just import this variable? */
  if (!p.envptr)
    p.envptr = &__cygwin_environ;
  else if (*(p.envptr) != __cygwin_environ)
    *(p.envptr) = __cygwin_environ;
#endif

  /* Don't run constructors or the "main" if we've forked. */
  if (!in_forkee)
    {
      /* global contructors */
      p.run_ctors ();

      /* entry point of dll (use main of per_process with null args...) */
      if (p.main)
	ret = p.main (0, 0, 0);
    }

  return ret;
}

/* Look for a dll based on the full path.

   CV, 2012-03-04: Per MSDN, If a DLL with the same module name is already
   loaded in memory, the system uses the loaded DLL, no matter which directory
   it is in. The system does not search for the DLL.  See
   http://msdn.microsoft.com/en-us/library/ms682586%28v=vs.85%29.aspx

   On 2012-02-08 I interpreted "module name" as "basename".  So the assumption
   was that the Windows Loader does not load another DLL with the same basename,
   if one such DLL is already loaded.  Consequentially I changed the code so
   that DLLs are only compared by basename.

   This assumption was obviously wrong, as the perl dynaloader proves.  It
   loads multiple DLLs with the same basename into memory, just from different
   locations.  This mechanism is broken when only comparing basenames in the
   below code.

   However, the original problem reported on 2012-02-07 was a result of
   a subtil difference between the paths returned by different calls to
   GetModuleFileNameW: Sometimes the path is a plain DOS path, sometimes
   it's preceeded by the long pathname prefix "\\?\".

   So I reverted the original change from 2012-02-08 and only applied the
   following fix: Check if the path is preceeded by a long pathname prefix,
   and, if so, drop it forthwith so that subsequent full path comparisons
   work as expected.

   At least that was the original idea.  In fact there are two case, linked
   and runtime loaded DLLs, which have to be distinguished:

   - Linked DLLs are loaded by only specifying the basename of the DLL and
     searching it using the system DLL search order as given in the
     aforementioned MSDN URL.

   - Runtime loaded DLLs are specified with the full path since that's how
     dlopen works.

   In effect, we have to be careful not to mix linked and loaded DLLs.
   For more info how this gets accomplished, see the comments at the start
   of dll_list::alloc, as well as the comment preceeding the definition of
   the in_load_after_fork bool later in the file. */
dll *
dll_list::operator[] (const PWCHAR name)
{
  dll *d = &start;
  while ((d = d->next) != NULL)
    if (!wcscasecmp (name, d->name))
      return d;

  return NULL;
}

/* Look for a dll based on the basename. */
dll *
dll_list::find_by_modname (const PWCHAR modname)
{
  dll *d = &start;
  while ((d = d->next) != NULL)
    if (!wcscasecmp (modname, d->modname))
      return d;

  return NULL;
}

#define RETRIES 1000

/* Allocate space for a dll struct. */
dll *
dll_list::alloc (HINSTANCE h, per_process *p, dll_type type)
{
  WCHAR buf[NT_MAX_PATH];
  GetModuleFileNameW (h, buf, NT_MAX_PATH);
  PWCHAR name = buf;
  if (!wcsncmp (name, L"\\\\?\\", 4))
    {
      name += 4;
      if (!wcsncmp (name, L"UNC\\", 4))
	{
	  name += 2;
	  *name = L'\\';
	}
    }
  DWORD namelen = wcslen (name);
  PWCHAR modname = wcsrchr (name, L'\\') + 1;

  guard (true);
  /* Already loaded?  For linked DLLs, only compare the basenames.  Linked
     DLLs are loaded using just the basename and the default DLL search path.
     The Windows loader picks up the first one it finds.  */
  dll *d = (type == DLL_LINK) ? dlls.find_by_modname (modname) : dlls[name];
  if (d)
    {
      if (!in_forkee)
	d->count++;	/* Yes.  Bump the usage count. */
      else if (d->handle != h)
	fabort ("%W: Loaded to different address: parent(%p) != child(%p)",
		name, d->handle, h);
      /* If this DLL has been linked against, and the full path differs, try
	 to sanity check if this is the same DLL, just in another path. */
      else if (type == DLL_LINK && wcscasecmp (name, d->name)
	       && (d->p.data_start != p->data_start
		   || d->p.data_start != p->data_start
		   || d->p.bss_start != p->bss_start
		   || d->p.bss_end != p->bss_end
		   || d->p.ctors != p->ctors
		   || d->p.dtors != p->dtors))
      	fabort ("\nLoaded different DLL with same basename in forked child,\n"
		"parent loaded: %W\n"
		" child loaded: %W\n"
		"The DLLs differ, so it's not safe to run the forked child.\n"
		"Make sure to remove the offending DLL before trying again.",
		d->name, name);
      d->p = p;
    }
  else
    {
      /* FIXME: Change this to new at some point. */
      d = (dll *) cmalloc (HEAP_2_DLL, sizeof (*d) + (namelen * sizeof (*name)));

      /* Now we've allocated a block of information.  Fill it in with the
	 supplied info about this DLL. */
      d->count = 1;
      wcscpy (d->name, name);
      d->modname = d->name + (modname - name);
      d->handle = h;
      d->has_dtors = true;
      d->p = p;
      d->ndeps = 0;
      d->deps = NULL;
      d->image_size = ((pefile*)h)->optional_hdr ()->SizeOfImage;
      d->preferred_base = (void*) ((pefile*)h)->optional_hdr()->ImageBase;
      d->type = type;
      append (d);
      if (type == DLL_LOAD)
	loaded_dlls++;
    }
  guard (false);
#ifndef __x86_64__
  assert (p->envptr != NULL);
#endif
  return d;
}

void
dll_list::append (dll* d)
{
  if (end == NULL)
    end = &start;	/* Point to "end" of dll chain. */
  end->next = d;	/* Standard linked list stuff. */
  d->next = NULL;
  d->prev = end;
  end = d;
}

void dll_list::populate_deps (dll* d)
{
  WCHAR wmodname[NT_MAX_PATH];
  pefile* pef = (pefile*) d->handle;
  PIMAGE_DATA_DIRECTORY dd = pef->idata_dir (IMAGE_DIRECTORY_ENTRY_IMPORT);
  /* Annoyance: calling crealloc with a NULL pointer will use the
     wrong heap and crash, so we have to replicate some code */
  long maxdeps = 4;
  d->deps = (dll**) cmalloc (HEAP_2_DLL, maxdeps*sizeof (dll*));
  d->ndeps = 0;
  for (PIMAGE_IMPORT_DESCRIPTOR id=
	(PIMAGE_IMPORT_DESCRIPTOR) pef->rva (dd->VirtualAddress);
      dd->Size && id->Name;
      id++)
    {
      char* modname = pef->rva (id->Name);
      sys_mbstowcs (wmodname, NT_MAX_PATH, modname);
      if (dll* dep = find_by_modname (wmodname))
	{
	  if (d->ndeps >= maxdeps)
	    {
	      maxdeps = 2*(1+maxdeps);
	      d->deps = (dll**) crealloc (d->deps, maxdeps*sizeof (dll*));
	    }
	  d->deps[d->ndeps++] = dep;
	}
    }

  /* add one to differentiate no deps from unknown */
  d->ndeps++;
}


void
dll_list::topsort ()
{
  /* Anything to do? */
  if (!end || end == &start)
    return;

  /* make sure we have all the deps available */
  dll* d = &start;
  while ((d = d->next))
    if (!d->ndeps)
      populate_deps (d);

  /* unlink head and tail pointers so the sort can rebuild the list */
  d = start.next;
  start.next = end = NULL;
  topsort_visit (d, true);

  /* clear node markings made by the sort */
  d = &start;
  while ((d = d->next))
    {
#ifdef DEBUGGING
      paranoid_printf ("%W", d->modname);
      for (int i = 1; i < -d->ndeps; i++)
	paranoid_printf ("-> %W", d->deps[i - 1]->modname);
#endif

      /* It would be really nice to be able to keep this information
	 around for next time, but we don't have an easy way to
	 invalidate cached dependencies when a module unloads. */
      d->ndeps = 0;
      cfree (d->deps);
      d->deps = NULL;
    }
}

/* A recursive in-place topological sort. The result is ordered so that
   dependencies of a dll appear before it in the list.

   NOTE: this algorithm is guaranteed to terminate with a "partial
   order" of dlls but does not do anything smart about cycles: an
   arbitrary dependent dll will necessarily appear first. Perhaps not
   surprisingly, Windows ships several dlls containing dependency
   cycles, including SspiCli/RPCRT4.dll and a lovely tangle involving
   USP10/LPK/GDI32/USER32.dll). Fortunately, we don't care about
   Windows DLLs here, and cygwin dlls should behave better */
void
dll_list::topsort_visit (dll* d, bool seek_tail)
{
  /* Recurse to the end of the dll chain, then visit nodes as we
     unwind. We do this because once we start visiting nodes we can no
     longer trust any _next_ pointers.

     We "mark" visited nodes (to avoid revisiting them) by negating
     ndeps (undone once the sort completes). */
  if (seek_tail && d->next)
    topsort_visit (d->next, true);

  if (d->ndeps > 0)
    {
      d->ndeps = -d->ndeps;
      for (long i = 1; i < -d->ndeps; i++)
	topsort_visit (d->deps[i - 1], false);

      append (d);
    }
}


dll *
dll_list::find (void *retaddr)
{
  MEMORY_BASIC_INFORMATION m;
  if (!VirtualQuery (retaddr, &m, sizeof m))
    return NULL;
  HMODULE h = (HMODULE) m.AllocationBase;

  dll *d = &start;
  while ((d = d->next))
    if (d->handle == h)
      break;
  return d;
}

/* Detach a DLL from the chain. */
void
dll_list::detach (void *retaddr)
{
  dll *d;
  /* Don't attempt to call destructors if we're still in fork processing
     since that likely means fork is failing and everything will not have been
     set up.  */
  if (!myself || in_forkee)
    return;
  guard (true);
  if ((d = find (retaddr)))
    {
      if (d->count <= 0)
	system_printf ("WARNING: trying to detach an already detached dll ...");
      if (--d->count == 0)
	{
	  /* Ensure our exception handler is enabled for destructors */
	  exception protect;
	  /* Call finalize function if we are not already exiting */
	  if (!exit_state)
	    __cxa_finalize (d->handle);
	  d->run_dtors ();
	  d->prev->next = d->next;
	  if (d->next)
	    d->next->prev = d->prev;
	  if (d->type == DLL_LOAD)
	    loaded_dlls--;
	  if (end == d)
	    end = d->prev;
	  cfree (d);
	}
    }
  guard (false);
}

/* Initialization for all linked DLLs, called by dll_crt0_1. */
void
dll_list::init ()
{
  /* Walk the dll chain, initializing each dll */
  dll *d = &start;
  dll_global_dtors_recorded = d->next != NULL;
  while ((d = d->next))
    d->init ();
}

#define A64K (64 * 1024)


/* Reserve the chunk of free address space starting _here_ and (usually)
   covering at least _dll_size_ bytes. However, we must take care not
   to clobber the dll's target address range because it often overlaps.
 */
static PVOID
reserve_at (const PWCHAR name, PVOID here, PVOID dll_base, DWORD dll_size)
{
  DWORD size;
  MEMORY_BASIC_INFORMATION mb;

  if (!VirtualQuery (here, &mb, sizeof (mb)))
    fabort ("couldn't examine memory at %p while mapping %W, %E", here, name);
  if (mb.State != MEM_FREE)
    return 0;

  size = mb.RegionSize;

  // don't clobber the space where we want the dll to land
  caddr_t end = (caddr_t) here + size;
  caddr_t dll_end = (caddr_t) dll_base + dll_size;
  if (dll_base < here && dll_end > (caddr_t) here)
      here = (PVOID) dll_end; // the dll straddles our left edge
  else if (dll_base >= here && (caddr_t) dll_base < end)
      end = (caddr_t) dll_base; // the dll overlaps partly or fully to our right

  size = end - (caddr_t) here;
  if (!VirtualAlloc (here, size, MEM_RESERVE, PAGE_NOACCESS))
    fabort ("couldn't allocate memory %p(%d) for '%W' alignment, %E\n",
	    here, size, name);
  return here;
}

/* Release the memory previously allocated by "reserve_at" above. */
static void
release_at (const PWCHAR name, PVOID here)
{
  if (!VirtualFree (here, 0, MEM_RELEASE))
    fabort ("couldn't release memory %p for '%W' alignment, %E\n",
	    here, name);
}

/* Step 1: Reserve memory for all DLL_LOAD dlls. This is to prevent
   anything else from taking their spot as we compensate for Windows
   randomly relocating things.

   NOTE: because we can't depend on LoadLibraryExW to do the right
   thing, we have to do a vanilla VirtualAlloc instead. One possible
   optimization might attempt a LoadLibraryExW first, in case it lands
   in the right place, but then we have to find a way of tracking
   which dlls ended up needing VirtualAlloc after all.  */
void
dll_list::reserve_space ()
{
  for (dll* d = dlls.istart (DLL_LOAD); d; d = dlls.inext ())
    if (!VirtualAlloc (d->handle, d->image_size, MEM_RESERVE, PAGE_NOACCESS))
      fabort ("address space needed by '%W' (%p) is already occupied",
	      d->modname, d->handle);
}

/* We need the in_load_after_fork flag so dll_dllcrt0_1 can decide at fork
   time if this is a linked DLL or a dynamically loaded DLL.  In either case,
   both, cygwin_finished_initializing and in_forkee are true, so they are not
   sufficient to discern the situation. */
static bool NO_COPY in_load_after_fork;

/* Reload DLLs after a fork.  Iterates over the list of dynamically loaded
   DLLs and attempts to load them in the same place as they were loaded in the
   parent. */
void
dll_list::load_after_fork (HANDLE parent)
{
  // moved to frok::child for performance reasons:
  // dll_list::reserve_space();

  in_load_after_fork = true;
  load_after_fork_impl (parent, dlls.istart (DLL_LOAD), 0);
  in_load_after_fork = false;
}

static int const DLL_RETRY_MAX = 6;
void dll_list::load_after_fork_impl (HANDLE parent, dll* d, int retries)
{
  /* Step 2: For each dll which did not map at its preferred base
     address in the parent, try to coerce it to land at the same spot
     as before. If not, unload it, reserve the memory around it, and
     try again. Use recursion to remember blocked regions address
     space so we can release them later.

     We DONT_RESOLVE_DLL_REFERENCES at first in case the DLL lands in
     the wrong spot;

     NOTE: This step skips DLLs which loaded at their preferred
     address in the parent because they should behave (we already
     verified that their preferred address in the child is
     available). However, this may fail on a Vista/Win7 machine with
     ASLR active, because the ASLR base address will usually not equal
     the preferred base recorded in the dll. In this case, we should
     make the LoadLibraryExW call unconditional.
   */
  for ( ; d; d = dlls.inext ())
    if (d->handle != d->preferred_base)
      {
	/* See if the DLL will load in proper place. If not, unload it,
	   reserve the memory around it, and try again.

	   If this is the first attempt, we need to release the
	   dll's protective reservation from step 1
	 */
	if (!retries && !VirtualFree (d->handle, 0, MEM_RELEASE))
	  fabort ("unable to release protective reservation for %W (%p), %E",
		  d->modname, d->handle);

	HMODULE h = LoadLibraryExW (d->name, NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!h)
	  fabort ("unable to create interim mapping for %W, %E", d->name);
	if (h != d->handle)
	  {
	    sigproc_printf ("%W loaded in wrong place: %p != %p",
			    d->modname, h, d->handle);
	    FreeLibrary (h);
	    PVOID reservation = reserve_at (d->modname, h,
					    d->handle, d->image_size);
	    if (!reservation)
	      fabort ("unable to block off %p to prevent %W from loading there",
		      h, d->modname);

	    if (retries < DLL_RETRY_MAX)
	      load_after_fork_impl (parent, d, retries+1);
	    else
	       fabort ("unable to remap %W to same address as parent (%p) - try running rebaseall",
		       d->modname, d->handle);

	    /* once the above returns all the dlls are mapped; release
	       the reservation and continue unwinding */
	    sigproc_printf ("releasing blocked space at %p", reservation);
	    release_at (d->modname, reservation);
	    return;
	  }
      }

  /* Step 3: try to load each dll for real after either releasing the
     protective reservation (for well-behaved dlls) or unloading the
     interim mapping (for rebased dlls) . The dll list is sorted in
     dependency order, so we shouldn't pull in any additional dlls
     outside our control.  */
  for (dll *d = dlls.istart (DLL_LOAD); d; d = dlls.inext ())
    {
      if (d->handle == d->preferred_base)
	{
	  if (!VirtualFree (d->handle, 0, MEM_RELEASE))
	    fabort ("unable to release protective reservation for %W (%p), %E",
		    d->modname, d->handle);
	}
      else
	{
	  /* Free the library using our parent's handle: it's identical
	     to ours or we wouldn't have gotten this far */
	  if (!FreeLibrary (d->handle))
	    fabort ("unable to unload interim mapping of %W, %E",
		    d->modname);
	}
      HMODULE h = LoadLibraryW (d->name);
      if (!h)
	fabort ("unable to map %W, %E", d->name);
      if (h != d->handle)
	fabort ("unable to map %W to same address as parent: %p != %p",
		d->modname, d->handle, h);
    }
}

struct dllcrt0_info
{
  HMODULE h;
  per_process *p;
  PVOID res;
  dllcrt0_info (HMODULE h0, per_process *p0): h (h0), p (p0) {}
};

extern "C" PVOID
dll_dllcrt0 (HMODULE h, per_process *p)
{
  if (dynamically_loaded)
    return (PVOID) 1;
  dllcrt0_info x (h, p);
  dll_dllcrt0_1 (&x);
  return x.res;
}

void
dll_dllcrt0_1 (VOID *x)
{
  HMODULE& h = ((dllcrt0_info *) x)->h;
  per_process*& p = ((dllcrt0_info *) x)->p;
  PVOID& res = ((dllcrt0_info *) x)->res;

  if (p == NULL)
    p = &__cygwin_user_data;
  else
    {
      *(p->impure_ptr_ptr) = __cygwin_user_data.impure_ptr;
      _pei386_runtime_relocator (p);
    }

  bool linked = !cygwin_finished_initializing && !in_load_after_fork;

  /* Broken DLLs built against Cygwin versions 1.7.0-49 up to 1.7.0-57
     override the cxx_malloc pointer in their DLL initialization code,
     when loaded either statically or dynamically.  Because this leaves
     a stale pointer into demapped memory space if the DLL is unloaded
     by a call to dlclose, we prevent this happening for dynamically
     loaded DLLs in dlopen by saving and restoring cxx_malloc around
     the call to LoadLibrary, which invokes the DLL's startup sequence.
     Modern DLLs won't even attempt to override the pointer when loaded
     statically, but will write their overrides directly into the
     struct it points to.  With all modern DLLs, this will remain the
     default_cygwin_cxx_malloc struct in cxx.cc, but if any broken DLLs
     are in the mix they will have overridden the pointer and subsequent
     overrides will go into their embedded cxx_malloc structs.  This is
     almost certainly not a problem as they can never be unloaded, but
     if we ever did want to do anything about it, we could check here to
     see if the pointer had been altered in the early parts of the DLL's
     startup, and if so copy back the new overrides and reset it here.
     However, that's just a note for the record; at the moment, we can't
     see any need to worry about this happening.  */

  check_sanity_and_sync (p);

  dll_type type;

  /* If this function is called before cygwin has finished
     initializing, then the DLL must be a cygwin-aware DLL
     that was explicitly linked into the program rather than
     a dlopened DLL. */
  if (linked)
    type = DLL_LINK;
  else
    {
      type = DLL_LOAD;
      dlls.reload_on_fork = 1;
    }

  /* Allocate and initialize space for the DLL. */
  dll *d = dlls.alloc (h, p, type);

  /* If d == NULL, then something is broken.
     Otherwise, if we've finished initializing, it's ok to
     initialize the DLL.  If we haven't finished initializing,
     it may not be safe to call the dll's "main" since not
     all of cygwin's internal structures may have been set up. */
  if (!d || (!linked && !d->init ()))
    res = (PVOID) -1;
  else
    res = (PVOID) d;
}

#ifndef __x86_64__
/* OBSOLETE: This function is obsolete and will go away in the
   future.  Cygwin can now handle being loaded from a noncygwin app
   using the same entry point. */
extern "C" int
dll_noncygwin_dllcrt0 (HMODULE h, per_process *p)
{
  return (int) dll_dllcrt0 (h, p);
}
#endif /* !__x86_64__ */

extern "C" void
cygwin_detach_dll (dll *)
{
  HANDLE retaddr;
  if (_my_tls.isinitialized ())
    retaddr = (void *) _my_tls.retaddr ();
  else
    retaddr = __builtin_return_address (0);
  dlls.detach (retaddr);
}

extern "C" void
dlfork (int val)
{
  dlls.reload_on_fork = val;
}

#ifndef __x86_64__
/* Called from various places to update all of the individual
   ideas of the environ block.  Explain to me again why we didn't
   just import __cygwin_environ? */
void __stdcall
update_envptrs ()
{
  for (dll *d = dlls.istart (DLL_ANY); d; d = dlls.inext ())
    if (*(d->p.envptr) != __cygwin_environ)
      *(d->p.envptr) = __cygwin_environ;
  *main_environ = __cygwin_environ;
}
#endif
@


1.110
log
@* common.din (__cxa_finalize): Export.
* dcrt0.cc (cygwin_atexit): Use d->handle with __cxa_atexit.
* dll_init.cc (dll_list::detach): Use d->handle with __cxa_finalize.
* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Use 274 for
__cxa_finalize as well.
@
text
@d643 1
a643 1
     loaded DLLS in dlopen by saving and restoring cxx_malloc around
@


1.109
log
@	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d404 1
a404 1
	    __cxa_finalize (d);
@


1.108
log
@	* dll_init.cc (dll_list::topsort): Fix early-return condition to
	accommodate process with all runtime loaded DLLs already dlclosed
	at fork time.
	* gendef (_sigfe_maybe): Fix code handling early return if we don't
	have a tls, broken on 2013-05-21.
@
text
@d182 1
a182 1
  GetModuleFileNameW (h, buf, sizeof (buf));
@


1.108.2.1
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@d182 1
a182 1
  GetModuleFileNameW (h, buf, NT_MAX_PATH);
@


1.108.2.2
log
@2014-08-11  Corinna Vinschen  <corinna@@vinschen.de>

	* cpuid.h: Add missing copyright header.  Fix formatting.  Use uint32_t
	instead of unsigned throughout.  Change functions to static inline and
	always inline.
	(cpuid): Add parameter to set ecx, allowing to request extended CPUID
	info.
	* fhandler_proc.cc (format_proc_cpuinfo): Use uint32_t instead of
	unsigned throughout.  Add fake decimal places to MHz info.  Handle more
	feature flags.
	* fhandler_random.cc (fhandler_dev_random::write): Allow up to 4K
	input to add entropy.
	* syscalls.cc: Drop including cpuid.h.

2014-08-07  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (__cxa_finalize): Export.
	* dcrt0.cc (cygwin_atexit): Use d->handle with __cxa_atexit.
	* dll_init.cc (dll_list::detach): Use d->handle with __cxa_finalize.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Use 274 for
	__cxa_finalize as well.

2014-08-04  Anthony Heading  <anthony@@ajrh.net>

	* include/sys/file.h: Add extern "C".

2014-08-04  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Export.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump to 274.

2014-07-31  Eric Blake  <eblake@@redhat.com>

	* include/pthread.h: Decorate attribute names with __, for
	namespace safety.
	* include/cygwin/core_dump.h: Likewise.
	* include/cygwin/cygwin_dll.h: Likewise.
	* include/sys/cygwin.h: Likewise.
	* include/sys/strace.h: Likewise.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d404 1
a404 1
	    __cxa_finalize (d->handle);
@


1.108.2.3
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@d643 1
a643 1
     loaded DLLs in dlopen by saving and restoring cxx_malloc around
@


1.107
log
@	* Merge in cygwin-64bit-branch.
@
text
@d302 1
a302 1
  if (!end)
@


1.106
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012 Red Hat, Inc.
d89 1
d95 1
d248 1
d250 1
d437 2
a438 2
static DWORD
reserve_at (const PWCHAR name, DWORD here, DWORD dll_base, DWORD dll_size)
d443 2
a444 3
  if (!VirtualQuery ((void *) here, &mb, sizeof (mb)))
    fabort ("couldn't examine memory at %08lx while mapping %W, %E",
	    here, name);
d451 6
a456 6
  DWORD end = here + size;
  DWORD dll_end = dll_base + dll_size;
  if (dll_base < here && dll_end > here)
      here = dll_end; // the dll straddles our left edge
  else if (dll_base >= here && dll_base < end)
      end = dll_base; // the dll overlaps partly or fully to our right
d458 2
a459 2
  size = end - here;
  if (!VirtualAlloc ((void *) here, size, MEM_RESERVE, PAGE_NOACCESS))
d467 1
a467 1
release_at (const PWCHAR name, DWORD here)
d469 1
a469 1
  if (!VirtualFree ((void *) here, 0, MEM_RELEASE))
d542 1
a542 1
	  fabort ("unable to release protective reservation for %W (%08lx), %E",
d550 1
a550 1
	    sigproc_printf ("%W loaded in wrong place: %08lx != %08lx",
d553 2
a554 2
	    DWORD reservation = reserve_at (d->modname, (DWORD) h,
					    (DWORD) d->handle, d->image_size);
d562 1
a562 1
	       fabort ("unable to remap %W to same address as parent (%08lx) - try running rebaseall",
d567 1
a567 1
	    sigproc_printf ("releasing blocked space at %08lx", reservation);
d583 1
a583 1
	    fabort ("unable to release protective reservation for %W (%08lx), %E",
d607 1
a607 1
  int res;
d611 1
a611 1
extern "C" int
d615 1
a615 1
    return 1;
d626 1
a626 1
  int& res = ((dllcrt0_info *) x)->res;
d683 1
a683 1
    res = -1;
d685 1
a685 1
    res = (DWORD) d;
d688 1
a691 1

d695 1
a695 1
  return dll_dllcrt0 (h, p);
d697 1
d716 1
d728 1
@


1.105
log
@whitespace cleanup
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.104
log
@	* dll_init.cc (dll_list::alloc): Take long UNC paths into account.
@
text
@d135 1
a135 1
   
d138 1
a138 1
   
@


1.104.2.1
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d135 1
a135 1

d138 1
a138 1

@


1.104.2.2
log
@	* dll_init.cc (reserve_at): Use PVOID rather than DWORD as type for
	pointer parameters and return type.
	(release_at): Ditto.
	(dll_list::load_after_fork_impl): Fix format strings.  Call reserve_at
	without casts to DWORD.
	(struct dllcrt0_info): Change type of res to PVOID.
	(dll_dllcrt0): Return PVOID rather than int.
	(dll_dllcrt0_1): Accommodate type change of dllcrt0_info::res.
	(dll_noncygwin_dllcrt0): Disable on 64 bit.  Add a cast for 32 bit.
	* dll_init.h (struct pefile): Drop 32 bit decoration from Windows
	types.
	* ntdll.h (struct _DEBUG_HEAP_INFORMATION): Define Base as UINT_PTR.
	(struct _DEBUG_MODULE_INFORMATION): Define Reserved and Base as
	UINT_PTR.
	* winsup.h (dll_dllcrt0): Declare as PVOID.
	(dll_noncygwin_dllcrt0): Don't declare on 64 bit.
	* include/cygwin/cygwin_dll.h (cygwin_attach_dll): Declare as PVOID.
	(cygwin_detach_dll): Declare with PVOID parameter.
	(dll_index): Declare as PVOID.
	(_cygwin_dll_entry): Accommodate type change of dll_index.
	* lib/crt0.h (dll_dllcrt0): Declare as PVOID.
	* lib/cygwin_attach_dll.c (cygwin_attach_dll): Define PVOID.
@
text
@d433 2
a434 2
static PVOID
reserve_at (const PWCHAR name, PVOID here, PVOID dll_base, DWORD dll_size)
d439 3
a441 2
  if (!VirtualQuery (here, &mb, sizeof (mb)))
    fabort ("couldn't examine memory at %p while mapping %W, %E", here, name);
d448 6
a453 6
  caddr_t end = (caddr_t) here + size;
  caddr_t dll_end = (caddr_t) dll_base + dll_size;
  if (dll_base < here && dll_end > (caddr_t) here)
      here = (PVOID) dll_end; // the dll straddles our left edge
  else if (dll_base >= here && (caddr_t) dll_base < end)
      end = (caddr_t) dll_base; // the dll overlaps partly or fully to our right
d455 2
a456 2
  size = end - (caddr_t) here;
  if (!VirtualAlloc (here, size, MEM_RESERVE, PAGE_NOACCESS))
d464 1
a464 1
release_at (const PWCHAR name, PVOID here)
d466 1
a466 1
  if (!VirtualFree (here, 0, MEM_RELEASE))
d539 1
a539 1
	  fabort ("unable to release protective reservation for %W (%p), %E",
d550 2
a551 2
	    PVOID reservation = reserve_at (d->modname, h,
					    d->handle, d->image_size);
d564 1
a564 1
	    sigproc_printf ("releasing blocked space at %p", reservation);
d604 1
a604 1
  PVOID res;
d608 1
a608 1
extern "C" PVOID
d612 1
a612 1
    return (PVOID) 1;
d623 1
a623 1
  PVOID& res = ((dllcrt0_info *) x)->res;
d680 1
a680 1
    res = (PVOID) -1;
d682 1
a682 1
    res = (PVOID) d;
a684 1
#ifndef __x86_64__
d688 1
d692 1
a692 1
  return (int) dll_dllcrt0 (h, p);
a693 1
#endif /* !__x86_64__ */
@


1.104.2.3
log
@	* dll_init.cc: Fix debug printf to be type-safe.
	* dtable.cc: Ditto.
@
text
@d546 1
a546 1
	    sigproc_printf ("%W loaded in wrong place: %p != %p",
d558 1
a558 1
	       fabort ("unable to remap %W to same address as parent (%p) - try running rebaseall",
d579 1
a579 1
	    fabort ("unable to release protective reservation for %W (%p), %E",
@


1.104.2.4
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.104.2.5
log
@	For x86_64 target:
	* Makefile.in (COMMON_CFLAGS): Add -mcmodel=small to create smaller
	footprint.
	* cygwin64.din (__cygwin_environ): Drop export.  Only export environ
	as alias to __cygwin_environ.
	* dcrt0.cc (dll_crt0_1): Call main with __cygwin_environ as parameter.
	(_dll_crt0): Don't set main_environ.
	(cygwin_dll_init): Don't create local variable envp and don't set
	user_data->envptr.
	* dll_init.cc (dll_list::alloc): Don't assert.
	* dll_init.h (per_module::operator =): Don't set envptr.
	* environ.cc (cur_environ): Disable.
	* environ.h (main_environ): Don't define.
	(cur_environ): Change to macro.
	* globals.cc (main_environ): Don't initialize.
	(struct per_process): Drop envptr.
	* perprocess.h (SIZEOF_PER_PROCESS): Set to 41*8 to accommodate size
	change of struct per_process.
	* include/sys/cygwin.h (struct per_process): Drop envptr.
	* lib/_cygwin_crt0_common.cc (environ): Drop declaration.
	(_cygwin_crt0_common): Don't set u->envptr.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
a245 1
#ifndef __x86_64__
a246 1
#endif
a717 1
#ifndef __x86_64__
a721 1
#endif
@


1.104.2.6
log
@	For x86_64 target:
	* dll_init.cc (dll::init): Don't set p.envptr.
	(update_envptrs): Disable entirely.
	* dll_init.h (struct per_module): Disable envptr.
	* environ.h (update_envptrs): Change to empty macro.
@
text
@a88 1
#ifndef __x86_64__
a93 1
#endif
a713 1
#ifndef __x86_64__
d720 1
d725 1
a726 1
#endif
@


1.103
log
@	* dll_init.cc (dll_list::operator[]): Extend comment a bit more to
	explain previous patch.
@
text
@d183 8
a190 1
    name += 4;
@


1.102
log
@	* dll_init.cc (dll_list::alloc): Compare linked DLLs by basename only.
	Explain why.  Add code to check if a DLL with the same basename but
	different path is the same DLL.  Bail out if not.
	(in_load_after_fork): New static NO_COPY bool to allow to differ
	between linked and loaded DLL at fork.
	(dll_list::load_after_fork): Set in_load_after_fork accordingly.
	(dll_dllcrt0_1): Don't treat DLL as linked if in_load_after_fork is set.
	Drop test for in_forkee.
@
text
@d134 16
a149 1
   work as expected. */
@


1.101
log
@	* dll_init.cc: Revert pathname changes from 2012-02-08.
	(dll_list::operator[]): Add long comment to explain the misery.
	(dll_list::alloc): Skip long pathname prefix potentially returned by
	GetModuleFileNameW.
	* dll_init.h (dll_list::find_by_modname): Add back declaration.
@
text
@d170 1
d173 4
a176 2
  /* Already loaded? */
  dll *d = dlls[name];
d184 15
d210 1
a210 1
      d->modname = wcsrchr (d->name, L'\\') + 1;
d467 6
d482 1
d484 1
d611 1
a611 1
  bool linked = !in_forkee && !cygwin_finished_initializing;
@


1.100
log
@	* dll_init.h (struct dll): Re-add modname.
	* dll_init.cc: Throughout, use modname where it was used before.
	(dll_list::operator[]): Use modname.  Move comment from dll_list::alloc
	here and remove hint about GetModuleBaseNameW.
	(dll_list::alloc): Store full path in name, pointer to basename in
	modname.  Search dll using modname.
@
text
@d109 38
a146 5
/* Look for a dll based on the basename.
   Only compare basenames for DLLs.  Per MSDN, the Windows loader re-uses
   the already loaded DLL, if the new DLL has the same basename as the
   already loaded DLL.  It will not try to load the new DLL at all.  See
   http://msdn.microsoft.com/en-us/library/ms682586%28v=vs.85%29.aspx */
d148 1
a148 1
dll_list::operator[] (const PWCHAR modname)
d164 5
a168 2
  WCHAR name[NT_MAX_PATH];
  GetModuleFileNameW (h, name, sizeof (name));
a169 1
  PWCHAR modname = wcsrchr (name, L'\\') + 1;
d173 1
a173 1
  dll *d = dlls[modname];
d180 1
a180 1
		modname, d->handle, h);
d192 1
a192 1
      d->modname = d->name + (modname - name);
d238 1
a238 1
      if (dll* dep = dlls[wmodname])
@


1.99
log
@	* dll_init.cc: Throughout, drop usage of modname in favor of name.
	(dll_list::find_by_modname): Remove.
	(dll_list::alloc): Only store module basename in name.  Add comment to
	explain why.  Simplify address check.  Fix formatting in comment.
	* dll_init.h (struct dll): Drop modname and find_by_modname.
@
text
@d109 5
a113 1
/* Look for a dll based on name */
d115 1
a115 1
dll_list::operator[] (const PWCHAR name)
d119 1
a119 1
    if (!wcscasecmp (name, d->name))
d131 2
a132 9
  /* Only use and compare basenames for DLLs.  Per MSDN, the Windows loader
     re-uses the already loaded DLL, if the new DLL has the same basename
     as the already loaded DLL.  It will not try to load the new DLL at all.
     See http://msdn.microsoft.com/en-us/library/ms682586%28v=vs.85%29.aspx
     Use GetModuleFileNameW + wcsrchr rather than GetModuleBaseNameW since
     it's faster per MSDN, and it doesn't require to link against psapi. */
  WCHAR buf[NT_MAX_PATH];
  GetModuleFileNameW (h, buf, sizeof (buf));
  PWCHAR name = wcsrchr (buf, L'\\') + 1;
d134 1
d138 1
a138 1
  dll *d = dlls[name];
d145 1
a145 1
		name, d->handle, h);
d157 1
d242 1
a242 1
      paranoid_printf ("%W", d->name);
d244 1
a244 1
	paranoid_printf ("-> %W", d->deps[i - 1]->name);
d411 1
a411 1
	      d->name, d->handle);
d457 1
a457 1
		  d->name, d->handle);
d461 1
a461 2
	  fabort ("unable to create interim mapping for %W, %E",
		  d->name);
d465 1
a465 1
			    d->name, h, d->handle);
d467 1
a467 1
	    DWORD reservation = reserve_at (d->name, (DWORD) h,
d471 1
a471 1
		      h, d->name);
d477 1
a477 1
		       d->name, d->handle);
d482 1
a482 1
	    release_at (d->name, reservation);
d498 1
a498 1
		    d->name, d->handle);
d506 1
a506 1
		    d->name);
d513 1
a513 1
		d->name, d->handle, h);
@


1.98
log
@	* dll_init.cc (dll_list::alloc): Add DLL name to fabort output.  Fix
	fabort string in case of bss start.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
a120 12
/* Look for a dll based on is short name only (no path) */
dll *
dll_list::find_by_modname (const PWCHAR name)
{
  dll *d = &start;
  while ((d = d->next) != NULL)
    if (!wcscasecmp (name, d->modname))
      return d;

  return NULL;
}

d127 10
a136 2
  WCHAR name[NT_MAX_PATH];
  DWORD namelen = GetModuleFileNameW (h, name, sizeof (name));
d145 3
a147 15
      else
	{
	  if (d->p.data_start != p->data_start)
	    fabort ("%W: data segment start: parent(%p) != child(%p)",
		    name, d->p.data_start, p->data_start);
	  else if (d->p.data_end != p->data_end)
	    fabort ("%W: data segment end: parent(%p) != child(%p)",
		    name, d->p.data_end, p->data_end);
	  else if (d->p.bss_start != p->bss_start)
	    fabort ("%W: bss segment start: parent(%p) != child(%p)",
		    name, d->p.bss_start, p->bss_start);
	  else if (d->p.bss_end != p->bss_end)
	    fabort ("%W: bss segment end: parent(%p) != child(%p)",
		    name, d->p.bss_end, p->bss_end);
	}
d155 2
a156 2
      /* Now we've allocated a block of information.  Fill it in with the supplied
	 info about this DLL. */
a163 3
      d->modname = wcsrchr (d->name, L'\\');
      if (d->modname)
       d->modname++;
d204 1
a204 1
      if (dll* dep = find_by_modname (wmodname))
d243 1
a243 1
      paranoid_printf ("%W", d->modname);
d245 1
a245 1
	paranoid_printf ("-> %W", d->deps[i - 1]->modname);
d412 1
a412 1
	      d->modname, d->handle);
d458 1
a458 1
		  d->modname, d->handle);
d467 1
a467 1
			    d->modname, h, d->handle);
d469 1
a469 1
	    DWORD reservation = reserve_at (d->modname, (DWORD) h,
d473 1
a473 1
		      h, d->modname);
d479 1
a479 1
		       d->modname, d->handle);
d484 1
a484 1
	    release_at (d->modname, reservation);
d500 1
a500 1
		    d->modname, d->handle);
d508 1
a508 1
		    d->modname);
d515 1
a515 1
		d->modname, d->handle, h);
@


1.97
log
@* dll_init.cc (dll_dllcrt0): Don't try to initialize dll data if we're
dynamically loaded since fork() doesn't work in that scenario anyway.
(dll_dllcrt0_1): Don't accommodate dynamically loaded dlls.
* exceptions.cc (ctrl_c_handler): Don't lock the process; there's too much risk
of deadlock.
* sigproc.cc (_cygtls::remove_wq): Don't try to remove anything from the waitq
if there is obviously nothing there.
* strace.cc (strace::activate): Allow stracing dynamically loaded cygwin1.dll.
@
text
@d152 2
a153 2
	    fabort ("data segment start: parent(%p) != child(%p)",
		    d->p.data_start, p->data_start);
d155 2
a156 2
	    fabort ("data segment end: parent(%p) != child(%p)",
		    d->p.data_end, p->data_end);
d158 2
a159 2
	    fabort ("data segment start: parent(%p) != child(%p)",
		    d->p.bss_start, p->bss_start);
d161 2
a162 2
	    fabort ("bss segment end: parent(%p) != child(%p)",
		    d->p.bss_end, p->bss_end);
@


1.96
log
@* sync.cc: Fix comment.
* dll_init.cc (dll_list::reserve_space): Use %p rather than %lx to show
reserved space.
@
text
@d549 2
d552 1
a552 5

  if (_my_tls.isinitialized ())
    dll_dllcrt0_1 (&x);
  else
    _my_tls.call ((DWORD (*) (void *, void *)) dll_dllcrt0_1, &x);
d593 1
a593 5
  /* Partially initialize Cygwin guts for non-cygwin apps. */
  if (dynamically_loaded && user_data->magic_biscuit == 0)
    dll_crt0 (p);
  else
    check_sanity_and_sync (p);
@


1.95
log
@* dll_init.cc: Use fabort in favor of api_fatal and fork_info->abort where
appropriate throughout.
(fabort): Define.
(dll_list::topsort): Don't print sorting information.  Fix formatting.
(dll_list::topsort_visit): Fix formatting.
(dll_list::load_after_fork_impl): Perform comment fixups.
* sigproc.cc (child_info_fork::abort): (for now?) Always print cause of fork
failure.
* include/sys/strace.h (strace_vprintf): Remove _STRACE_NOTALL when printing.
We really do want to see this.
@
text
@d430 1
a430 1
      fabort ("address space needed by '%W' (%08lx) is already occupied",
@


1.94
log
@* dll_init.cc (dll_list::load_after_fork_impl): Add a hint to an error message.
@
text
@d31 2
d152 2
a153 2
	    fork_info->abort ("data segment start: parent(%p) != child(%p)",
			      d->p.data_start, p->data_start);
d155 2
a156 2
	    fork_info->abort ("data segment end: parent(%p) != child(%p)",
			      d->p.data_end, p->data_end);
d158 2
a159 2
	    fork_info->abort ("data segment start: parent(%p) != child(%p)",
			      d->p.bss_start, p->bss_start);
d161 2
a162 2
	    fork_info->abort ("bss segment end: parent(%p) != child(%p)",
			      d->p.bss_end, p->bss_end);
d261 5
a265 3
      debug_printf ("%W", d->modname);
      for (int i=1; i < -d->ndeps; i++)
	debug_printf ("-> %W", d->deps[i-1]->modname);
d301 2
a302 2
      for (long i=1; i < -d->ndeps; i++)
	topsort_visit (d->deps[i-1], false);
d385 2
a386 2
    api_fatal ("couldn't examine memory at %08lx while mapping %W, %E",
	       here, name);
d402 2
a403 2
    api_fatal ("couldn't allocate memory %p(%d) for '%W' alignment, %E\n",
	       here, size, name);
d412 2
a413 2
    api_fatal ("couldn't release memory %p for '%W' alignment, %E\n",
	       here, name);
d430 2
a431 2
      fork_info->abort ("address space needed by '%W' (%08lx) is already occupied",
			d->modname, d->handle);
d476 2
a477 2
	  api_fatal ("unable to release protective reservation for %W (%08lx), %E",
		     d->modname, d->handle);
d481 2
a482 1
	  api_fatal ("unable to create interim mapping for %W, %E", d->name);
d491 2
a492 2
	      api_fatal ("unable to block off %p to prevent %W from loading there",
			 h, d->modname);
d497 2
a498 2
	      fork_info->abort ("unable to remap %W to same address as parent (%08lx) - try running rebaseall",
				d->modname, d->handle);
d512 1
a512 7
     outside our control.

     It stinks that we can't invert the order of the initial LoadLibrary
     and FreeLibrary since Microsoft documentation seems to imply that
     should do what we want.  However, once a library is loaded as
     above, the second LoadLibrary will not execute its startup code
     unless it is first unloaded. */
d518 2
a519 2
	    api_fatal ("unable to release protective reservation for %W (%08lx), %E",
		       d->modname, d->handle);
d524 1
a524 1
	     to ours our we wouldn't have gotten this far */
d526 2
a527 1
	    api_fatal ("unable to unload interim mapping of %W, %E", d->modname);
d531 1
a531 1
	api_fatal ("unable to map %W, %E", d->name);
d533 2
a534 2
	api_fatal ("unable to map %W to same address as parent: %p != %p",
		   d->modname, d->handle, h);
@


1.93
log
@whitespace elimination
@
text
@d492 1
a492 1
	      fork_info->abort ("unable to remap %W to same address as parent (%08lx)",
@


1.92
log
@* dll_init.cc (dll_list::append): Eliminate increment of unused tot variable.
* dll_init.h (dll_list::tot): Delete.
(dll_list::populate_all_deps): Delete undefined function.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Move EPIPE handling
under error condition.
@
text
@d474 1
a474 1
	
@


1.91
log
@* dll_init.cc (reserve_upto): Remove.
(release_upto): Ditto.
(dll_list::reserve_space): New function to reserve space needed by DLL_LOAD
dlls early in the fork process.
(dll_list::load_after_fork): Rewrite to use recursion to track reservations it
makes while trying to make dlls land where they belong.
(dll_list::load_after_fork_impl): New function used by load_after_fork.
(dll_list::alloc): Initialize image base field.
* dll_init.h (dll_list::prefered_base): New field.
(dll_list::reserve_space): Declare new function.
(dll_list::load_after_fork): Declare new function.
* fork.cc (frok::child): call dll_list::reserve_space early, so we can retry if
it fails.
@
text
@a201 1
  tot++;
@


1.90
log
@* dll_init.cc (dll_list::find_by_modname): New function to search the dll list
for a module name only (no path).
(dll_list::alloc): Initialize newly-added members of struct dll.
(dll_list::append): New function to factor out the append operation
(used by dll_list::topsort).
(dll_list::populate_deps): New function to identify dll dependencies.
(dll_list::topsort): New function to sort the dll list topologically by
dependencies.
(dll_list::topsort_visit): New helper function for the above.
* dll_init.h (dll::ndeps): New class member.
(dll::deps): Ditto.
(dll::modname): Ditto.
(dll_list::find_by_modname): New function related to topsort.
(dll_list::populate_all_deps): Ditto.
(dll_list::populate_deps): Ditto.
(dll_list::topsort): Ditto.
(dll_list::topsort_visit): Ditto.
(dll_list::append): Ditto.
(pefile): New struct allowing simple introspection of dll images.
* fork.cc (fork): Topologically sort the dll list before forking
* child_info.h (CURR_CHILD_INFO_MAGIC): Refresh.
(child_info::refresh_cygheap): New function.
* spawn.cc (spawn_guts): Call refresh_cygheap before creating a new process to
ensure that cygheap_max is up-to-date.
* fork.cc (frok::parent): Ditto.
@
text
@d182 1
d232 1
a232 1
  
d244 1
a244 1
  
d250 1
a250 1
  
d294 1
a294 1
  
a369 50
/* Mark every memory address up to "here" as reserved.  This may force
   Windows NT to load a DLL in the next available, lowest slot. */
static void
reserve_upto (const PWCHAR name, DWORD here)
{
  DWORD size;
  MEMORY_BASIC_INFORMATION mb;
  for (DWORD start = 0x10000; start < here; start += size)
    if (!VirtualQuery ((void *) start, &mb, sizeof (mb)))
      size = A64K;
    else
      {
	size = A64K * ((mb.RegionSize + A64K - 1) / A64K);
	start = A64K * (((DWORD) mb.BaseAddress + A64K - 1) / A64K);

	if (start + size > here)
	  size = here - start;
	if (mb.State == MEM_FREE &&
	    !VirtualAlloc ((void *) start, size, MEM_RESERVE, PAGE_NOACCESS))
	  api_fatal ("couldn't allocate memory %p(%d) for '%W' alignment, %E\n",
		     start, size, name);
      }
}

/* Release all of the memory previously allocated by "upto" above.
   Note that this may also free otherwise reserved memory.  If that becomes
   a problem, we'll have to keep track of the memory that we reserve above. */
static void
release_upto (const PWCHAR name, DWORD here)
{
  DWORD size;
  MEMORY_BASIC_INFORMATION mb;
  for (DWORD start = 0x10000; start < here; start += size)
    if (!VirtualQuery ((void *) start, &mb, sizeof (mb)))
      size = 64 * 1024;
    else
      {
	size = mb.RegionSize;
	if (!(mb.State == MEM_RESERVE && mb.AllocationProtect == PAGE_NOACCESS
	    && (((void *) start < cygheap->user_heap.base
		 || (void *) start > cygheap->user_heap.top)
		 && ((void *) start < (void *) cygheap
		     || (void *) start
			> (void *) ((char *) cygheap + CYGHEAPSIZE)))))
	  continue;
	if (!VirtualFree ((void *) start, 0, MEM_RELEASE))
	  api_fatal ("couldn't release memory %p(%d) for '%W' alignment, %E\n",
		     start, size, name);
      }
}
d388 1
a388 1
  
d396 1
a396 1
  
d413 18
d437 2
a438 1
  DWORD preferred_block = 0;
d440 2
a441 21
  for (dll *d = &dlls.start; (d = d->next) != NULL; )
    if (d->type == DLL_LOAD)
      for (int i = 0; i < 2; i++)
	{
	  /* See if DLL will load in proper place.  If so, free it and reload
	     it the right way.
	     It stinks that we can't invert the order of the initial LoadLibrary
	     and FreeLibrary since Microsoft documentation seems to imply that
	     should do what we want.  However, once a library is loaded as
	     above, the second LoadLibrary will not execute its startup code
	     unless it is first unloaded. */
	  HMODULE h = LoadLibraryExW (d->name, NULL, DONT_RESOLVE_DLL_REFERENCES);

	  if (!h)
	    system_printf ("can't reload %W, %E", d->name);
	  else
	    {
	      FreeLibrary (h);
	      if (h == d->handle)
		h = LoadLibraryW (d->name);
	    }
d443 25
a467 5
	  /* If we reached here on the second iteration of the for loop
	     then there is a lot of memory to release. */
	  if (i > 0)
	    {
	      release_upto (d->name, (DWORD) d->handle);
d469 34
a502 28
	      if (preferred_block)
		release_at (d->name, preferred_block);
	      preferred_block = 0;
	    }

	  if (h == d->handle)
	    break;		/* Success */

	  if (i > 0)
	    /* We tried once to relocate the dll and it failed. */
	    api_fatal ("unable to remap %W to same address as parent: %p != %p",
		       d->name, d->handle, h);

	  /* Dll loaded in the wrong place.  Dunno why this happens but it
	     always seems to happen when there are multiple DLLs with the
	     same base address.  In the "forked" process, the relocated DLL
	     may load at a different address. So, block all of the memory up
	     to the relocated load address and try again. */
	  reserve_upto (d->name, (DWORD) d->handle);

	  /* Also, if the DLL loaded at a higher address than wanted (probably
	     it's base address), reserve the memory at that address. This can
	     happen if it couldn't load at the preferred base in the parent, but
	     can in the child, due to differences in the load ordering.
	     Block memory at it's preferred address and try again. */
	  if ((DWORD) h > (DWORD) d->handle)
	    preferred_block = reserve_at (d->name, (DWORD) h,
					  (DWORD) d->handle, d->image_size);
d504 25
d530 7
@


1.89
log
@* dll_init.cc (dll_list::alloc): Initialize dll::image_size.
(reserve_at): Don't reserve space needed by the target dll if the latter
overlaps the free region to be blocked.
(dll_list::load_after_fork): Use new version of reserve_at.
* dll_init.h (dll::image_size): New member.
(pefile): New struct.
@
text
@d119 12
d176 5
d183 1
a183 7
      if (end == NULL)
	end = &start;	/* Point to "end" of dll chain. */
      end->next = d;	/* Standard linked list stuff. */
      d->next = NULL;
      d->prev = end;
      end = d;
      tot++;
d192 113
d449 1
a449 1
               here, size, name);
d459 1
a459 1
               here, name);
d495 2
a496 2
            {
              release_upto (d->name, (DWORD) d->handle);
d498 4
a501 4
              if (preferred_block)
                release_at (d->name, preferred_block);
              preferred_block = 0;
            }
d512 4
a515 4
             always seems to happen when there are multiple DLLs with the
             same base address.  In the "forked" process, the relocated DLL
             may load at a different address. So, block all of the memory up
             to the relocated load address and try again. */
d518 7
a524 7
          /* Also, if the DLL loaded at a higher address than wanted (probably
             it's base address), reserve the memory at that address. This can
             happen if it couldn't load at the preferred base in the parent, but
             can in the child, due to differences in the load ordering.
             Block memory at it's preferred address and try again. */
          if ((DWORD) h > (DWORD) d->handle)
            preferred_block = reserve_at (d->name, (DWORD) h,
@


1.88
log
@Revert previous checkins as they introduced a bug when running zsh.
@
text
@d164 1
d296 4
a299 2
/* Mark one page at "here" as reserved.  This may force
   Windows NT to load a DLL elsewhere. */
d301 1
a301 1
reserve_at (const PWCHAR name, DWORD here)
d307 2
a308 2
    size = 64 * 1024;

d313 10
d400 2
a401 1
            preferred_block = reserve_at (d->name, (DWORD) h);
@


1.87
log
@* dll_init.cc (reserve_upto): Remove.
(release_upto): Ditto.
(dll_list::reserve_space): New function to reserve space needed by DLL_LOAD
dlls early in the fork process.
(dll_list::load_after_fork): Rewrite to use recursion for tracking reservations
made while trying to make dlls land where they belong.
(dll_list::load_after_fork_impl): Ditto.
(dll_list::alloc): Initialize image base field.
* dll_init.h (struct dll_list): declare new functions.
(dll::image_size): New member.
@
text
@a118 12
/* Look for a dll based on is short name only (no path) */
dll *
dll_list::find_by_modname (const PWCHAR name)
{
  dll *d = &start;
  while ((d = d->next) != NULL)
    if (!wcscasecmp (name, d->modname))
      return d;

  return NULL;
}

a163 6
      d->image_size = ((pefile*)h)->optional_hdr ()->SizeOfImage;
      d->ndeps = 0;
      d->deps = NULL;
      d->modname = wcsrchr (d->name, L'\\');
      if (d->modname)
	d->modname++;
d165 7
a171 1
      append (d);
a179 113
void
dll_list::append (dll* d)
{
  if (end == NULL)
    end = &start;	/* Point to "end" of dll chain. */
  end->next = d;	/* Standard linked list stuff. */
  d->next = NULL;
  d->prev = end;
  end = d;
  tot++;
}

void dll_list::populate_deps (dll* d)
{
  WCHAR wmodname[NT_MAX_PATH];
  pefile* pef = (pefile*) d->handle;
  PIMAGE_DATA_DIRECTORY dd = pef->idata_dir (IMAGE_DIRECTORY_ENTRY_IMPORT);
  /* Annoyance: calling crealloc with a NULL pointer will use the
     wrong heap and crash, so we have to replicate some code */
  long maxdeps = 4;
  d->deps = (dll**) cmalloc (HEAP_2_DLL, maxdeps*sizeof (dll*));
  d->ndeps = 0;
  for (PIMAGE_IMPORT_DESCRIPTOR id=
	(PIMAGE_IMPORT_DESCRIPTOR) pef->rva (dd->VirtualAddress);
      dd->Size && id->Name;
      id++)
    {
      char* modname = pef->rva (id->Name);
      sys_mbstowcs (wmodname, NT_MAX_PATH, modname);
      if (dll* dep = find_by_modname (wmodname))
	{
	  if (d->ndeps >= maxdeps)
	    {
	      maxdeps = 2*(1+maxdeps);
	      d->deps = (dll**) crealloc (d->deps, maxdeps*sizeof (dll*));
	    }
	  d->deps[d->ndeps++] = dep;
	}
    }
  
  /* add one to differentiate no deps from unknown */
  d->ndeps++;
}


void
dll_list::topsort ()
{
  /* Anything to do? */
  if (!end)
    return;
  
  /* make sure we have all the deps available */
  dll* d = &start;
  while ((d = d->next))
    if (!d->ndeps)
      populate_deps (d);
  
  /* unlink head and tail pointers so the sort can rebuild the list */
  d = start.next;
  start.next = end = NULL;
  topsort_visit (d, true);

  /* clear node markings made by the sort */
  d = &start;
  while ((d = d->next))
    {
      debug_printf ("%W", d->modname);
      for (int i=1; i < -d->ndeps; i++)
	debug_printf ("-> %W", d->deps[i-1]->modname);

      /* It would be really nice to be able to keep this information
	 around for next time, but we don't have an easy way to
	 invalidate cached dependencies when a module unloads. */
      d->ndeps = 0;
      cfree (d->deps);
      d->deps = NULL;
    }
}

/* A recursive in-place topological sort. The result is ordered so that
   dependencies of a dll appear before it in the list.

   NOTE: this algorithm is guaranteed to terminate with a "partial
   order" of dlls but does not do anything smart about cycles: an
   arbitrary dependent dll will necessarily appear first. Perhaps not
   surprisingly, Windows ships several dlls containing dependency
   cycles, including SspiCli/RPCRT4.dll and a lovely tangle involving
   USP10/LPK/GDI32/USER32.dll). Fortunately, we don't care about
   Windows DLLs here, and cygwin dlls should behave better */
void
dll_list::topsort_visit (dll* d, bool seek_tail)
{
  /* Recurse to the end of the dll chain, then visit nodes as we
     unwind. We do this because once we start visiting nodes we can no
     longer trust any _next_ pointers.

     We "mark" visited nodes (to avoid revisiting them) by negating
     ndeps (undone once the sort completes). */
  if (seek_tail && d->next)
    topsort_visit (d->next, true);
  
  if (d->ndeps > 0)
    {
      d->ndeps = -d->ndeps;
      for (long i=1; i < -d->ndeps; i++)
	topsort_visit (d->deps[i-1], false);

      append (d);
    }
}


d295 2
a296 4
/* Reserve the chunk of free address space starting _here_ and (usually)
   covering at least _dll_size_ bytes. However, we must take care not
   to clobber the dll's target address range because it often overlaps.
 */
d298 1
a298 1
reserve_at (const PWCHAR name, DWORD here, DWORD dll_base, DWORD dll_size)
d304 2
a305 2
    api_fatal ("couldn't examine memory at %08lx while mapping %W, %E",
	       here, name);
a309 10
  
  // don't clobber the space where we want the dll to land
  DWORD end = here + size;
  DWORD dll_end = dll_base + dll_size;
  if (dll_base < here && dll_end > here)
      here = dll_end; // the dll straddles our left edge
  else if (dll_base >= here && dll_base < end)
      end = dll_base; // the dll overlaps partly or fully to our right
  
  size = end - here;
d387 1
a387 2
            preferred_block = reserve_at (d->name, (DWORD) h,
					  (DWORD) d->handle, d->image_size);
@


1.86
log
@* dll_init.cc (dll_list::find_by_modname): New function to search the dll list
for a module name only (no path).
(dll_list::alloc): Initialize newly-added members of struct dll.
(dll_list::append): New function to factor out the append operation
(used by dll_list::topsort).
(dll_list::populate_deps): New function to identify dll dependencies.
(dll_list::topsort): New function to sort the dll list topologically by
dependencies.
(dll_list::topsort_visit): New helper function for the above.
* dll_init.h (dll::ndeps): New class member.
(dll::deps): Ditto.
(dll::modname): Ditto.
(dll_list::find_by_modname): New function related to topsort.
(dll_list::populate_all_deps): Ditto.
(dll_list::populate_deps): Ditto.
(dll_list::topsort): Ditto.
(dll_list::topsort_visit): Ditto.
(dll_list::append): Ditto.
(pefile): New struct allowing simple introspection of dll images.
* fork.cc (fork): Topologically sort the dll list before forking.
@
text
@d176 1
d420 4
a423 2
/* Mark one page at "here" as reserved.  This may force
   Windows NT to load a DLL elsewhere. */
d425 1
a425 1
reserve_at (const PWCHAR name, DWORD here)
d431 2
a432 2
    size = 64 * 1024;

d437 10
d524 2
a525 1
            preferred_block = reserve_at (d->name, (DWORD) h);
@


1.85
log
@* dll_init.c (dll_list::load_after_fork): Don't clear in_forkee here.
* fork.cc (frok::errmsg): Rename from 'error'.
(frok::error): New function.  Handle conditional printing of error messages.
(frok::parent): Record hchild handle for use by error function.  Use
throughout.  Use error function rather than setting error pointer directly.
(fork): Clear is_forkee here.  Accommodate rename of 'error' to 'errmsg'.
* sigproc.cc (child_info::proc_retry): Detect EXITCODE_FORK_FAILED.
@
text
@d119 12
d176 5
d182 1
a182 7
      if (end == NULL)
	end = &start;	/* Point to "end" of dll chain. */
      end->next = d;	/* Standard linked list stuff. */
      d->next = NULL;
      d->prev = end;
      end = d;
      tot++;
d191 113
@


1.84
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@a389 1
  in_forkee = false;
@


1.83
log
@* dll_list::detach (dll_list::detach): Avoid doing anything with detach during
a failing fork.
@
text
@d22 1
d135 15
@


1.82
log
@* dll_init.cc (dll_global_dtors): Avoid calling destructors during failing
fork().
@
text
@d184 4
a187 1
  if (!myself)
@


1.81
log
@Eliminate trailing whitespace in some files.

* dll_init.cc (dll_list::alloc): Reset 'p' in forked process.
* select.cc (select_stuff::wait): Move cleanup() closer to WFMO to minimize
unavoidable (?) race.
@
text
@d40 5
@


1.80
log
@* cygheap.cc (init_cygheap::close_ctty): Avoid closing console-cttys since they
don't use archetypes and this will just result in double frees.
* dll_init.cc (dll_list::protect): Define.
(dll_list::alloc): Guard list access.
(dll_list::detach): Ditto.
* dll_init.h (dll_list::protect): Declare new muto.
(dll_list::guard): Define/declare function to guard list access.
* fhandler_termios.cc (fhandler_termios::sigflush): Avoid SEGV in pathological
condition of get_ttyp() == NULL.
@
text
@d129 1
@


1.79
log
@* dll_init.cc (reserve_at, release_at): New functions.
(load_after_fork): If the DLL was loaded higher than the required address,
assume that it loaded at it's base address and also reserve memory there to
force it to be relocated.
@
text
@d13 1
d32 2
d122 1
d153 1
d178 1
a178 1
  if (!myself || !(d = find (retaddr)))
d180 2
a181 3
  if (d->count <= 0)
    system_printf ("WARNING: trying to detach an already detached dll ...");
  if (--d->count == 0)
d183 19
a201 14
      /* Ensure our exception handler is enabled for destructors */
      exception protect;
      /* Call finalize function if we are not already exiting */
      if (!exit_state)
	__cxa_finalize (d);
      d->run_dtors ();
      d->prev->next = d->next;
      if (d->next)
	d->next->prev = d->prev;
      if (d->type == DLL_LOAD)
	loaded_dlls--;
      if (end == d)
	end = d->prev;
      cfree (d);
d203 1
@


1.78
log
@* dll_init.cc (dll::init): Accommodate ill-behaved dlls who don't fill out
p.envptr.
@
text
@d81 1
a81 1
  else
d260 30
d296 2
d319 1
d323 8
a330 1
	    release_upto (d->name, (DWORD) d->handle);
d340 4
a343 4
	     always seems to happen when there are multiple DLLs attempting to
	     load into the same address space.  In the "forked" process, the
	     second DLL always loads into a different location. So, block all
	     of the memory up to the new load address and try again. */
d345 9
d363 1
a363 1
  dllcrt0_info (HMODULE h0, per_process *p0): h(h0), p(p0) {}
d381 3
a383 3
  HMODULE& h = ((dllcrt0_info *)x)->h;
  per_process*& p = ((dllcrt0_info *)x)->p;
  int& res = ((dllcrt0_info *)x)->res;
d483 2
a484 1
    *(d->p.envptr) = __cygwin_environ;
@


1.77
log
@	* Throughout fix copyright dates.
@
text
@d79 4
a82 1
  *(p.envptr) = __cygwin_environ;
@


1.77.2.1
log
@Pull in HEAD changes
@
text
@d79 1
a79 4
  if (!p.envptr)
    p.envptr = &__cygwin_environ;
  else
    *(p.envptr) = __cygwin_environ;
@


1.76
log
@* dll_init.cc: Fix typo in comment.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010 Red Hat, Inc.
@


1.75
log
@* Makefile.in (DLL_OFILES): Add pseudo-reloc.o.
* dcrt0.cc (child_info_fork::handle_fork): Call _pei386_runtime_relocator here.
(dll_crt0_1): Ditto for non-fork case.
* dll_init.cc (dll::init): Complain more in comment.  Clean up slightly.
(dll_dllcrt0_1): Call _pei386_runtime_relocator when we know we have a
filled-in per_process structure.
* globals.cc (__cygwin_user_data): Accommodate new fields for
_pei386_runtime_relocator.
* pseudo-reloc.cc: New file adapted from old lib/pseudo-reloc.c.  Include
winsup.h directly.  Collapse #ifdef __CYGWIN__ into one block.  Perform minor
whitespace code reformatting.
(__report_error): Use small_printf to output error.
(_pei386_runtime_relocator): Conditionalize for cygwin to take per_process
pointer parameter.
* winsup.h (_pei386_runtime_relocator): Declare.
* include/cygwin/version.h
(CYGWIN_VERSION_PER_PROCESS_API_VERSION_COMBINED): New macro.
(CYGWIN_VERSION_USER_API_VERSION_COMBINED): Use above macro.
(CYGWIN_VERSION_USE_PSEUDO_RELOC_IN_DLL): New macro.
(CYGWIN_VERSION_API_MINOR): Bump to 227.
* include/sys/cygwin.h: Remove obsolete comment.
(per_process::unused2): Shorten.
(per_process::pseudo_reloc_start): New field.
(per_process::pseudo_reloc_end): Ditto.
(per_process::image_base): Ditto.
* lib/_cygwin_crt0_common.cc: Declare pseudo runtime externs needed for
per_process structure.
(_cygwin_crt0_common): Fill in pseudo_reloc runtime constants.
* lib/pseudo-reloc-dummy.c: New file.  Dummy function to satisify ld.
* lib/pseudo-reloc.c: Delete.
@
text
@d270 1
a270 1
	     and FreeLibrar  since Microsoft documentation seems to imply that
@


1.74
log
@* dll_init.cc (dll_list::alloc): Add debugging assertion.
@
text
@d78 1
a78 1
  /* Why didn't we just import this variable? */
d89 1
a89 1
	ret = (*(p.main)) (0, 0, 0);
d336 4
a339 1
    *(p->impure_ptr_ptr) = __cygwin_user_data.impure_ptr;
@


1.73
log
@* globals.cc (exit_status): Add new ES_EXIT_STARTING enum.
* dcrt0.cc (cygwin_exit): Set exit_state to ES_EXIT_STARTING prior to calling
real exit.
* dll_init.cc (dll_list::detach): Remove dll from linked list and call
destructors even if exiting.  Don't call __cxa_finalize in exiting case.
@
text
@d25 1
a121 1
      return d;		/* Return previously allocated pointer. */
d123 4
d128 19
a146 20
  /* FIXME: Change this to new at some point. */
  d = (dll *) cmalloc (HEAP_2_DLL, sizeof (*d) + (namelen * sizeof (*name)));

  /* Now we've allocated a block of information.  Fill it in with the supplied
     info about this DLL. */
  d->count = 1;
  wcscpy (d->name, name);
  d->handle = h;
  d->has_dtors = true;
  d->p = p;
  d->type = type;
  if (end == NULL)
    end = &start;	/* Point to "end" of dll chain. */
  end->next = d;	/* Standard linked list stuff. */
  d->next = NULL;
  d->prev = end;
  end = d;
  tot++;
  if (type == DLL_LOAD)
    loaded_dlls++;
@


1.72
log
@Update some copyrights.
* cygtls.cc (_cygtls::call): Invoke new exception protection here.
(_cygtls::init_thread): Remove conditionalized exception handler setup.
(exception_list): Delete declaration.
(_cygtls::init_exception_handler): Delete obsolete function.
* cygtls.h: Remove (now) unneeded include.
(_cygtls): Make this a real C++ class.
(_cygtls::handle_exceptions): Remove.
(_cygtls::init_exception_handler): Remove.
(_cygtls::call2): Make private.
(myfault::faulted): Remove unneeded parentheses.
* dcrt0.cc (dll_crt0_1): Remove exception handler setup.
* dlfcn.cc (dlopen): Ditto.
(dlclose): Ditto.
* dll_init.cc (dll_dllcrt0_1): Ditto.
(dll_list::detach): Use new exception handler protection.
* exceptions.cc (dump_exception): Rename to prevent confusion with new class.
(exception::handle): Rename from _cygtls::handle_exceptions.  Accommodate new
exception class.  Accommodate rename to dump_exception.
* tlsoffsets.h: Regenerate.
@
text
@d167 1
a167 1
  if (!myself || exit_state || !(d = find (retaddr)))
d175 3
a177 1
      __cxa_finalize (d);
@


1.71
log
@* cygtls.h (_cygtls::init_exception_handler): Eliminate argument.
(_cygtls::andreas): Convert to a pointer.
(san): Convert to a real class with methods.  Use a linked list to keep track
of previous handlers on the "stack".
(myfault): Rewrite to use new san class rather than calling directly into
_cygtls.
* cygtls.cc (_cygtls::init_exception_handler): Just assume that we're always
using the standard exception handler.
(_cygtls::init_thread): Reflect loss of argument to init_exception_handler.
* dcrt0.cc (dll_crt0_1): Ditto.
* dfcn.cc (dlopen): Ditto.
(dlclose): Reset the exception handler after FreeLibrary.
* dll_init.cc (dll_list::detach): Make sure that the exception handler is
initialized before calling destructors.
* exceptions.cc (_cygtls::handle_exceptions): Accommodate new andreas pointer.
* thread.cc (verifyable_object_isvalid): Pass objectptr to faulted for explicit
NULL pointer checking.
* tlsoffsets.h: Regenerate.
@
text
@d4 1
a4 1
   2007, 2008, 2009 Red Hat, Inc.
d22 1
d173 2
a174 2
      /* Make sure our exception handler is enabled for destructors */
      _my_tls.init_exception_handler ();
a327 9
  /* Make sure that our exception handler is installed.
     That should always be the case but this just makes sure.

     At some point, we may want to just remove this code since
     the exception handler should be guaranteed to be installed.
     I'm leaving it in until potentially after the release of
     1.7.1 */
  _my_tls.init_exception_handler ();

@


1.70
log
@* dll_init.cc (per_module::run_dtors): Use consistent method for running
destructors.
@
text
@d172 2
d334 1
a334 1
  _my_tls.init_exception_handler (_cygtls::handle_exceptions);
@


1.69
log
@* dcrt0.cc (atexit_lock): Delete.
(cygwin_exit): Remove atexit lock.
(cygwin_atexit): Ditto.  Rename parameter to match newlib.  Call __cxa_atexit
when invoked by a registered DLL.
* dll_init.cc (remove_dll_atexit): Delete.
(dll_list::find): New function.
(dll_list::detach): Use dll_list::find to find dll associated with return
address.  Use __cxa_finalize to run atexit functions associated with the dll.
(cygwin_detach_dll): Don't assume that HANDLE == void *.
* dll_init.h (dll_list::find): Declare.
(__cxa_atexit): Ditto.
(__cxa_finalize): Ditto.
* init.cc (dll_entry): Clarify comment.
@
text
@d66 2
a67 2
  for (int i = 1; pfunc[i]; i++)
    (pfunc[i]) ();
@


1.68
log
@* dll_init.cc (remove_dll_atexit): New function.
(dll_list::detach): Run any atexit handlers registered in the DLL prior to
unloading.
@
text
@d146 7
a152 2
/* This function looks for every atexit function registered in the
   about-to-be-unloaded DLL and runs it.
d154 5
a158 21
   newlib does not provide any method for selectively running elements
   from the atexit() queue so we have to roll our own.

   Note that this is not foolproof since a function in the DLL could
   register an atexit function outside of the DLL and that should be
   run when the DLL detachs.  */
static void
remove_dll_atexit (MEMORY_BASIC_INFORMATION& m)
{
  unsigned char *dll_beg = (unsigned char *) m.AllocationBase;
  unsigned char *dll_end = (unsigned char *) m.AllocationBase + m.RegionSize;
  struct _atexit *p = _GLOBAL_REENT->_atexit;
  for (int n = p->_ind - 1; n >= 0; n--)
    {
      void (*fn) (void) = p->_fns[n];
      if ((unsigned char *) fn >= dll_beg && (unsigned char *) fn < dll_end)
	{
	  fn ();
	  p->_fns[n] = NULL;
	}
    }
d165 2
a166 1
  if (!myself || exit_state)
d168 15
a182 25
  MEMORY_BASIC_INFORMATION m;
  if (!VirtualQuery (retaddr, &m, sizeof m))
    return;
  HMODULE h = (HMODULE) m.AllocationBase;

  dll *d = &start;
  while ((d = d->next))
    if (d->handle != h)
      continue;
    else if (d->count <= 0)
      system_printf ("WARNING: trying to detach an already detached dll ...");
    else if (--d->count == 0)
      {
	remove_dll_atexit (m);
	d->run_dtors ();
	d->prev->next = d->next;
	if (d->next)
	  d->next->prev = d->prev;
	if (d->type == DLL_LOAD)
	  loaded_dlls--;
	if (end == d)
	  end = d->prev;
	cfree (d);
	break;
      }
d410 1
a410 1
    retaddr = (HANDLE) _my_tls.retaddr ();
@


1.67
log
@* libc/strfmon.c (__setup_vars): Fix compiler warning about assigning const
strings.  Compare a pointer to NULL rather than '\0'.
* dll_init.cc (dll_dllcrt0_1): Minor comment fix.
* pipe.cc (fhandler_pipe::create_selectable): Remove Win9x accommodation.
@
text
@d23 1
d146 26
d191 1
@


1.66
log
@* dll_init.h (has_dtors): New flag.
(run_dtors): New wrapper function which avoids calling dtors more than once.
* dll_init.cc (dll_global_dtors): Use dll.run_dtors wrapper.
(dll_list::detach): Ditto.
(dll_list::alloc): Set has_dtors flag.
@
text
@d387 1
a387 1
/* OBSOLETE: This function is obsolescent and will go away in the
@


1.65
log
@	* cxx.cc (default_cygwin_cxx_malloc): Enhance commenting.
	* dll_init.cc (dll_dllcrt0_1): Likewise.
	* dlfcn.cc (dlopen): Prevent dlopen()'d DLL from installing any
	cxx malloc overrides.
	* include/cygwin/cygwin_dll.h (__dynamically_loaded): New variable.
	* lib/_cygwin_crt0_common.cc (_cygwin_crt0_common): Check it and only
	install cxx malloc overrides when statically loaded.  Extend comments.
@
text
@d38 1
a38 1
      d->p.run_dtors ();
d122 1
d130 1
d164 1
a164 1
	d->p.run_dtors ();
@


1.64
log
@* cygtls.cc (_cygtls::init_exception_handler): Test for e, not e->prev or we
could still end up adding our handler twice.  Add comment explaining what we're
doing.
* dll_init.cc (dll_dllcrt0_1): Clarify comment.
@
text
@d331 20
@


1.63
log
@* cygheap.h (mini_cygheap): New struct.
(init_cygheap): Inherit locale field via mini_cygheap.
* cygheap.cc (cygheap_at_start): Define new variable.
(cygheap): Initialize as cygheap_at_start so that locale information is always
available.
(cygheap_init): Initialize cygheap iff it is set to cygheap_at_start.
* shared_info.h (memory_init): Accommodate argument change.
* memory.cc (memory_init): Accept an argument indicating whether cygheap should
be initialized or not.
* dcrt0.cc (child_info_fork::handle_fork): Pass false to memory_init().
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Pass true to memory_init when not forking or execing.
* cygheap.h (cygheap_types::HEAP_2_DLL): New enum.
* dll_init.h (dll): Remove unused namelen field.
(dll_list::load_after_fork): Accommodate change in arguments.
* dll_init.cc (dll_list::alloc): Allocate dll information in the cygwin heap.
(dll_list::detach): Free dll information from the cygwin heap.
(dll_list::load_after_fork): Use dll information in the cygwin heap directly
rather than querying parent.
* fork.cc (frok::first_dll): Delete.
(frok::child): Don't report on first_dll.  Don't pass it to load_on_fork.
(frok::parent): Don't set first_dll.
(fork): Ditto.
@
text
@d315 7
a321 6
  /* Windows apparently installs a bunch of exception handlers prior to
     this function getting called and one of them may trip before cygwin
     gets to it.  So, install our own exception handler only.
     FIXME: It is possible that we may have to save state of the
     previous exception handler chain and restore it, if problems
     are noted. */
@


1.62
log
@	* dll_init.cc (dll_list::alloc): Allocate memory using a section
	object.  Explain why.  Drop call to GetSystemInfo, rather call
	getpagesize to get allocation granularity.  Only align to allocation
	granularity under WOW64.  Use roundup2 to align.
	(dll_list::detach): Call NtUnmapViewOfSection instead of VirtualFree.
@
text
@a22 4
#include <alloca.h>
#include <unistd.h>
#include <sys/param.h>
#include "ntdll.h"
d26 1
a26 1
dll_list NO_COPY dlls;
d106 1
a106 1
/* Allocate space for a dll struct contiguous with the just-loaded dll. */
d117 2
a118 1
      d->count++;	/* Yes.  Bump the usage count. */
d122 1
a122 81
  void *s = p->bss_end;
  size_t d_size = sizeof (dll) + namelen * sizeof (WCHAR);

  MEMORY_BASIC_INFORMATION m;
  NTSTATUS status = 0;
  HANDLE sect_h;
  OBJECT_ATTRIBUTES oa;
  InitializeObjectAttributes (&oa, NULL, 0, NULL,
			      sec_none.lpSecurityDescriptor);

  /* Search for space after the DLL */
  for (int i = 0; i <= RETRIES; i++, s = (char *) m.BaseAddress + m.RegionSize)
    {
      if (!VirtualQuery (s, &m, sizeof (m)))
	return NULL;	/* Can't do it. */
      if (m.State == MEM_FREE)
	{
	  /* Couldn't find any.  Uh oh.  FIXME: Issue an error? */
	  if (i == RETRIES)
	    return NULL;	/* Oh well.  Couldn't locate free space. */

	  d = (dll *) m.BaseAddress;
	  /* Instead of calling VirtualAlloc, which always allocates memory
	     on a 64K boundary, we allocate the memory using a section
	     object.  The disadvantage of the 64K boundary in this case is
	     the fact that that boundary could be easily the start address
	     of another DLL yet to load into memory.

	     On x86, using a section object allows us to allocate the struct
	     dll into a memory slot in the remainder of the last 64K slot of
	     the DLL.  This memory slot will never be used for anything
	     else.  Given that the struct dll will fit into a single page
	     99.99% of the time anyway, this is a neat way to avoid DLL load
	     address collisions in most cases.

	     Of course, this doesn't help if the DLL needs all of the 64K
	     memory slot but there's only a 1 in 16 chance for that.

	     And, alas, it won't work on 64 bit systems because the
	     AT_ROUND_TO_PAGE flag required to make a page-aligned allocation
	     isn't supported under WOW64.  So, as with VirtualAlloc, ensure
	     that address is rounded up to next 64K allocation boundary if
	     running under WOW64. */
	  if (wincap.is_wow64 ())
	    d = (dll *) roundup2 ((uintptr_t) d, getpagesize ());

	  LARGE_INTEGER so = { QuadPart: d_size };
	  status = NtCreateSection (&sect_h, SECTION_ALL_ACCESS, &oa, &so,
				    PAGE_READWRITE, SEC_COMMIT, NULL);
	  if (NT_SUCCESS (status))
	    {
	      ULONG viewsize = 0;
	      so.QuadPart = 0;
	      status = NtMapViewOfSection (sect_h, GetCurrentProcess (),
					   (void **) &d, 0, d_size, &so,
					   &viewsize, ViewUnmap,
					   wincap.is_wow64 ()
					   ? 0 : AT_ROUND_TO_PAGE,
					   PAGE_READWRITE);
#ifdef DEBUGGING
	      if (!NT_SUCCESS (status))
		system_printf ("NtMapViewOfSection failed, %p", status);
#endif
	      NtClose (sect_h);
	    }
#ifdef DEBUGGING
	  else
	    system_printf ("NtCreateSection failed, %p", status);
#endif

	  if (NT_SUCCESS (status))
	    break;
	}
    }

  /* Did we succeed? */
  if (!NT_SUCCESS (status))
    {			/* Nope. */
      __seterrno_from_nt_status (status);
      return NULL;
    }
a126 1
  d->namelen = namelen;
d170 1
a170 1
	NtUnmapViewOfSection (GetCurrentProcess (), d);
d240 2
a241 2
   DLLs and attempts to load them in the same place as they were loaded in
   the parent. */
d243 1
a243 1
dll_list::load_after_fork (HANDLE parent, dll *first)
d245 3
a247 24
  int try2 = 0;
  dll *d = (dll *) alloca (sizeof (dll) + (NT_MAX_PATH - 1) * sizeof (WCHAR));

  void *next = first;
  while (next)
    {
      DWORD nb;
      /* Read 4K of the dll structure from the parent.  A full page has
         been allocated anyway and this covers most, if not all DLL paths.
	 Only if d->namelen indicates that more than 4K are required,
	 read them in a second step. */
      if (!ReadProcessMemory (parent, next, d, getsystempagesize (), &nb)
	  || nb != getsystempagesize ())
	return;
      size_t namelen = d->namelen * sizeof (WCHAR);
      if (namelen >= getsystempagesize () - sizeof (dll)
	  && (!ReadProcessMemory (parent, next, d->name, namelen, &nb)
	      || nb != namelen))
	return;

      /* We're only interested in dynamically loaded dlls.
	 Hopefully, this function wouldn't even have been called unless
	 the parent had some of those. */
      if (d->type == DLL_LOAD)
d249 8
a256 3
	  bool unload = true;
	  HMODULE h = LoadLibraryExW (d->name, NULL,
				      DONT_RESOLVE_DLL_REFERENCES);
d259 1
a259 19
	    system_printf ("can't reload %W", d->name);
	  /* See if DLL will load in proper place.  If so, free it and reload
	     it the right way.
	     It sort of stinks that we can't invert the order of the
	     FreeLibrary and LoadLibrary since Microsoft documentation seems
	     to imply that that should do what we want.  However, since the
	     library was loaded above, the second LoadLibrary does not execute
	     it's startup code unless it is first unloaded. */
	  else if (h == d->handle)
	    {
	      if (unload)
		{
		  FreeLibrary (h);
		  LoadLibraryW (d->name);
		}
	    }
	  else if (try2)
	    api_fatal ("unable to remap %W to same address as parent(%p) != %p",
		       d->name, d->handle, h);
a261 4
	      /* It loaded in the wrong place.  Dunno why this happens but it
		 always seems to happen when there are multiple DLLs attempting
		 to load into the same address space.  In the "forked" process,
		 the second DLL always loads into a different location. */
d263 2
a264 11
	      /* Block all of the memory up to the new load address. */
	      reserve_upto (d->name, (DWORD) d->handle);
	      try2 = 1;		/* And try */
	      continue;		/*  again. */
	    }
	  /* If we reached here, and try2 is set, then there is a lot of
	     memory to release. */
	  if (try2)
	    {
	      release_upto (d->name, (DWORD) d->handle);
	      try2 = 0;
d266 18
a284 2
      next = d->next;	/* Get the address of the next DLL. */
    }
@


1.61
log
@	* dll_init.h (struct dll): Set size of name element to ANYSIZE_ARRAY.
	* dll_init.cc: Fix formatting.
	(dll_list::alloc): Only allocate as much memory for struct dll as
	necessary for given DLL name.
	(dll_list::load_after_fork): Only read a single page of parent memory.
	Only read more if namelen indicates that it's necessary.
@
text
@d24 3
a115 1
  size_t d_size = sizeof (dll) + namelen * sizeof (WCHAR);
d125 2
a126 2
  SYSTEM_INFO s1;
  GetSystemInfo (&s1);
a127 3
  int i;
  void *s = p->bss_end;
  DWORD n;
d129 6
d136 1
a136 1
  for (i = 0; i <= RETRIES; i++, s = (char *) m.BaseAddress + m.RegionSize)
d146 50
a195 13
	  /* Ensure that this is rounded to the nearest page boundary.
	     FIXME: Should this be ensured by VirtualQuery? */
	  n = (DWORD) m.BaseAddress;
	  DWORD r = n % s1.dwAllocationGranularity;

	  if (r)
	    n = ((n - r) + s1.dwAllocationGranularity);

	  /* First reserve the area of memory, then commit it. */
	  if (VirtualAlloc ((void *) n, d_size, MEM_RESERVE, PAGE_READWRITE))
	    d = (dll *) VirtualAlloc ((void *) n, d_size, MEM_COMMIT,
				      PAGE_READWRITE);
	  if (d)
d201 1
a201 1
  if (d == NULL)
d203 1
a203 4
#ifdef DEBUGGING
      system_printf ("VirtualAlloc failed, %E");
#endif
      __seterrno ();
d254 1
a254 1
	VirtualFree (d, 0, MEM_RELEASE);
@


1.60
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d3 2
a4 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006  Red Hat, Inc.
d23 1
d113 1
d150 2
a151 2
	  if (VirtualAlloc ((void *) n, sizeof (dll), MEM_RESERVE, PAGE_READWRITE))
	    d = (dll *) VirtualAlloc ((void *) n, sizeof (dll), MEM_COMMIT,
d271 6
a276 5
	if (!(mb.State == MEM_RESERVE && mb.AllocationProtect == PAGE_NOACCESS &&
	    (((void *) start < cygheap->user_heap.base
	      || (void *) start > cygheap->user_heap.top) &&
	     ((void *) start < (void *) cygheap
	      || (void *) start > (void *) ((char *) cygheap + CYGHEAPSIZE)))))
d284 3
a286 2
/* Reload DLLs after a fork.  Iterates over the list of dynamically loaded DLLs
   and attempts to load them in the same place as they were loaded in the parent. */
d291 1
a291 1
  dll d;
d297 11
a307 3
      /* Read the dll structure from the parent. */
      if (!ReadProcessMemory (parent, next, &d, sizeof (dll), &nb) ||
	  nb != sizeof (dll))
d313 1
a313 1
      if (d.type == DLL_LOAD)
d316 2
a317 1
	  HMODULE h = LoadLibraryExW (d.name, NULL, DONT_RESOLVE_DLL_REFERENCES);
d320 1
a320 1
	    system_printf ("can't reload %W", d.name);
d323 6
a328 6
	     It sort of stinks that we can't invert the order of the FreeLibrary
	     and LoadLibrary since Microsoft documentation seems to imply that that
	     should do what we want.  However, since the library was loaded above,
	     the second LoadLibrary does not execute it's startup code unless it
	     is first unloaded. */
	  else if (h == d.handle)
d333 1
a333 1
		  LoadLibraryW (d.name);
d338 1
a338 1
		       d.name, d.handle, h);
d341 4
a344 4
	      /* It loaded in the wrong place.  Dunno why this happens but it always
		 seems to happen when there are multiple DLLs attempting to load into
		 the same address space.  In the "forked" process, the second DLL always
		 loads into a different location. */
d347 1
a347 1
	      reserve_upto (d.name, (DWORD) d.handle);
d351 2
a352 2
	  /* If we reached here, and try2 is set, then there is a lot of memory to
	     release. */
d355 1
a355 1
	      release_upto (d.name, (DWORD) d.handle);
d359 1
a359 1
      next = d.next;	/* Get the address of the next DLL. */
@


1.59
log
@	* dll_init.cc: Throughout convert to use long pathnames.
	* dll_init.h (struct dll): Change name to WCHAR, change operator [] to
	take PWCHAR argument.
@
text
@d272 1
a272 1
	      | (void *) start > (void *) ((char *) cygheap + CYGHEAPSIZE)))))
@


1.58
log
@* dll_init.cc (dll_global_dtors): Add an additional test to avoid walking the
linked list if it is empty.
(dll_list::detach): Don't set dll_global_dtors_recorded if we aren't actually
going to record any dlls.
@
text
@d21 1
d93 1
a93 1
dll_list::operator[] (const char *name)
d97 1
a97 1
    if (strcasematch (name, d->name))
d109 2
a110 2
  char name[NT_MAX_PATH];
  DWORD namelen = GetModuleFileName (h, name, sizeof (name));
d169 1
a169 1
  strcpy (d->name, name);
d233 1
a233 1
reserve_upto (const char *name, DWORD here)
d249 1
a249 1
	  api_fatal ("couldn't allocate memory %p(%d) for '%s' alignment, %E\n",
d258 1
a258 1
release_upto (const char *name, DWORD here)
d275 1
a275 1
	  api_fatal ("couldn't release memory %p(%d) for '%s' alignment, %E\n",
d303 1
a303 1
	  HMODULE h = LoadLibraryEx (d.name, NULL, DONT_RESOLVE_DLL_REFERENCES);
d306 1
a306 1
	    system_printf ("can't reload %s", d.name);
d319 1
a319 1
		  LoadLibrary (d.name);
d323 1
a323 1
	    api_fatal ("unable to remap %s to same address as parent(%p) != %p",
@


1.57
log
@Changes suggested by Dave Korn.
* dcrt0.cc (cygwin_exit): Remove (hopefully) extraneous call to
dll_global_dtors.
* dll_init.cc (dll_global_dtors): Run destructors in reverse dependency/load
order.
* dll_init.h (dll_list): Add dll_global_dtors as a friend.
@
text
@d34 1
a34 1
  if (recorded)
a219 2
  dll_global_dtors_recorded = true;

d222 1
@


1.56
log
@Remove unneeded header files from source files throughout.
@
text
@d35 1
a35 1
    for (dll *d = dlls.istart (DLL_ANY); d; d = dlls.inext ())
@


1.55
log
@	* cygheap.cc (cwcsdup): New function.
	(cwcsdup1): New function.
	* cygheap.h (cygheap_user::get_windows_id): New method returning PWCHAR.
	(cwcsdup): Declare.
	(cwcsdup1): Declare.
	* registry.cc (get_registry_hive_path): Use WCHAR instead of char
	throughout.
	(load_registry_hive): Ditto.
	* registry.h (get_registry_hive_path): Change declaration accordingly.
	(load_registry_hive): Ditto.
	* sec_helper.cc (cygpsid::string): New method returning PWCHAR.
	* security.h (cygpsid::string): Declare.
	* syscalls.cc (seteuid32): Convert local name var to WCHAR.
	* uinfo.cc (cygheap_user::env_userprofile): Convert local name buffers
	to WCHAR.  Call sys_wcstombs_alloc to generate puserprof buffer.

	* winsup.h: Fix comment.
	(NT_MAX_PATH): New definition for maximum internal path length.
	Use throughout where appropriate.
	* include/limits.h (PATH_MAX): Set to 4096 as on Linux.
@
text
@a9 1
#include <stdlib.h>
@


1.54
log
@	* dcrt0.cc: Include string.h.
	(initial_env): Use small_printf's %P specifier.
	* dll_init.cc (dll_list::alloc): Use PATH_MAX instead of CYG_MAX_PATH
	for path name buffer size.
	* dll_init.h (struct dll): Ditto.
	* environ.cc: Include string.h.
	(win_env::add_cache): Use temporary local buffer for path conversion.
	(posify): Ditto.
	* exceptions.cc (try_to_debug): Use CreateProcessW to allow long path
	names.
	* miscfuncs.cc: Drop unused implementations of strcasematch and
	strncasematch.
	(ch_case_eq): Drop.
	(strcasestr): Drop.
	(cygwin_wcscasecmp): New function.
	(cygwin_wcsncasecmp): New function.
	(cygwin_strcasecmp): New function.
	(cygwin_strncasecmp): New function.
	(cygwin_wcslwr): New function.
	(cygwin_wcsupr): New function.
	(cygwin_strlwr): New function.
	(cygwin_strupr): New function.
	* ntdll.h (RtlDowncaseUnicodeString): Declare.
	(RtlUpcaseUnicodeString): Declare.
	(RtlInt64ToHexUnicodeString): Fix typo in comment.
	* string.h: Disable not NLS aware implementations of strcasematch
	and strncasematch.
	(cygwin_strcasecmp): Declare.
	(strcasecmp): Define as cygwin_strcasecmp.
	(cygwin_strncasecmp): Declare.
	(strncasecmp): Define as cygwin_strncasecmp.
	(strcasematch):Define using cygwin_strcasecmp.
	(strncasematch):Define using cygwin_strncasecmp.
	(cygwin_strlwr): Declare.
	(strlwr): Define as cygwin_strlwr.
	(cygwin_strupr): Declare.
	(strupr): Define as cygwin_strupr.
	* wchar.h: New file.
	* wincap.cc (wincapc::init): Use "NT" as fix OS string.
	* winsup.h (strcasematch): Drop declaration.
	(strncasematch): Ditto.
	(strcasestr): Ditto.
@
text
@d109 1
a109 1
  char name[PATH_MAX];
@


1.53
log
@* cygheap.cc (cygheap_fixup_in_child): Don't close parent handle here.  Let the
caller do that.
* dcrt0.cc (child_info_spawn::handle_spawn): Close parent handle here to allow
fixup_after_exec functions to use it.
* cygtls.cc (_cygtls::call2): Avoid calling exit thread if called with
*crt0_1 functions.
* cygtls.h (_cygtls::isinitialized): Check that we actually have a tls before
seeing if it is initialized.
* gendef (_sigfe_maybe): Ditto.
* dcrt0.cc (dll_crt0_1): Remove static, use just one argument.
* dll_init.cc (dllcrt0_info): New structure.
(dll_dllcrt0): Change into a front-end to renamed dll_dllcrt0_1 so that we'll
always be assured of having something like a tls.
(dll_dllcrt0_1): New function, basically renamed from from dll_dllcrt0.
Unconditionally call _my_tls.init_exception_handler now that we are assured of
having a tls.  Change variable name from "linking" to "linked".
* winsup.h (dll_crt0_1): Declare.
(dll_dllcrt0_1): Ditto.
@
text
@d109 1
a109 1
  char name[CYG_MAX_PATH];
@


1.52
log
@* dll_init.cc (dll_dllcrt0): Previous change didn't work very well with fork.
Semi-revert it but change name of variable to something that makes better
sense.
@
text
@d351 8
d362 16
d384 1
a384 2
  if (cygwin_finished_initializing)
    _my_tls.init_exception_handler (_cygtls::handle_exceptions);
d391 1
a391 1
  bool linking = !in_forkee && !cygwin_finished_initializing;
d405 1
a405 1
  if (linking)
d421 4
a424 4
  if (!d || (!linking && !d->init ()))
    return -1;

  return (DWORD) d;
@


1.51
log
@add missing comment
@
text
@d368 2
d382 1
a382 1
  if (cygwin_finished_initializing)
d398 1
a398 1
  if (!d || (cygwin_finished_initializing && !d->init ()))
@


1.50
log
@* dll_init.cc (dll_dllcrt0): Call _my_tls.init_exception_handler if we've
finished initializing (Thanks to Gary Zablackis for noticing this problem).
Just use cygwin_finished_initializing rather than defining a separate variable.
@
text
@d354 6
@


1.49
log
@* dcrt0.cc (main_environ): Initialize to &__cygwin_environment.
(dll_crt0_1): Move resourcelocks, thread interface, pinfo_init, and
uinfo_init...
(dll_crt0_0): ...to here.
(_dll_crt0): Call update_envptrs here after setting main_environ.
* environ.cc (environ_init): Eliminate initted variable.  Don't call
update_envptrs here.
* sigproc.cc (wait_sig): Use my_sendsig when calling CreatePipe to avoid a
dereference.
@
text
@d354 3
a360 1
  bool initializing = in_forkee || cygwin_finished_initializing;
d374 1
a374 1
  if (!initializing)
d390 1
a390 1
  if (!d || (initializing && !d->init ()))
@


1.48
log
@* cygtls.h (CYGTLS_INITIALIZED): Change to a little more unlikely value.
(CYGTLSMAGIC): Delete.
* dcrt0.cc (dll_crt0_0): Call sigproc_init during init startup.
(_dll_crt0): Don't worry about sync_startup.  Just wait for sigthread here.
* dll_init.cc (cygwin_detach_dll): Only pick up tls version of retaddr if we
have a valid tls.
* fork.cc (frok::child): Remove sigproc_init initialization since it happens
much earlier now.
* gendef: Recognize SIGFE_MAYBE.
(fefunc): Generate calls to _sigfe_maybe, if appropriate.
(_sigfe_maybe): New function.
* init.cc (search_for): Always initialize search_for, even on fork.
(calibration_thread): Delete.
(calibration_id): Delete.
(prime_threads): Delete.
(munge_threadfunc): Remove calibration_thread special case.  Avoid calling
thread function if we haven't yet hit the "search_for" thread.
(dll_entry): Remove prime_threads call.  Only call munge_threadfunc when
hwait_sig is active.  Ditto.  for _my_tls.remove ();
* sigproc.cc (hwait_sig): Make global.
(sigproc_init): Don't bother with sync_startup.
(sig_send): Treat flush as a no-op when signals are held.
(wait_sig): Cause signals to be held after fork.
@
text
@a426 1
  extern char ***main_environ;
@


1.47
log
@* cygtls.h (_cygtls::retaddr): New method.
* dll_init.cc (cygwin_detach_dll): Use new tls function to find return address
since this function is now signal guarded.
(update_envptrs): Remove unneeded braces.
* syscalls.cc (statvfs): Coerce full_path to avoid a gcc warning.
@
text
@d407 6
a412 1
  dlls.detach ((HANDLE) _my_tls.retaddr ());
@


1.46
log
@*** cygwin DLL Changes:
* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::dwProcessId): Delete.
(child_info::straced): New variable.
(child_info::handle_fork): New member function.
* dcrt0.cc (in_forkee): New global variable.
(__cygwin_user_data::forkee): Mark as obsolete.
(do_global_ctors): Use in_forkee rather than user_data->forkee.
(get_cygwin_startup_info): Ditto.  Deal with new straced field to allow strace
to deal with children of attached processes.
(initial_env): Accommodate changes to strace::hello.
(child_info_fork::handle_fork): Rename from plain old 'handle_fork'.  Move
alloc_stack() call elsewhere.
(dll_crt0_0): Fill out more of user_data.  Reference handle_fork via fork_info.
Add some debugging output.
(_dll_crt0): Don't wait for sync thread if sync_startup is invalid.  Zero
sync_startup here.  Call alloc_stack() here, if appropriate.
(dll_crt0_1): Use in_forkee rather than user_data->forkee.
(dll_crt0): Ditto.
* malloc_wrapper.cc (malloc_init): Ditto.
* dll_init.cc (in_forkee): Remove local static version of this variable.
(dll_list::load_after_fork): Don't set in_forkee here.
* external.cc (cygwin_internal): Use strace method rather than accessing field
directly.
* fhandler.cc (fhandler_base::read): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Ditto.
* fork.cc (frok::parent): Invoke strace write_childpid to communicate with
potential strace.
(child_copy): Add more detail to debugging output.
* init.cc (calibration_id): New static variable.
(prime_threads): Set sync_startup to invalid handle if we already know about
thread_func_ix.  Use static calibration_id to hold calibration thread id.
* munge_threadfunc (munge_threadfunc): Don't try to debug if we don't find
threadfunc_ix.
(dll_entry): Avoid calling munge_threadfunc and _cygtls::remove on non-cygwin
threads invoked during process startup.
* pinfo.cc (set_myself): Always call strace.hello here regardless of DEBUGGING.
* sigproc.cc (child_info::child_info): Remove spurious handling of dwProcessId.
Set straced as appropriate.
* spawn.cc (spawn_guts): Rename ciresrv to ch.  Invoke strace write_childpid to
communicate with potential strace.
* strace.cc: Include child_info.h.
(strace::hello): Remove inited test.  Use active() method to test if strace has
been activated.  Handle case where we are started before
(mypid): New function.
(strace::vsprntf): Try to deal more intelligently with case where progname may
not be filled out.  Put pid in parentheses if it is a windows pid rather than a
cygwin pid.  myself has been filled out.
(strace::write_childpid): New function for notifying strace about the creation
of children.
(strace::vprntf): Use strace method rather than accessing field directly.
(strace_printf): Ditto.
(strace::wm): Ditto.
* winsup.h (in_forkee): Declare.
* include/sys/strace.h (strace::write_childpid): Declare new function.
(strace::attached): Define new function.
(strace::active): Ditto.
(strace::active_val): Ditto.
(_STRACE_ON): Delete.
(_STRACE_OFF): Ditto.
(define_strace0): Use strace method rather than accessing field directly.
(strace_printf_wrap): Ditto.
(strace_printf_wrap1): Ditto.

*** cygwin utils changes:
* strace.cc (nprocesses): Make static global.
(quiet): New variable.
(strace_active): Ditto.
(add_child): Increment nprocesses here.  Don't add a child if it is already
added (windows bug?).  Report on child if not quiet.
(get_child): Just return NULL if child not found.
(remove_child): Report on child if not quiet.
(attach_process): Don't complain if given a windows process.  Use windows pid
in error.
(handle_output_debug_string): Issue error if trying to manipulate a process
that we don't know about.  Handle _STRACE_CHILD_PID - attach to reported child
when we get this.
(proc_child): Move nprocesses to file scope.  Report on exceptions.
(longopts): Implement "--quiet".
(opts): Implement "-q".
(main): Manipulate quiet flag.
* utils.sgml (strace): Add words describing '-q'.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
d21 1
d407 1
a407 1
  dlls.detach (__builtin_return_address (0));
d424 1
a424 3
    {
	*(d->p.envptr) = __cygwin_environ;
    }
@


1.45
log
@* dcrt0.cc (do_global_dtors): Run DLL dtors.
(__main): Don't rely on atexit to run dtors.
(do_exit): Specifically call do_global_dtors here.
(cygwin_exit): Ditto.
* dll_init.cc (dll_global_dtors): Make global.  Only run dtors once.
(dll_list::init): Just set flag that dtors should be run.  Don't rely on
atexit.
* dll_init.h (dll_global_dtors): Declare.
* exceptions.cc (sigrelse): Define.
* path.h (is_fs_device): New method.
(is_lnk_special): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::link): Use "is_lnk_special" rather
than "is_lnk_symlink".
* syscalls.cc (rename): Ditto.
* hookapi.cc (ld_preload): Use colon as a separator rather than space.
@
text
@a25 1
static int NO_COPY in_forkee;
a284 1
  in_forkee = 1;
d347 1
a347 1
  in_forkee = 0;
@


1.44
log
@	Unify usage of CYG_MAX_PATH throughout.  Change buffers from
	size CYG_MAX_PATH + 1 to CYG_MAX_PATH.  Change length tests
	accordingly.
@
text
@d27 1
a27 1
static int dll_global_dtors_recorded;
d30 1
a30 1
static void
d33 5
a37 2
  for (dll *d = dlls.istart (DLL_ANY); d; d = dlls.inext ())
    d->p.run_dtors ();
d221 1
a221 6
  /* Make sure that destructors are called on exit. */
  if (!dll_global_dtors_recorded)
    {
      atexit (dll_global_dtors);
      dll_global_dtors_recorded = 1;
    }
@


1.43
log
@* Makefile.in (clean): Remove sigfe.s.
(sigfe.s): Ensure that sigfe.s will be regenerated if it does not exist.
* dll_init.cc (dll_dllcrt0): Simplify initializing tests.
* exceptions.cc (setup_handler): Detect when stub caller is either spinning or
has acquired the lock after being suspended to avoid windows problems with
suspending a win32 API call.
* cygtls.h (_cygtls::spinning): Declare new element.
* gendef: Remove unused _siglist_index and _siglist declaration.
(_sigfe): Set spinning element when potentially looping, waiting for lock.
(_sigbe): Ditto.
(_cygtls::lock): Ditto.
(_longjmp): Ditto.
* tlsoffsets.h: Regenerate.
* pinfo.cc (_pinfo::exit): Set final exit state here.  Call sigproc_terminate
if invoked with 'norecord'.  Clear any residual _cygtls stuff.
* winsup.h (exit_states): Define ES_FINAL.
* spawn.cc (spawn_guts): Don't call proc_terminate specifically when execing.
Let _pinfo::exit handle that case.
* sigproc.cc (wait_subproc): Always exit loop early when proc_loop_wait.
* init.cc (munge_threadfunc): Eliminate unused argument.
(dll_entry): Reflect above change in call to munge_threadfunc.
@
text
@d106 1
a106 1
  char name[CYG_MAX_PATH + 1];
@


1.42
log
@Rename _threadinfo to _cygtls, throughout.
* cygtls.h (_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::push): Make second argument mandatory.
(_cygtls::fixup_after_fork): Declare new function.
(_cygtls::lock): Ditto.
* cygtls.cc (_cygtls::fixup_after_fork): Define new function.
* dcrt0.cc (cygwin_finished_initializing): Define as bool.
(alloc_stack): Use _tlstop rather than arbitrary variable in probably vain
attempt to avoid strange fork problem on CTRL-C.
(dll_crt0_0): Remove obsolete winpids::init call.
* dll_init.cc (dll_dllcrt0): Detect forkee condition as equivalent to
initializing.
* winsup.h (cygwin_finished_initializing): Declare as bool.
* exceptions.cc (handle_exceptions): Rely on cygwin_finished_initializing to
determine how to handle exception during process startup.
(_cygtls::call_signal_handler): Rename from call_signal_handler_now.
(_cygtls::interrupt_now): Fill in second argument to push.
(signal_fixup_after_fork): Eliminate.
(setup_handler): Initialize locked to avoid potential inappropriate unlock.
Resume thread if it has acquired the stack lock.
(ctrl_c_handler): Just exit if ctrl-c is hit before cygiwn has finished
initializing.
* fork.cc (sync_with_child): Don't call abort since it can cause exit
deadlocks.
(sync_with_child): Change debugging output slightly.
(fork_child): Set cygwin_finished_initializing here.  Call _cygtls fork fixup
and explicitly call sigproc_init.
(fork_parent): Release malloc lock on fork failure.
(vfork): Call signal handler via _my_tls.
* sigproc.cc (sig_send): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* signal.cc (nanosleep): Ditto.
(abort): Ditto.
(kill_pgrp): Avoid killing self if exiting.
* sync.cc (muto::acquire): Remove (temporarily?) ill-advised exiting_thread
check.
* gendef (_sigfe): Be more agressive in protecting stack pointer from other
access by signal thread.
(_cygtls::locked): Define new function.
(_sigbe): Ditto.
(_cygtls::pop): Protect edx.
(_cygtls::lock): Use guaranteed method to set eax to 1.
(longjmp): Aggressively protect signal stack.
* miscfuncs.cc (low_priority_sleep): Reduce "sleep time" for secs == 0.
* pinfo.cc (winpids::set): Counterintuitively use malloc's lock to protect
simultaneous access to the pids list since there are pathological conditions
which can cause malloc to call winpid.
(winpids::init): Eliminate.
* pinfo.h (winpids::cs): Eliminate declaration.
* pinfo.h (winpids::init): Eliminate definition.
@
text
@d26 1
a26 1
static NO_COPY int in_forkee = 0;
d186 1
a186 1
  if (!myself || myself->process_state == PID_EXITED)
d361 1
d375 1
a375 1
  if (!in_forkee && !cygwin_finished_initializing)
d391 1
a391 1
  if (!d || ((in_forkee || cygwin_finished_initializing) && !d->init ()))
@


1.41
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d374 1
a374 1
  if (!cygwin_finished_initializing)
d390 1
a390 1
  if (!d || (cygwin_finished_initializing && !d->init ()))
@


1.40
log
@* cygtls.h (_threadinfo::call): Remove regparm declaration to work around
compiler bug.
* autoload.cc (TryEnterCriticalSection): Remove.
* dcrt0.cc (dll_crt0_0): Delete inappropriate setting of _my_tls.stackptr to
NULL since it has really bad consequences.  Make 'si' an automatic variable.
* cygtls.cc (_threadinfo::init_thread): Correct thinko which caused thread list
to be allocated every time.
* cygtls.h (CYGTLS_PADSIZE): Define as const int.
* sync.h: Make multiple inclusion safe.
(muto::next): Eliminate.
(muto::exiting_thread): New variable.
(muto::set_exiting_thread): New function.
(new_muto): Change to use different section for mutos since c++ give
inexplicable warning in some cases otherwise.
(new_muto1): Ditto.
* dcrt0.cc (do_exit): Call muto::set_exiting_thread here.
* sync.cc (muto_start): Eliminate.
(muto::acquire): Always give exiting thread a lock.  Never give thread a lock
if exiting.
(muto::release): Ditto for releasing.
* dtable.cc (dtable::init_lock): Unline function and define here.
* dtable.h (lock_cs): Define as a muto since critical sections seem to work
oddly on Windows Me.
(lock): Accommodate switch to muto.
(unlock): Ditto.
* exceptions.cc (setup_handler): Don't worry about acquiring mutos since that
hasn't mattered for a long time.
(signal_exit): Ditto: muto stuff will be handled automatically on exit now.
* Makefile.in (DLL_IMPORTS): Link advapi32 to ensure proper DLL initialization.
* autoload.cc (RegCloseKey): Arbitrarily choose this function as a "seed" to
pull the advapi32 link library in.  So, comment out the autoloading.
* cygtls.cc (_threadinfo::init_thread): Just clear CYGTLS_PADSIZE.
(_threadinfo::remove): Add debugging.
(_threadinfo::find_tls): Ditto.
* cygtls.h (_threadinfo::padding): Make zero length (for now?).
* dcrt0.cc (dll_crt0_0): Move more initialization here from dll_crt0_1.
(dll_crt0_1): See above.
* dtable.h (dtable::lock): Remove commented out critical section locking.
* dtable.h (dtable::init_lock): Remove commented out critical section locking.
* dtable.h (dtable::unlock): Remove commented out critical section locking.
* exceptions.cc (interruptible): bool'ize.
* init.cc (threadfunc_fe): Revert to storing threadfunc at stack bottom.
(munge_threadfunc): Ditto.  Avoid adding overhead to calibration_thread.
(prime_threads): Don't initialize tls stuff.
(dll_entry): Make minor change to initialization order.
* tlsoffsets.h: Regenerate.
* sigproc.cc (wait_sig): Add sanity check for end of process thread exit.
* select.h: Make minor formatting change.
* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.39
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d198 1
a198 1
      system_printf ("WARNING: try to detach an already detached dll ...");
@


1.39.2.1
log
@* Makefile.in: Add still more -fomit-frame-pointer functions.
* dtable.h (dtable::lock): New function.
(dtable::unlock): New function.
(dtable::init_lock): New function.
* cygheap.h (HEAP_TLS): Declare new enum value.
(init_cygheap::threadlist): Declare new array.
(init_cygheap::sthreads): Declare new variable.
(cygheap_fdmanip::~cygheap_fdmanip): Use new dtable lock/unlock functions.
(cygheap_fdnew::cygheap_fdnew): Ditto.
(cygheap_fdget::cygheap_fdget): Ditto.
* dtable.cc (dtable_init): Initialize fdtab critical section.
(dtable::fixup_after_fork): Ditto.
(dtable::fixup_after_exec): Ditto.
(dtable::dup2): Use lock/unlock calls to protect access to fdtab.
(dtable::find_fifo): Ditto.
(dtable::fixup_before_fork): Ditto.
(dtable::fixup_before_exec): Ditto.
(dtable::set_file_pointers_for_exec): Ditto.
(dtable::vfork_child_dup): Ditto.
(dtable::vfork_parent_restore): Ditto.
* syscalls.cc (close_all_files): Ditto.
* sync.h (muto::acquired): Declare new function.
(new_muto1): Declare new macro used to specify name of muto storage.
* sync.cc (muto::acquired): Define new function.
* cygthread.cc (cygthread::stub): Remove signal chain removal call since it is
handled during initialization now.
* cygthread.cc (cygthread::simplestub): Remove signal chain removal call since
it is handled during initialization now.
* cygtls.cc (sentry): New class used for locking.  Use throughout.
(_threadinfo::reset_exception): Don't pop stack.
(_threadinfo::find_tls): Move from exceptions.cc.
(_threadinfo::init_thread): Initialize array of threads rather than linked
list.  Take second argument indicating thread function for this thread.
(_threadinfo::remove): Search thread array rather than linked list.  Use sentry
to lock.  Only unlock if we got the lock.
(_threadinfo::find_tls): Ditto for first two.
(handle_threadlist_exception): Handle exceptions when manipulating the thread
list in case of premature thread termination.
(_threadinfo::init_threadlist_exceptions): Ditto.
* cygtls.h (TLS_STACK_SIZE): Decrease size.
(_threadinfo::padding): Add element to avoid overwriting lower part of stack.
(_threadinfo::remove): Add a "wait" argument to control how long we wait for a
lock before removing.
* exceptions.cc (init_exception_handler): Make global.  Take argument to
control exception handler being set.
(ctrl_c_handler): Wait forever when removing self from signal chain.
(_threadinfo::find_tls): Move to cygtls.cc.
(sig_handle): Reorganize detection for thread-specific signals.
* heap.cc (heap_init): Rework slightly.  Make fatal error more verbose.  Remove
malloc initialization since it can't happen during dll attach.
* init.cc (search_for): Move address to search for on stack here.
(threadfunc_ix): Ditto for stack offset.  Make shared so that stack walk
potentially only has to be done once when cygwin processes are running.
(threadfunc_fe): Use standard tls to store thread function (may change back
later).
(calibration_thread): New function.  Potentially called to find threadfunc_ix.
(munge_threadfunc): Search for "search_for" value on stack.  Output warning
when thread func not found on stack.  Use standard tls to store thread
function.
(prime_threads): New function.  Called to prime thread front end.
(dll_entry): Call dll_crt0_0 here when DLL_PROCESS_ATTACH.  Call prime_threads
here.  Try to remove thread from signal list here.
* sigproc.cc (wait_sig): Initialize threadlist exception stuff here.
* thread.cc (pthread::exit): Pass argument to signal list remove function.
* thread.h: Remove obsolete *ResourceLock defines.
* tlsoffsets.h: Regenerate.
* winsup.h (spf): Define temporary debug macro to be deleted later.
* dcrt0.cc (dll_crt0_0): New function, called during DLL initialization.
Mainly consists of code pulled from dll_crt0_1.
(dll_crt0_1): See above.
(_dll_crt0): Wait for initial calibration thread to complete, if appropriate.
Move some stuff to dll_crt0_0.
(initialize_main_tls): Accommodate argument change to
_thread_info::init_thread.
* fork.cc (fork_child): Ditto.
(sync_with_child): Fix debug message.
* external.cc (cygwin_internal): Remove special considerations for
uninitialized dll since initialization happens during dll attach now.
* dlfcn.cc (dlopen): Remove obsolete *ResourceLock calls.
(dlclose): Ditto.
* cygheap.h (init_cygheap::close_ctty): Declare new function.
* cygheap.cc (init_cygheap::close_ctty): Define new function.
* syscalls.cc (close_all_files): Use close_ctty.
(setsid): Ditto.
* cygthread.cc (cygthread::stub): Remove exception initialization.
* cygthread.cc (cygthread::stub): Remove exception initialization.
(cygthread::simplestub): Ditto.
* thread.cc (pthread::thread_init_wrapper): Ditto.
* cygtls.cc (_last_thread): Make static.
(_threadinfo::call2): Initialize exception handler here.
(_threadinfo::find_tls): Move here.
* exceptions.cc (_threadinfo::find_tls): Move.
* dcrt0.cc (__api_fatal): Add prefix info to message here rather than including
it in every call to function.
* winsup.h (api_fatal): Accommodate above change.
* debug.cc (add_handle): Don't do anything if cygheap not around.
(mark_closed): Ditto.
* dll_init.cc (dll_list::detach): Fix debug output.
* fork.cc (sync_with_child): Ditto.
(vfork): Improve debug output.
* heap.cc (heap_init): Ditto.
* exceptions.cc (try_to_debug): Clarify message when debugger attaches.
@
text
@d198 1
a198 1
      system_printf ("WARNING: trying to detach an already detached dll ...");
@


1.38
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d106 1
a106 1
  char name[MAX_PATH + 1];
@


1.37
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d16 1
a17 1
#include "path.h"
@


1.36
log
@* dll_init.cc (dll_list::load_after_fork): Don't revert to LoadLibrary if
LoadLibraryEx fails.
* dtable.cc (dtable::dec_console_fds): Eliminate.
(dtable::release): Don't treat console specially.
(dtable::build_fhandler): Ditto.
* dtable.h (console_fds): Eliminate.
(dtable::dec_console_fds): Eliminate.
(dtable::inc_console_fds): Eliminate.
* fhandler.h (fhandler_console::open_fhs): New static element.
* fhandler_console.cc (fhandler_console::open): Increment open_fs.
(fhandler_console::close): Call FreeConsole if no more open consoles and ctty
is not associated with the console.
* syscalls.cc (setsid): Simplify check for when to call FreeConsole.
(check_pty_fds): Eliminate definition.
* winsup.h (check_pty_fds): Eliminate declaration.
@
text
@a10 1
#include <errno.h>
@


1.35
log
@* dll_init.cc (dll_list::load_after_fork): Fix typo where result of LoadLibrary
was ignored.
@
text
@a310 5
	    {
	      unload = false;
	      h = LoadLibrary (d.name);
	    }
	  if (!h)
@


1.34
log
@* cygwin.din: Wrap atexit and exit with cygwin, thread-safe functions.
* dcrt0.cc (cygwin_atexit): New function.
(cygwin_exit): Ditto.
@
text
@d313 1
a313 1
	      LoadLibrary (d.name);
@


1.33
log
@* dll_init.cc (dll_list::detach): Eliminate reliance on passed in dll address.
Infer from module of caller instead.
(cygwin_detach_dll): Ignore dll_index argument.
* dll_init.h (dll_list::detach): Reflect argument change above.
@
text
@d307 1
d310 7
d324 1
a324 1
	  if (h == d.handle)
d326 5
a330 2
	      FreeLibrary (h);
	      LoadLibrary (d.name);
@


1.33.8.1
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d17 1
a18 1
#include "fhandler.h"
@


1.33.8.2
log
@merge from trunk
@
text
@a306 1
	  bool unload = true;
a308 7
	  if (!h)
	    {
	      unload = false;
	      LoadLibrary (d.name);
	    }
	  if (!h)
	    system_printf ("can't reload %s", d.name);
d316 1
a316 1
	  else if (h == d.handle)
d318 2
a319 5
	      if (unload)
		{
		  FreeLibrary (h);
		  LoadLibrary (d.name);
		}
@


1.33.8.3
log
@merge from trunk
@
text
@d311 5
@


1.33.8.4
log
@merge from trunk
@
text
@d11 1
@


1.32
log
@space
@
text
@d185 1
a185 1
dll_list::detach (dll *d)
d189 4
d194 19
a212 14
  if (d->count <= 0)
    system_printf ("WARNING: try to detach an already detached dll ...");
  else if (--d->count == 0)
    {
      d->p.run_dtors ();
      d->prev->next = d->next;
      if (d->next)
	d->next->prev = d->prev;
      if (d->type == DLL_LOAD)
	loaded_dlls--;
      if (end == d)
	end = d->prev;
      VirtualFree (d, 0, MEM_RELEASE);
    }
d402 1
a402 1
cygwin_detach_dll (dll *d)
d404 1
a404 1
  dlls.detach (d);
@


1.31
log
@* cygheap.cc (cygheap_fixup_in_child): Use user_heap element in cygheap.
(init_cheap): Ditto for declaration.
* fork.cc (fork_parent): Use user_heap element in cygheap.
* heap.h (inheap): Ditto.
* heap.cc (sbrk): Ditto.
(heap_init): Ditto.  Reorganize to shrink heap chunk as required and record new
value in cygheap.
* dcrt0.cc (dll_crt0_1): More "move the cygthread init" games.
* shared.cc (open_shared): Rework memory protection to properly deal with
relocated shared segment.
(shared_info::heap_chunk_size): Rename element to 'heap_chunk'.
* shared_info.h (shared_info): Ditto for declaration.
* strace.cc (strace::hello): Report on heap chunk size from cygheap since it
may shrink.
@
text
@d266 1
a266 1
	     ((void *) start < (void *) cygheap 
@


1.30
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info_fork::heaptop): Remove obsolete element.
(child_info_fork::heabbase): Ditto.
(child_info_fork::heapptr): Ditto.
(child_info_fork::mount_table): New element.
(child_info_fork::myself_addr): Ditto.
* dcrt0.cc (dll_crt0_1): Set mount_table and myself_addr when forking.
(initial_env): Add newline to "sleeping" message.
* dll_init.cc (reserve_upto): Accommodate cygwin heap when freeing memory.
Make debugging output a little more descriptive.
* fork.cc (fork_parent): Save mount_table and myself_addr.
* pinfo.cc (myself_addr): New variable.
(set_myself): Pass PID_MYSELF flag to init.
(pinfo::Init): Honor PID_MYSELF.  Save address where myself shared memory
resides in myself_addr, for fork.
* pinfo.h (myself_addr): Declare.
* shared.cc (memory_init): On fork, use previously saved address for location
of mount table.
* include/sys/cygwin.h (PID_MYSELF): New value.
* dtable.cc (dtable::stdio_init): Don't pass access type to
init_std_file_from_handle.  It's always the same.
(dtable::init_std_file_from_handle): Remove access type argument.  Assume
read/write.
* dtable.h (dtable::init_std_file_from_handle): Ditto for declaration.
* exceptions.cc (try_to_debug): Don't try to debug if already being debugged.
* fhandler_console.cc (shared_console_info_save): New variable.
(fhandler_console::get_tty_stuff): Save address of shared console stuff for
fork.
@
text
@d264 4
a267 2
	    (((void *) start < cygheap->heapbase || (void *) start > cygheap->heaptop) &&
	     ((void *) start < (void *) cygheap || (void *) start > (void *) ((char *) cygheap + CYGHEAPSIZE)))))
@


1.29
log
@Remove \n from calls to strace class printfs throughout.
@
text
@d234 1
a234 1
      size = 64 * 1024;
d264 2
a265 1
	    ((void *) start < cygheap->heapbase || (void *) start > cygheap->heaptop)))
d311 2
a312 1
	    api_fatal ("unable to remap %s to same address as parent -- %p", d.name, h);
@


1.28
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d191 1
a191 1
    system_printf ("WARNING: try to detach an already detached dll ...\n");
@


1.27
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d32 1
a32 1
dll_global_dtors()
@


1.26
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001 Red Hat, Inc.
@


1.25
log
@* dll_init.cc (dll_list::init): Eliminate unneeded debugging statement.
@
text
@d21 1
d187 3
@


1.24
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@a205 1
  debug_printf ("here");
@


1.23
log
@revert patch
@
text
@a11 1
#include "exceptions.h"
@


1.22
log
@2002-04-16  Thomas Pfaff  <tpfaff@@gmx.net>

        * dll_init.h (per_process::dtors_run): New member.
        * dll_init.cc (per_module::run_dtors): Run dtors only once.
        (dll::init): Initialize dtors_run flag.
@
text
@a61 5

  if( dtors_run )
     return;
  dtors_run = true;

a73 2

  p.dtors_run = false;
@


1.21
log
@* dll_init.cc (dll_list::alloc): Increase retry count to 1000.
@
text
@d62 5
d79 2
@


1.20
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d101 1
a101 1
#define RETRIES 100
@


1.19
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d11 1
@


1.18
log
@Update copyrights.
@
text
@d18 1
@


1.18.4.1
log
@Merged changes from HEAD
@
text
@a17 1
#include "path.h"
@


1.18.4.2
log
@Merged changes from HEAD
@
text
@a10 1
#include <errno.h>
d100 1
a100 1
#define RETRIES 1000
@


1.18.4.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d12 1
a21 1
#include "pinfo.h"
a186 3
  if (!myself || myself->process_state == PID_EXITED)
    return;

d207 1
@


1.17
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d3 1
a3 1
   Copyright 1998, 1999, 2000 Cygnus Solutions.
@


1.16
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d16 4
d260 1
a260 1
	    ((void *) start < user_data->heapbase || (void *) start > user_data->heaptop)))
@


1.15
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d21 1
a21 1
static NO_COPY int in_forkee;
@


1.14
log
@forced commit
@
text
@d21 2
a22 2
static NO_COPY int in_forkee = 0;
static int dll_global_dtors_recorded = 0;
@


1.13
log
@Whitespace cleanup.

* configure.in: Eliminate subdir stuff.
* configure: Regenerate.
* include/getopt.h (option): Make name field 'const'.
@
text
@@


1.12
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@d273 1
a273 1
  void *next = first; 
d366 1
a366 1
  
@


1.11
log
@* path.cc (readlink): Check if buffer length is positive.  Truncate output to
buffer length.  Don't terminate buffer with '\0'.
@
text
@d12 2
d15 1
a15 1
#include "cygerrno.h"
@


1.10
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d44 1
a44 1
      for (int j = i - 1; j > 0; j-- )
@


1.9
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d13 1
@


1.8
log
@* dll_init.cc (dll_list::alloc): Fix debugging output.
@
text
@d9 1
a10 1
#include "winsup.h"
@


1.7
log
@Throughout, eliminate third argument to path_conv and use new PC_* constants
for second argument.
* path.h: Generalize SYMLINK_* constants to PC_*.
(path_conv): Create a new method.  Fold third argument into second.
* dll_init.cc (dll_list::alloc): Try harder to find space to allocate dll
struct.
(dll_dllcrt0): Don't check sanity if we've already called dll_crt0.
* path.cc (path_conv::check): Don't check for a null or empty path unless
specifically told with a flag setting.
(check_null_empty_path): New function, adapted from macro.
* syscalls.cc (_rename): Use already-determined file attributes rather than
checking again.
* lib/cygwin/cygwin_attach.dll.c (cygwin_attach_dll): Use a static per_process
structure since this is apparently supposed to be zeroed.
* lib/cygwin_crt0.c (cygwin_crt0): Zero per_process structure sent to older
DLLs.
@
text
@d148 1
a148 1
      system_printf ("VirtualAlloc failed for %E");
@


1.6
log
@Update comments.
@
text
@d109 3
d114 1
d117 1
a117 1
  for (i = 0; i <= RETRIES; i++)
d122 20
a141 2
	break;		/* Found some free space */
      s = (char *) m.BaseAddress + m.RegionSize;
a143 19
  /* Couldn't find any.  Uh oh.  FIXME: Issue an error? */
  if (i == RETRIES)
    return NULL;	/* Oh well.  Couldn't locate free space. */

  SYSTEM_INFO s1;
  GetSystemInfo (&s1);

  /* Ensure that this is rounded to the nearest page boundary.
     FIXME: Should this be ensured by VirtualQuery? */
  DWORD n = (DWORD) m.BaseAddress;
  DWORD r = n % s1.dwAllocationGranularity;

  if (r)
    n = ((n - r) + s1.dwAllocationGranularity);

  /* First reserve the area of memory, then commit it. */
  if (VirtualAlloc ((void *) n, sizeof (dll), MEM_RESERVE, PAGE_READWRITE))
    d = (dll *) VirtualAlloc ((void *) n, sizeof (dll), MEM_COMMIT, PAGE_READWRITE);

d148 1
a148 1
      system_printf ("VirtualAlloc failed for %p, %E", n);
d336 1
a336 2

  if (p)
@


1.5
log
@* dll_init.cc (dll_list::alloc): Round correctly.  Use VirtualAlloc since
shared file mapping is unnecessary.
(dll_list::detach): Release memory via VirtualFree since there we no longer use
shared file mapping.
@
text
@a18 4
/* local variables */

//-----------------------------------------------------------------------------

d94 1
a94 1
/* Allocate space for a dll struct after the just-loaded dll. */
d118 1
a118 1
	break;
d124 1
a124 1
    return NULL; /* Oh well */
d129 2
a130 2
  /* Need to do the shared memory thing since W95 can't allocate in
     the shared memory region otherwise. */
d136 2
d141 1
d143 1
a143 1
    {
d191 1
a191 1
/* Initialization called by dll_crt0_1. */
a257 1
#define MAX_DLL_SIZE (sizeof (dll))
d272 2
a273 2
      if (!ReadProcessMemory (parent, next, &d, MAX_DLL_SIZE, &nb) ||
	  nb != MAX_DLL_SIZE)
d275 1
d288 1
a288 1
	     The second LoadLibrary does not execute it's startup code unless it
@


1.4
log
@* hinfo.cc (hinfo::linearize_fd_array): Make max_used_fd an int so that we can
detect when there are no fds to pass.
* dcrt0.cc (host_dependent_constants::init): Revert Sat Mar 18 01:32:04 2000
change.
(dll_crt0_1): Set "cygwin_finished_initializing" flag.
(dll_crt0): Don't perform memcpy if uptr is already set to internal structure.
(_dll_crt0): Remember location of programs envptr.
* dll_init.h (per_module, dll, dll_list): Revamp.
* dll_init.cc: Revamp.  Use new classes.
* fork.cc (fork): Use new revamped dll, dll_list, and per_module stuff.
* environ.cc: Use __cygwin_environ throughout rather than the
user_data->envptr.
* exec.cc: Ditto.
* spawn.cc: Ditto.
* winsup.h: Declare update_envptrs, cygwin_finished_initializing.
* lib/_cygwin_crt0_common.cc (_cygwin_crt0_common): Revert previous change.
* lib/cygwin_attach_dll.cc (cygwin_attach_dll): Always pass in own per_process
structure or we end up overwriting information from the main program.
@
text
@d135 7
a141 2
  HANDLE h1 = CreateFileMapping (INVALID_HANDLE_VALUE, &sec_none_nih,
				 PAGE_READWRITE, 0, sizeof (dll), NULL);
d143 8
a150 4
  DWORD n = (DWORD) m.BaseAddress;
  n = ((n - (n % s1.dwAllocationGranularity)) + s1.dwAllocationGranularity);
  d = (dll *) MapViewOfFileEx (h1, FILE_MAP_WRITE, 0, 0, 0, (void *) n);
  CloseHandle (h1);
d188 1
a188 1
      UnmapViewOfFile (d);
@


1.3
log
@* debug.cc (thread_stub): Use impure_ptr in place of reent_data.
* dll_init.cc (dll_dllcrt0): Replace erroneous use of local symbol with correct
__cygwin_user_data->impure_ptr.
@
text
@d16 1
a16 4
#ifdef _MT_SAFE
extern ResourceLocks _reslock NO_COPY;
extern MTinterface _mtinterf NO_COPY;
#endif /*_MT_SAFE*/
d18 2
a19 1
/* WARNING: debug can't be called before init !!!! */
a21 23
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// the private structure

typedef enum   { NONE, LINK, LOAD } dllType;

struct dll
{
  per_process p;
  HMODULE handle;
  const char *name;
  dllType type;
};

//-----------------------------------------------------------------------------

#define MAX_DLL_BEFORE_INIT	100 // FIXME: enough ???
static dll _list_before_init[MAX_DLL_BEFORE_INIT];

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// local variables
d23 1
a23 16
static DllList _the;
static int _last = 0;
static int _max = MAX_DLL_BEFORE_INIT;
static dll *_list = _list_before_init;
static int _initCalled = 0;
static int _numberOfOpenedDlls = 0;
static int _forkeeMustReloadDlls = 0;
static int _in_forkee = 0;
static const char *_dlopenedLib = 0;
static int _dlopenIndex = -1;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

static int __dll_global_dtors_recorded = 0;
d25 1
d27 1
a27 1
__dll_global_dtors()
d29 2
a30 1
  _the.doGlobalDestructorsOfDlls();
d33 3
a35 2
static void
doGlobalCTORS (per_process *p)
d37 1
a37 1
  void (**pfunc)() = p->ctors;
d52 3
a54 2
static void
doGlobalDTORS (per_process *p)
d56 1
a56 3
  if (!p)
    return;
  void (**pfunc)() = p->dtors;
d61 3
a63 4
#define INC 500

static int
add (HMODULE h, char *name, per_process *p, dllType type)
d65 1
a65 1
  int ret = -1;
d67 2
a68 2
  if (p)
    check_sanity_and_sync (p);
d70 2
a71 39
  if (_last == _max)
    {
      if (!_initCalled) // we try to load more than MAX_DLL_BEFORE_INIT
	{
	  small_printf ("try to load more dll than max allowed=%d\n",
		       MAX_DLL_BEFORE_INIT);
	  ExitProcess (1);
	}

      dll* newArray = new dll[_max+INC];
      if (_list)
	{
	  memcpy (newArray, _list, _max * sizeof (dll));
	  if (_list != _list_before_init)
	    delete []_list;
	}
      _list = newArray;
      _max += INC;
    }

  _list[_last].name = name && type == LOAD ? strdup (name) : NULL;
  _list[_last].handle = h;
  _list[_last].p = *p;
  _list[_last].type = type;

  ret = _last++;
  return ret;
}

static int
initOneDll (per_process *p)
{
  /* FIXME: init environment (useful?) */
  *(p->envptr) = *(user_data->envptr);

  /* FIXME: need other initializations? */

  int ret = 1;
  if (!_in_forkee)
d74 1
a74 1
      doGlobalCTORS (p);
d77 2
a78 2
      if (p->main)
	ret = (*(p->main)) (0, 0, 0);
d84 3
a86 2
DllList&
DllList::the ()
d88 6
a93 1
  return _the;
d96 1
a96 8
void
DllList::currentDlOpenedLib (const char *name)
{
  if (_dlopenedLib != 0)
    small_printf ("WARNING: previous dlopen of %s wasn't correctly performed\n", _dlopenedLib);
  _dlopenedLib = name;
  _dlopenIndex = -1;
}
d98 3
a100 2
int
DllList::recordDll (HMODULE h, per_process *p)
d102 2
a103 1
  int ret = -1;
d105 3
a107 3
  /* debug_printf ("Record a dll p=%p\n", p); see WARNING */
  dllType type = LINK;
  if (_initCalled)
d109 2
a110 3
      type = LOAD;
      _numberOfOpenedDlls++;
      forkeeMustReloadDlls (1);
d113 5
a117 1
  if (_in_forkee)
d119 5
a123 2
      ret = 0;		// Just a flag
      goto out;
d126 6
a131 2
  char buf[MAX_PATH];
  GetModuleFileName (h, buf, MAX_PATH);
d133 4
a136 27
  if (type == LOAD && _dlopenedLib !=0)
    {
    // it is not the current dlopened lib
    // so we insert one empty lib to preserve place for current dlopened lib
    if (!strcasematch (_dlopenedLib, buf))
      {
      if (_dlopenIndex == -1)
	_dlopenIndex = add (0, 0, 0, NONE);
      ret = add (h, buf, p, type);
      }
    else // it is the current dlopened lib
      {
	if (_dlopenIndex != -1)
	  {
	    _list[_dlopenIndex].handle = h;
	    _list[_dlopenIndex].p = *p;
	    _list[_dlopenIndex].type = type;
	    ret = _dlopenIndex;
	    _dlopenIndex = -1;
	  }
	else // it this case the dlopened lib doesn't need other lib
	  ret = add (h, buf, p, type);
	_dlopenedLib = 0;
      }
    }
  else
    ret = add (h, buf, p, type);
d138 4
a141 8
out:
  if (_initCalled) // main module is already initialized
    {
      if (!initOneDll (p))
	ret = -1;
    }
  return ret;
}
d143 18
a160 13
void
DllList::detachDll (int dll_index)
{
  if (dll_index != -1)
    {
      dll *aDll = &(_list[dll_index]);
      doGlobalDTORS (&aDll->p);
      if (aDll->type == LOAD)
	_numberOfOpenedDlls--;
      aDll->type = NONE;
    }
  else
    small_printf ("WARNING: try to detach an already detached dll ...\n");
d163 1
d165 1
a165 1
DllList::initAll ()
d167 3
a169 10
  // init for destructors
  // because initAll isn't called in forked process, this exit function will
  // be recorded only once
  if (!__dll_global_dtors_recorded)
    {
      atexit (__dll_global_dtors);
      __dll_global_dtors_recorded = 1;
    }

  if (!_initCalled)
d171 9
a179 8
      debug_printf ("call to DllList::initAll");
      for (int i = 0; i < _last; i++)
	{
	  per_process *p = &_list[i].p;
	  if (p)
	    initOneDll (p);
	}
      _initCalled = 1;
d183 1
d185 1
a185 1
DllList::doGlobalDestructorsOfDlls ()
d187 3
a189 2
  // global destructors in reverse order
  for (int i = _last - 1; i >= 0; i--)
d191 2
a192 6
      if (_list[i].type != NONE)
	{
	  per_process *p = &_list[i].p;
	  if (p)
	    doGlobalDTORS (p);
	}
a193 13
}

int
DllList::numberOfOpenedDlls ()
{
  return _numberOfOpenedDlls;
}

int
DllList::forkeeMustReloadDlls ()
{
  return _forkeeMustReloadDlls;
}
d195 4
a198 4
void
DllList::forkeeMustReloadDlls (int i)
{
  _forkeeMustReloadDlls = i;
d205 1
a205 1
void
d230 1
a230 1
void
d250 1
d254 1
a254 1
DllList::forkeeLoadDlls ()
d256 1
a256 2
  _initCalled = 1;
  _in_forkee = 1;
d258 1
a258 30
  for (int i = 0; i < _last; i++)
    if (_list[i].type == LOAD)
      {
	const char *name = _list[i].name;
	HMODULE handle = _list[i].handle;
	HMODULE h = LoadLibraryEx (name, NULL, DONT_RESOLVE_DLL_REFERENCES);

	if (h == handle)
	  {
	    FreeLibrary (h);
	    LoadLibrary (name);
	  }
	else if (try2)
	  api_fatal ("unable to remap %s to same address as parent -- %p", name, h);
	else
	  {
	    FreeLibrary (h);
	    reserve_upto (name, (DWORD) handle);
	    try2 = 1;
	    i--;
	    continue;
	  }
	if (try2)
	  {
	    release_upto (name, (DWORD) handle);
	    try2 = 0;
	  }
      }
  _in_forkee = 0;
}
d260 14
a273 3
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// iterators
d275 37
a311 38
DllListIterator::DllListIterator (int type) : _type (type), _index (-1)
{
  operator++ ();
}

DllListIterator::~DllListIterator ()
{
}

DllListIterator::operator per_process* ()
{
  return &_list[index ()].p;
}

void
DllListIterator::operator++ ()
{
  _index++;
  while (_index < _last && (int) (_list[_index].type) != _type)
    _index++;
  if (_index == _last)
    _index = -1;
}

LinkedDllIterator::LinkedDllIterator () : DllListIterator ((int) LINK)
{
}

LinkedDllIterator::~LinkedDllIterator ()
{
}

LoadedDllIterator::LoadedDllIterator () : DllListIterator ((int) LOAD)
{
}

LoadedDllIterator::~LoadedDllIterator ()
{
d325 30
a354 1
  return _the.recordDll (h, p);
d361 1
a361 2
extern "C"
int
d367 2
a368 3
extern "C"
void
cygwin_detach_dll (int dll_index)
d370 1
a370 1
  _the.detachDll (dll_index);
d373 1
a373 2
extern "C"
void
d376 1
a376 1
  _the.forkeeMustReloadDlls (val);
d379 13
a391 2
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
@


1.2
log
@* dcrt0.cc (__cygwin_user_data): Initialize.
(dll_crt0_1): Eliminate user_data initialization.
(dll_crt0): Set up impure_ptr_ptr for older executables.
(cygwin_dll_init): Eliminate user_data initializations.
(__api_fatal): Don't check for user_data initialization.
* dll_init.cc (struct dll): Store entire contents of per_process rather than
just a pointer.
(add): Ditto.
(initOneDll): Don't check for user_data initialization.
(DllList::recordDll): Store contents of per_process argument.
(DllList::detachDll): Pass address of per_process field.
(DllList::initAll): Ditto.
(DllList::doGlobalDestructorsOfDlls): Ditto.
(DllListIterator::operator *): Ditto.
(dll_dllcrt0): Default to __cygwin_user_data if arg is NULL.
* include/sys/cygwin.h: Reorganize per_process to eliminate obsolete fields and
accomodate new way of initializing.
* lib/_cygwin_crt0_common: Initialize _impure_ptr from
__cygwin_user_data.impure_ptr.
@
text
@a140 2
  /* global variable user_data must be initialized */

d440 1
a440 13
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// the extern symbols

extern "C"
{
  /* This is an exported copy of environ which can be used by DLLs
     which use cygwin.dll.  */
  extern struct _reent reent_data;
};

extern "C"
int
a442 1
  struct _reent reent_data;
d446 1
a446 1
    *(p->impure_ptr_ptr) = &reent_data;
@


1.1
log
@Initial revision
@
text
@d32 1
a32 1
  per_process *p;
d131 1
a131 1
  _list[_last].p = p;
a141 8
  if (user_data == NULL)
    {
      small_printf ("WARNING: process not inited while trying to init a DLL!\n");
      return 0;
    }

  /* init impure_ptr */
  *(p->impure_ptr_ptr) = *(user_data->impure_ptr_ptr);
d215 1
a215 1
	    _list[_dlopenIndex].p = p;
d243 1
a243 1
      doGlobalDTORS (aDll->p);
d269 1
a269 1
	  per_process *p = _list[i].p;
d285 1
a285 1
	  per_process *p = _list[i].p;
d413 1
a413 1
  return _list[index ()].p;
d457 6
d464 2
a465 4
  if (dynamically_loaded && (! user_data || user_data->magic_biscuit == 0))
    {
      dll_crt0 (p);
    }
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
