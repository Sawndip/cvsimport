head	1.14;
access;
symbols
	cygwin-1_7_35-release:1.14
	cygwin-1_7_34-release:1.14
	cygwin-1_7_33-release:1.14
	cygwin-1_7_32-release:1.14
	cygwin-1_7_31-release:1.14
	cygwin-1_7_30-release:1.14
	cygwin-1_7_29-release:1.14
	cygwin-1_7_29-release-branchpoint:1.14.0.26
	cygwin-pre-user-db:1.14
	cygwin-1_7_28-release:1.14
	cygwin-1_7_27-release:1.14
	cygwin-1_7_26-release:1.14
	cygwin-1_7_25-release:1.14
	cygwin-1_7_24-release:1.14
	cygwin-1_7_23-release:1.14
	cygwin-1_7_22-release:1.14
	cygwin-1_7_21-release:1.14
	cygwin-1_7_20-release:1.14
	cygwin-1_7_19-release:1.14
	cygwin-64bit-postmerge:1.14
	cygwin-64bit-premerge-branch:1.14.0.24
	cygwin-64bit-premerge:1.14
	cygwin-1_7_18-release:1.14
	post-ptmalloc3:1.14
	pre-ptmalloc3:1.14
	cygwin-1_7_17-release:1.14
	cygwin-64bit-branch:1.14.0.22
	cygwin-1_7_16-release:1.14
	cygwin-1_7_15-release:1.14
	cygwin-1_7_14_2-release:1.14
	cygwin-1_7_14-release:1.14
	cygwin-1_7_12-release:1.14
	cygwin-1_7_11-release:1.14
	cygwin-1_7_10-release:1.14
	signal-rewrite:1.14.0.20
	pre-notty:1.14
	cygwin-1_7_9-release:1.14
	cv-post-1_7_9:1.14.0.18
	cygwin-1_7_8-release:1.14
	cygwin-1_7_7-release:1.14
	cygwin-1_7_5-release:1.14
	cygwin-1_7_4-release:1.14
	cygwin-1_7_3-release:1.14
	cygwin-1_7_2-release:1.14
	fifo_doover3:1.14.0.16
	cygwin-1_7_1-release:1.14
	prefifo:1.14
	cv-branch-2:1.14.0.14
	pre-ripout-set_console_state_for_spawn:1.14
	EOL_registry_mounts:1.14
	preoverlapped:1.14
	drop_9x_support_start:1.14
	cr-0x5f1:1.14.0.12
	cv-branch:1.14.0.10
	pre-ptymaster-archetype:1.14
	cr-0x3b58:1.14.0.8
	cr-0x5ef:1.14.0.6
	after-mmap-privanon-noreserve:1.14
	after-mmap-revamp:1.14
	before-mmap-revamp:1.14
	cgf-more-exit-sync:1.14
	post_wait_sig_exit:1.14
	pre_wait_sig_exit:1.14
	reparent-point:1.14
	noreparent:1.14.0.4
	cr-0x5e6:1.14.0.2
	cr-0x9e:1.11.0.6
	cr-0x9d:1.11.0.4
	cgf-deleteme:1.11.0.2
	pre-sigrewrite:1.7
	corinna-01:1.7
	cr-0x9c:1.7.0.6
	cr-0x9b:1.7.0.4
	cr-0x99:1.7
	Z-emcb-cygwin_daemon:1.7.0.2
	w32api-2_2:1.7
	mingw-runtime-2_4:1.7
	pre-cgf-merge:1.7
	cgf-dev-branch:1.7.0.16
	predaemon:1.6
	cygwin_daemon_merge_HEAD:1.6
	pregp02r1:1.6.0.32
	cygnus_cvs_20020108_pre:1.6
	Z-cygwin_daemon_merge-new_HEAD:1.7
	Z-cygwin_daemon_merge_HEAD:1.7
	cygwin_daemon:1.6.0.2;
locks; strict;
comment	@# @;


1.14
date	2004.03.14.05.35.19;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.09.01.29.39;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.06.21.43.57;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.15.04.44.30;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.29.00.26.40;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.28.22.13.57;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.28.20.55.58;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.03.23.34.01;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.22.01.29.07;	author cgf;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.09.17.18.10.02;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.15.00.47.44;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.14.16.57.32;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.05.20.12.38;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.03.20.36.52;	author cgf;	state Exp;
branches;
next	;

1.6.2.1
date	2002.08.06.07.14.59;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.14
log
@minor cleanup
@
text
@Copyright 2001, 2002, 2003, 2004 Red Hat Inc., Christopher Faylor

[note that the following discussion is still incomplete]

How do signals work?

On process startup, cygwin starts a secondary thread which deals with
signals.  This thread contains a loop which blocks waiting for
information to arrive on a pipe whose handle (sendsig) is currently
stored in _pinfo (this may change).

Communication on the sendsig pipe is via the 'sigpacket' structure.
This structure is filled out by the sig_send function with information
about the signal being sent, such as (as of this writing) the signal
number, the originating pid, the originating thread, and the address of
the mask to use (this may change).

Any cygwin function which calls a win32 api function is wrapped by the
assembly functions "_sigfe" and "_sigbe".  These functions maintain a
cygwin "signal stack" which is used by the signal thread to control
handling of signal interrupts.  Cygwin functions which need to be
wrapped by these functions (the majority) are labelled by the SIGFE
option in the file cygwin.din.

The cygwin.din function is translated into a standard cygwin.def file by
the perl script "gendef".  This function notices exported cygwin
functions which are labelled as SIGFE and generates a front end assembly
file "sigfe.s" which contains the wrapper glue necessary for every
function to call sigfe prior to actually dispatching to the real cygwin
function.  This generated file contains low-level signal related
functions: _sigfe, _sigbe, sigdelayed, sigreturn, longjmp, and setjmp.

The signal stack maintained by sigfe/sigbe and friends is a secondary
shadow stack.  Addresses from this stack are swapped into the "real"
stack as needed to control program flow.  The intent is that executing
cygwin functions will still see the same stack layout as if they had
been called directly and will be able to retrieve arguments from the
stack but will always return to the _sigbe routine so that any signal
handlers will be properly called.

Upon receipt of a "non-special" (see below) signal, the function
sigpacket::process is called.  This function determines what action, if
any, to take on the signal.  Possible actions are: Ignore the signal
(e.g., SIGUSR1), terminate the program (SIGKILL, SIGTERM), stop the
program (SIGSTOP, SIGTSTP, etc.), wake up a sigwait or sigwaitinfo in a
targetted thread, or call a signal handler (possibly in a thread).  If
no thread information has been sent to sigpacket::process, it determines
the correct thread to use based on various heuristics, as per UNIX.  As
per linux, the only time a handler is called in a thread is when there
is some kind of fault like SIGSEGV, SIGILL, etc.  Signals sent via the
UNIX kill() function are normally sent to the main thread.  Ditto
signals sent as the result of pressing tty keys, like CTRL-C.

Signals which stop a process are handled by a special internal handler:
sig_handle_tty_stop.  Some signals (e.g., SIGKILL, SIGSTOP) are
uncatchable, as on UNIX.

If the signal has an associated signal handler, then the setup_handler
function is eventually called.  It is passed the signal, the address of
the handler, a standard UNIX sigaction structure, and a pointer to the
thread's "_cygtls" information.  The meat of signal processing is in
setup_handler.

setup_handler has a "simple" task.  It tries to stop the appropriate
thread and either redirect its execution to the signal handler function,
flag that a signal has been received (sigwait) or both (sigpause).

To accomplish its task, setup_handler first inspects the target thread's
local storage (_cygtls) structure.  This structure contains information
on any not-yet-handled signals that may have been set up by a previous
call to setup_handler but not yet dispatched in the target thread.  If this
structure seems to be "active", then setup_handler returns, notifying it's
parent via a false value.  Otherwise processing continues.

(For pending signals, the theory is that the signal handler thread will
be forced to be rerun by having some strategic cygwin function call
sig_send with a __SIGFLUSH argument.  This causes the signal handler to
rescan the signal array looking for pending signals.)

After determining that it's ok to send a signal, setup_handler will lock
the cygtls stack to ensure that it has complete access.  It will then
inspect the thread's 'incyg' boolean.  If this is true, the thread is
currently executing a cygwin function.  If it is false, the thread is
unlocked and it is assumed that the thread is executing "user" code.
The actions taken by setup_handler differ based on whether the program
is executing a cygwin routine or not.

If the program is executing a cygwin routine, then the
interrupt_on_return function is called which causes the address of the
'sigdelayed' function to be pushed onto the thread's signal stack, and
the signal's mask and handler to be saved in the tls structure.  After
performing these operations, the 'signal_arrived' event is signalled, as
well as any thread-specific wait event.

Since the sigdelayed function was saved on the thread's signal stack,
when the cygwin function returns, it will eventually return to the
sigdelayed "front end".  The sigdelayed function will save a lot of
state on the stack and set the signal mask as appropriate for POSIX.
It uses information from the _cygtls structure which has been filled in
by interrupt_setup, as called by setup_handler.  sigdelayed pushes a
"call" to the function "sigreturn" on the thread's signal stack.  This
will be the return address eventually seen by the signal handler.  After
setting up the return value, modifying the signal mask, and saving other
information on the stack, sigreturn clears the signal number in the
_cygtls structure so that setup_handler can use it and jumps to the
signal handler function.  And, so a UNIX signal handler function is
emulated.

The signal handler function operates as normal for UNIX but, upon
return, it does not go directly back to the return address of the
original cygwin function.  Instead it returns to the previously
mentioned 'sigreturn' assembly language function.

sigreturn resets the process mask to its state prior to calling the
signal handler.  It checks to see if a cygwin routine has set a special
"restore this errno on returning from a signal" value and sets errno to
this, if so.  It pops the signal stack, places the new return address on
the real stack, restores all of the register values that were in effect
when sigdelayed was called, and then returns.

Ok.  That is more or less how cygwin interrupts a process which is
executing a cygwin function.  We are almost ready to talk about how
cygwin interrupts user code but there is one more thing to talk about:
SA_RESTART.

UNIX allows some blocking functions to be interrupted by a signal
handler and then return to blocking.  In cygwin, so far, only
read/readv() and the wait* functions operate in this fashion.  To
accommodate this behavior, a function notices when a signal comes in and
then calls the _cygtls function 'call_signal_handler_now'.
'call_signal_handler_now' emulates the behavior of both sigdelayed and
sigreturn.  It sets the appropriate masks and calls the handler,
returning true to the caller if SA_RESTART is active.  If SA_RESTART is
active, the function will loop.  Otherwise it will typically return -1
and set the errno to EINTR.

Phew.  So, now we turn to the case where cygwin needs to interrupt the
program when it is not executing a cygwin function.  In this scenario,
we rely on the win32 "SuspendThread" function.  Cygwin will suspend the
thread using this function and then inspect the location at which the
thread is executing using the win32 "GetThreadContext" call.  In theory,
the program should not be executing in a win32 api since attempts to
suspend a process executing a win32 call can cause disastrous results,
especially on Win9x.

If the process is executing in an unsafe location then setup_handler
will (quickly!) return false as in the case above.  Otherwise, the
current location of the thread is pushed on the thread's signal stack
and the thread is redirected to the sigdelayed function via the win32
"SetThreadContext" call.  Then the thread is restarted using the win32
"ResumeThread" call and things proceed as per the sigdelayed discussion
above.

This leads us to the sig_send function.  This is the "client side" part
of the signal manipulation process.  sig_send is the low-level function
called by a high level process like kill() or pthread_kill().

** More to come **
@


1.13
log
@.
@
text
@d30 1
a30 1
function.  This generated function contains low-level signal related
d36 4
a39 4
cygwin functions will still see roughly the same stack layout and will
be able to retrieve arguments from the stack but will always return
to the _sigbe routine so that any signal handlers will be properly
called.
d43 10
a52 9
any, to take on the signal.  Possible actions are: Ignore the signal (e.g.,
SIGUSR1), terminate the program (SIGKILL, SIGTERM), stop the program
(SIGSTOP, SIGTSTP, etc.), wake up a sigwait or sigwaitinfo in a
targetted thread, or call a signal handler (possibly in a thread).
If no thread information has been sent to sigpacket::process, it determines
the correct thread to use based on various heuristics, as per UNIX.
Signals sent via the UNIX kill() function are normally sent to the
main thread.  Ditto signals sent as the result of pressing tty keys,
like CTRL-C.
d77 2
a78 2
sig_send with a __SIGFLUSH "argument" to it.  This causes the signal
handler to rescan the signal array looking for pending signals.)
d82 1
a82 1
inspect the thread's 'incyg' element.  If this is true, the thread is
d89 5
a93 5
interrupt_on_return function is called which sets the address of the
'sigdelayed' function is pushed onto the thread's signal stack, and the
signal's mask and handler is saved in the tls structure.  Then the
'signal_arrived' event is signalled, as well as any thread-specific wait
event.
d96 1
a96 1
when the cygwin functio returns, it will eventually return to the
d128 8
a135 7
read/readv() operate in this fashion.  To accommodate this behavior,
readv notices when a signal comes in and then calls the _cygtls function
'call_signal_handler_now'.  'call_signal_handler_now' emulates the
behavior of both sigdelayed and sigreturn.  It sets the appropriate
masks and calls the handler, returning true to the caller if SA_RESTART
is active.  If SA_RESTART is active, readv will loop.  Otherwise
it will return -1 and set the errno to EINTR.
d147 6
a152 5
will return false as in the case above.  Otherwise, the current location
of the thread is pushed on the thread's signal stack and the thread is
redirected to the sigdelayed function via the win32 "SetThreadContext"
call.  Then the thread is restarted using the win32 "ResumeThread" call
and things proceed as per the sigdelayed discussion above.
d157 2
@


1.12
log
@update some documentation
@
text
@d9 1
a9 1
information to show up on a pipe whose handle (sendsig) is currently
@


1.11
log
@add out-of-date notice.
@
text
@d1 3
a3 1
Copyright 2001, 2002, 2003 Red Hat Inc., Christopher Faylor
a4 1
[this information is currently out-of-date]
d7 49
a55 24
On process startup, cygwin starts a secondary thread that deals with signals.
This thread contains a loop which blocks waiting for information to show up
on a pipe whose handle (sendsig) is currently stored in _pinfo (this may change).

Communication on the sendsig pipe is via the 'sigelem' structure.  This
structure is filled out by the sig_send function with information about the
signal being sent, such as (as of this writing) the signal number, the
originating pid, the originating thread, and the address of the mask to
use (this may change).

If the signal is not blocked, then the function "sig_handle" is called
with the signal number as an argument.  This is a fairly straightforward
function.  It first checks to see if the signal is special in any way.

A special signal is something like SIGKILL or SIGSTOP.  The user has no
control over how those signals affect a UNIX process.  If a SIGKILL is
received then sig_handle calls exit_sig to exit the process.  If SIGSTOP
is called then sig_handle calls the regular signal dispatch function
with a special function argument "sig_handle_tty_stop".  The signal
dispatch function is described below.

An uncaught signal like SIGTERM or SIGHUP will cause the process to exit
with the standard UNIX exit values.  Uncaught signals like SIGUSR1 are
ignored, as on UNIX.
d59 3
a61 2
the handler, and a standard UNIX sigaction structure.  The meat of
signal processing is in setup_handler.
d64 41
a104 45
thread and redirect its execution to the signal handler function.
Currently, the "appropriate thread" is only the main thread.  Someday
we'll have to change this to allow cygwin to interrupt other user
threads.

To accomplish its task, setup_handler first inspects the static sigsave
structure.  This structure contains information on any not-yet-handled
signals that may have been set up by a previous call to setup_handler
but not yet dispatched in the main thread.  If the sigsave structure
seems to be "active", then a "pending" flag is set (see below) and the
function returns.  Otherwise processing continues.

After determining that sigsave is available, setup_handler will take one
of two routes, depending on whether the main thread is executing in the
cygwin DLL or is currently in "user" code.  We'll discuss the cygwin DLL
case first.

If sigsave seems to be available, then the frame information for the
main thread is inspected.  This information is set by any cygwin
function that is known to block (such as _read()), usually by calling
'sigframe thisframe (mainthread)' in the cygwin function.  This call
sets up information about the current stack frame of an executing cygwin
process.  Any function which uses 'sigframe thisframe' should be signal
aware.  It should detect when a signal has arrived and return
immediately.  This method is also used throughout the DLL to ensure
accurate frame info for the executing function.  So, you'll see it
sprinkled liberally throughout the DLL, usually at places where
empirical tests have indicated problems finding this address via the
brute force method stack walking method employed in setup_handler.

So, if mainframe is active, that means that we have good information
about the state of the main thread.  Cygwin uses the stack frame info
from this structure to insert a call to the assembly language function
'sigdelayed' in place of the main thread's normal return address.  So,
when a call to (e.g.) _read returns after detecting a signal, it does
not return to its caller.  Rather, it returns to sigdelayed.

The sigdelayed function saves a lot of state on the stack and sets the
signal mask as appropriate for POSIX.  It uses information from the
sigsave structure which has been filled in by interrupt_on_return, as
called by setup_handler.  sigdelayed pushes a "call" to the function
"sigreturn" on the stack.  This will be the return address seen by the
signal handler.  After setting up the return value, modifying the signal
mask, and saving other information on the stack, sigreturn clears the
sigsave structure (so that setup_handler can use it) and jumps to the
d114 36
a149 18
signal handler.  It checks to see if any new signals have come in and
calls the handler for them now, ensuring that the order of signal
arrival is more or less maintained.  It checks to see if a cygwin
routine has set a special "restore this errno on returning from a
signal" value and sets errno to this, if so.  Finally, it restores all
of the register values that were in effect when sigdelayed was called.

Ok, you thought I had forgotten about the 'pending' stuff didn't you?
Well, if you can rewind up to the discussion of sig_handle, we'll return
to the situation where sigsave was currently active.  In this case,
setup_handler will set a "pending" flag, will reincrement the appropriate
element of the above signal array, and will return 0 to indicate that
the interrupt did not occur.  Otherwise setup_handler returns 1.

For pending signals, the theory is that the signal handler thread will
be forced to be rerun by having some strategic cygwin function call
sig_send with a __SIGFLUSH "argument" to it.  This causes the signal
handler to rescan the signal array looking for pending signals.
d153 1
a153 2
called by a high level process like kill().  You would use sig_send
to send a __SIGFLUSH to the signal thread.
@


1.10
log
@* pinfo.h (_pinfo::getthread2signal): Remove obsolete function.
* cygtls.h (_threadinfo): Define tid more precisely.
(_threadinfo::operator HANDLE): Define.
* exceptions.cc (_threadinfo::interupt_now): Use _threadinfo HANDLE operator to
derive thread handle.
(setup_handler): Ditto.
* sigproc.cc: Reorganize includes.
@
text
@d1 1
a1 1
Copyright 2001 Red Hat Inc., Christopher Faylor
d3 1
@


1.9
log
@* pinfo.h (_pinfo::getsig): Remove obsolete function, here and throughout.
* exceptions.cc: Ditto.
* fhandler_termios.cc: Ditto.
* signal.cc: Ditto.
* sigproc.cc: Ditto.
* Makefile.in: Revert previous change which made a cygwin.din newer than a
version.h a warning rather than an error.
@
text
@d9 5
a13 11
If one of these is activated, then the the signal handler inspects an
array of integers looking for a non-zero value.  The array corresponds
to the normal UNIX signals + two extra locations for internal usage.
This array is located in the 'sigtodo' array in the procinfo class.

The signal thread uses the InterlockedDecrement function to atomically
inspect elements of the array.  If one one of the elements of the array
is non-zero, then cygwin checks to see if the user has blocked the
signal by inspecting the process signal mask.  If the signal is blocked,
then the current array element is reincremented and the next element is
checked.
@


1.8
log
@Eliminate use of sigframe and sigthread throughout.
* Makefile.in (DLL_OFILES): Add sigfe.o.  Remove reliance on cygwin.def from
cygwin0.dll dependency since dependence on sigfe.o implies that.  Generate def
file on the fly using 'gendef'.
* configure.in: Don't auto-generate cygwin.def.
* configure: Regenerate.
* cygwin.din: Add SIGFE stuff where appropriate.
* dcrt0.cc (dll_crt0_1): Initialize cygwin tls early in process startup.  Set
_main_tls to address of the main thread's cygwin tls.
* debug.h: Remove now unneeded WFSO and WFMO declarations.
* exceptions.cc (_last_thread): Define.
(set_thread_state_for_signals): New function.
(reset_thread_exception_for_signals): Ditto.
(init_thread_for_signals): Ditto.
(delete_thread_for_signals): Ditto.
(capture_thread_for_signals): Ditto.
(handle_exceptions): Set return address explicitly for exceptions prior to
calling sig_send.
(interrupt_on_return): Eliminate.
(setup_handler): Add preliminary implementation for dealing with
thread-specific signals by querying _main_tls.
(signal_exit): Use cygthread::main_thread_id instead of mainthread.id.
(call_signal_handler_now): For now, just handle the main thread.
* fork.cc (vfork): Save and restore main _my_tls.
* gendef: New file.  Generates def file and sigfe.s file.
* gentls_offsets: New file.  Generates offsets for perl to use in sigfe.s.
* how-signals-work.txt: Mention that info is obsolete.
* init.cc (dll_entry): Initialize cygwin tls storage here.
* miscfuncs.cc (low_priority_sleep): Make a C function for easier calling from
asm.
* perthread.h (vfork_save::tls): New element.
* signal.cc (nanosleep): Replace previous use of
sigframe.call_signal_handler_now with straight call to call_signal_handler_now.
(abort): Ditto.
* syscalls.cc (readv): Ditto.
* termios.cc (tcsetattr): Ditto.
* wait.cc (wait4): Ditto.
* sigproc.cc (sig_dispatch_pending): Ditto.
(sig_send): Ditto.
* sigproc.h: Declare call_signal_handler_now.
* thread.cc (pthread::thread_init_wrapper): Initialize cygwin tls.  Remove
obsolete and unworking signal stuff.
* thread.h (verifyable_object::sigs): Eliminate.
(verifyable_object::sigmask): Eliminate.
(verifyable_object::sigtodo): Eliminate.
(verifyable_object::exit): Make attribute noreturn.
(verifyable_object::thread_init_wrapper): Ditto.
(pthread_null::exit): Ditto.
* winbase.h (__stackbase): Always define.
* winsup.h (low_priority_sleep): Declare as a "C" function.
* include/cygwin/version.h: Bump API version to reflect sigwait export.
* include/sys/queue.h: Protect SLIST_ENTRY from previous declaration.
* signal.cc (sigwait): Implement.
* select.cc (fhandler_base::ready_for_read): Add debugging output.
* devices.h: Define more device pointers via their storage.
* devices.in: Don't parse things like /dev/inet/tcp, as they really have no
meaning.
* devices.cc: Regenerate.
* gendevices: Set proper protection for output file.
* cygtls.h: New file.
* gendef: New file.
* gentls_offsets: New file.
* tlsoffsets.h: New file.  Autogenerated.
* config/i386/longjmp.c: Remove.  File subsumed by gendef output.
* config/i386/makefrag: Remove obsolete file.
* fhandler.cc: Remove spurious access_worker declaration.
* spawn.cc (spawnve): Make debugging output more accurate.
* cygwin-gperf: Remove.
* devices.cc: Remove.
@
text
@a2 1
[this information is currently obsolete -- sorry]
d6 2
a7 16
This thread contains a loop which blocks waiting for one of three events:

1) sigcatch_main - a semaphore which, when incremented, indicates that a
   signal may be available for the main thread.  The caller waits for the
   signal to be delivered before returning.

2) sigcatch_nonmain - a semaphore which , when incremented, indicates that
   a signal is available for a non-main thread (currently this is not truly
   implemented).  The caller waits for the signal to be delivered before
   returning.

3) sigcatch_nosync - a semaphore which, when incremented, indicates that
   a signal may be available for the main thread.  The caller does not wait
   for the delivery of the signal before returning.

So, the signal handler blocks waiting for one of these three semaphores.
@


1.7
log
@update
@
text
@d3 1
@


1.6
log
@typo, words.
@
text
@d80 5
a84 1
immediately.
@


1.6.2.1
log
@Merged changes from HEAD
@
text
@d80 1
a80 5
immediately.  This method is also used throughout the DLL to ensure
accurate frame info for the executing function.  So, you'll see it
sprinkled liberally throughout the DLL, usually at places where
empirical tests have indicated problems finding this address via the
brute force method stack walking method employed in setup_handler.
@


1.5
log
@* syscalls.cc (rmdir): Set cwd to some other location if attempting to rmdir
current working directory.
@
text
@d114 1
a114 1
Well, if you can rewind up to the discussion of sig_handle we'll return
d122 2
a123 2
sig_send with a __SIGFLUSH argument.  This causes the signal handler
to rescan the signal array looking for pending signals.
d127 2
a128 1
called by a high level process like kill().
@


1.4
log
@* dcrt0.cc (dll_crt0_1): Create vfork main storage here so that it can be
queried in waitsig later.
* sigproc.cc (wait_sig): Don't deliver a signal if in a vfork.
* fork.cc (vfork): Deliver all signals on parent return from vfork.
@
text
@a2 2
[This is not yet complete. -cgf]

d112 16
@


1.3
log
@add copyrights.
@
text
@d70 4
a73 4
After determining that sigsave is available, setup_handler will take
one of two routes, depending on whether the main thread is executing
in the cygwin DLL or is currently in "user" code.  We'll discuss the
cygwin DLL case first.
d84 6
a89 6
So, if mainframe is active, that means that we have good information about
the state of the main thread.  Cygwin uses the stack frame info from this
structure to insert a call to the assembly language function 'sigdelayed'
in place of the main thread's normal return address.  So, when a call to
(e.g.) _read returns after detecting a signal, it does not return to its
caller.  Rather, it returns to sigdelayed.
d94 1
a94 1
called by setup_handler.  sigdelayed pushes a "call" the function
d99 2
a100 1
signal handler function.
d102 4
d107 7
@


1.2
log
@minor wording changes
@
text
@d1 2
@


1.1
log
@*** empty log message ***
@
text
@d30 4
a33 3
is non-zero, then cygwin checks to see if the user has blocked the signal
by inspecting the process signal mask.  If the signal is blocked, then
the array is reincremented and the next element is checked.
d57 3
a59 1
Currently, the "appropriate thread" is only the main thread.
d61 1
a61 1
To accomplish this, setup_handler first inspects the static sigsave
d65 2
a66 1
seems to be "active", then a "pending" flag is set (see below).
d92 6
a97 6
called by setup_handler.  sigdelayed pushes another "sigreturn" address
on the stack.  This will be the return address seen by the signal
handler.  After setting up the return value, modifying the signal mask,
and saving other information on the stack, sigreturn clears the sigsave
structure (so that setup_handler can use it) and jumps to the signal
handler function.
@

