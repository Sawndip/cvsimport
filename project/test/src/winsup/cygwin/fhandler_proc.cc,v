head	1.126;
access;
symbols
	cygwin-1_7_35-release:1.126
	cygwin-1_7_34-release:1.125
	cygwin-1_7_33-release:1.119.2.3
	cygwin-1_7_32-release:1.119.2.2
	cygwin-1_7_31-release:1.119.2.1
	cygwin-1_7_30-release:1.119
	cygwin-1_7_29-release:1.119
	cygwin-1_7_29-release-branchpoint:1.119.0.2
	cygwin-pre-user-db:1.119
	cygwin-1_7_28-release:1.119
	cygwin-1_7_27-release:1.119
	cygwin-1_7_26-release:1.119
	cygwin-1_7_25-release:1.119
	cygwin-1_7_24-release:1.119
	cygwin-1_7_23-release:1.119
	cygwin-1_7_22-release:1.119
	cygwin-1_7_21-release:1.119
	cygwin-1_7_20-release:1.118
	cygwin-1_7_19-release:1.118
	cygwin-64bit-postmerge:1.118
	cygwin-64bit-premerge-branch:1.117.0.2
	cygwin-64bit-premerge:1.117
	cygwin-1_7_18-release:1.117
	post-ptmalloc3:1.115.2.4
	pre-ptmalloc3:1.115.2.4
	cygwin-1_7_17-release:1.115
	cygwin-64bit-branch:1.115.0.2
	cygwin-1_7_16-release:1.115
	cygwin-1_7_15-release:1.115
	cygwin-1_7_14_2-release:1.115
	cygwin-1_7_14-release:1.115
	cygwin-1_7_12-release:1.115
	cygwin-1_7_11-release:1.115
	cygwin-1_7_10-release:1.115
	signal-rewrite:1.111.0.2
	pre-notty:1.106
	cygwin-1_7_9-release:1.95
	cv-post-1_7_9:1.95.0.2
	cygwin-1_7_8-release:1.95
	cygwin-1_7_7-release:1.92
	cygwin-1_7_5-release:1.89
	cygwin-1_7_4-release:1.89
	cygwin-1_7_3-release:1.89
	cygwin-1_7_2-release:1.89
	fifo_doover3:1.87.0.4
	cygwin-1_7_1-release:1.87
	prefifo:1.87
	cv-branch-2:1.87.0.2
	pre-ripout-set_console_state_for_spawn:1.81
	EOL_registry_mounts:1.79
	preoverlapped:1.76
	drop_9x_support_start:1.72
	cr-0x5f1:1.69.0.4
	cv-branch:1.69.0.2
	pre-ptymaster-archetype:1.69
	cr-0x3b58:1.65.0.4
	cr-0x5ef:1.65.0.2
	after-mmap-privanon-noreserve:1.60
	after-mmap-revamp:1.60
	before-mmap-revamp:1.59
	cgf-more-exit-sync:1.59
	post_wait_sig_exit:1.58
	pre_wait_sig_exit:1.58
	reparent-point:1.47
	noreparent:1.47.0.2
	cr-0x5e6:1.41.0.2
	cr-0x9e:1.38.0.6
	cr-0x9d:1.38.0.4
	cgf-deleteme:1.38.0.2
	pre-sigrewrite:1.38
	corinna-01:1.37
	cr-0x9c:1.35.0.6
	cr-0x9b:1.35.0.4
	cr-0x99:1.35
	Z-emcb-cygwin_daemon:1.35.0.2
	w32api-2_2:1.20
	mingw-runtime-2_4:1.20
	pre-cgf-merge:1.35
	cgf-dev-branch:1.20.0.2
	Z-cygwin_daemon_merge_HEAD:1.16
	cygwin_daemon:1.12.0.2
	Z-cygwin_daemon_merge-new_HEAD:1.16;
locks; strict;
comment	@// @;


1.126
date	2015.02.06.11.41.56;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2014.10.24.19.08.55;	author corinna;	state Exp;
branches;
next	1.124;

1.124
date	2014.10.16.15.35.10;	author corinna;	state Exp;
branches;
next	1.123;

1.123
date	2014.10.09.13.24.37;	author corinna;	state Exp;
branches;
next	1.122;

1.122
date	2014.09.05.19.11.01;	author corinna;	state Exp;
branches;
next	1.121;

1.121
date	2014.08.11.12.03.18;	author corinna;	state Exp;
branches;
next	1.120;

1.120
date	2014.05.20.11.00.37;	author corinna;	state Exp;
branches;
next	1.119;

1.119
date	2013.06.14.09.09.41;	author corinna;	state Exp;
branches
	1.119.2.1;
next	1.118;

1.118
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.117;

1.117
date	2013.04.03.19.54.58;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2013.01.21.04.34.51;	author cgf;	state Exp;
branches;
next	1.115;

1.115
date	2011.12.22.11.02.33;	author corinna;	state Exp;
branches
	1.115.2.1;
next	1.114;

1.114
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2011.10.20.14.02.54;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2011.08.19.20.05.15;	author yselkowitz;	state Exp;
branches;
next	1.110;

1.110
date	2011.08.12.12.35.37;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2011.08.12.12.31.08;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2011.08.11.16.43.24;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2011.06.12.20.15.26;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2011.06.06.05.02.10;	author cgf;	state Exp;
branches;
next	1.105;

1.105
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2011.05.12.11.13.02;	author yselkowitz;	state Exp;
branches;
next	1.103;

1.103
date	2011.05.10.15.39.01;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2011.04.19.08.39.38;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2011.04.11.02.09.43;	author yselkowitz;	state Exp;
branches;
next	1.100;

1.100
date	2011.04.04.12.23.35;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2011.04.04.11.12.48;	author yselkowitz;	state Exp;
branches;
next	1.98;

1.98
date	2011.04.02.11.32.55;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2011.04.01.19.48.19;	author yselkowitz;	state Exp;
branches;
next	1.96;

1.96
date	2011.04.01.09.00.21;	author yselkowitz;	state Exp;
branches;
next	1.95;

1.95
date	2011.01.17.14.31.30;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2011.01.17.13.38.06;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.06.09.47.01;	author corinna;	state Exp;
branches;
next	1.92;

1.92
date	2010.08.27.09.08.32;	author corinna;	state Exp;
branches;
next	1.91;

1.91
date	2010.08.26.10.59.13;	author corinna;	state Exp;
branches;
next	1.90;

1.90
date	2010.08.09.08.18.30;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2010.03.12.23.13.47;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2010.01.11.15.10.21;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2009.06.09.09.45.29;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2009.06.08.20.04.37;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2009.02.04.16.40.04;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2009.01.20.17.22.11;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2009.01.17.10.16.42;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2008.07.16.20.20.45;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2007.12.04.13.29.44;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2007.07.26.17.30.54;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2007.07.07.16.46.35;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2007.03.07.14.03.29;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2007.02.22.11.17.01;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2007.02.22.10.54.47;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2007.01.17.19.26.57;	author corinna;	state Exp;
branches;
next	1.71;

1.71
date	2006.10.19.10.01.03;	author corinna;	state Exp;
branches;
next	1.70;

1.70
date	2006.10.19.09.15.26;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2006.05.28.15.50.14;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.09.09.01.07;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.01.22.56.12;	author corinna;	state Exp;
branches;
next	1.66;

1.66
date	2006.01.27.21.50.40;	author corinna;	state Exp;
branches;
next	1.65;

1.65
date	2006.01.12.15.53.51;	author corinna;	state Exp;
branches;
next	1.64;

1.64
date	2006.01.10.16.49.28;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2005.12.12.12.18.14;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2005.12.07.22.28.49;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2005.12.07.20.32.27;	author corinna;	state Exp;
branches;
next	1.60;

1.60
date	2005.11.28.22.32.29;	author corinna;	state Exp;
branches;
next	1.59;

1.59
date	2005.10.02.00.13.41;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2005.08.24.04.38.39;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2005.08.20.06.19.54;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2005.07.06.20.05.00;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2005.06.20.19.58.26;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.19.01.25.20;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.13.16.41.32;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.01.17.16.14;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.01.16.49.12;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2005.02.01.15.11.42;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.29.11.23.06;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.18.16.37.44;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2004.09.12.03.47.56;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2004.09.03.01.53.11;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2004.07.26.13.19.03;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2004.07.19.13.13.48;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.23.16.09.32;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.28.19.50.05;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.18.12.28.47;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.09.04.04.23;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2003.11.14.23.40.05;	author rbcollins;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.23.08.54.00;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.05.03.04.28;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.26.04.53.59;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.10.02.09.24;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.10.01.09.24;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.15.11.56.51;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.19.01.03.16;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.16.03.03.44;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.01.16.11.41;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.18.09.30.03;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.13.22.53.16;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.13.22.32.40;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.09.20.10.25;	author cgf;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2003.03.08.17.56.13;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.08.16.44.24;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2003.01.09.08.22.04;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.30.21.05.17;	author cgf;	state Exp;
branches
	1.18.2.1
	1.18.10.1;
next	1.17;

1.17
date	2002.09.30.15.17.44;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.31.16.37.51;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.02.01.36.15;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.01.19.03.26;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2002.06.02.16.42.02;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.02.03.13.22;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.31.20.30.36;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.30.07.45.30;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.22.22.09.57;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.12.01.37.48;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.04.03.24.35;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.03.02.43.45;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.02.04.26.05;	author cgf;	state Exp;
branches;
next	;

1.119.2.1
date	2014.07.16.09.54.55;	author corinna;	state Exp;
branches;
next	1.119.2.2;

1.119.2.2
date	2014.08.13.17.39.10;	author corinna;	state Exp;
branches;
next	1.119.2.3;

1.119.2.3
date	2014.11.13.12.53.01;	author corinna;	state Exp;
branches;
next	;

1.115.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.115.2.2;

1.115.2.2
date	2012.11.05.17.20.20;	author corinna;	state Exp;
branches;
next	1.115.2.3;

1.115.2.3
date	2012.11.12.17.26.21;	author corinna;	state Exp;
branches;
next	1.115.2.4;

1.115.2.4
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.115.2.5;

1.115.2.5
date	2013.03.01.16.32.33;	author corinna;	state Exp;
branches;
next	1.115.2.6;

1.115.2.6
date	2013.04.03.19.55.44;	author corinna;	state Exp;
branches;
next	;

1.23.2.1
date	2003.03.13.23.04.43;	author cgf;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2003.03.13.23.14.02;	author cgf;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2003.03.18.09.38.33;	author corinna;	state Exp;
branches;
next	;

1.20.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2003.02.14.03.03.28;	author cgf;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2003.03.09.16.22.58;	author cgf;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2003.03.09.20.53.45;	author cgf;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2003.03.19.19.59.54;	author cgf;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2003.05.10.17.20.53;	author cgf;	state Exp;
branches;
next	1.20.2.8;

1.20.2.8
date	2003.05.26.19.39.06;	author cgf;	state Exp;
branches;
next	1.20.2.9;

1.20.2.9
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.20.2.10;

1.20.2.10
date	2003.07.10.01.10.44;	author cgf;	state Exp;
branches;
next	1.20.2.11;

1.20.2.11
date	2003.08.06.03.58.57;	author cgf;	state Exp;
branches;
next	;

1.18.2.1
date	2002.11.07.03.47.46;	author cgf;	state Exp;
branches;
next	;

1.18.10.1
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	1.18.10.2;

1.18.10.2
date	2003.01.09.08.22.51;	author cgf;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.13.14.34.05;	author rbcollins;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.07.02.10.58.18;	author scottc;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2002.09.03.13.52.07;	author scottc;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;


desc
@@


1.126
log
@	* fhandler_proc.cc (format_proc_cpuinfo): Enable multi-core fields
	on Intel CPUs.
@
text
@/* fhandler_proc.cc: fhandler for /proc virtual filesystem

   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
   2013, 2014, 2015 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "miscfuncs.h"
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "shared_info.h"
#include "fhandler.h"
#include "fhandler_virtual.h"
#include "pinfo.h"
#include "dtable.h"
#include "cygheap.h"
#include "tls_pbuf.h"
#include <sys/utsname.h>
#include <sys/param.h>
#include <sys/sysinfo.h>
#include "ntdll.h"
#include <winioctl.h>
#include <wchar.h>
#include <wctype.h>
#include "cpuid.h"
#include "mount.h"

#define _COMPILING_NEWLIB
#include <dirent.h>

static off_t format_proc_loadavg (void *, char *&);
static off_t format_proc_meminfo (void *, char *&);
static off_t format_proc_stat (void *, char *&);
static off_t format_proc_version (void *, char *&);
static off_t format_proc_uptime (void *, char *&);
static off_t format_proc_cpuinfo (void *, char *&);
static off_t format_proc_partitions (void *, char *&);
static off_t format_proc_self (void *, char *&);
static off_t format_proc_cygdrive (void *, char *&);
static off_t format_proc_mounts (void *, char *&);
static off_t format_proc_filesystems (void *, char *&);
static off_t format_proc_swaps (void *, char *&);
static off_t format_proc_devices (void *, char *&);
static off_t format_proc_misc (void *, char *&);

/* names of objects in /proc */
static const virt_tab_t proc_tab[] = {
  { _VN ("."),		 FH_PROC,	virt_directory,	NULL },
  { _VN (".."),		 FH_PROC,	virt_directory,	NULL },
  { _VN ("cpuinfo"),	 FH_PROC,	virt_file,	format_proc_cpuinfo },
  { _VN ("cygdrive"),	 FH_PROC,	virt_symlink,	format_proc_cygdrive },
  { _VN ("devices"),	 FH_PROC,	virt_file,	format_proc_devices },
  { _VN ("filesystems"), FH_PROC,	virt_file,	format_proc_filesystems },
  { _VN ("loadavg"),	 FH_PROC,	virt_file,	format_proc_loadavg },
  { _VN ("meminfo"),	 FH_PROC,	virt_file,	format_proc_meminfo },
  { _VN ("misc"),	 FH_PROC,	virt_file,	format_proc_misc },
  { _VN ("mounts"),	 FH_PROC,	virt_symlink,	format_proc_mounts },
  { _VN ("net"),	 FH_PROCNET,	virt_directory,	NULL },
  { _VN ("partitions"),  FH_PROC,	virt_file,	format_proc_partitions },
  { _VN ("registry"),	 FH_REGISTRY,	virt_directory,	NULL  },
  { _VN ("registry32"),  FH_REGISTRY,	virt_directory,	NULL },
  { _VN ("registry64"),  FH_REGISTRY,	virt_directory,	NULL },
  { _VN ("self"),	 FH_PROC,	virt_symlink,	format_proc_self },
  { _VN ("stat"),	 FH_PROC,	virt_file,	format_proc_stat },
  { _VN ("swaps"),	 FH_PROC,	virt_file,	format_proc_swaps },
  { _VN ("sys"),	 FH_PROCSYS,	virt_directory,	NULL },
  { _VN ("sysvipc"),	 FH_PROCSYSVIPC,	virt_directory,	NULL },
  { _VN ("uptime"),	 FH_PROC,	virt_file,	format_proc_uptime },
  { _VN ("version"),	 FH_PROC,	virt_file,	format_proc_version },
  { NULL, 0,	   	 FH_NADA,	virt_none,	NULL }
};

#define PROC_DIR_COUNT 4

static const int PROC_LINK_COUNT = (sizeof (proc_tab) / sizeof (virt_tab_t)) - 1;

/* name of the /proc filesystem */
const char proc[] = "/proc";
const size_t proc_len = sizeof (proc) - 1;

/* bsearch compare function. */
static int
proc_tab_cmp (const void *key, const void *memb)
{
  int ret = strncmp (((virt_tab_t *) key)->name, ((virt_tab_t *) memb)->name,
		     ((virt_tab_t *) memb)->name_len);
  if (!ret && ((virt_tab_t *) key)->name[((virt_tab_t *) memb)->name_len] != '\0' && ((virt_tab_t *) key)->name[((virt_tab_t *) memb)->name_len] != '/')
    return 1;
  return ret;
}

/* Helper function to perform a binary search of the incoming pathname
   against the alpha-sorted virtual file table. */
virt_tab_t *
virt_tab_search (const char *path, bool prefix, const virt_tab_t *table,
		 size_t nelem)
{
  virt_tab_t key = { path, 0, FH_NADA, virt_none, NULL };
  virt_tab_t *entry = (virt_tab_t *) bsearch (&key, table, nelem,
					      sizeof (virt_tab_t),
					      proc_tab_cmp);
  if (entry && (path[entry->name_len] == '\0'
		|| (prefix && path[entry->name_len] == '/')))
    return entry;
  return NULL;
}

/* Auxillary function that returns the fhandler associated with the given
   path. */
fh_devices
fhandler_proc::get_proc_fhandler (const char *path)
{
  debug_printf ("get_proc_fhandler(%s)", path);
  path += proc_len;
  /* Since this method is called from path_conv::check we can't rely on
     it being normalised and therefore the path may have runs of slashes
     in it.  */
  while (isdirsep (*path))
    path++;

  /* Check if this is the root of the virtual filesystem (i.e. /proc).  */
  if (*path == 0)
    return FH_PROC;

  virt_tab_t *entry = virt_tab_search (path, true, proc_tab,
				       PROC_LINK_COUNT);
  if (entry)
    return entry->fhandler;

  int pid = atoi (path);
  pinfo p (pid);
  /* If p->pid != pid, then pid is actually the Windows PID for an execed
     Cygwin process, and the pinfo entry is the additional entry created
     at exec time.  We don't want to enable the user to access a process
     entry by using the Win32 PID, though. */
  if (p && p->pid == pid)
    return FH_PROCESS;

  bool has_subdir = false;
  while (*path)
    if (isdirsep (*path++))
      {
	has_subdir = true;
	break;
      }

  if (has_subdir)
    /* The user is trying to access a non-existent subdirectory of /proc. */
    return FH_NADA;
  else
    /* Return FH_PROC so that we can return EROFS if the user is trying to
       create a file. */
    return FH_PROC;
}

/* Returns 0 if path doesn't exist, >0 if path is a directory,
   -1 if path is a file, -2 if it's a symlink.  */
virtual_ftype_t
fhandler_proc::exists ()
{
  const char *path = get_name ();
  debug_printf ("exists (%s)", path);
  path += proc_len;
  if (*path == 0)
    return virt_rootdir;
  virt_tab_t *entry = virt_tab_search (path + 1, false, proc_tab,
				       PROC_LINK_COUNT);
  if (entry)
    {
      fileid = entry - proc_tab;
      return entry->type;
    }
  return virt_none;
}

fhandler_proc::fhandler_proc ():
  fhandler_virtual ()
{
}

int __reg2
fhandler_proc::fstat (struct stat *buf)
{
  const char *path = get_name ();
  debug_printf ("fstat (%s)", path);

  path += proc_len;
  fhandler_base::fstat (buf);

  buf->st_mode &= ~_IFMT & NO_W;

  if (!*path)
    {
      winpids pids ((DWORD) 0);
      buf->st_ino = 2;
      buf->st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
      buf->st_nlink = PROC_DIR_COUNT + 2 + pids.npids;
      return 0;
    }
  else
    {
      virt_tab_t *entry = virt_tab_search (path + 1, false, proc_tab,
					   PROC_LINK_COUNT);
      if (entry)
	{
	  if (entry->type == virt_directory)
	    buf->st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
	  else if (entry->type == virt_symlink)
	    buf->st_mode = S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;
	  else
	    {
	      buf->st_mode &= NO_X;
	      buf->st_mode |= S_IFREG;
	    }
	  return 0;
	}
    }
  set_errno (ENOENT);
  return -1;
}

DIR *
fhandler_proc::opendir (int fd)
{
  DIR *dir = fhandler_virtual::opendir (fd);
  if (dir && !(dir->__handle = (void *) new winpids ((DWORD) 0)))
    {
      free (dir);
      dir = NULL;
      set_errno (ENOMEM);
    }
  return dir;
}

int
fhandler_proc::closedir (DIR *dir)
{
  delete (winpids *) dir->__handle;
  return fhandler_virtual::closedir (dir);
}

int
fhandler_proc::readdir (DIR *dir, dirent *de)
{
  int res;
  if (dir->__d_position < PROC_LINK_COUNT)
    {
      strcpy (de->d_name, proc_tab[dir->__d_position].name);
      de->d_type = virt_ftype_to_dtype (proc_tab[dir->__d_position].type);
      dir->__d_position++;
      dir->__flags |= dirent_saw_dot | dirent_saw_dot_dot;
      res = 0;
    }
  else
    {
      winpids &pids = *(winpids *) dir->__handle;
      int found = 0;
      res = ENMFILE;
      for (unsigned i = 0; i < pids.npids; i++)
	if (found++ == dir->__d_position - PROC_LINK_COUNT)
	  {
	    __small_sprintf (de->d_name, "%d", pids[i]->pid);
	    de->d_type = DT_DIR;
	    dir->__d_position++;
	    res = 0;
	    break;
	  }
    }

  syscall_printf ("%d = readdir(%p, %p) (%s)", res, dir, de, de->d_name);
  return res;
}

int
fhandler_proc::open (int flags, mode_t mode)
{
  int proc_file_no = -1;

  int res = fhandler_virtual::open (flags, mode);
  if (!res)
    goto out;

  nohandle (true);

  const char *path;

  path = get_name () + proc_len;

  if (!*path)
    {
      if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
	{
	  set_errno (EEXIST);
	  res = 0;
	  goto out;
	}
      else if (flags & O_WRONLY)
	{
	  set_errno (EISDIR);
	  res = 0;
	  goto out;
	}
      else
	{
	  flags |= O_DIROPEN;
	  goto success;
	}
    }

  proc_file_no = -1;
  for (int i = 0; proc_tab[i].name; i++)
    if (path_prefix_p (proc_tab[i].name, path + 1, strlen (proc_tab[i].name),
		       false))
      {
	proc_file_no = i;
	if (proc_tab[i].fhandler != FH_PROC)
	  {
	    if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
	      {
		set_errno (EEXIST);
		res = 0;
		goto out;
	      }
	    else if (flags & O_WRONLY)
	      {
		set_errno (EISDIR);
		res = 0;
		goto out;
	      }
	    else
	      {
		flags |= O_DIROPEN;
		goto success;
	      }
	  }
      }

  if (proc_file_no == -1)
    {
      if (flags & O_CREAT)
	{
	  set_errno (EROFS);
	  res = 0;
	  goto out;
	}
      else
	{
	  set_errno (ENOENT);
	  res = 0;
	  goto out;
	}
    }
  if (flags & O_WRONLY)
    {
      set_errno (EROFS);
      res = 0;
      goto out;
    }

  fileid = proc_file_no;
  if (!fill_filebuf ())
    {
      res = 0;
      goto out;
    }

  if (flags & O_APPEND)
    position = filesize;
  else
    position = 0;

success:
  res = 1;
  set_flags ((flags & ~O_TEXT) | O_BINARY);
  set_open_status ();
out:
  syscall_printf ("%d = fhandler_proc::open(%y, 0%o)", res, flags, mode);
  return res;
}

bool
fhandler_proc::fill_filebuf ()
{
  if (fileid < PROC_LINK_COUNT && proc_tab[fileid].format_func)
    {
      filesize = proc_tab[fileid].format_func (NULL, filebuf);
      if (filesize > 0)
	return true;
    }
  return false;
}

static off_t
format_proc_version (void *, char *&destbuf)
{
  tmp_pathbuf tp;
  char *buf = tp.c_get ();
  char *bufptr = buf;
  struct utsname uts_name;

  uname (&uts_name);
  bufptr += __small_sprintf (bufptr, "%s version %s (%s@@%s) (%s) %s\n",
			  uts_name.sysname, uts_name.release, USERNAME, HOSTNAME,
			  GCC_VERSION, uts_name.version);

  destbuf = (char *) crealloc_abort (destbuf, bufptr - buf);
  memcpy (destbuf, buf, bufptr - buf);
  return bufptr - buf;
}

static off_t
format_proc_loadavg (void *, char *&destbuf)
{
  extern int get_process_state (DWORD dwProcessId);
  unsigned running = 0;
  winpids pids ((DWORD) 0);

  for (unsigned i = 0; i < pids.npids; i++)
    switch (get_process_state (i)) {
      case 'O':
      case 'R':
	running++;
	break;
    }

  destbuf = (char *) crealloc_abort (destbuf, 48);
  return __small_sprintf (destbuf, "%u.%02u %u.%02u %u.%02u %u/%u\n",
				    0, 0, 0, 0, 0, 0, running, pids.npids);
}

static off_t
format_proc_meminfo (void *, char *&destbuf)
{
  unsigned long long mem_total, mem_free, swap_total, swap_free;
  struct sysinfo info;

  sysinfo (&info);
  mem_total = (unsigned long long) info.totalram * info.mem_unit;
  mem_free = (unsigned long long) info.freeram * info.mem_unit;
  swap_total = (unsigned long long) info.totalswap * info.mem_unit;
  swap_free = (unsigned long long) info.freeswap * info.mem_unit;

  destbuf = (char *) crealloc_abort (destbuf, 512);
  return sprintf (destbuf, "MemTotal:     %10llu kB\n"
			   "MemFree:      %10llu kB\n"
			   "HighTotal:             0 kB\n"
			   "HighFree:              0 kB\n"
			   "LowTotal:     %10llu kB\n"
			   "LowFree:      %10llu kB\n"
			   "SwapTotal:    %10llu kB\n"
			   "SwapFree:     %10llu kB\n",
			   mem_total >> 10, mem_free >> 10,
			   mem_total >> 10, mem_free >> 10,
			   swap_total >> 10, swap_free >> 10);
}

static off_t
format_proc_uptime (void *, char *&destbuf)
{
  unsigned long long uptime = 0ULL, idle_time = 0ULL;
  NTSTATUS status;
  SYSTEM_TIMEOFDAY_INFORMATION stodi;
  /* Sizeof SYSTEM_PERFORMANCE_INFORMATION on 64 bit systems.  It
     appears to contain some trailing additional information from
     what I can tell after examining the content.
     FIXME: It would be nice if this could be verified somehow. */
  const size_t sizeof_spi = sizeof (SYSTEM_PERFORMANCE_INFORMATION) + 16;
  PSYSTEM_PERFORMANCE_INFORMATION spi = (PSYSTEM_PERFORMANCE_INFORMATION)
					alloca (sizeof_spi);

  status = NtQuerySystemInformation (SystemTimeOfDayInformation, &stodi,
				     sizeof stodi, NULL);
  if (NT_SUCCESS (status))
    uptime = (stodi.CurrentTime.QuadPart - stodi.BootTime.QuadPart) / 100000ULL;
  else
    debug_printf ("NtQuerySystemInformation(SystemTimeOfDayInformation), "
		  "status %y", status);

  if (NT_SUCCESS (NtQuerySystemInformation (SystemPerformanceInformation,
						 spi, sizeof_spi, NULL)))
    idle_time = (spi->IdleTime.QuadPart / wincap.cpu_count ())
		/ 100000ULL;

  destbuf = (char *) crealloc_abort (destbuf, 80);
  return __small_sprintf (destbuf, "%U.%02u %U.%02u\n",
			  uptime / 100, long (uptime % 100),
			  idle_time / 100, long (idle_time % 100));
}

static off_t
format_proc_stat (void *, char *&destbuf)
{
  unsigned long pages_in = 0UL, pages_out = 0UL, interrupt_count = 0UL,
		context_switches = 0UL, swap_in = 0UL, swap_out = 0UL;
  time_t boot_time = 0;
  NTSTATUS status;
  /* Sizeof SYSTEM_PERFORMANCE_INFORMATION on 64 bit systems.  It
     appears to contain some trailing additional information from
     what I can tell after examining the content.
     FIXME: It would be nice if this could be verified somehow. */
  const size_t sizeof_spi = sizeof (SYSTEM_PERFORMANCE_INFORMATION) + 16;
  PSYSTEM_PERFORMANCE_INFORMATION spi = (PSYSTEM_PERFORMANCE_INFORMATION)
					alloca (sizeof_spi);
  SYSTEM_TIMEOFDAY_INFORMATION stodi;
  tmp_pathbuf tp;

  char *buf = tp.c_get ();
  char *eobuf = buf;

  SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION spt[wincap.cpu_count ()];
  status = NtQuerySystemInformation (SystemProcessorPerformanceInformation,
				     (PVOID) spt,
				     sizeof spt[0] * wincap.cpu_count (), NULL);
  if (!NT_SUCCESS (status))
    debug_printf ("NtQuerySystemInformation(SystemProcessorPerformanceInformation), "
		  "status %y", status);
  else
    {
      unsigned long long user_time = 0ULL, kernel_time = 0ULL, idle_time = 0ULL;
      for (unsigned long i = 0; i < wincap.cpu_count (); i++)
	{
	  kernel_time += (spt[i].KernelTime.QuadPart - spt[i].IdleTime.QuadPart)
			 * HZ / 10000000ULL;
	  user_time += spt[i].UserTime.QuadPart * HZ / 10000000ULL;
	  idle_time += spt[i].IdleTime.QuadPart * HZ / 10000000ULL;
	}

      eobuf += __small_sprintf (eobuf, "cpu %U %U %U %U\n",
				user_time, 0ULL, kernel_time, idle_time);
      user_time = 0ULL, kernel_time = 0ULL, idle_time = 0ULL;
      for (unsigned long i = 0; i < wincap.cpu_count (); i++)
	{
	  interrupt_count += spt[i].InterruptCount;
	  kernel_time = (spt[i].KernelTime.QuadPart - spt[i].IdleTime.QuadPart) * HZ / 10000000ULL;
	  user_time = spt[i].UserTime.QuadPart * HZ / 10000000ULL;
	  idle_time = spt[i].IdleTime.QuadPart * HZ / 10000000ULL;
	  eobuf += __small_sprintf (eobuf, "cpu%d %U %U %U %U\n", i,
				    user_time, 0ULL, kernel_time, idle_time);
	}

      status = NtQuerySystemInformation (SystemPerformanceInformation,
					 (PVOID) spi, sizeof_spi, NULL);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("NtQuerySystemInformation(SystemPerformanceInformation)"
			", status %y", status);
	  memset (spi, 0, sizeof_spi);
	}
      status = NtQuerySystemInformation (SystemTimeOfDayInformation,
					 (PVOID) &stodi, sizeof stodi, NULL);
      if (!NT_SUCCESS (status))
	debug_printf ("NtQuerySystemInformation(SystemTimeOfDayInformation), "
		      "status %y", status);
    }
  if (!NT_SUCCESS (status))
    {
      __seterrno_from_nt_status (status);
      return 0;
    }

  pages_in = spi->PagesRead;
  pages_out = spi->PagefilePagesWritten + spi->MappedFilePagesWritten;
  /* Note: there is no distinction made in this structure between pages read
     from the page file and pages read from mapped files, but there is such
     a distinction made when it comes to writing.  Goodness knows why.  The
     value of swap_in, then, will obviously be wrong but its our best guess. */
  swap_in = spi->PagesRead;
  swap_out = spi->PagefilePagesWritten;
  context_switches = spi->ContextSwitches;
  boot_time = to_time_t (&stodi.BootTime);

  eobuf += __small_sprintf (eobuf, "page %u %u\n"
				   "swap %u %u\n"
				   "intr %u\n"
				   "ctxt %u\n"
				   "btime %u\n",
				   pages_in, pages_out,
				   swap_in, swap_out,
				   interrupt_count,
				   context_switches,
				   boot_time);
  destbuf = (char *) crealloc_abort (destbuf, eobuf - buf);
  memcpy (destbuf, buf, eobuf - buf);
  return eobuf - buf;
}

#define print(x) { bufptr = stpcpy (bufptr, (x)); }

static off_t
format_proc_cpuinfo (void *, char *&destbuf)
{
  DWORD orig_affinity_mask;
  int cpu_number;
  const int BUFSIZE = 256;
  union
  {
    BYTE b[BUFSIZE];
    char s[BUFSIZE];
    WCHAR w[BUFSIZE / sizeof (WCHAR)];
    DWORD d;
    uint32_t m[13];
  } in_buf;
  tmp_pathbuf tp;

  char *buf = tp.c_get ();
  char *bufptr = buf;

  for (cpu_number = 0; ; cpu_number++)
    {
      WCHAR cpu_key[128];
      __small_swprintf (cpu_key, L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION"
				  "\\System\\CentralProcessor\\%d", cpu_number);
      if (!NT_SUCCESS (RtlCheckRegistryKey (RTL_REGISTRY_ABSOLUTE, cpu_key)))
	break;
      if (cpu_number)
	print ("\n");

      orig_affinity_mask = SetThreadAffinityMask (GetCurrentThread (),
						  1 << cpu_number);
      if (orig_affinity_mask == 0)
	debug_printf ("SetThreadAffinityMask failed %E");
      /* I'm not sure whether the thread changes processor immediately
	 and I'm not sure whether this function will cause the thread
	 to be rescheduled */
      yield ();

      bool has_cpuid = false;

      if (!can_set_flag (0x00040000))
	debug_printf ("386 processor - no cpuid");
      else
	{
	  debug_printf ("486 processor");
	  if (can_set_flag (0x00200000))
	    {
	      debug_printf ("processor supports CPUID instruction");
	      has_cpuid = true;
	    }
	  else
	    debug_printf ("processor does not support CPUID instruction");
	}

      if (!has_cpuid)
	{
	  WCHAR vendor[64], id[64];
	  UNICODE_STRING uvendor, uid;
	  RtlInitEmptyUnicodeString (&uvendor, vendor, sizeof (vendor));
	  RtlInitEmptyUnicodeString (&uid, id, sizeof (id));
	  DWORD cpu_mhz = 0;
	  RTL_QUERY_REGISTRY_TABLE tab[4] = {
	   { NULL, RTL_QUERY_REGISTRY_NOEXPAND | RTL_QUERY_REGISTRY_DIRECT,
	     L"VendorIdentifier", &uvendor, REG_NONE, NULL, 0 },
	   { NULL, RTL_QUERY_REGISTRY_NOEXPAND | RTL_QUERY_REGISTRY_DIRECT,
	     L"Identifier", &uid, REG_NONE, NULL, 0 },
	   { NULL, RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOSTRING,
	     L"~Mhz", &cpu_mhz, REG_NONE, NULL, 0 },
	   { NULL, 0, NULL, NULL, 0, NULL, 0 }
	  };

	  RtlQueryRegistryValues (RTL_REGISTRY_ABSOLUTE, cpu_key, tab,
				  NULL, NULL);
	  bufptr += __small_sprintf (bufptr,
				     "processor       : %d\n"
				     "vendor_id       : %S\n"
				     "identifier      : %S\n"
				     "cpu MHz         : %u\n",
				     cpu_number, &uvendor, &uid, cpu_mhz);
	  print ("flags           :");
	  if (IsProcessorFeaturePresent (PF_3DNOW_INSTRUCTIONS_AVAILABLE))
	    print (" 3dnow");
	  if (IsProcessorFeaturePresent (PF_COMPARE_EXCHANGE_DOUBLE))
	    print (" cx8");
	  if (!IsProcessorFeaturePresent (PF_FLOATING_POINT_EMULATED))
	    print (" fpu");
	  if (IsProcessorFeaturePresent (PF_MMX_INSTRUCTIONS_AVAILABLE))
	    print (" mmx");
	  if (IsProcessorFeaturePresent (PF_PAE_ENABLED))
	    print (" pae");
	  if (IsProcessorFeaturePresent (PF_RDTSC_INSTRUCTION_AVAILABLE))
	    print (" tsc");
	  if (IsProcessorFeaturePresent (PF_XMMI_INSTRUCTIONS_AVAILABLE))
	    print (" sse");
	  if (IsProcessorFeaturePresent (PF_XMMI64_INSTRUCTIONS_AVAILABLE))
	    print (" sse2");
	}
      else
	{
	  DWORD cpu_mhz = 0;
	  RTL_QUERY_REGISTRY_TABLE tab[2] = {
	    { NULL, RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOSTRING,
	      L"~Mhz", &cpu_mhz, REG_NONE, NULL, 0 },
	    { NULL, 0, NULL, NULL, 0, NULL, 0 }
	  };

	  RtlQueryRegistryValues (RTL_REGISTRY_ABSOLUTE, cpu_key, tab,
				  NULL, NULL);
	  bufptr += __small_sprintf (bufptr, "processor\t: %d\n", cpu_number);
	  uint32_t maxf, vendor_id[4], unused;
	  cpuid (&maxf, &vendor_id[0], &vendor_id[2], &vendor_id[1], 0);
	  maxf &= 0xffff;
	  vendor_id[3] = 0;

	  /* Vendor identification. */
	  bool is_amd = false, is_intel = false;
	  if (!strcmp ((char*)vendor_id, "AuthenticAMD"))
	    is_amd = true;
	  else if (!strcmp ((char*)vendor_id, "GenuineIntel"))
	    is_intel = true;

	  bufptr += __small_sprintf (bufptr, "vendor_id\t: %s\n",
				     (char *)vendor_id);
	  if (maxf >= 1)
	    {
	      uint32_t features2, features1, extra_info, cpuid_sig;
	      cpuid (&cpuid_sig, &extra_info, &features2, &features1, 1);
	      /* uint32_t extended_family = (cpuid_sig & 0x0ff00000) >> 20,
			  extended_model  = (cpuid_sig & 0x000f0000) >> 16,
			  type		  = (cpuid_sig & 0x00003000) >> 12; */
	      uint32_t family		= (cpuid_sig & 0x00000f00) >> 8,
		       model		= (cpuid_sig & 0x000000f0) >> 4,
		       stepping		= cpuid_sig & 0x0000000f;
	      /* Not printed on Linux */
	      //uint32_t brand_id		= extra_info & 0x0000000f;
	      //uint32_t cpu_count	= (extra_info & 0x00ff0000) >> 16;
	      uint32_t apic_id		= (extra_info & 0xff000000) >> 24;
	      if (family == 15)
		family += (cpuid_sig >> 20) & 0xff;
	      if (family >= 6)
		model += ((cpuid_sig >> 16) & 0x0f) << 4;
	      uint32_t maxe = 0;
	      cpuid (&maxe, &unused, &unused, &unused, 0x80000000);
	      if (maxe >= 0x80000004)
		{
		  cpuid (&in_buf.m[0], &in_buf.m[1], &in_buf.m[2],
			 &in_buf.m[3], 0x80000002);
		  cpuid (&in_buf.m[4], &in_buf.m[5], &in_buf.m[6],
			 &in_buf.m[7], 0x80000003);
		  cpuid (&in_buf.m[8], &in_buf.m[9], &in_buf.m[10],
			 &in_buf.m[11], 0x80000004);
		  in_buf.m[12] = 0;
		}
	      else
		{
		  /* Could implement a lookup table here if someone needs it. */
		  strcpy (in_buf.s, "unknown");
		}
	      int cache_size = -1,
		  tlb_size = -1,
		  clflush = 64,
		  cache_alignment = 64;
	      if (features1 & (1 << 19)) /* CLFSH */
		clflush = ((extra_info >> 8) & 0xff) << 3;
	      if (is_intel && family == 15)
		cache_alignment = clflush * 2;
	      if (maxe >= 0x80000005) /* L1 Cache and TLB Identifiers. */
		{
		  uint32_t data_cache, inst_cache;
		  cpuid (&unused, &unused, &data_cache, &inst_cache,
			 0x80000005);

		  cache_size = (inst_cache >> 24) + (data_cache >> 24);
		  tlb_size = 0;
		}
	      if (maxe >= 0x80000006) /* L2 Cache and L2 TLB Identifiers. */
		{
		  uint32_t tlb, l2;
		  cpuid (&unused, &tlb, &l2, &unused, 0x80000006);

		  cache_size = l2 >> 16;
		  tlb_size = ((tlb >> 16) & 0xfff) + (tlb & 0xfff);
		}
	      bufptr += __small_sprintf (bufptr, "cpu family\t: %d\n"
						 "model\t\t: %d\n"
						 "model name\t: %s\n"
						 "stepping\t: %d\n"
						 "cpu MHz\t\t: %d.000\n",
					 family,
					 model,
					 in_buf.s + strspn (in_buf.s, " 	"),
					 stepping,
					 cpu_mhz);
	      if (cache_size >= 0)
		bufptr += __small_sprintf (bufptr, "cache size\t: %d KB\n",
					   cache_size);

	      /* Recognize multi-core CPUs. */
	      if (maxe >= 0x80000008)
		{
		  uint32_t core_info;
		  cpuid (&unused, &unused, &core_info, &unused, 0x80000008);

		  int max_cores = 1 + (core_info & 0xff);
		  if (max_cores > 1)
		    {
		      int shift = (core_info >> 12) & 0x0f;
		      if (!shift)
			while ((1 << shift) < max_cores)
			  ++shift;
		      int core_id = apic_id & ((1 << shift) - 1);
		      apic_id >>= shift;

		      bufptr += __small_sprintf (bufptr, "physical id\t: %d\n"
							 "core id\t\t: %d\n"
							 "cpu cores\t: %d\n",
						 apic_id, core_id, max_cores);
		    }
		}
	      /* Recognize Intel Hyper-Transport CPUs. */
	      else if (is_intel && (features1 & (1 << 28)) && maxf >= 4)
		{
		  /* TODO */
		}

	      bufptr += __small_sprintf (bufptr, "fpu\t\t: %s\n"
						 "fpu_exception\t: %s\n"
						 "cpuid level\t: %d\n"
						 "wp\t\t: yes\n",
					 (features1 & (1 << 0)) ? "yes" : "no",
					 (features1 & (1 << 0)) ? "yes" : "no",
					 maxf);
	      print ("flags\t\t:");
	      if (features1 & (1 << 0))
		print (" fpu");
	      if (features1 & (1 << 1))
		print (" vme");
	      if (features1 & (1 << 2))
		print (" de");
	      if (features1 & (1 << 3))
		print (" pse");
	      if (features1 & (1 << 4))
		print (" tsc");
	      if (features1 & (1 << 5))
		print (" msr");
	      if (features1 & (1 << 6))
		print (" pae");
	      if (features1 & (1 << 7))
		print (" mce");
	      if (features1 & (1 << 8))
		print (" cx8");
	      if (features1 & (1 << 9))
		print (" apic");
	      if (features1 & (1 << 11))
		print (" sep");
	      if (features1 & (1 << 12))
		print (" mtrr");
	      if (features1 & (1 << 13))
		print (" pge");
	      if (features1 & (1 << 14))
		print (" mca");
	      if (features1 & (1 << 15))
		print (" cmov");
	      if (features1 & (1 << 16))
		print (" pat");
	      if (features1 & (1 << 17))
		print (" pse36");
	      if (features1 & (1 << 18))
		print (" pn");
	      if (features1 & (1 << 19))
		print (" clflush");
	      if (is_intel && features1 & (1 << 21))
		print (" dts");
	      if (is_intel && features1 & (1 << 22))
		print (" acpi");
	      if (features1 & (1 << 23))
		print (" mmx");
	      if (features1 & (1 << 24))
		print (" fxsr");
	      if (features1 & (1 << 25))
		print (" sse");
	      if (features1 & (1 << 26))
		print (" sse2");
	      if (is_intel && (features1 & (1 << 27)))
		print (" ss");
	      if (features1 & (1 << 28))
		print (" ht");
	      if (is_intel)
		{
		  if (features1 & (1 << 29))
		    print (" tm");
		  if (features1 & (1 << 30))
		    print (" ia64");
		  if (features1 & (1 << 31))
		    print (" pbe");
		}

	      if (is_amd && maxe >= 0x80000001)
		{
		  cpuid (&unused, &unused, &unused, &features1, 0x80000001);

		  if (features1 & (1 << 11))
		    print (" syscall");
		  if (features1 & (1 << 19)) /* Huh?  Not in AMD64 specs. */
		    print (" mp");
		  if (features1 & (1 << 20))
		    print (" nx");
		  if (features1 & (1 << 22))
		    print (" mmxext");
		  if (features1 & (1 << 25))
		    print (" fxsr_opt");
		  if (features1 & (1 << 26))
		    print (" pdpe1gb");
		  if (features1 & (1 << 27))
		    print (" rdtscp");
		  if (features1 & (1 << 29))
		    print (" lm");
		  if (features1 & (1 << 30)) /* 31th bit is on. */
		    print (" 3dnowext");
		  if (features1 & (1 << 31)) /* 32th bit (highest) is on. */
		    print (" 3dnow");
		}

	      if (features2 & (1 << 0))
		print (" pni");
	      if (is_intel)
		{
		  if (features2 & (1 << 2))
		    print (" dtes64");
		  if (features2 & (1 << 3))
		    print (" monitor");
		  if (features2 & (1 << 4))
		    print (" ds_cpl");
		  if (features2 & (1 << 5))
		    print (" vmx");
		  if (features2 & (1 << 6))
		    print (" smx");
		  if (features2 & (1 << 7))
		    print (" est");
		  if (features2 & (1 << 8))
		    print (" tm2");
		  if (features2 & (1 << 9))
		    print (" ssse3");
		  if (features2 & (1 << 10))
		    print (" cid");
		  if (features2 & (1 << 12))
		    print (" fma");
		}
	      if (features2 & (1 << 13))
		print (" cx16");
	      if (is_intel)
		{
		  if (features2 & (1 << 14))
		    print (" xtpr");
		  if (features2 & (1 << 15))
		    print (" pdcm");
		  if (features2 & (1 << 18))
		    print (" dca");
		  if (features2 & (1 << 19))
		    print (" sse4_1");
		  if (features2 & (1 << 20))
		    print (" sse4_2");
		  if (features2 & (1 << 21))
		    print (" x2apic");
		  if (features2 & (1 << 22))
		    print (" movbe");
		  if (features2 & (1 << 23))
		    print (" popcnt");
		  if (features2 & (1 << 25))
		    print (" aes");
		  if (features2 & (1 << 26))
		    print (" xsave");
		  if (features2 & (1 << 27))
		    print (" osxsave");
		  if (features2 & (1 << 28))
		    print (" avx");
		  if (features2 & (1 << 29))
		    print (" f16c");
		  if (features2 & (1 << 30))
		    print (" rdrand");
		  if (features2 & (1 << 31))
		    print (" hypervisor");
		}

	      if (maxe >= 0x80000001)
		{
		  cpuid (&unused, &unused, &features1, &unused, 0x80000001);

		  if (features1 & (1 << 0))
		    print (" lahf_lm");
		  if (features1 & (1 << 1))
		    print (" cmp_legacy");
		  if (is_amd)
		    {
		      if (features1 & (1 << 2))
			print (" svm");
		      if (features1 & (1 << 3))
			print (" extapic");
		      if (features1 & (1 << 4))
			print (" cr8_legacy");
		      if (features1 & (1 << 5))
			print (" abm");
		      if (features1 & (1 << 6))
			print (" sse4a");
		      if (features1 & (1 << 7))
			print (" misalignsse");
		      if (features1 & (1 << 8))
			print (" 3dnowprefetch");
		      if (features1 & (1 << 9))
			print (" osvw");
		    }
		  if (features1 & (1 << 10))
		    print (" ibs");
		  if (is_amd)
		    {
		      if (features1 & (1 << 11))
			print (" sse5");
		      if (features1 & (1 << 12))
			print (" skinit");
		      if (features1 & (1 << 13))
			print (" wdt");
		      if (features1 & (1 << 15))
			print (" lwp");
		      if (features1 & (1 << 16))
			print (" fma4");
		      if (features1 & (1 << 17))
			print (" tce");
		      if (features1 & (1 << 19))
			print (" nodeid_msr");
		      if (features1 & (1 << 21))
			print (" tbm");
		      if (features1 & (1 << 22))
			print (" topoext");
		      if (features1 & (1 << 23))
			print (" perfctr_core");
		      if (features1 & (1 << 24))
			print (" perfctr_nb");
		      if (features1 & (1 << 28))
			print (" perfctr_l2");
		    }
		}
	      if (is_intel) /* features scattered in various CPUID levels. */
		{
		  cpuid (&features1, &unused, &features2, &unused, 0x06);

		  if (features1 & (1 << 1))
		    print (" ida");
		  if (features1 & (1 << 2))
		    print (" arat");
		  if (features2 & (1 << 3))
		    print (" epb");

		  cpuid (&features2, &unused, &unused, &unused, 0x0d, 1);
		  if (features2 & (1 << 0))
		    print (" xsaveopt");

		  if (features1 & (1 << 4))
		    print (" pln");
		  if (features1 & (1 << 6))
		    print (" pts");
		  if (features1 & (1 << 0))
		    print (" dtherm");
		}
	      if (is_intel) /* Extended feature flags */
		{
		  cpuid (&unused, &features1, &unused, &unused, 0x07, 0);

		  if (features1 & (1 << 0))
		    print (" fsgsbase");
		  if (features1 & (1 << 1))
		    print (" tsc_adjust");
		  if (features1 & (1 << 3))
		    print (" bmi1");
		  if (features1 & (1 << 4))
		    print (" hle");
		  if (features1 & (1 << 5))
		    print (" avx2");
		  if (features1 & (1 << 7))
		    print (" smep");
		  if (features1 & (1 << 8))
		    print (" bmi2");
		  if (features1 & (1 << 9))
		    print (" erms");
		  if (features1 & (1 << 10))
		    print (" invpcid");
		  if (features1 & (1 << 11))
		    print (" rtm");
		  if (features1 & (1 << 14))
		    print (" mpx");
		  if (features1 & (1 << 16))
		    print (" avx512f");
		  if (features1 & (1 << 18))
		    print (" rdseed");
		  if (features1 & (1 << 19))
		    print (" adx");
		  if (features1 & (1 << 20))
		    print (" smap");
		  if (features1 & (1 << 23))
		    print (" clflushopt");
		  if (features1 & (1 << 26))
		    print (" avx512pf");
		  if (features1 & (1 << 27))
		    print (" avx512er");
		  if (features1 & (1 << 28))
		    print (" avx512cd");
		}

	      print ("\n");

	      /* TODO: bogomips */

	      if (tlb_size >= 0)
		bufptr += __small_sprintf (bufptr,
					   "TLB size\t: %d 4K pages\n",
					   tlb_size);
	      bufptr += __small_sprintf (bufptr, "clflush size\t: %d\n"
						 "cache_alignment\t: %d\n",
					 clflush,
					 cache_alignment);

	      if (maxe >= 0x80000008) /* Address size. */
		{
		  uint32_t addr_size, phys, virt;
		  cpuid (&addr_size, &unused, &unused, &unused, 0x80000008);

		  phys = addr_size & 0xff;
		  virt = (addr_size >> 8) & 0xff;
		  /* Fix an errata on Intel CPUs */
		  if (is_intel && family == 15 && model == 3 && stepping == 4)
		    phys = 36;
		  bufptr += __small_sprintf (bufptr, "address sizes\t: "
						     "%u bits physical, "
						     "%u bits virtual\n",
					     phys, virt);
		}

	      if (maxe >= 0x80000007) /* Advanced power management. */
		{
		  cpuid (&unused, &unused, &unused, &features1, 0x80000007);

		  print ("power management:");
		  if (features1 & (1 << 0))
		    print (" ts");
		  if (features1 & (1 << 1))
		    print (" fid");
		  if (features1 & (1 << 2))
		    print (" vid");
		  if (features1 & (1 << 3))
		    print (" ttp");
		  if (features1 & (1 << 4))
		    print (" tm");
		  if (features1 & (1 << 5))
		    print (" stc");
		  if (features1 & (1 << 6))
		    print (" 100mhzsteps");
		  if (features1 & (1 << 7))
		    print (" hwpstate");
		}
	    }
	  else
	    {
	      bufptr += __small_sprintf (bufptr, "cpu MHz         : %d\n"
						 "fpu             : %s\n",
						 cpu_mhz,
						 IsProcessorFeaturePresent (PF_FLOATING_POINT_EMULATED) ? "no" : "yes");
	    }
	}
      if (orig_affinity_mask != 0)
	SetThreadAffinityMask (GetCurrentThread (), orig_affinity_mask);
      print ("\n");
    }

  destbuf = (char *) crealloc_abort (destbuf, bufptr - buf);
  memcpy (destbuf, buf, bufptr - buf);
  return bufptr - buf;
}

static off_t
format_proc_partitions (void *, char *&destbuf)
{
  OBJECT_ATTRIBUTES attr;
  IO_STATUS_BLOCK io;
  NTSTATUS status;
  HANDLE dirhdl;
  tmp_pathbuf tp;

  char *buf = tp.c_get ();
  char *bufptr = buf;
  char *ioctl_buf = tp.c_get ();
  PWCHAR mp_buf = tp.w_get ();
  WCHAR fpath[MAX_PATH];
  WCHAR gpath[MAX_PATH];
  DWORD len;

  /* Open \Device object directory. */
  wchar_t wpath[MAX_PATH] = L"\\Device";
  UNICODE_STRING upath = {14, 16, wpath};
  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE, NULL, NULL);
  status = NtOpenDirectoryObject (&dirhdl, DIRECTORY_QUERY, &attr);
  if (!NT_SUCCESS (status))
    {
      debug_printf ("NtOpenDirectoryObject, status %y", status);
      __seterrno_from_nt_status (status);
      return 0;
    }

  /* Traverse \Device directory ... */
  PDIRECTORY_BASIC_INFORMATION dbi = (PDIRECTORY_BASIC_INFORMATION)
				     alloca (640);
  BOOLEAN restart = TRUE;
  bool got_one = false;
  ULONG context = 0;
  while (NT_SUCCESS (NtQueryDirectoryObject (dirhdl, dbi, 640, TRUE, restart,
					     &context, NULL)))
    {
      HANDLE devhdl;
      PARTITION_INFORMATION_EX *pix = NULL;
      PARTITION_INFORMATION *pi = NULL;
      DWORD bytes_read;
      DWORD part_cnt = 0;
      unsigned long long size;
      device dev;

      restart = FALSE;
      /* ... and check for a "Harddisk[0-9]*" entry. */
      if (dbi->ObjectName.Length < 9 * sizeof (WCHAR)
	  || wcsncasecmp (dbi->ObjectName.Buffer, L"Harddisk", 8) != 0
	  || !iswdigit (dbi->ObjectName.Buffer[8]))
	continue;
      /* Got it.  Now construct the path to the entire disk, which is
	 "\\Device\\HarddiskX\\Partition0", and open the disk with
	 minimum permissions. */
      unsigned long drive_num = wcstoul (dbi->ObjectName.Buffer + 8, NULL, 10);
      wcscpy (wpath, dbi->ObjectName.Buffer);
      PWCHAR wpart = wpath + dbi->ObjectName.Length / sizeof (WCHAR);
      wcpcpy (wpart, L"\\Partition0");
      upath.Length = dbi->ObjectName.Length + 22;
      upath.MaximumLength = upath.Length + sizeof (WCHAR);
      InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE,
				  dirhdl, NULL);
      status = NtOpenFile (&devhdl, READ_CONTROL, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, 0);
      if (!NT_SUCCESS (status))
	{
	  debug_printf ("NtOpenFile(%S), status %y", &upath, status);
	  __seterrno_from_nt_status (status);
	  continue;
	}
      if (!got_one)
	{
	  print ("major minor  #blocks  name   win-mounts\n\n");
	  got_one = true;
	}
      /* Fetch partition info for the entire disk to get its size. */
      if (DeviceIoControl (devhdl, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0,
			   ioctl_buf, NT_MAX_PATH, &bytes_read, NULL))
	{
	  pix = (PARTITION_INFORMATION_EX *) ioctl_buf;
	  size = pix->PartitionLength.QuadPart;
	}
      else if (DeviceIoControl (devhdl, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
				ioctl_buf, NT_MAX_PATH, &bytes_read, NULL))
	{
	  pi = (PARTITION_INFORMATION *) ioctl_buf;
	  size = pi->PartitionLength.QuadPart;
	}
      else
	{
	  debug_printf ("DeviceIoControl (%S, "
			 "IOCTL_DISK_GET_PARTITION_INFO{_EX}) %E", &upath);
	  size = 0;
	}
      dev.parsedisk (drive_num, 0);
      bufptr += __small_sprintf (bufptr, "%5d %5d %9U %s\n",
				 dev.get_major (), dev.get_minor (),
				 size >> 10, dev.name + 5);
      /* Fetch drive layout info to get size of all partitions on the disk. */
      if (DeviceIoControl (devhdl, IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
			   NULL, 0, ioctl_buf, NT_MAX_PATH, &bytes_read, NULL))
	{
	  PDRIVE_LAYOUT_INFORMATION_EX pdlix = (PDRIVE_LAYOUT_INFORMATION_EX)
					       ioctl_buf;
	  part_cnt = pdlix->PartitionCount;
	  pix = pdlix->PartitionEntry;
	}
      else if (DeviceIoControl (devhdl, IOCTL_DISK_GET_DRIVE_LAYOUT,
				NULL, 0, ioctl_buf, NT_MAX_PATH, &bytes_read, NULL))
	{
	  PDRIVE_LAYOUT_INFORMATION pdli = (PDRIVE_LAYOUT_INFORMATION) ioctl_buf;
	  part_cnt = pdli->PartitionCount;
	  pi = pdli->PartitionEntry;
	}
      else
	debug_printf ("DeviceIoControl(%S, "
		      "IOCTL_DISK_GET_DRIVE_LAYOUT{_EX}): %E", &upath);
      /* Loop over partitions. */
      if (pix || pi)
	for (DWORD i = 0; i < part_cnt; ++i)
	  {
	    DWORD part_num;

	    if (pix)
	      {
		size = pix->PartitionLength.QuadPart;
		part_num = pix->PartitionNumber;
		++pix;
	      }
	    else
	      {
		size = pi->PartitionLength.QuadPart;
		part_num = pi->PartitionNumber;
		++pi;
	      }
	    /* A partition number of 0 denotes an extended partition or a
	       filler entry as described in fhandler_dev_floppy::lock_partition.
	       Just skip. */
	    if (part_num == 0)
	      continue;
	    dev.parsedisk (drive_num, part_num);

	    bufptr += __small_sprintf (bufptr, "%5d %5d %9U %s",
				       dev.get_major (), dev.get_minor (),
				       size >> 10, dev.name + 5);
	    /* Check if the partition is mounted in Windows and, if so,
	       print the mount point list. */
	    __small_swprintf (fpath,
			      L"\\\\?\\GLOBALROOT\\Device\\%S\\Partition%u\\",
			      &dbi->ObjectName, part_num);
	    if (GetVolumeNameForVolumeMountPointW (fpath, gpath, MAX_PATH)
		&& GetVolumePathNamesForVolumeNameW (gpath, mp_buf,
						     NT_MAX_PATH, &len))
	      {
		len = strlen (dev.name + 5);
		while (len++ < 6)
		  *bufptr++ = ' ';
		for (PWCHAR p = mp_buf; *p; p = wcschr (p, L'\0') + 1)
		  bufptr += __small_sprintf (bufptr, " %W", p);
	      }

	    *bufptr++ = '\n';
	  }
      NtClose (devhdl);
    }
  NtClose (dirhdl);

  if (!got_one)
    return 0;

  destbuf = (char *) crealloc_abort (destbuf, bufptr - buf);
  memcpy (destbuf, buf, bufptr - buf);
  return bufptr - buf;
}

static off_t
format_proc_self (void *, char *&destbuf)
{
  destbuf = (char *) crealloc_abort (destbuf, 16);
  return __small_sprintf (destbuf, "%d", getpid ());
}

static off_t
format_proc_cygdrive (void *, char *&destbuf)
{
  destbuf = (char *) crealloc_abort (destbuf, mount_table->cygdrive_len + 1);
  char *dend = stpcpy (destbuf, mount_table->cygdrive);
  if (dend > destbuf + 1)	/* cygdrive != "/"? */
    *--dend = '\0';
  return dend - destbuf;
}

static off_t
format_proc_mounts (void *, char *&destbuf)
{
  destbuf = (char *) crealloc_abort (destbuf, sizeof ("self/mounts"));
  return __small_sprintf (destbuf, "self/mounts");
}

static off_t
format_proc_filesystems (void *, char *&destbuf)
{
  tmp_pathbuf tp;
  char *buf = tp.c_get ();
  char *bufptr = buf;

  /* start at 1 to skip type "none" */
  for (int i = 1; fs_names[i].name; i++)
    bufptr += __small_sprintf(bufptr, "%s\t%s\n",
			      fs_names[i].block_device ? "" : "nodev",
			      fs_names[i].name);

  destbuf = (char *) crealloc_abort (destbuf, bufptr - buf);
  memcpy (destbuf, buf, bufptr - buf);
  return bufptr - buf;
}

static off_t
format_proc_swaps (void *, char *&destbuf)
{
  unsigned long long total = 0ULL, used = 0ULL;
  PSYSTEM_PAGEFILE_INFORMATION spi = NULL;
  ULONG size = 512;
  NTSTATUS status = STATUS_SUCCESS;

  tmp_pathbuf tp;
  char *buf = tp.c_get ();
  char *bufptr = buf;

  spi = (PSYSTEM_PAGEFILE_INFORMATION) malloc (size);
  if (spi)
    {
      status = NtQuerySystemInformation (SystemPagefileInformation, (PVOID) spi,
					 size, &size);
      if (status == STATUS_INFO_LENGTH_MISMATCH)
	{
	  free (spi);
	  spi = (PSYSTEM_PAGEFILE_INFORMATION) malloc (size);
	  if (spi)
	    status = NtQuerySystemInformation (SystemPagefileInformation,
					       (PVOID) spi, size, &size);
	}
    }

  bufptr += __small_sprintf (bufptr,
			     "Filename\t\t\t\tType\t\tSize\tUsed\tPriority\n");

  if (spi && NT_SUCCESS (status))
    {
      PSYSTEM_PAGEFILE_INFORMATION spp = spi;
      char *filename = tp.c_get ();
      do
	{
	  total = (unsigned long long) spp->CurrentSize * wincap.page_size ();
	  used = (unsigned long long) spp->TotalUsed * wincap.page_size ();
	  cygwin_conv_path (CCP_WIN_W_TO_POSIX, spp->FileName.Buffer,
			    filename, NT_MAX_PATH);
	  bufptr += sprintf (bufptr, "%-40s%-16s%-8llu%-8llu%-8d\n",
			     filename, "file", total >> 10, used >> 10, 0);
	}
      while (spp->NextEntryOffset
	     && (spp = (PSYSTEM_PAGEFILE_INFORMATION)
		       ((char *) spp + spp->NextEntryOffset)));
    }

  if (spi)
    free (spi);

  destbuf = (char *) crealloc_abort (destbuf, bufptr - buf);
  memcpy (destbuf, buf, bufptr - buf);
  return bufptr - buf;
}

static off_t
format_proc_devices (void *, char *&destbuf)
{
  tmp_pathbuf tp;
  char *buf = tp.c_get ();
  char *bufptr = buf;

  bufptr += __small_sprintf (bufptr,
			     "Character devices:\n"
			     "%3d mem\n"
			     "%3d cons\n"
			     "%3d /dev/tty\n"
			     "%3d /dev/console\n"
			     "%3d /dev/ptmx\n"
			     "%3d st\n"
			     "%3d misc\n"
			     "%3d sound\n"
			     "%3d ttyS\n"
			     "%3d tty\n"
			     "\n"
			     "Block devices:\n"
			     "%3d fd\n"
			     "%3d sd\n"
			     "%3d sr\n"
			     "%3d sd\n"
			     "%3d sd\n"
			     "%3d sd\n"
			     "%3d sd\n"
			     "%3d sd\n"
			     "%3d sd\n"
			     "%3d sd\n",
			     DEV_MEM_MAJOR, DEV_CONS_MAJOR, _major (FH_TTY),
			     _major (FH_CONSOLE), _major (FH_PTMX),
			     DEV_TAPE_MAJOR, DEV_MISC_MAJOR, DEV_SOUND_MAJOR,
			     DEV_SERIAL_MAJOR, DEV_PTYS_MAJOR, DEV_FLOPPY_MAJOR,
			     DEV_SD_MAJOR, DEV_CDROM_MAJOR, DEV_SD1_MAJOR,
			     DEV_SD2_MAJOR, DEV_SD3_MAJOR, DEV_SD4_MAJOR,
			     DEV_SD5_MAJOR, DEV_SD6_MAJOR, DEV_SD7_MAJOR);

  destbuf = (char *) crealloc_abort (destbuf, bufptr - buf);
  memcpy (destbuf, buf, bufptr - buf);
  return bufptr - buf;
}

static off_t
format_proc_misc (void *, char *&destbuf)
{
  tmp_pathbuf tp;
  char *buf = tp.c_get ();
  char *bufptr = buf;

  bufptr += __small_sprintf (bufptr,
			     "%3d clipboard\n"
			     "%3d windows\n",
			     _minor (FH_CLIPBOARD), _minor (FH_WINDOWS));

  destbuf = (char *) crealloc_abort (destbuf, bufptr - buf);
  memcpy (destbuf, buf, bufptr - buf);
  return bufptr - buf;
}

#undef print
@


1.125
log
@	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".
@
text
@d4 1
a4 1
   2013, 2014 Red Hat, Inc.
d796 1
a796 1
	      if (is_amd && maxe >= 0x80000008)
@


1.124
log
@	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.
@
text
@d1363 2
a1364 1
  *--dend = '\0';
@


1.123
log
@	* fhandler_proc.cc (fhandler_proc::readdir): Set dirent d_type.
	* fhandler_process.cc (fhandler_process::readdir): Ditto.
	* fhandler_procnet.cc (fhandler_procnet::readdir): Ditto.
	* fhandler_procsys.cc (fhandler_procsys::readdir): Ditto.
	* fhandler_procsysvipc.cc (fhandler_procsysvipc::readdir): Ditto.
	*  fhandler_virtual.h (virt_ftype_to_dtype): Define new inline function
	to generate dirent d_type from virtual_ftype_t.
@
text
@d1187 4
d1229 1
a1229 1
	 minimum permssions. */
d1233 2
a1234 3
      __small_swprintf (wpart, L"\\Partition0");
      upath.Length = dbi->ObjectName.Length
		     + wcslen (wpart) * sizeof (WCHAR);
d1248 1
a1248 1
	  print ("major minor  #blocks  name\n\n");
d1317 2
a1318 1
	    bufptr += __small_sprintf (bufptr, "%5d %5d %9U %s\n",
d1321 17
@


1.122
log
@	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.
@
text
@d257 3
a259 1
      strcpy (de->d_name, proc_tab[dir->__d_position++].name);
d272 1
@


1.121
log
@	* cpuid.h: Add missing copyright header.  Fix formatting.  Use uint32_t
	instead of unsigned throughout.  Change functions to static inline and
	always inline.
	(cpuid): Add parameter to set ecx, allowing to request extended CPUID
	info.
	* fhandler_proc.cc (format_proc_cpuinfo): Use uint32_t instead of
	unsigned throughout.  Add fake decimal places to MHz info.  Handle more
	feature flags.
	* fhandler_random.cc (fhandler_dev_random::write): Allow up to 4K
	input to add entropy.
	* syscalls.cc: Drop including cpuid.h.
@
text
@d20 1
d48 1
d60 1
d1335 9
@


1.120
log
@	* fhandler_proc.cc (format_proc_swaps): Use tmp_pathbuf for filename,
	rather than allocating and forgetting to free (CID 59982).
@
text
@d604 1
a604 1
    unsigned m[13];
d701 1
a701 1
	  unsigned maxf, vendor_id[4], unused;
d717 1
a717 1
	      unsigned features2, features1, extra_info, cpuid_sig;
d719 1
a719 1
	      /* unsigned extended_family = (cpuid_sig & 0x0ff00000) >> 20,
d722 1
a722 1
	      unsigned family		= (cpuid_sig & 0x00000f00) >> 8,
d726 3
a728 3
	      //unsigned brand_id		= extra_info & 0x0000000f;
	      //unsigned cpu_count	= (extra_info & 0x00ff0000) >> 16;
	      unsigned apic_id		= (extra_info & 0xff000000) >> 24;
d733 1
a733 1
	      unsigned maxe = 0;
d760 1
a760 1
		  unsigned data_cache, inst_cache;
d769 1
a769 1
		  unsigned tlb, l2;
d779 1
a779 1
						 "cpu MHz\t\t: %d\n",
d792 1
a792 1
		  unsigned core_info;
d891 1
a891 2
		  unsigned features;
		  cpuid (&unused, &unused, &unused, &features, 0x80000001);
d893 1
a893 1
		  if (features & (1 << 11))
d895 1
a895 1
		  if (features & (1 << 19)) /* Huh?  Not in AMD64 specs. */
d897 1
a897 1
		  if (features & (1 << 20))
d899 1
a899 1
		  if (features & (1 << 22))
d901 1
a901 1
		  if (features & (1 << 25))
d903 1
a903 1
		  if (features & (1 << 26))
d905 1
a905 1
		  if (features & (1 << 27))
d907 1
a907 1
		  if (features & (1 << 29))
d909 1
a909 1
		  if (features & (1 << 30)) /* 31th bit is on. */
d911 1
a911 1
		  if (features & (1 << 31)) /* 32th bit (highest) is on. */
d968 6
d978 1
a978 2
		  unsigned features;
		  cpuid (&unused, &unused, &features, &unused, 0x80000001);
d980 1
a980 1
		  if (features & (1 << 0))
d982 1
a982 1
		  if (features & (1 << 1))
d986 1
a986 1
		      if (features & (1 << 2))
d988 1
a988 1
		      if (features & (1 << 3))
d990 1
a990 1
		      if (features & (1 << 4))
d992 1
a992 1
		      if (features & (1 << 5))
d994 1
a994 1
		      if (features & (1 << 6))
d996 1
a996 1
		      if (features & (1 << 7))
d998 1
a998 1
		      if (features & (1 << 8))
d1000 1
a1000 1
		      if (features & (1 << 9))
d1003 1
a1003 1
		  if (features & (1 << 10))
d1007 1
a1007 1
		      if (features & (1 << 11))
d1009 1
a1009 1
		      if (features & (1 << 12))
d1011 1
a1011 1
		      if (features & (1 << 13))
d1013 18
d1033 65
d1114 1
a1114 1
		  unsigned addr_size, phys, virt;
d1130 1
a1130 1
		  cpuid (&unused, &unused, &unused, &features2, 0x80000007);
d1133 1
a1133 1
		  if (features2 & (1 << 0))
d1135 1
a1135 1
		  if (features2 & (1 << 1))
d1137 1
a1137 1
		  if (features2 & (1 << 2))
d1139 1
a1139 1
		  if (features2 & (1 << 3))
d1141 1
a1141 1
		  if (features2 & (1 << 4))
d1143 1
a1143 1
		  if (features2 & (1 << 5))
d1145 1
a1145 1
		  if (features2 & (1 << 6))
d1147 1
a1147 1
		  if (features2 & (1 << 7))
@


1.119
log
@	Streamline time/times functionality.  Remove last remains of former
	Windows 9x compatibility.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Drop now unneeded
	casts in calls to_timestruc_t.
	(fhandler_base::utimens_fs): Ditto for timespec_to_filetime.
	* fhandler_proc.cc (format_proc_stat): Ditto for to_time_t.
	* hires.h (class hires_ms): Remove unused member initime_ns.
	Remove declarations for timeGetTime_ns and prime.
	(hires_ms::uptime): Remove.
	* posix_ipc.cc (ipc_cond_timedwait): Ditto for timespec_to_filetime.
	* fhandler_registry.cc (fhandler_registry::fstat): Add cast.
	* resource.cc (fill_rusage): Call NtQueryInformationProcess rather than
	GetProcessTimes to deal with LARGE_INTEGER rather than FILETIME.
	* times.cc: Simplify time handling.  Throughout, use LARGE_INTEGER
	rather than FILETIME to simplify computations.  Throughout use
	{u}int64_t rather than {unsigned} long long.  Drop unneeded casts since
	NSPERSEC is 64 bit anyway.
	(systime_ns): Remove.
	(times): Call NtQuerySystemInformation to fetch boot time.  Call
	NtQueryInformationProcess rather than GetProcessTimes to deal with
	LARGE_INTEGER rather than FILETIME.  Call GetSystemTimeAsFileTime.
	(totimeval): Use constant 1000000 as in other functions.
	(time_t_to_filetime): Remove.
	(to_time_t): Change return type to time_t.
	(time_as_timestruc_t): Rename filetime to systime.
	(time): Ditto. Add cast.
	(hires_ns::nsecs): Fix return type cast.
	(hires_ms::timeGetTime_ns): Remove.
	(hires_ns::prime): Remove.
	(hires_ms::nsecs): Drop call to prime.  Call GetSystemTimeAsFileTime
	directly.  Subtract FACTOR here since it's the only function needing
	to do so.
	(minperiod): Cosmetically change to ULONG.
	(hires_ns::resolution): Fix return type cast.
	(hires_ms::resolution): Simplify, rely on NtQueryTimerResolution.
	* winsup.h: Align time related prototypes to above changes.
@
text
@d4 1
a4 1
   2013 Red Hat, Inc.
a1272 2
  char *filename = NULL;
  ssize_t filename_len;
d1302 1
a1306 4

	  filename_len = cygwin_conv_path (CCP_WIN_W_TO_POSIX,
					   spp->FileName.Buffer, filename, 0);
	  filename = (char *) malloc (filename_len);
d1308 1
a1308 2
			    filename, filename_len);

@


1.119.2.1
log
@Add more missing patches
@
text
@d4 1
a4 1
   2013, 2014 Red Hat, Inc.
d1273 2
a1303 1
      char *filename = tp.c_get ();
d1308 4
d1313 2
a1314 1
			    filename, NT_MAX_PATH);
@


1.119.2.2
log
@2014-08-11  Corinna Vinschen  <corinna@@vinschen.de>

	* cpuid.h: Add missing copyright header.  Fix formatting.  Use uint32_t
	instead of unsigned throughout.  Change functions to static inline and
	always inline.
	(cpuid): Add parameter to set ecx, allowing to request extended CPUID
	info.
	* fhandler_proc.cc (format_proc_cpuinfo): Use uint32_t instead of
	unsigned throughout.  Add fake decimal places to MHz info.  Handle more
	feature flags.
	* fhandler_random.cc (fhandler_dev_random::write): Allow up to 4K
	input to add entropy.
	* syscalls.cc: Drop including cpuid.h.

2014-08-07  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (__cxa_finalize): Export.
	* dcrt0.cc (cygwin_atexit): Use d->handle with __cxa_atexit.
	* dll_init.cc (dll_list::detach): Use d->handle with __cxa_finalize.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Use 274 for
	__cxa_finalize as well.

2014-08-04  Anthony Heading  <anthony@@ajrh.net>

	* include/sys/file.h: Add extern "C".

2014-08-04  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Export.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump to 274.

2014-07-31  Eric Blake  <eblake@@redhat.com>

	* include/pthread.h: Decorate attribute names with __, for
	namespace safety.
	* include/cygwin/core_dump.h: Likewise.
	* include/cygwin/cygwin_dll.h: Likewise.
	* include/sys/cygwin.h: Likewise.
	* include/sys/strace.h: Likewise.
@
text
@d604 1
a604 1
    uint32_t m[13];
d701 1
a701 1
	  uint32_t maxf, vendor_id[4], unused;
d717 1
a717 1
	      uint32_t features2, features1, extra_info, cpuid_sig;
d719 1
a719 1
	      /* uint32_t extended_family = (cpuid_sig & 0x0ff00000) >> 20,
d722 1
a722 1
	      uint32_t family		= (cpuid_sig & 0x00000f00) >> 8,
d726 3
a728 3
	      //uint32_t brand_id		= extra_info & 0x0000000f;
	      //uint32_t cpu_count	= (extra_info & 0x00ff0000) >> 16;
	      uint32_t apic_id		= (extra_info & 0xff000000) >> 24;
d733 1
a733 1
	      uint32_t maxe = 0;
d760 1
a760 1
		  uint32_t data_cache, inst_cache;
d769 1
a769 1
		  uint32_t tlb, l2;
d779 1
a779 1
						 "cpu MHz\t\t: %d.000\n",
d792 1
a792 1
		  uint32_t core_info;
d891 2
a892 1
		  cpuid (&unused, &unused, &unused, &features1, 0x80000001);
d894 1
a894 1
		  if (features1 & (1 << 11))
d896 1
a896 1
		  if (features1 & (1 << 19)) /* Huh?  Not in AMD64 specs. */
d898 1
a898 1
		  if (features1 & (1 << 20))
d900 1
a900 1
		  if (features1 & (1 << 22))
d902 1
a902 1
		  if (features1 & (1 << 25))
d904 1
a904 1
		  if (features1 & (1 << 26))
d906 1
a906 1
		  if (features1 & (1 << 27))
d908 1
a908 1
		  if (features1 & (1 << 29))
d910 1
a910 1
		  if (features1 & (1 << 30)) /* 31th bit is on. */
d912 1
a912 1
		  if (features1 & (1 << 31)) /* 32th bit (highest) is on. */
a968 6
		  if (features2 & (1 << 29))
		    print (" f16c");
		  if (features2 & (1 << 30))
		    print (" rdrand");
		  if (features2 & (1 << 31))
		    print (" hypervisor");
d973 2
a974 1
		  cpuid (&unused, &unused, &features1, &unused, 0x80000001);
d976 1
a976 1
		  if (features1 & (1 << 0))
d978 1
a978 1
		  if (features1 & (1 << 1))
d982 1
a982 1
		      if (features1 & (1 << 2))
d984 1
a984 1
		      if (features1 & (1 << 3))
d986 1
a986 1
		      if (features1 & (1 << 4))
d988 1
a988 1
		      if (features1 & (1 << 5))
d990 1
a990 1
		      if (features1 & (1 << 6))
d992 1
a992 1
		      if (features1 & (1 << 7))
d994 1
a994 1
		      if (features1 & (1 << 8))
d996 1
a996 1
		      if (features1 & (1 << 9))
d999 1
a999 1
		  if (features1 & (1 << 10))
d1003 1
a1003 1
		      if (features1 & (1 << 11))
d1005 1
a1005 1
		      if (features1 & (1 << 12))
d1007 1
a1007 1
		      if (features1 & (1 << 13))
a1008 18
		      if (features1 & (1 << 15))
			print (" lwp");
		      if (features1 & (1 << 16))
			print (" fma4");
		      if (features1 & (1 << 17))
			print (" tce");
		      if (features1 & (1 << 19))
			print (" nodeid_msr");
		      if (features1 & (1 << 21))
			print (" tbm");
		      if (features1 & (1 << 22))
			print (" topoext");
		      if (features1 & (1 << 23))
			print (" perfctr_core");
		      if (features1 & (1 << 24))
			print (" perfctr_nb");
		      if (features1 & (1 << 28))
			print (" perfctr_l2");
a1010 65
	      if (is_intel) /* features scattered in various CPUID levels. */
		{
		  cpuid (&features1, &unused, &features2, &unused, 0x06);

		  if (features1 & (1 << 1))
		    print (" ida");
		  if (features1 & (1 << 2))
		    print (" arat");
		  if (features2 & (1 << 3))
		    print (" epb");

		  cpuid (&features2, &unused, &unused, &unused, 0x0d, 1);
		  if (features2 & (1 << 0))
		    print (" xsaveopt");

		  if (features1 & (1 << 4))
		    print (" pln");
		  if (features1 & (1 << 6))
		    print (" pts");
		  if (features1 & (1 << 0))
		    print (" dtherm");
		}
	      if (is_intel) /* Extended feature flags */
		{
		  cpuid (&unused, &features1, &unused, &unused, 0x07, 0);

		  if (features1 & (1 << 0))
		    print (" fsgsbase");
		  if (features1 & (1 << 1))
		    print (" tsc_adjust");
		  if (features1 & (1 << 3))
		    print (" bmi1");
		  if (features1 & (1 << 4))
		    print (" hle");
		  if (features1 & (1 << 5))
		    print (" avx2");
		  if (features1 & (1 << 7))
		    print (" smep");
		  if (features1 & (1 << 8))
		    print (" bmi2");
		  if (features1 & (1 << 9))
		    print (" erms");
		  if (features1 & (1 << 10))
		    print (" invpcid");
		  if (features1 & (1 << 11))
		    print (" rtm");
		  if (features1 & (1 << 14))
		    print (" mpx");
		  if (features1 & (1 << 16))
		    print (" avx512f");
		  if (features1 & (1 << 18))
		    print (" rdseed");
		  if (features1 & (1 << 19))
		    print (" adx");
		  if (features1 & (1 << 20))
		    print (" smap");
		  if (features1 & (1 << 23))
		    print (" clflushopt");
		  if (features1 & (1 << 26))
		    print (" avx512pf");
		  if (features1 & (1 << 27))
		    print (" avx512er");
		  if (features1 & (1 << 28))
		    print (" avx512cd");
		}
d1027 1
a1027 1
		  uint32_t addr_size, phys, virt;
d1043 1
a1043 1
		  cpuid (&unused, &unused, &unused, &features1, 0x80000007);
d1046 1
a1046 1
		  if (features1 & (1 << 0))
d1048 1
a1048 1
		  if (features1 & (1 << 1))
d1050 1
a1050 1
		  if (features1 & (1 << 2))
d1052 1
a1052 1
		  if (features1 & (1 << 3))
d1054 1
a1054 1
		  if (features1 & (1 << 4))
d1056 1
a1056 1
		  if (features1 & (1 << 5))
d1058 1
a1058 1
		  if (features1 & (1 << 6))
d1060 1
a1060 1
		  if (features1 & (1 << 7))
@


1.119.2.3
log
@2014-11-07  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin__cxa_atexit): Fetch correct DSO handle value
	by searching dll list.  Explain why.

2014-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Change preceeding comment to reflect
	API version numbers.
	* external.cc (cygwin_internal): disable setting cxx_malloc on 64 bit.
	Add CW_FIXED_ATEXIT case.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_FIXED_ATEXIT.
	* lib/atexit.c (atexit): Test running Cygwin version by checking
	return value of cygwin_internal (CW_FIXED_ATEXIT).

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* lib/atexit.c (atexit): Check for being linked into the executable.
	If so, call __cxa_atexit with NULL DSO handle.  Explain why.
	* lib/dso_handle.c: New file providing fallback __dso_handle.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Add atexit to be not exported.
	* lib/atexit.c (atexit): New, statically linkable version of atexit.
	* dcrt0.cc (cygwin_atexit): Add comment to mark this function as old
	entry point.  Indiscriminately check for DSO of function pointer for
	all functions, if checking for DSO of return address fails on x86_64.
	Change comment accordingly.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (NEW_FUNCTIONS): Define target-independent.  Add target
	dependent stuff afterwards.  Globally define timezone and all xdr
	symbols as non-exported from libcygwin.a.

2014-11-03  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc: Fix formatting.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Create content of
	installation_dir as non-prefixed path, if possible.

2014-10-29  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (__cxa_atexit): Define as cygwin__cxa_atexit.
	* dcrt0.cc (cygwin__cxa_atexit): New function.  Explain what we do.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* globals.cc (dos_file_warning): Set to false by default.
	* path.cc (warn_msdos): Make static.  Drop test for dos_file_warning.
	(path_conv::check): Check for dos_file_warning here to avoid a function
	call in the default case.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (cygwin_atexit): Add workaround for broken atexit calls
	in __gcc_register_frame of DLLs built with gcc-4.8.3-3.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Set
	installation_dir_len.
	* cygheap.h (struct init_cygheap): Add installation_dir_len member.
	* environ.cc (win_env::add_cache): Use stpcpy for speed.
	(posify_maybe): Use tmp_pathbuf buffer instead of stack.
	(raise_envblock): New function to resize Windows environment block.
	(build_env): Fix indentation.  Call raise_envblock function.  Check if
	$PATH exists and is non-empty.  If not, add PATH variable with Cygwin
	installation directory as content to Windows environment.  Explain why.

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_cygdrive): Fix symlink path if cygdrive
	is "/".

2014-10-24  Corinna Vinschen  <corinna@@vinschen.de>

	* gendef (sigdelayed): 64 bit only: Fix seh_pushreg statements in
	prologue.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* common.din (stime): Export.
	* times.cc (stime): New function.
	* include/cygwin/time.h (stime): Declare.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc: Revert debug code accidentally checked in on
	2014-08-18.

2014-10-20  Corinna Vinschen  <corinna@@vinschen.de>

	* path.cc (symlink_info::check): Set error from status code if opening
	the parent directory failed, but keep special case for root dirs.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygheap.cc (init_cygheap::init_installation_root): Just memmove
	contents of installation_root instead of calling GetModuleFileNameW
	again.  Copy installation_root to installation_dir before stripping of
	"bin" dir.  Explain what we do.
	* cygheap.h (struct init_cygheap): Add installation_dir member.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.h (__try): Define __l_endtry as block-local label in 32 bit
	case as well.

2014-10-17  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Add quotactl.o.
	* common.din (quotactl): Export.
	* ntdll.h: Define FILE_FS_CONTROL_INFORMATION::FileSystemControlFlags
	flag values.
	(struct _FILE_FS_CONTROL_INFORMATION): Define.
	(struct _FILE_GET_QUOTA_INFORMATION): Define.
	(typedef struct _FILE_QUOTA_INFORMATION): Define.
	(NtQueryObject): Use PVOID rather than VOID*.
	(NtQueryVolumeInformationFile): Ditto.
	(NtQueryQuotaInformationFile): Declare.
	(NtSetQuotaInformationFile): Declare.
	(NtSetVolumeInformationFile): Declare.
	* quotactl.cc: New file implementing quotactl().
	* include/sys/mount.h (BLOCK_SIZE): Define.
	(BLOCK_SIZE_BITS): Define.
	* include/sys/quota.h: New header.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* Makefile.in (DLL_OFILES): Rearrange with one file per line.

2014-10-16  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (format_proc_partitions): Extend output to print
	the windows mount points the device is mounted on.

2014-10-13  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Drop redundant test for AF_LOCAL and
	SOCK_STREAM in SO_PEERCRED case, as in the original patch.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (gfpod_helper): Only check for POSIX dir separator, same as
	in get_full_path_of_dll.

2014-10-12  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (set_dl_error): Drop useless __stdcall.
	(check_path_access): Ditto.  Drop FE_CWD from call to find_exec.
	(gfpod_helper): Call path_conv::check for all paths containing a dir
	separator to more closely follow the Linux search algorithm.
	(get_full_path_of_dll): Drop useless __stdcall.
	(dlopen): Simplify RTLD_NOLOAD case by calling GetModuleHandleEx
	instead of GetModuleHandle/LoadLibrary.

2014-10-11  Christian Franke  <franke@@computer.org>

	Add setsockopt(sd, SOL_SOCKET, SO_PEERCRED, NULL, 0) to disable
	initial handshake on AF_LOCAL sockets.
	* fhandler.h (class fhandler_socket): Add no_getpeereid status flag.
	(fhandler_socket::af_local_set_no_getpeereid): New prototype.
	* fhandler_socket.cc (fhandler_socket::af_local_connect): Skip handshake
	if no_getpeereid is set.  Add debug output.
	(fhandler_socket::af_local_accept): Likewise.
	(fhandler_socket::af_local_set_no_getpeereid): New function.
	(fhandler_socket::af_local_copy): Copy no_getpeereid.
	(fhandler_socket::getpeereid): Fail if no_getpeereid is set.
	* net.cc (cygwin_setsockopt): Add SO_PEERCRED for AF_LOCAL/SOCK_STREAM
	sockets.  Add comment to explain why we need it.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-10  Corinna Vinschen  <corinna@@vinschen.de>

	* dlfcn.cc (dlopen): Disable old 32 bit code on 64 bit.
	* dcrt0.cc (check_sanity_and_sync): Ditto.
	* dll_init.cc (dll_dllcrt0_1): Fix typo in comment.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* common.din (ffsl): Export.
	(ffsll): Export.
	* syscalls.cc (ffs): Implement using GCC intrinsic.
	(ffsl): Ditto.
	(ffsll): Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.

2014-10-08  Christian Franke  <franke@@computer.org>

	* syscalls.cc (ffs): Fix crash of ffs (0x80000000) on 64 bit.

2014-10-08  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_process.cc (format_process_statm): Fix output of dirty
	pages.  Add linefeed.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_proc.cc (proc_tab): Add entry for cygdrive symlink.
	(format_proc_cygdrive): New function to implement /proc/cygdrive.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* exception.h (class exception): Remove unnecessary #ifdef.

2014-09-05  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (DNLEN): Raise to 31.  Explain why.

2014-08-28  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_disk_file::fstatvfs): Try the
	FileFsSizeInformation information class on filesystems choking on
	FileFsFullSizeInformation (I see you Netapp!)

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_pty_slave::fch_open_handles): Add bool parameter
	to declaration.
	* fhandler_tty.cc (fhandler_pty_slave::fch_open_handles): Add bool
	parameter "chown".  Only request WRITE_OWNER access when opening pty
	synchronization objects if "chown" is set.
	(fhandler_pty_slave::fchmod): Call fch_open_handles with new bool
	parameter set to false.
	(fhandler_pty_slave::fchown): Call fch_open_handles with new bool
	parameter set to true.
	* kernel32.cc (CreateFileMappingW): Fix default standard rights for
	file mappings from READ_CONTROL to STANDARD_RIGHTS_REQUIRED to allow
	changing the DACL (fixes "access denied" error in pinfo::set_acl).

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Change debug
	output to print mode bits in octal.
	* security.cc (alloc_sd): Ditto.
	(set_file_attribute): Ditto.

2014-08-27  Corinna Vinschen  <corinna@@vinschen.de>

	* ntea.cc (read_ea): Change left-over return to __leave.  Fix
	condition to close handle.  Call NtClose rather than CloseHandle.
	(write_ea): Fix condition to close handle.  Call NtClose rather than
	CloseHandle.
	* security.cc (get_file_sd): Call pc.init_reopen_attr if a valid
	incoming handle was given, pc.get_object_attr otherwise.
	(set_file_sd): Ditto.

2014-08-26  Corinna Vinschen  <corinna@@vinschen.de>

	* path.h (path_conv::init_reopen_attr): Change from void to returning
	POBJECT_ATTRIBUTES.  Take OBJECT_ATTRIBUTES reference as argument, not
	pointer.
	* fhandler_disk_file.cc: Throughout accommodate above change.
	* syscalls.cc: Ditto.
	* ntea.cc (read_ea): Don't set hdl to NULL if it's already NULL.  Set
	attr with pc.init_reopen_attr before trying to reopen file.
	(write_ea): Ditto.
	* security.cc (get_file_sd): Use pc.init_reopen_attr rather than
	pc.get_object_attr when trying to reopen file.
	(set_file_sd): Ditto.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (san::leave/x86_64): Implement.
	* cygtls.h (class tls_pathbuf): Move counter variables into a union.
	Add 64 bit element _counters covering both counter variables to
	optimize save and restore operations.
	(class san/x86_64): Only store single 64 bit value.
	(san::san/x86_64): Implement.
	(san::leave/x86_64): Only declare here, as returns_twice function.
	Explain why.
	(class san/i686): Change type of _c_cnt and _w_cnt to uint32_t.
	(__try/x86_64): Move definition of __sebastian after the first memory
	barrier.  Drop __sebastian.setup call.

2014-08-25  Corinna Vinschen  <corinna@@vinschen.de>

	* cygtls.cc (_cygtls::remove): Revert previous patch.
	*  cygtls.h (struct _local_storage): Move pathbufs back here.
	(class san/x86_64): Revert class.  Save and restore pathbufs counters
	only.
	(class san/i686): Revert saving and restoring pathbufs counters.
	(__try/x86_64): Add a san variable and call it's setup method.
	(__except/x86_64): Call san::leave to restore pathbufs counters.
	* gendef (_sigbe): Revert previous change.
	* thread.cc (verifyable_object_state): Remove gcc 4.7 workaround in
	forward declaration as well.
	* tls_pbuf.cc (tls_pbuf): Revert previous change.
	* tls_pbuf.h (class tmp_pathbuf): Accommodate reverting pathbufs to
	locals structure.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* Throughout, use __try/__except/__endtry blocks, rather than myfault
	handler.
	* cygtls.cc (_cygtls::remove): Accommodate the fact that pathbufs
	has been moved from _local_storage to _cygtls.
	* cygtls.h (class tls_pathbuf): Add comment to hint to gendef usage
	of counters.  Change type of counters to uint32_t for clarity.
	Remove _cygtls as friend class.
	(struct _local_storage): Move pathbufs from here...
	(struct _cygtls): ...to here, allowing to access it from _sigbe.
	(class san): Only define on 32 bit.  Remove errno, _c_cnt and _w_cnt
	members.
	(san::setup): Drop parameter.  Don't initialize removed members.
	(san::leave): Don't set removed members.
	(class myfault): Only define on 32 bit.
	(myfault::faulted): Only keep implementation not taking any parameter.
	Drop argument in call to sebastian.setup.
	(__try/__leave/__except/__endtry): Implement to support real SEH.  For
	now stick to SJLJ on 32 bit.
	* dcrt0.cc (dll_crt0_0): Drop 64 bit call to
	exception::install_myfault_handler.
	* exception.h (exception_handler): Define with EXCEPTION_DISPOSITION
	as return type.
	(PDISPATCHER_CONTEXT): Define as void * on 32 bit.  Define as pointer
	to _DISPATCHER_CONTEXT on 64 bit.
	(class exception): Define separately for 32 and 64 bit.
	(exception::myfault): Add handler for myfault SEH handling on 64 bit.
	(exception::exception): Fix mangled method name to account for change
	in type of last parameter.
	(exception::install_myfault_handler): Remove.
	* exceptions.cc (exception::myfault_handle): Remove.
	(exception::myfault): New SEH handler for 64 bit.
	* gendef (_sigbe): Set tls_pathbuf counters to 0 explicitely when
	returning to the caller.
	* ntdll.h: Move a comment to a better place.
	(struct _SCOPE_TABLE): Define on 64 bit.
	* thread.cc (verifyable_object_isvalid): Remove gcc 4.7 workaround.
	* tls_pbuf.cc (tls_pbuf): Fix to accommodate new place of pathbufs.
	(tls_pathbuf::destroy): Change type of loop variables to uint32_t.
	* tls_pbuf.h (class tmp_pathbuf): Change type of buffer counters to
	uint32_t.  Accommodate new place of pathbufs.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (__import_address): Cover the first dereference to imp
	under the fault handler.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (if_freenameindex): Don't catch a SEGV from free to fail
	loudly on double free.

2014-08-21  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (rmdir): Don't skip deleting fh in the ENOTEMPTY case.

2014-08-20  Corinna Vinschen  <corinna@@vinschen.de>

	* tls_pbuf.h (tmp_pathbuf::tmp_pathbuf): Convert to inline method.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.
	* tls_pbuf.cc (tmp_pathbuf::tmp_pathbuf): Remove here.
	(tmp_pathbuf::~tmp_pathbuf): Ditto.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* dir.cc (dirfd): Per POSIX, return EINVAL on invalid directory stream.
	(telldir): Per POSIX, return -1 and set errno to EBADF, rather than
	just returning 0, on invalid directory stream.
	* signal.cc (sigwaitinfo): Return -1, not EFAULT, when SEGV was catched.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* autoload.cc: Replace WNet[...]A with WNet[...]W imports.
	* dcrt0.cc (initial_env): Drop strlwr calls.  Call strcasestr instead.
	* fhandler_netdrive.cc: Throughout, convert to calling WNet UNICODE
	functions.  Use tmp_pathbuf rather than alloca.  Replace call to
	strlwr with call to RtlDowncaseUnicodeString.

2014-08-19  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (fhandler_serial::is_tty): Reinstantiate.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (strlwr): Rename from cygwin_strlwr.  Drop __stdcall
	decoration.
	(strupr): Rename from cygwin_strupr.  Drop __stdcall decoration.
	* string.h (strlwr): Remove override macro.  Simply declare.
	(strupr): Ditto.

2014-08-18  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::init_std_file_from_handle): Mention that console
	handles are kernel objects since Windows 8.
	* fhandler.h (enum conn_state): Add "listener" state.
	(class fhandler_socket): Drop listener status flag.
	(fhandler_socket::lseek): Return -1 and errno ESPIPE.
	(fhandler_serial::lseek): Ditto.
	(fhandler_serial::is_tty): Remove.
	* fhandler_socket.cc (fhandler_socket::listen): Set connect_state to
	listener.  Add comment.
	(fhandler_socket::accept4): Explicitely check if the socket is listening
	and fail with EINVAL, if not.  Explain why we have to do that.
	(fhandler_socket::getpeereid): Drop now redundant test.

2014-08-15  Corinna Vinschen  <corinna@@vinschen.de>

	* winsup.h (_GNU_SOURCE): Define.  Explain why.

2014-08-14  Corinna Vinschen  <corinna@@vinschen.de>

	* dlmalloc.c: Remove unused file.
	* dlmalloc.h: Ditto.
	* malloc.cc: Update to Doug Lea's malloc version 2.8.6.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 33.
	(CYGWIN_VERSION_API_MINOR): Bump to reflect intermediate 1.7.32 release.

2014-07-21  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/version.h (CYGWIN_VERSION_DLL_MINOR): Bump to 32.

2014-05-06  Corinna Vinschen  <corinna@@vinschen.de>

	* winlean.h (PIPE_REJECT_REMOTE_CLIENTS): Drop temporary definition
	since Mingw64 catched up.
	(DNLEN): Redefine as 16.  Explain why.

2014-03-06  Corinna Vinschen  <corinna@@vinschen.de>

	* setlsapwd.cc (setlsapwd): Use RtlSecureZeroMemory to delete password
	from memory.

2014-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document atexit.

2014-10-28  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwinenv.xml: Change default setting of dosfilewarning.
	* new-features.xml (ov-new1.7.33): Document aforementioned change.

2014-10-27  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Document empty $PATH handling.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* posix.xml (std-gnu): Add ffsl, ffsll, quotactl.
	(std-notes): Add restrictions of quotactl.

2014-10-22  Yaakov Selkowitz  <yselkowi@@redhat.com>

	* new-features.xml (ov-new1.7.33): Document stime.
	* posix.xml (std-deprec): Add stime.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): s/Linux/glibc.

2014-10-22  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Update to current state.

2014-08-13  Corinna Vinschen  <corinna@@vinschen.de>

	* new-features.xml (ov-new1.7.33): Add new section.
	(ov-new1.7.32): Reflect intermediate 1.7.32 release.

2014-10-21  Corinna Vinschen  <corinna@@vinschen.de>

	* cygcheck.cc (CYGLSA64_DLL): Remove unused macro.
	(dump_sysinfo): If COMSPEC isn't set in the MSVCRT environment, set it.
	Explain why.
@
text
@a19 1
#include "shared_info.h"
a46 1
static off_t format_proc_cygdrive (void *, char *&);
a57 1
  { _VN ("cygdrive"),	 FH_PROC,	virt_symlink,	format_proc_cygdrive },
a1180 4
  PWCHAR mp_buf = tp.w_get ();
  WCHAR fpath[MAX_PATH];
  WCHAR gpath[MAX_PATH];
  DWORD len;
d1219 1
a1219 1
	 minimum permissions. */
d1223 3
a1225 2
      wcpcpy (wpart, L"\\Partition0");
      upath.Length = dbi->ObjectName.Length + 22;
d1239 1
a1239 1
	  print ("major minor  #blocks  name   win-mounts\n\n");
d1308 1
a1308 2

	    bufptr += __small_sprintf (bufptr, "%5d %5d %9U %s",
a1310 17
	    /* Check if the partition is mounted in Windows and, if so,
	       print the mount point list. */
	    __small_swprintf (fpath,
			      L"\\\\?\\GLOBALROOT\\Device\\%S\\Partition%u\\",
			      &dbi->ObjectName, part_num);
	    if (GetVolumeNameForVolumeMountPointW (fpath, gpath, MAX_PATH)
		&& GetVolumePathNamesForVolumeNameW (gpath, mp_buf,
						     NT_MAX_PATH, &len))
	      {
		len = strlen (dev.name + 5);
		while (len++ < 6)
		  *bufptr++ = ' ';
		for (PWCHAR p = mp_buf; *p; p = wcschr (p, L'\0') + 1)
		  bufptr += __small_sprintf (bufptr, " %W", p);
	      }

	    *bufptr++ = '\n';
a1331 10
format_proc_cygdrive (void *, char *&destbuf)
{
  destbuf = (char *) crealloc_abort (destbuf, mount_table->cygdrive_len + 1);
  char *dend = stpcpy (destbuf, mount_table->cygdrive);
  if (dend > destbuf + 1)	/* cygdrive != "/"? */
    *--dend = '\0';
  return dend - destbuf;
}

static off_t
@


1.118
log
@	* Merge in cygwin-64bit-branch.
@
text
@d573 1
a573 1
  boot_time = to_time_t ((FILETIME *) &stodi.BootTime.QuadPart);
@


1.117
log
@	* fhandler_proc.cc (format_proc_loadavg): Raise too small buffer size
	to avoid overwriting unrelated cygheap memory.
@
text
@d3 2
a4 2
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013
   Red Hat, Inc.
d39 13
a51 13
static _off64_t format_proc_loadavg (void *, char *&);
static _off64_t format_proc_meminfo (void *, char *&);
static _off64_t format_proc_stat (void *, char *&);
static _off64_t format_proc_version (void *, char *&);
static _off64_t format_proc_uptime (void *, char *&);
static _off64_t format_proc_cpuinfo (void *, char *&);
static _off64_t format_proc_partitions (void *, char *&);
static _off64_t format_proc_self (void *, char *&);
static _off64_t format_proc_mounts (void *, char *&);
static _off64_t format_proc_filesystems (void *, char *&);
static _off64_t format_proc_swaps (void *, char *&);
static _off64_t format_proc_devices (void *, char *&);
static _off64_t format_proc_misc (void *, char *&);
d188 1
a188 1
fhandler_proc::fstat (struct __stat64 *buf)
d380 1
a380 1
  syscall_printf ("%d = fhandler_proc::open(%p, %d)", res, flags, mode);
d396 1
a396 1
static _off64_t
d414 1
a414 1
static _off64_t
d434 1
a434 1
static _off64_t
d460 1
a460 1
static _off64_t
d465 1
a465 1
  SYSTEM_TIME_OF_DAY_INFORMATION stodi;
d480 1
a480 1
		  "status %p", status);
d493 1
a493 1
static _off64_t
d507 1
a507 1
  SYSTEM_TIME_OF_DAY_INFORMATION stodi;
d513 3
a515 2
  SYSTEM_PROCESSOR_TIMES spt[wincap.cpu_count ()];
  status = NtQuerySystemInformation (SystemProcessorTimes, (PVOID) spt,
d518 2
a519 2
    debug_printf ("NtQuerySystemInformation(SystemProcessorTimes), "
		  "status %p", status);
d549 1
a549 1
			", status %p", status);
d556 1
a556 1
		      "status %p", status);
d592 1
a592 1
static _off64_t
d1082 1
a1082 1
static _off64_t
d1102 1
a1102 1
      debug_printf ("NtOpenDirectoryObject, status %p", status);
d1142 2
a1143 5
      /* Up to W2K the handle needs read access to fetch the partition info. */
      status = NtOpenFile (&devhdl, wincap.has_disk_ex_ioctls ()
				    ? READ_CONTROL
				    : READ_CONTROL | FILE_READ_DATA,
			   &attr, &io, FILE_SHARE_VALID_FLAGS, 0);
d1146 1
a1146 1
	  debug_printf ("NtOpenFile(%S), status %p", &upath, status);
d1156 2
a1157 3
      if (wincap.has_disk_ex_ioctls ()
	  && DeviceIoControl (devhdl, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0,
			      ioctl_buf, NT_MAX_PATH, &bytes_read, NULL))
d1179 2
a1180 3
      if (wincap.has_disk_ex_ioctls ()
	  && DeviceIoControl (devhdl, IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
			      NULL, 0, ioctl_buf, NT_MAX_PATH, &bytes_read, NULL))
d1212 1
a1212 7
		/* Pre-W2K you can't rely on the partition number info for
		   unused partitions. */
		if (pi->PartitionType == PARTITION_ENTRY_UNUSED
		    || pi->PartitionType == PARTITION_EXTENDED)
		  part_num = 0;
		else
		  part_num = pi->PartitionNumber;
d1237 1
a1237 1
static _off64_t
d1244 1
a1244 1
static _off64_t
d1251 1
a1251 1
static _off64_t
d1269 1
a1269 1
static _off64_t
d1331 1
a1331 1
static _off64_t
d1375 1
a1375 1
static _off64_t
@


1.116
log
@Throughout, change __attribute__ ((regparm (N))) to just __regN.  Throughout,
(mainly in fhandler*) start fixing gcc 4.7.2 mismatch between regparm
definitions and declarations.
* gendef: Define some functions to take @@ declaration to accommodate _regN
defines which use __stdcall.
* gentls_offsets: Define __regN macros as empty.
* autoload.cc (wsock_init): Remove unneeded regparm attribute.
* winsup.h (__reg1): Define.
(__reg2): Define.
(__reg3): Define.
* advapi32.cc (DuplicateTokenEx): Coerce some initializers to avoid warnings
from gcc 4.7.2.
* exceptions.cc (status_info): Declare struct to use NTSTATUS.
(cygwin_exception::dump_exception): Coerce e->ExceptionCode to NTSTATUS.
* fhandler_clipboard.cc (cygnativeformat): Redefine as UINT to avoid gcc 4.7.2
warnings.
(fhandler_dev_clipboard::read): Ditto.
@
text
@d429 1
a429 1
  destbuf = (char *) crealloc_abort (destbuf, 16);
@


1.115
log
@	Throughout use wincap.allocation_granularity instead of getpagesize.
	Throughout use wincap.page_size instead of getsystempagesize.
	Throughout use "status" as variable name to hold NTSTATUS values.
	* fhandler_mem.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	Fix debug_printf output.  Rectify long statements.  Fix comment
	formatting.
	* fhandler_proc.cc: Ditto.
	(format_proc_swaps): Drop useless test for ERROR_PROC_NOT_FOUND.
	* fhandler_process.cc: Ditto as in fhandler_mem.cc.
	(get_process_state): Rearrange allocation loop.  Use malloc/realloc.
	(get_mem_values): Fix potential NULL pointer usage.  Drop unused
	variable.
	* pinfo.cc (winpids::enum_processes): Handle low memory gracefully.
	* sec_auth.cc (get_priv_list): Drop local variable ret.
	* shared.cc (memory_init): Drop outdated call to getpagesize.
	* syscalls.cc (getsystempagesize): Remove.
	* sysconf.cc: Check for NT_SUCCESS rather than for STATUS_SUCCESS.
	(sysinfo): Constify sizeof_stodi.  Drop useless test for
	ERROR_PROC_NOT_FOUND.
	* thread.cc (pthread_getattr_np): Cast pointers to uintptr_t rather
	than to int for pointer arithmetic.
	* winsup.h (getsystempagesize): Drop declaration.
@
text
@d3 2
a4 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011 Red Hat, Inc.
d187 1
a187 1
int
@


1.115.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d38 13
a50 13
static off_t format_proc_loadavg (void *, char *&);
static off_t format_proc_meminfo (void *, char *&);
static off_t format_proc_stat (void *, char *&);
static off_t format_proc_version (void *, char *&);
static off_t format_proc_uptime (void *, char *&);
static off_t format_proc_cpuinfo (void *, char *&);
static off_t format_proc_partitions (void *, char *&);
static off_t format_proc_self (void *, char *&);
static off_t format_proc_mounts (void *, char *&);
static off_t format_proc_filesystems (void *, char *&);
static off_t format_proc_swaps (void *, char *&);
static off_t format_proc_devices (void *, char *&);
static off_t format_proc_misc (void *, char *&);
d187 1
a187 1
fhandler_proc::fstat (struct stat *buf)
d395 1
a395 1
static off_t
d413 1
a413 1
static off_t
d433 1
a433 1
static off_t
d459 1
a459 1
static off_t
d492 1
a492 1
static off_t
d590 1
a590 1
static off_t
d1080 1
a1080 1
static off_t
d1246 1
a1246 1
static off_t
d1253 1
a1253 1
static off_t
d1260 1
a1260 1
static off_t
d1278 1
a1278 1
static off_t
d1340 1
a1340 1
static off_t
d1384 1
a1384 1
static off_t
@


1.115.2.2
log
@	* cpuid.h (can_set_flag): Implement for x86_64.
	* fhandler.h (class fhandler_dev_raw): Define devbuf members taking
	numerical values as DWORD, rather than size_t.
	* fhandler_dsp.cc: Fix debug printf calls to be type safe.
	(waveOut_callback): Align parameter types to latest MSDN description.
	(waveIn_callback): Ditto.
	(fhandler_dev_dsp::Audio_out::start): Change casts in call to
	waveOutOpen according to MSDN.
	(fhandler_dev_dsp::Audio_out::parsewav): Fix a cast.
	(fhandler_dev_dsp::Audio_in::start): Change casts in call to
	waveInOpen according to MSDN.
	* fhandler_floppy.cc: Fix debug printf calls to be type safe.
	(fhandler_dev_floppy::ioctl): Add casts to be on the safe side.
	* fhandler_proc.cc: Fix debug printf calls to be type safe.
@
text
@d3 1
a3 2
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011,
   2012 Red Hat, Inc.
d379 1
a379 1
  syscall_printf ("%d = fhandler_proc::open(%y, 0%o)", res, flags, mode);
d479 1
a479 1
		  "status %y", status);
d517 1
a517 1
		  "status %y", status);
d547 1
a547 1
			", status %y", status);
d554 1
a554 1
		      "status %y", status);
d1100 1
a1100 1
      debug_printf ("NtOpenDirectoryObject, status %y", status);
d1147 1
a1147 1
	  debug_printf ("NtOpenFile(%S), status %y", &upath, status);
@


1.115.2.3
log
@	* dlfcn.cc (dlopen): Change cast to accommodate type change in ntdll.h
	* fhandler_process.cc (thread_info::thread_info): Change type of local
	variable size to ULONG to match NtQuerySystemInformation call.
	Add cast to avoid compiler warnings.
	(get_process_state): Add cast to avoid compiler warnings.  Accommodate
	name change of NextEntryOffset member of PSYSTEM_PROCESS_INFORMATION
	structure.
	* mmap.cc: Add casts to avoid compiler warnings.
	(mlock): Change type of local variables min and max to match
	GetProcessWorkingSetSize call.
	* nlsfuncs.cc (__collate_range_cmp): Add casts to avoid compiler
	warnings.
	* ntdll.h: Drop accommodations for Mingw32.  Fix a couple of formatting
	glitches.  Add a comment to all structures explicitely tested on 64 bit.
	(SYSTEM_INFORMATION_CLASS): Change SystemProcessesAndThreadsInformation
	to SystemProcessInformation and SystemProcessorTimes to
	SystemProcessorPerformanceInformation to match MSDN.
	(SYSTEM_BASIC_INFORMATION): Fix member types to match 64 bit.
	(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION): Rename from
	SYSTEM_PROCESSOR_TIMES to use official name from MSDN.  Accommodate
	throughout.  Drop unneeded align attribute.
	(VM_COUNTERS): Fix member types to match 64 bit.
	(SYSTEM_PROCESS_INFORMATION): Rename from SYSTEM_PROCESSES to use
	official name from MSDN.  Fix member types to match 64 bit.  Change
	member names to match MSDN and Mingw64.  Accommodate throughout.
	(IO_STATUS_BLOCK): Change to use MSDN definition.
	(SYSTEM_TIMEOFDAY_INFORMATION): Rename from
	SYSTEM_TIME_OF_DAY_INFORMATION to use official name from MSDN.
	Accommodate throughout.  Add Reserved1 area per MSDN.
	(LDR_DATA_TABLE_ENTRY): Add comment for future reference.  Change
	type of LoadCount to USHORT.
	(PEB_LDR_DATA): Change type of Initialized to BOOLEAN.  Add comment for
	future reference.
	(PEB): Fix member types to match 64 bit.
	(GDI_TEB_BATCH): New type.
	(TEB): Fix member types to match 64 bit.
	(PROCESS_BASIC_INFORMATION): Ditto.
	(MEMORY_WORKING_SET_LIST): Ditto.
	(SharedUserData): Change comment to note the fact that the address
	is valid on 32 and 64 bit.
	* pinfo.cc (winpids::enum_processes): Add cast to avoid compiler
	warnings.
	* select.cc (pipe_data_available): Add braces in initalization of an
	IO_STATUS_BLOCK to match new definition.
	* wincap.h (class wincapc): Change type of wow64 to ULONG_PTR to match
	MSDN description.
	(wincapc::is_wow64): Convert return value explicitely to bool.
	* wow64.cc (wow64_test_for_64bit_parent): Change type of wow64 to
	ULONG_PTR to match MSDN description.  Add a cast to avoid compiler
	warning.
	* regex/engine.c: Avoid compiler warnings about unused and potentially
	uninitialized variables.
	* regex/regcomp.c: Ditto.  Drop unnecessary definition of LCID.
@
text
@d465 1
a465 1
  SYSTEM_TIMEOFDAY_INFORMATION stodi;
d507 1
a507 1
  SYSTEM_TIMEOFDAY_INFORMATION stodi;
d513 2
a514 3
  SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION spt[wincap.cpu_count ()];
  status = NtQuerySystemInformation (SystemProcessorPerformanceInformation,
				     (PVOID) spt,
d517 1
a517 1
    debug_printf ("NtQuerySystemInformation(SystemProcessorPerformanceInformation), "
@


1.115.2.4
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011, 2012,
   2013 Red Hat, Inc.
d187 1
a187 1
int __reg2
@


1.115.2.5
log
@	* autoload.cc (AttachConsole): Remove.
	(GetModuleHandleExW): Remove.
	(GetSystemWow64DirectoryW): Remove.
	(GetVolumePathNamesForVolumeNameW): Remove.
	* exceptions.cc (cygwin_stackdump): Always call RtlCaptureContext.
	(exception::handle): Drop accidentally left in debugging statement.
	Always call RtlCaptureContext.
	(sigpacket::process): Always call RtlCaptureContext for current thread.
	* fhandler_disk_file.cc (fstatvfs): Drop code using
	FileFsSizeInformation.
	(struct __DIR_cache): Remove comment.
	(fhandler_disk_file::rewinddir): Drop W2K-only code.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Don't
	check for old OS.  Extend a comment.
	* fhandler_mem.cc (fhandler_dev_mem::open): Drop NT4 and W2K from
	debug output.
	* fhandler_proc.cc (format_proc_partitions): Drop Pre-XP considerations.
	* fhandler_procnet.cc (fhandler_procnet::exists): Ditto.
	(fhandler_procnet::readdir): Ditto.
	(format_procnet_ifinet6): Ditto.
	* fhandler_socket.cc (fhandler_socket::recvmsg): Ditto.
	* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
	* init.cc (dll_entry): Drop W2K-only code.
	* net.cc (get_ifs): Rename from get_xp_ifs.
	(get_2k_ifs): Remove.
	(getifaddrs): Always call get_ifs.
	(get_ifconf): Ditto.
	(if_nametoindex): Drop Pre-XP considerations.
	(load_ipv6_funcs): Ditto.  Fix preceeding comment.
	* sec_auth.cc (lsaauth): Drop code handling fake_login_sid.
	* sec_helper.cc (fake_logon_sid): Remove.
	(set_cygwin_privileges): Fix uncommented statement to drop pre-XP
	considerations.
	* security.h (fake_logon_sid): Drop declaration.
	* shared.cc (shared_info::init_obcaseinsensitive): Drop W2K-only code.
	* wincap.cc: Throughout, remove setting all deprecated wincapc members.
	(wincap_minimal): Set to wincap_xpsp2.
	(wincap_2000): Remove.
	(wincap_2000sp4): Remove.
	(wincap_xp): Remove.
	(wincap_xpsp1): Remove.
	(wincapc::init): Drop OS 5.0 and pre-SP2 XP.
	* wincap.h (struct wincaps): Remove the following members:
	has_create_global_privilege, has_ioctl_storage_get_media_types_ex,
	has_disk_ex_ioctls, has_buggy_restart_scan, needs_logon_sid_in_sid_list,
	has_gaa_prefixes, has_recvmsg, has_stack_size_param_is_a_reservation,
	kernel_is_always_casesensitive, has_rtl_capture_context.
@
text
@d1142 5
a1146 2
      status = NtOpenFile (&devhdl, READ_CONTROL, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, 0);
d1159 3
a1161 2
      if (DeviceIoControl (devhdl, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0,
			   ioctl_buf, NT_MAX_PATH, &bytes_read, NULL))
d1183 3
a1185 2
      if (DeviceIoControl (devhdl, IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
			   NULL, 0, ioctl_buf, NT_MAX_PATH, &bytes_read, NULL))
d1217 7
a1223 1
		part_num = pi->PartitionNumber;
@


1.115.2.6
log
@Pull in change from HEAD
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
d429 1
a429 1
  destbuf = (char *) crealloc_abort (destbuf, 48);
@


1.114
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@d463 1
a463 1
  NTSTATUS ret;
d473 3
a475 3
  ret = NtQuerySystemInformation (SystemTimeOfDayInformation, &stodi,
				  sizeof stodi, NULL);
  if (NT_SUCCESS (ret))
d479 1
a479 1
		  "status %p", ret);
d498 1
a498 1
  NTSTATUS ret;
d513 3
a515 3
  ret = NtQuerySystemInformation (SystemProcessorTimes, (PVOID) spt,
				  sizeof spt[0] * wincap.cpu_count (), NULL);
  if (!NT_SUCCESS (ret))
d517 1
a517 1
		  "status %p", ret);
d542 3
a544 3
      ret = NtQuerySystemInformation (SystemPerformanceInformation,
				      (PVOID) spi, sizeof_spi, NULL);
      if (!NT_SUCCESS (ret))
d547 1
a547 1
			", status %p", ret);
d550 3
a552 4
      ret = NtQuerySystemInformation (SystemTimeOfDayInformation,
				      (PVOID) &stodi,
				      sizeof stodi, NULL);
      if (!NT_SUCCESS (ret))
d554 1
a554 1
		      "status %p", ret);
d556 1
a556 1
  if (!NT_SUCCESS (ret))
d558 1
a558 1
      __seterrno_from_nt_status (ret);
d564 4
a567 7
  /*
   * Note: there is no distinction made in this structure between pages
   * read from the page file and pages read from mapped files, but there
   * is such a distinction made when it comes to writing. Goodness knows
   * why. The value of swap_in, then, will obviously be wrong but its our
   * best guess.
   */
d704 1
a704 1
	  // vendor identification
d745 1
a745 1
		  // could implement a lookup table here if someone needs it
d752 1
a752 1
	      if (features1 & (1 << 19)) // CLFSH
d756 1
a756 1
	      if (maxe >= 0x80000005) // L1 Cache and TLB Identifiers
d765 1
a765 1
	      if (maxe >= 0x80000006) // L2 Cache and L2 TLB Identifiers
d787 1
a787 1
	      // Recognize multi-core CPUs
d809 1
a809 1
	      // Recognize Intel Hyper-Transport CPUs
d894 1
a894 1
		  if (features & (1 << 19)) // Huh?  Not in AMD64 specs.
d908 1
a908 1
		  if (features & (1 << 30)) // 31th bit is on
d910 1
a910 1
		  if (features & (1 << 31)) // 32th bit (highest) is on
d1023 1
a1023 1
	      if (maxe >= 0x80000008) // Address size
d1039 1
a1039 1
	      if (maxe >= 0x80000007) // advanced power management
d1286 1
a1286 1
  NTSTATUS ret = STATUS_SUCCESS;
d1295 3
a1297 3
      ret = NtQuerySystemInformation (SystemPagefileInformation, (PVOID) spi,
				      size, &size);
      if (ret == STATUS_INFO_LENGTH_MISMATCH)
d1302 2
a1303 2
	    ret = NtQuerySystemInformation (SystemPagefileInformation,
					    (PVOID) spi, size, &size);
d1310 1
a1310 1
  if (spi && !ret && GetLastError () != ERROR_PROC_NOT_FOUND)
d1315 2
a1316 2
	  total = (unsigned long long) spp->CurrentSize * getsystempagesize ();
	  used = (unsigned long long) spp->TotalUsed * getsystempagesize ();
d1318 2
a1319 1
	  filename_len = cygwin_conv_path (CCP_WIN_W_TO_POSIX, spp->FileName.Buffer, filename, 0);
d1321 2
a1322 1
	  cygwin_conv_path (CCP_WIN_W_TO_POSIX, spp->FileName.Buffer, filename, filename_len);
d1329 1
a1329 1
			   ((char *) spp + spp->NextEntryOffset)));
@


1.113
log
@Throughout change TTY_* to PTY_*, tty_* to pty_*, and ttym_* to ptmx_*.
* devices.cc: Regenerate.
* dtable.cc: (fh_alloc): Preserve /dev/tty name when that's what we opened.
(build_fh_pc): Preserve any existing name.
* fhandler.cc (fhandler_base::open_with_arch): Ditto.
* fhandler_tty.cc (fhandler_pty_master::fhandler_pty_master): Force the name to
/dev/ptmx while preserving other pty master device information.
* path.h (cfree_maybe): New macro.
(path_conv::operator =): Free any allocated strings in target.
(path_conv::free_strings): Delete unused function.
* sigproc.cc (proc_terminate): Remove previous accommodation for execed
processes since it didn't have the desired effect.  Change comment to a FIXME.
* spawn.cc (chExeced): Mark NO_COPY.
(exe_suffixes): Ditto.
@
text
@d272 1
a272 1
  syscall_printf ("%d = readdir (%p, %p) (%s)", res, dir, de, de->d_name);
d379 1
a379 1
  syscall_printf ("%d = fhandler_proc::open (%p, %d)", res, flags, mode);
@


1.112
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d1376 1
a1376 1
			     DEV_SERIAL_MAJOR, DEV_TTYS_MAJOR, DEV_FLOPPY_MAJOR,
@


1.111
log
@* devices.h (fh_devices): Define DEV_MISC_MAJOR, DEV_MEM_MAJOR,
DEV_SOUND_MAJOR.  Use throughout.
* fhandler_proc.cc (proc_tab): Add /proc/devices and /proc/misc
virtual files.
(format_proc_devices): New function.
(format_proc_misc): New function.
@
text
@d1374 1
a1374 1
			     _major (FH_CONSOLE), _major (FH_PTYM),
@


1.110
log
@	* fhandler_proc.cc (fhandler_proc::closedir): Don't free, but delete
	instead.

	Also fix previous ChangeLog entry.
@
text
@d49 2
d57 1
d61 1
d1342 61
@


1.109
log
@	* fhandler.h (fhandler_proc::opendir): Declare.
	(fhandler_proc::closedir): Declare.
	* fhandler_proc.cc (fhandler_proc::opendir): New method.  Fetch list
	of active processes here once to avoid potential duplicates.
	(fhandler_proc::closedir): New method.
@
text
@d239 1
a239 1
  free (dir->__handle);
@


1.108
log
@	* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Don't allow to
	access process info by using the Windows PID.
	* fhandler_process.cc (fhandler_process::fstat): Ditto.
	(fhandler_process::fill_filebuf): Ditto.
@
text
@d223 20
d255 1
a255 1
      winpids pids ((DWORD) 0);
@


1.107
log
@Rename FH_BAD to FH_NADA throughout.
* devices.h (FH_ERROR): New value.
(iscons_dev): Extend to detect all the console device types.
* devices.in: Set aside storage for FH_ERROR.
* dtable.cc (dtable::init_std_file_from_handle): Use iscons_dev to detect when
device is a console.
(fh_alloc): Pass device to console constructor.
(build_fh_pc): Short circuit when we detect that the constructor saw an error.
* fhandler.h (fhandler_console::fhandler_console): Accept fh_devices parameter.
(get_tty_stuff): Change to void.
* fhandler_console (fhandler_console::set_unit): Set device to FH_ERROR on
attempt to access anything other than the current console.
(fhandler_console::get_tty_stuff): Change to void return.
(fhandler_console::open): Return EPERM on FH_ERROR device type.
(fhandler_console::fhandler_console): Set the device type appropriately before
calling get_tty_stuff and rely on that function to reset it if necessary.
@
text
@d131 7
a137 1
  if (pinfo (atoi (path)))
@


1.106
log
@whitespace elimination
@
text
@d71 1
a71 1
  { NULL, 0,	   	 FH_BAD,	virt_none,	NULL }
d99 1
a99 1
  virt_tab_t key = { path, 0, FH_BAD, virt_none, NULL };
d144 1
a144 1
    return FH_BAD;
@


1.105
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@d394 2
a395 2
        running++;
        break;
d517 1
a517 1
	  		", status %p", ret);
d1244 2
a1245 2
                              fs_names[i].block_device ? "" : "nodev",
                              fs_names[i].name);
d1282 1
a1282 1
                             "Filename\t\t\t\tType\t\tSize\tUsed\tPriority\n");
d1297 1
a1297 1
	                     filename, "file", total >> 10, used >> 10, 0);
@


1.104
log
@* fhandler_proc.cc (format_proc_meminfo): Rewrite to use sysinfo().
Support RAM and swap space larger than 4GB.
Remove output elements not found with modern Linux kernels.
(format_proc_swaps): Support paging files larger than 4GB.
@
text
@d71 1
a71 1
  { NULL, 0,	   	 0,		virt_none,	NULL }
d99 1
a99 1
  virt_tab_t key = { path, 0, 0, virt_none, NULL };
d111 1
a111 1
DWORD
d1152 1
a1152 1
				 dev.major, dev.minor,
d1205 1
a1205 1
				       dev.major, dev.minor,
@


1.103
log
@	* fhandler_proc.cc (format_proc_uptime): Don't call GetSystemInfo.
	Fetch CPU count from wincap.
	(format_proc_stat): Ditto.
	* globals.cc (system_info): Move to wincap.
	* heap.cc (heap_init): Fetch page size from wincap.
	* syscalls.cc (getpagesize): Fetch allocation granularity from wincap.
	(getsystempagesize): Fetch page size from wincap.
	* wincap.cc (wincap_2003): Default is_server to false.
	(wincapc::init): Call GetSystemInfo here.  Always set is_server value.
	* wincap.h (class wincapc): Add system_info as private member.
	(wincapc::cpu_count): New public method.
	(wincapc::page_size): Ditto.
	(wincapc::allocation_granularity): Ditto.
@
text
@d27 1
d406 8
a413 9
  unsigned long mem_total = 0UL, mem_free = 0UL, swap_total = 0UL,
		swap_free = 0UL;
  MEMORYSTATUS memory_status;
  GlobalMemoryStatus (&memory_status);
  mem_total = memory_status.dwTotalPhys;
  mem_free = memory_status.dwAvailPhys;
  PSYSTEM_PAGEFILE_INFORMATION spi = NULL;
  ULONG size = 512;
  NTSTATUS ret = STATUS_SUCCESS;
a414 34
  spi = (PSYSTEM_PAGEFILE_INFORMATION) malloc (size);
  if (spi)
    {
      ret = NtQuerySystemInformation (SystemPagefileInformation, (PVOID) spi,
				      size, &size);
      if (ret == STATUS_INFO_LENGTH_MISMATCH)
	{
	  free (spi);
	  spi = (PSYSTEM_PAGEFILE_INFORMATION) malloc (size);
	  if (spi)
	    ret = NtQuerySystemInformation (SystemPagefileInformation,
					    (PVOID) spi, size, &size);
	}
    }
  if (!spi || ret || (!ret && GetLastError () == ERROR_PROC_NOT_FOUND))
    {
      swap_total = memory_status.dwTotalPageFile - mem_total;
      swap_free = memory_status.dwAvailPageFile - mem_total;
    }
  else
    {
      PSYSTEM_PAGEFILE_INFORMATION spp = spi;
      do
	{
	  swap_total += spp->CurrentSize * getsystempagesize ();
	  swap_free += (spp->CurrentSize - spp->TotalUsed)
		       * getsystempagesize ();
	}
      while (spp->NextEntryOffset
	     && (spp = (PSYSTEM_PAGEFILE_INFORMATION)
			   ((char *) spp + spp->NextEntryOffset)));
    }
  if (spi)
    free (spi);
d416 11
a426 17
  return __small_sprintf (destbuf, "         total:      used:      free:\n"
				   "Mem:  %10lu %10lu %10lu\n"
				   "Swap: %10lu %10lu %10lu\n"
				   "MemTotal:     %10lu kB\n"
				   "MemFree:      %10lu kB\n"
				   "MemShared:             0 kB\n"
				   "HighTotal:             0 kB\n"
				   "HighFree:              0 kB\n"
				   "LowTotal:     %10lu kB\n"
				   "LowFree:      %10lu kB\n"
				   "SwapTotal:    %10lu kB\n"
				   "SwapFree:     %10lu kB\n",
				   mem_total, mem_total - mem_free, mem_free,
				   swap_total, swap_total - swap_free, swap_free,
				   mem_total >> 10, mem_free >> 10,
				   mem_total >> 10, mem_free >> 10,
				   swap_total >> 10, swap_free >> 10);
d1255 1
a1255 1
  unsigned long total = 0UL, used = 0UL;
d1289 2
a1290 2
	  total = spp->CurrentSize * getsystempagesize ();
	  used = spp->TotalUsed * getsystempagesize ();
d1296 1
a1296 1
	  bufptr += sprintf (bufptr, "%-40s%-16s%-8ld%-8ld%-8d\n",
@


1.102
log
@	* fhandler_proc.cc (read_value): Remove definition.
	(print): Simplify.
	(format_proc_cpuinfo): Drop useless call to GetSystemInfo.  Rearrange
	to use Rtl registry functions.  Rename dwOldThreadAffinityMask to
	orig_affinity_mask.
@
text
@a482 3
  if (!system_info.dwNumberOfProcessors)
    GetSystemInfo (&system_info);

d493 1
a493 1
    idle_time = (spi->IdleTime.QuadPart / system_info.dwNumberOfProcessors)
d522 1
a522 4
  if (!system_info.dwNumberOfProcessors)
    GetSystemInfo (&system_info);

  SYSTEM_PROCESSOR_TIMES spt[system_info.dwNumberOfProcessors];
d524 1
a524 1
				  sizeof spt[0] * system_info.dwNumberOfProcessors, NULL);
d531 1
a531 1
      for (unsigned long i = 0; i < system_info.dwNumberOfProcessors; i++)
d542 1
a542 1
      for (unsigned long i = 0; i < system_info.dwNumberOfProcessors; i++)
@


1.101
log
@* fhandler_proc.cc (proc_tab): Add /proc/swaps virtual file.
(format_proc_swaps): New function.
@
text
@d608 1
a608 21
#define read_value(x,y) \
      do {\
	dwCount = BUFSIZE; \
	if ((dwError = RegQueryValueEx (hKey, x, NULL, &dwType, in_buf.b, &dwCount)), \
	    (dwError != ERROR_SUCCESS && dwError != ERROR_MORE_DATA)) \
	  { \
	    debug_printf ("RegQueryValueEx failed retcode %d", dwError); \
	    return 0; \
	  } \
	if (dwType != y) \
	  { \
	    debug_printf ("Value %s had an unexpected type (expected %d, found %d)", y, dwType); \
	    return 0; \
	  }\
      } while (0)

#define print(x) \
	do { \
	  strcpy (bufptr, x), \
	  bufptr += sizeof (x) - 1; \
	} while (0)
d613 1
a613 4
  SYSTEM_INFO siSystemInfo;
  HKEY hKey;
  DWORD dwError, dwCount, dwType;
  DWORD dwOldThreadAffinityMask;
d620 1
a628 1
  GetSystemInfo (&siSystemInfo);
d631 5
d639 3
a641 12
      __small_sprintf (in_buf.s, "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\%d", cpu_number);

      if ((dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, in_buf.s, 0, KEY_QUERY_VALUE, &hKey)) != ERROR_SUCCESS)
	{
	  if (dwError == ERROR_FILE_NOT_FOUND)
	    break;
	  debug_printf ("RegOpenKeyEx failed retcode %d", dwError);
	  return 0;
	}

      dwOldThreadAffinityMask = SetThreadAffinityMask (GetCurrentThread (), 1 << cpu_number);
      if (dwOldThreadAffinityMask == 0)
d643 3
a645 2
      // I'm not sure whether the thread changes processor immediately
      // and I'm not sure whether this function will cause the thread to be rescheduled
a663 1

d666 23
a688 8
	  bufptr += __small_sprintf (bufptr, "processor       : %d\n", cpu_number);
	  read_value ("VendorIdentifier", REG_SZ);
	  bufptr += __small_sprintf (bufptr, "vendor_id       : %s\n", in_buf.s);
	  read_value ("Identifier", REG_SZ);
	  bufptr += __small_sprintf (bufptr, "identifier      : %s\n", in_buf.s);
	  read_value ("~Mhz", REG_DWORD);
	  bufptr += __small_sprintf (bufptr, "cpu MHz         : %u\n", in_buf.d);

d709 9
a732 2
	  read_value ("~Mhz", REG_DWORD);
	  unsigned cpu_mhz = in_buf.d;
d1090 4
a1093 6
      if (dwOldThreadAffinityMask != 0)
	SetThreadAffinityMask (GetCurrentThread (), dwOldThreadAffinityMask);

      RegCloseKey (hKey);
      bufptr += __small_sprintf (bufptr, "\n");
  }
a1099 2
#undef read_value

@


1.100
log
@	Drop NT4 support.
	* autoload.cc (DnsQuery_A): Fatal if not available.
	(DnsRecordListFree): Ditto.
	(DsGetDcNameW): Ditto.
	(NetGetAnyDCName): Remove.
	(NetGetDCName): Remove.
	(EnumProcessModules): Fatal if not available.
	(GetModuleFileNameExW): Ditto.
	(GetModuleInformation): Ditto.
	(GetProcessMemoryInfo): Ditto.
	(QueryWorkingSet): Ditto.
	(LsaRegisterLogonProcess): Ditto.
	* fenv.cc (_feinitialise): Drop supports_sse condition.
	* fhandler_disk_file.cc (path_conv::isgood_inode): Fix comment.
	(fhandler_base::fstat_by_name): Drop has_fileid_dirinfo condition.
	(fhandler_disk_file::opendir): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Fix comment.
	* fhandler_proc.cc (format_proc_partitions): Drop NT4-only code.
	* fhandler_process.cc (get_process_state): Ditto.
	* kernel32.cc (GetWindowsDirectoryW): Remove.
	(GetWindowsDirectoryA): Remove.
	* miscfuncs.cc (nice_to_winprio): Drop NT4-only code.
	* mount.cc (fs_info::update): Fix comments.
	* net.cc (get_2k_ifs): Drop NT4-only code.
	* sec_auth.cc (get_logon_server): Ditto.
	(lsaauth): Drop NT4-specific error handling.
	* security.cc (alloc_sd): Set SE_DACL_PROTECTED unconditionally.
	* select.cc (select_stuff::wait): Always use MWMO_INPUTAVAILABLE.
	(peek_windows): Drop NT4-only condition in call to PeekMessage.
	* syscalls.cc (gethostid): Remove NT4-only workaround.
	* wincap.cc: Througout, drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse from
	wincaps.
	(wincap_nt4sp4): Remove.
	(wincap_minimal): Set to wincap_2000.
	(wincapc::init): Rely on availability of OSVERSIONINFOEX structure.
	Treat error from GetVersionEx as fatal.  Treat NT4 as fatal.
	* wincap.h (struct wincaps): Drop has_dacl_protect,
	has_broken_if_oper_status, has_process_io_counters,
	has_terminal_services, has_extended_priority_class, has_guid_volumes,
	has_fileid_dirinfo, has_mwmo_inputavailable and supports_sse flags
	and methods.
	* winlean.h (GetWindowsDirectoryW) Define as GetSystemWindowsDirectoryW.
	(GetWindowsDirectoryA): Define as GetSystemWindowsDirectoryA.
@
text
@d15 1
d47 1
d65 1
d1307 60
@


1.99
log
@* Makefile.in (fhandler_proc_CFLAGS): Define USERNAME, HOSTNAME,
and GCC_VERSION.
* fhandler_proc.cc (format_proc_version):  Add build machine and GCC
version information as on Linux.
@
text
@a1195 11
      else if (DeviceIoControl (devhdl, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
				ioctl_buf, NT_MAX_PATH, &bytes_read, NULL))
	{
	  /* NT4 doesn't support to call IOCTL_DISK_GET_PARTITION_INFO for the
	     entire drive. */
	  DISK_GEOMETRY *dg = (DISK_GEOMETRY *) ioctl_buf;
	  size = (unsigned long long) dg->Cylinders.QuadPart
				      * dg->TracksPerCylinder
				      * dg->SectorsPerTrack
				      * dg->BytesPerSector;
	}
@


1.98
log
@	* fhandler_proc.cc (format_proc_partitions): Express length in WCHAR
	size.
@
text
@d364 3
d370 7
a376 6
  destbuf = (char *) crealloc_abort (destbuf, strlen (uts_name.sysname)
					      + strlen (uts_name.release)
					      + strlen (uts_name.version)
					      + 4);
  return __small_sprintf (destbuf, "%s %s %s\n",
			  uts_name.sysname, uts_name.release, uts_name.version);
@


1.97
log
@Implement /proc/sysvipc/*
* devices.in (dev_procsysvipc_storage): Add.
* devices.cc: Regenerate.
* devices.h (fh_devices): Add FH_PROCSYSVIPC.
* dtable.cc (build_fh_pc): Add case FH_PROCSYSVIPC.
* fhandler.h (class fhandler_procsysvipc): Declare.
(fhandler_union): Add __procsysvipc.
* fhandler_proc.cc (proc_tab): Add sysvipc virt_directory.
* fhandler_procsysvipc.cc: New file.
* Makefile.in (DLL_OFILES): Add fhandler_procsysvipc.o.
* path.h (isproc_dev): Add FH_PROCSYSVIPC to conditional.
@
text
@d1146 1
a1146 1
      if (dbi->ObjectName.Length < 18
@


1.96
log
@* fhandler_proc.cc (format_proc_loadavg): Add running/total
processes as fourth component of output.
* fhandler_process.cc (get_process_state): Make non-static.
Add FIXME about generating an 'O' flag.
@
text
@d64 1
@


1.95
log
@	* fhandler_proc.cc (format_proc_partitions): Fix compiler warning.
@
text
@d377 12
d390 2
a391 2
  return __small_sprintf (destbuf, "%u.%02u %u.%02u %u.%02u\n",
				    0, 0, 0, 0, 0, 0);
@


1.94
log
@	* fhandler_proc.cc (proc_tab_cmp): Fix typo in comment.
	(fhandler_proc::fill_filebuf): Handle return value of 0 from format
	function as error.
	(format_proc_stat): Set errno when returning 0 size.
	(format_proc_partitions): Rewrite method to fetch partition info.
@
text
@d1127 1
a1127 1
      DWORD part_cnt;
@


1.93
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procsys.o.
	* devices.h (enum fh_devices): Add FH_PROCSYS.
	* devices.in (dev_procsys_storage): New device.
	* devices.cc: Regenerate.
	* dtable.cc (build_fh_pc): Add code to allocate fhandler_procsys.
	* fhandler.h (proc_len): Convert to size_t.
	(procsys): Declare.
	(procsys_len): Declare.
	(enum virtual_ftype_t): Move here from fhandler_virtual.h.
	Add members supported by fhandler_procsys.
	(fhandler_virtual::exists): Return virtual_ftype_t.  Change
	in all derived classes.
	(class fhandler_procsys): New class.
	(fhandler_union): Add fhandler_procnet and fhandler_procsys members.
	* fhandler_disk_file.cc (__DIR_mounts::check_missing_mount): Use
	ro_u_proc.
	(fhandler_base::fstat_by_handle): Don't copy attributes if file is an
	NT device.
	(fhandler_base::fstat_by_name): Ditto.
	* fhandler_netdrive.cc (fhandler_netdrive::exists): Return
	virtual_ftype_t.
	* fhandler_proc.cc (proc_tab): Sort alphabetically.  Use _VN macro
	to store length.
	(proc_len): Change to size_t.
	(proc_tab_cmp): New static function.
	(virt_tab_search): New function to search entry in virt_tab_t
	arrays.  Use throughout in /proc and sibling classes instead of
	loop.
	(fhandler_proc::exists): Return virtual_ftype_t.
	* fhandler_process.cc (process_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_process::exists): Return virtual_ftype_t.
	(fhandler_process::open): Simplify code.
	* fhandler_procnet.cc (procnet_tab): Sort alphabetically.  Use _VN
	macro to store length.
	(fhandler_procnet::exists): Return virtual_ftype_t.
	(fhandler_procnet::open): Simplify.
	* fhandler_procsys.cc: New file.
	* fhandler_registry.cc (fhandler_registry::exists): Return
	virtual_ftype_t.
	* fhandler_virtual.cc (fhandler_virtual::exists): Ditto.
	* fhandler_virtual.h (enum virtual_ftype_t): Move to fhandler.h.
	(virt_tab_t): Add name_len member.
	(_VN): New macro.
	(virt_tab_search): Declare.
	* mount.cc (mount_info::conv_to_win32_path): Fix comment.  Backslashify
	isprocsys_dev paths.
	* ntdll.h (STATUS_OBJECT_TYPE_MISMATCH): Define
	(STATUS_INSTANCE_NOT_AVAILABLE): Define.
	(STATUS_PIPE_NOT_AVAILABLE): Define.
	(STATUS_INVALID_PIPE_STATE): Define.
	(STATUS_PIPE_BUSY): Define.
	(SYMBOLIC_LINK_QUERY): Define.
	(NtOpenSymbolicLinkObject): Declare.
	(NtQuerySymbolicLinkObject): Declare.
	* path.cc (path_conv::check): Accommodate fact that exists method
	returns virtual_ftype_t now.  Add cases for new virtual_ftype_t
	types.
	(cygwin_conv_path): Add GLOBALROOT prefix to native device paths.
	Make sure to strip \\?\ prefix only for actual filesystem-based
	paths, not for all paths.
	* path.h (isproc_dev): Add FH_PROCSYS.
	(isprocsys_dev): Define.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010 Red Hat, Inc.
a26 1
#include <ctype.h>
d29 1
d88 1
a88 1
/* Helper function to perform a binary search of  the incoming pathname
d354 2
a355 1
      return true;
d554 4
a557 1
    return 0;
a1091 1
  char devname[NAME_MAX + 1];
a1092 1
  HANDLE dirhdl, devhdl;
d1095 1
d1100 1
d1110 1
a1113 1
  print ("major minor  #blocks  name\n\n");
d1118 1
d1123 8
a1131 2
      sys_wcstombs (devname, NAME_MAX + 1, dbi->ObjectName.Buffer,
		    dbi->ObjectName.Length / 2);
d1133 3
a1135 3
      if (!strncasematch (devname, "Harddisk", 8)
	  || dbi->ObjectName.Length < 18
	  || !isdigit (devname[8]))
d1137 111
a1247 25
      /* Construct path name for partitions, starting with 0, which is the
	 whole disk, and try to open.
	 Note that the correct way to do this would be to open the HarddiskX
	 directory and enumerate the Partition entries.  However, while the
	 partition entries itself are accessible for query by everyone, the
	 HarddiskX parent directory is only queryable by SYSTEM and Admins.
	 This way we circumvent this nonsensical restriction.  Let's assume
	 we never have more than 99 partitions per disk for now... */
      for (int part_num = 0; part_num < 99; ++part_num)
	{
	  wcscpy (wpath, dbi->ObjectName.Buffer);
	  __small_swprintf (wpath + dbi->ObjectName.Length / 2,
			    L"\\Partition%d", part_num);
	  upath.Length = 22 + dbi->ObjectName.Length;
	  upath.MaximumLength = upath.Length + 2;
	  InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE,
				      dirhdl, NULL);
	  status = NtOpenFile (&devhdl, READ_CONTROL, &attr, &io,
			       FILE_SHARE_VALID_FLAGS, 0);
	  if (!NT_SUCCESS (status))
	    {
	      if (status == STATUS_OBJECT_NAME_NOT_FOUND
		  || status == STATUS_OBJECT_PATH_NOT_FOUND)
		break;
	      debug_printf ("NtOpenFile(%s), status %p", devname, status);
d1249 6
a1254 47
	    }

	  /* Use a buffer since some ioctl buffers aren't fixed size. */
	  char buf[256];
	  PARTITION_INFORMATION *pi = NULL;
	  PARTITION_INFORMATION_EX *pix = NULL;
	  DISK_GEOMETRY *dg = NULL;
	  DWORD bytes;
	  unsigned long drive_number = strtoul (devname + 8, NULL, 10);
	  unsigned long long size;

	  if (wincap.has_disk_ex_ioctls ()
	      && DeviceIoControl (devhdl, IOCTL_DISK_GET_PARTITION_INFO_EX,
				  NULL, 0, buf, 256, &bytes, NULL))
	    {
	      pix = (PARTITION_INFORMATION_EX *) buf;
	      size = pix->PartitionLength.QuadPart;
	    }
	  else if (DeviceIoControl (devhdl, IOCTL_DISK_GET_PARTITION_INFO,
				    NULL, 0, buf, 256, &bytes, NULL))
	    {
	      pi = (PARTITION_INFORMATION *) buf;
	      size = pi->PartitionLength.QuadPart;
	    }
	  else if (DeviceIoControl (devhdl, IOCTL_DISK_GET_DRIVE_GEOMETRY,
				    NULL, 0, buf, 256, &bytes, NULL))
	    {
	      dg = (DISK_GEOMETRY *) buf;
	      size = (unsigned long long) dg->Cylinders.QuadPart
			   * dg->TracksPerCylinder
			   * dg->SectorsPerTrack
			   * dg->BytesPerSector;
	    }
	  else
	    size = 0;
	  if (!pi && !pix && !dg)
	    debug_printf ("DeviceIoControl %E");
	  else
	    {
	      device dev;
	      dev.parsedisk (drive_number, part_num);
	      bufptr += __small_sprintf (bufptr, "%5d %5d %9U %s\n",
					 dev.major, dev.minor,
					 size >> 10, dev.name + 5);
	    }
	  NtClose (devhdl);
	}
d1258 3
@


1.92
log
@	* fhandler_proc.cc (format_proc_partitions): Improve comment.
@
text
@d49 18
a66 17
  { ".",	  FH_PROC,	virt_directory,	NULL },
  { "..",	  FH_PROC,	virt_directory,	NULL },
  { "loadavg",	  FH_PROC,	virt_file,	format_proc_loadavg },
  { "meminfo",	  FH_PROC,	virt_file,	format_proc_meminfo },
  { "registry",	  FH_REGISTRY,	virt_directory,	NULL  },
  { "stat",	  FH_PROC,	virt_file,	format_proc_stat },
  { "version",	  FH_PROC,	virt_file,	format_proc_version },
  { "uptime",	  FH_PROC,	virt_file,	format_proc_uptime },
  { "cpuinfo",	  FH_PROC,	virt_file,	format_proc_cpuinfo },
  { "partitions", FH_PROC,	virt_file,	format_proc_partitions },
  { "self",	  FH_PROC,	virt_symlink,	format_proc_self },
  { "mounts",	  FH_PROC,	virt_symlink,	format_proc_mounts },
  { "registry32", FH_REGISTRY,	virt_directory,	NULL },
  { "registry64", FH_REGISTRY,	virt_directory,	NULL },
  { "net",	  FH_PROCNET,	virt_directory,	NULL },
  { "filesystems", FH_PROC,	virt_file,	format_proc_filesystems },
  { NULL,	  0,		virt_none,	NULL }
d75 1
a75 1
const int proc_len = sizeof (proc) - 1;
d77 29
a105 3
/* Auxillary function that returns the fhandler associated with the given path
   this is where it would be nice to have pattern matching in C - polymorphism
   just doesn't cut it. */
d121 4
a124 6
  for (int i = 0; proc_tab[i].name; i++)
    {
      if (path_prefix_p (proc_tab[i].name, path, strlen (proc_tab[i].name),
			 false))
	return proc_tab[i].fhandler;
    }
d148 1
a148 1
int
d156 7
a162 6
  for (int i = 0; proc_tab[i].name; i++)
    if (!strcmp (path + 1, proc_tab[i].name))
      {
	fileid = i;
	return proc_tab[i].type;
      }
d192 15
a206 15
      path++;
      for (int i = 0; proc_tab[i].name; i++)
	if (!strcmp (path, proc_tab[i].name))
	  {
	    if (proc_tab[i].type == virt_directory)
	      buf->st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
	    else if (proc_tab[i].type == virt_symlink)
	      buf->st_mode = S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;
	    else
	      {
		buf->st_mode &= NO_X;
		buf->st_mode |= S_IFREG;
	      }
	    return 0;
	  }
@


1.91
log
@	* fhandler_proc.cc (format_proc_partitions): Simplify code and enable
	partition layout printing for non-privileged users.
@
text
@d1101 7
a1107 2
	 whole disk, and try to open.  Let's assume we never have more than
	 99 partitions per disk for now... */
@


1.90
log
@	* fhandler_proc.cc: Add /proc/filesystems virtual file.
	(format_proc_filesystems): New function.
	* mount.cc (fs_names): Move to global scope. Redefine as array
	of { "name", block_device? } structs.
	(fillout_mntent): Use name member of fs_names.
	* mount.h (fs_names): New prototype.
@
text
@d1100 12
a1111 17
      /* Construct path name for partition 0, which is the whole disk,
	 and try to open. */
      wcscpy (wpath, dbi->ObjectName.Buffer);
      wcscpy (wpath + dbi->ObjectName.Length / 2, L"\\Partition0");
      upath.Length = 22 + dbi->ObjectName.Length;
      upath.MaximumLength = upath.Length + 2;
      InitializeObjectAttributes (&attr, &upath, OBJ_CASE_INSENSITIVE,
				  dirhdl, NULL);
      status = NtOpenFile (&devhdl, READ_CONTROL | FILE_READ_DATA, &attr, &io,
			   FILE_SHARE_VALID_FLAGS, 0);
      if (!NT_SUCCESS (status))
	{
	  /* Retry with READ_CONTROL only for non-privileged users.  This
	     at least prints the Partition0 info, but it doesn't allow access
	     to the drive's layout information.  It beats me, though, why
	     a non-privileged user shouldn't get read access to the drive
	     layout information. */
d1116 3
a1121 1
	}
d1123 18
a1140 52
      /* Use a buffer since some ioctl buffers aren't fixed size. */
      char buf[256];
      PARTITION_INFORMATION *pi = NULL;
      PARTITION_INFORMATION_EX *pix = NULL;
      DISK_GEOMETRY *dg = NULL;
      DWORD bytes;
      unsigned long drive_number = strtoul (devname + 8, NULL, 10);
      unsigned long long size;

      if (wincap.has_disk_ex_ioctls ()
	  && DeviceIoControl (devhdl, IOCTL_DISK_GET_PARTITION_INFO_EX,
			      NULL, 0, buf, 256, &bytes, NULL))
	{
	  pix = (PARTITION_INFORMATION_EX *) buf;
	  size = pix->PartitionLength.QuadPart;
	}
      else if (DeviceIoControl (devhdl, IOCTL_DISK_GET_PARTITION_INFO,
				NULL, 0, buf, 256, &bytes, NULL))
	{
	  pi = (PARTITION_INFORMATION *) buf;
	  size = pi->PartitionLength.QuadPart;
	}
      else if (DeviceIoControl (devhdl, IOCTL_DISK_GET_DRIVE_GEOMETRY,
				NULL, 0, buf, 256, &bytes, NULL))
	{
	  dg = (DISK_GEOMETRY *) buf;
	  size = (unsigned long long) dg->Cylinders.QuadPart
		       * dg->TracksPerCylinder
		       * dg->SectorsPerTrack
		       * dg->BytesPerSector;
	}
      else
	size = 0;
      if (!pi && !pix && !dg)
	debug_printf ("DeviceIoControl %E");
      else
	{
	  device dev;
	  dev.parsedisk (drive_number, 0);
	  bufptr += __small_sprintf (bufptr, "%5d %5d %9U %s\n",
				     dev.major, dev.minor,
				     size >> 10, dev.name + 5);
	}
      size_t buf_size = 8192;
      while (true)
	{
	  char buf[buf_size];
	  if (DeviceIoControl (devhdl, IOCTL_DISK_GET_DRIVE_LAYOUT,
				NULL, 0, (DRIVE_LAYOUT_INFORMATION *) buf,
				buf_size, &bytes, NULL))
	    /* fall through */;
	  else if (GetLastError () == ERROR_INSUFFICIENT_BUFFER)
d1142 2
a1143 2
	      buf_size *= 2;
	      continue;
d1145 2
a1146 1
	  else
d1148 5
a1152 2
	      debug_printf ("DeviceIoControl %E");
	      break;
d1154 5
a1158 2
	  DRIVE_LAYOUT_INFORMATION *dli = (DRIVE_LAYOUT_INFORMATION *) buf;
	  for (unsigned part = 0; part < dli->PartitionCount; part++)
a1159 3
	      if (!dli->PartitionEntry[part].PartitionLength.QuadPart
		  || !dli->PartitionEntry[part].RecognizedPartition)
		continue;
d1161 1
a1161 3
	      dev.parsedisk (drive_number,
			     dli->PartitionEntry[part].PartitionNumber);
	      size = dli->PartitionEntry[part].PartitionLength.QuadPart >> 10;
d1164 1
a1164 1
					 size, dev.name + 5);
d1166 1
a1166 1
	  break;
a1167 1
      NtClose (devhdl);
@


1.89
log
@Throughout change all calls of low_priority_sleep (0) to yield ().
* miscfuncs.cc (yield): Rename from low_priority_sleep.  Remove all of the
logic which called Sleep() and just use SwitchToThread.
* miscfuncs.h (yield): Rename from low_priority_sleep.
(SLEEP_0_STAY_LOW): Delete unused define.
* shared.cc (memory_init): Move heap_init() call directly after shared memory
initialization to more closely mimic long-standing program flow.
* tty.cc (tty_list::terminate): Replace call to low_priority_sleep with Sleep.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2009 Red Hat, Inc.
d31 1
d45 1
d64 1
d1226 18
@


1.88
log
@	* fhandler_proc.cc (format_proc_stat): Use new in_buf.
	(format_proc_cpuinfo): Replace szBuffer with a union in_buf.  Use type
	correct throughout.  Add a couple of missing or newer cpu flags.  Allow
	certain AMD flags for intel as well.
@
text
@d619 1
a619 1
      low_priority_sleep (0);
@


1.87
log
@	* autoload.cc (GetSystemTimes): Remove.
	* fhandler_proc.cc (format_proc_uptime): Use global system_info rather
	than retrieving a local copy of the SYSTEM_INFO.  Drop call to
	GetSystemTimes and retrieve SystemPerformanceInformation on all systems
	again with buffer size big enough for 64 bit systems.
	(format_proc_stat): Use global system_info rather than retrieving a
	local copy of the SYSTEM_INFO.  Retrieve SystemPerformanceInformation
	with buffer size big enough for 64 bit systems.
@
text
@d558 1
a558 1
	if ((dwError = RegQueryValueEx (hKey, x, NULL, &dwType, (BYTE *) szBuffer, &dwCount)), \
d586 7
a592 1
  CHAR szBuffer[BUFSIZE];
d604 1
a604 1
      __small_sprintf (szBuffer, "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\%d", cpu_number);
d606 1
a606 1
      if ((dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_QUERY_VALUE, &hKey)) != ERROR_SUCCESS)
d642 1
a642 1
	  bufptr += __small_sprintf (bufptr, "vendor_id       : %s\n", szBuffer);
d644 1
a644 1
	  bufptr += __small_sprintf (bufptr, "identifier      : %s\n", szBuffer);
d646 1
a646 1
	  bufptr += __small_sprintf (bufptr, "cpu MHz         : %u\n", *(DWORD *) szBuffer);
d684 1
a684 1
	  unsigned cpu_mhz = *(DWORD *)szBuffer;
d707 7
a713 8
		  unsigned *model_name = (unsigned *) szBuffer;
		  cpuid (&model_name[0], &model_name[1], &model_name[2],
			 &model_name[3], 0x80000002);
		  cpuid (&model_name[4], &model_name[5], &model_name[6],
			 &model_name[7], 0x80000003);
		  cpuid (&model_name[8], &model_name[9], &model_name[10],
			 &model_name[11], 0x80000004);
		  model_name[12] = 0;
d718 1
a718 1
		  strcpy (szBuffer, "unknown");
d752 1
a752 1
					 szBuffer + strspn (szBuffer, " 	"),
d874 2
d890 2
d896 4
d901 2
d904 2
a905 2
		  if (features2 & (1 << 8))
		    print (" est");
d908 2
d913 27
d941 1
a941 1
	      if (is_amd && maxe >= 0x80000001)
d950 30
a979 4
		  if (features & (1 << 2))
		    print (" svm");
		  if (features & (1 << 4))
		    print (" cr8_legacy");
d1028 4
@


1.86
log
@	* autoload.cc (GetSystemTimes): Define.
	* fhandler_proc.cc (format_proc_uptime): Use GetSystemInfo to retrieve
	processor count.  Use GetSystemTimes when available to retrieve system
	idle time.  Improve debug output.
	(format_proc_stat): Use GetSystemInfo to retrieve processor
	count.  Improve debug output.  Ignore if SystemPerformanceInformation
	returns error.  Explain why.
@
text
@a423 1
  SYSTEM_INFO si;
d425 7
a431 2
  SYSTEM_PERFORMANCE_INFORMATION spi;
  FILETIME idletime;
d433 2
a434 1
  GetSystemInfo (&si);
d444 4
a447 11
  /* Can't use NtQuerySystemInformation on 64 bit systems, so we just use
     the offical Win32 function and fall back to NtQuerySystemInformation
     on older systems. */
  if (GetSystemTimes (&idletime, NULL, NULL))
    idle_time = ((unsigned long long) idletime.dwHighDateTime << 32)
    		| idletime.dwLowDateTime;
  else if (NT_SUCCESS (NtQuerySystemInformation (SystemPerformanceInformation,
						 &spi, sizeof spi, NULL)))
    idle_time = spi.IdleTime.QuadPart;
  idle_time /= si.dwNumberOfProcessors;
  idle_time /= 100000ULL;
d462 7
a468 1
  SYSTEM_PERFORMANCE_INFORMATION spi;
a469 1
  SYSTEM_INFO si;
d475 2
a476 1
  GetSystemInfo (&si);
d478 1
a478 1
  SYSTEM_PROCESSOR_TIMES spt[si.dwNumberOfProcessors];
d480 1
a480 1
				  sizeof spt[0] * si.dwNumberOfProcessors, NULL);
d487 1
a487 1
      for (unsigned long i = 0; i < si.dwNumberOfProcessors; i++)
d498 1
a498 1
      for (unsigned long i = 0; i < si.dwNumberOfProcessors; i++)
a507 5
      /* This fails on WOW64 with STATUS_INFO_LENGTH_MISMATCH because the
         SYSTEM_PERFORMANCE_INFORMATION struct is bigger.  This datastructure
	 was always undocumented, but on 64 bit systems we don't know its
	 layout and content at all.  So we just let it fail and set the
	 entire structure to 0. */
d509 1
a509 1
				      (PVOID) &spi, sizeof spi, NULL);
d514 1
a514 1
	  memset (&spi, 0, sizeof spi);
d526 2
a527 2
  pages_in = spi.PagesRead;
  pages_out = spi.PagefilePagesWritten + spi.MappedFilePagesWritten;
d535 3
a537 3
  swap_in = spi.PagesRead;
  swap_out = spi.PagefilePagesWritten;
  context_switches = spi.ContextSwitches;
@


1.85
log
@	* fhandler_proc.cc (proc_tab): Add entry for mounts symlink.
	(format_proc_mounts): New function to implement mounts symlink.
	* fhandler_process.cc (process_tab): Add entry for mounts file.
	(format_process_mounts): New function to implement mounts file.
@
text
@a422 1

d424 1
a424 1
  SYSTEM_BASIC_INFORMATION sbi;
d427 1
d429 1
a429 7
  ret = NtQuerySystemInformation (SystemBasicInformation, (PVOID) &sbi,
				  sizeof sbi, NULL);
  if (!NT_SUCCESS (ret))
    {
      debug_printf ("NtQuerySystemInformation: ret %d", ret);
      sbi.NumberProcessors = 1;
    }
d435 15
a449 5

  ret = NtQuerySystemInformation (SystemPerformanceInformation, &spi,
				  sizeof spi, NULL);
  if (NT_SUCCESS (ret))
    idle_time = (spi.IdleTime.QuadPart / sbi.NumberProcessors) / 100000ULL;
d466 1
a466 1
  SYSTEM_BASIC_INFORMATION sbi;
d472 1
a472 7
  if ((ret = NtQuerySystemInformation (SystemBasicInformation,
				       (PVOID) &sbi, sizeof sbi, NULL))
      != STATUS_SUCCESS)
    {
      debug_printf ("NtQuerySystemInformation: ret %d", ret);
      sbi.NumberProcessors = 1;
    }
d474 1
a474 1
  SYSTEM_PROCESSOR_TIMES spt[sbi.NumberProcessors];
d476 5
a480 3
				  sizeof spt[0] * sbi.NumberProcessors, NULL);
  interrupt_count = 0;
  if (ret == STATUS_SUCCESS)
d483 1
a483 1
      for (int i = 0; i < sbi.NumberProcessors; i++)
d494 1
a494 1
      for (int i = 0; i < sbi.NumberProcessors; i++)
d504 5
d511 12
d524 3
a526 9
  if (ret == STATUS_SUCCESS)
    ret = NtQuerySystemInformation (SystemTimeOfDayInformation,
				    (PVOID) &stodi,
				    sizeof stodi, NULL);
  if (ret != STATUS_SUCCESS)
    {
      debug_printf ("NtQuerySystemInformation: ret %d", ret);
      return 0;
    }
d1003 1
a1003 1
      debug_printf ("NtOpenDirectoryObject %x", status);
d1045 1
a1045 1
	      debug_printf ("NtOpenFile(%s) %x", devname, status);
@


1.84
log
@	* devices.h (FH_PROCESSFD): New device type.
	* dtable.cc (build_fh_pc): Add case for FH_PROCESSFD.
	* fhandler.h (class fhandler_virtual): Drop bufalloc member.
	* fhandler_virtual.h: New header.
	* fhandler_proc.cc: Remove types proc_type_t and proc_tab_t in favor
	of types virt_type_t and virt_tab_t from fhandler_virtual.h.
	Change prototypes of format_XXX functions accordingly.
	(proc_tab): Drop size member info.
	(fhandler_proc::fill_filebuf): Don't allocate filebuf here.  Allocate
	it in the format_XXX functions.
	* fhandler_process.cc: Reorganize global process content data into a
	new struct virt_tab_t.  Accommodate throughout.
	(format_process_winexename): New function.
	(format_process_winpid): New function.
	(format_process_exename): New function.
	(format_process_root): New function.
	(format_process_cwd): New function.
	(format_process_cmdline): New function.
	(format_process_ppid): New function.
	(format_process_uid): New function.
	(format_process_pgid): New function.
	(format_process_sid): New function.
	(format_process_gid): New function.
	(format_process_ctty): New function.
	(format_process_fd): New function.
	* fhandler_procnet.cc (fhandler_procnet::fill_filebuf): Don't use
	bufalloc.
	* fhandler_registry.cc (fhandler_registry::fill_filebuf): Define
	bufalloc locally.
	* fhandler_virtual.cc (fhandler_virtual::fhandler_virtual): Drop
	initialization of bufalloc.
	(fhandler_virtual::dup): Drop copying bufalloc.
@
text
@d43 1
d58 1
d1132 7
@


1.83
log
@	* fhandler_proc.cc: Reorganize global proc content data into a new
	struct proc_tab_t.  Accommodate throughout.
	(format_proc_version): New function.
	(format_proc_loadavg): New function.
	(format_proc_self): New function.

	* resource.cc (getrlimit): Return correct rlim_max value for
	RLIMIT_NOFILE.
@
text
@d19 1
d23 1
d35 8
a42 24
enum proc_type_t {
  proc_symlink = -2,
  proc_file = -1,
  proc_none = 0,
  proc_directory = 1,
  proc_rootdir = 2
};

struct proc_tab_t {
  const char *name;
  __dev32_t fhandler;
  proc_type_t type;
  size_t bufsize;
  _off64_t (*format_func)(char *, size_t);
};

static _off64_t format_proc_loadavg (char *, size_t);
static _off64_t format_proc_meminfo (char *, size_t);
static _off64_t format_proc_stat (char *, size_t);
static _off64_t format_proc_version (char *, size_t);
static _off64_t format_proc_uptime (char *, size_t);
static _off64_t format_proc_cpuinfo (char *, size_t);
static _off64_t format_proc_partitions (char *, size_t);
static _off64_t format_proc_self (char *, size_t);
d45 16
a60 16
static const proc_tab_t proc_tab[] = {
  { ".",	  FH_PROC,	proc_directory,	    0, NULL },
  { "..",	  FH_PROC,	proc_directory,	    0, NULL },
  { "loadavg",	  FH_PROC,	proc_file,	   16, format_proc_loadavg },
  { "meminfo",	  FH_PROC,	proc_file,	 2048, format_proc_meminfo },
  { "registry",	  FH_REGISTRY,	proc_directory,	    0, NULL  },
  { "stat",	  FH_PROC,	proc_file,	16384, format_proc_stat },
  { "version",	  FH_PROC,	proc_file,	  100, format_proc_version },
  { "uptime",	  FH_PROC,	proc_file,	   80, format_proc_uptime },
  { "cpuinfo",	  FH_PROC,	proc_file,	16384, format_proc_cpuinfo },
  { "partitions", FH_PROC,	proc_file,	 4096, format_proc_partitions },
  { "self",	  FH_PROC,	proc_symlink,	   16, format_proc_self },
  { "registry32", FH_REGISTRY,	proc_directory,	    0, NULL },
  { "registry64", FH_REGISTRY,	proc_directory,	    0, NULL },
  { "net",	  FH_PROCNET,	proc_directory,	    0, NULL },
  { NULL,	  0,		proc_none,	    0, NULL },
d65 1
a65 1
static const int PROC_LINK_COUNT = (sizeof (proc_tab) / sizeof (proc_tab_t)) - 1;
d125 1
a125 1
    return proc_rootdir;
d132 1
a132 1
  return 0;
d165 1
a165 1
	    if (proc_tab[i].type == proc_directory)
d167 1
a167 1
	    else if (proc_tab[i].type == proc_symlink)
d322 1
a322 3
      filebuf = (char *) crealloc_abort (filebuf,
					 bufalloc = proc_tab[fileid].bufsize);
      filesize = proc_tab[fileid].format_func (filebuf, bufalloc);
d329 1
a329 1
format_proc_version (char *destbuf, size_t maxsize)
d334 4
d343 1
a343 1
format_proc_loadavg (char *destbuf, size_t maxsize)
d345 1
d351 1
a351 1
format_proc_meminfo (char *destbuf, size_t maxsize)
d362 1
d397 1
d418 1
a418 1
format_proc_uptime (char *destbuf, size_t maxsize)
d445 1
d452 1
a452 1
format_proc_stat (char *destbuf, size_t maxsize)
a456 2

  char *eobuf = destbuf;
d460 5
a465 1
  SYSTEM_BASIC_INFORMATION sbi;
d538 3
a540 1
  return eobuf - destbuf;
d566 1
a566 1
format_proc_cpuinfo (char *destbuf, size_t maxsize)
d575 4
a578 1
  char *bufptr = destbuf;
a580 1

d963 3
a965 1
  return bufptr - destbuf;
d971 1
a971 1
format_proc_partitions (char *destbuf, size_t maxsize)
a972 3
  char *bufptr = destbuf;
  print ("major minor  #blocks  name\n\n");

d978 4
d991 1
a991 1
      return bufptr - destbuf;
d994 1
d1118 3
a1120 1
  return bufptr - destbuf;
d1124 1
a1124 1
format_proc_self (char *destbuf, size_t maxsize)
d1126 1
@


1.82
log
@	Add case-sensitivity.
	Unconditionally handle mount points case-sensitive.
	Unconditionally handle virtual paths case-sensitive.
	Unconditionally handle registry paths case-insensitive.
	Otherwise, accommodate case-sensitivity of given path throughout.
	* cygheap.cc (cygheap_root::set): Get additional caseinsensitive
	parameter and store it.
	* cygheap.h (struct cygheap_root_mount_info): Add member
	caseinsensitive.
	* dlfcn.cc (get_full_path_of_dll): Drop PC_NOFULL parameter from call
	to path_conv::check.
	* environ.cc (pcheck_case): Remove.
	(check_case_init): Remove.
	(known): Drop "check_case" option.
	* exceptions.cc (open_stackdumpfile): Add comment.
	* fhandler.cc (fhandler_base::get_default_fmode): Call pathmatch
	instead of strcasematch.
	* fhandler_disk_file.cc: Accommodate case-sensitivity of given path
	throughout.
	(__DIR_mounts::check_mount): Unconditionally check virtual paths
	case-sensitive.
	(fhandler_disk_file::link): Drop case clash handling.
	(fhandler_disk_file::open): Ditto.
	(fhandler_disk_file::readdir_helper): Drop managed mount code.
	* mount.cc: Remove managed mount code and datastructures.
	(struct opt): Remove "managed" option.  Add "posix=0" and "posix=1"
	options.
	(fillout_mntent): Remove "managed" output.  Add "posix" output.
	* path.cc (struct symlink_info): Remove case_clash member and
	case_check method.
	(pcheck_case): Remove.
	(path_prefix_p): Take additional bool parameter "caseinsensitive".
	(pathnmatch): Ditto.
	(pathmatch): Ditto.
	(mkrelpath): Ditto.
	(fs_info::update): Set caseinsensitive flag according to file system
	name and FILE_CASE_SENSITIVE_SEARCH flag.  Add comment.
	(tfx_chars_managed): Remove.
	(transform_chars): Drop "managed" parameter.  Always use tfx_chars.
	(get_nt_native_path): Drop "managed" parameter.  Make sure drive letters
	are always upper case.
	(getfileattr): Change second parameter to denote caseinsensitivity.
	(path_conv::check): Initialize caseinsensitive to OBJ_CASE_INSENSITIVE.
	Set caseinsensitive according to global obcaseinsensitive flag, file
	system case sensitivity and MOUNT_NOPOSIX mount flag.
	Drop case_clash and all the related code.
	(symlink_worker): Drop case clash handling.
	(symlink_info::set): Drop setting case_clash.
	(symlink_info::case_check): Remove.
	(cwdstuff::set): Add comment.
	(etc::init): Take path_conv instead of PUNICODE_STRING as parameter to
	allow case sensitivity.
	* path.h (enum pathconv_arg): Drop PC_SYM_IGNORE.
	(enum case_checking): Remove.
	(enum path_types): Drop PATH_ENC, add PATH_NOPOSIX flag.
	(struct fs_info): Add caseinsensitive flag and accessor methods.
	(class path_conv): Add caseinsensitive member and define
	objcaseinsensitive method.  Drop case_clash member and isencoded method.
	(pathmatch): Change prototype according to above change.
	(pathnmatch): Ditto.
	(path_prefix_p): Ditto.
	(get_nt_native_path): Ditto.
	(class etc): Ditto.
	(fnunmunge): Remove prototype.
	* shared.cc (shared_info::init_obcaseinsensitive): Initialize
	obcaseinsensitive flag from obcaseinsensitive registry value.
	(shared_info::initialize): Call init_obcaseinsensitive here by the
	first process creating the shared memory.
	* shared_info.h (mount_item::fnmunge): Remove.
	(shared_info::obcaseinsensitive): Rename from obcaseinsensitivity.
	(shared_info::init_obcaseinsensitive): Declare.
	* syscalls.cc (try_to_bin): Add comment.
	* include/sys/mount.h (MOUNT_ENC): Remove flag.
	(MOUNT_NOPOSIX): Add flag.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007 Red Hat, Inc.
d33 24
a56 13
/* offsets in proc_listing */
static const int PROC_LOADAVG    =  2;   // /proc/loadavg
static const int PROC_MEMINFO    =  3;   // /proc/meminfo
static const int PROC_REGISTRY   =  4;   // /proc/registry
static const int PROC_STAT       =  5;   // /proc/stat
static const int PROC_VERSION    =  6;   // /proc/version
static const int PROC_UPTIME     =  7;   // /proc/uptime
static const int PROC_CPUINFO    =  8;   // /proc/cpuinfo
static const int PROC_PARTITIONS =  9;   // /proc/partitions
static const int PROC_SELF       = 10;   // /proc/self
static const int PROC_REGISTRY32 = 11;   // /proc/registry32
static const int PROC_REGISTRY64 = 12;   // /proc/registry64
static const int PROC_NET        = 13;   // /proc/net
d59 16
a74 16
static const char *proc_listing[] = {
  ".",
  "..",
  "loadavg",
  "meminfo",
  "registry",
  "stat",
  "version",
  "uptime",
  "cpuinfo",
  "partitions",
  "self",
  "registry32",
  "registry64",
  "net",
  NULL
d79 1
a79 21
static const int PROC_LINK_COUNT = (sizeof (proc_listing) / sizeof (const char *)) - 1;

/* FH_PROC in the table below means the file/directory is handles by
 * fhandler_proc.
 */
static const DWORD proc_fhandlers[PROC_LINK_COUNT] = {
  FH_PROC,
  FH_PROC,
  FH_PROC,
  FH_PROC,
  FH_REGISTRY,
  FH_PROC,
  FH_PROC,
  FH_PROC,
  FH_PROC,
  FH_PROC,
  FH_PROC,
  FH_REGISTRY,
  FH_REGISTRY,
  FH_PROCNET,
};
a84 6
static _off64_t format_proc_meminfo (char *destbuf, size_t maxsize);
static _off64_t format_proc_stat (char *destbuf, size_t maxsize);
static _off64_t format_proc_uptime (char *destbuf, size_t maxsize);
static _off64_t format_proc_cpuinfo (char *destbuf, size_t maxsize);
static _off64_t format_proc_partitions (char *destbuf, size_t maxsize);

d103 1
a103 1
  for (int i = 0; proc_listing[i]; i++)
d105 1
a105 1
      if (path_prefix_p (proc_listing[i], path, strlen (proc_listing[i]),
d107 1
a107 1
	return proc_fhandlers[i];
d139 3
a141 3
    return 2;
  for (int i = 0; proc_listing[i]; i++)
    if (!strcmp (path + 1, proc_listing[i]))
d144 1
a144 1
	return (proc_fhandlers[i] == FH_PROC) ? (i == PROC_SELF ? -2 : -1) : 1;
d176 2
a177 2
      for (int i = 0; proc_listing[i]; i++)
	if (!strcmp (path, proc_listing[i]))
d179 1
a179 1
	    if (proc_fhandlers[i] != FH_PROC)
d181 1
a181 1
	    else if (i == PROC_SELF)
d201 1
a201 1
      strcpy (de->d_name, proc_listing[dir->__d_position++]);
d261 2
a262 2
  for (int i = 0; proc_listing[i]; i++)
    if (path_prefix_p (proc_listing[i], path + 1, strlen (proc_listing[i]),
d266 1
a266 1
	if (proc_fhandlers[i] != FH_PROC)
d315 1
a315 1
	}
d334 1
a334 1
  switch (fileid)
d336 22
a357 37
    case PROC_VERSION:
      {
	if (!filebuf)
	  {
	    struct utsname uts_name;
	    uname (&uts_name);
	    bufalloc = strlen (uts_name.sysname) + 1
		       + strlen (uts_name.release) + 1
		       + strlen (uts_name.version) + 2;
	    filebuf = (char *) crealloc_abort (filebuf, bufalloc);
	    filesize = __small_sprintf (filebuf, "%s %s %s\n",
					uts_name.sysname, uts_name.release,
					uts_name.version);
	  }
	break;
      }
    case PROC_UPTIME:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 80);
	filesize = format_proc_uptime (filebuf, bufalloc);
	break;
      }
    case PROC_STAT:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 16384);
	filesize = format_proc_stat (filebuf, bufalloc);
	break;
      }
    case PROC_LOADAVG:
      {
	/*
	 * not really supported - Windows doesn't keep track of these values
	 * Windows 95/98/me does have the KERNEL/CPUUsage performance counter
	 * which is similar.
	 */
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 16);
	filesize = __small_sprintf (filebuf, "%u.%02u %u.%02u %u.%02u\n",
a358 27
	break;
      }
    case PROC_MEMINFO:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 2048);
	filesize = format_proc_meminfo (filebuf, bufalloc);
	break;
      }
    case PROC_CPUINFO:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 16384);
	filesize = format_proc_cpuinfo (filebuf, bufalloc);
	break;
      }
    case PROC_PARTITIONS:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 4096);
	filesize = format_proc_partitions (filebuf, bufalloc);
	break;
      }
    case PROC_SELF:
      {
	filebuf = (char *) crealloc_abort (filebuf, bufalloc = 32);
	filesize = __small_sprintf (filebuf, "%d", getpid ());
      }
    }
    return true;
d1119 6
@


1.81
log
@Remove unneeded header files from source files throughout.
@
text
@d120 2
a121 1
      if (path_prefix_p (proc_listing[i], path, strlen (proc_listing[i])))
d156 1
a156 1
    if (pathmatch (path + 1, proc_listing[i]))
d192 1
a192 1
	if (pathmatch (path, proc_listing[i]))
d277 2
a278 1
    if (path_prefix_p (proc_listing[i], path + 1, strlen (proc_listing[i])))
@


1.80
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a14 2
#include <sys/cygwin.h>
#include <ntdef.h>
a21 1
#include <assert.h>
@


1.79
log
@	* fhandler_fifo.cc (fhandler_fifo::open): Use MAX_NAME for pipe name
	buffer size.
	(fhandler_fifo::fstatvfs): Use same technique as in fhandler_socket.
	* fhandler_proc.cc (format_proc_partitions): Use NAME_MAX+1 for
	device name buffer size.  Use MAX_PATH for device path buffer size.
@
text
@d12 1
@


1.78
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@d1033 1
a1033 1
  char devname[CYG_MAX_PATH];
d1040 1
a1040 1
  wchar_t wpath[CYG_MAX_PATH] = L"\\Device";
d1059 1
a1059 1
      sys_wcstombs (devname, CYG_MAX_PATH - 1, dbi->ObjectName.Buffer,
@


1.77
log
@	* dir.cc (readdir_worker): Drop dir parameter from call to
	readdir_get_ino.
	* fhandler.h (fhandler_disk_file::readdir_helper): Switch file name
	parameter to PUNICODE_STRING.
	* fhandler_disk_file.cc: Drop including ntdef.h.
	(class __DIR_mounts): Store mount points in UNICODE.  Additionally
	store cygdrive prefix in unicode here.  Change methods accordingly.
	(__DIR_mounts::eval_ino): Call new stat_worker instead of lstat64.
	(__DIR_mounts::~__DIR_mounts): New destructor to free UNICODE buffers.
	(path_conv::ndisk_links): Rewrite using native NT functions.
	(fhandler_base::fstat_by_handle): Use NAME_MAX instead of CYG_MAX_PATH.
	Always set pfvi->VolumeSerialNumber to non-0.  Remove last resort
	code.
	(fhandler_base::fstat_by_name): Rewrite using native NT functions.
	(fhandler_base::fstat_fs): Always call fstat_by_name if fstat_by_handle
	fails.
	(fhandler_base::fstat_helper): Rely on dwVolumeSerialNumber.
	(fhandler_disk_file::facl): Call fstat_by_name if fstat_by_handle fails.
	(DIR_BUF_SIZE): Define using NAME_MAX instead of CYG_MAX_PATH.
	(__DIR_cache): Remove __name.
	(d_dirname): Remove.
	(fhandler_disk_file::opendir): Drop pathname length check.
	Remove outdated comment.  Use get_name method instead of accessing
	pc.normalized_path directly.
	(readdir_get_ino): Drop unused dir parameter.  Accomodate throughout.
	Allocate fname dynamically.  Call new stat_worker instead of lstat64.
	Call NtOpenFile instead of CreateFile.  Call NtClose instead of
	CloseHandle.
	(fhandler_disk_file::readdir_helper): Use native NT functions.
	Check for volume mount points and use correct inode number.
	(fhandler_disk_file::readdir): Simplify slightly.
	Use get_name instead of pc.normalized_path.
	(fhandler_disk_file::rewinddir): Use RtlInitUnicodeString.
	(fhandler_cygdrive::fstat): Ignore floppy drives.  Set st_nlink
	correctly.
	(fhandler_cygdrive::readdir): Ignore floppy drives.
	* fhandler_netdrive.cc (fhandler_netdrive::readdir): Accommodate
	change to readdir_get_ino.
	* fhandler_proc.cc (PROC_DIR_COUNT): Define.
	(fhandler_proc::fstat): Evaluate correct link count for /proc.
	* ntdll.h (struct _FILE_DIRECTORY_INFORMATION): Define.
	(NtFsControlFile): Declare.
	(RtlAppendUnicodeToString): Declare.
	(RtlAppendUnicodeStringToString): Declare.
	(RtlCompareUnicodeString): Declare.
	(RtlCopyUnicodeString): Declare.
	(RtlCreateUnicodeStringFromAsciiz): Declare.
	(RtlEqualUnicodeString): Declare.
	(RtlFreeUnicodeString): Declare.
	(RtlInitEmptyUnicodeString): Declare.
	(RtlSecondsSince1970ToTime): Declare.
	(RtlInitEmptyUnicodeString): Define as inline function.
	(RtlInitCountedUnicodeString): Define as inline function.
	* path.cc (path_conv::check): New method with PUNICODE_STRING as path,
	preliminary implementation.
	(mount_info::get_mounts_here): Change to create UNICODE_STRINGs.
	Also copy cygpath prefix into UNICODE_STRING.
	(is_floppy): Drop 9x consideration.
	* path.h: Drop including ntdef.h.
	(path_conv::check): Add declaration.
	(path_conv::path_conv): Add constructor for UNICODE_STRING paths.
	* shared_info.h (mount_info::get_mounts_here): Change declaration.
	* syscalls.cc: Drop forward declaration of stat_worker.
	(stat_worke): Take path_conv as parameter.  Drop nofollow flag.
	(stat64): Create matching path_conv and call stat_worker with it.
	(lstat64): Ditto.
	* winsup.h: Include ntdef.h.
	(stat_worker): Declare.
	(readdir_get_ino): Change declaration.
@
text
@d360 1
a360 1
	    filebuf = (char *) crealloc (filebuf, bufalloc);
d369 1
a369 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 80);
d375 1
a375 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 16384);
d386 1
a386 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 16);
d393 1
a393 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 2048);
d399 1
a399 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 16384);
d405 1
a405 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 4096);
d411 1
a411 1
	filebuf = (char *) crealloc (filebuf, bufalloc = 32);
@


1.76
log
@* fhandler_disk_file.cc: White space.
* fhandler_proc.cc: Ditto.
* fhandler_virtual.cc: Ditto.
@
text
@d68 2
d183 2
a184 1
      buf->st_nlink = 1;
d186 1
@


1.75
log
@	* fhandler_proc.cc: Fix formatting.  Drop setting errno when creating
	proc file content.
	(format_proc_uptime): Simplify.
	(format_proc_cpuinfo): Align more closely to output of Linux 2.6 kernel.
	Evaluate more data, especially for AMD CPUs.
@
text
@d358 1
a358 1
	    				uts_name.sysname, uts_name.release,
d639 1
a639 1
        print ("\n");
d737 1
a737 1
	      	family += (cpuid_sig >> 20) & 0xff;
d739 1
a739 1
	      	model += ((cpuid_sig >> 16) & 0x0f) << 4;
d763 1
a763 1
	        clflush = ((extra_info >> 8) & 0xff) << 3;
d765 1
a765 1
	        cache_alignment = clflush * 2;
d767 1
a767 1
	        {
d776 1
a776 1
	        {
d794 1
a794 1
	        bufptr += __small_sprintf (bufptr, "cache size\t: %d KB\n",
d799 1
a799 1
	        {
d821 1
a821 1
	        {
d826 1
a826 1
	      					 "fpu_exception\t: %s\n"
d960 1
a960 1
	        bufptr += __small_sprintf (bufptr,
d964 1
a964 1
	      					 "cache_alignment\t: %d\n",
d969 1
a969 1
	        {
@


1.74
log
@	Throughout replace all usage of wincap.shared with the constant
	FILE_SHARE_VALID_FLAGS.
	* fhandler.cc (fhandler_base::open_9x): Drop local variable shared.
	* wincap.cc: Remove shared member throughout.
	* wincap.h: Ditto.
@
text
@d139 2
a140 2
    /* Return FH_PROC so that we can return EROFS if the user is trying to create
       a file. */
d353 3
a355 2
		bufalloc = strlen (uts_name.sysname) + 1 + strlen (uts_name.release) +
			  1 + strlen (uts_name.version) + 2;
d357 3
a359 2
		filesize = __small_sprintf (filebuf, "%s %s %s\n", uts_name.sysname,
			     uts_name.release, uts_name.version);
d486 2
d493 1
a493 2
      __seterrno_from_nt_status (ret);
      debug_printf ("NtQuerySystemInformation: ret %d, Dos(ret) %E", ret);
d497 2
a498 4
  SYSTEM_PROCESSOR_TIMES spt[sbi.NumberProcessors];
  ret = NtQuerySystemInformation (SystemProcessorTimes, (PVOID) spt,
				  sizeof spt[0] * sbi.NumberProcessors,
				  NULL);
d500 1
a500 8
    for (int i = 0; i < sbi.NumberProcessors; i++)
      {
	uptime += (spt[i].KernelTime.QuadPart + spt[i].UserTime.QuadPart)
		  / 100000ULL;
	idle_time += spt[i].IdleTime.QuadPart / 100000ULL;
      }
  uptime /= sbi.NumberProcessors;
  idle_time /= sbi.NumberProcessors;
d502 4
a505 2
  if (!uptime)
    uptime = GetTickCount () / 10;
d529 1
a529 2
      __seterrno_from_nt_status (ret);
      debug_printf ("NtQuerySystemInformation: ret %d, Dos(ret) %E", ret);
d570 1
a570 2
      __seterrno_from_nt_status (ret);
      debug_printf("NtQuerySystemInformation: ret %d, Dos(ret) %E", ret);
a605 1
	    __seterrno_from_win_error (dwError); \
d638 3
a646 1
	  __seterrno_from_win_error (dwError);
d705 1
a705 1
	  bufptr += __small_sprintf (bufptr, "processor       : %d\n", cpu_number);
d718 1
a718 1
	  bufptr += __small_sprintf (bufptr, "vendor_id       : %s\n",
d727 3
a729 3
			  extended_model  = (cpuid_sig & 0x000f0000) >> 16; */
	      unsigned type		= (cpuid_sig & 0x00003000) >> 12,
		       family		= (cpuid_sig & 0x00000f00) >> 8,
d732 8
a739 20
	      unsigned brand_id		= extra_info & 0x0000000f,
		       cpu_count	= (extra_info & 0x00ff0000) >> 16,
		       apic_id		= (extra_info & 0xff000000) >> 24;
	      const char *type_str;
	      switch (type)
		{
		case 0:
		  type_str = "primary processor";
		  break;
		case 1:
		  type_str = "overdrive processor";
		  break;
		case 2:
		  type_str = "secondary processor";
		  break;
		case 3:
		default:
		  type_str = "reserved";
		  break;
		}
d758 30
a787 11
	      bufptr += __small_sprintf (bufptr, "type            : %s\n"
						 "cpu family      : %d\n"
						 "model           : %d\n"
						 "model name      : %s\n"
						 "stepping        : %d\n"
						 "brand id        : %d\n"
						 "cpu count       : %d\n"
						 "apic id         : %d\n"
						 "cpu MHz         : %d\n"
						 "fpu             : %s\n",
					 type_str,
d792 41
a832 6
					 brand_id,
					 cpu_count,
					 apic_id,
					 cpu_mhz,
					 (features1 & (1 << 0)) ? "yes" : "no");
	      print ("flags           :");
d868 1
a868 1
		print (" psn");
d870 1
a870 1
		print (" clfl");
d872 1
a872 1
		print (" dtes");
d881 6
a888 6
		  if (features1 & (1 << 26))
		    print (" sse2");
		  if (features1 & (1 << 27))
		    print (" ss");
		  if (features1 & (1 << 28))
		    print (" htt");
d890 1
a890 1
		    print (" tmi");
d892 1
a892 1
		    print (" ia-64");
d895 26
d922 4
a925 2
		  if (features2 & (1 << 0))
		    print (" pni");
d934 1
a934 1
		 if (features2 & (1 << 10))
d937 2
d942 12
a953 3
		  // uses AMD extended calls to check
		  // for 3dnow and 3dnow extended support
		  // (source: AMD Athlon Processor Recognition Application Note)
d955 32
a986 3
		  if (maxe >= 0x80000001)  // has basic capabilities
		    {
		      cpuid (&unused, &unused, &unused, &features2, 0x80000001);
d988 13
a1000 13
		      if (features2 & (1 << 11))
			print (" syscall");
		      if (features2 & (1 << 19))
			print (" mp");
		      if (features2 & (1 << 22))
			print (" mmxext");
		      if (features2 & (1 << 29))
			print (" lm");
		      if (features2 & (1 << 30)) // 31th bit is on
			print (" 3dnowext");
		      if (features2 & (1 << 31)) // 32th bit (highest) is on
			print (" 3dnow");
		    }
@


1.73
log
@	* Makefile.in (DLL_IMPORTS): Add libntdll.a.
	* autoload.cc: Remove all symbols from advapi32.dll, kernel32.dll and
	ntdll.dll available on all platforms since NT4.

	Throughout remove all usage of wincap.is_winnt.
	* dcrt0.cc (dll_crt0_0): Remove call to mmap_init.
	* fhandler.h (class fhandler_base): Remove has_changed flag.
	(fhandler_disk_file::touch_ctime): Remove declaration.
	(fhandler_disk_file::readdir_9x): Ditto.
	(fhandler_disk_file::touch_ctime): Remove.
	(fhandler_disk_file::readdir_9x): Remove.
	(fhandler_disk_file::closedir): Call NtClose instead of CloseHandle.
	* mmap.cc: Throughout call CreateMapping and MapView directly.
	(VirtualProt9x): Remove.
	(VirtualProtNT): Remove.
	(VirtualProtEx9x): Remove.
	(VirtualProtExNT): Remove.
	(VirtualProtect): Remove define.
	(VirtualProtectEx): Remove define.
	(CreateMapping9x): Remove.
	(CreateMappingNT): Rename to CreateMapping.
	(MapView9x): Remove.
	(MapViewNT): Rename to MapView.
	(struct mmap_func_t): Remove definition.
	(mmap_funcs_9x): Remove.
	(mmap_funcs_nt): Remove.
	(mmap_func): Remove.
	(mmap_init): Remove.
	* net.cc (getdomainname): Drop comment. Use NT4 registry key only.
	(get_95_ifconf): Remove.
	* pinfo.cc (winpids::enumNT): Rename to winpids::enum_processes.
	(winpids::enum9x): Remove.
	(winpids::set): Just call enum_processes directly.
	(winpids::enum_init): Ditto.
	* pinfo.h (class winpids): Drop enum_processes pointer.  Rename
	enumNT to enum_processes.  Drop enum9x declaration.  Drop initialization
	of enum_processes throughout.
	* registry.cc (get_registry_hive_path): Just create NT key.
	(load_registry_hive): Only load NT specific file.
	* syscalls.cc (unlink_9x): Remove.
	(unlink): Just call unlink_nt.
	* wincap.cc: Remove is_winnt flag throughout.
	* wincap.h: Ditto.
	* winsup.h: Remove mmap_init declaration.
@
text
@d966 1
a966 1
			   wincap.shared (), 0);
d975 1
a975 1
			       wincap.shared (), 0);
@


1.72
log
@	* Makefile.in (DLL_OFILES): Add fhandler_procnet.o.
	* autoload.cc (GetAdaptersAddresses): Define.
	* devices.h (FH_PROCNET): Define new device.
	* devices.in (dev_procnet_storage): Add "/proc/net" entry.
	* devices.cc: Regenerate.
	* dir.cc (readdir_worker): Use isproc_dev macro.
	* dtable.cc (build_fh_pc): Add FH_PROCNET.
	* fhandler.h (class fhandler_procnet): New class.
	* fhandler_proc.cc: Add "net" subdirectory handling.
	* fhandler_procnet.cc: New file handling "/proc/net" directory.
	* path.cc (isvirtual_dev): Move to path.h.
	* path.h (isproc_dev): New macro to identify /proc files by device.
	(isvirtual_dev): Moved here.  Define using isproc_dev.
	* syscalls.cc (unlink): Use isproc_dev macro.
	* wincap.h (wincapc::has_gaa_prefixes): New element.
	(wincapc::has_gaa_on_link_prefix): New element.
	* wincap.cc: Implement above elements throughout.
	(wincapc::init): Check XP for service pack and set has_gaa_prefixes
	appropriately.
	* include/cygwin/in6.h: Include asm/byteorder.h.
@
text
@d482 6
a487 1
  if (wincap.is_winnt ())
d489 18
a506 2
      NTSTATUS ret;
      SYSTEM_BASIC_INFORMATION sbi;
a507 23
      ret = NtQuerySystemInformation (SystemBasicInformation, (PVOID) &sbi,
				      sizeof sbi, NULL);
      if (!NT_SUCCESS (ret))
	{
	  __seterrno_from_nt_status (ret);
	  debug_printf ("NtQuerySystemInformation: ret %d, Dos(ret) %E", ret);
	  sbi.NumberProcessors = 1;
	}

      SYSTEM_PROCESSOR_TIMES spt[sbi.NumberProcessors];
      ret = NtQuerySystemInformation (SystemProcessorTimes, (PVOID) spt,
				      sizeof spt[0] * sbi.NumberProcessors,
				      NULL);
      if (NT_SUCCESS (ret))
	for (int i = 0; i < sbi.NumberProcessors; i++)
	  {
	    uptime += (spt[i].KernelTime.QuadPart + spt[i].UserTime.QuadPart)
		      / 100000ULL;
	    idle_time += spt[i].IdleTime.QuadPart / 100000ULL;
	  }
      uptime /= sbi.NumberProcessors;
      idle_time /= sbi.NumberProcessors;
    }
d524 19
a542 3
  if (!wincap.is_winnt ())
    eobuf += __small_sprintf (destbuf, "cpu %U %U %U %U\n", 0ULL, 0ULL, 0ULL, 0ULL);
  else
d544 2
a545 19
      NTSTATUS ret;
      SYSTEM_PERFORMANCE_INFORMATION spi;
      SYSTEM_TIME_OF_DAY_INFORMATION stodi;

      SYSTEM_BASIC_INFORMATION sbi;
      if ((ret = NtQuerySystemInformation (SystemBasicInformation,
					   (PVOID) &sbi, sizeof sbi, NULL))
	  != STATUS_SUCCESS)
	{
	  __seterrno_from_nt_status (ret);
	  debug_printf ("NtQuerySystemInformation: ret %d, Dos(ret) %E", ret);
	  sbi.NumberProcessors = 1;
	}

      SYSTEM_PROCESSOR_TIMES spt[sbi.NumberProcessors];
      ret = NtQuerySystemInformation (SystemProcessorTimes, (PVOID) spt,
				      sizeof spt[0] * sbi.NumberProcessors, NULL);
      interrupt_count = 0;
      if (ret == STATUS_SUCCESS)
d547 16
a562 9
	  unsigned long long user_time = 0ULL, kernel_time = 0ULL, idle_time = 0ULL;
	  for (int i = 0; i < sbi.NumberProcessors; i++)
	    {
	      kernel_time += (spt[i].KernelTime.QuadPart - spt[i].IdleTime.QuadPart) * HZ / 10000000ULL;
	      user_time += spt[i].UserTime.QuadPart * HZ / 10000000ULL;
	      idle_time += spt[i].IdleTime.QuadPart * HZ / 10000000ULL;
	    }

	  eobuf += __small_sprintf (eobuf, "cpu %U %U %U %U\n",
d564 1
a564 10
	  user_time = 0ULL, kernel_time = 0ULL, idle_time = 0ULL;
	  for (int i = 0; i < sbi.NumberProcessors; i++)
	    {
	      interrupt_count += spt[i].InterruptCount;
	      kernel_time = (spt[i].KernelTime.QuadPart - spt[i].IdleTime.QuadPart) * HZ / 10000000ULL;
	      user_time = spt[i].UserTime.QuadPart * HZ / 10000000ULL;
	      idle_time = spt[i].IdleTime.QuadPart * HZ / 10000000ULL;
	      eobuf += __small_sprintf (eobuf, "cpu%d %U %U %U %U\n", i,
					user_time, 0ULL, kernel_time, idle_time);
	    }
d566 12
a577 26
	  ret = NtQuerySystemInformation (SystemPerformanceInformation,
					  (PVOID) &spi, sizeof spi, NULL);
	}
      if (ret == STATUS_SUCCESS)
	ret = NtQuerySystemInformation (SystemTimeOfDayInformation,
					(PVOID) &stodi,
					sizeof stodi, NULL);
      if (ret != STATUS_SUCCESS)
	{
	  __seterrno_from_nt_status (ret);
	  debug_printf("NtQuerySystemInformation: ret %d, Dos(ret) %E", ret);
	  return 0;
	}
      pages_in = spi.PagesRead;
      pages_out = spi.PagefilePagesWritten + spi.MappedFilePagesWritten;
      /*
       * Note: there is no distinction made in this structure between pages
       * read from the page file and pages read from mapped files, but there
       * is such a distinction made when it comes to writing. Goodness knows
       * why. The value of swap_in, then, will obviously be wrong but its our
       * best guess.
       */
      swap_in = spi.PagesRead;
      swap_out = spi.PagefilePagesWritten;
      context_switches = spi.ContextSwitches;
      boot_time = to_time_t ((FILETIME *) &stodi.BootTime.QuadPart);
d579 2
d582 5
a586 6
   * else
   *   {
   * There are only two relevant performance counters on Windows 95/98/me,
   * VMM/cPageIns and VMM/cPageOuts. The extra effort needed to read these
   * counters is by no means worth it.
   *   }
d588 5
d687 2
a688 4
	  if (wincap.is_winnt ())
	    {
	      read_value ("~Mhz", REG_DWORD);
	      bufptr += __small_sprintf (bufptr, "cpu MHz         : %u\n", *(DWORD *) szBuffer);
d690 17
a706 18
	      print ("flags           :");
	      if (IsProcessorFeaturePresent (PF_3DNOW_INSTRUCTIONS_AVAILABLE))
		print (" 3dnow");
	      if (IsProcessorFeaturePresent (PF_COMPARE_EXCHANGE_DOUBLE))
		print (" cx8");
	      if (!IsProcessorFeaturePresent (PF_FLOATING_POINT_EMULATED))
		print (" fpu");
	      if (IsProcessorFeaturePresent (PF_MMX_INSTRUCTIONS_AVAILABLE))
		print (" mmx");
	      if (IsProcessorFeaturePresent (PF_PAE_ENABLED))
		print (" pae");
	      if (IsProcessorFeaturePresent (PF_RDTSC_INSTRUCTION_AVAILABLE))
		print (" tsc");
	      if (IsProcessorFeaturePresent (PF_XMMI_INSTRUCTIONS_AVAILABLE))
		print (" sse");
	      if (IsProcessorFeaturePresent (PF_XMMI64_INSTRUCTIONS_AVAILABLE))
		print (" sse2");
	    }
d723 4
a726 7
	  bufptr += __small_sprintf (bufptr, "vendor_id       : %s\n", (char *)vendor_id);
	  unsigned cpu_mhz  = 0;
	  if (wincap.is_winnt ())
	    {
	      read_value ("~Mhz", REG_DWORD);
	      cpu_mhz = *(DWORD *)szBuffer;
	    }
d762 6
a767 3
		  cpuid (&model_name[0], &model_name[1], &model_name[2], &model_name[3], 0x80000002);
		  cpuid (&model_name[4], &model_name[5], &model_name[6], &model_name[7], 0x80000003);
		  cpuid (&model_name[8], &model_name[9], &model_name[10], &model_name[11], 0x80000004);
d775 20
a794 44
	      if (wincap.is_winnt ())
		{
		  bufptr += __small_sprintf (bufptr, "type            : %s\n"
						     "cpu family      : %d\n"
						     "model           : %d\n"
						     "model name      : %s\n"
						     "stepping        : %d\n"
						     "brand id        : %d\n"
						     "cpu count       : %d\n"
						     "apic id         : %d\n"
						     "cpu MHz         : %d\n"
						     "fpu             : %s\n",
					     type_str,
					     family,
					     model,
					     szBuffer + strspn (szBuffer, " 	"),
					     stepping,
					     brand_id,
					     cpu_count,
					     apic_id,
					     cpu_mhz,
					     (features1 & (1 << 0)) ? "yes" : "no");
		}
	      else
		{
		  bufptr += __small_sprintf (bufptr, "type            : %s\n"
						     "cpu family      : %d\n"
						     "model           : %d\n"
						     "model name      : %s\n"
						     "stepping        : %d\n"
						     "brand id        : %d\n"
						     "cpu count       : %d\n"
						     "apic id         : %d\n"
						     "fpu             : %s\n",
					     type_str,
					     family,
					     model,
					     szBuffer,
					     stepping,
					     brand_id,
					     cpu_count,
					     apic_id,
					     (features1 & (1 << 0)) ? "yes" : "no");
		}
d898 1
a898 1
	  else if (wincap.is_winnt ())
a923 3
  if (!wincap.is_winnt ())
    return bufptr - destbuf;

@


1.71
log
@	* fhandler.h (fhandler_base::set_name): Make virtual.
	(class fhandler_registry): Add wow64 and prefix_len members.
	Declare set_name method.
	* fhandler_proc.cc (PROC_REGISTRY32): Define.
	(PROC_REGISTRY64): Define.
	(proc_listing): Add "registry32" and "registry64" elements.
	(proc_fhandlers): Add corresponding FH_REGISTRY values.
	* fhandler_registry.cc (registry_len): Drop static value in favor of
	class member prefix_len.  Use preifx_len instead of registry_len
	throughout.
	(fhandler_registry::set_name): Define.  Set wow64 and prefix_len
	according to directory prefix.
	(fhandler_registry::fhandler_registry): Set wow64 and prefix_len to
	default values.
	(open_key): Add wow64 argument.  Handle wow64 in call to RegOpenKeyEx.
	Use fhandler_registry member wow64 in this place throughout.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005, 2006 Red Hat, Inc.
d47 1
d64 1
d87 1
@


1.70
log
@	* fhandler_proc.cc: Drop superfluous definition of _WIN32_WINNT.
	* miscfuncs.cc: Ditto.
	* sched.cc: Ditto.
@
text
@d36 11
a46 9
static const int PROC_LOADAVG  = 2;     // /proc/loadavg
static const int PROC_MEMINFO  = 3;     // /proc/meminfo
static const int PROC_REGISTRY = 4;     // /proc/registry
static const int PROC_STAT     = 5;     // /proc/stat
static const int PROC_VERSION  = 6;     // /proc/version
static const int PROC_UPTIME   = 7;     // /proc/uptime
static const int PROC_CPUINFO  = 8;     // /proc/cpuinfo
static const int PROC_PARTITIONS = 9;   // /proc/partitions
static const int PROC_SELF     = 10;    // /proc/self
d61 2
d83 2
@


1.69
log
@white space
@
text
@a10 2
#define _WIN32_WINNT 0x0501

@


1.68
log
@	* autoload.cc (NtClose): Define.
	(NtOpenDirectoryObject): Define.
	(NtQueryDirectoryObject): Define.
	* fhandler_proc.cc: Include ctype.h and wchar.h.
	(format_proc_partitions): Revamp loop over existing harddisks by
	scanning the NT native \Device object directory and looking for
	Harddisk entries.
	* ntdll.h: Rearrange system call declarations alphabetically.
	(DIRECTORY_QUERY): Define.
	(struct _DIRECTORY_BASIC_INFORMATION): Define.
	(NtOpenDirectoryObject): Declare.
	(NtQueryDirectoryObject): Declare.
@
text
@d994 1
a994 1
         and try to open. */
@


1.67
log
@	* fhandler_proc.cc (fhandler_proc::fstat): Always return fixed link
	count of 1 for /proc directory instead of incorrect PROC_LINK_COUNT.
@
text
@d29 1
d31 1
d957 27
a983 1
  if (wincap.is_winnt ())
d985 79
a1063 1
      for (int drive_number=0; ; drive_number++)
d1065 11
a1075 7
	  CHAR szDriveName[CYG_MAX_PATH];
	  __small_sprintf (szDriveName, "\\\\.\\PHYSICALDRIVE%d", drive_number);
	  HANDLE hDevice;
	  hDevice = CreateFile (szDriveName, GENERIC_READ,
				FILE_SHARE_READ | FILE_SHARE_WRITE,
				NULL, OPEN_EXISTING, 0, NULL);
	  if (hDevice == INVALID_HANDLE_VALUE)
d1077 1
a1077 4
	      if (GetLastError () == ERROR_PATH_NOT_FOUND)
		  break;
	      __seterrno ();
	      debug_printf ("CreateFile %d %E", GetLastError ());
d1080 2
a1081 1
	  else
d1083 10
a1092 83
	      DWORD dwBytesReturned;
	      /* Use a buffer since some ioctl buffers aren't fixed size. */
	      char buf[256];
	      PARTITION_INFORMATION *pi = NULL;
	      PARTITION_INFORMATION_EX *pix = NULL;
	      DISK_GEOMETRY *dg = NULL;
	      unsigned long long drive_size;

	      if (wincap.has_disk_ex_ioctls ()
		  && DeviceIoControl (hDevice, IOCTL_DISK_GET_PARTITION_INFO_EX,
				      NULL, 0, buf, 256, &dwBytesReturned,
				      NULL))
		{
		  pix = (PARTITION_INFORMATION_EX *) buf;
		  drive_size = pix->PartitionLength.QuadPart;
		}
	      else if (DeviceIoControl (hDevice, IOCTL_DISK_GET_PARTITION_INFO,
	      				NULL, 0, buf, 256, &dwBytesReturned,
					NULL))
		{
		  pi = (PARTITION_INFORMATION *) buf;
		  drive_size = pi->PartitionLength.QuadPart;
	        }
	      else if (DeviceIoControl (hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY,
	      				NULL, 0, buf, 256, &dwBytesReturned,
					NULL))
		{
		  dg = (DISK_GEOMETRY *) buf;
		  drive_size = (unsigned long long) dg->Cylinders.QuadPart
			       * dg->TracksPerCylinder
			       * dg->SectorsPerTrack
			       * dg->BytesPerSector;
		}
	      else
		drive_size = 0;
	      if (!pi && !pix && !dg)
		debug_printf ("DeviceIoControl %E");
	      else
		{
		  device dev;
		  dev.parsedisk (drive_number, 0);
		  bufptr += __small_sprintf (bufptr, "%5d %5d %9U %s\n",
					     dev.major, dev.minor,
					     drive_size >> 10,
					     dev.name + 5);
		}
	      size_t buf_size = 8192;
	      DWORD rc;
	      while (1)
		{
		  char buf[buf_size];
		  memset (buf, 0, buf_size);
		  rc = DeviceIoControl (hDevice, IOCTL_DISK_GET_DRIVE_LAYOUT,
					NULL, 0, (DRIVE_LAYOUT_INFORMATION *) buf,
					buf_size, &dwBytesReturned, NULL);
		  if (rc)
		    /* fall through */;
		  else if (GetLastError () == ERROR_INSUFFICIENT_BUFFER)
		    {
		      buf_size *= 2;
		      continue;
		    }
		  else
		    {
		      debug_printf ("DeviceIoControl %E");
		      break;
		    }
		  DRIVE_LAYOUT_INFORMATION *dli = (DRIVE_LAYOUT_INFORMATION *) buf;
		  for (unsigned partition = 0; partition < dli->PartitionCount; partition++)
		    {
		      if (!dli->PartitionEntry[partition].PartitionLength.QuadPart
		      	  || !dli->PartitionEntry[partition].RecognizedPartition)
			continue;
		      device dev;
		      dev.parsedisk (drive_number, dli->PartitionEntry[partition].PartitionNumber);
		      bufptr += __small_sprintf (bufptr, "%5d %5d %9U %s\n",
						 dev.major, dev.minor,
						 (long long)(dli->PartitionEntry[partition].PartitionLength.QuadPart >> 10),
						 dev.name + 5);
		    }
		  break;
		}
	      CloseHandle (hDevice);
d1094 1
d1096 1
d1098 2
a1099 6
  else
    {
      // not worth the effort
      // you need a 16 bit thunk DLL to access the partition table on Win9x
      // and then you have to decode it yourself
    }
@


1.66
log
@	* autoload.cc (NtQueryDirectoryFile): Define.
	* dir.cc (__opendir_with_d_ino): Just call opendir.
	(opendir): Remove CYGWIN_VERSION_CHECK_FOR_NEEDS_D_INO handling.
	(readdir_worker): Only try generating d_ino if it's 0.
	Utilize namehash of directories fhandler.  Call readdir_get_ino to
	generate d_ino for "..".
	(seekdir64): Keep dirent_set_d_ino flag.
	* fhandler.h (enum dirent_states): Add dirent_get_d_ino.
	(class fhandler_disk_file): Declare new private methods readdir_helper
	and readdir_9x.
	* fhandler_disk_file.cc (path_conv::hasgood_inode): New method to
	evaluate if a filesystem has reliable inode numbers.
	(fhandler_base::fstat_by_handle): Accomodate structure member name
	change from IndexNumber to FileId.
	(fhandler_base::fstat_helper): Call hasgood_inode here.
	(fhandler_disk_file::opendir): Call fhaccess only for real files.
	Don't append '*' to __d_dirname here, move to readdir_9x.  On NT,
	open directory handle here.  Set dirent_get_d_ino and dirent_set_d_ino
	flags according to wincap and filesystem.
	(fhandler_disk_file::readdir_helper): New method to implement readdir
	postprocessing only once.
	(readdir_get_ino_by_handle): New static function.
	(readdir_get_ino): New function to centralize inode number evaluation
	in case inode number hasn't been returned by NtQueryDirectoryFile.
	(fhandler_disk_file::readdir): Move old functionality to readdir_9x.
	Call readdir_9x when on 9x/Me.  Implement NT specific readdir here.
	(fhandler_disk_file::readdir_9x): Move 9x specific readdir here.
	(fhandler_disk_file::seekdir): Accomodate new NT readdir method.
	(fhandler_disk_file::closedir): Ditto.
	(fhandler_cygdrive::fstat): Set d_ino to namehash. Add comment.
	(fhandler_cygdrive::opendir): Call get_namehash to prepare later
	correct evaluation of d_ino.
	(fhandler_cygdrive::readdir): Replace recursion with loop. Evaluate
	drive's d_ino by calling readdir_get_ino.
	* fhandler_proc.cc (fhandler_proc::readdir): Set dirent_saw_dot and
	dirent_saw_dot_dot to avoid seeing . and .. entries twice.
	* fhandler_process.cc (fhandler_process::readdir): Ditto.
	* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
	* ntdll.h (STATUS_INVALID_PARAMETER): New define.
	(STATUS_INVALID_LEVEL): New define.
	(struct _FILE_INTERNAL_INFORMATION): Rename member IndexNumber to
	FileId (as in Nebbitt).
	* path.h (path_conv::hasgood_inode): Now implemented in
	fhandler_disk_file.cc.
	* wincap.h (wincaps::has_fileid_dirinfo): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (readdir_get_ino): Add declaration.
	* include/sys/dirent.h (struct dirent): Slightly rename structure
	members to accomodate changes.
	Remove __USE_EXPENSIVE_CYGWIN_D_INO handling and declaration of
	__opendir_with_d_ino.
@
text
@d172 1
a172 1
      buf->st_nlink = PROC_LINK_COUNT;
@


1.65
log
@	* Update copyrights.
@
text
@d205 1
@


1.64
log
@* fhandler_proc.cc (format_proc_cpuinfo): Avoid leading whitespace in model
name.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005 Red Hat, Inc.
@


1.63
log
@	* fhandler_proc.cc (format_proc_uptime): Drop usage of GetSystemTimes.
	Use NtQuerySystemInformation to evaluate uptime and idle_time from
	all CPU's processor times.  Fallback to GetTickCount.
@
text
@d796 1
a796 1
					     szBuffer,
@


1.62
log
@* hires.h (hires_ms::initime_ms): Delete.
(hires_ms::initime_us): Just define as LONGLONG.
(hires_ms::uptime): New function.
* select.cc (select_stuff::wait): Use gtod for timing to attempt to avoid
windows 32 bit wraparound.
* times.cc (systime): New function.
(times): Replace GetTickCount with gtod.uptime.
(hires_us::prime): Use systime() to calculate system time rather than calling
GetSystemTimeAsFileTime directly.
(hires_ms::prime): Ditto.  Eliminate initime_ms.
(hires_ms::usecs): Try harder to detect wraparound.
* fhandler_proc.cc (format_proc_partitions): Set drive_size to zero to avoid a
compiler warning.
@
text
@a470 1
  SYSTEM_PROCESSOR_TIMES spt;
d472 1
a472 3
  if (!GetSystemTimes ((FILETIME *) &spt.IdleTime, (FILETIME *) &spt.KernelTime,
		       (FILETIME *) &spt.UserTime)
      && GetLastError () == ERROR_PROC_NOT_FOUND)
d474 6
a479 8
      NTSTATUS ret = NtQuerySystemInformation (SystemProcessorTimes, (PVOID) &spt,
					       sizeof spt, NULL);
      if (!ret && GetLastError () == ERROR_PROC_NOT_FOUND)
	{
	  uptime = GetTickCount () / 10;
	  goto out;
	}
      else if (ret != STATUS_SUCCESS)
d482 2
a483 2
	  debug_printf("NtQuerySystemInformation: ret %d, Dos(ret) %E", ret);
	  return 0;
d485 14
d500 2
a501 4
  idle_time = spt.IdleTime.QuadPart / 100000ULL;
  uptime = (spt.KernelTime.QuadPart +
	    spt.UserTime.QuadPart) / 100000ULL;
out:
@


1.61
log
@	* fhandler_proc.cc (format_proc_partitions): Use modern IOCTLs
	to determine drive size as far as possible.
@
text
@d1000 2
@


1.60
log
@	* autoload.cc (NtCreateSection): Define.
	* cygheap.cc (_csbrk): Call getpagesize instead of getshmlba.
	* dcrt0.cc (dll_crt0_0): Call mmap_init.
	* external.cc (cygwin_internal): Call getpagesize instead of getshmlba.
	* fhandler.h (fhandler_base::mmap): Change access to prot parameter.
	(fhandler_base::fixup_mmap_after_fork): Ditto.
	(fhandler_disk_file::mmap): Ditto.
	(fhandler_disk_file::fixup_mmap_after_fork): Ditto.
	(fhandler_dev_mem::mmap): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::write): Call getsystempagesize
	instead of getpagesize.
	(fhandler_dev_mem::read): Ditto.
	(fhandler_dev_mem::fstat): Ditto.
	(fhandler_dev_mem::mmap): Move to mmap.cc.
	(fhandler_dev_mem::munmap): Ditto.
	(fhandler_dev_mem::msync): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.
	* fhandler_proc.cc (format_proc_meminfo): Call getsystempagesize
	instead of getpagesize.
	* fhandler_process.cc (format_process_stat): Ditto.
	(format_process_status): Ditto.
	(get_mem_values): Ditto.
	* mmap.cc: Fix formatting.  Try to make more readable and modular.
	Take advantage of pagesize==granularity.
	(gen_protect): New static function to evaluate Windows
	protection bits from POSIX protection and flags.
	(gen_access): Ditto for Windows access mode.
	(VirtualProt9x): Wrapper function to call VirtualProtect on 9x.
	(VirtualProtNT): Ditto for NT.
	(VirtualProtEx9x): Ditto for VirtualProtectEx on 9x.
	(VirtualProtExNT): Ditto for NT.
	(CreateMapping9x): Wrapper function for creating a mapping handle on 9x.
	(CreateMappingNT): Ditto for NT.
	(MapView9x): Wrapper function to map a view on 9x.
	(MapViewNT): Ditto for NT.
	(mmap_funcs_9x): Structure containing function pointers to wrapper
	functions for 9x.
	(mmap_funcs_nt): Ditto for NT.
	(mmap_func): Pointer to wrapper functions used in subsequent code.
	(mmap_init): Initialize mmap_func depending on OS.
	(class mmap_record): Use sensible member names.  Add POSIX protection
	member. Drop Windows access flags member.  Constify more methods.
	Use accessors instead of direct member access inside of own methods.
	(mmap_record::gen_protect): Class wrapper to evaluate matching
	Windows protection bits.
	(mmap_record::gen_access): Ditto for Windows access flags.
	(mmap_record::compatible_flags): New function to check if flags are
	compatible with flags of existing map.
	(list::add_record): Drop offset and length arguments.
	(class map): Change counters to unsigned.  Match usage throughout.
	(mmapped_areas): Convert from pointer to global struct.
	(mmap_record::alloc_page_map): Simplify.
	(mmap_record::map_pages): Ditto.
	(mmap_record::fixup_page_map): Delete.
	(mmap64): Simplify.  Add workaround for Windows 98 bug.  Fix bug on
	NT that existing anonymous mappings weren't searched for a match.
	(munmap): Add workaround for Windows 98 bug.
	(msync): Simplify.
	(mprotect): Handle existing maps correctly.
	(mlock): Add local pagesize variable and enlightening comment.
	(fhandler_disk_file::mmap): Main functionality now in CreateMapping/
	MapView wrapper functions.
	(fhandler_disk_file::fixup_mmap_after_fork): Call MapView wrapper.
	(fhandler_dev_mem::mmap): Moved from fhandler_mem.cc.  Simplify by
	calling MapViewNT.
	(fhandler_dev_mem::munmap): Moved from fhandler_mem.cc.
	(fhandler_dev_mem::msync): Ditto.
	(fhandler_dev_mem::fixup_mmap_after_fork): Ditto.  Call MapViewNT.
	(fixup_mmaps_after_fork): Restructure and hopefully speed up loop for
	setting protection and memory content on MAP_PRIVATE maps.
	* ntdll.h (AT_ROUND_TO_PAGE): Remove define.
	(AT_EXTENDABLE_FILE): Add define.
	(NtCreateSection): Add prototype.
	* syscalls.cc (getpagesize): Return granularity as pagesize now.
	(getsystempagesize): New function to retrieve "real" pagesize.
	(getshmlba): Delete since it's replaced by getpagesize now.
	* wincap.h (wincaps::has_mmap_alignment_bug): New element.
	* wincap.cc: Implement above element throughout.
	* winsup.h (getshmlba): Drop prototype.
	(getsystempagesize): Add prototype.
	(mmap_init): Ditto.
	* include/sys/mman.h: (Not yet) define MAP_NORESERVE.
@
text
@d954 1
a954 2
	  hDevice = CreateFile (szDriveName,
				GENERIC_READ,
d956 1
a956 4
				NULL,
				OPEN_EXISTING,
				0,
				NULL);
d967 34
a1000 11
	      DWORD dwBytesReturned, dwRetCode;
	      DISK_GEOMETRY dg;
	      dwRetCode = DeviceIoControl (hDevice,
					   IOCTL_DISK_GET_DRIVE_GEOMETRY,
					   NULL,
					   0,
					   &dg,
					   sizeof (dg),
					   &dwBytesReturned,
					   NULL);
	      if (!dwRetCode)
d1007 2
a1008 4
					     dev.major,
					     dev.minor,
					     (long long)((dg.Cylinders.QuadPart * dg.TracksPerCylinder *
					      dg.SectorsPerTrack * dg.BytesPerSector) >> 10),
@


1.59
log
@* dcrt0.cc (get_exit_lock): Use myself.lock rather than exit_lock.
* exceptions.cc (exit_lock): Delete.
(events_init): Don't init exit_lock.
* (_pinfo::commune_process): Add per-PICOM debugging.
* sigproc.cc (talktome): Add some temporary debugging statements.
* fhandler_proc.cc (format_proc_cpuinfo): Cosmetic change.
(format_proc_partitions): Ditto.
* syscalls.cc (locked_append): Ditto.
@
text
@d438 3
a440 2
	  swap_total += spp->CurrentSize * getpagesize ();
	  swap_free += (spp->CurrentSize - spp->TotalUsed) * getpagesize ();
@


1.58
log
@* cygheap.h (cygheap_types): Add HEAP_COMMUNE.
* fhandler_proc.cc: Use cygheap rather than user heap for allocation of filebuf
throughout.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_process.cc: Ditto.
(get_mem_values): Use malloc/realloc/free rather than new.
* pinfo.cc (_pinfo::commune_send): Allocate on cygwin heap rather than user
heap.  Avoid calling ReadFile when correct number of characters have been read
or suffer buffer corruption.
(_pinfo::fd): Allocate on cygwin heap rather than user heap.
(_pinfo::fds): Ditto.
(_pinfo::root): Ditto.
(_pinfo::cwd): Ditto.
(_pinfo::cmdline): Ditto.
* devices.h (FH_DEV): New define.
* devices.in: Detect lone /dev.
* devices.cc: Regenerate.
* path.cc (path_conv::check): Treat FH_DEV as a special case.
@
text
@d638 1
a638 1
  for (cpu_number = 0;;cpu_number++)
d948 1
a948 1
      for (int drive_number=0;;drive_number++)
@


1.57
log
@* cygerrno.h (geterrno_from_win_error): Change declaration to default to using
GetLastError and EACCESS.
* cygwin.din: Export readdir_r.
* include/cygwin/version.h: Bump API version number to 138.
* syscalls.cc (readdir_worker): New function, renamed from old readdir()
function.
(readdir): Use readdir_worker.
(readdir_r): New function.
* fhandler.h (fhandler_base::readdir): Accommodate second argument indicating
dirent buffer.
(fhandler_disk_file::readdir): Ditto.
(fhandler_cygdrive::readdir): Ditto.
(fhandler_proc::readdir): Ditto.
(fhandler_netdrive::readdir): Ditto.
(fhandler_registry::readdir): Ditto.
(fhandler_process::readdir): Ditto.
* fhandler.cc (fhandler_base::readdir): Ditto.
* fhandler_disk_file.cc (fhandler_disk_file::readdir): Ditto.
* fhandler_cygdrive.cc (fhandler_cygdrive::readdir): Ditto.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_netdrive.cc (fhandler_netdrive::readdir): Ditto.
* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
* fhandler_process.cc (fhandler_process::readdir): Ditto.
@
text
@d345 1
a345 1
	    filebuf = (char *) realloc (filebuf, bufalloc);
d353 1
a353 1
	filebuf = (char *) realloc (filebuf, bufalloc = 80);
d359 1
a359 1
	filebuf = (char *) realloc (filebuf, bufalloc = 16384);
d370 1
a370 1
	filebuf = (char *) realloc (filebuf, bufalloc = 16);
d377 1
a377 1
	filebuf = (char *) realloc (filebuf, bufalloc = 2048);
d383 1
a383 1
	filebuf = (char *) realloc (filebuf, bufalloc = 16384);
d389 1
a389 1
	filebuf = (char *) realloc (filebuf, bufalloc = 4096);
d395 1
a395 1
	filebuf = (char *) realloc (filebuf, bufalloc = 32);
@


1.56
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d198 2
a199 2
struct dirent *
fhandler_proc::readdir (DIR * dir)
d201 7
a207 1
  if (dir->__d_position >= PROC_LINK_COUNT)
d211 1
d215 1
a215 1
	    __small_sprintf (dir->__d_dirent->d_name, "%d", pids[i]->pid);
d217 2
a218 1
	    return dir->__d_dirent;
a219 1
      return NULL;
d222 2
a223 4
  strcpy (dir->__d_dirent->d_name, proc_listing[dir->__d_position++]);
  syscall_printf ("%p = readdir (%p) (%s)", &dir->__d_dirent, dir,
		  dir->__d_dirent->d_name);
  return dir->__d_dirent;
@


1.55
log
@	* fhandler_proc.cc (format_proc_partitions): Only list recognized
	partitions.  Use partition number given by PartitionNumber member.
@
text
@d166 1
a166 1
  (void) fhandler_base::fstat (buf);
@


1.54
log
@* external.cc: Move pids declaration to file scope and use less enthusiastic
constructor.
* pinfo.h (winpids::winpids): Remove default setting.
* fhandler_fifo.cc (fhandler_fifo::open_not_mine): Accommodate removal of
default setting.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
@
text
@d1012 2
a1013 1
		      if (!dli->PartitionEntry[partition].PartitionLength.QuadPart)
d1016 1
a1016 1
		      dev.parsedisk (drive_number, partition + 1);
@


1.53
log
@	* cygerrno.h (__seterrno_from_nt_status): Define. Always set Win32
	error code as well as errno. Use throughout where errno is set from
	NT status.
	(set_errno): Evaluate val only once.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Fix typo in
	debug output.
	* fhandler_mem.cc (fhandler_dev_mem::open): Rely on
	__seterrno_from_nt_status setting Win32 error code in debug output.
	* fhandler_proc.cc (format_proc_uptime): Ditto.
	(format_proc_stat): Ditto.
	* fhandler_process.cc (format_process_stat): Ditto.
	* sysconf.cc (sysconf): Ditto.
@
text
@d203 1
a203 1
      winpids pids;
@


1.52
log
@* fhandler_proc.cc (format_proc_partitions): Remove PartitionType check since
it could skip over partitions that are actually interesting.
@
text
@d480 2
a481 3
	  __seterrno_from_win_error (RtlNtStatusToDosError (ret));
	  debug_printf("NtQuerySystemInformation: ret %d, Dos(ret) %d",
		       ret, RtlNtStatusToDosError (ret));
d516 2
a517 3
	  __seterrno_from_win_error (RtlNtStatusToDosError (ret));
	  debug_printf ("NtQuerySystemInformation: ret %d, Dos(ret) %d",
			ret, RtlNtStatusToDosError (ret));
d557 2
a558 3
	  __seterrno_from_win_error (RtlNtStatusToDosError (ret));
	  debug_printf("NtQuerySystemInformation: ret %d, Dos(ret) %d",
		       ret, RtlNtStatusToDosError (ret));
@


1.51
log
@* cygthread.cc (cygthread::terminate_thread): Wait briefly for notification
event in the event that the thread was actually in the process of exiting.
* pipe.cc (fhandler_pipe::dup): read_state is not supposed to be inheritable.
Fix that.
* path.cc (path_conv::check): Set symlen = 0 to avoid a compiler warning.
* devices.h (devices::parsedisk): Declare new function.
* devices.in (devices::parsedisk): Define new function.
* dtable.cc (dtable::init_std_file_from_handle): Use device numbers rather than
name.
* fhandler_proc.cc (format_proc_partitions): Use parsedisk to generate disk
names from numeric codes.  (This was broken on two of my systems previously and
is still broken now)
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004 Red Hat, Inc.
d1015 1
a1015 2
		      if (!dli->PartitionEntry[partition].PartitionLength.QuadPart
			  || !dli->PartitionEntry[partition].PartitionType)
@


1.50
log
@	* fhandler.cc (fhandler_base::get_proc_fd_name): Don't generate
	"device:" entry.
	* fhandler.h (fhandler_socket::open): New method.
	(fhandler_pipe::open): New method.
	* fhandler_proc.cc (fhandler_proc::exists): Return -2 in case of
	/proc/self.
	* fhandler_process.cc (fhandler_process::exists): Return -2 in
	case of symlinks, -3 for pipes and -4 for sockets.
	(fhandler_process::fstat): Handle pipes and sockets.
	(fhandler_process::open): Handle opening /proc/<pid>/fd.
	(fhandler_process::fill_filebuf): Generate empty names for
	non exisiting file descriptors.
	* fhandler_socket.cc (fhandler_socket::get_proc_fd_name): Always
	generate "socket:[number]" strings as on Linux.
	(fhandler_socket::open): New method.
	(fhandler_socket::fstat): Always return socket type.
	* path.cc (symlink_info::set): Remove unused second parameter.
	(path_conv::check): Handle pipes and sockets in /proc.
	Set correct device type for AF_LOCAL sockets.
	* pinfo.cc (_pinfo::commune_recv): Generate empty names for
	non exisiting file descriptors.
	(_pinfo::fd): Ditto.
	* pipe.cc (fhandler_pipe::open): New method.
@
text
@d390 1
a390 1
        filebuf = (char *) realloc (filebuf, bufalloc = 32);
a969 2
	      int buf_size = 4096;
	      char buf[buf_size];
a981 2
		  char devname[16];
		  __small_sprintf (devname, "/dev/sd%c", drive_number + 'a');
d983 1
a983 1
		  dev.parse (devname);
d989 1
a989 1
					     devname + 5);
d991 3
a993 13
	      while (dwRetCode = DeviceIoControl (hDevice,
						  IOCTL_DISK_GET_DRIVE_LAYOUT,
						  NULL,
						  0,
						  (DRIVE_LAYOUT_INFORMATION *) buf,
						  buf_size,
						  &dwBytesReturned,
						  NULL),
		     !dwRetCode && GetLastError () == ERROR_INSUFFICIENT_BUFFER)
	      buf_size *= 2;
	      if (!dwRetCode)
		debug_printf ("DeviceIoControl %E");
	      else
d995 17
d1015 2
a1016 1
		      if (dli->PartitionEntry[partition].PartitionLength.QuadPart == 0)
a1017 4
		      char devname[16];
		      __small_sprintf (devname, "/dev/sd%c%d",
						drive_number + 'a',
						partition + 1);
d1019 1
a1019 1
		      dev.parse (devname);
d1023 1
a1023 1
						 devname + 5);
d1025 1
a1026 1

@


1.49
log
@	* autoload.cc (GetModuleFileNameExA): Add.
	(GetModuleInformation): Add.
	(QueryWorkingSet): Add.
	* fhandler.h (fhandler_virtual::get_filebuf): New method.
	* fhandler_proc.cc (PROC_SELF): Define.
	(proc_fhandlers): Change type of self to FH_PROC.
	(fhandler_proc::exists): Return -3 if self.
	(fhandler_proc::fstat): Handle self as symlink.
	(fhandler_proc::fill_filebuf): Handle self.
	* fhandler_process.cc: Include psapi.h.
	(PROCESS_EXENAME): Remove.
	(PROCESS_MAPS): Define.
	(PROCESS_ROOT): Define.
	(PROCESS_EXE): Define.
	(PROCESS_CWD): Define.
	(process_listing): Remove "exename", add "maps, "root", "exe" and
	"cwd" elements.
	(fhandler_process::exists): Return -2 for symlinks.
	(fhandler_process::fstat): Handle symlinks.
	(fill_filebuf): Evaluate pid if pid is 0.  Use exename handling for
	exe.  Handle maps, root and cwd.
	(format_process_maps): New function evaluating "maps".
	* path.cc (symlink_info::set): New method to fill symlink_info
	with data matching virtual symlinks.
	(path_conv::check): Handle virtual symlinks.
	* pinfo.cc (_pinfo::commune_recv): Add PICOM_CWD and PICOM_ROOT
	handling.
	(_pinfo::commune_send): Ditto.
	(_pinfo::root): New function.
	(_pinfo::cwd): New function.
	* pinfo.h (enum picom): Add PICOM_CWD and PICOM_ROOT.
	(_pinfo::root): Declare.
	(_pinfo::cwd): Declare.
@
text
@d136 1
a136 1
   <0 if path is a file.  */
d149 1
a149 1
	return (proc_fhandlers[i] == FH_PROC) ? (i == PROC_SELF ? -3 : -1) : 1;
@


1.48
log
@* fhandler_proc.cc (proc_listing): Add entry for "self".
(proc_fhandlers): Add entry for "self".
* fhandler_process.cc (fhandler_process::fstate): Handle "self".
(fhandler_process::open): Handle "self".
@
text
@d44 1
d78 1
a78 1
  FH_PROCESS,
d147 4
a150 1
      return (proc_fhandlers[i] == FH_PROC) ? -1 : 1;
d184 2
d388 5
@


1.47
log
@* exceptions.cc: (ctrl_c_handler): Do nothing while a Cygwin subprocess is
starting.
* child_info.h (init_child_info): Remove pid argument from declaration.
* cygheap.h (init_cygheap::pid): New element.
* dcrt0.cc (dll_crt0_0): Eliminate handling of now-noexistent cygpid parameter
in child_info struct.  Set forkee to 'true' rather than cygpid since the pid
value was never used.
(dll_crt0_1): Ditto.
(_dll_crt0): Ditto.
* fork.cc (fork_child): Don't wait for sigthread.  This is handled in the fork
call now.
(fork_parent): Remove obsolete pid argument from init_child_info call.  Don't
do anything special with cygpid when DEBUGGING.
(fork): Delay all signals during fork.
(fork_init): Don't do anything special when DEBUGGING.
* pinfo.cc (set_myself): Remove pid parameter.  Use new pid field in cygheap.
(pinfo_init): Don't pass pid argument to set_myself.
* sigproc.cc (sig_send): Wait for dwProcessId to be non-zero as well as
sendsig.
(init_child_info): Eliminate handling of pid.
(wait_sig): Implement method to temporarily hold off sending signals.
* sigproc.h (__SIGHOLD): New enum.
(__SIGNOHOLD): Ditto.
* spawn.cc (spawn_guts): Remove obsolete pid argument from init_child_info
call.
@
text
@d57 1
d77 1
@


1.46
log
@Regularize most strace_prints throughout so that %E is always preceded by a
comma and elminate most uses of "foo = %s" to "foo %s".
@
text
@d852 2
a853 2
	        {
	          if (features1 & (1 << 26))
d855 1
a855 1
	          if (features1 & (1 << 27))
d857 1
a857 1
	          if (features1 & (1 << 28))
d859 1
a859 1
	          if (features1 & (1 << 29))
d861 1
a861 1
	          if (features1 & (1 << 30))
d863 1
a863 1
	          if (features1 & (1 << 31))
d866 1
a866 1
	          if (features2 & (1 << 0))
d868 1
a868 1
	          if (features2 & (1 << 3))
d870 1
a870 1
	          if (features2 & (1 << 4))
d874 1
a874 1
	          if (features2 & (1 << 8))
d876 1
a876 1
	         if (features2 & (1 << 10))
d878 1
a878 1
	        }
d881 1
a881 1
	        {
d890 8
a897 8
                      if (features2 & (1 << 11))
		        print (" syscall");
                      if (features2 & (1 << 19))
		        print (" mp");
                      if (features2 & (1 << 22))
                        print (" mmxext");
                      if (features2 & (1 << 29))
                        print (" lm");
@


1.45
log
@	* fhandler_proc.cc (format_proc_cpuinfo): Remove Intel-specific flags
	from /proc/cpuinfo on non-Intel processors. Added new AMD-specific
	flags. Changed Intel flag names to match Linux.
@
text
@d468 1
a468 2
	  debug_printf("NtQuerySystemInformation: ret = %d, "
		       "Dos(ret) = %d",
d505 1
a505 2
	  debug_printf ("NtQuerySystemInformation: ret = %d, "
			"Dos(ret) = %d",
d547 1
a547 2
	  debug_printf("NtQuerySystemInformation: ret = %d, "
		       "Dos(ret) = %d",
@


1.44
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::Audio_out::init): Fix non-ISO
	expression.
	* fhandler_floppy.cc (fhandler_dev_floppy::open): Remove unused
	variable.
	* fhandler_proc.cc (format_proc_meminfo): Fix compiler warning.
@
text
@d701 1
a701 1
	  
d708 1
a708 1
	  
d844 1
a844 1
	      if (features1 & (1 << 21))
d846 1
a846 1
	      if (features1 & (1 << 22))
d854 30
a883 24
	      if (features1 & (1 << 26))
		print (" sse2");
	      if (features1 & (1 << 27))
		print (" ss");
	      if (features1 & (1 << 28))
		print (" htt");
	      if (features1 & (1 << 29))
		print (" tmi");
	      if (features1 & (1 << 30))
		print (" ia-64");
	      if (features1 & (1 << 31))
		print (" pbe");
	      if (features2 & (1 << 0))
		print (" sse3");
	      if (features2 & (1 << 3))
		print (" mon");
	      if (features2 & (1 << 4))
		print (" dscpl");
	      if (features2 & (1 << 8))
		print (" tm2");
	      if (features2 & (1 << 10))
		print (" cid");
	      
	      if (is_amd)
d888 2
a889 4
		  unsigned int a = 0, b, c, d;
		  cpuid (&a, &b, &c, &d, 0x80000000);
		  
		  if (a >= 0x80000001)  // has basic capabilities
d891 11
a901 3
		      cpuid (&a, &b, &c, &d, 0x80000001);
		      
		      if(d & (1 << 30)) // 31th bit is on
d903 1
a903 2
		      
		      if(d & (1 << 31)) // 32th bit (highest) is on
@


1.43
log
@	* fhandler_proc.cc (format_proc_cpuinfo): Test CPU vendor and print
	AMD specific 3dnow capabilities.
@
text
@d395 1
a395 1
  NTSTATUS ret;
@


1.42
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d701 8
d876 20
@


1.41
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d402 1
a402 1
        {
d419 1
a419 1
        {
d714 7
a720 7
	      unsigned type            = (cpuid_sig & 0x00003000) >> 12,
		       family          = (cpuid_sig & 0x00000f00) >> 8,
		       model           = (cpuid_sig & 0x000000f0) >> 4,
		       stepping        = cpuid_sig & 0x0000000f;
	      unsigned brand_id        = extra_info & 0x0000000f,
		       cpu_count       = (extra_info & 0x00ff0000) >> 16,
		       apic_id         = (extra_info & 0xff000000) >> 24;
d967 1
a967 1
		      				drive_number + 'a',
@


1.40
log
@	* fhandler_proc.cc (format_proc_meminfo): On NT, try to figure out
	real swap file usage by requesting SystemPagefileInformation.  Use
	GlobalMemoryStatus as fallback.
	* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemPagefileInformation.
	(struct _SYSTEM_PAGEFILE_INFORMATION): Define.
@
text
@d222 1
a222 1
  set_nohandle (true);
@


1.39
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@d393 36
a428 2
  swap_total = memory_status.dwTotalPageFile - mem_total;
  swap_free = memory_status.dwAvailPageFile - mem_total;
@


1.38
log
@2003-11-11  Robert Collins <rbtcollins@@hotmail.com>
	    Ron Parker <rdparker@@butlermfg.com>

	* bsdlib.cc: Update throughout to use CYG_MAX_PATH rather than MAX_PATH.
	* cygheap.h: Ditto.
	* dcrt0.cc: Ditto.
	* delqueue.cc: Ditto.
	* dlfcn.cc: Ditto.
	* dll_init.cc: Ditto.
	* dll_init.h: Ditto.
	* dtable.cc: Ditto.
	* environ.cc: Ditto.
	* environ.h: Ditto.
	* exceptions.cc: Ditto.
	* external.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_raw.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_socket.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* miscfuncs.cc: Ditto.
	* mmap.cc: Ditto.
	* netdb.cc: Ditto.
	* path.cc: Ditto.
	* path.h: Ditto.
	* pinfo.cc: Ditto.
	* pinfo.h: Ditto.
	* pthread.cc: Ditto.
	* registry.cc: Ditto.
	* shared.cc: Ditto.
	* shared_info.h: Ditto.
	* smallprint.c: Ditto.
	* spawn.cc: Ditto.
	* strace.cc: Ditto.
	* syscalls.cc: Ditto.
	* thread.h: Ditto.
	* uinfo.cc: Ditto.
	* winsup.h: Ditto.
	* include/limits.h: Ditto.
	* include/cygwin/config.h: Ditto.
	* include/sys/param.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002, 2003 Red Hat, Inc.
@


1.37
log
@	* fhandler_proc.cc (format_proc_partitions): Use new device code
	to get major and minor device numbers.  Fix size evaluation.
@
text
@d865 1
a865 1
	  CHAR szDriveName[MAX_PATH];
@


1.36
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d901 7
a907 3
		  bufptr += __small_sprintf (bufptr, "%5d %5d %9U sd%c\n",
					     FH_FLOPPY,
					     drive_number * 16 + 32,
d909 2
a910 2
					      dg.SectorsPerTrack * dg.BytesPerSector) >> 6),
					     drive_number + 'a');
d931 10
a940 6
		      bufptr += __small_sprintf (bufptr, "%5d %5d %9U sd%c%d\n",
						 FH_FLOPPY,
						 drive_number * 16 + partition + 33,
						 (long long)(dli->PartitionEntry[partition].PartitionLength.QuadPart >> 6),
						 drive_number + 'a',
						 partition + 1);
@


1.35
log
@* fhandler_disk_file.cc (fhandler_cygdrive::readdir): Do not change 'errno' if
end of directory condition is encountered as per SUSv2.
* fhandler_proc.cc (fhandler_proc::readdir): Ditto.
* fhandler_process (fhandler_process::readdir): Ditto.
* fhandler_registry (fhandler_registry::readdir): Ditto.
@
text
@d20 1
a21 1
#include "path.h"
d149 1
a149 6
  fhandler_virtual (FH_PROC)
{
}

fhandler_proc::fhandler_proc (DWORD devtype):
  fhandler_virtual (devtype)
d154 1
a154 1
fhandler_proc::fstat (struct __stat64 *buf, path_conv *pc)
d160 1
a160 1
  (void) fhandler_base::fstat (buf, pc);
d214 1
a214 1
fhandler_proc::open (path_conv *pc, int flags, mode_t mode)
d218 1
a218 1
  int res = fhandler_virtual::open (pc, flags, mode);
@


1.34
log
@* exceptions.cc (ctrl_c_handler): Send SIGHUP when events occur only if there
is a tty associated with the process.  Send SIGHUP on CTRL_LOGOFF_EVENT.
* fhandler_tty.cc (fhandler_tty_slave::open): Adjust console open handle
counter regardless of whether this is a pty or tty.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::dup): Ditto.
(fhandler_tty_common::set_close_on_exec): Ditto.
(fhandler_tty_master::init_console): Decrement console open handle counter
after init since it will now be handled by all tty open.
* syscalls.cc (setsid): Rework debugging output slightly.
@
text
@a208 1
      set_errno (ENMFILE);
@


1.33
log
@* fhandler_proc.cc (format_proc_stat): Use correctly sized constants for
filling in zeros on 98.
@
text
@d642 2
a643 2
          if (wincap.is_winnt ())
            {
d649 1
a649 1
	        print (" 3dnow");
d651 1
a651 1
	        print (" cx8");
d653 1
a653 1
	        print (" fpu");
d655 1
a655 1
	        print (" mmx");
d657 1
a657 1
	        print (" pae");
d659 1
a659 1
	        print (" tsc");
d661 1
a661 1
	        print (" sse");
d663 1
a663 1
	        print (" sse2");
d665 1
a665 1
        }
d674 3
a676 3
          unsigned cpu_mhz  = 0;
          if (wincap.is_winnt ())
            {
d679 1
a679 1
            }
d725 4
a728 4
              if (wincap.is_winnt ())
                {
	          bufptr += __small_sprintf (bufptr, "type            : %s\n"
	        				     "cpu family      : %d\n"
d747 22
a768 22
                }
              else
                {
                  bufptr += __small_sprintf (bufptr, "type            : %s\n"
                                                     "cpu family      : %d\n"
                                                     "model           : %d\n"
                                                     "model name      : %s\n"
                                                     "stepping        : %d\n"
                                                     "brand id        : %d\n"
                                                     "cpu count       : %d\n"
                                                     "apic id         : %d\n"
                                                     "fpu             : %s\n",
                                             type_str,
                                             family,
                                             model,
                                             szBuffer,
                                             stepping,
                                             brand_id,
                                             cpu_count,
                                             apic_id,
                                             (features1 & (1 << 0)) ? "yes" : "no");
                }
@


1.32
log
@* fhandler_proc.cc (fhandler_proc::fill_filebuf): Allocate more space for stat
buffer.
(format_proc_stat): Reorganize to accumulate and report on all cpus.
@
text
@d465 1
a465 1
    eobuf += __small_sprintf (destbuf, "cpu %U %U %U %U\n", 0, 0, 0, 0);
@


1.31
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d352 1
a352 1
	filebuf = (char *) realloc (filebuf, bufalloc = 2048);
a458 1
  unsigned long long user_time = 0ULL, kernel_time = 0ULL, idle_time = 0ULL;
d463 4
a466 1
  if (wincap.is_winnt ())
a468 1
      SYSTEM_PROCESSOR_TIMES spt;
d471 17
a487 3
      ret = NtQuerySystemInformation (SystemProcessorTimes,
				      (PVOID) &spt,
				      sizeof spt, NULL);
d489 25
a513 3
	ret = NtQuerySystemInformation (SystemPerformanceInformation,
					(PVOID) &spi,
					sizeof spi, NULL);
a525 4
      kernel_time = (spt.KernelTime.QuadPart - spt.IdleTime.QuadPart) * HZ / 10000000ULL;
      user_time = spt.UserTime.QuadPart * HZ / 10000000ULL;
      idle_time = spt.IdleTime.QuadPart * HZ / 10000000ULL;
      interrupt_count = spt.InterruptCount;
d548 1
a548 2
  return __small_sprintf (destbuf, "cpu %U %U %U %U\n"
				   "page %u %u\n"
d553 6
a558 7
			  user_time, 0ULL,
			  kernel_time, idle_time,
			  pages_in, pages_out,
			  swap_in, swap_out,
			  interrupt_count,
			  context_switches,
			  boot_time);
@


1.30
log
@	* fhandler_proc.cc (format_proc_meminfo): Make swap memory output
	Linux style values.
@
text
@a13 1
#include <errno.h>
@


1.29
log
@* Makefile.in: Use ${nostdlib} variable.
* fhandler_proc.cc (format_proc_cpuinfo): Change /proc/cpuinfo "vendor id"
string to "vendor_id" to conform with Linux systems.
@
text
@d400 2
a401 2
  swap_total = memory_status.dwTotalPageFile;
  swap_free = memory_status.dwAvailPageFile;
@


1.28
log
@* termios.cc (setspeed): New function.
(cfsetospeed): Use setspeed to set speed.
(cfsetispeed): Use setspeed to set speed.
* autoload.cc: Add load statement for UuidCreate, and UuidCreateSequential.
* cpuid.h: New file.
* cygwin.din: Export gethostid.
* fhandler_proc.cc (cpuid): Move to cpuid.h.
(can_set_flag): Move to cpuid.h.
* syscalls.cc (gethostid): New function.
* version.h: Bump DLL minor version number to 83.
@
text
@d609 1
a609 1
	  bufptr += __small_sprintf (bufptr, "vendor id       : %s\n", szBuffer);
d643 1
a643 1
	  bufptr += __small_sprintf (bufptr, "vendor id       : %s\n", (char *)vendor_id);
@


1.27
log
@	* dir.cc: Change __off32_t to _off_t and __off64_t to _off64_t
	throughout.
	* fhandler.cc: Ditto.
	* fhandler.h: Ditto.
	* fhandler_clipboard.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.
	* fhandler_dsp.cc: Ditto.
	* fhandler_floppy.cc: Ditto.
	* fhandler_mem.cc: Ditto.
	* fhandler_proc.cc: Ditto.
	* fhandler_process.cc: Ditto.
	* fhandler_random.cc: Ditto.
	* fhandler_registry.cc: Ditto.
	* fhandler_tape.cc: Ditto.
	* fhandler_termios.cc: Ditto.
	* fhandler_virtual.cc: Ditto.
	* fhandler_zero.cc: Ditto.
	* mmap.cc: Ditto.
	* pipe.cc: Ditto.
	* syscalls.cc: Ditto.
	* winsup.h: Ditto.
	* include/cygwin/stat.h: Ditto.
	* include/cygwin/types.h: Ditto.  Remove definition of __off32_t
	and __off64_t.
@
text
@d31 1
a552 31

static inline void
cpuid (unsigned *a, unsigned *b, unsigned *c, unsigned *d, unsigned in)
{
  asm ("cpuid"
       : "=a" (*a),
	 "=b" (*b),
	 "=c" (*c),
	 "=d" (*d)
       : "a" (in));
}

static inline bool
can_set_flag (unsigned flag)
{
  unsigned r1, r2;
  asm("pushfl\n"
      "popl %0\n"
      "movl %0, %1\n"
      "xorl %2, %0\n"
      "pushl %0\n"
      "popfl\n"
      "pushfl\n"
      "popl %0\n"
      "pushl %1\n"
      "popfl\n"
      : "=&r" (r1), "=&r" (r2)
      : "ir" (flag)
  );
  return ((r1 ^ r2) & flag) != 0;
}
@


1.26
log
@	* fhandler_proc.cc (format_proc_cpuinfo): Use IsProcessorFeaturePresent
	only on Windows NT. Read CPU Mhz value only on NT. Revert previous
	change so cpuid instruction is called even on non-NT systems.
@
text
@d82 5
a86 5
static __off64_t format_proc_meminfo (char *destbuf, size_t maxsize);
static __off64_t format_proc_stat (char *destbuf, size_t maxsize);
static __off64_t format_proc_uptime (char *destbuf, size_t maxsize);
static __off64_t format_proc_cpuinfo (char *destbuf, size_t maxsize);
static __off64_t format_proc_partitions (char *destbuf, size_t maxsize);
d390 1
a390 1
static __off64_t
d420 1
a420 1
static __off64_t
d456 1
a456 1
static __off64_t
d584 1
a584 1
static __off64_t
d861 1
a861 1
static __off64_t
@


1.25
log
@	* autoload.cc (IsProcessorFeaturePresent): Add.
	* fhandler_proc.cc (format_proc_cpuinfo): Add case for 9x systems.
@
text
@d634 2
a635 9
      if (!wincap.is_winnt ())
        {
	  bufptr += __small_sprintf (bufptr, "processor       : %d\n", cpu_number);
	  read_value ("VendorIdentifier", REG_SZ);
	  bufptr += __small_sprintf (bufptr, "vendor id       : %s\n", szBuffer);
	  read_value ("Identifier", REG_SZ);
	  bufptr += __small_sprintf (bufptr, "identifier      : %s\n", szBuffer);
	}
      else if (!has_cpuid)
d642 4
a645 2
	  read_value ("~Mhz", REG_DWORD);
	  bufptr += __small_sprintf (bufptr, "cpu MHz         : %u\n", *(DWORD *) szBuffer);
d647 19
a665 18
	  print ("flags           :");
	  if (IsProcessorFeaturePresent (PF_3DNOW_INSTRUCTIONS_AVAILABLE))
	    print (" 3dnow");
	  if (IsProcessorFeaturePresent (PF_COMPARE_EXCHANGE_DOUBLE))
	    print (" cx8");
	  if (!IsProcessorFeaturePresent (PF_FLOATING_POINT_EMULATED))
	    print (" fpu");
	  if (IsProcessorFeaturePresent (PF_MMX_INSTRUCTIONS_AVAILABLE))
	    print (" mmx");
	  if (IsProcessorFeaturePresent (PF_PAE_ENABLED))
	    print (" pae");
	  if (IsProcessorFeaturePresent (PF_RDTSC_INSTRUCTION_AVAILABLE))
	    print (" tsc");
	  if (IsProcessorFeaturePresent (PF_XMMI_INSTRUCTIONS_AVAILABLE))
	    print (" sse");
	  if (IsProcessorFeaturePresent (PF_XMMI64_INSTRUCTIONS_AVAILABLE))
	    print (" sse2");
	}
d674 6
a679 2
	  read_value ("~Mhz", REG_DWORD);
	  unsigned cpu_mhz = *(DWORD *)szBuffer;
d725 44
a768 20
	      bufptr += __small_sprintf (bufptr, "type            : %s\n"
						 "cpu family      : %d\n"
						 "model           : %d\n"
						 "model name      : %s\n"
						 "stepping        : %d\n"
						 "brand id        : %d\n"
						 "cpu count       : %d\n"
						 "apic id         : %d\n"
						 "cpu MHz         : %d\n"
						 "fpu             : %s\n",
					 type_str,
					 family,
					 model,
					 szBuffer,
					 stepping,
					 brand_id,
					 cpu_count,
					 apic_id,
					 cpu_mhz,
					 IsProcessorFeaturePresent (PF_FLOATING_POINT_EMULATED) ? "no" : "yes");
d841 1
a841 1
	  else
@


1.24
log
@	* fhandler_proc.cc (format_proc_cpuinfo): Fix vendor id in cpuid case.
@
text
@d634 9
a642 1
      if (!has_cpuid)
@


1.23
log
@Do some minor reformatting of 'extern "C"' use throughout.
* autoload.cc (GetSystemTimes): Define new autoload function.
* fhandler_proc.cc (proc_listing): Add cpuinfo and partitions entries.
(fhandler_proc::fill_filebuf): Add PROC_CPUINFO and PROC_PARTITIONS cases.
(format_proc_uptime): Use GetSystemTimes if available.
(read_value): New macro.
(print): New macro.
(cpuid): New function.
(can_set_flag): New function.
(format_proc_cpuinfo): New function.
(format_proc_partitions): New function.
@
text
@d666 1
a666 1
	  cpuid (&maxf, &vendor_id[0], &vendor_id[1], &vendor_id[2], 0);
@


1.23.2.1
log
@* fhandler_proc.cc (format_proc_cpuinfo): Fix vendor id in cpuid case.
* net.cc (cygwin_rcmd): Use correct file descriptor in call to fdsock.
(cygwin_rexec): Ditto.
@
text
@d666 1
a666 1
	  cpuid (&maxf, &vendor_id[0], &vendor_id[2], &vendor_id[1], 0);
@


1.23.2.2
log
@* include/cygwin/version.h: Bump DLL minor number to 22.
* autoload.cc (IsProcessorFeaturePresent): Add.
* fhandler_proc.cc (format_proc_cpuinfo): Add case for 9x systems.
@
text
@d634 1
a634 9
      if (!wincap.is_winnt ())
        {
	  bufptr += __small_sprintf (bufptr, "processor       : %d\n", cpu_number);
	  read_value ("VendorIdentifier", REG_SZ);
	  bufptr += __small_sprintf (bufptr, "vendor id       : %s\n", szBuffer);
	  read_value ("Identifier", REG_SZ);
	  bufptr += __small_sprintf (bufptr, "identifier      : %s\n", szBuffer);
	}
      else if (!has_cpuid)
@


1.23.2.3
log
@	* fhandler_proc.cc (format_proc_cpuinfo): Use IsProcessorFeaturePresent
	only on Windows NT. Read CPU Mhz value only on NT. Revert previous
	change so cpuid instruction is called even on non-NT systems.
@
text
@d634 9
a642 2

      if (!has_cpuid)
d649 2
a650 4
          if (wincap.is_winnt ())
            {
	      read_value ("~Mhz", REG_DWORD);
	      bufptr += __small_sprintf (bufptr, "cpu MHz         : %u\n", *(DWORD *) szBuffer);
d652 18
a669 19
	      print ("flags           :");
	      if (IsProcessorFeaturePresent (PF_3DNOW_INSTRUCTIONS_AVAILABLE))
	        print (" 3dnow");
	      if (IsProcessorFeaturePresent (PF_COMPARE_EXCHANGE_DOUBLE))
	        print (" cx8");
	      if (!IsProcessorFeaturePresent (PF_FLOATING_POINT_EMULATED))
	        print (" fpu");
	      if (IsProcessorFeaturePresent (PF_MMX_INSTRUCTIONS_AVAILABLE))
	        print (" mmx");
	      if (IsProcessorFeaturePresent (PF_PAE_ENABLED))
	        print (" pae");
	      if (IsProcessorFeaturePresent (PF_RDTSC_INSTRUCTION_AVAILABLE))
	        print (" tsc");
	      if (IsProcessorFeaturePresent (PF_XMMI_INSTRUCTIONS_AVAILABLE))
	        print (" sse");
	      if (IsProcessorFeaturePresent (PF_XMMI64_INSTRUCTIONS_AVAILABLE))
	        print (" sse2");
	    }
        }
d678 2
a679 6
          unsigned cpu_mhz  = 0;
          if (wincap.is_winnt ())
            {
	      read_value ("~Mhz", REG_DWORD);
	      cpu_mhz = *(DWORD *)szBuffer;
            }
d725 20
a744 44
              if (wincap.is_winnt ())
                {
	          bufptr += __small_sprintf (bufptr, "type            : %s\n"
	        				     "cpu family      : %d\n"
						     "model           : %d\n"
						     "model name      : %s\n"
						     "stepping        : %d\n"
						     "brand id        : %d\n"
						     "cpu count       : %d\n"
						     "apic id         : %d\n"
						     "cpu MHz         : %d\n"
						     "fpu             : %s\n",
					     type_str,
					     family,
					     model,
					     szBuffer,
					     stepping,
					     brand_id,
					     cpu_count,
					     apic_id,
					     cpu_mhz,
					     (features1 & (1 << 0)) ? "yes" : "no");
                }
              else
                {
                  bufptr += __small_sprintf (bufptr, "type            : %s\n"
                                                     "cpu family      : %d\n"
                                                     "model           : %d\n"
                                                     "model name      : %s\n"
                                                     "stepping        : %d\n"
                                                     "brand id        : %d\n"
                                                     "cpu count       : %d\n"
                                                     "apic id         : %d\n"
                                                     "fpu             : %s\n",
                                             type_str,
                                             family,
                                             model,
                                             szBuffer,
                                             stepping,
                                             brand_id,
                                             cpu_count,
                                             apic_id,
                                             (features1 & (1 << 0)) ? "yes" : "no");
                }
d817 1
a817 1
	  else if (wincap.is_winnt ())
@


1.22
log
@Revert below changes regarding _pinfo::cmdline.
@
text
@d11 2
d30 1
d42 2
d55 2
d73 3
a75 1
  FH_PROC
d85 2
d88 3
a90 4
/* auxillary function that returns the fhandler associated with the given path
 * this is where it would be nice to have pattern matching in C - polymorphism
 * just doesn't cut it
 */
d97 2
a98 3
   * it being normalised and therefore the path may have runs of slashes
   * in it.
   */
d133 1
a133 2
 * <0 if path is a file.
 */
d374 12
d426 19
a444 17
  NTSTATUS ret = NtQuerySystemInformation (SystemProcessorTimes, (PVOID) &spt,
					   sizeof spt, NULL);
  if (!ret && GetLastError () == ERROR_PROC_NOT_FOUND)
    uptime = GetTickCount () / 10;
  else if (ret != STATUS_SUCCESS)
    {
      __seterrno_from_win_error (RtlNtStatusToDosError (ret));
      debug_printf("NtQuerySystemInformation: ret = %d, "
		   "Dos(ret) = %d",
		   ret, RtlNtStatusToDosError (ret));
      return 0;
    }
  else
    {
      idle_time = spt.IdleTime.QuadPart / 100000ULL;
      uptime = (spt.KernelTime.QuadPart +
			spt.UserTime.QuadPart) / 100000ULL;
d446 4
d529 395
@


1.21
log
@	* external.cc (cygwin_internal): Change n to __off64_t to match change
	of _pinfo::cmdline.
	* fhandler.h (class fhandler_virtual): Change filesize member to
	__off64_t.
	* fhandler_proc.cc (format_proc_meminfo): Change to return __off64_t.
	(format_proc_stat): Ditto.
	(format_proc_uptime): Ditto.
	* fhandler_process.cc (format_process_stat): Ditto.
	(format_process_status): Ditto.
	(format_process_statm): Ditto.
	* pinfo.cc (_pinfo::cmdline): Expect __off64_t parameter.
	* pinfo.h (class _pinfo): Change declaration of cmdline accordingly.
@
text
@d370 1
a370 2
static
__off64_t
d400 1
a400 2
static
__off64_t
d430 1
a430 2
static
__off64_t
@


1.20
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d73 3
a75 3
static off_t format_proc_meminfo (char *destbuf, size_t maxsize);
static off_t format_proc_stat (char *destbuf, size_t maxsize);
static off_t format_proc_uptime (char *destbuf, size_t maxsize);
d371 1
a371 1
off_t
d402 1
a402 1
off_t
d433 1
a433 1
off_t
@


1.20.2.1
log
@merge from trunk
@
text
@d141 6
a146 1
  fhandler_virtual ()
@


1.20.2.2
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d19 1
a20 1
#include "fhandler.h"
d87 3
a89 2
     it being normalised and therefore the path may have runs of slashes
     in it.  */
d146 1
a146 1
fhandler_proc::fstat (struct __stat64 *buf)
d152 1
a152 1
  (void) fhandler_base::fstat (buf);
d207 1
a207 1
fhandler_proc::open (int flags, mode_t mode)
d211 1
a211 1
  int res = fhandler_virtual::open (flags, mode);
@


1.20.2.3
log
@merge from trunk
@
text
@d73 3
a75 3
static __off64_t format_proc_meminfo (char *destbuf, size_t maxsize);
static __off64_t format_proc_stat (char *destbuf, size_t maxsize);
static __off64_t format_proc_uptime (char *destbuf, size_t maxsize);
d364 2
a365 1
static __off64_t
d395 2
a396 1
static __off64_t
d426 2
a427 1
static __off64_t
@


1.20.2.4
log
@merge from trunk
@
text
@a10 2
#define _WIN32_WINNT 0x0501

a27 1
#include <winioctl.h>
a38 2
static const int PROC_CPUINFO  = 8;     // /proc/cpuinfo
static const int PROC_PARTITIONS = 9;   // /proc/partitions
a49 2
  "cpuinfo",
  "partitions",
d66 1
a66 3
  FH_PROC,
  FH_PROC,
  FH_PROC,
a75 2
static __off64_t format_proc_cpuinfo (char *destbuf, size_t maxsize);
static __off64_t format_proc_partitions (char *destbuf, size_t maxsize);
d77 4
a80 3
/* Auxillary function that returns the fhandler associated with the given path
   this is where it would be nice to have pattern matching in C - polymorphism
   just doesn't cut it. */
d123 2
a124 1
   <0 if path is a file.  */
a359 12
    case PROC_CPUINFO:
      {
	filebuf = (char *) realloc (filebuf, bufalloc = 16384);
	filesize = format_proc_cpuinfo (filebuf, bufalloc);
	break;
      }
    case PROC_PARTITIONS:
      {
	filebuf = (char *) realloc (filebuf, bufalloc = 4096);
	filesize = format_proc_partitions (filebuf, bufalloc);
	break;
      }
d400 17
a416 19
  if (!GetSystemTimes ((FILETIME *) &spt.IdleTime, (FILETIME *) &spt.KernelTime,
		       (FILETIME *) &spt.UserTime)
      && GetLastError () == ERROR_PROC_NOT_FOUND)
    {
      NTSTATUS ret = NtQuerySystemInformation (SystemProcessorTimes, (PVOID) &spt,
					       sizeof spt, NULL);
      if (!ret && GetLastError () == ERROR_PROC_NOT_FOUND)
	{
	  uptime = GetTickCount () / 10;
	  goto out;
	}
      else if (ret != STATUS_SUCCESS)
	{
	  __seterrno_from_win_error (RtlNtStatusToDosError (ret));
	  debug_printf("NtQuerySystemInformation: ret = %d, "
		       "Dos(ret) = %d",
		       ret, RtlNtStatusToDosError (ret));
	  return 0;
	}
a417 4
  idle_time = spt.IdleTime.QuadPart / 100000ULL;
  uptime = (spt.KernelTime.QuadPart +
	    spt.UserTime.QuadPart) / 100000ULL;
out:
a496 395

#define read_value(x,y) \
      do {\
	dwCount = BUFSIZE; \
	if ((dwError = RegQueryValueEx (hKey, x, NULL, &dwType, (BYTE *) szBuffer, &dwCount)), \
	    (dwError != ERROR_SUCCESS && dwError != ERROR_MORE_DATA)) \
	  { \
	    __seterrno_from_win_error (dwError); \
	    debug_printf ("RegQueryValueEx failed retcode %d", dwError); \
	    return 0; \
	  } \
	if (dwType != y) \
	  { \
	    debug_printf ("Value %s had an unexpected type (expected %d, found %d)", y, dwType); \
	    return 0; \
	  }\
      } while (0)

#define print(x) \
	do { \
	  strcpy (bufptr, x), \
	  bufptr += sizeof (x) - 1; \
	} while (0)

static inline void
cpuid (unsigned *a, unsigned *b, unsigned *c, unsigned *d, unsigned in)
{
  asm ("cpuid"
       : "=a" (*a),
	 "=b" (*b),
	 "=c" (*c),
	 "=d" (*d)
       : "a" (in));
}

static inline bool
can_set_flag (unsigned flag)
{
  unsigned r1, r2;
  asm("pushfl\n"
      "popl %0\n"
      "movl %0, %1\n"
      "xorl %2, %0\n"
      "pushl %0\n"
      "popfl\n"
      "pushfl\n"
      "popl %0\n"
      "pushl %1\n"
      "popfl\n"
      : "=&r" (r1), "=&r" (r2)
      : "ir" (flag)
  );
  return ((r1 ^ r2) & flag) != 0;
}

static __off64_t
format_proc_cpuinfo (char *destbuf, size_t maxsize)
{
  SYSTEM_INFO siSystemInfo;
  HKEY hKey;
  DWORD dwError, dwCount, dwType;
  DWORD dwOldThreadAffinityMask;
  int cpu_number;
  const int BUFSIZE = 256;
  CHAR szBuffer[BUFSIZE];
  char *bufptr = destbuf;

  GetSystemInfo (&siSystemInfo);

  for (cpu_number = 0;;cpu_number++)
    {
      __small_sprintf (szBuffer, "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\%d", cpu_number);

      if ((dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_QUERY_VALUE, &hKey)) != ERROR_SUCCESS)
	{
	  if (dwError == ERROR_FILE_NOT_FOUND)
	    break;
	  __seterrno_from_win_error (dwError);
	  debug_printf ("RegOpenKeyEx failed retcode %d", dwError);
	  return 0;
	}

      dwOldThreadAffinityMask = SetThreadAffinityMask (GetCurrentThread (), 1 << cpu_number);
      if (dwOldThreadAffinityMask == 0)
	debug_printf ("SetThreadAffinityMask failed %E");
      // I'm not sure whether the thread changes processor immediately
      // and I'm not sure whether this function will cause the thread to be rescheduled
      low_priority_sleep (0);

      bool has_cpuid = false;

      if (!can_set_flag (0x00040000))
	debug_printf ("386 processor - no cpuid");
      else
	{
	  debug_printf ("486 processor");
	  if (can_set_flag (0x00200000))
	    {
	      debug_printf ("processor supports CPUID instruction");
	      has_cpuid = true;
	    }
	  else
	    debug_printf ("processor does not support CPUID instruction");
	}

      if (!has_cpuid)
	{
	  bufptr += __small_sprintf (bufptr, "processor       : %d\n", cpu_number);
	  read_value ("VendorIdentifier", REG_SZ);
	  bufptr += __small_sprintf (bufptr, "vendor id       : %s\n", szBuffer);
	  read_value ("Identifier", REG_SZ);
	  bufptr += __small_sprintf (bufptr, "identifier      : %s\n", szBuffer);
	  read_value ("~Mhz", REG_DWORD);
	  bufptr += __small_sprintf (bufptr, "cpu MHz         : %u\n", *(DWORD *) szBuffer);

	  print ("flags           :");
	  if (IsProcessorFeaturePresent (PF_3DNOW_INSTRUCTIONS_AVAILABLE))
	    print (" 3dnow");
	  if (IsProcessorFeaturePresent (PF_COMPARE_EXCHANGE_DOUBLE))
	    print (" cx8");
	  if (!IsProcessorFeaturePresent (PF_FLOATING_POINT_EMULATED))
	    print (" fpu");
	  if (IsProcessorFeaturePresent (PF_MMX_INSTRUCTIONS_AVAILABLE))
	    print (" mmx");
	  if (IsProcessorFeaturePresent (PF_PAE_ENABLED))
	    print (" pae");
	  if (IsProcessorFeaturePresent (PF_RDTSC_INSTRUCTION_AVAILABLE))
	    print (" tsc");
	  if (IsProcessorFeaturePresent (PF_XMMI_INSTRUCTIONS_AVAILABLE))
	    print (" sse");
	  if (IsProcessorFeaturePresent (PF_XMMI64_INSTRUCTIONS_AVAILABLE))
	    print (" sse2");
	}
      else
	{
	  bufptr += __small_sprintf (bufptr, "processor       : %d\n", cpu_number);
	  unsigned maxf, vendor_id[4], unused;
	  cpuid (&maxf, &vendor_id[0], &vendor_id[1], &vendor_id[2], 0);
	  maxf &= 0xffff;
	  vendor_id[3] = 0;
	  bufptr += __small_sprintf (bufptr, "vendor id       : %s\n", (char *)vendor_id);
	  read_value ("~Mhz", REG_DWORD);
	  unsigned cpu_mhz = *(DWORD *)szBuffer;
	  if (maxf >= 1)
	    {
	      unsigned features2, features1, extra_info, cpuid_sig;
	      cpuid (&cpuid_sig, &extra_info, &features2, &features1, 1);
	      /* unsigned extended_family = (cpuid_sig & 0x0ff00000) >> 20,
			  extended_model  = (cpuid_sig & 0x000f0000) >> 16; */
	      unsigned type            = (cpuid_sig & 0x00003000) >> 12,
		       family          = (cpuid_sig & 0x00000f00) >> 8,
		       model           = (cpuid_sig & 0x000000f0) >> 4,
		       stepping        = cpuid_sig & 0x0000000f;
	      unsigned brand_id        = extra_info & 0x0000000f,
		       cpu_count       = (extra_info & 0x00ff0000) >> 16,
		       apic_id         = (extra_info & 0xff000000) >> 24;
	      const char *type_str;
	      switch (type)
		{
		case 0:
		  type_str = "primary processor";
		  break;
		case 1:
		  type_str = "overdrive processor";
		  break;
		case 2:
		  type_str = "secondary processor";
		  break;
		case 3:
		default:
		  type_str = "reserved";
		  break;
		}
	      unsigned maxe = 0;
	      cpuid (&maxe, &unused, &unused, &unused, 0x80000000);
	      if (maxe >= 0x80000004)
		{
		  unsigned *model_name = (unsigned *) szBuffer;
		  cpuid (&model_name[0], &model_name[1], &model_name[2], &model_name[3], 0x80000002);
		  cpuid (&model_name[4], &model_name[5], &model_name[6], &model_name[7], 0x80000003);
		  cpuid (&model_name[8], &model_name[9], &model_name[10], &model_name[11], 0x80000004);
		  model_name[12] = 0;
		}
	      else
		{
		  // could implement a lookup table here if someone needs it
		  strcpy (szBuffer, "unknown");
		}
	      bufptr += __small_sprintf (bufptr, "type            : %s\n"
						 "cpu family      : %d\n"
						 "model           : %d\n"
						 "model name      : %s\n"
						 "stepping        : %d\n"
						 "brand id        : %d\n"
						 "cpu count       : %d\n"
						 "apic id         : %d\n"
						 "cpu MHz         : %d\n"
						 "fpu             : %s\n",
					 type_str,
					 family,
					 model,
					 szBuffer,
					 stepping,
					 brand_id,
					 cpu_count,
					 apic_id,
					 cpu_mhz,
					 IsProcessorFeaturePresent (PF_FLOATING_POINT_EMULATED) ? "no" : "yes");
	      print ("flags           :");
	      if (features1 & (1 << 0))
		print (" fpu");
	      if (features1 & (1 << 1))
		print (" vme");
	      if (features1 & (1 << 2))
		print (" de");
	      if (features1 & (1 << 3))
		print (" pse");
	      if (features1 & (1 << 4))
		print (" tsc");
	      if (features1 & (1 << 5))
		print (" msr");
	      if (features1 & (1 << 6))
		print (" pae");
	      if (features1 & (1 << 7))
		print (" mce");
	      if (features1 & (1 << 8))
		print (" cx8");
	      if (features1 & (1 << 9))
		print (" apic");
	      if (features1 & (1 << 11))
		print (" sep");
	      if (features1 & (1 << 12))
		print (" mtrr");
	      if (features1 & (1 << 13))
		print (" pge");
	      if (features1 & (1 << 14))
		print (" mca");
	      if (features1 & (1 << 15))
		print (" cmov");
	      if (features1 & (1 << 16))
		print (" pat");
	      if (features1 & (1 << 17))
		print (" pse36");
	      if (features1 & (1 << 18))
		print (" psn");
	      if (features1 & (1 << 19))
		print (" clfl");
	      if (features1 & (1 << 21))
		print (" dtes");
	      if (features1 & (1 << 22))
		print (" acpi");
	      if (features1 & (1 << 23))
		print (" mmx");
	      if (features1 & (1 << 24))
		print (" fxsr");
	      if (features1 & (1 << 25))
		print (" sse");
	      if (features1 & (1 << 26))
		print (" sse2");
	      if (features1 & (1 << 27))
		print (" ss");
	      if (features1 & (1 << 28))
		print (" htt");
	      if (features1 & (1 << 29))
		print (" tmi");
	      if (features1 & (1 << 30))
		print (" ia-64");
	      if (features1 & (1 << 31))
		print (" pbe");
	      if (features2 & (1 << 0))
		print (" sse3");
	      if (features2 & (1 << 3))
		print (" mon");
	      if (features2 & (1 << 4))
		print (" dscpl");
	      if (features2 & (1 << 8))
		print (" tm2");
	      if (features2 & (1 << 10))
		print (" cid");
	    }
	  else
	    {
	      bufptr += __small_sprintf (bufptr, "cpu MHz         : %d\n"
						 "fpu             : %s\n",
						 cpu_mhz,
						 IsProcessorFeaturePresent (PF_FLOATING_POINT_EMULATED) ? "no" : "yes");
	    }
	}
      if (dwOldThreadAffinityMask != 0)
	SetThreadAffinityMask (GetCurrentThread (), dwOldThreadAffinityMask);

      RegCloseKey (hKey);
      bufptr += __small_sprintf (bufptr, "\n");
  }

  return bufptr - destbuf;
}

#undef read_value

static __off64_t
format_proc_partitions (char *destbuf, size_t maxsize)
{
  char *bufptr = destbuf;
  print ("major minor  #blocks  name\n\n");

  if (wincap.is_winnt ())
    {
      for (int drive_number=0;;drive_number++)
	{
	  CHAR szDriveName[MAX_PATH];
	  __small_sprintf (szDriveName, "\\\\.\\PHYSICALDRIVE%d", drive_number);
	  HANDLE hDevice;
	  hDevice = CreateFile (szDriveName,
				GENERIC_READ,
				FILE_SHARE_READ | FILE_SHARE_WRITE,
				NULL,
				OPEN_EXISTING,
				0,
				NULL);
	  if (hDevice == INVALID_HANDLE_VALUE)
	    {
	      if (GetLastError () == ERROR_PATH_NOT_FOUND)
		  break;
	      __seterrno ();
	      debug_printf ("CreateFile %d %E", GetLastError ());
	      break;
	    }
	  else
	    {
	      DWORD dwBytesReturned, dwRetCode;
	      DISK_GEOMETRY dg;
	      int buf_size = 4096;
	      char buf[buf_size];
	      dwRetCode = DeviceIoControl (hDevice,
					   IOCTL_DISK_GET_DRIVE_GEOMETRY,
					   NULL,
					   0,
					   &dg,
					   sizeof (dg),
					   &dwBytesReturned,
					   NULL);
	      if (!dwRetCode)
		debug_printf ("DeviceIoControl %E");
	      else
		{
		  bufptr += __small_sprintf (bufptr, "%5d %5d %9U sd%c\n",
					     FH_FLOPPY,
					     drive_number * 16 + 32,
					     (long long)((dg.Cylinders.QuadPart * dg.TracksPerCylinder *
					      dg.SectorsPerTrack * dg.BytesPerSector) >> 6),
					     drive_number + 'a');
		}
	      while (dwRetCode = DeviceIoControl (hDevice,
						  IOCTL_DISK_GET_DRIVE_LAYOUT,
						  NULL,
						  0,
						  (DRIVE_LAYOUT_INFORMATION *) buf,
						  buf_size,
						  &dwBytesReturned,
						  NULL),
		     !dwRetCode && GetLastError () == ERROR_INSUFFICIENT_BUFFER)
	      buf_size *= 2;
	      if (!dwRetCode)
		debug_printf ("DeviceIoControl %E");
	      else
		{
		  DRIVE_LAYOUT_INFORMATION *dli = (DRIVE_LAYOUT_INFORMATION *) buf;
		  for (unsigned partition = 0; partition < dli->PartitionCount; partition++)
		    {
		      if (dli->PartitionEntry[partition].PartitionLength.QuadPart == 0)
			continue;
		      bufptr += __small_sprintf (bufptr, "%5d %5d %9U sd%c%d\n",
						 FH_FLOPPY,
						 drive_number * 16 + partition + 33,
						 (long long)(dli->PartitionEntry[partition].PartitionLength.QuadPart >> 6),
						 drive_number + 'a',
						 partition + 1);
		    }
		}

	      CloseHandle (hDevice);
	    }
	}
    }
  else
    {
      // not worth the effort
      // you need a 16 bit thunk DLL to access the partition table on Win9x
      // and then you have to decode it yourself
    }
  return bufptr - destbuf;
}

#undef print
@


1.20.2.5
log
@merge from trunk
@
text
@a628 1

d636 2
a637 4
          if (wincap.is_winnt ())
            {
	      read_value ("~Mhz", REG_DWORD);
	      bufptr += __small_sprintf (bufptr, "cpu MHz         : %u\n", *(DWORD *) szBuffer);
d639 18
a656 19
	      print ("flags           :");
	      if (IsProcessorFeaturePresent (PF_3DNOW_INSTRUCTIONS_AVAILABLE))
	        print (" 3dnow");
	      if (IsProcessorFeaturePresent (PF_COMPARE_EXCHANGE_DOUBLE))
	        print (" cx8");
	      if (!IsProcessorFeaturePresent (PF_FLOATING_POINT_EMULATED))
	        print (" fpu");
	      if (IsProcessorFeaturePresent (PF_MMX_INSTRUCTIONS_AVAILABLE))
	        print (" mmx");
	      if (IsProcessorFeaturePresent (PF_PAE_ENABLED))
	        print (" pae");
	      if (IsProcessorFeaturePresent (PF_RDTSC_INSTRUCTION_AVAILABLE))
	        print (" tsc");
	      if (IsProcessorFeaturePresent (PF_XMMI_INSTRUCTIONS_AVAILABLE))
	        print (" sse");
	      if (IsProcessorFeaturePresent (PF_XMMI64_INSTRUCTIONS_AVAILABLE))
	        print (" sse2");
	    }
        }
d661 1
a661 1
	  cpuid (&maxf, &vendor_id[0], &vendor_id[2], &vendor_id[1], 0);
d665 2
a666 6
          unsigned cpu_mhz  = 0;
          if (wincap.is_winnt ())
            {
	      read_value ("~Mhz", REG_DWORD);
	      cpu_mhz = *(DWORD *)szBuffer;
            }
d712 20
a731 44
              if (wincap.is_winnt ())
                {
	          bufptr += __small_sprintf (bufptr, "type            : %s\n"
	        				     "cpu family      : %d\n"
						     "model           : %d\n"
						     "model name      : %s\n"
						     "stepping        : %d\n"
						     "brand id        : %d\n"
						     "cpu count       : %d\n"
						     "apic id         : %d\n"
						     "cpu MHz         : %d\n"
						     "fpu             : %s\n",
					     type_str,
					     family,
					     model,
					     szBuffer,
					     stepping,
					     brand_id,
					     cpu_count,
					     apic_id,
					     cpu_mhz,
					     (features1 & (1 << 0)) ? "yes" : "no");
                }
              else
                {
                  bufptr += __small_sprintf (bufptr, "type            : %s\n"
                                                     "cpu family      : %d\n"
                                                     "model           : %d\n"
                                                     "model name      : %s\n"
                                                     "stepping        : %d\n"
                                                     "brand id        : %d\n"
                                                     "cpu count       : %d\n"
                                                     "apic id         : %d\n"
                                                     "fpu             : %s\n",
                                             type_str,
                                             family,
                                             model,
                                             szBuffer,
                                             stepping,
                                             brand_id,
                                             cpu_count,
                                             apic_id,
                                             (features1 & (1 << 0)) ? "yes" : "no");
                }
d804 1
a804 1
	  else if (wincap.is_winnt ())
@


1.20.2.6
log
@merge from trunk
@
text
@d82 5
a86 5
static _off64_t format_proc_meminfo (char *destbuf, size_t maxsize);
static _off64_t format_proc_stat (char *destbuf, size_t maxsize);
static _off64_t format_proc_uptime (char *destbuf, size_t maxsize);
static _off64_t format_proc_cpuinfo (char *destbuf, size_t maxsize);
static _off64_t format_proc_partitions (char *destbuf, size_t maxsize);
d385 1
a385 1
static _off64_t
d415 1
a415 1
static _off64_t
d451 1
a451 1
static _off64_t
d579 1
a579 1
static _off64_t
d856 1
a856 1
static _off64_t
@


1.20.2.7
log
@merge from trunk
@
text
@a30 1
#include "cpuid.h"
d548 31
d634 1
a634 1
	  bufptr += __small_sprintf (bufptr, "vendor_id       : %s\n", szBuffer);
d668 1
a668 1
	  bufptr += __small_sprintf (bufptr, "vendor_id       : %s\n", (char *)vendor_id);
@


1.20.2.8
log
@merge from trunk
@
text
@d395 2
a396 2
  swap_total = memory_status.dwTotalPageFile - mem_total;
  swap_free = memory_status.dwAvailPageFile - mem_total;
@


1.20.2.9
log
@merge from trunk
@
text
@d14 1
@


1.20.2.10
log
@merge from trunk
@
text
@d347 1
a347 1
	filebuf = (char *) realloc (filebuf, bufalloc = 16384);
d454 1
d459 1
a459 4
  char *eobuf = destbuf;
  if (!wincap.is_winnt ())
    eobuf += __small_sprintf (destbuf, "cpu %U %U %U %U\n", 0, 0, 0, 0);
  else
d462 1
d465 3
a467 17

      SYSTEM_BASIC_INFORMATION sbi;
      if ((ret = NtQuerySystemInformation (SystemBasicInformation,
					   (PVOID) &sbi, sizeof sbi, NULL))
	  != STATUS_SUCCESS)
	{
	  __seterrno_from_win_error (RtlNtStatusToDosError (ret));
	  debug_printf ("NtQuerySystemInformation: ret = %d, "
			"Dos(ret) = %d",
			ret, RtlNtStatusToDosError (ret));
	  sbi.NumberProcessors = 1;
	}

      SYSTEM_PROCESSOR_TIMES spt[sbi.NumberProcessors];
      ret = NtQuerySystemInformation (SystemProcessorTimes, (PVOID) spt,
				      sizeof spt[0] * sbi.NumberProcessors, NULL);
      interrupt_count = 0;
d469 3
a471 25
	{
	  unsigned long long user_time = 0ULL, kernel_time = 0ULL, idle_time = 0ULL;
	  for (int i = 0; i < sbi.NumberProcessors; i++)
	    {
	      kernel_time += (spt[i].KernelTime.QuadPart - spt[i].IdleTime.QuadPart) * HZ / 10000000ULL;
	      user_time += spt[i].UserTime.QuadPart * HZ / 10000000ULL;
	      idle_time += spt[i].IdleTime.QuadPart * HZ / 10000000ULL;
	    }

	  eobuf += __small_sprintf (eobuf, "cpu %U %U %U %U\n",
				    user_time, 0ULL, kernel_time, idle_time);
	  user_time = 0ULL, kernel_time = 0ULL, idle_time = 0ULL;
	  for (int i = 0; i < sbi.NumberProcessors; i++)
	    {
	      interrupt_count += spt[i].InterruptCount;
	      kernel_time = (spt[i].KernelTime.QuadPart - spt[i].IdleTime.QuadPart) * HZ / 10000000ULL;
	      user_time = spt[i].UserTime.QuadPart * HZ / 10000000ULL;
	      idle_time = spt[i].IdleTime.QuadPart * HZ / 10000000ULL;
	      eobuf += __small_sprintf (eobuf, "cpu%d %U %U %U %U\n", i,
					user_time, 0ULL, kernel_time, idle_time);
	    }

	  ret = NtQuerySystemInformation (SystemPerformanceInformation,
					  (PVOID) &spi, sizeof spi, NULL);
	}
d484 4
d510 2
a511 1
  eobuf += __small_sprintf (eobuf, "page %u %u\n"
d516 7
a522 6
				   pages_in, pages_out,
				   swap_in, swap_out,
				   interrupt_count,
				   context_switches,
				   boot_time);
  return eobuf - destbuf;
@


1.20.2.11
log
@merge from trunk
@
text
@d204 1
d460 1
a460 1
    eobuf += __small_sprintf (destbuf, "cpu %U %U %U %U\n", 0ULL, 0ULL, 0ULL, 0ULL);
d637 2
a638 2
	  if (wincap.is_winnt ())
	    {
d644 1
a644 1
		print (" 3dnow");
d646 1
a646 1
		print (" cx8");
d648 1
a648 1
		print (" fpu");
d650 1
a650 1
		print (" mmx");
d652 1
a652 1
		print (" pae");
d654 1
a654 1
		print (" tsc");
d656 1
a656 1
		print (" sse");
d658 1
a658 1
		print (" sse2");
d660 1
a660 1
	}
d669 3
a671 3
	  unsigned cpu_mhz  = 0;
	  if (wincap.is_winnt ())
	    {
d674 1
a674 1
	    }
d720 4
a723 4
	      if (wincap.is_winnt ())
		{
		  bufptr += __small_sprintf (bufptr, "type            : %s\n"
						     "cpu family      : %d\n"
d742 22
a763 22
		}
	      else
		{
		  bufptr += __small_sprintf (bufptr, "type            : %s\n"
						     "cpu family      : %d\n"
						     "model           : %d\n"
						     "model name      : %s\n"
						     "stepping        : %d\n"
						     "brand id        : %d\n"
						     "cpu count       : %d\n"
						     "apic id         : %d\n"
						     "fpu             : %s\n",
					     type_str,
					     family,
					     model,
					     szBuffer,
					     stepping,
					     brand_id,
					     cpu_count,
					     apic_id,
					     (features1 & (1 << 0)) ? "yes" : "no");
		}
@


1.19
log
@Use isdirsep rather than SLASH_P throughout.
* path.cc (iscygdrive): Disallow /cygdrive\x.
(normalize_posix_path): "Normalize" a windows path, if detected, rather than
converting to posix.
* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support and capability
checking for B230400 bitrate.
(fhandler_serial::tcgetattr): Add support for B230400 bitrate.
* include/sys/termios.h: Add B230400 definition for Posix support of 230.4Kbps.
@
text
@d3 1
a3 1
   Copyright 2002 Red Hat, Inc.
@


1.18
log
@* external.cc (cygwin_internal): Implement CW_CMDLINE.
* pinfo.h (SIGCOMMUNE): New signal type.
(commune_result): New structure for commune functions.
(picom): New enum for commune functions.
(_pinfo::hello_pid): New.  Pid who's communicating with me.
(_pinfo::tothem): New.  Handle of communicating pipe.
(_pinfo::fromthem): Ditto.
(_pinfo::commune_recv): Declare.
(_pinfo::commune_send): Declare.
(_pinfo::alive): Declare.
(_pinfo::cmdline): Declare.
(_pinfo::lock): Declare.
* pinfo.cc (set_myself): Initialize new _pinfo lock.
(_pinfo::alive): Define.  Determines if process still exists.
(_pinfo::commune_recv): Define.  Receive info from another cooperating process.
(_pinfo::commune_send): Define.  Send info to another cooperating process.
(_pinfo::cmdline): Define.  Determine command line of a given process.
* include/sys/cygwin.h (CW_CMDLINE): Define.
*sigproc.cc (talktome): Communicate with any processes who want to talk to me.
(wait_sig): Honor __SIGCOMMUNE.
* fhandler.cc (fhandler_virtual::fixup_after_exec): Declare.
* fhandler_proc.cc: Use malloc/free/realloc throughout rather than cmalloc
since buffers don't need to be propagated to subprocesses.
* fhandler_registry.cc: Ditto.
* fhandler_virtual.cc: Ditto.
(fhandler_virtual::fixup_after_exec): Define.
* fhandler_process.cc: Ditto for malloc/free/realloc.
(process_listin): Add "cmdline".
(fhandler_process::fill_filebuf): Implement PROCESS_CMDLINE.
* miscfuncs.cc (isalpha_array): New array populated with xor values for alpha
characters to switch from one case to another.
* string.h (cygwin_strcasematch): New asm implementation of case match.
* string.h (cygwin_nstrcasematch): New asm implementation of counted case
match.
@
text
@d90 1
a90 1
  while (SLASH_P (*path))
d108 1
a108 1
    if (SLASH_P (*path++))
@


1.18.10.1
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d141 6
a146 1
  fhandler_virtual ()
@


1.18.10.2
log
@.
@
text
@d90 1
a90 1
  while (isdirsep (*path))
d108 1
a108 1
    if (isdirsep (*path++))
@


1.18.2.1
log
@* include/cygwin/version.h: Bump API minor number for below export.
* cygwin.din (pututline): New exported function.
* syscalls.cc (login): Use pututiline().
(setutent): Open utmp as read/write.
(endutent): Check if utmp file is open.
(utmpname): call endutent() to close current utmp file.
(getutid): Enable all cases, use strncmp() to compare ut_id fields.
(pututline): New.
* tty.cc (create_tty_master): Set ut_pid to current pid.
* fhandler.h (fhandler_serial::vmin_): Declare as size_t.
* fhandler_serial.cc (fhandler_serial::raw_read): Use correct type for
minchars.
(fhandler_serial::ioctl): Set errno if the ClearCommError fails.
(fhandler_serial::tcsetattr): Use correct value for vmin_.
(fhandler_serial::tcgetattr): Ditto.
* fhandler_socket.cc (fhandler_socket::recvmsg): Call if from == NULL
WSARecvFrom with fromlen = NULL.
@
text
@d330 1
a330 1
	    filebuf = (char *) cmalloc (HEAP_BUF, bufalloc);
d338 1
a338 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 80);
d344 1
a344 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
d355 1
a355 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 16);
d362 1
a362 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
@


1.17
log
@whitespace
@
text
@d330 1
a330 1
	    filebuf = (char *) cmalloc (HEAP_BUF, bufalloc);
d338 1
a338 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 80);
d344 1
a344 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
d355 1
a355 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 16);
d362 1
a362 2
	if (!filebuf)
	  filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
@


1.16
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d428 1
a428 1
		        spt.UserTime.QuadPart) / 100000ULL;
@


1.15
log
@* fhandler_proc.cc: Add <sys/param.h> include.
(format_proc_uptime): Use KernelTime and UserTime only as they include the
other counters.
(format_proc_stat): KernelTime includes IdleTime, so subtract IdleTime from
KernelTime.  Make number of 'jiffies' per second same as HZ define.
* fhandler_process.cc: Add <sys/param.h> include.
(format_process_stat): Make number of 'jiffies' per second same as HZ define.
Use KernelTime and UserTime only to calculate start_time.
@
text
@d53 1
a53 1
static const int PROC_LINK_COUNT = (sizeof(proc_listing) / sizeof(const char *)) - 1;
d415 1
a415 1
    uptime = GetTickCount() / 10;
@


1.14
log
@* autoload.cc (GetSecurityInfo): Define new autoload function.
(RegQueryInfoKeyA): Ditto.
* fhandler.h (fhandler_virtual::fill_filebuf): Change return type to bool.
(fhandler_proc::fill_filebuf): Ditto.
(fhandler_registry::fill_filebuf): Ditto.
(fhandler_process::fill_filebuf): Ditto.
(fhandler_registry::value_name): Add new member.
(fhandler_registry::close): Add new method.
(fhandler_process::p): Remove member.
* fhandler_proc.cc (fhandler_proc::open): Add set_nohandle after calling
superclass method.  Check return value of fill_filebuf.
(fhandler_proc::fill_filebuf): Change return type to bool.  Add return
statement.
* fhandler_process.cc (fhandler_process::open): Add set_nohandle after calling
superclass method.  Remove references to p.  Check return value of
fill_filebuf.
(fhandler_process::fill_filebuf): Change return type to bool.  Don't use
dereference operator on p.  Add return statement.
(fhandler_process::format_process_stat): Fix typo.
* fhandler_registry.cc: Add static open_key declaration.
(fhandler_registry::exists): Assume path is already normalised.  Try opening
the path as a key in its own right first, before reverting to enumerating
subkeys and values of the parent key.
(fhandler_registry::fstat): Add additional code to return more relevant
information about the registry key/value.
(fhandler_registry::readdir): Explicitly set desired access when opening
registry key.  Remove output of buf from debug_printf format string.
(fhandler_registry::open): Use set_io_handle to store registry key handle.  Set
value_name member.  Move code to read a value from the registry to
fill_filebuf.  Add call to fill_filebuf.
(fhandler_registry::close): New method.
(fhandler_registry::fill_filebuf): Change return type to bool.  Add code to
read a value from registry.
(fhandler_registry::open_key): Make function static.  Use KEY_READ as desired
access unless this is the last path component.  Check the return value of
RegOpenKeyEx for an error instead of hKey.
* fhandler_virtual.cc (fhandler_virtual::lseek): Check the return value of
fill_filebuf.
(fhandler_virtual::open): Remove call to set_nohandle.
(fhandler_virtual::fill_filebuf): Change return type to bool.  Add return
statement.
* security.cc (get_nt_object_attribute): New function.
(get_object_attribute): New function.
* security.h (get_object_attribute): New function declaration.
@
text
@d26 1
d427 2
a428 3
      uptime = (spt.InterruptTime.QuadPart + spt.KernelTime.QuadPart +
		spt.IdleTime.QuadPart + spt.UserTime.QuadPart +
		spt.DpcTime.QuadPart) / 100000ULL;
d470 3
a472 3
      kernel_time = (spt.KernelTime.QuadPart + spt.InterruptTime.QuadPart + spt.DpcTime.QuadPart) / 100000ULL;
      user_time = spt.UserTime.QuadPart / 100000ULL;
      idle_time = spt.IdleTime.QuadPart / 100000ULL;
@


1.13
log
@* fhandler_clipboard.c (fhandler_dev_clipboard::open): Force text mode.
* fhandler_console.cc (fhandler_console::open): *Really* force binary mode
rather than make it optional.
* fhandler_proc.cc (fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (set_flags): Add more debugging.
@
text
@d219 2
d296 5
a300 1
  fill_filebuf ();
d316 1
a316 1
void
d370 1
@


1.12
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d303 1
a303 1
  set_flags (flags & ~O_TEXT, O_BINARY);
@


1.12.2.1
log
@Merged changes from HEAD
@
text
@@


1.12.2.2
log
@Merged changes from HEAD
@
text
@a218 2
  set_nohandle (true);

d294 1
a294 5
  if (!fill_filebuf ())
    {
      res = 0;
      goto out;
	}
d303 1
a303 1
  set_flags ((flags & ~O_TEXT) | O_BINARY);
d310 1
a310 1
bool
a363 1
    return true;
@


1.12.2.3
log
@Merged changes from HEAD
@
text
@a25 1
#include <sys/param.h>
d426 3
a428 2
      uptime = (spt.KernelTime.QuadPart +
		        spt.UserTime.QuadPart) / 100000ULL;
d470 3
a472 3
      kernel_time = (spt.KernelTime.QuadPart - spt.IdleTime.QuadPart) * HZ / 10000000ULL;
      user_time = spt.UserTime.QuadPart * HZ / 10000000ULL;
      idle_time = spt.IdleTime.QuadPart * HZ / 10000000ULL;
@


1.12.2.4
log
@Merged changes from HEAD
@
text
@d53 1
a53 1
static const int PROC_LINK_COUNT = (sizeof (proc_listing) / sizeof (const char *)) - 1;
d415 1
a415 1
    uptime = GetTickCount () / 10;
@


1.11
log
@* fhandler_process.cc (fhandler_process::open): Set fileid.
@
text
@a11 1
#include <sys/fcntl.h>
d303 1
a304 1
  set_flags (flags);
@


1.10
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d320 7
a326 7
	struct utsname uts_name;
	uname (&uts_name);
	    bufalloc = strlen (uts_name.sysname) + 1 + strlen (uts_name.release) +
		      1 + strlen (uts_name.version) + 2;
	filebuf = (char *) cmalloc (HEAP_BUF, bufalloc);
	    filesize = __small_sprintf (filebuf, "%s %s %s\n", uts_name.sysname,
			 uts_name.release, uts_name.version);
@


1.9
log
@* fhandler.cc (fhandler_base::fstat): Move dev and ino calculation into caller.
* syscalls.cc (stat_worker): Calculate dev and ino calculation here, if zero.
* fhandler_proc.cc (fhandler_proc::fhandler_proc): Minor reorg for debugging.
* fhandler_process.cc (fhandler_process::exists): Return 0 on nonexistence.
(fhandler_process::fstat): Simplify pid logic.
* fhandler_tape.cc (fhandler_dev_tape::fstat): Minor reformatting.
@
text
@a21 1
#include "sigproc.h"
d103 2
a104 5
  int pid = atoi (path);
  winpids pids;
  for (unsigned i = 0; i < pids.npids; i++)
    {
      _pinfo *p = pids[i];
d106 15
a120 22
      if (!proc_exists (p))
	continue;

      if (p->pid == pid)
	return FH_PROCESS;
    }

    bool has_subdir = false;
    while (*path)
      if (SLASH_P (*path++))
	{
	  has_subdir = true;
	  break;
	}

    if (has_subdir)
      /* The user is trying to access a non-existent subdirectory of /proc. */
      return FH_BAD;
    else
      /* Return FH_PROC so that we can return EROFS if the user is trying to create
	 a file. */
      return FH_PROC;
d195 6
a200 14
	{
	  _pinfo *p = pids[i];

	  if (!proc_exists (p))
	    continue;

	  if (found == dir->__d_position - PROC_LINK_COUNT)
	    {
	      __small_sprintf (dir->__d_dirent->d_name, "%d", p->pid);
	      dir->__d_position++;
	      return dir->__d_dirent;
	    }
	  found++;
	}
@


1.8
log
@* fhandler_proc.cc (fhandler_proc::readdir): Set errno when no more files.
* fhandler_process.cc (fhandler_process::readdir): Ditto.
* fhandler_registry.cc (fhandler_registry::readdir): Ditto.
@
text
@a163 1
  debug_printf ("fstat (%s)", get_name ());
d165 2
@


1.7
log
@	* autoload.cc: Replace autoload statments for ZwXXX by NtXXX.
	Drop ZwQuerySystemInformation since NtQuerySystemInformation was
	already available.
	* fhandler_proc.cc (format_proc_uptime): Replace call to
	ZwQuerySystemInformation by call to NtQuerySystemInformation.
	(format_proc_stat): Ditto.
	* fhandler_process.cc (format_process_stat): Replace call to
	ZwQueryInformationProcess by call to NtQueryInformationProcess.
	(get_process_state): Ditto.
	(get_mem_values): Ditto.  Replace call to ZwQueryVirtualMemory by
	call to NtQueryVirtualMemory.
	* ntdll.h: Cleanup.  Drop ZwQuerySystemInformation since
	NtQuerySystemInformation was already available.  Replace declarations
	of ZwXXX functions by declarations of NtXXX.
	* pinfo.cc (winpids::enumNT): Replace call to ZwQuerySystemInformation
	by call to NtQuerySystemInformation.
@
text
@d219 1
@


1.6
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d422 1
a422 1
  NTSTATUS ret = ZwQuerySystemInformation (SystemProcessorTimes, (PVOID) &spt,
d462 1
a462 1
      ret = ZwQuerySystemInformation (SystemProcessorTimes,
d466 1
a466 1
	ret = ZwQuerySystemInformation (SystemPerformanceInformation,
d470 1
a470 1
	ret = ZwQuerySystemInformation (SystemTimeOfDayInformation,
@


1.5
log
@* fhandler.h (fhandler_virtual::exists): Eliminate path argument.
(fhandler_proc::exists): Ditto.
(fhandler_registry::exists): Ditto.
(fhandler_process::exists): Ditto.
* fhandler_proc.cc (fhandler_proc::exists): Ditto.  Use built-in name.
* fhandler_process.cc (fhandler_process::exists): Ditto.
(fstat): Ditto.
* fhandler_registry.cc (fhandler_registry::exists): Ditto.
(fhandler_registry::fstat): Ditto.
* fhandler_virtual.cc (fhandler_virtual::opendir): Ditto.
* path.cc (path_conv::check): Ditto.  Add debugging.
* syscalls.cc (dup): Always call dup2 for error handling.
@
text
@d101 1
a101 1
        return proc_fhandlers[i];
d111 1
a111 1
        continue;
d114 1
a114 1
        return FH_PROCESS;
d181 2
a182 2
        if (pathmatch (path, proc_listing[i]))
          {
d190 2
a191 2
            return 0;
          }
d205 2
a206 2
        {
          _pinfo *p = pids[i];
d208 2
a209 2
          if (!proc_exists (p))
            continue;
d211 8
a218 8
          if (found == dir->__d_position - PROC_LINK_COUNT)
            {
              __small_sprintf (dir->__d_dirent->d_name, "%d", p->pid);
              dir->__d_position++;
              return dir->__d_dirent;
            }
          found++;
        }
d224 1
a224 1
                  dir->__d_dirent->d_name);
d244 5
a248 5
        {
          set_errno (EEXIST);
          res = 0;
          goto out;
        }
d250 5
a254 5
        {
          set_errno (EISDIR);
          res = 0;
          goto out;
        }
d256 4
a259 4
        {
          flags |= O_DIROPEN;
          goto success;
        }
d266 21
a286 21
        proc_file_no = i;
        if (proc_fhandlers[i] != FH_PROC)
          {
            if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
              {
                set_errno (EEXIST);
                res = 0;
                goto out;
              }
            else if (flags & O_WRONLY)
              {
                set_errno (EISDIR);
                res = 0;
                goto out;
              }
            else
              {
                flags |= O_DIROPEN;
                goto success;
              }
          }
d292 5
a296 5
        {
          set_errno (EROFS);
          res = 0;
          goto out;
        }
d298 5
a302 5
        {
          set_errno (ENOENT);
          res = 0;
          goto out;
        }
d335 11
a345 11
        if (!filebuf)
          {
        struct utsname uts_name;
        uname (&uts_name);
            bufalloc = strlen (uts_name.sysname) + 1 + strlen (uts_name.release) +
                      1 + strlen (uts_name.version) + 2;
        filebuf = (char *) cmalloc (HEAP_BUF, bufalloc);
            filesize = __small_sprintf (filebuf, "%s %s %s\n", uts_name.sysname,
                         uts_name.release, uts_name.version);
          }
        break;
d349 4
a352 4
        if (!filebuf)
          filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 80);
        filesize = format_proc_uptime (filebuf, bufalloc);
        break;
d356 4
a359 4
        if (!filebuf)
          filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
        filesize = format_proc_stat (filebuf, bufalloc);
        break;
d363 10
a372 10
        /*
         * not really supported - Windows doesn't keep track of these values
         * Windows 95/98/me does have the KERNEL/CPUUsage performance counter
         * which is similar.
         */
        if (!filebuf)
          filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 16);
        filesize = __small_sprintf (filebuf, "%u.%02u %u.%02u %u.%02u\n",
                                    0, 0, 0, 0, 0, 0);
        break;
d376 4
a379 4
        if (!filebuf)
          filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 2048);
        filesize = format_proc_meminfo (filebuf, bufalloc);
        break;
d389 1
a389 1
                swap_free = 0UL;
d397 16
a412 16
                                   "Mem:  %10lu %10lu %10lu\n"
                                   "Swap: %10lu %10lu %10lu\n"
                                   "MemTotal:     %10lu kB\n"
                                   "MemFree:      %10lu kB\n"
                                   "MemShared:             0 kB\n"
                                   "HighTotal:             0 kB\n"
                                   "HighFree:              0 kB\n"
                                   "LowTotal:     %10lu kB\n"
                                   "LowFree:      %10lu kB\n"
                                   "SwapTotal:    %10lu kB\n"
                                   "SwapFree:     %10lu kB\n",
                                   mem_total, mem_total - mem_free, mem_free,
                                   swap_total, swap_total - swap_free, swap_free,
                                   mem_total >> 10, mem_free >> 10,
                                   mem_total >> 10, mem_free >> 10,
                                   swap_total >> 10, swap_free >> 10);
d438 2
a439 2
                spt.IdleTime.QuadPart + spt.UserTime.QuadPart +
                spt.DpcTime.QuadPart) / 100000ULL;
d443 2
a444 2
                          uptime / 100, long (uptime % 100),
                          idle_time / 100, long (idle_time % 100));
d453 1
a453 1
                context_switches = 0UL, swap_in = 0UL, swap_out = 0UL;
d463 2
a464 2
                                      (PVOID) &spt,
                                      sizeof spt, NULL);
d466 3
a468 3
        ret = ZwQuerySystemInformation (SystemPerformanceInformation,
                                        (PVOID) &spi,
                                        sizeof spi, NULL);
d470 3
a472 3
        ret = ZwQuerySystemInformation (SystemTimeOfDayInformation,
                                        (PVOID) &stodi,
                                        sizeof stodi, NULL);
d474 7
a480 7
        {
          __seterrno_from_win_error (RtlNtStatusToDosError (ret));
          debug_printf("NtQuerySystemInformation: ret = %d, "
                       "Dos(ret) = %d",
                       ret, RtlNtStatusToDosError (ret));
          return 0;
        }
d508 12
a519 12
                                   "page %u %u\n"
                                   "swap %u %u\n"
                                   "intr %u\n"
                                   "ctxt %u\n"
                                   "btime %u\n",
                          user_time, 0ULL,
                          kernel_time, idle_time,
                          pages_in, pages_out,
                          swap_in, swap_out,
                          interrupt_count,
                          context_switches,
                          boot_time);
@


1.4
log
@* autoload.cc: Add dynamic load statements for 'ZwQueryInformationProcess' and
'ZwQueryVirtualMemory'.
* fhandler.h: Change type of bufalloc and filesize members of fhandler_virtual
from int to size_t.  Change type of position member from __off32_t to
__off64_t.  Add new fileid member to fhandler_virtual class.  Make seekdir take
an __off64_t argument.  Make lseek take an __off64_t argument.  Add
fill_filebuf method to fhandler_virtual.  Add fill_filebuf method to
fhandler_proc.  Add fill_filebuf method to fhandler_registry.  Add fill_filebuf
method to fhandler_process.  Add saved_pid and saved_p members to
fhandler_process.
* fhandler_proc.cc (proc_listing_array): Add 'loadavg', 'meminfo', and 'stat'.
(proc_fhandlers array): Ditto.
(fhandler_proc::open): Use fill_filebuf to flesh out the file contents.
(fhandler_proc::fill_filebuf): New method.
(fhandler_proc::format_proc_meminfo): Ditto.
(fhandler_proc::format_proc_stat): Ditto.
(fhandler_proc::format_proc_uptime): Ditto.
* fhandler_process.cc (process_listing): Add 'stat' and 'statm'.
(fhandler_process::fstat): Find the _pinfo structure for the process named in
the filename.  Return ENOENT if the process is no longer around.  Set the gid
and uid fields of the stat structure.
(fhandler_process::open): Store pid and pointer to _pinfo structure in
saved_pid and saved_p respectively.  Use fill_filebuf to flesh out file
contents.
(fhandler_proc::fill_filebuf): New method.
(format_process_stat): New function.
(format_process_status): Ditto.
(format_process_statm): Ditto.
(get_process_state): Ditto.
(get_mem_values): Ditto.
* fhandler_registry.cc (fhandler_registry::seekdir): Change argument type from
__off32_t to __off64_t.
(fhandler_registry::fill_filebuf): New method.
* fhandler_virtual.cc (fhandler_virtual::seekdir): Change argument type from
__off32_t to __off64_t.
(fhandler_virtual::lseek): Ditto.
(fhandler_virtual::fill_filebuf): New method.
(fhandler_virtual::fhandler_virtual): Initialise fileid to -1.
* wincap.cc: Set flag has_process_io_counters appropriately.
* wincap.h: Add flag has_process_io_counters.
@
text
@d138 1
a138 1
fhandler_proc::exists (const char *path)
d140 1
@


1.3
log
@* net.cc (getdomainname): Change second argument of getdomainname to size_t.
* fhandler_proc.cc (proc_listing): Add '.' and '..' to directory listing.
(fhandler_proc::open): Change use of mode to flags.  If the file does not exist
already, fail with EROFS if O_CREAT flag is set.  Change EROFS error to EACCES
error when writing to a file.  Use cmalloc to allocate memory for filebuf.
(fhandler_proc::close): Use cfree to free filebuf.
(fhandler_proc::get_proc_fhandler): Properly detect attempts to access unknown
subdir.
* fhandler_process.cc (process_listing): Add '.' and '..' to directory listing.
(fhandler_process::open): Use cmalloc to allocate memory for filebuf.
(fhandler_process::close): Use cfree to free filebuf.
* fhandler_registry.cc (registry_listing): Add .  and '..' to directory
listing.
(fhandler_registry::open): Move check for open for writing before open_key.
Use cmalloc to allocate memory for filebuf.
(fhandler_registry::close): Use cfree to free filebuf.
(fhandler_registry::telldir): Use lower 16 bits of __d_position as position in
directory.
(fhandler_registry::seekdir): Ditto.
* fhandler_virtual.cc (fhandler_virtual::write): Change EROFS error to EACCES
error.
(fhandler_virtual::open): Set the NOHANDLE flag.
(fhandler_virtual::dup): Add call to fhandler_base::dup.  Allocate child's
filebuf using cmalloc.  Copy filebuf from parent to child.
(fhandler_virtual::close): Use cfree to free filebuf.
(fhandler_virtual::~fhandler_virtual): Ditto.
(from Chris Faylor <cgf@@redhat.com>).
(fhandler_registry::readdir): Add support for '.' and '..' files in
subdirectories of /proc/registry.
* path.cc (path_conv::check): Do not return ENOENT if a file is not found in
/proc.
@
text
@d17 1
d28 1
d34 6
a39 3
static const int PROC_REGISTRY = 2;     // /proc/registry
static const int PROC_VERSION  = 3;     // /proc/version
static const int PROC_UPTIME   = 4;     // /proc/uptime
d45 2
d48 1
d59 3
a61 1
static const DWORD proc_fhandlers[] = {
d66 1
d74 4
d309 22
a330 1
  switch (proc_file_no)
d334 2
d338 2
a339 2
        filesize = bufalloc = strlen (uts_name.sysname) + 1 +
          strlen (uts_name.release) + 1 + strlen (uts_name.version) + 2;
d341 1
a341 1
        __small_sprintf (filebuf, "%s %s %s\n", uts_name.sysname,
d343 1
d348 18
a365 3
        /* GetTickCount() wraps after 49 days - on WinNT/2000/XP, should use
         * perfomance counters but I don't know Redhat's policy on
         * NT only dependancies.
d367 11
a377 5
        DWORD ticks = GetTickCount ();
        filebuf = (char *) cmalloc (HEAP_BUF, bufalloc = 40);
        __small_sprintf (filebuf, "%d.%02d\n", ticks / 1000,
                         (ticks / 10) % 100);
        filesize = strlen (filebuf);
d381 39
d421 12
a432 2
  if (flags & O_APPEND)
    position = filesize;
d434 20
a453 1
    position = 0;
d455 64
a518 7
success:
  res = 1;
  set_open_status ();
  set_flags (flags);
out:
  syscall_printf ("%d = fhandler_proc::open (%p, %d)", res, flags, mode);
  return res;
@


1.2
log
@* fhandler_proc.cc (fhandler_proc::fstat): Use fhandler name rather than
path_conv name.
(fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::fstat): Use fhandler name rather than
path_conv name.
(fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::fstat): Use fhandler name rather
than path_conv name.
(fhandler_registry::open): Ditto.
* path.cc (path_conv::check): Don't copy posix path when virtual.
(mount_info::conv_to_win32_path): Don't zero string when isproc.  Just derive
normal windows path.
* path.h (path_conv::clear_normalized_path): Declare new method.
* path.cc (path_conv::clear_normalized_path): Define new method.
* dtable.cc (build_fhandler_from_name): Clear normalized path when finished to
conserve space.
@
text
@d23 2
d32 3
a34 3
static const int PROC_REGISTRY = 0;     // /proc/registry
static const int PROC_VERSION = 1;      // /proc/version
static const int PROC_UPTIME = 2;       // /proc/uptime
d38 2
d52 2
d101 16
a116 1
  return FH_BAD;
d227 1
a227 1
      if ((mode & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
d233 1
a233 1
      else if (mode & O_WRONLY)
d253 1
a253 1
            if ((mode & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
d259 1
a259 1
            else if (mode & O_WRONLY)
d275 1
a275 1
      if ((mode & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
d288 1
a288 1
  if (mode & O_WRONLY)
d302 1
a302 1
        filebuf = new char[bufalloc];
d314 1
a314 1
        filebuf = new char[bufalloc = 40];
@


1.1
log
@add new files
@
text
@d127 1
a127 1
  debug_printf ("fstat (%s)", (char *) *pc);
d202 1
a202 1
  path = (char *) *pc + proc_len;
@

