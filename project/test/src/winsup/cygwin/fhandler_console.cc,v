head	1.296;
access;
symbols
	cygwin-1_7_35-release:1.296
	cygwin-1_7_34-release:1.296
	cygwin-1_7_33-release:1.285.2.10
	cygwin-1_7_32-release:1.285.2.10
	cygwin-1_7_31-release:1.285.2.10
	cygwin-1_7_30-release:1.285.2.10
	cygwin-1_7_29-release:1.285.2.9
	cygwin-1_7_29-release-branchpoint:1.285.0.2
	cygwin-pre-user-db:1.285
	cygwin-1_7_28-release:1.285
	cygwin-1_7_27-release:1.282
	cygwin-1_7_26-release:1.282
	cygwin-1_7_25-release:1.280
	cygwin-1_7_24-release:1.280
	cygwin-1_7_23-release:1.280
	cygwin-1_7_22-release:1.280
	cygwin-1_7_21-release:1.280
	cygwin-1_7_20-release:1.280
	cygwin-1_7_19-release:1.280
	cygwin-64bit-postmerge:1.279
	cygwin-64bit-premerge-branch:1.278.0.2
	cygwin-64bit-premerge:1.278
	cygwin-1_7_18-release:1.278
	post-ptmalloc3:1.275.2.8
	pre-ptmalloc3:1.275.2.8
	cygwin-1_7_17-release:1.276
	cygwin-64bit-branch:1.275.0.2
	cygwin-1_7_16-release:1.274
	cygwin-1_7_15-release:1.273
	cygwin-1_7_14_2-release:1.273
	cygwin-1_7_14-release:1.272
	cygwin-1_7_12-release:1.268
	cygwin-1_7_11-release:1.261
	cygwin-1_7_10-release:1.259
	signal-rewrite:1.249.0.2
	pre-notty:1.237
	cygwin-1_7_9-release:1.223
	cv-post-1_7_9:1.223.0.2
	cygwin-1_7_8-release:1.223
	cygwin-1_7_7-release:1.218
	cygwin-1_7_5-release:1.218
	cygwin-1_7_4-release:1.216
	cygwin-1_7_3-release:1.216
	cygwin-1_7_2-release:1.215
	fifo_doover3:1.213.0.2
	cygwin-1_7_1-release:1.207
	prefifo:1.199
	cv-branch-2:1.195.0.2
	pre-ripout-set_console_state_for_spawn:1.181
	EOL_registry_mounts:1.179
	preoverlapped:1.169
	drop_9x_support_start:1.167
	cr-0x5f1:1.165.0.4
	cv-branch:1.165.0.2
	pre-ptymaster-archetype:1.163
	cr-0x3b58:1.159.0.4
	cr-0x5ef:1.159.0.2
	after-mmap-privanon-noreserve:1.146
	after-mmap-revamp:1.146
	before-mmap-revamp:1.146
	cgf-more-exit-sync:1.143
	post_wait_sig_exit:1.141
	pre_wait_sig_exit:1.140
	reparent-point:1.131
	noreparent:1.131.0.2
	cr-0x5e6:1.129.0.2
	cr-0x9e:1.122.0.4
	cr-0x9d:1.122.0.2
	cgf-deleteme:1.120.0.2
	pre-sigrewrite:1.117
	corinna-01:1.117
	cr-0x9c:1.113.0.4
	cr-0x9b:1.113.0.2
	cr-0x99:1.111
	Z-emcb-cygwin_daemon:1.111.0.2
	w32api-2_2:1.103
	mingw-runtime-2_4:1.103
	pre-cgf-merge:1.113
	cgf-dev-branch:1.101.0.2
	predaemon:1.71
	cygwin_daemon_merge_HEAD:1.71
	pregp02r1:1.71.0.22
	cygnus_cvs_20020108_pre:1.71
	Z-cygwin_daemon_merge-new_HEAD:1.87
	Z-cygwin_daemon_merge_HEAD:1.87
	cygwin_daemon:1.61.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.296
date	2014.05.09.14.28.48;	author cgf;	state Exp;
branches;
next	1.295;

1.295
date	2014.04.26.17.38.22;	author cgf;	state Exp;
branches;
next	1.294;

1.294
date	2014.03.10.18.18.56;	author cgf;	state Exp;
branches;
next	1.293;

1.293
date	2014.03.10.17.33.17;	author cgf;	state Exp;
branches;
next	1.292;

1.292
date	2014.03.10.03.15.39;	author cgf;	state Exp;
branches;
next	1.291;

1.291
date	2014.03.09.22.49.56;	author cgf;	state Exp;
branches;
next	1.290;

1.290
date	2014.03.09.18.46.30;	author cgf;	state Exp;
branches;
next	1.289;

1.289
date	2014.02.26.03.58.37;	author cgf;	state Exp;
branches;
next	1.288;

1.288
date	2014.02.23.03.42.02;	author cgf;	state Exp;
branches;
next	1.287;

1.287
date	2014.02.23.03.38.52;	author cgf;	state Exp;
branches;
next	1.286;

1.286
date	2014.02.16.01.48.24;	author cgf;	state Exp;
branches;
next	1.285;

1.285
date	2014.01.31.04.23.22;	author cgf;	state Exp;
branches
	1.285.2.1;
next	1.284;

1.284
date	2014.01.04.23.58.32;	author cgf;	state Exp;
branches;
next	1.283;

1.283
date	2013.12.31.22.19.07;	author cgf;	state Exp;
branches;
next	1.282;

1.282
date	2013.11.24.12.13.33;	author corinna;	state Exp;
branches;
next	1.281;

1.281
date	2013.10.24.15.26.21;	author cgf;	state Exp;
branches;
next	1.280;

1.280
date	2013.05.01.01.20.37;	author yselkowitz;	state Exp;
branches;
next	1.279;

1.279
date	2013.04.23.09.44.32;	author corinna;	state Exp;
branches;
next	1.278;

1.278
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.277;

1.277
date	2013.01.11.11.04.50;	author corinna;	state Exp;
branches;
next	1.276;

1.276
date	2012.08.16.23.34.43;	author cgf;	state Exp;
branches;
next	1.275;

1.275
date	2012.07.30.03.44.40;	author cgf;	state Exp;
branches
	1.275.2.1;
next	1.274;

1.274
date	2012.06.17.20.50.24;	author cgf;	state Exp;
branches;
next	1.273;

1.273
date	2012.04.25.07.25.00;	author corinna;	state Exp;
branches;
next	1.272;

1.272
date	2012.04.24.14.39.22;	author corinna;	state Exp;
branches;
next	1.271;

1.271
date	2012.04.24.14.29.37;	author corinna;	state Exp;
branches;
next	1.270;

1.270
date	2012.04.15.17.51.22;	author cgf;	state Exp;
branches;
next	1.269;

1.269
date	2012.04.13.02.30.51;	author cgf;	state Exp;
branches;
next	1.268;

1.268
date	2012.04.01.22.28.39;	author cgf;	state Exp;
branches;
next	1.267;

1.267
date	2012.03.29.17.34.55;	author cgf;	state Exp;
branches;
next	1.266;

1.266
date	2012.03.10.17.51.33;	author cgf;	state Exp;
branches;
next	1.265;

1.265
date	2012.03.08.09.36.11;	author corinna;	state Exp;
branches;
next	1.264;

1.264
date	2012.03.03.21.35.30;	author cgf;	state Exp;
branches;
next	1.263;

1.263
date	2012.03.02.11.56.06;	author corinna;	state Exp;
branches;
next	1.262;

1.262
date	2012.03.02.10.17.16;	author corinna;	state Exp;
branches;
next	1.261;

1.261
date	2012.02.14.11.27.43;	author corinna;	state Exp;
branches;
next	1.260;

1.260
date	2012.02.07.16.54.13;	author cgf;	state Exp;
branches;
next	1.259;

1.259
date	2011.12.17.23.39.46;	author cgf;	state Exp;
branches;
next	1.258;

1.258
date	2011.12.13.04.11.45;	author cgf;	state Exp;
branches;
next	1.257;

1.257
date	2011.12.09.16.02.56;	author cgf;	state Exp;
branches;
next	1.256;

1.256
date	2011.12.04.17.58.24;	author cgf;	state Exp;
branches;
next	1.255;

1.255
date	2011.12.03.21.43.25;	author cgf;	state Exp;
branches;
next	1.254;

1.254
date	2011.11.14.01.29.48;	author cgf;	state Exp;
branches;
next	1.253;

1.253
date	2011.10.22.16.26.29;	author cgf;	state Exp;
branches;
next	1.252;

1.252
date	2011.10.15.22.37.29;	author cgf;	state Exp;
branches;
next	1.251;

1.251
date	2011.10.12.14.19.20;	author corinna;	state Exp;
branches;
next	1.250;

1.250
date	2011.10.11.23.20.38;	author cgf;	state Exp;
branches;
next	1.249;

1.249
date	2011.08.19.18.19.22;	author cgf;	state Exp;
branches;
next	1.248;

1.248
date	2011.08.19.13.10.01;	author corinna;	state Exp;
branches;
next	1.247;

1.247
date	2011.07.25.15.19.35;	author corinna;	state Exp;
branches;
next	1.246;

1.246
date	2011.07.22.18.50.42;	author corinna;	state Exp;
branches;
next	1.245;

1.245
date	2011.07.14.10.02.11;	author corinna;	state Exp;
branches;
next	1.244;

1.244
date	2011.07.05.18.01.13;	author corinna;	state Exp;
branches;
next	1.243;

1.243
date	2011.06.30.13.55.57;	author corinna;	state Exp;
branches;
next	1.242;

1.242
date	2011.06.24.08.25.19;	author corinna;	state Exp;
branches;
next	1.241;

1.241
date	2011.06.16.23.00.00;	author cgf;	state Exp;
branches;
next	1.240;

1.240
date	2011.06.14.21.48.43;	author cgf;	state Exp;
branches;
next	1.239;

1.239
date	2011.06.12.20.15.26;	author cgf;	state Exp;
branches;
next	1.238;

1.238
date	2011.06.09.21.20.27;	author cgf;	state Exp;
branches;
next	1.237;

1.237
date	2011.06.07.20.55.10;	author cgf;	state Exp;
branches;
next	1.236;

1.236
date	2011.06.06.05.02.09;	author cgf;	state Exp;
branches;
next	1.235;

1.235
date	2011.06.05.02.10.31;	author cgf;	state Exp;
branches;
next	1.234;

1.234
date	2011.06.04.00.12.29;	author cgf;	state Exp;
branches;
next	1.233;

1.233
date	2011.06.01.01.47.51;	author cgf;	state Exp;
branches;
next	1.232;

1.232
date	2011.05.28.18.17.08;	author cgf;	state Exp;
branches;
next	1.231;

1.231
date	2011.05.06.20.12.20;	author cgf;	state Exp;
branches;
next	1.230;

1.230
date	2011.05.05.22.30.53;	author cgf;	state Exp;
branches;
next	1.229;

1.229
date	2011.05.05.19.43.03;	author corinna;	state Exp;
branches;
next	1.228;

1.228
date	2011.05.04.13.06.10;	author corinna;	state Exp;
branches;
next	1.227;

1.227
date	2011.05.02.17.38.16;	author corinna;	state Exp;
branches;
next	1.226;

1.226
date	2011.04.19.10.15.09;	author corinna;	state Exp;
branches;
next	1.225;

1.225
date	2011.04.19.10.02.06;	author corinna;	state Exp;
branches;
next	1.224;

1.224
date	2011.04.17.19.56.25;	author cgf;	state Exp;
branches;
next	1.223;

1.223
date	2011.02.15.15.56.01;	author corinna;	state Exp;
branches;
next	1.222;

1.222
date	2011.02.07.11.18.19;	author corinna;	state Exp;
branches;
next	1.221;

1.221
date	2010.10.23.18.07.07;	author cgf;	state Exp;
branches;
next	1.220;

1.220
date	2010.10.02.19.08.21;	author cgf;	state Exp;
branches;
next	1.219;

1.219
date	2010.09.12.15.49.30;	author cgf;	state Exp;
branches;
next	1.218;

1.218
date	2010.04.11.19.11.17;	author corinna;	state Exp;
branches;
next	1.217;

1.217
date	2010.04.10.18.05.52;	author cgf;	state Exp;
branches;
next	1.216;

1.216
date	2010.03.30.16.17.34;	author corinna;	state Exp;
branches;
next	1.215;

1.215
date	2010.03.09.21.26.55;	author cgf;	state Exp;
branches;
next	1.214;

1.214
date	2010.01.14.18.46.01;	author corinna;	state Exp;
branches;
next	1.213;

1.213
date	2009.12.25.17.38.46;	author cgf;	state Exp;
branches;
next	1.212;

1.212
date	2009.12.21.10.11.27;	author corinna;	state Exp;
branches;
next	1.211;

1.211
date	2009.12.19.15.40.31;	author corinna;	state Exp;
branches;
next	1.210;

1.210
date	2009.12.19.15.37.10;	author corinna;	state Exp;
branches;
next	1.209;

1.209
date	2009.12.16.14.56.10;	author corinna;	state Exp;
branches;
next	1.208;

1.208
date	2009.12.15.12.46.40;	author corinna;	state Exp;
branches;
next	1.207;

1.207
date	2009.11.10.20.02.20;	author corinna;	state Exp;
branches;
next	1.206;

1.206
date	2009.11.09.15.38.36;	author corinna;	state Exp;
branches;
next	1.205;

1.205
date	2009.09.30.09.23.45;	author corinna;	state Exp;
branches;
next	1.204;

1.204
date	2009.09.28.12.10.32;	author corinna;	state Exp;
branches;
next	1.203;

1.203
date	2009.08.10.15.25.58;	author cgf;	state Exp;
branches;
next	1.202;

1.202
date	2009.08.10.08.54.51;	author corinna;	state Exp;
branches;
next	1.201;

1.201
date	2009.07.25.08.27.10;	author corinna;	state Exp;
branches;
next	1.200;

1.200
date	2009.07.24.20.54.33;	author cgf;	state Exp;
branches;
next	1.199;

1.199
date	2009.07.05.16.49.56;	author cgf;	state Exp;
branches;
next	1.198;

1.198
date	2009.07.04.23.51.10;	author cgf;	state Exp;
branches;
next	1.197;

1.197
date	2009.07.03.18.05.50;	author cgf;	state Exp;
branches;
next	1.196;

1.196
date	2009.07.03.10.50.51;	author corinna;	state Exp;
branches;
next	1.195;

1.195
date	2009.06.04.14.59.47;	author corinna;	state Exp;
branches;
next	1.194;

1.194
date	2009.06.04.09.57.34;	author corinna;	state Exp;
branches;
next	1.193;

1.193
date	2009.06.03.11.07.38;	author corinna;	state Exp;
branches;
next	1.192;

1.192
date	2009.05.30.05.51.41;	author cgf;	state Exp;
branches;
next	1.191;

1.191
date	2009.05.14.19.49.37;	author corinna;	state Exp;
branches;
next	1.190;

1.190
date	2009.05.06.17.16.33;	author cgf;	state Exp;
branches;
next	1.189;

1.189
date	2009.05.04.04.43.50;	author cgf;	state Exp;
branches;
next	1.188;

1.188
date	2009.05.04.03.51.16;	author cgf;	state Exp;
branches;
next	1.187;

1.187
date	2009.04.07.12.13.37;	author corinna;	state Exp;
branches;
next	1.186;

1.186
date	2009.03.25.12.29.04;	author corinna;	state Exp;
branches;
next	1.185;

1.185
date	2009.03.24.12.18.34;	author corinna;	state Exp;
branches;
next	1.184;

1.184
date	2008.09.11.04.34.23;	author cgf;	state Exp;
branches;
next	1.183;

1.183
date	2008.06.12.15.57.23;	author corinna;	state Exp;
branches;
next	1.182;

1.182
date	2008.06.12.14.55.08;	author cgf;	state Exp;
branches;
next	1.181;

1.181
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.180;

1.180
date	2008.04.07.16.15.45;	author cgf;	state Exp;
branches;
next	1.179;

1.179
date	2008.04.01.13.22.46;	author corinna;	state Exp;
branches;
next	1.178;

1.178
date	2008.03.10.17.23.50;	author corinna;	state Exp;
branches;
next	1.177;

1.177
date	2008.03.10.16.48.56;	author corinna;	state Exp;
branches;
next	1.176;

1.176
date	2008.03.10.16.22.38;	author corinna;	state Exp;
branches;
next	1.175;

1.175
date	2008.03.07.11.24.51;	author corinna;	state Exp;
branches;
next	1.174;

1.174
date	2008.02.15.17.53.10;	author cgf;	state Exp;
branches;
next	1.173;

1.173
date	2008.02.06.18.24.50;	author corinna;	state Exp;
branches;
next	1.172;

1.172
date	2008.02.05.17.37.10;	author corinna;	state Exp;
branches;
next	1.171;

1.171
date	2008.01.31.20.26.01;	author corinna;	state Exp;
branches;
next	1.170;

1.170
date	2007.11.26.21.30.49;	author cgf;	state Exp;
branches;
next	1.169;

1.169
date	2007.02.23.12.01.52;	author corinna;	state Exp;
branches;
next	1.168;

1.168
date	2007.02.22.17.35.14;	author corinna;	state Exp;
branches;
next	1.167;

1.167
date	2007.02.20.00.16.14;	author cgf;	state Exp;
branches;
next	1.166;

1.166
date	2006.11.23.10.08.04;	author corinna;	state Exp;
branches;
next	1.165;

1.165
date	2006.07.03.15.29.10;	author corinna;	state Exp;
branches
	1.165.4.1;
next	1.164;

1.164
date	2006.06.03.20.32.07;	author cgf;	state Exp;
branches;
next	1.163;

1.163
date	2006.05.19.00.32.36;	author cgf;	state Exp;
branches;
next	1.162;

1.162
date	2006.04.21.18.53.05;	author cgf;	state Exp;
branches;
next	1.161;

1.161
date	2006.03.23.23.58.52;	author cgf;	state Exp;
branches;
next	1.160;

1.160
date	2006.03.16.02.57.37;	author cgf;	state Exp;
branches;
next	1.159;

1.159
date	2006.01.12.05.17.12;	author cgf;	state Exp;
branches;
next	1.158;

1.158
date	2006.01.12.05.03.15;	author cgf;	state Exp;
branches;
next	1.157;

1.157
date	2006.01.07.18.00.19;	author cgf;	state Exp;
branches;
next	1.156;

1.156
date	2006.01.07.17.57.26;	author cgf;	state Exp;
branches;
next	1.155;

1.155
date	2006.01.05.16.26.22;	author cgf;	state Exp;
branches;
next	1.154;

1.154
date	2006.01.05.03.58.19;	author cgf;	state Exp;
branches;
next	1.153;

1.153
date	2006.01.05.00.49.17;	author cgf;	state Exp;
branches;
next	1.152;

1.152
date	2006.01.04.04.47.19;	author cgf;	state Exp;
branches;
next	1.151;

1.151
date	2006.01.04.03.43.55;	author cgf;	state Exp;
branches;
next	1.150;

1.150
date	2006.01.03.17.44.26;	author cgf;	state Exp;
branches;
next	1.149;

1.149
date	2006.01.03.01.15.29;	author cgf;	state Exp;
branches;
next	1.148;

1.148
date	2005.12.19.19.04.14;	author cgf;	state Exp;
branches;
next	1.147;

1.147
date	2005.12.19.04.34.13;	author cgf;	state Exp;
branches;
next	1.146;

1.146
date	2005.11.14.14.15.51;	author cgf;	state Exp;
branches;
next	1.145;

1.145
date	2005.11.14.05.36.16;	author cgf;	state Exp;
branches;
next	1.144;

1.144
date	2005.11.14.04.28.44;	author cgf;	state Exp;
branches;
next	1.143;

1.143
date	2005.09.28.19.22.21;	author corinna;	state Exp;
branches;
next	1.142;

1.142
date	2005.09.28.19.02.49;	author corinna;	state Exp;
branches;
next	1.141;

1.141
date	2005.09.13.17.08.54;	author cgf;	state Exp;
branches;
next	1.140;

1.140
date	2005.07.06.20.05.00;	author cgf;	state Exp;
branches;
next	1.139;

1.139
date	2005.07.05.03.16.44;	author cgf;	state Exp;
branches;
next	1.138;

1.138
date	2005.06.11.05.09.25;	author cgf;	state Exp;
branches;
next	1.137;

1.137
date	2005.05.11.03.33.38;	author cgf;	state Exp;
branches;
next	1.136;

1.136
date	2005.04.28.23.59.44;	author cgf;	state Exp;
branches;
next	1.135;

1.135
date	2005.04.22.17.03.38;	author cgf;	state Exp;
branches;
next	1.134;

1.134
date	2004.12.16.13.19.08;	author corinna;	state Exp;
branches;
next	1.133;

1.133
date	2004.12.14.12.09.51;	author corinna;	state Exp;
branches;
next	1.132;

1.132
date	2004.11.26.04.15.07;	author cgf;	state Exp;
branches;
next	1.131;

1.131
date	2004.10.20.01.02.18;	author cgf;	state Exp;
branches
	1.131.2.1;
next	1.130;

1.130
date	2004.05.28.19.50.05;	author cgf;	state Exp;
branches;
next	1.129;

1.129
date	2004.05.17.15.27.56;	author cgf;	state Exp;
branches;
next	1.128;

1.128
date	2004.05.16.04.18.50;	author cgf;	state Exp;
branches;
next	1.127;

1.127
date	2004.04.10.13.45.09;	author corinna;	state Exp;
branches;
next	1.126;

1.126
date	2004.04.09.12.09.45;	author corinna;	state Exp;
branches;
next	1.125;

1.125
date	2004.02.09.04.04.22;	author cgf;	state Exp;
branches;
next	1.124;

1.124
date	2004.02.02.21.00.07;	author cgf;	state Exp;
branches;
next	1.123;

1.123
date	2004.02.02.20.33.09;	author cgf;	state Exp;
branches;
next	1.122;

1.122
date	2004.01.17.03.47.27;	author cgf;	state Exp;
branches;
next	1.121;

1.121
date	2004.01.15.19.51.49;	author cgf;	state Exp;
branches;
next	1.120;

1.120
date	2003.12.30.01.57.16;	author cgf;	state Exp;
branches
	1.120.2.1;
next	1.119;

1.119
date	2003.12.11.06.12.41;	author cgf;	state Exp;
branches;
next	1.118;

1.118
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.117;

1.117
date	2003.10.16.14.08.28;	author corinna;	state Exp;
branches;
next	1.116;

1.116
date	2003.10.15.08.23.26;	author corinna;	state Exp;
branches;
next	1.115;

1.115
date	2003.09.27.02.36.50;	author cgf;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.25.00.37.16;	author cgf;	state Exp;
branches;
next	1.113;

1.113
date	2003.09.09.03.11.31;	author cgf;	state Exp;
branches;
next	1.112;

1.112
date	2003.09.05.01.55.01;	author cgf;	state Exp;
branches;
next	1.111;

1.111
date	2003.06.16.03.24.10;	author cgf;	state Exp;
branches;
next	1.110;

1.110
date	2003.04.08.21.19.33;	author cgf;	state Exp;
branches;
next	1.109;

1.109
date	2003.04.02.23.01.11;	author cgf;	state Exp;
branches;
next	1.108;

1.108
date	2003.03.17.19.08.10;	author cgf;	state Exp;
branches;
next	1.107;

1.107
date	2003.03.13.23.11.38;	author cgf;	state Exp;
branches;
next	1.106;

1.106
date	2003.03.03.03.58.10;	author cgf;	state Exp;
branches
	1.106.2.1;
next	1.105;

1.105
date	2003.03.02.18.37.17;	author cgf;	state Exp;
branches;
next	1.104;

1.104
date	2003.02.13.23.51.41;	author cgf;	state Exp;
branches;
next	1.103;

1.103
date	2003.02.04.03.01.17;	author cgf;	state Exp;
branches;
next	1.102;

1.102
date	2003.01.25.01.17.51;	author cgf;	state Exp;
branches;
next	1.101;

1.101
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2002.12.27.05.31.30;	author cgf;	state Exp;
branches
	1.100.2.1;
next	1.99;

1.99
date	2002.12.27.03.50.29;	author cgf;	state Exp;
branches;
next	1.98;

1.98
date	2002.12.14.04.01.32;	author cgf;	state Exp;
branches;
next	1.97;

1.97
date	2002.12.05.16.24.52;	author cgf;	state Exp;
branches;
next	1.96;

1.96
date	2002.11.15.04.35.13;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2002.11.14.18.02.05;	author cgf;	state Exp;
branches;
next	1.94;

1.94
date	2002.11.13.19.36.12;	author cgf;	state Exp;
branches;
next	1.93;

1.93
date	2002.11.07.03.35.02;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2002.11.07.02.50.50;	author cgf;	state Exp;
branches;
next	1.91;

1.91
date	2002.10.15.07.03.44;	author cgf;	state Exp;
branches;
next	1.90;

1.90
date	2002.10.14.20.25.52;	author cgf;	state Exp;
branches;
next	1.89;

1.89
date	2002.10.09.04.08.05;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2002.10.08.06.16.16;	author cgf;	state Exp;
branches;
next	1.87;

1.87
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.86;

1.86
date	2002.09.19.15.12.48;	author cgf;	state Exp;
branches;
next	1.85;

1.85
date	2002.09.19.03.30.20;	author cgf;	state Exp;
branches;
next	1.84;

1.84
date	2002.08.19.04.43.58;	author cgf;	state Exp;
branches;
next	1.83;

1.83
date	2002.08.01.16.20.31;	author cgf;	state Exp;
branches;
next	1.82;

1.82
date	2002.07.29.03.18.41;	author cgf;	state Exp;
branches;
next	1.81;

1.81
date	2002.07.13.20.00.25;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2002.07.01.19.03.26;	author cgf;	state Exp;
branches;
next	1.79;

1.79
date	2002.06.26.05.29.41;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.05.04.01.42;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.05.01.42.28;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2002.06.04.01.40.53;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2002.05.31.22.53.25;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2002.05.31.22.35.56;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2002.05.28.01.55.40;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2001.11.26.20.21.27;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2001.11.26.20.20.42;	author cgf;	state Exp;
branches;
next	1.69;

1.69
date	2001.11.12.17.06.50;	author cgf;	state Exp;
branches;
next	1.68;

1.68
date	2001.10.24.21.56.53;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2001.10.24.04.16.45;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2001.10.22.18.39.22;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2001.10.13.17.23.35;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2001.10.13.01.35.15;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2001.10.04.02.34.19;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2001.09.12.17.46.36;	author corinna;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2001.09.04.10.45.54;	author corinna;	state Exp;
branches;
next	1.57;

1.57
date	2001.08.07.05.15.59;	author cgf;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.04.21.10.52;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2001.07.26.19.22.23;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.24.22.26.50;	author cgf;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.22.20.08.06;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.16.17.09.19;	author cgf;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.05.17.59.46;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.08.15.16.49;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2001.04.28.23.48.27;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.24.02.07.58;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2001.04.09.00.44.25;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.31.09.19.32;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.30.11.10.13;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.22.18.19.00;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.12.20.39.40;	author duda;	state Exp;
branches;
next	1.41;

1.41
date	2001.03.06.12.05.45;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.05.06.28.23;	author cgf;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.03.03.56.34;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.02.27.09.14.35;	author duda;	state Exp;
branches;
next	1.37;

1.37
date	2001.02.14.22.00.09;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.17.14.57.09;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2001.01.08.04.02.01;	author cgf;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.03.14.45.47;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.16.03.11.02;	author cgf;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.15.04.42.20;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2000.12.10.00.45.11;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2000.12.09.21.31.49;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.17.03.01.14;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.23.03.35.50;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.21.04.53.49;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.19.03.12.44;	author dj;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.12.04.38.29;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.08.02.56.54;	author cgf;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.07.16.23.50;	author cgf;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.30.17.58.48;	author cgf;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.29.19.07.15;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.29.16.24.37;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.27.17.30.48;	author dj;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.07.26.13.59.23;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.10.23.08.45;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.10.15.30.04;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.04.02.26.20;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.24.21.41.11;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.15.03.52.24;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.12.06.29.54;	author cgf;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.12.04.44.37;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.26.01.11.54;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.24.06.45.32;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.285.2.1
date	2014.02.21.02.43.26;	author cgf;	state Exp;
branches;
next	1.285.2.2;

1.285.2.2
date	2014.02.23.03.39.38;	author cgf;	state Exp;
branches;
next	1.285.2.3;

1.285.2.3
date	2014.02.23.03.42.22;	author cgf;	state Exp;
branches;
next	1.285.2.4;

1.285.2.4
date	2014.02.26.01.40.49;	author cgf;	state Exp;
branches;
next	1.285.2.5;

1.285.2.5
date	2014.03.09.18.46.07;	author cgf;	state Exp;
branches;
next	1.285.2.6;

1.285.2.6
date	2014.03.09.22.49.06;	author cgf;	state Exp;
branches;
next	1.285.2.7;

1.285.2.7
date	2014.03.10.03.15.02;	author cgf;	state Exp;
branches;
next	1.285.2.8;

1.285.2.8
date	2014.03.10.17.33.06;	author cgf;	state Exp;
branches;
next	1.285.2.9;

1.285.2.9
date	2014.03.10.18.18.49;	author cgf;	state Exp;
branches;
next	1.285.2.10;

1.285.2.10
date	2014.05.19.11.47.53;	author corinna;	state Exp;
branches;
next	;

1.275.2.1
date	2012.08.13.20.04.33;	author corinna;	state Exp;
branches;
next	1.275.2.2;

1.275.2.2
date	2012.10.16.15.18.38;	author corinna;	state Exp;
branches;
next	1.275.2.3;

1.275.2.3
date	2012.10.31.17.00.08;	author corinna;	state Exp;
branches;
next	1.275.2.4;

1.275.2.4
date	2012.12.10.11.45.46;	author corinna;	state Exp;
branches;
next	1.275.2.5;

1.275.2.5
date	2013.01.11.12.36.55;	author corinna;	state Exp;
branches;
next	1.275.2.6;

1.275.2.6
date	2013.01.14.17.16.30;	author corinna;	state Exp;
branches;
next	1.275.2.7;

1.275.2.7
date	2013.01.21.13.52.05;	author corinna;	state Exp;
branches;
next	1.275.2.8;

1.275.2.8
date	2013.02.09.20.38.00;	author corinna;	state Exp;
branches;
next	1.275.2.9;

1.275.2.9
date	2013.03.27.15.58.29;	author corinna;	state Exp;
branches;
next	;

1.165.4.1
date	2008.06.12.15.57.35;	author corinna;	state Exp;
branches;
next	;

1.131.2.1
date	2004.11.16.15.16.56;	author cgf;	state Exp;
branches;
next	;

1.120.2.1
date	2004.01.14.21.49.24;	author cgf;	state Exp;
branches;
next	1.120.2.2;

1.120.2.2
date	2004.01.17.04.13.20;	author cgf;	state Exp;
branches;
next	;

1.106.2.1
date	2003.03.16.23.38.18;	author cgf;	state Exp;
branches;
next	;

1.101.2.1
date	2003.01.16.01.27.30;	author cgf;	state Exp;
branches;
next	1.101.2.2;

1.101.2.2
date	2003.01.25.01.18.28;	author cgf;	state Exp;
branches;
next	1.101.2.3;

1.101.2.3
date	2003.02.05.14.25.07;	author cgf;	state Exp;
branches;
next	1.101.2.4;

1.101.2.4
date	2003.02.14.03.03.27;	author cgf;	state Exp;
branches;
next	1.101.2.5;

1.101.2.5
date	2003.03.02.18.57.51;	author cgf;	state Exp;
branches;
next	1.101.2.6;

1.101.2.6
date	2003.03.03.03.59.39;	author cgf;	state Exp;
branches;
next	1.101.2.7;

1.101.2.7
date	2003.03.19.19.59.54;	author cgf;	state Exp;
branches;
next	1.101.2.8;

1.101.2.8
date	2003.04.03.01.32.32;	author cgf;	state Exp;
branches;
next	1.101.2.9;

1.101.2.9
date	2003.05.10.17.20.52;	author cgf;	state Exp;
branches;
next	1.101.2.10;

1.101.2.10
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.101.2.11;

1.101.2.11
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	;

1.100.2.1
date	2002.12.28.16.56.16;	author cgf;	state Exp;
branches;
next	1.100.2.2;

1.100.2.2
date	2002.12.28.17.39.47;	author cgf;	state Exp;
branches;
next	;

1.61.2.1
date	2001.10.02.12.09.54;	author rbcollins;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2002.01.04.03.56.07;	author rbcollins;	state Exp;
branches;
next	1.61.2.3;

1.61.2.3
date	2002.06.13.14.34.04;	author rbcollins;	state Exp;
branches;
next	1.61.2.4;

1.61.2.4
date	2002.06.27.11.30.14;	author scottc;	state Exp;
branches;
next	1.61.2.5;

1.61.2.5
date	2002.07.02.10.58.18;	author scottc;	state Exp;
branches;
next	1.61.2.6;

1.61.2.6
date	2002.07.13.20.39.24;	author scottc;	state Exp;
branches;
next	1.61.2.7;

1.61.2.7
date	2002.07.29.10.54.14;	author scottc;	state Exp;
branches;
next	1.61.2.8;

1.61.2.8
date	2002.08.01.20.34.06;	author scottc;	state Exp;
branches;
next	1.61.2.9;

1.61.2.9
date	2002.08.24.12.25.31;	author scottc;	state Exp;
branches;
next	1.61.2.10;

1.61.2.10
date	2002.09.19.08.11.17;	author scottc;	state Exp;
branches;
next	1.61.2.11;

1.61.2.11
date	2002.09.19.21.51.22;	author scottc;	state Exp;
branches;
next	1.61.2.12;

1.61.2.12
date	2002.09.22.10.01.27;	author scottc;	state Exp;
branches;
next	;

1.13.2.1
date	2000.07.29.18.35.01;	author cgf;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2000.07.30.17.58.51;	author cgf;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2000.08.04.00.48.23;	author cgf;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.296
log
@* signal.cc (sigprocmask): Fix strace output to include "how".
* fhandler_console.cc (dev_console::save_restore): Only current dwEnd line
rather than the one after that.
@
text
@/* fhandler_console.cc

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include "miscfuncs.h"
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <ctype.h>
#include <sys/param.h>
#include <sys/cygwin.h>
#include <cygwin/kd.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "sigproc.h"
#include "pinfo.h"
#include "shared_info.h"
#include "cygtls.h"
#include "tls_pbuf.h"
#include "registry.h"
#include <asm/socket.h>
#include "sync.h"
#include "child_info.h"
#include "cygwait.h"

/* Don't make this bigger than NT_MAX_PATH as long as the temporary buffer
   is allocated using tmp_pathbuf!!! */
#define CONVERT_LIMIT NT_MAX_PATH

#define ALT_PRESSED (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)
#define CTRL_PRESSED (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)

#define con (shared_console_info->con)
#define srTop (con.b.srWindow.Top + con.scroll_region.Top)
#define srBottom ((con.scroll_region.Bottom < 0) ? con.b.srWindow.Bottom : con.b.srWindow.Top + con.scroll_region.Bottom)

const char *get_nonascii_key (INPUT_RECORD&, char *);

const unsigned fhandler_console::MAX_WRITE_CHARS = 16384;

fhandler_console::console_state NO_COPY *fhandler_console::shared_console_info;

bool NO_COPY fhandler_console::invisible_console;

static void
beep ()
{
  const WCHAR ding[] = L"\\media\\ding.wav";
  reg_key r (HKEY_CURRENT_USER, KEY_ALL_ACCESS, L"AppEvents", L"Schemes",
	     L"Apps", L".Default", L".Default", L".Current", NULL);
  if (r.created ())
    {
      PWCHAR buf = NULL;
      UINT len = GetSystemWindowsDirectoryW (buf, 0) * sizeof (WCHAR);
      buf = (PWCHAR) alloca (len += sizeof (ding));
      UINT res = GetSystemWindowsDirectoryW (buf, len);
      if (res && res <= len)
	r.set_string (L"", wcscat (buf, ding));
    }
  MessageBeep (MB_OK);
}

fhandler_console::console_state *
fhandler_console::open_shared_console (HWND hw, HANDLE& h, bool& create)
{
  wchar_t namebuf[(sizeof "XXXXXXXXXXXXXXXXXX-consNNNNNNNNNN")];
  __small_swprintf (namebuf, L"%S-cons%p", &cygheap->installation_key, hw);

  shared_locations m = create ? SH_SHARED_CONSOLE : SH_JUSTOPEN;
  console_state *res = (console_state *)
    open_shared (namebuf, 0, h, sizeof (*shared_console_info), &m);
  create = m != SH_JUSTOPEN;
  return res;
}

class console_unit
{
  int n;
  unsigned long bitmask;
  HWND me;

public:
  operator int () const {return n;}
  console_unit (HWND);
  friend BOOL CALLBACK enum_windows (HWND, LPARAM);
};

BOOL CALLBACK
enum_windows (HWND hw, LPARAM lp)
{
  console_unit *this1 = (console_unit *) lp;
  if (hw == this1->me)
    return TRUE;
  HANDLE h = NULL;
  fhandler_console::console_state *cs;
  if ((cs = fhandler_console::open_shared_console (hw, h)))
    {
      this1->bitmask ^= 1 << cs->tty_min_state.getntty ();
      UnmapViewOfFile ((void *) cs);
      CloseHandle (h);
    }
  return TRUE;
}

console_unit::console_unit (HWND me0):
  bitmask (0xffffffff), me (me0)
{
  EnumWindows (enum_windows, (LPARAM) this);
  n = (_minor_t) ffs (bitmask) - 1;
  if (n < 0)
    api_fatal ("console device allocation failure - too many consoles in use, max consoles is 32");
}

bool
fhandler_console::set_unit ()
{
  bool created;
  fh_devices devset;
  lock_ttys here;
  HWND me;
  fh_devices this_unit = dev ();
  bool generic_console = this_unit == FH_CONIN || this_unit == FH_CONOUT;
  if (shared_console_info)
    {
      fh_devices shared_unit =
	(fh_devices) shared_console_info->tty_min_state.getntty ();
      devset = (shared_unit == this_unit || this_unit == FH_CONSOLE
		|| generic_console
		|| this_unit == FH_TTY) ?
		shared_unit : FH_ERROR;
      created = false;
    }
  else if ((!generic_console && (myself->ctty != -1 && !iscons_dev (myself->ctty)))
	   || !(me = GetConsoleWindow ()))
    devset = FH_ERROR;
  else
    {
      created = true;
      shared_console_info = open_shared_console (me, cygheap->console_h, created);
      ProtectHandleINH (cygheap->console_h);
      if (created)
	shared_console_info->tty_min_state.setntty (DEV_CONS_MAJOR, console_unit (me));
      devset = (fh_devices) shared_console_info->tty_min_state.getntty ();
    }

  dev ().parse (devset);
  if (devset != FH_ERROR)
    pc.file_attributes (FILE_ATTRIBUTE_NORMAL);
  else
    {
      set_io_handle (NULL);
      set_output_handle (NULL);
      created = false;
    }
  return created;
}

/* Allocate and initialize the shared record for the current console. */
void
fhandler_console::setup ()
{
  if (set_unit ())
      {
	con.scroll_region.Bottom = -1;
	con.dwLastCursorPosition.X = -1;
	con.dwLastCursorPosition.Y = -1;
	con.dwLastMousePosition.X = -1;
	con.dwLastMousePosition.Y = -1;
	con.dwLastButtonState = 0;	/* none pressed */
	con.last_button_code = 3;	/* released */
	con.underline_color = FOREGROUND_GREEN | FOREGROUND_BLUE;
	con.dim_color = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
	con.meta_mask = LEFT_ALT_PRESSED;
	/* Set the mask that determines if an input keystroke is modified by
	   META.  We set this based on the keyboard layout language loaded
	   for the current thread.  The left <ALT> key always generates
	   META, but the right <ALT> key only generates META if we are using
	   an English keyboard because many "international" keyboards
	   replace common shell symbols ('[', '{', etc.) with accented
	   language-specific characters (umlaut, accent grave, etc.).  On
	   these keyboards right <ALT> (called AltGr) is used to produce the
	   shell symbols and should not be interpreted as META. */
	if (PRIMARYLANGID (LOWORD (GetKeyboardLayout (0))) == LANG_ENGLISH)
	  con.meta_mask |= RIGHT_ALT_PRESSED;
	con.set_default_attr ();
	con.backspace_keycode = CERASE;
	shared_console_info->tty_min_state.is_console = true;
      }
}

/* Return the tty structure associated with a given tty number.  If the
   tty number is < 0, just return a dummy record. */
tty_min *
tty_list::get_cttyp ()
{
  dev_t n = myself->ctty;
  if (iscons_dev (n))
    return fhandler_console::shared_console_info ?
      &fhandler_console::shared_console_info->tty_min_state : NULL;
  else if (istty_slave_dev (n))
    return &ttys[device::minor (n)];
  else
    return NULL;
}

inline DWORD
dev_console::con_to_str (char *d, int dlen, WCHAR w)
{
  return sys_cp_wcstombs (cygheap->locale.wctomb, cygheap->locale.charset,
			  d, dlen, &w, 1);
}

inline UINT
dev_console::get_console_cp ()
{
  /* The alternate charset is always 437, just as in the Linux console. */
  return alternate_charset_active ? 437 : 0;
}

inline DWORD
dev_console::str_to_con (mbtowc_p f_mbtowc, const char *charset,
			 PWCHAR d, const char *s, DWORD sz)
{
  return sys_cp_mbstowcs (f_mbtowc, charset, d, CONVERT_LIMIT, s, sz);
}

bool
fhandler_console::set_raw_win32_keyboard_mode (bool new_mode)
{
  bool old_mode = con.raw_win32_keyboard_mode;
  con.raw_win32_keyboard_mode = new_mode;
  syscall_printf ("raw keyboard mode %sabled", con.raw_win32_keyboard_mode ? "en" : "dis");
  return old_mode;
};

void
fhandler_console::set_cursor_maybe ()
{
  con.fillin (get_output_handle ());
  if (con.dwLastCursorPosition.X != con.b.dwCursorPosition.X ||
      con.dwLastCursorPosition.Y != con.b.dwCursorPosition.Y)
    {
      SetConsoleCursorPosition (get_output_handle (), con.b.dwCursorPosition);
      con.dwLastCursorPosition = con.b.dwCursorPosition;
    }
}

void
fhandler_console::send_winch_maybe ()
{
  SHORT y = con.dwWinSize.Y;
  SHORT x = con.dwWinSize.X;
  con.fillin (get_output_handle ());

  if (y != con.dwWinSize.Y || x != con.dwWinSize.X)
    {
      con.scroll_region.Top = 0;
      con.scroll_region.Bottom = -1;
      get_ttyp ()->kill_pgrp (SIGWINCH);
    }
}

/* Check whether a mouse event is to be reported as an escape sequence */
bool
fhandler_console::mouse_aware (MOUSE_EVENT_RECORD& mouse_event)
{
  if (!con.use_mouse)
    return 0;

  /* Adjust mouse position by window scroll buffer offset
     and remember adjusted position in state for use by read() */
  CONSOLE_SCREEN_BUFFER_INFO now;
  if (!GetConsoleScreenBufferInfo (get_output_handle (), &now))
    /* Cannot adjust position by window scroll buffer offset */
    return 0;

  con.dwMousePosition.X = mouse_event.dwMousePosition.X - now.srWindow.Left;
  con.dwMousePosition.Y = mouse_event.dwMousePosition.Y - now.srWindow.Top;

  return ((mouse_event.dwEventFlags == 0 || mouse_event.dwEventFlags == DOUBLE_CLICK)
	  && mouse_event.dwButtonState != con.dwLastButtonState)
	 || mouse_event.dwEventFlags == MOUSE_WHEELED
	 || (mouse_event.dwEventFlags == MOUSE_MOVED
	     && (con.dwMousePosition.X != con.dwLastMousePosition.X
		 || con.dwMousePosition.Y != con.dwLastMousePosition.Y)
	     && ((con.use_mouse >= 2 && mouse_event.dwButtonState)
		 || con.use_mouse >= 3));
}

void __reg3
fhandler_console::read (void *pv, size_t& buflen)
{
  push_process_state process_state (PID_TTYIN);

  HANDLE h = get_io_handle ();

#define buf ((char *) pv)

  int ch;
  set_input_state ();

  int copied_chars = get_readahead_into_buffer (buf, buflen);

  if (copied_chars)
    {
      buflen = copied_chars;
      return;
    }

  DWORD timeout = is_nonblocking () ? 0 : INFINITE;
  char tmp[60];

  termios ti = get_ttyp ()->ti;
  for (;;)
    {
      int bgres;
      if ((bgres = bg_check (SIGTTIN)) <= bg_eof)
	{
	  buflen = bgres;
	  return;
	}

      set_cursor_maybe ();	/* to make cursor appear on the screen immediately */
      switch (cygwait (h, timeout))
	{
	case WAIT_OBJECT_0:
	  break;
	case WAIT_SIGNALED:
	  goto sig_exit;
	case WAIT_CANCELED:
	  process_state.pop ();
	  pthread::static_cancel_self ();
	  /*NOTREACHED*/
	case WAIT_TIMEOUT:
	  set_sig_errno (EAGAIN);
	  buflen = (size_t) -1;
	  return;
	default:
	  goto err;
	}

      DWORD nread;
      INPUT_RECORD input_rec;
      const char *toadd = NULL;

      if (!ReadConsoleInputW (h, &input_rec, 1, &nread))
	{
	  syscall_printf ("ReadConsoleInput failed, %E");
	  goto err;		/* seems to be failure */
	}

      /* check the event that occurred */
      switch (input_rec.EventType)
	{
	case KEY_EVENT:
#define virtual_key_code (input_rec.Event.KeyEvent.wVirtualKeyCode)
#define control_key_state (input_rec.Event.KeyEvent.dwControlKeyState)

	  con.nModifiers = 0;

#ifdef DEBUGGING
	  /* allow manual switching to/from raw mode via ctrl-alt-scrolllock */
	  if (input_rec.Event.KeyEvent.bKeyDown &&
	      virtual_key_code == VK_SCROLL &&
	      ((control_key_state & (LEFT_ALT_PRESSED | LEFT_CTRL_PRESSED)) == (LEFT_ALT_PRESSED | LEFT_CTRL_PRESSED))
	    )
	    {
	      set_raw_win32_keyboard_mode (!con.raw_win32_keyboard_mode);
	      continue;
	    }
#endif

	  if (con.raw_win32_keyboard_mode)
	    {
	      __small_sprintf (tmp, "\033{%u;%u;%u;%u;%u;%luK",
				    input_rec.Event.KeyEvent.bKeyDown,
				    input_rec.Event.KeyEvent.wRepeatCount,
				    input_rec.Event.KeyEvent.wVirtualKeyCode,
				    input_rec.Event.KeyEvent.wVirtualScanCode,
				    input_rec.Event.KeyEvent.uChar.UnicodeChar,
				    input_rec.Event.KeyEvent.dwControlKeyState);
	      toadd = tmp;
	      nread = strlen (toadd);
	      break;
	    }

#define ich (input_rec.Event.KeyEvent.uChar.AsciiChar)
#define wch (input_rec.Event.KeyEvent.uChar.UnicodeChar)

	  /* Ignore key up events, except for left alt events with non-zero character
	   */
	  if (!input_rec.Event.KeyEvent.bKeyDown &&
	      /*
		Event for left alt, with a non-zero character, comes from
		"alt + numerics" key sequence.
		e.g. <left-alt> 0233 => &eacute;
	      */
	      !(wch != 0
		// ?? experimentally determined on an XP system
		&& virtual_key_code == VK_MENU
		// left alt -- see http://www.microsoft.com/hwdev/tech/input/Scancode.asp
		&& input_rec.Event.KeyEvent.wVirtualScanCode == 0x38))
	    continue;

	  if (control_key_state & SHIFT_PRESSED)
	    con.nModifiers |= 1;
	  if (control_key_state & RIGHT_ALT_PRESSED)
	    con.nModifiers |= 2;
	  if (control_key_state & CTRL_PRESSED)
	    con.nModifiers |= 4;
	  if (control_key_state & LEFT_ALT_PRESSED)
	    con.nModifiers |= 8;

	  /* Allow Backspace to emit ^? and escape sequences. */
	  if (input_rec.Event.KeyEvent.wVirtualKeyCode == VK_BACK)
	    {
	      char c = con.backspace_keycode;
	      nread = 0;
	      if (control_key_state & ALT_PRESSED)
		{
		  if (con.metabit)
		    c |= 0x80;
		  else
		    tmp[nread++] = '\e';
		}
	      tmp[nread++] = c;
	      tmp[nread] = 0;
	      toadd = tmp;
	    }
	  /* Allow Ctrl-Space to emit ^@@ */
	  else if (input_rec.Event.KeyEvent.wVirtualKeyCode == VK_SPACE
		   && (control_key_state & CTRL_PRESSED)
		   && !(control_key_state & ALT_PRESSED))
	    toadd = "";
	  else if (wch == 0
	      /* arrow/function keys */
	      || (input_rec.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY))
	    {
	      toadd = get_nonascii_key (input_rec, tmp);
	      if (!toadd)
		{
		  con.nModifiers = 0;
		  continue;
		}
	      nread = strlen (toadd);
	    }
	  else
	    {
	      nread = con.con_to_str (tmp + 1, 59, wch);
	      /* Determine if the keystroke is modified by META.  The tricky
		 part is to distinguish whether the right Alt key should be
		 recognized as Alt, or as AltGr. */
	      bool meta =
		     /* Alt but not AltGr (= left ctrl + right alt)? */
		     (control_key_state & ALT_PRESSED) != 0
		     && ((control_key_state & CTRL_PRESSED) == 0
			    /* but also allow Alt-AltGr: */
			 || (control_key_state & ALT_PRESSED) == ALT_PRESSED
			 || (wch <= 0x1f || wch == 0x7f));
	      if (!meta)
		{
		  /* Determine if the character is in the current multibyte
		     charset.  The test is easy.  If the multibyte sequence
		     is > 1 and the first byte is ASCII CAN, the character
		     has been translated into the ASCII CAN + UTF-8 replacement
		     sequence.  If so, just ignore the keypress.
		     FIXME: Is there a better solution? */
		  if (nread > 1 && tmp[1] == 0x18)
		    beep ();
		  else
		    toadd = tmp + 1;
		}
	      else if (con.metabit)
		{
		  tmp[1] |= 0x80;
		  toadd = tmp + 1;
		}
	      else
		{
		  tmp[0] = '\033';
		  tmp[1] = cyg_tolower (tmp[1]);
		  toadd = tmp;
		  nread++;
		  con.nModifiers &= ~4;
		}
	    }
#undef ich
#undef wch
	  break;

	case MOUSE_EVENT:
	  send_winch_maybe ();
	  {
	    MOUSE_EVENT_RECORD& mouse_event = input_rec.Event.MouseEvent;
	    /* As a unique guard for mouse report generation,
	       call mouse_aware() which is common with select(), so the result
	       of select() and the actual read() will be consistent on the
	       issue of whether input (i.e. a mouse escape sequence) will
	       be available or not */
	    if (mouse_aware (mouse_event))
	      {
		/* Note: Reported mouse position was already retrieved by
		   mouse_aware() and adjusted by window scroll buffer offset */

		/* Treat the double-click event like a regular button press */
		if (mouse_event.dwEventFlags == DOUBLE_CLICK)
		  {
		    syscall_printf ("mouse: double-click -> click");
		    mouse_event.dwEventFlags = 0;
		  }

		/* This code assumes Windows never reports multiple button
		   events at the same time. */
		int b = 0;
		char sz[32];
		char mode6_term = 'M';

		if (mouse_event.dwEventFlags == MOUSE_WHEELED)
		  {
		    if (mouse_event.dwButtonState & 0xFF800000)
		      {
			b = 0x41;
			strcpy (sz, "wheel down");
		      }
		    else
		      {
			b = 0x40;
			strcpy (sz, "wheel up");
		      }
		  }
		else
		  {
		    /* Ignore unimportant mouse buttons */
		    mouse_event.dwButtonState &= 0x7;

		    if (mouse_event.dwEventFlags == MOUSE_MOVED)
		      {
			b = con.last_button_code;
		      }
		    else if (mouse_event.dwButtonState < con.dwLastButtonState && !con.ext_mouse_mode6)
		      {
			b = 3;
			strcpy (sz, "btn up");
		      }
		    else if ((mouse_event.dwButtonState & 1) != (con.dwLastButtonState & 1))
		      {
			b = 0;
			strcpy (sz, "btn1 down");
		      }
		    else if ((mouse_event.dwButtonState & 2) != (con.dwLastButtonState & 2))
		      {
			b = 2;
			strcpy (sz, "btn2 down");
		      }
		    else if ((mouse_event.dwButtonState & 4) != (con.dwLastButtonState & 4))
		      {
			b = 1;
			strcpy (sz, "btn3 down");
		      }

		    if (con.ext_mouse_mode6 /* distinguish release */
			&& mouse_event.dwButtonState < con.dwLastButtonState)
			mode6_term = 'm';

		    con.last_button_code = b;

		    if (mouse_event.dwEventFlags == MOUSE_MOVED)
		      {
			b += 32;
			strcpy (sz, "move");
		      }
		    else
		      {
			/* Remember the modified button state */
			con.dwLastButtonState = mouse_event.dwButtonState;
		      }
		  }

		/* Remember mouse position */
		con.dwLastMousePosition.X = con.dwMousePosition.X;
		con.dwLastMousePosition.Y = con.dwMousePosition.Y;

		/* Remember the modifiers */
		con.nModifiers = 0;
		if (mouse_event.dwControlKeyState & SHIFT_PRESSED)
		    con.nModifiers |= 0x4;
		if (mouse_event.dwControlKeyState & ALT_PRESSED)
		    con.nModifiers |= 0x8;
		if (mouse_event.dwControlKeyState & CTRL_PRESSED)
		    con.nModifiers |= 0x10;

		/* Indicate the modifiers */
		b |= con.nModifiers;

		/* We can now create the code. */
		if (con.ext_mouse_mode6)
		  {
		    __small_sprintf (tmp, "\033[<%d;%d;%d%c", b,
				     con.dwMousePosition.X + 1,
				     con.dwMousePosition.Y + 1,
				     mode6_term);
		    nread = strlen (tmp);
		  }
		else if (con.ext_mouse_mode15)
		  {
		    __small_sprintf (tmp, "\033[%d;%d;%dM", b + 32,
				     con.dwMousePosition.X + 1,
				     con.dwMousePosition.Y + 1);
		    nread = strlen (tmp);
		  }
		else if (con.ext_mouse_mode5)
		  {
		    unsigned int xcode = con.dwMousePosition.X + ' ' + 1;
		    unsigned int ycode = con.dwMousePosition.Y + ' ' + 1;

		    __small_sprintf (tmp, "\033[M%c", b + ' ');
		    nread = 4;
		    /* the neat nested encoding function of mintty
		       does not compile in g++, so let's unfold it: */
		    if (xcode < 0x80)
		      tmp [nread++] = xcode;
		    else if (xcode < 0x800)
		      {
			tmp [nread++] = 0xC0 + (xcode >> 6);
			tmp [nread++] = 0x80 + (xcode & 0x3F);
		      }
		    else
		      tmp [nread++] = 0;
		    if (ycode < 0x80)
		      tmp [nread++] = ycode;
		    else if (ycode < 0x800)
		      {
			tmp [nread++] = 0xC0 + (ycode >> 6);
			tmp [nread++] = 0x80 + (ycode & 0x3F);
		      }
		    else
		      tmp [nread++] = 0;
		  }
		else
		  {
		    unsigned int xcode = con.dwMousePosition.X + ' ' + 1;
		    unsigned int ycode = con.dwMousePosition.Y + ' ' + 1;
		    if (xcode >= 256)
		      xcode = 0;
		    if (ycode >= 256)
		      ycode = 0;
		    __small_sprintf (tmp, "\033[M%c%c%c", b + ' ',
				     xcode, ycode);
		    nread = 6;	/* tmp may contain NUL bytes */
		  }
		syscall_printf ("mouse: %s at (%d,%d)", sz,
				con.dwMousePosition.X,
				con.dwMousePosition.Y);

		toadd = tmp;
	      }
	  }
	  break;

	case FOCUS_EVENT:
	  if (con.use_focus)
	    {
	      if (input_rec.Event.FocusEvent.bSetFocus)
		__small_sprintf (tmp, "\033[I");
	      else
		__small_sprintf (tmp, "\033[O");

	      toadd = tmp;
	      nread = 3;
	    }
	  break;

	case WINDOW_BUFFER_SIZE_EVENT:
	  send_winch_maybe ();
	  /* fall through */
	default:
	  continue;
	}

      if (toadd)
	{
	  line_edit_status res = line_edit (toadd, nread, ti);
	  if (res == line_edit_signalled)
	    goto sig_exit;
	  else if (res == line_edit_input_done)
	    break;
	}
    }

  while (buflen)
    if ((ch = get_readahead ()) < 0)
      break;
    else
      {
	buf[copied_chars++] = (unsigned char)(ch & 0xff);
	buflen--;
      }
#undef buf

  buflen = copied_chars;
  return;

err:
  __seterrno ();
  buflen = (size_t) -1;
  return;

sig_exit:
  set_sig_errno (EINTR);
  buflen = (size_t) -1;
}

void
fhandler_console::set_input_state ()
{
  if (get_ttyp ()->rstcons ())
    input_tcsetattr (0, &get_ttyp ()->ti);
}

bool
dev_console::fillin (HANDLE h)
{
  bool ret;

  if ((ret = GetConsoleScreenBufferInfo (h, &b)))
    {
      dwWinSize.Y = 1 + b.srWindow.Bottom - b.srWindow.Top;
      dwWinSize.X = 1 + b.srWindow.Right - b.srWindow.Left;
      if (b.dwSize.Y != b.dwSize.Y || b.dwSize.X != b.dwSize.X)
	dwEnd.X = dwEnd.Y = 0;
      if (b.dwCursorPosition.Y > dwEnd.Y
	  || (b.dwCursorPosition.Y >= dwEnd.Y && b.dwCursorPosition.X > dwEnd.X))
	dwEnd = b.dwCursorPosition;
    }
  else
    {
      memset (&b, 0, sizeof (b));
      dwWinSize.Y = 25;
      dwWinSize.X = 80;
      b.srWindow.Bottom = 24;
      b.srWindow.Right = 79;
    }

  return ret;
}

void __reg3
dev_console::scroll_buffer (HANDLE h, int x1, int y1, int x2, int y2, int xn, int yn)
{
/* Scroll the screen context.
   x1, y1 - ul corner
   x2, y2 - dr corner
   xn, yn - new ul corner
   Negative values represents current screen dimensions
*/
  SMALL_RECT sr1, sr2;
  CHAR_INFO fill;
  COORD dest;
  fill.Char.AsciiChar = ' ';
  fill.Attributes = current_win32_attr;

  fillin (h);
  sr1.Left = x1 >= 0 ? x1 : dwWinSize.X - 1;
  sr1.Top = y1 >= 0 ? y1 : b.srWindow.Bottom;
  sr1.Right = x2 >= 0 ? x2 : dwWinSize.X - 1;
  sr1.Bottom = y2 >= 0 ? y2 : b.srWindow.Bottom;
  sr2.Top = b.srWindow.Top + scroll_region.Top;
  sr2.Left = 0;
  sr2.Bottom = (scroll_region.Bottom < 0) ? b.srWindow.Bottom : b.srWindow.Top + scroll_region.Bottom;
  sr2.Right = dwWinSize.X - 1;
  if (sr1.Bottom > sr2.Bottom && sr1.Top <= sr2.Bottom)
    sr1.Bottom = sr2.Bottom;
  dest.X = xn >= 0 ? xn : dwWinSize.X - 1;
  dest.Y = yn >= 0 ? yn : b.srWindow.Bottom;
  ScrollConsoleScreenBuffer (h, &sr1, &sr2, dest, &fill);
}

inline void
fhandler_console::scroll_buffer (int x1, int y1, int x2, int y2, int xn, int yn)
{
  con.scroll_buffer (get_output_handle (), x1, y1, x2, y2, xn, yn);
}

inline void
fhandler_console::scroll_buffer_screen (int x1, int y1, int x2, int y2, int xn, int yn)
{
  if (y1 >= 0)
    y1 += con.b.srWindow.Top;
  if (y2 >= 0)
    y1 += con.b.srWindow.Top;
  if (yn >= 0)
    yn += con.b.srWindow.Top;
  con.scroll_buffer (get_output_handle (), x1, y1, x2, y2, xn, yn);
}

int
fhandler_console::dup (fhandler_base *child, int flags)
{
  /* See comments in fhandler_pty_slave::dup */
  if (myself->ctty != -2)
    myself->set_ctty (this, flags);
  return 0;
}

int
fhandler_console::open (int flags, mode_t)
{
  HANDLE h;

  if (dev () == FH_ERROR)
    {
      set_errno (EPERM);	/* constructor found an error */
      return 0;
    }

  tcinit (false);

  set_io_handle (NULL);
  set_output_handle (NULL);

  /* Open the input handle as handle_ */
  h = CreateFile ("CONIN$", GENERIC_READ | GENERIC_WRITE,
		  FILE_SHARE_READ | FILE_SHARE_WRITE, &sec_none,
		  OPEN_EXISTING, 0, 0);

  if (h == INVALID_HANDLE_VALUE)
    {
      __seterrno ();
      return 0;
    }
  set_io_handle (h);

  h = CreateFile ("CONOUT$", GENERIC_READ | GENERIC_WRITE,
		  FILE_SHARE_READ | FILE_SHARE_WRITE, &sec_none,
		  OPEN_EXISTING, 0, 0);

  if (h == INVALID_HANDLE_VALUE)
    {
      __seterrno ();
      return 0;
    }
  set_output_handle (h);

  if (con.fillin (get_output_handle ()))
    {
      con.current_win32_attr = con.b.wAttributes;
      if (!con.default_color)
	con.default_color = con.b.wAttributes;
      con.set_default_attr ();
    }

  get_ttyp ()->rstcons (false);
  set_open_status ();

  DWORD cflags;
  if (GetConsoleMode (get_io_handle (), &cflags))
    SetConsoleMode (get_io_handle (),
		    ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT | cflags);

  debug_printf ("opened conin$ %p, conout$ %p", get_io_handle (),
		get_output_handle ());

  return 1;
}

void
fhandler_console::open_setup (int flags)
{
  set_flags ((flags & ~O_TEXT) | O_BINARY);
  if (myself->set_ctty (this, flags) && !myself->cygstarted)
    init_console_handler (true);
  fhandler_base::open_setup (flags);
}

int
fhandler_console::close ()
{
  CloseHandle (get_io_handle ());
  CloseHandle (get_output_handle ());
  if (!have_execed)
    free_console ();
  return 0;
}

int
fhandler_console::ioctl (unsigned int cmd, void *arg)
{
  int res = fhandler_termios::ioctl (cmd, arg);
  if (res <= 0)
    return res;
  switch (cmd)
    {
      case TIOCGWINSZ:
	int st;

	st = con.fillin (get_output_handle ());
	if (st)
	  {
	    /* *not* the buffer size, the actual screen size... */
	    /* based on Left Top Right Bottom of srWindow */
	    ((struct winsize *) arg)->ws_row = con.dwWinSize.Y;
	    ((struct winsize *) arg)->ws_col = con.dwWinSize.X;
	    syscall_printf ("WINSZ: (row=%d,col=%d)",
			   ((struct winsize *) arg)->ws_row,
			   ((struct winsize *) arg)->ws_col);
	    return 0;
	  }
	else
	  {
	    syscall_printf ("WINSZ failed");
	    __seterrno ();
	    return -1;
	  }
	return 0;
      case TIOCSWINSZ:
	bg_check (SIGTTOU);
	return 0;
      case KDGKBMETA:
	*(int *) arg = (con.metabit) ? K_METABIT : K_ESCPREFIX;
	return 0;
      case KDSKBMETA:
	if ((intptr_t) arg == K_METABIT)
	  con.metabit = TRUE;
	else if ((intptr_t) arg == K_ESCPREFIX)
	  con.metabit = FALSE;
	else
	  {
	    set_errno (EINVAL);
	    return -1;
	  }
	return 0;
      case TIOCLINUX:
	if (*(unsigned char *) arg == 6)
	  {
	    *(unsigned char *) arg = (unsigned char) con.nModifiers;
	    return 0;
	  }
	set_errno (EINVAL);
	return -1;
      case FIONREAD:
	{
	  /* Per MSDN, max size of buffer required is below 64K. */
#define	  INREC_SIZE	(65536 / sizeof (INPUT_RECORD))

	  DWORD n;
	  int ret = 0;
	  INPUT_RECORD inp[INREC_SIZE];
	  if (!PeekConsoleInputW (get_io_handle (), inp, INREC_SIZE, &n))
	    {
	      set_errno (EINVAL);
	      return -1;
	    }
	  while (n-- > 0)
	    if (inp[n].EventType == KEY_EVENT && inp[n].Event.KeyEvent.bKeyDown)
	      ++ret;
	  *(int *) arg = ret;
	  return 0;
	}
	break;
    }

  return fhandler_base::ioctl (cmd, arg);
}

int
fhandler_console::tcflush (int queue)
{
  int res = 0;
  if (queue == TCIFLUSH
      || queue == TCIOFLUSH)
    {
      if (!FlushConsoleInputBuffer (get_io_handle ()))
	{
	  __seterrno ();
	  res = -1;
	}
    }
  return res;
}

int
fhandler_console::output_tcsetattr (int, struct termios const *t)
{
  /* All the output bits we can ignore */

  DWORD flags = ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT;

  int res = SetConsoleMode (get_output_handle (), flags) ? 0 : -1;
  if (res)
    __seterrno_from_win_error (GetLastError ());
  syscall_printf ("%d = tcsetattr(,%p) (ENABLE FLAGS %y) (lflag %y oflag %y)",
		  res, t, flags, t->c_lflag, t->c_oflag);
  return res;
}

int
fhandler_console::input_tcsetattr (int, struct termios const *t)
{
  /* Ignore the optional_actions stuff, since all output is emitted
     instantly */

  DWORD oflags;

  if (!GetConsoleMode (get_io_handle (), &oflags))
    oflags = 0;
  DWORD flags = 0;

#if 0
  /* Enable/disable LF -> CRLF conversions */
  rbinary ((t->c_iflag & INLCR) ? false : true);
#endif

  /* There's some disparity between what we need and what's
     available.  We've got ECHO and ICANON, they've
     got ENABLE_ECHO_INPUT and ENABLE_LINE_INPUT. */

  termios_printf ("this %p, get_ttyp () %p, t %p", this, get_ttyp (), t);
  get_ttyp ()->ti = *t;

  if (t->c_lflag & ECHO)
    {
      flags |= ENABLE_ECHO_INPUT;
    }
  if (t->c_lflag & ICANON)
    {
      flags |= ENABLE_LINE_INPUT;
    }

  if (flags & ENABLE_ECHO_INPUT
      && !(flags & ENABLE_LINE_INPUT))
    {
      /* This is illegal, so turn off the echo here, and fake it
	 when we read the characters */

      flags &= ~ENABLE_ECHO_INPUT;
    }

  if ((t->c_lflag & ISIG) && !(t->c_iflag & IGNBRK))
    {
      flags |= ENABLE_PROCESSED_INPUT;
    }

  flags |= ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT;

  int res;
  if (flags == oflags)
    res = 0;
  else
    {
      res = SetConsoleMode (get_io_handle (), flags) ? 0 : -1;
      if (res < 0)
	__seterrno ();
      syscall_printf ("%d = tcsetattr(,%p) enable flags %y, c_lflag %y iflag %y",
		      res, t, flags, t->c_lflag, t->c_iflag);
    }

  get_ttyp ()->rstcons (false);
  return res;
}

int
fhandler_console::tcsetattr (int a, struct termios const *t)
{
  int res = output_tcsetattr (a, t);
  if (res != 0)
    return res;
  return input_tcsetattr (a, t);
}

int
fhandler_console::tcgetattr (struct termios *t)
{
  int res;
  *t = get_ttyp ()->ti;

  t->c_cflag |= CS8;

  DWORD flags;

  if (!GetConsoleMode (get_io_handle (), &flags))
    {
      __seterrno ();
      res = -1;
    }
  else
    {
      if (flags & ENABLE_ECHO_INPUT)
	t->c_lflag |= ECHO;

      if (flags & ENABLE_LINE_INPUT)
	t->c_lflag |= ICANON;

      if (flags & ENABLE_PROCESSED_INPUT)
	t->c_lflag |= ISIG;
      else
	t->c_iflag |= IGNBRK;

      /* What about ENABLE_WINDOW_INPUT
	 and ENABLE_MOUSE_INPUT   ? */

      /* All the output bits we can ignore */
      res = 0;
    }
  syscall_printf ("%d = tcgetattr(%p) enable flags %y, t->lflag %y, t->iflag %y",
		 res, t, flags, t->c_lflag, t->c_iflag);
  return res;
}

fhandler_console::fhandler_console (fh_devices unit) :
  fhandler_termios ()
{
  if (unit > 0)
    dev ().parse (unit);
  setup ();
  trunc_buf.len = 0;
  _tc = &(shared_console_info->tty_min_state);
}

void
dev_console::set_color (HANDLE h)
{
  WORD win_fg = fg;
  WORD win_bg = bg;
  if (reverse)
    {
      WORD save_fg = win_fg;
      win_fg = (win_bg & BACKGROUND_RED   ? FOREGROUND_RED   : 0) |
	       (win_bg & BACKGROUND_GREEN ? FOREGROUND_GREEN : 0) |
	       (win_bg & BACKGROUND_BLUE  ? FOREGROUND_BLUE  : 0) |
	       (win_bg & BACKGROUND_INTENSITY ? FOREGROUND_INTENSITY : 0);
      win_bg = (save_fg & FOREGROUND_RED   ? BACKGROUND_RED   : 0) |
	       (save_fg & FOREGROUND_GREEN ? BACKGROUND_GREEN : 0) |
	       (save_fg & FOREGROUND_BLUE  ? BACKGROUND_BLUE  : 0) |
	       (save_fg & FOREGROUND_INTENSITY ? BACKGROUND_INTENSITY : 0);
    }

  /* apply attributes */
  if (underline)
    win_fg = underline_color;
  /* emulate blink with bright background */
  if (blink)
    win_bg |= BACKGROUND_INTENSITY;
  if (intensity == INTENSITY_INVISIBLE)
    win_fg = win_bg;
  else if (intensity != INTENSITY_BOLD)
    /* nothing to do */;
    /* apply foreground intensity only in non-reverse mode! */
  else if (reverse)
    win_bg |= BACKGROUND_INTENSITY;
  else
    win_fg |= FOREGROUND_INTENSITY;

  current_win32_attr = win_fg | win_bg;
  if (h)
    SetConsoleTextAttribute (h, current_win32_attr);
}

#define FOREGROUND_ATTR_MASK (FOREGROUND_RED | FOREGROUND_GREEN | \
			      FOREGROUND_BLUE | FOREGROUND_INTENSITY)
#define BACKGROUND_ATTR_MASK (BACKGROUND_RED | BACKGROUND_GREEN | \
			      BACKGROUND_BLUE | BACKGROUND_INTENSITY)
void
dev_console::set_default_attr ()
{
  blink = underline = reverse = false;
  intensity = INTENSITY_NORMAL;
  fg = default_color & FOREGROUND_ATTR_MASK;
  bg = default_color & BACKGROUND_ATTR_MASK;
  set_color (NULL);
}

int
dev_console::set_cl_x (cltype x)
{
  if (x == cl_disp_beg || x == cl_buf_beg)
    return 0;
  if (x == cl_disp_end)
    return dwWinSize.X - 1;
  if (x == cl_buf_end)
    return b.dwSize.X - 1;
  return b.dwCursorPosition.X;
}

int
dev_console::set_cl_y (cltype y)
{
  if (y == cl_buf_beg)
    return 0;
  if (y == cl_disp_beg)
    return b.srWindow.Top;
  if (y == cl_disp_end)
    return b.srWindow.Bottom;
  if (y == cl_buf_end)
    return b.dwSize.Y - 1;
  return b.dwCursorPosition.Y;
}

bool
dev_console::scroll_window (HANDLE h, int x1, int y1, int x2, int y2)
{
  if (save_buf || x1 != 0 || x2 != dwWinSize.X - 1 || y1 != b.srWindow.Top
      || y2 != b.srWindow.Bottom || b.dwSize.Y <= dwWinSize.Y)
    return false;

  SMALL_RECT sr;
  int toscroll = 2 + dwEnd.Y - b.srWindow.Top;
  int shrink = 1 + toscroll + b.srWindow.Bottom - b.dwSize.Y;
  sr.Left = sr.Right = dwEnd.X = 0;
  /* Can't increment dwEnd yet since we may not have space in
     the buffer.  */
  SetConsoleCursorPosition (h, dwEnd);
  if (shrink > 0)
    {
      COORD c = b.dwSize;
      c.Y = dwEnd.Y - shrink;
      SetConsoleScreenBufferSize (h, c);
      SetConsoleScreenBufferSize (h, b.dwSize);
      dwEnd.Y = 0;
      fillin (h);
      toscroll = 2 + dwEnd.Y - b.srWindow.Top;
    }

  sr.Top = sr.Bottom = toscroll;

  SetConsoleWindowInfo (h, FALSE, &sr);

  dwEnd.Y++;
  SetConsoleCursorPosition (h, dwEnd);

  fillin (h);
  return true;
}

/*
 * Clear the screen context from x1/y1 to x2/y2 cell.
 * Negative values represents current screen dimensions
 */
void __reg3
fhandler_console::clear_screen (cltype xc1, cltype yc1, cltype xc2, cltype yc2)
{
  HANDLE h = get_output_handle ();
  con.fillin (h);

  int x1 = con.set_cl_x (xc1);
  int y1 = con.set_cl_y (yc1);
  int x2 = con.set_cl_x (xc2);
  int y2 = con.set_cl_y (yc2);

  /* Detect special case - scroll the screen if we have a buffer in order to
     preserve the buffer. */
  if (!con.scroll_window (h, x1, y1, x2, y2))
    con.clear_screen (h, x1, y1, x2, y2);
}

void __reg3
dev_console::clear_screen (HANDLE h, int x1, int y1, int x2, int y2)
{
  COORD tlc;
  DWORD done;
  int num;

  num = abs (y1 - y2) * b.dwSize.X + abs (x1 - x2) + 1;

  if ((y2 * b.dwSize.X + x2) > (y1 * b.dwSize.X + x1))
    {
      tlc.X = x1;
      tlc.Y = y1;
    }
  else
    {
      tlc.X = x2;
      tlc.Y = y2;
    }
  FillConsoleOutputCharacterA (h, ' ', num, tlc, &done);
  FillConsoleOutputAttribute (h, current_win32_attr, num, tlc, &done);
}

void __reg3
fhandler_console::cursor_set (bool rel_to_top, int x, int y)
{
  COORD pos;

  con.fillin (get_output_handle ());
#if 0
  /* Setting y to the current b.srWindow.Bottom here is the reason that the window
     isn't scrolled back to the current cursor position like it's done in
     any other terminal.  Rather, the curser is forced to the bottom of the
     currently scrolled region.  This breaks the console buffer content if
     output is generated while the user had the window scrolled back.  This
     behaviour is very old, it has no matching ChangeLog entry.
     Just disable for now but keep the code in for future reference. */
  if (y > con.b.srWindow.Bottom)
    y = con.b.srWindow.Bottom;
  else
#endif
  if (y < 0)
    y = 0;
  else if (rel_to_top)
    y += con.b.srWindow.Top;

  if (x > con.dwWinSize.X)
    x = con.dwWinSize.X - 1;
  else if (x < 0)
    x = 0;

  pos.X = x;
  pos.Y = y;
  SetConsoleCursorPosition (get_output_handle (), pos);
}

void __reg3
fhandler_console::cursor_rel (int x, int y)
{
  con.fillin (get_output_handle ());
  x += con.b.dwCursorPosition.X;
  y += con.b.dwCursorPosition.Y;
  cursor_set (false, x, y);
}

void __reg3
fhandler_console::cursor_get (int *x, int *y)
{
  con.fillin (get_output_handle ());
  *y = con.b.dwCursorPosition.Y;
  *x = con.b.dwCursorPosition.X;
}

/* VT100 line drawing graphics mode maps `abcdefghijklmnopqrstuvwxyz{|}~ to
   graphical characters */
static const wchar_t __vt100_conv[31] = {
	0x25C6, /* Black Diamond */
	0x2592, /* Medium Shade */
	0x2409, /* Symbol for Horizontal Tabulation */
	0x240C, /* Symbol for Form Feed */
	0x240D, /* Symbol for Carriage Return */
	0x240A, /* Symbol for Line Feed */
	0x00B0, /* Degree Sign */
	0x00B1, /* Plus-Minus Sign */
	0x2424, /* Symbol for Newline */
	0x240B, /* Symbol for Vertical Tabulation */
	0x2518, /* Box Drawings Light Up And Left */
	0x2510, /* Box Drawings Light Down And Left */
	0x250C, /* Box Drawings Light Down And Right */
	0x2514, /* Box Drawings Light Up And Right */
	0x253C, /* Box Drawings Light Vertical And Horizontal */
	0x23BA, /* Horizontal Scan Line-1 */
	0x23BB, /* Horizontal Scan Line-3 */
	0x2500, /* Box Drawings Light Horizontal */
	0x23BC, /* Horizontal Scan Line-7 */
	0x23BD, /* Horizontal Scan Line-9 */
	0x251C, /* Box Drawings Light Vertical And Right */
	0x2524, /* Box Drawings Light Vertical And Left */
	0x2534, /* Box Drawings Light Up And Horizontal */
	0x252C, /* Box Drawings Light Down And Horizontal */
	0x2502, /* Box Drawings Light Vertical */
	0x2264, /* Less-Than Or Equal To */
	0x2265, /* Greater-Than Or Equal To */
	0x03C0, /* Greek Small Letter Pi */
	0x2260, /* Not Equal To */
	0x00A3, /* Pound Sign */
	0x00B7, /* Middle Dot */
};

inline
bool fhandler_console::write_console (PWCHAR buf, DWORD len, DWORD& done)
{
  if (con.iso_2022_G1
	? con.vt100_graphics_mode_G1
	: con.vt100_graphics_mode_G0)
    for (DWORD i = 0; i < len; i ++)
      if (buf[i] >= (unsigned char) '`' && buf[i] <= (unsigned char) '~')
	buf[i] = __vt100_conv[buf[i] - (unsigned char) '`'];

  while (len > 0)
    {
      DWORD nbytes = len > MAX_WRITE_CHARS ? MAX_WRITE_CHARS : len;
      if (!WriteConsoleW (get_output_handle (), buf, nbytes, &done, 0))
	{
	  __seterrno ();
	  return false;
	}
      len -= done;
      buf += done;
    }
  return true;
}

/* The following three functions were adapted (i.e., mildly modified) from
   http://stackoverflow.com/questions/14699043/replacement-to-systemcolor */

/* Split a rectangular region into two smaller rectangles based on the
   largest dimension. */
static void
region_split (PCHAR_INFO& buf, COORD& bufsiz, SMALL_RECT& region,
	      PCHAR_INFO& buf_b, COORD& bufsiz_b, SMALL_RECT& region_b)
{
  region_b = region;
  bufsiz_b = bufsiz;

  SHORT half = (1 + region.Bottom - region.Top) / 2;
  region_b.Top += half;
  region.Bottom = (bufsiz.Y = region_b.Top) - 1;
  buf_b = buf + (half * (1 + region.Right));
  bufsiz_b.Y = region_b.Bottom - region_b.Top;
}

/* Utility function to figure out the distance between two points. */
static SHORT
delta (SHORT first, SHORT second)
{
  return (second >= first) ? (second - first + 1) : 0;
}

/* Subdivide the ReadConsoleInput operation into smaller and smaller chunks as
   needed until it succeeds in reading the entire screen buffer. */
static BOOL
ReadConsoleOutputWrapper (HANDLE h, PCHAR_INFO buf, COORD bufsiz,
			  SMALL_RECT region)
{
  COORD coord = {};
  SHORT width = delta (region.Left, region.Right);
  SHORT height = delta (region.Top, region.Bottom);

  if ((width == 0) || (height == 0))
    return TRUE;

  BOOL success = ReadConsoleOutputW (h, buf, bufsiz, coord, &region);
  if (success)
    /* it worked */;
  else if (GetLastError () == ERROR_NOT_ENOUGH_MEMORY && (width * height) > 1)
    {
      PCHAR_INFO buf_b;
      COORD bufsiz_b;
      SMALL_RECT region_b;
      region_split (buf, bufsiz, region, buf_b, bufsiz_b, region_b);
      success = ReadConsoleOutputWrapper (h, buf, bufsiz, region)
		&& ReadConsoleOutputWrapper (h, buf_b, bufsiz_b, region_b);
    }
  return success;
}

void
dev_console::save_restore (HANDLE h, char c)
{
  if (c == 'h') /* save */
    {
      fillin (h);
      save_bufsize.X = b.dwSize.X;
      if ((save_bufsize.Y = dwEnd.Y + 1) > b.dwSize.Y)
	save_bufsize.X = b.dwSize.Y;

      if (save_buf)
	cfree (save_buf);
      size_t screen_size = sizeof (CHAR_INFO) * save_bufsize.X * save_bufsize.Y;
      save_buf = (PCHAR_INFO) cmalloc_abort (HEAP_1_BUF, screen_size);

      save_cursor = b.dwCursorPosition;	/* Remember where we were. */
      save_top = b.srWindow.Top;

      SMALL_RECT now = {};		/* Read the whole buffer */
      now.Bottom = save_bufsize.Y - 1;
      now.Right = save_bufsize.X - 1;
      if (!ReadConsoleOutputWrapper (h, save_buf, save_bufsize, now))
	debug_printf ("ReadConsoleOutputWrapper(h, ...) failed during save, %E");

      /* Position at top of buffer */
      COORD cob = {};
      if (!SetConsoleCursorPosition (h, cob))
	debug_printf ("SetConsoleCursorInfo(%p, ...) failed during save, %E", h);

      /* Clear entire buffer */
      clear_screen (h, 0, 0, now.Right, now.Bottom);
      b.dwCursorPosition.X = b.dwCursorPosition.Y = dwEnd.X = dwEnd.Y = 0;
    }
  else if (save_buf)
    {
      COORD cob = {};
      SMALL_RECT now = {};
      now.Bottom = save_bufsize.Y - 1;
      now.Right = save_bufsize.X - 1;
      /* Restore whole buffer */
      clear_screen (h, 0, 0, b.dwSize.X - 1, b.dwSize.Y - 1);
      BOOL res = WriteConsoleOutputW (h, save_buf, save_bufsize, cob, &now);
      if (!res)
	debug_printf ("WriteConsoleOutputW failed, %E");

      cfree (save_buf);
      save_buf = NULL;

      cob.X = 0;
      cob.Y = save_top;
      /* CGF: NOOP?  Doesn't seem to position screen as expected */
      /* Temporarily position at top of screen */
      if (!SetConsoleCursorPosition (h, cob))
	debug_printf ("SetConsoleCursorInfo(%p, cob) failed during restore, %E", h);
      /* Position where we were previously */
      if (!SetConsoleCursorPosition (h, save_cursor))
	debug_printf ("SetConsoleCursorInfo(%p, save_cursor) failed during restore, %E", h);
      /* Get back correct version of buffer information */
      dwEnd.X = dwEnd.Y = 0;
      fillin (h);
    }
}

#define BAK 1
#define ESC 2
#define NOR 0
#define IGN 4
#if 1
#define ERR 5
#else
#define ERR NOR
#endif
#define DWN 6
#define BEL 7
#define TAB 8 /* We should't let the console deal with these */
#define CR 13
#define LF 10
#define SO 14
#define SI 15

static const char base_chars[256] =
{
/*00 01 02 03 04 05 06 07 */ IGN, ERR, ERR, NOR, NOR, NOR, NOR, BEL,
/*08 09 0A 0B 0C 0D 0E 0F */ BAK, TAB, DWN, ERR, ERR, CR,  SO,  SI,
/*10 11 12 13 14 15 16 17 */ NOR, NOR, ERR, ERR, ERR, ERR, ERR, ERR,
/*18 19 1A 1B 1C 1D 1E 1F */ NOR, NOR, ERR, ESC, ERR, ERR, ERR, ERR,
/*   !  "  #  $  %  &  '  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*(  )  *  +  ,  -  .  /  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*0  1  2  3  4  5  6  7  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*8  9  :  ;  <  =  >  ?  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*@@  A  B  C  D  E  F  G  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*H  I  J  K  L  M  N  O  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*P  Q  R  S  T  U  V  W  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*X  Y  Z  [  \  ]  ^  _  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*`  a  b  c  d  e  f  g  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*h  i  j  k  l  m  n  o  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*p  q  r  s  t  u  v  w  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*x  y  z  {  |  }  ~  7F */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*80 81 82 83 84 85 86 87 */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*88 89 8A 8B 8C 8D 8E 8F */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*90 91 92 93 94 95 96 97 */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*98 99 9A 9B 9C 9D 9E 9F */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*A0 A1 A2 A3 A4 A5 A6 A7 */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*A8 A9 AA AB AC AD AE AF */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*B0 B1 B2 B3 B4 B5 B6 B7 */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*B8 B9 BA BB BC BD BE BF */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*C0 C1 C2 C3 C4 C5 C6 C7 */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*C8 C9 CA CB CC CD CE CF */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*D0 D1 D2 D3 D4 D5 D6 D7 */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*D8 D9 DA DB DC DD DE DF */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*E0 E1 E2 E3 E4 E5 E6 E7 */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*E8 E9 EA EB EC ED EE EF */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*F0 F1 F2 F3 F4 F5 F6 F7 */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
/*F8 F9 FA FB FC FD FE FF */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR };

void
fhandler_console::char_command (char c)
{
  int x, y, n;
  char buf[40];

  switch (c)
    {
    case 'm':   /* Set Graphics Rendition */
       for (int i = 0; i <= con.nargs; i++)
	 switch (con.args[i])
	   {
	     case 0:    /* normal color */
	       con.set_default_attr ();
	       break;
	     case 1:    /* bold */
	       con.intensity = INTENSITY_BOLD;
	       break;
	     case 2:	/* dim */
	       con.intensity = INTENSITY_DIM;
	       break;
	     case 4:	/* underlined */
	       con.underline = 1;
	       break;
	     case 5:    /* blink mode */
	       con.blink = true;
	       break;
	     case 7:    /* reverse */
	       con.reverse = true;
	       break;
	     case 8:    /* invisible */
	       con.intensity = INTENSITY_INVISIBLE;
	       break;
	     case 10:   /* end alternate charset */
	       con.alternate_charset_active = false;
	       break;
	     case 11:   /* start alternate charset */
	       con.alternate_charset_active = true;
	       break;
	     case 22:
	     case 28:
	       con.intensity = INTENSITY_NORMAL;
	       break;
	     case 24:
	       con.underline = false;
	       break;
	     case 25:
	       con.blink = false;
	       break;
	     case 27:
	       con.reverse = false;
	       break;
	     case 30:		/* BLACK foreground */
	       con.fg = 0;
	       break;
	     case 31:		/* RED foreground */
	       con.fg = FOREGROUND_RED;
	       break;
	     case 32:		/* GREEN foreground */
	       con.fg = FOREGROUND_GREEN;
	       break;
	     case 33:		/* YELLOW foreground */
	       con.fg = FOREGROUND_RED | FOREGROUND_GREEN;
	       break;
	     case 34:		/* BLUE foreground */
	       con.fg = FOREGROUND_BLUE;
	       break;
	     case 35:		/* MAGENTA foreground */
	       con.fg = FOREGROUND_RED | FOREGROUND_BLUE;
	       break;
	     case 36:		/* CYAN foreground */
	       con.fg = FOREGROUND_BLUE | FOREGROUND_GREEN;
	       break;
	     case 37:		/* WHITE foreg */
	       con.fg = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED;
	       break;
	     case 39:
	       con.fg = con.default_color & FOREGROUND_ATTR_MASK;
	       break;
	     case 40:		/* BLACK background */
	       con.bg = 0;
	       break;
	     case 41:		/* RED background */
	       con.bg = BACKGROUND_RED;
	       break;
	     case 42:		/* GREEN background */
	       con.bg = BACKGROUND_GREEN;
	       break;
	     case 43:		/* YELLOW background */
	       con.bg = BACKGROUND_RED | BACKGROUND_GREEN;
	       break;
	     case 44:		/* BLUE background */
	       con.bg = BACKGROUND_BLUE;
	       break;
	     case 45:		/* MAGENTA background */
	       con.bg = BACKGROUND_RED | BACKGROUND_BLUE;
	       break;
	     case 46:		/* CYAN background */
	       con.bg = BACKGROUND_BLUE | BACKGROUND_GREEN;
	       break;
	     case 47:    /* WHITE background */
	       con.bg = BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED;
	       break;
	     case 49:
	       con.bg = con.default_color & BACKGROUND_ATTR_MASK;
	       break;
	   }
       con.set_color (get_output_handle ());
      break;
    case 'q': /* Set cursor style (DECSCUSR) */
      if (con.saw_space)
	{
	    CONSOLE_CURSOR_INFO console_cursor_info;
	    GetConsoleCursorInfo (get_output_handle (), &console_cursor_info);
	    switch (con.args[0])
	      {
		case 0: /* blinking block */
		case 1: /* blinking block (default) */
		case 2: /* steady block */
		  console_cursor_info.dwSize = 100;
		  SetConsoleCursorInfo (get_output_handle (), &console_cursor_info);
		  break;
		case 3: /* blinking underline */
		case 4: /* steady underline */
		  console_cursor_info.dwSize = 10;	/* or Windows default 25? */
		  SetConsoleCursorInfo (get_output_handle (), &console_cursor_info);
		  break;
		default: /* use value as percentage */
		  console_cursor_info.dwSize = con.args[0];
		  SetConsoleCursorInfo (get_output_handle (), &console_cursor_info);
		  break;
	      }
	}
      break;
    case 'h':
    case 'l':
      if (!con.saw_question_mark)
	{
	  switch (con.args[0])
	    {
	    case 4:    /* Insert mode */
	      con.insert_mode = (c == 'h') ? true : false;
	      syscall_printf ("insert mode %sabled", con.insert_mode ? "en" : "dis");
	      break;
	    }
	  break;
	}
      switch (con.args[0])
	{
	case 25: /* Show/Hide Cursor (DECTCEM) */
	  {
	    CONSOLE_CURSOR_INFO console_cursor_info;
	    GetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
	    if (c == 'h')
	      console_cursor_info.bVisible = TRUE;
	    else
	      console_cursor_info.bVisible = FALSE;
	    SetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
	    break;
	  }
	case 47:   /* Save/Restore screen */
	  con.save_restore (get_output_handle (), c);
	  break;

	case 67: /* DECBKM ("DEC Backarrow Key Mode") */
	  con.backspace_keycode = (c == 'h' ? CTRL('H') : CERASE);
	  break;

	case 1000: /* Mouse tracking */
	  con.use_mouse = (c == 'h') ? 1 : 0;
	  break;

	case 1002: /* Mouse button event tracking */
	  con.use_mouse = (c == 'h') ? 2 : 0;
	  break;

	case 1003: /* Mouse any event tracking */
	  con.use_mouse = (c == 'h') ? 3 : 0;
	  break;

	case 1004: /* Focus in/out event reporting */
	  con.use_focus = (c == 'h') ? true : false;
	  break;

	case 1005: /* Extended mouse mode */
	  con.ext_mouse_mode5 = c == 'h';
	  break;

	case 1006: /* SGR extended mouse mode */
	  con.ext_mouse_mode6 = c == 'h';
	  break;

	case 1015: /* Urxvt extended mouse mode */
	  con.ext_mouse_mode15 = c == 'h';
	  break;

	case 2000: /* Raw keyboard mode */
	  set_raw_win32_keyboard_mode ((c == 'h') ? true : false);
	  break;

	default: /* Ignore */
	  syscall_printf ("unknown h/l command: %d", con.args[0]);
	  break;
	}
      break;
    case 'J':
      switch (con.args[0])
	{
	case 0:			/* Clear to end of screen */
	  clear_screen (cl_curr_pos, cl_curr_pos, cl_disp_end, cl_disp_end);
	  break;
	case 1:			/* Clear from beginning of screen to cursor */
	  clear_screen (cl_disp_beg, cl_disp_beg, cl_curr_pos, cl_curr_pos);
	  break;
	case 2:			/* Clear screen */
	  cursor_get (&x, &y);
	  clear_screen (cl_disp_beg, cl_disp_beg, cl_disp_end, cl_disp_end);
	  cursor_set (false, x, y);
	  break;
	default:
	  goto bad_escape;
	}
      break;

    case 'A':
      cursor_rel (0, -(con.args[0] ?: 1));
      break;
    case 'B':
      cursor_rel (0, con.args[0] ?: 1);
      break;
    case 'C':
      cursor_rel (con.args[0] ?: 1, 0);
      break;
    case 'D':
      cursor_rel (-(con.args[0] ?: 1),0);
      break;
    case 'K':
      switch (con.args[0])
	{
	  case 0:		/* Clear to end of line */
	    clear_screen (cl_curr_pos, cl_curr_pos, cl_disp_end, cl_curr_pos);
	    break;
	  case 2:		/* Clear line */
	    clear_screen (cl_disp_beg, cl_curr_pos, cl_disp_end, cl_curr_pos);
	    break;
	  case 1:		/* Clear from bol to cursor */
	    clear_screen (cl_disp_beg, cl_curr_pos, cl_curr_pos, cl_curr_pos);
	    break;
	  default:
	    goto bad_escape;
	}
      break;
    case 'H':
    case 'f':
      cursor_set (true, (con.args[1] ?: 1) - 1,
			(con.args[0] ?: 1) - 1);
      break;
    case 'G':   /* hpa - position cursor at column n - 1 */
      cursor_get (&x, &y);
      cursor_set (false, (con.args[0] ? con.args[0] - 1 : 0), y);
      break;
    case 'd':   /* vpa - position cursor at line n */
      cursor_get (&x, &y);
      cursor_set (true, x, (con.args[0] ? con.args[0] - 1 : 0));
      break;
    case 's':   /* Save cursor position */
      cursor_get (&con.savex, &con.savey);
      con.savey -= con.b.srWindow.Top;
      break;
    case 'u':   /* Restore cursor position */
      cursor_set (true, con.savex, con.savey);
      break;
    case 'I':	/* TAB */
      cursor_get (&x, &y);
      cursor_set (false, 8 * (x / 8 + 1), y);
      break;
    case 'L':				/* AL - insert blank lines */
      n = con.args[0] ?: 1;
      cursor_get (&x, &y);
      scroll_buffer (0, y, -1, -1, 0, y + n);
      break;
    case 'M':				/* DL - delete lines */
      n = con.args[0] ?: 1;
      cursor_get (&x, &y);
      scroll_buffer (0, y + n, -1, -1, 0, y);
      break;
    case '@@':				/* IC - insert chars */
      n = con.args[0] ?: 1;
      cursor_get (&x, &y);
      scroll_buffer (x, y, -1, y, x + n, y);
      break;
    case 'P':				/* DC - delete chars */
      n = con.args[0] ?: 1;
      cursor_get (&x, &y);
      scroll_buffer (x + n, y, -1, y, x, y);
      break;
    case 'S':				/* SF - Scroll forward */
      n = con.args[0] ?: 1;
      scroll_buffer_screen (0, n, -1, -1, 0, 0);
      break;
    case 'T':				/* SR - Scroll down */
      con.fillin (get_output_handle ());
      n = con.b.srWindow.Top + con.args[0] ?: 1;
      scroll_buffer_screen (0, 0, -1, -1, 0, n);
      break;
    case 'X':				/* ec - erase chars */
      n = con.args[0] ?: 1;
      cursor_get (&x, &y);
      scroll_buffer (x + n, y, -1, y, x, y);
      scroll_buffer (x, y, -1, y, x + n, y);
      break;
    case 'Z':				/* Back tab */
      cursor_get (&x, &y);
      cursor_set (false, ((8 * (x / 8 + 1)) - 8), y);
      break;
    case 'b':				/* Repeat char #1 #2 times */
      if (con.insert_mode)
	{
	  cursor_get (&x, &y);
	  scroll_buffer (x, y, -1, y, x + con.args[1], y);
	}
      while (con.args[1]--)
	WriteFile (get_output_handle (), &con.args[0], 1, (DWORD *) &x, 0);
      break;
    case 'c':				/* u9 - Terminal enquire string */
      if (con.saw_greater_than_sign)
	/* Generate Secondary Device Attribute report, using 67 = ASCII 'C'
	   to indicate Cygwin (convention used by Rxvt, Urxvt, Screen, Mintty),
	   and cygwin version for terminal version. */
	__small_sprintf (buf, "\033[>67;%d%02d;0c", CYGWIN_VERSION_DLL_MAJOR, CYGWIN_VERSION_DLL_MINOR);
      else
	strcpy (buf, "\033[?6c");
      /* The generated report needs to be injected for read-ahead into the
	 fhandler_console object associated with standard input.
	 The current call does not work. */
      puts_readahead (buf);
      break;
    case 'n':
      switch (con.args[0])
	{
	case 6:				/* u7 - Cursor position request */
	  cursor_get (&x, &y);
	  y -= con.b.srWindow.Top;
	  /* x -= con.b.srWindow.Left;		// not available yet */
	  __small_sprintf (buf, "\033[%d;%dR", y + 1, x + 1);
	  puts_readahead (buf);
	  break;
      default:
	  goto bad_escape;
	}
      break;
    case 'r':				/* Set Scroll region */
      con.scroll_region.Top = con.args[0] ? con.args[0] - 1 : 0;
      con.scroll_region.Bottom = con.args[1] ? con.args[1] - 1 : -1;
      cursor_set (true, 0, 0);
      break;
    case 'g':				/* TAB set/clear */
      break;
    default:
bad_escape:
      break;
    }
}

/* This gets called when we found an invalid input character.  We just
   print a half filled square (UTF 0x2592).  We have no chance to figure
   out the "meaning" of the input char anyway. */
inline void
fhandler_console::write_replacement_char ()
{
  static const wchar_t replacement_char = 0x2592; /* Half filled square */
  DWORD done;
  WriteConsoleW (get_output_handle (), &replacement_char, 1, &done, 0);
}

const unsigned char *
fhandler_console::write_normal (const unsigned char *src,
				const unsigned char *end)
{
  /* Scan forward to see what a char which needs special treatment */
  DWORD done;
  DWORD buf_len;
  const unsigned char *found = src;
  size_t ret;
  mbstate_t ps;
  UINT cp = con.get_console_cp ();
  const char *charset;
  mbtowc_p f_mbtowc;

  if (cp)
    {
      /* The alternate charset is always 437, just as in the Linux console. */
      f_mbtowc = __cp_mbtowc;
      charset = "CP437";
    }
  else
    {
      f_mbtowc = cygheap->locale.mbtowc;
      charset = cygheap->locale.charset;
    }

  /* First check if we have cached lead bytes of a former try to write
     a truncated multibyte sequence.  If so, process it. */
  if (trunc_buf.len)
    {
      const unsigned char *nfound;
      int cp_len = MIN (end - src, 4 - trunc_buf.len);
      memcpy (trunc_buf.buf + trunc_buf.len, src, cp_len);
      memset (&ps, 0, sizeof ps);
      switch (ret = f_mbtowc (_REENT, NULL, (const char *) trunc_buf.buf,
			       trunc_buf.len + cp_len, charset, &ps))
	{
	case -2:
	  /* Still truncated multibyte sequence?  Keep in trunc_buf. */
	  trunc_buf.len += cp_len;
	  return end;
	case -1:
	  /* Give up, print replacement chars for trunc_buf... */
	  for (int i = 0; i < trunc_buf.len; ++i)
	    write_replacement_char ();
	  /* ... mark trunc_buf as unused... */
	  trunc_buf.len = 0;
	  /* ... and proceed. */
	  nfound = NULL;
	  break;
	case 0:
	  nfound = trunc_buf.buf + 1;
	  break;
	default:
	  nfound = trunc_buf.buf + ret;
	  break;
	}
      /* Valid multibyte sequence?  Process. */
      if (nfound)
	{
	  buf_len = con.str_to_con (f_mbtowc, charset, write_buf,
					   (const char *) trunc_buf.buf,
					   nfound - trunc_buf.buf);
	  if (!write_console (write_buf, buf_len, done))
	    {
	      debug_printf ("multibyte sequence write failed, handle %p", get_output_handle ());
	      return 0;
	    }
	  found = src + (nfound - trunc_buf.buf - trunc_buf.len);
	  trunc_buf.len = 0;
	  return found;
	}
    }

  /* Loop over src buffer as long as we have just simple characters.  Stop
     as soon as we reach the conversion limit, or if we encounter a control
     character or a truncated or invalid mutibyte sequence. */
  memset (&ps, 0, sizeof ps);
  while (found < end
	 && found - src < CONVERT_LIMIT
	 && base_chars[*found] == NOR)
    {
      switch (ret = f_mbtowc (_REENT, NULL, (const char *) found,
			       end - found, charset, &ps))
	{
	case -2: /* Truncated multibyte sequence.  Store for next write. */
	  trunc_buf.len = end - found;
	  memcpy (trunc_buf.buf, found, trunc_buf.len);
	  goto do_print;
	case -1: /* Invalid multibyte sequence. Handled below. */
	  goto do_print;
	case 0:
	  found++;
	  break;
	default:
	  found += ret;
	  break;
	}
    }

do_print:

  /* Print all the base characters out */
  if (found != src)
    {
      DWORD len = found - src;
      buf_len = con.str_to_con (f_mbtowc, charset, write_buf,
				       (const char *) src, len);
      if (!buf_len)
	{
	  debug_printf ("conversion error, handle %p",
			get_output_handle ());
	  __seterrno ();
	  return 0;
	}

      if (con.insert_mode)
	{
	  int x, y;
	  cursor_get (&x, &y);
	  scroll_buffer (x, y, -1, y, x + buf_len, y);
	}

      if (!write_console (write_buf, buf_len, done))
	{
	  debug_printf ("write failed, handle %p", get_output_handle ());
	  return 0;
	}
      /* Stop here if we reached the conversion limit. */
      if (len >= CONVERT_LIMIT)
	return found + trunc_buf.len;
    }
  /* If there's still something in the src buffer, but it's not a truncated
     multibyte sequence, then we stumbled over a control character or an
     invalid multibyte sequence.  Print it. */
  if (found < end && trunc_buf.len == 0)
    {
      int x, y;
      switch (base_chars[*found])
	{
	case SO:	/* Shift Out: Invoke G1 character set (ISO 2022) */
	  con.iso_2022_G1 = true;
	  break;
	case SI:	/* Shift In: Invoke G0 character set (ISO 2022) */
	  con.iso_2022_G1 = false;
	  break;
	case BEL:
	  beep ();
	  break;
	case ESC:
	  con.state = gotesc;
	  break;
	case DWN:
	  cursor_get (&x, &y);
	  if (y >= srBottom)
	    {
	      if (y >= con.b.srWindow.Bottom && !con.scroll_region.Top)
		WriteConsoleW (get_output_handle (), L"\n", 1, &done, 0);
	      else
		{
		  scroll_buffer (0, srTop + 1, -1, srBottom, 0, srTop);
		  y--;
		}
	    }
	  cursor_set (false, ((get_ttyp ()->ti.c_oflag & ONLCR) ? 0 : x), y + 1);
	  break;
	case BAK:
	  cursor_rel (-1, 0);
	  break;
	case IGN:
	  cursor_rel (1, 0);
	  break;
	case CR:
	  cursor_get (&x, &y);
	  cursor_set (false, 0, y);
	  break;
	case ERR:
	  /* Don't print chars marked as ERR chars, except for a ASCII CAN
	     sequence which is printed as singlebyte chars from the UTF
	     Basic Latin and Latin 1 Supplement plains. */
	  if (*found == 0x18)
	    {
	      write_replacement_char ();
	      if (found + 1 < end)
		{
		  ret = __utf8_mbtowc (_REENT, NULL, (const char *) found + 1,
				       end - found - 1, NULL, &ps);
		  if (ret != (size_t) -1)
		    while (ret-- > 0)
		      {
			WCHAR w = *(found + 1);
			WriteConsoleW (get_output_handle (), &w, 1, &done, 0);
			found++;
		      }
		}
	    }
	  break;
	case TAB:
	  cursor_get (&x, &y);
	  cursor_set (false, 8 * (x / 8 + 1), y);
	  break;
	case NOR:
	  write_replacement_char ();
	  break;
	}
      found++;
    }
  return found + trunc_buf.len;
}

ssize_t __stdcall
fhandler_console::write (const void *vsrc, size_t len)
{
  bg_check_types bg = bg_check (SIGTTOU);
  if (bg <= bg_eof)
    return (ssize_t) bg;

  push_process_state process_state (PID_TTYOU);

  /* Run and check for ansi sequences */
  unsigned const char *src = (unsigned char *) vsrc;
  unsigned const char *end = src + len;
  /* This might look a bit far fetched, but using the TLS path buffer allows
     to allocate a big buffer without using the stack too much.  Doing it here
     in write instead of in write_normal should be faster, too. */
  tmp_pathbuf tp;
  write_buf = tp.w_get ();

  debug_printf ("%p, %ld", vsrc, len);

  while (src < end)
    {
      paranoid_printf ("char %0c state is %d", *src, con.state);
      switch (con.state)
	{
	case normal:
	  src = write_normal (src, end);
	  if (!src) /* write_normal failed */
	    return -1;
	  break;
	case gotesc:
	  if (*src == '[')		/* CSI Control Sequence Introducer */
	    {
	      con.state = gotsquare;
	      con.saw_question_mark = false;
	      con.saw_greater_than_sign = false;
	      con.saw_space = false;
	      for (con.nargs = 0; con.nargs < MAXARGS; con.nargs++)
		con.args[con.nargs] = 0;
	      con.nargs = 0;
	    }
	  else if (*src == ']')		/* OSC Operating System Command */
	    {
	      con.rarg = 0;
	      con.my_title_buf[0] = '\0';
	      con.state = gotrsquare;
	    }
	  else if (*src == '(')		/* Designate G0 character set */
	    {
	      con.state = gotparen;
	    }
	  else if (*src == ')')		/* Designate G1 character set */
	    {
	      con.state = gotrparen;
	    }
	  else if (*src == 'M')		/* Reverse Index (scroll down) */
	    {
	      con.fillin (get_output_handle ());
	      scroll_buffer_screen (0, 0, -1, -1, 0, 1);
	      con.state = normal;
	    }
	  else if (*src == 'c')		/* RIS Full Reset */
	    {
	      con.set_default_attr ();
	      con.vt100_graphics_mode_G0 = false;
	      con.vt100_graphics_mode_G1 = false;
	      con.iso_2022_G1 = false;
	      cursor_set (false, 0, 0);
	      clear_screen (cl_buf_beg, cl_buf_beg, cl_buf_end, cl_buf_end);
	      con.state = normal;
	    }
	  else if (*src == '8')		/* DECRC Restore cursor position */
	    {
	      cursor_set (false, con.savex, con.savey);
	      con.state = normal;
	    }
	  else if (*src == '7')		/* DECSC Save cursor position */
	    {
	      cursor_get (&con.savex, &con.savey);
	      con.state = normal;
	    }
	  else if (*src == 'R')		/* ? */
	      con.state = normal;
	  else
	    {
	      con.state = normal;
	    }
	  src++;
	  break;
	case gotarg1:
	  if (isdigit (*src))
	    {
	      con.args[con.nargs] = con.args[con.nargs] * 10 + *src - '0';
	      src++;
	    }
	  else if (*src == ';')
	    {
	      src++;
	      con.nargs++;
	      if (con.nargs >= MAXARGS)
		con.nargs--;
	    }
	  else if (*src == ' ')
	    {
	      src++;
	      con.saw_space = true;
	      con.state = gotcommand;
	    }
	  else
	    con.state = gotcommand;
	  break;
	case gotcommand:
	  char_command (*src++);
	  con.state = normal;
	  break;
	case gotrsquare:
	  if (isdigit (*src))
	    con.rarg = con.rarg * 10 + (*src - '0');
	  else if (*src == ';' && (con.rarg == 2 || con.rarg == 0))
	    con.state = gettitle;
	  else
	    con.state = eattitle;
	  src++;
	  break;
	case eattitle:
	case gettitle:
	  {
	    int n = strlen (con.my_title_buf);
	    if (*src < ' ')
	      {
		if (*src == '\007' && con.state == gettitle)
		  set_console_title (con.my_title_buf);
		con.state = normal;
	      }
	    else if (n < TITLESIZE)
	      {
		con.my_title_buf[n++] = *src;
		con.my_title_buf[n] = '\0';
	      }
	    src++;
	    break;
	  }
	case gotsquare:
	  if (*src == ';')
	    {
	      con.state = gotarg1;
	      con.nargs++;
	      src++;
	    }
	  else if (isalpha (*src))
	    con.state = gotcommand;
	  else if (*src != '@@' && !isalpha (*src) && !isdigit (*src))
	    {
	      if (*src == '?')
		con.saw_question_mark = true;
	      else if (*src == '>')
		con.saw_greater_than_sign = true;
	      /* ignore any extra chars between [ and first arg or command */
	      src++;
	    }
	  else
	    con.state = gotarg1;
	  break;
	case gotparen:	/* Designate G0 Character Set (ISO 2022) */
	  if (*src == '0')
	    con.vt100_graphics_mode_G0 = true;
	  else
	    con.vt100_graphics_mode_G0 = false;
	  con.state = normal;
	  src++;
	  break;
	case gotrparen:	/* Designate G1 Character Set (ISO 2022) */
	  if (*src == '0')
	    con.vt100_graphics_mode_G1 = true;
	  else
	    con.vt100_graphics_mode_G1 = false;
	  con.state = normal;
	  src++;
	  break;
	}
    }

  syscall_printf ("%ld = fhandler_console::write(...)", len);

  return len;
}

static const struct {
  int vk;
  const char *val[4];
} keytable[] = {
	       /* NORMAL */    /* SHIFT */     /* CTRL */     /* CTRL-SHIFT */
  /* Unmodified and Alt-modified keypad keys comply with linux console
     SHIFT, CTRL, CTRL-SHIFT modifiers comply with xterm modifier usage */
  {VK_NUMPAD5,	{"\033[G",	"\033[1;2G",	"\033[1;5G",	"\033[1;6G"}},
  {VK_CLEAR,	{"\033[G",	"\033[1;2G",	"\033[1;5G",	"\033[1;6G"}},
  {VK_LEFT,	{"\033[D",	"\033[1;2D",	"\033[1;5D",	"\033[1;6D"}},
  {VK_RIGHT,	{"\033[C",	"\033[1;2C",	"\033[1;5C",	"\033[1;6C"}},
  {VK_UP,	{"\033[A",	"\033[1;2A",	"\033[1;5A",	"\033[1;6A"}},
  {VK_DOWN,	{"\033[B",	"\033[1;2B",	"\033[1;5B",	"\033[1;6B"}},
  {VK_PRIOR,	{"\033[5~",	"\033[5;2~",	"\033[5;5~",	"\033[5;6~"}},
  {VK_NEXT,	{"\033[6~",	"\033[6;2~",	"\033[6;5~",	"\033[6;6~"}},
  {VK_HOME,	{"\033[1~",	"\033[1;2~",	"\033[1;5~",	"\033[1;6~"}},
  {VK_END,	{"\033[4~",	"\033[4;2~",	"\033[4;5~",	"\033[4;6~"}},
  {VK_INSERT,	{"\033[2~",	"\033[2;2~",	"\033[2;5~",	"\033[2;6~"}},
  {VK_DELETE,	{"\033[3~",	"\033[3;2~",	"\033[3;5~",	"\033[3;6~"}},
  /* F1...F12, SHIFT-F1...SHIFT-F10 comply with linux console
     F6...F12, and all modified F-keys comply with rxvt (compatible extension) */
  {VK_F1,	{"\033[[A",	"\033[23~",	"\033[11^",	"\033[23^"}},
  {VK_F2,	{"\033[[B",	"\033[24~",	"\033[12^",	"\033[24^"}},
  {VK_F3,	{"\033[[C",	"\033[25~",	"\033[13^",	"\033[25^"}},
  {VK_F4,	{"\033[[D",	"\033[26~",	"\033[14^",	"\033[26^"}},
  {VK_F5,	{"\033[[E",	"\033[28~",	"\033[15^",	"\033[28^"}},
  {VK_F6,	{"\033[17~",	"\033[29~",	"\033[17^",	"\033[29^"}},
  {VK_F7,	{"\033[18~",	"\033[31~",	"\033[18^",	"\033[31^"}},
  {VK_F8,	{"\033[19~",	"\033[32~",	"\033[19^",	"\033[32^"}},
  {VK_F9,	{"\033[20~",	"\033[33~",	"\033[20^",	"\033[33^"}},
  {VK_F10,	{"\033[21~",	"\033[34~",	"\033[21^",	"\033[34^"}},
  {VK_F11,	{"\033[23~",	"\033[23$",	"\033[23^",	"\033[23@@"}},
  {VK_F12,	{"\033[24~",	"\033[24$",	"\033[24^",	"\033[24@@"}},
  /* CTRL-6 complies with Windows cmd console but should be fixed */
  {'6',		{NULL,		NULL,		"\036",		NULL}},
  /* Table end marker */
  {0}
};

const char *
get_nonascii_key (INPUT_RECORD& input_rec, char *tmp)
{
#define NORMAL  0
#define SHIFT	1
#define CONTROL	2
/*#define CONTROLSHIFT	3*/

  int modifier_index = NORMAL;
  if (input_rec.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED)
    modifier_index = SHIFT;
  if (input_rec.Event.KeyEvent.dwControlKeyState & CTRL_PRESSED)
    modifier_index += CONTROL;

  for (int i = 0; keytable[i].vk; i++)
    if (input_rec.Event.KeyEvent.wVirtualKeyCode == keytable[i].vk)
      {
	if ((input_rec.Event.KeyEvent.dwControlKeyState & ALT_PRESSED)
	    && keytable[i].val[modifier_index] != NULL)
	  { /* Generic ESC prefixing if Alt is pressed */
	    tmp[0] = '\033';
	    strcpy (tmp + 1, keytable[i].val[modifier_index]);
	    return tmp;
	  }
	else
	  return keytable[i].val[modifier_index];
      }

  if (input_rec.Event.KeyEvent.uChar.AsciiChar)
    {
      tmp[0] = input_rec.Event.KeyEvent.uChar.AsciiChar;
      tmp[1] = '\0';
      return tmp;
    }
  return NULL;
}

int
fhandler_console::init (HANDLE h, DWORD a, mode_t bin)
{
  // this->fhandler_termios::init (h, mode, bin);
  /* Ensure both input and output console handles are open */
  int flags = 0;

  a &= GENERIC_READ | GENERIC_WRITE;
  if (a == GENERIC_READ)
    flags = O_RDONLY;
  if (a == GENERIC_WRITE)
    flags = O_WRONLY;
  if (a == (GENERIC_READ | GENERIC_WRITE))
    flags = O_RDWR;
  open_with_arch (flags | O_BINARY | (h ? 0 : O_NOCTTY));

  return !tcsetattr (0, &get_ttyp ()->ti);
}

int
fhandler_console::igncr_enabled ()
{
  return get_ttyp ()->ti.c_iflag & IGNCR;
}

void
fhandler_console::set_close_on_exec (bool val)
{
  close_on_exec (val);
}

void __stdcall
set_console_title (char *title)
{
  wchar_t buf[TITLESIZE + 1];
  sys_mbstowcs (buf, TITLESIZE + 1, title);
  lock_ttys here (15000);
  SetConsoleTitleW (buf);
  debug_printf ("title '%W'", buf);
}

void
fhandler_console::fixup_after_fork_exec (bool execing)
{
  set_unit ();
}

// #define WINSTA_ACCESS (WINSTA_READATTRIBUTES | STANDARD_RIGHTS_READ | STANDARD_RIGHTS_WRITE | WINSTA_CREATEDESKTOP | WINSTA_EXITWINDOWS)
#define WINSTA_ACCESS WINSTA_ALL_ACCESS

/* Create a console in an invisible window station.  This should work
   in all versions of Windows NT except Windows 7 (so far). */
bool
fhandler_console::create_invisible_console (HWINSTA horig)
{
  HWINSTA h = CreateWindowStationW (NULL, 0, WINSTA_ACCESS, NULL);
  termios_printf ("%p = CreateWindowStation(NULL), %E", h);
  BOOL b;
  if (h)
    {
      b = SetProcessWindowStation (h);
      termios_printf ("SetProcessWindowStation %d, %E", b);
    }
  b = AllocConsole ();	/* will cause flashing if CreateWindowStation
			   failed */
  if (!h)
    SetParent (GetConsoleWindow (), HWND_MESSAGE);
  if (horig && h && h != horig && SetProcessWindowStation (horig))
    CloseWindowStation (h);
  termios_printf ("%d = AllocConsole (), %E", b);
  invisible_console = true;
  return b;
}

/* Ugly workaround for Windows 7 and later.

   First try to just attach to any console which may have started this
   app.  If that works use this as our "invisible console".

   This will fail if not started from the command prompt.  In that case, start
   a dummy console application in a hidden state so that we can use its console
   as our invisible console.  This probably works everywhere but process
   creation is slow and to be avoided if possible so the window station method
   is vastly preferred.

   FIXME: This is not completely thread-safe since it creates two inheritable
   handles which are known only to this function.  If another thread starts
   a process the new process will inherit these handles.  However, since this
   function is currently only called at startup and during exec, it shouldn't
   be a big deal.  */
bool
fhandler_console::create_invisible_console_workaround ()
{
  if (!AttachConsole (-1))
    {
      bool taskbar;
      DWORD err = GetLastError ();
      path_conv helper ("/bin/cygwin-console-helper.exe");
      HANDLE hello = NULL;
      HANDLE goodbye = NULL;
      /* If err == ERROR_PROC_FOUND then this method won't work.  But that's
	 ok.  The window station method should work ok when AttachConsole doesn't
	 work.

	 If the helper doesn't exist or we can't create event handles then we
	 can't use this method. */
      if (err == ERROR_PROC_NOT_FOUND || !helper.exists ()
	  || !(hello = CreateEvent (&sec_none, true, false, NULL))
	  || !(goodbye = CreateEvent (&sec_none, true, false, NULL)))
	{
	  AllocConsole ();	/* This is just sanity check code.  We should
				   never actually hit here unless we're running
				   in an environment which lacks the helper
				   app. */
	  taskbar = true;
	}
      else
	{
	  STARTUPINFOW si = {};
	  PROCESS_INFORMATION pi;
	  size_t len = helper.get_wide_win32_path_len ();
	  WCHAR cmd[len + (2 * strlen (" 0xffffffff")) + 1];
	  WCHAR title[] = L"invisible cygwin console";

	  helper.get_wide_win32_path (cmd);
	  __small_swprintf (cmd + len, L" %p %p", hello, goodbye);

	  si.cb = sizeof (si);
	  si.dwFlags = STARTF_USESHOWWINDOW;
	  si.wShowWindow = SW_HIDE;
	  si.lpTitle = title;

	  /* Create a new hidden process.  Use the two event handles as
	     argv[1] and argv[2]. */
	  BOOL x = CreateProcessW (NULL, cmd, &sec_none_nih, &sec_none_nih, true,
				   CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
	  if (x)
	    {
	      CloseHandle (pi.hProcess);	/* Don't need */
	      CloseHandle (pi.hThread);		/*  these.    */
	    }
	  taskbar = false;
	  /* Wait for subprocess to indicate that it is live.  This may not
	     actually be needed but it's hard to say since it is possible that
	     there will be no console for a brief time after the process
	     returns and there is no easy way to determine if/when this happens
	     in Windows.  So play it safe. */
	  if (!x || (WaitForSingleObject (hello, 10000) != WAIT_OBJECT_0)
	      || !AttachConsole (pi.dwProcessId))
	    AllocConsole ();	/* Oh well.  Watch the flash. */
	}

      if (!taskbar)
	/* Setting the owner of the console window to HWND_MESSAGE seems to
	   hide it from the taskbar.  Don't know if this method is faster than
	   calling ShowWindowAsync but it should guarantee no taskbar presence
	   for the hidden console. */
	SetParent (GetConsoleWindow (), HWND_MESSAGE);
      if (hello)
	CloseHandle (hello);
      if (goodbye)
	{
	  SetEvent (goodbye);	/* Tell helper process it's ok to exit. */
	  CloseHandle (goodbye);
	}
    }
  return invisible_console = true;
}

void
fhandler_console::free_console ()
{
  BOOL res = FreeConsole ();
  debug_printf ("freed console, res %d", res);
  init_console_handler (false);
}

bool
fhandler_console::need_invisible ()
{
  BOOL b = false;
  if (exists ())
    invisible_console = false;
  else
    {
      HWINSTA h;
      /* The intent here is to allocate an "invisible" console if we have no
	 controlling tty or to reuse the existing console if we already have
	 a tty.  So, first get the old window station.  If there is no controlling
	 terminal, create a new window station and then set it as the current
	 window station.  The subsequent AllocConsole will then be allocated
	 invisibly.  But, after doing that we have to restore any existing windows
	 station or, strangely, characters will not be displayed in any windows
	 drawn on the current screen.  We only do this if we have changed to
	 a new window station and if we had an existing windows station previously.
	 We also close the previously opened window station even though AllocConsole
	 is now "using" it.  This doesn't seem to cause any problems.

	 Things to watch out for if you make changes in this code:

	 - Flashing, black consoles showing up when you start, e.g., ssh in
	   an xterm.
	 - Non-displaying of characters in rxvt or xemacs if you start a
	   process using setsid: bash -lc "setsid rxvt".  */

      h = GetProcessWindowStation ();

      USEROBJECTFLAGS oi;
      DWORD len;
      if (!h
	  || !GetUserObjectInformationW (h, UOI_FLAGS, &oi, sizeof (oi), &len)
	  || !(oi.dwFlags & WSF_VISIBLE))
	{
	  b = true;
	  debug_printf ("window station is not visible");
	  AllocConsole ();
	  invisible_console = true;
	}
      else if (wincap.has_broken_alloc_console ())
	b = create_invisible_console_workaround ();
      else
	b = create_invisible_console (h);
    }

  debug_printf ("invisible_console %d", invisible_console);
  return b;
}
@


1.295
log
@* DevNotes: Add entry cgf-000026.
* fhandler.h (fhandler_console::save_top): Save top of screen coordinates.
* fhandler_console.cc (dev::save_restore): Record top of screen coordinates.
Clear entire buffer when restoring saved buffer and try to position the cursor
on the save relative place on the screen.
@
text
@d87 1
d1461 1
a1461 1
      if ((save_bufsize.Y = dwEnd.Y + 2) > b.dwSize.Y)
d1504 1
d1682 1
a1682 1
	    GetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
d1689 1
a1689 1
		  SetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
d1694 1
a1694 1
		  SetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
d1698 1
a1698 1
		  SetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
@


1.294
log
@* fhandler.h (dev_console::b): Redefine as CONSOLE_SCREEN_BUFFER_INFO for use
with older OS.
* fhandler_console.cc (dev_console::fillin): Ditto for
GetConsoleScreenBufferInfo.
@
text
@d1469 1
d1493 1
d1501 5
d1508 1
a1508 1
	debug_printf ("SetConsoleCursorInfo(%p, ...) failed during restore, %E", h);
@


1.293
log
@* fhandler_console.cc (dev_console::save_restore): Save entire line of current
cursor position.
@
text
@d736 1
a736 2
  b.cbSize = sizeof (b);
  if ((ret = GetConsoleScreenBufferInfoEx (h, &b)))
@


1.292
log
@* fhandler_console.cc (fhandler_console::save_restore): Save only until last
written row and, because of this, don't bother trying to restore the screen
buffer size.  Set cursor position after refilling buffer.
(fhandler_console::write): Use absolute paths when saving/restoring cursor
position or suffer odd problems after a saved screen is restored.
@
text
@a1459 1
      save_bufsize.Y = dwEnd.Y + 1;		/* Assume starting from 0/0 */
d1461 2
@


1.291
log
@* fhandler.h (fhandler_console::dwBufferSize): Delete.
(fhandler_console::dwCursorPosition): Ditto.
(fhandler_console::wAttributes): Ditto.
(fhandler_console::b): New field encompassing previously disparate screen
buffer info.
(fhandler_console::save_bufsize): Rename from savebufsiz
(fhandler_console::save_buf): Rename sfrom savebuf.
(fhandler_console::save_cursor): New field.
(fhandler_console::save_restore): New function.
(fhandler_console::con): Rename from dev_state.
(fhandler_console::focus_aware): Accommodate name change.
* fhandler_console.cc: Use 'b' field of dev_console throughout instead of
disparate names.  Accommodate dev_state -> con rename.
(dev_state:save_restore): New function.  Attempt to save the entire screen
buffer rather than just the visible part.  Clear the buffer when saving, like
Linux.
(fhandler_console::char_command): Use con.save_restore() for Save/restore
screen sequence.
@
text
@d1460 2
a1461 1
      save_bufsize = b.dwSize;		/* Assume starting from 0/0 */
d1471 2
a1472 2
      now.Bottom = b.dwSize.Y - 1;
      now.Right = b.dwSize.X - 1;
a1486 11
      /* Restore original buffer size, just in case.  */
      if (!SetConsoleScreenBufferSize (h, save_bufsize))
	debug_printf ("SetConsoleScreenBufferSize(h, ...) failed during restore, %E", h);

      /* Position where we were previously */
      if (!SetConsoleCursorPosition (h, save_cursor))
	debug_printf ("SetConsoleCursorInfo(%p, ...) failed during restore, %E", h);

      /* Get back correct version of buffer information */
      dwEnd.X = dwEnd.Y = 0;
      fillin (h);
d1489 2
a1490 2
      now.Bottom = b.dwSize.Y - 1;
      now.Right = b.dwSize.X - 1;
d1498 7
d2218 1
a2218 1
	      cursor_set (true, con.savex, con.savey);
a2223 1
	      con.savey -= con.b.srWindow.Top;
@


1.290
log
@* fhandler_console.cc (fhandler_console::char_command): Properly use calculated
value rather than directly using dev_state.args[0].
@
text
@d45 3
a47 3
#define dev_state (shared_console_info->dev_state)
#define srTop (dev_state.winTop + dev_state.scroll_region.Top)
#define srBottom ((dev_state.scroll_region.Bottom < 0) ? dev_state.winBottom : dev_state.winTop + dev_state.scroll_region.Bottom)
d175 10
a184 10
	dev_state.scroll_region.Bottom = -1;
	dev_state.dwLastCursorPosition.X = -1;
	dev_state.dwLastCursorPosition.Y = -1;
	dev_state.dwLastMousePosition.X = -1;
	dev_state.dwLastMousePosition.Y = -1;
	dev_state.dwLastButtonState = 0;	/* none pressed */
	dev_state.last_button_code = 3;	/* released */
	dev_state.underline_color = FOREGROUND_GREEN | FOREGROUND_BLUE;
	dev_state.dim_color = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
	dev_state.meta_mask = LEFT_ALT_PRESSED;
d195 3
a197 3
	  dev_state.meta_mask |= RIGHT_ALT_PRESSED;
	dev_state.set_default_attr ();
	dev_state.backspace_keycode = CERASE;
d241 3
a243 3
  bool old_mode = dev_state.raw_win32_keyboard_mode;
  dev_state.raw_win32_keyboard_mode = new_mode;
  syscall_printf ("raw keyboard mode %sabled", dev_state.raw_win32_keyboard_mode ? "en" : "dis");
d250 3
a252 7
  CONSOLE_SCREEN_BUFFER_INFO now;

  if (!GetConsoleScreenBufferInfo (get_output_handle (), &now))
    return;

  if (dev_state.dwLastCursorPosition.X != now.dwCursorPosition.X ||
      dev_state.dwLastCursorPosition.Y != now.dwCursorPosition.Y)
d254 2
a255 2
      SetConsoleCursorPosition (get_output_handle (), now.dwCursorPosition);
      dev_state.dwLastCursorPosition = now.dwCursorPosition;
d262 3
a264 3
  SHORT y = dev_state.dwWinSize.Y;
  SHORT x = dev_state.dwWinSize.X;
  dev_state.fillin (get_output_handle ());
d266 1
a266 1
  if (y != dev_state.dwWinSize.Y || x != dev_state.dwWinSize.X)
d268 2
a269 2
      dev_state.scroll_region.Top = 0;
      dev_state.scroll_region.Bottom = -1;
d278 1
a278 1
  if (!dev_state.use_mouse)
d288 2
a289 2
  dev_state.dwMousePosition.X = mouse_event.dwMousePosition.X - now.srWindow.Left;
  dev_state.dwMousePosition.Y = mouse_event.dwMousePosition.Y - now.srWindow.Top;
d292 1
a292 1
	  && mouse_event.dwButtonState != dev_state.dwLastButtonState)
d295 4
a298 4
	     && (dev_state.dwMousePosition.X != dev_state.dwLastMousePosition.X
		 || dev_state.dwMousePosition.Y != dev_state.dwLastMousePosition.Y)
	     && ((dev_state.use_mouse >= 2 && mouse_event.dwButtonState)
		 || dev_state.use_mouse >= 3));
d370 1
a370 1
	  dev_state.nModifiers = 0;
d379 1
a379 1
	      set_raw_win32_keyboard_mode (!dev_state.raw_win32_keyboard_mode);
d384 1
a384 1
	  if (dev_state.raw_win32_keyboard_mode)
d417 1
a417 1
	    dev_state.nModifiers |= 1;
d419 1
a419 1
	    dev_state.nModifiers |= 2;
d421 1
a421 1
	    dev_state.nModifiers |= 4;
d423 1
a423 1
	    dev_state.nModifiers |= 8;
d428 1
a428 1
	      char c = dev_state.backspace_keycode;
d432 1
a432 1
		  if (dev_state.metabit)
d453 1
a453 1
		  dev_state.nModifiers = 0;
d460 1
a460 1
	      nread = dev_state.con_to_str (tmp + 1, 59, wch);
d484 1
a484 1
	      else if (dev_state.metabit)
d495 1
a495 1
		  dev_state.nModifiers &= ~4;
d549 1
a549 1
			b = dev_state.last_button_code;
d551 1
a551 1
		    else if (mouse_event.dwButtonState < dev_state.dwLastButtonState && !dev_state.ext_mouse_mode6)
d556 1
a556 1
		    else if ((mouse_event.dwButtonState & 1) != (dev_state.dwLastButtonState & 1))
d561 1
a561 1
		    else if ((mouse_event.dwButtonState & 2) != (dev_state.dwLastButtonState & 2))
d566 1
a566 1
		    else if ((mouse_event.dwButtonState & 4) != (dev_state.dwLastButtonState & 4))
d572 2
a573 2
		    if (dev_state.ext_mouse_mode6 /* distinguish release */
			&& mouse_event.dwButtonState < dev_state.dwLastButtonState)
d576 1
a576 1
		    dev_state.last_button_code = b;
d586 1
a586 1
			dev_state.dwLastButtonState = mouse_event.dwButtonState;
d591 2
a592 2
		dev_state.dwLastMousePosition.X = dev_state.dwMousePosition.X;
		dev_state.dwLastMousePosition.Y = dev_state.dwMousePosition.Y;
d595 1
a595 1
		dev_state.nModifiers = 0;
d597 1
a597 1
		    dev_state.nModifiers |= 0x4;
d599 1
a599 1
		    dev_state.nModifiers |= 0x8;
d601 1
a601 1
		    dev_state.nModifiers |= 0x10;
d604 1
a604 1
		b |= dev_state.nModifiers;
d607 1
a607 1
		if (dev_state.ext_mouse_mode6)
d610 2
a611 2
				     dev_state.dwMousePosition.X + 1,
				     dev_state.dwMousePosition.Y + 1,
d615 1
a615 1
		else if (dev_state.ext_mouse_mode15)
d618 2
a619 2
				     dev_state.dwMousePosition.X + 1,
				     dev_state.dwMousePosition.Y + 1);
d622 1
a622 1
		else if (dev_state.ext_mouse_mode5)
d624 2
a625 2
		    unsigned int xcode = dev_state.dwMousePosition.X + ' ' + 1;
		    unsigned int ycode = dev_state.dwMousePosition.Y + ' ' + 1;
d652 2
a653 2
		    unsigned int xcode = dev_state.dwMousePosition.X + ' ' + 1;
		    unsigned int ycode = dev_state.dwMousePosition.Y + ' ' + 1;
d663 2
a664 2
				dev_state.dwMousePosition.X,
				dev_state.dwMousePosition.Y);
d672 1
a672 1
	  if (dev_state.use_focus)
a734 1
  CONSOLE_SCREEN_BUFFER_INFO linfo;
d736 2
a737 1
  if ((ret = GetConsoleScreenBufferInfo (h, &linfo)))
d739 3
a741 5
      winTop = linfo.srWindow.Top;
      winBottom = linfo.srWindow.Bottom;
      dwWinSize.Y = 1 + linfo.srWindow.Bottom - linfo.srWindow.Top;
      dwWinSize.X = 1 + linfo.srWindow.Right - linfo.srWindow.Left;
      if (dwBufferSize.Y != linfo.dwSize.Y || dwBufferSize.X != linfo.dwSize.X)
d743 3
a745 6
      dwBufferSize = linfo.dwSize;
      dwCursorPosition = linfo.dwCursorPosition;
      if (dwCursorPosition.Y > dwEnd.Y
	  || (dwCursorPosition.Y >= dwEnd.Y && dwCursorPosition.X > dwEnd.X))
	dwEnd = dwCursorPosition;
      wAttributes = linfo.wAttributes;
d749 1
d752 2
a753 1
      winBottom = 24;
d776 1
a776 1
  sr1.Top = y1 >= 0 ? y1 : winBottom;
d778 2
a779 2
  sr1.Bottom = y2 >= 0 ? y2 : winBottom;
  sr2.Top = winTop + scroll_region.Top;
d781 1
a781 1
  sr2.Bottom = (scroll_region.Bottom < 0) ? winBottom : winTop + scroll_region.Bottom;
d786 1
a786 1
  dest.Y = yn >= 0 ? yn : winBottom;
d793 1
a793 1
  dev_state.scroll_buffer (get_output_handle (), x1, y1, x2, y2, xn, yn);
d800 1
a800 1
    y1 += dev_state.winTop;
d802 1
a802 1
    y1 += dev_state.winTop;
d804 2
a805 2
    yn += dev_state.winTop;
  dev_state.scroll_buffer (get_output_handle (), x1, y1, x2, y2, xn, yn);
d856 1
a856 1
  if (dev_state.fillin (get_output_handle ()))
d858 4
a861 4
      dev_state.current_win32_attr = dev_state.wAttributes;
      if (!dev_state.default_color)
	dev_state.default_color = dev_state.wAttributes;
      dev_state.set_default_attr ();
d908 1
a908 1
	st = dev_state.fillin (get_output_handle ());
d913 2
a914 2
	    ((struct winsize *) arg)->ws_row = dev_state.dwWinSize.Y;
	    ((struct winsize *) arg)->ws_col = dev_state.dwWinSize.X;
d931 1
a931 1
	*(int *) arg = (dev_state.metabit) ? K_METABIT : K_ESCPREFIX;
d935 1
a935 1
	  dev_state.metabit = TRUE;
d937 1
a937 1
	  dev_state.metabit = FALSE;
d947 1
a947 1
	    *(unsigned char *) arg = (unsigned char) dev_state.nModifiers;
d1192 2
a1193 2
    return dwBufferSize.X - 1;
  return dwCursorPosition.X;
d1202 1
a1202 1
    return winTop;
d1204 1
a1204 1
    return winBottom;
d1206 2
a1207 2
    return dwBufferSize.Y - 1;
  return dwCursorPosition.Y;
d1213 2
a1214 2
  if (savebuf || x1 != 0 || x2 != dwWinSize.X - 1 || y1 != winTop
      || y2 != winBottom || dwBufferSize.Y <= dwWinSize.Y)
d1218 2
a1219 2
  int toscroll = 2 + dwEnd.Y - winTop;
  int shrink = 1 + toscroll + winBottom - dwBufferSize.Y;
d1226 1
a1226 1
      COORD c = dwBufferSize;
d1229 1
a1229 1
      SetConsoleScreenBufferSize (h, dwBufferSize);
d1232 1
a1232 1
      toscroll = 2 + dwEnd.Y - winTop;
d1254 1
a1254 1
  dev_state.fillin (h);
d1256 4
a1259 4
  int x1 = dev_state.set_cl_x (xc1);
  int y1 = dev_state.set_cl_y (yc1);
  int x2 = dev_state.set_cl_x (xc2);
  int y2 = dev_state.set_cl_y (yc2);
d1263 2
a1264 2
  if (!dev_state.scroll_window (h, x1, y1, x2, y2))
    dev_state.clear_screen (h, x1, y1, x2, y2);
d1274 1
a1274 1
  num = abs (y1 - y2) * dwBufferSize.X + abs (x1 - x2) + 1;
d1276 1
a1276 1
  if ((y2 * dwBufferSize.X + x2) > (y1 * dwBufferSize.X + x1))
d1295 1
a1295 1
  dev_state.fillin (get_output_handle ());
d1297 1
a1297 1
  /* Setting y to the current winBottom here is the reason that the window
d1304 2
a1305 2
  if (y > dev_state.winBottom)
    y = dev_state.winBottom;
d1311 1
a1311 1
    y += dev_state.winTop;
d1313 2
a1314 2
  if (x > dev_state.dwWinSize.X)
    x = dev_state.dwWinSize.X - 1;
d1326 3
a1328 3
  dev_state.fillin (get_output_handle ());
  x += dev_state.dwCursorPosition.X;
  y += dev_state.dwCursorPosition.Y;
d1335 3
a1337 3
  dev_state.fillin (get_output_handle ());
  *y = dev_state.dwCursorPosition.Y;
  *x = dev_state.dwCursorPosition.X;
d1379 3
a1381 3
  if (dev_state.iso_2022_G1
	? dev_state.vt100_graphics_mode_G1
	: dev_state.vt100_graphics_mode_G0)
d1430 1
a1430 1
			  SMALL_RECT& region)
d1454 57
d1572 2
a1573 2
       for (int i = 0; i <= dev_state.nargs; i++)
	 switch (dev_state.args[i])
d1576 1
a1576 1
	       dev_state.set_default_attr ();
d1579 1
a1579 1
	       dev_state.intensity = INTENSITY_BOLD;
d1582 1
a1582 1
	       dev_state.intensity = INTENSITY_DIM;
d1585 1
a1585 1
	       dev_state.underline = 1;
d1588 1
a1588 1
	       dev_state.blink = true;
d1591 1
a1591 1
	       dev_state.reverse = true;
d1594 1
a1594 1
	       dev_state.intensity = INTENSITY_INVISIBLE;
d1597 1
a1597 1
	       dev_state.alternate_charset_active = false;
d1600 1
a1600 1
	       dev_state.alternate_charset_active = true;
d1604 1
a1604 1
	       dev_state.intensity = INTENSITY_NORMAL;
d1607 1
a1607 1
	       dev_state.underline = false;
d1610 1
a1610 1
	       dev_state.blink = false;
d1613 1
a1613 1
	       dev_state.reverse = false;
d1616 1
a1616 1
	       dev_state.fg = 0;
d1619 1
a1619 1
	       dev_state.fg = FOREGROUND_RED;
d1622 1
a1622 1
	       dev_state.fg = FOREGROUND_GREEN;
d1625 1
a1625 1
	       dev_state.fg = FOREGROUND_RED | FOREGROUND_GREEN;
d1628 1
a1628 1
	       dev_state.fg = FOREGROUND_BLUE;
d1631 1
a1631 1
	       dev_state.fg = FOREGROUND_RED | FOREGROUND_BLUE;
d1634 1
a1634 1
	       dev_state.fg = FOREGROUND_BLUE | FOREGROUND_GREEN;
d1637 1
a1637 1
	       dev_state.fg = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED;
d1640 1
a1640 1
	       dev_state.fg = dev_state.default_color & FOREGROUND_ATTR_MASK;
d1643 1
a1643 1
	       dev_state.bg = 0;
d1646 1
a1646 1
	       dev_state.bg = BACKGROUND_RED;
d1649 1
a1649 1
	       dev_state.bg = BACKGROUND_GREEN;
d1652 1
a1652 1
	       dev_state.bg = BACKGROUND_RED | BACKGROUND_GREEN;
d1655 1
a1655 1
	       dev_state.bg = BACKGROUND_BLUE;
d1658 1
a1658 1
	       dev_state.bg = BACKGROUND_RED | BACKGROUND_BLUE;
d1661 1
a1661 1
	       dev_state.bg = BACKGROUND_BLUE | BACKGROUND_GREEN;
d1664 1
a1664 1
	       dev_state.bg = BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED;
d1667 1
a1667 1
	       dev_state.bg = dev_state.default_color & BACKGROUND_ATTR_MASK;
d1670 1
a1670 1
       dev_state.set_color (get_output_handle ());
d1673 1
a1673 1
      if (dev_state.saw_space)
d1677 1
a1677 1
	    switch (dev_state.args[0])
d1691 1
a1691 1
		  console_cursor_info.dwSize = dev_state.args[0];
d1699 1
a1699 1
      if (!dev_state.saw_question_mark)
d1701 1
a1701 1
	  switch (dev_state.args[0])
d1704 2
a1705 2
	      dev_state.insert_mode = (c == 'h') ? true : false;
	      syscall_printf ("insert mode %sabled", dev_state.insert_mode ? "en" : "dis");
d1710 1
a1710 1
      switch (dev_state.args[0])
d1724 1
a1724 46
	  if (c == 'h') /* save */
	    {
	      CONSOLE_SCREEN_BUFFER_INFO now;

	      if (!GetConsoleScreenBufferInfo (get_output_handle (), &now))
		break;

	      /* Assume starting from 0/0 */
	      dev_state.savebufsiz.X = 1 + now.srWindow.Right;
	      dev_state.savebufsiz.Y = 1 + now.srWindow.Bottom;

	      if (dev_state.savebuf)
		cfree (dev_state.savebuf);
	      size_t screen_size = sizeof (CHAR_INFO) * dev_state.savebufsiz.X * dev_state.savebufsiz.Y;
	      dev_state.savebuf = (PCHAR_INFO) cmalloc_abort (HEAP_1_BUF, screen_size);

	      BOOL res = ReadConsoleOutputWrapper (get_output_handle (),
						   dev_state.savebuf,
						   dev_state.savebufsiz,
						   now.srWindow);
	      if (!res)
		debug_printf ("ReadConsoleOutputWrapper failed, %E");
	    }
	  else		/* restore */
	    {
	      if (!dev_state.savebuf)
		break;

	      CONSOLE_SCREEN_BUFFER_INFO now;
	      COORD cob = { 0, 0 };

	      if (!GetConsoleScreenBufferInfo (get_output_handle (), &now))
		{
		  debug_printf ("GetConsoleScreenBufferInfo(%y, %y), %E", get_output_handle (), &now);
		  break;
		}

	      BOOL res = WriteConsoleOutputW (get_output_handle (), dev_state.savebuf,
					      dev_state.savebufsiz, cob, &now.srWindow);
	      if (!res)
		debug_printf ("WriteConsoleOutputW failed, %E");

	      cfree (dev_state.savebuf);
	      dev_state.savebuf = NULL;
	      dev_state.savebufsiz.X = dev_state.savebufsiz.Y = 0;
	    }
d1728 1
a1728 1
	  dev_state.backspace_keycode = (c == 'h' ? CTRL('H') : CERASE);
d1732 1
a1732 1
	  dev_state.use_mouse = (c == 'h') ? 1 : 0;
d1736 1
a1736 1
	  dev_state.use_mouse = (c == 'h') ? 2 : 0;
d1740 1
a1740 1
	  dev_state.use_mouse = (c == 'h') ? 3 : 0;
d1744 1
a1744 1
	  dev_state.use_focus = (c == 'h') ? true : false;
d1748 1
a1748 1
	  dev_state.ext_mouse_mode5 = c == 'h';
d1752 1
a1752 1
	  dev_state.ext_mouse_mode6 = c == 'h';
d1756 1
a1756 1
	  dev_state.ext_mouse_mode15 = c == 'h';
d1764 1
a1764 1
	  syscall_printf ("unknown h/l command: %d", dev_state.args[0]);
d1769 1
a1769 1
      switch (dev_state.args[0])
d1788 1
a1788 1
      cursor_rel (0, -(dev_state.args[0] ?: 1));
d1791 1
a1791 1
      cursor_rel (0, dev_state.args[0] ?: 1);
d1794 1
a1794 1
      cursor_rel (dev_state.args[0] ?: 1, 0);
d1797 1
a1797 1
      cursor_rel (-(dev_state.args[0] ?: 1),0);
d1800 1
a1800 1
      switch (dev_state.args[0])
d1817 2
a1818 2
      cursor_set (true, (dev_state.args[1] ?: 1) - 1,
			(dev_state.args[0] ?: 1) - 1);
d1822 1
a1822 1
      cursor_set (false, (dev_state.args[0] ? dev_state.args[0] - 1 : 0), y);
d1826 1
a1826 1
      cursor_set (true, x, (dev_state.args[0] ? dev_state.args[0] - 1 : 0));
d1829 2
a1830 2
      cursor_get (&dev_state.savex, &dev_state.savey);
      dev_state.savey -= dev_state.winTop;
d1833 1
a1833 1
      cursor_set (true, dev_state.savex, dev_state.savey);
d1840 1
a1840 1
      n = dev_state.args[0] ?: 1;
d1845 1
a1845 1
      n = dev_state.args[0] ?: 1;
d1850 1
a1850 1
      n = dev_state.args[0] ?: 1;
d1855 1
a1855 1
      n = dev_state.args[0] ?: 1;
d1860 1
a1860 1
      n = dev_state.args[0] ?: 1;
d1864 2
a1865 2
      dev_state.fillin (get_output_handle ());
      n = dev_state.winTop + dev_state.args[0] ?: 1;
d1869 1
a1869 1
      n = dev_state.args[0] ?: 1;
d1879 1
a1879 1
      if (dev_state.insert_mode)
d1882 1
a1882 1
	  scroll_buffer (x, y, -1, y, x + dev_state.args[1], y);
d1884 2
a1885 2
      while (dev_state.args[1]--)
	WriteFile (get_output_handle (), &dev_state.args[0], 1, (DWORD *) &x, 0);
d1888 1
a1888 1
      if (dev_state.saw_greater_than_sign)
d1901 1
a1901 1
      switch (dev_state.args[0])
d1905 2
a1906 2
	  y -= dev_state.winTop;
	  /* x -= dev_state.winLeft;		// not available yet */
d1915 2
a1916 2
      dev_state.scroll_region.Top = dev_state.args[0] ? dev_state.args[0] - 1 : 0;
      dev_state.scroll_region.Bottom = dev_state.args[1] ? dev_state.args[1] - 1 : -1;
d1948 1
a1948 1
  UINT cp = dev_state.get_console_cp ();
d1998 1
a1998 1
	  buf_len = dev_state.str_to_con (f_mbtowc, charset, write_buf,
d2044 1
a2044 1
      buf_len = dev_state.str_to_con (f_mbtowc, charset, write_buf,
d2054 1
a2054 1
      if (dev_state.insert_mode)
d2079 1
a2079 1
	  dev_state.iso_2022_G1 = true;
d2082 1
a2082 1
	  dev_state.iso_2022_G1 = false;
d2088 1
a2088 1
	  dev_state.state = gotesc;
d2094 1
a2094 1
	      if (y >= dev_state.winBottom && !dev_state.scroll_region.Top)
d2170 2
a2171 2
      paranoid_printf ("char %0c state is %d", *src, dev_state.state);
      switch (dev_state.state)
d2181 7
a2187 7
	      dev_state.state = gotsquare;
	      dev_state.saw_question_mark = false;
	      dev_state.saw_greater_than_sign = false;
	      dev_state.saw_space = false;
	      for (dev_state.nargs = 0; dev_state.nargs < MAXARGS; dev_state.nargs++)
		dev_state.args[dev_state.nargs] = 0;
	      dev_state.nargs = 0;
d2191 3
a2193 3
	      dev_state.rarg = 0;
	      dev_state.my_title_buf[0] = '\0';
	      dev_state.state = gotrsquare;
d2197 1
a2197 1
	      dev_state.state = gotparen;
d2201 1
a2201 1
	      dev_state.state = gotrparen;
d2205 1
a2205 1
	      dev_state.fillin (get_output_handle ());
d2207 1
a2207 1
	      dev_state.state = normal;
d2211 4
a2214 4
	      dev_state.set_default_attr ();
	      dev_state.vt100_graphics_mode_G0 = false;
	      dev_state.vt100_graphics_mode_G1 = false;
	      dev_state.iso_2022_G1 = false;
d2217 1
a2217 1
	      dev_state.state = normal;
d2221 2
a2222 2
	      cursor_set (true, dev_state.savex, dev_state.savey);
	      dev_state.state = normal;
d2226 3
a2228 3
	      cursor_get (&dev_state.savex, &dev_state.savey);
	      dev_state.savey -= dev_state.winTop;
	      dev_state.state = normal;
d2231 1
a2231 1
	      dev_state.state = normal;
d2234 1
a2234 1
	      dev_state.state = normal;
d2241 1
a2241 1
	      dev_state.args[dev_state.nargs] = dev_state.args[dev_state.nargs] * 10 + *src - '0';
d2247 3
a2249 3
	      dev_state.nargs++;
	      if (dev_state.nargs >= MAXARGS)
		dev_state.nargs--;
d2254 2
a2255 2
	      dev_state.saw_space = true;
	      dev_state.state = gotcommand;
d2258 1
a2258 1
	    dev_state.state = gotcommand;
d2262 1
a2262 1
	  dev_state.state = normal;
d2266 3
a2268 3
	    dev_state.rarg = dev_state.rarg * 10 + (*src - '0');
	  else if (*src == ';' && (dev_state.rarg == 2 || dev_state.rarg == 0))
	    dev_state.state = gettitle;
d2270 1
a2270 1
	    dev_state.state = eattitle;
d2276 1
a2276 1
	    int n = strlen (dev_state.my_title_buf);
d2279 3
a2281 3
		if (*src == '\007' && dev_state.state == gettitle)
		  set_console_title (dev_state.my_title_buf);
		dev_state.state = normal;
d2285 2
a2286 2
		dev_state.my_title_buf[n++] = *src;
		dev_state.my_title_buf[n] = '\0';
d2294 2
a2295 2
	      dev_state.state = gotarg1;
	      dev_state.nargs++;
d2299 1
a2299 1
	    dev_state.state = gotcommand;
d2303 1
a2303 1
		dev_state.saw_question_mark = true;
d2305 1
a2305 1
		dev_state.saw_greater_than_sign = true;
d2310 1
a2310 1
	    dev_state.state = gotarg1;
d2314 1
a2314 1
	    dev_state.vt100_graphics_mode_G0 = true;
d2316 2
a2317 2
	    dev_state.vt100_graphics_mode_G0 = false;
	  dev_state.state = normal;
d2322 1
a2322 1
	    dev_state.vt100_graphics_mode_G1 = true;
d2324 2
a2325 2
	    dev_state.vt100_graphics_mode_G1 = false;
	  dev_state.state = normal;
@


1.289
log
@* fhandler.h (fhandler_console::scroll_buffer_screen): New function.
* fhandler_console.cc (fhandler_console::scroll_buffer_screen): New function.
(fhandler_console::char_command): Use scroll_buffer_screen as appropriate.
(dev_console::scroll_buffer): Remove if 0'ed block.
@
text
@d1842 1
a1842 1
      scroll_buffer (0, y + dev_state.args[0], -1, -1, 0, y);
@


1.288
log
@* dev_console::scroll_buffer): Reinstate clipping region.
@
text
@d795 1
d797 4
a800 11
#if 0 /* CGF: 2014-01-04 Assuming that we don't need this anymore */
  /* ScrollConsoleScreenBuffer on Windows 95 is buggy - when scroll distance
   * is more than half of screen, filling doesn't work as expected */

  if (sr1.Top == sr1.Bottom)
    /* nothing to do */;
  else if (dest.Y <= sr1.Top)	/* forward scroll */
    clear_screen (0, 1 + dest.Y + sr1.Bottom - sr1.Top, sr2.Right, sr2.Bottom);
  else			/* reverse scroll */
    clear_screen (0, sr1.Top, sr2.Right, dest.Y - 1);
#endif
d804 1
a804 1
fhandler_console::scroll_buffer (int x1, int y1, int x2, int y2, int xn, int yn)
d806 6
d1856 1
a1856 1
      scroll_buffer (0, n, -1, -1, 0, 0);
d1861 1
a1861 1
      scroll_buffer (0, dev_state.winTop, -1, -1, 0, n);
d2201 1
a2201 1
	      scroll_buffer (0, 0, -1, -1, 0, 1);
@


1.287
log
@* fhandler.h (dev_console::is_fullscreen): Delete.
(dev_console::scroll_window): Return bool indicating success.
(dev_console::scroll_screen): New function.
(dev_console::clear_screen): New function.
(fhandler_console::clear_screen): Make __reg3.
(fhandler_console::cursor_set): Ditto.
(fhandler_console::cursor_get): Ditto.
(fhandler_console::cursor_rel): Ditto.
* fhandler_console.cc (dev_console::scroll_buffer): Adapt from
fhandler_console.
(fhandler_console::scroll_buffer): Use dev_console function.
(dev_console::is_fullscreen): Delete.
(dev_console::scroll_window): Return true if we cleared the screen.
Shrink/grow buffer first before scrolling to ensure that there is sufficient
space after scrolling.
(fhandler_console::clear_screen): Make reg3, use dev_console function.
(dev_console::clear_screen): New function adapted from fhandler_console.
(fhandler_console::cursor_set): Make __reg3.
(fhandler_console::cursor_rel): Ditto.
(fhandler_console::cursor_get): Ditto.
(fhandler_console::write): Fix "reverse index".
@
text
@d794 1
a794 1
  ScrollConsoleScreenBuffer (h, &sr1, NULL, dest, &fill);
@


1.286
log
@* DevNotes: Add entry cgf-000024.
* fhandler.h (dev_console::state): Remove trailing underscore.
(dev_console::args): Ditto.
(dev_console::nargs): Ditto.
(dev_console::info): Eliminate subclass.
(dev_console::dwEnd): New field.
(dev_console::scroll_window): New function.
(dev_console::is_fullscreen): Ditto.
(dev_console::fillin): Rename from fillin_info.
(fhandler_console::scroll_buffer): Rename from scroll_screen.
* fhandler_console.cc: Throughout s/dev_state\.info/dev_state/g.  Accommodate
other name changes.
(dev_console::fillin): Accommodate rename.  Notice max x/y written to.  Forgo
memset if GetConsoleScreenBufferInfo fails.
(fhandler_console::scroll_buffer): Accommodate rename.  Don't treat y
coordinate of zero as top of screen.
(dev_console::is_fullscreen): New function.
(dev_console::scroll_window): Ditto.
(fhandler_console::clear_screen): Just scroll the screen when clearing the
screen in a state where the screen buffer is bigger than the screen.
(fhandler_console::char_command): Try harder to get 'S' and 'T' working in the
presence of a screen buffer.  Use temporary 'n' variable rather than
dev_state.args[0].  Use GNU ?: shortcut method.
@
text
@d766 3
a774 3
void
fhandler_console::scroll_buffer (int x1, int y1, int x2, int y2, int xn, int yn)
{
d779 1
a779 1
  fill.Attributes = dev_state.current_win32_attr;
d781 6
a786 6
  dev_state.fillin (get_output_handle ());
  sr1.Left = x1 >= 0 ? x1 : dev_state.dwWinSize.X - 1;
  sr1.Top = y1 >= 0 ? y1 : dev_state.winBottom;
  sr1.Right = x2 >= 0 ? x2 : dev_state.dwWinSize.X - 1;
  sr1.Bottom = y2 >= 0 ? y2 : dev_state.winBottom;
  sr2.Top = srTop;
d788 2
a789 2
  sr2.Bottom = srBottom;
  sr2.Right = dev_state.dwWinSize.X - 1;
d792 3
a794 3
  dest.X = xn >= 0 ? xn : dev_state.dwWinSize.X - 1;
  dest.Y = yn >= 0 ? yn : dev_state.winBottom;
  ScrollConsoleScreenBuffer (get_output_handle (), &sr1, NULL, dest, &fill);
d809 6
d1218 1
a1218 1
dev_console::is_fullscreen (int x1, int y1, int x2, int y2)
d1220 3
a1222 4
  return !savebuf
	 && x1 == 0 && x2 == dwWinSize.X - 1 && y1 == winTop && y2 == winBottom
	 && dwBufferSize.Y > dwWinSize.Y;
}
a1223 3
void
dev_console::scroll_window (HANDLE h)
{
d1225 19
a1243 2
  sr.Top = sr.Bottom = 1 + dwEnd.Y - winTop;
  sr.Left = sr.Right = 0;
d1245 2
a1246 1
  dwEnd.X = 0;
d1248 3
d1257 1
a1257 1
void
d1260 2
a1261 5
  COORD tlc;
  DWORD done;
  int num;

  dev_state.fillin (get_output_handle ());
d1268 1
a1268 1
  /* Detect special case - scroll the screen if we have a buffer to
d1270 10
a1279 5
  if (dev_state.is_fullscreen (x1, y1, x2, y2))
    {
      dev_state.scroll_window (get_output_handle ());
      return;
    }
d1281 1
a1281 1
  num = abs (y1 - y2) * dev_state.dwBufferSize.X + abs (x1 - x2) + 1;
d1283 1
a1283 1
  if ((y2 * dev_state.dwBufferSize.X + x2) > (y1 * dev_state.dwBufferSize.X + x1))
d1293 2
a1294 9
  FillConsoleOutputCharacterA (get_output_handle (), ' ',
			       num,
			       tlc,
			       &done);
  FillConsoleOutputAttribute (get_output_handle (),
			       dev_state.current_win32_attr,
			       num,
			       tlc,
			       &done);
d1297 1
a1297 1
void
d1330 1
a1330 1
void
d1339 1
a1339 1
void
d2201 1
a2201 1
	      scroll_buffer (0, 0, -1, -1, 0, dev_state.winTop + 1);
@


1.285
log
@* fhandler.h (cltype): Add cl_buf_beg, cl_buf_end.
* fhandler_console.cc (dev_console::console_attrs::set_cl_x): Honor buffer
locations.
(dev_console::console_attrs::set_cl_y): Ditto.
(fhandler_console::write): On reset, use absolute positioning to go to
beginning of buffer.  Clear entire buffer.
@
text
@d46 2
a47 2
#define srTop (dev_state.info.winTop + dev_state.scroll_region.Top)
#define srBottom ((dev_state.scroll_region.Bottom < 0) ? dev_state.info.winBottom : dev_state.info.winTop + dev_state.scroll_region.Bottom)
a174 1

d266 3
a268 3
  SHORT y = dev_state.info.dwWinSize.Y;
  SHORT x = dev_state.info.dwWinSize.X;
  dev_state.fillin_info (get_output_handle ());
d270 1
a270 1
  if (y != dev_state.info.dwWinSize.Y || x != dev_state.info.dwWinSize.X)
d736 1
a736 1
dev_console::fillin_info (HANDLE h)
d743 12
a754 7
      info.winTop = linfo.srWindow.Top;
      info.winBottom = linfo.srWindow.Bottom;
      info.dwWinSize.Y = 1 + linfo.srWindow.Bottom - linfo.srWindow.Top;
      info.dwWinSize.X = 1 + linfo.srWindow.Right - linfo.srWindow.Left;
      info.dwBufferSize = linfo.dwSize;
      info.dwCursorPosition = linfo.dwCursorPosition;
      info.wAttributes = linfo.wAttributes;
d758 3
a760 4
      memset (&info, 0, sizeof info);
      info.dwWinSize.Y = 25;
      info.dwWinSize.X = 80;
      info.winBottom = 24;
d773 1
a773 1
fhandler_console::scroll_screen (int x1, int y1, int x2, int y2, int xn, int yn)
d778 2
d781 5
a785 11
  dev_state.fillin_info (get_output_handle ());
  sr1.Left = x1 >= 0 ? x1 : dev_state.info.dwWinSize.X - 1;
  if (y1 == 0)
    sr1.Top = dev_state.info.winTop;
  else
    sr1.Top = y1 > 0 ? y1 : dev_state.info.winBottom;
  sr1.Right = x2 >= 0 ? x2 : dev_state.info.dwWinSize.X - 1;
  if (y2 == 0)
    sr1.Bottom = dev_state.info.winTop;
  else
    sr1.Bottom = y2 > 0 ? y2 : dev_state.info.winBottom;
d789 1
a789 1
  sr2.Right = dev_state.info.dwWinSize.X - 1;
d792 3
a794 8
  dest.X = xn >= 0 ? xn : dev_state.info.dwWinSize.X - 1;
  if (yn == 0)
    dest.Y = dev_state.info.winTop;
  else
    dest.Y = yn > 0 ? yn : dev_state.info.winBottom;
  fill.Char.AsciiChar = ' ';
  fill.Attributes = dev_state.current_win32_attr;
  ScrollConsoleScreenBuffer (get_output_handle (), &sr1, &sr2, dest, &fill);
d857 1
a857 1
  if (dev_state.fillin_info (get_output_handle ()))
d859 1
a859 1
      dev_state.current_win32_attr = dev_state.info.wAttributes;
d861 1
a861 1
	dev_state.default_color = dev_state.info.wAttributes;
d909 1
a909 1
	st = dev_state.fillin_info (get_output_handle ());
d914 2
a915 2
	    ((struct winsize *) arg)->ws_row = dev_state.info.dwWinSize.Y;
	    ((struct winsize *) arg)->ws_col = dev_state.info.dwWinSize.X;
d1186 1
a1186 1
dev_console::console_attrs::set_cl_x (cltype x)
d1198 1
a1198 1
dev_console::console_attrs::set_cl_y (cltype y)
d1210 20
a1229 1
  
d1241 1
a1241 1
  dev_state.fillin_info (get_output_handle ());
d1243 12
a1254 4
  int x1 = dev_state.info.set_cl_x (xc1);
  int y1 = dev_state.info.set_cl_y (yc1);
  int x2 = dev_state.info.set_cl_x (xc2);
  int y2 = dev_state.info.set_cl_y (yc2);
d1256 1
a1256 1
  num = abs (y1 - y2) * dev_state.info.dwBufferSize.X + abs (x1 - x2) + 1;
d1258 1
a1258 1
  if ((y2 * dev_state.info.dwBufferSize.X + x2) > (y1 * dev_state.info.dwBufferSize.X + x1))
d1284 1
a1284 1
  dev_state.fillin_info (get_output_handle ());
d1293 2
a1294 2
  if (y > dev_state.info.winBottom)
    y = dev_state.info.winBottom;
d1300 1
a1300 1
    y += dev_state.info.winTop;
d1302 2
a1303 2
  if (x > dev_state.info.dwWinSize.X)
    x = dev_state.info.dwWinSize.X - 1;
d1315 3
a1317 3
  dev_state.fillin_info (get_output_handle ());
  x += dev_state.info.dwCursorPosition.X;
  y += dev_state.info.dwCursorPosition.Y;
d1324 3
a1326 3
  dev_state.fillin_info (get_output_handle ());
  *y = dev_state.info.dwCursorPosition.Y;
  *x = dev_state.info.dwCursorPosition.X;
d1498 1
a1498 1
  int x, y;
d1504 2
a1505 2
       for (int i = 0; i <= dev_state.nargs_; i++)
	 switch (dev_state.args_[i])
d1609 1
a1609 1
	    switch (dev_state.args_[0])
d1623 1
a1623 1
		  console_cursor_info.dwSize = dev_state.args_[0];
d1633 1
a1633 1
	  switch (dev_state.args_[0])
d1642 1
a1642 1
      switch (dev_state.args_[0])
d1741 1
a1741 1
	  syscall_printf ("unknown h/l command: %d", dev_state.args_[0]);
d1746 1
a1746 1
      switch (dev_state.args_[0])
a1751 1
	  cursor_get (&x, &y);
d1755 1
d1757 1
a1757 1
	  cursor_set (true, 0, 0);
d1765 1
a1765 1
      cursor_rel (0, -(dev_state.args_[0] ? dev_state.args_[0] : 1));
d1768 1
a1768 1
      cursor_rel (0, dev_state.args_[0] ? dev_state.args_[0] : 1);
d1771 1
a1771 1
      cursor_rel (dev_state.args_[0] ? dev_state.args_[0] : 1, 0);
d1774 1
a1774 1
      cursor_rel (-(dev_state.args_[0] ? dev_state.args_[0] : 1),0);
d1777 1
a1777 1
      switch (dev_state.args_[0])
d1794 2
a1795 2
      cursor_set (true, (dev_state.args_[1] ? dev_state.args_[1] : 1) - 1,
			(dev_state.args_[0] ? dev_state.args_[0] : 1) - 1);
d1799 1
a1799 1
      cursor_set (false, (dev_state.args_[0] ? dev_state.args_[0] - 1 : 0), y);
d1803 1
a1803 1
      cursor_set (true, x, (dev_state.args_[0] ? dev_state.args_[0] - 1 : 0));
d1807 1
a1807 1
      dev_state.savey -= dev_state.info.winTop;
d1817 1
a1817 1
      dev_state.args_[0] = dev_state.args_[0] ? dev_state.args_[0] : 1;
d1819 1
a1819 1
      scroll_screen (0, y, -1, -1, 0, y + dev_state.args_[0]);
d1822 1
a1822 1
      dev_state.args_[0] = dev_state.args_[0] ? dev_state.args_[0] : 1;
d1824 1
a1824 1
      scroll_screen (0, y + dev_state.args_[0], -1, -1, 0, y);
d1827 1
a1827 1
      dev_state.args_[0] = dev_state.args_[0] ? dev_state.args_[0] : 1;
d1829 1
a1829 1
      scroll_screen (x, y, -1, y, x + dev_state.args_[0], y);
d1832 1
a1832 1
      dev_state.args_[0] = dev_state.args_[0] ? dev_state.args_[0] : 1;
d1834 1
a1834 1
      scroll_screen (x + dev_state.args_[0], y, -1, y, x, y);
d1837 2
a1838 2
      dev_state.args_[0] = dev_state.args_[0] ? dev_state.args_[0] : 1;
      scroll_screen (0, dev_state.args_[0], -1, -1, 0, 0);
d1841 3
a1843 3
      dev_state.fillin_info (get_output_handle ());
      dev_state.args_[0] = dev_state.args_[0] ? dev_state.args_[0] : 1;
      scroll_screen (0, 0, -1, -1, 0, dev_state.info.winTop + dev_state.args_[0]);
d1846 1
a1846 1
      dev_state.args_[0] = dev_state.args_[0] ? dev_state.args_[0] : 1;
d1848 2
a1849 2
      scroll_screen (x + dev_state.args_[0], y, -1, y, x, y);
      scroll_screen (x, y, -1, y, x + dev_state.args_[0], y);
d1859 1
a1859 1
	  scroll_screen (x, y, -1, y, x + dev_state.args_[1], y);
d1861 2
a1862 2
      while (dev_state.args_[1]--)
	WriteFile (get_output_handle (), &dev_state.args_[0], 1, (DWORD *) &x, 0);
d1878 1
a1878 1
      switch (dev_state.args_[0])
d1882 2
a1883 2
	  y -= dev_state.info.winTop;
	  /* x -= dev_state.info.winLeft;		// not available yet */
d1892 2
a1893 2
      dev_state.scroll_region.Top = dev_state.args_[0] ? dev_state.args_[0] - 1 : 0;
      dev_state.scroll_region.Bottom = dev_state.args_[1] ? dev_state.args_[1] - 1 : -1;
d2035 1
a2035 1
	  scroll_screen (x, y, -1, y, x + buf_len, y);
d2065 1
a2065 1
	  dev_state.state_ = gotesc;
d2071 1
a2071 1
	      if (y >= dev_state.info.winBottom && !dev_state.scroll_region.Top)
d2075 1
a2075 1
		  scroll_screen (0, srTop + 1, -1, srBottom, 0, srTop);
d2147 2
a2148 2
      paranoid_printf ("char %0c state is %d", *src, dev_state.state_);
      switch (dev_state.state_)
d2158 1
a2158 1
	      dev_state.state_ = gotsquare;
d2162 3
a2164 3
	      for (dev_state.nargs_ = 0; dev_state.nargs_ < MAXARGS; dev_state.nargs_++)
		dev_state.args_[dev_state.nargs_] = 0;
	      dev_state.nargs_ = 0;
d2170 1
a2170 1
	      dev_state.state_ = gotrsquare;
d2174 1
a2174 1
	      dev_state.state_ = gotparen;
d2178 1
a2178 1
	      dev_state.state_ = gotrparen;
d2182 3
a2184 3
	      dev_state.fillin_info (get_output_handle ());
	      scroll_screen (0, 0, -1, -1, 0, dev_state.info.winTop + 1);
	      dev_state.state_ = normal;
d2194 1
a2194 1
	      dev_state.state_ = normal;
d2199 1
a2199 1
	      dev_state.state_ = normal;
d2204 2
a2205 2
	      dev_state.savey -= dev_state.info.winTop;
	      dev_state.state_ = normal;
d2208 1
a2208 1
	      dev_state.state_ = normal;
d2211 1
a2211 1
	      dev_state.state_ = normal;
d2218 1
a2218 1
	      dev_state.args_[dev_state.nargs_] = dev_state.args_[dev_state.nargs_] * 10 + *src - '0';
d2224 3
a2226 3
	      dev_state.nargs_++;
	      if (dev_state.nargs_ >= MAXARGS)
		dev_state.nargs_--;
d2232 1
a2232 1
	      dev_state.state_ = gotcommand;
d2235 1
a2235 1
	    dev_state.state_ = gotcommand;
d2239 1
a2239 1
	  dev_state.state_ = normal;
d2245 1
a2245 1
	    dev_state.state_ = gettitle;
d2247 1
a2247 1
	    dev_state.state_ = eattitle;
d2256 1
a2256 1
		if (*src == '\007' && dev_state.state_ == gettitle)
d2258 1
a2258 1
		dev_state.state_ = normal;
d2271 2
a2272 2
	      dev_state.state_ = gotarg1;
	      dev_state.nargs_++;
d2276 1
a2276 1
	    dev_state.state_ = gotcommand;
d2287 1
a2287 1
	    dev_state.state_ = gotarg1;
d2294 1
a2294 1
	  dev_state.state_ = normal;
d2302 1
a2302 1
	  dev_state.state_ = normal;
@


1.285.2.1
log
@* DevNotes: Add entry cgf-000024.
* fhandler.h (dev_console::state): Remove trailing underscore.
(dev_console::args): Ditto.
(dev_console::nargs): Ditto.
(dev_console::info): Eliminate subclass.
(dev_console::dwEnd): New field.
(dev_console::scroll_window): New function.
(dev_console::is_fullscreen): Ditto.
(dev_console::fillin): Rename from fillin_info.
(fhandler_console::scroll_buffer): Rename from scroll_screen.
* fhandler_console.cc: Throughout s/dev_state\.info/dev_state/g.  Accommodate
other name changes.
(dev_console::fillin): Accommodate rename.  Notice max x/y written to.  Forgo
memset if GetConsoleScreenBufferInfo fails.
(fhandler_console::scroll_buffer): Accommodate rename.  Don't treat y
coordinate of zero as top of screen.
(dev_console::is_fullscreen): New function.
(dev_console::scroll_window): Ditto.
(fhandler_console::clear_screen): Just scroll the screen when clearing the
screen in a state where the screen buffer is bigger than the screen.
(fhandler_console::char_command): Try harder to get 'S' and 'T' working in the
presence of a screen buffer.  Use temporary 'n' variable rather than
dev_state.args[0].  Use GNU ?: shortcut method.
@
text
@d46 2
a47 2
#define srTop (dev_state.winTop + dev_state.scroll_region.Top)
#define srBottom ((dev_state.scroll_region.Bottom < 0) ? dev_state.winBottom : dev_state.winTop + dev_state.scroll_region.Bottom)
d175 1
d267 3
a269 3
  SHORT y = dev_state.dwWinSize.Y;
  SHORT x = dev_state.dwWinSize.X;
  dev_state.fillin (get_output_handle ());
d271 1
a271 1
  if (y != dev_state.dwWinSize.Y || x != dev_state.dwWinSize.X)
d737 1
a737 1
dev_console::fillin (HANDLE h)
d744 7
a750 12
      winTop = linfo.srWindow.Top;
      winBottom = linfo.srWindow.Bottom;
      dwWinSize.Y = 1 + linfo.srWindow.Bottom - linfo.srWindow.Top;
      dwWinSize.X = 1 + linfo.srWindow.Right - linfo.srWindow.Left;
      if (dwBufferSize.Y != linfo.dwSize.Y || dwBufferSize.X != linfo.dwSize.X)
	dwEnd.X = dwEnd.Y = 0;
      dwBufferSize = linfo.dwSize;
      dwCursorPosition = linfo.dwCursorPosition;
      if (dwCursorPosition.Y > dwEnd.Y
	  || (dwCursorPosition.Y >= dwEnd.Y && dwCursorPosition.X > dwEnd.X))
	dwEnd = dwCursorPosition;
      wAttributes = linfo.wAttributes;
d754 4
a757 3
      dwWinSize.Y = 25;
      dwWinSize.X = 80;
      winBottom = 24;
d770 1
a770 1
fhandler_console::scroll_buffer (int x1, int y1, int x2, int y2, int xn, int yn)
a774 2
  fill.Char.AsciiChar = ' ';
  fill.Attributes = dev_state.current_win32_attr;
d776 11
a786 5
  dev_state.fillin (get_output_handle ());
  sr1.Left = x1 >= 0 ? x1 : dev_state.dwWinSize.X - 1;
  sr1.Top = y1 >= 0 ? y1 : dev_state.winBottom;
  sr1.Right = x2 >= 0 ? x2 : dev_state.dwWinSize.X - 1;
  sr1.Bottom = y2 >= 0 ? y2 : dev_state.winBottom;
d790 1
a790 1
  sr2.Right = dev_state.dwWinSize.X - 1;
d793 8
a800 3
  dest.X = xn >= 0 ? xn : dev_state.dwWinSize.X - 1;
  dest.Y = yn >= 0 ? yn : dev_state.winBottom;
  ScrollConsoleScreenBuffer (get_output_handle (), &sr1, NULL, dest, &fill);
d863 1
a863 1
  if (dev_state.fillin (get_output_handle ()))
d865 1
a865 1
      dev_state.current_win32_attr = dev_state.wAttributes;
d867 1
a867 1
	dev_state.default_color = dev_state.wAttributes;
d915 1
a915 1
	st = dev_state.fillin (get_output_handle ());
d920 2
a921 2
	    ((struct winsize *) arg)->ws_row = dev_state.dwWinSize.Y;
	    ((struct winsize *) arg)->ws_col = dev_state.dwWinSize.X;
d1192 1
a1192 1
dev_console::set_cl_x (cltype x)
d1204 1
a1204 1
dev_console::set_cl_y (cltype y)
d1216 1
a1216 20

bool
dev_console::is_fullscreen (int x1, int y1, int x2, int y2)
{
  return !savebuf
	 && x1 == 0 && x2 == dwWinSize.X - 1 && y1 == winTop && y2 == winBottom
	 && dwBufferSize.Y > dwWinSize.Y;
}

void
dev_console::scroll_window (HANDLE h)
{
  SMALL_RECT sr;
  sr.Top = sr.Bottom = 1 + dwEnd.Y - winTop;
  sr.Left = sr.Right = 0;
  SetConsoleWindowInfo (h, FALSE, &sr);
  dwEnd.X = 0;
  SetConsoleCursorPosition (h, dwEnd);
}

d1228 1
a1228 1
  dev_state.fillin (get_output_handle ());
d1230 4
a1233 12
  int x1 = dev_state.set_cl_x (xc1);
  int y1 = dev_state.set_cl_y (yc1);
  int x2 = dev_state.set_cl_x (xc2);
  int y2 = dev_state.set_cl_y (yc2);

  /* Detect special case - scroll the screen if we have a buffer to
     preserve the buffer. */
  if (dev_state.is_fullscreen (x1, y1, x2, y2))
    {
      dev_state.scroll_window (get_output_handle ());
      return;
    }
d1235 1
a1235 1
  num = abs (y1 - y2) * dev_state.dwBufferSize.X + abs (x1 - x2) + 1;
d1237 1
a1237 1
  if ((y2 * dev_state.dwBufferSize.X + x2) > (y1 * dev_state.dwBufferSize.X + x1))
d1263 1
a1263 1
  dev_state.fillin (get_output_handle ());
d1272 2
a1273 2
  if (y > dev_state.winBottom)
    y = dev_state.winBottom;
d1279 1
a1279 1
    y += dev_state.winTop;
d1281 2
a1282 2
  if (x > dev_state.dwWinSize.X)
    x = dev_state.dwWinSize.X - 1;
d1294 3
a1296 3
  dev_state.fillin (get_output_handle ());
  x += dev_state.dwCursorPosition.X;
  y += dev_state.dwCursorPosition.Y;
d1303 3
a1305 3
  dev_state.fillin (get_output_handle ());
  *y = dev_state.dwCursorPosition.Y;
  *x = dev_state.dwCursorPosition.X;
d1477 1
a1477 1
  int x, y, n;
d1483 2
a1484 2
       for (int i = 0; i <= dev_state.nargs; i++)
	 switch (dev_state.args[i])
d1588 1
a1588 1
	    switch (dev_state.args[0])
d1602 1
a1602 1
		  console_cursor_info.dwSize = dev_state.args[0];
d1612 1
a1612 1
	  switch (dev_state.args[0])
d1621 1
a1621 1
      switch (dev_state.args[0])
d1720 1
a1720 1
	  syscall_printf ("unknown h/l command: %d", dev_state.args[0]);
d1725 1
a1725 1
      switch (dev_state.args[0])
d1731 1
a1734 1
	  cursor_get (&x, &y);
d1736 1
a1736 1
	  cursor_set (false, x, y);
d1744 1
a1744 1
      cursor_rel (0, -(dev_state.args[0] ?: 1));
d1747 1
a1747 1
      cursor_rel (0, dev_state.args[0] ?: 1);
d1750 1
a1750 1
      cursor_rel (dev_state.args[0] ?: 1, 0);
d1753 1
a1753 1
      cursor_rel (-(dev_state.args[0] ?: 1),0);
d1756 1
a1756 1
      switch (dev_state.args[0])
d1773 2
a1774 2
      cursor_set (true, (dev_state.args[1] ?: 1) - 1,
			(dev_state.args[0] ?: 1) - 1);
d1778 1
a1778 1
      cursor_set (false, (dev_state.args[0] ? dev_state.args[0] - 1 : 0), y);
d1782 1
a1782 1
      cursor_set (true, x, (dev_state.args[0] ? dev_state.args[0] - 1 : 0));
d1786 1
a1786 1
      dev_state.savey -= dev_state.winTop;
d1796 1
a1796 1
      n = dev_state.args[0] ?: 1;
d1798 1
a1798 1
      scroll_buffer (0, y, -1, -1, 0, y + n);
d1801 1
a1801 1
      n = dev_state.args[0] ?: 1;
d1803 1
a1803 1
      scroll_buffer (0, y + dev_state.args[0], -1, -1, 0, y);
d1806 1
a1806 1
      n = dev_state.args[0] ?: 1;
d1808 1
a1808 1
      scroll_buffer (x, y, -1, y, x + n, y);
d1811 1
a1811 1
      n = dev_state.args[0] ?: 1;
d1813 1
a1813 1
      scroll_buffer (x + n, y, -1, y, x, y);
d1816 2
a1817 2
      n = dev_state.args[0] ?: 1;
      scroll_buffer (0, n, -1, -1, 0, 0);
d1820 3
a1822 3
      dev_state.fillin (get_output_handle ());
      n = dev_state.winTop + dev_state.args[0] ?: 1;
      scroll_buffer (0, dev_state.winTop, -1, -1, 0, n);
d1825 1
a1825 1
      n = dev_state.args[0] ?: 1;
d1827 2
a1828 2
      scroll_buffer (x + n, y, -1, y, x, y);
      scroll_buffer (x, y, -1, y, x + n, y);
d1838 1
a1838 1
	  scroll_buffer (x, y, -1, y, x + dev_state.args[1], y);
d1840 2
a1841 2
      while (dev_state.args[1]--)
	WriteFile (get_output_handle (), &dev_state.args[0], 1, (DWORD *) &x, 0);
d1857 1
a1857 1
      switch (dev_state.args[0])
d1861 2
a1862 2
	  y -= dev_state.winTop;
	  /* x -= dev_state.winLeft;		// not available yet */
d1871 2
a1872 2
      dev_state.scroll_region.Top = dev_state.args[0] ? dev_state.args[0] - 1 : 0;
      dev_state.scroll_region.Bottom = dev_state.args[1] ? dev_state.args[1] - 1 : -1;
d2014 1
a2014 1
	  scroll_buffer (x, y, -1, y, x + buf_len, y);
d2044 1
a2044 1
	  dev_state.state = gotesc;
d2050 1
a2050 1
	      if (y >= dev_state.winBottom && !dev_state.scroll_region.Top)
d2054 1
a2054 1
		  scroll_buffer (0, srTop + 1, -1, srBottom, 0, srTop);
d2126 2
a2127 2
      paranoid_printf ("char %0c state is %d", *src, dev_state.state);
      switch (dev_state.state)
d2137 1
a2137 1
	      dev_state.state = gotsquare;
d2141 3
a2143 3
	      for (dev_state.nargs = 0; dev_state.nargs < MAXARGS; dev_state.nargs++)
		dev_state.args[dev_state.nargs] = 0;
	      dev_state.nargs = 0;
d2149 1
a2149 1
	      dev_state.state = gotrsquare;
d2153 1
a2153 1
	      dev_state.state = gotparen;
d2157 1
a2157 1
	      dev_state.state = gotrparen;
d2161 3
a2163 3
	      dev_state.fillin (get_output_handle ());
	      scroll_buffer (0, 0, -1, -1, 0, dev_state.winTop + 1);
	      dev_state.state = normal;
d2173 1
a2173 1
	      dev_state.state = normal;
d2178 1
a2178 1
	      dev_state.state = normal;
d2183 2
a2184 2
	      dev_state.savey -= dev_state.winTop;
	      dev_state.state = normal;
d2187 1
a2187 1
	      dev_state.state = normal;
d2190 1
a2190 1
	      dev_state.state = normal;
d2197 1
a2197 1
	      dev_state.args[dev_state.nargs] = dev_state.args[dev_state.nargs] * 10 + *src - '0';
d2203 3
a2205 3
	      dev_state.nargs++;
	      if (dev_state.nargs >= MAXARGS)
		dev_state.nargs--;
d2211 1
a2211 1
	      dev_state.state = gotcommand;
d2214 1
a2214 1
	    dev_state.state = gotcommand;
d2218 1
a2218 1
	  dev_state.state = normal;
d2224 1
a2224 1
	    dev_state.state = gettitle;
d2226 1
a2226 1
	    dev_state.state = eattitle;
d2235 1
a2235 1
		if (*src == '\007' && dev_state.state == gettitle)
d2237 1
a2237 1
		dev_state.state = normal;
d2250 2
a2251 2
	      dev_state.state = gotarg1;
	      dev_state.nargs++;
d2255 1
a2255 1
	    dev_state.state = gotcommand;
d2266 1
a2266 1
	    dev_state.state = gotarg1;
d2273 1
a2273 1
	  dev_state.state = normal;
d2281 1
a2281 1
	  dev_state.state = normal;
@


1.285.2.2
log
@* fhandler.h (dev_console::is_fullscreen): Delete.
(dev_console::scroll_window): Return bool indicating success.
(dev_console::scroll_screen): New function.
(dev_console::clear_screen): New function.
(fhandler_console::clear_screen): Make __reg3.
(fhandler_console::cursor_set): Ditto.
(fhandler_console::cursor_get): Ditto.
(fhandler_console::cursor_rel): Ditto.
* fhandler_console.cc (dev_console::scroll_buffer): Adapt from
fhandler_console.
(fhandler_console::scroll_buffer): Use dev_console function.
(dev_console::is_fullscreen): Delete.
(dev_console::scroll_window): Return true if we cleared the screen.
Shrink/grow buffer first before scrolling to ensure that there is sufficient
space after scrolling.
(fhandler_console::clear_screen): Make reg3, use dev_console function.
(dev_console::clear_screen): New function adapted from fhandler_console.
(fhandler_console::cursor_set): Make __reg3.
(fhandler_console::cursor_rel): Ditto.
(fhandler_console::cursor_get): Ditto.
(fhandler_console::write): Fix "reverse index".
@
text
@a765 3
void __reg3
dev_console::scroll_buffer (HANDLE h, int x1, int y1, int x2, int y2, int xn, int yn)
{
d772 3
d779 1
a779 1
  fill.Attributes = current_win32_attr;
d781 6
a786 6
  fillin (h);
  sr1.Left = x1 >= 0 ? x1 : dwWinSize.X - 1;
  sr1.Top = y1 >= 0 ? y1 : winBottom;
  sr1.Right = x2 >= 0 ? x2 : dwWinSize.X - 1;
  sr1.Bottom = y2 >= 0 ? y2 : winBottom;
  sr2.Top = winTop + scroll_region.Top;
d788 2
a789 2
  sr2.Bottom = (scroll_region.Bottom < 0) ? winBottom : winTop + scroll_region.Bottom;
  sr2.Right = dwWinSize.X - 1;
d792 3
a794 3
  dest.X = xn >= 0 ? xn : dwWinSize.X - 1;
  dest.Y = yn >= 0 ? yn : winBottom;
  ScrollConsoleScreenBuffer (h, &sr1, NULL, dest, &fill);
a808 6
inline void
fhandler_console::scroll_buffer (int x1, int y1, int x2, int y2, int xn, int yn)
{
  dev_state.scroll_buffer (get_output_handle (), x1, y1, x2, y2, xn, yn);
}

d1212 1
a1212 1
dev_console::scroll_window (HANDLE h, int x1, int y1, int x2, int y2)
d1214 4
a1217 3
  if (savebuf || x1 != 0 || x2 != dwWinSize.X - 1 || y1 != winTop
      || y2 != winBottom || dwBufferSize.Y <= dwWinSize.Y)
    return false;
d1219 3
d1223 2
a1224 19
  int toscroll = 2 + dwEnd.Y - winTop;
  int shrink = 1 + toscroll + winBottom - dwBufferSize.Y;
  sr.Left = sr.Right = dwEnd.X = 0;
  /* Can't increment dwEnd yet since we may not have space in
     the buffer.  */
  SetConsoleCursorPosition (h, dwEnd);
  if (shrink > 0)
    {
      COORD c = dwBufferSize;
      c.Y = dwEnd.Y - shrink;
      SetConsoleScreenBufferSize (h, c);
      SetConsoleScreenBufferSize (h, dwBufferSize);
      dwEnd.Y = 0;
      fillin (h);
      toscroll = 2 + dwEnd.Y - winTop;
    }

  sr.Top = sr.Bottom = toscroll;

d1226 1
a1226 2

  dwEnd.Y++;
a1227 3

  fillin (h);
  return true;
d1234 1
a1234 1
void __reg3
d1237 5
a1241 2
  HANDLE h = get_output_handle ();
  dev_state.fillin (h);
d1248 1
a1248 1
  /* Detect special case - scroll the screen if we have a buffer in order to
d1250 5
a1254 3
  if (!dev_state.scroll_window (h, x1, y1, x2, y2))
    dev_state.clear_screen (h, x1, y1, x2, y2);
}
d1256 1
a1256 6
void __reg3
dev_console::clear_screen (HANDLE h, int x1, int y1, int x2, int y2)
{
  COORD tlc;
  DWORD done;
  int num;
d1258 1
a1258 3
  num = abs (y1 - y2) * dwBufferSize.X + abs (x1 - x2) + 1;

  if ((y2 * dwBufferSize.X + x2) > (y1 * dwBufferSize.X + x1))
d1268 9
a1276 2
  FillConsoleOutputCharacterA (h, ' ', num, tlc, &done);
  FillConsoleOutputAttribute (h, current_win32_attr, num, tlc, &done);
d1279 1
a1279 1
void __reg3
d1312 1
a1312 1
void __reg3
d1321 1
a1321 1
void __reg3
d2183 1
a2183 1
	      scroll_buffer (0, 0, -1, -1, 0, 1);
@


1.285.2.3
log
@* dev_console::scroll_buffer): Reinstate clipping region.
@
text
@d794 1
a794 1
  ScrollConsoleScreenBuffer (h, &sr1, &sr2, dest, &fill);
@


1.285.2.4
log
@* fhandler.h (fhandler_console::scroll_buffer_screen): New function.
* fhandler_console.cc (fhandler_console::scroll_buffer_screen): New function.
(fhandler_console::char_command): Use scroll_buffer_screen as appropriate.
(dev_console::scroll_buffer): Remove if 0'ed block.
@
text
@d795 12
a814 12
inline void
fhandler_console::scroll_buffer_screen (int x1, int y1, int x2, int y2, int xn, int yn)
{
  if (y1 >= 0)
    y1 += dev_state.winTop;
  if (y2 >= 0)
    y1 += dev_state.winTop;
  if (yn >= 0)
    yn += dev_state.winTop;
  dev_state.scroll_buffer (get_output_handle (), x1, y1, x2, y2, xn, yn);
}

d1856 1
a1856 1
      scroll_buffer_screen (0, n, -1, -1, 0, 0);
d1861 1
a1861 1
      scroll_buffer_screen (0, 0, -1, -1, 0, n);
d2201 1
a2201 1
	      scroll_buffer_screen (0, 0, -1, -1, 0, 1);
@


1.285.2.5
log
@* fhandler_console.cc (fhandler_console::char_command): Properly use calculated
value rather than directly using dev_state.args[0].
@
text
@d1842 1
a1842 1
      scroll_buffer (0, y + n, -1, -1, 0, y);
@


1.285.2.6
log
@* fhandler.h (fhandler_console::dwBufferSize): Delete.
(fhandler_console::dwCursorPosition): Ditto.
(fhandler_console::wAttributes): Ditto.
(fhandler_console::b): New field encompassing previously disparate screen
buffer info.
(fhandler_console::save_bufsize): Rename from savebufsiz
(fhandler_console::save_buf): Rename sfrom savebuf.
(fhandler_console::save_cursor): New field.
(fhandler_console::save_restore): New function.
(fhandler_console::con): Rename from dev_state.
(fhandler_console::focus_aware): Accommodate name change.
* fhandler_console.cc: Use 'b' field of dev_console throughout instead of
disparate names.  Accommodate dev_state -> con rename.
(dev_state:save_restore): New function.  Now attempts to save the entire screen
buffer rather than just the visible part.  Clear the buffer when saving, like
Linux.
(fhandler_console::char_command): Use con.save_restore() for Save/restore
screen sequence.
@
text
@d45 3
a47 3
#define con (shared_console_info->con)
#define srTop (con.b.srWindow.Top + con.scroll_region.Top)
#define srBottom ((con.scroll_region.Bottom < 0) ? con.b.srWindow.Bottom : con.b.srWindow.Top + con.scroll_region.Bottom)
d175 10
a184 10
	con.scroll_region.Bottom = -1;
	con.dwLastCursorPosition.X = -1;
	con.dwLastCursorPosition.Y = -1;
	con.dwLastMousePosition.X = -1;
	con.dwLastMousePosition.Y = -1;
	con.dwLastButtonState = 0;	/* none pressed */
	con.last_button_code = 3;	/* released */
	con.underline_color = FOREGROUND_GREEN | FOREGROUND_BLUE;
	con.dim_color = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
	con.meta_mask = LEFT_ALT_PRESSED;
d195 3
a197 3
	  con.meta_mask |= RIGHT_ALT_PRESSED;
	con.set_default_attr ();
	con.backspace_keycode = CERASE;
d241 3
a243 3
  bool old_mode = con.raw_win32_keyboard_mode;
  con.raw_win32_keyboard_mode = new_mode;
  syscall_printf ("raw keyboard mode %sabled", con.raw_win32_keyboard_mode ? "en" : "dis");
d250 7
a256 3
  con.fillin (get_output_handle ());
  if (con.dwLastCursorPosition.X != con.b.dwCursorPosition.X ||
      con.dwLastCursorPosition.Y != con.b.dwCursorPosition.Y)
d258 2
a259 2
      SetConsoleCursorPosition (get_output_handle (), con.b.dwCursorPosition);
      con.dwLastCursorPosition = con.b.dwCursorPosition;
d266 3
a268 3
  SHORT y = con.dwWinSize.Y;
  SHORT x = con.dwWinSize.X;
  con.fillin (get_output_handle ());
d270 1
a270 1
  if (y != con.dwWinSize.Y || x != con.dwWinSize.X)
d272 2
a273 2
      con.scroll_region.Top = 0;
      con.scroll_region.Bottom = -1;
d282 1
a282 1
  if (!con.use_mouse)
d292 2
a293 2
  con.dwMousePosition.X = mouse_event.dwMousePosition.X - now.srWindow.Left;
  con.dwMousePosition.Y = mouse_event.dwMousePosition.Y - now.srWindow.Top;
d296 1
a296 1
	  && mouse_event.dwButtonState != con.dwLastButtonState)
d299 4
a302 4
	     && (con.dwMousePosition.X != con.dwLastMousePosition.X
		 || con.dwMousePosition.Y != con.dwLastMousePosition.Y)
	     && ((con.use_mouse >= 2 && mouse_event.dwButtonState)
		 || con.use_mouse >= 3));
d374 1
a374 1
	  con.nModifiers = 0;
d383 1
a383 1
	      set_raw_win32_keyboard_mode (!con.raw_win32_keyboard_mode);
d388 1
a388 1
	  if (con.raw_win32_keyboard_mode)
d421 1
a421 1
	    con.nModifiers |= 1;
d423 1
a423 1
	    con.nModifiers |= 2;
d425 1
a425 1
	    con.nModifiers |= 4;
d427 1
a427 1
	    con.nModifiers |= 8;
d432 1
a432 1
	      char c = con.backspace_keycode;
d436 1
a436 1
		  if (con.metabit)
d457 1
a457 1
		  con.nModifiers = 0;
d464 1
a464 1
	      nread = con.con_to_str (tmp + 1, 59, wch);
d488 1
a488 1
	      else if (con.metabit)
d499 1
a499 1
		  con.nModifiers &= ~4;
d553 1
a553 1
			b = con.last_button_code;
d555 1
a555 1
		    else if (mouse_event.dwButtonState < con.dwLastButtonState && !con.ext_mouse_mode6)
d560 1
a560 1
		    else if ((mouse_event.dwButtonState & 1) != (con.dwLastButtonState & 1))
d565 1
a565 1
		    else if ((mouse_event.dwButtonState & 2) != (con.dwLastButtonState & 2))
d570 1
a570 1
		    else if ((mouse_event.dwButtonState & 4) != (con.dwLastButtonState & 4))
d576 2
a577 2
		    if (con.ext_mouse_mode6 /* distinguish release */
			&& mouse_event.dwButtonState < con.dwLastButtonState)
d580 1
a580 1
		    con.last_button_code = b;
d590 1
a590 1
			con.dwLastButtonState = mouse_event.dwButtonState;
d595 2
a596 2
		con.dwLastMousePosition.X = con.dwMousePosition.X;
		con.dwLastMousePosition.Y = con.dwMousePosition.Y;
d599 1
a599 1
		con.nModifiers = 0;
d601 1
a601 1
		    con.nModifiers |= 0x4;
d603 1
a603 1
		    con.nModifiers |= 0x8;
d605 1
a605 1
		    con.nModifiers |= 0x10;
d608 1
a608 1
		b |= con.nModifiers;
d611 1
a611 1
		if (con.ext_mouse_mode6)
d614 2
a615 2
				     con.dwMousePosition.X + 1,
				     con.dwMousePosition.Y + 1,
d619 1
a619 1
		else if (con.ext_mouse_mode15)
d622 2
a623 2
				     con.dwMousePosition.X + 1,
				     con.dwMousePosition.Y + 1);
d626 1
a626 1
		else if (con.ext_mouse_mode5)
d628 2
a629 2
		    unsigned int xcode = con.dwMousePosition.X + ' ' + 1;
		    unsigned int ycode = con.dwMousePosition.Y + ' ' + 1;
d656 2
a657 2
		    unsigned int xcode = con.dwMousePosition.X + ' ' + 1;
		    unsigned int ycode = con.dwMousePosition.Y + ' ' + 1;
d667 2
a668 2
				con.dwMousePosition.X,
				con.dwMousePosition.Y);
d676 1
a676 1
	  if (con.use_focus)
d739 1
d741 1
a741 2
  b.cbSize = sizeof (b);
  if ((ret = GetConsoleScreenBufferInfoEx (h, &b)))
d743 5
a747 3
      dwWinSize.Y = 1 + b.srWindow.Bottom - b.srWindow.Top;
      dwWinSize.X = 1 + b.srWindow.Right - b.srWindow.Left;
      if (b.dwSize.Y != b.dwSize.Y || b.dwSize.X != b.dwSize.X)
d749 6
a754 3
      if (b.dwCursorPosition.Y > dwEnd.Y
	  || (b.dwCursorPosition.Y >= dwEnd.Y && b.dwCursorPosition.X > dwEnd.X))
	dwEnd = b.dwCursorPosition;
a757 1
      memset (&b, 0, sizeof (b));
d760 1
a760 2
      b.srWindow.Bottom = 24;
      b.srWindow.Right = 79;
d783 1
a783 1
  sr1.Top = y1 >= 0 ? y1 : b.srWindow.Bottom;
d785 2
a786 2
  sr1.Bottom = y2 >= 0 ? y2 : b.srWindow.Bottom;
  sr2.Top = b.srWindow.Top + scroll_region.Top;
d788 1
a788 1
  sr2.Bottom = (scroll_region.Bottom < 0) ? b.srWindow.Bottom : b.srWindow.Top + scroll_region.Bottom;
d793 1
a793 1
  dest.Y = yn >= 0 ? yn : b.srWindow.Bottom;
d800 1
a800 1
  con.scroll_buffer (get_output_handle (), x1, y1, x2, y2, xn, yn);
d807 1
a807 1
    y1 += con.b.srWindow.Top;
d809 1
a809 1
    y1 += con.b.srWindow.Top;
d811 2
a812 2
    yn += con.b.srWindow.Top;
  con.scroll_buffer (get_output_handle (), x1, y1, x2, y2, xn, yn);
d863 1
a863 1
  if (con.fillin (get_output_handle ()))
d865 4
a868 4
      con.current_win32_attr = con.b.wAttributes;
      if (!con.default_color)
	con.default_color = con.b.wAttributes;
      con.set_default_attr ();
d915 1
a915 1
	st = con.fillin (get_output_handle ());
d920 2
a921 2
	    ((struct winsize *) arg)->ws_row = con.dwWinSize.Y;
	    ((struct winsize *) arg)->ws_col = con.dwWinSize.X;
d938 1
a938 1
	*(int *) arg = (con.metabit) ? K_METABIT : K_ESCPREFIX;
d942 1
a942 1
	  con.metabit = TRUE;
d944 1
a944 1
	  con.metabit = FALSE;
d954 1
a954 1
	    *(unsigned char *) arg = (unsigned char) con.nModifiers;
d1199 2
a1200 2
    return b.dwSize.X - 1;
  return b.dwCursorPosition.X;
d1209 1
a1209 1
    return b.srWindow.Top;
d1211 1
a1211 1
    return b.srWindow.Bottom;
d1213 2
a1214 2
    return b.dwSize.Y - 1;
  return b.dwCursorPosition.Y;
d1220 2
a1221 2
  if (save_buf || x1 != 0 || x2 != dwWinSize.X - 1 || y1 != b.srWindow.Top
      || y2 != b.srWindow.Bottom || b.dwSize.Y <= dwWinSize.Y)
d1225 2
a1226 2
  int toscroll = 2 + dwEnd.Y - b.srWindow.Top;
  int shrink = 1 + toscroll + b.srWindow.Bottom - b.dwSize.Y;
d1233 1
a1233 1
      COORD c = b.dwSize;
d1236 1
a1236 1
      SetConsoleScreenBufferSize (h, b.dwSize);
d1239 1
a1239 1
      toscroll = 2 + dwEnd.Y - b.srWindow.Top;
d1261 1
a1261 1
  con.fillin (h);
d1263 4
a1266 4
  int x1 = con.set_cl_x (xc1);
  int y1 = con.set_cl_y (yc1);
  int x2 = con.set_cl_x (xc2);
  int y2 = con.set_cl_y (yc2);
d1270 2
a1271 2
  if (!con.scroll_window (h, x1, y1, x2, y2))
    con.clear_screen (h, x1, y1, x2, y2);
d1281 1
a1281 1
  num = abs (y1 - y2) * b.dwSize.X + abs (x1 - x2) + 1;
d1283 1
a1283 1
  if ((y2 * b.dwSize.X + x2) > (y1 * b.dwSize.X + x1))
d1302 1
a1302 1
  con.fillin (get_output_handle ());
d1304 1
a1304 1
  /* Setting y to the current b.srWindow.Bottom here is the reason that the window
d1311 2
a1312 2
  if (y > con.b.srWindow.Bottom)
    y = con.b.srWindow.Bottom;
d1318 1
a1318 1
    y += con.b.srWindow.Top;
d1320 2
a1321 2
  if (x > con.dwWinSize.X)
    x = con.dwWinSize.X - 1;
d1333 3
a1335 3
  con.fillin (get_output_handle ());
  x += con.b.dwCursorPosition.X;
  y += con.b.dwCursorPosition.Y;
d1342 3
a1344 3
  con.fillin (get_output_handle ());
  *y = con.b.dwCursorPosition.Y;
  *x = con.b.dwCursorPosition.X;
d1386 3
a1388 3
  if (con.iso_2022_G1
	? con.vt100_graphics_mode_G1
	: con.vt100_graphics_mode_G0)
d1437 1
a1437 1
			  SMALL_RECT region)
a1460 57
void
dev_console::save_restore (HANDLE h, char c)
{
  if (c == 'h') /* save */
    {
      fillin (h);
      save_bufsize = b.dwSize;		/* Assume starting from 0/0 */

      if (save_buf)
	cfree (save_buf);
      size_t screen_size = sizeof (CHAR_INFO) * save_bufsize.X * save_bufsize.Y;
      save_buf = (PCHAR_INFO) cmalloc_abort (HEAP_1_BUF, screen_size);

      save_cursor = b.dwCursorPosition;	/* Remember where we were. */

      SMALL_RECT now = {};		/* Read the whole buffer */
      now.Bottom = b.dwSize.Y - 1;
      now.Right = b.dwSize.X - 1;
      if (!ReadConsoleOutputWrapper (h, save_buf, save_bufsize, now))
	debug_printf ("ReadConsoleOutputWrapper(h, ...) failed during save, %E");

      /* Position at top of buffer */
      COORD cob = {};
      if (!SetConsoleCursorPosition (h, cob))
	debug_printf ("SetConsoleCursorInfo(%p, ...) failed during save, %E", h);

      /* Clear entire buffer */
      clear_screen (h, 0, 0, now.Right, now.Bottom);
      b.dwCursorPosition.X = b.dwCursorPosition.Y = dwEnd.X = dwEnd.Y = 0;
    }
  else if (save_buf)
    {
      /* Restore original buffer size, just in case.  */
      if (!SetConsoleScreenBufferSize (h, save_bufsize))
	debug_printf ("SetConsoleScreenBufferSize(h, ...) failed during restore, %E", h);

      /* Position where we were previously */
      if (!SetConsoleCursorPosition (h, save_cursor))
	debug_printf ("SetConsoleCursorInfo(%p, ...) failed during restore, %E", h);

      /* Get back correct version of buffer information */
      dwEnd.X = dwEnd.Y = 0;
      fillin (h);
      COORD cob = {};
      SMALL_RECT now = {};
      now.Bottom = b.dwSize.Y - 1;
      now.Right = b.dwSize.X - 1;
      /* Restore whole buffer */
      BOOL res = WriteConsoleOutputW (h, save_buf, save_bufsize, cob, &now);
      if (!res)
	debug_printf ("WriteConsoleOutputW failed, %E");

      cfree (save_buf);
      save_buf = NULL;
    }
}

d1522 2
a1523 2
       for (int i = 0; i <= con.nargs; i++)
	 switch (con.args[i])
d1526 1
a1526 1
	       con.set_default_attr ();
d1529 1
a1529 1
	       con.intensity = INTENSITY_BOLD;
d1532 1
a1532 1
	       con.intensity = INTENSITY_DIM;
d1535 1
a1535 1
	       con.underline = 1;
d1538 1
a1538 1
	       con.blink = true;
d1541 1
a1541 1
	       con.reverse = true;
d1544 1
a1544 1
	       con.intensity = INTENSITY_INVISIBLE;
d1547 1
a1547 1
	       con.alternate_charset_active = false;
d1550 1
a1550 1
	       con.alternate_charset_active = true;
d1554 1
a1554 1
	       con.intensity = INTENSITY_NORMAL;
d1557 1
a1557 1
	       con.underline = false;
d1560 1
a1560 1
	       con.blink = false;
d1563 1
a1563 1
	       con.reverse = false;
d1566 1
a1566 1
	       con.fg = 0;
d1569 1
a1569 1
	       con.fg = FOREGROUND_RED;
d1572 1
a1572 1
	       con.fg = FOREGROUND_GREEN;
d1575 1
a1575 1
	       con.fg = FOREGROUND_RED | FOREGROUND_GREEN;
d1578 1
a1578 1
	       con.fg = FOREGROUND_BLUE;
d1581 1
a1581 1
	       con.fg = FOREGROUND_RED | FOREGROUND_BLUE;
d1584 1
a1584 1
	       con.fg = FOREGROUND_BLUE | FOREGROUND_GREEN;
d1587 1
a1587 1
	       con.fg = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED;
d1590 1
a1590 1
	       con.fg = con.default_color & FOREGROUND_ATTR_MASK;
d1593 1
a1593 1
	       con.bg = 0;
d1596 1
a1596 1
	       con.bg = BACKGROUND_RED;
d1599 1
a1599 1
	       con.bg = BACKGROUND_GREEN;
d1602 1
a1602 1
	       con.bg = BACKGROUND_RED | BACKGROUND_GREEN;
d1605 1
a1605 1
	       con.bg = BACKGROUND_BLUE;
d1608 1
a1608 1
	       con.bg = BACKGROUND_RED | BACKGROUND_BLUE;
d1611 1
a1611 1
	       con.bg = BACKGROUND_BLUE | BACKGROUND_GREEN;
d1614 1
a1614 1
	       con.bg = BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED;
d1617 1
a1617 1
	       con.bg = con.default_color & BACKGROUND_ATTR_MASK;
d1620 1
a1620 1
       con.set_color (get_output_handle ());
d1623 1
a1623 1
      if (con.saw_space)
d1627 1
a1627 1
	    switch (con.args[0])
d1641 1
a1641 1
		  console_cursor_info.dwSize = con.args[0];
d1649 1
a1649 1
      if (!con.saw_question_mark)
d1651 1
a1651 1
	  switch (con.args[0])
d1654 2
a1655 2
	      con.insert_mode = (c == 'h') ? true : false;
	      syscall_printf ("insert mode %sabled", con.insert_mode ? "en" : "dis");
d1660 1
a1660 1
      switch (con.args[0])
d1674 46
a1719 1
	  con.save_restore (get_output_handle (), c);
d1723 1
a1723 1
	  con.backspace_keycode = (c == 'h' ? CTRL('H') : CERASE);
d1727 1
a1727 1
	  con.use_mouse = (c == 'h') ? 1 : 0;
d1731 1
a1731 1
	  con.use_mouse = (c == 'h') ? 2 : 0;
d1735 1
a1735 1
	  con.use_mouse = (c == 'h') ? 3 : 0;
d1739 1
a1739 1
	  con.use_focus = (c == 'h') ? true : false;
d1743 1
a1743 1
	  con.ext_mouse_mode5 = c == 'h';
d1747 1
a1747 1
	  con.ext_mouse_mode6 = c == 'h';
d1751 1
a1751 1
	  con.ext_mouse_mode15 = c == 'h';
d1759 1
a1759 1
	  syscall_printf ("unknown h/l command: %d", con.args[0]);
d1764 1
a1764 1
      switch (con.args[0])
d1783 1
a1783 1
      cursor_rel (0, -(con.args[0] ?: 1));
d1786 1
a1786 1
      cursor_rel (0, con.args[0] ?: 1);
d1789 1
a1789 1
      cursor_rel (con.args[0] ?: 1, 0);
d1792 1
a1792 1
      cursor_rel (-(con.args[0] ?: 1),0);
d1795 1
a1795 1
      switch (con.args[0])
d1812 2
a1813 2
      cursor_set (true, (con.args[1] ?: 1) - 1,
			(con.args[0] ?: 1) - 1);
d1817 1
a1817 1
      cursor_set (false, (con.args[0] ? con.args[0] - 1 : 0), y);
d1821 1
a1821 1
      cursor_set (true, x, (con.args[0] ? con.args[0] - 1 : 0));
d1824 2
a1825 2
      cursor_get (&con.savex, &con.savey);
      con.savey -= con.b.srWindow.Top;
d1828 1
a1828 1
      cursor_set (true, con.savex, con.savey);
d1835 1
a1835 1
      n = con.args[0] ?: 1;
d1840 1
a1840 1
      n = con.args[0] ?: 1;
d1845 1
a1845 1
      n = con.args[0] ?: 1;
d1850 1
a1850 1
      n = con.args[0] ?: 1;
d1855 1
a1855 1
      n = con.args[0] ?: 1;
d1859 2
a1860 2
      con.fillin (get_output_handle ());
      n = con.b.srWindow.Top + con.args[0] ?: 1;
d1864 1
a1864 1
      n = con.args[0] ?: 1;
d1874 1
a1874 1
      if (con.insert_mode)
d1877 1
a1877 1
	  scroll_buffer (x, y, -1, y, x + con.args[1], y);
d1879 2
a1880 2
      while (con.args[1]--)
	WriteFile (get_output_handle (), &con.args[0], 1, (DWORD *) &x, 0);
d1883 1
a1883 1
      if (con.saw_greater_than_sign)
d1896 1
a1896 1
      switch (con.args[0])
d1900 2
a1901 2
	  y -= con.b.srWindow.Top;
	  /* x -= con.b.srWindow.Left;		// not available yet */
d1910 2
a1911 2
      con.scroll_region.Top = con.args[0] ? con.args[0] - 1 : 0;
      con.scroll_region.Bottom = con.args[1] ? con.args[1] - 1 : -1;
d1943 1
a1943 1
  UINT cp = con.get_console_cp ();
d1993 1
a1993 1
	  buf_len = con.str_to_con (f_mbtowc, charset, write_buf,
d2039 1
a2039 1
      buf_len = con.str_to_con (f_mbtowc, charset, write_buf,
d2049 1
a2049 1
      if (con.insert_mode)
d2074 1
a2074 1
	  con.iso_2022_G1 = true;
d2077 1
a2077 1
	  con.iso_2022_G1 = false;
d2083 1
a2083 1
	  con.state = gotesc;
d2089 1
a2089 1
	      if (y >= con.b.srWindow.Bottom && !con.scroll_region.Top)
d2165 2
a2166 2
      paranoid_printf ("char %0c state is %d", *src, con.state);
      switch (con.state)
d2176 7
a2182 7
	      con.state = gotsquare;
	      con.saw_question_mark = false;
	      con.saw_greater_than_sign = false;
	      con.saw_space = false;
	      for (con.nargs = 0; con.nargs < MAXARGS; con.nargs++)
		con.args[con.nargs] = 0;
	      con.nargs = 0;
d2186 3
a2188 3
	      con.rarg = 0;
	      con.my_title_buf[0] = '\0';
	      con.state = gotrsquare;
d2192 1
a2192 1
	      con.state = gotparen;
d2196 1
a2196 1
	      con.state = gotrparen;
d2200 1
a2200 1
	      con.fillin (get_output_handle ());
d2202 1
a2202 1
	      con.state = normal;
d2206 4
a2209 4
	      con.set_default_attr ();
	      con.vt100_graphics_mode_G0 = false;
	      con.vt100_graphics_mode_G1 = false;
	      con.iso_2022_G1 = false;
d2212 1
a2212 1
	      con.state = normal;
d2216 2
a2217 2
	      cursor_set (true, con.savex, con.savey);
	      con.state = normal;
d2221 3
a2223 3
	      cursor_get (&con.savex, &con.savey);
	      con.savey -= con.b.srWindow.Top;
	      con.state = normal;
d2226 1
a2226 1
	      con.state = normal;
d2229 1
a2229 1
	      con.state = normal;
d2236 1
a2236 1
	      con.args[con.nargs] = con.args[con.nargs] * 10 + *src - '0';
d2242 3
a2244 3
	      con.nargs++;
	      if (con.nargs >= MAXARGS)
		con.nargs--;
d2249 2
a2250 2
	      con.saw_space = true;
	      con.state = gotcommand;
d2253 1
a2253 1
	    con.state = gotcommand;
d2257 1
a2257 1
	  con.state = normal;
d2261 3
a2263 3
	    con.rarg = con.rarg * 10 + (*src - '0');
	  else if (*src == ';' && (con.rarg == 2 || con.rarg == 0))
	    con.state = gettitle;
d2265 1
a2265 1
	    con.state = eattitle;
d2271 1
a2271 1
	    int n = strlen (con.my_title_buf);
d2274 3
a2276 3
		if (*src == '\007' && con.state == gettitle)
		  set_console_title (con.my_title_buf);
		con.state = normal;
d2280 2
a2281 2
		con.my_title_buf[n++] = *src;
		con.my_title_buf[n] = '\0';
d2289 2
a2290 2
	      con.state = gotarg1;
	      con.nargs++;
d2294 1
a2294 1
	    con.state = gotcommand;
d2298 1
a2298 1
		con.saw_question_mark = true;
d2300 1
a2300 1
		con.saw_greater_than_sign = true;
d2305 1
a2305 1
	    con.state = gotarg1;
d2309 1
a2309 1
	    con.vt100_graphics_mode_G0 = true;
d2311 2
a2312 2
	    con.vt100_graphics_mode_G0 = false;
	  con.state = normal;
d2317 1
a2317 1
	    con.vt100_graphics_mode_G1 = true;
d2319 2
a2320 2
	    con.vt100_graphics_mode_G1 = false;
	  con.state = normal;
@


1.285.2.7
log
@* fhandler_console.cc (fhandler_console::save_restore): Save only until last
written row and, because of this, don't bother trying to restore the screen
buffer size.  Set cursor position after refilling buffer.
(fhandler_console::write): Use absolute paths when saving/restoring cursor
position or suffer odd problems after a saved screen is restored.
@
text
@d1460 1
a1460 2
      save_bufsize.Y = dwEnd.Y + 1;		/* Assume starting from 0/0 */
      save_bufsize.X = b.dwSize.X;
d1470 2
a1471 2
      now.Bottom = save_bufsize.Y - 1;
      now.Right = save_bufsize.X - 1;
d1486 11
d1499 2
a1500 2
      now.Bottom = save_bufsize.Y - 1;
      now.Right = save_bufsize.X - 1;
a1507 7

      /* Position where we were previously */
      if (!SetConsoleCursorPosition (h, save_cursor))
	debug_printf ("SetConsoleCursorInfo(%p, ...) failed during restore, %E", h);
      /* Get back correct version of buffer information */
      dwEnd.X = dwEnd.Y = 0;
      fillin (h);
d2221 1
a2221 1
	      cursor_set (false, con.savex, con.savey);
d2227 1
@


1.285.2.8
log
@* fhandler_console.cc (dev_console::save_restore): Save entire line of current
cursor position.
@
text
@d1460 1
a1461 2
      if ((save_bufsize.Y = dwEnd.Y + 2) > b.dwSize.Y)
	save_bufsize.X = b.dwSize.Y;
@


1.285.2.9
log
@* fhandler.h (dev_console::b): Redefine as CONSOLE_SCREEN_BUFFER_INFO for use
with older OS.
* fhandler_console.cc (dev_console::fillin): Ditto for
GetConsoleScreenBufferInfo.
@
text
@d736 2
a737 1
  if ((ret = GetConsoleScreenBufferInfo (h, &b)))
@


1.285.2.10
log
@2014-05-19  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (try_to_debug): Fix size of dbg_cmd (CID 59929).

2014-05-18  David Stacey  <drstacey@@tiscali.co.uk>

	* syscalls.cc (getusershell): Fix buffer overrun (Coverity ID 59932).

2014-05-13  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::ioctl): Handle the different
	ideas of u_long between Winsock and Cygwin applications on x86_64.
	Add long comment.

2014-05-09  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* signal.cc (sigprocmask): Fix strace output to include "how".

	* fhandler_console.cc (dev_console::save_restore): Only save current
	dwEnd line rather than the one after that.

2014-05-05  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_getsockopt): Rearrange code slightly and handle
	TCP_NODELAY just like SO_KEEPALIVE and SO_DONTROUTE.

2014-05-03  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* spawn.cc (av::setup): Eat trailing whitespace on #! script.

2014-05-02  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* fhandler_dsp.cc (ioctl): Use _ioctl for recursive call.

2014-04-26  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* DevNotes: Add entry cgf-000026.
	* fhandler.h (fhandler_console::save_top): Save top of screen
	coordinates.
	* fhandler_console.cc (dev::save_restore): Record top of screen
	coordinates.  Clear entire buffer when restoring saved buffer and try
	to position the cursor on the save relative place on the screen.

2014-04-25  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (NT_TRANSACTIONAL_ERROR): Cover all status codes up to
	STATUS_TRANSACTION_NOT_ENLISTED.

2014-04-24  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	(get_inet_addr): Convert ANY address to LOOPBACK address.  Explain why.
	(fhandler_socket::evaluate_events): Forcibly set SO_ERROR socket option
	in case a connection attempt failed.  Explain why.
	(fhandler_socket::ioctl): Drop x86_64 re-definition of u_long here.
	* fhandler_procnet.cc: On x86_64, define u_long as __ms_u_long before
	including the windows headers.  Explain why.
	* net.cc: Ditto.

2014-04-23  Corinna Vinschen  <corinna@@vinschen.de>

	* miscfuncs.cc (check_iovec): Allow 0 as valid iovcnt value.

2014-04-18  Corinna Vinschen  <corinna@@vinschen.de>

	* winf.cc (linebuf::fromargv): Temporarily revert patch from 2014-01-24.

2014-04-16  Corinna Vinschen  <corinna@@vinschen.de>

	* net.cc (cygwin_setsockopt): Ignore IPV6_TCLASS the same way as IP_TOS.

2014-04-08  Corinna Vinschen  <corinna@@vinschen.de>

	* cygwin.sc.in: (Temporarily?) workaround serious ld bug which
	truncates symbols in certain computations to 32 bit.  See
	https://sourceware.org/bugzilla/show_bug.cgi?id=16821

2014-04-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Only handle the minimum
	amount of exceptions the myfault handler was designed for.
@
text
@a86 1

d1460 1
a1460 1
      if ((save_bufsize.Y = dwEnd.Y + 1) > b.dwSize.Y)
a1468 1
      save_top = b.srWindow.Top;
a1491 1
      clear_screen (h, 0, 0, b.dwSize.X - 1, b.dwSize.Y - 1);
a1498 6
      cob.X = 0;
      cob.Y = save_top;
      /* CGF: NOOP?  Doesn't seem to position screen as expected */
      /* Temporarily position at top of screen */
      if (!SetConsoleCursorPosition (h, cob))
	debug_printf ("SetConsoleCursorInfo(%p, cob) failed during restore, %E", h);
d1501 1
a1501 1
	debug_printf ("SetConsoleCursorInfo(%p, save_cursor) failed during restore, %E", h);
d1673 1
a1673 1
	    GetConsoleCursorInfo (get_output_handle (), &console_cursor_info);
d1680 1
a1680 1
		  SetConsoleCursorInfo (get_output_handle (), &console_cursor_info);
d1685 1
a1685 1
		  SetConsoleCursorInfo (get_output_handle (), &console_cursor_info);
d1689 1
a1689 1
		  SetConsoleCursorInfo (get_output_handle (), &console_cursor_info);
@


1.284
log
@* fhandler.h: Update copyright.
(cltype): New enum.
(dev_console::console_attrs): Define struct name.
(dev_console::console_attrs::set_cl_x): New function.
(dev_console::console_attrs::set_cl_y): New function.
(fhandler_console::clear_screen): Redefine input params.
* fhandler_console.cc: Update copyright.  Throughout, reflect change in
arguments to fhandler_console::clear_screeen.
(fhandler_console::mouse_aware): Simplify logic slightly.
(fhandler_console::scroll_screen): Remove hopefully obsolete win95 code.
(dev_console::console_attrs::set_cl_x): New function.
(dev_console::console_attrs::set_cl_y): New function.
(fhandler_console::clear_screen): Redefine input params.  Calculate position
based on enum value.
(region_split): Change arguments.  Simplify.
(ReadConsoleOutputWrapper): Remove coord argument since we now always use 0, 0.
Send extra arguments to region_split.
@
text
@a44 8
/*
 * Scroll the screen context.
 * x1, y1 - ul corner
 * x2, y2 - dr corner
 * xn, yn - new ul corner
 * Negative values represents current screen dimensions
 */

d763 6
d1194 1
a1194 1
  if (x == cl_disp_beg)
d1198 2
d1206 4
d1212 2
a1213 2
  if (y == cl_disp_beg)
    return winTop;
d2171 2
a2172 2
	      clear_screen (cl_disp_beg, cl_disp_beg, cl_disp_end, cl_disp_end);
	      cursor_set (true, 0, 0);
@


1.283
log
@* fhandler_console.cc (region_split): New function.
(delta): Ditto.
(ReadConsoleOutputWrapper): Ditto.
(fhandler_console::char_command): Use ReadConsoleOutputWrapper to avoid OOM
condition from ReadConsoleOutputW.  Add more debugging.
@
text
@d4 1
a4 1
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
d297 6
a302 10
  if (GetConsoleScreenBufferInfo (get_output_handle (), &now))
    {
      dev_state.dwMousePosition.X = mouse_event.dwMousePosition.X - now.srWindow.Left;
      dev_state.dwMousePosition.Y = mouse_event.dwMousePosition.Y - now.srWindow.Top;
    }
  else
    {
      /* Cannot adjust position by window scroll buffer offset */
      return 0;
    }
a313 65
/* The following three functions were adapted (i.e., mildly modified) from
   http://stackoverflow.com/questions/14699043/replacement-to-systemcolor */

/* Split a rectangular region into two smaller rectangles based on the
   largest dimension. */
static void
region_split (SHORT width, SHORT height, COORD coord,
	      const SMALL_RECT& region, COORD& coord_a,
	      SMALL_RECT& region_a, COORD& coord_b,
	      SMALL_RECT& region_b)
{
  coord_a = coord_b = coord;
  region_a = region_b = region;

  if (height >= width)
    {
      SHORT half = height / 2;
      coord_b.Y += half;
      region_b.Top += half;
      region_a.Bottom = region_b.Top - 1;
    }
  else
    {
      SHORT half = width / 2;
      coord_b.X += half;
      region_b.Left += half;
      region_a.Right = region_b.Left - 1;
    }
}

/* Utility function to figure out the distance between two points. */
static SHORT
delta (SHORT first, SHORT second)
{
  return (second >= first) ? (second - first + 1) : 0;
}

/* Subdivide the ReadConsoleInput operation into smaller and smaller chunks as
   needed until it succeeds in reading the entire screen buffer. */
static BOOL
ReadConsoleOutputWrapper (HANDLE h, PCHAR_INFO buf,
			  COORD bufsiz, COORD coord,
			  SMALL_RECT& region)
{
  SHORT width = delta (region.Left, region.Right);
  SHORT height = delta (region.Top, region.Bottom);

  if ((width == 0) || (height == 0))
    return TRUE;

  BOOL success = ReadConsoleOutputW (h, buf, bufsiz, coord, &region);
  if (success)
    /* it worked */;
  else if (GetLastError () == ERROR_NOT_ENOUGH_MEMORY && (width * height) > 1)
    {
      COORD coord_a, coord_b;
      SMALL_RECT region_a, region_b;
      region_split (width, height, coord, region, coord_a, region_a,
		    coord_b, region_b);
      success = ReadConsoleOutputWrapper (h, buf, bufsiz, coord_a, region_a)
		&& ReadConsoleOutputWrapper (h, buf, bufsiz, coord_b, region_b);
    }
  return success;
}

d804 1
d814 1
d1193 20
d1218 1
a1218 1
fhandler_console::clear_screen (int x1, int y1, int x2, int y2)
d1226 4
a1229 8
  if (x1 < 0)
    x1 = dev_state.info.dwWinSize.X - 1;
  if (y1 < 0)
    y1 = dev_state.info.winBottom;
  if (x2 < 0)
    x2 = dev_state.info.dwWinSize.X - 1;
  if (y2 < 0)
    y2 = dev_state.info.winBottom;
d1364 54
a1633 1
	      COORD cob = { 0, 0 };
d1638 3
a1640 2
	      dev_state.savebufsiz.X = now.srWindow.Right - now.srWindow.Left + 1;
	      dev_state.savebufsiz.Y = now.srWindow.Bottom - now.srWindow.Top + 1;
d1649 1
a1649 1
						   dev_state.savebufsiz, cob,
d1724 1
a1724 2
	  cursor_get (&x, &y);
	  clear_screen (x, y, -1, -1);
d1728 1
a1728 1
	  clear_screen (0, 0, x, y);
d1731 2
a1732 2
	  clear_screen (0, 0, -1, -1);
	  cursor_set (true, 0,0);
d1755 1
a1755 2
	    cursor_get (&x, &y);
	    clear_screen (x, y, -1, y);
d1758 1
a1758 2
	    cursor_get (&x, &y);
	    clear_screen (0, y, -1, y);
d1761 1
a1761 2
	    cursor_get (&x, &y);
	    clear_screen (0, y, x, y);
d2167 1
a2167 1
	      clear_screen (0, 0, -1, -1);
d2210 1
a2210 3
	    {
	      dev_state.state_ = gotcommand;
	    }
@


1.282
log
@	Throughout, drop unnecessary explicit includes of windows header files
	included by default.
	* winlean.h: Add long comment to explain why we have to define certain
	symbols.
	(_NORMALIZE_): Define.
	(_WINNLS_): Drop definition and subsequent undef.
	(_WINNETWK_): Ditto.
	(_WINSVC_): Ditto.

2013-11-23  Eric Blake  <eblake@@redhat.com>
@
text
@d318 65
d1641 2
a1642 2
	      dev_state.savebuf = (PCHAR_INFO) cmalloc_abort (HEAP_1_BUF, sizeof (CHAR_INFO) *
					     dev_state.savebufsiz.X * dev_state.savebufsiz.Y);
d1644 6
a1649 2
	      ReadConsoleOutputW (get_output_handle (), dev_state.savebuf,
				  dev_state.savebufsiz, cob, &now.srWindow);
d1653 3
d1660 4
a1663 4
		break;

	      if (!dev_state.savebuf)
		break;
d1665 4
a1668 2
	      WriteConsoleOutputW (get_output_handle (), dev_state.savebuf,
				   dev_state.savebufsiz, cob, &now.srWindow);
@


1.281
log
@* external.cc (fillout_pinfo): If start_time is 0, wait a while before
returning the pinfo structure.
* fhandler.cc (fhandler_base::open_setup): Convert from inline.
* fhandler.h (fhandler_base::open_setup): Declare.
* fhandler_console.cc (fhandler_console::open_setup): Always call
fhandler_base::open_setup.
* fhandler_tty.cc (fhandler_pty_slave::open_setup): Ditto.
(fhandler_pty_master::open_setup): Ditto.
@
text
@a16 3
#include <wingdi.h>
#include <winuser.h>
#include <winnls.h>
@


1.280
log
@Throughout, (mainly in fhandler*) fix remaining gcc 4.7 mismatch
warnings between regparm definitions and declarations.
* smallprint.cc (__small_vswprintf): Conditionalize declaration and
setting of l_opt for only x86_64.
* spawn.cc (child_info_spawn::worker): Remove unused 'pid' variable.
* thread.cc (verifyable_object_isvalid): Temporarily define as
non-inline with gcc 4.7+, regardless of target.
@
text
@d898 1
@


1.279
log
@	* Merge in cygwin-64bit-branch.
@
text
@d321 1
a321 1
void __stdcall
@


1.278
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d219 1
a219 1
  _dev_t n = myself->ctty;
d947 1
a947 1
	if ((int) arg == K_METABIT)
d949 1
a949 1
	else if ((int) arg == K_ESCPREFIX)
d1016 1
a1016 1
  syscall_printf ("%d = tcsetattr(,%x) (ENABLE FLAGS %x) (lflag %x oflag %x)",
d1078 1
a1078 1
      syscall_printf ("%d = tcsetattr(,%x) enable flags %p, c_lflag %p iflag %p",
d1129 1
a1129 1
  syscall_printf ("%d = tcgetattr(%p) enable flags %p, t->lflag %p, t->iflag %p",
d2047 1
a2047 1
  debug_printf ("%x, %d", vsrc, len);
d2214 1
a2214 1
  syscall_printf ("%d = fhandler_console::write(...)", len);
d2219 1
a2219 1
static struct {
d2222 1
a2222 1
} keytable[] NO_COPY = {
d2369 1
a2369 1
/* Ugly workaround for Windows 7.
@


1.277
log
@	* fhandler.h (class dev_console): Flag for expanded control sequence.
	* fhandler_console.cc (char_command): Supporting cursor style modes.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.276
log
@whitespace cleanup
@
text
@d4 1
a4 1
   2006, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc.
d1513 25
d1553 11
d1791 1
a1791 1
    default:
d2065 1
d2132 6
@


1.275
log
@* cygwait.cc (cancelable_wait): Add some debugging-only output.
* exceptions.cc (sig_handle_tty_stop): Make sure that incyg is cleared when
exiting if we have no parent process.  Only wait for signal_arrived.
(sigpacket::process): Make continue_now a bool.  Delay sending signal_arrived
until the end.  Make code more defensive to avoid calling signal handler when
stopped.  Only set signal_arrived when stopped.
* sigproc.cc (sig_hold): Rename from sigCONT.  Make static.
(sig_send): Accommodate sigCONT -> sig_hold rename.
(wait_sig): Ditto.
* sigproc.h (sigCONT): Delete declaration.
* fhandler_console.cc (fhandler_console::write): Use new '%0c' facility to
print characters.  Change to paranoid to avoid excessive strace output.
* fhandler_tty.cc (fhandler_pty_master::accept_input): Make frequent strace
printf "paranoid" to help cut down on strace output size.
* signal.cc (sigsuspend): Add standard syscall strace output.
(sigpause): Ditto.
(pause): Ditto.
* cygtls.h (_cygtls::reset_signal_arrived): New function.
@
text
@d594 1
a594 1
		        mode6_term = 'm';
d649 1
a649 1
		    /* the neat nested encoding function of mintty 
d695 1
a695 1
	        __small_sprintf (tmp, "\033[I");
d697 1
a697 1
	        __small_sprintf (tmp, "\033[O");
@


1.275.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d219 1
a219 1
  dev_t n = myself->ctty;
@


1.275.2.2
log
@	Pull in changes from HEAD
	ChangeLog.64bit: New file.
@
text
@d594 1
a594 1
			mode6_term = 'm';
d649 1
a649 1
		    /* the neat nested encoding function of mintty
d695 1
a695 1
		__small_sprintf (tmp, "\033[I");
d697 1
a697 1
		__small_sprintf (tmp, "\033[O");
@


1.275.2.3
log
@	* cygthread.cc: Fix usage of %p in debug printfs, throughout.
	* dcrt0.cc: Ditto.
	* dtable.cc: Ditto.
	* errno.cc: Ditto.
	* exceptions.cc: Ditto.
	* fhandler.cc: Ditto.
	* fhandler_console.cc: Ditto.
	* fhandler_disk_file.cc: Ditto.

	* fhandler_clipboard.cc (cygnativeformat): Define as UINT.
	(fhandler_dev_clipboard::read): Ditto for local format variable.
	Use casts to compare off_t with size_t value.
	* fhandler_console.cc (fhandler_console::ioctl): Avoid compiler
	warnings.
	* fhandler_disk_file.cc (fhandler_disk_file::opendir): Fix cast.
	* include/sys/dirent.h (struct __DIR): Define __d_internal as uintptr_t,
	rather than unsigned int.

	And pull in changes from HEAD.
@
text
@d947 1
a947 1
	if ((intptr_t) arg == K_METABIT)
d949 1
a949 1
	else if ((intptr_t) arg == K_ESCPREFIX)
d1078 1
a1078 1
      syscall_printf ("%d = tcsetattr(,%x) enable flags %y, c_lflag %y iflag %y",
d1129 1
a1129 1
  syscall_printf ("%d = tcgetattr(%p) enable flags %y, t->lflag %y, t->iflag %y",
@


1.275.2.4
log
@	* Throughout, fix format string of debug printf and api_fatal calls
	to work in 32 and 64 bit environment, as well as to honor signedness.
	Use %y instead of 0x%x.
	* fhandler.h (class fhandler_dev_mem): Change type of mem_size from
	DWORD to SIZE_T.
	* fhandler_mem.cc: Throughout, cast mem_size in comparisons to make
	GCC happy.
	* fhandler_process.cc (format_process_maps): Change type of ret_len
	to SIZE_T.
	(get_mem_values): Ditto for n and length.
	* mmap.cc (MapView): Ditto for commitsize and viewsize.
	(class mmap_record): Ditto for len.  Use SIZE_T througout for memory
	size in method args and return types.
	* ntdll.h (NtLockVirtualMemory): Fix type of memory size parameters
	to SIZE_T.
	(NtMapViewOfSection): Ditto.
	(NtQueryVirtualMemory): Ditto.
	(NtUnlockVirtualMemory): Ditto.
	(RtlFreeHeap): Change type of first parameter to HANDLE.
	* shm.cc (shmat): Change type of viewsize to SIZE_T.
	* timer.cc (timer_thread): Change type of sleep_ms to LONG.
	(ualarm): Drop casts to unsigned int in timer value computation.
@
text
@d1016 1
a1016 1
  syscall_printf ("%d = tcsetattr(,%p) (ENABLE FLAGS %y) (lflag %y oflag %y)",
d1078 1
a1078 1
      syscall_printf ("%d = tcsetattr(,%p) enable flags %y, c_lflag %y iflag %y",
d2011 1
a2011 1
  debug_printf ("%p, %ld", vsrc, len);
d2171 1
a2171 1
  syscall_printf ("%ld = fhandler_console::write(...)", len);
@


1.275.2.5
log
@Pull in changes from HEAD
@
text
@a1512 25
    case 'q': /* Set cursor style (DECSCUSR) */
      if (dev_state.saw_space)
	{
	    CONSOLE_CURSOR_INFO console_cursor_info;
	    GetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
	    switch (dev_state.args_[0])
	      {
		case 0: /* blinking block */
		case 1: /* blinking block (default) */
		case 2: /* steady block */
		  console_cursor_info.dwSize = 100;
		  SetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
		  break;
		case 3: /* blinking underline */
		case 4: /* steady underline */
		  console_cursor_info.dwSize = 10;	/* or Windows default 25? */
		  SetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
		  break;
		default: /* use value as percentage */
		  console_cursor_info.dwSize = dev_state.args_[0];
		  SetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
		  break;
	      }
	}
      break;
a1527 11
	case 25: /* Show/Hide Cursor (DECTCEM) */
	  {
	    CONSOLE_CURSOR_INFO console_cursor_info;
	    GetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
	    if (c == 'h')
	      console_cursor_info.bVisible = TRUE;
	    else
	      console_cursor_info.bVisible = FALSE;
	    SetConsoleCursorInfo (get_output_handle (), & console_cursor_info);
	    break;
	  }
d1755 1
a1755 1
      default:
a2028 1
	      dev_state.saw_space = false;
a2094 6
	  else if (*src == ' ')
	    {
	      src++;
	      dev_state.saw_space = true;
	      dev_state.state_ = gotcommand;
	    }
@


1.275.2.6
log
@Fix copyrights
@
text
@d4 1
a4 1
   2006, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.275.2.7
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008, 2009, 2010, 2011, 2012, 2013 Red Hat, Inc.
@


1.275.2.8
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d2219 1
a2219 1
static const struct {
d2222 1
a2222 1
} keytable[] = {
@


1.275.2.9
log
@	* fhandler_console.cc
	(fhandler_console::create_invisible_console_workaround): Fix comment.
	* wincap.cc: Throughout, remove unused has_console_handle_problem
	wincapc members.
	* wincap.h (struct wincaps): Remove has_console_handle_problem.
@
text
@d2369 1
a2369 1
/* Ugly workaround for Windows 7 and later.
@


1.274
log
@Add '#include "cygwait.h"' throughout, where appropriate.
* DevNotes: Add entry cgf-000012.
* Makefile.in (DLL_OFILES): Add cygwait.o.
* sigproc.h: Remove cygwait definitions.
* cygwait.h: New file.  Define/declare Cygwin waitfor functions.
* cygwait.cc: Ditto.
* exceptions.cc: Include cygwait.h.
(handle_sigsuspend): Accommodate change in cancelable_wait arguments.
(sigpacket::process): Display thread tls in debugging output.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use symbolic names
for signal and cancel return.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_dev_dsp::Audio_out::waitforspace): Ditto.
fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* select.cc (cygwin_select): Ditto.
* wait.cc (wait4): Ditto.
* thread.cc (cancelable_wait): Move definition to cygwait.h.
(pthread_cond::wait): Accommodate change in cancelable_wait arguments.
(pthread_mutex::lock): Ditto.
(pthread_spinlock::lock): Ditto.
(pthread::join): Ditto.
(pthread::thread_init_wrapper): Display tls in debugging output.
(semaphore::_timedwait): Ditto.
* thread.h (cw_sig_wait): Move to cygwait.h.
(cw_cancel_action): Delete.
(cancelable_wait): Move declaration to cygwait.h.
@
text
@d2015 1
a2015 2
      debug_printf ("at %d(%c) state is %d", *src, isprint (*src) ? *src : ' ',
		    dev_state.state_);
@


1.273
log
@	* fhandler.h (class dev_console): Add member ext_mouse_mode5.
	* fhandler_console.cc (fhandler_console::read): Implement extended
	mouse mode 1005 (xterm, mintty).
	Fix actual mouse reporting for large coordinates.
@
text
@d39 1
d359 1
a359 1
	case WAIT_OBJECT_0 + 1:
d361 1
a361 1
	case WAIT_OBJECT_0 + 2:
@


1.272
log
@	* fhandler_console.cc (ALT_PRESSED): Define earlier, never undefine.
	(CTRL_PRESSED): Ditto.
	(fhandler_console::read): Simplify expressions testing for pressed ALT
	or CTRL modifier keys.
	(get_nonascii_key): Ditto.
@
text
@a309 8
  /* Check whether adjusted mouse position can be reported */
  if (dev_state.dwMousePosition.X > 0xFF - ' ' - 1
      || dev_state.dwMousePosition.Y > 0xFF - ' ' - 1)
    {
      /* Mouse position out of reporting range */
      return 0;
    }

d641 28
a668 1
		/* else if (dev_state.ext_mouse_mode5) not implemented */
d1588 1
a1588 1
	  syscall_printf ("ignored h/l command for extended mouse mode");
@


1.271
log
@	* fhandler.h (class dev_console): Add members ext_mouse_mode6 and
	ext_mouse_mode15.
	* fhandler_console.cc (fhandler_console::read): Implement extended
	mouse modes 1015 (urxvt, mintty, xterm) and 1006 (xterm).  Recognize,
	but don't implement extended mouse mode 1005 (xterm, mintty).
	Support mouse coordinates greater than 222 (each axis).  Fix formatting.
	(fhandler_console::char_command): Initialize enhanced mouse reporting
	modes.
@
text
@d44 3
a426 2
#define ALT_PRESSED (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)
#define CTRL_PRESSED (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)
a526 2
#undef ALT_PRESSED
#undef CTRL_PRESSED
d625 1
a625 1
		if (mouse_event.dwControlKeyState & (RIGHT_ALT_PRESSED|LEFT_ALT_PRESSED))
d627 1
a627 1
		if (mouse_event.dwControlKeyState & (RIGHT_CTRL_PRESSED|LEFT_CTRL_PRESSED))
d2207 1
a2207 2
  if (input_rec.Event.KeyEvent.dwControlKeyState &
		(LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED))
d2213 1
a2213 2
	if ((input_rec.Event.KeyEvent.dwControlKeyState &
		(LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))
@


1.270
log
@wincap.h: Rename assitant to assistant throughout.  wincap.cc: Ditto.
* devices.in (exists_console): Use fhandler_console::exists () rather than raw
test.
* devices.cc: Regenerate.
* fhandler.h (fhandler_console::exists): Define new function.
* fhandler_console.cc (fhandler_console::need_invisible): Use
fhandler_console::exists () rather than raw test.
* spawn.cc: Rename assitant to assistant throughout.
(child_info_spawn::worker): Simplify test for when to start a non-Cygwin
process in its own process group.  Just do it whenever we start a non-Cygwin
process.
@
text
@d456 7
a462 6
	      if (control_key_state & ALT_PRESSED) {
		if (dev_state.metabit)
		  c |= 0x80;
		else
		  tmp[nread++] = '\e';
	      }
d555 1
d579 1
a579 1
		    else if (mouse_event.dwButtonState < dev_state.dwLastButtonState)
d600 4
d635 31
a665 2
		sprintf (tmp, "\033[M%c%c%c", b + ' ', dev_state.dwMousePosition.X + ' ' + 1, dev_state.dwMousePosition.Y + ' ' + 1);
		syscall_printf ("mouse: %s at (%d,%d)", sz, dev_state.dwMousePosition.X, dev_state.dwMousePosition.Y);
a667 1
		nread = 6;
d673 6
a678 5
	  if (dev_state.use_focus) {
	    if (input_rec.Event.FocusEvent.bSetFocus)
	      sprintf (tmp, "\033[I");
	    else
	      sprintf (tmp, "\033[O");
d680 3
a682 3
	    toadd = tmp;
	    nread = 3;
	  }
a1554 1
	  syscall_printf ("mouse support set to mode %d", dev_state.use_mouse);
a1558 1
	  syscall_printf ("mouse support set to mode %d", dev_state.use_mouse);
a1562 1
	  syscall_printf ("mouse support set to mode %d", dev_state.use_mouse);
d1567 12
a1578 1
	  syscall_printf ("focus reporting set to %d", dev_state.use_focus);
@


1.269
log
@* devices.in (exists_console): Allow /dev/con{sole,in,out} to be referenced
they exist.
* devices.cc: Regenerate.
* fhandler_console.cc (fhandler_console::set_unit): Ditto.
@
text
@d2374 1
a2374 1
  if (GetConsoleCP ())
@


1.268
log
@* dtable.cc (dtable::fixup_close): Define new function.
(dtable::fixup_after_exec): Use fixup_close() and detect when it was not
possible to open an inherited file handle.
(dtable::fixup_after_fork): Defensively close any file handles which were not,
for some reason, inheritable.
* dtable.h: Make #pragma once.
(dtable::fixup_close): Declare new function.
* fhandler_console.cc (fhandler_console::set_unit): Set I/O handles to NULL
when this function fails.
@
text
@d139 2
a142 1
      fh_devices this_unit = dev ();
d146 1
a146 1
		|| this_unit == FH_CONIN || this_unit == FH_CONOUT
d151 1
a151 1
  else if ((myself->ctty != -1 && !iscons_dev (myself->ctty))
@


1.267
log
@* fhandler_console.cc (fhandler_console::set_unit): Don't succeed unless we are
opening a console actually associated with this process.
@
text
@a143 1
      created = false;
d148 1
d152 1
a152 4
    {
      created = false;
      devset = FH_ERROR;
    }
d166 6
@


1.266
log
@* dtable.cc (fh_alloc): Treat pc.dev as unsigned.
* fhandler_console.cc (fhandler_console::set_unit): Use lock always to avoid
races between competing cygwin processes running on the console.
@
text
@d138 1
d150 6
a157 1
      HWND me = GetConsoleWindow ();
@


1.265
log
@	* Throughout, replace usage of w32api's min with MIN from sys/param.h.
@
text
@d137 1
d156 1
a156 4
	{
	  lock_ttys here;
	  shared_console_info->tty_min_state.setntty (DEV_CONS_MAJOR, console_unit (me));
	}
@


1.264
log
@* fhandler_console.cc (fhandler_console::dup): Only set ctty when we haven't
specifically called setsid.
* fhandler_tty.cc (fhandler_pty_slave::dup): Ditto.  Also add comment
documenting research into rxvt problem.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Don't check specifically
for myself->ctty == -1.  Test for > 0 as that is the correct test.
(fhandler_termios::sigflush): Ditto.
@
text
@d21 1
d1744 1
a1744 1
      int cp_len = min (end - src, 4 - trunc_buf.len);
@


1.263
log
@	* fhandler_console.cc (fhandler_console::input_tcsetattr): Revert
	prevois patch.
	(fhandler_console::open_setup): Install Ctrl-C handler here, if this
	console is the controlling tty and the process hasn't been started by
	a Cygwin process.
@
text
@d762 3
a764 1
  myself->set_ctty (this, flags);
@


1.262
log
@	* fhandler_console.cc (fhandler_console::input_tcsetattr): Set the
	state of the Ctrl-C handler depending on the setting of
	ENABLE_PROCESSED_INPUT.
@
text
@d831 2
a832 1
  myself->set_ctty (this, flags);
a1012 3
      else
	/* Set state of ctrl_c handler depending on ENABLE_PROCESSED_INPUT. */
	init_console_handler (flags & ENABLE_PROCESSED_INPUT);
@


1.261
log
@	* cygheap.cc (init_cygheap::init_installation_root): Convert function
	init_installation_root into a cygheap method.
	* cygheap.h (struct init_cygheap): Move installation_root,
	installation_key, and installation_key_buf from shared
	.cygwin_dll_common DLL section to cygheap.  Declare new method
	init_installation_root.
	* dtable.cc (handle_to_fn): Accommodate the move of installation strings
	to the cygheap.
	* external.cc (cygwin_internal): Ditto.
	* fhandler_console.cc (fhandler_console::open_shared_console): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Ditto.
	* fhandler_tty.cc: Ditto, throughout.
	* mount.cc (mount_info::init): Ditto.
	* pipe.cc (fhandler_pipe::create): Ditto.
	* shared.cc: Ditto, throughout.
	(installation_root): Remove.
	(installation_key): Move to cygheap.
	(installation_key_buf): Ditto.
	(installation_root_inited): Remove.
	(SPIN_WAIT): Remove.
	(init_installation_root): Move to cygheap.
	(memory_init): Call cygheap->init_installation_root right after
	cygheap->user.init.  Drop call of init_installation_root function.
	* shared_info.h (init_installation_root): Drop declaration.
	(installation_root): Ditto.
	(installation_key): Ditto.
	* uinfo.cc (pwdgrp::load): Accommodate the move of installation strings
	to the cygheap.
@
text
@d1012 3
@


1.260
log
@* cygheap.cc (init_cygheap::manage_console_count): Delete.
* cygheap.h (init_cygheap::manage_console_count): Ditto.
(init_cygheap::console_count): Ditto.
* fhandler.h (fhandler_console::has_a): Ditto.
(fhandler_console::free_console): Declare new function.
* fhandler_console.cc (fhandler_console::free_console): Define new function.
(fhandler_console::open_setup): Delete call to manage_console_count.
(fhandler_console::close): Ditto.  Replace with call to free_console().
* fhandler_tty.cc (fhandler_pty_slave::open): Delete call to
manage_console_count.
(fhandler_pty_slave::cleanup): Ditto.
(fhandler_pty_slave::close): Call fhandler_console::free_console() if this is
our controlling tty.
* pinfo.cc (_pinfo::set_ctty): Skip function if tty in question == our ctty.
Delete call to manage_console_count.
* syscalls.cc (close_all_files): Avoid locking and avoid setting errno when
iterating over fds.
@
text
@d85 1
a85 1
  __small_swprintf (namebuf, L"%S-cons%p", &installation_key, hw);
@


1.259
log
@Clean up whitespace.
@
text
@d4 1
a4 1
   2006, 2008, 2009, 2010, 2011 Red Hat, Inc.
a829 1
  cygheap->manage_console_count ("fhandler_console::open", 1);
d840 1
a840 1
    cygheap->manage_console_count ("fhandler_console::close", -1);
d2350 8
@


1.258
log
@* cygthread.h (cygthread::name): Very minor formatting tweak.
* exceptions.cc (_cygtls::call_signal_handler): Add paranoid debugging output.
* sigproc.h (cygwait): Call signal handler when signal is detected and loop as
appropriate.
* fhandler.h (fhandler_base_overlapped::wait_return): Remove overlapped_signal.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Remove restartable
signal accommodations in light of cygwait improvements.
(fhandler_base_overlapped::raw_read): Remove now-obsolete signal loop behavior.
(fhandler_base_overlapped::raw_write): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* fhandler_tty.cc (fhandler_pty_slave::read): Ditto.
* ioctl.cc (ioctl): Add standard syscall introducer and leaver debug output.
@
text
@d139 1
a139 1
      fh_devices shared_unit = 
@


1.257
log
@Rename cygWFMO to cygwait throughout and use the magic of polymorphism to "wait
for stuff".
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use simplified arg
form of cygwait.
* fhandler_console.cc (fhandler_console::read): Ditto.
* fhandler_audio.cc (fhandler_dev_dsp::Audio_out::waitforspac): Ditto.
(fhandler_dev_dsp::Audio_in::waitfordata): Ditto.
* fhandler_fifo.cc (fhandler_fifo::wait): Ditto.
* fhandler_serial.cc (fhandler_serial::raw_read): Ditto.
(fhandler_serial::raw_write): Ditto.
* select.cc (cygwin_select): Ditto.
* sigproc.h (cygwait): Rename from cygWFMO.  Define two argument and single
argument forms of this function.
* fhandler_tty.cc (fhandler_pty_slave::open): Use method to query if tty is
open.
(fhandler_pty_slave::read): Send SIGHUP when master is detected as closed.
(fhandler_pty_common::close): Close input_available_event in callers since
master may need to signal it first.
(fhandler_pty_master::close): Lie and set input_available_event when closing,
then close input_available_event.
(fhandler_pty_slave::close): Close input_available_event explicitly here.
* tty.h (tty::is_master_closed): Declare new method.
@
text
@a349 1
restart:
a354 2
	  if (_my_tls.call_signal_handler ())
	    goto restart;
@


1.256
log
@* exceptions.cc (exception::handle): Drop abbreviation for "exception" since I
never remember what it stands for.
(sig_handle_tty_stop): Remove obsolete call to sig_handle_tty_stop.
(_cygtls::call_signal_handler): Rework to grab signal information from
_main_tls if none is set for _my_tls.  Try harder to keep thread locked.
(reset_signal_arrived): Delete.
* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Use new cygWFMO call
to wait for an event + standard cygwin stuff.  Modify debug output to
acccomodate new function.
* fhandler_console.cc (fhandler_console::read): Replace WaitForMultipleObjects
with cygWFMO.
* fhandler_socket.cc (get_inet_addr): Add comment.
* gendef (_sigdelayed): Remove call to reset_signal_arrived.
* sigproc.cc (_cygtls::signal_exit): Don't close my_readsig here unless we're
in the signal thread.
(create_signal_arrived): Create signal_arrived as auto-reset so that only one
thread is woken when a signal arrives.
* sigproc.h (cygWFMO): New function.
(reset_signal_arrived): Delete declaration.
@
text
@d351 1
a351 1
      switch (cygWFMO (1, timeout, h))
@


1.255
log
@Throughout, remove extra space after function name from debugging output.
Throughout, change syscalls to report on return values using new %R format
option.
* smallprint.cc (__small_vsprintf): Add parsing for %R to report on return
values and possible errno from syscalls.
* errno.cc (errmap): Add PRIVILEGE_NOT_HELD.
* fhandler_tty.cc (fhandler_pty_master::setup): When creating a thread use
shorter name to reduce debuggging output.
* select.cc (start_thread_pipe): Ditto.
(start_thread_serial): Ditto.
(start_thread_socket): Ditto.
(start_thread_mailslot): Ditto.
* sigproc.cc (talktome): Ditto.
@
text
@a335 2
  HANDLE w4[3] = { h, signal_arrived, pthread::get_cancel_event () };
  DWORD nwait = w4[2] ? 3 : 2;
d351 1
a351 1
      switch (WaitForMultipleObjects (nwait, w4, FALSE, timeout))
@


1.254
log
@Throughout use "have_execed" macro rather than "hExeced" global handle.
Throughout rename _PROC_* to _CH_*.
* child_info.h: Include "pinfo.h".
(child_info_types): Rename _PROC_* -> _CH_* to avoid confusion with similarly
named constants.
(_PROC_*): Delete unneeded aliases.
(PROC_*): Ditto.
(CURR_CHILD_INFO_MAGIC): Ditto.
(cchildren): Define using "pinfo_minimal".
(child_info::set_saw_ctrl_c): Move to
(child_info_spawn::set_saw_ctrl_c): Here.
(child_info_spawn::lock): New field.
(child_info_spawn::hExeced): Ditto.
(child_info_spawn::ev): Ditto.
(child_info_spawn::~child_info_spawn): Move to sigproc.cc.
(child_info_spawn::child_info_spawn): Ditto.
(child_info_spawn::cleanup): Declare new function.
(child_info_spawn::set_saw_ctrl_c): Move to this class.  Set flag only when
execed and return true when we have set the flag.
(child_info_spawn::child_info_spawn::signal_myself_exited): New function.
(child_info_spawn::wait_for_myself): Ditto.
(child_info_spawn::has_execed_cygwin): Ditto.
(child_info_spawn::has_execed): Ditto.  Replaces "hExeced" test.
(child_info_spawn::operator HANDLE&): New operator.
(child_info_spawn::worker): Define old "spawn_guts" as class member.
(ch_spawn): Declare.
(have_execed): Define.
(have_execed_cygwin): Ditto.
* cygheap.h: Update comment.
* dcrt0.cc (get_cygwin_startup_info): Use _CH_* enums.
(child_info_spawn::handle_spawn): Ditto.
(dll_crt0_0): Ditto.
(multiple_cygwin_problem): Ditto.
* exceptions.cc (chExeced): Delete obsolete declaration.
(ctrl_c_handler): Reference set_saw_ctrl_c via new ch_spawn global.
* globals.cc (hExeced): Delete.
* pinfo.cc (pinfo::thisproc): Refer to cygheap as ::cygheap for consistency in
handle naming when -DDEBUGGING.
(pinfo::init): Accommodate case where myself.h is known but h0 is passed in.
(pinfo::pinfo): New constructor for setting up a pinfo passed in by previous
exec'or.
(pinfo::proc_waiter): Don't handle subprocess if we're in the process of
exiting due to an exec of a cygwin process.  Don't close rd_proc_pipe here.
Close it when we actually are finished with the process.  Use new
ch_spawn.signal_myself_exited function to let exec stub know that subprocess
has exited.
(pinfo::wait): Clarify debugging output.
(pinfo::release): Use "close_h" to close all handles to avoid races.
(winpids::add): Assume that elements of the array do not need to be zeroed and
are properly initialized or suffer problems on pinfo::release.  Don't close
hProcess since release does that now.
* pinfo.h: Update comment.
(pinfo_minimal): Move some elements from pinfo here so that child_info_spawn
can use them.
(pinfo): Inherit from pinfo_minimal.
(pinfo::pinfo): Modify to accommodate new pinfo_minimal.
(pinfo::allow_remove): New function.
* sigproc.cc (proc_subproc): Use boolean values for true/false.  Implement
PROC_EXEC_CLEANUP.
(proc_terminate): Set ppid = 1 since the procs list will only be iterated when
the process has not execed.  Don't do any cleanup here since it is now handled
in pinfo::release.
(sigproc_init): Initialize sync_proc_subproc earlier.
(child_info::child_info): Assume that all important fields are properly
initialized and avoid memset().
(child_info_spawn::child_info_spawn): Specifically test for execing and then
set up appropriate fields in the struct.
(child_info_spawn::cleanup): Define new function.
(child_info_spawn::record_children): Specifically test for being execed here.
Fill in pinfo_minimal part of children array.
(child_info_spawn::reattach_children): Use constructor to duplicate information
for previous exec'or.  Add more debugging output.
(remove_proc): Force deletion of thread when exiting due to exec.  Rely on
pinfo::cleanup in release.
* sigproc.h (PROC_EXEC_CLEANUP): New enum.
(PROC_DETACHED_CHILD): Delete.
* spawn.cc (chExeced): Delete.
(child_info_spawn::worker): Rename from spawn_guts.  Use elements of
child_info_spawn throughout rather than ch.whatever.  Use ::cygheap to refer to
global rather than element of child_info.  Use wait_for_myself() rather than
waitpid().  Call child_info_spawn::cleanup on function return.
(spawnve): Reflect movement of spawn_guts functionality into
child_info_spawn::worker.
* syscalls.cc (popen): Ditto.
* winsup.h (spawn_guts): Delete declaration.
@
text
@d956 1
a956 1
  syscall_printf ("%d = tcsetattr (,%x) (ENABLE FLAGS %x) (lflag %x oflag %x)",
d1018 1
a1018 1
      syscall_printf ("%d = tcsetattr (,%x) enable flags %p, c_lflag %p iflag %p",
d1069 1
a1069 1
  syscall_printf ("%d = tcgetattr (%p) enable flags %p, t->lflag %p, t->iflag %p",
d2104 1
a2104 1
  syscall_printf ("%d = fhandler_console::write (...)", len);
@


1.253
log
@* dtable.cc (dtable::delete_archetype): Improve debugging output.
(dtable::init_std_file_from_handle): Close console handle early, before
initialization.  Build up openflags for passing to open_setup, just to be safe.
(last_tty_dev): New variable.
(fh_last_tty_dev): New macro.
(fh_alloc): Try again to keep track of previously opened tty, this time by just
saving the device and using that to potentially open an archetype.  Avoid
setting the "/dev/tty" name if the creation of the fhandler failed.
(build_fh_pc): Remove unused second argument.  Reorganize how and where the
name is set.  Set last_tty_dev as appropriate.  Avoid a NULL dereference in a
debug printf.
* dtable.h (build_fh_pc): Reflect removal of second parameter.
* fhandler.cc (fhandler_base::reset): Use new '<<' operator to copy pc since it
preserves any potentially previously set name.
(fhandler_base::set_name): Ditto.
* fhandler.h (fhandler_*::clone): Throughout use ccalloc to allocate new
fhandler, primarily to make sure that pc field is properly zeroed.
(fhandler_termios::last): Eliminate.
(fhandler_termios): Remove setting of last.
(fhandler_base::~fhandler_termios): Ditto.
* fhandler_console.cc (fhandler_console::open): Don't make decisions about
opening close-on-exec handles here since it makes no sense for archetypes.
(fhandler_console::init): Assume that input handle has already been opened.
* fhandler_termios.cc (fhandler_termios::last): Delete.
* path.h (path_conv::eq_worker): New function.  Move bulk of operator = here.
(operator <<): New function.
(operator =): Use eq_worker to perform old functionality.
@
text
@d36 2
d845 1
a845 1
  if (!hExeced)
@


1.252
log
@* cygerrno.h (__set_errno): Modify debugging output to make searching strace
logs easier.  Throughout, change /dev/tty* to /dev/pty*.  Throughout, add flags
argument to fhandler_*::dup methods.
* devices.in: Rename (temporarily?) /dev/ttyN to /dev/ptyN.  Add /dev/ptymN
devices for pty masters.
* devices.cc: Regenerate.
* devices.h (MAX_CONSOLES): Set to max number supported by devices.in.
(fh_devices::FH_PTMX): Rename from FH_PTYM.
(device::operator int): Return by reference.
* dtable.cc (fh_alloc): Take pc as an argument rather than just the device.
This makes debugging easier since more information is available.  Actually
implement handling for already-allocated pty master devices.  Make different
decisions when generating fhandler for not-opened devices.  Add kludge to deal
with opening /dev/tty.
(cnew_no_ctor): New macro.
(build_fh_pc): Make debugging output more verbose.  Use new clone() fhandler
interface to duplicate archetypes.  Reset last term opened.
(dtable::dup_worker): Use Use new clone() fhandler interface to duplicate
archetypes.  Pass flags to child dup handler.
(dtable::dup3): Set O_NOCTTY flag if newfd is not stdin/stdout/stderr.
* fhandler.cc (fhandler_base::reset): Rename from operator =() and reduce
functionality and sense of copy direction.
(fhandler_base::open_with_arch): Use published interface to query io_handle().
Use new copyto() fhandler method to copy from/to found archetype.
* fhandler.h: Throughout, delete size(), add copyout, clone, and fhandler_*
(void *) methods.
(fhandler_base::reset): Rename from operator =().
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): change "protected" region to "private".
(fhandler_termios::is_dev_tty): Delete.
(fhandler_termios): Rearrange protected/public.
(fhandler_termios::fhandler_termios): Remember last fhandler_termios "opened".
(fhandler_termios::~fhandler_termios): Forget last fhandler_termios opened.
(ioctl): Rename from ioctl_termios.  Take a void * argument.  Reflect argument
change in pinfo::set_ctty.
(fhandler_console::dup): Declare new function.  Set ctty here if appropriate.
(fhandler_pty_master::from_master): Privatize.
(fhandler_pty_master::to_master): Ditto.
(fhandler_pty_master::dwProcessId): Ditto.
(fhandler_pty_master::fhandler_pty_master): Add an `int' argument.
(fhandler_pty_master::open_setup): Declare new function.
(fhandler_pty_master::~fhandler_pty_master): Declare new method.
(fhandler_nodevice): Remove commented out function declaration.
* fhandler_console.cc: Use get_ttyp() instead of tc() throughout.
(fhandler_console::dup): Define new function to set controlling ctty on dup, as
appropriate.
(fhandler_console::ioctl): Reflect ioctl_termios name change.
(fhandler_console::setup): Rename from get_tty_stuff.
(fhandler_console::open_setup): Reflect argument change in pinfo::set_ctty.
(fhandler_console::fhandler_console): Set _tc here.
* fhandler_termios.cc (handler_termios::ioctl): Rename.  Take a void * arg like
other ioctl functions.
* fhandler_tty.cc (fhandler_pty_slave::dup): Call myself->set_ctty to
potentially reset the controlling terminal.
(fhandler_pty_slave::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_slave::fhandler_pty_slave): Take a "unit" argument.  Call setup()
here so that we will know the unit number of this fhandler as soon as possible.
Set the unit as appropriate.
(handler_pty_master::open): Move most stuff to constructor and open_setup.
(handler_pty_slave::open_setup): Reflect argument change in pinfo::set_ctty.
(handler_pty_master::open_setup): Define new function.
(fhandler_pty_master::cleanup): Clear handles as a flag that the destructor
does not have to do "close" operations.
(fhandler_pty_master::close): Ditto.
(fhandler_pty_master::~fhandler_pty_master): Define new method.
(fhandler_pty_master::ioctl): Reflect name/arg change for ioctl_termios.
(fhandler_pty_master::setup): Allocate tty here.  Rely on handles being
returned from allocated test rather than opening them here.  Avoid setting
_need_nl here since it is already zeroed in the constructor.  Set up device
information with DEV_TTYM_MAJOR.
* path.h (path_conv &operator =): Take a const argument.
(path_conv::dup): Ditto.
(pathconv_arg::PC_OPEN): New enum.
(pathconv_arg::PC_CTTY): Ditto.
(path_types::PATH_CTTY): Ditto.
(path_types::PATH_OPEN): Ditto.
(path_conv::isopen): New method.
(path_conv::isctty_capable): Ditto.
* path.cc (path_conv::check): Set PATH_OPEN and PATH_CTTY as appropriate.
* pipe.cc (fhandler_pipe::open): Use copyto to copy pipe handle.
* syscall.cc (open): Reinstate fd > 2 check to disallow resetting ctty on
non-std* handles.
* tty.cc (tty_list::allocate): Pass out handles for allocated tty.  use
`not_allocated' to find unallocated ttys.  Avoid keeping the lock since the
allocation of the tty should be sufficient to prevent multiple access.
(tty::not_allocated): Clarify comment.  Rename.  Return handles when an unused
tty is found.  Simply test for existing tty.
(tty::exists): Rewrite to use `not_allocated'.
* tty.h (NTTYS): Reset down to actual number supported by devices.in.
(tty::not_allocated): Declare new function.
(tty_list::allocate): Pass out read/write tty handles.  Zero them when not
found.
* fhandler_proc.cc: Reflect name change from FH_PTYM -> FH_PTMX.
* pinfo.h (pinfo::set_ctty): Reduce/reorder arguments passed in.
* pinfo.cc (pinfo::set_ctty): Ditto.  Just use tc() built into the passed-in
fhandler_termios pointer.  Return true if ctty is assigned.
* syscalls.cc (open): Call build_fh_pc with PC_OPEN flag.  Set PC_CTTY if
appropriate.
(stat_worker): Remove is_dev_tty () stuff.
@
text
@d787 1
a787 1
		  FILE_SHARE_READ | FILE_SHARE_WRITE, sec_none_cloexec (flags),
d798 1
a798 1
		  FILE_SHARE_READ | FILE_SHARE_WRITE, sec_none_cloexec (flags),
a2199 2
  if (h && h != INVALID_HANDLE_VALUE)
    CloseHandle (h);	/* Reopened by open */
@


1.251
log
@	* fhandler_console.cc (fhandler_console::cursor_set): Disable forcing
	y to the current winBottom position.  Explain why.
@
text
@d167 1
a167 1
fhandler_console::get_tty_stuff ()
d271 1
a271 1
      tc ()->kill_pgrp (SIGWINCH);
d339 1
a339 1
  termios ti = tc ()->ti;
d687 2
a688 2
  if (tc ()->rstcons ())
    input_tcsetattr (0, &tc ()->ti);
d763 7
d816 1
a816 1
  tc ()->rstcons (false);
d835 1
a835 1
  myself->set_ctty (&shared_console_info->tty_min_state, flags, this);
d851 1
a851 1
  int res = ioctl_termios (cmd, (int) arg);
d980 2
a981 2
  termios_printf ("this %p, tc () %p, t %p", this, tc (), t);
  tc ()->ti = *t;
d1020 1
a1020 1
  tc ()->rstcons (false);
d1037 1
a1037 1
  *t = tc ()->ti;
d1077 1
a1077 1
  get_tty_stuff ();
d1079 1
d1877 1
a1877 1
	  cursor_set (false, ((tc ()->ti.c_oflag & ONLCR) ? 0 : x), y + 1);
d2203 1
a2203 1
  return !tcsetattr (0, &tc ()->ti);
d2209 1
a2209 1
  return tc ()->ti.c_iflag & IGNCR;
@


1.250
log
@* cygwin.din: Remove some _tc* exports.  Add tcgetsid().
* dtable.cc (fh_alloc): Revert ill-advised setting of major/minor.  Use new
is_dev_tty to remember that this device was opened as /dev/tty.
* fhandler.cc (fhandler_base::fstat): Remove leftover debugging statement.
(fhandler_base::tcgetsid): New function.
* fhandler.h ((fhandler_base::tcgetsid): Declare new function.
(fhandler_base::is_dev_tty): Ditto.
(fhandler_termios::opened_as_dev_tty): Declare new field.
(fhandler_termios::is_dev_tty): Declare new function.
(fhandler_termios::tcgetsid): Ditto.
(fhandler_pty_common::use_archetype): Move here from subclass.
(fhandler_pty_slave::use_archetype): Move up.
(fhandler_pty_master::use_archetype): Ditto.
* fhandler_console.cc (fhandler_console::ioctl): Rename second argument from
`buf' to `arg' for consistency.  Call ioctl_termios for common fhandler_termios
ioctl handling.
* fhandler_tty.cc (fhandler_pty_slave::ioctl): Call ioctl_termios for common
fhandler_termios ioctl handling.
(fhandler_pty_master::ioctl): Ditto.
* fhandler_termios.cc (fhandler_termios::tcgetsid): Implement new function.
(fhandler_termios::ioctl_termios): Ditto.  Implements TIOCSCTTY handling.
* syscalls.cc (stat_worker): Set /dev/tty device info when appropriate.
* termios.cc (tcgetpgrp): Avoid extraneous "isatty" check.
(tcgetsid): Implement new function.
* include/cygwin/version.h: Bump CYGWIN_VERSION_API_MINOR to 253.
* include/sys/termios.h (TIOCSCTTY): Define.
@
text
@d1178 8
d1188 3
a1190 1
  else if (y < 0)
@


1.249
log
@* dtable.cc: Mark some const variables as static.
* environ.cc (conv_start_chars): Move to shared cygwin region and initialize at
compile time.
(match_first_char): New generic function for querying conv_start_chars.
(posify_maybe): Rename from posify.
(environ_init): Remove conv_envvars initialization.  Don't check
conv_start_chars, just allow posify_maybe to make the decision.
* fhandler_console.cc (__vt100_conv): Fix formatting.  Mark as const.
@
text
@d842 1
a842 1
fhandler_console::ioctl (unsigned int cmd, void *buf)
d844 3
d857 2
a858 2
	    ((struct winsize *) buf)->ws_row = dev_state.info.dwWinSize.Y;
	    ((struct winsize *) buf)->ws_col = dev_state.info.dwWinSize.X;
d860 2
a861 2
			   ((struct winsize *) buf)->ws_row,
			   ((struct winsize *) buf)->ws_col);
d875 1
a875 1
	*(int *) buf = (dev_state.metabit) ? K_METABIT : K_ESCPREFIX;
d878 1
a878 1
	if ((int) buf == K_METABIT)
d880 1
a880 1
	else if ((int) buf == K_ESCPREFIX)
d889 1
a889 1
	if (*(unsigned char *) buf == 6)
d891 1
a891 1
	    *(unsigned char *) buf = (unsigned char) dev_state.nModifiers;
d912 1
a912 1
	  *(int *) buf = ret;
d918 1
a918 1
  return fhandler_base::ioctl (cmd, buf);
@


1.248
log
@	* fhandler_console.cc (fhandler_console::read): Recognize backspace key
	using the device independent key code, rather than the device dependent
	scan code.
@
text
@d1211 1
a1211 1
static wchar_t __vt100_conv [31] = {
@


1.247
log
@	* fhandler_console.cc (fhandler_console::ioctl): Fetch console events
	using PeekConsoleInput and return only key down events in buf.
	* fhandler_tty.cc (fhandler_pty_slave::ioctl): Always return EINVAL
	if PeekNamedPipe fails.
	(fhandler_pty_master::ioctl): Ditto.
@
text
@d446 1
a446 1
	  if (input_rec.Event.KeyEvent.wVirtualScanCode == 14)
@


1.246
log
@	* fhandler_tty.cc (fhandler_pty_slave::ioctl): Drop FIONBIO case.
	Handle FIONREAD.
	(fhandler_pty_master::ioctl): Ditto.  Call fhandler_base::ioctl to
	decode default condition.
	* fhandler_console.cc (fhandler_console::ioctl): Handle FIONREAD.
@
text
@d895 3
d899 3
a901 1
	  if (!GetNumberOfConsoleInputEvents (get_io_handle (), &n))
d903 1
a903 1
	      __seterrno ();
d906 4
a909 1
	  *(int *) buf = (int) n;
@


1.245
log
@	* fhandler_console.cc (fhandler_console::input_tcsetattr): Revert to
	setting ENABLE_PROCESSED_INPUT depending on ISIG and IGNBRK.
	(fhandler_console::tcgetattr): Set ISIG depending on
	ENABLE_PROCESSED_INPUT as well.
@
text
@d35 1
d891 14
a904 5
	else
	  {
	    set_errno (EINVAL);
	    return -1;
	  }
@


1.244
log
@	* fhandler_console.cc (fhandler_console::input_tcsetattr): Make
	ENABLE_PROCESSED_INPUT flag only depending on value of IGNBRK.
	(fhandler_console::tcgetattr): Don't set ISIG depending on
	ENABLE_PROCESSED_INPUT, set IGNBRK instead.
@
text
@d973 1
a973 1
  if (!(t->c_iflag & IGNBRK))
d1028 3
a1030 1
      if (!(flags & ENABLE_PROCESSED_INPUT))
@


1.243
log
@	* fhandler_console.cc (fhandler_console::read): Add comment.
	(fhandler_console::input_tcsetattr): Don't set ENABLE_PROCESSED_INPUT
	if IGNBRK flag is set.
@
text
@d973 1
a973 1
  if ((t->c_lflag & ISIG) && !(t->c_iflag & IGNBRK))
d1028 2
a1029 2
      if (flags & ENABLE_PROCESSED_INPUT)
	t->c_lflag |= ISIG;
@


1.242
log
@	* fhandler_console.cc (fhandler_console::read): Don't generate ^@@ on
	Ctrl+Alt+Space.
@
text
@d444 1
d973 1
a973 1
  if (t->c_lflag & ISIG)
@


1.241
log
@* fhandler_console.cc (fhandler_console::set_unit): Set pc.file_attributes() to
reflect existence.
* fhandler.h (fhandler_pty_common::fhandler_pty_common): Ditto.
* pinfo.cc (_pinfo::set_ctty): Output device numbers in hex.
@
text
@d460 2
a461 1
		   && (control_key_state & CTRL_PRESSED))
@


1.240
log
@* cygheap.h (init_cygheap::ctty_on_hold): Remove conditionalized variable.
* dcrt0.cc (do_exit): Remove code which handled CYGWIN=tty style ttys.
* devices.in: Remove "/dev/ttym".
* dtable.cc: Rename tty to pty where appropriate throughout.
(dtable::stdio_init): Use new t->is_console rather than using now-deleted hwnd
element in tty structure.
(dtable::init_std_file_from_handle): Remove code which handled CYGWIN=tty style
ttys.
(fh_alloc): Ditto.
* fhandler.h: Rename tty to pty where appropriate.
(fhandler_pty_common): Delete output_done_event, ioctl_request_event,
ioctl_done_event.
(fhandler_pty_master::setup): Delete argument.
(fhandler_tty_master): Delete.
(fhandler_union): Delete __tty_master.
* fhandler_console.cc (use_tty): Delete.
(fhandler_console::get_tty_stuff): Set is_console to true rather than calling
sethwnd.
(fhandler_console::send_winch_maybe): Remove CYGWIN=tty considerations.
(fhandler_console::input_tcsetattr): Ditto.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Use new t->is_console
rather than using now-deleted hwnd element in tty structure.
* fhandler_tty.cc: Rename tty to pty where appropriate throughout.
(tty_master): Delete.
(process_input): Ditto.
(process_output): Ditto.
(process_ioctl): Ditto.
(fhandler_tty_master::*): Ditto.
(fhandler_pty_master::process_slave_output): Remove CYGWIN=tty considerations.
(fhandler_pty_slave::open): Ditto for *_done_event.
(fhandler_pty_slave::write): Ditto.
(fhandler_pty_slave::ioctl): Ditto.
(fhandler_pty_slave::fch_open_handles): Ditto.
(fhandler_pty_slave::fch_set_sd): Ditto.
(fhandler_pty_slave::fch_close_handles): Ditto.
(fhandler_pty_common::close): Ditto.
(fhandler_pty_master::setup): Ditto.  Remove now-unneeded ispty parameter.
(fhandler_pty_master::open): Reflect argument removal for tty::allocate.
* select.cc: Rename tty to pty where appropriate throughout.
* sigproc.cc (proc_subproc): Remove CYGWIN=tty considerations.
* tty.cc (ttyslot): Accommodate CYGWIN=tty removal.
(tty_list::init_session): Ditto.
(tty_list::attach): Ditto.
(tty::create_master): Delete.
(tty_list::terminate): Ditto.
(tty_list::allocate): Delete "with_console" parameter.  Remove CYGWIN=tty
considerations.
(tty::init): Set is_console = false.  Use 'false' for was_opened since it is a
boolean.
* tty.h (*_{DONE,REQUEST}_EVENT): Delete.
(tty_min::is_console): Declare new field which replaces hwnd.
(tty_min::gethwnd): Delete.
(tty_min::sethwnd): Ditto.
(tty_list::allocate): Delete parameter.
(tty_list::terminate): Delete declaration.
* include/sys/cygwin.h (PID_USETTY): Redefine to PID_UNUSED1 and change comment
to reflect its availability.
@
text
@d159 2
@


1.239
log
@Rename FH_BAD to FH_NADA throughout.
* devices.h (FH_ERROR): New value.
(iscons_dev): Extend to detect all the console device types.
* devices.in: Set aside storage for FH_ERROR.
* dtable.cc (dtable::init_std_file_from_handle): Use iscons_dev to detect when
device is a console.
(fh_alloc): Pass device to console constructor.
(build_fh_pc): Short circuit when we detect that the constructor saw an error.
* fhandler.h (fhandler_console::fhandler_console): Accept fh_devices parameter.
(get_tty_stuff): Change to void.
* fhandler_console (fhandler_console::set_unit): Set device to FH_ERROR on
attempt to access anything other than the current console.
(fhandler_console::get_tty_stuff): Change to void return.
(fhandler_console::open): Return EPERM on FH_ERROR device type.
(fhandler_console::fhandler_console): Set the device type appropriately before
calling get_tty_stuff and rely on that function to reset it if necessary.
@
text
@a51 2
#define use_tty ISSTATE (myself, PID_USETTY)

d192 1
a192 1
	shared_console_info->tty_min_state.sethwnd ((HWND) INVALID_HANDLE_VALUE);
a265 1
      extern fhandler_tty_master *tty_master;
d268 1
a268 4
      if (tty_master)
	tty_master->set_winsize (true);
      else
	tc ()->kill_pgrp (SIGWINCH);
a973 7
  if (use_tty)
    {
      flags = 0; // ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT;
      tc ()->ti.c_iflag = 0;
      tc ()->ti.c_lflag = 0;
    }

@


1.238
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info::old_title): Delete.
(child_info::~child_info_spawn): Remove recording of old_title.
* dcrt0.cc (title_buf): Delete.
(child_info_spawn::handle_spawn): Remove recording of old_title.
(dll_crt0_1): Get rid of all title handling.
(do_exit): Ditto.
* environ.cc (known): Delete strip_title and title.
* fhandler_console.cc (fhandler_console::write): Remove recording of old_title.
* globals.cc (exit_states): Remove ES_TITLE.
(display_title): Delete.
(strip_title_path): Delete.
(old_title): Delete.
* spawn.cc (spawn_guts): Remove old_title accommodation.
@
text
@d134 1
d136 10
a145 1
    created = false;
d157 1
d160 1
d164 2
a165 3
/* Allocate and initialize the shared record for the current console.
   Returns a pointer to shared_console_info. */
tty_min *
a195 2

  return &shared_console_info->tty_min_state;
d768 6
d1051 1
a1051 1
fhandler_console::fhandler_console () :
d1054 2
a1056 1
  dev ().parse (shared_console_info->tty_min_state.getntty ());
@


1.237
log
@* fhandler_console.cc (fhandler_console::open_shared_console): Semi-revert to
using fixed location for console stuff.
* shared.cc (offsets): Ditto.  Comment.
* shared_info (shared_locations): Re-add SH_SHARED_CONSOLE.
@
text
@d2003 1
a2003 5
		  {
		    if (old_title)
		      strcpy (old_title, dev_state.my_title_buf);
		    set_console_title (dev_state.my_title_buf);
		  }
@


1.236
log
@whitespace elimination
@
text
@d86 1
a86 1
  shared_locations m = create ? SH_JUSTCREATE: SH_JUSTOPEN;
d89 1
a89 1
  create = m == SH_JUSTCREATE;
@


1.235
log
@* fhandler_console.cc (fhandler_console::open_shared_console): Don't zero
handle to open_shared since it is supposed to be an input.
(enum_windows): Set handle input to open_shared to NULL since it does not
represent any previously opened shared region.
* shared.cc (open_shared): Tweak debugging output.
@
text
@d88 1
a88 1
    open_shared (namebuf, 0, h, sizeof (*shared_console_info), &m); 
d303 1
a303 1
	         || dev_state.dwMousePosition.Y != dev_state.dwLastMousePosition.Y)
d305 1
a305 1
	         || dev_state.use_mouse >= 3));
d519 4
a522 4
	    /* As a unique guard for mouse report generation, 
	       call mouse_aware() which is common with select(), so the result 
	       of select() and the actual read() will be consistent on the 
	       issue of whether input (i.e. a mouse escape sequence) will 
d526 1
a526 1
		/* Note: Reported mouse position was already retrieved by 
d1226 1
a1226 1
        buf[i] = __vt100_conv[buf[i] - (unsigned char) '`'];
d1616 2
a1617 2
	/* Generate Secondary Device Attribute report, using 67 = ASCII 'C' 
	   to indicate Cygwin (convention used by Rxvt, Urxvt, Screen, Mintty), 
d1622 3
a1624 3
      /* The generated report needs to be injected for read-ahead into the 
         fhandler_console object associated with standard input.
         The current call does not work. */
d2120 1
a2120 1
        if ((input_rec.Event.KeyEvent.dwControlKeyState &
d2123 1
a2123 1
          { /* Generic ESC prefixing if Alt is pressed */
d2127 3
a2129 3
          }
        else
          return keytable[i].val[modifier_index];
d2207 1
a2207 1
	 		   failed */
@


1.234
log
@* fhandler.cc (fhandler_base_overlapped::wait_overlapped): Only raise SIGPIPE
when writing.
* fhandler.h: Include "tty.h".
(fhandler_termios::_tc): Rename from tc.
(fhandler_termios::tc): New method.
(fhandler_termios::tcinit): Remove an argument.
(fhandler_termios::get_ttyp): Use method to retrieve value.
(fhandler_console::console_state): Move here.
(fhandler_console::dev_state): Delete.
(fhandler_console::shared_console_info): Define.
(fhandler_console::open_shared_console): Move this function under
fhandler_console umbrella.
(fhandler_console::tc): Define.  Return static value.
(fhandler_console::focus_aware): Accommodate deletion of dev_state.
(fhandler_console): Add tty_list::get_cttyp as a friend.
* fhandler_console.cc (dev_state): Redefine as a pointer within
shared_console_info and change dev-> to dev.  throughout.
(fhandler_console::shared_console_info): Move into fhandler_console.
(fhandler_console::open_shared_console): Move into fhandler_console change
argument to simple bool.
(enum_windows): Accommodate changes to console_state and open_shared_console.
(console_unit::console_unit): Ditto.
(fhandler_console::get_tty_stuff): Accommodate change to dev_state.
(tty_list::get_cttyp): Accommodate change to
handler_console::shared_console_info.
(fhandler_console::read): Accommodate change from tc to tc ().
(fhandler_console::set_input_state): Ditto.
(fhandler_console::open): Accommodate tcinit argument change and change from tc
to tc().
(fhandler_console::input_tcsetattr): Accomodate change from tc to tc().
(fhandler_console::input_tcsetattr): Ditto.
(fhandler_console::write_normal): Ditto.
(fhandler_console::init): Ditto.
(fhandler_console::igncr_enabled): Ditto.
* fhandler_termios.cc (fhandler_termios::tcinit): Remove first argument.
Expect tc() to have been set up first.  Use tc() rather than tc.
(fhandler_termios::tcsetpgrp): Accomodate change from tc to tc().
(fhandler_termios::tcgetpgrp): Ditto.
(fhandler_termios::bg_check): Ditto.
(fhandler_termios::line_edit: Ditto.
(fhandler_tty_master::set_winsize): Ditto.
(fhandler_tty_slave::open): Ditto.
(fhandler_tty_slave::init): Ditto.
(fhandler_pty_master::write): Ditto.
(fhandler_pty_master::setup): Ditto.  Accommodate change in arguments to
tcinit.
(fhandler_tty_slave::fch_open_handles): Set _tc directly.
(tty_min::is_orphaned_process_group): Don't assume that parent pid exists.
* pinfo.cc (_pinfo::set_ctty): Reset myself->{pgid,sid} here if we were started
by a non-Cygwin process but the tty exists.
* shared_info.h (console_state): Delete from here.
* tty.h: Make multiple inclusion safe.
@
text
@a84 1
  h = NULL;
d110 1
a110 1
  HANDLE h;
@


1.233
log
@* exceptions.cc (ctrl_c_handler): Simplify test for no parent tty.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Return NULL if ctty is
not tty/console.  Improve test for slave tty/pty device.
@
text
@d48 3
a50 2
#define srTop (dev_state->info.winTop + dev_state->scroll_region.Top)
#define srBottom ((dev_state->scroll_region.Bottom < 0) ? dev_state->info.winBottom : dev_state->info.winTop + dev_state->scroll_region.Bottom)
d58 1
a58 1
static console_state NO_COPY *shared_console_info;
a61 2
dev_console NO_COPY *fhandler_console::dev_state;

d80 2
a81 2
console_state *
open_shared_console (HWND hw, HANDLE& h, shared_locations& m)
d86 6
a91 3
  return (console_state *) open_shared (namebuf, 0, h,
					sizeof (*shared_console_info),
					&m); 
a110 1
  shared_locations m = SH_JUSTOPEN;
d112 2
a113 2
  console_state *cs;
  if ((cs = open_shared_console (hw, h, m)))
d134 1
a134 1
  bool need_initializing;
d136 1
a136 1
    need_initializing = false;
d140 2
a141 2
      shared_locations m = SH_JUSTCREATE;
      shared_console_info = open_shared_console (me, cygheap->console_h, m);
d143 1
a143 1
      if ((need_initializing = m != SH_JUSTOPEN))
d150 1
a150 2
  dev_state = &shared_console_info->dev_state;
  return need_initializing;
d161 10
a170 10
	dev_state->scroll_region.Bottom = -1;
	dev_state->dwLastCursorPosition.X = -1;
	dev_state->dwLastCursorPosition.Y = -1;
	dev_state->dwLastMousePosition.X = -1;
	dev_state->dwLastMousePosition.Y = -1;
	dev_state->dwLastButtonState = 0;	/* none pressed */
	dev_state->last_button_code = 3;	/* released */
	dev_state->underline_color = FOREGROUND_GREEN | FOREGROUND_BLUE;
	dev_state->dim_color = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
	dev_state->meta_mask = LEFT_ALT_PRESSED;
d181 3
a183 3
	  dev_state->meta_mask |= RIGHT_ALT_PRESSED;
	dev_state->set_default_attr ();
	dev_state->backspace_keycode = CERASE;
d197 2
a198 1
    return shared_console_info ? &shared_console_info->tty_min_state : NULL;
d229 3
a231 3
  bool old_mode = dev_state->raw_win32_keyboard_mode;
  dev_state->raw_win32_keyboard_mode = new_mode;
  syscall_printf ("raw keyboard mode %sabled", dev_state->raw_win32_keyboard_mode ? "en" : "dis");
d243 2
a244 2
  if (dev_state->dwLastCursorPosition.X != now.dwCursorPosition.X ||
      dev_state->dwLastCursorPosition.Y != now.dwCursorPosition.Y)
d247 1
a247 1
      dev_state->dwLastCursorPosition = now.dwCursorPosition;
d254 3
a256 3
  SHORT y = dev_state->info.dwWinSize.Y;
  SHORT x = dev_state->info.dwWinSize.X;
  dev_state->fillin_info (get_output_handle ());
d258 1
a258 1
  if (y != dev_state->info.dwWinSize.Y || x != dev_state->info.dwWinSize.X)
d261 2
a262 2
      dev_state->scroll_region.Top = 0;
      dev_state->scroll_region.Bottom = -1;
d266 1
a266 1
	tc->kill_pgrp (SIGWINCH);
d274 1
a274 1
  if (! dev_state->use_mouse)
d282 2
a283 2
      dev_state->dwMousePosition.X = mouse_event.dwMousePosition.X - now.srWindow.Left;
      dev_state->dwMousePosition.Y = mouse_event.dwMousePosition.Y - now.srWindow.Top;
d292 2
a293 2
  if (dev_state->dwMousePosition.X > 0xFF - ' ' - 1
      || dev_state->dwMousePosition.Y > 0xFF - ' ' - 1)
d300 1
a300 1
	  && mouse_event.dwButtonState != dev_state->dwLastButtonState)
d303 4
a306 4
	     && (dev_state->dwMousePosition.X != dev_state->dwLastMousePosition.X
	         || dev_state->dwMousePosition.Y != dev_state->dwLastMousePosition.Y)
	     && ((dev_state->use_mouse >= 2 && mouse_event.dwButtonState)
	         || dev_state->use_mouse >= 3));
d334 1
a334 1
  termios ti = tc->ti;
d383 1
a383 1
	  dev_state->nModifiers = 0;
d392 1
a392 1
	      set_raw_win32_keyboard_mode (!dev_state->raw_win32_keyboard_mode);
d397 1
a397 1
	  if (dev_state->raw_win32_keyboard_mode)
d432 1
a432 1
	    dev_state->nModifiers |= 1;
d434 1
a434 1
	    dev_state->nModifiers |= 2;
d436 1
a436 1
	    dev_state->nModifiers |= 4;
d438 1
a438 1
	    dev_state->nModifiers |= 8;
d442 1
a442 1
	      char c = dev_state->backspace_keycode;
d445 1
a445 1
		if (dev_state->metabit)
d465 1
a465 1
		  dev_state->nModifiers = 0;
d472 1
a472 1
	      nread = dev_state->con_to_str (tmp + 1, 59, wch);
d496 1
a496 1
	      else if (dev_state->metabit)
d507 1
a507 1
		  dev_state->nModifiers &= ~4;
d562 1
a562 1
			b = dev_state->last_button_code;
d564 1
a564 1
		    else if (mouse_event.dwButtonState < dev_state->dwLastButtonState)
d569 1
a569 1
		    else if ((mouse_event.dwButtonState & 1) != (dev_state->dwLastButtonState & 1))
d574 1
a574 1
		    else if ((mouse_event.dwButtonState & 2) != (dev_state->dwLastButtonState & 2))
d579 1
a579 1
		    else if ((mouse_event.dwButtonState & 4) != (dev_state->dwLastButtonState & 4))
d585 1
a585 1
		    dev_state->last_button_code = b;
d595 1
a595 1
			dev_state->dwLastButtonState = mouse_event.dwButtonState;
d600 2
a601 2
		dev_state->dwLastMousePosition.X = dev_state->dwMousePosition.X;
		dev_state->dwLastMousePosition.Y = dev_state->dwMousePosition.Y;
d604 1
a604 1
		dev_state->nModifiers = 0;
d606 1
a606 1
		    dev_state->nModifiers |= 0x4;
d608 1
a608 1
		    dev_state->nModifiers |= 0x8;
d610 1
a610 1
		    dev_state->nModifiers |= 0x10;
d613 1
a613 1
		b |= dev_state->nModifiers;
d616 2
a617 2
		sprintf (tmp, "\033[M%c%c%c", b + ' ', dev_state->dwMousePosition.X + ' ' + 1, dev_state->dwMousePosition.Y + ' ' + 1);
		syscall_printf ("mouse: %s at (%d,%d)", sz, dev_state->dwMousePosition.X, dev_state->dwMousePosition.Y);
d626 1
a626 1
	  if (dev_state->use_focus) {
d680 2
a681 2
  if (tc->rstcons ())
    input_tcsetattr (0, &tc->ti);
d718 2
a719 2
  dev_state->fillin_info (get_output_handle ());
  sr1.Left = x1 >= 0 ? x1 : dev_state->info.dwWinSize.X - 1;
d721 1
a721 1
    sr1.Top = dev_state->info.winTop;
d723 2
a724 2
    sr1.Top = y1 > 0 ? y1 : dev_state->info.winBottom;
  sr1.Right = x2 >= 0 ? x2 : dev_state->info.dwWinSize.X - 1;
d726 1
a726 1
    sr1.Bottom = dev_state->info.winTop;
d728 1
a728 1
    sr1.Bottom = y2 > 0 ? y2 : dev_state->info.winBottom;
d732 1
a732 1
  sr2.Right = dev_state->info.dwWinSize.X - 1;
d735 1
a735 1
  dest.X = xn >= 0 ? xn : dev_state->info.dwWinSize.X - 1;
d737 1
a737 1
    dest.Y = dev_state->info.winTop;
d739 1
a739 1
    dest.Y = yn > 0 ? yn : dev_state->info.winBottom;
d741 1
a741 1
  fill.Attributes = dev_state->current_win32_attr;
d760 1
a760 1
  tcinit (get_tty_stuff (), false);
d788 1
a788 1
  if (dev_state->fillin_info (get_output_handle ()))
d790 4
a793 4
      dev_state->current_win32_attr = dev_state->info.wAttributes;
      if (!dev_state->default_color)
	dev_state->default_color = dev_state->info.wAttributes;
      dev_state->set_default_attr ();
d796 1
a796 1
  tc->rstcons (false);
d836 1
a836 1
	st = dev_state->fillin_info (get_output_handle ());
d841 2
a842 2
	    ((struct winsize *) buf)->ws_row = dev_state->info.dwWinSize.Y;
	    ((struct winsize *) buf)->ws_col = dev_state->info.dwWinSize.X;
d859 1
a859 1
	*(int *) buf = (dev_state->metabit) ? K_METABIT : K_ESCPREFIX;
d863 1
a863 1
	  dev_state->metabit = TRUE;
d865 1
a865 1
	  dev_state->metabit = FALSE;
d875 1
a875 1
	    *(unsigned char *) buf = (unsigned char) dev_state->nModifiers;
d940 2
a941 1
  tc->ti = *t;
d969 2
a970 2
      tc->ti.c_iflag = 0;
      tc->ti.c_lflag = 0;
d987 1
a987 1
  tc->rstcons (false);
d1004 1
a1004 1
  *t = tc->ti;
d1109 1
a1109 1
  dev_state->fillin_info (get_output_handle ());
d1112 1
a1112 1
    x1 = dev_state->info.dwWinSize.X - 1;
d1114 1
a1114 1
    y1 = dev_state->info.winBottom;
d1116 1
a1116 1
    x2 = dev_state->info.dwWinSize.X - 1;
d1118 1
a1118 1
    y2 = dev_state->info.winBottom;
d1120 1
a1120 1
  num = abs (y1 - y2) * dev_state->info.dwBufferSize.X + abs (x1 - x2) + 1;
d1122 1
a1122 1
  if ((y2 * dev_state->info.dwBufferSize.X + x2) > (y1 * dev_state->info.dwBufferSize.X + x1))
d1137 1
a1137 1
			       dev_state->current_win32_attr,
d1148 3
a1150 3
  dev_state->fillin_info (get_output_handle ());
  if (y > dev_state->info.winBottom)
    y = dev_state->info.winBottom;
d1154 1
a1154 1
    y += dev_state->info.winTop;
d1156 2
a1157 2
  if (x > dev_state->info.dwWinSize.X)
    x = dev_state->info.dwWinSize.X - 1;
d1169 3
a1171 3
  dev_state->fillin_info (get_output_handle ());
  x += dev_state->info.dwCursorPosition.X;
  y += dev_state->info.dwCursorPosition.Y;
d1178 3
a1180 3
  dev_state->fillin_info (get_output_handle ());
  *y = dev_state->info.dwCursorPosition.Y;
  *x = dev_state->info.dwCursorPosition.X;
d1222 3
a1224 3
  if (dev_state->iso_2022_G1
	? dev_state->vt100_graphics_mode_G1
	: dev_state->vt100_graphics_mode_G0)
d1304 2
a1305 2
       for (int i = 0; i <= dev_state->nargs_; i++)
	 switch (dev_state->args_[i])
d1308 1
a1308 1
	       dev_state->set_default_attr ();
d1311 1
a1311 1
	       dev_state->intensity = INTENSITY_BOLD;
d1314 1
a1314 1
	       dev_state->intensity = INTENSITY_DIM;
d1317 1
a1317 1
	       dev_state->underline = 1;
d1320 1
a1320 1
	       dev_state->blink = true;
d1323 1
a1323 1
	       dev_state->reverse = true;
d1326 1
a1326 1
	       dev_state->intensity = INTENSITY_INVISIBLE;
d1329 1
a1329 1
	       dev_state->alternate_charset_active = false;
d1332 1
a1332 1
	       dev_state->alternate_charset_active = true;
d1336 1
a1336 1
	       dev_state->intensity = INTENSITY_NORMAL;
d1339 1
a1339 1
	       dev_state->underline = false;
d1342 1
a1342 1
	       dev_state->blink = false;
d1345 1
a1345 1
	       dev_state->reverse = false;
d1348 1
a1348 1
	       dev_state->fg = 0;
d1351 1
a1351 1
	       dev_state->fg = FOREGROUND_RED;
d1354 1
a1354 1
	       dev_state->fg = FOREGROUND_GREEN;
d1357 1
a1357 1
	       dev_state->fg = FOREGROUND_RED | FOREGROUND_GREEN;
d1360 1
a1360 1
	       dev_state->fg = FOREGROUND_BLUE;
d1363 1
a1363 1
	       dev_state->fg = FOREGROUND_RED | FOREGROUND_BLUE;
d1366 1
a1366 1
	       dev_state->fg = FOREGROUND_BLUE | FOREGROUND_GREEN;
d1369 1
a1369 1
	       dev_state->fg = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED;
d1372 1
a1372 1
	       dev_state->fg = dev_state->default_color & FOREGROUND_ATTR_MASK;
d1375 1
a1375 1
	       dev_state->bg = 0;
d1378 1
a1378 1
	       dev_state->bg = BACKGROUND_RED;
d1381 1
a1381 1
	       dev_state->bg = BACKGROUND_GREEN;
d1384 1
a1384 1
	       dev_state->bg = BACKGROUND_RED | BACKGROUND_GREEN;
d1387 1
a1387 1
	       dev_state->bg = BACKGROUND_BLUE;
d1390 1
a1390 1
	       dev_state->bg = BACKGROUND_RED | BACKGROUND_BLUE;
d1393 1
a1393 1
	       dev_state->bg = BACKGROUND_BLUE | BACKGROUND_GREEN;
d1396 1
a1396 1
	       dev_state->bg = BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED;
d1399 1
a1399 1
	       dev_state->bg = dev_state->default_color & BACKGROUND_ATTR_MASK;
d1402 1
a1402 1
       dev_state->set_color (get_output_handle ());
d1406 1
a1406 1
      if (!dev_state->saw_question_mark)
d1408 1
a1408 1
	  switch (dev_state->args_[0])
d1411 2
a1412 2
	      dev_state->insert_mode = (c == 'h') ? true : false;
	      syscall_printf ("insert mode %sabled", dev_state->insert_mode ? "en" : "dis");
d1417 1
a1417 1
      switch (dev_state->args_[0])
d1428 2
a1429 2
	      dev_state->savebufsiz.X = now.srWindow.Right - now.srWindow.Left + 1;
	      dev_state->savebufsiz.Y = now.srWindow.Bottom - now.srWindow.Top + 1;
d1431 4
a1434 4
	      if (dev_state->savebuf)
		cfree (dev_state->savebuf);
	      dev_state->savebuf = (PCHAR_INFO) cmalloc_abort (HEAP_1_BUF, sizeof (CHAR_INFO) *
					     dev_state->savebufsiz.X * dev_state->savebufsiz.Y);
d1436 2
a1437 2
	      ReadConsoleOutputW (get_output_handle (), dev_state->savebuf,
				  dev_state->savebufsiz, cob, &now.srWindow);
d1447 1
a1447 1
	      if (!dev_state->savebuf)
d1450 2
a1451 2
	      WriteConsoleOutputW (get_output_handle (), dev_state->savebuf,
				   dev_state->savebufsiz, cob, &now.srWindow);
d1453 3
a1455 3
	      cfree (dev_state->savebuf);
	      dev_state->savebuf = NULL;
	      dev_state->savebufsiz.X = dev_state->savebufsiz.Y = 0;
d1460 1
a1460 1
	  dev_state->backspace_keycode = (c == 'h' ? CTRL('H') : CERASE);
d1464 2
a1465 2
	  dev_state->use_mouse = (c == 'h') ? 1 : 0;
	  syscall_printf ("mouse support set to mode %d", dev_state->use_mouse);
d1469 2
a1470 2
	  dev_state->use_mouse = (c == 'h') ? 2 : 0;
	  syscall_printf ("mouse support set to mode %d", dev_state->use_mouse);
d1474 2
a1475 2
	  dev_state->use_mouse = (c == 'h') ? 3 : 0;
	  syscall_printf ("mouse support set to mode %d", dev_state->use_mouse);
d1479 2
a1480 2
	  dev_state->use_focus = (c == 'h') ? true : false;
	  syscall_printf ("focus reporting set to %d", dev_state->use_focus);
d1488 1
a1488 1
	  syscall_printf ("unknown h/l command: %d", dev_state->args_[0]);
d1493 1
a1493 1
      switch (dev_state->args_[0])
d1513 1
a1513 1
      cursor_rel (0, -(dev_state->args_[0] ? dev_state->args_[0] : 1));
d1516 1
a1516 1
      cursor_rel (0, dev_state->args_[0] ? dev_state->args_[0] : 1);
d1519 1
a1519 1
      cursor_rel (dev_state->args_[0] ? dev_state->args_[0] : 1, 0);
d1522 1
a1522 1
      cursor_rel (-(dev_state->args_[0] ? dev_state->args_[0] : 1),0);
d1525 1
a1525 1
      switch (dev_state->args_[0])
d1545 2
a1546 2
      cursor_set (true, (dev_state->args_[1] ? dev_state->args_[1] : 1) - 1,
			(dev_state->args_[0] ? dev_state->args_[0] : 1) - 1);
d1550 1
a1550 1
      cursor_set (false, (dev_state->args_[0] ? dev_state->args_[0] - 1 : 0), y);
d1554 1
a1554 1
      cursor_set (true, x, (dev_state->args_[0] ? dev_state->args_[0] - 1 : 0));
d1557 2
a1558 2
      cursor_get (&dev_state->savex, &dev_state->savey);
      dev_state->savey -= dev_state->info.winTop;
d1561 1
a1561 1
      cursor_set (true, dev_state->savex, dev_state->savey);
d1568 1
a1568 1
      dev_state->args_[0] = dev_state->args_[0] ? dev_state->args_[0] : 1;
d1570 1
a1570 1
      scroll_screen (0, y, -1, -1, 0, y + dev_state->args_[0]);
d1573 1
a1573 1
      dev_state->args_[0] = dev_state->args_[0] ? dev_state->args_[0] : 1;
d1575 1
a1575 1
      scroll_screen (0, y + dev_state->args_[0], -1, -1, 0, y);
d1578 1
a1578 1
      dev_state->args_[0] = dev_state->args_[0] ? dev_state->args_[0] : 1;
d1580 1
a1580 1
      scroll_screen (x, y, -1, y, x + dev_state->args_[0], y);
d1583 1
a1583 1
      dev_state->args_[0] = dev_state->args_[0] ? dev_state->args_[0] : 1;
d1585 1
a1585 1
      scroll_screen (x + dev_state->args_[0], y, -1, y, x, y);
d1588 2
a1589 2
      dev_state->args_[0] = dev_state->args_[0] ? dev_state->args_[0] : 1;
      scroll_screen (0, dev_state->args_[0], -1, -1, 0, 0);
d1592 3
a1594 3
      dev_state->fillin_info (get_output_handle ());
      dev_state->args_[0] = dev_state->args_[0] ? dev_state->args_[0] : 1;
      scroll_screen (0, 0, -1, -1, 0, dev_state->info.winTop + dev_state->args_[0]);
d1597 1
a1597 1
      dev_state->args_[0] = dev_state->args_[0] ? dev_state->args_[0] : 1;
d1599 2
a1600 2
      scroll_screen (x + dev_state->args_[0], y, -1, y, x, y);
      scroll_screen (x, y, -1, y, x + dev_state->args_[0], y);
d1607 1
a1607 1
      if (dev_state->insert_mode)
d1610 1
a1610 1
	  scroll_screen (x, y, -1, y, x + dev_state->args_[1], y);
d1612 2
a1613 2
      while (dev_state->args_[1]--)
	WriteFile (get_output_handle (), &dev_state->args_[0], 1, (DWORD *) &x, 0);
d1616 1
a1616 1
      if (dev_state->saw_greater_than_sign)
d1629 1
a1629 1
      switch (dev_state->args_[0])
d1633 2
a1634 2
	  y -= dev_state->info.winTop;
	  /* x -= dev_state->info.winLeft;		// not available yet */
d1643 2
a1644 2
      dev_state->scroll_region.Top = dev_state->args_[0] ? dev_state->args_[0] - 1 : 0;
      dev_state->scroll_region.Bottom = dev_state->args_[1] ? dev_state->args_[1] - 1 : -1;
d1676 1
a1676 1
  UINT cp = dev_state->get_console_cp ();
d1726 1
a1726 1
	  buf_len = dev_state->str_to_con (f_mbtowc, charset, write_buf,
d1772 1
a1772 1
      buf_len = dev_state->str_to_con (f_mbtowc, charset, write_buf,
d1782 1
a1782 1
      if (dev_state->insert_mode)
d1807 1
a1807 1
	  dev_state->iso_2022_G1 = true;
d1810 1
a1810 1
	  dev_state->iso_2022_G1 = false;
d1816 1
a1816 1
	  dev_state->state_ = gotesc;
d1822 1
a1822 1
	      if (y >= dev_state->info.winBottom && !dev_state->scroll_region.Top)
d1830 1
a1830 1
	  cursor_set (false, ((tc->ti.c_oflag & ONLCR) ? 0 : x), y + 1);
d1899 2
a1900 2
		    dev_state->state_);
      switch (dev_state->state_)
d1910 6
a1915 6
	      dev_state->state_ = gotsquare;
	      dev_state->saw_question_mark = false;
	      dev_state->saw_greater_than_sign = false;
	      for (dev_state->nargs_ = 0; dev_state->nargs_ < MAXARGS; dev_state->nargs_++)
		dev_state->args_[dev_state->nargs_] = 0;
	      dev_state->nargs_ = 0;
d1919 3
a1921 3
	      dev_state->rarg = 0;
	      dev_state->my_title_buf[0] = '\0';
	      dev_state->state_ = gotrsquare;
d1925 1
a1925 1
	      dev_state->state_ = gotparen;
d1929 1
a1929 1
	      dev_state->state_ = gotrparen;
d1933 3
a1935 3
	      dev_state->fillin_info (get_output_handle ());
	      scroll_screen (0, 0, -1, -1, 0, dev_state->info.winTop + 1);
	      dev_state->state_ = normal;
d1939 4
a1942 4
	      dev_state->set_default_attr ();
	      dev_state->vt100_graphics_mode_G0 = false;
	      dev_state->vt100_graphics_mode_G1 = false;
	      dev_state->iso_2022_G1 = false;
d1945 1
a1945 1
	      dev_state->state_ = normal;
d1949 2
a1950 2
	      cursor_set (true, dev_state->savex, dev_state->savey);
	      dev_state->state_ = normal;
d1954 3
a1956 3
	      cursor_get (&dev_state->savex, &dev_state->savey);
	      dev_state->savey -= dev_state->info.winTop;
	      dev_state->state_ = normal;
d1959 1
a1959 1
	      dev_state->state_ = normal;
d1962 1
a1962 1
	      dev_state->state_ = normal;
d1969 1
a1969 1
	      dev_state->args_[dev_state->nargs_] = dev_state->args_[dev_state->nargs_] * 10 + *src - '0';
d1975 3
a1977 3
	      dev_state->nargs_++;
	      if (dev_state->nargs_ >= MAXARGS)
		dev_state->nargs_--;
d1981 1
a1981 1
	      dev_state->state_ = gotcommand;
d1986 1
a1986 1
	  dev_state->state_ = normal;
d1990 3
a1992 3
	    dev_state->rarg = dev_state->rarg * 10 + (*src - '0');
	  else if (*src == ';' && (dev_state->rarg == 2 || dev_state->rarg == 0))
	    dev_state->state_ = gettitle;
d1994 1
a1994 1
	    dev_state->state_ = eattitle;
d2000 1
a2000 1
	    int n = strlen (dev_state->my_title_buf);
d2003 1
a2003 1
		if (*src == '\007' && dev_state->state_ == gettitle)
d2006 2
a2007 2
		      strcpy (old_title, dev_state->my_title_buf);
		    set_console_title (dev_state->my_title_buf);
d2009 1
a2009 1
		dev_state->state_ = normal;
d2013 2
a2014 2
		dev_state->my_title_buf[n++] = *src;
		dev_state->my_title_buf[n] = '\0';
d2022 2
a2023 2
	      dev_state->state_ = gotarg1;
	      dev_state->nargs_++;
d2027 1
a2027 1
	    dev_state->state_ = gotcommand;
d2031 1
a2031 1
		dev_state->saw_question_mark = true;
d2033 1
a2033 1
		dev_state->saw_greater_than_sign = true;
d2038 1
a2038 1
	    dev_state->state_ = gotarg1;
d2042 1
a2042 1
	    dev_state->vt100_graphics_mode_G0 = true;
d2044 2
a2045 2
	    dev_state->vt100_graphics_mode_G0 = false;
	  dev_state->state_ = normal;
d2050 1
a2050 1
	    dev_state->vt100_graphics_mode_G1 = true;
d2052 2
a2053 2
	    dev_state->vt100_graphics_mode_G1 = false;
	  dev_state->state_ = normal;
d2160 1
a2160 1
  return !tcsetattr (0, &tc->ti);
d2166 1
a2166 1
  return tc->ti.c_iflag & IGNCR;
d2188 1
a2188 1
  ((fhandler_console *)archetype)->tc = tc = get_tty_stuff ();
@


1.232
log
@* autoload.cc: Call _api_fatal in asm.
* child_info.h: Redefine CURR_CHILD_INFO_MAGIC.
(child_info_fork::abort): Rename from handle_failure.  Change arguments.
* cygtls.h (_local_storage::ttybuf): New field.
* dcrt0.cc (vapi_fatal): Split api_fatal.  Add "in forked process" to message
when appropriate.
(api_fatal): Use vapi_fatal.
* devices.h: Make multiple inclusion safe.
(fh_devices): Add FH_CONS* stuff.  Reorder slightly.
(device): Eliminate anonymous union.  Add more ways to access minor/major.
(device::setunit): Accommodate no-longer-anonymous union.
(device::is_fs): Ditto.
(device::is_fs_special): Ditto.
(device::major): New function.
(device::minor): Ditto.
(device::is_device): New function.
(device::not_device): Ditto.
(device::operator int): New operator.
(device::operator fh_devices): Ditto.
(device::operator bool): Ditto.
(device::operator DWORD): Ditto.
(device::operator =): Ditto.
(isproc_dev): New function.
(isprocsys_dev): Ditto.
(iscons_dev): Ditto.
(istty_slave_dev): Ditto.
* devices.in: Add new "/dev/cons*" strings.  Accommodate no-longer-anonymous
union throughout.
(BRACK): Use more precise method for initialization.
* devices.cc: Regenerate.
* dtable.cc (dtable::stdio_init): Use get_cttyp instead of get_tty.
(dtable::find_archetype): Use new DWORD operator in device to test archetypes.
(dtable::init_std_file_from_handle): Use different method to initialize 'dev'.
Adapt to different ctty handling and accommodate /dev/cons*.
(fh_alloc): Accommodate no-longer-anonymous union.  Adapt to new /dev/cons*.
(build_fh_pc): Make debugging output more useful.
* exceptions.cc (ctrl_c_handler): Use get_cttyp instead of get_tty.
* external.cc (fillout_pinfo): Accommodate new cons* stuff.
* fhandler.cc (fhandler_base::read): Eliminate is_slow() test.
* fhandler.h (fhandler_base::*): Adapt to changes in device.h.
(fhandler_*::is_slow): Delete.
( fhandler_proc::get_proc_fhandler): Return fh_devices type.
* fhandler_console.cc (open_shared_console): New function.
(console_unit): New class.
(console_unit::console_unit): New constructor.
(enum_windows): New function.  Declare as friend to console_unit.
(fhandler_console::set_unit): New function.
(fhandler_console::get_tty_stuff): Call set_unit to set the unit number and
determine if initialization is needed.  Eliminate flags parameter.
(tty_list::get_cttyp): Rename (sorta) from get_tty.  Return pointer to correct
tty_min.
(fhandler_console::open): Adapt to elimination of argument to get_tty_stuff.
(fhandler_console::output_tcsetattr): Properly detect error condition.
(fhandler_console::fixup_after_fork_exec): Adapt to get_tty_stuff() setting tc
automatically.
* fhandler_proc.cc: Use FH_BAD rather than 0 throughout where using fh_devices
enum.
(fhandler_proc::get_proc_fhandler): Return fh_devices.  Adapt to devices.h
changes.
* fhandler_process.cc: Adapt to devices.h changes.  Use FH_BAD rather than 0
throughout where using fh_devices enum.
* fhandler_procnet.cc: Ditto.
* fhandler_procsys.cc: Ditto.
* fhandler_procsysvipc.cc: Ditto.
* fhandler_tape.cc (fhandler_dev_tape::fhandler_dev_tape): Ditto.
* fhandler_termios.cc (handler_termios::bg_check): Use tc->ttyname() rather
than assuming that we can construct a tty.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Just return
get_minor() of dev.
(fhandler_pty_master::process_slave_output): Add slightly more debugging info.
(fhandler_tty_slave::fhandler_tty_slave): Change name from ntty to unit.
(fhandler_pty_master::open): Ditto.
(fhandler_tty_slave::ioctl): Adapt to change which causes ctty to represent a
complete device.
(fhandler_tty_master::init_console): Add debugging for failure path.
(fhandler_pty_master::setup): Use get_unit() to retrieve unit number rather
than relying on raw ntty.
(fhandler_pty_master::setup): Ditto.
* fhandler_virtual.h (virt_tab_t): Redefine fhandler as fh_devices.
* fork.cc: Remove obsolete vfork stuff.
(frok::child): Don't assume that a ctty == 0 is valid.
* mount.cc (mount_info::conv_to_win32_path): Adapt to device struct changes.
(mount_info::conv_to_win32_path): Ditto.
* path.cc (path_conv::check): Retrive major/minor numbers via a method rather
than accessing them directly from device.  Rely on dev operators to
set/retrieve device information as required by device struct change.
* path.h (isproc_dev): Move to devices.h.
(isprocsys_dev): Ditto.
(isvirtual_dev): Ditto.
(path_conv:{isdevice,isfifo,isspecial,iscygdrive,issocket,get_devn,get_unitn}):
Use device methods to access/manipulate devices.
* pinfo.cc (pinfo::exit): Don't assume that ctty == 0 is valid.  Use iscons_dev
to determine if a device is a console.
(_pinfo::_ctty): Use device::parse to generate tty/cons name.
(_pinfo::set_ctty): Don't assume that ctty == 0 is valid.  Remove redundant
info from debugging.
* shared.cc (offsets): Remove console offset.
* shared_info.h (shared_locations): Ditto.
* syscalls.cc (umask): Use device methods to manipulate device information.
(ctermid): Use device::parse to generate term device name.
* tlsoffsets.h: Regenerate.
* tty.cc (ttyslot): Return minor number of ctty since ctty now represents a
full device.
(tty::create_master): Set ctty to a complete device.
(tty_list::attach): Rework to detect new /dev/cons* stuff.
(tty_list::terminate): Adapt to changes to ctty.
(tty_list::init): Adapt to change to setntty - pass in device major number.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Define new function.
* tty.h (tty_min::ntty): Redefine as fh_devices.
(tty::exists): Use get_unit() to retrive tty unit number.
(tty::open_mutex): Ditto.
(tty::open_inuse): Ditto.
(tty::create_inuse): Ditto.
(tty::get_event): Ditto.
(tty_min::ttyname): Declare new function.
(tty::getntty): Declare as const.
(tty_list::operator []): Assure that only minor part of argument is used.
* dll_init.cc (dll_list::alloc): Detect mismatch of data segments early issuing
an explicit error message if necessary.
* heap.cc (heap_init): Adapt to changes from fork->handle_failure to
fork->abort.
* pinfo.h (EXITCODE_FORK_FAILED): New enum.  (from Ryan Johnson)
* sigproc.cc (child_info_fork::abort): Rename from handle_failure.  Change
arguments to allow passing in a printf-like message.
* winsup.h (api_fatal): Delete macro definition.
(api_fatal): Redefine from __api_fatal.
(vapi_fatal): Declare new function.
* include/sys/strace.h (strace_vprintf): Define new macro.
* ntdll.h (_SYSTEM_INFORMATION_CLASS): Add SystemHandleInformation.
@
text
@a129 1

a194 1
  static tty_min nada;
d197 2
a198 2
    return &shared_console_info->tty_min_state;
  else if (n > 0)
d201 1
a201 1
    return &nada;
@


1.231
log
@* fhandler.cc (fhandler_base::dup): Avoid duping a handle when an fhandler has
an archetype.
* fhandler_console.cc (fhandler_console::invisible_console): Move to the top.
(fhandler_console::set_close_on_exec): Don't set close-on-exec on handle since
it's an archetype and you don't know how many things could be using it.
@
text
@d81 73
d157 1
a157 1
fhandler_console::get_tty_stuff (int flags = 0)
d159 2
a160 2
  if (dev_state)
    return &shared_console_info->tty_min_state;
d162 25
a186 36
  shared_console_info =
    (console_state *) open_shared (NULL, 0, cygheap->console_h,
				   sizeof (*shared_console_info),
				   SH_SHARED_CONSOLE);
  dev_state = &shared_console_info->dev_state;

  ProtectHandleINH (cygheap->console_h);
  if (!shared_console_info->tty_min_state.ntty)
    {
      shared_console_info->tty_min_state.setntty (TTY_CONSOLE);

      dev_state->scroll_region.Bottom = -1;
      dev_state->dwLastCursorPosition.X = -1;
      dev_state->dwLastCursorPosition.Y = -1;
      dev_state->dwLastMousePosition.X = -1;
      dev_state->dwLastMousePosition.Y = -1;
      dev_state->dwLastButtonState = 0;	/* none pressed */
      dev_state->last_button_code = 3;	/* released */
      dev_state->underline_color = FOREGROUND_GREEN | FOREGROUND_BLUE;
      dev_state->dim_color = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
      dev_state->meta_mask = LEFT_ALT_PRESSED;
      /* Set the mask that determines if an input keystroke is modified by
	 META.  We set this based on the keyboard layout language loaded
	 for the current thread.  The left <ALT> key always generates
	 META, but the right <ALT> key only generates META if we are using
	 an English keyboard because many "international" keyboards
	 replace common shell symbols ('[', '{', etc.) with accented
	 language-specific characters (umlaut, accent grave, etc.).  On
	 these keyboards right <ALT> (called AltGr) is used to produce the
	 shell symbols and should not be interpreted as META. */
      if (PRIMARYLANGID (LOWORD (GetKeyboardLayout (0))) == LANG_ENGLISH)
	dev_state->meta_mask |= RIGHT_ALT_PRESSED;
      dev_state->set_default_attr ();
      dev_state->backspace_keycode = CERASE;
      shared_console_info->tty_min_state.sethwnd ((HWND) INVALID_HANDLE_VALUE);
    }
d194 1
a194 1
tty_list::get_tty (int n)
d197 2
a198 1
  if (n == TTY_CONSOLE)
d200 2
a201 2
  else if (n >= 0)
    return &cygwin_shared->tty.ttys[n];
d761 1
a761 1
  tcinit (get_tty_stuff (flags), false);
d913 1
a913 1
  if (!res)
d1040 2
a1041 1
  dev ().parse (FH_CONSOLE);
d2188 1
a2188 1
  get_tty_stuff ();
@


1.230
log
@* cygheap.cc (cygheap::close_ctty): Close ctty via close_with_arch().
* debug.cc (close_handle): Call debugger on failure.
* devices.in (device::tty_to_real_device): Delete.
* devices.h (device::tty_to_real_device): Ditto.
* devices.cc: Regenerate.
* dtable.cc: Delete old ifdef'ed vfork code.
(dtable::release): Don't handle archetype here.
(dtable::init_std_file_from_handle): Consolidate console tests.  Generate
major/minor for tty ASAP.  Fix incorrect setting of DEV_TTYS* for serial.
(fh_alloc): New function derived from build_fh_pc.  Pass current tty when
building tty.
(build_pc_pc): Use fh_alloc to create.  Set name from fh->dev if appropriate.
Generate an archetype or point to one here.
(dtable::dup_worker): Deal with archetypes.  Rely on = operator copying whole
class rather than just fhandler_base.
(dtable::fixup_after_exec): Call close_with_arch to handle closing of fhandlers
with archetypes.
* fhandler.cc (fhandler_base::operator =): Call memcpy with fhandler's size()
rather than sizeof fhandler_base.
(fhandler_base::open_with_arch): New function.  Handles opening of fhandler's
with archetypes, dealing with usecounts, etc.
(fhandler_base::close_with_arch): Ditto for close.
* fhandler.h: Many changes for archetypes.
(fhandler_base::set_name): Set both normalized path and regular path.
(fhandler_base::open_with_arch): New function.
(fhandler_base::open_setup): Ditto.
(fhandler_base::use_archetype): Ditto.
(fhandler_base::_archetype_usecount): Ditto.
(fhandler_*::size): Ditto.
(fhandler_dev_tape::open): Remove virtual decoration.
(fhandler_console::use_archetype): New function.  Return true.
(fhandler_console::open_setup): New function.
(fhandler_console::dup): Delete.
(fhandler_tty_slave::fhandler_tty_slave): Redeclare to take an argument.
(fhandler_tty_slave::use_archetype): New function.  Return true.
(fhandler_tty_slave::cleanup): New function.
(fhandler_pty_master::use_archetype): New function.  Return true.
(fhandler_pty_master::cleanup): New function.
(fhandler_pty_master::is_tty_master): New function.  Return false.
(fhandler_tty_master::is_tty_master): New function.  Return true.
(fhandler_dev_dsp::fhandler_dev_dsp): New function.  Return true.
(report_tty_counts): Only report on archetype's usecount if there is one.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove handling of
setsid, set_ctty, set_flags, and manage_console_count.
(fhandler_console::open_setup): New function.  Implement functionality removed
from get_tty_stuff.
(fhandler_console::dup): Delete.
(fhandler_console::output_tcsetattr): Set errno on error.
(fhandler_console::fhandler_console): Set device early.
(fhandler_console::init): Use open_with_arch to open console handles.
(fhandler_console::fixup_after_fork_exec): Nuke most of the stuff for dealing
with console handles.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Remove archetype handling.
(fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
(fhandler_dev_dsp::close): Ditto.
(fhandler_dev_dsp::dup): Ditto.
(fhandler_dev_dsp::ioctl): Ditto.
(fhandler_dev_dsp::fixup_after_fork): Ditto.
(fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_common::__acquire_output_mutex): Add a little
more debugging.
(fhandler_tty_common::__release_output_mutex): Ditto.
(fhandler_pty_master::process_slave_output): Ditto.  Don't do signal handling
or pthread_cancel handling in the tty master thread.
(process_output): Minor reorg.
(fhandler_tty_slave::fhandler_tty_slave): Set device based on new ntty
argument.
(fhandler_tty_slave::open): Remove archetype handling.  Move some processing
into open_setup().
(fhandler_tty_slave::open_setup): New function.
(fhandler_tty_slave::cleanup): New function.
(fhandler_tty_slave::close): Remove archetype handling.  Move some processing
into cleanup().
(fhandler_tty_slave::init): Rename argument from f to h.  Open device using
open_with_arch().  Remove archetype handling.
(fhandler_pty_master::dup): Ditto.
(fhandler_pty_master::open): Ditto.
(fhandler_pty_master::close): Ditto.  Move some handling to cleanup().
(fhandler_pty_master::cleanup): New function.
(fhandler_tty_master::init_console): Give unique name to captive console
fhandler.
* pinfo.cc (_pinfo::set_ctty): Rename argument from arch to fh.  Eliminate
archetype assumption.
* syscalls.cc (close_all_files): Use close_with_arch for closing.
(open): Use open_with_arch() rather than open().
(close): Use close_with_arch() rather than close().
@
text
@d59 2
d2108 1
a2108 2
  fhandler_base::set_close_on_exec (val);
  set_no_inheritance (output_handle, val);
a2126 2
bool NO_COPY fhandler_console::invisible_console;

@


1.229
log
@	* pinfo.h (class push_process_state): New class to push a process state
	flag temporarily into myself->process_state.
	* fhandler_console.cc (fhandler_console::read): Add push_process_state
	handler.
	(fhandler_console::write): Call bg_check from here.  Add
	push_process_state handler.
	* fhandler_tty.cc (fhandler_tty_slave::write): Ditto.
	(fhandler_tty_slave::read): Ditto.
	(fhandler_pty_master::write): Ditto.
	(fhandler_pty_master::read): Ditto.
	* syscalls.cc (readv): Remove bg_check call and setting process state.
	(writev): Ditto.
@
text
@a96 2
      shared_console_info->tty_min_state.setsid (myself->sid);
      myself->set_ctty (&shared_console_info->tty_min_state, flags, this);
a700 2
  set_flags ((flags & ~O_TEXT) | O_BINARY);

a733 1
  cygheap->manage_console_count ("fhandler_console::open", 1);
d746 8
a763 13
/*  Special console dup to duplicate input and output  handles.  */

int
fhandler_console::dup (fhandler_base *child)
{
  fhandler_console *fhc = (fhandler_console *) child;

  if (!fhc->open (get_flags () & ~O_NOCTTY, 0))
    system_printf ("error opening console, %E");

  return 0;
}

d848 2
d975 1
d2090 1
a2090 1
  open (flags | O_BINARY | (h ? 0 : O_NOCTTY));
d2123 1
a2123 18
  HANDLE h = get_handle ();
  HANDLE oh = get_output_handle ();

  if ((execing && close_on_exec ()) || open (O_NOCTTY | get_flags (), 0))
    cygheap->manage_console_count ("fhandler_console::fixup_after_fork_exec", -1);
  else
    {
      if (!get_io_handle ())
	system_printf ("error opening input console handle for %s after fork/exec, errno %d, %E", get_name (), get_errno ());
      if (!get_output_handle ())
	system_printf ("error opening output console handle for %s after fork/exec, errno %d, %E", get_name (), get_errno ());
    }

  if (!close_on_exec ())
    {
      CloseHandle (h);
      CloseHandle (oh);
    }
@


1.228
log
@	* fhandler.h (class fhandler_base): Remove uninterruptible_io status
	flag.
	(fhandler_base::ready_for_read): Remove declaration.
	(fhandler_socket::ready_for_read): Ditto.
	(fhandler_pipe::ready_for_read): Ditto.
	(fhandler_tty_master::is_slow): Remove.
	* fhandler_console.cc (fhandler_console::open): Drop setting
	uninterruptible_io.
	* fhandler_serial.cc (fhandler_serial::open): Ditto.
	* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Ditto.
	(fhandler_tty_master::init_console): Ditto.
	* pipe.cc (fhandler_pipe::fhandler_pipe): Ditto.
	(fhandler_pipe::open): Ditto.
	(_pipe): Ditto.
	* select.cc (fhandler_pipe::ready_for_read): Remove.
	(fhandler_base::ready_for_read): Remove.
	* syscalls.cc (readv): Drop unneeded wait variable.  Remove entire test
	which might lead to calling ready_for_read.  Remove now unused label
	out.
@
text
@d250 2
d293 1
d1820 6
@


1.227
log
@	* fhandler_console.cc (fhandler_console::read): Make restartable and
	cancelable.
@
text
@a712 1
  uninterruptible_io (true);	// Handled explicitly in read code
@


1.226
log
@	* autoload.cc (GetConsoleWindow): Drop.
	(GetSystemWindowsDirectoryW): Drop.
	* fhandler_console.cc (beep): Call GetSystemWindowsDirectoryW instead of
	GetWindowsDirectoryW.
	* uinfo.cc (cygheap_user::env_systemroot): Call
	GetSystemWindowsDirectoryW and convert to multibyte on the fly.
	* winlean.h (GetWindowsDirectoryW): Redefine to something invalid.
	Explain why.
@
text
@d265 3
a267 2
  HANDLE w4[2];
  DWORD nwait;
a269 9
  w4[0] = h;
  if (&_my_tls != _main_tls)
    nwait = 1;
  else
    {
      w4[1] = signal_arrived;
      nwait = 2;
    }

d281 2
a282 1
      switch (WaitForMultipleObjects (nwait, w4, FALSE, INFINITE))
d287 2
d290 7
@


1.225
log
@	* Makefile.in (DLL_IMPORTS): Drop advapi32.dll.
	* autoload.cc: Enable autoloading advapi32 functions.
	* environ.cc (regopt): Use wide char arguments in reg_key functions.
	* fhandler_console.cc (beep): Ditto.  Use WCHAR throughout.
	* registry.cc (reg_key): Rewrite reg_key class to use native NT registry
	functions.  Use WCHAR string parameters throughout.  Use PCWSTR rather
	than const WCHAR.  Drop multibyte char functionality.  Drop unused
	methods.
	(get_registry_hive_path): Use RtlQueryRegistryValues to fetch path from
	registry.
	(load_registry_hive): Drop useless check for user hive being available.
	Load hive using NtLoadKey.
	* registry.h: Accommodate above changes.
	* sched.cc (sched_rr_get_interval): Use wide char arguments in reg_key
	functions.
	* shared.cc (init_installation_root): Ditto.
	(shared_info::init_obcaseinsensitive): Use RtlQueryRegistryValues to
	fetch obcaseinsensitive value.
	(shared_info::heap_slop_size): Use wide char arguments in reg_key
	functions.
	(shared_info::heap_chunk_size): Ditto.
	* syscalls.cc (gethostid): Ditto.
	* winsup.h (__WIDE): Define.
	(_WIDE): Define.
	* libc/minires-os-if.c (get_registry_dns_items): Don't fetch values
	from registry.  Just extract them from given UNICODE_STRING parameter.
	(get_registry_dns): Fetch all registry values at once using
	RtlQueryRegistryValues.
@
text
@d70 1
a70 1
      UINT len = GetWindowsDirectoryW (buf, 0) * sizeof (WCHAR);
d72 1
a72 1
      UINT res = GetWindowsDirectoryW (buf, len);
@


1.224
log
@* cygheap.h (init_cygheap::ctty): Use base class so that console can join in
the fun.
* dtable.cc (dtable::stdio_init): Remove special-case call to set_console_ctty
().
* exceptions.cc (sigpacket::process): Conditionally flush terminal input on
certain signals.
* fhandler.h (fhandler_console::get_tty_stuff): Make non-static.
(fhandler_termios::get_ttyp): Move here.
(fhandler_termios::sigflush): Declare.
(fhandler_tty_common::get_ttyp): Delete.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass this as "arch"
argument.
(set_console_ctty): Delete.
(tty_list::get_tty): Just return pointer to shared console region, delaying
get_tty_stuff until open().
(fhandler_console::init): Treat NULL handle as signifying that console should
be opened with O_NOCTTY flag.  Rename handle argument to the more common 'h'.
* fhandler_termios.cc (fhandler_termios::sigflush): Define.
* fhandler_tty.cc (handler_tty_master::init_console): Pass NULL as first
argument to fhandler_console::init.
* pinfo.cc (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
Add extra debugging.
* pinfo.h (_pinfo::set_ctty): Change third parameter to fhandler_termios *.
* sigproc.cc (handle_sigsuspend): Don't special-case non-main threads.
@
text
@d64 3
a66 2
  reg_key r (HKEY_CURRENT_USER, KEY_ALL_ACCESS, "AppEvents", "Schemes", "Apps",
	     ".Default", ".Default", ".Current", NULL);
d69 4
a72 4
      char *buf = NULL;
      UINT len = GetWindowsDirectory (buf, 0);
      buf = (char *) alloca (len += sizeof ("\\media\\ding.wav"));
      UINT res = GetWindowsDirectory (buf, len);
d74 1
a74 1
	r.set_string ("", strcat (buf, "\\media\\ding.wav"));
@


1.223
log
@	* Throughout fix copyright dates.
@
text
@d97 1
a97 1
      myself->set_ctty (&shared_console_info->tty_min_state, flags, NULL);
a127 6
void
set_console_ctty ()
{
  fhandler_console::get_tty_stuff ();
}

d135 1
a135 1
    return fhandler_console::get_tty_stuff ();
d2073 1
a2073 1
fhandler_console::init (HANDLE f, DWORD a, mode_t bin)
d2075 1
a2075 1
  // this->fhandler_termios::init (f, mode, bin);
d2086 3
a2088 3
  open (flags | O_BINARY);
  if (f != INVALID_HANDLE_VALUE)
    CloseHandle (f);	/* Reopened by open */
@


1.222
log
@	* fhandler_console.cc (fhandler_console::write_normal): Remove
	erroneous premature return after collecting truncated multibyte
	sequence in trunc_buf.  Rather fall through to printing routine.
	Fix return value to take trunc_buf content into account.  Improve
	comments.
@
text
@d4 1
a4 1
   2006, 2008, 2009, 2010 Red Hat, Inc.
@


1.221
log
@* fhandler.h (fhandler_termios::tcinit): Make second argument non-optional.
* fhandler_console.cc (fhandler_console::open): Specify second argument to
tcinit.
* fhandler_termios.cc (fhandler_termios::tcinit): Rename second argument.  Set
pgid to 0 if this is a pty master.
(fhandler_termios::tcgetpgrp): Just return value of pgid.  It will be zero if
not initialized.
* fhandler_tty.cc (fhandler_tty_slave::open): Specify second argument to
tcinit.
(fhandler_tty_slave::ioctl): Implement TIOCGPRP/TIOCSPGRP.  Fix switch
indentation.
(fhandler_tty_master::ioctl): Implement TIOCGPRP/TIOCSPGRP.
* include/sys/termios.h (TIOCGPGRP): Define similarly to Linux.
* include/sys/termios.h (TIOCSPGRP): Ditto.
@
text
@d1682 3
d1693 1
a1693 2
	case -2:
	  /* Truncated multibyte sequence.  Stick to it until the next write. */
d1696 3
a1698 3
	  return end;
	case -1:
	  break;
a1705 2
      if (ret == (size_t) -1)		/* Invalid multibyte sequence. */
	break;
d1708 3
a1710 1
  /* Print all the base ones out */
d1736 1
d1738 1
a1738 1
	return found;
d1740 4
a1743 2

  if (found < end)
d1815 1
a1815 1
  return found;
@


1.220
log
@* dcrt0.cc (dll_crt0_0): Move _main_tls initialization here.
(__dll_crt0): Only initialize _main_tls if it changes.
* fhandler_console.cc (fhandler_console::write): Fix debugging output.
@
text
@d698 1
a698 1
  tcinit (get_tty_stuff (flags));
@


1.219
log
@* cygthread.h (cygthread::cygthread): Reorganize slightly.
* dcrt0.cc (dll_crt0_0): Move sigproc initialization later to ensure everything
we need has been set up.
(dll_crt0_1): Streamline some logic slightly.
* sigproc.cc (no_signals_available): Add back dropped test for macro parameter.
* fhandler_console.cc (fhandler_console::write): Show a little bit of what's
being written to the console in debugging output.
@
text
@d1990 1
a1990 1
  syscall_printf ("%d = fhandler_console::write (\".20s\")", len, vsrc);
@


1.218
log
@	* fhandler.h (class dev_console): Add backspace_keycode member.
	* fhandler_console.cc (fhandler_console::get_tty_stuff): Initialize
	backspace_keycode with CERASE.
	(fhandler_console::read): Return dev_state->backspace_keycode if the
	backspace key is pressed.
	(fhandler_console::char_command): Implement DECBKM escape sequence.
@
text
@d1990 1
a1990 1
  syscall_printf ("%d = fhandler_console::write (,..%d)", len, len);
@


1.217
log
@* fhandler_console.cc (fhandler_console::read): Default to sending CERASE
character if termios VERASE field is zero.
(fhandler_console::fixup_after_fork_exec): Avoid a spurious debug message.
@
text
@d121 1
a377 1
	  /* Send the VERASE character from the terminal settings as backspace keycode. */
d380 1
a380 1
	      char c = ti.c_cc[VERASE] ?: CERASE;
d1401 4
@


1.216
log
@2010-03-30  Thomas Wolff  <towo@@towo.net>

	* fhandler.h (class dev_console): Drop vt100_graphics_mode_active.
	Add flags vt100_graphics_mode_G0, vt100_graphics_mode_G1 and
	iso_2022_G1.
	* fhandler_console.cc: Throughout, tune VT100 graphics mode switching
	to follow ISO 2022 strictly.
@
text
@d380 1
a380 1
	      char c = ti.c_cc[VERASE];
a2122 1
      bool sawerr = false;
d2124 1
a2124 4
	{
	  system_printf ("error opening input console handle for %s after fork/exec, errno %d, %E", get_name (), get_errno ());
	  sawerr = true;
	}
d2126 1
a2126 7
	{
	  system_printf ("error opening output console handle for %s after fork/exec, errno %d, %E", get_name (), get_errno ());
	  sawerr = true;
	}

      if (!sawerr)
	system_printf ("error opening console after fork/exec, errno %d, %E", get_errno ());
@


1.215
log
@* shared_info.h (open_shared): Create function wrapper for common use case.
(open_shared): Change fifth argument to a pointer rather than a reference.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Eliminate use of dummy
variable and call open_shared with constant.
* fhandler_process.cc (format_process_mounts): Ditto.
* pinfo.cc (pinfo::init): Pass pointer to shloc.
* shared.cc (shared_mem_inited): New variable.
(open_shared): Crate function wrapper for common use case.
(open_shared): Accommodate change to fifth argument to a pointer.
(shared_info::initialize): Remove spinlock test.  Simplify function.  Move
get_session_parent_dir call back here.
(memory_init): Protect global shared settings with shared_mem_inited spinlock.
Move get_session_parent_dir call to shared_info::initialize.
@
text
@d1164 3
a1166 1
  if (dev_state->vt100_graphics_mode_active)
d1739 2
a1740 2
	case SO:
	  dev_state->vt100_graphics_mode_active = true;
d1742 2
a1743 2
	case SI:
	  dev_state->vt100_graphics_mode_active = false;
d1867 3
d1967 1
a1967 1
	case gotparen:
d1969 1
a1969 1
	    dev_state->vt100_graphics_mode_active = true;
d1971 1
a1971 1
	    dev_state->vt100_graphics_mode_active = false;
d1975 1
a1975 2
	case gotrparen:
	  /* This is not strictly needed, ^N/^O can just always be enabled */
d1977 1
a1977 1
	    /*dev_state->vt100_graphics_mode_SOSI_enabled = true*/;
d1979 1
a1979 1
	    /*dev_state->vt100_graphics_mode_SOSI_enabled = false*/;
@


1.214
log
@	* cygwin.din (dup3): Export.
	(pipe2): Export.
	* dtable.cc (dtable::dup_worker): Take additional flags parameter.
	Handle O_CLOEXEC flag.
	(dtable::dup3): Rename from dup2.  Take additional flags parameter.
	Check for valid flags.  Drop check for newfd == oldfd.
	* dtable.h (dtable::dup_worker): Add flags parameter.
	(dtable::dup3): Rename from dup2.
	* fcntl.cc (fcntl64): Add F_DUPFD_CLOEXEC case.
	* fhandler.h (fhandler_mailslot::get_object_attr): Add flags parameter.
	* fhandler.cc (fhandler_base::open): Use security attribute with
	inheritance according to setting of O_CLOEXEC flag.
	* fhandler_console.cc (fhandler_console::open): Ditto.
	* fhandler_fifo.cc (sec_user_cloexec): New inline function to
	create security attribute with inheritance according to setting of
	O_CLOEXEC flag.
	(fhandler_fifo::open): Call sec_user_cloexec to fetch security
	attribute.
	(fhandler_fifo::wait): Ditto.
	* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::get_object_attr): Take
	additional flags parameter.  Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(fhandler_mailslot::open): Call get_object_attr with flags parameter.
	* fhandler_registry.cc (fhandler_registry::open): Call set_close_on_exec
	on real handles to accommodate O_CLOEXEC flag.
	* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
	* fhandler_tape.cc: Create mutex with inheritance according to setting
	of O_CLOEXEC flag.
	* pipe.cc: Replace usage of O_NOINHERIT with O_CLOEXEC.
	 (fhandler_pipe::init): Simplify setting close_on_exec flag.
	(fhandler_pipe::open): Remove setting close_on_exec flag.
	(fhandler_pipe::create): Use security attribute with inheritance
	according to setting of O_CLOEXEC flag.
	(pipe2): New exported function.
	* posix_ipc.cc: Throughout, open backing files with O_CLOEXEC
	flag to follow POSIX semantics.
	* security.h (sec_none_cloexec): New define.
	* syscalls.cc (dup): Add missing extern "C" qualifier.  Accommodate
	renaming of dtable::dup2 to dtable::dup3.
	(dup2): Ditto.  Check newfd == oldfd here.
	(dup3): New function.  Check newfd == oldfd here.
	(open): Set close_on_exec flag according to O_CLOEXEC flag before
	calling fhandler->open.
	* include/cygwin/version.h (CYGWIN_VERSION_API_MINOR): Bump.
@
text
@a85 1
  shared_locations sh_shared_console = SH_SHARED_CONSOLE;
d89 1
a89 1
				   sh_shared_console);
@


1.213
log
@* fhandler_console.cc (handler_console::read): Use the tty's VERASE character
as the backspace keycode.
@
text
@d4 1
a4 1
   2006, 2008, 2009 Red Hat, Inc.
d708 1
a708 1
		  FILE_SHARE_READ | FILE_SHARE_WRITE, &sec_none,
d720 1
a720 1
		  FILE_SHARE_READ | FILE_SHARE_WRITE, &sec_none,
@


1.212
log
@	* fhandler_console.cc (get_nonascii_key): Generate ESC prefix
	for Alt modifier generically for function keys and keypad keys.
	Distinguish Normal, Ctrl, Shift, Ctrl-Shift rather
	than Normal, Ctrl, Shift, Alt, so that in combination with generic
	Alt handling all 8 combinations of these modifiers are distinguished.
	(keytable): Add escape sequences for remaining modified
	function keys as a compatible extension using rxvt escape codes.
	Also distinguish keypad keys modified with Ctrl, Shift, Ctrl-Shift
	using xterm-style modifier coding.
@
text
@d378 1
a378 2
	  /* Adopt the linux standard of translating the backspace key to DEL
	     except when ALT is pressed.  */
d381 11
a391 3
	      toadd = (control_key_state & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))
		      ? (dev_state->metabit ? "\377" : "\033\177") : "\177";
	      nread = strlen (toadd);
@


1.211
log
@	* fhandler_console.cc (__vt100_conv): Minor formatting change.
@
text
@d1985 30
a2014 25
	       /* NORMAL */    /* SHIFT */     /* CTRL */     /* ALT */
  {VK_LEFT,	{"\033[D",	"\033[D",	"\033[D",	"\033\033[D"}},
  {VK_RIGHT,	{"\033[C",	"\033[C",	"\033[C",	"\033\033[C"}},
  {VK_UP,	{"\033[A",	"\033[A",	"\033[A",	"\033\033[A"}},
  {VK_DOWN,	{"\033[B",	"\033[B",	"\033[B",	"\033\033[B"}},
  {VK_PRIOR,	{"\033[5~",	"\033[5~",	"\033[5~",	"\033\033[5~"}},
  {VK_NEXT,	{"\033[6~",	"\033[6~",	"\033[6~",	"\033\033[6~"}},
  {VK_HOME,	{"\033[1~",	"\033[1~",	"\033[1~",	"\033\033[1~"}},
  {VK_END,	{"\033[4~",	"\033[4~",	"\033[4~",	"\033\033[4~"}},
  {VK_INSERT,	{"\033[2~",	"\033[2~",	"\033[2~",	"\033\033[2~"}},
  {VK_DELETE,	{"\033[3~",	"\033[3~",	"\033[3~",	"\033\033[3~"}},
  {VK_F1,	{"\033[[A",	"\033[23~",	NULL,		NULL}},
  {VK_F2,	{"\033[[B",	"\033[24~",	NULL,		NULL}},
  {VK_F3,	{"\033[[C",	"\033[25~",	NULL,		NULL}},
  {VK_F4,	{"\033[[D",	"\033[26~",	NULL,		NULL}},
  {VK_F5,	{"\033[[E",	"\033[28~",	NULL,		NULL}},
  {VK_F6,	{"\033[17~",	"\033[29~",	"\036",		NULL}},
  {VK_F7,	{"\033[18~",	"\033[31~",	NULL,		NULL}},
  {VK_F8,	{"\033[19~",	"\033[32~",	NULL,		NULL}},
  {VK_F9,	{"\033[20~",	"\033[33~",	NULL,		NULL}},
  {VK_F10,	{"\033[21~",	"\033[34~",	NULL,		NULL}},
  {VK_F11,	{"\033[23~",	NULL,		NULL,		NULL}},
  {VK_F12,	{"\033[24~",	NULL,		NULL,		NULL}},
  {VK_NUMPAD5,	{"\033[G",	NULL,		NULL,		NULL}},
  {VK_CLEAR,	{"\033[G",	NULL,		NULL,		NULL}},
d2016 2
a2017 1
  {0,		{"",		NULL,		NULL,		NULL}}
d2026 2
a2027 1
#define ALT	3
a2028 1

d2031 1
a2031 1
  else if (input_rec.Event.KeyEvent.dwControlKeyState &
d2033 1
a2033 4
    modifier_index = CONTROL;
  else if (input_rec.Event.KeyEvent.dwControlKeyState &
		(LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))
    modifier_index = ALT;
d2037 12
a2048 1
      return keytable[i].val[modifier_index];
@


1.210
log
@	* fhandler_console.cc (write_console): Check for VT100
	graphics mode and transform wide characters in ASCII small
	letter range to corresponding graphics.
	(__vt100_conv): Table to transform small ASCII letters to line
	drawing graphics for use in VT100 graphics mode.
	(write_normal): Check for SO/SI control characters to
	enable/disable VT100 graphics mode.
	(base_chars): Enable SO/SI control characters for detection.
	(write): Check for ESC ( 0 / ESC ( B escape sequences to
	enable/disable VT100 graphics mode. Also detect ">" while
	parsing ESC [ sequences to distinguish specific requests.
	(char_command): Distinguish Secondary from Primary Device Attribute
	request to report more details about cygwin console terminal version.
	* fhandler.h (vt100_graphics_mode_active): New flag to indicate mode.
	(saw_greater_than_sign): New parse flag for ESC [ > sequences.
	(gotparen, gotrparen): New state values to parse ESC ( / ) sequences.

	* fhandler_console.cc (read): Allow combined Alt-AltGr modifiers
	to also produce an ESC prefix like a plain Alt modifier, e.g. to make
	Alt-@@ work on a keyboard where @@ is AltGr-q.
@
text
@a1118 1
static wchar_t __vt100_conv [31] = {
d1121 1
@


1.209
log
@	* fhandler_console.cc (read): Detect and handle mouse wheel scrolling
	events (for completion of mouse reporting mode 1000) and mouse
	movement events (for additional mouse reporting modes 1002 and 1003).
	Use mouse_aware() as a guard and only condition for mouse
	reporting in order to enforce consistence of read() and select().
	Add focus reports (for additional focus reporting mode 1004).
	(mouse_aware): Enable detection of additional mouse events for select().
	Tune function to precisely match actual reporting criteria.
	Move adjustment of mouse position (by window scroll offset)
	here to avoid duplicate code.
	(char_command): Initialization of enhanced mouse reporting modes.
	Initialization of focus reporting mode.
	* fhandler.h (use_mouse): Change flag (bool->int) to indicate
	additional mouse modes. Add flag to indicate focus reporting.
	(mouse_aware): Move enhanced function into fhandler_console.cc.
	* select.cc (peek_console): Use modified mouse_aware() for more
	general detection of mouse events. Also check for focus reports.
@
text
@d408 3
a410 2
	      bool meta;
	      meta = (control_key_state & ALT_PRESSED) != 0
d412 2
d1119 36
d1158 5
d1191 2
d1197 1
a1197 1
/*08 09 0A 0B 0C 0D 0E 0F */ BAK, TAB, DWN, ERR, ERR, CR,  ERR, IGN,
d1546 10
a1555 1
      strcpy (buf, "\033[?6c");
d1731 6
d1827 1
a1827 1
	  if (*src == '[')
d1831 1
d1836 1
a1836 1
	  else if (*src == ']')
d1842 9
a1850 1
	  else if (*src == 'M')		/* Reverse Index */
d1856 1
a1856 1
	  else if (*src == 'c')		/* Reset Linux terminal */
d1863 1
a1863 1
	  else if (*src == '8')		/* Restore cursor position */
d1868 1
a1868 1
	  else if (*src == '7')		/* Save cursor position */
d1874 1
a1874 1
	  else if (*src == 'R')
d1948 2
d1956 17
@


1.208
log
@	* fhandler_console.cc (char_command): Fix code to select dim mode
	to 2 rather than 9.  Add entries for mode 22 (normal, not bold)
	28 (visible, not invisible), 25 (not blinking).
@
text
@d103 4
d213 39
d447 11
a457 3
	  if (dev_state->use_mouse)
	    {
	      MOUSE_EVENT_RECORD& mouse_event = input_rec.Event.MouseEvent;
d459 6
a464 6
	      /* Treat the double-click event like a regular button press */
	      if (mouse_event.dwEventFlags == DOUBLE_CLICK)
		{
		  syscall_printf ("mouse: double-click -> click");
		  mouse_event.dwEventFlags = 0;
		}
d466 4
a469 7
	      /* Did something other than a click occur? */
	      if (mouse_event.dwEventFlags)
		continue;

	      /* Retrieve reported mouse position */
	      int x = mouse_event.dwMousePosition.X;
	      int y = mouse_event.dwMousePosition.Y;
d471 17
a487 12
	      /* Adjust mouse position by scroll buffer offset */
	      CONSOLE_SCREEN_BUFFER_INFO now;
	      if (GetConsoleScreenBufferInfo (get_output_handle (), &now))
		{
		  y -= now.srWindow.Top;
		  x -= now.srWindow.Left;
		}
	      else
		{
		  syscall_printf ("mouse: cannot adjust position by scroll buffer offset");
		  continue;
		}
d489 24
a512 7
	      /* If the mouse event occurred out of the area we can handle,
		 ignore it. */
	      if ((x + ' ' + 1 > 0xFF) || (y + ' ' + 1 > 0xFF))
		{
		  syscall_printf ("mouse: position out of range");
		  continue;
		}
d514 1
a514 2
	      /* Ignore unimportant mouse buttons */
	      mouse_event.dwButtonState &= 0x7;
d516 11
a526 29
	      /* This code assumes Windows never reports multiple button
		 events at the same time. */
	      int b = 0;
	      char sz[32];
	      if (mouse_event.dwButtonState == dev_state->dwLastButtonState)
		{
		  syscall_printf ("mouse: button state unchanged");
		  continue;
		}
	      else if (mouse_event.dwButtonState < dev_state->dwLastButtonState)
		{
		  b = 3;
		  strcpy (sz, "btn up");
		}
	      else if ((mouse_event.dwButtonState & 1) != (dev_state->dwLastButtonState & 1))
		{
		  b = 0;
		  strcpy (sz, "btn1 down");
		}
	      else if ((mouse_event.dwButtonState & 2) != (dev_state->dwLastButtonState & 2))
		{
		  b = 2;
		  strcpy (sz, "btn2 down");
		}
	      else if ((mouse_event.dwButtonState & 4) != (dev_state->dwLastButtonState & 4))
		{
		  b = 1;
		  strcpy (sz, "btn3 down");
		}
d528 7
a534 8
	      /* Remember the current button state */
	      dev_state->dwLastButtonState = mouse_event.dwButtonState;

	      /* If a button was pressed, remember the modifiers */
	      if (b != 3)
		{
		  dev_state->nModifiers = 0;
		  if (mouse_event.dwControlKeyState & SHIFT_PRESSED)
d536 1
a536 1
		  if (mouse_event.dwControlKeyState & (RIGHT_ALT_PRESSED|LEFT_ALT_PRESSED))
d538 1
a538 1
		  if (mouse_event.dwControlKeyState & (RIGHT_CTRL_PRESSED|LEFT_CTRL_PRESSED))
a539 1
		}
d541 2
a542 1
	      b |= dev_state->nModifiers;
d544 3
a546 3
	      /* We can now create the code. */
	      sprintf (tmp, "\033[M%c%c%c", b + ' ', x + ' ' + 1, y + ' ' + 1);
	      syscall_printf ("mouse: %s at (%d,%d)", sz, x, y);
d548 4
a551 3
	      toadd = tmp;
	      nread = 6;
	    }
d555 11
d1347 18
a1364 3
	case 1000: /* Mouse support */
	  dev_state->use_mouse = (c == 'h') ? true : false;
	  syscall_printf ("mouse support %sabled", dev_state->use_mouse ? "en" : "dis");
@


1.207
log
@	* fhandler_console.cc (fhandler_console::read): Revert change from
	2009-11-09.
@
text
@d1139 4
a1142 1
	     case 4:
a1153 3
	     case 9:    /* dim */
	       dev_state->intensity = INTENSITY_DIM;
	       break;
d1160 4
d1167 3
@


1.206
log
@	* fhandler_console.cc (fhandler_console::read): Restrict generating
	META key sequences to singlebyte input chars.
@
text
@d382 1
a382 1
	      else if (nread == 1)
d384 10
a393 15
		  /* META handling is restricted to singlebyte (ASCII)
		     character values. */
		  if (dev_state->metabit)
		    {
		      tmp[1] |= 0x80;
		      toadd = tmp + 1;
		    }
		  else
		    {
		      tmp[0] = '\033';
		      tmp[1] = cyg_tolower (tmp[1]);
		      toadd = tmp;
		      nread++;
		      dev_state->nModifiers &= ~4;
		    }
@


1.205
log
@	* fhandler_console.cc (beep): Move up to avoid forward declaration.
	(fhandler_console::read): Just beep on characters invalid in current
	charset.  Add comment.
@
text
@d382 1
a382 1
	      else if (dev_state->metabit)
d384 15
a398 10
		  tmp[1] |= 0x80;
		  toadd = tmp + 1;
		}
	      else
		{
		  tmp[0] = '\033';
		  tmp[1] = cyg_tolower (tmp[1]);
		  toadd = tmp;
		  nread++;
		  dev_state->nModifiers &= ~4;
@


1.204
log
@	* fhandler.h (class dev_console): Constify charset parameter of
	str_to_con.
	* fhandler_console.cc (dev_console::con_to_str): Simplify.  Always
	default to the current internal locale.
	(dev_console::get_console_cp): Always use codepage 437 for alternate
	charset.
	(dev_console::str_to_con): Constify charset parameter.
	(fhandler_console::write_normal): Always use codepage 437 for alternate
	charset.  Otherwise always default to the current internal locale.
	Replace ASCII SO with ASCII CAN.
	* strfuncs.cc: Tweka comments according to below changes.
	(sys_cp_wcstombs): Constify charset parameter.  Convert all wchar_t
	values in the Unicode private use area U+F0xx to the singlebyte
	counterpart.  Drop special handling creating ASCII SO sequence from
	U+DCxx value.  Rearrange for performance.  Replace ASCII SO with
	ASCII CAN.
	(sys_cp_mbstowcs): Constify charset parameter.  Replace ASCII SO with
	ASCII CAN.  Drop special case for U+DCxx ASCII SO sequences.  Always
	create a replacement from the Unicode private use area U+F0xx for
	invalid byte values in a multibyte sequence.  Do the same for wchar_t
	values from the U+F0xx range to make them roundtrip safe.
	* wchar.h (sys_cp_wcstombs): Constify charset parameter.
	(sys_cp_mbstowcs): Ditto.
@
text
@d61 17
d370 12
a381 1
		toadd = tmp + 1;
a1445 17
static void
beep ()
{
  reg_key r (HKEY_CURRENT_USER, KEY_ALL_ACCESS, "AppEvents", "Schemes", "Apps",
	     ".Default", ".Default", ".Current", NULL);
  if (r.created ())
    {
      char *buf = NULL;
      UINT len = GetWindowsDirectory (buf, 0);
      buf = (char *) alloca (len += sizeof ("\\media\\ding.wav"));
      UINT res = GetWindowsDirectory (buf, len);
      if (res && res <= len)
	r.set_string ("", strcat (buf, "\\media\\ding.wav"));
    }
  MessageBeep (MB_OK);
}

@


1.203
log
@* fhandler_console.cc (create_invisible_console_workaround): Fix size of cmd in
the way originally intended.
@
text
@d130 2
a131 3
  return sys_cp_wcstombs (*cygheap->locale.charset == 'A'
			  ? __ascii_wctomb : cygheap->locale.wctomb,
			  cygheap->locale.charset, d, dlen, &w, 1);
d137 2
a138 1
  return alternate_charset_active ? GetConsoleOutputCP () : 0;
d142 1
a142 1
dev_console::str_to_con (mbtowc_p f_mbtowc, char *charset,
d1457 1
a1457 2
  char charsetbuf[ENCODING_LEN + 1];
  char *charset;
d1461 5
a1465 1
    f_mbtowc = __set_charset_from_codepage (cp, charset = charsetbuf);
d1468 1
a1469 1
      f_mbtowc = (*charset == 'A') ? __ascii_mbtowc : cygheap->locale.mbtowc;
d1612 4
a1615 4
	  /* Don't print chars marked as ERR chars, except for a SO sequence
	     which is printed as singlebyte chars from the UTF Basic Latin
	     and Latin 1 Supplement plains. */
	  if (*found == 0x0e)
@


1.202
log
@	* fhandler_console.cc (create_invisible_console_workaround):  Fix
	size of cmd to take spaces into account.
@
text
@d2011 1
a2011 1
	  WCHAR cmd[len + (2 * strlen ("0xffffffff")) + 2 /* spaces */ + 1];
@


1.201
log
@	* fhandler_console.cc (set_console_title): Set buffer size to
	TITLESIZE + 1.  Call sys_mbstowcs with correct destination length.
@
text
@d2011 1
a2011 1
	  WCHAR cmd[len + (2 * strlen ("0xffffffff")) + 1];
@


1.200
log
@* sigproc.h (wait_for_sigthread): Eliminate parameter.
* sigproc.cc (wait_for_sigthread): Ditto.  Don't synchronize with wait_sig
after receiving an event that it is ready to go.
(init_sig_pipe): New function.
(wait_sig): Call init_sig_pipe to create pipes for communicating signals to
this process.  Don't send sigCONT signal when initializing.
* fork.cc (frok::child): Accommodate wait_for_sigpipe parameter change.
* fhandler.h (fhandler_*::write): Make ssize_t/__stdcall.
(fhandler_*::write_overlapped): Ditto.
(fhandler_*::raw_write): Ditto.
(fhandler_*::readv): Ditto.
(fhandler_*::writev): Ditto.
(fhandler_*::raw_read): Make __stdcall.
* fhandler: Accommodate changes to read/write functions throughout.
* fhandler_clipboard.cc: Ditto.
* fhandler_console.cc: Ditto.
* fhandler_dsp.cc: Ditto.
* fhandler_fifo.cc: Ditto.
* fhandler_mailslot.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_mem.cc: Ditto.
* fhandler_random.cc: Ditto.
* fhandler_tape.cc: Ditto.
* fhandler_tty.cc: Ditto.
* fhandler_virtual.cc: Ditto.
* fhandler_windows.cc: Ditto.
* fhandler_zero.cc: Ditto.
* syscalls.cc (readv): Use ssize_t as temp variable.
* fhandler.cc (fhandler_base::read): Coerce returned len to signed or it will
never be treated as < 0.
(fhandler_base::wait_overlapped): Minimize calls to GetLastError.  Remove
duplicate debugging test.  Fix error return.
* fhandler.h (fhandler_fifo::fifo_name): Declare new function.
(fhandler_fifo::close): Ditto.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
* fhandler.cc (fhandler_fifo::fifo_name): Define new function.
(FIFO_BUF_SIZE): New define.
(cnp): Ditto.
(fhandler_fifo::open): Rework.  Use cnp to open named pipe.  Always open write
side as a client.  Open dummy client when writing and can't connect.
(wait): Rework.  Implement fifo_wait_for_next_client.  Handle signals during
connect better.  Add new fifo_wait_for_server code which polls
(sigh) waiting for server.
(fhandler_fifo::raw_read): Handle transition states when one client closes and
another is available.
(fhandler_fifo::close): Define.
(fhandler_fifo::dup): Ditto.
(fhandler_fifo::close_on_exec): Ditto.
@
text
@d1895 2
a1896 2
  wchar_t buf[257];
  sys_mbstowcs (buf, sizeof buf, title);
@


1.199
log
@* fhandler_console.cc: Change workstation -> windows station throughout.
@
text
@d1642 1
a1642 1
int
@


1.198
log
@* autoload.cc (SetParent): Add new import.
* fhandler.h (fhandler_console::create_invisible_console): Declare new
function.
(create_invisible_console_workaround): Ditto.
* fhandler_console.cc (fhandler_console::create_invisible_console): Define new
function.
(create_invisible_console_workaround): Ditto.  Add too much code to deal with
broken Windows 7.  Use a helper app to start an invisible console window.
(fhandler_console::need_invisible): Reorganize to use helper functions to
create invisible console.
* spawn.cc (spawn_guts): Avoid zeroing already zeroed fields in si.
@
text
@d1940 1
a1940 1
/* Create a console in an invisible workstation.  This should work
d1972 1
a1972 1
   creation is slow and to be avoided if possible so the workstation method
d1991 1
a1991 1
	 ok.  The workstation method should work ok when AttachConsole doesn't
d2070 3
a2072 3
	 a tty.  So, first get the old windows station.  If there is no controlling
	 terminal, create a new windows station and then set it as the current
	 windows station.  The subsequent AllocConsole will then be allocated
d2076 2
a2077 2
	 a new windows station and if we had an existing windows station previously.
	 We also close the previously opened workstation even though AllocConsole
@


1.197
log
@* dcrt0.cc (jit_debug): New global.
(initial_env): Set jit_debug when we are automatically starting a gdb process.
* dtable.cc (dtable::get_debugger_info): Don't tty tricks when we are being
debugged by our own captive gdb, as determined by jit_debug == true.
(dtable::init_std_file_from_handle): Detect errors when initializing a tty
early rather than at random points later.
* fhandler.h (fhandler_*::init): Return int to indicate success/failure.
* fhandler.cc (fhandler_base::init): Reflect change in return value.
* pipe.cc (fhandler_pipe::init): Ditto.
(fhandler_pipe::create_selectable): Don't say we're retrying when we aren't.
* fhandler_console.cc (fhandler_console::init): Ditto.  Return success/failure.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
(fhandler_tty_slave::open): Make debugging output more detailed.
* tty.cc (tty_list::terminate): Don't close I/O handles before all slaves have
checked in.
(tty::slave_alive): Make a non-inlined function.  Check if tty pipe handles can
be created as an additional exists check.
* tty.h (tty::slave_alive): Just define here.
@
text
@d1938 120
a2057 1
#define WINSTA_ACCESS STANDARD_RIGHTS_READ
d2067 1
a2067 1
      HWINSTA h, horig;
d2087 1
a2087 1
      h = horig = GetProcessWindowStation ();
d2091 2
a2092 2
      if (!horig
	  || !GetUserObjectInformationW (horig, UOI_FLAGS, &oi, sizeof (oi), &len)
d2097 1
d2100 4
a2103 33
      /* Band-aid for Windows 7.  AllocConsole is broken on W7 in that it
         doesn't allocate the console in the hidden, active WindowStation,
	 but instead on the WindowStation on which the application has
	 originally been started on.  This effectively disallows to create
	 a hidden console.
	 So what we do now is this.  First we try to attach to an existing
	 console window of the parent process.  If that doesn't work, we
	 skip generating a hidden WindowStation entirely.  After creating
	 the new console, we hide it.  Unfortunately it's still visible in
	 the taskbar.  Hopefully this will be fixed in SP1... */
      else if (!wincap.has_broken_alloc_console () || !AttachConsole (-1))
	{
	  if (myself->ctty != TTY_CONSOLE
	      && !wincap.has_broken_alloc_console ())
	    {
	      h = CreateWindowStationW (NULL, 0, WINSTA_ACCESS, NULL);
	      termios_printf ("%p = CreateWindowStation(NULL), %E", h);
	      if (h)
		{
		  b = SetProcessWindowStation (h);
		  termios_printf ("SetProcessWindowStation %d, %E", b);
		}
	    }
	  b = AllocConsole ();	/* will cause flashing if CreateWindowStation
				   failed */
	  if (b && wincap.has_broken_alloc_console ())
	    ShowWindowAsync (GetConsoleWindow (), SW_HIDE);
	  debug_printf ("h %p, horig %p, flags %p", h, horig, oi.dwFlags);
	  if (horig && h && h != horig && SetProcessWindowStation (horig))
	    CloseWindowStation (h);
	  termios_printf ("%d = AllocConsole (), %E", b);
	  invisible_console = true;
	}
@


1.196
log
@	* autoload.cc: Fix typo in comment.
	(ShowWindowAsync): Define.
	(AttachConsole): Define.
	* fhandler_console.cc (fhandler_console::need_invisible): Add band-aid
	for Windows 7 AllocConsole bug.
@
text
@d1858 1
a1858 1
void
d1876 1
a1876 1
  tcsetattr (0, &tc->ti);
@


1.195
log
@	* fhandler_console.cc (set_console_title): Convert title string to
	wchar_t and call SetConsoleTitleW.
@
text
@d1980 11
a1990 1
      else
d1992 2
a1993 1
	  if (myself->ctty != TTY_CONSOLE)
d2005 2
@


1.194
log
@	* fhandler_console.cc (fhandler_console::read): Allow Ctrl-Space to
	emit a NUL byte.
@
text
@d1895 2
a1896 3
  char buf[257];
  strncpy (buf, title, sizeof (buf) - 1);
  buf[sizeof (buf) - 1] = '\0';
d1898 2
a1899 2
  SetConsoleTitle (buf);
  debug_printf ("title '%s'", buf);
@


1.193
log
@	* fhandler_console.cc (fhandler_console::read): Convert Alt-Backspace
	to \033\177 or to \377 dependent on the setting of dev_state->metabit.
@
text
@d326 4
@


1.192
log
@* fhandler_console.cc (fhandler_console::read): Convert backspace key to DEL.
@
text
@d321 5
a325 2
	    toadd = (control_key_state & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))
	            ? "" : "\177";
@


1.191
log
@	* cygheap.cc (cygheap_init): Set Cygwin default locale values.
	* cygheap.h (struct cygheap_locale): New structure.
	(struct user_heap_info): Add cygheap_locale member locale.
	* dcrt0.cc (dll_crt0_1): Revert to calling _setlocale_r so that only
	the applications locale is reverted to "C".
	* environ.cc (environ_init): Remove unused got_lc variable.
	* fhandler.h (class dev_console): Remove now unsed locale variables.
	* fhandler_console.cc (fhandler_console::get_tty_stuff): Remove
	setting dev_console's locale members.
	(dev_console::con_to_str): Use internal locale settings.  Default to
	__ascii_wctomb if charset is "ASCII".
	(fhandler_console::write_normal): Ditto.
	* strfuncs.cc (__ascii_wctomb): Drop declaration.
	(__db_wctomb): Use fixed value 2 instead of not
	necessarily matching MB_CUR_MAX.
	(__eucjp_wctomb): Use 3 instead of MB_CUR_MAX.
	(sys_cp_wcstombs): Remove special case for "C" locale.
	(sys_wcstombs): Implement here.  Use internal locale data stored on
	cygheap.
	(sys_cp_mbstowcs): Remove special case for "C" locale.
	(sys_mbstowcs): Implement here.  Use internal locale data stored on
	cygheap.
	* syscalls.cc (internal_setlocale): New function to set cygheap locale
	data and to reset CWD posix path.
	(setlocale): Just call internal_setlocale from here if necessary.
	* wchar.h (__ascii_wctomb): Declare.
	(sys_wcstombs): Don't define inline, just declare.
	(sys_mbstowcs): Ditto.
@
text
@d53 1
a53 1
const char * get_nonascii_key (INPUT_RECORD&, char *);
d318 6
a323 1
	  if (wch == 0 ||
d325 1
a325 1
	      (input_rec.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY))
d1791 1
a1791 1
	       /* NORMAL */  /* SHIFT */    /* CTRL */       /* ALT */
@


1.190
log
@* fhandler_console.cc (fhandler_console::ioctl): Properly treat TIOCLINUX
argument as a char.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use coercion to properly set
char value.
@
text
@a101 19

      /* Set the console charset and the mb<->wc conversion functions from
	 the current locale the first time the shared console info is created.
	 When this initialization is called, the current locale is the one
	 used when reading the environment.  This way we get a console setting
	 which matches the setting of LC_ALL/LC_CTYPE/LANG at the time the
	 first Cygwin process in this console starts.

	 This has an interesting effect.  If none of the above environment
	 variables is set, the setting is equivalent to before when
	 CYGWIN=codepage was not set:  The console charset will be the
	 default ANSI codepage.  So it's sort of backward compatible.

	 TODO: Find out if that's a feasible approach.  It might be better
	 in the long run to have a distinct console charset environment
	 variable. */
      dev_state->con_mbtowc = __mbtowc;
      dev_state->con_wctomb = __wctomb;
      strcpy (dev_state->con_charset, __locale_charset ());
d130 3
a132 1
  return sys_cp_wcstombs (con_wctomb, con_charset, d, dlen, &w, 1);
d1453 2
a1454 2
      f_mbtowc = dev_state->con_mbtowc;
      charset = dev_state->con_charset;
@


1.189
log
@* fhandler_console.cc (fhandler_console::write_console): Eliminate unneeded
debugging output.
(fhandler_console::write_normal): Eliminate unneeded __seterrno.
@
text
@d726 1
a726 1
	if (* (int *) buf == 6)
d728 1
a728 1
	    * (int *) buf = dev_state->nModifiers;
@


1.188
log
@* fhandler.h (fhandler_console::MAX_WRITE_CHARS): Declare.
(fhandler_console::write_replacement_char): Declare as inline.
(fhandler_console::write_console): Declare new function.
* fhandler_console.cc (fhandler_console::MAX_WRITE_CHARS): Define.
(handler_console::write_console): Define.
(fhandler_console::write_replacement_char): Define as inline.
(fhandler_console::write_normal): Use write_console when writing buffers of
unknown length.
@
text
@a1038 1
	  debug_printf ("write failed, handle %p", get_output_handle ());
a1513 1
	      __seterrno ();
a1571 1
	  __seterrno ();
@


1.187
log
@	* fhandler.h (class dev_console): Add members con_mbtowc, con_wctomb,
	and con_charset.
	(dev_console::str_to_con): Take mbtowc function pointer and charset
	as additional parameters.
	* fhandler_console.cc (fhandler_console::get_tty_stuff): Initialize
	aforementioned new members.  Explain why.
	(dev_console::con_to_str): Remove useless comment.  Call new
	sys_cp_wcstombs function rather than sys_wcstombs.
	(dev_console::str_to_con): Take mbtowc function pointer and charset
	as additional parameters.  Call sys_cp_mbstowcs accordingly.
	(fhandler_console::write_normal): Only initialize f_mbtowc and charset
	once.  Accommodate changed str_to_con.
	* strfuncs.cc (sys_cp_wcstombs): Renamed from sys_wcstombs.  Take
	wctomb function pointer and charset as parameters.  Use throughout.
	(sys_cp_mbstowcs): Take wctomb function pointer and charset as
	parameters instead of codepage.  Remove matching local variables and
	their initialization.
	* wchar.h (ENCODING_LEN): Define as in newlib.
	(__mbtowc): Use mbtowc_p typedef for declaration.
	(wctomb_f): New type.
	(wctomb_p): New type.
	(__wctomb): Declare.
	(__utf8_wctomb): Use wctomb_f typedef for declaration.
	(sys_cp_wcstombs): Move declaration from winsup.h here.
	(sys_wcstombs): Ditto.
	(sys_wcstombs_alloc): Ditto.
	(sys_cp_mbstowcs): Ditto.
	(sys_mbstowcs): Ditto.
	(sys_mbstowcs_alloc): Ditto.
	* winsup.h: Move declaration of sys_FOO functions to wchar.h.  Include
	wchar.h instead.
@
text
@d55 2
d1031 18
d1444 1
a1444 1
void
d1512 6
a1517 1
	  WriteConsoleW (get_output_handle (), write_buf, buf_len, &done, 0);
d1571 1
a1571 2
      register PWCHAR buf = write_buf;
      do
d1573 3
a1575 8
	  if (!WriteConsoleW (get_output_handle (), buf, buf_len, &done, 0))
	    {
	      debug_printf ("write failed, handle %p", get_output_handle ());
	      __seterrno ();
	      return 0;
	    }
	  buf_len -= done;
	  buf += done;
a1576 1
      while (buf_len > 0);
d1797 1
a1797 1
  syscall_printf ("%d = write_console (,..%d)", len, len);
@


1.186
log
@	* environ.cc (environ_init): Break from locale loop after first hit.
	* fhandler_console.cc (fhandler_console::write_normal): Print a SO
	sequence using always valid Unicode chars.
@
text
@d4 1
a4 1
   2006, 2008 Red Hat, Inc.
d100 19
a143 3
/* The results of GetConsoleCP() and GetConsoleOutputCP() cannot be
   cached, because a program or the user can change these values at
   any time. */
d147 1
a147 1
  return sys_wcstombs (d, dlen, &w, 1);
d157 2
a158 1
dev_console::str_to_con (PWCHAR d, const char *s, DWORD sz)
d160 1
a160 1
  return sys_cp_mbstowcs (get_console_cp (), d, CONVERT_LIMIT, s, sz);
d1443 3
a1445 3
  char charsetbuf[32];
  char *charset = __locale_charset ();
  mbtowc_p f_mbtowc = __mbtowc;
d1449 5
d1489 1
a1489 1
	  buf_len = dev_state->str_to_con (write_buf,
d1529 2
a1530 1
      buf_len = dev_state->str_to_con (write_buf, (const char *) src, len);
@


1.185
log
@	* ctype.cc (_CTYPE_DATA_0_127): Add _B class to TAB character.
	(__ctype_default): New character class array for default ASCII
	character set.
	(__ctype_iso): New array of character class array for ISO charsets.
	(__ctype_cp): Ditto for singlebyte Windows codepages.
	(tolower): Implement as distinct function to support any singlebyte
	charset.
	(toupper): Ditto.
	(__set_ctype): New function to copy singlebyte character classes
	corresponding to current charset to ctype_b array.
	Align copyright text to upstream.
	* dcrt0.cc (dll_crt0_1): Reset current locale to "C" per POSIX.
	* environ.cc (set_file_api_mode): Remove.
	(codepage_init): Remove.
	(parse_thing): Remove "codepage" setting.
	(environ_init): Set locale according to environment settings, or
	to current codepage, before converting environment to multibyte.
	* fhandler.h (fhandler_console::write_replacement_char): Drop argument.
	* fhandler_console.cc (dev_console::str_to_con): Call sys_cp_mbstowcs
	rather than MultiByteToWideChar.
	(fhandler_console::write_replacement_char): Always print a funny
	half filled square if a character isn't in the current charset.
	(fhandler_console::write_normal): Convert to using __mbtowc
	rather than next_char.
	* fork.cc (frok::child): Drop call to set_file_api_mode.
	* globals.cc (enum codepage_type) Remove.
	(current_codepage): Remove.
	* miscfuncs.cc (cygwin_wcslwr): Unused, dangerous.  Remove.
	(cygwin_wcsupr): Ditto.
	(is_cp_multibyte): Remove.
	(next_char): Remove.
	* miscfuncs.h (is_cp_multibyte): Drop declaration.
	(next_char): Ditto.
	* strfuncs.cc (get_cp): Remove.
	(__db_wctomb): New function to implement _wctomb_r functionality for
	doublebyte charsets using WideCharToMultiByte.
	(__sjis_wctomb): New function to replace unusable newlib function.
	(__jis_wctomb): Ditto.
	(__eucjp_wctomb): Ditto.
	(__gbk_wctomb): New function.
	(__kr_wctomb): Ditto.
	(__big5_wctomb): Ditto.
	(__db_mbtowc): New function to implement _mbtowc_r functionality for
	doublebyte charsets using MultiByteToWideChar.
	(__sjis_mbtowc): New function to replace unusable newlib function.
	(__jis_mbtowc): Ditto.
	(__eucjp_mbtowc): Ditto.
	(__gbk_mbtowc): New function.
	(__kr_mbtowc): New function
	(__big5_mbtowc): New function
	(__set_charset_from_codepage): New function.
	(sys_wcstombs): Reimplement, basically using same wide char to multibyte
	conversion as newlib's application level functions.  Plus extras.
	Add lengthy comment to explain.  Change return type to size_t.
	(sys_wcstombs_alloc): Just use sys_wcstombs.  Change return type to
	size_t.
	(sys_cp_mbstowcs): Replace sys_mbstowcs, take additional codepage
	argument.  Explain why.  Change return type to size_t.
	(sys_mbstowcs_alloc): Just use sys_mbstowcs.  Change return type to
	size_t.
	* wchar.h: Declare internal functions implemented in strfuncs.cc.
	(wcscasecmp): Remove.
	(wcsncasecmp): Remove.
	(wcslwr): Remove.
	(wcsupr): Remove.
	* winsup.h (codepage_init): Remove declaration.
	(get_cp): Ditto.
	(sys_wcstombs): Align declaration to new implementation.
	(sys_wcstombs_alloc): Ditto.
	(sys_cp_mbstowcs): Add declaration.
	(sys_mbstowcs): Define as inline function.
	(sys_mbstowcs_alloc): Align declaration to new implementation.
	(set_file_api_mode): Remove declaration.
	* include/ctype.h (isblank): Redefine to use _B character class.
	(toupper): Remove ASCII-only definition.
	(tolower): Ditto.
@
text
@d1576 19
a1594 1
	  /* Don't print chars marked as ERR chars. */
@


1.184
log
@* cygheap.cc (creturn): Reorganize to avoid a new compiler warning/error.
* dtable.cc (handle_to_fn): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::scroll_screen): Ditto.
(dev_console::set_color): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::write): Ditto.
(fhandler_dev_dsp::read): Ditto.
* fhandler_tape.cc (mtinfo_drive::get_status): Ditto.
* hookapi.cc (find_first_notloaded_dll): Ditto.
* mmap.cc (msync): Ditto.
* pipe.cc (pipesync::pipesync): Ditto.
* sec_acl.cc (getace): Ditto.
* sec_auth.cc (create_token): Ditto.
(lsaauth): Ditto.
* select.cc (peek_pipe): Ditto.
* spawn.cc (av::fixup): Ditto.
* syscalls.cc (popen): Ditto.
* tty.cc (tty::init_session): Ditto.
* uinfo.cc (pwdgrp::load): Ditto.
* fhandler.cc (fhandler_base::setup_overlapped): Ditto.
(fhandler_base::wait_overlapped): Rename second use of res variable to wres or
errors are not returned correctly.
* dcrt0.cc: Remove obsolete variable.
* dll_init.cc (release_upto): Fix typo involving incorrect use of '|'.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Avoid a compiler
warning regarding coercing type-punned variables.
(fhandler_base::fstat_by_name): Ditto.  fhandler_fifo.cc
(fhandler_fifo::open_nonserver): Fix = vs.  == typo.
(fhandler_fifo::wait): Add all conditions to switch statement to avoid a
compiler warning.
* fhandler_process.cc: Avoid unneeded initialization of variables to zero.
(fhandler_socket::listen): Add braces around initializer.
* flock.cc (inode_t::get_all_locks_list): Reorganize to avoid a compiler
warning.  Fix problem with EWOULDBLOCK error return.
* path.cc (GUID_shortcut): Use braces around struct initializer.
(cygwin_conv_path): Reorganize to avoid a compiler warning.
* random.cc (dummy): Mark variable as volatile to avoid a "used uninitialized"
warning.
* libc/getopt.c: Mark some variables as dllexport although gcc doesn't seem to
do the right thing with them.
* libc/minires-os-if.c (get_registry_dns_items): Coerce some function arguments
to avoid a compiler warning.
@
text
@d16 1
d137 1
a137 1
  return alternate_charset_active ? GetConsoleOutputCP () : get_cp ();
d143 1
a143 1
  return MultiByteToWideChar (get_console_cp (), 0, s, sz, d, CONVERT_LIMIT);
d1404 3
a1406 3
/* This gets called when we found an invalid UTF-8 character.  We try with
   the default ANSI codepage.  If that fails we just print a question mark.
   Looks ugly but is a neat and alomst sane fallback for many languages. */
d1408 1
a1408 1
fhandler_console::write_replacement_char (const unsigned char *char_p)
d1410 1
a1410 2
  int n;
  WCHAR def_cp_chars[2];
d1412 1
a1412 7

  n = MultiByteToWideChar (GetACP (), 0, (const CHAR *) char_p, 1,
			   def_cp_chars, 2);
  if (n)
    WriteConsoleW (get_output_handle (), def_cp_chars, n, &done, 0);
  else
    WriteConsoleW (get_output_handle (), L"?", 1, &done, 0);
d1423 2
a1424 1
  const unsigned char *nfound;
d1426 6
d1437 1
d1440 3
a1442 4
      nfound = next_char (cp, trunc_buf.buf,
			  trunc_buf.buf + trunc_buf.len + cp_len);
      /* Still truncated multibyte sequence?  Keep in trunc_buf. */
      if (nfound == trunc_buf.buf)
d1444 2
d1448 15
a1474 6
      /* Give up, print replacement chars for trunc_buf... */
      for (int i = 0; i < trunc_buf.len; ++i)
	write_replacement_char (trunc_buf.buf + i);
      /* ... mark trunc_buf as unused... */
      trunc_buf.len = 0;
      /* ... and proceed. */
d1477 1
d1482 5
a1486 5
      nfound = next_char (cp, found, end);
      if (!nfound)		/* Invalid multibyte sequence. */
	break;
      if (nfound == found)	/* Truncated multibyte sequence. */
	{			/* Stick to it until the next write. */
d1490 8
d1499 2
a1500 1
      found = nfound;
d1583 1
a1583 1
	  write_replacement_char (found);
@


1.183
log
@	* fhandler.h (set_console_state_for_spawn): Drop declaration.
	* fhandler_console.cc (set_console_state_for_spawn): Remove.
	(fhandler_console::open): Set console state last.  Don't set
	ENABLE_PROCESSED_INPUT flag.
	* spawn.cc (spawn_guts): Drop call to set_console_state_for_spawn.
@
text
@d264 1
a264 1
	      control_key_state & (LEFT_ALT_PRESSED | LEFT_CTRL_PRESSED) == LEFT_ALT_PRESSED | LEFT_CTRL_PRESSED
d571 6
a576 5
  if (sr1.Top != sr1.Bottom)
    if (dest.Y <= sr1.Top)	/* forward scroll */
      clear_screen (0, 1 + dest.Y + sr1.Bottom - sr1.Top, sr2.Right, sr2.Bottom);
    else			/* reverse scroll */
      clear_screen (0, sr1.Top, sr2.Right, dest.Y - 1);
d899 2
a900 1
  else if (intensity == INTENSITY_BOLD)
d902 4
a905 4
    if (reverse)
      win_bg |= BACKGROUND_INTENSITY;
    else
      win_fg |= FOREGROUND_INTENSITY;
@


1.182
log
@remove obsolete comment
@
text
@a123 28
/* Determine if a console is associated with this process prior to a spawn.
   If it is, then just return.  If the console has been initialized, then
   set it into a more friendly state for non-cygwin apps. */
void __stdcall
set_console_state_for_spawn (bool iscyg)
{
  if (fhandler_console::need_invisible () || iscyg
      || (myself->ctty >= 0 && myself->ctty != TTY_CONSOLE))
    return;

  HANDLE h = CreateFile ("CONIN$", GENERIC_READ, FILE_SHARE_WRITE,
			 &sec_none_nih, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
			 NULL);

  if (h == INVALID_HANDLE_VALUE)
    return;

  if (shared_console_info != NULL)
    {
      SetConsoleMode (h, ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT);
      shared_console_info->tty_min_state.rstcons (true);
    }

  CloseHandle (h);

  return;
}

d622 4
d628 2
a629 4
    {
      cflags |= ENABLE_PROCESSED_INPUT;
      SetConsoleMode (get_io_handle (), ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT | cflags);
    }
a630 3
  tc->rstcons (false);
  set_open_status ();
  cygheap->manage_console_count ("fhandler_console::open", 1);
@


1.181
log
@Remove unneeded header files from source files throughout.
@
text
@a142 1
      /* ACK.  Temporarily define for use in TTYSETF macro */
@


1.180
log
@Add miscfuncs.h to files as needed throughout.
* mount.cc: New file.
* path.cc: Move mount-specific stuff into mount.cc.  Move common stuff into
miscfuncs.cc.  Remove unneeded includes.
* miscfuncs.cc: Move some common path functions here.
* miscfuncs.h: New file.
* winsup.h: Move miscelleneous functions to miscfuncs.h.
* dcrt0.cc: Remove unneeded includes.
* Makefile.in (DLL_OFILES): Add mount.o.
* include/cygwin/config.h: Fix a minor typo.
@
text
@a13 1
#include <sys/termios.h>
a15 1
#include <unistd.h>
a17 1
#include <wincon.h>
@


1.179
log
@	* Fix copyright dates.
@
text
@d13 1
@


1.178
log
@	* fhandler.h (class fhandler_console): Add write_buf as pointer to
	temporary buffer space.
	* fhandler_console.cc (CONVERT_LIMIT): Define as NT_MAX_PATH.  Add
	comment.
	(fhandler_console::write_normal): Use write_buf throughout.
	(fhandler_console::write): Use tmp_pathbuf to allocate write_buf.
@
text
@d4 1
a4 1
   2006 Red Hat, Inc.
@


1.177
log
@	* fhandler_console.cc (fhandler_console::write_normal): Don't print
	chars marked as ERR chars.
@
text
@d34 1
d37 3
a39 1
#define CONVERT_LIMIT 65536
d1479 2
a1480 2
	  WCHAR buf[2];
	  buf_len = dev_state->str_to_con (buf, (const char *) trunc_buf.buf,
d1482 1
a1482 1
	  WriteConsoleW (get_output_handle (), buf, buf_len, &done, 0);
d1515 1
a1515 3
      PWCHAR buf = (PWCHAR) alloca (CONVERT_LIMIT * sizeof (WCHAR));

      buf_len = dev_state->str_to_con (buf, (const char *) src, len);
d1531 1
d1605 5
@


1.176
log
@	* fhandler.h (dev_console::con_to_str): Declare returning DWORD.
	* fhandler_console.cc (dev_console::con_to_str): Return number of
	multibyte char bytes.
	(fhandler_console::read): Set nread to number of multibyte char bytes
	returned from con_to_str.
	(fhandler_console::write_normal): Reorder trunc buffer preocessing.
	Return after writing valid multibyte sequence out of trunc buffer.
	Change comments slightly.
@
text
@d1582 1
a1582 1
	  WriteFile (get_output_handle (), found, 1, &done, 0);
@


1.175
log
@	* Makefile.in (DLL_OFILES): Add tls_pbuf.o.
	* autoload.cc (CreateDesktopW): Replace CreateDesktopA.
	(CreateWindowStationW): Replace CreateWindowStationA.
	(GetUserObjectInformationW): Replace GetUserObjectInformationA.
	* cygheap.h (cwdstuff::get): Assume default buffer size NT_MAX_PATH.
	* cygtls.cc (_cygtls::remove): Free temporary TLS path buffers.
	* cygtls.h (TP_NUM_C_BUFS): Define.
	(TP_NUM_W_BUFS): Define.
	(class tls_pathbuf): New class to store pointers to thread local
	temporary path buffers.
	(_local_storage::pathbufs): New member.
	* environ.cc (win_env::add_cache): Use temporary TLS path buffer instead
	of stack based buffer.
	(posify): Get temporary outenv buffer from calling function.
	(environ_init): Create temporary TLS path buffer for posify.
	(build_env): Create Windows environment block as WCHAR buffer.
	* environ.h (build_env): Change declaration accordingly.
	* external.cc (sync_winenv): Accommodate build_env change.
	* fhandler_console.cc (fhandler_console::need_invisible): Use
	GetUserObjectInformationW and CreateWindowStationW.
	* fhandler_process.cc (format_process_maps): Use temporary TLS path
	buffer instead of stack based buffer.
	* fork.cc (frok::parent): Convert to use CreateProcessW.
	* path.cc: Throughout use temporary TLS path buffers instead of stack
	based buffer.  Replace checks for CYG_MAX_PATH by checks for
	NT_MAX_PATH.
	(getfileattr): New function to replace GetFileAttributesA.
	(normalize_win32_path): Remove Win32 and NT long path prefixes.
	(getwd): Assume PATH_MAX + 1 buffer per SUSv3.
	* path.h (class path_conv): Set path buffer to size NT_MAX_PATH.
	(iswdrive): Define.
	* pinfo.cc (commune_process): Use temporary TLS path buffer instead of
	stack based buffer.
	* registry.cc (get_registry_hive_path): Ditto.
	(load_registry_hive): Ditto.
	* spawn.cc (spawn_guts): Convert to use CreateProcessW and
	CreateProcessAsUserW.
	(av::fixup): Open/close file using NtOpenFile/NtClose.
	* syscalls.cc (mknod_worker): Allow PATH_MAX file name.
	(mknod32): Ditto.
	(getusershell): Ditto.
	* tls_pbuf.cc: New file implementing tls_pathbuf and tmp_pathbuf
	methods.
	* tls_pbuf.h: New header for files using tmp_pathbuf.
	* tlsoffsets.h: Regenerate.
	* winsup.h (NT_MAX_PATH): Define as 32767 to avoid USHORT overflow.
@
text
@d155 1
a155 1
inline bool
d158 1
a158 1
  return !!sys_wcstombs (d, dlen, &w, 1);
d357 1
a357 1
	      dev_state->con_to_str (tmp + 1, 59, wch);
d1467 3
a1469 7
      if (!nfound)		/* Invalid multibyte sequence. */
	{			/* Give up and print replacement chars. */
	  for (int i = 0; i < trunc_buf.len; ++i)
	    write_replacement_char (trunc_buf.buf + i);
	}
      else if (nfound == trunc_buf.buf)
	{			/* Still truncated multibyte sequence. */
d1473 2
a1474 1
      else
a1475 1
	  /* Valid multibyte sequence.  Process. */
d1481 2
d1484 4
a1487 1
      /* Mark trunc_buf as unused. */
d1489 1
@


1.174
log
@Perform whitespace cleanup throughout.
* dcrt0.cc (signal_shift_subtract): Eliminate ancient backwards compatibility.
(check_sanity_and_sync): Ditto.
* winsup.h (SIGTOMASK): Ditto.  Just use constant in signal calculation.
* include/cygwin/version: Remove backwards signal mask compatibility define.
* path.cc (symlink_info::check_sysfile): Cosmetic change.
* registry.cc (get_registry_hive_path): Remove unneeded variable.
* exceptions.cc (handle_sigsuspend): Eliminate thread signal mask and use
either main sigmask or current thread sigmask.
(set_process_mask): Ditto.
(sighold): Ditto.
(sigrelse): Ditto.
(sigset): Ditto.
(set_process_mask_delta): Ditto.
(_cygtls::call_signal_handler): Ditto.
* fhandler_process.cc (format_process_status): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Ditto.
* pinfo.h (class pinfo): Ditto.
* select.cc (pselect): Ditto.
* signal.cc (sigprocmask): Ditto.
(abort): Ditto.
(sigpause): Ditto.
(sigsend): Ditto.
(wait_sig): Ditto.
* thread.h (pthread::parent_tls): New member.
* thread.cc (pthread::pthread): Record parent_tls here.
(pthread::thread_init_wrapper): Initialize sigmask from parent thread.
@
text
@d1922 1
a1922 1
	  || !GetUserObjectInformation (horig, UOI_FLAGS, &oi, sizeof (oi), &len)
d1933 1
a1933 1
	      h = CreateWindowStation (NULL, 0, WINSTA_ACCESS, NULL);
@


1.173
log
@	* fhandler.h (fhandler_console::trunc_buf): Add to use as cache for
	truncated multibyte characters on input.
	(fhandler_console::write_replacement_char): Declare new method.
	* fhandler_console.cc (CONVERT_LIMIT): Raise to 64K.
	(fhandler_console::fhandler_console): Initialize trunc_buf.
	(ERR): Define as independent value again.
	(fhandler_console::write_replacement_char): New method to print
	replacement chars.
	(fhandler_console::write_normal): Add handling for truncated multibyte
	sequences.  Call next_char instead of pathetic CharNextExA function.
	Don't change src, rather just work with found later on.
	* miscfuncs.cc (is_cp_multibyte): Move here from strfuncs.cc.
	Don't call Windows function, restrict to well-known ANSI/OEM codepages
	and UTF-8.
	(next_char): Call CharNextExA only for doublebyte codepages.
	Implement for UTF-8 here.
	* strfuncs.cc (is_cp_multibyte): Move to miscfuncs.cc.
	* winsup.h (next_char): Declare.
	* include/limits.h (MB_LEN_MAX): Set to maximum value of MB_CUR_MAX
	as defined by newlib for now.
@
text
@d1431 1
a1431 1
   the default ANSI codepage.  If that fails we just print a question mark. 
d1459 1
a1459 1
  /* First check if we have cached lead bytes of a former try to write 
d1468 1
a1468 1
        {			/* Give up and print replacement chars. */
d1498 1
a1498 1
        {			/* Stick to it until the next write. */
@


1.172
log
@	* autoload.cc (CharToOemA): Remove.
	(CharNextExA): Define.
	* environ.cc (codepage_init): Un-static.  Set active_codepage to
	active codepage.  Default to ansi regardless of buf pointer.
	* fhandler.h (dev_console::get_console_cp): New method.
	(dev_console::con_to_str): Change declaration according to new
	implementation.
	(dev_console::str_to_con): Ditto.
	* fhandler_console.cc (cp_convert): Remove.
	(dev_console::con_to_str): Redefine to take WCHAR as incoming console
	char.
	(dev_console::get_console_cp): Return correct codepage according to
	alternate_charset_active setting.
	(dev_console::str_to_con): Redefine to create WCHAR buffer for console
	output.
	(fhandler_console::read): Read console input as WCHARs.
	(base_chars): Fix typo in comment.
	(fhandler_console::char_command): Save and restore console output
	buffer using UNICODE functions.
	(fhandler_console::write_normal): Convert to write output in UNICODE.
	Use CharNextExA to recognize multibyte characters in input.  Workaround
	problem with UTF-8 and MultiByteToWideChar.  Simplify the loop for
	printing "normal" characters.
	* strfuncs.cc (active_codepage): New variable to store active codepage.
	(get_cp): Call codepage_init() if active_codepage is uninitialized.
	Just return active_codepage.
	(is_cp_multibyte): New function.
	* winsup.h (active_codepage): Declare.
	(codepage_init): Declare.
	(is_cp_multibyte): Declare.
@
text
@d36 1
a36 1
#define CONVERT_LIMIT 16384
d898 1
d900 1
d1042 1
a1042 1
#if 0
d1430 18
d1454 3
a1456 1
  unsigned char *found = (unsigned char *) src;
d1458 31
a1488 1
  bool mb = is_cp_multibyte (cp);
d1494 8
a1501 11
      if (mb && *found && *found >= 0x80)
	{
	  unsigned char *nfound = (unsigned char *)
				  CharNextExA (cp, (const CHAR *) found, 0);
	  /* Sanity check for UTF-8 to workaround the problem in
	     MultiByteToWideChar, that it's not capable of using replacement
	     characters for invalid source chars in the given codepage. */
	  if (nfound == found + 1 && cp == CP_UTF8)
	    *found++ = '?';
	  else
	    found = nfound;
d1503 1
a1503 2
      else
	++found;
a1509 1
      DWORD buf_len;
d1540 2
a1541 1
      src = found;
d1544 1
a1544 1
  if (src < end)
d1547 1
a1547 1
      switch (base_chars[*src])
d1580 1
a1580 1
	  WriteFile (get_output_handle (), src, 1, &done, 0);
d1586 3
d1590 1
a1590 1
      src ++;
d1592 1
a1592 1
  return src;
@


1.171
log
@	* dcrt0.cc (dll_crt0_1): Use GetCommandLineW and convert to current
	codepage.
	* environ.cc (set_file_api_mode): Always set file api to ANSI if not
	using the OEM codepage.
	(codepage_init): Allow "utf8" codepage.
	* fhandler_clipboard.cc (set_clipboard): Convert clipbuf to void and
	cast as needed.  Always convert input to wide char and write
	CF_UNICODETEXT to clipboard.
	(fhandler_dev_clipboard::read): Read CF_UNICODETEXT from clipboard and
	convert to current codepage if CYGWIN_NATIVE format is not available.
	* fhandler_console.cc: Drop redundant undef.
	* smallprint.cc (__small_vsprintf): Convert PWCHAR and UNICODE_STRING
	to current codepage for printing.
	* strfuncs.cc: Use PWCHAR throughout.
	(get_cp): Return CP_UTF8 for utf8_cp codepage setting.
	(sys_wcstombs): Allow NULL target buffer.
	(sys_wcstombs_alloc): New function.
	(sys_mbstowcs_alloc): Ditto.
	* winsup.h (codepage_type): Add utf8_cp.
	(HEAP_NOTHEAP): Define.
	(sys_wcstombs_alloc): Declare.
	(sys_mbstowcs_alloc): Declare.
@
text
@a37 22
static bool
cp_convert (UINT destcp, char *dest, UINT srccp, const char *src, DWORD size)
{
  if (!size)
    /* no action */;
  else if (destcp == srccp)
    {
      if (dest != src)
	memcpy (dest, src, size);
    }
  else
    {
      WCHAR wbuffer[CONVERT_LIMIT]; /* same size as the maximum input, s.b. */
      if (!MultiByteToWideChar (srccp, 0, src, size, wbuffer, sizeof (wbuffer)))
	return false;
      if (!WideCharToMultiByte (destcp, 0, wbuffer, size, dest, size,
				NULL, NULL))
	return false;
    }
  return true;
}

d156 7
a162 1
dev_console::con_to_str (char *d, const char *s, DWORD sz)
d164 1
a164 1
  return cp_convert (get_cp (), d, GetConsoleCP (), s, sz);
d167 2
a168 2
inline bool
dev_console::str_to_con (char *d, const char *s, DWORD sz)
d170 1
a170 7
  if (alternate_charset_active)
    {
      /* no translation when alternate charset is active */
      memcpy(d, s, sz);
      return true;
    }
  return cp_convert (GetConsoleOutputCP (), d, get_cp (), s, sz);
d273 1
a273 1
      if (!ReadConsoleInput (h, &input_rec, 1, &nread))
d357 1
a357 5
	      tmp[1] = ich;
	      /* Need this check since US code page seems to have a bug when
		 converting a CTRL-U. */
	      if ((unsigned char) ich > 0x7f)
		dev_state->con_to_str (tmp + 1, tmp + 1, 1);
d364 1
a364 1
			 || ((signed char) ich >= 0 && ich <= 0x1f || ich == 0x7f));
d1058 1
a1058 1
/*()  *  +  ,  -  .  /  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
d1220 1
a1220 1
	      ReadConsoleOutputA (get_output_handle (), dev_state->savebuf,
d1234 1
a1234 1
	      WriteConsoleOutputA (get_output_handle (), dev_state->savebuf,
d1434 7
a1440 3
  const unsigned char *found = src;

  while (found < end)
d1442 14
a1455 4
      char ch = base_chars[*found];
      if (ch != NOR)
	break;
      found++;
d1462 5
a1466 1
      do
d1468 5
a1472 10
	  DWORD buf_len;
	  char buf[CONVERT_LIMIT];
	  done = buf_len = min (sizeof (buf), len);
	  if (!dev_state->str_to_con (buf, (const char *) src, buf_len))
	    {
	      debug_printf ("conversion error, handle %p",
			    get_output_handle ());
	      __seterrno ();
	      return 0;
	    }
d1474 6
a1479 6
	  if (dev_state->insert_mode)
	    {
	      int x, y;
	      cursor_get (&x, &y);
	      scroll_screen (x, y, -1, y, x + buf_len, y);
	    }
d1481 3
a1483 1
	  if (!WriteFile (get_output_handle (), buf, buf_len, &done, 0))
d1489 2
a1490 2
	  len -= done;
	  src += done;
d1492 2
a1493 1
      while (len > 0);
d1512 1
a1512 1
		WriteFile (get_output_handle (), "\n", 1, &done, 0);
@


1.170
log
@Change many cygheap allocation routines to their *_abort analogs.
* cygheap.cc (cmalloc_abort): New function.
(crealloc_abort): Ditto.
(ccalloc_abort): Ditto.
@
text
@a529 1
#undef ich
@


1.169
log
@	* fhandler_console.cc (fhandler_console::need_invisible): Drop
	pty_needs_alloc_console check.
	* spawn.cc (spawn_guts): Ditto.
	(av::fixup): Remove setting iscui.
	* syscalls.cc (rename): Drop has_move_file_ex checks.  Remove 9x
	specific code.
	* wincap.cc: Remove has_move_file_ex and pty_needs_alloc_console
	throughout.
	* wincap.h: Ditto.
@
text
@d1244 1
a1244 1
	      dev_state->savebuf = (PCHAR_INFO) cmalloc (HEAP_1_BUF, sizeof (CHAR_INFO) *
@


1.168
log
@	* fhandler_console.cc (fhandler_console::read): Drop 9x specific
	handling of AltGr key.
	* mmap.cc: Take NT for granted throughout.
	* wincap.cc: Remove map_view_of_file_ex_sucks, altgr_is_ctrl_alt,
	has_working_copy_on_write, share_mmaps_only_by_name,
	virtual_protect_works_on_shared_pages, has_mmap_alignment_bug and
	has_working_virtual_lock throughout.
	* wincap.h: Ditto.
@
text
@d1853 1
a1853 1
  if (GetConsoleCP () || !wincap.pty_needs_alloc_console ())
@


1.167
log
@Remove extraneous whitespace.
* pinfo.cc (commune_process): Use default argument to lock_process.
* sigproc.cc: Update copyright.
* select.cc: Ditto.
@
text
@d388 3
a390 11
	      if (wincap.altgr_is_ctrl_alt ())
		/* WinNT: AltGr is reported as Ctrl+Alt, and Ctrl+Alt is
		   treated just like AltGr.  However, if Ctrl+Alt+key generates
		   an ASCII control character, interpret is as META. */
		meta = (control_key_state & ALT_PRESSED) != 0
		       && ((control_key_state & CTRL_PRESSED) == 0
			   || ((signed char) ich >= 0 && ich <= 0x1f || ich == 0x7f));
	      else
		/* Win9x: there's no way to distinguish Alt from AltGr, so rely
		   on dev_state->meta_mask heuristic (see fhandler_console constructor). */
		meta = (control_key_state & dev_state->meta_mask) != 0;
@


1.166
log
@	* fhandler_console.cc (set_color): Avoid (again) inappropriate
	intensity interchanging that used to render reverse output unreadable
	when (non-reversed) text is bright.
	See http://sourceware.org/bugzilla/show_bug.cgi?id=514
@
text
@d403 1
a403 1
		  tmp[1] |= 0x80; 
d962 1
a962 1
    if (reverse) 
@


1.165
log
@	* fhandler.h (class dev_console): Add `metabit' indicating the
	current meta key mode.
	* fhandler_console.cc (fhandler_console::read): Set the top bit of
	the character if metabit is true.
	* fhandler_console.cc (fhandler_console::ioctl): Implement
	KDGKBMETA and KDSKBMETA commands.
	* fhandler_tty.cc (process_ioctl): Support KDSKBMETA.
	(fhandler_tty_slave::ioctl): Send KDGKBMETA and KDSKBMETA to the
	master.
	* include/cygwin/kd.h: New file for the meta key mode.
	* include/sys/kd.h: New file.
@
text
@d951 2
d961 6
a966 1
    win_fg |= FOREGROUND_INTENSITY;
@


1.165.4.1
log
@	* fhandler_console.cc (fhandler_console::open): Set console state last.
	Only add ENABLE_PROCESSED_INPUT flag if this is the first time we open
	the console.
@
text
@a684 4
  tc->rstcons (false);
  set_open_status ();
  int cons_cnt = cygheap->manage_console_count ("fhandler_console::open", 1);

d688 2
a689 4
      if (cons_cnt <= 1)
	cflags |= ENABLE_PROCESSED_INPUT;
      SetConsoleMode (get_io_handle (),
		      ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT | cflags);
d692 3
@


1.164
log
@* dcrt0.cc (dll_crt0_0): Call tty_list::init_session here.
(dll_crt0_1): Reflect renaming from tty_init to tty::init_session.
(do_exit): Reflect moving of tty_terminate into tty_list.
* exceptions.cc (events_init): Move tty_mutex stuff elsewhere.
* fhandler_console.cc (set_console_title): Use lock_ttys class.
* fhandler_termios.cc (fhandler_termios::bg_check): Make debug output more
accurate.
* fhandler_tty.cc (fhandler_tty_slave::open): Reflect move of attach_tty into
tty_list class.  Don't attempt to grab master end of pty if master doesn't
exist.
(fhandler_pty_master::open): Reflect move of allocate_tty into tty_list class.
Use lock_ttys::release to release mutex.  Improve debugging output.
(fhandler_pty_master::setup): Remove if 0'ed block.  Fix argument to
SetNamedPipeHandleState.
* pinfo.cc (_pinfo::set_ctty): Lock ttys before setting sid/pgid.  Improve
debugging.  Add temporary debugging.
* tty.cc (tty_list::init_session): New function.
(tty::init_session): Rename from tty_init.  Reflect move of attach_tty to
tty_list class.
(tty::create_master): Rename from create_tty_master.
(tty_list::attach): Rename from attach_tty.  Reflect renaming of connect_tty to
connect.  Ditto for allocate_tty.
(tty_terminate): Delete.
(tty_list::terminate): Subsume tty_terminate.  Use lock_ttys rather than
manipulating mutex directly.
(tty_list::allocate): Rename from allocate_tty.  Use lock_ttys rather than
manipulating mutex directly.  Don't set sid here since linux apparently doesn't
do this.  Reflect move of create_tty_master into tty.
(lock_ttys::lock_ttys): Define new constructor.
(lock_ttys::release): New function.
* tty.h (tty::exists): Return false immediately if !master_pid.
(tty::set_master_closed): Define new function.
(tty::create_master): Ditto.
(tty::init_session): Ditto.
(tty_list::mutex): New field.
(tty_list::allocate): Define new function.
(tty_list::connect): Ditto.
(tty_list::attach): Ditto.
(tty_list::init_session): Ditto.
(lock_ttys): New class.
(tty_init): Delete declaration.
(tty_terminate): Ditto.
(attach_tty): Ditto.
(create_tty_master): Ditto.
@
text
@d23 1
d401 5
d754 14
@


1.163
log
@* fhandler_console.cc (fhandler_console::need_invisible): Allocate an invisible
window station when ctty != TTY_CONSOLE.
@
text
@a1783 1
  int rc;
d1787 1
a1787 2
  if ((rc = WaitForSingleObject (tty_mutex, 15000)) != WAIT_OBJECT_0)
    sigproc_printf ("wait for title mutex failed rc %d, %E", rc);
a1788 1
  ReleaseMutex (tty_mutex);
@


1.162
log
@* tty.h (tty::hwnd): Move to tty_min.
(tty::gethwnd): Ditto.
(tty::sethwnd): Ditto.
(tty_min::hwnd): Receive variable from tty class.
(tty_min::gethwnd): Receive function from tty classs.
(tty_min::sethwnd): Ditto.
* dtable.cc (dtable::stdio_init): Only call init_console_handler when we
actually own the console.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Set tty's hwnd to
non-zero value.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Semi-reinstate handling of
console when pgrp is set.
@
text
@d1851 1
a1851 1
	 We also close the previously opened work station even though AllocConsole
d1875 1
a1875 1
	  if (myself->ctty == -1)
d1878 1
a1878 1
	      termios_printf ("CreateWindowStation(NULL, %p), %E", h);
d1885 2
a1886 2
	  b = AllocConsole ();	/* will cause flashing if CreateWorkstation
				       failed */
@


1.161
log
@* fhandler_console.cc (fhandler_console::fixup_after_fork_exec): Make error
message more explicit.
* pinfo.cc (_pinfo::commune_request): Don't lock process unless we're looking
for fifos.
@
text
@d118 1
@


1.160
log
@* cygheap.cc (init_cygheap::manage_console_count): Turn console control handler
on/off depending on whether we have allocated a console or not.
* dcrt0.cc (child_info_fork::fork_retry): Add more potential retry statuses.
(dll_crt0_0): Turn on/off console control depending on whether we have a
controlling tty or not.
* exceptions.cc (init_console_handler): Change BOOL to bool.
* fhandler_console.cc (fhandler_console::need_invisible): Cosmetic change.
* winsup.h (init_console_handler): Reflect argument type change.
* wincap.h (supports_setconsolectrlhandler_null): Remove duplicate capability
throughout.
* wincap.cc: Ditto.
@
text
@d1807 1
a1807 1
	  system_printf ("error opening input console handle after fork/exec, errno %d, %E", get_errno ());
d1812 1
a1812 1
	  system_printf ("error opening output console handle after fork/exec, errno %d, %E", get_errno ());
@


1.159
log
@* fhandler_console.cc (set_console_state_for_spawn): Fix to recognize ttys >=
0.
@
text
@d1888 1
a1888 3
	    {
	      CloseWindowStation (h);
	    }
@


1.158
log
@* fhandler.h (set_console_state_for_spawn): Whackamole the argument back to a
bool.
* spawn.cc (spawn_guts): Ditto, i.e., once again call
set_console_state_for_spawn with an indication of whether we're about to start
a cygwin process.
* fhandler_console.cc (set_console_state_for_spawn): Don't set the console
state if we know we're starting a cygwin process or if we're using a "real"
tty.
@
text
@d150 1
a150 1
      || (myself->ctty > 0 && myself->ctty != TTY_CONSOLE))
@


1.157
log
@* fhandler_console.cc (fhandler_console::need_invisible): Remove duplicate
test.
@
text
@d147 1
a147 1
set_console_state_for_spawn ()
d149 2
a150 1
  if (fhandler_console::need_invisible ())
@


1.156
log
@* fhandler.h (set_console_state_for_spawn): Eliminate argument from
declaration.
* fhandler.cc (set_console_state_for_spawn): Eliminate argument from
definition.  Always check for invisible console.
(fhandler_console::need_invisible): Don't do anything if the windows station is
already not visible.
* spawn.cc (spawn_guts): Accommodate change of argument to
set_console_state_for_spawn.
@
text
@d147 1
a147 1
set_console_state_for_spawn (bool noncygwin_process)
d1873 1
a1873 1
	  if (myself->ctty == -1 && oi.dwFlags & WSF_VISIBLE)
@


1.155
log
@(fix ChangeLog and check in remaining files)
* sigproc.cc (sigproc_init): Move clearing of sync_startup here to lessen the
likelihood of trying to deal with non-cygwin threads in dll_entry.
* fhandler_console: Fix set_console_state_for_spawn comment.
@
text
@d149 1
a149 1
  if (noncygwin_process && fhandler_console::need_invisible ())
d1828 3
d1860 12
a1871 1
      if (myself->ctty == -1)
d1873 14
a1886 5
	  if (!(h = CreateWindowStation (NULL, 0, WINSTA_ALL_ACCESS, &sec_all_nih)))
	    h = CreateWindowStation ("CygwinInvisible", 0, WINSTA_ALL_ACCESS,
				     &sec_all_nih);
	  termios_printf ("CreateWindowStation(\"CygwinInvisible\", %p), %E", h);
	  if (h)
d1888 1
a1888 2
	      b = SetProcessWindowStation (h);
	      termios_printf ("SetProcessWindowStation %d, %E", b);
d1890 2
a1892 7
      b = AllocConsole ();	/* will cause flashing if CreateWorkstation
				   failed */
      debug_printf ("h (%p), horig (%p)", h, horig);
      if (horig && h && h != horig && SetProcessWindowStation (horig))
	CloseWindowStation (h);
      termios_printf ("%d = AllocConsole (), %E", b);
      invisible_console = true;
@


1.154
log
@* fhandler_console.cc (fhandler_console::need_invisible): Only try to open
"CygwinInvisible" windows station if opening of default station fails.  Use
CloseWindowStation to close window station handle.
@
text
@d144 1
a144 1
   If it is, then we'll return 1.  If the console has been initialized, then
@


1.153
log
@* fhandler_console.cc (fhandler_console::need_invisible): Open up the security
of the newly created windows station.
@
text
@d1859 3
a1861 1
	  h = CreateWindowStation ("CygwinInvisible", 0, WINSTA_ALL_ACCESS, &sec_all_nih);
d1869 2
a1870 2
      b = AllocConsole ();	// will cause flashing if workstation
				// stuff fails
d1873 1
a1873 1
	CloseHandle (h);
@


1.152
log
@* fhandler_console.cc (beep): Use MB_OK which is documented as using the
default bell rather than -1 which seems to behave differently on different
versions of Windows.
@
text
@d1859 1
a1859 1
	  h = CreateWindowStation ("CygwinInvisible", 0, WINSTA_ALL_ACCESS, &sec_none_nih);
@


1.151
log
@* fhandler_process.cc (fhandler_process::readdir): Add missing argument to
syscall_printf.
* fhandler_console.cc (fhandler_console::need_invisible): Use made-up name for
windows station rather than asking Windows to create one for us.
* spawn.cc (spawn_guts): Don't mess with console if we're detaching.
@
text
@d1431 1
a1431 1
  MessageBeep (0xFFFFFFFF);
@


1.150
log
@* dir.cc (readdir_worker): Minor code cleanup.
* fhandler_console.cc (beep): Use a more Windows-generic wav file if the beep
is missing.  Use a more foolproof way to find out whether we should be
recreating the missing key.
* registry.h (reg_key::_disposition): New field.
(reg_key::created): New function.
* registry.cc (reg_key::reg_key): Set _disposition to zero by default.
(reg_key::build_key): Fill in _disposition field.
@
text
@d1859 2
a1860 2
	  h = CreateWindowStation (NULL, 0, WINSTA_ALL_ACCESS, &sec_none_nih);
	  termios_printf ("CreateWindowStation %p, %E", h);
@


1.149
log
@* fhandler_console.cc (beep): New function.  Restores missing "Default Beep",
if necessary.
(fhandler_console::write_normal): Use beep().
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat, Inc.
a1419 1
  char buf[4096];
d1421 10
a1430 3
	     ".Default", ".Default", ".current", NULL);
  if (r.get_string ("", buf, sizeof (buf), "") != 0)
    r.set_string ("", "Windows XP Ding.wav");
@


1.148
log
@* fhandler.h (set_console_state_for_spawn): Add an argument to the declaration.
* fhandler_console.cc (set_console_state_for_spawn): Ditto for the definition.
Only set invisible console for non-cygwin process.  Remove debugging leftover.
* spawn.cc (spawn_guts): Pass argument denoting whether this is a cygwin
process to set_console_state_for_spawn and only call this function when
exec'ing.
@
text
@d32 1
d1416 11
d1485 1
a1485 1
	  MessageBeep (0xFFFFFFFF);
@


1.147
log
@* fhandler.h (fhandler_pipe::fixup_in_child): Declare new function.
(fhandler_console::invisible_console): Declare new variable.
(fhandler_console::need_invisible): Ditto.
(fhandler_console::has_a): Ditto.
* fhandler_console.cc (set_console_state_for_spawn): Eliminate return value.
Set up an invisible console if necessary prior to spawning.
(fhandler_console::invisible_console): Define.
* fhandler_tty.cc (fhandler_tty_slave::open): Use
fhandler_console::invisible_console to setup an invisible console.
* pipe.cc (fhandler_pipe::fixup_in_child): Define new function from
fixup_after_exec.
(fhandler_pipe::fixup_after_exec): Use fixup_in_child when appropriate.
(fhandler_pipe::fixup_after_fork): Ditto.
* spawn.cc (handle): Reorganize and modernize a little.
(spawn_guts): Rely on set_console_state_for_spawn to set the console into the
right state but don't create the process with "detached" flag if we have no
controlling tty since that confuses 'cmd'.
* dtable.cc (dtable::stdio_init): Don't set console as controlling terminal if
we have an invisible console.
* sigproc.cc (child_info::sync): Use correct name in ForceCloseHandle1.
@
text
@a140 1

d145 1
a145 1
set_console_state_for_spawn ()
d147 1
a147 1
  if (fhandler_console::need_invisible ())
d1851 1
a1851 1
      if (0 && horig && h && h != horig && SetProcessWindowStation (horig))
@


1.146
log
@* fhandler.h (fhandler_console::fixup_after_fork_exec): Define with additional
bool parameter.
(fhandler_console::fixup_after_exec): Accommodate fixup_after_fork_exec's
parameter.
(fhandler_console::fixup_after_fork): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_fork_exec): Avoid opening
new console only when close_on_exec AND execing.
@
text
@d145 1
a145 1
int __stdcall
d148 3
d156 1
a156 1
    return 0;
d166 2
a167 1
  return 1;
d1807 54
@


1.145
log
@* fhandler.h (fhandler_console::fixup_after_fork_exec): Declare new function.
(fhandler_console::fixup_after_fork): Use fixup_after_fork_exec.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_fork): Delete definition.
(fhandler_console::fixup_after_fork_exec): Rename from fixup_after_exec.
* pinfo.cc (_pinfo::set_ctty): Don't play with console count here.
* syscalls.cc (close_all_files): Don't close cygheap ctty if hExeced since the
child will be copying information from us.
(setsid): Use myctty() rather than raw ctty #.
@
text
@d1772 1
a1772 1
fhandler_console::fixup_after_fork_exec ()
d1777 1
a1777 1
  if (close_on_exec () || open (O_NOCTTY | get_flags (), 0))
@


1.144
log
@* cygheap.h (init_cygheap::manage_console_count): Declare new function.
(init_cygheap::console_count): Renamed from open_fhs.  Make private.
* cygheap.cc (init_cygheap::manage_console_count): Define new function.
* dtable.cc (dtable::fixup_after_exec): Always call fixup_after_exec on
elements of fd even when they are about to be closed.
* fhandler.h (report_tty_counts): Remove open_fhs from debugging output.
* fhandler_console.cc (fhandler_console::open): Use manage_console_count rather
than manipulating count directly.
(fhandler_console::close): Ditto.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.  Don't close handles if
close_on_exec.
* fhandler_tty.cc (fhandler_tty_slave::open): Use manage_console_count() rather
than manipulating count directly.  Reflect change in arguments to
report_tty_counts().
(fhandler_tty_slave::close): Ditto for both.
(fhandler_tty_slave::dup): Ditto for both.
(fhandler_tty_slave::ioctl): Use myctty() rather than raw ctty #.
(fhandler_tty_slave::fixup_after_fork): Reflect change in arguments to
report_tty_counts().
(fhandler_tty_master::init_console): Use manage_console_count() rather than
manipulating count directly.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fixup_after_exec): Don't
perform any operations if close_on_exec.
* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fixup_after_exec): Ditto.
* fhandler_serial.cc (fhandler_serial::fixup_after_exec): Ditto.
* pinfo.h (_pinfo::_ctty): Declare new function.
(myctty): Declare new macro.
(__ctty): Declare new macro.
* pinfo.cc (_pinfo::_ctty): Define new function.
(_pinfo::set_ctty): Use manage_console_count() rather than manipulating count
directly.
* signal.cc (kill_pgrp): Use myctty() and __ctty() macros rather than raw ctty
#.
* syscalls.cc (setsid): Ditto.  Use manage_console_count() rather than
manipulating count directly.
@
text
@d698 1
a698 4
/*
 * Special console dup to duplicate input and output
 * handles.
 */
a1756 23
void
fhandler_console::fixup_after_fork (HANDLE)
{
  HANDLE h = get_handle ();
  HANDLE oh = get_output_handle ();

  /* Windows does not allow duplication of console handles between processes
     so open the console explicitly. */

  if (!open (O_NOCTTY | get_flags (), 0))
    system_printf ("error opening console after fork, %E");

  /* Need to decrement console_count since this open is basically a no-op to reopen
     the console and we've already recorded that fact. */
  cygheap->manage_console_count ("fhandler_console::fixup_after_fork", -1);

  if (!close_on_exec ())
    {
      CloseHandle (h);
      CloseHandle (oh);
    }
}

d1772 1
a1772 1
fhandler_console::fixup_after_exec ()
d1778 1
a1778 1
    cygheap->manage_console_count ("fhandler_console::fixup_after_exec", -1);
d1784 1
a1784 1
	  system_printf ("error opening input console handle after exec, errno %d, %E", get_errno ());
d1789 1
a1789 1
	  system_printf ("error opening output console handle after exec, errno %d, %E", get_errno ());
d1794 1
a1794 1
	system_printf ("error opening console after exec, errno %d, %E", get_errno ());
@


1.143
log
@	Revert erroneous checkin.
@
text
@d681 1
a681 2
  cygheap->open_fhs++;
  debug_printf ("incremented open_fhs, now %d", cygheap->open_fhs);
d693 2
a694 6
  if (!hExeced && --(cygheap->open_fhs) <= 0 && myself->ctty != TTY_CONSOLE)
    {
      syscall_printf ("open_fhs %d", cygheap->open_fhs);
      FreeConsole ();
    }
  debug_printf ("decremented open_fhs, now %d", cygheap->open_fhs);
a1768 1
  cygheap->open_fhs--;		/* The downside of storing this in cygheap. */
d1772 4
d1803 3
a1805 2
  cygheap->open_fhs--;		/* The downside of storing this in cygheap. */
  if (!open (O_NOCTTY | get_flags (), 0))
d1823 5
a1827 2
  CloseHandle (h);
  CloseHandle (oh);
@


1.142
log
@	* fhandler.h (class fhandler_dev_raw): Delete current_position and
	eof_detected status flag.  Delete is_eom and is_eof methods.
	Move drive_size, bytes_per_sector, eom_detected status flag, as well
	as the methods read_file, write_file, raw_read and raw_write to ...
	(class fhandler_dev_floppy): ... here. Remove is_eom and is_eof
	methods.  Add dup method.
	* fhandler_floppy.cc (IS_EOM): New macro.
	(fhandler_dev_floppy::is_eom): Remove.
	(fhandler_dev_floppy::is_eof): Remove.
	(fhandler_dev_floppy::fhandler_dev_floppy): Initialize status flags.
	(fhandler_dev_floppy::get_drive_info): Only call EX functions on
	systems supporting them and stop suffering strange delays.
	(fhandler_dev_floppy::read_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::write_file): Move here, drop setting
	current_position.
	(fhandler_dev_floppy::open): Rearrange comment.
	(fhandler_dev_floppy::dup): New method.
	(fhandler_dev_floppy::get_current_position): New inline method.  Use
	instead of former current_position were appropriate.
	(fhandler_dev_floppy::raw_read): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::raw_write): Move here.  Drop EOF handling.
	(fhandler_dev_floppy::lseek): Remove useless conditions.  Convert
	sector_aligned_offset to LARGE_INTEGER to improve SetFilePointer call.
	(fhandler_dev_floppy::ioctl): Move blocksize check in RDSETBLK case
	to here.
	* fhandler_raw.cc (fhandler_dev_raw::is_eom): Remove.
	(fhandler_dev_raw::is_eof): Remove.
	(fhandler_dev_raw::write_file): Remove.
	(fhandler_dev_raw::read_file): Remove.
	(fhandler_dev_raw::raw_read): Remove.
	(fhandler_dev_raw::raw_write): Remove.
	(fhandler_dev_raw::dup): Drop copying removed members.
	(fhandler_dev_raw::ioctl): Drop blocksize testing.
	* wincap.h: Implement has_disk_ex_ioctls throughout.
	* wincap.cc: Ditto.
	(wincap_vista): Preliminary wincaps for Windows Vista/Longhorn.
	(wincapc::init): Add Vista/Longhorn handling.
@
text
@d709 1
a709 1
fhandler_console::dup (fhandler_base *child, HANDLE from_proc)
@


1.141
log
@* dcrt0.cc (do_exit): Rely on sigproc_terminate to set exit_state
appropriately.
* pinfo.cc (pinfo::exit): Always call sigproc_terminate here.  Rely on
sigproc_terminate to signal signal thread to handle eventual process exit.
* sigproc.cc (no_signals_available): Change criteria for determining if this
process can handle signals to itself.
(my_sendsig): New variable.  Copy of my sendsig handle.
(proc_can_be_signalled): Don't send signals if exit code is set.
(sigproc_terminate): Use and set exit_state appropriately to determine when to
do anything.  Send __SIGEXIT to self to control process exit.
(sig_send): Use my_sendsig for sending signals.  Don't call
proc_can_be_signalled for myself since the criteria is now different for
sending signals to myself.
(wait_sig): Copy myself->sendsig to my_sendsig for future use.  Exit signal
loop when __SIGEXIT is received.  Wait for main thread to exit and use its exit
status to actually exit process.
* sigproc.h (__SIGEXIT): New enum.
* dcrt0.cc (alloc_stack): Eliminate superfluous "return;".
* debug.cc (add_handle): Ditto.
* devices.in (device::parse): Ditto.
* dtable.cc (dtable::vfork_parent_restore): Ditto.
(dtable::vfork_child_fixup): Ditto.
* environ.cc (parse_options): Ditto.
* errno.cc (seterrno_from_win_error): Ditto.
* exceptions.cc (sig_handle_tty_stop): Ditto.
(set_signal_mask): Ditto.
* fhandler.cc (fhandler_base::read): Ditto.
(fhandler_base::operator delete): Ditto.
(fhandler_base::seekdir): Ditto.
(fhandler_base::rewinddir): Ditto.
* fhandler_console.cc (fhandler_console::read): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* sigproc.cc (sigproc_init): Ditto.
(sigproc_terminate): Ditto.

* devices.cc: Regenerate.
@
text
@d709 1
a709 1
fhandler_console::dup (fhandler_base *child)
@


1.140
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@a548 1
  return;
a1825 1
  return;
@


1.139
log
@Change foo (void) to foo () for all c++ functions throughout.  Remove all
fhandler_*::dump functions throughout.
* fhandler.h (fhandler_dev_mem::close): Remove pass-through function in favor
of virtual method.
(handler_dev_raw::close): Ditto.
(fhandler_dev_clipboard::fixup_after_exec): New method.
* fhandler_dev_mem.cc (fhandler_dev_mem::close): Eliminate pass through
* fhandler_dev_raw.cc (fhandler_dev_raw::close): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::close): Don't go to extra
effort when execing.
(fhandler_dev_clipboard::fixup_after_exec): New function.
* fhandler_console.cc (fhandler_console::close): Don't do "extra stuff" when we
know we're execing.
* fhandler_disk_file.cc (fhandler_disk_file::close): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::close): Ditto.
* fhandler_fifo.cc (fhandler_fifo.cc::close): Ditto.  function in favor of base
function.
* fhandler_random.cc (fhandler_dev_random::close): Ditto.
* fhandler_registry.cc (fhandler_registry::close): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::close): Ditto.
* fhandler_virtual.cc (fhandler_virtual::close): Ditto.
* pinfo.cc (proc_waiter): Remove unneeded hExeced declaration.
* sigproc.cc: Ditto.
* winsup.h (hExeced): Define here.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Just call close()
to reinitialize things to known state.
@
text
@d124 1
a124 1
  (void) fhandler_console::get_tty_stuff ();
d593 1
a593 1
  (void) dev_state->fillin_info (get_output_handle ());
d748 1
a748 1
	(void) bg_check (SIGTTOU);
d972 1
a972 1
  (void) dev_state->fillin_info (get_output_handle ());
d1011 1
a1011 1
  (void) dev_state->fillin_info (get_output_handle ());
d1032 1
a1032 1
  (void) dev_state->fillin_info (get_output_handle ());
@


1.138
log
@* fhandler_console.cc (fhandler_console::read): Fix a compiler warning.
@
text
@d691 1
a691 1
fhandler_console::close (void)
d695 1
a695 3
  set_io_handle (NULL);
  set_output_handle (NULL);
  if (--(cygheap->open_fhs) <= 0 && myself->ctty != TTY_CONSOLE)
d1754 1
a1754 1
fhandler_console::igncr_enabled (void)
@


1.137
log
@* cygtls.cc (_cygtls::remove): Clear exitsock after close.
* fhandler_console.cc (fhandler_console::write_normal): Store character in a
local variable for potential future inspection.
@
text
@d386 1
a386 1
			   || (ich >= 0 && ich <= 0x1f || ich == 0x7f));
@


1.136
log
@* shared_info.h (cygwin_shared_address): Bump to a higher value to avoid
collision with large data areas.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Accommodate changes to
open_shared arguments.
* fhandler_tape.cc (mtinfo_init): Ditto.
* pinfo.cc (pinfo::init): Use open_shared rather than win32 mmap calls.
* shared.cc (user_shared_initialize): Ditto.
(memory_init): Ditto.
(open_shared): Change to allow use a smore general mmap handler.
* shared_info.h (shared_locations): Add SH_JUSTCREATE, SH_JUSTOPEN.
(open_shared): Change declaration to match new usage.
* autoload.cc (LoadDLLfuncEx2): Define in terms of LoadDLLfuncEx3.
(LoadDLLfuncEx3): New macro.
@
text
@d1433 2
a1434 1
      if (base_chars[*found] != NOR)
@


1.135
log
@* fhandler.h (dev_console::set_color): Define new function.
(dev_console::set_default_attr): Ditto, moved from fhandler_console.
(dev_console::fillin_info): Ditto.  Accommodate this change throughout this
file.
(fhandler_console::get_win32_attr): Eliminate.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Properly set default
attributes on initialization.
(fhandler_console::open): Set current attributes rather than default color on
open.
(fhandler_console::get_win32_attr): Eliminate.
(dev_console::set_color): New function.  Move get_win32_attr stuff here.
(dev_console::set_default_attr): New function, moved from fhandler_console.
(dev_console::fillin_info): Ditto.
(fhandler_console::char_command): Call set_color to set screen characteristics.
@
text
@d84 1
d88 1
a88 1
				   SH_SHARED_CONSOLE);
@


1.134
log
@	* fhandler_console.cc (get_win32_attr): Avoid inappropriate intensity
	interchanging that used to render reverse output unreadable when
	non-reversed text is bright.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Red Hat, Inc.
a99 1
      dev_state->default_color = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
d114 1
d216 1
a216 1
  fillin_info ();
d559 1
a559 1
fhandler_console::fillin_info (void)
d564 1
a564 1
  if ((ret = GetConsoleScreenBufferInfo (get_output_handle (), &linfo)))
d566 7
a572 7
      dev_state->info.winTop = linfo.srWindow.Top;
      dev_state->info.winBottom = linfo.srWindow.Bottom;
      dev_state->info.dwWinSize.Y = 1 + linfo.srWindow.Bottom - linfo.srWindow.Top;
      dev_state->info.dwWinSize.X = 1 + linfo.srWindow.Right - linfo.srWindow.Left;
      dev_state->info.dwBufferSize = linfo.dwSize;
      dev_state->info.dwCursorPosition = linfo.dwCursorPosition;
      dev_state->info.wAttributes = linfo.wAttributes;
d576 4
a579 4
      memset (&dev_state->info, 0, sizeof dev_state->info);
      dev_state->info.dwWinSize.Y = 25;
      dev_state->info.dwWinSize.X = 80;
      dev_state->info.winBottom = 24;
d592 1
a592 1
  (void) fillin_info ();
d664 7
a670 4
  if (fillin_info ())
    dev_state->default_color = dev_state->info.wAttributes;

  set_default_attr ();
d729 1
a729 1
	st = fillin_info ();
a916 5

#define FOREGROUND_ATTR_MASK (FOREGROUND_RED | FOREGROUND_GREEN | \
			      FOREGROUND_BLUE | FOREGROUND_INTENSITY)
#define BACKGROUND_ATTR_MASK (BACKGROUND_RED | BACKGROUND_GREEN | \
			      BACKGROUND_BLUE | BACKGROUND_INTENSITY)
d918 1
a918 1
fhandler_console::set_default_attr ()
d920 3
a922 14
  dev_state->blink = dev_state->underline = dev_state->reverse = false;
  dev_state->intensity = INTENSITY_NORMAL;
  dev_state->fg = dev_state->default_color & FOREGROUND_ATTR_MASK;
  dev_state->bg = dev_state->default_color & BACKGROUND_ATTR_MASK;
  dev_state->current_win32_attr = get_win32_attr ();
  SetConsoleTextAttribute (get_output_handle (), dev_state->current_win32_attr);
}

WORD
fhandler_console::get_win32_attr ()
{
  WORD win_fg = dev_state->fg;
  WORD win_bg = dev_state->bg;
  if (dev_state->reverse)
d934 2
a935 2
  if (dev_state->underline)
    win_fg = dev_state->underline_color;
d937 1
a937 1
  if (dev_state->blink)
d939 1
a939 1
  if (dev_state->intensity == INTENSITY_INVISIBLE)
d941 1
a941 1
  else if (dev_state->intensity == INTENSITY_BOLD)
d943 17
a959 1
  return (win_fg | win_bg);
d973 1
a973 1
  (void)fillin_info ();
d1012 1
a1012 1
  (void) fillin_info ();
d1033 1
a1033 1
  fillin_info ();
d1042 1
a1042 1
  fillin_info ();
d1106 1
a1106 3
       int i;

       for (i = 0; i <= dev_state->nargs_; i++)
d1110 1
a1110 1
	       set_default_attr ();
d1197 1
a1197 2
	 dev_state->current_win32_attr = get_win32_attr ();
	 SetConsoleTextAttribute (get_output_handle (), dev_state->current_win32_attr);
d1368 1
a1368 1
      fillin_info ();
d1558 1
a1558 1
	      fillin_info ();
d1564 1
a1564 1
	      set_default_attr ();
@


1.133
log
@	* fhandler_console.cc (read): Consider offset within scrolling
	region of the console window.
@
text
@d941 1
a941 1
	       (win_fg & FOREGROUND_INTENSITY);
d945 1
a945 1
	       (win_bg & BACKGROUND_INTENSITY);
@


1.132
log
@* child_info.h (child_info_spawn::hexec_proc): Eliminate.
* dcrt0.cc (dll_crt0_0): Remove hexec_proc stuff.
* fork.cc (fork_child): Remove call to pinfo_fixup_after_fork.
* pinfo.cc (set_myself): Close and zero pid_handle if set.
(pinfo_fixup_after_fork): Delete.
(proc_waiter): Don't close vchild.hProcess here.  Do that when we are remove
the vchild from procs.  Save hProcess as pid_handle only on first reparent
operation.
(pinfo::wait): Don't set pid_handle here.
(pinfo::alert_parent): Always try to send signal.  If unsuccessful then close
and zero wr_proc_pipe.
* pinfo.h (pinfo::pinfo): Make sure that appropriate parts of the class are
zeroed on construction.
(pinfo::alert_parent): Take char argument.
(pinfo_fixup_after_fork): Delete declaration.
(hexec_proc): Ditto.
* sigproc.cc (remove_proc): Close pid_handle and hProcess if appropriate.
* spawn.cc (spawn_guts): Set cygheap->pid_handle on first exec.
* cygheap.h (init_cygheap::pid_handle): New element.
* pinfo.cc (set_myself): Clear previously existing cygheap->pid_handle when a
new process has been started.
(pinfo::wait): Make sure that a handle to the newly forked/spawned process is
kept around so that the pid will not be reused.
* pinfo.h (_pinfo::pid_handle): Move.
(pinfo::pid_handle): to here.
* spawn.cc (spawn_guts): Create a pid_handle in cygheap prior to spawning to
ensure that the pid does not get reused during the lifetime of the "cygwin
pid".
* pinfo.h (pinfo::alert_parent): New function.
* exceptions.cc (sig_handle_tty_stop): Use alert_parent to send "signals" to
parent.
* fork.cc (fork_parent): Don't close pi.hProcess.  Let the waiter thread do
that.
* pinfo.cc (proc_waiter): Detect case where process exits without setting the
exit code and use value from GetExitCodeProcess.  Reluctantly implement
__SIGREPARENT.
(pinfo::alert_parent): Define.
* sigproc.h (__SIGREPARENT): New enum.
* spawn.cc (spawn_guts): Send reparent signal to parent on exec.  Always create
process in suspended state to avoid races.  Remove cygthread.h in favor of
cygtls.h throughout since cygtls now includes cygthread.h.  Eliminate
ppid_handle usage throughout.
* child_info.h: Regenerate magic number
(child_info): Remove pppid_handle.
* cygthread.h (cygthread::release): New method.  Frees thread without waiting.
* cygthread.cc (cygthread::stub): Set _ctinfo in _mytls to point to information
for executing thread.  Don't call SetEvent if thread is no longer in use.
(cygthread::simplestub): Ditto.
* cygtls.h (_cygtls::_ctinfo): New element contains pointer to information
about executing cygthread, if any.
* dcrt0.cc: Remove last vestiges of per_thread stuff.
(dll_crt0_0): Ditto.  Remove accommodation for ppid_handle.
(do_exit): Remove obsolete reparenting test.
(_exit): Exit with a more SUSv3-like exit value.
* dtable.cc (dtable::stdio_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* exceptions.cc (open_stackdumpfile): Ditto.
(handle_exceptions): Ditto.
(ctrl_c_handler): Ditto.
(sig_handle_tty_stop): Ditto.  Let parent send signal to itself on STOP.
(sigpacket::process): Comment out vfork test.
(signal_exit): Use more SUSv3-like exit value on signal.
* external.cc (fillout_pinfo): Don't set hProcess.
* fork.cc: Remove VFORK cruft.
(per_thread::set): Delete.
(fork_child): Remove perthread stuff.
(fork_parent): Remove obsolete subproc_init.  Accommodate new method for
tracking subprocesses.
* pinfo.cc (set_myself): Accommodate new pinfo/_pinfo layout.  Set some things
here that used to be set in wait_sig.
(_pinfo::exit): Set exitcode here.  Close process pipe.
(_pinfo::commune_send): Accommodeate new pinfo/_pinfo layout.
(proc_waiter): New function.  Waits, in a thread for subprocess to go away.
(pinfo::wait): New function.  Initialization for proc_waiter.
* pinfo.h (_pinfo::exitcode): New element.
(_pinfo::cygstarted): Ditto.
(_pinfo::wr_proc_pipe): Ditto.
(_pinfo::ppid_handle): Delete.
(_pinfo::hProcess): Delete.
(_pinfo::lock): Delete.
(pinfo::hProcess): New element.
(pinfo::lock): Ditto.
(pinfo::wait): Declare new function.
(pinfo::preserve): Define new function.
* sigproc.cc: Remove old stuff from wait_subproc thread based method.
(zombies): Remove.
(procs): New.
(my_parent_is_alive): Just check that the parent pid exists.
(mychild): Just use pinfo methods to determine if child is mine.
(proc_subproc): Revamp PROC_ADDCHILD to use pinfo::wait.  Remove
PROC_CHILDTERMINATED logic.  Use different method to remove processes from list
when SIGCHLD == SIG_IGN.
(proc_terminate): Gut.
(subproc_init): Delete.
(init_child_info): Remove setting of pppid_handle.
(checkstate): Revamp to only scan procs array.
(remove_proc): Rename from remove_zombie.  Don't close hProcess or pid_handle.
Don't release memory if it's myself.
(stopped_or_terminated): Change logic to handle new consolidated proc/zombie
array.
(wait_subproc): Delete.
* sigproc.h: Remove obsolete EXIT_* defines.
(subproc_init): Remove declaration.
* spawn.cc (spawn_guts): Remove reparenting stuff.  Use standard wait logic to
wait for child if started from a non-cygwin process.
* tlsoffsets.h: Regenerate.
* tty.cc (tty_init): Check for myself->cygstarted rather than
myself->ppid_handle to see if we were started by a cygwin process.
* include/sys/signal.h (external_pinfo::exitcode): Replace hProcess.
* include/sys/wait.h (WCOREDUMP): Define.
* fhandler_tty.cc (fhandler_tty_slave::read): Add debugging output for timeout
case.
* signal.cc (abort): Flag that we are exiting with the ABORT signal.
@
text
@d424 17
a442 2
	      int x = mouse_event.dwMousePosition.X;
	      int y = mouse_event.dwMousePosition.Y;
@


1.131
log
@* fhandler_console.cc (fhandler_console::fixup_after_exec): Fix error message.
@
text
@a30 1
#include "cygthread.h"
@


1.131.2.1
log
@Use cygthread.  Add release mechanism to cygthread so that it can be
used by threads which detach themselves.
@
text
@d31 1
@


1.130
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d1795 1
a1795 1
      int sawerr = 0;
d1799 1
a1799 1
	  sawerr = 1;
d1803 2
a1804 2
	  system_printf ("error opening input console handle after exec, errno %d, %E", get_errno ());
	  sawerr = 1;
@


1.129
log
@Change the name "title_mutex" to "tty_mutex" throughout.
* tty.h (tty_list::allocate_tty): Turn argument into a boolean.
* tty.cc (tty_list::init): Protect entire allocation operation with tty_mutex
(formerly title_mutex) to protect against allocation races.
@
text
@d1115 2
a1116 2
             case 10:   /* end alternate charset */
               dev_state->alternate_charset_active = false;
d1118 2
a1119 2
             case 11:   /* start alternate charset */
               dev_state->alternate_charset_active = true;
@


1.128
log
@* cygthread.cc (cygthread::is): Eliminate.
* cygthread.h (cygthread::is): Eliminate declaratin.
* fhandler_console.cc (fhandler_console::read): Only wait for signal_arrived in
the main thread.
* fhandler_socket.cc: Include new "wininfo.h".
(fhandler_socket::ioctl): Use 'winmsg' rather than 'gethwnd()'.
* sync.cc (muto::grab): Define new function.
(muto::acquire): Use tls pointer rather than tid.
(muto::acquired): Ditto.
(muto::reset): Delete.
(muto::release): Ditto.  Also implement "close on last release".
* sync.h (muto::tid): Delete.
(muto::tls): New field.
(muto::ismine): Delete.
(muto::owner): Delete.
(muto::unstable): Delete.
(muto::reset): Delete.
(muto::upforgrabs): New method.
(muto::grab): Ditto.
(new_muto_name): New define.
* wininfo.h: New file.
(wininfo): New class.
* window.cc: Rework throughout to use winfo class for controlling invisible
window operation.
(gethwnd): Delete definition.
* winsup.h (gethwnd): Delete declaration.
@
text
@d1779 1
a1779 1
  if ((rc = WaitForSingleObject (title_mutex, 15000)) != WAIT_OBJECT_0)
d1782 1
a1782 1
  ReleaseMutex (title_mutex);
@


1.127
log
@	* Use new unified status_flag accessor methods from classes fhandler_*,
	tty_min, mtinfo and fs_info thoroughout.
	* fhandler.h: Redefine all set_close_on_exec methods to take a bool
	argument.
	(enum conn_state): Rename from connect_state.
	(class fhandler_base): Rename some status flags to align with
	accessor method names.  Drop encoded flag entirely.  Unify status
	accessor methods.  Const'ify all read accessor methods.
	(class fhandler_socket): Ditto.
	(class fhandler_dev_raw): Ditto.
	* fhandler_disk_file.cc (fhandler_base::fstat_fs): Use fs.fs_is_fat()
	instead of evaluating FATness of file system here.
	(fhandler_disk_file::opendir): Drop call to set_encoded().
	(fhandler_disk_file::readdir): Use pc.isencoded() directly.
	* mtinfo.h (class mtinfo_drive): Const'ify all read accessor methods.
	* path.cc (fsinfo_cnt): Add.
	(fs_info::update): Accomodate class changes. Evaluate file system
	name specific flags right here. Add thread safety for reading and
	writing global fsinfo array.
	* path.h (enum path_types): Drop values for flags kept in fs already.
	(struct fs_info): Move status informatin into private struct type
	status_flags.  Add accessor methods. Remove path and file system
	name string arrays in favor of status bits.
	(class path_conv): Use new fs_info status information where
	appropriate.
	(path_conf::fs_has_ea): Rename from fs_fast_ea.
	(path_conf::fs_has_acls): New method.
	(path_conf::root_dir): Remove.
	(path_conf::volname): Remove.
	* syscalls (statfs): Evaluate root dir locally.
	* tty.h (class tty_min): Unify status accessor methods.  Const'ify
	all read accessor methods.
@
text
@d32 1
d254 1
a254 1
  if (cygthread::is ())
@


1.126
log
@	* fhandler.h (fhandler_base::status): Declare private.
	(fhandler_base::open_status): Ditto.
	(class fhandler_socket): Move status bits into private bitfield struct
	type status_flags.  Change accessor methods appropriately.
	* fhandler_socket.cc (fhandler_socket::fhandler_socket): Accomodate
	above status bit changes.
	* tty.h: Remove status bit enumerator.
	(TTYISSETF): Remove.
	(TTYSETF): Remove.
	(TTYCLEARF): Remove.
	(TTYCONDSETF): Remove.
	(tty_min::status): Define as private bitfield struct type status_flags.
	Add appropriate accessor methods.
	* fhandler_console.cc: Use tty_min::status accessor methods throughout.
	* fhandler_termios.cc: Ditto.
	* winsup.h (__ISSETF): Remove.
	(__SETF): Remove.
	(__CLEARF): Remove.
	(__CONDSETF): Remove.
@
text
@d158 1
a158 1
      shared_console_info->tty_min_state.set_rstcons ();
d539 1
a539 1
  if (tc->needs_rstcons ())
d636 1
a636 1
  set_r_no_interrupt (1);	// Handled explicitly in read code
d661 1
a661 1
  tc->clear_rstcons ();
d792 1
a792 1
  set_r_binary ((t->c_iflag & INLCR) ? 0 : 1);
d845 1
a845 1
  tc->clear_rstcons ();
d1745 1
a1745 1
fhandler_console::set_close_on_exec (int val)
d1764 1
a1764 1
  if (!get_close_on_exec ())
@


1.125
log
@* debug.h (console_printf): Define for non-debugging condition.
* cygtls.h (_threadinfo::lock): Remove wait argument.
(_threadinfo::interrupt_setup): Remove retaddr argument.
* exceptions.cc (_threadinfo::interrupt_setup): Ditto.
(_threadinfo::interrupt_now): Accommodate change to interrupt_setup argument.
(setup_handler): Ditto.  Always lock sig stack prior to determining interrupt
method.
* gendef (_sigfe): Correct thinko regarding cmpxchg.
(_sigbe): Ditto.
(_threadinfo::lock): Ditto.
(_threadinfo::pop): Eliminate left-over stack unlock.
* sigproc.cc (proc_subproc): Chnage debugging output to printed warning.
@
text
@a156 1
#     define tc &shared_console_info->tty_min_state
d158 1
a158 2
      TTYSETF (RSTCONS);
#     undef tc
d539 1
a539 1
  if (TTYISSETF (RSTCONS))
d661 1
a661 1
  TTYCLEARF (RSTCONS);
d845 1
a845 1
  TTYCLEARF (RSTCONS);
@


1.124
log
@* fhandler.h (*::fixup_after_exec): Eliminate unused handle argument.
* fhandler.h (dtable::fixup_after_exec): Eliminate unused handle argument.
* dcrt0.cc (dll_crt0_1): Reflect elimination of unused handle argument to
fixup_after_exec.
* dtable.cc (dtable::fixup_after_exec): Ditto.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dsp::fixup_after_exec): Ditto.
* fhandler_raw.cc (fhandler_raw::fixup_after_exec): Ditto.
* fhandler_socket.cc (fhandler_socket::fixup_after_exec): Ditto.
* fhandler_virtual.cc (fhandler_virtual::fixup_after_exec): Ditto.
* pipe.cc (fhandler_pipe::fixup_after_exec): Ditto.
* spawn.cc (spawn_guts): Do not set ciresrv.parent.
* child_info.h (child_info_spawn::~child_info_spawn): Do not close parent.
Update CURR_CHILD_INFO_MAGIC.
* dcrt0.cc (dll_crt0_0): Do not close spawn_info->parent.  Pass NULL to
cygheap->fdtab.fixup_after_exec().
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Red Hat, Inc.
@


1.123
log
@Throughout, change name from set_inheritance to set_no_inheritance to better
reflect input arguments of this function.
* cygheap.h (CYGHEAPSIZE): Increase size of cygheap to something closer to the
21st century.
@
text
@d1788 1
a1788 1
fhandler_console::fixup_after_exec (HANDLE)
@


1.122
log
@* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
@
text
@d1750 1
a1750 1
  set_inheritance (output_handle, val);
@


1.121
log
@* gentls_offsets: Reinstate unlink of temp files.
* fhandler_console.cc (fhandler_console::close): Fix debugging output.
(fhandler_console::fixup_after_fork): Decrement open_fhs prior to call to
fhandler_console::open since this would cause incrementing too much
incrementing in child processes.  (Probably needs to be handled more elegantly
someday)
(fhandler_console::fixup_after_exec): Ditto.
@
text
@d680 1
a680 2
  if (!cygheap->fdtab.in_vfork_cleanup () && --(cygheap->open_fhs) <= 0
      && myself->ctty != TTY_CONSOLE)
@


1.120
log
@Move open_fhs from fhandler.h to cygheap.h for easier tracking.  Accommodate
this change throughout.
* dtable.cc (dtable::add_archetype): Use correct count when iterating through
*active* archetypes.
* dtable.cc (dtable::fixup_after_exec): Close handle if close_on_exec and
archetype exists since archetype currently does not set windows close-on-exec
flag (FIXME).
* fhandler_tty.cc (fhandler_tty_slave::open): Change debugging output slightly.
(fhandler_tty_slave::close): Ditto.
(fhandler_tty_slave::fixup_after_fork): Just report on inherited use counts
since since archetype currently does not set windows close-on-exec flag
(FIXME).
* pinfo.cc (_pinfo::set_ctty): Change debugging output slightly.
* cygheap.cc (cygheap_init): Remove open_fhs accommodation and use count
reporting.
* perthread.h (vfork_save::fhctty): New element.
* perthread.h (vfork_save::open_fhs): New element.
* fork.cc (vfork): Muck around with ctty and open_fhs stuff, both of which are
now saved in the vfork_save structure.
@
text
@d683 1
a683 2
      syscall_printf ("open_fhs %d, freeing console %p", cygheap->open_fhs,
		      myself->ctty);
d1763 1
d1794 1
@


1.120.2.1
log
@* fhandler_console.cc (fhandler_console::close): Fix debugging output.
(fhandler_console::fixup_after_fork): Decrement open_fhs prior to call to
fhandler_console::open since this would cause incrementing too much
incrementing in child processes.  (Probably needs to be handled more elegantly
someday)
(fhandler_console::fixup_after_exec): Ditto.
@
text
@d683 2
a684 1
      syscall_printf ("open_fhs %d", cygheap->open_fhs);
a1763 1
  cygheap->open_fhs--;		/* The downside of storing this in cygheap. */
a1793 1
  cygheap->open_fhs--;		/* The downside of storing this in cygheap. */
@


1.120.2.2
log
@* cygtls.h (_threadinfo::threadkill): New element.
(_threadinfo::set_threadkill): Declare new function.
(_threadinfo::reset_threadkill): Declare new function.
* dcrt0.cc (dcrt0_1): Call here so that it will be possible to attach to
running process with #(*& Windows Me/9x.
(initial_env): Try to initialize strace if uninitialized.
* gendef: Don't zero signal if threadkill is set since that will happen in the
called function.
* signal.cc (sigwait): Ensure cleanup in error conditions.
* sigproc.cc (sig_send): Clear packet mask storage.
(wait_subproc): Fill in child exit code in siginfo_t structure.
* thread.cc (pthread_kill): Set threadkill flag.
* tlsoffsets.h: Regenerate.  Throughout, use siginfo_t to fill out all signal
information for "kernel" signals.
* cygtls.h (_threadinfo::set_siginfo): Declare new function.
* cygtls.cc (_threadinfo::set_siginfo): Define new function.
* dcrt0.cc (do_exit): Accommodate siginfo_t considerations.
* exceptions.cc (handle_exceptions): Ditto.
(sig_handle_tty_stop): Ditto.
(ctrl_c_handler): Use killsys() to send signal.
(sigpacket::process): Rename from sig_handle.  Use siginfo_t field from
sigpacket for everything.
(tty_min::kill_pgrp): Accommodate siginfo_t considerations.
(fhandler_termios::bg_check): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::ioctl): Use killsys() to send signal.
* signal.cc (kill_worker): Rewrite to use siginfo_t second argument.
(kill_pgrp): Ditto.
(kill0): Define new function pulled from kill().
(kill): Rewrite as frontend to kill0.
(killsys): Define new function.
* sigproc.cc (sigelem): Eliminate.
(sigpacket): Move to sigproc.h.  Subsume sigelem.
(pending_signals): Use sigpacket rather than sigelem for everything.
(sig_clear): Ditto.
(wait_sig): Ditto.
(sig_send): Rewrite to use siginfo_t argument.
(sig_send): New function wratpper to sig_send with siginfo_t argument.
(wait_subproc): Accommodate siginfo_t considerations.
* thread.cc (pthread_kill): Ditto.
* sigproc.h (sigpacket): Move here.
(sigpacket::process): Declare "new" function.
(sig_handle): Eliminate declaration.
(sig_send): Declare with new paramaters.
(killsys): Declare new function.
(kill_pgrp): Declare.
* winsup.h: Move some signal-specific stuff to sigproc.h.
* include/cygwin/signal.h: Tweak some siginfo_t stuff.
* fhandler_console.cc (fhandler_console::close): Remove obsolete test for
vfork_cleanup.
* pipe.cc (fhandler_pipe::close): Add comment.
* cygheap.cc (init_cygheap::close_ctty): Don't NULL ctty if it is still active.
* dtable.cc (dtable::vfork_parent_restore): Store ctty_on_hold prior to calling
close_all_files since it will be zeroed.
@
text
@d680 2
a681 1
  if (--(cygheap->open_fhs) <= 0 && myself->ctty != TTY_CONSOLE)
@


1.119
log
@* cygheap.h (cygheap_types): Add HEAP_ARCHETYPES.
(init_cheap::ctty): Change to pointer.
* dtable.h (dtable::find_archetype): Declare new function.
(dtable::add_archetype): Declare new function.
(dtable::delete_archetype): Declare new function.
(dtable::narchetypes): Declare.
(dtable::farchetypes): Declare.
(dtable::initial_archetype_size): Declare.
(dtable::dtable): Initialize new fields.
(dtable::initial_archetype_size): Declare.
* dtable.cc (dtable::find_archetype): Define new function.
(dtable::add_archetype): Define new function.
(dtable::delete_archetype): Define new function.
(dtable::initial_archetype_size): Define.
* fhandler.h (fhandler_base::archetype): Declare.
(fhandler_base::usecount): Declare.
* fhandler.cc (fhandler_base::fhandler_base): Initialize new fields.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Pass NULL to third
argument of set_ctty.
* fhandler_tty.cc (fhandler_tty_slave::open): Accommodate new archetype method
to create only one instance of a tty.
(fhandler_tty_slave::close): Don't close handles unless archetype usecount is
zero.  When that happens, close archetype too.
(fhandler_tty_slave::dup): Just copy archetype.  Set use count appropriately.
Set ctty, if appropriate.
(fhandler_tty_common::dup): Remove slave considerations.
(fhandler_tty_common::set_close_on_exec): Remove cygheap->ctty considerations.
* pinfo.cc (_pinfo::set_ctty): Accommodate new archetype methods.
* pinfo.h (_pinfo::set_ctty): Make third argument explicit.
* syscalls.cc (close_all_files): Decrement controlling tty use count before
closing all handles to allow controlling tty to be closed.  Remove previous
controlling tty considerations.
@
text
@a75 2
int NO_COPY fhandler_console::open_fhs;

d665 4
a668 4
  open_fhs++;
  debug_printf ("incremented open_fhs, now %d", open_fhs);
  debug_printf ("opened conin$ %p, conout$ %p",
		get_io_handle (), get_output_handle ());
d680 1
a680 1
  if (!cygheap->fdtab.in_vfork_cleanup () && --open_fhs <= 0
d683 2
a684 2
      syscall_printf ("open_fhs %d, freeing console %p",
		      fhandler_console::open_fhs, myself->ctty);
d687 1
a687 1
  debug_printf ("decremented open_fhs, now %d", open_fhs);
@


1.118
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d97 1
a97 1
      myself->set_ctty (&shared_console_info->tty_min_state, flags);
@


1.117
log
@	* dcrt0.cc: Remove local variable alternate_charset_active.
	* fhandler.h: Add variable alternate_charset_active, functions
	str_to_con, con_to_str to dev_console structure.
	* fhandler_console.cc (con_to_str): Move function into dev_console
	class.
	(str_to_con): Ditto.
	(fhandler_console::read): Call con_to_str on dev_state.
	(fhandler_console::write_normal): Call str_to_con on dev_state.
	(fhandler_console::char_command): Change active_charset_active
	assignment to be on dev_state.
	* winsup.h: Remove global external variable alternate_charset_active.
@
text
@d35 1
a35 1
static BOOL
d49 1
a49 1
	return FALSE;
d52 1
a52 1
	return FALSE;
d54 1
a54 1
  return TRUE;
d97 1
a97 1
      shared_console_info->tty_min_state.set_ctty (TTY_CONSOLE, flags);
d172 1
a172 1
inline BOOL
d178 1
a178 1
inline BOOL
d185 1
a185 1
      return TRUE;
d190 2
a191 2
BOOL
fhandler_console::set_raw_win32_keyboard_mode (BOOL new_mode)
d193 1
a193 1
  BOOL old_mode = dev_state->raw_win32_keyboard_mode;
d547 1
a547 1
BOOL
d550 1
a550 1
  BOOL ret;
d913 1
a913 1
  dev_state->blink = dev_state->underline = dev_state->reverse = FALSE;
d996 1
a996 1
fhandler_console::cursor_set (BOOL rel_to_top, int x, int y)
d1024 1
a1024 1
  cursor_set (FALSE, x, y);
d1109 1
a1109 1
	       dev_state->blink = TRUE;
d1112 1
a1112 1
	       dev_state->reverse = TRUE;
d1121 1
a1121 1
               dev_state->alternate_charset_active = FALSE;
d1124 1
a1124 1
               dev_state->alternate_charset_active = TRUE;
d1127 1
a1127 1
	       dev_state->underline = FALSE;
d1130 1
a1130 1
	       dev_state->reverse = FALSE;
d1197 1
a1197 1
	      dev_state->insert_mode = (c == 'h') ? TRUE : FALSE;
d1246 1
a1246 1
	  dev_state->use_mouse = (c == 'h') ? TRUE : FALSE;
d1251 1
a1251 1
	  set_raw_win32_keyboard_mode ((c == 'h') ? TRUE : FALSE);
d1272 1
a1272 1
	  cursor_set (TRUE, 0,0);
d1312 1
a1312 1
      cursor_set (TRUE, (dev_state->args_[1] ? dev_state->args_[1] : 1) - 1,
d1317 1
a1317 1
      cursor_set (FALSE, (dev_state->args_[0] ? dev_state->args_[0] - 1 : 0), y);
d1321 1
a1321 1
      cursor_set (TRUE, x, (dev_state->args_[0] ? dev_state->args_[0] - 1 : 0));
d1328 1
a1328 1
      cursor_set (TRUE, dev_state->savex, dev_state->savey);
d1332 1
a1332 1
      cursor_set (FALSE, 8 * (x / 8 + 1), y);
d1371 1
a1371 1
      cursor_set (FALSE, ((8 * (x / 8 + 1)) - 8), y);
d1403 1
a1403 1
      cursor_set (TRUE, 0, 0);
d1487 1
a1487 1
	  cursor_set (FALSE, ((tc->ti.c_oflag & ONLCR) ? 0 : x), y + 1);
d1497 1
a1497 1
	  cursor_set (FALSE, 0, y);
d1504 1
a1504 1
	  cursor_set (FALSE, 8 * (x / 8 + 1), y);
d1536 1
a1536 1
	      dev_state->saw_question_mark = FALSE;
d1557 1
a1557 1
	      cursor_set (TRUE, 0, 0);
d1562 1
a1562 1
	      cursor_set (TRUE, dev_state->savex, dev_state->savey);
d1644 1
a1644 1
		dev_state->saw_question_mark = TRUE;
@


1.116
log
@	* fhandler_console.cc (char_command): Add escape sequence for codepage
	ansi <-> oem switching for ncurses frame drawing capabilities.
	* dcrt0.cc: Add local variable alternate_charset_active.
	* winsup.h: Add global external variable alternate_charset_active.
@
text
@a56 21
/* The results of GetConsoleCP() and GetConsoleOutputCP() cannot be
   cached, because a program or the user can change these values at
   any time. */
inline BOOL
con_to_str (char *d, const char *s, DWORD sz)
{
  return cp_convert (get_cp (), d, GetConsoleCP (), s, sz);
}

inline BOOL
str_to_con (char *d, const char *s, DWORD sz)
{
  if (alternate_charset_active)
    {
      /* no translation when alternate charset is active */
      memcpy(d, s, sz);
      return TRUE;
    }
  return cp_convert (GetConsoleOutputCP (), d, get_cp (), s, sz);
}

d169 21
d378 1
a378 1
		con_to_str (tmp + 1, tmp + 1, 1);
d1121 1
a1121 1
               alternate_charset_active = FALSE;
d1124 1
a1124 1
               alternate_charset_active = TRUE;
d1437 1
a1437 1
	  if (!str_to_con (buf, (const char *) src, buf_len))
@


1.115
log
@* fhandler_console.c (fhandler_console::read): Record the state of the SHIFT,
CTRL and ALT keys at the time of the last keyboard input event.
(fhandler_console::ioctl): Handle requests to retrieve the keyboard modifiers
via the TIOCLINUX command.
* fhandler_tty.c (fhandler_tty_slave::read): Ditto.
* include/sys/termios.h (TIOCLINUX): New macro definition.
@
text
@d69 6
d1119 6
@


1.114
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d297 2
d345 9
d360 4
a363 1
		continue;
d396 1
d733 11
@


1.113
log
@* dcrt0.cc (dlL_crt0_1): Set __argc_safe after __argc is absolutely know to be
set.
* exceptions.cc (sig_handle_tty_stop): Don't reset sigCONT event since it is
reset automatically.
* fork.cc (fork): Remove obsolete usage of PID_SPLIT_HEAP.
* include/sys/cygwin.h: Ditto.
* sigproc.cc (sig_send): Use sigframe init method to set frame since it checks
for previous ownership of the frame.
* sigproc.h (sigframe::init): Accept an "is_exception" argument.
@
text
@d24 1
a25 1
#include "path.h"
d597 1
a597 1
fhandler_console::open (path_conv *, int flags, mode_t)
d682 1
a682 1
  if (!fhc->open (NULL, get_flags () & ~O_NOCTTY, 0))
d870 1
a870 1
  fhandler_termios (FH_CONSOLE, -1)
d1699 1
a1699 1
  open ((path_conv *) NULL, flags | O_BINARY);
d1728 1
a1728 1
  if (!open (NULL, O_NOCTTY | get_flags (), 0))
d1758 1
a1758 1
  if (!open (NULL, O_NOCTTY | get_flags (), 0))
@


1.112
log
@* dcrt0.cc (__argc_safe): New variable.
(dll_crt0_1): Store argc in __argc_safe, which will theoretically remain
untouched by the user.
* fhandler_console.cc (fhandler_console::read): Silence some compiler warnings.
* fhandler_raw.cc (fhandler_dev_raw::raw_read): Ditto.
* pinfo.cc (_pinfo::commune_recv): Carefully bound argv scan and check for
potentially bad pointers since user could have set argv cell to anythinw.
* cygheap.h (CYGHEAPSIZE): Bump up size.
@
text
@d513 1
a513 1
 sig_exit:
@


1.111
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d510 1
a510 1
  (ssize_t) buflen = -1;
d515 1
a515 1
  (ssize_t) buflen = -1;
@


1.110
log
@* fhandler_console.cc (fhandler_console::read) Handle certain key up events, to
allow pasting accented characters and typing them using the "alt + numerics"
sequences.
* include/limits.h (IOV_MAX): Set to a number which is small enough to use in
an array.
@
text
@a14 1
#include <errno.h>
@


1.109
log
@* external.cc (check_ntsec): New function.
(cygwin_internal): Add CW_CHECK_NTSEC handling to call check_ntsec() from
applications.
* include/cygwin/version.h: Bump API minor number.
* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_CHECK_NTSEC.
* cygthread.cc (cygthread::new): Add more defensive debugging.
@
text
@a323 3
	  if (!input_rec.Event.KeyEvent.bKeyDown)
	    continue;

d328 15
@


1.108
log
@* cygwin.din: Export btowc, trunc.
* include/cygwin/version.h: Reflect new exports.
* syscalls.cc (_stat): Rename to stat to avoid newlib wrapper.
* syscalls.cc (_fstat): Ditto.
* fhandler_console.cc (fhandler_console::close): Correct check for current tty.
Add debugging output when console is freed.
(set_console_state_for_spawn): Add debugging output.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't decrement console open flag
when vforking.
* sigproc.cc (sigproc_terminate): Fix debugging output.
* spawn.cc (handle): Eliminate second argument.
(spawn_guts): Reflect elimination of argument change to handle.
* syscalls.cc (setsid): Add debugging output when console is freed.
* syscalls.cc (rename): Revert assumption that DELETE_ON_CLOSE works on Win9x.
@
text
@d34 1
a34 1
#define CONVERT_LIMIT 4096
@


1.107
log
@* include/cygwin/version.h: Bump DLL minor number to 23.
@
text
@d651 1
a651 1
      && myself->ctty != FH_CONSOLE)
d653 2
a654 2
      syscall_printf ("open_fhs %d, freeing console",
		      fhandler_console::open_fhs);
@


1.106
log
@* fhandler_console.cc (fhandler_console::close): Don't decrement in use counter
if in vfork fixup stage.
@
text
@d652 5
a656 1
    FreeConsole ();
@


1.106.2.1
log
@* fhandler_console.cc (fhandler_console::close): Correct check for current tty.
Add debugging output when console is freed.
(set_console_state_for_spawn): Add debugging output.
* fhandler_tty.cc (fhandler_tty_slave::open): Don't decrement console open flag
when vforking.
* sigproc.cc (sigproc_terminate): Fix debugging output.
* spawn.cc (handle): Eliminate second argument.
(spawn_guts): Reflect elimination of argument change to handle.
* syscalls.cc (setsid): Add debugging output when console is freed.
@
text
@a168 1
  debug_printf ("h %p", h);
d651 2
a652 6
      && myself->ctty != TTY_CONSOLE)
    {
      syscall_printf ("open_fhs %d, freeing console %p",
		      fhandler_console::open_fhs, myself->ctty);
      FreeConsole ();
    }
@


1.105
log
@* dll_init.cc (dll_list::load_after_fork): Don't revert to LoadLibrary if
LoadLibraryEx fails.
* dtable.cc (dtable::dec_console_fds): Eliminate.
(dtable::release): Don't treat console specially.
(dtable::build_fhandler): Ditto.
* dtable.h (console_fds): Eliminate.
(dtable::dec_console_fds): Eliminate.
(dtable::inc_console_fds): Eliminate.
* fhandler.h (fhandler_console::open_fhs): New static element.
* fhandler_console.cc (fhandler_console::open): Increment open_fs.
(fhandler_console::close): Call FreeConsole if no more open consoles and ctty
is not associated with the console.
* syscalls.cc (setsid): Simplify check for when to call FreeConsole.
(check_pty_fds): Eliminate definition.
* winsup.h (check_pty_fds): Eliminate declaration.
@
text
@d650 2
a651 1
  if (--open_fhs <= 0 && myself->ctty != FH_CONSOLE)
@


1.104
log
@* fhandler_console.cc (fhandler_console::write_normal): Use MessageBeep for
bell sound.
* autoload.cc (MessageBeep): Add.
@
text
@d92 2
d635 2
d650 3
@


1.103
log
@Eliminate most unneeded this-> pointers throughout.
@
text
@d1409 1
a1409 1
	  Beep (412, 100);
@


1.102
log
@* fhandler_console.cc (fhandler_console::send_winch_maybe): Reset scroll region
if size changes.
@
text
@d1680 1
a1680 1
  this->tcsetattr (0, &tc->ti);
d1692 1
a1692 1
  this->fhandler_base::set_close_on_exec (val);
@


1.101
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d218 2
@


1.101.2.1
log
@merge from trunk
@
text
@d845 1
a845 1
  fhandler_termios ()
@


1.101.2.2
log
@merge from trunk
@
text
@a217 2
      dev_state->scroll_region.Top = 0;
      dev_state->scroll_region.Bottom = -1;
@


1.101.2.3
log
@merge from trunk
@
text
@d1680 1
a1680 1
  tcsetattr (0, &tc->ti);
d1692 1
a1692 1
  fhandler_base::set_close_on_exec (val);
@


1.101.2.4
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d25 1
a26 1
#include "fhandler.h"
d584 1
a584 1
fhandler_console::open (int flags, mode_t)
d659 1
a659 1
  if (!fhc->open (get_flags () & ~O_NOCTTY, 0))
d1409 1
a1409 1
	  MessageBeep (0xFFFFFFFF);
d1676 1
a1676 1
  open (flags | O_BINARY);
d1705 1
a1705 1
  if (!open (O_NOCTTY | get_flags (), 0))
d1735 1
a1735 1
  if (!open (O_NOCTTY | get_flags (), 0))
@


1.101.2.5
log
@merge from trunk
@
text
@a91 2
int NO_COPY fhandler_console::open_fhs;

a632 2
  open_fhs++;
  debug_printf ("incremented open_fhs, now %d", open_fhs);
a645 3
  if (--open_fhs <= 0 && myself->ctty != FH_CONSOLE)
    FreeConsole ();
  debug_printf ("decremented open_fhs, now %d", open_fhs);
@


1.101.2.6
log
@merge from trunk
@
text
@d650 1
a650 2
  if (!cygheap->fdtab.in_vfork_cleanup () && --open_fhs <= 0
      && myself->ctty != FH_CONSOLE)
@


1.101.2.7
log
@merge from trunk
@
text
@d651 2
a652 6
      && myself->ctty != TTY_CONSOLE)
    {
      syscall_printf ("open_fhs %d, freeing console %p",
		      fhandler_console::open_fhs, myself->ctty);
      FreeConsole ();
    }
@


1.101.2.8
log
@merge from trunk
@
text
@d34 1
a34 1
#define CONVERT_LIMIT 16384
@


1.101.2.9
log
@merge from trunk
@
text
@d324 3
a330 15

	  /* Ignore key up events, except for left alt events with non-zero character
	   */
	  if (!input_rec.Event.KeyEvent.bKeyDown &&
	      /*
		Event for left alt, with a non-zero character, comes from
		"alt + numerics" key sequence.
		e.g. <left-alt> 0233 => &eacute;
	      */
	      !(wch != 0
		// ?? experimentally determined on an XP system
		&& virtual_key_code == VK_MENU
		// left alt -- see http://www.microsoft.com/hwdev/tech/input/Scancode.asp
		&& input_rec.Event.KeyEvent.wVirtualScanCode == 0x38))
	    continue;
@


1.101.2.10
log
@merge from trunk
@
text
@d15 1
@


1.101.2.11
log
@merge from trunk
@
text
@d510 1
a510 1
  buflen = (size_t) -1;
d513 1
a513 1
sig_exit:
d515 1
a515 1
  buflen = (size_t) -1;
@


1.100
log
@* fhandler.h (fhandler_tty_master::set_winsize): Declare new function.
* fhandler_console.cc (fhandler_console::send_winch_maybe): If appropriate,
call tty master function to handle screen size change.
* fhandler_tty.cc (fhandler_tty_master::set_winsize): New function.
(fhandler_tty_master::init): Call set_winsize to set initial screen size.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
@


1.100.2.1
log
@Eliminate unit argument and special unit fields from fhandler classes and
constructors throughout.
* fhandler_mem.cc (fhandler_dev_mem::fhandler_dev_mem): Make decisions based on
specific device type rather than unit number.
* fhandler_random.cc (fhandler_dev_random::write): Ditto.
(fhandler_dev_random::read): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Set device type to
"urandom" after construction of entropy_source.
* path.cc (windows_devices_names): Remove.
@
text
@d845 1
a845 1
  fhandler_termios (FH_CONSOLE)
@


1.100.2.2
log
@Eliminate device number argument from fhandler constructors throughout.
@
text
@d845 1
a845 1
  fhandler_termios ()
@


1.99
log
@* fhandler.h (fhandler_termios::line_edit): Replace third argument with
passed-in termios struct.
* fhandler_console.cc (fhandler_console::read): Prior to loop, make a copy of
current termios for passing to line_edit prior so that all characters are
processed consistently.
* fhandler_tty.cc (fhandler_pty_master::write): Ditto.
(process_input): Make a copy of curent termios prior to read for use in
subsequent line_edit.
* fhandler_termios.cc (fhandler_termios::line_edit): Replace third parameter
with passed-in termios struct and use it throughout rather than the data from
the current fhandler_termios class.
@
text
@d216 7
a222 1
    tc->kill_pgrp (SIGWINCH);
@


1.98
log
@Throughout, change fhandler_*::read and fhandler_*::raw_read to void functions
whose second arguments are both the lenght and the return value.
* fhandler.cc (fhandler_base::read): Rework slightly to use second argument as
input/output.  Tweak CRLF stuff.
(fhandler_base::readv): Accommodate fhandler_*::read changes.
* cygthread.h (cygthread::detach): Declare as taking optional handle argument.
(cygthread::detach): When given a handle argument, wait for the handle to be
signalled before waiting for thread to detach.  Return true when signal
detected.
@
text
@d250 1
d465 1
a465 1
	  line_edit_status res = line_edit (toadd, nread);
@


1.97
log
@* fhandler.h (fhandler_termios::line_edit): Change return from an int to an
enum to allow the function to return an error.
* fhandler_console.cc (fhandler_console::read): Update the line_edit call to
use the new enum.
* fhandler_termios.cc (fhandler_termios::line_edit): Change return from an int
to an enum to allow the function to return an error.  Put put_readahead call
before doecho for future patch.
* fhandler_tty.cc (fhandler_pty_master::write): Change to call line_edit one
character at a time, and stop if an error occurs.
@
text
@d219 2
a220 2
int __stdcall
fhandler_console::read (void *pv, size_t buflen)
d232 4
a235 1
    return copied_chars;
d254 4
a257 1
	return bgres;
d267 1
a267 2
	  __seterrno ();
	  return -1;
a275 1
	  __seterrno ();
d277 1
a277 1
	  return -1;		/* seems to be failure */
d483 7
a489 1
  return copied_chars;
d493 2
a494 1
  return -1;
@


1.96
log
@* exceptions.cc (setup_handler): Add debugging output.  Set thread priority to
idle if pending signals to allow other threads to get into interruptible state.
* miscfuncs.cc (sys_mbstowcs): Save current thread in variable to avoid an OS
call.
* wait.cc (wait_sig): Reset thread priority each time through loop since the
priority may have been set down to deal with pending signals.
@
text
@d460 2
a461 2
	  int res = line_edit (toadd, nread);
	  if (res < 0)
d463 1
a463 1
	  else if (res)
@


1.95
log
@checking previously ChangeLog'ed file.
@
text
@d1559 1
a1559 3
	    {
	      dev_state->state_ = gotcommand;
	    }
@


1.94
log
@* miscfuncs.cc (low_priority_sleep): New function.  Use throughout where code
is supposed to be giving up time slice.
* fhandler_console.cc (fhandler_console::read): Switch button 2/3 output escape
sequences to be consistent with xterm.
@
text
@d1533 1
a1533 1
	    if (*src < ' ' || *src >= '\177')
@


1.93
log
@* fhandler_console.cc (keytable[]): Revert previous change.  It would break too
many things.
@
text
@d415 1
a415 1
		  b = 1;
d420 1
a420 1
		  b = 2;
@


1.92
log
@* syscalls.cc (getutid): Use UT_IDLEN where appropriate.
@
text
@d1595 5
a1599 5
  {VK_F1,	{"\033[OP",	"\033[23~",	NULL,		NULL}},
  {VK_F2,	{"\033[OQ",	"\033[24~",	NULL,		NULL}},
  {VK_F3,	{"\033[OR",	"\033[25~",	NULL,		NULL}},
  {VK_F4,	{"\033[OS",	"\033[26~",	NULL,		NULL}},
  {VK_F5,	{"\033[15~",	"\033[28~",	NULL,		NULL}},
@


1.91
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info_fork::mount_table): Remove.
(child_info_fork::myself_addr): Remove.
* fork.cc (fork_child): Don't set either of the above.
* dcrt0.cc (dll_crt0_1): Call memory_init as early as possible.
* fhandler_console.cc (console_state): Move to shared_info.h.
(fhandler_console::get_tty_stuff): Reflect open_shared arg change.
* pinfo.cc (myself_addr): Remove definition.
(pinfo::init): Get myself address from open_shared.
* pinfo.h (myself_addr): Remove declaration.
* shared.cc (open_shared): Rework so that known shared memory locations are
protected.  Take shared memory type as fifth argument.
(memory_init): Reflect open_shared arg change.
* shared_info.h (shared_locations): New enum.
(console_state): Move here.
(open_shared): Reflect open_shared arg change in declaration.
@
text
@d1595 5
a1599 5
  {VK_F1,	{"\033[[A",	"\033[23~",	NULL,		NULL}},
  {VK_F2,	{"\033[[B",	"\033[24~",	NULL,		NULL}},
  {VK_F3,	{"\033[[C",	"\033[25~",	NULL,		NULL}},
  {VK_F4,	{"\033[[D",	"\033[26~",	NULL,		NULL}},
  {VK_F5,	{"\033[[E",	"\033[28~",	NULL,		NULL}},
@


1.90
log
@* child_info.h (CURR_CHILD_INFO_MAGIC): Reset.
(child_info_fork::heaptop): Remove obsolete element.
(child_info_fork::heabbase): Ditto.
(child_info_fork::heapptr): Ditto.
(child_info_fork::mount_table): New element.
(child_info_fork::myself_addr): Ditto.
* dcrt0.cc (dll_crt0_1): Set mount_table and myself_addr when forking.
(initial_env): Add newline to "sleeping" message.
* dll_init.cc (reserve_upto): Accommodate cygwin heap when freeing memory.
Make debugging output a little more descriptive.
* fork.cc (fork_parent): Save mount_table and myself_addr.
* pinfo.cc (myself_addr): New variable.
(set_myself): Pass PID_MYSELF flag to init.
(pinfo::Init): Honor PID_MYSELF.  Save address where myself shared memory
resides in myself_addr, for fork.
* pinfo.h (myself_addr): Declare.
* shared.cc (memory_init): On fork, use previously saved address for location
of mount table.
* include/sys/cygwin.h (PID_MYSELF): New value.
* dtable.cc (dtable::stdio_init): Don't pass access type to
init_std_file_from_handle.  It's always the same.
(dtable::init_std_file_from_handle): Remove access type argument.  Assume
read/write.
* dtable.h (dtable::init_std_file_from_handle): Ditto for declaration.
* exceptions.cc (try_to_debug): Don't try to debug if already being debugged.
* fhandler_console.cc (shared_console_info_save): New variable.
(fhandler_console::get_tty_stuff): Save address of shared console stuff for
fork.
@
text
@a87 6
struct console_state
{
  tty_min tty_min_state;
  dev_console dev_state;
};

a88 1
static console_state *shared_console_info_save;
d100 1
a100 1
  shared_console_info = shared_console_info_save =
d103 1
a103 1
				   shared_console_info_save);
@


1.89
log
@* cygheap.cc (dup_now): Make fatal error a little more informative.
(cygheap_setup_for_child): Detect when default size of shared region is less
than the current size and allocate that much.
(_cbrk): Just return NULL on inability to allocate.
(_cmalloc): Ditto.
* cygheap.h (CYGHEAPSIZE): Change size to reflect newer, tinier fhandler sizes.
* spawn.cc (av::error): New element, reflects potential errno from cmalloc.
(av::~av): Don't free NULL pointers.
(av::replace0_maybe): Detect out-of-memory conditions.
(av::dup_maybe): Ditto.
(av::dup_all): Ditto.
(av::unshift): Ditto.
(spawn_guts): Set errno and return if argv creation ran into problems.
* fhandler.h (fhandler_union): Change member names to something safer.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Always set
fhandler_console::dev_state regardless of whether shared region is initialized.
* cygthread.cc (cygthread::runner): Use ExitThread rather than return
(planning for future).
@
text
@d94 2
a95 1
static console_state NO_COPY *shared_console_info = NULL;
d107 1
a107 1
  shared_console_info =
d109 2
a110 1
				   sizeof (*shared_console_info), NULL);
@


1.88
log
@* fhandler.h (dev_console): New class.
(fhandler_console::dev_state): New class element.
(fhandler_console::mouse_aware): Use dev_state element.
(fhandler_console::get_tty_stuff): Declare new function.
* fhandler_console.cc: Use dev_state fhandler_console element, throughout.
(fhandler_console::get_tty_stuff): Move to fhandler_console class.  Incorporate
dev_console information.  Move constructor stuff here.
@
text
@d103 1
a103 1
  if (shared_console_info)
d109 2
a117 1
      fhandler_console::dev_state = &shared_console_info->dev_state;
@


1.87
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d81 2
a82 2
#define srTop (info.winTop + scroll_region.Top)
#define srBottom ((scroll_region.Bottom < 0) ? info.winBottom : info.winTop + scroll_region.Bottom)
d88 9
a96 1
static tty_min NO_COPY *shared_console_info = NULL;
d100 2
a101 2
static tty_min *
get_tty_stuff (int flags = 0)
d104 1
a104 1
    return shared_console_info;
d106 3
a108 3
  shared_console_info = (tty_min *) open_shared (NULL, 0, cygheap->console_h,
						 sizeof (*shared_console_info),
						 NULL);
d110 1
a110 1
  if (!shared_console_info->ntty)
d112 23
a134 3
      shared_console_info->setntty (TTY_CONSOLE);
      shared_console_info->setsid (myself->sid);
      shared_console_info->set_ctty (TTY_CONSOLE, flags);
d136 2
a137 1
  return shared_console_info;
d143 1
a143 1
  (void) get_tty_stuff ();
d153 1
a153 1
    return get_tty_stuff ();
d176 2
a177 1
#     define tc shared_console_info	/* ACK.  Temporarily define for use in TTYSETF macro */
d190 3
a192 3
  BOOL old_mode = raw_win32_keyboard_mode;
  raw_win32_keyboard_mode = new_mode;
  syscall_printf ("raw keyboard mode %sabled", raw_win32_keyboard_mode ? "en" : "dis");
d204 2
a205 2
  if (dwLastCursorPosition.X != now.dwCursorPosition.X ||
      dwLastCursorPosition.Y != now.dwCursorPosition.Y)
d208 1
a208 1
      dwLastCursorPosition = now.dwCursorPosition;
d215 2
a216 2
  SHORT y = info.dwWinSize.Y;
  SHORT x = info.dwWinSize.X;
d219 1
a219 1
  if (y != info.dwWinSize.Y || x != info.dwWinSize.X)
d294 1
a294 1
	      set_raw_win32_keyboard_mode (!raw_win32_keyboard_mode);
d299 1
a299 1
	  if (raw_win32_keyboard_mode)
d350 2
a351 2
		   on meta_mask heuristic (see fhandler_console constructor). */
		meta = (control_key_state & meta_mask) != 0;
d370 1
a370 1
	  if (use_mouse)
d402 1
a402 1
	      if (mouse_event.dwButtonState == dwLastButtonState)
d407 1
a407 1
	      else if (mouse_event.dwButtonState < dwLastButtonState)
d412 1
a412 1
	      else if ((mouse_event.dwButtonState & 1) != (dwLastButtonState & 1))
d417 1
a417 1
	      else if ((mouse_event.dwButtonState & 2) != (dwLastButtonState & 2))
d422 1
a422 1
	      else if ((mouse_event.dwButtonState & 4) != (dwLastButtonState & 4))
d429 1
a429 1
	      dwLastButtonState = mouse_event.dwButtonState;
d434 1
a434 1
		  nModifiers = 0;
d436 1
a436 1
		    nModifiers |= 0x4;
d438 1
a438 1
		    nModifiers |= 0x8;
d440 1
a440 1
		    nModifiers |= 0x10;
d443 1
a443 1
	      b |= nModifiers;
d505 7
a511 7
      info.winTop = linfo.srWindow.Top;
      info.winBottom = linfo.srWindow.Bottom;
      info.dwWinSize.Y = 1 + linfo.srWindow.Bottom - linfo.srWindow.Top;
      info.dwWinSize.X = 1 + linfo.srWindow.Right - linfo.srWindow.Left;
      info.dwBufferSize = linfo.dwSize;
      info.dwCursorPosition = linfo.dwCursorPosition;
      info.wAttributes = linfo.wAttributes;
d515 4
a518 4
      memset (&info, 0, sizeof info);
      info.dwWinSize.Y = 25;
      info.dwWinSize.X = 80;
      info.winBottom = 24;
d532 1
a532 1
  sr1.Left = x1 >= 0 ? x1 : info.dwWinSize.X - 1;
d534 1
a534 1
    sr1.Top = info.winTop;
d536 2
a537 2
    sr1.Top = y1 > 0 ? y1 : info.winBottom;
  sr1.Right = x2 >= 0 ? x2 : info.dwWinSize.X - 1;
d539 1
a539 1
    sr1.Bottom = info.winTop;
d541 1
a541 1
    sr1.Bottom = y2 > 0 ? y2 : info.winBottom;
d545 1
a545 1
  sr2.Right = info.dwWinSize.X - 1;
d548 1
a548 1
  dest.X = xn >= 0 ? xn : info.dwWinSize.X - 1;
d550 1
a550 1
    dest.Y = info.winTop;
d552 1
a552 1
    dest.Y = yn > 0 ? yn : info.winBottom;
d554 1
a554 1
  fill.Attributes = current_win32_attr;
d604 1
a604 1
    default_color = info.wAttributes;
a645 41
  fhc->default_color = default_color;
  fhc->underline_color = underline_color;
  fhc->dim_color = dim_color;
  fhc->state_ = state_;
  fhc->nargs_ = nargs_;
  for (int i = 0; i < MAXARGS; i++)
    fhc->args_[i] = args_[i];
  fhc->rarg = rarg;
  fhc->saw_question_mark = saw_question_mark;

  strncpy (fhc->my_title_buf, my_title_buf, TITLESIZE + 1) ;

  fhc->current_win32_attr = current_win32_attr;
  fhc->intensity = intensity;
  fhc->underline = underline;
  fhc->blink = blink;
  fhc->reverse = reverse;
  fhc->fg = fg;
  fhc->bg = bg;

  fhc->savex = savex;
  fhc->savey = savey;

  fhc->savebufsiz = savebufsiz;
  if (savebuf)
    {
      fhc->savebuf = (PCHAR_INFO) cmalloc (HEAP_1_BUF, sizeof (CHAR_INFO) *
					  savebufsiz.X * savebufsiz.Y);
      memcpy (fhc->savebuf, savebuf, sizeof (CHAR_INFO) *
				     savebufsiz.X * savebufsiz.Y);
    }

  fhc->scroll_region = scroll_region;
  fhc->dwLastCursorPosition = dwLastCursorPosition;
  fhc->dwLastButtonState = dwLastButtonState;
  fhc->nModifiers = nModifiers;

  fhc->insert_mode = insert_mode;
  fhc->use_mouse = use_mouse;
  fhc->raw_win32_keyboard_mode = raw_win32_keyboard_mode;

d662 2
a663 2
	    ((struct winsize *) buf)->ws_row = info.dwWinSize.Y;
	    ((struct winsize *) buf)->ws_col = info.dwWinSize.X;
d831 2
a832 26
  fhandler_termios (FH_CONSOLE, -1),
  default_color (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE),
  underline_color (FOREGROUND_GREEN | FOREGROUND_BLUE),
  dim_color (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE),
  meta_mask (LEFT_ALT_PRESSED), state_ (normal), nargs_ (0), savex (0),
  savey (0), savebuf (NULL), dwLastButtonState (0), nModifiers (0),
  insert_mode (false), use_mouse (false), raw_win32_keyboard_mode (false)
{
  for (int i = 0; i < MAXARGS; i++) args_ [i] = 0;
  savebufsiz.X = savebufsiz.Y = 0;
  scroll_region.Top = 0;
  scroll_region.Bottom = -1;
  dwLastCursorPosition.X = -1;
  dwLastCursorPosition.Y = -1;
  /* Set the mask that determines if an input keystroke is modified by
     META.  We set this based on the keyboard layout language loaded
     for the current thread.  The left <ALT> key always generates
     META, but the right <ALT> key only generates META if we are using
     an English keyboard because many "international" keyboards
     replace common shell symbols ('[', '{', etc.) with accented
     language-specific characters (umlaut, accent grave, etc.).  On
     these keyboards right <ALT> (called AltGr) is used to produce the
     shell symbols and should not be interpreted as META. */
  if (PRIMARYLANGID (LOWORD (GetKeyboardLayout (0))) == LANG_ENGLISH)
    meta_mask |= RIGHT_ALT_PRESSED;

d842 6
a847 6
  blink = underline = reverse = FALSE;
  intensity = INTENSITY_NORMAL;
  fg = default_color & FOREGROUND_ATTR_MASK;
  bg = default_color & BACKGROUND_ATTR_MASK;
  current_win32_attr = get_win32_attr ();
  SetConsoleTextAttribute (get_output_handle (), current_win32_attr);
d853 3
a855 3
  WORD win_fg = fg;
  WORD win_bg = bg;
  if (reverse)
d867 2
a868 1
  if (underline) win_fg = underline_color;
d870 3
a872 2
  if (blink) win_bg |= BACKGROUND_INTENSITY;
  if (intensity == INTENSITY_INVISIBLE)
d874 1
a874 1
  else if (intensity == INTENSITY_BOLD)
d893 1
a893 1
    x1 = info.dwWinSize.X - 1;
d895 1
a895 1
    y1 = info.winBottom;
d897 1
a897 1
    x2 = info.dwWinSize.X - 1;
d899 1
a899 1
    y2 = info.winBottom;
d901 1
a901 1
  num = abs (y1 - y2) * info.dwBufferSize.X + abs (x1 - x2) + 1;
d903 1
a903 1
  if ((y2 * info.dwBufferSize.X + x2) > (y1 * info.dwBufferSize.X + x1))
d918 1
a918 1
			       current_win32_attr,
d930 2
a931 2
  if (y > info.winBottom)
    y = info.winBottom;
d935 1
a935 1
    y += info.winTop;
d937 2
a938 2
  if (x > info.dwWinSize.X)
    x = info.dwWinSize.X - 1;
d951 2
a952 2
  x += info.dwCursorPosition.X;
  y += info.dwCursorPosition.Y;
d960 2
a961 2
  *y = info.dwCursorPosition.Y;
  *x = info.dwCursorPosition.X;
d1025 2
a1026 2
       for (i = 0; i <= nargs_; i++)
	 switch (args_[i])
d1032 1
a1032 1
	       intensity = INTENSITY_BOLD;
d1035 1
a1035 1
	       underline = 1;
d1038 1
a1038 1
	       blink = TRUE;
d1041 1
a1041 1
	       reverse = TRUE;
d1044 1
a1044 1
	       intensity = INTENSITY_INVISIBLE;
d1047 1
a1047 1
	       intensity = INTENSITY_DIM;
d1050 1
a1050 1
	       underline = FALSE;
d1053 1
a1053 1
	       reverse = FALSE;
d1056 1
a1056 1
	       fg = 0;
d1059 1
a1059 1
	       fg = FOREGROUND_RED;
d1062 1
a1062 1
	       fg = FOREGROUND_GREEN;
d1065 1
a1065 1
	       fg = FOREGROUND_RED | FOREGROUND_GREEN;
d1068 1
a1068 1
	       fg = FOREGROUND_BLUE;
d1071 1
a1071 1
	       fg = FOREGROUND_RED | FOREGROUND_BLUE;
d1074 1
a1074 1
	       fg = FOREGROUND_BLUE | FOREGROUND_GREEN;
d1077 1
a1077 1
	       fg = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED;
d1080 1
a1080 1
	       fg = default_color & FOREGROUND_ATTR_MASK;
d1083 1
a1083 1
	       bg = 0;
d1086 1
a1086 1
	       bg = BACKGROUND_RED;
d1089 1
a1089 1
	       bg = BACKGROUND_GREEN;
d1092 1
a1092 1
	       bg = BACKGROUND_RED | BACKGROUND_GREEN;
d1095 1
a1095 1
	       bg = BACKGROUND_BLUE;
d1098 1
a1098 1
	       bg = BACKGROUND_RED | BACKGROUND_BLUE;
d1101 1
a1101 1
	       bg = BACKGROUND_BLUE | BACKGROUND_GREEN;
d1104 1
a1104 1
	       bg = BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED;
d1107 1
a1107 1
	       bg = default_color & BACKGROUND_ATTR_MASK;
d1110 2
a1111 2
	 current_win32_attr = get_win32_attr ();
	 SetConsoleTextAttribute (get_output_handle (), current_win32_attr);
d1115 1
a1115 1
      if (!saw_question_mark)
d1117 1
a1117 1
	  switch (args_[0])
d1120 2
a1121 2
	      insert_mode = (c == 'h') ? TRUE : FALSE;
	      syscall_printf ("insert mode %sabled", insert_mode ? "en" : "dis");
d1126 1
a1126 1
      switch (args_[0])
d1137 2
a1138 2
	      savebufsiz.X = now.srWindow.Right - now.srWindow.Left + 1;
	      savebufsiz.Y = now.srWindow.Bottom - now.srWindow.Top + 1;
d1140 4
a1143 4
	      if (savebuf)
		cfree (savebuf);
	      savebuf = (PCHAR_INFO) cmalloc (HEAP_1_BUF, sizeof (CHAR_INFO) *
					     savebufsiz.X * savebufsiz.Y);
d1145 2
a1146 2
	      ReadConsoleOutputA (get_output_handle (), savebuf,
				  savebufsiz, cob, &now.srWindow);
d1156 1
a1156 1
	      if (!savebuf)
d1159 2
a1160 2
	      WriteConsoleOutputA (get_output_handle (), savebuf,
				   savebufsiz, cob, &now.srWindow);
d1162 3
a1164 3
	      cfree (savebuf);
	      savebuf = NULL;
	      savebufsiz.X = savebufsiz.Y = 0;
d1169 2
a1170 2
	  use_mouse = (c == 'h') ? TRUE : FALSE;
	  syscall_printf ("mouse support %sabled", use_mouse ? "en" : "dis");
d1178 1
a1178 1
	  syscall_printf ("unknown h/l command: %d", args_[0]);
d1183 1
a1183 1
      switch (args_[0])
d1203 1
a1203 1
      cursor_rel (0, -(args_[0] ? args_[0] : 1));
d1206 1
a1206 1
      cursor_rel (0, args_[0] ? args_[0] : 1);
d1209 1
a1209 1
      cursor_rel (args_[0] ? args_[0] : 1, 0);
d1212 1
a1212 1
      cursor_rel (-(args_[0] ? args_[0] : 1),0);
d1215 1
a1215 1
      switch (args_[0])
d1235 2
a1236 2
      cursor_set (TRUE, (args_[1] ? args_[1] : 1) - 1,
			(args_[0] ? args_[0] : 1) - 1);
d1240 1
a1240 1
      cursor_set (FALSE, (args_[0] ? args_[0] - 1 : 0), y);
d1244 1
a1244 1
      cursor_set (TRUE, x, (args_[0] ? args_[0] - 1 : 0));
d1247 2
a1248 2
      cursor_get (&savex, &savey);
      savey -= info.winTop;
d1251 1
a1251 1
      cursor_set (TRUE, savex, savey);
d1258 1
a1258 1
      args_[0] = args_[0] ? args_[0] : 1;
d1260 1
a1260 1
      scroll_screen (0, y, -1, -1, 0, y + args_[0]);
d1263 1
a1263 1
      args_[0] = args_[0] ? args_[0] : 1;
d1265 1
a1265 1
      scroll_screen (0, y + args_[0], -1, -1, 0, y);
d1268 1
a1268 1
      args_[0] = args_[0] ? args_[0] : 1;
d1270 1
a1270 1
      scroll_screen (x, y, -1, y, x + args_[0], y);
d1273 1
a1273 1
      args_[0] = args_[0] ? args_[0] : 1;
d1275 1
a1275 1
      scroll_screen (x + args_[0], y, -1, y, x, y);
d1278 2
a1279 2
      args_[0] = args_[0] ? args_[0] : 1;
      scroll_screen (0, args_[0], -1, -1, 0, 0);
d1283 2
a1284 2
      args_[0] = args_[0] ? args_[0] : 1;
      scroll_screen (0, 0, -1, -1, 0, info.winTop + args_[0]);
d1287 1
a1287 1
      args_[0] = args_[0] ? args_[0] : 1;
d1289 2
a1290 2
      scroll_screen (x + args_[0], y, -1, y, x, y);
      scroll_screen (x, y, -1, y, x + args_[0], y);
d1297 1
a1297 1
      if (insert_mode)
d1300 1
a1300 1
	  scroll_screen (x, y, -1, y, x + args_[1], y);
d1302 2
a1303 2
      while (args_[1]--)
	WriteFile (get_output_handle (), &args_[0], 1, (DWORD *) &x, 0);
d1310 1
a1310 1
      switch (args_[0])
d1314 2
a1315 2
	  y -= info.winTop;
	  /* x -= info.winLeft;		// not available yet */
d1324 2
a1325 2
      scroll_region.Top = args_[0] ? args_[0] - 1 : 0;
      scroll_region.Bottom = args_[1] ? args_[1] - 1 : -1;
d1362 2
a1363 1
	      debug_printf ("conversion error, handle %p", get_output_handle ());
d1368 1
a1368 1
	  if (insert_mode)
d1396 1
a1396 1
	  state_ = gotesc;
d1402 1
a1402 1
	      if (y >= info.winBottom && !scroll_region.Top)
d1447 2
a1448 2
		    state_);
      switch (state_)
d1458 5
a1462 5
	      state_ = gotsquare;
	      saw_question_mark = FALSE;
	      for (nargs_ = 0; nargs_ < MAXARGS; nargs_++)
		args_[nargs_] = 0;
	      nargs_ = 0;
d1466 3
a1468 3
	      rarg = 0;
	      my_title_buf[0] = '\0';
	      state_ = gotrsquare;
d1473 2
a1474 2
	      scroll_screen (0, 0, -1, -1, 0, info.winTop + 1);
	      state_ = normal;
d1481 1
a1481 1
	      state_ = normal;
d1485 2
a1486 2
	      cursor_set (TRUE, savex, savey);
	      state_ = normal;
d1490 3
a1492 3
	      cursor_get (&savex, &savey);
	      savey -= info.winTop;
	      state_ = normal;
d1495 1
a1495 1
	      state_ = normal;
d1498 1
a1498 1
	      state_ = normal;
d1505 1
a1505 1
	      args_[nargs_] = args_[nargs_] * 10 + *src - '0';
d1511 3
a1513 3
	      nargs_++;
	      if (nargs_ >= MAXARGS)
		nargs_--;
d1517 1
a1517 1
	      state_ = gotcommand;
d1522 1
a1522 1
	  state_ = normal;
d1526 3
a1528 3
	    rarg = rarg * 10 + (*src - '0');
	  else if (*src == ';' && (rarg == 2 || rarg == 0))
	    state_ = gettitle;
d1530 1
a1530 1
	    state_ = eattitle;
d1536 1
a1536 1
	    int n = strlen (my_title_buf);
d1539 1
a1539 1
		if (*src == '\007' && state_ == gettitle)
d1542 2
a1543 2
		      strcpy (old_title, my_title_buf);
		    set_console_title (my_title_buf);
d1545 1
a1545 1
		state_ = normal;
d1549 2
a1550 2
		my_title_buf[n++] = *src;
		my_title_buf[n] = '\0';
d1558 2
a1559 2
	      state_ = gotarg1;
	      nargs_++;
d1564 1
a1564 1
	      state_ = gotcommand;
d1569 1
a1569 1
		saw_question_mark = TRUE;
d1574 1
a1574 1
	    state_ = gotarg1;
@


1.86
log
@Cleanup calls to CreateFile throughout.
* dcrt0.cc (__api_fatal): Correctly check for failing return from CreateFile.
* assert.cc (__assert): Don't check return value from CreateFile for NULL.
* fhandler_console.cc (set_console_state_for_spawn): Ditto.
* fork.cc (fork_parent): Ditto.
@
text
@d544 2
a545 2
  set_io_handle (INVALID_HANDLE_VALUE);
  set_output_handle (INVALID_HANDLE_VALUE);
d598 2
a599 2
  set_io_handle (INVALID_HANDLE_VALUE);
  set_output_handle (INVALID_HANDLE_VALUE);
@


1.85
log
@* cygthread.cc (cygthread::initialized): Avoid copying on fork or some threads
may not end up in the pool.
(cygthread::new): Avoid race when checking for initialized.  Add debugging
code.
* fhandler.cc (fhandler_base::raw_read): Add case for ERROR_INVALID_HANDLE due
to Win95 directories.
(fhandler_base::open): Handle errors due to Win95 directories.
(fhandler_base::close): Add get_nohandle () test.
(fhandler_base::set_close_on_exec): Ditto.
(fhandler_base::fork_fixup): Ditto.
(fhandler_base::lock): Change error code to Posix EINVAL.
(fhandler_base::dup): If get_nohandle (), set new value to INVALID_HANDLE_VALUE
instead of NULL.
* fhandler_disk_file.cc (fhandler_disk_file::fstat): Call fstat_by_name if
get_nohandle ().  Remove extraneous element from strpbrk.
(fhandler_disk_file::open): Remove test for Win95 directory.
* fhandler_random.cc (fhandler_dev_random::open): Add set_nohandle ().
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
(fhandler_dev_zero::close): Delete.
* fhandler.h (class fhandler_dev_zero): Ditto.
@
text
@d138 3
a140 3
  HANDLE h = CreateFileA ("CONIN$", GENERIC_READ, FILE_SHARE_WRITE,
			  &sec_none_nih, OPEN_EXISTING,
			  FILE_ATTRIBUTE_NORMAL, NULL);
d142 1
a142 1
  if (h == INVALID_HANDLE_VALUE || h == NULL)
d550 3
a552 3
  h = CreateFileA ("CONIN$", GENERIC_READ|GENERIC_WRITE,
		   FILE_SHARE_READ | FILE_SHARE_WRITE, &sec_none,
		   OPEN_EXISTING, 0, 0);
d562 3
a564 3
  h = CreateFileA ("CONOUT$", GENERIC_READ|GENERIC_WRITE,
		   FILE_SHARE_READ | FILE_SHARE_WRITE, &sec_none,
		   OPEN_EXISTING, 0, 0);
@


1.84
log
@* fhandler.h (fhandler_console::send_winch_maybe): New method.
* fhandler_console.cc (set_console_state_for_spawn): Remove if 0'ed code.
(fhandler_console::send_winch_maybe): Define new method.
(fhandler_console::read): Use send_winch_maybe where appropriate.
(fhandler_console::init): Just call all tcsetattr rather than output_tcsetattr.
* select.cc (peek_console): Reorganize so that send_winch_maybe is called for
everything but keyboard input.
@
text
@d188 1
a188 1
	       
@


1.83
log
@* Makefile.in (DLL_OFILES): Add cygthread.o.
* dcrt0.cc (dll_crt0_1): Eliminate various thread initialization functions in
favor of new cygthread class.
* debug.cc: Remove thread manipulation functions.
* debug.h: Ditto.
* external.cc (cygwin_internal): Use cygthread method for determining thread
name.  Remove capability for setting thread name.
* fhandler_console.cc (fhandler_console::read): Use cygthread method rather
than iscygthread function.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Use cygthread
methods to create threads.
(fhandler_tty_common::__acquire_output_mutex): Use cygthread method to retrieve
thread name.
* select.cc (pipeinf): Use cygthread pointer rather than handle.
(start_thread_pipe): Ditto.
(pipe_cleanup): Ditto.
(serialinf): Ditto.
(start_thread_serial): Ditto.
(serial_cleanup): Ditto.
(socketinf): Ditto.
(start_thread_socket): Ditto.
(socket_cleanup): Ditto.
* sigproc.cc (hwait_sig): Ditto.
(hwait_subproc): Ditto.
(proc_terminate): Ditto.
(sigproc_terminate): Ditto.
(sigproc_init): Initialize cygthread hwait_sig pointer.
(subproc_init): Initialize cygthread hwait_subproc pointer.
(wait_sig): Rely on cygthread HANDLE operator.
* strace.cc (strace::vsprntf): Use cygthread::name rather than threadname.
* window.cc (gethwnd): Use cygthread method to initialize thread.
@
text
@a149 7
#if 0
      char ch;
      DWORD n;
      /* NOTE -- This ReadFile is apparently necessary for correct functioning on
	 Windows NT 4.0.  Without this, the next ReadFile returns garbage.  */
      (void) ReadFile (h, &ch, 0, &n, NULL);
#endif
d182 11
d339 1
d342 1
a342 1
	      MOUSE_EVENT_RECORD & mouse_event = input_rec.Event.MouseEvent;
d424 1
d426 2
a427 3
	  tc->kill_pgrp (SIGWINCH);
	  continue;

d501 1
a501 1
  (void)fillin_info ();
a768 2
  /* What about ENABLE_WINDOW_INPUT
     and ENABLE_MOUSE_INPUT   ? */
d962 1
a962 1
  (void)fillin_info ();
d1698 1
a1698 1
  output_tcsetattr (0, &tc->ti);
@


1.82
log
@* fhandler_console.cc (fhandler_console::read): Use appropriate kill_pgrp
method.
* select.cc (peek_console): Ditto.
* fhandler_termios.cc (fhandler_termios::bg_check): Send "stopped" signal to
entire process group as dictated by SUSv3.
* termios.cc (tcsetattr): Detect when stopped signal sent and force a stop
before setting anything.
@
text
@d32 1
d209 1
a209 1
  if (iscygthread ())
@


1.81
log
@* debug.h (handle_list): Move here from debug.cc.  Add "inherit" flag
functionality.
* cygheap.cc (init_cheap): Move cygheap_max calculation to _csbrk.
(_csbrk): Reorganize to not assume first allocation is <= 1 page.
(cygheap_setup_for_child): Mark protected handle as inheritable.
* cygheap.h (cygheap_debug): New struct.
(init_cygheap): Add new structure when debugging.
* dcrt0.cc (dll_crt0_1): Remove call to debug_init.  Close ppid_handle here, if
appropriate.  Don't protect subproc_ready, since it is already protected in the
parent.  Call memory_init prior to ProtectHandle to ensure that cygheap is set
up.  Call debug_fixup_after_fork_exec when appropriate.
(_dll_crt0): Don't close ppid_handle here.
* debug.cc: Use cygheap debug structure rather than static elements throughout.
(add_handle): Don't issue a warning if attempt to protect handle in exactly the
same way from exactly the same place.  Add pid info to warning output.  Accept
additional argument controlling whether handle is to be inherited.  Add pid to
stored information.
(debug_fixup_after_fork_exec): Renamed from debug_fixup_after_fork.  Reorganize
to avoid erroneously skipping handles.
(mark_closed): Add pid info to warning output.
(setclexec): Rename from setclexec_pid.
* fhandler.cc (fhandler_base::get_default_fmode): Minor reorg.
(fhandler_base::fstat): Add debugging output.
(fhandler_base::set_inheritance): Call setclexec rather than setclexec_pid.
(fhandler_base::fork_fixup): Ditto.
* fhandler_console.cc (get_tty_stuff): Mark protected handle as inheritable.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* tty.cc (tty::make_pipes): Ditto.
(tty::common_init): Ditto.
* fork.cc (fork_parent): Ditto.
(fork_child): Close protected handles with correct name.  Remove
debug_fixup_after_fork call.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Mark protected
handle as inheritable/non-inheritable, as appropriate.
* shared.cc (memory_init): Mark protected handle as inheritable.  Call
debug_init here.
* sigproc.cc (wait_sig): Close protected handle with correct name.
* spawn.cc (spawn_guts): Rename spr to subproc_ready and mark it as
inheritable.
* exceptions.cc (debugger_command): Try to run dumper.exe, if found.
* syscalls.cc (fstat64): Don't follow symlinks for path_conv lookup since path
is already resolved.
@
text
@d419 1
a419 1
	  kill_pgrp (tc->getpgid (), SIGWINCH);
@


1.80
log
@* fhandler_clipboard.c (fhandler_dev_clipboard::open): Force text mode.
* fhandler_console.cc (fhandler_console::open): *Really* force binary mode
rather than make it optional.
* fhandler_proc.cc (fhandler_proc::open): Ditto.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (set_flags): Add more debugging.
@
text
@d100 1
a100 1
  ProtectHandle (cygheap->console_h);
@


1.79
log
@* autoload (noload): Avoid clobbering bx register.
* environ.cc (codepage_init): Use case insensitive match.
* fhandler_console.cc (cp_get_internal): Delete.
(con_to_str): Use get_cp to derive code page.
(str_to_con): Ditto.
* miscfuncs.cc (get_cp): New function.
(sys_wcstombs): New function.  Converted from macro.
(sys_mbstowcs): Ditto.
* winsup.h: Reflect above changes.
@
text
@d541 1
a541 1
  set_flags (flags & ~O_TEXT, O_BINARY);
@


1.78
log
@* dtable.cc (handle_to_fn): Attempt to handle "raw" accesses to remote shares.
* path.cc (mount_info::conv_to_win32_path): Set flags to binary when mount
entry is not found.
(mount_info::set_flags_from_win32_path): Ditto.
@
text
@d20 1
a20 1
#include <winnls.h>	// MultiByteToWideChar () and friends
a34 8
/* The codepages are resolved here instead of using CP_ACP and
   CP_OEMCP, so that they can later be compared for equality. */
inline UINT
cp_get_internal ()
{
  return current_codepage == ansi_cp ? GetACP() : GetOEMCP();
}

d36 1
a36 1
cp_convert (UINT destcp, char * dest, UINT srccp, const char * src, DWORD size)
d63 1
a63 1
  return cp_convert (cp_get_internal (), d, GetConsoleCP (), s, sz);
d69 1
a69 1
  return cp_convert (GetConsoleOutputCP (), d, cp_get_internal (), s, sz);
@


1.77
log
@Remove fcntl.h includes throughout.
* fhandler.h: Move fcntl.h include here.
(fhandler_base::set_flags): Accept supplied_bin argument.  Make non-inlined.
* dtable.cc (dtable::init_std_file_from_handle): Just use binmode from pc.
(reset_to_open_binmode): Use set_flags.
* cygwin.din (open): Avoid newlib wrapper.
(read): Ditto.
(unlink): Ditto.
(write): Ditto.
* fhandler.cc (fhandler_base::set_flags): Accept supplied_bin argument.  Make
binmode decisions here.
(fhandler_base::open): Avoid using pc if it is NULL.  Eliminate binmode logic.
Just call set_flags with binmode argument.
(fhandler_base::init): Call set_flags with binmode argument.
* fhandler_clipboard.cc (fhandler_dev_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::init): Force binary on open.
* fhandler_disk_file.cc (fhandler_disk_file::open): Don't set binmode here.
Let it happen in base class.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Force binmode open.  Set return
value appropriately if unable to open.
* fhandler_proc.cc (fhandler_proc::open): Make sure flags are set before
open_status.
* fhandler_process.cc (fhandler_process::open): Ditto.
* fhandler_registry.cc (fhandler_registry::open): Ditto.
* fhandler_random.cc (fhandler_dev_random::fhandler_dev_random): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Force O_BINARY by default.
* fhandler_serial.cc (fhandler_serial::init): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_virtual.cc (fhandler_virtual::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* net.cc (fdsock): Ditto.
* path.cc (path_conv::check): Avoid checking for extension when error or
directory.
(set_flags): Set PATH_TEXT explicitly, when appropriate.
(mount_info::conv_to_win32_path): Use set_flags() to set path flags.
* path.h (PATH_TEXT): New enum.
(path_conv::binmode): Return appropriate constant based on binmode.
* pipe.cc (make_pipe): Set binmode to O_TEXT xor O_BINARY.
* syscalls.cc (setmode_helper): Make debugging message a little clearer.
(setmode): Set binmode via set_flags.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Red Hat, Inc.
a715 8
  /* Ignore the optional_actions stuff, since all output is emitted
     instantly */

#if 0
  /* Enable/disable LF -> CRLF conversions */
  set_w_binary ((t->c_oflag & ONLCR) ? 0 : 1);
#endif

d738 1
d741 1
a814 7

#if 0
  if (!get_r_binary ())
    t->c_iflag |= IGNCR;
  if (!get_w_binary ())
    t->c_oflag |= ONLCR;
#endif
@


1.76
log
@* fhandler.cc (fhandler_base::open): Don't set binmode if already set.  Don't
check for file.  Files should already be set.  Report on binary mode for
debugging.
(fhandler_base::fhandler_base): Don't set default binmode here.  That's for
later.
* fhandler_console.cc (fhandler_console::output_tcsetattr): Don't set binmode,
ever, for console.
* fhandler_disk_file.cc (fhandler_disk_file::open): Always set the binary mode
to the value derived from mount table.
* path.cc (mount_info::conv_to_win32_path): Default to binmode if path does not
translate into anything in the mount table.
@
text
@a14 1
#include <fcntl.h>
d549 1
a549 3
  set_flags (flags);
  set_w_binary (1);
  set_r_binary (1);
d1700 1
a1700 2
  this->fhandler_termios::init (f, a, bin);

d1702 1
a1702 1
  int mode = 0;
d1706 1
a1706 1
    mode = O_RDONLY;
d1708 1
a1708 1
    mode = O_WRONLY;
d1710 2
a1711 2
    mode = O_RDWR;
  open ((path_conv *) NULL, mode);
@


1.75
log
@* fhandler_console.cc (fhandler_console::open): Reinstate setting of flags.
@
text
@d722 1
d725 1
@


1.74
log
@* fhandler_console.cc (fhandler_console::open): Always default to binmode.
(fhandler_console::write_normal): Don't honor binmode setting.  There is
already a termios setting for this.
(fhandler_console::init): Correct argument order in init call.
@
text
@d550 1
@


1.73
log
@* autoload.cc (LoadFuncEx): Define via new LoadFuncEx2 macro.
(LoadFuncEx2): Adapted from LoadFuncEx.  Provides control of return value for
nonexistent function.
(NtQueryObject): Declare.
(IsDebuggerPresent): Declare via LoadFuncEx2 and always return true if not
available.
* debug.h (being_debugged): Just rely on IsDebuggerPresent return value.
* dtable.cc (handle_to_fn): New function.
(dtable::init_std_file_from_handle): Attempt to derive std handle's name via
handle_to_fn.
(dtable::build_fhandler_from_name): Fill in what we can in path_conv structure
when given a handle and path doesn't exist.
* fhandler.cc (fhandler_base::open): Don't set the file pointer here.  Use
pc->exists () to determine if file exists rather than calling GetFileAttributes
again.
* fhandler.h (fhandler_base::exec_state_isknown): New method.
(fhandler_base::fstat_helper): Add extra arguments to declaration.
(fhandler_base::fstat_by_handle): Declare new method.
(fhandler_base::fstat_by_name): Declare new method.
* fhandler_disk_file (num_entries): Make __stdcall.
(fhandler_base::fstat_by_handle): Define new method.
(fhandler_base::fstat_by_name): Define new method.
(fhandler_base:fstat): Call fstat_by_{handle,name} as appropriate.
(fhandler_disk_file::fstat_helper): Accept extra arguments for filling out stat
structure.  Move handle or name specific stuff to new methods above.
(fhandler_disk_file::open): Use real_path->exists rather than calling
GetFileAttributes again.
* ntdll.h (FILE_NAME_INFORMATION): Define new structure.
(OBJECT_INFORMATION_CLASS): Partially define new enum.
(OBJECT_NAME_INFORMATION): Define new structure.
(NtQueryInformationFile): New declaration.
(NtQueryObject): New declaration.
* path.cc (path_conv::fillin): Define new method.
* path.h (path_conv::fillin): Declare new method.
(path_conv::drive_thpe): Rename from 'get_drive_type'.
(path_conv::volser): Declare new method.
(path_conv::volname): Declare new method.
(path_conv::root_dir): Declare new method.
* syscalls.cc (fstat64): Send real path_conv to fstat as second argument.
@
text
@d550 2
a551 1
  set_flags (flags);
d1447 1
a1447 1
	case DWN:		/* WriteFile ("\n") always adds CR... */
d1451 3
a1453 1
	      if (y < info.winBottom || scroll_region.Top)
a1457 2
	      else
		WriteFile (get_output_handle (), "\n", 1, &done, 0);
d1459 1
a1459 3
	  if (!get_w_binary ())
	    x = 0;
	  cursor_set (FALSE, x, y + 1);
d1700 1
a1700 1
  this->fhandler_termios::init (f, bin, a);
@


1.72
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d1197 1
a1197 1
	  else          /* restore */
@


1.71
log
@Revert erroneous checkin.
@
text
@a29 1
#include "sync.h"
@


1.70
log
@* Makefile.in (libcygwin.a): Use ar commands to build libcygwin.a since adding
an archive doesn't work the way we want it to.
@
text
@a587 5
  if (GetConsoleMode (get_output_handle (), &cflags))
    {
      cflags |= ENABLE_PROCESSED_OUTPUT;
      SetConsoleMode (get_io_handle (), cflags);
    }
@


1.69
log
@* fhandler_console.cc (fhandler_console::read): Revert 2001-10-23 change to
only honor keydown events.
@
text
@d588 5
@


1.68
log
@* Makefile.in: Only build testsuite directory on first 'make check'.
* configure.in: Remove testsuite from SUBDIRS.
* configure: Regenerate.
@
text
@a261 3
	  if (!input_rec.Event.KeyEvent.bKeyDown)
	    continue;

@


1.67
log
@Ensure that all fhandler_*::read definitions are __stdcall throughout.
* fhandler.cc (fhandler_base::set_inheritance): Be more defensive in debugging
code.
* fhandler.h: Adjust regparms throughout to reflect passing 'this' parameter.
* fhandler_console.cc (fhandler_console::read): Remove unneeded test.  Only
honor "key down" events.
* miscfuncs.cc (strcasestr): Reorganize for efficient code use.
(check_null_empty_str_errno): Ditto.
(__check_null_invalid_struct_errno): Ditto.
(__check_invalid_read_ptr_errno): Ditto.
* syscalls.cc (_read): Return 0 when length == 0, as per Single UNIX
Specification.
@
text
@d107 1
a107 1
  shared_console_info = (tty_min *) open_shared (NULL, cygheap->console_h,
@


1.66
log
@Remove 'cb' parameter and modify fhandler_* constructors throughout.
* dtable.cc (dtable::build_fhandler): Remove debugging output which uses 'cb'.
* exec.cc (execvp): New function.
(execvpe): Ditto.
* fhandler.cc (fhandler_base::fhandler_base): Use constructor initialization.
* fhandler.h (fhandler_tty_common::fhandler_tty_common): Ditto.
* fhandler_clipboard.cc (fhandler_dev_clipboard::fhandler_dev_clipboard):
Ditto.
* fhandler_console.cc (fhandler_console::fhandler_console): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::fhandler_dev_raw): Ditto.
* fhandler_serial.cc (fhandler_serial::fhandler_serial): Ditto.
* fhandler_tty.cc (fhandler_tty_master::fhandler_tty_master): Ditto.
(fhandler_tty_slave::fhandler_tty_slave): Ditto.
(fhandler_pty_master::fhandler_pty_master): Ditto.
* fhandler_windows.cc (fhandler_windows::fhandler_windows): Ditto.
@
text
@d198 1
a198 1
int
a200 3
  if (!buflen)
    return 0;

d262 3
d313 1
a313 1
	      if ((unsigned char)ich > 0x7f)
@


1.65
log
@* fhandler_dsp.cc (fhandler_dsp::ioctl): Return 0 for successful
SNDCTL_DSP_GETBLKSIZE operation.  Remove obsolete 'name' arg from fhandler_*
constructors throughout.
* winsup.h (winsock_active): New macro.
(winsock2_active): Ditto.
* autoload.cc (wsock_init): Use new macros to decide if winsock or winsock2 is
loaded.
(nonexist_wsock32): Dummy function to force winsock load.
(nonexist_ws2_32): Dummy function to force winsock2 load.
* fhandler.h (fhandler_socket::fstat): Declare new method.  Currently unused.
* fhandler_socket.cc (fhandler_socket::fixup_before_fork_exec): Check that
winsock2 is active before trying WSADuplicateSocketA.
(fhandler_socket::fixup_after_fork): Add extra check for winsock2_active.
Otherwise use iffy procedures for Windows 95.
(fhandler_socket::fixup_after_exec): Add debugging.
(fhandler_socket::dup): Add debugging.
(fhandler_socket::fstat): New method.
(fhandler_socket::set_close_on_exec): Attempt to perform iffy stuff on Windows
95.
* errno.cc (_sys_nerr): Work around compiler strangeness.
* pinfo.cc (winpids::add): Add extra element at end of allocated array for
setting to NULL.
(winpids::enumNT): Ditto.
(winpids::init): Don't modify pidlist if it hasn't been allocated
(possibly due to malloc problem).
@
text
@a860 4
/*
 * Constructor.
 */

d862 7
a868 1
  fhandler_termios (FH_CONSOLE, -1)
a869 5
  set_cb (sizeof *this);
  default_color = dim_color = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
  underline_color = FOREGROUND_GREEN | FOREGROUND_BLUE;
  state_ = normal;
  nargs_ = 0;
a870 1
  savex = savey = 0;
a871 1
  savebuf = NULL;
a875 3
  dwLastButtonState = 0;
  nModifiers = 0;
  insert_mode = use_mouse = raw_win32_keyboard_mode = FALSE;
a884 1
  meta_mask = LEFT_ALT_PRESSED;
@


1.64
log
@* autoload.cc (wsock_init): Reorganize slightly to accomodate a new compiler.
@
text
@d865 2
a866 2
fhandler_console::fhandler_console (const char *name) :
  fhandler_termios (FH_CONSOLE, name, -1)
@


1.63
log
@* dcrt0.cc (dll_crt0_1): Don't close hexec_proc if it is NULL.
* fork.cc (vfork): Add debugging statements.
* path.cc (get_device_number): Make static.  Rewrite to inspect both unix and
windows paths.
(get_raw_device_number): Just check for parts of raw device that we care about.
(get_devn): New function, pulled from get_device_number.
(win32_device_name): Accomodate arg changes to get_device_number.
(mount_info::get_device_number): Call get_device_number on translated Windows
path.
* spawn.cc (spawn_guts): Don't treat P_VFORK differently from P_NOWAIT.  Add
handle to child's shared region to child so that it will be preserved if the
parent goes away.
* fhandler.h: Throughout, simplify to one open method for all fhandler classes,
requiring a path_conv first element.
* fhandler.cc (fhandler_base::open): Remove obsolete method.  Generalize to
require path_conv * as first argument.
(fhandler_disk_file::open): Remove obsolete method.
(fhandler_disk_file::open): Use path_conv pointer rather than reference.
* fhandler_clipboard.cc (fhandler_dev_clipboard::dup): Use new open method.
(fhandler_dev_clipboard::open): Accomodate new argument for open methods.
* fhandler_console.cc (fhandler_console::open): Ditto.
(fhandler_console::dup): Use new open method.
(fhandler_console::fixup_after_fork): Ditto.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_dsp.cc (fhandler_dev_dsp::open): Accomodate new argument for open
methods.
* fhandler_floppy.cc (fhandler_dev_floppy::open): Ditto.
* fhandler_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_random (fhandler_dev_random::open): Ditto.
* fhandler_raw.cc (fhandler_dev_raw::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tape.cc (fhandler_dev_tape::open): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::open): Ditto.
(fhandler_pty_master::open): Ditto.
* fhandler_windows.cc (fhandler_windows::open): Ditto.
* fhandler_zero.cc (fhandler_dev_zero::open): Ditto.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Accomodate new
argument for open methods.
* syscalls.cc (_open): Ditto.
(stat_worker): Ditto.
@
text
@d1650 1
a1650 1
} const keytable[] NO_COPY = {
@


1.62
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d545 1
a545 1
fhandler_console::open (const char *, int flags, mode_t)
d620 1
a620 1
  if (!fhc->open (get_name (), get_flags () & ~O_NOCTTY, 0))
d1726 1
a1726 1
  open (0, mode);
d1755 1
a1755 1
  if (!open (get_name (), O_NOCTTY | get_flags (), 0))
d1785 1
a1785 1
  if (!open (get_name (), O_NOCTTY | get_flags (), 0))
@


1.61
log
@        * Makefile.in: Build wincap.o.
        * wincap.cc: New file.
        * wincap.h: Ditto.
        * autoload.cc: Add dynamic load statement for `CreateHardLinkA'.
        * dcrt0.cc (os_being_run): Eliminated.
        (osname): Ditto.
        (iswinnt): Ditto.
        (set_os_type): Ditto.
        (dll_crt0_1): Call wincap.init() instead of set_os_type().
        (_dll_crt0): Ditto.
        * environ.cc (set_chunksize): New function.
        (parse_thing): `forkchunk' setting now invokes function `set_chunksize'.
        * fork.cc (chunksize): Eliminated. Moved to be member of wincap.
        * host_dependent.h: Removed.
        * syscalls.cc (_link): Try using `CreateHardLinkA' first, if available.
        * cygheap.cc, dcrt0.cc, delqueue.cc, dir.cc,
        environ.cc, fhandler.cc, fhandler.h, fhandler_console.cc,
        fhandler_mem.cc, fork.cc, mmap.cc, net.cc, pinfo.cc, pinfo.h,
        security.cc, syscalls.cc, sysconf.cc, syslog.cc, thread.cc,
        times.cc, tty.cc, uinfo.cc, uname.cc, winsup.h: Use new wincap
        capability check throughout.
        * winsup.h: Include wincap.h. Eliminate extern declarations of
        `os_being_run' and `iswinnt'. Eliminate `os_type" definition.
        * include/cygwin/version.h: Bump version to 1.3.4.
@
text
@d27 1
@


1.61.2.1
log
@Merged changes from HEAD
@
text
@a26 1
#include "path.h"
@


1.61.2.2
log
@Merged changes from HEAD
@
text
@d107 1
a107 1
  shared_console_info = (tty_min *) open_shared (NULL, 0, cygheap->console_h,
d198 1
a198 1
int __stdcall
d201 3
d313 1
a313 1
	      if ((unsigned char) ich > 0x7f)
d545 1
a545 1
fhandler_console::open (path_conv *, int flags, mode_t)
d620 1
a620 1
  if (!fhc->open (NULL, get_flags () & ~O_NOCTTY, 0))
d861 6
a866 8
fhandler_console::fhandler_console () :
  fhandler_termios (FH_CONSOLE, -1),
  default_color (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE),
  underline_color (FOREGROUND_GREEN | FOREGROUND_BLUE),
  dim_color (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE),
  meta_mask (LEFT_ALT_PRESSED), state_ (normal), nargs_ (0), savex (0),
  savey (0), savebuf (NULL), dwLastButtonState (0), nModifiers (0),
  insert_mode (false), use_mouse (false), raw_win32_keyboard_mode (false)
d868 5
d874 1
d876 1
d881 3
d893 1
d1650 1
a1650 1
} keytable[] NO_COPY = {
d1726 1
a1726 1
  open ((path_conv *) NULL, mode);
d1755 1
a1755 1
  if (!open (NULL, O_NOCTTY | get_flags (), 0))
d1785 1
a1785 1
  if (!open (NULL, O_NOCTTY | get_flags (), 0))
@


1.61.2.3
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Red Hat, Inc.
d15 1
d30 1
d551 1
a551 1
  set_flags (flags & ~O_TEXT, O_BINARY);
d718 6
a745 1
#if 0
a747 1
#endif
d822 7
d1198 1
a1198 1
	  else		/* restore */
d1447 1
a1447 1
	case DWN:
d1451 1
a1451 3
	      if (y >= info.winBottom && !scroll_region.Top)
		WriteFile (get_output_handle (), "\n", 1, &done, 0);
	      else
d1456 2
d1459 3
a1461 1
	  cursor_set (FALSE, ((tc->ti.c_oflag & ONLCR) ? 0 : x), y + 1);
d1702 2
a1703 1
  // this->fhandler_termios::init (f, mode, bin);
d1705 1
a1705 1
  int flags = 0;
d1709 1
a1709 1
    flags = O_RDONLY;
d1711 1
a1711 1
    flags = O_WRONLY;
d1713 2
a1714 2
    flags = O_RDWR;
  open ((path_conv *) NULL, flags | O_BINARY);
@


1.61.2.4
log
@Merged changes from HEAD
@
text
@d20 1
a20 1
#include <winnls.h>
d35 8
d44 1
a44 1
cp_convert (UINT destcp, char *dest, UINT srccp, const char *src, DWORD size)
d71 1
a71 1
  return cp_convert (get_cp (), d, GetConsoleCP (), s, sz);
d77 1
a77 1
  return cp_convert (GetConsoleOutputCP (), d, get_cp (), s, sz);
@


1.61.2.5
log
@Merged changes from HEAD
@
text
@d541 1
a541 1
  set_flags ((flags & ~O_TEXT) | O_BINARY);
@


1.61.2.6
log
@Merged changes from HEAD
@
text
@d100 1
a100 1
  ProtectHandleINH (cygheap->console_h);
@


1.61.2.7
log
@Merged changes from HEAD
@
text
@d419 1
a419 1
	  tc->kill_pgrp (SIGWINCH);
@


1.61.2.8
log
@Merged changes from HEAD
@
text
@a31 1
#include "cygthread.h"
d208 1
a208 1
  if (cygthread::is ())
@


1.61.2.9
log
@Merged changes from HEAD
@
text
@d150 7
a188 11
void
fhandler_console::send_winch_maybe ()
{
  SHORT y = info.dwWinSize.Y;
  SHORT x = info.dwWinSize.X;
  fillin_info ();
	       
  if (y != info.dwWinSize.Y || x != info.dwWinSize.X)
    tc->kill_pgrp (SIGWINCH);
}

a334 1
	  send_winch_maybe ();
d337 1
a337 1
	      MOUSE_EVENT_RECORD& mouse_event = input_rec.Event.MouseEvent;
a418 1
	case FOCUS_EVENT:
d420 3
a422 2
	  send_winch_maybe ();
	  /* fall through */
d496 1
a496 1
  (void) fillin_info ();
d764 2
d959 1
a959 1
  (void) fillin_info ();
d1695 1
a1695 1
  this->tcsetattr (0, &tc->ti);
@


1.61.2.10
log
@Merged changes from HEAD
@
text
@d188 1
a188 1

@


1.61.2.11
log
@Merged changes from HEAD
@
text
@d138 3
a140 3
  HANDLE h = CreateFile ("CONIN$", GENERIC_READ, FILE_SHARE_WRITE,
			 &sec_none_nih, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
			 NULL);
d142 1
a142 1
  if (h == INVALID_HANDLE_VALUE)
d550 3
a552 3
  h = CreateFile ("CONIN$", GENERIC_READ | GENERIC_WRITE,
		  FILE_SHARE_READ | FILE_SHARE_WRITE, &sec_none,
		  OPEN_EXISTING, 0, 0);
d562 3
a564 3
  h = CreateFile ("CONOUT$", GENERIC_READ | GENERIC_WRITE,
		  FILE_SHARE_READ | FILE_SHARE_WRITE, &sec_none,
		  OPEN_EXISTING, 0, 0);
@


1.61.2.12
log
@Merged changes from HEAD
@
text
@d544 2
a545 2
  set_io_handle (NULL);
  set_output_handle (NULL);
d598 2
a599 2
  set_io_handle (NULL);
  set_output_handle (NULL);
@


1.60
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d318 1
a318 1
	      if (iswinnt)
@


1.59
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d324 1
a324 1
		           || (ich >= 0 && ich <= 0x1f || ich == 0x7f));
@


1.58
log
@2001-09-04  Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>

        * fhandler_console.cc (fhandler_console::char_command): Save the cursor
        position relative to the top of the window.
        * fhandler_cc (fhandler_console::write): Ditto.
@
text
@d1649 1
a1649 1
} keytable[] = {
@


1.57
log
@* fhandler_console.cc (get_tty_stuff): Don't initialize shared memory console
area if it is already initialized.
* fhandler_termios.cc (fhandler_termios::tcsetpgrp): Augment debugging info.
@
text
@d1309 1
d1312 1
a1312 1
      cursor_set (FALSE, savex, savey);
d1547 1
a1547 1
	      cursor_set (FALSE, savex, savey);
d1553 1
@


1.56
log
@Throughout, change check for running under Windows NT to 'iswinnt'.
* dcrt0.cc (set_os_type): Set 'iswinnt' appropriately.
* cygheap.cc (init_cheap): Revert to using VirtualAlloc for allocating cygheap.
(cygheap_setup_for_child_cleanup): New function.  Standard function to call
after calling CreateProcess to cleanup cygheap info passed to child.
(cygheap_fixup_in_child): Copy cygheap from shared memory into allocated space
under Windows 9x or if can't relocate shared space under NT.
* cygheap.h: Declare new function.
* spawn.cc (spawn_guts): Use cygheap_fixup_in_child.
* fork.cc (fork_parent): Ditto.
* winsup.h: Declare iswinnt.
@
text
@d110 6
a115 3
  shared_console_info->setntty (TTY_CONSOLE);
  shared_console_info->setsid (myself->sid);
  shared_console_info->set_ctty (TTY_CONSOLE, flags);
@


1.55
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d315 1
a315 1
	      if (os_being_run == winNT)
@


1.54
log
@forced commit
@
text
@d25 1
a32 1
#include "security.h"
@


1.53
log
@        * fhandler_console.cc (fhandler_console::read): Detect AltGr more
        robustly on WinNT.
@
text
@@


1.52
log
@* exceptions.cc (sig_handle_tty_stop): Reset PID_STOPPED if not actually
stopping.
* fhandler_console.cc (fhandler_console::fixup_after_fork): Don't set
controlling terminal if just inheriting a handle.
(fhandler_console::fixup_after_exec): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::init): Ditto.
* signal.cc (kill_worker): Set appropriate errno if proc_exists determines that
process does not really exist.
@
text
@d292 2
d311 16
a326 2
	      /* Determine if the keystroke is modified by META. */
	      if (!(input_rec.Event.KeyEvent.dwControlKeyState & meta_mask))
d338 2
@


1.51
log
@        * fhandler_console.cc (fhandler_console::dup): Allocate space for
        savebuf on Cygwin heap.
        (fhandler_console::char_command): Ditto. Use correct values for size.
@
text
@d1731 1
a1731 1
  if (!open (get_name (), get_flags (), 0))
d1761 1
a1761 1
  if (!open (get_name (), get_flags (), 0))
@


1.50
log
@* cygheap.cc (_cfree): Add regparm attribute.
(_crealloc): Ditto.
* dcrt0.cc (dll_crt0_1): Default to always checking for executable for now.
* dtable.cc (dtable::not_open): Move method.
* dtable.h (dtable): Here.
* exceptions.cc (ctrl_c_handler): Don't expect process group leader to handle a
signal if it doesn't exist.
* fhandler.h (fhandler_base): Make openflags protected.
* localtime.c (tzsetwall): Check for __CYGWIN__ as well as __WIN32__.
* path.cc (path_conv::check): Add some comments.  Change strcat to assignment.
* lib/_cygwin_S_IEXEC.cc (_cygwin_bob__): Eliminate.
* fhandler_tty.cc (fhandler_console::dup): Set controlling terminal if
necessary.
* fhandler_tty.cc (fhandler_tty_slave::dup): Ditto.
@
text
@d627 1
a627 1
      fhc->savebuf = (PCHAR_INFO) malloc (sizeof (CHAR_INFO) *
d1177 2
a1178 2
	      savebufsiz.X = now.srWindow.Right - now.srWindow.Left;
	      savebufsiz.Y = now.srWindow.Bottom - now.srWindow.Top;
d1181 2
a1182 2
		free (savebuf);
	      savebuf = (PCHAR_INFO) malloc (sizeof (CHAR_INFO) *
d1202 1
a1202 1
	      free (savebuf);
@


1.49
log
@Throughout, change 'tty_attached' to 'real_tty_attached', for clarity.
Throughout, change 'OutputStopped' to 'output_stopped', for consistency.
* dtable.cc (stdio_init): Set controlling tty if not set by stdio opens.
* exceptions.cc (ctrl_c_handler): Avoid special pgid checking if no tty is
associated with the process.
(Suggested by Tim Baker <dbaker@@direct.ca>)
* external.cc (fillout_pinfo): Return actual tty number for ctty.
* fhandler_console.cc (get_tty_stuff): Set ctty when shared memory is
allocated.  Accept flags input from open().
(set_console_ctty): New function.
(fhandler_console::open): Pass flags to get_tty_stuff and rely on this function
to set the ctty, if appropriate.
* fhandler_termios.cc (fhandler_termios::set_ctty): Move to tty_min class.
* fhandler_tty.cc (fhandler_tty_slave::open): Use tc field to access
set_ctty().
* tty.h (TTY_CONSOLE): Move to include/sys/cygwin.h.
(tty_min): Add set_ctty class here.
* include/sys/cygwin.h (TTY_CONSOLE): New home here.
* path.cc (symlink_info): Make contents an actual buffer.  Pass more flags to
case_check.
(path_conv::check): Reorganize to do parsing based on posix path rather than
native path.
(symlink_info::check): Expect posix path as input.  Translate to native path
here.  Accept path_conv flags.  Stop parsing if not a symlink regardless of
whether previous path was a symlink.
@
text
@d598 1
a598 1
  if (!fhc->open (get_name (), get_flags (), 0))
@


1.48
log
@Remove trailing underscore from fhandler_base and friends, throughout.
* fhandler.h (fhandler_base::set_open_status): New method.  Stores original
open status.
(fhandler_base::get_open_status): New method.  Retrieves original open status.
(fhandler_base::reset_to_open_binmode): New method.
* fhandler.cc (fhandler_base::open): Save open status.
(fhandler_base::init): Ditto.
* fhandler_clipboard.cc (fhandler_clipboard::open): Ditto.
* fhandler_console.cc (fhandler_console::open): Ditto.
* fhandler_dsp.cc (fhandler_dsp::open): Ditto.
* fhandler_dev_mem.cc (fhandler_dev_mem::open): Ditto.
* fhandler_dev_random.cc (fhandler_dev_random::open): Ditto.
* fhandler_serial.cc (fhandler_serial::open): Ditto.
* fhandler_tty_slave.cc (fhandler_tty_slave::open): Ditto.
* fhandler_tty_master.cc (fhandler_tty_master::open): Ditto.
* fhandler_dev_zero.cc (fhandler_dev_zero::open): Ditto.
* syscalls.cc (setmode): Rework so that 0 mode value causes reversion to open
state.
* fhandler_tty_slave.cc (fhandler_tty_slave::read): Use correct multiplier when
converting from deciseconds to milliseconds.
@
text
@d100 2
a101 2
static __inline tty_min *
get_tty_stuff (int force = 0)
d103 1
a103 1
  if (shared_console_info && !force)
d112 1
d116 6
d527 1
a527 1
  tcinit (get_tty_stuff ());
a570 1
  set_ctty (TTY_CONSOLE, flags);
@


1.47
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d565 1
@


1.46
log
@* Makefile.in: Put -lgcc last in list of libraries, since stdc++ library needs
it.
* cygwin.din: Remove obsolete "__empty" export.
* exceptions.cc (call_signal_handler_now): Force inclusion of function even
when -finline-functions is specified.
* sigproc.h: Remove obsolete call_signal_handler declaration.
* fhandler_console.cc (cp_get_internal): New function.
(cp_convert): New function.
(con_to_str): New function.
(str_to_con): New function.
(fhandler_console::read): Replace OemToCharBuff with con_to_str.
(fhandler_console::write_normal): Replace CharToOemBuff with str_to_con.
@
text
@a23 1
#include "cygheap.h"
d26 2
@


1.45
log
@        * fhandler.h (class fhandler_console): Add members `insert_mode'.
        * fhandler_console.cc (fhandler_console::dup): Duplicate `insert_mode'.
        (fhandler_console::fhandler_console): Initialize `insert_mode'.
        fhandler_console::char_command): Add terminal capabilities
        "enter insert mode" = \E[4h and "exit insert mode" = \E[4l.
        Care for insert mode on terminal capability "repeat char" = \E[x;yb.
        (fhandler_console::write_normal): Care for insert mode before writing
        to the console.
        (array keytable): Add keymapping for modified cursor and control
        block keys (xterm like).
@
text
@d21 1
d33 47
d175 1
a175 1
  if (!GetConsoleScreenBufferInfo (get_output_handle(), &now))
d267 7
a273 7
	      __small_sprintf(tmp, "\033{%u;%u;%u;%u;%u;%luK",
				   input_rec.Event.KeyEvent.bKeyDown,
				   input_rec.Event.KeyEvent.wRepeatCount,
				   input_rec.Event.KeyEvent.wVirtualKeyCode,
				   input_rec.Event.KeyEvent.wVirtualScanCode,
				   input_rec.Event.KeyEvent.uChar.UnicodeChar,
				   input_rec.Event.KeyEvent.dwControlKeyState);
d299 2
a300 2
	      if ((unsigned char)ich > 0x7f && current_codepage == ansi_cp)
		OemToCharBuff (tmp + 1, tmp + 1, 1);
d324 1
a324 1
		  syscall_printf("mouse: double-click -> click");
d338 1
a338 1
		  syscall_printf("mouse: position out of range");
d351 1
a351 1
		  syscall_printf("mouse: button state unchanged");
d357 1
a357 1
		  strcpy(sz, "btn up");
d362 1
a362 1
		  strcpy(sz, "btn1 down");
d367 1
a367 1
		  strcpy(sz, "btn2 down");
d372 1
a372 1
		  strcpy(sz, "btn3 down");
d393 2
a394 2
	      sprintf(tmp, "\033[M%c%c%c", b + ' ', x + ' ' + 1, y + ' ' + 1);
	      syscall_printf("mouse: %s at (%d,%d)", sz, x, y);
d450 1
a450 1
  if ((ret = GetConsoleScreenBufferInfo (get_output_handle(), &linfo)))
d564 1
a564 1
  debug_printf("opened conin$ %p, conout$ %p",
d590 1
a590 1
  if (!fhc->open(get_name (), get_flags (), 0))
d620 1
a620 1
      					  savebufsiz.X * savebufsiz.Y);
d622 1
a622 1
      				     savebufsiz.X * savebufsiz.Y);
d925 1
a925 1
    x1 = info.dwWinSize.X-1;
d929 1
a929 1
    x2 = info.dwWinSize.X-1;
d1148 1
a1148 1
        {
d1153 1
a1153 1
	      syscall_printf("insert mode %sabled", insert_mode ? "en" : "dis");
d1167 1
a1167 1
	        break;
d1173 1
a1173 1
	        free (savebuf);
d1175 1
a1175 1
	      				     savebufsiz.X * savebufsiz.Y);
d1186 1
a1186 1
	        break;
d1189 1
a1189 1
	        break;
d1192 1
a1192 1
	      			   savebufsiz, cob, &now.srWindow);
d1202 1
a1202 1
	  syscall_printf("mouse support %sabled", use_mouse ? "en" : "dis");
d1210 1
a1210 1
	  syscall_printf("unknown h/l command: %d", args_[0]);
d1286 1
a1286 1
      cursor_set (FALSE, 8*(x/8+1), y);
d1310 1
a1310 1
      scroll_screen(0, args_[0], -1, -1, 0, 0);
d1330 1
a1330 1
          cursor_get (&x, &y);
d1381 1
d1385 2
a1386 15
      char buf[4096];
      size_t len = found - src;
      do {
	size_t l2 = min (sizeof (buf), len);
	if (current_codepage == ansi_cp)
	  CharToOemBuff ((LPCSTR)src, buf, l2);
	else
	  strncpy (buf, (LPCSTR)src, l2);
        if (insert_mode)
	  {
	    int x, y;
            cursor_get (&x, &y);
	    scroll_screen (x, y, -1, y, x + l2, y);
	  }
	if (!WriteFile (get_output_handle (), buf, l2, &done, 0))
d1388 25
a1412 3
	  debug_printf ("write failed, handle %p", get_output_handle ());
	  __seterrno ();
	  return 0;
d1414 1
a1414 3
	len -= done;
	src += done;
      } while (len > 0);
d1416 1
d1428 1
a1428 1
	case DWN:		/* WriteFile("\n") always adds CR... */
d1556 1
a1556 1
	  if (isdigit(*src))
d1723 1
a1723 1
  if (!open(get_name (), get_flags (), 0))
d1738 2
a1739 2
  strncpy(buf, title, sizeof(buf) - 1);
  buf[sizeof(buf) - 1] = '\0';
d1753 1
a1753 1
  if (!open(get_name (), get_flags (), 0))
@


1.44
log
@        * fhandler.h (class fhandler_console): Add members `savebufsiz' and
        `savebuf' to allow save/restore of screen.
        * fhandler_console.cc (fhandler_console::dup): Duplicate savebuf.
        (fhandler_console::fhandler_console): Initialize `savebufsiz' and
        `savebuf'.
        (fhandler_console::char_command): Add terminal capabilities
        "save screen content" = \E[?47h and "restore screen content" = \E[?47l.
@
text
@d582 1
d805 1
a805 1
  use_mouse = raw_win32_keyboard_mode = FALSE;
d1100 10
a1109 1
	break;
d1280 5
d1344 6
d1563 10
a1572 10
  {VK_LEFT,	{"\033[D",	NULL,		NULL,		NULL}},
  {VK_RIGHT,	{"\033[C",	NULL,		NULL,		NULL}},
  {VK_UP,	{"\033[A",	NULL,		NULL,		NULL}},
  {VK_DOWN,	{"\033[B",	NULL,		NULL,		NULL}},
  {VK_PRIOR,	{"\033[5~",	NULL,		NULL,		NULL}},
  {VK_NEXT,	{"\033[6~",	NULL,		NULL,		NULL}},
  {VK_HOME,	{"\033[1~",	NULL,		NULL,		NULL}},
  {VK_END,	{"\033[4~",	NULL,		NULL,		NULL}},
  {VK_INSERT,	{"\033[2~",	NULL,		NULL,		NULL}},
  {VK_DELETE,	{"\033[3~",	NULL,		NULL,		NULL}},
@


1.43
log
@* fhandler_console.cc (fhandler_console::set_default_attr): Update console
color attributes on tty reset.
@
text
@d568 9
d796 2
d1102 40
@


1.42
log
@* fhandler.h (fhandler_termios::fhandler_termios): Enable fixup
after fork.
* fhandler_console.cc (fhandler_console::fhandler_console): Fixup
after fork is now enabled in the base class constructor.
@
text
@d820 2
@


1.41
log
@        * autoload.c (cygwin_premain0): Add missing parameter.
        * binmode.c (cygwin_premain0): Ditto.
        * textmode.c (cygwin_premain0): Ditto.

Patch contributed by Jason Tiller <jtiller@@sjm.com> :
        * auto_load.cc: Add "GetKeyboardLayout" entry in the list of
        Win32 User32.DLL exports to provide.
        * fhandler.h (class fhandler_console): Add meta_mask private
        member to remember which keystroke modifiers should generate
        META.
        * fhandler_console.cc (fhandler_console::read): Modify code that
        tests a keystroke for a META-escaped key to use the 'meta_mask'
        variable.
        (fhandler_console::fhandler_console): Add definition for
        variable "meta_mask" used to determine if a keystroke should be
        preceded by META in the client console stream.  Set meta_mask
        based on whether or not user's keyboard language is English -
        non-English keyboards pass AltGr (right <ALT>) unmolested,
        whereas English keyboards now interpret left- and right-<ALT>
        as META.
@
text
@a806 1
  set_need_fork_fixup ();
@


1.40
log
@* dlopen.c (dlopen): Return NULL when name is NULL (suggested by
chrisiasci@@aol.com).
* cygwin.din: Add a new, internally used export - _check_for_executable.
* dcrt0.cc (dll_crt0_1): Set _check_for_executable for older binaries.  Pass
user_data to premain functions.
* fhandler.cc (fhandler_disk_file::open): Only check for executable if the
linked program is intereested in the executable bit.
(fhandler_disk_file::check_execable_p): Delete.
* fhandler.h (executable_states): New enumeration of various states of
executable bit caring.
(fhandler_base::set_execable_p): New method.
* fhandler_termios.cc (fhandler_termios::line_edit): Flag when a signal has
been sent to the tty.  Return -1 when this is so.
* fhandler_console.cc (fhandler_console::read): Return -1 when signal sending
character encountered.
* path.cc (path_conv::check): Record when path refers to a disk device.  Move
executable extension check here.
(check_sysfile): Accomodate new EXEC path states.
(has_suffix): Remove.
(next_suffix): Remove.
(class suffix_scan): New clas.
(suffix_scan::has): New method.
(suffix_scan:next): New method.
(symlink_info::check): Use suffix_scan method to control for scanning for
suffixes.
* path.h (path_conv::exec_state): New method.
* perprocess.h: Make "C" friendly.
* include/cygwin/version.h: Define CYGWIN_VERSION_CHECK_FOR_S_IEXEC.  Bump
CYGWIN_VERSION_API_MINOR.
* include/sys/cygwin.h: Change premain declarations.
* winsup.h: Move __cplusplus test to after builtin defines.
@
text
@d253 2
a254 1
	      if (!(input_rec.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED))
d794 13
@


1.39
log
@*** empty log message ***
@
text
@d181 1
a181 2
	  set_sig_errno (EINTR);
	  return -1;
d360 8
a367 2
      if (toadd && line_edit (toadd, nread))
	break;
d382 4
@


1.38
log
@* fhandler.h (class fhandler_console): Make all variables that
describe "state" of console to be members of fhandler_console.
default_color is now the color which is set when console recieves
reset command.
* fhandler_console.cc (fhandler_console::fhandler_console): Turn
mouse handling and raw keyboard mode off by default. Initialize
state information.
* fhandler.cc (fhandler_console::set_raw_win32_keyboard_mode): New
function.
* fhandler_console.cc (fhandler_console::set_default_attr): New
function. Reset console attributes to default values.
* fhandler_console.cc (fhandler_console::open): Reset attributes.
* fhandler_console.cc (fhandler_console::get_win32_attr): New function.
Calculate win32-style console attribute based on terminal attributes.
* fhandler_console.cc (fhandler_console::set_cursor_maybe): Use
member variable.
* fhandler_console.cc (fhandler_console::read): If in raw-win32
keyboard mode, encode win32 keyboard events in \033{x;y;z;t;u;wK
sequences.
* fhandler_console.cc (fhandler_console::dup): Copy all state
information to the dup()ed handle.
* fhandler_console.cc (fhandler_console::scroll_screen): Use current
fill-in	attribute.
* fhandler_console.cc (fhandler_console::clear_screen): Ditto.
* fhandler_console.cc (fhandler_console::char_command): Check if we
saw '?' symbol by member variable. Set terminal	attributes on \033[Xm
commands. \033[24m - turn off underline mode, \033[27m - turn off
reverse mode, \033[39m - restore default foreground color.
\033[49m - restore default background color. \033[2000h - turn on raw
keyboard mode, \033[2000l - turn off raw keyboard mode.
* fhandler_console.cc (fhandler_console::write): Set attribues to
default values on reset command.
@
text
@d207 9
a215 9
          /* allow manual switching to/from raw mode via ctrl-alt-scrolllock */
          if (input_rec.Event.KeyEvent.bKeyDown &&
              virtual_key_code == VK_SCROLL &&
              control_key_state & (LEFT_ALT_PRESSED | LEFT_CTRL_PRESSED) == LEFT_ALT_PRESSED | LEFT_CTRL_PRESSED
             )
            {   
              set_raw_win32_keyboard_mode ( !raw_win32_keyboard_mode );
              continue;
            }
d218 13
a230 13
          if (raw_win32_keyboard_mode)
            {
              __small_sprintf(tmp, "\033{%u;%u;%u;%u;%u;%luK",
                                   input_rec.Event.KeyEvent.bKeyDown,
                                   input_rec.Event.KeyEvent.wRepeatCount,
                                   input_rec.Event.KeyEvent.wVirtualKeyCode,
                                   input_rec.Event.KeyEvent.wVirtualScanCode,
                                   input_rec.Event.KeyEvent.uChar.UnicodeChar,
                                   input_rec.Event.KeyEvent.dwControlKeyState );
              toadd = tmp;
              nread = strlen (toadd);
              break;
            }
d247 2
a248 2
          else
            {
d263 1
a263 1
            }
d283 1
a283 1
	      
d293 1
a293 1
	      
d296 1
a296 1
	      
d326 1
a326 1
	      
d329 1
a329 1
	      
d341 1
a341 1
	      
d343 1
a343 1
	      
d540 1
a540 1
  for ( int i = 0; i < MAXARGS; i++ ) 
d545 1
a545 1
  strncpy ( fhc->my_title_buf, my_title_buf, TITLESIZE + 1) ;
d548 1
a548 1
  fhc->intensity = intensity; 
d775 1
a775 1
  for ( int i = 0; i < MAXARGS; i++ ) args_ [i] = 0;
d788 1
a788 1
                              FOREGROUND_BLUE | FOREGROUND_INTENSITY)
d790 1
a790 1
                              BACKGROUND_BLUE | BACKGROUND_INTENSITY)
d805 2
a806 2
  if ( reverse )
    { 
d808 8
a815 8
      win_fg = ( win_bg & BACKGROUND_RED   ? FOREGROUND_RED   : 0 ) |
               ( win_bg & BACKGROUND_GREEN ? FOREGROUND_GREEN : 0 ) |
               ( win_bg & BACKGROUND_BLUE  ? FOREGROUND_BLUE  : 0 ) |
               ( win_fg & FOREGROUND_INTENSITY );
      win_bg = ( save_fg & FOREGROUND_RED   ? BACKGROUND_RED   : 0 ) |
               ( save_fg & FOREGROUND_GREEN ? BACKGROUND_GREEN : 0 ) |
               ( save_fg & FOREGROUND_BLUE  ? BACKGROUND_BLUE  : 0 ) |
               ( win_bg & BACKGROUND_INTENSITY );
d817 1
a817 1
  if ( underline ) win_fg = underline_color;
d819 2
a820 2
  if ( blink ) win_bg |= BACKGROUND_INTENSITY;
  if ( intensity == INTENSITY_INVISIBLE )
d822 1
a822 1
  else if ( intensity == INTENSITY_BOLD )
d824 1
a824 1
  return ( win_fg | win_bg );
d934 1
a934 1
/*(  )  *  +  ,  -  .  /  */ NOR, NOR, NOR, NOR, NOR, NOR, NOR, NOR,
d977 1
a977 1
               set_default_attr ();
d980 1
a980 1
               intensity = INTENSITY_BOLD;
d982 1
a982 1
	     case 4:    
d986 1
a986 1
               blink = TRUE;
d989 1
a989 1
               reverse = TRUE;
d992 1
a992 1
               intensity = INTENSITY_INVISIBLE;
d995 7
a1001 1
               intensity = INTENSITY_DIM;
a1002 6
             case 24:
               underline = FALSE;
               break;
             case 27: 
               reverse = FALSE;
               break;
d1027 3
a1029 3
             case 39:
               fg = default_color & FOREGROUND_ATTR_MASK;
               break;
d1054 3
a1056 3
             case 49:
               bg = default_color & BACKGROUND_ATTR_MASK;
               break;
d1058 2
a1059 2
         current_win32_attr = get_win32_attr ();
  	 SetConsoleTextAttribute (get_output_handle (), current_win32_attr);
d1072 4
a1075 4
        case 2000: /* Raw keyboard mode */
         set_raw_win32_keyboard_mode ( (c == 'h') ? TRUE : FALSE );
         break;
          
d1254 1
a1254 1
	if (! WriteFile (get_output_handle (), buf, l2, &done, 0))
d1338 1
a1338 1
              saw_question_mark = FALSE;
d1357 1
a1357 1
              set_default_attr ();
@


1.37
log
@* fhandler_console.cc (fhandler_console::char_command): Ignore unknown
rendition codes in \033[xx;yym control sequences
@
text
@a38 4
static struct
    {
      short Top, Bottom;
    } scroll_region = {0, -1};
a46 2
static BOOL use_mouse = FALSE;

d113 9
a125 1
  static CONSOLE_SCREEN_BUFFER_INFO last = {{0, 0}, {-1, -1}, 0, {0, 0}, {0, 0}};
d130 2
a131 2
  if (last.dwCursorPosition.X != now.dwCursorPosition.X ||
      last.dwCursorPosition.Y != now.dwCursorPosition.Y)
d134 1
a134 1
      last.dwCursorPosition = now.dwCursorPosition;
d158 1
a158 1
  char tmp[17];
d203 29
a298 1
	      static DWORD dwLastButtonState = 0;
a329 1
	      static int nModifiers = 0;
a385 10
static struct
  {
    SHORT winTop;
    SHORT winBottom;
    COORD dwWinSize;
    COORD dwBufferSize;
    COORD dwCursorPosition;
    WORD wAttributes;
  } info;

d443 1
a443 1
  fill.Attributes = default_color;
d495 2
d535 3
d539 26
a564 1
  fhc->default_color = default_color;
d771 2
d774 10
d787 40
d866 1
a866 1
			       default_color,
a961 4
/*#define syscall_printf small_printf*/

static int savex, savey; /* for CSI s, CSI u */

d963 1
a963 1
fhandler_console::char_command (char c, bool saw_question_mark)
a964 7
  // Keep the background intensity with the colr since there doesn't seem
  // to be a way to set this with termcap/terminfo.
  static int fg = default_color & (FOREGROUND_BLUE | FOREGROUND_GREEN |
				   FOREGROUND_RED),
	     bg = default_color & (BACKGROUND_BLUE | BACKGROUND_GREEN |
				   BACKGROUND_RED | BACKGROUND_INTENSITY),
			 bold = default_color & FOREGROUND_INTENSITY;
d977 1
a977 5
	       fg = default_color & (FOREGROUND_BLUE | FOREGROUND_GREEN |
				     FOREGROUND_RED);
	       bg = default_color & (BACKGROUND_BLUE | BACKGROUND_GREEN |
				     BACKGROUND_RED | BACKGROUND_INTENSITY);
	       bold = default_color & FOREGROUND_INTENSITY;
d980 1
a980 5
	       fg = default_color & (FOREGROUND_BLUE | FOREGROUND_GREEN |
				     FOREGROUND_RED);
	       bg = default_color & (BACKGROUND_BLUE | BACKGROUND_GREEN |
				     BACKGROUND_RED | BACKGROUND_INTENSITY);
	       bold = FOREGROUND_INTENSITY;
d982 2
a983 5
	     case 4:    /* underline - simulate with cyan */
	       fg = FOREGROUND_BLUE | FOREGROUND_GREEN;
	       bg = default_color & (BACKGROUND_BLUE | BACKGROUND_GREEN |
				     BACKGROUND_RED | BACKGROUND_INTENSITY);
	       bold = default_color & FOREGROUND_INTENSITY;
d986 1
a986 5
	       fg = default_color & (FOREGROUND_BLUE | FOREGROUND_GREEN |
				     FOREGROUND_RED);
	       bg = default_color & (BACKGROUND_BLUE | BACKGROUND_GREEN |
				     BACKGROUND_RED | BACKGROUND_INTENSITY);
	       bold = default_color & FOREGROUND_INTENSITY;
d989 1
a989 10
	       fg = (default_color & BACKGROUND_BLUE) ? FOREGROUND_BLUE : 0;
	       fg |= (default_color & BACKGROUND_GREEN) ? FOREGROUND_GREEN : 0;
	       fg |= (default_color & BACKGROUND_RED) ? FOREGROUND_RED : 0;
	       fg |= (default_color & BACKGROUND_INTENSITY) ?
					     FOREGROUND_INTENSITY : 0;
	       bg = (default_color & FOREGROUND_BLUE) ? BACKGROUND_BLUE : 0;
	       bg |= (default_color & FOREGROUND_GREEN) ? BACKGROUND_GREEN : 0;
	       bg |= (default_color & FOREGROUND_RED) ? BACKGROUND_RED : 0;
	       bg |= (default_color & FOREGROUND_INTENSITY) ?
					     BACKGROUND_INTENSITY : 0;
d992 1
a992 7
	       fg = (default_color & BACKGROUND_BLUE) ? FOREGROUND_BLUE : 0;
	       fg |= (default_color & BACKGROUND_GREEN) ? FOREGROUND_GREEN : 0;
	       fg |= (default_color & BACKGROUND_RED) ? FOREGROUND_RED : 0;
	       bg = default_color & (BACKGROUND_BLUE | BACKGROUND_GREEN |
				     BACKGROUND_RED | BACKGROUND_INTENSITY);
	       bold = (default_color & BACKGROUND_INTENSITY) ?
						   FOREGROUND_INTENSITY : 0;
d995 1
a995 5
	       fg = default_color & (FOREGROUND_BLUE | FOREGROUND_GREEN |
				     FOREGROUND_RED);
	       bg = default_color & (BACKGROUND_BLUE | BACKGROUND_GREEN |
				     BACKGROUND_RED | BACKGROUND_INTENSITY);
	       bold = (fg == 0) ? FOREGROUND_INTENSITY : 0;
d997 6
d1027 3
d1054 3
d1058 2
a1059 1
	 SetConsoleTextAttribute (get_output_handle (), fg | bg | bold);
d1072 4
a1319 3
  static NO_COPY unsigned rarg;
  static NO_COPY char my_title_buf[TITLESIZE + 1];
  bool saw_question_mark = 0;
d1338 1
d1357 1
d1399 1
a1399 1
	  char_command (*src++, saw_question_mark);
d1447 1
a1447 1
		saw_question_mark = 1;
@


1.36
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@a988 7
	     default:
	       fg = default_color & (FOREGROUND_BLUE | FOREGROUND_GREEN |
				     FOREGROUND_RED);
	       bg = default_color & (BACKGROUND_BLUE | BACKGROUND_GREEN |
				     BACKGROUND_RED | BACKGROUND_INTENSITY);
	       bold = default_color & FOREGROUND_INTENSITY;
	       break;
@


1.35
log
@* autoload.cc (LoadDLLinitfunc): Remove debugging statement.
* exceptions.cc (sig_handle_tty_stop): Move setting of PID_STOPPED to earlier
in interrupt.
((interrupt_setup): i.e., here.
(sig_handle): Don't queue multiple SIGSTOPS.
* fhandler.h (bg_check_types): Enumerate return value of bg_check for clarity.
* signal.cc (kill_pgrp): Minor cleanup.
* fhandler_termios.cc (fhandler_termios::bg_check): Use enumerated type for
function return.  Don't raise signal if a signal is already queued.
* fhandler_console.cc (fhandler_console::read): Use enumerated return type for
bg_check.
* select.cc: Ditto, throughout.
* read.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
(_read): YA interrupt detect simplification.
* wait.cc (wait4): Ditto.
@
text
@d23 1
a52 2
HANDLE console_shared_h;

d63 1
a63 1
  shared_console_info = (tty_min *) open_shared (NULL, console_shared_h,
d66 1
a66 1
  ProtectHandle (console_shared_h);
@


1.34
log
@* pinfo.cc (codepage_init): Move function.
* environ.cc (codepage_init): To here.
* exceptoins.cc (SIG_NONMASKABLE): Remove SIGCONT from consideration since it
is supposed to be maskable.
* signal.cc (sigaction): Ditto.
* sigproc.cc (wait_sig): Ditto.
* winsup.h: Eliminate global declaration of codepage_init.
@
text
@d171 1
a171 1
      if ((bgres = bg_check (SIGTTIN)) <= 0)
@


1.33
log
@* fhandler_console.cc (fhandler_console::read): Restore missing test for code
page before doing OemToCharBuff.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Cygnus Solutions.
@


1.32
log
@* fhandler_console.cc (read): Add support for xterm-style mouse event
reporting.
(fhandler_console::char_command): Honor mouse events.
(fhandler_console::open): Enable mouse input events.
(fhandler_console::input_tcsetattr): Ditto.
* select.cc (peek_console): Add check for mouse events.
@
text
@d222 1
a222 1
	      if ((unsigned char)ich > 0x7f)
@


1.31
log
@* fhandler.h (fhandler_console): Add additional argument to char_command
method.
* fhandler_console.cc (fhandler_console::read): Revert previously misapplied
patch.
(fhandler_console::char_command): Add a second argument.
(fhandler_console::write): Recognize when a '?' is found after a <esc>[.
@
text
@d50 2
d189 1
a189 1
      const char *toadd;
d198 7
d208 29
a236 1
      /* check if we're just disposing of this one */
d238 2
a239 28
      if (input_rec.EventType == WINDOW_BUFFER_SIZE_EVENT)
	{
	  kill_pgrp (tc->getpgid (), SIGWINCH);
	  continue;
	}
      if (input_rec.EventType != KEY_EVENT ||
	  !input_rec.Event.KeyEvent.bKeyDown)
	continue;

      if (wch == 0 ||
	  /* arrow/function keys */
	  (input_rec.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY))
	{
	  toadd = get_nonascii_key (input_rec, tmp);
	  if (!toadd)
	    continue;
	  nread = strlen (toadd);
	}
      else
	{
	  tmp[1] = ich;
	  /* Need this check since US code page seems to have a bug when
	     converting a CTRL-U. */
	  if ((unsigned char)ich > 0x7f && current_codepage == ansi_cp)
	    OemToCharBuff (tmp + 1, tmp + 1, 1);
	  if (!(input_rec.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED))
	    toadd = tmp + 1;
	  else
d241 79
a319 2
	      tmp[0] = '\033';
	      tmp[1] = cyg_tolower (tmp[1]);
d321 1
a321 1
	      nread++;
d323 8
d333 1
a333 1
      if (line_edit (toadd, nread))
d464 1
a464 1
		   FILE_SHARE_WRITE | FILE_SHARE_WRITE, &sec_none,
d481 1
a481 1
      SetConsoleMode (get_io_handle (), ENABLE_WINDOW_INPUT | cflags);
d644 1
a644 1
  flags |= ENABLE_WINDOW_INPUT;
d1002 13
a1014 1
      /* Ignore */
@


1.30
log
@* autoload.cc: Autoload CharToOemA.
* dcrt0.cc (dll_crt0_1): Translate command line to OEM if current codepage is
OEM.
* environ.cc: Add new option 'codepage' to CYGWIN environment variable.
* fhandler_clipboard.cc (fhandler_clipboard::read): Read clipboard in OEM mode
if current codepage is OEM.
* fhandler_console.cc (fhandler_console::read): Only translate console input if
current codepage is ANSI.
* fhandler_console.cc (fhandler_console::write_normal): Translate output data
if current codepage is ANSI.
* pinfo.cc (codepage_init): New function.  Setup current codepage from CYGWIN
environment variable and set codepage for file APIs.
* security.cc (read_sd): Translate file name to it if current codepage is OEM.
* winsup.h: (sys_wcstombs,sys_mbstowcs): Use current codepage for translations
between multibyte and widechar string and vice versa.
@
text
@a195 7
      /* check the event that occurred */
      switch (input_rec.EventType)
	{
	case KEY_EVENT:
	  if (!input_rec.Event.KeyEvent.bKeyDown)
	    continue;

d199 29
a227 9
	  if (wch == 0 ||
	      /* arrow/function keys */
	      (input_rec.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY))
	    {
	      toadd = get_nonascii_key (input_rec, tmp);
	      if (!toadd)
		continue;
	      nread = strlen (toadd);
	    }
d230 4
a233 14
	      tmp[1] = ich;
	      /* Need this check since US code page seems to have a bug when
		 converting a CTRL-U. */
	  if ((unsigned char)ich > 0x7f && current_codepage == ansi_cp)
		OemToCharBuff (tmp + 1, tmp + 1, 1);
	      if (!(input_rec.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED))
		toadd = tmp + 1;
	      else
		{
		  tmp[0] = '\033';
		  tmp[1] = cyg_tolower (tmp[1]);
		  toadd = tmp;
		  nread++;
		}
a234 93
#undef ich
#undef wch
	  break;

	case MOUSE_EVENT:
	  {
	    MOUSE_EVENT_RECORD & mouse_event = input_rec.Event.MouseEvent;

	    /* Treat the double-click event like a regular button press */
	    if (mouse_event.dwEventFlags == DOUBLE_CLICK)
	      {
		syscall_printf("mouse: double-click -> click");
		mouse_event.dwEventFlags = 0;
	      }

	    /* Did something other than a click occur? */
	    if (mouse_event.dwEventFlags)
	      continue;

	    /* If the mouse event occurred out of the area we can handle,
	       ignore it. */
	    int x = mouse_event.dwMousePosition.X;
	    int y = mouse_event.dwMousePosition.Y;
	    if ((x + ' ' + 1 > 0xFF) || (y + ' ' + 1 > 0xFF))
	      {
		syscall_printf("mouse: position out of range");
		continue;
	      }

	    /* Ignore unimportant mouse buttons */
	    mouse_event.dwButtonState &= 0x7;

	    /* This code assumes Windows never reports multiple button
	       events at the same time. */
	    static DWORD dwLastButtonState = 0;
	    int b = 0;
	    char sz[32];
	    if (mouse_event.dwButtonState == dwLastButtonState)
	      {
		syscall_printf("mouse: button state unchanged");
		continue;
	      }
	    else if (mouse_event.dwButtonState < dwLastButtonState)
	      {
		b = 3;
		strcpy(sz, "btn up");
	      }
	    else if ((mouse_event.dwButtonState & 1) != (dwLastButtonState & 1))
	      {
		b = 0;
		strcpy(sz, "btn1 down");
	      }
	    else if ((mouse_event.dwButtonState & 2) != (dwLastButtonState & 2))
	      {
		b = 1;
		strcpy(sz, "btn2 down");
	      }
	    else if ((mouse_event.dwButtonState & 4) != (dwLastButtonState & 4))
	      {
		b = 2;
		strcpy(sz, "btn3 down");
	      }

	    /* Remember the current button state */
	    dwLastButtonState = mouse_event.dwButtonState;

	    static int nModifiers = 0;
	    /* If a button was pressed, remember the modifiers */
	    if (b != 3)
	      {
		nModifiers = 0;
		if (mouse_event.dwControlKeyState & SHIFT_PRESSED)
		  nModifiers |= 0x4;
		if (mouse_event.dwControlKeyState & (RIGHT_ALT_PRESSED|LEFT_ALT_PRESSED))
		  nModifiers |= 0x8;
		if (mouse_event.dwControlKeyState & (RIGHT_CTRL_PRESSED|LEFT_CTRL_PRESSED))
		  nModifiers |= 0x10;
	      }

	    b |= nModifiers;

	    /* We can now create the code. */
	    sprintf(tmp, "\033[M%c%c%c", b + ' ', x + ' ' + 1, y + ' ' + 1);
	    syscall_printf("mouse: %s at (%d,%d)", sz, x, y);
	  }
	  break;

	case WINDOW_BUFFER_SIZE_EVENT:
	  kill_pgrp (tc->getpgid (), SIGWINCH);
	  continue;

	default:
	  continue;
d239 1
d385 1
a385 1
      SetConsoleMode (get_io_handle (), ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT | cflags);
d548 1
a548 1
  flags |= ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT;
d771 1
a771 1
fhandler_console::char_command (char c)
d1149 1
d1227 1
a1227 1
	  char_command (*src++);
d1274 2
@


1.29
log
@* path.cc (normalize_win32_path): Check for explicit use of two slashes at the
beginning of a path.  These should be treated specially regardless of whether
they are UNC paths or old-style //a paths.  Avoid adding cwd to a path if the
path already begins with '/'.
@
text
@d220 1
a220 1
	      if ((unsigned char)ich > 0x7f)
d1166 4
a1169 1
	CharToOemBuff ((LPCSTR)src, buf, l2);
@


1.28
log
@* fhandler_console.cc: New member variable `dwBufferSize' for `info'.
(fillin_info): Set `dwBufferSize' to the size of the console buffer.
(clear_screen): Use width of console buffer to calculate how many spaces to
clear.
@
text
@d196 7
d206 112
a317 1
      /* check if we're just disposing of this one */
d319 1
a319 2
      if (input_rec.EventType == WINDOW_BUFFER_SIZE_EVENT)
	{
d322 3
a324 30
	}
      if (input_rec.EventType != KEY_EVENT ||
	  !input_rec.Event.KeyEvent.bKeyDown)
	continue;

      if (wch == 0 ||
	  /* arrow/function keys */
	  (input_rec.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY))
	{
	  toadd = get_nonascii_key (input_rec, tmp);
	  if (!toadd)
	    continue;
	  nread = strlen (toadd);
	}
      else
	{
	  tmp[1] = ich;
	  /* Need this check since US code page seems to have a bug when
	     converting a CTRL-U. */
	  if ((unsigned char)ich > 0x7f)
	    OemToCharBuff (tmp + 1, tmp + 1, 1);
	  if (!(input_rec.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED))
	    toadd = tmp + 1;
	  else
	    {
	      tmp[0] = '\033';
	      tmp[1] = cyg_tolower (tmp[1]);
	      toadd = tmp;
	      nread++;
	    }
a328 1
#undef ich
d474 1
a474 1
      SetConsoleMode (get_io_handle (), ENABLE_WINDOW_INPUT | cflags);
d637 1
a637 1
  flags |= ENABLE_WINDOW_INPUT;
@


1.27
log
@* fork.cc (fork): Set sigframe here, since it can pause for a considerable
amount of time.
* environ.cc (_addenv): Add debugging.
* fhandler.cc: Eliminate unneeded include.
* smallprint.c: Ditto.
@
text
@d267 1
d284 1
d653 1
a653 1
  num = abs (y1 - y2) * info.dwWinSize.X + abs (x1 - x2) + 1;
d655 1
a655 1
  if ((y2 * info.dwWinSize.X + x2) > (y1 * info.dwWinSize.X + x1))
@


1.26
log
@* fhandler.h (fhandler_console): Remove tcsetpgrp.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Eliminate.
* fork.cc (fork_parent): Avoid returning same pid twice in a row regardless of
OS.
* pinfo.cc (pinfo::init): Rename create argument to flags and treat it as such.
* signal.cc (set_sigcatchers): New function.
(signal): Use set_sigcatchers to increment or decrement sigcatcher tracker.
(sigaction): Ditto.  Add debugging output.
* spawn.cc (spawn_guts): Always quote first argv[0] argument when it's a
COMSPEC shell.
@
text
@d1155 1
a1155 1
	  if (src == 0) /* write_normal fail */
@


1.25
log
@* Makefile.in: add miscfuncs.cc
* miscfuncs.cc: new, miscellaneous functions
* winsup.h: define table-driven tolower/toupper
* environ.cc: use them
* fhandler_console.cc: ditto
* fhandler_termios: ditto
* path.cc: ditto
(strncasematch, strcasematch, strcasestr): move to miscfuncs.cc
@
text
@d191 1
a192 1
	  __seterrno ();
a252 7
}

int
fhandler_console::tcsetpgrp (pid_t pid)
{
  tc->pgid = pid;
  return 0;
@


1.24
log
@* errno.cc (seterrno_from_win_error): Fix debugging output.
* fhandler.cc (fhandler_base::fstat): Move to inline method in fhandler.h.
(fhandler_base::set_io_handle): Ditto.
* fhandler.h (fhandler_base): Make some methods inline.
* fhandler_console.cc (fhandler_console::write_normal): Make buffer larger.
* sigproc.h (sigframe::sigframe): Actually use set ebp parameter correctly.
* spawn.cc (spawn_guts): Set dwProcessId when exec'ing.  Just exit immediately
after reparenting.
* syscalls.cc: Sprinkle sigframe stuff throughout.
* wait.cc (wait4): Set signal frame here.
* dcrt0.cc (__api_fatal): Don't rely on small_printf to display errors.  Always
display problems to the console, if possible.
@
text
@d231 1
a231 1
	      tmp[1] = tolower (tmp[1]);
@


1.23
log
@Break out more header info into separate files.  Use appropriate header files
throughout.
* shared.h: Remove.
* cygwin_version.h: New file.
* delqueue.h: New file.
* environ.h: New file.
* host_dependent.h: New file.
* perprocess.h: New file.
* registry.h: New file.
* security.h: New file.
@
text
@a268 1

d1078 2
a1079 2
      char buf[256];
      int len = found - src;
d1081 1
a1081 1
	int l2 = min (256, len);
@


1.22
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@d22 1
a27 1
#include "tty.h"
d29 1
@


1.21
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d27 2
d253 15
@


1.20
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@a10 4
/* FIXMES:
   Should the constructor call tcinit() explicitly rather than having
   it sprinkled throughout here? */

d20 1
d1404 2
a1405 3
int
fhandler_console::de_linearize (const char *buf, const char *unix_name,
			        const char *win32_name)
a1406 1
  int res = fhandler_base::de_linearize (buf, unix_name, win32_name);
d1430 1
a1430 1
  return res;
@


1.19
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d25 4
a29 1
#include "cygerrno.h"
@


1.18
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d26 1
@


1.17
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d25 1
@


1.16
log
@* fhandler_console.cc: Remove VK_DIVIDE detection.
(get_nonascii_key): Simplify previous patch to return ascii char if it is
non-zero.  Add a second "temporary buffer" argument to help with thread safety.
* select.cc (peek_console): Pass a temporary buffer argument to
get_nonascii_key.
@
text
@d15 1
a21 1
#include "winsup.h"
@


1.15
log
@* fhandler_console.cc: Add VK_DIVIDE detection.  Return virtual keycode if it
is not detected and it is less than ' '.
@
text
@d43 1
a43 1
const char * get_nonascii_key (INPUT_RECORD& input_rec);
d209 1
a209 1
	  toadd = get_nonascii_key (input_rec);
a1299 2
  /* FIXME: Should this be \033OQ? */
  {VK_DIVIDE,	{"/",		"/",		"/",		"/"}},
d1304 1
a1304 1
get_nonascii_key (INPUT_RECORD& input_rec)
d1325 1
a1325 1
  if (input_rec.Event.KeyEvent.wVirtualKeyCode < ' ')
d1327 3
a1329 4
      /* FIXME: Probably not thread-safe */
      static char buf[2];
      buf[0] = input_rec.Event.KeyEvent.wVirtualKeyCode;
      return buf;
@


1.14
log
@* include/cygwin/version.h: Bump DLL minor version number to 5 due to all of
the changes below.  Redefine process structure to avoid a fixed size table.
Redefine pinfo/_pinfo classes.  Use these throughout.
* dcrt0.cc (dll_crt0_1): Accomodate set_myself argument change.
(__api_fatal): Accomodate _pinfo::record_death argument change.
* exceptions.cc (really_exit): Ditto.
(sig_handle_tty_stop): Use pinfo constructor to access process info.
(events_init): Don't create pinfo_mutex since it is no longer required.
* external.cc (fillout_pinfo): Use winpids class to iterate over all system
pids.
(cygwin_internal): lock_pinfo_for_update and unlock_pinfo are now noops.
* fhandler_termios.cc (fhandler_termios::set_ctty): Use pinfo constructor to
access process info.
* fork.cc (fork): Reorganize to initialize child info after the child has
started since that is when we know the child's winpid, which is necessary to
allocate the pinfo shared memory.
* mmap.cc (recreate_mmaps_after_fork): Change arg type to _pinfo.
* pinfo.cc: Rename pinfo methods to _pinfo throughout.  Eliminate pinfo_list
stuff.
(set_myself): Accept a pid argument now.  Call pinfo initializer to initialize
myself.  Detect when this is an "execed" process and create an "indirect" pid
block.
(pinfo_init): Accomodate set_myself arg change.
(procinfo): Remove.
(pinfo::lock_pinfo): Remove.
(pinfo::unlock_pinfo): Remove.
(pinfo::init): New method.  Allocates shared memory space for process pinfo
structure.
(pinfo::record_death): Don't call locking functions.
(cygwin_winpid_to_pid): Simplify by using new pinfo constructor.
(EnumProcessesW95): New function for iterating over processes on Windows 95.
(winpids::winpids): New constructor for winpids class.  Sets up a list of
process ids.
(enum_init): Initialize w95/wnt pid enumerators.
* shared.cc (shared-info::initialize): Remove pid initialization.
* shared.h: Move pinfo stuff into pinfo.h.
(class shared_info): Remove pinfo_list element.
* signal.cc (kill_worker): Use pinfo constructor to access process info.
(kill_pgrp): Ditto.  Use winpids methods to access list of processes.
* sigproc.cc: Throughout, modify to use _pinfo where appropriate.
(proc_exists (pid_t)): New function.  Determines if a process exists based on
the pid.
(proc_exists (_pinfo *p): Use new proc_exists function above.
(proc_subproc): Copy pinfo stuff around rather than _pinfo pointers.  Try to be
careful about releasing shared memory when we don't need it anymore.  Remove
pinfo locks.
(remove_zombies): Remove pinfo memory when zombie is going away.
* sigproc.h: Reflect _pinfo/pinfo changes in sigproc.cc.
* spawn.cc (spawn_guts): Eliminate pinfo *child argument.  Reorganize to only
initialize child pinfo after process has been started and we know the windows
pid.
(_spawnve): Reflect spawn_guts changes.
* syscalls.cc (setpgid): Use pinfo constructor to access process info.
(getpgid): Ditto.
(internal_getlogin): Use _pinfo.
* winsup.h: Eliminate pinfo_mutex.  Eliminate spawn_guts declaration since it
is static now.  Reflect set_myself argument change.
* include/sys/cygwin.h: Add some PID_* enums to accomodate new pinfo stuff.
* include/cygwin/version.h: Update minor version for cygdrive changes below.
@
text
@d1300 2
d1327 7
@


1.13
log
@* testsuite/winsup.api/winsup.exp: ignore stdout by default
* testsuite/winsup.api/crlf.c: non-verbose by default

* winsup.h: prune out windows headers we don't normally need
* assert.cc: add wingdi.h and winuser.h
* fhandler_console.cc: ditto
* fhandler_windows.cc: ditto
* select.cc: ditto
* spawn.cc: ditto
* strace.cc: ditto
* tty.cc: ditto
* window.cc: ditto
* hinfo.cc: add winsock.h
* syscalls.cc: add winnls.h
* uinfo.cc: ditto

* include/windows.h: optimize non-inclusion of repeat headers
@
text
@d113 17
d167 1
a167 1
      cursor_rel (0,0); /* to make cursor appear on the screen immediately */
d1264 1
@


1.13.2.1
log
@* fhandler_console.cc: Add VK_DIVIDE detection.  Return virtual keycode if it
is not detected and it is less than ' '.
@
text
@a112 17
void
fhandler_console::set_cursor_maybe ()
{
  CONSOLE_SCREEN_BUFFER_INFO now;
  static CONSOLE_SCREEN_BUFFER_INFO last = {{0, 0}, {-1, -1}, 0, {0, 0}, {0, 0}};

  if (!GetConsoleScreenBufferInfo (get_output_handle(), &now))
    return;

  if (last.dwCursorPosition.X != now.dwCursorPosition.X ||
      last.dwCursorPosition.Y != now.dwCursorPosition.Y)
    {
      SetConsoleCursorPosition (get_output_handle (), now.dwCursorPosition);
      last.dwCursorPosition = now.dwCursorPosition;
    }
}

d150 1
a150 1
      set_cursor_maybe ();	/* to make cursor appear on the screen immediately */
a1246 1

a1281 2
  /* FIXME: Should this be \033OQ? */
  {VK_DIVIDE,	{"/",		"/",		"/",		"/"}},
a1306 7
  if (input_rec.Event.KeyEvent.wVirtualKeyCode < 127)
    {
      /* FIXME: Probably not thread-safe */
      static char buf[2];
      buf[0] = input_rec.Event.KeyEvent.wVirtualKeyCode;
      return buf;
    }
@


1.13.2.2
log
@* fhandler_console.cc: Remove VK_DIVIDE detection.
(get_nonascii_key): Simplify previous patch to return ascii char if it is
non-zero.  Add a second "temporary buffer" argument to help with thread safety.
* select.cc (peek_console): Pass a temporary buffer argument to
get_nonascii_key.
@
text
@d43 1
a43 1
const char * get_nonascii_key (INPUT_RECORD&, char *);
d209 1
a209 1
	  toadd = get_nonascii_key (input_rec, tmp);
d1300 2
d1306 1
a1306 1
get_nonascii_key (INPUT_RECORD& input_rec, char *tmp)
d1327 1
a1327 1
  if (input_rec.Event.KeyEvent.uChar.AsciiChar)
d1329 4
a1332 3
      tmp[0] = input_rec.Event.KeyEvent.uChar.AsciiChar;
      tmp[1] = '\0';
      return tmp;
@


1.13.2.3
log
@* select.cc (fhandler_console::select_read): Call set_cursor_maybe since select
may block and cursor may not be visible.
* select.cc (fhandler_console::select_write): Ditto.
* select.cc (fhandler_console::select_except): Ditto.
* environ.cc (cur_environ): Give "C" linkage.
* winsup.h: Ditto.
* winsup.cc: Change include ordering.
@
text
@d125 1
a125 1
      (void) SetConsoleCursorPosition (get_output_handle (), now.dwCursorPosition);
@


1.12
log
@* fhandler_console.cc (fhandler_console::read): Explicitly set cursor to make
it visible while waiting in WaitForMultipleObjects.
@
text
@d22 2
@


1.11
log
@* fhandler_console.cc (fhandler_console::read): Unicode interface to
ReadConsoleInput only exists on W2K, so use workaround from Kazuhiro Fujieda
<fujieda@@jaist.ac.jp>.
@
text
@d148 1
@


1.10
log
@* Makefile.in (install): Install textmode.o as well as binmode.o.
@
text
@d164 1
a164 1
      if (!ReadConsoleInputW (h, &input_rec, 1, &nread))
d196 5
a200 1
	  nread = WideCharToMultiByte (CP_ACP, 0, &wch, 1, tmp + 1, sizeof (tmp) - 1, NULL, NULL);
@


1.9
log
@* dcrt0.cc (dll_crt0_1): Eliminate SetFileApisToOEM and CharToOem.
* (dummy_autoload): Add functions used in fhandler_console.
* fhandler_console.cc (fhandler_console::read): Use ENCHANCED_KEY flag to
distinguish extended keys.  Translate an input character from the OEM code page
to the ANSI code page.
* (fhandler_console::write_normal): Translate output characters from the ANSI
code page to the OEM code page.
* syscalls.cc (_link): Use MultiByteToWideChar instead of OemToCharW.
@
text
@d131 1
d159 1
d164 1
a164 1
      if (!ReadConsoleInput (h, &input_rec, 1, &nread))
d172 1
d185 1
a185 1
      if (ich == 0 ||
a193 5
      else if (!(input_rec.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED))
	{
	  OemToCharBuff (&ich, &ich, 1);
	  toadd = &ich;
	}
d196 10
a205 5
	  static char tmp[2];
	  tmp[0] = '\033';
	  tmp[1] = tolower (ich);
	  toadd = tmp;
	  nread = 2;
@


1.8
log
@* fhandler_console.cc (fhandler_console::read): Detect extended keycode
information for Windows 9x so that function keys will work correctly.
@
text
@d182 3
a184 1
      if (ich == 0 || (ich & 0xff) == 0xe0)  /* arrow/function keys */
d192 4
a195 1
	toadd = &ich;
d1032 6
a1037 1
      if (! WriteFile (get_output_handle (), src,  found - src, &done, 0))
d1043 3
a1045 1
      src += done;
@


1.7
log
@* fhandler_console.cc (keytable): Add support for keypad 5 key, which MS seems
to think is equivalent to VK_CLEAR.
* debug.cc (thread_stub): Eliminate initialization of reent stuff.
* init.cc (dll_entry): Move it here.
@
text
@d182 1
a182 1
      if (ich == 0)  /* arrow/function keys */
@


1.6
log
@* fhandler.cc (fhandler_base::get_readahead_into_buffer): New function.
* fhandler.h: Declare new function.  Add extra argument to
process_slave_output.
* fhandler_console.cc (fhandler_console::read): Move read ahead code to new
function.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Move common code
here.
(fhandler_tty_slave::read): Understand readahead.
(fhandler_pty_master::read): Move code to process_slave_output.
* select.cc (peek_pipe): Avoid performing certain checks when non-read and on
inappropriate fh types.
@
text
@d1258 1
@


1.5
log
@* fhandler_console.cc (fhandler_console::read): Don't even think about breaking
on interrupt if executing in a "cygwin" thread.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Streamline,
simplify code.
* sigproc.cc (sig_send): Remove debugging statement.
@
text
@a117 1
  int copied_chars = 0;
d123 2
a124 8
  while (buflen)
    if ((ch = get_readahead ()) < 0)
      break;
    else
      {
	buf[copied_chars++] = (unsigned char)(ch & 0xff);
	buflen--;
      }
@


1.4
log
@* exceptions.cc (interruptible): Make a little more structured.
(call_handler): Allow signals to be sent even if signalled thread is stopped.
Change order of signal_arrived arming/waiting threads clearing to eliminate a
race.
(reset_signal_arrived): New helper function.
* malloc.cc (malloc_init): Use mutos so that signal handler can keep track of
who owns the lock.
(__malloc_lock): Ditto.
(__malloc_unlock): Ditto.
* sync.h (new_muto): Actually use a muto for the "buffer".
* Makefile.in: Fix a dependency.
@
text
@d140 7
a146 2
  nwait = 2;
  w4[1] = signal_arrived;
d159 1
a159 2
	  if (!iscygthread ())
	    set_sig_errno (EINTR);
@


1.3
log
@Fix final round of gcc warnings relating to unused parameters.
* debug.cc (iscygthread): New function.
* debug.h: Declare it.
* exceptions.cc (set_process_mask): Flush pending signals.
(handle_sigsuspend): No need to flush pending signals.
(call_handler): Refine previous tests of muto ownership.  Only clear wait()'s
when we have definitely responded to a signal.
* fhandler_console.cc (fhandler_console::read): Don't set EINTR if executing in
a "cygwin" thread.
* sigproc.cc (proc_subproc): Use second argument to control whether CLEARWAIT
actually sets "signalled" flag.
* sync.h (muto): Add 'unstable' method.
@
text
@a180 1
debug_printf ("ich %d, keydown %d, type %d", ich, input_rec.Event.KeyEvent.bKeyDown, input_rec.EventType);
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d154 2
a155 1
	  set_sig_errno (EINTR);
@


1.1
log
@Initial revision
@
text
@d410 1
a410 1
	(void) bg_check (SIGTTOU, 0);
d1326 1
a1326 1
fhandler_console::fixup_after_fork (HANDLE parent)
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
