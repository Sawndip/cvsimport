head	1.113;
access;
symbols
	cygwin-1_7_35-release:1.113
	cygwin-1_7_34-release:1.112
	cygwin-1_7_33-release:1.96
	cygwin-1_7_32-release:1.96
	cygwin-1_7_31-release:1.96
	cygwin-1_7_30-release:1.96
	cygwin-1_7_29-release:1.96
	cygwin-1_7_29-release-branchpoint:1.96.0.2
	cygwin-pre-user-db:1.96
	cygwin-1_7_28-release:1.96
	cygwin-1_7_27-release:1.94
	cygwin-1_7_26-release:1.94
	cygwin-1_7_25-release:1.94
	cygwin-1_7_24-release:1.94
	cygwin-1_7_23-release:1.94
	cygwin-1_7_22-release:1.94
	cygwin-1_7_21-release:1.94
	cygwin-1_7_20-release:1.94
	cygwin-1_7_19-release:1.94
	cygwin-64bit-postmerge:1.94
	cygwin-64bit-premerge-branch:1.93.0.2
	cygwin-64bit-premerge:1.93
	cygwin-1_7_18-release:1.93
	post-ptmalloc3:1.92.2.2
	pre-ptmalloc3:1.92.2.2
	cygwin-1_7_17-release:1.92
	cygwin-64bit-branch:1.92.0.2
	cygwin-1_7_16-release:1.92
	cygwin-1_7_15-release:1.91
	cygwin-1_7_14_2-release:1.91
	cygwin-1_7_14-release:1.91
	cygwin-1_7_12-release:1.89
	cygwin-1_7_11-release:1.89
	cygwin-1_7_10-release:1.88
	signal-rewrite:1.87.0.2
	pre-notty:1.87
	cygwin-1_7_9-release:1.86
	cv-post-1_7_9:1.86.0.2
	cygwin-1_7_8-release:1.86
	cygwin-1_7_7-release:1.84
	cygwin-1_7_5-release:1.84
	cygwin-1_7_4-release:1.84
	cygwin-1_7_3-release:1.84
	cygwin-1_7_2-release:1.84
	fifo_doover3:1.84.0.4
	cygwin-1_7_1-release:1.84
	prefifo:1.84
	cv-branch-2:1.84.0.2
	pre-ripout-set_console_state_for_spawn:1.81
	EOL_registry_mounts:1.80
	preoverlapped:1.80
	drop_9x_support_start:1.79
	cr-0x5f1:1.79.0.8
	cv-branch:1.79.0.6
	pre-ptymaster-archetype:1.79
	cr-0x3b58:1.79.0.4
	cr-0x5ef:1.79.0.2
	after-mmap-privanon-noreserve:1.79
	after-mmap-revamp:1.79
	before-mmap-revamp:1.79
	cgf-more-exit-sync:1.79
	post_wait_sig_exit:1.79
	pre_wait_sig_exit:1.78
	reparent-point:1.77
	noreparent:1.77.0.2
	cr-0x5e6:1.76.0.8
	cr-0x9e:1.76.0.6
	cr-0x9d:1.76.0.4
	cgf-deleteme:1.76.0.2
	pre-sigrewrite:1.74
	corinna-01:1.74
	cr-0x9c:1.73.0.4
	cr-0x9b:1.73.0.2
	cr-0x99:1.71
	Z-emcb-cygwin_daemon:1.71.0.2
	w32api-2_2:1.70
	mingw-runtime-2_4:1.70
	pre-cgf-merge:1.73
	cgf-dev-branch:1.57.0.2
	predaemon:1.42
	cygwin_daemon_merge_HEAD:1.42
	pregp02r1:1.42.0.2
	cygnus_cvs_20020108_pre:1.39
	Z-cygwin_daemon_merge-new_HEAD:1.50
	Z-cygwin_daemon_merge_HEAD:1.50
	cygwin_daemon:1.34.0.2;
locks; strict;
comment	@// @;
expand	@o@;


1.113
date	2015.02.24.20.52.57;	author corinna;	state Exp;
branches;
next	1.112;

1.112
date	2014.07.07.10.22.51;	author corinna;	state Exp;
branches;
next	1.111;

1.111
date	2014.06.25.09.10.50;	author corinna;	state Exp;
branches;
next	1.110;

1.110
date	2014.05.07.14.49.54;	author corinna;	state Exp;
branches;
next	1.109;

1.109
date	2014.05.07.11.00.00;	author corinna;	state Exp;
branches;
next	1.108;

1.108
date	2014.03.19.13.05.33;	author corinna;	state Exp;
branches;
next	1.107;

1.107
date	2014.03.12.17.36.56;	author corinna;	state Exp;
branches;
next	1.106;

1.106
date	2014.03.07.20.38.48;	author corinna;	state Exp;
branches;
next	1.105;

1.105
date	2014.03.06.18.54.07;	author corinna;	state Exp;
branches;
next	1.104;

1.104
date	2014.03.05.20.58.33;	author corinna;	state Exp;
branches;
next	1.103;

1.103
date	2014.02.27.12.57.26;	author corinna;	state Exp;
branches;
next	1.102;

1.102
date	2014.02.22.19.38.12;	author corinna;	state Exp;
branches;
next	1.101;

1.101
date	2014.02.21.10.01.00;	author corinna;	state Exp;
branches;
next	1.100;

1.100
date	2014.02.19.18.29.51;	author corinna;	state Exp;
branches;
next	1.99;

1.99
date	2014.02.18.19.39.48;	author corinna;	state Exp;
branches;
next	1.98;

1.98
date	2014.02.17.15.36.33;	author corinna;	state Exp;
branches;
next	1.97;

1.97
date	2014.02.09.19.44.55;	author corinna;	state Exp;
branches;
next	1.96;

1.96
date	2014.01.27.20.04.35;	author cgf;	state Exp;
branches;
next	1.95;

1.95
date	2014.01.17.14.53.04;	author corinna;	state Exp;
branches;
next	1.94;

1.94
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.93;

1.93
date	2013.01.21.04.38.27;	author cgf;	state Exp;
branches;
next	1.92;

1.92
date	2012.07.09.12.57.03;	author corinna;	state Exp;
branches
	1.92.2.1;
next	1.91;

1.91
date	2012.04.05.10.16.09;	author corinna;	state Exp;
branches;
next	1.90;

1.90
date	2012.04.04.09.57.17;	author corinna;	state Exp;
branches;
next	1.89;

1.89
date	2012.02.09.01.20.55;	author cgf;	state Exp;
branches;
next	1.88;

1.88
date	2012.02.03.12.26.08;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2011.03.29.10.42.11;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2010.09.28.14.49.31;	author corinna;	state Exp;
branches
	1.86.2.1;
next	1.85;

1.85
date	2010.09.28.14.40.18;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2009.01.26.13.20.46;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2008.10.21.16.47.28;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2008.07.24.18.25.49;	author corinna;	state Exp;
branches;
next	1.81;

1.81
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.80;

1.80
date	2007.02.23.15.15.49;	author corinna;	state Exp;
branches;
next	1.79;

1.79
date	2005.09.14.14.27.55;	author cgf;	state Exp;
branches;
next	1.78;

1.78
date	2005.07.06.20.05.02;	author cgf;	state Exp;
branches;
next	1.77;

1.77
date	2004.05.28.19.50.06;	author cgf;	state Exp;
branches;
next	1.76;

1.76
date	2003.12.23.16.26.30;	author cgf;	state Exp;
branches;
next	1.75;

1.75
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.74;

1.74
date	2003.09.25.00.37.17;	author cgf;	state Exp;
branches;
next	1.73;

1.73
date	2003.09.08.22.03.20;	author cgf;	state Exp;
branches;
next	1.72;

1.72
date	2003.09.08.21.44.53;	author cgf;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.16.03.24.11;	author cgf;	state Exp;
branches;
next	1.70;

1.70
date	2003.02.06.14.01.54;	author corinna;	state Exp;
branches;
next	1.69;

1.69
date	2003.02.04.14.58.04;	author corinna;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.01.18.41.29;	author cgf;	state Exp;
branches;
next	1.67;

1.67
date	2003.01.31.17.00.42;	author cgf;	state Exp;
branches;
next	1.66;

1.66
date	2003.01.27.17.00.17;	author cgf;	state Exp;
branches;
next	1.65;

1.65
date	2003.01.27.00.16.01;	author cgf;	state Exp;
branches;
next	1.64;

1.64
date	2003.01.26.06.02.34;	author cgf;	state Exp;
branches;
next	1.63;

1.63
date	2003.01.26.05.38.37;	author cgf;	state Exp;
branches;
next	1.62;

1.62
date	2003.01.24.03.53.46;	author cgf;	state Exp;
branches;
next	1.61;

1.61
date	2003.01.21.06.58.11;	author cgf;	state Exp;
branches;
next	1.60;

1.60
date	2003.01.20.02.57.54;	author cgf;	state Exp;
branches;
next	1.59;

1.59
date	2003.01.17.18.05.32;	author cgf;	state Exp;
branches;
next	1.58;

1.58
date	2003.01.17.05.18.29;	author cgf;	state Exp;
branches;
next	1.57;

1.57
date	2003.01.10.12.32.46;	author corinna;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2003.01.02.00.03.23;	author cgf;	state Exp;
branches;
next	1.55;

1.55
date	2003.01.01.18.12.49;	author cgf;	state Exp;
branches;
next	1.54;

1.54
date	2002.12.10.12.43.49;	author corinna;	state Exp;
branches
	1.54.4.1;
next	1.53;

1.53
date	2002.11.25.15.11.39;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2002.11.20.17.10.05;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2002.09.30.15.17.44;	author cgf;	state Exp;
branches;
next	1.50;

1.50
date	2002.09.22.03.38.57;	author cgf;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.19.15.27.24;	author cgf;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.05.15.43.49;	author cgf;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.05.11.56.56;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.05.11.10.15;	author corinna;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.02.06.07.00;	author cgf;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.29.15.04.26;	author corinna;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.25.02.22.50;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.17.04.59.54;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.10.13.50.13;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.10.13.38.49;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.15.23.39.32;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.13.01.35.15;	author cgf;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.01.04.10.06;	author cgf;	state Exp;
branches;
next	1.36;

1.36
date	2001.09.28.07.23.18;	author cgf;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.28.07.01.22;	author cgf;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.14.03.01.47;	author cgf;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2001.09.11.20.01.00;	author cgf;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.09.16.52.37;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.07.21.32.04;	author cgf;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.06.03.39.18;	author cgf;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.22.21.51.48;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.07.08.56.22;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.26.19.22.24;	author cgf;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.26.14.47.48;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.24.22.26.51;	author cgf;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.19.05.29.00;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.30.18.21.48;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.25.09.43.25;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.24.21.52.57;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.24.21.45.20;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.21.14.23.47;	author rbcollins;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.18.21.10.12;	author cgf;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.28.05.51.14;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.15.00.13.08;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.16.23.55.57;	author cgf;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.07.16.23.50;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.04.17.52.42;	author cgf;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.03.04.16.35;	author cgf;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.22.05.10.20;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.22.03.58.47;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.12.05.35.42;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.12.04.48.44;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.02.16.28.17;	author dj;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.26.11.48.38;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.01.17.30.35;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.25.03.48.10;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.24.17.37.52;	author corinna;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.05.20.37;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.92.2.1
date	2012.08.13.20.04.34;	author corinna;	state Exp;
branches;
next	1.92.2.2;

1.92.2.2
date	2013.01.21.13.52.09;	author corinna;	state Exp;
branches;
next	;

1.86.2.1
date	2011.03.13.12.05.58;	author corinna;	state Exp;
branches;
next	;

1.57.2.1
date	2003.01.24.04.04.20;	author cgf;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2003.01.26.05.39.17;	author cgf;	state Exp;
branches;
next	1.57.2.3;

1.57.2.3
date	2003.01.26.06.43.32;	author cgf;	state Exp;
branches;
next	1.57.2.4;

1.57.2.4
date	2003.01.27.00.16.44;	author cgf;	state Exp;
branches;
next	1.57.2.5;

1.57.2.5
date	2003.01.30.02.46.41;	author cgf;	state Exp;
branches;
next	1.57.2.6;

1.57.2.6
date	2003.01.31.22.26.24;	author cgf;	state Exp;
branches;
next	1.57.2.7;

1.57.2.7
date	2003.02.01.18.42.23;	author cgf;	state Exp;
branches;
next	1.57.2.8;

1.57.2.8
date	2003.02.05.14.25.09;	author cgf;	state Exp;
branches;
next	1.57.2.9;

1.57.2.9
date	2003.02.07.15.20.03;	author cgf;	state Exp;
branches;
next	1.57.2.10;

1.57.2.10
date	2003.02.14.03.03.29;	author cgf;	state Exp;
branches;
next	1.57.2.11;

1.57.2.11
date	2003.07.06.05.10.43;	author cgf;	state Exp;
branches;
next	1.57.2.12;

1.57.2.12
date	2003.09.10.16.23.39;	author cgf;	state Exp;
branches;
next	;

1.54.4.1
date	2003.01.01.18.16.37;	author cgf;	state Exp;
branches;
next	1.54.4.2;

1.54.4.2
date	2003.01.02.00.04.30;	author cgf;	state Exp;
branches;
next	;

1.34.2.1
date	2001.09.29.09.35.31;	author rbcollins;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.10.02.12.09.55;	author rbcollins;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2002.01.04.03.56.09;	author rbcollins;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2002.02.28.12.53.25;	author rbcollins;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2002.06.13.14.34.07;	author rbcollins;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2002.06.19.20.58.58;	author scottc;	state Exp;
branches;
next	1.34.2.7;

1.34.2.7
date	2002.09.22.10.01.28;	author scottc;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.38.31;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.113
log
@	* ldap.h: Remove index macros.
	(class cyg_ldap): Remove members srch_msg and srch_entry.
	(cyg_ldap::get_string_attribute): Remove private method taking index
	argument.
	(cyg_ldap::get_num_attribute): Ditto.  Add method taking attribute name.
	(cyg_ldap::get_primary_gid): Adjust to aforementioned change.
	(cyg_ldap::get_unix_uid): Ditto.
	(cyg_ldap::get_unix_gid): Ditto.
	* ldap.cc: Throughout, use msg and entry in place of srch_msg and
	srch_entry.
	(std_user_attr): Add sAMAccountName and objectSid.
	(group_attr): Ditto.
	(cyg_ldap::close): Drop handling of srch_msg and srch_entry.
	(cyg_ldap::get_string_attribute): Move earlier in file.
	(cyg_ldap::get_num_attribute): Ditto.
	(cyg_ldap::enumerate_ad_accounts): Add comments for clarity.
	Use group_attr or user_attr rather than sid_attr to fetch all desired
	attributes for an account right away.
	(cyg_ldap::next_account): Store found SID in last_fetched_sid to
	skip calls to fetch_ad_account from fetch_account_from_windows.
	(cyg_ldap::get_string_attribute): Remove method taking index argument.
	(cyg_ldap::get_num_attribute): Ditto.
	* pwdgrp.h (class pg_ent): Fix formatting.  Add member dom.
	* passwd.cc (pg_ent::enumerate_ad): Store current flat domain name
	in dom.  Construct fetch_acc_t argument from LDAP attributes and
	call fetch_account_from_windows with that.
	* userinfo.h (enum fetch_user_arg_type_t): Rename FULL_grp_arg to
	FULL_acc_arg.  Change throughout.
	(struct fetch_acc_t): Rename from fetch_full_grp_t.  Change throughout.
	(struct fetch_user_arg_t): Rename full_grp to full_acc.  Change
	throughout.
@
text
@/* passwd.cc: getpwnam () and friends

   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008,
   2009, 2010, 2011, 2012, 2013, 2014, 2015  Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <lm.h>
#include <stdlib.h>
#include <stdio.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "pinfo.h"
#include "cygheap.h"
#include "shared_info.h"
#include "miscfuncs.h"
#include "ldap.h"
#include "tls_pbuf.h"

/* Parse /etc/passwd line into passwd structure. */
bool
pwdgrp::parse_passwd ()
{
  pg_pwd &res = passwd ()[curr_lines];
  res.p.pw_name = next_str (':');
  res.p.pw_passwd = next_str (':');
  if (!next_num (res.p.pw_uid))
    return false;
  if (!next_num (res.p.pw_gid))
    return false;
  res.p.pw_comment = NULL;
  res.p.pw_gecos = next_str (':');
  res.p.pw_dir =  next_str (':');
  res.p.pw_shell = next_str (':');
  res.sid.getfrompw (&res.p);
  /* lptr points to the \0 after pw_shell.  Increment by one to get the correct
     required buffer len in getpw_cp. */
  res.len = lptr - res.p.pw_name + 1;
  return true;
}

void
pwdgrp::init_pwd ()
{
  pwdgrp_buf_elem_size = sizeof (pg_pwd);
  parse = &pwdgrp::parse_passwd;
}

struct passwd *
pwdgrp::find_user (cygpsid &sid)
{
  for (ULONG i = 0; i < curr_lines; i++)
    if (sid == passwd ()[i].sid)
      return &passwd ()[i].p;
  return NULL;
}

struct passwd *
pwdgrp::find_user (const char *name)
{
  for (ULONG i = 0; i < curr_lines; i++)
    /* on Windows NT user names are case-insensitive */
    if (strcasematch (name, passwd ()[i].p.pw_name))
      return &passwd ()[i].p;
  return NULL;
}

struct passwd *
pwdgrp::find_user (uid_t uid)
{
  for (ULONG i = 0; i < curr_lines; i++)
    if (uid == passwd ()[i].p.pw_uid)
      return &passwd ()[i].p;
  return NULL;
}

struct passwd *
internal_getpwsid (cygpsid &sid, cyg_ldap *pldap)
{
  struct passwd *ret;

  cygheap->pg.nss_init ();
  /* Check caches first. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.pwd_cache.cygserver.find_user (sid)))
    return ret;
  if (cygheap->pg.nss_pwd_files ()
      && (ret = cygheap->pg.pwd_cache.file.find_user (sid)))
    return ret;
  if (cygheap->pg.nss_pwd_db ()
      && (ret = cygheap->pg.pwd_cache.win.find_user (sid)))
    return ret;
  /* Ask sources afterwards. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.pwd_cache.cygserver.add_user_from_cygserver (sid)))
    return ret;
  if (cygheap->pg.nss_pwd_files ())
    {
      cygheap->pg.pwd_cache.file.check_file ();
      if ((ret = cygheap->pg.pwd_cache.file.add_user_from_file (sid)))
	return ret;
    }
  if (cygheap->pg.nss_pwd_db ())
    return cygheap->pg.pwd_cache.win.add_user_from_windows (sid, pldap);
  return NULL;
}

/* This function gets only called from mkpasswd via cygwin_internal. */
struct passwd *
internal_getpwsid_from_db (cygpsid &sid)
{
  cygheap->pg.nss_init ();
  return cygheap->pg.pwd_cache.win.add_user_from_windows (sid);
}

struct passwd *
internal_getpwnam (const char *name, cyg_ldap *pldap)
{
  struct passwd *ret;

  cygheap->pg.nss_init ();
  /* Check caches first. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.pwd_cache.cygserver.find_user (name)))
    return ret;
  if (cygheap->pg.nss_pwd_files ()
      && (ret = cygheap->pg.pwd_cache.file.find_user (name)))
    return ret;
  if (cygheap->pg.nss_pwd_db ()
      && (ret = cygheap->pg.pwd_cache.win.find_user (name)))
    return ret;
  /* Ask sources afterwards. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.pwd_cache.cygserver.add_user_from_cygserver (name)))
    return ret;
  if (cygheap->pg.nss_pwd_files ())
    {
      cygheap->pg.pwd_cache.file.check_file ();
      if ((ret = cygheap->pg.pwd_cache.file.add_user_from_file (name)))
	return ret;
    }
  if (cygheap->pg.nss_pwd_db ())
    return cygheap->pg.pwd_cache.win.add_user_from_windows (name, pldap);
  return NULL;
}

struct passwd *
internal_getpwuid (uid_t uid, cyg_ldap *pldap)
{
  struct passwd *ret;

  cygheap->pg.nss_init ();
  /* Check caches first. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.pwd_cache.cygserver.find_user (uid)))
    return ret;
  if (cygheap->pg.nss_pwd_files ()
      && (ret = cygheap->pg.pwd_cache.file.find_user (uid)))
    return ret;
  if (cygheap->pg.nss_pwd_db ()
      && (ret = cygheap->pg.pwd_cache.win.find_user (uid)))
    return ret;
  /* Ask sources afterwards. */
  if (cygheap->pg.nss_cygserver_caching ()
      && (ret = cygheap->pg.pwd_cache.cygserver.add_user_from_cygserver (uid)))
    return ret;
  if (cygheap->pg.nss_pwd_files ())
    {
      cygheap->pg.pwd_cache.file.check_file ();
      if ((ret = cygheap->pg.pwd_cache.file.add_user_from_file (uid)))
	return ret;
    }
  if (cygheap->pg.nss_pwd_db () || uid == ILLEGAL_UID)
    return cygheap->pg.pwd_cache.win.add_user_from_windows (uid, pldap);
  return NULL;
}

/* getpwuid/getpwnam are not reentrant. */
static struct {
  struct passwd p;
  char *buf;
  size_t bufsiz;
} app_pw;

static struct passwd *
getpw_cp (struct passwd *temppw)
{
  if (!temppw)
    return NULL;
  pg_pwd *pw = (pg_pwd *) temppw;
  if (app_pw.bufsiz < pw->len)
    {
      char *newbuf = (char *) realloc (app_pw.buf, pw->len);
      if (!newbuf)
	{
	  set_errno (ENOMEM);
	  return NULL;
	}
      app_pw.buf = newbuf;
      app_pw.bufsiz = pw->len;
    }
  memcpy (app_pw.buf, pw->p.pw_name, pw->len);
  memcpy (&app_pw.p, &pw->p, sizeof pw->p);
  ptrdiff_t diff = app_pw.buf - pw->p.pw_name;
  app_pw.p.pw_name += diff;
  app_pw.p.pw_passwd += diff;
  app_pw.p.pw_gecos += diff;
  app_pw.p.pw_dir += diff;
  app_pw.p.pw_shell += diff;
  return &app_pw.p;
}

extern "C" struct passwd *
getpwuid32 (uid_t uid)
{
  struct passwd *temppw = internal_getpwuid (uid);
  pthread_testcancel ();
  return getpw_cp (temppw);
}

#ifdef __x86_64__
EXPORT_ALIAS (getpwuid32, getpwuid)
#else
extern "C" struct passwd *
getpwuid (__uid16_t uid)
{
  return getpwuid32 (uid16touid32 (uid));
}
#endif

extern "C" int
getpwuid_r32 (uid_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
{
  *result = NULL;

  if (!pwd || !buffer)
    return ERANGE;

  struct passwd *temppw = internal_getpwuid (uid);
  pthread_testcancel ();
  if (!temppw)
    return 0;

  /* check needed buffer size. */
  size_t needsize = strlen (temppw->pw_name) + strlen (temppw->pw_passwd)
		    + strlen (temppw->pw_gecos) + strlen (temppw->pw_dir)
		    + strlen (temppw->pw_shell) + 5;
  if (needsize > bufsize)
    return ERANGE;

  /* make a copy of temppw */
  *result = pwd;
  pwd->pw_uid = temppw->pw_uid;
  pwd->pw_gid = temppw->pw_gid;
  buffer = stpcpy (pwd->pw_name = buffer, temppw->pw_name);
  buffer = stpcpy (pwd->pw_passwd = buffer + 1, temppw->pw_passwd);
  buffer = stpcpy (pwd->pw_gecos = buffer + 1, temppw->pw_gecos);
  buffer = stpcpy (pwd->pw_dir = buffer + 1, temppw->pw_dir);
  stpcpy (pwd->pw_shell = buffer + 1, temppw->pw_shell);
  pwd->pw_comment = NULL;
  return 0;
}

#ifdef __x86_64__
EXPORT_ALIAS (getpwuid_r32, getpwuid_r)
#else
extern "C" int
getpwuid_r (__uid16_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
{
  return getpwuid_r32 (uid16touid32 (uid), pwd, buffer, bufsize, result);
}
#endif

extern "C" struct passwd *
getpwnam (const char *name)
{
  struct passwd *temppw = internal_getpwnam (name);
  pthread_testcancel ();
  return getpw_cp (temppw);
}


/* the max size buffer we can expect to
 * use is returned via sysconf with _SC_GETPW_R_SIZE_MAX.
 * This may need updating! - Rob Collins April 2001.
 */
extern "C" int
getpwnam_r (const char *nam, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
{
  *result = NULL;

  if (!pwd || !buffer || !nam)
    return ERANGE;

  struct passwd *temppw = internal_getpwnam (nam);
  pthread_testcancel ();

  if (!temppw)
    return 0;

  /* check needed buffer size. */
  size_t needsize = strlen (temppw->pw_name) + strlen (temppw->pw_passwd)
		    + strlen (temppw->pw_gecos) + strlen (temppw->pw_dir)
		    + strlen (temppw->pw_shell) + 5;
  if (needsize > bufsize)
    return ERANGE;

  /* make a copy of temppw */
  *result = pwd;
  pwd->pw_uid = temppw->pw_uid;
  pwd->pw_gid = temppw->pw_gid;
  buffer = stpcpy (pwd->pw_name = buffer, temppw->pw_name);
  buffer = stpcpy (pwd->pw_passwd = buffer + 1, temppw->pw_passwd);
  buffer = stpcpy (pwd->pw_gecos = buffer + 1, temppw->pw_gecos);
  buffer = stpcpy (pwd->pw_dir = buffer + 1, temppw->pw_dir);
  stpcpy (pwd->pw_shell = buffer + 1, temppw->pw_shell);
  pwd->pw_comment = NULL;
  return 0;
}

/* getpwent functions are not reentrant. */
static pw_ent pwent;

void
pg_ent::clear_cache ()
{
  if (pg.curr_lines)
    {
      if (state > from_file)
	cfree (group ? grp.g.gr_name : pwd.p.pw_name);
      pg.curr_lines = 0;
    }
}

void
pg_ent::setent (bool _group, int _enums, PCWSTR _enum_tdoms)
{
  cygheap->dom.init ();
  endent (_group);
  if (!_enums && !_enum_tdoms)
    {
      /* This is the default, when called from the usual setpwent/setgrent
         functions. */
      enums = cygheap->pg.nss_db_enums ();
      enum_tdoms = cygheap->pg.nss_db_enum_tdoms ();
      if (_group)
	{
	  from_files = cygheap->pg.nss_grp_files ();
	  from_db = cygheap->pg.nss_grp_db ();
	}
      else
	{
	  from_files = cygheap->pg.nss_pwd_files ();
	  from_db = cygheap->pg.nss_pwd_db ();
	}
    }
  else
    {
      /* This case is when called from mkpasswd/mkgroup via cygwin_internal. */
      enums = _enums;
      enum_tdoms = _enum_tdoms;
      from_files = false;
      from_db = true;
    }
  state = from_cache;
}

void *
pg_ent::getent (void)
{
  void *entry;

  switch (state)
    {
    case rewound:
      state = from_cache;
      /*FALLTHRU*/
    case from_cache:
      if (nss_db_enum_caches ()
	  && (entry = enumerate_caches ()))
	return entry;
      state = from_file;
      /*FALLTHRU*/
    case from_file:
      if (from_files
	  && nss_db_enum_files ()
	  && (entry = enumerate_file ()))
	return entry;
      state = from_builtin;
      /*FALLTHRU*/
    case from_builtin:
      if (from_db
	  && nss_db_enum_builtin ()
	  && (entry = enumerate_builtin ()))
	return entry;
      state = from_local;
      /*FALLTHRU*/
    case from_local:
      if (from_db
	  && nss_db_enum_local ()
	  && (!cygheap->dom.member_machine ()
	      || !nss_db_enum_primary ())
	  && (entry = enumerate_local ()))
	return entry;
      state = from_sam;
      /*FALLTHRU*/
    case from_sam:
      if (from_db
	  && nss_db_enum_local ()
	  /* Domain controller?  If so, sam and ad are one and the same
	     and "local ad" would list all domain accounts twice without
	     this test. */
	  && (cygheap->dom.account_flat_name ()[0] != L'@@'
	      || !nss_db_enum_primary ())
	  && (entry = enumerate_sam ()))
	return entry;
      state = from_ad;
      /*FALLTHRU*/
    case from_ad:
      if (cygheap->dom.member_machine ()
	  && from_db
	  && (entry = enumerate_ad ()))
	return entry;
      state = finished;
      /*FALLTHRU*/
    case finished:
      break;
    }
  return NULL;
}

void
pg_ent::endent (bool _group)
{
  if (buf)
    {
      if (state == from_file)
	free (buf);
      else if (state == from_local || state == from_sam)
      	NetApiBufferFree (buf);
      buf = NULL;
    }
  if (!pg.curr_lines)
    {
      if ((group = _group))
	{
	  pg.init_grp ();
	  pg.pwdgrp_buf = (void *) &grp;
	}
      else
	{
	  pg.init_pwd ();
	  pg.pwdgrp_buf = (void *) &pwd;
	}
      pg.max_lines = 1;
    }
  else
    clear_cache ();
  cldap.close ();
  rl.close ();
  cnt = max = resume = 0;
  enums = 0;
  enum_tdoms = NULL;
  state = rewound;
}

void *
pg_ent::enumerate_file ()
{
  void *entry;

  if (!cnt)
    {
      pwdgrp &prf = group ? cygheap->pg.grp_cache.file
			  : cygheap->pg.pwd_cache.file;
      if (prf.check_file ())
	{
	  if (!buf)
	    buf = (char *) malloc (NT_MAX_PATH);
	  if (buf
	      && !rl.init (prf.file_attr (), buf, NT_MAX_PATH))
	    {
	      free (buf);
	      buf = NULL;
	    }
	}
    }
  ++cnt;
  if ((entry = pg.add_account_post_fetch (rl.gets (), false)))
    return entry;
  rl.close ();
  free (buf);
  buf = NULL;
  cnt = max = resume = 0;
  return NULL;
}

void *
pg_ent::enumerate_builtin ()
{
  static cygpsid *pwd_builtins[] = {
    &well_known_system_sid,
    &well_known_local_service_sid,
    &well_known_network_service_sid,
    &well_known_admins_sid,
    &trusted_installer_sid,
    NULL
  };
  static cygpsid *grp_builtins[] = {
    &well_known_system_sid,
    &trusted_installer_sid,
    NULL
  };

  cygpsid **builtins = group ? grp_builtins : pwd_builtins;
  if (!builtins[cnt])
    {
      cnt = max = resume = 0;
      return NULL;
    }
  cygsid sid (*builtins[cnt++]);
  fetch_user_arg_t arg;
  arg.type = SID_arg;
  arg.sid = &sid;
  char *line = pg.fetch_account_from_windows (arg);
  return pg.add_account_post_fetch (line, false);
} 

void *
pg_ent::enumerate_sam ()
{
  while (true)
    {
      if (!cnt)
	{
	  DWORD total;
	  NET_API_STATUS ret;

	  if (buf)
	    {
	      NetApiBufferFree (buf);
	      buf = NULL;
	    }
	  if (resume == ULONG_MAX)
	    ret = ERROR_NO_MORE_ITEMS;
	  else if (group)
	    ret = NetGroupEnum (NULL, 2, (PBYTE *) &buf, MAX_PREFERRED_LENGTH,
				&max, &total, &resume);
	  else
	    ret = NetUserEnum (NULL, 20, FILTER_NORMAL_ACCOUNT, (PBYTE *) &buf,
			       MAX_PREFERRED_LENGTH, &max, &total,
			       (PDWORD) &resume);
	  if (ret == NERR_Success)
	    resume = ULONG_MAX;
	  else if (ret != ERROR_MORE_DATA)
	    {
	      cnt = max = resume = 0;
	      return NULL;
	    }
	}
      while (cnt < max)
	{
	  cygsid sid (cygheap->dom.account_sid ());
	  sid_sub_auth (sid, sid_sub_auth_count (sid)) = 
	    group ? ((PGROUP_INFO_2) buf)[cnt].grpi2_group_id
		  : ((PUSER_INFO_20) buf)[cnt].usri20_user_id;
	  ++cnt;
	  ++sid_sub_auth_count (sid);
	  fetch_user_arg_t arg;
	  arg.type = SID_arg;
	  arg.sid = &sid;
	  char *line = pg.fetch_account_from_windows (arg);
	  if (line)
	    return pg.add_account_post_fetch (line, false);
	}
      cnt = 0;
    }
}

void *
pg_ent::enumerate_ad ()
{
  while (true)
    {
      if (!cnt)
	{
	  PDS_DOMAIN_TRUSTSW td;

	  if (!resume)
	    {
	      ++resume;
	      if (!nss_db_enum_primary ()
		  || cldap.enumerate_ad_accounts (NULL, group) != NO_ERROR)
		continue;
	      RtlInitUnicodeString (&dom, cygheap->dom.primary_flat_name ());
	    }
	  else if ((td = cygheap->dom.trusted_domain (resume - 1)))
	    {
	      ++resume;
	      /* Ignore primary domain in list of trusted domains only if all
		 trusted domains are enumerated anyway.  This handles an
		 annoying backward compatibility problem in mkpasswd/mkgroup.
		 Without this test, `mkpasswd -d PRIMARY_DOMAIN' wouldn't
		 work as expected. */
	      if (((enums & ENUM_TDOMS_ALL) && td->Flags & DS_DOMAIN_PRIMARY)
		  || !td->DomainSid
		  || (!nss_db_enum_tdom (td->NetbiosDomainName)
		      && !nss_db_enum_tdom (td->DnsDomainName))
		      || cldap.enumerate_ad_accounts (td->DnsDomainName, group)
			 != NO_ERROR)
		continue;
	      RtlInitUnicodeString (&dom, td->NetbiosDomainName);
	    }
	  else
	    {
	      cldap.close ();
	      return NULL;
	    }
	}
      ++cnt;
      cygsid sid;
      int ret = cldap.next_account (sid);
      if (ret == NO_ERROR)
	{
	  fetch_acc_t full;
	  fetch_user_arg_t arg;
	  UNICODE_STRING name;

	  arg.type = FULL_acc_arg;
	  arg.full_acc = &full;
	  full.sid = sid;
	  RtlInitUnicodeString (&name,
				cldap.get_string_attribute (L"sAMAccountName"));
	  full.name = &name;
	  full.dom = &dom;
	  if (sid_sub_auth (sid, 0) == SECURITY_BUILTIN_DOMAIN_RID)
	    full.acc_type = SidTypeAlias;
	  else
	    full.acc_type = group ? SidTypeGroup : SidTypeUser;
	  char *line = pg.fetch_account_from_windows (arg, &cldap);
	  if (line)
	    return pg.add_account_post_fetch (line, false);
	  ret = EIO;
	}
      if (ret != ENMFILE)
	{
	  cldap.close ();
	  set_errno (ret);
	  return NULL;
	}
      cnt = 0;
    }
}

void *
pw_ent::enumerate_caches ()
{
  switch (max)
    {
    case 0:
      if (cygheap->pg.nss_cygserver_caching ())
	{
	  pwdgrp &prc = cygheap->pg.pwd_cache.cygserver;
	  if (cnt < prc.cached_users ())
	    return &prc.passwd ()[cnt++].p;
	}
      cnt = 0;
      max = 1;
      /*FALLTHRU*/
    case 1:
      if (from_files)
	{
	  pwdgrp &prf = cygheap->pg.pwd_cache.file;
	  prf.check_file ();
	  if (cnt < prf.cached_users ())
	    return &prf.passwd ()[cnt++].p;
	}
      cnt = 0;
      max = 2;
      /*FALLTHRU*/
    default:
      if (from_db)
	{
	  pwdgrp &prw = cygheap->pg.pwd_cache.win;
	  if (cnt < prw.cached_users ())
	    return &prw.passwd ()[cnt++].p;
	}
      break;
    }
  cnt = max = 0;
  return NULL;
}

void *
pw_ent::enumerate_local ()
{
  return NULL;
}

struct passwd *
pw_ent::getpwent (void)
{
  if (state == rewound)
    setent (false);
  else
    clear_cache ();
  return (struct passwd *) getent ();
}

extern "C" void
setpwent ()
{
  pwent.setpwent ();
}

extern "C" struct passwd *
getpwent (void)
{
  return pwent.getpwent ();
}

extern "C" void
endpwent (void)
{
  pwent.endpwent ();
}

/* *_filtered functions are called from mkpasswd */
void *
setpwent_filtered (int enums, PCWSTR enum_tdoms)
{
  pw_ent *pw = new pw_ent;
  if (pw)
    pw->setpwent (enums, enum_tdoms);
  return (void *) pw;
}

void *
getpwent_filtered (void *pw)
{
  return (void *) ((pw_ent *) pw)->getpwent ();
}

void
endpwent_filtered (void *pw)
{
  ((pw_ent *) pw)->endpwent ();
}

#ifndef __x86_64__
extern "C" struct passwd *
getpwduid (__uid16_t)
{
  return NULL;
}
#endif

extern "C" int
setpassent (int)
{
  return 0;
}

static void
_getpass_close_fd (void *arg)
{
  if (arg)
    fclose ((FILE *) arg);
}

extern "C" char *
getpass (const char * prompt)
{
  char *pass = _my_tls.locals.pass;
  struct termios ti, newti;
  bool tc_set = false;

  /* Try to use controlling tty in the first place.  Use stdin and stderr
     only as fallback. */
  FILE *in = stdin, *err = stderr;
  FILE *tty = fopen ("/dev/tty", "w+b");
  pthread_cleanup_push  (_getpass_close_fd, tty);
  if (tty)
    {
      /* Set close-on-exec for obvious reasons. */
      fcntl (fileno (tty), F_SETFD, fcntl (fileno (tty), F_GETFD) | FD_CLOEXEC);
      in = err = tty;
    }

  /* Make sure to notice if stdin is closed. */
  if (fileno (in) >= 0)
    {
      flockfile (in);
      /* Change tty attributes if possible. */
      if (!tcgetattr (fileno (in), &ti))
	{
	  newti = ti;
	  newti.c_lflag &= ~(ECHO | ISIG); /* No echo, no signal handling. */
	  if (!tcsetattr (fileno (in), TCSANOW, &newti))
	    tc_set = true;
	}
      fputs (prompt, err);
      fflush (err);
      fgets (pass, _PASSWORD_LEN, in);
      fprintf (err, "\n");
      if (tc_set)
	tcsetattr (fileno (in), TCSANOW, &ti);
      funlockfile (in);
      char *crlf = strpbrk (pass, "\r\n");
      if (crlf)
	*crlf = '\0';
    }
  pthread_cleanup_pop (1);
  return pass;
}
@


1.112
log
@	* passwd.cc (pg_ent::enumerate_ad): Revert to simply skipping a domain
	if opening the connection to the domain fails.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2013, 2014 Red Hat, Inc.
d603 1
d620 1
d633 1
d635 13
a647 2
	  arg.type = SID_arg;
	  arg.sid = &sid;
@


1.111
log
@	* autoload.cc (ldap_search_sW): Replace ldap_search_stW.
	(LdapMapErrorToWin32): Import.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Accommodate
	change to cyg_ldap::open.
	* ldap.cc (CYG_LDAP_TIMEOUT): Remove.
	(CYG_LDAP_ENUM_TIMEOUT): Remove.
	(def_tv): Remove.
	(enum_tv): Remove.
	(cyg_ldap::map_ldaperr_to_errno): New method to map LDAP error codes to
	POSIX errno codes.  Explicitly map LDAP_NO_RESULTS_RETURNED to ENMFILE.
	(cyg_ldap::wait): Ditto.
	(struct cyg_ldap_init): New struct.
	(cyg_ldap::connect_ssl): Return ULONG.  Drop setting LDAP_OPT_TIMELIMIT.
	Add call to ldap_search_sW to fetch root DSE.
	(cyg_ldap::connect_non_ssl): Ditto.
	(ldap_init_thr): New static thread function.
	(cyg_ldap::connect): New method to call connect_ssl/connect_non_ssl in
	an interruptible cygthread.
	(struct cyg_ldap_search): New struct.
	(cyg_ldap::search_s): New method to perform generic synchronous search.
	(ldap_search_thr): New static thread function.
	(cyg_ldap::search): New method to call search_s in an interruptible
	cygthread.
	(struct cyg_ldap_next_page): New struct.
	(cyg_ldap::next_page_s): New method to perform generic synchronous
	paged search.
	(ldap_next_page_thr): New static thread function.
	(cyg_ldap::next_page): New method to call next_page_s in an
	interruptible cygthread.
	(cyg_ldap::open): Return POSIX errno.  Call connect method.
	(cyg_ldap::fetch_ad_account): Call search method rather than
	ldap_search_stW.
	(cyg_ldap::enumerate_ad_accounts): Return POSIX errno.  Use infinite
	timeout in call to ldap_search_init_pageW.
	(cyg_ldap::next_account): Return POSIX errno.  Call next_page method
	rather than ldap_get_next_page_s.
	(cyg_ldap::fetch_posix_offset_for_domain): Call search method rather
	than ldap_search_stW.
	(cyg_ldap::fetch_unix_sid_from_ad): Ditto.
	(cyg_ldap::fetch_unix_name_from_rfc2307): Ditto.
	* ldap.h (class cyg_ldap): Accommodate aforementioned changes.
	* passwd.cc (pg_ent::enumerate_ad): Ditto.  Break search if one of
	cyg_ldap::enumerate_ad_accounts or cldap.next_account returns with
	an error code other than ENMFILE.
	* sec_helper.cc (cygpsid::get_id): Accommodate change to cyg_ldap::open.
	* uinfo.cc (fetch_posix_offset): Ditto.
@
text
@a595 1
	  int ret;
d600 2
a601 1
	      if (!nss_db_enum_primary ())
a602 6
	      if ((ret = cldap.enumerate_ad_accounts (NULL, group)) != NO_ERROR)
		{
		  cldap.close ();
		  set_errno (ret);
		  return NULL;
		}
d615 3
a617 1
		      && !nss_db_enum_tdom (td->DnsDomainName)))
a618 7
	      if ((ret = cldap.enumerate_ad_accounts (td->DnsDomainName, group))
		  != NO_ERROR)
		{
		  cldap.close ();
		  set_errno (ret);
		  return NULL;
		}
@


1.110
log
@	* passwd.cc (pwdgrp::parse_passwd): Fix an off by one computing the
	buffer len.  Add comment.
	* uinfo.cc (internal_getlogin): Fix typo in comment.
@
text
@d596 1
d601 1
a601 2
	      if (!nss_db_enum_primary ()
		  || !cldap.enumerate_ad_accounts (NULL, group))
d603 6
d621 1
a621 2
		      && !nss_db_enum_tdom (td->DnsDomainName))
		  || !cldap.enumerate_ad_accounts (td->DnsDomainName, group))
d623 7
d639 2
a640 1
      if (cldap.next_account (sid))
d648 7
@


1.109
log
@	* grp.cc (pwdgrp::parse_group): Set grp.len.  Drop generating any
	gr_mem entries.
	(getgrgid_r): Don't try to copy gr_mem entries.  Always set gr_mem
	to an empty list.
	(getgrnam_r): Ditto.
	(app_gr): New static struct to store group data propagated to the
	calling application via getgrgid/getgrnam.
	(getgr_cp): Fill app_gr and return pointer to app_gr.g.
	(getgrgid32): Call getgr_cp.
	(getgrnam32): Ditto.
	* passwd.cc (pwdgrp::parse_passwd): Set res.len.
	(app_pw): New static struct to store passwd data propagated to the
	calling application via getpwuid/getpwnam.
	(getpw_cp): Fill app_pw and return pointer to app_pw.p.
	(getpwuid32): Cal getpw_cp.
	(getpwnam): Ditto.
	* pwdgrp.h (struct pg_pwd): Add len member.
	(struct pg_grp): Ditto.
@
text
@d44 3
a46 1
  res.len = lptr - res.p.pw_name;
@


1.108
log
@	* fhandler_dsp.cc (fhandler_dev_dsp::fixup_after_fork): Actually call
	_fixup_after_fork rather than looping forever.
	(fhandler_dev_dsp::fixup_after_exec): Ditto.
@
text
@d44 1
d184 35
d224 1
a224 1
  return temppw;
d285 1
a285 1
  return temppw;
@


1.107
log
@	* cygheap.h (enum cygheap_pwdgrp::cache_t): Remove.
	(cygheap_pwdgrp::caching): Convert to bool.
	(cygheap_pwdgrp::pwd_cache): Add cygserver member.
	(cygheap_pwdgrp::grp_cache): Ditto.
	(cygheap_pwdgrp::nss_db_caching): Drop.
	(cygheap_pwdgrp::nss_db_full_caching): Drop.
	(cygheap_pwdgrp::nss_cygserver_caching): New method.
	(cygheap_pwdgrp::nss_disable_cygserver_caching): New method.
	* cygserver.h (client_request::request_code_t): Add
	CYGSERVER_REQUEST_PWDGRP.
	* cygserver_pwdgrp.h: New file.
	* cygtls.h (struct _local_storage): Remove pwbuf and grbuf members.
	* grp.cc (pwdgrp::prep_tls_grbuf): Drop.
	(internal_getgrsid): Handle cygserver caching and rearrange to check
	the caches first.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(gr_ent::enumerate_caches): Handle cygserver cache.
	* passwd.cc (pwdgrp::prep_tls_pwbuf): Drop.
	(internal_getpwsid): Handle cygserver caching and rearrange to check
	the caches first.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(pw_ent::enumerate_caches): Handle cygserver cache.
	* pwdgrp.h (pwdgrp::add_account_from_cygserver): New method declaration.
	(pwdgrp::fetch_account_from_cygserver): New method declaration.
	(pwdgrp::prep_tls_pwbuf): Drop declaration.
	(pwdgrp::prep_tls_grbuf): Drop declaration.
	(pwdgrp::add_user_from_cygserver): New inline methods.
	(pwdgrp::add_group_from_cygserver): New inline methods.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Regenerate.
	* uinfo.cc (internal_getlogin): Call internal_getgroups if cygserver
	caching is not available.
	(cygheap_pwdgrp::init): Initialize pwd_cache.cygserver and
	grp_cache.cygserver.  Set caching to true.
	(cygheap_pwdgrp::nss_init_line): Drop db_cache handling entirely.
	(pwdgrp::add_account_from_windows): Drop no caching handling.
	(client_request_pwdgrp::client_request_pwdgrp): New method.
	(pwdgrp::fetch_account_from_cygserver): New method.
	(pwdgrp::add_account_from_cygserver): New method.

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Fix formatting.
	* include/sys/cygwin.h: Ditto.
@
text
@d569 6
a574 1
	      if ((td->Flags & DS_DOMAIN_PRIMARY)
@


1.106
log
@	* pwdgrp.h (pwdgrp::is_passwd): New inline method.
	(pwdgrp::is_group): New inline method.
	(add_account_from_windows): Drop group argument from declaration.
	(fetch_account_from_windows): Ditto.
	(check_file): Ditto.
	(add_user_from_windows): Call add_account_from_windows accordingly.
	(add_group_from_windows): Ditto.
	* uinfo.cc (pwdgrp::add_account_from_windows): Drop group argument.
	Use is_group method instead.
	(pwdgrp::check_file): Ditto.
	(pwdgrp::fetch_account_from_windows): Ditto.
	* grp.cc: Accommodate aforementioned changes.
	* passwd.cc: Ditto.
@
text
@a53 21
pwdgrp *
pwdgrp::prep_tls_pwbuf ()
{
  if (!_my_tls.locals.pwbuf)
    {
      _my_tls.locals.pwbuf = ccalloc_abort (HEAP_BUF, 1,
					    sizeof (pwdgrp) + sizeof (pg_pwd));
      pwdgrp *pw = (pwdgrp *) _my_tls.locals.pwbuf;
      pw->init_pwd ();
      pw->pwdgrp_buf = (void *) (pw + 1);
      pw->max_lines = 1;
    }
  pwdgrp *pw = (pwdgrp *) _my_tls.locals.pwbuf;
  if (pw->curr_lines)
    {
      cfree (pw->passwd ()[0].p.pw_name);
      pw->curr_lines = 0;
    }
  return pw;
}

d88 14
a104 2
      if ((ret = cygheap->pg.pwd_cache.file.find_user (sid)))
	return ret;
d109 1
a109 5
    {
      if ((ret = cygheap->pg.pwd_cache.win.find_user (sid)))
	return ret;
      return cygheap->pg.pwd_cache.win.add_user_from_windows (sid, pldap);
    }
d127 14
a143 2
      if ((ret = cygheap->pg.pwd_cache.file.find_user (name)))
	return ret;
d148 1
a148 5
    {
      if ((ret = cygheap->pg.pwd_cache.win.find_user (name)))
	return ret;
      return cygheap->pg.pwd_cache.win.add_user_from_windows (name, pldap);
    }
d158 14
a174 2
      if ((ret = cygheap->pg.pwd_cache.file.find_user (uid)))
	return ret;
d178 2
a179 8
  if (cygheap->pg.nss_pwd_db ())
    {
      if ((ret = cygheap->pg.pwd_cache.win.find_user (uid)))
	return ret;
      return cygheap->pg.pwd_cache.win.add_user_from_windows (uid, pldap);
    }
  else if (uid == ILLEGAL_UID)
    return cygheap->pg.pwd_cache.win.add_user_from_windows (uid);
d600 1
a600 1
  if (!max && from_files)
d602 7
a608 4
      pwdgrp &prf = cygheap->pg.pwd_cache.file;
      prf.check_file ();
      if (cnt < prf.cached_users ())
        return &prf.passwd ()[cnt++].p;
d611 20
a630 6
    }
  if (from_db && cygheap->pg.nss_db_caching ())
    {
      pwdgrp &prw = cygheap->pg.pwd_cache.win;
      if (cnt < prw.cached_users ())
        return &prw.passwd ()[cnt++].p;
@


1.105
log
@	* passwd.cc (pg_ent::enumerate_builtin): Convert pwd_builtins and
	grp_builtins to array of cygpsid pointers.  Replace SID strings with
	pointers to well known SIDs.
	* sec_helper.cc (well_known_local_service_sid): Define.
	(well_known_network_service_sid): Define.
	(trusted_installer_sid): Define.
	* security.h (well_known_local_service_sid): Declare.
	(well_known_network_service_sid): Declare.
	(trusted_installer_sid): Declare.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Throughout set acc_type
	to SidTypeUnknown if LookupAccountXXX function failed.  Create
	simplified passwd entry for non-user accounts, except for LocalSystem.
	Add comment.
@
text
@d111 1
a111 1
      cygheap->pg.pwd_cache.file.check_file (false);
d142 1
a142 1
      cygheap->pg.pwd_cache.file.check_file (false);
d165 1
a165 1
      cygheap->pg.pwd_cache.file.check_file (false);
d445 1
a445 1
      if (prf.check_file (group))
d494 1
a494 1
  char *line = pg.fetch_account_from_windows (arg, group);
d541 1
a541 1
	  char *line = pg.fetch_account_from_windows (arg, group);
d588 1
a588 1
	  char *line = pg.fetch_account_from_windows (arg, group, &cldap);
d602 1
a602 1
      prf.check_file (false);
@


1.104
log
@	* ldap.cc (rediscover_thread): Remove.
	(cyg_ldap::open): Remove code to rediscover DC.  It just won't do the
	right thing.
	(cyg_ldap::enumerate_ad_accounts): Change to be self-sufficient (no
	explicit open call required).  Enumerate on a DC of the domain itself
	instead of relying on delegation.  Remove ill-advised code trying to
	generate rootdse from domain name.
	* passwd.cc (pg_ent::enumerate_ad): Drop explicit call to
	cyg_ldap::open.
@
text
@d470 6
a475 12
  static const char *pwd_builtins[] = {
    /* SYSTEM */
    "S-1-5-18",
    /* LocalService */
    "S-1-5-19",
    /* NetworkService */
    "S-1-5-20",
    /* Administrators */
    "S-1-5-32-544",
    /* TrustedInstaller */
    "S-1-5-80-956008885-3418522649-1831038044-1853292631-2271478464",
    /* The end */
d478 3
a480 6
  static const char *grp_builtins[] = {
    /* SYSTEM */
    "S-1-5-18",
    /* TrustedInstaller */
    "S-1-5-80-956008885-3418522649-1831038044-1853292631-2271478464",
    /* The end */
d484 1
a484 1
  const char **builtins = group ? grp_builtins : pwd_builtins;
d490 1
a490 1
  cygsid sid (builtins[cnt++]);
@


1.103
log
@	* autoload.cc (CheckTokenMembership): Import.
	* external.cc (cygwin_internal): Call get_uid/get_gid instead of get_id.
	* grp.cc (internal_getgrsid): Take additional cyg_ldap pointer.
	Forward to pwdgrp::add_group_from_windows.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(gr_ent::enumerate_local): Drop ugid_caching bool from call to
	pwdgrp::fetch_account_from_windows.
	(getgroups32): Rename from internal_getgroups and drop getgroups32 stub.
	Drop srchsid parameter and code handling it.  Add local cyg_ldap
	instance and forward to internal_getgrXXX.
	(getgroups): Call getgroups32.
	(get_groups): Add local cyg_ldap instance and forward to
	internal_getgrXXX.
	(getgrouplist): Ditto.
	(setgroups32): Ditto.
	* ldap.cc (cyg_ldap::open): Don't call close.  Return true if connection
	is already open.
	(cyg_ldap::remap_uid): Forward this to internal_getpwsid.
	(cyg_ldap::remap_gid): Forward this to internal_getgrsid.
	* passwd.cc (internal_getpwsid): Take additional cyg_ldap pointer.
	Forward to pwdgrp::add_user_from_windows.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(pg_ent::enumerate_builtin): Drop ugid_caching bool from call to
	pwdgrp::fetch_account_from_windows.
	(pg_ent::enumerate_sam): Ditto.
	(pg_ent::enumerate_ad): Ditto.  Forward local cldap instead.
	* pwdgrp.h (internal_getpwsid): Align declaration to above change.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(internal_getgrsid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgroups): Drop declaration.
	(pwdgrp::add_account_from_windows): Align declaration to below change.
	(pwdgrp::add_user_from_windows): Ditto.
	(pwdgrp::add_group_from_windows): Ditto.
	* sec_acl.cc (setacl): Add local cyg_ldap instance and forward to
	internal_getpwuid and internal_getgrgid.
	(getacl): Add local cyg_ldap instance and forward to cygpsid::get_id.
	(aclfromtext32): Add local cyg_ldap instance and forward to
	internal_getpwnam and internal_getgrnam.
	* sec_helper.cc (cygpsid::get_id): Take additional cyg_ldap pointer.
	Forward to internal_getgrsid and internal_getpwsid.
	(get_sids_info): Drop ldap_open.  Forward local cldap to
	internal_getpwsid and internal_getgrXXX.  Call CheckTokenMembership
	rather than internal_getgroups.
	* security.h (cygpsid::get_id): Add cyg_ldap pointer, drop default
	parameter.
	(cygpsid::get_uid): Add cyg_ldap pointer.  Call get_id accordingly.
	(cygpsid::get_gid): Ditto.
	* uinfo.cc (internal_getlogin): Add local cyg_ldap instance and forward
	to internal_getpwXXX and internal_getgrXXX calls.
	(pwdgrp::add_account_from_windows): Take additional cyg_ldap pointer.
	Forward to pwdgrp::fetch_account_from_windows.
	(fetch_posix_offset): Drop ldap_open argument and handling.  Get
	cyg_ldap instance as pointer.
	(pwdgrp::fetch_account_from_windows): Take additional cyg_ldap pointer.
	Use it if it's not NULL, local instance otherwise.  Drop ldap_open.
	Drop fetching extended group arguments from AD for speed.
@
text
@a568 2
	      if (!cldap.open (NULL))
		return NULL;
@


1.102
log
@	* external.cc (cygwin_internal): Add cases for CW_GETNSSSEP,
	CW_GETPWSID and CW_GETGRSID.
	* grp.cc (internal_getgrsid_from_db): New function.
	* passwd.cc (internal_getpwsid_from_db): New function.
	(pg_ent::setent): Add special case for call from mkpasswd/mkgroup.
	* pwdgrp.h (internal_getpwsid_from_db): Declare.
	(internal_getgrsid_from_db): Declare.
	(enum nss_enum_t): Move to include/sys/cygwin.h.
	(class pg_ent): Add comment.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Fix typo in comment.
	Change "UNIX" to "Unix" in domain name.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_GETNSSSEP,
	CW_GETPWSID and CW_GETGRSID.
	(enum nss_enum_t): Define here.
@
text
@d104 1
a104 1
internal_getpwsid (cygpsid &sid)
d121 1
a121 1
      return cygheap->pg.pwd_cache.win.add_user_from_windows (sid);
d135 1
a135 1
internal_getpwnam (const char *name)
d152 1
a152 1
      return cygheap->pg.pwd_cache.win.add_user_from_windows (name);
d158 1
a158 1
internal_getpwuid (uid_t uid)
d175 1
a175 1
      return cygheap->pg.pwd_cache.win.add_user_from_windows (uid);
d503 1
a503 1
  char *line = pg.fetch_account_from_windows (arg, group, false);
d550 1
a550 1
	  char *line = pg.fetch_account_from_windows (arg, group, false);
d599 1
a599 1
	  char *line = pg.fetch_account_from_windows (arg, group, false);
@


1.101
log
@	* pwdgrp.h (pwdgrp::fetch_account_from_windows): Add bool parameter
	to declaration, set to true by default.
	* uinfo.cc (pwdgrp::fetch_account_from_windows): Add bool parameter
	"ugid_caching".  Only add account to ugid_cache if set to true.
	* grp.cc (gr_ent::enumerate_local): Call fetch_account_from_windows
	with ugid_caching parameter set to false.
	* passwd.cc (pg_ent::enumerate_builtin): Ditto.
	(pg_ent::enumerate_sam): Ditto.
	(pg_ent::enumerate_ad): Ditto.
@
text
@d126 8
d311 2
d315 10
d328 1
d331 2
a332 10
    }
  if (_group)
    {
      from_files = cygheap->pg.nss_grp_files ();
      from_db = cygheap->pg.nss_grp_db ();
    }
  else
    {
      from_files = cygheap->pg.nss_pwd_files ();
      from_db = cygheap->pg.nss_pwd_db ();
@


1.100
log
@	* passwd.cc (pg_ent::setent): Initialize cygheap domain info.
	* sec_auth.cc (get_logon_server): Ditto.
@
text
@d490 1
a490 1
  char *line = pg.fetch_account_from_windows (arg, group);
d537 1
a537 1
	  char *line = pg.fetch_account_from_windows (arg, group);
d586 1
a586 1
	  char *line = pg.fetch_account_from_windows (arg, group);
@


1.99
log
@	* external.cc (cygwin_internal): Handle new CW_SETENT, CW_GETENT and
	CW_ENDENT info types.
	* grp.cc (setgrent_filtered): New function, called from cygwin_internal.
	(getgrent_filtered): Ditto.
	(endgrent_filtered): Ditto.
	* passwd.cc (pg_ent::setent): Set state explicitely to from_cache.
	(pg_ent::getent): Handle the fact that a DC has no SAM and enumerating
	local accounts is equivalent to enumerating domain accounts.
	(setpwent_filtered): New function, called from cygwin_internal.
	(getpwent_filtered): Ditto.
	(endpwent_filtered): Ditto.
	* pwdgrp.h (setpwent_filtered): Declare.
	(getgrent_filtered): Ditto.
	(endgrent_filtered): Ditto.
	(setpwent_filtered): Ditto.
	(getpwent_filtered): Ditto.
	(endpwent_filtered): Ditto.
	* include/sys/cygwin.h (cygwin_getinfo_types): Add CW_SETENT, CW_GETENT,
	and CW_ENDENT.
@
text
@d299 1
@


1.98
log
@	* autoload.cc (ldap_abandon): Import.
	(ldap_result): Import.
	(ldap_searchW): Import.
	(NetGroupEnum): Import.
	(NetLocalGroupEnum): Import.
	(NetUserEnum): Import.
	* cygheap.h (class cygheap_pwdgrp): Add members enums and enum_tdoms.
	(cygheap_pwdgrp::nss_db_enums): New inline method.
	(cygheap_pwdgrp::nss_db_enum_tdoms): Ditto.
	* cygtls.h (struct _local_storage): Drop unused members pw_pos and
	grp_pos.
	* grp.cc (grent): New static variable of class gr_ent.
	(gr_ent::enumerate_caches): New method.
	(gr_ent::enumerate_local): New method.
	(gr_ent::getgrent): New method.
	(setgrent): Call gr_ent method.
	(getgrent32): Ditto.
	(endgrent): Ditto.
	* ldap.cc (sid_attr): Rename from nfs_attr.
	(cyg_ldap::close): Abandon still running asynchronous search.
	(cyg_ldap::fetch_ad_account): Reduce filter buffer size.
	(cyg_ldap::enumerate_ad_accounts): New method.
	(cyg_ldap::next_account): New method.
	(cyg_ldap::fetch_posix_offset_for_domain): Reduce filter buffer size.
	(cyg_ldap::fetch_unix_sid_from_ad): Ditto.  Fix return value in case
	no value has been read.
	(cyg_ldap::fetch_unix_name_from_rfc2307): Reduce filter buffer size.
	* ldap.h (class cyg_ldap): Add msg_id member.
	(cyg_ldap::enumerate_ad_accounts): Declare.
	(cyg_ldap::next_account): Declare:
	* passwd.cc (pwent): New static variable of class pw_ent.
	(pg_ent::clear_cache): New method.
	(pg_ent::setent): New method.
	(pg_ent::getent): New method.
	(pg_ent::endent): New method.
	(pg_ent::enumerate_file): New method.
	(pg_ent::enumerate_builtin): New method.
	(pg_ent::enumerate_sam): New method.
	(pg_ent::enumerate_ad): New method.
	(pw_ent::enumerate_caches): New method.
	(pw_ent::enumerate_local): New method.
	(pw_ent::getpwent): New method.
	(setpwent): Call pw_ent method.
	(getpwent): Ditto.
	(endpwent): Ditto.
	* pwdgrp.h (class pwdgrp): Define pg_ent, pw_ent and gr_ent as friend
	classes.
	(pwdgrp::add_account_post_fetch): Declare with extra bool parameter.
	(pwdgrp::file_attr): New inline method.
	(enum nss_enum_t): Define.
	(class pg_ent): Define.
	(class pw_ent): Define.
	(class gr_ent): Define.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (cygheap_pwdgrp::init): Initialize enums and enum_tdoms.
	(cygheap_pwdgrp::nss_init_line): Fix typo in preceeding comment.
	Handle new "db_enum" keyword.
	(pwdgrp::add_account_post_fetch): Take additional `bool lock' parameter
	and acquire pglock before adding element to array if lock is true.
	(pwdgrp::add_account_from_file): Call add_account_post_fetch with lock
	set to true.
	(pwdgrp::add_account_from_windows): Ditto in case of caching.
	(pwdgrp::fetch_account_from_windows): Handle builtin aliases only
	known to the domain controller.  Only call NetLocalGroupGetInfo for
	aliases.
@
text
@d320 1
d365 5
d649 22
@


1.97
log
@	Introduce reading passwd/group entries from SAM/AD.  Introduce
	/etc/nsswitch.conf file to configure it.
	* Makefile.in (DLL_OFILES): Add ldap.o.
	* autoload.cc: Import ldap functions from wldap32.dll.
	(DsEnumerateDomainTrustsW): Import.
	(NetGroupGetInfo): Import.
	* cygheap.h (class cygheap_domain_info): New class to keep global
	domain info.
	(class cygheap_pwdgrp): New class to keep passwd/group caches and
	configuration info from /etc/nssswitch.conf.
	(struct init_cygheap): Add cygheap_domain_info member "dom" and
	cygheap_pwdgrp member "pg".
	* cygtls.h (struct _local_storage): Remove unused member "res".
	Rearrange slightly, Add members pwbuf and grbuf to implement non-caching
	passwd/group fetching from SAM/AD.  Make pw_pos and pw_pos unsigned.
	* fhandler_disk_file.cc (fhandler_base::fstat_by_nfs_ea): Add RFC 2307
	uid/gid mapping.
	* fhandler_process.cc: Drop including pwdgrp.h.
	* fhandler_procsysvipc.cc: Ditto.
	* fhandler_registry.cc (fhandler_registry::fstat): Set key uid/gid
	to ILLEGAL_UID/ILLEGAL_GID rather than UNKNOWN_UID/UNKNOWN_GID.
	* grp.cc (group_buf): Drop.
	(gr): Drop.
	(pwdgrp::parse_group): Fill pg_grp.
	(pwdgrp::read_group): Remove.
	(pwdgrp::init_grp): New method.
	(pwdgrp::prep_tls_grbuf): New method.
	(pwdgrp::find_group): New methods.
	(internal_getgrsid): Convert to call new pwdgrp methods.
	(internal_getgrnam): Ditto.
	(internal_getgrgid): Ditto.
	(getgrgid_r): Drop 2nd parameter from internal_getgrgid call.
	(getgrgid32): Ditto.
	(getgrnam_r): Ditto for internal_getgrnam.
	(getgrnam32): Ditto.
	(getgrent32): Convert to call new pwdgrp methods.
	(internal_getgrent): Remove.
	(internal_getgroups): Simplify, especially drop calls to
	internal_getgrent.
	* ldap.cc: New file implementing cyg_ldap class for LDAP access to AD
	and RFC 2307 server.
	* ldap.h: New header, declaring cyg_ldap class.
	* passwd.cc (passwd_buf): Drop.
	(pr): Drop.
	(pwdgrp::parse_passwd): Fill pg_pwd.
	(pwdgrp::read_passwd): Remove.
	(pwdgrp::init_pwd): New method.
	(pwdgrp::prep_tls_pwbuf): New method.
	(find_user): New methods.
	(internal_getpwsid): Convert to call new pwdgrp methods.
	(internal_getpwnam): Ditto.
	(internal_getpwuid): Ditto.
	(getpwuid32): Drop 2nd parameter from internal_getpwuid call.
	(getpwuid_r): Ditto.
	(getpwnam): Ditto for internal_getpwnam.
	(getpwnam_r): Ditto.
	(getpwent): Convert to call new pwdgrp methods.
	* path.cc (class etc): Remove all methods.
	* path.h (class etc): Drop.
	* pinfo.cc (pinfo_basic::pinfo_basic): Set gid to ILLEGAL_GID rather
	than UNKNOWN_GID.
	(pinfo_init): Ditto.
	* pwdgrp.h (internal_getpwnam): Drop 2nd parameter from declaration.
	(internal_getpwuid): Ditto.
	(internal_getgrgid): Ditto.
	(internal_getgrnam): Ditto.
	(internal_getgrent): Drop declaration.
	(enum fetch_user_arg_type_t): New type.
	(struct fetch_user_arg_t): New type.
	(struct pg_pwd): New type.
	(struct pg_grp): New type.
	(class pwdgrp): Rework to provide functions for file and db requests
	and caching.
	(class ugid_cache_t): New class to provide RFC 2307 uid map caching.
	(ugid_cache): Declare.
	* sec_acl.cc: Drop including pwdgrp.h.
	* sec_auth.cc: Drop including dsgetdc.h and pwdgrp.h.
	(get_logon_server): Convert third parameter to ULONG flags argument
	to allow arbitrary flags values in DsGetDcNameW call and change calls
	to this function throughout.  Use cached account domain name rather
	than calling GetComputerNameW.
	(get_unix_group_sidlist): Remove.
	(get_server_groups): Drop call to get_unix_group_sidlist.
	(verify_token): Rework token group check without calling
	internal_getgrent.
	* sec_helper.cc (cygpsid::pstring): New methods, like string() but
	return pointer to end of string.
	(cygsid::getfromstr): Add wide character implementation.
	(get_sids_info): Add RFC 2307 uid/gid mapping for Samba shares.
	* security.cc: Drop including pwdgrp.h.
	* security.h (DEFAULT_UID): Remove.
	(UNKNOWN_UID): Remove.
	(UNKNOWN_GID): Remove.
	(uinfo_init): Move here from winsup.h.
	(ILLEGAL_UID): Ditto.
	(ILLEGAL_GID): Ditto.
	(UNIX_POSIX_OFFSET): Define.  Add lengthy comment.
	(UNIX_POSIX_MASK): Ditto.
	(MAP_UNIX_TO_CYGWIN_ID): Ditto.
	(ILLEGAL_UID16): Move here from winsup.h.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Ditto.
	(gid16togid32): Ditto.
	(sid_id_auth): New convenience macro for SID component access.
	(sid_sub_auth_count): Ditto.
	(sid_sub_auth): Ditto.
	(sid_sub_auth_rid): Ditto.
	(cygpsid::pstring): Declare.
	(cygsid::getfromstr): Declare wide character variant.
	(cygsid::operator=): Ditto.
	(cygsid::operator*=): Ditto.
	(get_logon_server): Change declaration according to source code.
	* setlsapwd.cc (setlsapwd): Drop 2nd parameter from internal_getpwnam
	call.
	* shared.cc (memory_init): Call cygheap->pg.init in first process.
	* syscalls.cc: Drop including pwdgrp.h.
	* tlsoffsets.h: Regenerate.
	* tlsoffsets64.h: Ditto.
	* uinfo.cc (internal_getlogin): Drop gratuitious internal_getpwuid
	call.  Fix debug output.  Overwrite user gid in border case of a
	missing passwd file while a group file exists.
	(pwdgrp::add_line): Allocate memory on cygheap.
	(pwdgrp::load): Remove.
	(ugid_cache): Define.
	(cygheap_pwdgrp::init): New method.
	(cygheap_pwdgrp::nss_init_line): New method.
	(cygheap_pwdgrp::_nss_init): New method.
	(cygheap_domain_info::init): New method.
	(logon_sid): Define.
	(get_logon_sid): New function.
	(pwdgrp::add_account_post_fetch): New method.
	(pwdgrp::add_account_from_file): New methods.
	(pwdgrp::add_account_from_windows): New methods.
	(pwdgrp::check_file): New method.
	(pwdgrp::fetch_account_from_line): New method.
	(pwdgrp::fetch_account_from_file): New method.
	(pwdgrp::fetch_account_from_windows): New method.
	* winsup.h: Move aforementioned macros and declarations to security.h.
@
text
@d13 1
d24 3
d282 307
a588 2
extern "C" struct passwd *
getpwent (void)
d590 1
a590 2
  pwdgrp &prf = cygheap->pg.pwd_cache.file;
  if (cygheap->pg.nss_pwd_files ())
d592 6
a597 3
      cygheap->pg.pwd_cache.file.check_file (false);
      if (_my_tls.locals.pw_pos < prf.cached_users ())
	return &prf.passwd ()[_my_tls.locals.pw_pos++].p;
d599 1
a599 1
  if ((cygheap->pg.nss_pwd_db ()) && cygheap->pg.nss_db_caching ())
d602 2
a603 2
      if (_my_tls.locals.pw_pos - prf.cached_users () < prw.cached_users ())
	return &prw.passwd ()[_my_tls.locals.pw_pos++ - prf.cached_users ()].p;
d605 1
d609 2
a610 3
#ifndef __x86_64__
extern "C" struct passwd *
getpwduid (__uid16_t)
d614 10
a623 1
#endif
d626 7
a632 1
setpwent (void)
d634 1
a634 1
  _my_tls.locals.pw_pos = 0;
d640 8
a647 1
  _my_tls.locals.pw_pos = 0;
d649 1
@


1.96
log
@update copyright
@
text
@a21 1
#include "pwdgrp.h"
a23 6
/* Read /etc/passwd only once for better performance.  This is done
   on the first call that needs information from it. */

passwd *passwd_buf;
static pwdgrp pr (passwd_buf);

d28 4
a31 4
  passwd &res = (*passwd_buf)[curr_lines];
  res.pw_name = next_str (':');
  res.pw_passwd = next_str (':');
  if (!next_num (res.pw_uid))
d33 1
a33 1
  if (!next_num (res.pw_gid))
d35 5
a39 4
  res.pw_comment = NULL;
  res.pw_gecos = next_str (':');
  res.pw_dir =  next_str (':');
  res.pw_shell = next_str (':');
a42 3
/* Read in /etc/passwd and save contents in the password cache.
   This sets pr to loaded or emulated so functions in this file can
   tell that /etc/passwd has been read in or will be emulated. */
d44 1
a44 1
pwdgrp::read_passwd ()
d46 3
a48 1
  load (L"\\etc\\passwd");
d50 11
a60 28
  char strbuf[128] = "";
  bool searchentry = true;
  struct passwd *pw;
  /* must be static */
  static char NO_COPY pretty_ls[] = "????????:*:-1:-1:::";

  add_line (pretty_ls);
  cygsid tu = cygheap->user.sid ();
  tu.string (strbuf);
  if (!user_shared->cb || myself->uid == ILLEGAL_UID)
    searchentry = !internal_getpwsid (tu);
  if (searchentry
      && (!(pw = internal_getpwnam (cygheap->user.name ()))
	  || !user_shared->cb
	  || (myself->uid != ILLEGAL_UID
	      && myself->uid != pw->pw_uid
	      && !internal_getpwuid (myself->uid))))
    {
      static char linebuf[1024];	// must be static and
					// should not be NO_COPY
      snprintf (linebuf, sizeof (linebuf), "%s:*:%u:%u:,%s:%s:/bin/sh",
		cygheap->user.name (),
		(!user_shared->cb || myself->uid == ILLEGAL_UID)
		? UNKNOWN_UID : myself->uid,
		!user_shared->cb ? UNKNOWN_GID : myself->gid,
		strbuf, getenv ("HOME") ?: "");
      debug_printf ("Completing /etc/passwd: %s", linebuf);
      add_line (linebuf);
d62 35
d102 1
a102 3
  struct passwd *pw;
  char *ptr1, *ptr2, *endptr;
  char sid_string[128] = {0,','};
d104 10
a113 3
  pr.refresh (false);

  if (sid.string (sid_string + 2))
d115 3
a117 10
      endptr = strchr (sid_string + 2, 0) - 1;
      for (int i = 0; i < pr.curr_lines; i++)
	{
	  pw = passwd_buf + i;
	  if (pw->pw_dir > pw->pw_gecos + 8)
	    for (ptr1 = endptr, ptr2 = pw->pw_dir - 2;
		 *ptr1 == *ptr2; ptr2--)
	      if (!*--ptr1)
		return pw;
	}
d123 1
a123 1
internal_getpwuid (uid_t uid, bool check)
d125 1
a125 1
  pr.refresh (check);
d127 15
a141 3
  for (int i = 0; i < pr.curr_lines; i++)
    if (uid == passwd_buf[i].pw_uid)
      return passwd_buf + i;
d146 1
a146 1
internal_getpwnam (const char *name, bool check)
d148 1
a148 1
  pr.refresh (check);
d150 17
a166 4
  for (int i = 0; i < pr.curr_lines; i++)
    /* on Windows NT user names are case-insensitive */
    if (strcasematch (name, passwd_buf[i].pw_name))
      return passwd_buf + i;
a169 1

d173 1
a173 1
  struct passwd *temppw = internal_getpwuid (uid, true);
d196 1
a196 1
  struct passwd *temppw = internal_getpwuid (uid, true);
d234 1
a234 1
  struct passwd *temppw = internal_getpwnam (name, true);
d252 1
a252 1
  struct passwd *temppw = internal_getpwnam (nam, true);
d281 13
a293 5
  if (_my_tls.locals.pw_pos == 0)
    pr.refresh (true);
  if (_my_tls.locals.pw_pos < pr.curr_lines)
    return passwd_buf + _my_tls.locals.pw_pos++;

@


1.95
log
@	* passwd.cc (setpassent): Align to BSD definition.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012, 2014 Red Hat, Inc.
@


1.94
log
@	* Merge in cygwin-64bit-branch.
@
text
@d4 1
a4 1
   2009, 2010, 2011, 2012 Red Hat, Inc.
d277 1
a277 1
setpassent ()
@


1.93
log
@Throughout, update copyrights to reflect dates which correspond to main-branch
checkins.  Regularize copyright format.
@
text
@d72 1
a72 1
	      && myself->uid != (__uid32_t) pw->pw_uid
d77 1
a77 1
      snprintf (linebuf, sizeof (linebuf), "%s:*:%lu:%lu:,%s:%s:/bin/sh",
d114 1
a114 1
internal_getpwuid (__uid32_t uid, bool check)
d119 1
a119 1
    if (uid == (__uid32_t) passwd_buf[i].pw_uid)
d138 1
a138 1
getpwuid32 (__uid32_t uid)
d145 3
d153 1
d156 1
a156 1
getpwuid_r32 (__uid32_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
d188 3
d196 1
d256 1
d262 1
@


1.92
log
@	* passwd.cc (getpass): Make check for closed stream more reliable.
	Check if setting tty attributes worked and only revert to old state
	if so.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2001, 2002, 2003, 2007, 2008, 2009,
   2010, 2011, 2012 Red Hat, Inc.
@


1.92.2.1
log
@	* include/cygwin/stat.h (struct __stat64): Drop entirely in favor of
	struct stat.  Accommodate throughout Cygwin.
	* include/cygwin/types.h: Throughout, drop current, internal types
	used since Cygwin 1.5 with the base type they have been used for.
	Throughout, define types based on bitsize-specific types where
	appropriate.  Accommodate throughout Cygwin.
	* include/sys/cygwin.h: Drop __uid32_t and __gid32_t in favor of
	uid_t and gid_t.  Define uid/gid types based on bitsize-specific types.
	(struct external_pinfo): Accommodate above change.
	* cygtls.h (struct _local_storage): Drop unused members grp and
	namearray,
	* tlsoffsets.h: Regenerate.
	* devices.h (_dev_t): Drop definition.  Use dev_t throughout instead.
	* devices.cc: Regenerate.

	Probably temporary patch to drop unneeded functionality on x86_64:
	* fcntl.cc (_fcntl): Alias to fcntl64 on x86_64.
	* glob.cc (CYGWIN_gl_stat): Simplify on x86_64.
	* grp.cc (grp32togrp16): Don't define on x86_64.
	(getgrgid): Alias to getgrgid32 on x86_64.
	(getgrnam): Alias to getgrnam32 on x86_64.
	(getgrent): Alias to getgrent32 on x86_64.
	(getgroups): Alias to getgroups32 on x86_64.
	(initgroups): Alias to initgroups32 on x86_64.
	(setgroups): Alias to setgroups32 on x86_64.
	* mmap.cc (mmap): Alias to mmap64 on x86_64.
	* passwd.cc (getpwuid): Alias to getpwuid32 on x86_64.
	(getpwuid_r): Alias to getpwuid_r32 on x86_64.
	(getpwduid): Don't define on x86_64.
	* syscalls.cc (lseek): Alias to lseek64 on x86_64.
	(_lseek): Alias to lseek64 on x86_64.
	(chown): Alias to chown32 on x86_64.
	(lchown): Alias to lchown32 on x86_64.
	(fchown): Alias to fchown32 on x86_64.
	(stat64_to_stat32): Don't define on x86_64.
	(fstat): Alias to fstat64 on x86_64.
	(_fstat_r): Alias to _fstat64_r on x86_64.
	(stat): Alias to stat64 on x86_64.
	(_stat_r): Alias to _stat64_r on x86_64.
	(lstat): Alias to lstat64 on x86_64.
	(ftruncate): Alias to ftruncate64 on x86_64.
	(truncate): Alias to truncate64 on x86_64.
	(seteuid): Alias to seteuid32 on x86_64.
	(setuid): Alias to setuid32 on x86_64.
	(setreuid): Alias to setreuid32 on x86_64.
	(setegid): Alias to setegid32 on x86_64.
	(setgid): Alias to setgid32 on x86_64.
	(setregid): Alias to setregid32 on x86_64.
	* uinfo.cc (getuid): Alias to getuid32 on x86_64.
	(getgid): Alias to getgid32 on x86_64.
	(geteuid): Alias to geteuid32 on x86_64.
	(getegid): Alias to getegid32 on x86_64.
	* winsup.h (ILLEGAL_UID16): Don't define on x86_64.
	(ILLEGAL_GID16): Ditto.
	(uid16touid32): Don't declare on x86_64.
	(gid16togid32): Don't declare on x86_64.
@
text
@d72 1
a72 1
	      && myself->uid != pw->pw_uid
d77 1
a77 1
      snprintf (linebuf, sizeof (linebuf), "%s:*:%u:%u:,%s:%s:/bin/sh",
d114 1
a114 1
internal_getpwuid (uid_t uid, bool check)
d119 1
a119 1
    if (uid == passwd_buf[i].pw_uid)
d138 1
a138 1
getpwuid32 (uid_t uid)
a144 3
#ifdef __x86_64__
EXPORT_ALIAS (getpwuid32, getpwuid)
#else
a149 1
#endif
d152 1
a152 1
getpwuid_r32 (uid_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
a183 3
#ifdef __x86_64__
EXPORT_ALIAS (getpwuid_r32, getpwuid_r)
#else
a188 1
#endif
a247 1
#ifndef __x86_64__
a252 1
#endif
@


1.92.2.2
log
@Pull in changes from HEAD
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008,
   2009, 2010, 2011, 2012 Red Hat, Inc.
@


1.91
log
@	* passwd.cc (pwdgrp::read_passwd): Fix pretty_ls entry tyo contain
	the required number of colons.
@
text
@d284 1
d299 1
a299 3
  if (tcgetattr (fileno (in), &ti) == -1)
    pass[0] = '\0';
  else
d302 8
a309 3
      newti = ti;
      newti.c_lflag &= ~(ECHO | ISIG);	/* No echo, no signal handling. */
      tcsetattr (fileno (in), TCSANOW, &newti);
d314 2
a315 1
      tcsetattr (fileno (in), TCSANOW, &ti);
@


1.90
log
@	* passwd.cc (_getpass_close_fd): New static pthread cleanup handler.
	(getpass): Rework to use /dev/tty in the first place.  Install
	_getpass_close_fd as pthread cleanup handler.  Flush prompt explicitely.
	Lock input and switch off signal input handling when reading password.
@
text
@d61 1
a61 1
  static char NO_COPY pretty_ls[] = "????????:*:-1:-1:";
@


1.89
log
@* dtable.cc (dtable::init_std_file_from_handle): Reinstate opening tty handles
with O_RDWR permissions.
@
text
@d272 7
d285 11
a295 1
  cygheap_fdget fhstdin (0);
d297 2
a298 1
  if (fhstdin < 0)
d302 1
a302 1
      fhstdin->tcgetattr (&ti);
d304 11
a314 9
      newti.c_lflag &= ~ECHO;
      fhstdin->tcsetattr (TCSANOW, &newti);
      fputs (prompt, stderr);
      fgets (pass, _PASSWORD_LEN, stdin);
      fprintf (stderr, "\n");
      for (int i=0; pass[i]; i++)
	if (pass[i] == '\r' || pass[i] == '\n')
	  pass[i] = '\0';
      fhstdin->tcsetattr (TCSANOW, &ti);
d316 1
@


1.88
log
@	* grp.cc (pwdgrp::parse_group): Convert grp from macro to reference.
	* passwd.cc (pwdgrp::parse_passwd): Ditto for res.
@
text
@d4 1
a4 1
   2010, 2011 Red Hat, Inc.
@


1.87
log
@	* autoload.cc (UuidCreate): Remove.
	(UuidCreateSequential): Remove.
	* passwd.cc (internal_getpwsid): Avoid a strict-aliasing compiler
	error with gcc 4.5.1.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Ditto.
	* ntdll.h (NtAllocateUuids): Declare.
	* syscalls.cc (gethostid): Use NtAllocateUuids function rather than
	UuidCreateSequential/UuidCreate to get rid of rpcrt4 dependency.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 2001, 2002, 2003, 2007, 2008, 2009 Red Hat, Inc.
d35 1
a35 1
# define res (*passwd_buf)[curr_lines]
a46 1
# undef res
@


1.86
log
@	Revert accidental previous login.
@
text
@d101 8
a108 5
	if ((pw = passwd_buf + i)->pw_dir > pw->pw_gecos + 8)
	  for (ptr1 = endptr, ptr2 = pw->pw_dir - 2;
	       *ptr1 == *ptr2; ptr2--)
	    if (!*--ptr1)
	      return pw;
@


1.86.2.1
log
@	* passwd.cc (internal_getpwsid): Avoid a strict-aliasing compiler
	error with gcc 4.5.1.
	* fhandler_floppy.cc (fhandler_dev_floppy::get_drive_info): Ditto.
	* syscalls.cc (gethostid): Ditto.
@
text
@d101 5
a105 8
	{
	  pw = passwd_buf + i;
	  if (pw->pw_dir > pw->pw_gecos + 8)
	    for (ptr1 = endptr, ptr2 = pw->pw_dir - 2;
		 *ptr1 == *ptr2; ptr2--)
	      if (!*--ptr1)
		return pw;
	}
@


1.85
log
@	* Makefile.in (DLL_IMPORTS): Remove libadvapi32.a.
	* autoload.cc: Add all advapi32 entry points.
	* mount.cc (mount_info::init): Read user fstab only if we have a
	username.
	* passwd.cc (pwdgrp::read_passwd): Only use username if we have one.
	* shared.cc (user_info::initialize): Set cb last so as not to override
	planned behaviour in pwdgrp::read_passwd.
	* uinfo.cc (cygheap_user::init): Fetch Windows username from environment
	variable $USERNAME.  Don't set name in cygheap if variable is empty.
	(internal_getlogin): If we still have no username, try GetUserNameW.
@
text
@d69 1
a69 2
      && (!cygheap->user.name ()
	  || !(pw = internal_getpwnam (cygheap->user.name ()))
d78 1
a78 1
		cygheap->user.name () ?: "",
@


1.84
log
@	* grp.cc (getgrgid_r): Simplify code by using stpcpy.
	(getgrnam_r): Ditto.
	* passwd.cc (getpwuid_r32): Simplify code by using stpcpy.
	(getpwnam_r): Ditto.
@
text
@d69 2
a70 1
      && (!(pw = internal_getpwnam (cygheap->user.name ()))
d79 1
a79 1
		cygheap->user.name (),
@


1.83
log
@	* passwd.cc (pwdgrp::read_passwd): Check if we're called within
	user_shared initialization and ignore myself, if so.  Reformat
	conditional expression.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2001, 2002, 2003, 2007 Red Hat, Inc.
d162 3
a164 3
  size_t needsize = strlen (temppw->pw_name) + strlen (temppw->pw_dir) +
		    strlen (temppw->pw_shell) + strlen (temppw->pw_gecos) +
		    strlen (temppw->pw_passwd) + 5;
d172 5
a176 4
  pwd->pw_name = buffer;
  pwd->pw_dir = pwd->pw_name + strlen (temppw->pw_name) + 1;
  pwd->pw_shell = pwd->pw_dir + strlen (temppw->pw_dir) + 1;
  pwd->pw_gecos = pwd->pw_shell + strlen (temppw->pw_shell) + 1;
a177 6
  pwd->pw_passwd = pwd->pw_gecos + strlen (temppw->pw_gecos) + 1;
  strcpy (pwd->pw_name, temppw->pw_name);
  strcpy (pwd->pw_dir, temppw->pw_dir);
  strcpy (pwd->pw_shell, temppw->pw_shell);
  strcpy (pwd->pw_gecos, temppw->pw_gecos);
  strcpy (pwd->pw_passwd, temppw->pw_passwd);
d215 3
a217 3
  size_t needsize = strlen (temppw->pw_name) + strlen (temppw->pw_dir) +
		    strlen (temppw->pw_shell) + strlen (temppw->pw_gecos) +
		    strlen (temppw->pw_passwd) + 5;
d225 5
a229 4
  pwd->pw_name = buffer;
  pwd->pw_dir = pwd->pw_name + strlen (temppw->pw_name) + 1;
  pwd->pw_shell = pwd->pw_dir + strlen (temppw->pw_dir) + 1;
  pwd->pw_gecos = pwd->pw_shell + strlen (temppw->pw_shell) + 1;
a230 6
  pwd->pw_passwd = pwd->pw_gecos + strlen (temppw->pw_gecos) + 1;
  strcpy (pwd->pw_name, temppw->pw_name);
  strcpy (pwd->pw_dir, temppw->pw_dir);
  strcpy (pwd->pw_shell, temppw->pw_shell);
  strcpy (pwd->pw_gecos, temppw->pw_gecos);
  strcpy (pwd->pw_passwd, temppw->pw_passwd);
@


1.82
log
@	* shared.cc (user_shared_initialize): Fetch potentially changed Cygwin
	username from /etc/passwd before loading mount table.
	(shared_info::init_installation_root): New function fetching Cygwin's
	installation root dir and storing as native NT path in global shared
	memory.
	(shared_info::initialize): Call init_installation_root exactly once at
	first startup.
	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add installation_root member.
	(shared_info::init_installation_root): Declare.

	* grp.cc (pwdgrp::read_group): Call pwdgrp::load with native WCHAR path.
	* passwd.cc (pwdgrp::read_passwd): Ditto.  Avoid recursion.
	(etc::init): Take POBJECT_ATTRIBUTES instead of path_conv.
	* path.h (etc::init): Change prototype accordingly.
	* pwdgrp.h (class pwdgrp): Store path as UNICODE_STRING/PWCHAR instead
	of as path_conv.
	(pwdgrp::load): Accommodate prototype.
	* uinfo.cc (pwdgrp::load): Change argument type from char to wchar_t.
	Create native NT path here instead of calling path_conv.

	* mount.cc (find_root_from_cygwin_dll): Drop in favor of global
	initializaion in shared_info.
	(mount_info::init): Fetch native NT root dir from cygwin_shared.
	(mount_info::from_fstab): Expect native NT path and use native NT
	functions to access file.  Convert username part in user fstab path
	according to special char transformation rules.
	* path.cc (tfx_chars): Convert slash to backslash.
	(transform_chars): Implement for path given as PWCHAR.
	(transform_chars): PUNICODE_STRING version calls PWCHAR version.
	Remove useless commented code.
@
text
@d22 1
d66 1
a66 1
  if (myself->uid == ILLEGAL_UID)
d68 6
a73 5
  if (searchentry &&
      (!(pw = internal_getpwnam (cygheap->user.name ())) ||
       (myself->uid != ILLEGAL_UID &&
	myself->uid != (__uid32_t) pw->pw_uid  &&
	!internal_getpwuid (myself->uid))))
d79 3
a81 2
		myself->uid == ILLEGAL_UID ? UNKNOWN_UID : myself->uid,
		myself->gid,
@


1.81
log
@Remove unneeded header files from source files throughout.
@
text
@d54 1
a54 1
  load ("/etc/passwd");
a74 1
      cygheap->user.ontherange (CH_HOME, NULL);
@


1.80
log
@	Throughout remove all usage of wincap.has_security.
	* environ.cc (environ_init): Drop setting allow_ntsec here.
	* grp.cc (initgroups32): Drop usage of label "out".
	* security.cc (allow_ntsec): Set to true by default.
	* syscalls.cc (seteuid32): Remove label success_9x.
	* wincap.cc: Remove has_security throughout.
	* wincap.h: Ditto.
@
text
@a12 1
#include <pwd.h>
a20 1
#include <sys/termios.h>
@


1.79
log
@Remove some more unneeded 'return;'s throughout.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2001, 2002, 2003 Red Hat, Inc.
d61 2
d64 5
a68 12
  if (wincap.has_security ())
    {
      /* must be static */
      static char NO_COPY pretty_ls[] = "????????:*:-1:-1:";
      add_line (pretty_ls);
      cygsid tu = cygheap->user.sid ();
      tu.string (strbuf);
      if (myself->uid == ILLEGAL_UID)
	searchentry = !internal_getpwsid (tu);
    }
  else if (myself->uid == ILLEGAL_UID)
    searchentry = !internal_getpwuid (DEFAULT_UID);
@


1.78
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@a90 1
  return;
@


1.77
log
@* path.cc (chdir): Always use the normalized_path as posix_cwd, except if it
starts with a drive.

Also perform whitespace cleanup.
@
text
@d82 1
a82 1
      (void) cygheap->user.ontherange (CH_HOME, NULL);
@


1.76
log
@* exceptions.cc (set_signal_mask): Redefine to not pass by address.  Report
calculated mask in debugging output.
* sigproc.h (set_signal_mask): Reflect above change in declaration.
* path.cc (mount_item::build_win32): Take path apart before feeding it to
fnmunge.  Throughout, change use of _reent_winsup()-> to _my_tls.locals.
instead.  Throughout, remove obsolete MT_SAFE/_CYG_THREAD_FAILSAFE
considerations.  Througout, add cygtls.h include.
* Makefile.in (DLL_OFILES): Add cygtls.o.  Add some more objects to the
-fomit-frame-pointer list.
* acconfig.h: Remove obsolete settings.
* config.h.in: Ditto.
* bsdlib.cc: Add cygtls.h include.
* configure.in: Remove --enable-extra-threadsafe-checking.
* configure: Regenerate.
* cygtls.h (_local_storage): New struct renamed from _winsup_t (sic).
(_threadinfo:local_clib): Add new field.
(_threadinfo::locals): Ditto.
(_threadinfo::init_thread): Accept second _reent * argument.
(_threadinfo::call): Define as regparm.
(CYGTLS_PADSIZE): Remove unnecessary slop.
(_getreent): Define as a macro.
* thread.h: Remove _CYG_THREAD_FAILSAFE and MT_SAFE stuff.
(_winsup_t): Move to cygtls.h.
(ResourceLocks::ResourceLocks): Eliminate empty constructor.
(MTinterface::reents): Eliminate.
(MTinterface::thread_self_key): Eliminate.
(MTinterface::MTinterface): Eliminate.
* dcrt0.cc: Include stdio.h for _impure_ptr initialization.
(do_global_ctors): Remove run_ctors_p (sic) considerations.  Don't call atexit
here.
(__main): Initialize destructors for user here.
(dll_crt0_1): Accept a dummy argument.  Don't call init_thread here.  Don't set
_impure_ptr here.  Call do_global_ctors after more things have been
initialized.
(_dll_crt0): Define zeros buffer as max of needed size of CYGTLS_PADSIZE so
that it can be used for two purposes while minimizing stack usage.  Initialize
_impure_ptr specifically, for speed.  Call dll_crt0_1 with buffer argument.
(cygwin_dll_init): Call dll_crt0_1 with dummy argument.
* dtable.cc (dtable::find_unused_handle): Remove call to AssertResourceOwner.
* exceptions.cc: Move _threadinfo stuff to new file.
* cygtls.cc: New file.
* gentls_offsets: Accommodate increasing complexity of cygtls.h.
* hires.h (hires_base::~hires_base): Remove.
* init.cc (dll_entry): Remove setting of reents.
* thread.cc: Remove syslog.h include.
(__getreent): Simplify to use _my_tls.
(_reent_winsup): Delete.
(AssertResourceOwner): Delete.
(MTinterface::Init): Remove setting of _clib and _winsup, with all that
entails.
(MTinterface::fixup_after_fork): Ditto.
(pthread::thread_init_wrapper): Ditto.  Also remove call to
set_tls_self_pointer.
(pthread::set_tls_self_pointer): Eliminate.
(pthread::get_tls_self_pointer): Just return _my_tls.tid;
(__reent_t::init_clib): Eliminate.
* tlsoffsets.h: Regenerate.
@
text
@d81 1
a81 1
      					// should not be NO_COPY
@


1.75
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@a28 1
/* FIXME: This really should use a constructor, but they are slow */
a30 3
/* Position in the passwd cache */
#define pw_pos  _reent_winsup ()->_pw_pos

d253 1
a253 1
  if (pw_pos == 0)
d255 2
a256 2
  if (pw_pos < pr.curr_lines)
    return passwd_buf + pw_pos++;
d270 1
a270 1
  pw_pos = 0;
d276 1
a276 1
  pw_pos = 0;
d288 1
a288 1
  char *pass=_reent_winsup ()->_pass;
@


1.74
log
@* devices.cc: New file.
* devices.gperf: New file.
* devices.shilka: New file.
* cygwin-gperf: New file.
* cygwin-shilka: New file.
* fhandler_fifo.cc: New file.
* fhandler_nodevice.cc : New file.  Reorganize headers so that path.h precedes
fhandler.h throughout.  Remove device argument and unit arguments from fhandler
constructors throughout.  Remove pc arguments to fhandler functions and use
internal pc element instead, throughout.  Use dev element in pc throughout.
Use major/minor elements rather than units and device numbers previously in
fhandler class.  Use correct methods for fhandler file names rather than
directly accessing file name variables, throughout.
* Makefile.in (DLL_OFILES): Add devices.o, fhandler_fifo.o
* dcrt0.cc (dll_crt0_1): Call device::init.
* devices.h: Renumber devices based on more Linux-like major/minor numbers.
Add more devices.  Declare standard device storage.
(device): Declare struct.
* dir.cc (opendir): Use new 'build_fh_name' to construct a fhandler_* type.
* dtable.cc (dtable::get_debugger_info): Ditto.
(cygwin_attach_handle_to_fd): Ditto.
(dtable::release): Remove special FH_SOCKET case in favor of generic
"need_fixup_before" test.
(dtable::init_std_file_from_handle): Use either build_fh_dev or build_fh_name
to build standard fhandler.
(dtable::build_fh_name): Renamed from dtable::build_fhandler_from_name.  Move
out of dtable class.  Don't accept a path_conv argument.  Just build it here
and pass it to:
(build_fh_pc): Renamed from dtable::build_fhandler.  Move out of dtable class.
Use intrinsic device type in path_conv to create new fhandler.
(build_fh_dev): Renamed from dtable::build_fhandler.  Move out of dtable class.
Simplify arguments to just take new 'device' type and a name.  Just return
pointer to fhandler rather than trying to insert into dtable.
(dtable::dup_worker): Accommodate above build_fh name changes.
(dtable::find_fifo): New (currently broken) function.
(handle_to_fn): Use strechr for efficiency.
* dtable.h: Reflect above build_fh name changes and argument differences.
(fhandler_base *&operator []): Return self rather than copy of self.
* fhandler.cc (fhandler_base::operator =): Use pc element to set normalized
path.
(fhandler_base::set_name): Ditto.
(fhandler_base::raw_read): Use method to access name.
(fhandler_base::write): Correctly use get_output_handle rather than get_handle.
(handler_base::device_access_denied): New function.
(fhandler_base::open): Eliminate pc argument and use pc element of
fhandler_base throughout.
(fhandler_base::fstat): Detect if device is based in filesystem and use
fstat_fs to calculate stat, if so.
(fhandler_base::fhandler_base): Eliminate handling of file names and, instead,
just free appropriate component from pc.
(fhandler_base::opendir): Remove path_conv parameter.
* fhandler.h: Remove all device flags.
(fhandler_base::pc): New element.
(fhandler_base::set_name): Change argument to path_conv.
(fhandler_base::error): New function.
(fhandler_base::exists): New function.
(fhandler_base::pc_binmode): New function.
(fhandler_base::dev): New function.
(fhandler_base::open_fs): New function.
(fhandler_base::fstat_fs): New function.
(fhandler_base::fstat_by_name): New function.
(fhandler_base::fstat_by_handle): New function.
(fhandler_base::isfifo): New function.
(fhandler_base::is_slow): New function.
(fhandler_base::is_auto_device): New function.
(fhandler_base::is_fs_special): New function.
(fhandler_base::device_access_denied): New function.
(fhandler_base::operator DWORD&): New operator.
(fhandler_base::get_name): Return normalized path from pc.
(fhandler_base::get_win32_name): Return windows path from pc.
(fhandler_base::isdevice): Renamed from is_device.
(fhandler_base::get_native_name): Return device format.
(fhandler_fifo): New class.
(fhandler_nodevice): New class.
(select_stuff::device_specific): Remove array.
(select_stuff::device_specific_pipe): New class element.
(select_stuff::device_specific_socket): New class element.
(select_stuff::device_specific_serial): New class element.
(select_stuff::select_stuff): Initialize new elements.
* fhandler_disk_file.cc (fhandler_base::fstat_by_handle): Move to base class
from fhandler_disk_file.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_base::fstat_by_name): Ditto.
(fhandler_disk_file::open): Move most functionality into
fhandler_base::open_fs.
(fhandler_base::open_fs): New function.
(fhandler_disk_file::close): Move most functionality into
fhandler_base::close_fs.
(fhandler_base::close_fs): New function.
* fhandler_mem.cc (fhandler_dev_mem::open): Use device name in debugging
output.
* fhandler_socket.cc (fhandler_socket::set_connect_secret): Copy standard
urandom device into appropriate place.
(fhandler_socket::accept): Reflect change in fdsock return value.
* fhandler_tty.cc: See "throughouts" above.
* net.cc: Accommodate fdsock change throughout.
(fdsock): Return success or failure, accept fd argument and device argument.
* path.cc (symlink_info::major): New element.
(symlink_info::minor): New element.
(symlink_info::parse_device): Declare new function.
(fs_info::update): Accommodate changes in path_conv class.
(path_conv::fillin): Ditto.
(path_conv::return_and_clear_normalized_path): Eliminate.
(path_conv::set_normalized_path): New function.
(path_conv::path_conv): Set info in dev element.  Use path_conv methods Check
for FH_FS rather than FH_BAD to indicate when to fill in filesystem stuff.
where appropriate rather than direct access.  Use set_normalized_path to set
normalized path.
(windows_device_names): Eliminate.
(get_dev): Ditto.
(get_raw_device_number): Ditto.
(get_device_number): Ditto.
(win32_device_name): Call new device name parser to do most of the heavy
lifting.
(mount_info::conv_to_win32_path): Fill in dev field as appropriate.
(symlink_worker): Handle new device files.
(symlink_info::check): Ditto.
(symlink_info::parse_device): Define new function.
* path.h (executable_states): Move here from fhandler.h.
(fs_info): Rename variables to *_storage and create methods for accessing same.
(path_conv): Add dev element, remove devn and unit and adjust inline methods to
accommodate.
(set_normalized_path): Declare new function.
* pinfo.cc (_pinfo::commune_recv): Add broken support for handling fifos.
(_pinfo::commune_send): Ditto.
* pipe.cc (fhandler_pipe::close): check for existence of handle before closing
it.
(handler_pipe::create): Rename from make_pipe.  Change arguments to accept
fhandler_pipe array.  Accommodate fifos.
(pipe): Rework to deal with fhandler_pipe::create changes.
(_pipe): Ditto.
* select.cc: Use individual device_specific types throughout rather than
indexing with obsolete device number.
(set_bits): Use is_socket call rather than checking device number.
* shared_info.h (CURR_MOUNT_MAGIC): Update.
(conv_to_win32_path): Reflect addition of device argument.
* syscalls.cc (mknod_worker): New function.
(open): Use build_fh_name to build fhandler.
(chown_worker): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(chmod_device): New function.
(chmod): Detect if this is an 'auto' device rather than an on-filesystem device
and handle appropriately.  Use chmod_device to set mode of in-filesystem
devices.
(stat_worker): Eliminate path_conv argument.  Call build_fh_name to construct
fhandler.  Use fh->error() rather than pc->error to detect errors in fhandler
construction.
(access_worker): New function pulled from access.  Accommodate in-filesystem
devices.
(access): Use access_worker.
(fpathconf): Detect if this is an 'auto' device rather than an on-filesystem
device and handle appropriately.
(mknod_worker): New function.
(mknod32): New function.
(chroot): Free normalized path -- assuming it was actually cmalloced.
* tty.cc (create_tty_master): Tweak for new device class.
(tty::common_init): Ditto.
* winsup.h (stat_worker): Remove.
(symlink_worker): Declare.
* exceptions.cc (set_process_mask): Just call sig_dispatch_pending and don't
worry about pending_signals since sig_dispatch_pending should always do the
right thing now.
(sig_handle): Reorganize SIGCONT handling to more closely conform to SUSv3.
* pinfo.h: Move __SIG enum to sigproc.h.
(PICOM_FIFO): New enum element.
(_pinfo): Remove 'thread2signal' stuff throughout class.
(_pinfo::commune_send): Make varargs.
(_pinfo::sigtodo): Eliminate.
(_pinfo::thread2signal): Ditto.
* signal.cc (kill_worker): Eliminate call to setthread2signal.
* sigproc.cc (local_sigtodo): Eliminate.
(getlocal_sigtodo): Ditto.
(sigelem): New class.
(pending_signals): New class.
(sigqueue): New variable, start of sigqueue linked list.
(sigcatch_nonmain): Eliminate.
(sigcatch_main): Eliminate.
(sigcatch_nosync): Eliminate.
(sigcomplete_nonmain): Eliminate.
(pending_signals): Eliminate.
(sig_clear): Call signal thread to clear pending signals, unless already in
signal thread.
(sigpending): Call signal thread to get pending signals.
(sig_dispatch_pending): Eliminate use of pending_signals and just check
sigqueue.
(sigproc_terminate): Eliminate all of the obsolete semaphore stuff.  Close
signal pipe handle.
(sig_send): Eliminate all of the obsolete semaphore stuff and use pipe to send
signals.
(getevent): Eliminate.
(pending_signals::add): New function.
(pending_signals::del): New function.
(pending_signals::next): New function.
(wait_sig): Eliminate all of the obsolete semaphore stuff.  Use pipe to
communicate and maintain a linked list of signals.
* sigproc.h: Move __SIG defines here.  Add __SIGPENDING.
(sig_dispatch_pending): Remove "C" specifier.
(sig_handle): Accept a mask argument.
* thread.cc: Remove signal handling considerations throughout.
@
text
@d147 1
a147 1
  struct passwd *temppw = internal_getpwuid (uid, TRUE);
d166 1
a166 1
  struct passwd *temppw = internal_getpwuid (uid, TRUE);
d205 1
a205 1
  struct passwd *temppw = internal_getpwnam (name, TRUE);
d223 1
a223 1
  struct passwd *temppw = internal_getpwnam (nam, TRUE);
@


1.73
log
@* passwe.cc (getpwnam_r): Initialize pw_comment field.
@
text
@d17 1
a18 1
#include "path.h"
@


1.72
log
@* passwd.cc (getpwuid_r32): Initialize pw_comment field.
@
text
@d244 1
@


1.71
log
@Throughout, remove "include <errno.h>" from files which already include
cygerrno.h.
* include/cygwin/config.h (__DYNAMIC_REENT__): Define.
* include/cygwin/version.h: Bump API minor version.
* cygwin.din: Export __getreent
* cygerrno.h: Include errno.h.  Fix places where _impure_ptr is used directly
to store the errno value.
* debug.cc (__set_errno): Ditto.
* errno.cc: Remove _RRENT_ONLY define to get errno.cc compiled.
* signal.cc: Rename _reent_clib to _REENT throughout.
* thread.h (reent_clib): Remove prototype.
* thread.cc (reent_clib): Rename reent_clib to __getreent.  Return _impure_ptr
until MTinterface is initialized.
(reent_winsup): Fix a possible SEGV when _r == NULL.  Return NULL instead.
* MTinterface::fixup_after_fork: Switch reent back to _impure_ptr to keep
signal handling running when fork is called from a thread other than the
mainthread.
@
text
@d186 1
@


1.70
log
@	* security.h: Introduce names UNKNOWN_UID and UNKNOWN_GID and delete
	declaration of is_grp_member.
	* uinfo.cc (internal_getlogin): Use UNKNOWN_GID.
	* passwd.cc (pwdgrp::read_passwd): Use UNKNOWN_UID.
	* grp.cc (pwdgrp::read_group): Change group name to provide better
	feedback.
	(getgrgid): Use gid16togid32.
	* sec_helper.cc (is_grp_member): Delete.
@
text
@a14 1
#include <errno.h>
@


1.69
log
@	* security.h (class cygpsid): New class.
	(class cygsid): Use cygpsid as base. Remove members psid, get_id,
	get_uid, get_gid, string, debug_printf and the == and != operators.
	(cygsidlist::clear_supp): Only do work if setgroups has been called.
	* sec_helper.cc: Define sid_auth NO_COPY.
	(cygpsid::operator==): New operator.
	(cygpsid::get_id): New function.
	(cygpsid::string): New function.
	(cygsid::string): Delete.
	(cygsid::get_id): Delete.
	* pwdgrp.h: Change arguments of internal_getpwsid,
	internal_getgrsid and internal_getgroups to cygpsid.
	* passwd.cc (internal_getpwsid): Change argument from cygsid to cygpsid.
	* grp.cc (internal_getgrsid): Ditto.
	(internal_getgroups): Ditto.
@
text
@d90 1
a90 1
		myself->uid == ILLEGAL_UID ? DEFAULT_UID_NT : myself->uid,
@


1.68
log
@* grp.cc (getgrent32): Only refresh group entries when at beginning.
(internal_getgrsid): Only refresh if uninitialized.
(internal_getgrent): Ditto.
* passwd.cc (getpwent): Only refresh passwd entries when at beginning.
(pwdgrp::read_passwd): linebuf *cannot* be NO_COPY.
(internal_getpwsid): Only refresh if uninitialized.
(getpass): No need to refresh passwd data here.
* pwdgrp.h (refresh): Eliminate default.
@
text
@d100 1
a100 1
internal_getpwsid (cygsid &sid)
@


1.67
log
@* passwd.cc (pwdgrp::read_passwd): linebuf *must* be static (from Pierre
Humblet).
* pwdgrp.h (pwdgrp::refresh): Avoid calling read function if we already have
lock since that means we are in the process of reading the file.
@
text
@d85 2
a86 1
      static char NO_COPY linebuf[1024];	// must be static
d106 1
a106 1
  pr.refresh ();
d256 2
a257 2
  pr.refresh ();

a292 2

  pr.refresh ();
@


1.66
log
@* passwd.cc (pwdgrp::parse_passwd): Be more unforgiving about non-numeric
fields.
@
text
@d69 1
d85 1
a85 1
      char linebuf[1024];
@


1.65
log
@* strings.h (strechr): New function.
* uinfo.cc (pwdgrp::next_str): Search only for input char in string.  Return
EOS on failure.  Don't check for NULL since it shouldn't be possible.
(pwdgrp::add_line): Revert to replacing '\n' in input line with '\0'.
(pwdgrp::next_num): Pass explicit separator character to next_str.
* grp.cc (pwdgrp::parse_group): Ditto.
* passwd.cc (pwdgrp::parse_passwd): Ditto.  Revamp test for garbage input.
* pwdgrp.h (pwdgrp::next_str): Don't use default parameter.
@
text
@d43 4
a46 5
  char *p = raw_ptr ();
  (void) next_num (res.pw_uid);
  if (p == raw_ptr ())
    return false;	/* parsing did not advance.  line is garbage */
  (void) next_num (res.pw_gid);
@


1.64
log
@* passwd.cc (pwdgrp::parse_passwd): Eliminate use of memset.  The structure
should always be completely filled out.
* grp.cc (pwdgrp::parse_group): Ditto.
* grp.cc (pwdgrp::parse_group): Fix off-by-one problem in allocating
@
text
@d41 3
a43 6
  res.pw_name = next_str ();
  res.pw_passwd = next_str ();

  if (res.pw_name == res.pw_passwd)
    return false;

d45 2
d49 3
a51 3
  res.pw_gecos = next_str ();
  res.pw_dir =  next_str ();
  res.pw_shell = next_str ();
@


1.63
log
@* include/sys/strace.h (paranoid_printf): Define as not being part of "all"
output.
* pwdgrp.h (pwdgrp::next_num): Rename from next_int.  Returns true/false if
parse operation succeeded.
(pwdgrp::reparse): Remove.
(pwdgrp::raw_ptr): New function.  Returns pointer in line.
(pwdgrp::next_num): New functions for parsing other than unsigned long.
* grp.cc (pwdgrp::parse_group): Reinstate previous parsing behavior.  Don't
fill in fields with NULL and assign empty gr_mem to known pointer rather than
doing a pointless calloc.  Streamline gr_mem parsing.  Don't increment
curr_lines here.
* passwd.cc (pwdgrp::parse_passwd): Use new behavior of next_num.  Don't
increment curr_lines here.
* uinfo.cc (pwdgrp::next_str): Keep returning EOL if out of data.
(pwdgrp::reparse): Remove.
(pwdgrp::next_num): Rename from next_int.  Return bool indicating success of
parse, argument returns value parsed.
(pwdgrp::add_line): Increment curr_lines here on successful parse.
(pwdgrp::load): (from Pierre Humblet) Don't return status.  Just report it
here.
@
text
@a40 3

  memset (&res, 0, sizeof (res));

@


1.62
log
@* pwdrp.h (pwdgrp::refresh): Lock entire test prior to reading.
* grp.cc (pwdgrp::parse_group): Eliminate arg and use class member instead.
Use next_str and next_int to parse arguments.
* passwd.cc (pwdgrp::parse_passwd): Ditto.
(grab_string): Eliminate.
(grab_int): Ditto.
* pwdgrp.h (pwdgrp::parse): Eliminate input arg.
(pwdgrp::parse_passwd): Reflect above change.
(pwdgrp::parse_group): Reflect above change.
(pwdgrp::next_str): New function.
(pwdgrp::next_int): Ditto.
(pwdgrp::gets): Eliminate.
* uinfo.cc (pwdgrp::next_str): New function.
(pwdgrp::next_int): Ditto.
(pwdgrp::add_line): Subsume gets.
(pwdgrp::gets): Eliminate.
(pwdgrp::load): Just call add_line to parse input buffer.
@
text
@a39 1
  int n;
d41 1
a41 2
  /* Allocate enough room for the passwd struct and all the strings
     in it in one go */
d43 1
d47 1
a47 2
  n = next_int ();
  if (n < 0)
a48 1
  res.pw_uid = n;
d50 3
a52 5
  n = next_int ();
  if (n < 0)
    return false;
  res.pw_gid = n;
  res.pw_comment = 0;
a55 1
  curr_lines++;
d66 1
a66 2
  if (!load ("/etc/passwd"))
    debug_printf ("load failed");
d75 1
a75 1
      pr.add_line (pretty_ls);
d97 1
a97 1
      pr.add_line (linebuf);
@


1.61
log
@* grp.cc: Call gr.refresh() rather than doing isunitialized tests throughout.
(gr): Use constructor (sigh).
(pwdgrp::parse_group): Rename from parse_grp.
(pwdgrp::read_group): Rename from read_etc_group.  Just call gr.load with a
single argument.
* passwd.cc: Call pr.refresh() rather than doing isunitialized tests
throughout.
(pr): Use constructor (sigh).
(pwdgrp::parse_passwd): Rename from "parse_pwd".
(pwdgrp::read_passwd): Rename from read_etc_passwd.  Just call pr.load with a
single argument.
* pwdgrp.h (pwdgrp_state): Eliminate.
(pwdgrp): Reflect above renamings.
(pwdgrp::etc_ix): Rename from pwd_ix.
(pwdgrp::read): New element.
(pwdgrp::lock): New element.
(pwdgrp::refresh): New function.
(pwdgrp::load): Eliminate variations which take buffer arguments.
(pwdgrp::pwdgrp): New constructors.  Initialize mutex here.
* uinfo.cc (pwdgrp::load): Accommodate pwd_ix -> etc_ix renaming.
(pwdgrp::load): Set initialized state to true rather than setting state to
loaded.
@
text
@a35 29
/* Remove a : terminated string from the buffer, and increment the pointer */
static char *
grab_string (char **p)
{
  char *src = *p;
  char *res = src;

  while (*src && *src != ':')
    src++;

  if (*src == ':')
    {
      *src = 0;
      src++;
    }
  *p = src;
  return res;
}

/* same, for ints */
static unsigned int
grab_int (char **p)
{
  char *src = *p;
  unsigned int val = strtoul (src, p, 10);
  *p = (*p == src || **p != ':') ? almost_null : *p + 1;
  return val;
}

d38 1
a38 1
pwdgrp::parse_passwd (char *buf)
d40 1
d44 11
a54 5
  res.pw_name = grab_string (&buf);
  res.pw_passwd = grab_string (&buf);
  res.pw_uid = grab_int (&buf);
  res.pw_gid = grab_int (&buf);
  if (!*buf)
d56 1
d58 3
a60 3
  res.pw_gecos = grab_string (&buf);
  res.pw_dir =  grab_string (&buf);
  res.pw_shell = grab_string (&buf);
@


1.60
log
@* pwdgrp.h (etc): Move to path.h.
(pwdgrp::max_lines): New field.
(pwdgrp::curr_lines): New field.
(pwdgrp::pwdgrp_buf): Ditto.
(pwdgrp_buf_elem_size): Ditto.
(pwdgrp_parse): Ditto.
(pwdgrp::gets): Just declare here.
(pwdgrp::load): Ditto.  Just take one argument.
(pwdgrp::load): Define overloaded function accepting passwd buf.
(pwdgrp::load): Define overloaded function accepting group buf.
* grp.cc: Use pwdgrp elements rather than standalone static variables
throughout.
(curr_lines): Eliminate.
(max_lines): Ditto.
(add_grp_line): Ditto.
(parse_grp): Define as returning boolean.  Accept void * arg and line count.
Coerce first argument into __group32 buf reference.  Increment curr_line as
appropriate.
(read_etc_group): Pass pwdgrp buffer to gr.load.
* passwd.cc: Use pwdgrp elements rather than standalone static variables
throughout.
(curr_lines): Eliminate.
(max_lines): Ditto.
(add_grp_line): Ditto.
(parse_passwd): Define as returning boolean.  Accept void * arg and line count.
Coerce first argument into passwd buf reference.  Increment curr_line as
appropriate.
(read_etc_group): Pass pwdgrp buffer to pr.load.
* path.cc (etc::fn): Extend buffer size to allow index by 1 rather than zero.
(etc::last_modified): Ditto.
(etc::change_possible): Ditto.  Renamed from sawchange.  Change to signed char
since elements are now tri-state.
(etc::init): Assume "handle" is 1 based rather than 0.
(etc::test_file_change): New function.  Sets change_possible based on file date
comparison.
(etc::dir_changed): Check file states immediately after changed_h is
initialized to avoid a race.
(etc::file_changed): Use test_file_change to detect if file needs to be
updated.
* path.h (etc): Move class here from pwdgrp.h.
* uinfo.cc: Move etc:: functions to path.cc.  Move pwdgrp functions here.
(pwdgrp::gets): Eliminate buf checks.  Just check eptr and set lptr.
(pwdgrp::add_line): New function.
(pwdgrp::load): Call generic add_line function which will call correct parser.
@
text
@a28 1
static pwdgrp pr;
d30 2
d67 1
a67 1
pwdgrp::parse_pwd (char *buf)
a86 20
class passwd_lock
{
  bool armed;
  static NO_COPY pthread_mutex_t mutex;
 public:
  passwd_lock (bool doit)
  {
    if (doit)
      pthread_mutex_lock (&mutex);
    armed = doit;
  }
  ~passwd_lock ()
  {
    if (armed)
      pthread_mutex_unlock (&mutex);
  }
};

pthread_mutex_t NO_COPY passwd_lock::mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;

d90 2
a91 2
static void
read_etc_passwd ()
d93 6
a98 5
  /* A mutex is ok for speed here - pthreads will use critical sections not
   * mutexes for non-shared mutexes in the future. Also, this function will
   * at most be called once from each thread, after that the pr
   * test will succeed */
  passwd_lock here (cygwin_finished_initializing);
d100 16
a115 2
  /* if we got blocked by the mutex, then etc_passwd may have been processed */
  if (pr.isinitializing ())
d117 9
a125 34
      if (!pr.load ("/etc/passwd", passwd_buf))
	debug_printf ("pr.load failed");

      char strbuf[128] = "";
      bool searchentry = true;
      struct passwd *pw;

      if (wincap.has_security ())
	{
	  static char NO_COPY pretty_ls[] = "????????:*:-1:-1:";
	  pr.add_line (pretty_ls);
	  cygsid tu = cygheap->user.sid ();
	  tu.string (strbuf);
	  if (myself->uid == ILLEGAL_UID)
	    searchentry = !internal_getpwsid (tu);
	}
      else if (myself->uid == ILLEGAL_UID)
        searchentry = !internal_getpwuid (DEFAULT_UID);
      if (searchentry &&
	  (!(pw = internal_getpwnam (cygheap->user.name ())) ||
	   (myself->uid != ILLEGAL_UID &&
	    myself->uid != (__uid32_t) pw->pw_uid  &&
	    !internal_getpwuid (myself->uid))))
	{
	  char linebuf[1024];
	  (void) cygheap->user.ontherange (CH_HOME, NULL);
	  snprintf (linebuf, sizeof (linebuf), "%s:*:%lu:%lu:,%s:%s:/bin/sh",
		    cygheap->user.name (),
		    myself->uid == ILLEGAL_UID ? DEFAULT_UID_NT : myself->uid,
		    myself->gid,
		    strbuf, getenv ("HOME") ?: "");
	  debug_printf ("Completing /etc/passwd: %s", linebuf);
	  pr.add_line (linebuf);
	}
d137 1
a137 2
  if (pr.isuninitialized ())
    read_etc_passwd ();
d155 1
a155 2
  if (pr.isuninitialized () || (check && pr.isinitializing ()))
    read_etc_passwd ();
d166 1
a166 2
  if (pr.isuninitialized () || (check && pr.isinitializing ()))
    read_etc_passwd ();
d287 1
a287 2
  if (pr.isinitializing ())
    read_etc_passwd ();
d325 1
a325 2
  if (pr.isinitializing ())
    read_etc_passwd ();
@


1.59
log
@* dcrt0.cc (initialize_env): Use colon for CYGWIN_DEBUG separator.
* grp.cc: Change most statics to NO_COPY throughout.
* passwd.cc: Ditto.
* pwdgrp.h: Change some BOOLs to bools.
(pwdgrp::pwdgrp): Remove unneeded constructor.
* passwd.cc: Change BOOL to bool throughout.
@
text
@d29 2
a30 5
static struct passwd NO_COPY *passwd_buf;	/* passwd contents in memory */
static int NO_COPY curr_lines;
static int NO_COPY max_lines;

static NO_COPY pwdgrp pr;
d65 2
a66 2
static int
parse_pwd (struct passwd &res, char *buf)
d68 1
d76 1
a76 1
    return 0;
d81 3
a83 14
  return 1;
}

/* Add one line from /etc/passwd into the password cache */
static void
add_pwd_line (char *line)
{
    if (curr_lines >= max_lines)
      {
	max_lines += 10;
	passwd_buf = (struct passwd *) realloc (passwd_buf, max_lines * sizeof (struct passwd));
      }
    if (parse_pwd (passwd_buf[curr_lines], line))
      curr_lines++;
d121 1
a121 2
      curr_lines = 0;
      if (!pr.load ("/etc/passwd", add_pwd_line))
d130 2
a131 2
	  static char pretty_ls[] = "????????:*:-1:-1:";
	  add_pwd_line (pretty_ls);
d153 1
a153 1
	  add_pwd_line (linebuf);
d172 1
a172 1
      for (int i = 0; i < curr_lines; i++)
d188 1
a188 1
  for (int i = 0; i < curr_lines; i++)
d200 1
a200 1
  for (int i = 0; i < curr_lines; i++)
d322 1
a322 1
  if (pw_pos < curr_lines)
@


1.58
log
@* grp.cc (read_etc_group): On NT, add a line for gid = -1.  Change name
"unknown" to "mkgroup".
(internal_getgrgid): Do not return default in nontsec case.
(internal_getgroups): Add argument srchsid and look for it in groups if not
NULL.
* passwd.cc (read_etc_passwd): On NT, add a line for uid = -1.  Use same
default uid for Win95 and NT.  Call cygheap_user::ontherange to initialize
HOME.
* cygheap.cc (init_cygheap::etc_changed): Move to uinfo.cc.
* cygheap.h (init_cygheap::etc_changed_h): Remove.
(init_cygheap::etc_changed): Ditto.
* grp.cc (group_state): Remove.  Use gr instead throughout.
(gr): Define as class pwdgrp.
(read_etc_group): Remove gr definition.  Remove calls to set_last_modified and
close.  Pass add_grp to gr.load to load file.
* passwd.cc (passwd_state): Remove.  Use pr instead, throughout.
(pr): Define as class pwdgrp.
(read_etc_passwd): Remove pr definition.  Remove calls to set_last_modified and
close.  Pass add_pwd_line to pr.load to load file.
* pwdgrp.h (etc): New helper class for pwdgrp.
(pwdgrp): Combine pwdgrp_check and pwdgrp_read into one class.  Remove file_w32
and last_modified fields.
(pwdgrp::set_last_modified): Remove.
(pwdgrp::isinitializing): Remove FindFirstFile stuff.  Move to
etc::file_changed.
(pwdgrp::load): Rename from 'open'.  Call etc::init to initialize etc scanning.
Close file handle after reading buffer into memory.  Parse buffer by calling
second argument.
(pwdgrp::gets): Reorganize slightly to rely on eptr starting at beginning of
buffer.  Free buffer when memory exhausted.
(pwdgrp::close): Remove.
* uinfo.cc (etc::dir_changed): New function.
(etc::init): Ditto.
(etc::file_changed): Ditto.
(etc::set_last_modified): Ditto.
@
text
@d29 3
a31 3
static struct passwd *passwd_buf;	/* passwd contents in memory */
static int curr_lines;
static int max_lines;
d33 1
a33 1
static pwdgrp pr;
a35 1
#ifdef _MT_SAFE
a36 3
#else
static int pw_pos = 0;
#endif
a137 1
      static char linebuf[1024];
d139 1
a139 1
      BOOL searchentry = TRUE;
d159 1
d197 1
a197 1
internal_getpwuid (__uid32_t uid, BOOL check)
d199 1
a199 2
  if (pr.isuninitialized ()
      || (check && pr.isinitializing ()))
d209 1
a209 1
internal_getpwnam (const char *name, BOOL check)
d211 1
a211 2
  if (pr.isuninitialized ()
      || (check && pr.isinitializing ()))
a368 1
#ifdef _MT_SAFE
a369 3
#else
  static char pass[_PASSWORD_LEN];
#endif
@


1.57
log
@	Split ChangeLog, create ChangeLog-2002.
	Fix copyright dates.
@
text
@d33 1
a33 2
static pwdgrp_check passwd_state;

d42 1
a42 1
/* Remove a : teminated string from the buffer, and increment the pointer */
d124 1
a124 1
   This sets passwd_state to loaded or emulated so functions in this file can
a128 2
  static pwdgrp_read pr;

d131 1
a131 1
   * at most be called once from each thread, after that the passwd_state
d136 1
a136 1
  if (passwd_state.isinitializing ())
d139 2
a140 11
      if (pr.open ("/etc/passwd"))
	{
	  char *line;
	  while ((line = pr.gets ()) != NULL)
	    add_pwd_line (line);

	  passwd_state.set_last_modified (pr.get_fhandle (), pr.get_fname ());
	  pr.close ();
	  debug_printf ("Read /etc/passwd, %d lines", curr_lines);
	}
      passwd_state = loaded;
a144 1
      __uid32_t default_uid = DEFAULT_UID;
d149 2
d153 2
a154 3
	  if (myself->uid == ILLEGAL_UID
	      && (searchentry = !internal_getpwsid (tu)))
	    default_uid = DEFAULT_UID_NT;
d164 1
d167 1
a167 1
		    myself->uid == ILLEGAL_UID ? default_uid : myself->uid,
d169 1
a169 1
		    strbuf, getenv ("HOME") ?: "/");
d184 1
a184 1
  if (passwd_state.isuninitialized ())
d203 2
a204 2
  if (passwd_state.isuninitialized ()
      || (check && passwd_state.isinitializing ()))
d216 2
a217 2
  if (passwd_state.isuninitialized ()
      || (check && passwd_state.isinitializing ()))
d339 1
a339 1
  if (passwd_state.isinitializing ())
d382 1
a382 1
  if (passwd_state.isinitializing ())
@


1.57.2.1
log
@trunk merge
@
text
@d29 6
a34 3
passwd *passwd_buf;
/* FIXME: This really should use a constructor, but they are slow */
static pwdgrp pr (passwd_buf);
d37 1
d39 32
d73 2
a74 2
bool
pwdgrp::parse_passwd ()
a75 2
  int n;
# define res (*passwd_buf)[curr_lines]
d78 6
a83 13
  memset (&res, 0, sizeof (res));
  res.pw_name = next_str ();
  res.pw_passwd = next_str ();

  n = next_int ();
  if (n < 0)
    return false;
  res.pw_uid = n;

  n = next_int ();
  if (n < 0)
    return false;
  res.pw_gid = n;
d85 38
a122 7
  res.pw_gecos = next_str ();
  res.pw_dir =  next_str ();
  res.pw_shell = next_str ();
  curr_lines++;
  return true;
# undef res
}
d125 1
a125 1
   This sets pr to loaded or emulated so functions in this file can
d127 2
a128 2
void
pwdgrp::read_passwd ()
d130 1
a130 2
  if (!load ("/etc/passwd"))
    debug_printf ("load failed");
d132 5
a136 3
  char strbuf[128] = "";
  bool searchentry = true;
  struct passwd *pw;
d138 2
a139 16
  if (wincap.has_security ())
    {
      static char NO_COPY pretty_ls[] = "????????:*:-1:-1:";
      pr.add_line (pretty_ls);
      cygsid tu = cygheap->user.sid ();
      tu.string (strbuf);
      if (myself->uid == ILLEGAL_UID)
	searchentry = !internal_getpwsid (tu);
    }
  else if (myself->uid == ILLEGAL_UID)
    searchentry = !internal_getpwuid (DEFAULT_UID);
  if (searchentry &&
      (!(pw = internal_getpwnam (cygheap->user.name ())) ||
       (myself->uid != ILLEGAL_UID &&
	myself->uid != (__uid32_t) pw->pw_uid  &&
	!internal_getpwuid (myself->uid))))
d141 43
a183 9
      char linebuf[1024];
      (void) cygheap->user.ontherange (CH_HOME, NULL);
      snprintf (linebuf, sizeof (linebuf), "%s:*:%lu:%lu:,%s:%s:/bin/sh",
		cygheap->user.name (),
		myself->uid == ILLEGAL_UID ? DEFAULT_UID_NT : myself->uid,
		myself->gid,
		strbuf, getenv ("HOME") ?: "");
      debug_printf ("Completing /etc/passwd: %s", linebuf);
      pr.add_line (linebuf);
d195 2
a196 1
  pr.refresh ();
d201 1
a201 1
      for (int i = 0; i < pr.curr_lines; i++)
d212 1
a212 1
internal_getpwuid (__uid32_t uid, bool check)
d214 3
a216 1
  pr.refresh (check);
d218 1
a218 1
  for (int i = 0; i < pr.curr_lines; i++)
d225 1
a225 1
internal_getpwnam (const char *name, bool check)
d227 3
a229 1
  pr.refresh (check);
d231 1
a231 1
  for (int i = 0; i < pr.curr_lines; i++)
d350 2
a351 1
  pr.refresh ();
d353 1
a353 1
  if (pw_pos < pr.curr_lines)
d386 1
d388 3
d393 2
a394 1
  pr.refresh ();
@


1.57.2.2
log
@merge from trunk
@
text
@d40 1
d42 2
a43 1

a44 1

d48 2
a49 1
  if (res.pw_name == res.pw_passwd)
d51 1
d53 5
a57 3
  (void) next_num (res.pw_uid);
  (void) next_num (res.pw_gid);
  res.pw_comment = NULL;
d61 1
d72 2
a73 1
  load ("/etc/passwd");
d82 1
a82 1
      add_line (pretty_ls);
d104 1
a104 1
      add_line (linebuf);
@


1.57.2.3
log
@merge from trunk
@
text
@d41 3
@


1.57.2.4
log
@merge from trunk
@
text
@d41 6
a46 3
  res.pw_name = next_str (':');
  res.pw_passwd = next_str (':');
  char *p = raw_ptr ();
a47 2
  if (p == raw_ptr ())
    return false;	/* parsing did not advance.  line is garbage */
d50 3
a52 3
  res.pw_gecos = next_str (':');
  res.pw_dir =  next_str (':');
  res.pw_shell = next_str (':');
@


1.57.2.5
log
@merge from trunk
@
text
@d43 5
a47 4
  if (!next_num (res.pw_uid))
    return false;
  if (!next_num (res.pw_gid))
    return false;
@


1.57.2.6
log
@merge from trunk
@
text
@a68 1
      /* must be static */
d84 1
a84 1
      static char NO_COPY linebuf[1024];	// must be static
@


1.57.2.7
log
@merge from trunk
@
text
@d85 1
a85 2
      static char linebuf[1024];	// must be static and
      					// should not be NO_COPY
d105 1
a105 1
  pr.refresh (false);
d255 2
a256 2
  if (pw_pos == 0)
    pr.refresh (true);
d292 2
@


1.57.2.8
log
@merge from trunk
@
text
@d100 1
a100 1
internal_getpwsid (cygpsid &sid)
@


1.57.2.9
log
@merge from trunk
@
text
@d90 1
a90 1
		myself->uid == ILLEGAL_UID ? UNKNOWN_UID : myself->uid,
@


1.57.2.10
log
@merge from trunk.
Reorganize includes throughout so that path.h comes before fhandler.h.
Eliminate path_conv arguments from fhandler functions which take them,
throughout.  Use get_name() and get_win32_name() consistently throughout for
fhandler objects.  Use build_fh_* functions throughout, where appropriate.
* fhandler.h (fhandler_base): Store path_conv struct here.  Remove dev.
* dtable.h (dtable::build_fhandler_*): Remove.
(build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* dtable.cc (build_fh_dev): New.
(build_fh_pc): New.
(build_fh_name): New.
* fhandler.h (fhandler_base::set_name): Change argument.
* fhandler.cc (fhandler_base::set_name): Just accept a path_conv argument.
(executable_states): Move.
* path.h (executable_state): Accept.
* syscalls.cc (stat_worker): Make static.
* winsup.h (stat_worker): Remove definition.
@
text
@d18 1
a19 1
#include "fhandler.h"
@


1.57.2.11
log
@merge from trunk
@
text
@d15 1
@


1.57.2.12
log
@merge from trunk
@
text
@a185 1
  pwd->pw_comment = NULL;
a242 1
  pwd->pw_comment = NULL;
@


1.56
log
@* passwd.cc (getpwuid_r32): Revert previous change.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2001, 2002 Red Hat, Inc.
@


1.55
log
@* sysconf.cc (sysconf): Return arbitrary values for _SC_GETGR_R_SIZE_MAX,
_SC_LOGIN_NAME_MAX, _SC_GETPW_R_SIZE_MAX.
* passwd.cc (getpwuid_r32): Add uid/gid fields to size check calculation.
@
text
@d269 1
a269 2
		    strlen (temppw->pw_passwd) + 5 +
		    sizeof (temppw->pw_uid) + sizeof (temppw->pw_gid);
@


1.54
log
@2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* pwdgrp.h (pwdgrp_check::pwdgrp_state): Replace by
	pwdgrp_check::isinitializing ().
	(pwdgrp_check::isinitializing): Create.
	* passwd.cc (grab_int): Change type to unsigned, use strtoul and
	set the pointer content to 0 if the field is invalid.
	(parse_pwd): Move validity test after getting pw_gid.
	(read_etc_passwd): Replace "passwd_state <= " by
	passwd_state::isinitializing ().
	(internal_getpwuid): Ditto.
	(internal_getpwnam): Ditto.
	(getpwent): Ditto.
	(getpass): Ditto.
	* grp.cc (parse_grp): Use strtoul for gr_gid and verify the validity.
	(read_etc_group): Replace "group_state <= " by
	group_state::isinitializing ().
	(internal_getgrgid): Ditto.
	(getgrent32): Ditto.
	(internal_getgrent): Ditto.

2002-12-10  Pierre Humblet <pierre.humblet@@ieee.org>

	* security.h: Move declarations of internal_getgrent,
	internal_getpwsid and internal_getgrsid to pwdgrp.h.
	* pwdgrp.h: Declare internal_getpwsid, internal_getpwnam,
	internal_getpwuid, internal_getgrsid, internal_getgrgid,
	internal_getgrnam, internal_getgrent and internal_getgroups.
	Delete "emulated" from enum pwdgrp_state.
	(pwdgrp_check::isuninitialized): Create.
	(pwdgrp_check::pwdgrp_state): Change state to initializing
	rather than to uninitialized.
	(pwdgrp_read::gets): Remove trailing CRs.
	* passwd.cc (grab_string): Don't look for NLs.
	(grab_int): Ditto.
	(parse_pwd): Don't look for CRs. Return 0 if entry is too short.
	(search_for): Delete.
	(read_etc_passwd): Simplify tests to actually read the file.
	Set state to loaded before making internal_getpwXX calls.
	Replace search_for calls by equivalent internal_pwgetXX calls.
	(internal_getpwsid): Use passwd_state.isuninitialized to decide
	to call read_etc_passwd.
	(internal_getpwuid): Create.
	(internal_getpwnam): Create.
	(getpwuid32): Simply call internal_getpwuid.
	(getpwuid_r32): Call internal_getpwuid.
	(getpwnam): Simply call internal_getpwnam.
	(getpwnam_r): Call internal_getpwnam.
	* grp.cc (parse_grp): Don't look for CRs. Adjust blank space.
	(add_grp_line): Adjust blank space.
	(class group_lock): Ditto.
	(read_etc_group): Simplify tests to actually read the file.
	Set state to loaded before making internal_getgrXX calls.
	Replace getgrXX calls by equivalent internal calls.
	(internal_getgrsid): Use group_state.isuninitialized to decide
	to call read_etc_group.
	(internal_getgrgid): Create.
	(internal_getgrnam): Create.
	(getgroups32): Simply call internal_getgrgid.
	(getgrnam32): Simply call internal_getgrnam.
	(internal_getgrent): Call group_state.isuninitialized.
	(internal_getgroups): Create from the former getgroups32, using
	two of the four arguments. Set gid to myself->gid and username
	to cygheap->user.name ().
	(getgroups32): Simply call internal_getgroup.
	(getgroups): Call internal_getgroup instead of getgroups32.
	(setgroups32): Call internal versions of get{pw,gr}XX.
	* sec_helper.cc: Include pwdgrp.h.
	(is_grp_member): Call internal versions of get{pw,gr}XX.
	* security.cc: Include pwdgrp.h.
	(alloc_sd): Call internal versions of get{pw,gr}XX.
	* syscalls.cc: Include pwdgrp.h.
	(seteuid32): Call internal versions of get{pw,gr}XX.
	(setegid32): Ditto.
	* uinfo.cc: Include pwdgrp.h.
	(internal_getlogin): Call internal versions of get{pw,gr}XX.
	(cygheap_user::ontherange): Ditto.
	* sec_acl.cc: Include pwdgrp.h.
	(setacl): Call internal versions of get{pw,gr}XX.
	(acl_access): Ditto and simplify logic.
	(aclfromtext): Ditto.
@
text
@d269 2
a270 1
		    strlen (temppw->pw_passwd) + 5;
@


1.54.4.1
log
@* sysconf.cc (sysconf): Return arbitrary values for _SC_GETGR_R_SIZE_MAX,
_SC_LOGIN_NAME_MAX, _SC_GETPW_R_SIZE_MAX.
* passwd.cc (getpwuid_r32): Add uid/gid fields to size check calculation.
* exceptions.cc (events_init): Display name of mutex on failure.
* windows.cc (setitimer): Return ENOSYS on invalid argument.
@
text
@d269 1
a269 2
		    strlen (temppw->pw_passwd) + 5 +
		    sizeof (temppw->pw_uid) + sizeof (temppw->pw_gid);
@


1.54.4.2
log
@* passwd.cc (getpwuid_r32): Revert previous change.
@
text
@d269 2
a270 1
		    strlen (temppw->pw_passwd) + 5;
@


1.53
log
@	* passwd.cc (read_etc_passwd): Never add an entry when starting
	on Win95/98/ME if a default entry is present.
	* uinfo.cc (internal_getlogin): Look for the default uid if needed.
	Always call user.set_name ().
@
text
@d30 1
a30 1
static int curr_lines = -1;
d50 1
a50 1
  while (*src && *src != ':' && *src != '\n')
d63 1
a63 1
static int
d67 2
a68 6
  int val = strtol (src, NULL, 10);
  while (*src && *src != ':' && *src != '\n')
    src++;
  if (*src == ':')
    src++;
  *p = src;
a77 6
  size_t len = strlen (buf);
  if (buf[--len] == '\r')
    buf[len] = '\0';
  if (len < 6)
    return 0;

d82 2
a123 22
/* Cygwin internal */
/* If this ever becomes non-reentrant, update all the getpw*_r functions */
static struct passwd *
search_for (__uid32_t uid, const char *name)
{
  struct passwd *res = 0;

  for (int i = 0; i < curr_lines; i++)
    {
      res = passwd_buf + i;
      /* on Windows NT user names are case-insensitive */
      if (name)
        {
	  if (strcasematch (name, res->pw_name))
	    return res;
	}
      else if (uid == (__uid32_t) res->pw_uid)
	return res;
    }
  return NULL;
}

d139 1
a139 4
  if (passwd_state != uninitialized)
    return;

  if (passwd_state != initializing)
a140 1
      passwd_state = initializing;
d152 1
d169 1
a169 1
        searchentry = !search_for (DEFAULT_UID, NULL);
d171 1
a171 1
	  (!(pw = search_for (0, cygheap->user.name ())) ||
d174 1
a174 1
	    !search_for (myself->uid, NULL))))
a183 1
      passwd_state = loaded;
d195 1
a195 1
  if (curr_lines < 0 && passwd_state  <= initializing)
d211 28
d242 1
a242 3
  if (passwd_state  <= initializing)
    read_etc_passwd ();

d244 1
a244 2

  return search_for (uid, 0);
d261 1
a261 3
  if (passwd_state  <= initializing)
    read_etc_passwd ();

a262 3

  struct passwd *temppw = search_for (uid, 0);

d299 1
a299 3
  if (passwd_state  <= initializing)
    read_etc_passwd ();

d301 1
a301 2

  return search_for (0, name);
d317 1
a317 3
  if (passwd_state  <= initializing)
    read_etc_passwd ();

a319 2
  struct passwd *temppw = search_for (0, nam);

d350 1
a350 1
  if (passwd_state  <= initializing)
a382 14
#if 0 /* Unused */
/* Internal function. ONLY USE THIS INTERNALLY, NEVER `getpwent'!!! */
struct passwd *
internal_getpwent (int pos)
{
  if (passwd_state  <= initializing)
    read_etc_passwd ();

  if (pos < curr_lines)
    return passwd_buf + pos;
  return NULL;
}
#endif

d393 1
a393 1
  if (passwd_state  <= initializing)
@


1.52
log
@	* security.h: Declare internal_getpwsid and internal_getgrsid.
	Undeclare internal_getpwent.  Define DEFAULT_UID_NT.  Change
	DEFAULT_GID.
	* passwd.cc (internal_getpwsid): New function.
	(internal_getpwent): Suppress.
	(read_etc_passwd): Make static.  Rewrite the code for the completion
	line.  Set curr_lines to 0.
	(parse_pwd): Change type to static int.  Return 0 for short lines.
	(add_pwd_line): Pay attention to the value of parse_pwd.
	(search_for): Do not look for nor return the DEFAULT_UID.
	* grp.cc (read_etc_group): Make static.  Free gr_mem and set
	curr_lines to 0.  Always call add_pwd_line.  Rewrite the code for the
	completion line.
	(internal_getgrsid): New function.
	(parse_grp): If grp.gr_mem is empty, set it to &null_ptr.
	Never NULL gr_passwd.
	(getgrgid32): Only return the default if ntsec is off and the gid is
	ILLEGAL_GID.
	* sec_helper.cc (cygsid::get_id): Use getpwsid and getgrsid.
	(cygsid_getfrompw): Clean up last line.
	(cygsid_getfromgr): Ditto.
	(is_grp_member): Use getpwuid32 and getgrgid32.
	* uinfo.cc (internal_getlogin): Set DEFAULT_GID at start.
	Use getpwsid. Move the read of /etc/group after the second access
	to /etc/passwd.  Change some debug_printf.
@
text
@d201 2
@


1.51
log
@whitespace
@
text
@d30 1
a30 1
static int curr_lines;
d77 1
a77 1
void
d85 2
d96 1
d108 2
a109 1
    parse_pwd (passwd_buf[curr_lines++], line);
d132 22
d157 1
a157 1
void
d175 1
d180 1
a180 2
	    if (strlen (line))
	      add_pwd_line (line);
a182 1
	  passwd_state = loaded;
d186 20
a205 1
      else
d207 7
a213 40
	  static char linebuf[1024];

	  if (wincap.has_security ())
	    {
	      HANDLE ptok;
	      cygsid tu, tg;
	      DWORD siz;

	      if (OpenProcessToken (hMainProc, TOKEN_QUERY, &ptok))
		{
		  if (GetTokenInformation (ptok, TokenUser, &tu, sizeof tu,
					   &siz)
		      && GetTokenInformation (ptok, TokenPrimaryGroup, &tg,
					      sizeof tg, &siz))
		    {
		      char strbuf[100];
		      snprintf (linebuf, sizeof (linebuf),
				"%s::%lu:%lu:%s:%s:/bin/sh",
				cygheap->user.name (),
				*GetSidSubAuthority (tu,
					     *GetSidSubAuthorityCount(tu) - 1),
				*GetSidSubAuthority (tg,
					     *GetSidSubAuthorityCount(tg) - 1),
				tu.string (strbuf), getenv ("HOME") ?: "/");
		      debug_printf ("Emulating /etc/passwd: %s", linebuf);
		      add_pwd_line (linebuf);
		      passwd_state = emulated;
		    }
		  CloseHandle (ptok);
		}
	    }
	  if (passwd_state != emulated)
	    {
	      snprintf (linebuf, sizeof (linebuf), "%s::%u:%u::%s:/bin/sh",
			cygheap->user.name (), (unsigned) DEFAULT_UID,
			(unsigned) DEFAULT_GID, getenv ("HOME") ?: "/");
	      debug_printf ("Emulating /etc/passwd: %s", linebuf);
	      add_pwd_line (linebuf);
	      passwd_state = emulated;
	    }
d215 1
a215 1

a216 1

d220 2
a221 4
/* Cygwin internal */
/* If this ever becomes non-reentrant, update all the getpw*_r functions */
static struct passwd *
search_for (__uid32_t uid, const char *name)
d223 6
a228 2
  struct passwd *res = 0;
  struct passwd *default_pw = 0;
d230 1
a230 1
  for (int i = 0; i < curr_lines; i++)
d232 7
a238 11
      res = passwd_buf + i;
      if (res->pw_uid == DEFAULT_UID)
	default_pw = res;
      /* on Windows NT user names are case-insensitive */
      if (name)
	{
	  if (strcasematch (name, res->pw_name))
	    return res;
	}
      else if (uid == (__uid32_t) res->pw_uid)
	return res;
a239 8

  /* Return default passwd entry if passwd is emulated or it's a
     request for the current user. */
  if (passwd_state != loaded
      || (!name && uid == myself->uid)
      || (name && strcasematch (name, cygheap->user.name ())))
    return default_pw;

d402 1
d414 1
@


1.50
log
@* fhandler.cc (fhandler_base::dup): Don't set handle on failure.  Caller has
already taken care of that.
* fhandler_console.cc (fhandler_console::open): Initialize handles to NULL.
(fhandler_console::close): Ditto.  GNUify non-GNU formatted functions calls
throughout.
@
text
@d172 1
a172 1
	        {
d174 1
a174 1
		                           &siz)
d183 1
a183 1
				             *GetSidSubAuthorityCount(tu) - 1),
d185 1
a185 1
				             *GetSidSubAuthorityCount(tg) - 1),
d192 1
a192 1
	        }
@


1.49
log
@Use hMainProc where appropriate, throughout.
* environ.cc (spenv::retrieve): Add debugging statements.
* pinfo.cc (set_myself): Don't call strace.hello if already stracing.
* strace.cc (strace): Move NO_COPY keyword so that it will actually take
effect.
@
text
@d156 1
a156 1
	  passwd_state.set_last_modified (pr.get_fhandle(), pr.get_fname ());
d182 1
a182 1
				*GetSidSubAuthority(tu,
d184 1
a184 1
				*GetSidSubAuthority(tg,
d249 1
a249 1
  pthread_testcancel();
d271 1
a271 1
  pthread_testcancel();
d314 1
a314 1
  pthread_testcancel();
d335 1
a335 1
  pthread_testcancel();
@


1.48
log
@* dtable.cc (handle_to_fn): Check error return value from NtQueryObject first
before seeing if name buffer is NULL.
* grp.cc (read_etc_group): Fix gcc warning regarding snprintf format.
* passwd.cc (read_etc_passwd): Ditto.
@
text
@d171 1
a171 1
	      if (OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok))
@


1.47
log
@	* grp.cc (read_etc_group): When emulating nonexisting group file on
	NT systems, read primary group SID from process token.  Use that info
	to create correct group entry.  On error or on 9x systems fallback
	to emulating Administrators group as before.
	(read_etc_passwd): When emulating nonexisting passwd file on NT systems,
	read user and primary group SID from process token.  Use that info to
	create correct passwd entry.  On error or on 9x systems fallback to
	emulating user with Administrator user id and Administrators group
	as before.
@
text
@d180 1
a180 1
				"%s::%u:%u:%s:%s:/bin/sh",
@


1.46
log
@	* grp.cc (etc_group): Removed.
	(parse_grp): Make line parameter nonconst.  Don't copy data into new
	allocated memory.  Check for CR instead of LF to accomodate new
	read method.
	(add_grp_line): Make line parameter nonconst.
	(read_etc_group): Rearrange using new pwdgrp_read class.
	* passwd.cc (parse_pwd): Don't copy data into new allocated memory.
	Check for CR instead of LF to accomodate new read method.
	(read_etc_passwd): Rearrange using new pwdgrp_read class.
	* pwdgrp.h (pwdgrp_check::set_last_modified):  Use different
	parameters.
	(class pwdgrp_read): New class for opening and reading passwd and
	group files.
@
text
@d163 1
a163 1
	  static char linebuf[400];
d165 38
a202 6
	  debug_printf ("Emulating /etc/passwd");
	  snprintf (linebuf, sizeof (linebuf), "%s::%u:%u::%s:/bin/sh",
	  	    cygheap->user.name (), (unsigned) DEFAULT_UID,
		    (unsigned) DEFAULT_GID, getenv ("HOME") ?: "/");
	  add_pwd_line (linebuf);
	  passwd_state = emulated;
@


1.45
log
@Remove unneeded sigproc.h includes throughout.
* fhandler.h (fhandler_proc::fill_filebuf): Take a pinfo argument.
* fhandler_proc.cc (fhandler_proc::get_proc_fhandler): Simplify search for
given pid.
(fhandler_proc::readdir): Assume that pid exists if it shows up in the winpid
list.
* fhandler_process.cc (fhandler_process::open): Simplify search for given pid.
Call fill_filebuf with pinfo argument.
(fhandler_process::fill_filebuf): Pass pinfo here and assume that it exists.
* pinfo.h (pinfo::remember): Define differently if sigproc.h is not included.
* dll_init.cc (dll_list::detach): Don't run destructor on exit.
@
text
@d83 7
a89 9
  char *mybuf = (char *) malloc (len + 1);
  (void) memcpy (mybuf, buf, len + 1);
  if (mybuf[--len] == '\n')
    mybuf[len] = '\0';

  res.pw_name = grab_string (&mybuf);
  res.pw_passwd = grab_string (&mybuf);
  res.pw_uid = grab_int (&mybuf);
  res.pw_gid = grab_int (&mybuf);
d91 3
a93 3
  res.pw_gecos = grab_string (&mybuf);
  res.pw_dir =  grab_string (&mybuf);
  res.pw_shell = grab_string (&mybuf);
d134 1
a134 10
    char linebuf[1024];
    /* A mutex is ok for speed here - pthreads will use critical sections not mutex's
     * for non-shared mutexs in the future. Also, this function will at most be called
     * once from each thread, after that the passwd_state test will succeed
     */
    passwd_lock here (cygwin_finished_initializing);

    /* if we got blocked by the mutex, then etc_passwd may have been processed */
    if (passwd_state != uninitialized)
      return;
d136 36
a171 32
    if (passwd_state != initializing)
      {
	passwd_state = initializing;
	if (max_lines) /* When rereading, free allocated memory first. */
	  {
	    for (int i = 0; i < curr_lines; ++i)
	      free (passwd_buf[i].pw_name);
	    curr_lines = 0;
	  }

	FILE *f = fopen ("/etc/passwd", "rt");

	if (f)
	  {
	    while (fgets (linebuf, sizeof (linebuf), f) != NULL)
	      {
		if (strlen (linebuf))
		  add_pwd_line (linebuf);
	      }

	    passwd_state.set_last_modified (f);
	    fclose (f);
	    passwd_state = loaded;
	  }
	else
	  {
	    debug_printf ("Emulating /etc/passwd");
	    snprintf (linebuf, sizeof (linebuf), "%s::%u:%u::%s:/bin/sh", cygheap->user.name (),
		      (unsigned) DEFAULT_UID, (unsigned) DEFAULT_GID, getenv ("HOME") ?: "/");
	    add_pwd_line (linebuf);
	    passwd_state = emulated;
	  }
d173 1
a173 1
      }
@


1.44
log
@	Change internal uid datatype from __uid16_t to __uid32_t
	throughout.
	* cygwin.din: Export new symbols getpwuid32, getpwuid_r32, getuid32,
	geteuid32, setuid32, seteuid32.
	* passwd.cc (getpwuid32): New function.
	(getpwuid_r32): Ditto.
	* syscalls.cc (seteuid32): Ditto.
	(setuid32): Ditto.
	* uinfo.cc (getuid32): Ditto.
	(geteuid32): Ditto.
	* winsup.h (uid16touid32): New macro, correclt casting from __uid16_t
	to __uid32_t.
	(gid16togid32): Ditto fir gids.
	(getuid32): Declare.
	(geteuid32): Ditto.
	(getpwuid32): Ditto.
	* include/sys/cygwin.h (struct external_pinfo): Add members uid32 and
	gid32.
@
text
@a20 1
#include "sigproc.h"
@


1.43
log
@Remove unneeded sync.h, where appropriate, throughout.  Remove unneeded heap.h,
where appropriate, throughout.  Remove unneeded exceptions.h, where
appropriate, throughout.  Remove unneeded perprocess.h, where appropriate,
throughout.
@
text
@d189 1
a189 1
search_for (__uid16_t uid, const char *name)
d205 1
a205 1
      else if (uid == res->pw_uid)
d220 1
a220 1
getpwuid (__uid16_t uid)
d230 6
d237 1
a237 1
getpwuid_r (__uid16_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
d276 6
@


1.42
log
@* times.cc (hires::prime): Restore thread priority on failure condition.
* uinfo.cc (uinfo_init): Use more robust method for determining if process was
invoked from a non-cygwin process.
* sync.h (muto::init): Eliminate "inheritance" parameter.
(new_muto): Reflect removal of parameter.
* sync.cc (muto::init): Ditto.
* cygheap.cc (cygheap_init): Ditto.
* debug.cc (threadname_init): Ditto.
* exceptions.cc (events_init): Ditto.
* malloc.cc (malloc_init): Ditto.
* path.cc (cwdstuff::init): Ditto.
* sigproc.cc (sigproc_init): Ditto.
* grp.cc (group_lock): Use different method for locking with static member.
(read_etc_group): REALLY ensure that read lock mutex is released.
* passwd.cc (passwd_lock): Use different method for locking with static member.
(read_etc_passwd): REALLY ensure that read lock mutex is released.
* shared.cc (sec_user): Correct reversed inheritance test.
@
text
@a20 1
#include "sync.h"
@


1.41
log
@	* child_info.h, cygheap.h, fhandler_clipboard.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, thread.h, uinfo.cc, include/cygwin/acl.h: Fix copyright.
@
text
@d114 2
a115 1
  pthread_mutex_t mutex;
d117 6
a122 2
  passwd_lock (): mutex ((pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER) {}
  void arm () {pthread_mutex_lock (&mutex); }
d125 1
a125 1
    if (mutex != (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER)
d130 2
d143 1
a143 4
    static NO_COPY passwd_lock here;

    if (cygwin_finished_initializing)
      here.arm ();
@


1.40
log
@	* (child_info.h, cygheap.h, dcrt0.cc, dir.cc, fhandler.cc, fhandler.h,
	fhandler_clipboard.cc, fhandler_disk_file.cc, fhandler_dsp.cc,
	fhandler_floppy.cc, fhandler_mem.cc, fhandler_random.cc,
	fhandler_tape.cc, fhandler_zero.cc, grp.cc, mmap.cc, passwd.cc,
	pinfo.cc, pinfo.h, pipe.cc, sec_acl.cc, sec_helper.cc, security.cc,
	security.h, spawn.cc, syscalls.cc, thread.h, uinfo.cc, winsup.h):
	Change usage of uid_t to __uid16_t, gid_t to __gid16_t and
	off_t to __off32_t throughout.  Use INVALID_UID, INVALID_GID and
	INVALID_SEEK instead casting -1 to the appropriate type.
	* winsup.h: Define INVALID_UID, INVALID_GID and INVALID_SEEK.
	* include/cygwin/acl.h: Define internal __aclent16_t and __aclent32_t
	types.  Don't declare acl functions when compiling Cygwin.
	* include/cygwin/grp.h: Declare getgrgid() and getgrnam() with
	correct types for internal usage.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2001 Red Hat, Inc.
@


1.39
log
@* fhandler.cc (fhandler_base::fork_fixup): Don't protect handle.
* dlfcn.cc: Fix to confirm to coding standards.  Reorganize includes throughout
to accomodate new cygheap.h usage.
* cygheap.h (cygheap_fdmanip): New class: simplifies locking and retrieval of
fds from cygheap->fdtab.
(cygheap_fdget): Ditto.
(cygheap_fdnew): Ditto.
* fcntl.cc (_fcntl): Use new method to lock fdtab and retrieve info.
* ioctl.cc (ioctl): Ditto.
* mmap.cc (mmap): Ditto.
* net.cc: Ditto, throughout.
* passwd.cc (getpass): Ditto.
* path.cc (fchdir): Ditto.
* pipe.cc (make_pipe): Ditto.
* sec_acl.cc (facl): Ditto.
* syscalls.cc: Ditto, throughout.
* termios.cc: Ditto, throughout.
@
text
@d186 1
a186 1
search_for (uid_t uid, const char *name)
d217 1
a217 1
getpwuid (uid_t uid)
d228 1
a228 1
getpwuid_r (uid_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
d340 1
a340 1
getpwduid (uid_t)
@


1.38
log
@* autoload.cc (wsock_init): Reorganize slightly to accomodate a new compiler.
@
text
@d388 4
a391 5
  if (cygheap->fdtab.not_open (0))
    {
      set_errno (EBADF);
      pass[0] = '\0';
    }
a393 1
      fhandler_base *fhstdin = cygheap->fdtab[0];
@


1.37
log
@Add "path.h" include throughout, where needed.  Use new path_conv methods and
operators to simplify testing for directory and attributes, throughout.
* path.h (path_conv::exists): New method.
(path_conv::has_attribute): Ditto.
(path_conv::isdir): Ditto.
(path_conv::DWORD &): New operator.
(path_conv::int &): Ditto.
* dir.cc (rmdir): Eliminate a goto.
* dtable.cc (dtable::build_fhandler): Accept opt and suffix info for
path_conv.check.  Return fh == NULL on path_conv error.  Pass unit to set_name
as appropriate.
(dtable::reset_unix_path_name): New method.
* dtable.h (dtable): Declare new method.  Reflect arg changes to
build_fhandler.
* fhandler.cc (fhandler_disk_dummy_name): Eliminate.
(fhandler_base::set_name): Expect paths to be NULL.  Build unix_path_name from
win32_path_name when it is a device.
(fhandler_base::reset_unix_path_name): New method.
(fhandler_base::raw_read): Report EISDIR when ERROR_INVALID_FUNCTION or
ERROR_INVALID_PARAMETER and reading a directory.
(fhandler_disk_file::fstat): Don't call stat_dev since we should now never be
calling fhandler_disk_file methods with devices.
(fhandler_base::fhandler_base): Clear {unix,win32}_path_name.
(fhandler_base::~fhandler_base): Always free {unix,win32}_path_name.
(fhandler_disk_file::fhandler_disk_file): Remove set_no_free_names kludge.
(fhandler_disk_file::open): Ditto.
* fhandler.h (fhandler_base::no_free_names): Eliminate.
(fhandler_base::set_no_free_names): Ditto.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Don't set
unix_path_name here.
* path.cc (fchdir): Lock fd table throughout.  Use new
dtable::reset_unix_path_name method to reset path.
* syscalls.cc (stat_worker): Reorganize to always call fstat method.  Pass
path_conv method to fhandler_*::open.
(chroot): Elminate a goto.
@
text
@d173 1
a173 1
		      DEFAULT_UID, DEFAULT_GID, getenv ("HOME") ?: "/");
@


1.36
log
@* passwd.cc (read_etc_passwd): Bother with unlocking when not in cygwin
initialization.
* grp.cc (read_etc_group): Ditto.
@
text
@d19 1
a20 1
#include "path.h"
@


1.35
log
@* passwd.cc (read_etc_passwd): Don't bother with locking when
in cygwin initialization since there is only one thread.
* grp.cc (read_etc_group): Ditto.
@
text
@d118 5
@


1.34
log
@* grp.cc (read_etc_group): Just reuse group_buf storage for subsequent reread
of /etc/group.
* passwd.cc (read_etc_passwd): Just reuse passwd_buf storage for subsequent
reread of /etc/passwd.
@
text
@d112 8
d131 4
a134 2
    static NO_COPY pthread_mutex_t etc_passwd_mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock (&etc_passwd_mutex);
d138 1
a138 4
      {
	pthread_mutex_unlock(&etc_passwd_mutex);
	return;
      }
d175 1
a175 1
  pthread_mutex_unlock (&etc_passwd_mutex);
@


1.34.2.1
log
@Merged changes from HEAD
@
text
@a111 13
class passwd_lock
{
  pthread_mutex_t mutex;
 public:
  passwd_lock (): mutex ((pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER) {}
  void arm () {pthread_mutex_lock (&mutex); }
  ~passwd_lock ()
  {
    if (mutex != (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER)
      pthread_mutex_unlock (&mutex);
  }
};

d123 2
a124 4
    static NO_COPY passwd_lock here;

    if (cygwin_finished_initializing)
      here.arm ();
d128 4
a131 1
      return;
d168 1
a168 1
  return;
@


1.34.2.2
log
@Merged changes from HEAD
@
text
@d19 1
a20 1
#include "dtable.h"
@


1.34.2.3
log
@Merged changes from HEAD
@
text
@d173 1
a173 1
		      (unsigned) DEFAULT_UID, (unsigned) DEFAULT_GID, getenv ("HOME") ?: "/");
d388 5
a392 4
  cygheap_fdget fhstdin (0);

  if (fhstdin < 0)
    pass[0] = '\0';
d395 1
@


1.34.2.4
log
@Merged changes from HEAD
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2001, 2002 Red Hat, Inc.
d114 1
a114 2
  bool armed;
  static NO_COPY pthread_mutex_t mutex;
d116 2
a117 6
  passwd_lock (bool doit)
  {
    if (doit)
      pthread_mutex_lock (&mutex);
    armed = doit;
  }
d120 1
a120 1
    if (armed)
a124 2
pthread_mutex_t NO_COPY passwd_lock::mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;

d136 4
a139 1
    passwd_lock here (cygwin_finished_initializing);
d186 1
a186 1
search_for (__uid16_t uid, const char *name)
d217 1
a217 1
getpwuid (__uid16_t uid)
d228 1
a228 1
getpwuid_r (__uid16_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
d340 1
a340 1
getpwduid (__uid16_t)
@


1.34.2.5
log
@Merged changes from HEAD
@
text
@d21 2
d85 9
a93 7
  if (buf[--len] == '\r')
    buf[len] = '\0';

  res.pw_name = grab_string (&buf);
  res.pw_passwd = grab_string (&buf);
  res.pw_uid = grab_int (&buf);
  res.pw_gid = grab_int (&buf);
d95 3
a97 3
  res.pw_gecos = grab_string (&buf);
  res.pw_dir =  grab_string (&buf);
  res.pw_shell = grab_string (&buf);
d138 10
a147 1
  static pwdgrp_read pr;
d149 32
a180 9
  /* A mutex is ok for speed here - pthreads will use critical sections not
   * mutexes for non-shared mutexes in the future. Also, this function will
   * at most be called once from each thread, after that the passwd_state
   * test will succeed */
  passwd_lock here (cygwin_finished_initializing);

  /* if we got blocked by the mutex, then etc_passwd may have been processed */
  if (passwd_state != uninitialized)
    return;
d182 1
a182 60
  if (passwd_state != initializing)
    {
      passwd_state = initializing;
      if (pr.open ("/etc/passwd"))
	{
	  char *line;
	  while ((line = pr.gets ()) != NULL)
	    if (strlen (line))
	      add_pwd_line (line);

	  passwd_state.set_last_modified (pr.get_fhandle(), pr.get_fname ());
	  passwd_state = loaded;
	  pr.close ();
	  debug_printf ("Read /etc/passwd, %d lines", curr_lines);
	}
      else
	{
	  static char linebuf[1024];

	  if (wincap.has_security ())
	    {
	      HANDLE ptok;
	      cygsid tu, tg;
	      DWORD siz;

	      if (OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &ptok))
	        {
		  if (GetTokenInformation (ptok, TokenUser, &tu, sizeof tu,
		                           &siz)
		      && GetTokenInformation (ptok, TokenPrimaryGroup, &tg,
					      sizeof tg, &siz))
		    {
		      char strbuf[100];
		      snprintf (linebuf, sizeof (linebuf),
				"%s::%lu:%lu:%s:%s:/bin/sh",
				cygheap->user.name (),
				*GetSidSubAuthority(tu,
				             *GetSidSubAuthorityCount(tu) - 1),
				*GetSidSubAuthority(tg,
				             *GetSidSubAuthorityCount(tg) - 1),
				tu.string (strbuf), getenv ("HOME") ?: "/");
		      debug_printf ("Emulating /etc/passwd: %s", linebuf);
		      add_pwd_line (linebuf);
		      passwd_state = emulated;
		    }
		  CloseHandle (ptok);
	        }
	    }
	  if (passwd_state != emulated)
	    {
	      snprintf (linebuf, sizeof (linebuf), "%s::%u:%u::%s:/bin/sh",
			cygheap->user.name (), (unsigned) DEFAULT_UID,
			(unsigned) DEFAULT_GID, getenv ("HOME") ?: "/");
	      debug_printf ("Emulating /etc/passwd: %s", linebuf);
	      add_pwd_line (linebuf);
	      passwd_state = emulated;
	    }
	}

    }
d190 1
a190 1
search_for (__uid32_t uid, const char *name)
d206 1
a206 1
      else if (uid == (__uid32_t) res->pw_uid)
d221 1
a221 1
getpwuid32 (__uid32_t uid)
a230 6
extern "C" struct passwd *
getpwuid (__uid16_t uid)
{
  return getpwuid32 (uid16touid32 (uid));
}

d232 1
a232 1
getpwuid_r32 (__uid32_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
a270 6
}

extern "C" int
getpwuid_r (__uid16_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result)
{
  return getpwuid_r32 (uid16touid32 (uid), pwd, buffer, bufsize, result);
@


1.34.2.6
log
@Merged changes from HEAD
@
text
@d171 1
a171 1
	      if (OpenProcessToken (hMainProc, TOKEN_QUERY, &ptok))
@


1.34.2.7
log
@Merged changes from HEAD
@
text
@d156 1
a156 1
	  passwd_state.set_last_modified (pr.get_fhandle (), pr.get_fname ());
d182 1
a182 1
				*GetSidSubAuthority (tu,
d184 1
a184 1
				*GetSidSubAuthority (tg,
d249 1
a249 1
  pthread_testcancel ();
d271 1
a271 1
  pthread_testcancel ();
d314 1
a314 1
  pthread_testcancel ();
d335 1
a335 1
  pthread_testcancel ();
@


1.33
log
@Update copyrights.
@
text
@d140 1
a140 2
	    free (passwd_buf);
	    curr_lines = max_lines = 0;
@


1.32
log
@	* cygheap.cc (init_cygheap::etc_changed): New method to signal
	a change in /etc.
	* cygheap.h (struct init_cygheap): Add member `etc_changed_h'
	and method `etc_changed'.
	* grp.cc (enum grp_state): Eliminate.
	(class grp_check): Ditto.
	(group_state): Define as `class pwdgrp_check'.
	(parse_grp): Remeber path and modification time of /etc/group file.
	* passwd.cc (enum_pwd_state): Eliminate.
	(class pwd_check): Ditto.
	(passwd_state): Define as `class pwdgrp_check'.
	(read_etc_passwd): Remember path and modification time of /etc/passwd
	file.
	* pwdgrp.h: New file.
	(enum pwdgrp_state): Substitutes `pwd_state' and `grp_state'.
	(class pwdgrp_check): Substitutes `pwd_check' and `grp_check'.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 2001 Cygnus Solutions.
@


1.31
log
@* cygheap.h (init_cygheap): Move heap pointers here.
* include/sys/cygwin.h (perprocess): Remove heap pointers.
* dcrt0.cc (__cygwin_user_data): Reflect obsolete perprocess stuff.
(_dll_crt0): Don't initialize heap pointers.
(cygwin_dll_init): Ditto.
(release_upto): Use heap pointers from cygheap.
* heap.h: Ditto.
* fork.cc (fork_parent): Ditto.  Don't set heap pointers in ch.
(fork_child): Remove obsolete sigproc_fixup_after_fork.
* shared.cc (memory_init): Reorganize so that cygheap initialization is called
prior to regular heap since regular heap uses cygheap now.
* sigproc.cc (proc_subproc): Eliminate zombies allocation.
(sigproc_init): Move zombies alloation here.  Don't free up array on fork, just
reuse it.
(sigproc_fixup_after_fork): Eliminate.
* sigproc.h: Ditto.
* include/cygwin/version.h: Reflect change to perprocess structure.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998 Cygnus Solutions.
d26 1
d35 1
a35 51
/* Set to loaded when /etc/passwd has been read in by read_etc_passwd ().
   Set to emulated if passwd is emulated. */
/* Functions in this file need to check the value of passwd_state
   and read in the password file if it isn't set. */
enum pwd_state {
  uninitialized = 0,
  initializing,
  emulated,
  loaded
};
class pwd_check {
  pwd_state state;
  FILETIME  last_modified;
  char	    pwd_w32[MAX_PATH];

public:
  pwd_check () : state (uninitialized)
    {
      last_modified.dwLowDateTime = last_modified.dwHighDateTime = 0;
      pwd_w32[0] = '\0';
    }
  operator pwd_state ()
    {
      HANDLE h;
      WIN32_FIND_DATA data;

      if (!pwd_w32[0])	/* First call. */
	{
	  path_conv p ("/etc/passwd", PC_SYM_FOLLOW | PC_FULL);
	  if (!p.error)
	    strcpy (pwd_w32, p.get_win32 ());
	}

      if ((h = FindFirstFile (pwd_w32, &data)) != INVALID_HANDLE_VALUE)
	{
	  if (CompareFileTime (&data.ftLastWriteTime, &last_modified) > 0)
	    {
	      state = uninitialized;
	      last_modified = data.ftLastWriteTime;
	    }
	  FindClose (h);
	}
      return state;
    }
  void operator = (pwd_state nstate)
    {
      state = nstate;
    }
};

static pwd_check passwd_state;
d154 1
@


1.30
log
@* cygheap.h (init_cygheap): Move bucket array here from cygheap.cc.
* cygheap.cc: Throughout use bucket array from cygheap.
* sigproc.cc (proc_subproc): Dynamically allocate zombie buffer to save DLL
space.
(sigproc_fixup_after_fork): Free zombie array after a fork.
* sigproc.h (sigproc_fixup_after_fork): Declare.
* dir.cc (mkdir): Expand buffer for security descriptor to 4K to avoid stack
corruption.
* fhandler.cc (fhandler_base::open): Ditto.
* path.cc (symlink): Ditto.
@
text
@d75 1
a75 1
        }
@


1.29
log
@        * net.cc (cygwin_inet_ntoa): Rearrange previous patch to use
        thread local buffer space when compiled thread safe.
        (cygwin_getprotobyname): Ditto.
        (cygwin_getprotobynumber): Ditto.
        (cygwin_getservbyname): Ditto.
        (cygwin_getservbyport): Ditto.
        (cygwin_gethostbyname): Ditto.
        (cygwin_gethostbyaddr): Ditto. Move near to cygwin_gethostbyname.
        * thread.h (struct _winsup_t): Add pointers for above used buffer space.
        * passwd.cc (getpwduid): Remove initializing passwd.
        (setpwent): Ditto.
        (endpwent): Ditto.
        (setpassent): Ditto.
@
text
@d30 3
a32 3
static struct passwd *passwd_buf = NULL;	/* passwd contents in memory */
static int curr_lines = 0;
static int max_lines = 0;
@


1.28
log
@        * grp.cc (class grp_check): New class. Make `group_state'
        a member of class grp_check.
        (read_etc_group): Free former allocated memory on reread.
        * passwd.cc (class pwd_check): New class Make `passwd_state'
        a member of class pwd_check.
        (read_etc_passwd): Free former allocated memory on reread.
@
text
@a378 3
  if (passwd_state  <= initializing)
    read_etc_passwd ();

a384 3
  if (passwd_state  <= initializing)
    read_etc_passwd ();

a390 3
  if (passwd_state  <= initializing)
    read_etc_passwd ();

a396 3
  if (passwd_state  <= initializing)
    read_etc_passwd ();

@


1.27
log
@Throughout, reorganize header file inclusion to put security.h prior to
fhandler.h.
* fhandler.h (fhandler_base::get_inheritance): New method.
* fhandler_socket.cc (fhandler_socket::create_secret_event): Use proper
close-on-exec inheritance when creating.
(fhandler_socket::check_peer_secret_event): Create handle as non-inheritable.
@
text
@d20 1
d44 42
a85 1
static pwd_state passwd_state = uninitialized;
d185 7
@


1.26
log
@* mmap.cc: Clean up *ResourceLock calls throughout.
* thread.cc (pthread_cond::TimedWait): Check for WAIT_TIMEOUT as well as
WAIT_ABANDONED.
(__pthread_cond_timedwait): Calculate a relative wait from the abstime
parameter.
@
text
@d17 1
a23 1
#include "security.h"
@


1.25
log
@forced commit
@
text
@d136 2
a137 2
        pthread_mutex_unlock(&etc_passwd_mutex);
        return;
d209 1
a209 1
  
d215 1
a215 1
extern "C" int 
d235 1
a235 1
  		    strlen (temppw->pw_shell) + strlen (temppw->pw_gecos) +
d262 1
a262 1
  
d269 1
a269 1
/* the max size buffer we can expect to 
d293 1
a293 1
  		    strlen (temppw->pw_shell) + strlen (temppw->pw_gecos) +
d297 1
a297 1
    
@


1.24
log
@* grp.cc (read_etc_group): Don't copy mutex on fork.
* pwd.cc (read_etc_passwd): Ditto.
* autoload.cc (LoadDLLfuncEx): Use LoadDLLprime to initialize DLL specific
area.
@
text
@@


1.23
log
@        * grp.cc: Eliminate MAX_DOMAIN_NAME define.
        (read_etc_group): Substitute MAX_DOMAIN_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * passwd.cc (parse_pwd): Don't force pw_name to be lower case.
        * sec_helper.cc: Substitute MAX_USER_NAME by UNLEN,
        MAX_COMPUTERNAME_LENGTH by INTERNET_MAX_HOST_NAME_LENGTH throughout.
        (lookup_name): Slight cleanup.
        * security.cc (alloc_sd): Substitute MAX_USER_NAME by UNLEN.
        * security.h: Define DEFAULT_UID as DOMAIN_USER_RID_ADMIN and
        DEFAULT_GID as DOMAIN_ALIAS_RID_ADMINS.
        * shared.cc (memory_init): Substitute MAX_USER_NAME by UNLEN.
        * thread.h: Ditto.
        * uinfo.cc (internal_getlogin): Substitute MAX_USER_NAME by UNLEN.
        Substitute MAX_COMPUTERNAME_LENGTH and MAX_HOST_NAME by
        INTERNET_MAX_HOST_NAME_LENGTH.
        * winsup.h: Include lmcons.h. Eliminate MAX_USER_NAME and
        MAX_HOST_NAME. Move DEFAULT_UID and DEFAULT_GID to security.h.
@
text
@d130 1
a130 1
    static pthread_mutex_t etc_passwd_mutex = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;
@


1.22
log
@        * autoload.cc: Add LoadDLLfunc statements for SetTokenInformation@@16.
        * cygheap.cc: Include security.h.
        * grp.cc (internal_getgrent): New function.
        (getgroups): Rearranged using `internal_getgrent' and the new
        `cygsid' class.
        * passwd.cc (internal_getpwent): New function.
        * sec_acl.cc: Use new `cygsid' class throughout.
        (acl_access): Use `internal_getgrent' instead of `getgrent'.
        * sec_helper.cc: Use new `cygsid' class throughout.
        (get_id_from_sid): Use `internal_getgrent' instead of `getgrent'.
        Use `internal_getpwent' instead of `getpwent'.
        * security.cc: Use new `cygsid' class throughout.
        * security.h: Move `MAX_SID_LEN' from winsup.h to here.
        Add extern declarations for `internal_getgrent' and `internal_getpwent'.
        (class cygsid): New class.
        * shared.cc (sec_user): Use new `cygsid' class.
        * syscalls.cc (seteuid): Try to set owner to user and primary group to
        current group in impersonation token before performing impersonation.
        (setegid): Try to set primary group in process token to the new group
        if ntsec is on.
        * uinfo.cc (internal_getlogin): Use new `cygsid' class.
        Try to set owner to user and primary group to current group in process
        token if the process has been started from a non cygwin process.
        (uinfo_init): Set primary group only if the process has been started
        from a non cygwin process.
        * winsup.h: Move define for `MAX_SID_LEN' to security.h.
@
text
@d23 1
d97 1
a97 1
  res.pw_name = strlwr (grab_string (&mybuf));
@


1.21
log
@        * passwd.cc (getpwnam_r): Add pw_passwd handling as well.
        (getpwuid_r): Ditto.
@
text
@d362 12
@


1.20
log
@        * passwd.cc (getpwnam_r): Use correct offsets into buffer.
        Copy pw_gecos field as well.
        (getpwuid_r): Ditto.
@
text
@d234 2
a235 1
  		    strlen (temppw->pw_shell) + strlen (temppw->pw_gecos) + 4;
d247 1
d252 1
d292 2
a293 1
  		    strlen (temppw->pw_shell) + strlen (temppw->pw_gecos) + 4;
d305 1
d310 1
@


1.19
log
@Sun Apr 22 20:22:00 2001  Robert Collins <rbtcollins@@hotmail.com>

	* passwd.cc (getpwuid): Check for thread cancellation.
	(getpwuid_r): Ditto.
	(getpwname): Ditto.
	(getpwnam_r): Ditto.
	* thread.h (pthread_mutex): New constructors for pshared operation.
	(MTinterface): Associative array for pshared mutex's.
	* thread.cc (MTinterface::Init): Initailize pshared mutex array.
	(pthread_cond::BroadCast): Implementation notes.
	(pthread_cond::TimedWait): Remove use of SignalObjectAndWait on non-NT systems.
	(pthread_mutex::pthread_mutex(unsigned short)): New function.
	(pthread_mutex::pthread_mutex (pthread_mutex_t *, pthread_mutexattr *)):New function.
	(pthread_mutex::pthread_mutex(pthread_mutexattr *)): Fail on pshared mutex's.
	(__pthread_mutex_getpshared): New function.
	(__pthread_join): Check for thread cancellation.
	(__pthread_cond_timedwait): Support pshared mutex's.
	(__pthread_cond_wait): Ditto.
	(__pthread_condattr_setpshared): Error on PROCESS_SHARED requests.
	(__pthread_mutex_init): Support pshared mutex's.
	(__pthread_mutex_getprioceiling): Ditto.
	(__pthread_mutex_lock): Ditto.
	(__pthread_mutex_trylock): Ditto.
	(__pthread_mutex_unlock): Ditto.
	(__pthread_mutex_destroy): Ditto.
	(__pthread_mutex_setprioceiling): Ditto.
	(__pthread_mutexattr_setpshared): Support PTHREAD_PROCESS_PSHARED requests.
@
text
@d233 2
a234 1
  size_t needsize = strlen (temppw->pw_name) + strlen (temppw->pw_dir) + strlen (temppw->pw_shell);
d243 3
a245 2
  pwd->pw_dir = buffer + strlen (temppw->pw_name);
  pwd->pw_shell = buffer + strlen (temppw->pw_name) + strlen (temppw->pw_dir);
d249 1
d288 2
a289 1
  size_t needsize = strlen (temppw->pw_name) + strlen (temppw->pw_dir) + strlen (temppw->pw_shell);
d298 3
a300 2
  pwd->pw_dir = buffer + strlen (temppw->pw_name);
  pwd->pw_shell = buffer + strlen (temppw->pw_name) + strlen (temppw->pw_dir);
d304 1
@


1.18
log
@Throughout, change fdtab references to cygheap->fdtab.
* child_info.h (cygheap_exec_info): Eliminate special fdtab stuff.
* spawn.cc (spawn_guts): Ditto.
* cygheap.cc (cygheap_init): Initialize fdtab, if appropriate.
* cygheap.h (CYGHEAPSIZE): Include size of init_cygheap.
(_cmalloc_entry): Include fdtab here.
* dtable.h (dtable): Declare/define new methods.
* dtable.cc (dtable::vfork_child_fixup): New method.
(dtable::fixup_after_exec): Remove unneeded extra arguments.
* dcrt0.cc (dll_crt0_1): Ditto.
* environ.cc (getwinenv): Use case sensitive comparison.
(winenv): Make a copy of environment cache to avoid realloc problems when
duplicate environment variables exist in the environment.  (From Egor Duda)
* net.cc (cygwin_socket): Revert Apr 14 change.
* include/sys/file.h: Protect against previous X_OK definition.
* passwd.cc: Eliminate passwd_sem throughout.
* security.cc: Ditto.
* cygwin.din: Export New functions.
* passwd.cc (read_etc_passwd): Make race safe.
(getpwuid_r): New function.
(getpwnam_r): New function.
@
text
@d208 2
d225 2
d255 2
d276 2
@


1.17
log
@Throughout, change 'cygwin_shared.mount' to 'mount_table'.
* child_info.h (child_info): Move shared_h, console_h to cygheap.  Add mount_h.
* cygheap.h (init_cygheap): Add shared_h, console_h.
* cygheap.cc (init_cheap): Initialize heap at a fixed location after the shared
memory regions.  Initialize cygheap->user name here.
* dcrt0.cc (dll_crt0_1): Call getpagesize () to initialize constants.  Remove
cygheap_init since it is done in shared_init now.
(_dll_crt0): Initialize mount_h, remove shared_h and console_h initialization.
* fhandler_console.cc (console_shared_h): Eliminate.
(get_tty_stuff): Use cygheap->console_h rather than console_shared_h.
* heap.cc (heap_init): Use page size constant calculated earlier in
initialization.
* shared.cc: Eliminate cygwin_shared_h.  Add cygwin_mount_h.
(mount_table_init): New function for initializing a user mount table.
(open_shared_file_map): Use constant for shared memory region.  Initialize
cygheap and mount table here.
(open_shared): Improve debugging output.
(shared_info::initialize): Eliminate call to mount.init.
(shared_terminate): Use cygheap->shared_h.  Close cygwin_mount_h.
(open_shared_file_map): Eliminate.
* shared_info.h (mount_info): Add a version field.
(shared_align_past): New macro for calculating location for shared memory
regions.
* sigproc.cc (init_child_info): Eliminate shared_h, console_h.
* spawn.cc (spawn_guts): Pass on cygwin_mount_h iff not a different user.
* syscalls.cc (system_info): New global holding system memory defaults.
(getpagesize): Use system_info.
* uinfo.cc (internal_getlogin): Only fill in user name if nonexistent.
* winsup.h: Declare system_info.
* passwd.cc (read_etc_passwd): Use cygheap->user.name () rather than retrieving
the name again.
@
text
@d38 1
a123 1
    extern int passwd_sem;
d125 6
a130 3
    ++passwd_sem;
    FILE *f = fopen ("/etc/passwd", "rt");
    --passwd_sem;
d132 2
a133 1
    if (f)
d135 11
a145 1
	while (fgets (linebuf, sizeof (linebuf), f) != NULL)
d147 16
a162 2
	    if (strlen (linebuf))
	      add_pwd_line (linebuf);
a164 10
	fclose (f);
	passwd_state = loaded;
      }
    else
      {
	debug_printf ("Emulating /etc/passwd");
	snprintf (linebuf, sizeof (linebuf), "%s::%u:%u::%s:/bin/sh", cygheap->user.name (),
		  DEFAULT_UID, DEFAULT_GID, getenv ("HOME") ?: "/");
	add_pwd_line (linebuf);
	passwd_state = emulated;
d166 2
d171 1
d206 1
a206 1
  if (passwd_state == uninitialized)
d212 34
d249 1
a249 1
  if (passwd_state == uninitialized)
d255 39
d297 1
a297 1
  if (passwd_state == uninitialized)
d309 1
a309 1
  if (passwd_state == uninitialized)
d318 1
a318 1
  if (passwd_state == uninitialized)
d327 1
a327 1
  if (passwd_state == uninitialized)
d336 1
a336 1
  if (passwd_state == uninitialized)
d352 1
a352 1
  if (passwd_state == uninitialized)
d355 1
a355 1
  if (fdtab.not_open (0))
d362 1
a362 1
      fhandler_base *fhstdin = fdtab[0];
@


1.16
log
@        * cygheap.cc (cygheap_root::cygheap_root): New function.
        (cygheap_root::~cygheap_root): Ditto.
        (cygheap_root::operator=): Ditto.
        (cygheap_user::~cygheap_user): Ditto.
        (cygheap_user::set_name): Ditto.
        (cygheap_user::set_logsrv): Ditto.
        (cygheap_user::set_domain): Ditto.
        (cygheap_user::set_sid): Ditto.
        * cygheap.h (cygheap_root): New class.
        (cygheap_user): Ditto.
        (init_cygheap): Change type of `root' member to cygheap_root.
        Add `user' member.
        * dir.cc (opendir): Use new `cygheap_root' class.
        * dcrt0.cc (dll_crt0_1): Use new `cygheap_user' class.
        * fork.cc (fork_parent): Ditto.
        * grp.cc (getgroups): Ditto.
        * passwd.cc (search_for): Ditto.
        * path.cc: Use new `cygheap_root' class throughout.
        * pinfo.h (_pinfo): Remove `use_psid'. Move `username', `psid',
        `logsrv', `domain', `orig_{uid,gid}' and `real_{uid,gid}' to
        cygheap_user class.
        * security.cc: Use new `cygheap_user' class throughout.
        * shared.cc (sec_user): Ditto.
        * sigproc.cc (proc_subproc): Remove copy statements for user
        related information moved to `cygheap_user' class.
        * spawn.cc (spawn_guts): Invalidate current chroot settings
        when creating Windows environment. Use new `cygheap_user' class.
        * syscalls.cc: Use new `cygheap_user' class throughout.
        * uinfo.cc: Ditto.
        * uinfo.cc (internal_getlogin): Change parameters to reflect the
        move of user information to cygheap.
@
text
@d45 1
a45 1
#define pw_pos  _reent_winsup()->_pw_pos
d95 1
a95 1
  res.pw_name = strlwr(grab_string (&mybuf));
d143 1
a143 8
	char user_name [ MAX_USER_NAME ];
	DWORD user_name_len = MAX_USER_NAME;
	if (! GetUserNameA (user_name, &user_name_len))
	  {
	    strncpy (user_name, "Administrator", MAX_USER_NAME);
	    debug_printf ("Failed to get current user name. %E");
	  }
	snprintf (linebuf, sizeof (linebuf), "%s::%u:%u::%s:/bin/sh", user_name,
d176 1
a176 1
      || (name && strcasematch(name, cygheap->user.name ())))
d186 1
a186 1
    read_etc_passwd();
d195 1
a195 1
    read_etc_passwd();
d204 1
a204 1
    read_etc_passwd();
d216 1
a216 1
    read_etc_passwd();
d225 1
a225 1
    read_etc_passwd();
d234 1
a234 1
    read_etc_passwd();
d243 1
a243 1
    read_etc_passwd();
d252 1
a252 1
  char *pass=_reent_winsup()->_pass;
d259 1
a259 1
    read_etc_passwd();
@


1.15
log
@* Makefile.in: Remove some obsolete stuff.
* dcrt0.cc (dll_crt0_1): Call signal_fixup_after_exec where appropriate.  Set
myself->uid from parent version.  Just use ThreadItem Init method.  Close or
store hexec_proc as appropriate.
(_dll_crt0): Store user_data->forkee here so that proper tests can be made
subsequently.
(do_exit): Remove hExeced stuff.
* environ.cc (environ_init): Accept environ count as well as environ pointer.
* environ.h: Reflect above change.
* pinfo.cc (pinfo_init): Ditto.  Accept environ count.
(fixup_in_spawned_child): Remove.
* spawn.cc (spawn_guts): Move signal code to dll_crt0_1.  Don't suspend execing
process since it is no longer necessary.  Store envc.
* exceptions.cc (signal_fixup_after_exec): New function.
(call_handler): Remove hExeced test.
* child_info.h (cygheap_exec_info): Store envc as well as envp.
(child_info_spawn): Store hexec_proc so that it can be closed in child.
* path.cc (normalize_posix_path): Avoid intermediate use of temporary cwd buf.
(normalize_win32_path): Ditto.
(cwdstuff::get_initial): Always set lock.
* sigproc.h: Remove hExeced.
* strace.cc (strace::vsprntf): Modify to accomodate for lack of hExeced.
* thread.cc (MTinterface::Init): Merge Init1 and ClearReent into this method.
(MTinterface::Init1): Eliminate.
(MTinterface::ClearReent): Eliminate.
* thread.h: Reflect above changes.
* include/sys/strace.h (strace): Make microseconds() public.  Make various
functions 'regparm', throughout.
* pinfo.h (_pinfo): Inline simple signal manipulation functions.  Requires
inclusion of thread.h which was removed from .cc files, where appropriate.
throughout.
* pinfo.cc: Eliminate signal manipulation functions.
(_pinfo::exit): Calculate total rusage for exiting process here.
* cygheap.cc (size2bucket): Eliminate.
(init_buckets): Ditto.
(_cmalloc): Calculate size and bits in a loop rather than going through a
function call.
(_crealloc): Use stored array index to calculate allocated size.
* spawn.cc (spawn_guts): Use _pinfo exit method to exit, calculating cpu usage.
@
text
@d22 1
d183 1
a183 1
      || (name && strcasematch(name, myself->username)))
@


1.14
log
@Split out tty and shared_info stuff into their own headers and use throughout.
Include sys/termios.h for files which need it.
* tty.h: New file.
* shared_info.h: New file.
* fhandler.h: Move inline methods that rely on tty stuff to
fhandler_console.cc.
* fhandler_tty.cc (fhandler_pty_master::process_slave_output): Set
output_done_event immediately after reading data to speed up tty output
processing.
(process_output): Set write_error to errno or zero.
(fhandler_tty_slave::write): Check previous write error prior to writing to
slave end of pipe.  This allows tty output to be slightly less synchronous.
* fhandler_console.cc (fhandler_console::tcsetpgrp): Moved here from
fhandler.h.
(fhandler_console::set_input_state): Ditto.
@
text
@a18 1
#include "thread.h"
@


1.13
log
@* path.cc (readlink): Check if buffer length is positive.  Truncate output to
buffer length.  Don't terminate buffer with '\0'.
@
text
@d23 1
@


1.12
log
@* Makefile.in: Add cygheap.o.
* child_info.h: Add specific exec class.
* cygheap.h: New file.  Contains declarations for cygwin heap.
* cygheap.cc: New file.  Implements cygwin heap functions.
* dcrt0.cc (quoted): Simplify due to new method for passing arguments between
cygwin programs.
(alloc_stack_hard_way): Attempt to handle overlapped stack.
(dll_crt0_1): Move child_info processing here.  Accomodate new method for
passing arguments between cygwin programs.  Initialize cygwin heap.  Establish
__argc and __argv variables.
(_dll_crt0): Move most of child_info processing to dll_crt0_1.
(cygwin_dll_init): Remove duplication.
* dtable.cc (dtable::extend): Allocate dtable using cygwin heap.
(dtable::build_fhandler): Ditto for fhandler type being constructed.
(dtable::dup_worker): Free new fhandler from cygwin heap on error.
(dtable::select_*): Don't assume that this == fdtab.
(dtable::linearize_fd_array): Delete.
(dtable::delinearize_fd_array): Delete.
(dtable::fixup_after_exec): New file.
(dtable::vfork_child_dup): Use cygwin heap.
(dtable::vfork_parent_restore): Ditto.
* dtable.h: Remove obsolete methods.  Add new method.
* environ.cc (posify): Eliminate already_posix parameter and logic.
(envsize): New function.
(_addenv): Use envsize.
(environ_init): Accept an argument pointing to an existing environment list.
If supplied, allocate space for this in the the program's heap.
* fhandler.cc (fhandler_base::operator =): Move here from fhandler.h.  Use
cygwin heap to allocate filenames.
(fhandler_base::set_name): Allocate/free names from cygwin heap.
(fhandler_base::linearize): Delete.
(fhandler_base::de_linearize): Delete.
(fhandler_base::operator delete): Free from cygwin heap.
(fhandler_base::~fhandler_base): Ditto.
* fhandler.h: Accomodate elimination of *linearize and other changes above.
* fhandler_console.cc (fhandler_console::fixup_after_exec): Rename from
de_linearize.
* heap.h: New file.
* fhandler_tty.cc (fhandler_tty_slave::fhandler_tty_slave): Use cygwin heap for
name.  fhandler_tty::fixup_after_exec): Rename from de_linearize.
* fork.cc (fork): Call cygheap_fixup_in_child.
* heap.cc: Use declarations in heap.h.
* malloc.cc: Sprinkle assertions throughout to catch attempts to free/realloc
something from the cygwin heap.
* path.cc: Throughout, eliminate use of per-thread cache for cwd.  Use cwd_*
functions rather than cwd_* variables to access cwd_win32 and cwd_posix.
(cwd_win32): New function.
(cwd_posix): New function.
(cwd_hash): New function.
(cwd_fixup_after_exec): New function.
* path.h: Accomodate path.cc changes.
* pinfo.cc (pinfo_init): Accept a pointer to an environment table.  Pass this
to environ_init.  Eliminate old 'title' tests.
* pinfo.h: Accomodate above change in argument.
* spawn.cc (struct av): New method for building argv list.
(av::unshift): New method.
(spawn_guts): Allocate everything that the child process needs in the cygwin
heap and pass a pointer to this to the child.  Build argv list using new
method.  Eliminate delinearize stuff.
* thread.h: Eliminate _cwd_win32 and _cwd_posix buffers.
* winsup.h: Eliminate obsolete functions.  Add envsize() declaration.
@
text
@d181 2
a182 2
      || (! name && uid == myself->uid)
      || (  name && strcasematch(name, myself->username)))
@


1.11
log
@* winsup.h: Eliminate inclusion of most of the cygwin .h files.  Use .h files
only in sources which require them.
* Makefile.in: Generate dependencies with -MD option.
@
text
@d137 1
a137 1
        passwd_state = loaded;
d141 9
a149 9
        debug_printf ("Emulating /etc/passwd");
        char user_name [ MAX_USER_NAME ];
        DWORD user_name_len = MAX_USER_NAME;
        if (! GetUserNameA (user_name, &user_name_len))
          {
            strncpy (user_name, "Administrator", MAX_USER_NAME);
            debug_printf ("Failed to get current user name. %E");
          }
        snprintf (linebuf, sizeof (linebuf), "%s::%u:%u::%s:/bin/sh", user_name,
d151 2
a152 2
        add_pwd_line (linebuf);
        passwd_state = emulated;
d167 1
a167 1
        default_pw = res;
@


1.10
log
@* cygerrno.h: New file.  Use this throughout whenever errno manipulation is
required.
* errno.cc: Use DWORD to hold Windows errors.
(geterrno_from_win_error): New function.
(seterrno_from_win_error): Use geterrno_from_win_error to convert supplied
windows error (suggested by Corinna Vinschen).
* path.cc (symlink_info): Add error element.
* path.cc (path_conv::check): Remove errno setting.  Use new symlink_info errno
element to set path_conv error, where appropriate.
(symlink_info::check): Set error element rather than attempting to manipulate
errno.  Add more checks for trailing / and /..  even though they are currently
useless.  Avoid setting EINVAL.
* path.cc (normalize_posix_path): Correct check for trailing /.
@
text
@d16 2
d19 3
a22 1
#include "cygerrno.h"
@


1.9
log
@* winsup.h: Split out dtable definitions into separate header file.
* dtable.h: New file.
* sigproc.h: Eliminate pinfo.h usage here.  Use it in source files that need
it.
@
text
@d18 1
@


1.8
log
@Rename hinfo -> dtable.  Name the former dtable array 'fdtab'.
@
text
@d16 2
@


1.7
log
@* winsup.h: take out protections of environ, errno, allow C use
* *.cc: put winsup.h before other headers (for __INSIDE_CYGWIN__);
use cur_environ() instead of just environ
* times.cc: remove import protections
* glob.c: add winsup.h
* localtime.c: ditto
* smallprint.c: ditto
* Makefile.in: don't __INSIDE_CYGWIN__ as it messes up profiling.
@
text
@d260 1
a260 1
  if (dtable.not_open (0))
d267 1
a267 1
      fhandler_base *fhstdin = dtable[0];
@


1.6
log
@        * passwd.cc: Change name of passwd_in_memory_p to passwd_state.
        Change type to enum. Change storage class to static. Adjust comments.
        (read_etc_passwd): Set passwd_state to different values when loaded
        from file in contrast to being emulated.
        (search_for): Return default passwd entry if passwd is emulated or
        it's a request for the current user. Otherwise return NULL.
@
text
@d11 1
a15 1
#include "winsup.h"
@


1.5
log
@Changes by  Kazuhiro Fujieda  <fujieda@@jaist.ac.jp>
        * assert.cc (__assert): Reduce dependency on newlib.
        * exec.cc: Eliminate unnecessary inclusion of ctype.h.
        * glob.c: Ditto.
        * hinfo.cc: Ditto.
        * init.cc: Ditto.
        * strace.cc: Ditto.
        * tty.cc: Ditto.
        * grp.cc (parse_grp): Eliminate atoi.
        * passwd.cc (grab_int): Ditto.
        * grp.cc (getgroups): Eliminate str{n,}casecmp.
        * path.cc (get_raw_device_number): Ditto.
        * path.cc (sort_by_native_name): Ditto.
        * spawn.cc (iscmd): Ditto.
        * uinfo.cc (internal_getlogin): Ditto.
@
text
@d24 3
a26 2
/* Set to 1 when /etc/passwd has been read in by read_etc_passwd (). */
/* Functions in this file need to check the value of passwd_in_memory_p
d28 6
a33 1
int passwd_in_memory_p = 0;
d110 2
a111 2
   This sets passwd_in_memory_p to 1 so functions in this file can
   tell that /etc/passwd has been read in */
d130 1
d145 1
a146 1
    passwd_in_memory_p = 1;
d171 8
a178 1
  return default_pw;
d184 1
a184 1
  if (!passwd_in_memory_p)
d193 1
a193 1
  if (!passwd_in_memory_p)
d202 1
a202 1
  if (!passwd_in_memory_p)
d214 1
a214 1
  if (!passwd_in_memory_p)
d223 1
a223 1
  if (!passwd_in_memory_p)
d232 1
a232 1
  if (!passwd_in_memory_p)
d241 1
a241 1
  if (!passwd_in_memory_p)
d257 1
a257 1
  if (!passwd_in_memory_p)
@


1.4
log
@* grp.cc (read_etc_group): Open file in text mode.
* pwd.cc (read_etc_passwd): Ditto.
* shared.h: Bump PROC_MAGIC.
@
text
@d60 1
a60 1
  int val = atoi (src);
@


1.3
log
@        * fork.cc (fork): Fix error in copying SID pointer.
        * spawn.cc (_spawnve): Ditto.
        * passwd.cc: Remove static from `passwd_in_memory_p'.
        (read_etc_passwd): Remove static.
        * uinfo.cc: Move global declaration of `read_etc_group' and
        `group_in_memory_p' into `uinfo_init'.
        (internal_getlogin): Try to get SID from current process first.
        (uinfo_init): Don't set uid and gid if `myself' has a valid SID.
        Only load /etc/passwd and /etc/group in that case.
@
text
@d112 1
a112 1
    FILE *f = fopen ("/etc/passwd", "r");
@


1.2
log
@Respond to a multitude of g++ warnings.
@
text
@d27 1
a27 1
static int passwd_in_memory_p = 0;
d106 1
a106 1
static void
@


1.1
log
@Initial revision
@
text
@d167 1
a167 2
extern "C"
struct passwd *
d176 1
a176 2
extern "C"
struct passwd *
d185 1
a185 2
extern "C"
struct passwd *
d197 2
a198 3
extern "C"
struct passwd *
getpwduid (uid_t uid)
d206 1
a206 2
extern "C"
void
d215 1
a215 2
extern "C"
void
d224 1
a224 2
extern "C"
int
d233 1
a233 2
extern "C"
char *
@


1.1.1.1
log
@import winsup-2000-02-17 snapshot
@
text
@@
