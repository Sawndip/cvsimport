head	1.34;
access;
symbols
	cygwin-1_7_35-release:1.34
	cygwin-1_7_34-release:1.34
	cygwin-1_7_33-release:1.30.2.2
	cygwin-1_7_32-release:1.30.2.2
	cygwin-1_7_31-release:1.30.2.2
	cygwin-1_7_30-release:1.30.2.1
	cygwin-1_7_29-release:1.30.2.1
	cygwin-1_7_29-release-branchpoint:1.30.0.2
	cygwin-pre-user-db:1.30
	cygwin-1_7_28-release:1.30
	cygwin-1_7_27-release:1.30
	cygwin-1_7_26-release:1.30
	cygwin-1_7_25-release:1.29
	cygwin-1_7_24-release:1.29
	cygwin-1_7_23-release:1.29
	cygwin-1_7_22-release:1.29
	cygwin-1_7_21-release:1.29
	cygwin-1_7_20-release:1.29
	cygwin-1_7_19-release:1.29
	cygwin-64bit-postmerge:1.28
	cygwin-64bit-premerge-branch:1.27.0.6
	cygwin-64bit-premerge:1.27
	cygwin-1_7_18-release:1.27
	post-ptmalloc3:1.27.4.3
	pre-ptmalloc3:1.27.4.3
	cygwin-1_7_17-release:1.27
	cygwin-64bit-branch:1.27.0.4
	cygwin-1_7_16-release:1.27
	cygwin-1_7_15-release:1.27
	cygwin-1_7_14_2-release:1.27
	cygwin-1_7_14-release:1.27
	cygwin-1_7_12-release:1.27
	cygwin-1_7_11-release:1.27
	cygwin-1_7_10-release:1.27
	signal-rewrite:1.27.0.2
	pre-notty:1.27
	cygwin-1_7_9-release:1.26
	cv-post-1_7_9:1.26.0.2
	cygwin-1_7_8-release:1.26
	cygwin-1_7_7-release:1.25
	cygwin-1_7_5-release:1.25
	cygwin-1_7_4-release:1.25
	cygwin-1_7_3-release:1.25
	cygwin-1_7_2-release:1.25
	fifo_doover3:1.25.0.2
	cygwin-1_7_1-release:1.25
	prefifo:1.25
	cv-branch-2:1.21.0.2
	pre-ripout-set_console_state_for_spawn:1.19
	EOL_registry_mounts:1.18
	preoverlapped:1.15
	drop_9x_support_start:1.15
	cr-0x5f1:1.15.0.8
	cv-branch:1.15.0.6
	pre-ptymaster-archetype:1.15
	cr-0x3b58:1.15.0.4
	cr-0x5ef:1.15.0.2
	after-mmap-privanon-noreserve:1.15
	after-mmap-revamp:1.15
	before-mmap-revamp:1.15
	cgf-more-exit-sync:1.14
	post_wait_sig_exit:1.14
	pre_wait_sig_exit:1.14
	reparent-point:1.11
	noreparent:1.11.0.4
	cr-0x5e6:1.11.0.2
	cr-0x9e:1.10.0.6
	cr-0x9d:1.10.0.4
	cgf-deleteme:1.10.0.2
	pre-sigrewrite:1.8
	corinna-01:1.8
	cr-0x9c:1.8.0.8
	cr-0x9b:1.8.0.6
	cr-0x99:1.8
	Z-emcb-cygwin_daemon:1.8.0.2
	w32api-2_2:1.8
	mingw-runtime-2_4:1.8
	pre-cgf-merge:1.8
	cgf-dev-branch:1.8.0.4
	predaemon:1.5
	cygwin_daemon_merge_HEAD:1.5
	pregp02r1:1.5.0.10
	cygnus_cvs_20020108_pre:1.5
	Z-cygwin_daemon_merge-new_HEAD:1.6
	Z-cygwin_daemon_merge_HEAD:1.6
	cygwin_daemon:1.3.0.4;
locks; strict;
comment	@// @;


1.34
date	2015.01.08.09.37.16;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2015.01.07.21.27.22;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2014.06.23.13.38.06;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2014.03.05.12.45.49;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2013.11.25.11.38.08;	author corinna;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2013.05.14.13.34.05;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.23.09.44.33;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.18.19.07.18;	author corinna;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2010.10.30.19.22.42;	author cgf;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.14.09.35.35;	author corinna;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.14.05.49.01;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2009.06.12.15.08.43;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.12.15.06.26;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.14.12.08.07;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.11.05.43.11;	author cgf;	state Exp;
branches;
next	1.19;

1.19
date	2008.04.07.18.45.57;	author cgf;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.11.16.14.24;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.11.15.01.31;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.01.13.26.56;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.18.17.48.23;	author corinna;	state Exp;
branches
	1.15.8.1;
next	1.14;

1.14
date	2005.07.06.20.05.01;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.23.22.17.28;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.19.19.58.38;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.08.19.59.27;	author cgf;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.07.22.37.11;	author cgf;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.01.10.39.16;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.20.03.40.00;	author phumblet;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.23.00.31.30;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.07.13.18.44;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.19.20.10.02;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.13.01.35.15;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.06.05.17.22;	author cgf;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.09.06.04.41.59;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.25.21.58.21;	author corinna;	state Exp;
branches;
next	;

1.30.2.1
date	2014.03.09.18.56.20;	author cgf;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2014.07.15.14.34.37;	author corinna;	state Exp;
branches;
next	;

1.27.4.1
date	2013.02.09.20.38.00;	author corinna;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2013.02.18.21.00.55;	author corinna;	state Exp;
branches;
next	1.27.4.3;

1.27.4.3
date	2013.02.18.21.09.46;	author corinna;	state Exp;
branches;
next	;

1.15.8.1
date	2007.11.12.15.30.19;	author corinna;	state Exp;
branches;
next	1.15.8.2;

1.15.8.2
date	2007.12.11.15.01.38;	author corinna;	state Exp;
branches;
next	1.15.8.3;

1.15.8.3
date	2007.12.11.16.14.33;	author corinna;	state Exp;
branches;
next	;

1.3.4.1
date	2002.01.04.03.56.08;	author rbcollins;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.06.13.14.34.06;	author rbcollins;	state Exp;
branches;
next	;


desc
@@


1.34
log
@	* localtime.cc (__cygwin_gettzoffset): New function for access from
	newlib.
	(__cygwin_gettzname): Ditto.
@
text
@/*	$NetBSD: localtime.c,v 1.72 2012/10/28 19:02:29 christos Exp $	*/

/* Don't reformat the code arbitrarily.

   It uses in wide parts the exact formatting as the upstream NetBSD
   versions.  The purpose is to simplify subsequent diffs to the NetBSD
   version, should the need arise again at one point. */

/*
** This file is in the public domain, so clarified as of
** 1996-06-05 by Arthur David Olson.
*/
/* Temporarily merged private.h and tzfile.h for ease of management - DJ */

#include "winsup.h"
#include "cygerrno.h"
#include "sync.h"
#include <ctype.h>
#define STD_INSPIRED
#define lint

#define USG_COMPAT

#ifndef lint
#ifndef NOID
static char	elsieid[] = "@@(#)localtime.c	8.17";
#endif /* !defined NOID */
#endif /* !defined lint */

/*
** Leap second handling from Bradley White.
** POSIX-style TZ environment variable handling from Guy Harris.
*/

#define NO_ERROR_IN_DST_GAP

/*LINTLIBRARY*/

#ifndef PRIVATE_H

#define PRIVATE_H

/*
** This file is in the public domain, so clarified as of
** 1996-06-05 by Arthur David Olson
*/

/*
** This header is for use ONLY with the time conversion code.
** There is no guarantee that it will remain unchanged,
** or that it will remain at all.
** Do NOT copy it to any system include directory.
** Thank you!
*/

/*
** ID
*/

#ifndef lint
#ifndef NOID
static char	privatehid[] = "@@(#)private.h	7.48";
#endif /* !defined NOID */
#endif /* !defined lint */

/*
** Nested includes
*/

#include "stdio.h"
#include "limits.h"	/* for CHAR_BIT */
#include "stdlib.h"
#include "unistd.h"	/* for F_OK and R_OK */

/* Unlike <ctype.h>'s isdigit, this also works if c < 0 | c > UCHAR_MAX.  */
#define is_digit(c) ((unsigned)(c) - '0' <= 9)

#ifndef __pure
#if 2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)
# define __pure __attribute__ ((__pure__))
#else
# define __pure /* empty */
#endif
#endif

/*
** Finally, some convenience items.
*/

#ifndef TYPE_INTEGRAL
#define TYPE_INTEGRAL(type) (/*CONSTCOND*/((type) 0.5) != 0.5)
#endif /* !defined TYPE_INTEGRAL */

#ifndef TYPE_BIT
#define TYPE_BIT(type)	(sizeof (type) * CHAR_BIT)
#endif /* !defined TYPE_BIT */

#ifndef TYPE_SIGNED
#define TYPE_SIGNED(type) (((type) -1) < 0)
#endif /* !defined TYPE_SIGNED */

#ifndef INT_STRLEN_MAXIMUM
/*
** 302 / 1000 is log10(2.0) rounded up.
** Subtract one for the sign bit if the type is signed;
** add one for integer division truncation;
** add one more for a minus sign if the type is signed.
*/
#define INT_STRLEN_MAXIMUM(type) \
    ((TYPE_BIT(type) - TYPE_SIGNED(type)) * 302 / 1000 + 1 + TYPE_SIGNED(type))
#endif /* !defined INT_STRLEN_MAXIMUM */

/*
** INITIALIZE(x)
*/

#ifndef GNUC_or_lint
#ifdef lint
#define GNUC_or_lint
#endif /* defined lint */
#ifndef lint
#ifdef __GNUC__
#define GNUC_or_lint
#endif /* defined __GNUC__ */
#endif /* !defined lint */
#endif /* !defined GNUC_or_lint */

#ifndef INITIALIZE
#ifdef GNUC_or_lint
#define INITIALIZE(x)	((x) = 0)
#endif /* defined GNUC_or_lint */
#ifndef GNUC_or_lint
#define INITIALIZE(x)
#endif /* !defined GNUC_or_lint */
#endif /* !defined INITIALIZE */

#ifndef TZ_DOMAIN
#define TZ_DOMAIN "tz"
#endif /* !defined TZ_DOMAIN */

#ifndef YEARSPERREPEAT
#define YEARSPERREPEAT	  400     /* years before a Gregorian repeat */
#endif /* !defined YEARSPERREPEAT */

/*
** The Gregorian year averages 365.2425 days, which is 31556952 seconds.
*/

#ifndef AVGSECSPERYEAR
#define AVGSECSPERYEAR	  31556952L
#endif /* !defined AVGSECSPERYEAR */

#ifndef SECSPERREPEAT
#define SECSPERREPEAT	   ((int_fast64_t) YEARSPERREPEAT * (int_fast64_t) AVGSECSPERYEAR)
#endif /* !defined SECSPERREPEAT */

#ifndef SECSPERREPEAT_BITS
#define SECSPERREPEAT_BITS      34      /* ceil(log2(SECSPERREPEAT)) */
#endif /* !defined SECSPERREPEAT_BITS */

/*
** UNIX was a registered trademark of UNIX System Laboratories in 1993.
*/

#endif /* !defined PRIVATE_H */

#ifndef TZFILE_H

#define TZFILE_H

/*
** This file is in the public domain, so clarified as of
** 1996-06-05 by Arthur David Olson.
*/

/*
** This header is for use ONLY with the time conversion code.
** There is no guarantee that it will remain unchanged,
** or that it will remain at all.
** Do NOT copy it to any system include directory.
** Thank you!
*/

/*
** ID
*/

#ifndef lint
#ifndef NOID
static char	tzfilehid[] = "@@(#)tzfile.h	7.14";
#endif /* !defined NOID */
#endif /* !defined lint */

/*
** Information about time zone files.
*/

#ifndef TZDIR
#define TZDIR	"/usr/share/zoneinfo" /* Time zone object file directory */
#endif /* !defined TZDIR */

#ifndef TZDEFAULT
#define TZDEFAULT	"localtime"
#endif /* !defined TZDEFAULT */

#ifndef TZDEFRULES
#define TZDEFRULES	"posixrules"
#endif /* !defined TZDEFRULES */

/*
** Each file begins with. . .
*/

#define	TZ_MAGIC	"TZif"

struct tzhead {
	char	tzh_magic[4];		/* TZ_MAGIC */
	char	tzh_version[1];		/* '\0' or '2' as of 2005 */
	char	tzh_reserved[15];	/* reserved for future use */
	char	tzh_ttisgmtcnt[4];	/* coded number of trans. time flags */
	char	tzh_ttisstdcnt[4];	/* coded number of trans. time flags */
	char	tzh_leapcnt[4];		/* coded number of leap seconds */
	char	tzh_timecnt[4];		/* coded number of transition times */
	char	tzh_typecnt[4];		/* coded number of local time types */
	char	tzh_charcnt[4];		/* coded number of abbr. chars */
};

/*
** . . .followed by. . .
**
**	tzh_timecnt (char [4])s		coded transition times a la time(2)
**	tzh_timecnt (unsigned char)s	types of local time starting at above
**	tzh_typecnt repetitions of
**		one (char [4])		coded UTC offset in seconds
**		one (unsigned char)	used to set tm_isdst
**		one (unsigned char)	that's an abbreviation list index
**	tzh_charcnt (char)s		'\0'-terminated zone abbreviations
**	tzh_leapcnt repetitions of
**		one (char [4])		coded leap second transition times
**		one (char [4])		total correction after above
**	tzh_ttisstdcnt (char)s		indexed by type; if TRUE, transition
**					time is standard time, if FALSE,
**					transition time is wall clock time
**					if absent, transition times are
**					assumed to be wall clock time
**	tzh_ttisgmtcnt (char)s		indexed by type; if TRUE, transition
**					time is UTC, if FALSE,
**					transition time is local time
**					if absent, transition times are
**					assumed to be local time
*/

/*
** If tzh_version is '2' or greater, the above is followed by a second instance
** of tzhead and a second instance of the data in which each coded transition
** time uses 8 rather than 4 chars,
** then a POSIX-TZ-environment-variable-style string for use in handling
** instants after the last transition time stored in the file
** (with nothing between the newlines if there is no POSIX representation for
** such instants).
*/

/*
** In the current implementation, "tzset()" refuses to deal with files that
** exceed any of the limits below.
*/

#ifndef TZ_MAX_TIMES
/*
** The TZ_MAX_TIMES value below is enough to handle a bit more than a
** year's worth of solar time (corrected daily to the nearest second) or
** 138 years of Pacific Presidential Election time
** (where there are three time zone transitions every fourth year).
*/
#define TZ_MAX_TIMES	1200
#endif /* !defined TZ_MAX_TIMES */

#ifndef TZ_MAX_TYPES
#ifndef NOSOLAR
#define TZ_MAX_TYPES	256 /* Limited by what (unsigned char)'s can hold */
#endif /* !defined NOSOLAR */
#ifdef NOSOLAR
/*
** Must be at least 14 for Europe/Riga as of Jan 12 1995,
** as noted by Earl Chew.
*/
#define TZ_MAX_TYPES	20	/* Maximum number of local time types */
#endif /* !defined NOSOLAR */
#endif /* !defined TZ_MAX_TYPES */

#ifndef TZ_MAX_CHARS
#define TZ_MAX_CHARS	50	/* Maximum number of abbreviation characters */
				/* (limited by what unsigned chars can hold) */
#endif /* !defined TZ_MAX_CHARS */

#ifndef TZ_MAX_LEAPS
#define TZ_MAX_LEAPS	50	/* Maximum number of leap second corrections */
#endif /* !defined TZ_MAX_LEAPS */

#define SECSPERMIN	60
#define MINSPERHOUR	60
#define HOURSPERDAY	24
#define DAYSPERWEEK	7
#define DAYSPERNYEAR	365
#define DAYSPERLYEAR	366
#define SECSPERHOUR	(SECSPERMIN * MINSPERHOUR)
#define SECSPERDAY	((long) SECSPERHOUR * HOURSPERDAY)
#define MONSPERYEAR	12

#define TM_SUNDAY	0
#define TM_MONDAY	1
#define TM_TUESDAY	2
#define TM_WEDNESDAY	3
#define TM_THURSDAY	4
#define TM_FRIDAY	5
#define TM_SATURDAY	6

#define TM_JANUARY	0
#define TM_FEBRUARY	1
#define TM_MARCH	2
#define TM_APRIL	3
#define TM_MAY		4
#define TM_JUNE		5
#define TM_JULY		6
#define TM_AUGUST	7
#define TM_SEPTEMBER	8
#define TM_OCTOBER	9
#define TM_NOVEMBER	10
#define TM_DECEMBER	11

#define TM_YEAR_BASE	1900

#define EPOCH_YEAR	1970
#define EPOCH_WDAY	TM_THURSDAY

/*
** Accurate only for the past couple of centuries;
** that will probably do.
*/

#define isleap(y) (((y) % 4) == 0 && (((y) % 100) != 0 || ((y) % 400) == 0))

#endif /* !defined TZFILE_H */

#include "fcntl.h"

#ifdef __TM_GMTOFF
# define TM_GMTOFF __TM_GMTOFF
#endif
#ifdef __TM_ZONE
# define TM_ZONE __TM_ZONE
#endif

/*
** SunOS 4.1.1 headers lack O_BINARY.
*/

#ifdef O_BINARY
#define OPEN_MODE	(O_RDONLY | O_BINARY)
#endif /* defined O_BINARY */
#ifndef O_BINARY
#define OPEN_MODE	O_RDONLY
#endif /* !defined O_BINARY */

#ifndef WILDABBR
/*
** Someone might make incorrect use of a time zone abbreviation:
**	1.	They might reference tzname[0] before calling tzset (explicitly
**		or implicitly).
**	2.	They might reference tzname[1] before calling tzset (explicitly
**		or implicitly).
**	3.	They might reference tzname[1] after setting to a time zone
**		in which Daylight Saving Time is never observed.
**	4.	They might reference tzname[0] after setting to a time zone
**		in which Standard Time is never observed.
**	5.	They might reference tm.TM_ZONE after calling offtime.
** What's best to do in the above cases is open to debate;
** for now, we just set things up so that in any of the five cases
** WILDABBR is used. Another possibility: initialize tzname[0] to the
** string "tzname[0] used before set", and similarly for the other cases.
** And another: initialize tzname[0] to "ERA", with an explanation in the
** manual page of what this "time zone abbreviation" means (doing this so
** that tzname[0] has the "normal" length of three characters).
*/
#define WILDABBR	"   "
#endif /* !defined WILDABBR */

static const char	wildabbr[] = WILDABBR;

static const char	gmt[] = "GMT";

/*
** The DST rules to use if TZ has no rules and we can't load TZDEFRULES.
** We default to US rules as of 1999-08-17.
** POSIX 1003.1 section 8.1.1 says that the default DST rules are
** implementation dependent; for historical reasons, US rules are a
** common default.
*/
#ifndef TZDEFRULESTRING
#define TZDEFRULESTRING ",M4.1.0,M10.5.0"
#endif /* !defined TZDEFDST */

struct ttinfo {				/* time type information */
	long		tt_gmtoff;	/* UTC offset in seconds */
	int		tt_isdst;	/* used to set tm_isdst */
	int		tt_abbrind;	/* abbreviation list index */
	int		tt_ttisstd;	/* TRUE if transition is std time */
	int		tt_ttisgmt;	/* TRUE if transition is UTC */
};

struct lsinfo {				/* leap second information */
	time_t		ls_trans;	/* transition time */
	long		ls_corr;	/* correction to apply */
};

#define BIGGEST(a, b)	(((a) > (b)) ? (a) : (b))

#ifdef TZNAME_MAX
#define MY_TZNAME_MAX	TZNAME_MAX
#endif /* defined TZNAME_MAX */
#ifndef TZNAME_MAX
#define MY_TZNAME_MAX	255
#endif /* !defined TZNAME_MAX */

struct __state {
	int		leapcnt;
	int		timecnt;
	int		typecnt;
	int		charcnt;
	int		goback;
	int		goahead;
	time_t		ats[TZ_MAX_TIMES];
	unsigned char	types[TZ_MAX_TIMES];
	struct ttinfo	ttis[TZ_MAX_TYPES];
	char		chars[/*CONSTCOND*/BIGGEST(BIGGEST(TZ_MAX_CHARS + 1,
				sizeof gmt), (2 * (MY_TZNAME_MAX + 1)))];
	struct lsinfo	lsis[TZ_MAX_LEAPS];
};

typedef struct __state *timezone_t;

struct rule {
	int		r_type;		/* type of rule--see below */
	int		r_day;		/* day number of rule */
	int		r_week;		/* week number of rule */
	int		r_mon;		/* month number of rule */
	long		r_time;		/* transition time of rule */
};

#define JULIAN_DAY		0	/* Jn - Julian day */
#define DAY_OF_YEAR		1	/* n - day of year */
#define MONTH_NTH_DAY_OF_WEEK	2	/* Mm.n.d - month, week, day of week */

typedef struct tm *(*subfun_t)(const timezone_t sp, const time_t *timep,
			       long offset, struct tm *tmp);

/*
** Prototypes for static functions.
*/

static long		detzcode(const char * codep);
static time_t		detzcode64(const char * codep);
static int		differ_by_repeat(time_t t1, time_t t0);
static const char *	getzname(const char * strp) __pure;
static const char *	getqzname(const char * strp, const int delim) __pure;
static const char *	getnum(const char * strp, int * nump, int min,
				int max);
static const char *	getsecs(const char * strp, long * secsp);
static const char *	getoffset(const char * strp, long * offsetp);
static const char *	getrule(const char * strp, struct rule * rulep);
static void		gmtload(timezone_t sp);
static struct tm *	gmtsub(const timezone_t sp, const time_t *timep,
				long offset, struct tm * tmp);
static struct tm *	localsub(const timezone_t sp, const time_t *timep,
				long offset, struct tm *tmp);
static int		increment_overflow(int * number, int delta);
static int		leaps_thru_end_of(int y) __pure;
static int		long_increment_overflow(long * number, int delta);
static int		long_normalize_overflow(long * tensptr,
				int * unitsptr, int base);
static int		normalize_overflow(int * tensptr, int * unitsptr,
				int base);
static void		settzname(void);
static time_t		time1(const timezone_t sp, struct tm * const tmp,
				subfun_t funcp, const long offset);
static time_t		time2(const timezone_t sp, struct tm * const tmp,
				subfun_t funcp,
				const long offset, int *const okayp);
static time_t		time2sub(const timezone_t sp, struct tm * const tmp,
				subfun_t funcp, const long offset,
				int *const okayp, const int do_norm_secs);
static struct tm *	timesub(const timezone_t sp, const time_t * timep,
				long offset, struct tm * tmp);
static int		tmcomp(const struct tm * atmp,
				const struct tm * btmp);
static time_t		transtime(time_t janfirst, int year,
				const struct rule * rulep, long offset) __pure;
static int		typesequiv(const timezone_t sp, int a, int b);
static int		tzload(timezone_t sp, const char * name,
				int doextend);
static int		tzparse(timezone_t sp, const char * name,
				int lastditch);
static void		tzset_unlocked(void);
static long		leapcorr(const timezone_t sp, time_t * timep);

static timezone_t lclptr;
static timezone_t gmtptr;

#ifndef TZ_STRLEN_MAX
#define TZ_STRLEN_MAX 255
#endif /* !defined TZ_STRLEN_MAX */

static char		lcl_TZname[TZ_STRLEN_MAX + 1];
static enum lcl_states
{
  lcl_setting = -1,
  lcl_unset = 0,
  lcl_from_environment = 1,
  lcl_from_default = 2
} lcl_is_set;
static int		gmt_is_set;

#define tzname _tzname
#undef _tzname

char *	tzname[2] = {
	(char *) wildabbr,
	(char *) wildabbr
};

/*
** Section 4.12.3 of X3.159-1989 requires that
**	Except for the strftime function, these functions [asctime,
**	ctime, gmtime, localtime] return values in one of two static
**	objects: a broken-down time structure and an array of char.
** Thanks to Paul Eggert for noting this.
*/

static struct tm	tm;

/* These variables are initialized by tzset.  The macro versions are
   defined in time.h, and indirect through the __imp_ pointers.  */

#define timezone _timezone
#define daylight _daylight
#undef _timezone
#undef _daylight

#ifdef USG_COMPAT
long			timezone = 0;
int			daylight;
#endif /* defined USG_COMPAT */

#ifdef ALTZONE
time_t			altzone = 0;
#endif /* defined ALTZONE */

static long
detzcode(const char *const codep)
{
	long	result;
	int	i;

	result = (codep[0] & 0x80) ? ~0L : 0;
	for (i = 0; i < 4; ++i)
		result = (result << 8) | (codep[i] & 0xff);
	return result;
}

static time_t
detzcode64(const char *const codep)
{
	time_t	result;
	int	i;

	result = (time_t)((codep[0] & 0x80) ? (~(int_fast64_t) 0) : 0);
	for (i = 0; i < 8; ++i)
		result = result * 256 + (codep[i] & 0xff);
	return result;
}

static void
settzname (void)
{
	timezone_t const	sp = lclptr;
	int			i;

	tzname[0] = (char *) wildabbr;
	tzname[1] = (char *) wildabbr;
#ifdef USG_COMPAT
	daylight = 0;
	timezone = 0;
#endif /* defined USG_COMPAT */
#ifdef ALTZONE
	altzone = 0;
#endif /* defined ALTZONE */
	if (sp == NULL) {
		tzname[0] = tzname[1] = (char *) gmt;
		return;
	}
	for (i = 0; i < sp->typecnt; ++i) {
		const struct ttinfo * const	ttisp = &sp->ttis[i];

		tzname[ttisp->tt_isdst] =
			&sp->chars[ttisp->tt_abbrind];
#ifdef USG_COMPAT
		if (ttisp->tt_isdst)
			daylight = 1;
		if (!ttisp->tt_isdst)
			timezone = -(ttisp->tt_gmtoff);
#endif /* defined USG_COMPAT */
#ifdef ALTZONE
		if (ttisp->tt_isdst)
			altzone = -(ttisp->tt_gmtoff);
#endif /* defined ALTZONE */
	}
	/*
	** And to get the latest zone names into tzname. . .
	*/
	for (i = 0; i < sp->timecnt; ++i) {
		const struct ttinfo *const ttisp = &sp->ttis[sp->types[i]];

		tzname[ttisp->tt_isdst] =
			&sp->chars[ttisp->tt_abbrind];
	}
}

#include "tz_posixrules.h"

static int
differ_by_repeat(const time_t t1, const time_t t0)
{
	if (TYPE_INTEGRAL(time_t) &&
		TYPE_BIT(time_t) - TYPE_SIGNED(time_t) < SECSPERREPEAT_BITS)
			return 0;
	return (int_fast64_t)t1 - (int_fast64_t)t0 == SECSPERREPEAT;
}

static int
tzload(timezone_t sp, const char *name, const int doextend)
{
	const char *		p;
	int			i;
	int			fid;
	int			stored;
	ssize_t			nread;
	typedef union {
		struct tzhead	tzhead;
		char		buf[2 * sizeof(struct tzhead) +
					2 * sizeof *sp +
					4 * TZ_MAX_TIMES];
	} u_t;
	u_t *			up;
	save_errno		save;

	up = (u_t *) calloc(1, sizeof *up);
	if (up == NULL)
		return -1;

	sp->goback = sp->goahead = FALSE;
	if (name == NULL && (name = TZDEFAULT) == NULL)
		goto oops;
	{
		int	doaccess;
		/*
		** Section 4.9.1 of the C standard says that
		** "FILENAME_MAX expands to an integral constant expression
		** that is the size needed for an array of char large enough
		** to hold the longest file name string that the implementation
		** guarantees can be opened."
		*/
		char		fullname[FILENAME_MAX + 1];

		if (name[0] == ':')
			++name;
		doaccess = name[0] == '/';
		if (!doaccess) {
			if ((p = TZDIR) == NULL)
				goto oops;
			if ((strlen(p) + strlen(name) + 1) >= sizeof fullname)
				goto oops;
			(void) strcpy(fullname, p);	/* XXX strcpy is safe */
			(void) strcat(fullname, "/");	/* XXX strcat is safe */
			(void) strcat(fullname, name);	/* XXX strcat is safe */
			/*
			** Set doaccess if '.' (as in "../") shows up in name.
			*/
			if (strchr(name, '.') != NULL)
				doaccess = TRUE;
			name = fullname;
		}
		if ((doaccess && access(name, R_OK) != 0)
		    || (fid = open(name, OPEN_MODE)) == -1)
		  {
		    const char *base = strrchr(name, '/');
		    if (base)
		      base++;
		    else
		      base = name;
		    if (strcmp(base, "posixrules"))
		      goto oops;

		    /* We've got a built-in copy of posixrules just in case */
		    fid = -2;
		  }
	}
	if (fid == -2)
	  {
	    memcpy(up->buf, _posixrules_data, sizeof (_posixrules_data));
	    nread = sizeof (_posixrules_data);
	  }
	else
	  {
	    nread = read(fid, up->buf, sizeof up->buf);
	    if (close(fid) < 0 || nread <= 0)
	      goto oops;
	  }
	for (stored = 4; stored <= 8; stored *= 2) {
		int		ttisstdcnt;
		int		ttisgmtcnt;

		ttisstdcnt = (int) detzcode(up->tzhead.tzh_ttisstdcnt);
		ttisgmtcnt = (int) detzcode(up->tzhead.tzh_ttisgmtcnt);
		sp->leapcnt = (int) detzcode(up->tzhead.tzh_leapcnt);
		sp->timecnt = (int) detzcode(up->tzhead.tzh_timecnt);
		sp->typecnt = (int) detzcode(up->tzhead.tzh_typecnt);
		sp->charcnt = (int) detzcode(up->tzhead.tzh_charcnt);
		p = up->tzhead.tzh_charcnt + sizeof up->tzhead.tzh_charcnt;
		if (sp->leapcnt < 0 || sp->leapcnt > TZ_MAX_LEAPS ||
			sp->typecnt <= 0 || sp->typecnt > TZ_MAX_TYPES ||
			sp->timecnt < 0 || sp->timecnt > TZ_MAX_TIMES ||
			sp->charcnt < 0 || sp->charcnt > TZ_MAX_CHARS ||
			(ttisstdcnt != sp->typecnt && ttisstdcnt != 0) ||
			(ttisgmtcnt != sp->typecnt && ttisgmtcnt != 0))
				goto oops;
		if (nread - (p - up->buf) <
			sp->timecnt * stored +		/* ats */
			sp->timecnt +			/* types */
			sp->typecnt * 6 +		/* ttinfos */
			sp->charcnt +			/* chars */
			sp->leapcnt * (stored + 4) +	/* lsinfos */
			ttisstdcnt +			/* ttisstds */
			ttisgmtcnt)			/* ttisgmts */
				goto oops;
		for (i = 0; i < sp->timecnt; ++i) {
			sp->ats[i] = (time_t)((stored == 4) ?
				detzcode(p) : detzcode64(p));
			p += stored;
		}
		for (i = 0; i < sp->timecnt; ++i) {
			sp->types[i] = (unsigned char) *p++;
			if (sp->types[i] >= sp->typecnt)
				goto oops;
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *	ttisp;

			ttisp = &sp->ttis[i];
			ttisp->tt_gmtoff = detzcode(p);
			p += 4;
			ttisp->tt_isdst = (unsigned char) *p++;
			if (ttisp->tt_isdst != 0 && ttisp->tt_isdst != 1)
				goto oops;
			ttisp->tt_abbrind = (unsigned char) *p++;
			if (ttisp->tt_abbrind < 0 ||
				ttisp->tt_abbrind > sp->charcnt)
					goto oops;
		}
		for (i = 0; i < sp->charcnt; ++i)
			sp->chars[i] = *p++;
		sp->chars[i] = '\0';	/* ensure '\0' at end */
		for (i = 0; i < sp->leapcnt; ++i) {
			struct lsinfo *	lsisp;

			lsisp = &sp->lsis[i];
			lsisp->ls_trans = (time_t)((stored == 4) ?
			    detzcode(p) : detzcode64(p));
			p += stored;
			lsisp->ls_corr = detzcode(p);
			p += 4;
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *	ttisp;

			ttisp = &sp->ttis[i];
			if (ttisstdcnt == 0)
				ttisp->tt_ttisstd = FALSE;
			else {
				ttisp->tt_ttisstd = *p++;
				if (ttisp->tt_ttisstd != TRUE &&
					ttisp->tt_ttisstd != FALSE)
						goto oops;
			}
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *	ttisp;

			ttisp = &sp->ttis[i];
			if (ttisgmtcnt == 0)
				ttisp->tt_ttisgmt = FALSE;
			else {
				ttisp->tt_ttisgmt = *p++;
				if (ttisp->tt_ttisgmt != TRUE &&
					ttisp->tt_ttisgmt != FALSE)
						goto oops;
			}
		}
		/*
		** Out-of-sort ats should mean we're running on a
		** signed time_t system but using a data file with
		** unsigned values (or vice versa).
		*/
		for (i = 0; i < sp->timecnt - 2; ++i)
			if (sp->ats[i] > sp->ats[i + 1]) {
				++i;
				if (TYPE_SIGNED(time_t)) {
					/*
					** Ignore the end (easy).
					*/
					sp->timecnt = i;
				} else {
					/*
					** Ignore the beginning (harder).
					*/
					int	j;

					for (j = 0; j + i < sp->timecnt; ++j) {
						sp->ats[j] = sp->ats[j + i];
						sp->types[j] = sp->types[j + i];
					}
					sp->timecnt = j;
				}
				break;
			}
		/*
		** If this is an old file, we're done.
		*/
		if (up->tzhead.tzh_version[0] == '\0')
			break;
		nread -= p - up->buf;
		for (i = 0; i < nread; ++i)
			up->buf[i] = p[i];
		/*
		** If this is a narrow integer time_t system, we're done.
		*/
		if (stored >= (int) sizeof(time_t)
/* CONSTCOND */
				&& TYPE_INTEGRAL(time_t))
			break;
	}
	if (doextend && nread > 2 &&
		up->buf[0] == '\n' && up->buf[nread - 1] == '\n' &&
		sp->typecnt + 2 <= TZ_MAX_TYPES) {
			struct __state ts;
			int	result;

			up->buf[nread - 1] = '\0';
			result = tzparse(&ts, &up->buf[1], FALSE);
			if (result == 0 && ts.typecnt == 2 &&
				sp->charcnt + ts.charcnt <= TZ_MAX_CHARS) {
					for (i = 0; i < 2; ++i)
						ts.ttis[i].tt_abbrind +=
							sp->charcnt;
					for (i = 0; i < ts.charcnt; ++i)
						sp->chars[sp->charcnt++] =
							ts.chars[i];
					i = 0;
					while (i < ts.timecnt &&
						ts.ats[i] <=
						sp->ats[sp->timecnt - 1])
							++i;
					while (i < ts.timecnt &&
					    sp->timecnt < TZ_MAX_TIMES) {
						sp->ats[sp->timecnt] =
							ts.ats[i];
						sp->types[sp->timecnt] =
							sp->typecnt +
							ts.types[i];
						++sp->timecnt;
						++i;
					}
					sp->ttis[sp->typecnt++] = ts.ttis[0];
					sp->ttis[sp->typecnt++] = ts.ttis[1];
			}
	}
	if (sp->timecnt > 1) {
		for (i = 1; i < sp->timecnt; ++i)
			if (typesequiv(sp, sp->types[i], sp->types[0]) &&
				differ_by_repeat(sp->ats[i], sp->ats[0])) {
					sp->goback = TRUE;
					break;
				}
		for (i = sp->timecnt - 2; i >= 0; --i)
			if (typesequiv(sp, sp->types[sp->timecnt - 1],
				sp->types[i]) &&
				differ_by_repeat(sp->ats[sp->timecnt - 1],
				sp->ats[i])) {
					sp->goahead = TRUE;
					break;
		}
	}
	free(up);
	/*
	** Get latest zone offsets into tzinfo (for newlib). . .
	*/
	if (sp == lclptr)
	  {
	    for (i = 0; i < sp->timecnt; ++i)
	      {
		const struct ttinfo *const ttisp = &sp->ttis[sp->types[i]];

		__gettzinfo ()->__tzrule[ttisp->tt_isdst].offset
				    = -ttisp->tt_gmtoff;
	      }
	  }
	return 0;
oops:
	free(up);
	return -1;
}

static int
typesequiv(const timezone_t sp, const int a, const int b)
{
	int	result;

	if (sp == NULL ||
		a < 0 || a >= sp->typecnt ||
		b < 0 || b >= sp->typecnt)
			result = FALSE;
	else {
		const struct ttinfo *	ap = &sp->ttis[a];
		const struct ttinfo *	bp = &sp->ttis[b];
		result = ap->tt_gmtoff == bp->tt_gmtoff &&
			ap->tt_isdst == bp->tt_isdst &&
			ap->tt_ttisstd == bp->tt_ttisstd &&
			ap->tt_ttisgmt == bp->tt_ttisgmt &&
			strcmp(&sp->chars[ap->tt_abbrind],
			&sp->chars[bp->tt_abbrind]) == 0;
	}
	return result;
}

static const int	mon_lengths[2][MONSPERYEAR] = {
	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
};

static const int	year_lengths[2] = {
	DAYSPERNYEAR, DAYSPERLYEAR
};

/*
** Given a pointer into a time zone string, scan until a character that is not
** a valid character in a zone name is found. Return a pointer to that
** character.
*/

static const char *
getzname(const char *strp)
{
	char	c;

	while ((c = *strp) != '\0' && !is_digit(c) && c != ',' && c != '-' &&
		c != '+')
			++strp;
	return strp;
}

/*
** Given a pointer into an extended time zone string, scan until the ending
** delimiter of the zone name is located. Return a pointer to the delimiter.
**
** As with getzname above, the legal character set is actually quite
** restricted, with other characters producing undefined results.
** We don't do any checking here; checking is done later in common-case code.
*/

static const char *
getqzname(const char *strp, const int delim)
{
	int	c;

	while ((c = *strp) != '\0' && c != delim)
		++strp;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a number from that string.
** Check that the number is within a specified range; if it is not, return
** NULL.
** Otherwise, return a pointer to the first character not part of the number.
*/

static const char *
getnum(const char *strp, int *const nump, const int min, const int max)
{
	char	c;
	int	num;

	if (strp == NULL || !is_digit(c = *strp)) {
		errno = EINVAL;
		return NULL;
	}
	num = 0;
	do {
		num = num * 10 + (c - '0');
		if (num > max) {
			errno = EOVERFLOW;
			return NULL;	/* illegal value */
		}
		c = *++strp;
	} while (is_digit(c));
	if (num < min) {
		errno = EINVAL;
		return NULL;		/* illegal value */
	}
	*nump = num;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a number of seconds,
** in hh[:mm[:ss]] form, from the string.
** If any error occurs, return NULL.
** Otherwise, return a pointer to the first character not part of the number
** of seconds.
*/

static const char *
getsecs(const char *strp, long *const secsp)
{
	int	num;

	/*
	** `HOURSPERDAY * DAYSPERWEEK - 1' allows quasi-Posix rules like
	** "M10.4.6/26", which does not conform to Posix,
	** but which specifies the equivalent of
	** ``02:00 on the first Sunday on or after 23 Oct''.
	*/
	strp = getnum(strp, &num, 0, HOURSPERDAY * DAYSPERWEEK - 1);
	if (strp == NULL)
		return NULL;
	*secsp = num * (long) SECSPERHOUR;
	if (*strp == ':') {
		++strp;
		strp = getnum(strp, &num, 0, MINSPERHOUR - 1);
		if (strp == NULL)
			return NULL;
		*secsp += num * SECSPERMIN;
		if (*strp == ':') {
			++strp;
			/* `SECSPERMIN' allows for leap seconds. */
			strp = getnum(strp, &num, 0, SECSPERMIN);
			if (strp == NULL)
				return NULL;
			*secsp += num;
		}
	}
	return strp;
}

/*
** Given a pointer into a time zone string, extract an offset, in
** [+-]hh[:mm[:ss]] form, from the string.
** If any error occurs, return NULL.
** Otherwise, return a pointer to the first character not part of the time.
*/

static const char *
getoffset(const char *strp, long *const offsetp)
{
	int	neg = 0;

	if (*strp == '-') {
		neg = 1;
		++strp;
	} else if (*strp == '+')
		++strp;
	strp = getsecs(strp, offsetp);
	if (strp == NULL)
		return NULL;		/* illegal time */
	if (neg)
		*offsetp = -*offsetp;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a rule in the form
** date[/time]. See POSIX section 8 for the format of "date" and "time".
** If a valid rule is not found, return NULL.
** Otherwise, return a pointer to the first character not part of the rule.
*/

static const char *
getrule(const char *strp, struct rule *const rulep)
{
	if (*strp == 'J') {
		/*
		** Julian day.
		*/
		rulep->r_type = JULIAN_DAY;
		++strp;
		strp = getnum(strp, &rulep->r_day, 1, DAYSPERNYEAR);
	} else if (*strp == 'M') {
		/*
		** Month, week, day.
		*/
		rulep->r_type = MONTH_NTH_DAY_OF_WEEK;
		++strp;
		strp = getnum(strp, &rulep->r_mon, 1, MONSPERYEAR);
		if (strp == NULL)
			return NULL;
		if (*strp++ != '.')
			return NULL;
		strp = getnum(strp, &rulep->r_week, 1, 5);
		if (strp == NULL)
			return NULL;
		if (*strp++ != '.')
			return NULL;
		strp = getnum(strp, &rulep->r_day, 0, DAYSPERWEEK - 1);
	} else if (is_digit(*strp)) {
		/*
		** Day of year.
		*/
		rulep->r_type = DAY_OF_YEAR;
		strp = getnum(strp, &rulep->r_day, 0, DAYSPERLYEAR - 1);
	} else	return NULL;		/* invalid format */
	if (strp == NULL)
		return NULL;
	if (*strp == '/') {
		/*
		** Time specified.
		*/
		++strp;
		strp = getsecs(strp, &rulep->r_time);
	} else	rulep->r_time = 2 * SECSPERHOUR;	/* default = 2:00:00 */
	return strp;
}

/*
** Given the Epoch-relative time of January 1, 00:00:00 UTC, in a year, the
** year, a rule, and the offset from UTC at the time that rule takes effect,
** calculate the Epoch-relative time that rule takes effect.
*/

static time_t
transtime(const time_t janfirst, const int year, const struct rule *const rulep,
    const long offset)
{
	int	leapyear;
	time_t	value;
	int	i;
	int		d, m1, yy0, yy1, yy2, dow;

	INITIALIZE(value);
	leapyear = isleap(year);
	switch (rulep->r_type) {

	case JULIAN_DAY:
		/*
		** Jn - Julian day, 1 == January 1, 60 == March 1 even in leap
		** years.
		** In non-leap years, or if the day number is 59 or less, just
		** add SECSPERDAY times the day number-1 to the time of
		** January 1, midnight, to get the day.
		*/
		value = (time_t)(janfirst + (rulep->r_day - 1) * SECSPERDAY);
		if (leapyear && rulep->r_day >= 60)
			value += SECSPERDAY;
		break;

	case DAY_OF_YEAR:
		/*
		** n - day of year.
		** Just add SECSPERDAY times the day number to the time of
		** January 1, midnight, to get the day.
		*/
		value = (time_t)(janfirst + rulep->r_day * SECSPERDAY);
		break;

	case MONTH_NTH_DAY_OF_WEEK:
		/*
		** Mm.n.d - nth "dth day" of month m.
		*/
		value = janfirst;
		for (i = 0; i < rulep->r_mon - 1; ++i)
			value += (time_t)(mon_lengths[leapyear][i] * SECSPERDAY);

		/*
		** Use Zeller's Congruence to get day-of-week of first day of
		** month.
		*/
		m1 = (rulep->r_mon + 9) % 12 + 1;
		yy0 = (rulep->r_mon <= 2) ? (year - 1) : year;
		yy1 = yy0 / 100;
		yy2 = yy0 % 100;
		dow = ((26 * m1 - 2) / 10 +
			1 + yy2 + yy2 / 4 + yy1 / 4 - 2 * yy1) % 7;
		if (dow < 0)
			dow += DAYSPERWEEK;

		/*
		** "dow" is the day-of-week of the first day of the month. Get
		** the day-of-month (zero-origin) of the first "dow" day of the
		** month.
		*/
		d = rulep->r_day - dow;
		if (d < 0)
			d += DAYSPERWEEK;
		for (i = 1; i < rulep->r_week; ++i) {
			if (d + DAYSPERWEEK >=
				mon_lengths[leapyear][rulep->r_mon - 1])
					break;
			d += DAYSPERWEEK;
		}

		/*
		** "d" is the day-of-month (zero-origin) of the day we want.
		*/
		value += (time_t)(d * SECSPERDAY);
		break;
	}

	/*
	** "value" is the Epoch-relative time of 00:00:00 UTC on the day in
	** question. To get the Epoch-relative time of the specified local
	** time on that day, add the transition time and the current offset
	** from UTC.
	*/
	return (time_t)(value + rulep->r_time + offset);
}

/*
** Given a POSIX section 8-style TZ string, fill in the rule tables as
** appropriate.
*/

static int
tzparse(timezone_t sp, const char *name, const int lastditch)
{
	const char *			stdname;
	const char *			dstname;
	size_t				stdlen;
	size_t				dstlen;
	long				stdoffset;
	long				dstoffset;
	time_t *		atp;
	unsigned char *	typep;
	char *			cp;
	int			load_result;

	INITIALIZE(dstname);
	stdname = name;
	if (lastditch) {
		stdlen = strlen(name);	/* length of standard zone name */
		name += stdlen;
		if (stdlen >= sizeof sp->chars)
			stdlen = (sizeof sp->chars) - 1;
		stdoffset = 0;
	} else {
		if (*name == '<') {
			name++;
			stdname = name;
			name = getqzname(name, '>');
			if (*name != '>')
				return (-1);
			stdlen = name - stdname;
			name++;
		} else {
			name = getzname(name);
			stdlen = name - stdname;
		}
		if (*name == '\0')
			return -1;
		name = getoffset(name, &stdoffset);
		if (name == NULL)
			return -1;
	}
	load_result = tzload(sp, TZDEFRULES, FALSE);
	if (load_result != 0)
		sp->leapcnt = 0;		/* so, we're off a little */
	if (*name != '\0') {
		if (*name == '<') {
			dstname = ++name;
			name = getqzname(name, '>');
			if (*name != '>')
				return -1;
			dstlen = name - dstname;
			name++;
		} else {
			dstname = name;
			name = getzname(name);
			dstlen = name - dstname; /* length of DST zone name */
		}
		if (*name != '\0' && *name != ',' && *name != ';') {
			name = getoffset(name, &dstoffset);
			if (name == NULL)
				return -1;
		} else	dstoffset = stdoffset - SECSPERHOUR;
		if (*name == '\0' && load_result != 0)
			name = TZDEFRULESTRING;
		if (*name == ',' || *name == ';') {
			struct rule	start;
			struct rule	end;
			int	year;
			time_t	janfirst;
			time_t		starttime;
			time_t		endtime;

			++name;
			if ((name = getrule(name, &start)) == NULL)
				return -1;
			if (*name++ != ',')
				return -1;
			if ((name = getrule(name, &end)) == NULL)
				return -1;
			if (*name != '\0')
				return -1;
			sp->typecnt = 2;	/* standard time and DST */
			/*
			** Two transitions per year, from EPOCH_YEAR forward.
			*/
			memset(sp->ttis, 0, sizeof(sp->ttis));
			sp->ttis[0].tt_gmtoff = -dstoffset;
			sp->ttis[0].tt_isdst = 1;
			sp->ttis[0].tt_abbrind = (int)(stdlen + 1);
			sp->ttis[1].tt_gmtoff = -stdoffset;
			sp->ttis[1].tt_isdst = 0;
			sp->ttis[1].tt_abbrind = 0;
			atp = sp->ats;
			typep = sp->types;
			janfirst = 0;
			sp->timecnt = 0;
			for (year = EPOCH_YEAR;
			    sp->timecnt + 2 <= TZ_MAX_TIMES;
			    ++year) {
			    	time_t	newfirst;

				starttime = transtime(janfirst, year, &start,
					stdoffset);
				endtime = transtime(janfirst, year, &end,
					dstoffset);
				if (starttime > endtime) {
					*atp++ = endtime;
					*typep++ = 1;	/* DST ends */
					*atp++ = starttime;
					*typep++ = 0;	/* DST begins */
				} else {
					*atp++ = starttime;
					*typep++ = 0;	/* DST begins */
					*atp++ = endtime;
					*typep++ = 1;	/* DST ends */
				}
				sp->timecnt += 2;
				newfirst = janfirst;
				newfirst += (time_t)
				    (year_lengths[isleap(year)] * SECSPERDAY);
				if (newfirst <= janfirst)
					break;
				janfirst = newfirst;
			}
			/*
			** Get zone offsets into tzinfo (for newlib). . .
			*/
			if (sp == lclptr)
			  {
			    __gettzinfo ()->__tzrule[0].offset
						    = -sp->ttis[1].tt_gmtoff;
			    __gettzinfo ()->__tzrule[1].offset
						    = -sp->ttis[0].tt_gmtoff;
			  }
		} else {
			long	theirstdoffset;
			long	theirdstoffset;
			long	theiroffset;
			int	isdst;
			int	i;
			int	j;

			if (*name != '\0')
				return -1;
			/*
			** Initial values of theirstdoffset and theirdstoffset.
			*/
			theirstdoffset = 0;
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				if (!sp->ttis[j].tt_isdst) {
					theirstdoffset =
						-sp->ttis[j].tt_gmtoff;
					break;
				}
			}
			theirdstoffset = 0;
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				if (sp->ttis[j].tt_isdst) {
					theirdstoffset =
						-sp->ttis[j].tt_gmtoff;
					break;
				}
			}
			/*
			** Initially we're assumed to be in standard time.
			*/
			isdst = FALSE;
			theiroffset = theirstdoffset;
			/*
			** Now juggle transition times and types
			** tracking offsets as you do.
			*/
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				sp->types[i] = sp->ttis[j].tt_isdst;
				if (sp->ttis[j].tt_ttisgmt) {
					/* No adjustment to transition time */
				} else {
					/*
					** If summer time is in effect, and the
					** transition time was not specified as
					** standard time, add the summer time
					** offset to the transition time;
					** otherwise, add the standard time
					** offset to the transition time.
					*/
					/*
					** Transitions from DST to DDST
					** will effectively disappear since
					** POSIX provides for only one DST
					** offset.
					*/
					if (isdst && !sp->ttis[j].tt_ttisstd) {
						sp->ats[i] += (time_t)
						    (dstoffset - theirdstoffset);
					} else {
						sp->ats[i] += (time_t)
						    (stdoffset - theirstdoffset);
					}
				}
				theiroffset = -sp->ttis[j].tt_gmtoff;
				if (!sp->ttis[j].tt_isdst)
					theirstdoffset = theiroffset;
				else	theirdstoffset = theiroffset;
			}
			/*
			** Finally, fill in ttis.
			** ttisstd and ttisgmt need not be handled
			*/
			memset(sp->ttis, 0, sizeof(sp->ttis));
			sp->ttis[0].tt_gmtoff = -stdoffset;
			sp->ttis[0].tt_isdst = FALSE;
			sp->ttis[0].tt_abbrind = 0;
			sp->ttis[1].tt_gmtoff = -dstoffset;
			sp->ttis[1].tt_isdst = TRUE;
			sp->ttis[1].tt_abbrind = (int)(stdlen + 1);
			sp->typecnt = 2;
			/*
			** Get zone offsets into tzinfo (for newlib). . .
			*/
			if (sp == lclptr)
			  {
			    __gettzinfo ()->__tzrule[0].offset
						    = -sp->ttis[0].tt_gmtoff;
			    __gettzinfo ()->__tzrule[1].offset
						    = -sp->ttis[1].tt_gmtoff;
			  }
		}
	} else {
		dstlen = 0;
		sp->typecnt = 1;		/* only standard time */
		sp->timecnt = 0;
		memset(sp->ttis, 0, sizeof(sp->ttis));
		sp->ttis[0].tt_gmtoff = -stdoffset;
		sp->ttis[0].tt_isdst = 0;
		sp->ttis[0].tt_abbrind = 0;
		/*
		** Get zone offsets into tzinfo (for newlib). . .
		*/
		if (sp == lclptr)
		  {
		    __gettzinfo ()->__tzrule[0].offset = -sp->ttis[0].tt_gmtoff;
		    __gettzinfo ()->__tzrule[1].offset = -sp->ttis[0].tt_gmtoff;
		  }
	}
	sp->charcnt = (int)(stdlen + 1);
	if (dstlen != 0)
		sp->charcnt += (int)(dstlen + 1);
	if ((size_t) sp->charcnt > sizeof sp->chars)
		return -1;
	cp = sp->chars;
	(void) strncpy(cp, stdname, stdlen);
	cp += stdlen;
	*cp++ = '\0';
	if (dstlen != 0) {
		(void) strncpy(cp, dstname, dstlen);
		*(cp + dstlen) = '\0';
	}
	return 0;
}

static void
gmtload(timezone_t sp)
{
	if (tzload(sp, gmt, TRUE) != 0)
		(void) tzparse(sp, gmt, TRUE);
}

#ifndef STD_INSPIRED
/*
** A non-static declaration of tzsetwall in a system header file
** may cause a warning about this upcoming static declaration...
*/
static
#endif /* !defined STD_INSPIRED */
void
tzsetwall (void)
{
	if (lcl_is_set == lcl_setting)
		return;
	lcl_is_set = lcl_setting;

	if (lclptr == NULL) {
		save_errno save;
		lclptr = (timezone_t) calloc(1, sizeof *lclptr);
		if (lclptr == NULL) {
			settzname();	/* all we can do */
			return;
		}
	}
#if defined (__CYGWIN__)
	{
	    TIME_ZONE_INFORMATION tz;
	    char buf[BUFSIZ];
	    char *cp, *dst;
	    wchar_t *src;
	    div_t d;
	    GetTimeZoneInformation(&tz);
	    dst = cp = buf;
	    for (src = tz.StandardName; *src; src++)
	      if (isupper(*src)) *dst++ = *src;
	    if ((dst - cp) < 3)
	      {
		/* In non-english Windows, converted tz.StandardName
		   may not contain a valid standard timezone name. */
		strcpy(cp, wildabbr);
		cp += strlen(wildabbr);
	      }
	    else
	      cp = dst;
	    d = div(tz.Bias+tz.StandardBias, 60);
	    sprintf(cp, "%d", d.quot);
	    if (d.rem)
		sprintf(cp=strchr(cp, 0), ":%d", abs(d.rem));
	    if(tz.StandardDate.wMonth) {
		cp = strchr(cp, 0);
		dst = cp;
		for (src = tz.DaylightName; *src; src++)
		  if (isupper(*src)) *dst++ = *src;
		if ((dst - cp) < 3)
		  {
		    /* In non-english Windows, converted tz.DaylightName
		       may not contain a valid daylight timezone name. */
		    strcpy(cp, wildabbr);
		    cp += strlen(wildabbr);
		  }
		else
		  cp = dst;
		d = div(tz.Bias+tz.DaylightBias, 60);
		sprintf(cp, "%d", d.quot);
		if (d.rem)
		    sprintf(cp=strchr(cp, 0), ":%d", abs(d.rem));
		cp = strchr(cp, 0);
		sprintf(cp=strchr(cp, 0), ",M%d.%d.%d/%d",
		    tz.DaylightDate.wMonth,
		    tz.DaylightDate.wDay,
		    tz.DaylightDate.wDayOfWeek,
		    tz.DaylightDate.wHour);
		if (tz.DaylightDate.wMinute || tz.DaylightDate.wSecond)
		    sprintf(cp=strchr(cp, 0), ":%d", tz.DaylightDate.wMinute);
		if (tz.DaylightDate.wSecond)
		    sprintf(cp=strchr(cp, 0), ":%d", tz.DaylightDate.wSecond);
		cp = strchr(cp, 0);
		sprintf(cp=strchr(cp, 0), ",M%d.%d.%d/%d",
		    tz.StandardDate.wMonth,
		    tz.StandardDate.wDay,
		    tz.StandardDate.wDayOfWeek,
		    tz.StandardDate.wHour);
		if (tz.StandardDate.wMinute || tz.StandardDate.wSecond)
		    sprintf(cp=strchr(cp, 0), ":%d", tz.StandardDate.wMinute);
		if (tz.StandardDate.wSecond)
		    sprintf(cp=strchr(cp, 0), ":%d", tz.StandardDate.wSecond);
	    }
	    /* printf("TZ deduced as `%s'\n", buf); */
	    if (tzparse(lclptr, buf, FALSE) == 0) {
		settzname();
		lcl_is_set = lcl_from_default;
		strlcpy(lcl_TZname, buf, sizeof (lcl_TZname));
#if 0
		/* Huh?  POSIX doesn't mention anywhere that tzset should
		   set $TZ.  That's not right. */
		setenv("TZ", lcl_TZname, 1);
#endif
		return;
	    }
	}
#endif
	if (tzload(lclptr, NULL, TRUE) != 0)
		gmtload(lclptr);
	settzname();
}

static NO_COPY muto tzset_guard;

#ifndef STD_INSPIRED
/*
** A non-static declaration of tzsetwall in a system header file
** may cause a warning about this upcoming static declaration...
*/
static
#endif /* !defined STD_INSPIRED */
void
tzset_unlocked(void)
{
	const char *	name;

	name = getenv("TZ");
	if (name == NULL) {
		if (lcl_is_set != lcl_from_default)
			tzsetwall();
		return;
	}

	if (lcl_is_set > 0 && strcmp(lcl_TZname, name) == 0)
		return;
	lcl_is_set = (strlen(name) < sizeof (lcl_TZname)) ? lcl_from_environment : lcl_unset;
	if (lcl_is_set != lcl_unset)
		(void)strlcpy(lcl_TZname, name, sizeof (lcl_TZname));

	if (lclptr == NULL) {
		save_errno save;
		lclptr = (timezone_t) calloc(1, sizeof *lclptr);
		if (lclptr == NULL) {
			settzname();	/* all we can do */
			return;
		}
	}
	if (*name == '\0') {
		/*
		** User wants it fast rather than right.
		*/
		lclptr->leapcnt = 0;		/* so, we're off a little */
		lclptr->timecnt = 0;
		lclptr->typecnt = 0;
		lclptr->ttis[0].tt_isdst = 0;
		lclptr->ttis[0].tt_gmtoff = 0;
		lclptr->ttis[0].tt_abbrind = 0;
		(void) strlcpy(lclptr->chars, gmt, sizeof(lclptr->chars));
	} else if (tzload(lclptr, name, TRUE) != 0)
		if (name[0] == ':' || tzparse(lclptr, name, FALSE) != 0)
			(void) gmtload(lclptr);
	settzname();
}

extern "C" void
tzset(void)
{
	tzset_guard.init ("tzset_guard")->acquire ();
	tzset_unlocked();
	tzset_guard.release ();
}

/*
** The easy way to behave "as if no library function calls" localtime
** is to not call it--so we drop its guts into "localsub", which can be
** freely called. (And no, the PANS doesn't require the above behavior--
** but it *is* desirable.)
**
** The unused offset argument is for the benefit of mktime variants.
*/

/*ARGSUSED*/
static struct tm *
localsub(const timezone_t sp, const time_t * const timep, const long offset,
    struct tm *const tmp)
{
	const struct ttinfo *	ttisp;
	int			i;
	struct tm *		result;
	const time_t			t = *timep;

	if ((sp->goback && t < sp->ats[0]) ||
		(sp->goahead && t > sp->ats[sp->timecnt - 1])) {
			time_t			newt = t;
			time_t		seconds;
			time_t		tcycles;
			int_fast64_t	icycles;

			if (t < sp->ats[0])
				seconds = sp->ats[0] - t;
			else	seconds = t - sp->ats[sp->timecnt - 1];
			--seconds;
			tcycles = (time_t)
			    (seconds / YEARSPERREPEAT / AVGSECSPERYEAR);
			++tcycles;
			icycles = tcycles;
			if (tcycles - icycles >= 1 || icycles - tcycles >= 1)
				return NULL;
			seconds = (time_t) icycles;
			seconds *= YEARSPERREPEAT;
			seconds *= AVGSECSPERYEAR;
			if (t < sp->ats[0])
				newt += seconds;
			else	newt -= seconds;
			if (newt < sp->ats[0] ||
				newt > sp->ats[sp->timecnt - 1])
					return NULL;	/* "cannot happen" */
			result = localsub(sp, &newt, offset, tmp);
			if (result == tmp) {
				time_t	newy;

				newy = tmp->tm_year;
				if (t < sp->ats[0])
					newy -= (time_t)icycles * YEARSPERREPEAT;
				else	newy += (time_t)icycles * YEARSPERREPEAT;
				tmp->tm_year = (int)newy;
				if (tmp->tm_year != newy)
					return NULL;
			}
			return result;
	}
	if (sp->timecnt == 0 || t < sp->ats[0]) {
		i = 0;
		while (sp->ttis[i].tt_isdst)
			if (++i >= sp->typecnt) {
				i = 0;
				break;
			}
	} else {
		int	lo = 1;
		int	hi = sp->timecnt;

		while (lo < hi) {
			int	mid = (lo + hi) / 2;

			if (t < sp->ats[mid])
				hi = mid;
			else	lo = mid + 1;
		}
		i = (int) sp->types[lo - 1];
	}
	ttisp = &sp->ttis[i];
	/*
	** To get (wrong) behavior that's compatible with System V Release 2.0
	** you'd replace the statement below with
	**	t += ttisp->tt_gmtoff;
	**	timesub(&t, 0L, sp, tmp);
	*/
	result = timesub(sp, &t, ttisp->tt_gmtoff, tmp);
	tmp->tm_isdst = ttisp->tt_isdst;
	if (sp == lclptr)
		tzname[tmp->tm_isdst] = &sp->chars[ttisp->tt_abbrind];
#ifdef TM_ZONE
	if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
	  tmp->TM_ZONE = &sp->chars[ttisp->tt_abbrind];
#endif /* defined TM_ZONE */
	return result;
}

/*
** Re-entrant version of localtime.
*/
extern "C" struct tm *
localtime_r(const time_t *__restrict timep, struct tm *__restrict tmp)
{
	tzset_guard.init ("tzset_guard")->acquire ();
	tzset_unlocked();
	tmp = localsub(lclptr, timep, 0L, tmp);
	tzset_guard.release ();
	if (tmp == NULL)
		errno = EOVERFLOW;
	return tmp;
}

extern "C" struct tm *
localtime(const time_t *const timep)
{
	return localtime_r(timep, &tm);
}

/*
** gmtsub is to gmtime as localsub is to localtime.
*/
static NO_COPY muto gmt_guard;

static struct tm *
gmtsub(const timezone_t sp, const time_t *const timep, const long offset,
    struct tm *tmp)
{
	struct tm *	result;

	gmt_guard.init ("gmt_guard")->acquire ();
	if (!gmt_is_set) {
		save_errno save;
		gmt_is_set = TRUE;
		gmtptr = (timezone_t) calloc(1, sizeof *gmtptr);
		if (gmtptr != NULL)
			gmtload(gmtptr);
	}
	gmt_guard.release ();
	result = timesub(gmtptr, timep, offset, tmp);
#ifdef TM_ZONE
	/*
	** Could get fancy here and deliver something such as
	** "UTC+xxxx" or "UTC-xxxx" if offset is non-zero,
	** but this is no time for a treasure hunt.
	*/
	if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
	  {
	    if (offset != 0)
		    tmp->TM_ZONE = wildabbr;
	    else {
		    if (gmtptr == NULL)
			    tmp->TM_ZONE = gmt;
		    else	tmp->TM_ZONE = gmtptr->chars;
	    }
	  }
#endif /* defined TM_ZONE */
	return result;
}

extern "C" struct tm *
gmtime(const time_t *const timep)
{
	struct tm *tmp = gmtsub(NULL, timep, 0L, &tm);

	if (tmp == NULL)
		errno = EOVERFLOW;

	return tmp;
}

/*
** Re-entrant version of gmtime.
*/

extern "C" struct tm *
gmtime_r(const time_t *__restrict const timep, struct tm *__restrict tmp)
{
	tmp = gmtsub(NULL, timep, 0L, tmp);

	if (tmp == NULL)
		errno = EOVERFLOW;

	return tmp;
}

#ifdef STD_INSPIRED

extern "C" struct tm *
offtime(const time_t *const timep, long offset)
{
	struct tm *tmp = gmtsub(NULL, timep, offset, &tm);

	if (tmp == NULL)
		errno = EOVERFLOW;

	return tmp;
}

#endif /* defined STD_INSPIRED */

/*
** Return the number of leap years through the end of the given year
** where, to make the math easy, the answer for year zero is defined as zero.
*/

static int
leaps_thru_end_of(const int y)
{
	return (y >= 0) ? (y / 4 - y / 100 + y / 400) :
		-(leaps_thru_end_of(-(y + 1)) + 1);
}

static struct tm *
timesub(const timezone_t sp, const time_t *const timep, const long offset,
    struct tm *const tmp)
{
	const struct lsinfo *	lp;
	time_t			tdays;
	int			idays;	/* unsigned would be so 2003 */
	long			rem;
	int			y;
	const int *		ip;
	long			corr;
	int			hit;
	int			i;

	corr = 0;
	hit = 0;
	i = (sp == NULL) ? 0 : sp->leapcnt;
	while (--i >= 0) {
		lp = &sp->lsis[i];
		if (*timep >= lp->ls_trans) {
			if (*timep == lp->ls_trans) {
				hit = ((i == 0 && lp->ls_corr > 0) ||
					lp->ls_corr > sp->lsis[i - 1].ls_corr);
				if (hit)
					while (i > 0 &&
						sp->lsis[i].ls_trans ==
						sp->lsis[i - 1].ls_trans + 1 &&
						sp->lsis[i].ls_corr ==
						sp->lsis[i - 1].ls_corr + 1) {
							++hit;
							--i;
					}
			}
			corr = lp->ls_corr;
			break;
		}
	}
	y = EPOCH_YEAR;
	tdays = (time_t)(*timep / SECSPERDAY);
	rem = (long) (*timep - tdays * SECSPERDAY);
	while (tdays < 0 || tdays >= year_lengths[isleap(y)]) {
		int		newy;
		time_t	tdelta;
		int	idelta;
		int	leapdays;

		tdelta = tdays / DAYSPERLYEAR;
		idelta = (int) tdelta;
		if (tdelta - idelta >= 1 || idelta - tdelta >= 1)
			return NULL;
		if (idelta == 0)
			idelta = (tdays < 0) ? -1 : 1;
		newy = y;
		if (increment_overflow(&newy, idelta))
			return NULL;
		leapdays = leaps_thru_end_of(newy - 1) -
			leaps_thru_end_of(y - 1);
		tdays -= ((time_t) newy - y) * DAYSPERNYEAR;
		tdays -= leapdays;
		y = newy;
	}
	{
		long	seconds;

		seconds = tdays * SECSPERDAY + 0.5;
		tdays = (time_t)(seconds / SECSPERDAY);
		rem += (long) (seconds - tdays * SECSPERDAY);
	}
	/*
	** Given the range, we can now fearlessly cast...
	*/
	idays = (int) tdays;
	rem += offset - corr;
	while (rem < 0) {
		rem += SECSPERDAY;
		--idays;
	}
	while (rem >= SECSPERDAY) {
		rem -= SECSPERDAY;
		++idays;
	}
	while (idays < 0) {
		if (increment_overflow(&y, -1))
			return NULL;
		idays += year_lengths[isleap(y)];
	}
	while (idays >= year_lengths[isleap(y)]) {
		idays -= year_lengths[isleap(y)];
		if (increment_overflow(&y, 1))
			return NULL;
	}
	tmp->tm_year = y;
	if (increment_overflow(&tmp->tm_year, -TM_YEAR_BASE))
		return NULL;
	tmp->tm_yday = idays;
	/*
	** The "extra" mods below avoid overflow problems.
	*/
	tmp->tm_wday = EPOCH_WDAY +
		((y - EPOCH_YEAR) % DAYSPERWEEK) *
		(DAYSPERNYEAR % DAYSPERWEEK) +
		leaps_thru_end_of(y - 1) -
		leaps_thru_end_of(EPOCH_YEAR - 1) +
		idays;
	tmp->tm_wday %= DAYSPERWEEK;
	if (tmp->tm_wday < 0)
		tmp->tm_wday += DAYSPERWEEK;
	tmp->tm_hour = (int) (rem / SECSPERHOUR);
	rem %= SECSPERHOUR;
	tmp->tm_min = (int) (rem / SECSPERMIN);
	/*
	** A positive leap second requires a special
	** representation. This uses "... ??:59:60" et seq.
	*/
	tmp->tm_sec = (int) (rem % SECSPERMIN) + hit;
	ip = mon_lengths[isleap(y)];
	for (tmp->tm_mon = 0; idays >= ip[tmp->tm_mon]; ++(tmp->tm_mon))
		idays -= ip[tmp->tm_mon];
	tmp->tm_mday = (int) (idays + 1);
	tmp->tm_isdst = 0;
#ifdef TM_GMTOFF
	if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
	  tmp->TM_GMTOFF = offset;
#endif /* defined TM_GMTOFF */
	return tmp;
}

extern "C" char *
ctime(const time_t *const timep)
{
/*
** Section 4.12.3.2 of X3.159-1989 requires that
**	The ctime function converts the calendar time pointed to by timer
**	to local time in the form of a string. It is equivalent to
**		asctime(localtime(timer))
*/
	struct tm *rtm = localtime(timep);
	if (rtm == NULL)
		return NULL;
	return asctime(rtm);
}

extern "C" char *
ctime_r(const time_t *const timep, char *buf)
{
	struct tm	mytm, *rtm;

	rtm = localtime_r(timep, &mytm);
	if (rtm == NULL)
		return NULL;
	return asctime_r(rtm, buf);
}

/*
** Adapted from code provided by Robert Elz, who writes:
**	The "best" way to do mktime I think is based on an idea of Bob
**	Kridle's (so its said...) from a long time ago.
**	It does a binary search of the time_t space. Since time_t's are
**	just 32 bits, its a max of 32 iterations (even at 64 bits it
**	would still be very reasonable).
*/

#ifndef WRONG
#define WRONG	((time_t)-1)
#endif /* !defined WRONG */

/*
** Simplified normalize logic courtesy Paul Eggert.
*/

static int
increment_overflow(int *const ip, int j)
{
	int	i = *ip;

	/*
	** If i >= 0 there can only be overflow if i + j > INT_MAX
	** or if j > INT_MAX - i; given i >= 0, INT_MAX - i cannot overflow.
	** If i < 0 there can only be overflow if i + j < INT_MIN
	** or if j < INT_MIN - i; given i < 0, INT_MIN - i cannot overflow.
	*/
	if ((i >= 0) ? (j > INT_MAX - i) : (j < INT_MIN - i))
		return TRUE;
	*ip += j;
	return FALSE;
}

static int
long_increment_overflow(long *const lp, int m)
{
	long l = *lp;

	if ((l >= 0) ? (m > LONG_MAX - l) : (m < LONG_MIN - l))
		return TRUE;
	*lp += m;
	return FALSE;
}

static int
normalize_overflow(int *const tensptr, int *const unitsptr, const int base)
{
	int	tensdelta;

	tensdelta = (*unitsptr >= 0) ?
		(*unitsptr / base) :
		(-1 - (-1 - *unitsptr) / base);
	*unitsptr -= tensdelta * base;
	return increment_overflow(tensptr, tensdelta);
}

static int
long_normalize_overflow(long *const tensptr, int *const unitsptr,
    const int base)
{
	int	tensdelta;

	tensdelta = (*unitsptr >= 0) ?
		(*unitsptr / base) :
		(-1 - (-1 - *unitsptr) / base);
	*unitsptr -= tensdelta * base;
	return long_increment_overflow(tensptr, tensdelta);
}

static int
tmcomp(const struct tm *const atmp, const struct tm *const btmp)
{
	int	result;

	if ((result = (atmp->tm_year - btmp->tm_year)) == 0 &&
		(result = (atmp->tm_mon - btmp->tm_mon)) == 0 &&
		(result = (atmp->tm_mday - btmp->tm_mday)) == 0 &&
		(result = (atmp->tm_hour - btmp->tm_hour)) == 0 &&
		(result = (atmp->tm_min - btmp->tm_min)) == 0)
			result = atmp->tm_sec - btmp->tm_sec;
	return result;
}

static time_t
time2sub(const timezone_t sp, struct tm *const tmp, subfun_t funcp,
    const long offset, int *const okayp, const int do_norm_secs)
{
	int			dir;
	int			i, j;
	int			saved_seconds;
	long			li;
	time_t			lo;
	time_t			hi;
#ifdef NO_ERROR_IN_DST_GAP
	time_t			ilo;
#endif
	long				y;
	time_t				newt;
	time_t				t;
	struct tm			yourtm, mytm;

	*okayp = FALSE;
	yourtm = *tmp;
#ifdef NO_ERROR_IN_DST_GAP
again:
#endif
	if (do_norm_secs) {
		if (normalize_overflow(&yourtm.tm_min, &yourtm.tm_sec,
		    SECSPERMIN))
			goto overflow;
	}
	if (normalize_overflow(&yourtm.tm_hour, &yourtm.tm_min, MINSPERHOUR))
		goto overflow;
	if (normalize_overflow(&yourtm.tm_mday, &yourtm.tm_hour, HOURSPERDAY))
		goto overflow;
	y = yourtm.tm_year;
	if (long_normalize_overflow(&y, &yourtm.tm_mon, MONSPERYEAR))
		goto overflow;
	/*
	** Turn y into an actual year number for now.
	** It is converted back to an offset from TM_YEAR_BASE later.
	*/
	if (long_increment_overflow(&y, TM_YEAR_BASE))
		goto overflow;
	while (yourtm.tm_mday <= 0) {
		if (long_increment_overflow(&y, -1))
			goto overflow;
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday += year_lengths[isleap(li)];
	}
	while (yourtm.tm_mday > DAYSPERLYEAR) {
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday -= year_lengths[isleap(li)];
		if (long_increment_overflow(&y, 1))
			goto overflow;
	}
	for ( ; ; ) {
		i = mon_lengths[isleap(y)][yourtm.tm_mon];
		if (yourtm.tm_mday <= i)
			break;
		yourtm.tm_mday -= i;
		if (++yourtm.tm_mon >= MONSPERYEAR) {
			yourtm.tm_mon = 0;
			if (long_increment_overflow(&y, 1))
				goto overflow;
		}
	}
	if (long_increment_overflow(&y, -TM_YEAR_BASE))
		goto overflow;
	yourtm.tm_year = (int)y;
	if (yourtm.tm_year != y)
		goto overflow;
	if (yourtm.tm_sec >= 0 && yourtm.tm_sec < SECSPERMIN)
		saved_seconds = 0;
	else if (y + TM_YEAR_BASE < EPOCH_YEAR) {
		/*
		** We can't set tm_sec to 0, because that might push the
		** time below the minimum representable time.
		** Set tm_sec to 59 instead.
		** This assumes that the minimum representable time is
		** not in the same minute that a leap second was deleted from,
		** which is a safer assumption than using 58 would be.
		*/
		if (increment_overflow(&yourtm.tm_sec, 1 - SECSPERMIN))
			goto overflow;
		saved_seconds = yourtm.tm_sec;
		yourtm.tm_sec = SECSPERMIN - 1;
	} else {
		saved_seconds = yourtm.tm_sec;
		yourtm.tm_sec = 0;
	}
	/*
	** Do a binary search (this works whatever time_t's type is).
	*/
	/* LINTED const not */
	if (!TYPE_SIGNED(time_t)) {
		lo = 0;
		hi = lo - 1;
	/* LINTED const not */
	} else {
		lo = 1;
		for (i = 0; i < (int) TYPE_BIT(time_t) - 1; ++i)
			lo *= 2;
		hi = -(lo + 1);
	}
#ifdef NO_ERROR_IN_DST_GAP
	ilo = lo;
#endif
	for ( ; ; ) {
		t = lo / 2 + hi / 2;
		if (t < lo)
			t = lo;
		else if (t > hi)
			t = hi;
		if ((*funcp)(sp, &t, offset, &mytm) == NULL) {
			/*
			** Assume that t is too extreme to be represented in
			** a struct tm; arrange things so that it is less
			** extreme on the next pass.
			*/
			dir = (t > 0) ? 1 : -1;
		} else	dir = tmcomp(&mytm, &yourtm);
		if (dir != 0) {
			if (t == lo) {
				++t;
				if (t <= lo)
					goto overflow;
				++lo;
			} else if (t == hi) {
				--t;
				if (t >= hi)
					goto overflow;
				--hi;
			}
#ifdef NO_ERROR_IN_DST_GAP
			if (ilo != lo && lo - 1 == hi && yourtm.tm_isdst < 0 &&
			    do_norm_secs) {
				for (i = sp->typecnt - 1; i >= 0; --i) {
					for (j = sp->typecnt - 1; j >= 0; --j) {
						time_t off;
						if (sp->ttis[j].tt_isdst ==
						    sp->ttis[i].tt_isdst)
							continue;
						off = sp->ttis[j].tt_gmtoff -
						    sp->ttis[i].tt_gmtoff;
						yourtm.tm_sec += off < 0 ?
						    -off : off;
						goto again;
					}
				}
			}
#endif
			if (lo > hi)
				goto invalid;
			if (dir > 0)
				hi = t;
			else	lo = t;
			continue;
		}
		if (yourtm.tm_isdst < 0 || mytm.tm_isdst == yourtm.tm_isdst)
			break;
		/*
		** Right time, wrong type.
		** Hunt for right time, right type.
		** It's okay to guess wrong since the guess
		** gets checked.
		*/
		if (sp == NULL)
			goto invalid;
		for (i = sp->typecnt - 1; i >= 0; --i) {
			if (sp->ttis[i].tt_isdst != yourtm.tm_isdst)
				continue;
			for (j = sp->typecnt - 1; j >= 0; --j) {
				if (sp->ttis[j].tt_isdst == yourtm.tm_isdst)
					continue;
				newt = (time_t)(t + sp->ttis[j].tt_gmtoff -
				    sp->ttis[i].tt_gmtoff);
				if ((*funcp)(sp, &newt, offset, &mytm) == NULL)
					continue;
				if (tmcomp(&mytm, &yourtm) != 0)
					continue;
				if (mytm.tm_isdst != yourtm.tm_isdst)
					continue;
				/*
				** We have a match.
				*/
				t = newt;
				goto label;
			}
		}
		goto invalid;
	}
label:
	newt = t + saved_seconds;
	if ((newt < t) != (saved_seconds < 0))
		goto overflow;
	t = newt;
	if ((*funcp)(sp, &t, offset, tmp)) {
		*okayp = TRUE;
		return t;
	}
overflow:
	errno = EOVERFLOW;
	return WRONG;
invalid:
	errno = EINVAL;
	return WRONG;
}

static time_t
time2(const timezone_t sp, struct tm *const tmp, subfun_t funcp,
    const long offset, int *const okayp)
{
	time_t	t;

	/*
	** First try without normalization of seconds
	** (in case tm_sec contains a value associated with a leap second).
	** If that fails, try with normalization of seconds.
	*/
	t = time2sub(sp, tmp, funcp, offset, okayp, FALSE);
	return *okayp ? t : time2sub(sp, tmp, funcp, offset, okayp, TRUE);
}

static time_t
time1(const timezone_t sp, struct tm *const tmp, subfun_t funcp,
    const long offset)
{
	time_t			t;
	int			samei, otheri;
	int			sameind, otherind;
	int			i;
	int			nseen;
	int				seen[TZ_MAX_TYPES];
	int				types[TZ_MAX_TYPES];
	int				okay;

	if (tmp == NULL) {
		errno = EINVAL;
		return WRONG;
	}
	if (tmp->tm_isdst > 1)
		tmp->tm_isdst = 1;
	t = time2(sp, tmp, funcp, offset, &okay);
#ifdef PCTS
	/*
	** PCTS code courtesy Grant Sullivan.
	*/
	if (okay)
		return t;
	if (tmp->tm_isdst < 0)
		tmp->tm_isdst = 0;	/* reset to std and try again */
#endif /* defined PCTS */
#ifndef PCTS
	if (okay || tmp->tm_isdst < 0)
		return t;
#endif /* !defined PCTS */
	/*
	** We're supposed to assume that somebody took a time of one type
	** and did some math on it that yielded a "struct tm" that's bad.
	** We try to divine the type they started from and adjust to the
	** type they need.
	*/
	if (sp == NULL) {
		errno = EINVAL;
		return WRONG;
	}
	for (i = 0; i < sp->typecnt; ++i)
		seen[i] = FALSE;
	nseen = 0;
	for (i = sp->timecnt - 1; i >= 0; --i)
		if (!seen[sp->types[i]]) {
			seen[sp->types[i]] = TRUE;
			types[nseen++] = sp->types[i];
		}
	for (sameind = 0; sameind < nseen; ++sameind) {
		samei = types[sameind];
		if (sp->ttis[samei].tt_isdst != tmp->tm_isdst)
			continue;
		for (otherind = 0; otherind < nseen; ++otherind) {
			otheri = types[otherind];
			if (sp->ttis[otheri].tt_isdst == tmp->tm_isdst)
				continue;
			tmp->tm_sec += (int)(sp->ttis[otheri].tt_gmtoff -
					sp->ttis[samei].tt_gmtoff);
			tmp->tm_isdst = !tmp->tm_isdst;
			t = time2(sp, tmp, funcp, offset, &okay);
			if (okay)
				return t;
			tmp->tm_sec -= (int)(sp->ttis[otheri].tt_gmtoff -
					sp->ttis[samei].tt_gmtoff);
			tmp->tm_isdst = !tmp->tm_isdst;
		}
	}
	errno = EOVERFLOW;
	return WRONG;
}

extern "C" time_t
mktime(struct tm *const tmp)
{
	time_t result;

	tzset_guard.init ("tzset_guard")->acquire ();
	tzset_unlocked();
	result = time1(lclptr, tmp, localsub, 0L);
	tzset_guard.release ();
	return result;
}

#ifdef STD_INSPIRED

extern "C" time_t
timelocal(struct tm *const tmp)
{
	if (tmp != NULL)
		tmp->tm_isdst = -1;	/* in case it wasn't initialized */
	return mktime(tmp);
}

extern "C" time_t
timegm(struct tm *const tmp)
{
	time_t t;

	if (tmp != NULL)
		tmp->tm_isdst = 0;
	t = time1(gmtptr, tmp, gmtsub, 0L);
	return t;
}

extern "C" time_t
timeoff(struct tm *const tmp, const long offset)
{
	time_t t;

	if (tmp != NULL)
		tmp->tm_isdst = 0;
	t = time1(gmtptr, tmp, gmtsub, offset);
	return t;
}

#endif /* defined STD_INSPIRED */

#ifdef CMUCS

/*
** The following is supplied for compatibility with
** previous versions of the CMUCS runtime library.
*/

extern "C" long
gtime(struct tm *const tmp)
{
	const time_t t = mktime(tmp);

	if (t == WRONG)
		return -1;
	return t;
}

#endif /* defined CMUCS */

/*
** XXX--is the below the right way to conditionalize??
*/

#ifdef STD_INSPIRED

/*
** IEEE Std 1003.1-1988 (POSIX) legislates that 536457599
** shall correspond to "Wed Dec 31 23:59:59 UTC 1986", which
** is not the case if we are accounting for leap seconds.
** So, we provide the following conversion routines for use
** when exchanging timestamps with POSIX conforming systems.
*/

static long
leapcorr(const timezone_t sp, time_t *timep)
{
	struct lsinfo * lp;
	int		i;

	i = sp->leapcnt;
	while (--i >= 0) {
		lp = &sp->lsis[i];
		if (*timep >= lp->ls_trans)
			return lp->ls_corr;
	}
	return 0;
}

extern "C" time_t
time2posix(time_t t)
{
	time_t result;
	tzset_guard.init ("tzset_guard")->acquire ();
	tzset_unlocked();
	result = t - leapcorr(lclptr, &t);
	tzset_guard.release ();
	return (result);
}

extern "C" time_t
posix2time(time_t t)
{
	time_t	x;
	time_t	y;

	tzset_guard.init ("tzset_guard")->acquire ();
	tzset_unlocked();
	/*
	** For a positive leap second hit, the result
	** is not unique. For a negative leap second
	** hit, the corresponding time doesn't exist,
	** so we return an adjacent second.
	*/
	x = (time_t)(t + leapcorr(lclptr, &t));
	y = (time_t)(x - leapcorr(lclptr, &x));
	if (y < t) {
		do {
			x++;
			y = (time_t)(x - leapcorr(lclptr, &x));
		} while (y < t);
		if (t != y) {
			return x - 1;
		}
	} else if (y > t) {
		do {
			--x;
			y = (time_t)(x - leapcorr(lclptr, &x));
		} while (y > t);
		if (t != y) {
			return x + 1;
		}
	}
	tzset_guard.release ();
	return x;
}

#endif /* defined STD_INSPIRED */

extern "C" long
__cygwin_gettzoffset (const struct tm *tmp)
{
#ifdef TM_GMTOFF
  if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
    return tmp->TM_GMTOFF;
#endif /* defined TM_GMTOFF */
  __tzinfo_type *tz = __gettzinfo ();
  /* The sign of this is exactly opposite the envvar TZ.  We
     could directly use the global _timezone for tm_isdst==0,
     but have to use __tzrule for daylight savings.  */
  long offset = -tz->__tzrule[tmp->tm_isdst > 0].offset;
  return offset;
}

extern "C" const char *
__cygwin_gettzname (const struct tm *tmp)
{
#ifdef TM_ZONE
  if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
    return tmp->TM_ZONE;
#endif
  return _tzname[tmp->tm_isdst > 0];
}
@


1.33
log
@	* localtime.cc (tzload): Fix loading latest timezone offsets into
	tzinfo from zoneinfo files.  Add comment to explain what we do.
	(tzparse): Add more comments to explain in case of loading timezone
	offset from other sources.
@
text
@d2561 25
@


1.32
log
@	* localtime.cc (tzload): Fix leaking memory (CID 60001).
@
text
@d903 3
d908 7
a914 4
	    __gettzinfo ()->__tzrule[0].offset
				    = -sp->ttis[1].tt_gmtoff;
	    __gettzinfo ()->__tzrule[1].offset
				    = -sp->ttis[0].tt_gmtoff;
d1364 3
d1459 3
d1478 3
@


1.31
log
@	* localtime.cc: Define TM_GMTOFF and TM_ZONE based on __TM_GMTOFF and
	__TM_ZONE being defined.  Throughout, write to these struct tm members
	only if CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS is true.
	* libc/strptime.cc: Ditto.
	* include/cygwin/version.h (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS):
	Define.
	(CYGWIN_VERSION_API_MINOR): Bump to 272.
@
text
@d701 1
a701 1
		      return -1;
@


1.30
log
@	Throughout, keep function definitions and declarations in sync with
	newlib in terms of C99 "restrict" keyword.
@
text
@d347 7
d1750 2
a1751 1
	tmp->TM_ZONE = &sp->chars[ttisp->tt_abbrind];
d1804 10
a1813 7
	if (offset != 0)
		tmp->TM_ZONE = wildabbr;
	else {
		if (gmtptr == NULL)
			tmp->TM_ZONE = gmt;
		else	tmp->TM_ZONE = gmtptr->chars;
	}
d1992 2
a1993 1
	tmp->TM_GMTOFF = offset;
@


1.30.2.1
log
@* localtime.cc: Define TM_GMTOFF and TM_ZONE based on __TM_GMTOFF and __TM_ZONE
being defined.  Throughout, write to these struct tm members only if
CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS is true.
* libc/strptime.cc: Ditto.
* include/cygwin/version.h (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS): Define.
(CYGWIN_VERSION_API_MINOR): Bump to 272.
@
text
@a346 7
#ifdef __TM_GMTOFF
# define TM_GMTOFF __TM_GMTOFF
#endif
#ifdef __TM_ZONE
# define TM_ZONE __TM_ZONE
#endif

d1743 1
a1743 2
	if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
	  tmp->TM_ZONE = &sp->chars[ttisp->tt_abbrind];
d1796 7
a1802 10
	if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
	  {
	    if (offset != 0)
		    tmp->TM_ZONE = wildabbr;
	    else {
		    if (gmtptr == NULL)
			    tmp->TM_ZONE = gmt;
		    else	tmp->TM_ZONE = gmtptr->chars;
	    }
	  }
d1981 1
a1981 2
	if (CYGWIN_VERSION_CHECK_FOR_EXTRA_TM_MEMBERS)
	  tmp->TM_GMTOFF = offset;
@


1.30.2.2
log
@2014-07-14  Christopher Faylor  <me.cygwin2014@@cgf.cx>

	* sigproc.cc (send_sig): Fix bad format in diagnostic output.

2014-07-14  Yaakov Selkowitz  <yselkowitz@@cygwin.com>

	* thread.cc (pthread_mutex::pthread_mutex): Change default type
	to PTHREAD_MUTEX_NORMAL.
	(pthread_mutex::unlock): Return EPERM if the mutex has no owner and
	the mutex type is PTHREAD_MUTEX_ERRORCHECK, as on Linux.
	(pthread_mutexattr::pthread_mutexattr): Ditto.
	(pthread_mutex_unlock): Do not fail if mutex is a normal mutex
	initializer.
	* include/pthread.h (PTHREAD_MUTEX_INITIALIZER): Redefine as
	PTHREAD_NORMAL_MUTEX_INITIALIZER_NP.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread::create): Use PTHREAD_DEFAULT_STACKSIZE stacksize
	if attr.stacksize is 0.
	(pthread_attr::pthread_attr): Initialize stacksize to 0 to align more
	closely to Linux.
	(pthread_attr_getstack): Fix incorrect stackaddr computation.  Return
	stackaddr just like pthread_attr_getstackaddr.  Remove slightly off
	comment.
	(pthread_attr_getstackaddr): Remove slightly off comment.
	(pthread_getattr_np): Return stackaddr and stacksize based on the full
	allocated stackarea.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Rephrase comment.

2014-07-09  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Fix typo in comment.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* exceptions.cc (exception::myfault_handle): Disable handling
	STATUS_STACK_OVERFLOW.  Explain why.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::send_internal): Improve loop to
	write streams in chunks of wmem() bytes to raise performance when
	writing small buffers.  Rename variables and add comments to help
	understanding the code in years to come.

2014-07-07  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/minires.c (minires_dprintf): Change "Minires" to "Resolv" to
	differ from external minres lib.
	(res_nquerydomain): Fix off-by-one in domain concatenation.  Add debug
	output.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* spawn.cc (find_exec): Initialize err (CID 60111).
	* strace.cc (strace::activate): Fix potential buffer overrun (CID 59938)
	* syscalls.cc (popen): Close parent pipe descriptor via fclosing fp on
	error to avoid resource leak (CID 59981).
	* thread.cc (pthread::exit): Avoid accessing cygtls member after
	deleting "this" (CID 60217).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* select.cc (start_thread_socket): Delete si on early return in case of
	an error (CID 59967).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* regex/regcomp.c (computematchjumps): Free local memory in case of
	error (CID 59975).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* mount.cc (fs_info::update): Define dir in the outermost scope to avoid
	accessing out-of-scope value (CID 60027).  Always initialize attr to
	upath (CID 60113).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* malloc_wrapper.cc (mallinfo): Initialize m if external malloc is used,
	too (CID 60120).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzload): Fix leaking memory (CID 60001).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* environ.cc (regopt): Allocate small local buffer to avoid copying
	twice.  Fixes resource leak (CID 60012).  Add comment.

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dll_init.cc (dll_list::alloc): Fix buffer overrun (CID 59940).

2014-06-23  Corinna Vinschen  <corinna@@vinschen.de>

	* dcrt0.cc (insert_file): Fix resource leaks (CIDs 59987, 59988).
@
text
@d701 1
a701 1
		      goto oops;
@


1.29
log
@	* Makefile.in (localtime_CFLAGS): Define as -fwrapv since localtime
	code requires int overflows to be fully defined.
	* localtime.cc: Align a bit more to upstream code.
@
text
@d1752 1
a1752 1
localtime_r(const time_t *timep, struct tm *tmp)
d1823 1
a1823 1
gmtime_r(const time_t * const timep, struct tm *tmp)
@


1.28
log
@	* Merge in cygwin-64bit-branch.
@
text
@d11 1
a11 1
** 1996-06-05 by Arthur David Olson (arthur_david_olson@@nih.gov).
d26 1
a26 1
static char	elsieid[] = "@@(#)localtime.c	7.66";
d31 2
a32 3
** Leap second handling from Bradley White (bww@@k.gp.cs.cmu.edu).
** POSIX-style TZ environment variable handling from Guy Harris
** (guy@@auspex.com).
d173 1
a173 1
** 1996-06-05 by Arthur David Olson (arthur_david_olson@@nih.gov).
d275 1
a275 1
#define TZ_MAX_TIMES	370
d285 1
a285 1
** as noted by Earl Chew <earl@@hpato.aus.hp.com>.
a342 22
#ifndef USG

/*
** Use of the underscored variants may cause problems if you move your code to
** certain System-V-based systems; for maximum portability, use the
** underscore-free variants.  The underscored variants are provided for
** backward compatibility only; they may disappear from future versions of
** this file.
*/

#define SECS_PER_MIN	SECSPERMIN
#define MINS_PER_HOUR	MINSPERHOUR
#define HOURS_PER_DAY	HOURSPERDAY
#define DAYS_PER_WEEK	DAYSPERWEEK
#define DAYS_PER_NYEAR	DAYSPERNYEAR
#define DAYS_PER_LYEAR	DAYSPERLYEAR
#define SECS_PER_HOUR	SECSPERHOUR
#define SECS_PER_DAY	SECSPERDAY
#define MONS_PER_YEAR	MONSPERYEAR

#endif /* !defined USG */

d497 1
a497 1
static long		leapcorr(time_t * timep);
d602 1
a602 1
		if (i == 0 || !ttisp->tt_isdst)
d606 1
a606 1
		if (i == 0 || ttisp->tt_isdst)
d1503 1
d1613 1
a1613 1
	if (lcl_is_set > 0 && strncmp(lcl_TZname, name, sizeof(lcl_TZname) - 1) == 0)
d1617 1
a1617 1
		strlcpy(lcl_TZname, name, sizeof (lcl_TZname));
d2471 1
a2471 1
leapcorr(time_t *timep)
a2472 1
	timezone_t	sp;
a2475 1
	sp = lclptr;
d2491 1
a2491 1
	result = t - leapcorr(&t);
d2510 2
a2511 2
	x = (time_t)(t + leapcorr(&t));
	y = (time_t)(x - leapcorr(&x));
d2515 1
a2515 1
			y = (time_t)(x - leapcorr(&x));
d2523 1
a2523 1
			y = (time_t)(x - leapcorr(&x));
@


1.27
log
@	* localtime.cc (tzload): Don't change global timezone information
	when called from gmtime or gmtime_r.
	(tzparse): Ditto.
@
text
@d1 8
d36 2
d46 1
a46 1
** 1996-06-05 by Arthur David Olson (arthur_david_olson@@nih.gov).
a67 37
** Defaults for preprocessor symbols.
** You can override these in your C compiler options, e.g. `-DHAVE_ADJTIME=0'.
*/

#ifndef HAVE_ADJTIME
#define HAVE_ADJTIME		1
#endif /* !defined HAVE_ADJTIME */

#ifndef HAVE_GETTEXT
#define HAVE_GETTEXT		0
#endif /* !defined HAVE_GETTEXT */

#ifndef HAVE_SETTIMEOFDAY
#define HAVE_SETTIMEOFDAY	3
#endif /* !defined HAVE_SETTIMEOFDAY */

#ifndef HAVE_STRERROR
#define HAVE_STRERROR		0
#endif /* !defined HAVE_STRERROR */

#ifndef HAVE_SYMLINK
#define HAVE_SYMLINK		1
#endif /* !defined HAVE_SYMLINK */

#ifndef HAVE_UNISTD_H
#define HAVE_UNISTD_H		1
#endif /* !defined HAVE_UNISTD_H */

#ifndef HAVE_UTMPX_H
#define HAVE_UTMPX_H		0
#endif /* !defined HAVE_UTMPX_H */

#ifndef LOCALE_HOME
#define LOCALE_HOME		"/usr/lib/locale"
#endif /* !defined LOCALE_HOME */

/*
a73 5

#if HAVE_GETTEXT - 0
#endif /* HAVE_GETTEXT - 0 */

#if HAVE_UNISTD_H - 0
a74 10
#endif /* HAVE_UNISTD_H - 0 */

#if !(HAVE_UNISTD_H - 0)
#ifndef F_OK
#define F_OK	0
#endif /* !defined F_OK */
#ifndef R_OK
#define R_OK	4
#endif /* !defined R_OK */
#endif /* !(HAVE_UNISTD_H - 0) */
d79 7
a85 3
/*
** Workarounds for compilers/systems.
*/
d88 1
a88 32
** SunOS 4.1.1 cc lacks const.
*/

#ifndef const
#ifndef __STDC__
#define const
#endif /* !defined __STDC__ */
#endif /* !defined const */

/*
** SunOS 4.1.1 cc lacks prototypes.
*/

#ifndef P
#ifdef __STDC__
#define P(x)	x
#endif /* defined __STDC__ */
#ifndef __STDC__
#define P(x)	()
#endif /* !defined __STDC__ */
#endif /* !defined P */

/*
** SunOS 4.1.1 headers lack EXIT_SUCCESS.
*/

#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS	0
#endif /* !defined EXIT_SUCCESS */

/*
** SunOS 4.1.1 headers lack EXIT_FAILURE.
d91 3
a93 36
#ifndef EXIT_FAILURE
#define EXIT_FAILURE	1
#endif /* !defined EXIT_FAILURE */

/*
** SunOS 4.1.1 headers lack FILENAME_MAX.
*/

#ifndef FILENAME_MAX

#ifndef MAXPATHLEN
#ifdef unix
#endif /* defined unix */
#endif /* !defined MAXPATHLEN */

#ifdef MAXPATHLEN
#define FILENAME_MAX	MAXPATHLEN
#endif /* defined MAXPATHLEN */
#ifndef MAXPATHLEN
#define FILENAME_MAX	1024		/* Pure guesswork */
#endif /* !defined MAXPATHLEN */

#endif /* !defined FILENAME_MAX */

/*
** SunOS 4.1.1 libraries lack remove.
*/

#ifndef remove
extern int	unlink P((const char * filename));
#define remove	unlink
#endif /* !defined remove */

/*
** Finally, some convenience items.
*/
d138 8
d147 1
a147 3
** For the benefit of GNU folk...
** `_(MSGID)' uses the current locale's message library string for MSGID.
** The default is to use gettext if available, and use MSGID otherwise.
d150 3
a152 7
#ifndef _
#if HAVE_GETTEXT - 0
#define _(msgid) gettext(msgid)
#else /* !(HAVE_GETTEXT - 0) */
#define _(msgid) msgid
#endif /* !(HAVE_GETTEXT - 0) */
#endif /* !defined _ */
d154 7
a160 3
#ifndef TZ_DOMAIN
#define TZ_DOMAIN "tz"
#endif /* !defined TZ_DOMAIN */
d219 2
a220 1
	char	tzh_reserved[16];	/* reserved for future use */
d242 2
a243 2
**	tzh_ttisstdcnt (char)s		indexed by type; if true, transition
**					time is standard time, if false,
d247 2
a248 2
**	tzh_ttisgmtcnt (char)s		indexed by type; if true, transition
**					time is UTC, if false,
d255 10
d395 1
a395 1
** WILDABBR is used.  Another possibility:  initialize tzname[0] to the
d397 1
a397 1
** And another:  initialize tzname[0] to "ERA", with an explanation in the
d404 3
a406 1
static char wildabbr[] NO_COPY = WILDABBR;
d408 10
a417 1
static char gmt[] NO_COPY = "GMT";
d423 2
a424 2
	int		tt_ttisstd;	/* true if transition is std time */
	int		tt_ttisgmt;	/* true if transition is UTC */
d441 1
a441 1
struct state {
d446 2
d451 2
a452 2
	char		chars[BIGGEST(BIGGEST(TZ_MAX_CHARS + 1, sizeof gmt),
				(2 * (MY_TZNAME_MAX + 1)))];
d456 2
d470 3
d477 47
a523 49
static long		detzcode P((const char * codep));
static const char *	getzname P((const char * strp));
static const char *	getnum P((const char * strp, int * nump, int min,
				int max));
static const char *	getsecs P((const char * strp, long * secsp));
static const char *	getoffset P((const char * strp, long * offsetp));
static const char *	getrule P((const char * strp, struct rule * rulep));
static void		gmtload P((struct state * sp));
static void		gmtsub P((const time_t * timep, long offset,
				struct tm * tmp));
static void		localsub P((const time_t * timep, long offset,
				struct tm * tmp));
static int		increment_overflow P((int * number, int delta));
static int		normalize_overflow P((int * tensptr, int * unitsptr,
				int base));
static void		settzname P((void));
static time_t		time1 P((struct tm * tmp,
				void(*funcp) P((const time_t *,
				long, struct tm *)),
				long offset));
static time_t		time2 P((struct tm *tmp,
				void(*funcp) P((const time_t *,
				long, struct tm*)),
				long offset, int * okayp));
static time_t		time2sub P((struct tm *tmp,
				void(*funcp) P((const time_t *,
				long, struct tm*)),
				long offset, int * okayp, int do_norm_secs));
static void		timesub P((const time_t * timep, long offset,
				const struct state * sp, struct tm * tmp));
static int		tmcomp P((const struct tm * atmp,
				const struct tm * btmp));
static time_t		transtime P((time_t janfirst, int year,
				const struct rule * rulep, long offset));
static int		tzload P((const char * name, struct state * sp));
static int		tzparse P((const char * name, struct state * sp,
				int lastditch));

#ifdef ALL_STATE
static struct state *	lclptr;
static struct state *	gmtptr;
#endif /* defined ALL_STATE */

#ifndef ALL_STATE
static struct state	lclmem;
static struct state	gmtmem;
#define lclptr		(&lclmem)
#define gmtptr		(&gmtmem)
#endif /* State Farm */
d543 2
a544 2
	wildabbr,
	wildabbr
d552 1
a552 1
** Thanks to Paul Eggert (eggert@@twinsun.com) for noting this.
a556 1

d566 2
a567 2
long		timezone;	/* was time_t but POSIX requires long. */
int		daylight;
d571 1
a571 1
time_t		altzone;
d575 1
a575 1
detzcode(const char *codep)
d577 2
a578 2
	register long	result;
	register int	i;
d580 1
a580 1
	result = (codep[0] & 0x80) ? ~0L : 0L;
d586 12
d599 1
a599 1
settzname P((void))
d601 2
a602 2
	register struct state * const	sp = lclptr;
	register int			i;
d604 2
a605 2
	tzname[0] = wildabbr;
	tzname[1] = wildabbr;
a612 1
#ifdef ALL_STATE
d614 1
a614 1
		tzname[0] = tzname[1] = gmt;
a616 1
#endif /* defined ALL_STATE */
d618 1
a618 1
		register const struct ttinfo * const	ttisp = &sp->ttis[i];
d637 1
a637 3
		register const struct ttinfo * const	ttisp =
							&sp->ttis[
								sp->types[i]];
d647 1
a647 1
tzload(const char *name, struct state *sp)
d649 21
a669 3
	register const char *	p;
	register int		i;
	register int		fid;
d672 5
d678 1
a678 1
		return -1;
d680 1
a680 1
		register int	doaccess;
d695 1
a695 1
				return -1;
d697 4
a700 4
				return -1;
			strcpy(fullname, p);
			strcat(fullname, "/");
			strcat(fullname, name);
d705 1
a705 1
				doaccess = true;
d708 2
a709 5
#if 0
		if (doaccess && access(name, R_OK) != 0)
			return -1;
#endif
		if ((fid = open(name, OPEN_MODE)) == -1)
d723 12
a734 6
	{
		struct tzhead *	tzhp;
		union {
		  struct tzhead tzhead;
		  char		buf[sizeof *sp + sizeof *tzhp];
		} u;
d738 7
a744 18
		if (fid == -2)
		  {
		    memcpy(u.buf, _posixrules_data, sizeof (_posixrules_data));
		    i = sizeof (_posixrules_data);
		  }
		else
		  {
		    i = read(fid, u.buf, sizeof u.buf);
		    if (close(fid) != 0)
			return -1;
		  }
		ttisstdcnt = (int) detzcode(u.tzhead.tzh_ttisgmtcnt);
		ttisgmtcnt = (int) detzcode(u.tzhead.tzh_ttisstdcnt);
		sp->leapcnt = (int) detzcode(u.tzhead.tzh_leapcnt);
		sp->timecnt = (int) detzcode(u.tzhead.tzh_timecnt);
		sp->typecnt = (int) detzcode(u.tzhead.tzh_typecnt);
		sp->charcnt = (int) detzcode(u.tzhead.tzh_charcnt);
		p = u.tzhead.tzh_charcnt + sizeof u.tzhead.tzh_charcnt;
d751 3
a753 2
				return -1;
		if (i - (p - u.buf) < sp->timecnt * 4 +	/* ats */
d755 1
a755 1
			sp->typecnt * (4 + 2) +		/* ttinfos */
d757 1
a757 1
			sp->leapcnt * (4 + 4) +		/* lsinfos */
d760 1
a760 1
				return -1;
d762 3
a764 2
			sp->ats[i] = detzcode(p);
			p += 4;
d769 1
a769 1
				return -1;
d772 1
a772 1
			register struct ttinfo *	ttisp;
d779 1
a779 1
				return -1;
d783 1
a783 1
					return -1;
d789 1
a789 1
			register struct lsinfo *	lsisp;
d792 3
a794 2
			lsisp->ls_trans = detzcode(p);
			p += 4;
d799 1
a799 1
			register struct ttinfo *	ttisp;
d803 1
a803 1
				ttisp->tt_ttisstd = false;
d806 3
a808 3
				if (ttisp->tt_ttisstd != true &&
					ttisp->tt_ttisstd != false)
						return -1;
d812 1
a812 1
			register struct ttinfo *	ttisp;
d816 1
a816 1
				ttisp->tt_ttisgmt = false;
d819 81
a899 3
				if (ttisp->tt_ttisgmt != true &&
					ttisp->tt_ttisgmt != false)
						return -1;
d901 15
d918 1
d927 25
d965 1
a965 1
** a valid character in a zone name is found.  Return a pointer to that
d972 1
a972 1
	register char	c;
d981 19
d1007 1
a1007 1
getnum(const char *strp, int *nump, const int min, const int max)
d1009 2
a1010 2
	register char	c;
	register int	num;
d1012 2
a1013 1
	if (strp == NULL || !is_digit(c = *strp))
d1015 1
d1019 2
a1020 1
		if (num > max)
d1022 1
d1025 2
a1026 1
	if (num < min)
d1028 1
d1042 1
a1042 1
getsecs(const char *strp, long *secsp)
d1064 1
a1064 1
			/* `SECSPERMIN' allows for leap seconds.  */
d1082 1
a1082 1
getoffset(const char *strp, long *offsetp)
d1084 1
a1084 1
	register int	neg = 0;
d1101 1
a1101 1
** date[/time].  See POSIX section 8 for the format of "date" and "time".
d1107 1
a1107 1
getrule(const char *strp, struct rule *rulep)
d1159 2
a1160 2
transtime(const time_t janfirst, const int year, const struct rule *rulep,
		long offset)
d1162 3
a1164 3
	register int	leapyear;
	register time_t	value;
	register int	i;
d1179 1
a1179 1
		value = janfirst + (rulep->r_day - 1) * SECSPERDAY;
d1190 1
a1190 1
		value = janfirst + rulep->r_day * SECSPERDAY;
d1199 1
a1199 1
			value += mon_lengths[leapyear][i] * SECSPERDAY;
d1215 1
a1215 1
		** "dow" is the day-of-week of the first day of the month.  Get
d1232 1
a1232 1
		value += d * SECSPERDAY;
d1238 1
a1238 1
	** question.  To get the Epoch-relative time of the specified local
d1242 1
a1242 1
	return value + rulep->r_time + offset;
d1251 1
a1251 1
tzparse(const char *name, struct state *sp, const int lastditch)
d1259 4
a1262 4
	register time_t *		atp;
	register unsigned char *	typep;
	register char *			cp;
	register int			load_result;
d1273 12
a1284 4
		name = getzname(name);
		stdlen = name - stdname;
		if (stdlen < 3)
			return -1;
d1291 1
a1291 1
	load_result = tzload(TZDEFRULES, sp);
d1295 12
a1306 5
		dstname = name;
		name = getzname(name);
		dstlen = name - dstname;	/* length of DST zone name */
		if (dstlen < 3)
			return -1;
d1312 2
d1317 2
a1318 2
			register int	year;
			register time_t	janfirst;
d1333 1
a1333 1
			** Two transitions per year, from EPOCH_YEAR to 2037.
d1335 1
a1335 3
			sp->timecnt = 2 * (2037 - EPOCH_YEAR + 1);
			if (sp->timecnt > TZ_MAX_TIMES)
				return -1;
d1338 1
a1338 1
			sp->ttis[0].tt_abbrind = stdlen + 1;
d1345 6
a1350 1
			for (year = EPOCH_YEAR; year <= 2037; ++year) {
d1366 7
a1372 2
				janfirst += year_lengths[isleap(year)] *
					SECSPERDAY;
d1382 6
a1387 6
			register long	theirstdoffset;
			register long	theirdstoffset;
			register long	theiroffset;
			register int	isdst;
			register int	i;
			register int	j;
a1390 2
			if (load_result != 0)
				return -1;
d1415 1
a1415 1
			isdst = false;
d1442 2
a1443 2
						sp->ats[i] += dstoffset -
							theirdstoffset;
d1445 2
a1446 2
						sp->ats[i] += stdoffset -
							theirstdoffset;
d1450 3
a1452 3
				if (sp->ttis[j].tt_isdst)
					theirdstoffset = theiroffset;
				else	theirstdoffset = theiroffset;
d1456 1
a1456 1
			** ttisstd and ttisgmt need not be handled.
d1458 1
d1460 1
a1460 1
			sp->ttis[0].tt_isdst = false;
d1463 2
a1464 2
			sp->ttis[1].tt_isdst = true;
			sp->ttis[1].tt_abbrind = stdlen + 1;
d1478 1
d1488 1
a1488 1
	sp->charcnt = stdlen + 1;
d1490 1
a1490 1
		sp->charcnt += dstlen + 1;
d1494 1
a1494 1
	strncpy(cp, stdname, stdlen);
d1498 1
a1498 1
		strncpy(cp, dstname, dstlen);
d1505 1
a1505 1
gmtload(struct state *sp)
d1507 2
a1508 2
	if (tzload(gmt, sp) != 0)
		tzparse(gmt, sp, true);
d1519 1
a1519 1
tzsetwall P((void))
a1524 1
#ifdef ALL_STATE
d1526 1
a1526 1
		lclptr = (struct state *) malloc(sizeof *lclptr);
a1531 1
#endif /* defined ALL_STATE */
d1596 1
a1596 1
	    if (tzparse(buf, lclptr, false) == 0) {
d1609 1
a1609 1
	if (tzload((char *) NULL, lclptr) != 0)
d1616 9
a1624 2
extern "C" void
tzset P((void))
d1626 1
a1626 2
	tzset_guard.init ("tzset_guard")->acquire ();
	const char *	name = getenv("TZ");
d1628 1
d1632 1
a1632 1
		goto out;
d1636 1
a1636 1
		goto out;
a1640 1
#ifdef ALL_STATE
d1642 2
a1643 1
		lclptr = (struct state *) malloc(sizeof *lclptr);
d1646 1
a1646 1
			goto out;
a1648 1
#endif /* defined ALL_STATE */
d1655 2
d1659 4
a1662 5
		strcpy(lclptr->chars, gmt);
	} else if (tzload(name, lclptr) != 0) {
		if (name[0] == ':' || tzparse(name, lclptr, false) != 0)
			gmtload(lclptr);
	}
d1664 7
a1670 1
out:
d1677 1
a1677 1
** freely called.  (And no, the PANS doesn't require the above behavior--
d1684 7
a1690 8
static void
localsub (const time_t * const	timep,
	  const long offset,
	  struct tm * const tmp)
{
	register struct state *		sp;
	register const struct ttinfo *	ttisp;
	register int			i;
d1693 39
a1731 5
	sp = lclptr;
#ifdef ALL_STATE
	if (sp == NULL) {
		gmtsub(timep, offset, tmp);
		return;
a1732 1
#endif /* defined ALL_STATE */
d1741 11
a1751 4
		for (i = 1; i < sp->timecnt; ++i)
			if (t < sp->ats[i])
				break;
		i = sp->types[i - 1];
d1760 1
a1760 1
	timesub(&t, ttisp->tt_gmtoff, sp, tmp);
d1762 2
a1763 1
	tzname[tmp->tm_isdst] = &sp->chars[ttisp->tt_abbrind];
d1767 1
d1770 3
d1774 1
a1774 1
localtime(const time_t *timep)
d1776 7
a1782 3
	tzset();
	localsub(timep, 0L, &tm);
	return &tm;
a1784 3
/*
 * Re-entrant version of localtime
 */
d1786 1
a1786 1
localtime_r(const time_t *timep, struct tm *tm)
d1788 1
a1788 3
	tzset();
	localsub(timep, 0L, tm);
	return tm;
d1794 1
d1796 3
a1798 2
static void
gmtsub(const time_t *timep, const long offset, struct tm *tmp)
d1800 3
d1804 3
a1806 3
		gmt_is_set = true;
#ifdef ALL_STATE
		gmtptr = (struct state *) malloc(sizeof *gmtptr);
a1807 1
#endif /* defined ALL_STATE */
d1810 2
a1811 1
	timesub(timep, offset, gmtptr, tmp);
a1820 1
#ifdef ALL_STATE
a1823 4
#endif /* defined ALL_STATE */
#ifndef ALL_STATE
		tmp->TM_ZONE = gmtptr->chars;
#endif /* State Farm */
d1826 1
d1830 1
a1830 1
gmtime(const time_t *timep)
d1832 6
a1837 2
	gmtsub(timep, 0L, &tm);
	return &tm;
d1841 3
a1843 2
 * Re-entrant version of gmtime
 */
d1845 1
a1845 1
gmtime_r(const time_t *timep, struct tm *tm)
d1847 6
a1852 2
	gmtsub(timep, 0L, tm);
	return tm;
d1858 1
a1858 1
offtime(const time_t *timep, const long offset)
d1860 6
a1865 2
	gmtsub(timep, offset, &tm);
	return &tm;
d1870 7
a1876 3
static void
timesub(const time_t *timep, const long offset, const struct state *sp,
	struct tm *tmp)
d1878 17
a1894 9
	register const struct lsinfo *	lp;
	register long			days;
	register long			rem;
	register int			y;
	register int			yleap;
	register const int *		ip;
	register long			corr;
	register int			hit;
	register int			i;
a1897 1
#ifdef ALL_STATE
a1898 4
#endif /* defined ALL_STATE */
#ifndef ALL_STATE
	i = sp->leapcnt;
#endif /* State Farm */
d1919 30
a1948 9
	days = *timep / SECSPERDAY;
	rem = *timep % SECSPERDAY;
#ifdef mc68k
	if (*timep == 0x80000000) {
		/*
		** A 3B1 muffs the division on the most negative number.
		*/
		days = -24855;
		rem = -11648;
d1950 5
a1954 2
#endif /* defined mc68k */
	rem += (offset - corr);
d1957 1
a1957 1
		--days;
d1961 11
a1971 1
		++days;
d1973 16
d1990 1
a1990 1
	rem = rem % SECSPERHOUR;
d1994 1
a1994 1
	** representation.  This uses "... ??:59:60" et seq.
d1997 4
a2000 22
	tmp->tm_wday = (int) ((EPOCH_WDAY + days) % DAYSPERWEEK);
	if (tmp->tm_wday < 0)
		tmp->tm_wday += DAYSPERWEEK;
	y = EPOCH_YEAR;
#define LEAPS_THRU_END_OF(y)	((y) / 4 - (y) / 100 + (y) / 400)
	while (days < 0 || days >= (long) year_lengths[yleap = isleap(y)]) {
		register int	newy;

		newy = y + days / DAYSPERNYEAR;
		if (days < 0)
			--newy;
		days -= (newy - y) * DAYSPERNYEAR +
			LEAPS_THRU_END_OF(newy - 1) -
			LEAPS_THRU_END_OF(y - 1);
		y = newy;
	}
	tmp->tm_year = y - TM_YEAR_BASE;
	tmp->tm_yday = (int) days;
	ip = mon_lengths[yleap];
	for (tmp->tm_mon = 0; days >= (long) ip[tmp->tm_mon]; ++(tmp->tm_mon))
		days = days - (long) ip[tmp->tm_mon];
	tmp->tm_mday = (int) (days + 1);
d2005 1
d2009 1
a2009 1
ctime(const time_t *timep)
d2014 1
a2014 1
**	to local time in the form of a string.  It is equivalent to
d2017 4
a2020 1
	return asctime(localtime(timep));
d2024 1
a2024 1
ctime_r(const time_t *timep, char *buf)
d2026 1
a2026 1
	struct tm	tm;
d2028 4
a2031 1
	return asctime_r(localtime_r(timep, &tm), buf);
d2038 1
a2038 2
**	[kridle@@xinet.com as of 1996-01-16.]
**	It does a binary search of the time_t space.  Since time_t's are
d2044 1
a2044 1
#define WRONG	(-1)
d2048 1
a2048 1
** Simplified normalize logic courtesy Paul Eggert (eggert@@twinsun.com).
d2051 19
a2069 3
/* Mark as noinline to prevent a compiler warning. */
static int __attribute__((noinline))
increment_overflow(int *number, int delta)
d2071 1
a2071 1
	int	number0;
d2073 4
a2076 3
	number0 = *number;
	*number += delta;
	return (*number < number0) != (delta < 0);
d2080 1
a2080 1
normalize_overflow(int *tensptr, int *unitsptr, const int base)
d2082 1
a2082 1
	register int	tensdelta;
d2092 14
a2105 1
tmcomp(register const struct tm *atmp, register const struct tm *btmp)
d2107 1
a2107 1
	register int	result;
d2119 2
a2120 2
time2sub(struct tm *tmp, void (*funcp) P((const time_t*, long, struct tm*)),
	 const long offset, int *okayp, const int do_norm_secs)
d2122 10
a2131 5
	register const struct state *	sp;
	register int			dir;
	register int			bits;
	register int			i, j ;
	register int			saved_seconds;
d2136 1
a2136 1
	*okayp = false;
d2138 3
d2143 2
a2144 2
			SECSPERMIN))
				return WRONG;
d2147 1
a2147 1
		return WRONG;
d2149 4
a2152 3
		return WRONG;
	if (normalize_overflow(&yourtm.tm_year, &yourtm.tm_mon, MONSPERYEAR))
		return WRONG;
d2154 1
a2154 1
	** Turn yourtm.tm_year into an actual year number for now.
d2157 2
a2158 2
	if (increment_overflow(&yourtm.tm_year, TM_YEAR_BASE))
		return WRONG;
d2160 4
a2163 4
		if (increment_overflow(&yourtm.tm_year, -1))
			return WRONG;
		i = yourtm.tm_year + (1 < yourtm.tm_mon);
		yourtm.tm_mday += year_lengths[isleap(i)];
d2166 4
a2169 4
		i = yourtm.tm_year + (1 < yourtm.tm_mon);
		yourtm.tm_mday -= year_lengths[isleap(i)];
		if (increment_overflow(&yourtm.tm_year, 1))
			return WRONG;
d2172 1
a2172 1
		i = mon_lengths[isleap(yourtm.tm_year)][yourtm.tm_mon];
d2178 2
a2179 2
			if (increment_overflow(&yourtm.tm_year, 1))
				return WRONG;
d2182 8
a2189 3
	if (increment_overflow(&yourtm.tm_year, -TM_YEAR_BASE))
		return WRONG;
	if (yourtm.tm_year + TM_YEAR_BASE < EPOCH_YEAR) {
d2199 1
a2199 1
			return WRONG;
d2207 1
a2207 2
	** Divide the search space in half
	** (this works whether time_t is signed or unsigned).
d2209 14
a2222 7
	bits = TYPE_BIT(time_t) - 1;
	/*
	** If time_t is signed, then 0 is just above the median,
	** assuming two's complement arithmetic.
	** If time_t is unsigned, then (1 << bits) is just above the median.
	*/
	t = TYPE_SIGNED(time_t) ? 0 : (((time_t) 1) << bits);
d2224 13
a2236 2
		(*funcp)(&t, offset, &mytm);
		dir = tmcomp(&mytm, &yourtm);
d2238 34
a2271 7
			if (bits-- < 0)
				return WRONG;
			if (bits < 0)
				--t; /* may be needed if new t is minimal */
			else if (dir > 0)
				t -= ((time_t) 1) << bits;
			else	t += ((time_t) 1) << bits;
a2281 7
		/*
		** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
		*/
		sp = (const struct state *)
			(((void *) funcp == (void *) localsub) ?
			lclptr : gmtptr);
#ifdef ALL_STATE
d2283 1
a2283 2
			return WRONG;
#endif /* defined ALL_STATE */
d2290 4
a2293 3
				newt = t + sp->ttis[j].tt_gmtoff -
					sp->ttis[i].tt_gmtoff;
				(*funcp)(&newt, offset, &mytm);
d2305 1
a2305 1
		return WRONG;
d2310 1
a2310 1
		return WRONG;
d2312 10
a2321 3
	(*funcp)(&t, offset, tmp);
	*okayp = true;
	return t;
d2325 2
a2326 2
time2(struct tm *tmp, void (*funcp) P((const time_t*, long, struct tm*)),
      const long offset, int *okayp)
d2335 2
a2336 23
	t = time2sub(tmp, funcp, offset, okayp, false);
	if (*okayp)
	  return t;
	t = time2sub(tmp, funcp, offset, okayp, true);
	if (*okayp)
	  return t;
	/* Workaround for the spring forward gap problem which results in
	   the autoconf mktime usability test failing.
	   What we do here is this:  The gap has 3600 seconds.  If we
	   subtract 3600 from the tm_sec value and get a valid result,
	   then we can simply add 3600 to the return value and are done.
	   If the result is still not valid, the problem is not the
	   spring forward gap and we can give up. */
	struct tm tmp2 = *tmp;
	tmp2.tm_sec -= 3600;
	t = time2sub(&tmp2, funcp, offset, okayp, true);
	if (*okayp)
	  {
	    if (t + 3600 < 0)	/* Sanity check */
	      return WRONG;
	    return t + 3600;
	  }
	return t;
d2340 2
a2341 2
time1(struct tm *tmp, void (*funcp) P((const time_t *, long, struct tm *)),
      const long offset)
d2343 7
a2349 3
	register time_t			t;
	register const struct state *	sp;
	register int			samei, otheri;
d2352 4
d2358 1
a2358 1
	t = time2(tmp, funcp, offset, &okay);
d2361 1
a2361 1
	** PCTS code courtesy Grant Sullivan (grant@@osf.org).
d2378 2
a2379 7
	/*
	** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
	*/
	sp = (const struct state *) (((void *) funcp == (void *) localsub) ?
		lclptr : gmtptr);
#ifdef ALL_STATE
	if (sp == NULL)
d2381 11
a2391 2
#endif /* defined ALL_STATE */
	for (samei = sp->typecnt - 1; samei >= 0; --samei) {
d2394 2
a2395 1
		for (otheri = sp->typecnt - 1; otheri >= 0; --otheri) {
d2398 2
a2399 2
			tmp->tm_sec += sp->ttis[otheri].tt_gmtoff -
					sp->ttis[samei].tt_gmtoff;
d2401 1
a2401 1
			t = time2(tmp, funcp, offset, &okay);
d2404 2
a2405 2
			tmp->tm_sec -= sp->ttis[otheri].tt_gmtoff -
					sp->ttis[samei].tt_gmtoff;
d2409 1
d2414 1
a2414 1
mktime(struct tm *tmp)
d2416 7
a2422 2
	tzset();
	return time1(tmp, localsub, 0L);
d2428 1
a2428 1
timelocal(struct tm *tmp)
d2430 2
a2431 1
	tmp->tm_isdst = -1;	/* in case it wasn't initialized */
d2436 1
a2436 1
timegm(struct tm *tmp)
d2438 6
a2443 2
	tmp->tm_isdst = 0;
	return time1(tmp, gmtsub, 0L);
d2447 1
a2447 1
timeoff(struct tm *tmp, const long offset)
d2449 6
a2454 2
	tmp->tm_isdst = 0;
	return time1(tmp, gmtsub, offset);
d2467 1
a2467 1
gtime(struct tm *tmp)
d2469 1
a2469 1
	const time_t	t = mktime(tmp);
d2495 3
a2497 3
	register struct state *		sp;
	register struct lsinfo *	lp;
	register int			i;
d2512 6
a2517 2
	tzset();
	return t - leapcorr(&t);
d2526 2
a2527 1
	tzset();
d2530 1
a2530 1
	** is not unique.  For a negative leap second
d2534 2
a2535 2
	x = t + leapcorr(&t);
	y = x - leapcorr(&x);
d2539 1
a2539 1
			y = x - leapcorr(&x);
d2541 1
a2541 1
		if (t != y)
d2543 1
d2547 1
a2547 1
			y = x - leapcorr(&x);
d2549 1
a2549 1
		if (t != y)
d2551 1
d2553 1
@


1.27.4.1
log
@	* cygwin.sc.in (.rdata): Add .rdata_cygwin_nocopy subsection.
	(.cygheap): Raise size to 3 Megs on x86_64.
	* dcrt0.cc (dll_crt0_0): Drop call to init_global_security.
	* dtable.cc (std_consts): Drop NO_COPY.
	* errno.cc (errmap): Drop NO_COPY, constify instead.
	(_sys_errlist): Drop NO_COPY.
	* fhandler_clipboard.cc (CYGWIN_NATIVE): Ditto.
	* fhandler_console.cc (keytable): Drop NO_COPY, constify instead.
	* grp.cc (null_ptr): Make NO_COPY_RO.
	* heap.cc (eval_start_address): Fix comment.
	* localtime.cc (wildabbr): Make NO_COPY_RO.
	(gmt): Ditto.
	* miscfuncs.cc (case_folded_lower): Drop NO_COPY.
	(case_folded_upper): Ditto.
	(isalpha_array): Ditto.
	(nice_to_winprio): Ditto for priority.
	(class thread_allocator): New class to allocate thread stack on x86_64.
	(thr_alloc): Define global NO_COPY instant of thread_allocator.
	(CygwinCreateThread): Call thr_alloc.alloc on x86_64 to reserve stack.
	* net.cc (errmap): Drop NO_COPY, constify instead.
	(host_errmap): Ditto.
	* netdb.cc (SPACE): Drop NO_COPY.
	* sec_helper.cc (null_sdp): Static NO_COPY_RO definition of null SD.
	(sec_none): Define NO_COPY_RO, define content statically.
	(sec_none_nih): Ditto.
	(sec_all): Ditto.
	(sec_all_nih): Ditto.
	(get_null_sd): Remove.
	(init_global_security): Remove.
	* security.cc (file_mapping): Define NO_COPY_RO.
	(check_registry_access): Ditto for reg_mapping.
	* spawn.cc (exe_suffixes): Drop NO_COPY, constify instead.
	(dll_suffixes): Drop unused, disabled definition and comment.
	* strsig.cc (sys_sigabbrev): Drop NO_COPY_INIT.
	(sys_siglist): Ditto.
	* syscalls.cc (def_shells): Drop NO_COPY.
	* winsup.h (NO_COPY_RO): Define to place variable in
	.rdata_cygwin_nocopy section.
	(init_global_security): Drop declaration.
@
text
@d489 1
a489 1
static char wildabbr[] NO_COPY_RO = WILDABBR;
d491 1
a491 1
static char gmt[] NO_COPY_RO = "GMT";
@


1.27.4.2
log
@	* localtime.cc: Throughout, pull up to latest code from NetBSD.
@
text
@a0 1
/*	$NetBSD: localtime.c,v 1.72 2012/10/28 19:02:29 christos Exp $	*/
a27 2
#define NO_ERROR_IN_DST_GAP

d36 1
a36 1
** 1996-06-05 by Arthur David Olson
d58 37
d101 5
d107 10
d121 71
a191 7
#ifndef __pure
#if 2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)
# define __pure __attribute__ ((__pure__))
#else
# define __pure /* empty */
#endif
#endif
a196 4
#ifndef TYPE_INTEGRAL
#define TYPE_INTEGRAL(type) (/*CONSTCOND*/((type) 0.5) != 0.5)
#endif /* !defined TYPE_INTEGRAL */

a239 8
#ifndef TZ_DOMAIN
#define TZ_DOMAIN "tz"
#endif /* !defined TZ_DOMAIN */

#ifndef YEARSPERREPEAT
#define YEARSPERREPEAT	  400     /* years before a Gregorian repeat */
#endif /* !defined YEARSPERREPEAT */

d241 3
a243 1
** The Gregorian year averages 365.2425 days, which is 31556952 seconds.
d246 7
a252 3
#ifndef AVGSECSPERYEAR
#define AVGSECSPERYEAR	  31556952L
#endif /* !defined AVGSECSPERYEAR */
d254 3
a256 7
#ifndef SECSPERREPEAT
#define SECSPERREPEAT	   ((int_fast64_t) YEARSPERREPEAT * (int_fast64_t) AVGSECSPERYEAR)
#endif /* !defined SECSPERREPEAT */

#ifndef SECSPERREPEAT_BITS
#define SECSPERREPEAT_BITS      34      /* ceil(log2(SECSPERREPEAT)) */
#endif /* !defined SECSPERREPEAT_BITS */
d315 1
a315 2
	char	tzh_version[1];		/* '\0' or '2' as of 2005 */
	char	tzh_reserved[15];	/* reserved for future use */
d337 2
a338 2
**	tzh_ttisstdcnt (char)s		indexed by type; if TRUE, transition
**					time is standard time, if FALSE,
d342 2
a343 2
**	tzh_ttisgmtcnt (char)s		indexed by type; if TRUE, transition
**					time is UTC, if FALSE,
a349 10
** If tzh_version is '2' or greater, the above is followed by a second instance
** of tzhead and a second instance of the data in which each coded transition
** time uses 8 rather than 4 chars,
** then a POSIX-TZ-environment-variable-style string for use in handling
** instants after the last transition time stored in the file
** (with nothing between the newlines if there is no POSIX representation for
** such instants).
*/

/*
d480 1
a480 1
** WILDABBR is used. Another possibility: initialize tzname[0] to the
d482 1
a482 1
** And another: initialize tzname[0] to "ERA", with an explanation in the
d489 1
a489 1
static const char	wildabbr[] = WILDABBR;
d491 1
a491 12
static const char	gmt[] = "GMT";

/*
** The DST rules to use if TZ has no rules and we can't load TZDEFRULES.
** We default to US rules as of 1999-08-17.
** POSIX 1003.1 section 8.1.1 says that the default DST rules are
** implementation dependent; for historical reasons, US rules are a
** common default.
*/
#ifndef TZDEFRULESTRING
#define TZDEFRULESTRING ",M4.1.0,M10.5.0"
#endif /* !defined TZDEFDST */
d497 2
a498 2
	int		tt_ttisstd;	/* TRUE if transition is std time */
	int		tt_ttisgmt;	/* TRUE if transition is UTC */
d515 1
a515 1
struct __state {
a519 2
	int		goback;
	int		goahead;
d523 2
a524 2
	char		chars[/*CONSTCOND*/BIGGEST(BIGGEST(TZ_MAX_CHARS + 1,
				sizeof gmt), (2 * (MY_TZNAME_MAX + 1)))];
a527 2
typedef struct __state *timezone_t;

a539 3
typedef struct tm *(*subfun_t)(const timezone_t sp, const time_t *timep,
			       long offset, struct tm *tmp);

d544 49
a592 47
static long		detzcode(const char * codep);
static time_t		detzcode64(const char * codep);
static int		differ_by_repeat(time_t t1, time_t t0);
static const char *	getzname(const char * strp) __pure;
static const char *	getqzname(const char * strp, const int delim) __pure;
static const char *	getnum(const char * strp, int * nump, int min,
				int max);
static const char *	getsecs(const char * strp, long * secsp);
static const char *	getoffset(const char * strp, long * offsetp);
static const char *	getrule(const char * strp, struct rule * rulep);
static void		gmtload(timezone_t sp);
static struct tm *	gmtsub(const timezone_t sp, const time_t *timep,
				long offset, struct tm * tmp);
static struct tm *	localsub(const timezone_t sp, const time_t *timep,
				long offset, struct tm *tmp);
static int		increment_overflow(int * number, int delta);
static int		leaps_thru_end_of(int y) __pure;
static int		long_increment_overflow(long * number, int delta);
static int		long_normalize_overflow(long * tensptr,
				int * unitsptr, int base);
static int		normalize_overflow(int * tensptr, int * unitsptr,
				int base);
static void		settzname(void);
static time_t		time1(const timezone_t sp, struct tm * const tmp,
				subfun_t funcp, const long offset);
static time_t		time2(const timezone_t sp, struct tm * const tmp,
				subfun_t funcp,
				const long offset, int *const okayp);
static time_t		time2sub(const timezone_t sp, struct tm * const tmp,
				subfun_t funcp, const long offset,
				int *const okayp, const int do_norm_secs);
static struct tm *	timesub(const timezone_t sp, const time_t * timep,
				long offset, struct tm * tmp);
static int		tmcomp(const struct tm * atmp,
				const struct tm * btmp);
static time_t		transtime(time_t janfirst, int year,
				const struct rule * rulep, long offset) __pure;
static int		typesequiv(const timezone_t sp, int a, int b);
static int		tzload(timezone_t sp, const char * name,
				int doextend);
static int		tzparse(timezone_t sp, const char * name,
				int lastditch);
static void		tzset_unlocked(void);
static long		leapcorr(time_t * timep);

static timezone_t lclptr;
static timezone_t gmtptr;
d612 2
a613 2
	(char *) wildabbr,
	(char *) wildabbr
d621 1
a621 1
** Thanks to Paul Eggert for noting this.
d626 1
d636 2
a637 2
long			timezone = 0;
int			daylight;
d641 1
a641 1
time_t			altzone = 0;
d645 1
a645 1
detzcode(const char *const codep)
d647 2
a648 2
	long	result;
	int	i;
d650 1
a650 1
	result = (codep[0] & 0x80) ? ~0L : 0;
a655 12
static time_t
detzcode64(const char *const codep)
{
	time_t	result;
	int	i;

	result = (time_t)((codep[0] & 0x80) ? (~(int_fast64_t) 0) : 0);
	for (i = 0; i < 8; ++i)
		result = result * 256 + (codep[i] & 0xff);
	return result;
}

d657 1
a657 1
settzname (void)
d659 2
a660 2
	timezone_t const	sp = lclptr;
	int			i;
d662 2
a663 2
	tzname[0] = (char *) wildabbr;
	tzname[1] = (char *) wildabbr;
d671 1
d673 1
a673 1
		tzname[0] = tzname[1] = (char *) gmt;
d676 1
d678 1
a678 1
		const struct ttinfo * const	ttisp = &sp->ttis[i];
d697 3
a699 1
		const struct ttinfo *const ttisp = &sp->ttis[sp->types[i]];
d709 1
a709 10
differ_by_repeat(const time_t t1, const time_t t0)
{
	if (TYPE_INTEGRAL(time_t) &&
		TYPE_BIT(time_t) - TYPE_SIGNED(time_t) < SECSPERREPEAT_BITS)
			return 0;
	return (int_fast64_t)t1 - (int_fast64_t)t0 == SECSPERREPEAT;
}

static int
tzload(timezone_t sp, const char *name, const int doextend)
d711 3
a713 12
	const char *		p;
	int			i;
	int			fid;
	int			stored;
	ssize_t			nread;
	typedef union {
		struct tzhead	tzhead;
		char		buf[2 * sizeof(struct tzhead) +
					2 * sizeof *sp +
					4 * TZ_MAX_TIMES];
	} u_t;
	u_t *			up;
d716 1
a716 2
	up = (u_t *) calloc(1, sizeof *up);
	if (up == NULL)
a717 4

	sp->goback = sp->goahead = FALSE;
	if (name == NULL && (name = TZDEFAULT) == NULL)
		goto oops;
d719 1
a719 1
		int	doaccess;
d734 1
a734 1
				goto oops;
d736 4
a739 4
				goto oops;
			(void) strcpy(fullname, p);	/* XXX strcpy is safe */
			(void) strcat(fullname, "/");	/* XXX strcat is safe */
			(void) strcat(fullname, name);	/* XXX strcat is safe */
d744 1
a744 1
				doaccess = TRUE;
d747 5
a751 2
		if ((doaccess && access(name, R_OK) != 0)
		    || (fid = open(name, OPEN_MODE)) == -1)
d765 6
a770 12
	if (fid == -2)
	  {
	    memcpy(up->buf, _posixrules_data, sizeof (_posixrules_data));
	    nread = sizeof (_posixrules_data);
	  }
	else
	  {
	    nread = read(fid, up->buf, sizeof up->buf);
	    if (close(fid) < 0 || nread <= 0)
	      goto oops;
	  }
	for (stored = 4; stored <= 8; stored *= 2) {
d774 18
a791 7
		ttisstdcnt = (int) detzcode(up->tzhead.tzh_ttisstdcnt);
		ttisgmtcnt = (int) detzcode(up->tzhead.tzh_ttisgmtcnt);
		sp->leapcnt = (int) detzcode(up->tzhead.tzh_leapcnt);
		sp->timecnt = (int) detzcode(up->tzhead.tzh_timecnt);
		sp->typecnt = (int) detzcode(up->tzhead.tzh_typecnt);
		sp->charcnt = (int) detzcode(up->tzhead.tzh_charcnt);
		p = up->tzhead.tzh_charcnt + sizeof up->tzhead.tzh_charcnt;
d798 2
a799 3
				goto oops;
		if (nread - (p - up->buf) <
			sp->timecnt * stored +		/* ats */
d801 1
a801 1
			sp->typecnt * 6 +		/* ttinfos */
d803 1
a803 1
			sp->leapcnt * (stored + 4) +	/* lsinfos */
d806 1
a806 1
				goto oops;
d808 2
a809 3
			sp->ats[i] = (time_t)((stored == 4) ?
				detzcode(p) : detzcode64(p));
			p += stored;
d814 1
a814 1
				goto oops;
d817 1
a817 1
			struct ttinfo *	ttisp;
d824 1
a824 1
				goto oops;
d828 1
a828 1
					goto oops;
d834 1
a834 1
			struct lsinfo *	lsisp;
d837 2
a838 3
			lsisp->ls_trans = (time_t)((stored == 4) ?
			    detzcode(p) : detzcode64(p));
			p += stored;
d843 1
a843 1
			struct ttinfo *	ttisp;
d847 1
a847 1
				ttisp->tt_ttisstd = FALSE;
d850 3
a852 3
				if (ttisp->tt_ttisstd != TRUE &&
					ttisp->tt_ttisstd != FALSE)
						goto oops;
d856 1
a856 1
			struct ttinfo *	ttisp;
d860 1
a860 1
				ttisp->tt_ttisgmt = FALSE;
d863 3
a865 3
				if (ttisp->tt_ttisgmt != TRUE &&
					ttisp->tt_ttisgmt != FALSE)
						goto oops;
a867 42
		/*
		** Out-of-sort ats should mean we're running on a
		** signed time_t system but using a data file with
		** unsigned values (or vice versa).
		*/
		for (i = 0; i < sp->timecnt - 2; ++i)
			if (sp->ats[i] > sp->ats[i + 1]) {
				++i;
				if (TYPE_SIGNED(time_t)) {
					/*
					** Ignore the end (easy).
					*/
					sp->timecnt = i;
				} else {
					/*
					** Ignore the beginning (harder).
					*/
					int	j;

					for (j = 0; j + i < sp->timecnt; ++j) {
						sp->ats[j] = sp->ats[j + i];
						sp->types[j] = sp->types[j + i];
					}
					sp->timecnt = j;
				}
				break;
			}
		/*
		** If this is an old file, we're done.
		*/
		if (up->tzhead.tzh_version[0] == '\0')
			break;
		nread -= p - up->buf;
		for (i = 0; i < nread; ++i)
			up->buf[i] = p[i];
		/*
		** If this is a narrow integer time_t system, we're done.
		*/
		if (stored >= (int) sizeof(time_t)
/* CONSTCOND */
				&& TYPE_INTEGRAL(time_t))
			break;
a868 52
	if (doextend && nread > 2 &&
		up->buf[0] == '\n' && up->buf[nread - 1] == '\n' &&
		sp->typecnt + 2 <= TZ_MAX_TYPES) {
			struct __state ts;
			int	result;

			up->buf[nread - 1] = '\0';
			result = tzparse(&ts, &up->buf[1], FALSE);
			if (result == 0 && ts.typecnt == 2 &&
				sp->charcnt + ts.charcnt <= TZ_MAX_CHARS) {
					for (i = 0; i < 2; ++i)
						ts.ttis[i].tt_abbrind +=
							sp->charcnt;
					for (i = 0; i < ts.charcnt; ++i)
						sp->chars[sp->charcnt++] =
							ts.chars[i];
					i = 0;
					while (i < ts.timecnt &&
						ts.ats[i] <=
						sp->ats[sp->timecnt - 1])
							++i;
					while (i < ts.timecnt &&
					    sp->timecnt < TZ_MAX_TIMES) {
						sp->ats[sp->timecnt] =
							ts.ats[i];
						sp->types[sp->timecnt] =
							sp->typecnt +
							ts.types[i];
						++sp->timecnt;
						++i;
					}
					sp->ttis[sp->typecnt++] = ts.ttis[0];
					sp->ttis[sp->typecnt++] = ts.ttis[1];
			}
	}
	if (sp->timecnt > 1) {
		for (i = 1; i < sp->timecnt; ++i)
			if (typesequiv(sp, sp->types[i], sp->types[0]) &&
				differ_by_repeat(sp->ats[i], sp->ats[0])) {
					sp->goback = TRUE;
					break;
				}
		for (i = sp->timecnt - 2; i >= 0; --i)
			if (typesequiv(sp, sp->types[sp->timecnt - 1],
				sp->types[i]) &&
				differ_by_repeat(sp->ats[sp->timecnt - 1],
				sp->ats[i])) {
					sp->goahead = TRUE;
					break;
		}
	}
	free(up);
a876 25
oops:
	free(up);
	return -1;
}

static int
typesequiv(const timezone_t sp, const int a, const int b)
{
	int	result;

	if (sp == NULL ||
		a < 0 || a >= sp->typecnt ||
		b < 0 || b >= sp->typecnt)
			result = FALSE;
	else {
		const struct ttinfo *	ap = &sp->ttis[a];
		const struct ttinfo *	bp = &sp->ttis[b];
		result = ap->tt_gmtoff == bp->tt_gmtoff &&
			ap->tt_isdst == bp->tt_isdst &&
			ap->tt_ttisstd == bp->tt_ttisstd &&
			ap->tt_ttisgmt == bp->tt_ttisgmt &&
			strcmp(&sp->chars[ap->tt_abbrind],
			&sp->chars[bp->tt_abbrind]) == 0;
	}
	return result;
d890 1
a890 1
** a valid character in a zone name is found. Return a pointer to that
d897 1
a897 1
	char	c;
a905 19
** Given a pointer into an extended time zone string, scan until the ending
** delimiter of the zone name is located. Return a pointer to the delimiter.
**
** As with getzname above, the legal character set is actually quite
** restricted, with other characters producing undefined results.
** We don't do any checking here; checking is done later in common-case code.
*/

static const char *
getqzname(const char *strp, const int delim)
{
	int	c;

	while ((c = *strp) != '\0' && c != delim)
		++strp;
	return strp;
}

/*
d913 1
a913 1
getnum(const char *strp, int *const nump, const int min, const int max)
d915 2
a916 2
	char	c;
	int	num;
d918 1
a918 2
	if (strp == NULL || !is_digit(c = *strp)) {
		errno = EINVAL;
a919 1
	}
d923 1
a923 2
		if (num > max) {
			errno = EOVERFLOW;
a924 1
		}
d927 1
a927 2
	if (num < min) {
		errno = EINVAL;
a928 1
	}
d942 1
a942 1
getsecs(const char *strp, long *const secsp)
d964 1
a964 1
			/* `SECSPERMIN' allows for leap seconds. */
d982 1
a982 1
getoffset(const char *strp, long *const offsetp)
d984 1
a984 1
	int	neg = 0;
d1001 1
a1001 1
** date[/time]. See POSIX section 8 for the format of "date" and "time".
d1007 1
a1007 1
getrule(const char *strp, struct rule *const rulep)
d1059 2
a1060 2
transtime(const time_t janfirst, const int year, const struct rule *const rulep,
    const long offset)
d1062 3
a1064 3
	int	leapyear;
	time_t	value;
	int	i;
d1079 1
a1079 1
		value = (time_t)(janfirst + (rulep->r_day - 1) * SECSPERDAY);
d1090 1
a1090 1
		value = (time_t)(janfirst + rulep->r_day * SECSPERDAY);
d1099 1
a1099 1
			value += (time_t)(mon_lengths[leapyear][i] * SECSPERDAY);
d1115 1
a1115 1
		** "dow" is the day-of-week of the first day of the month. Get
d1132 1
a1132 1
		value += (time_t)(d * SECSPERDAY);
d1138 1
a1138 1
	** question. To get the Epoch-relative time of the specified local
d1142 1
a1142 1
	return (time_t)(value + rulep->r_time + offset);
d1151 1
a1151 1
tzparse(timezone_t sp, const char *name, const int lastditch)
d1159 4
a1162 4
	time_t *		atp;
	unsigned char *	typep;
	char *			cp;
	int			load_result;
d1173 4
a1176 12
		if (*name == '<') {
			name++;
			stdname = name;
			name = getqzname(name, '>');
			if (*name != '>')
				return (-1);
			stdlen = name - stdname;
			name++;
		} else {
			name = getzname(name);
			stdlen = name - stdname;
		}
d1183 1
a1183 1
	load_result = tzload(sp, TZDEFRULES, FALSE);
d1187 5
a1191 12
		if (*name == '<') {
			dstname = ++name;
			name = getqzname(name, '>');
			if (*name != '>')
				return -1;
			dstlen = name - dstname;
			name++;
		} else {
			dstname = name;
			name = getzname(name);
			dstlen = name - dstname; /* length of DST zone name */
		}
a1196 2
		if (*name == '\0' && load_result != 0)
			name = TZDEFRULESTRING;
d1200 2
a1201 2
			int	year;
			time_t	janfirst;
d1216 1
a1216 1
			** Two transitions per year, from EPOCH_YEAR forward.
d1218 3
a1220 1
			memset(sp->ttis, 0, sizeof(sp->ttis));
d1223 1
a1223 1
			sp->ttis[0].tt_abbrind = (int)(stdlen + 1);
d1230 1
a1230 6
			sp->timecnt = 0;
			for (year = EPOCH_YEAR;
			    sp->timecnt + 2 <= TZ_MAX_TIMES;
			    ++year) {
			    	time_t	newfirst;

d1246 2
a1247 7
				sp->timecnt += 2;
				newfirst = janfirst;
				newfirst += (time_t)
				    (year_lengths[isleap(year)] * SECSPERDAY);
				if (newfirst <= janfirst)
					break;
				janfirst = newfirst;
d1257 6
a1262 6
			long	theirstdoffset;
			long	theirdstoffset;
			long	theiroffset;
			int	isdst;
			int	i;
			int	j;
d1266 2
d1292 1
a1292 1
			isdst = FALSE;
d1319 2
a1320 2
						sp->ats[i] += (time_t)
						    (dstoffset - theirdstoffset);
d1322 2
a1323 2
						sp->ats[i] += (time_t)
						    (stdoffset - theirstdoffset);
d1327 3
a1329 3
				if (!sp->ttis[j].tt_isdst)
					theirstdoffset = theiroffset;
				else	theirdstoffset = theiroffset;
d1333 1
a1333 1
			** ttisstd and ttisgmt need not be handled
a1334 1
			memset(sp->ttis, 0, sizeof(sp->ttis));
d1336 1
a1336 1
			sp->ttis[0].tt_isdst = FALSE;
d1339 2
a1340 2
			sp->ttis[1].tt_isdst = TRUE;
			sp->ttis[1].tt_abbrind = (int)(stdlen + 1);
a1353 1
		memset(sp->ttis, 0, sizeof(sp->ttis));
d1363 1
a1363 1
	sp->charcnt = (int)(stdlen + 1);
d1365 1
a1365 1
		sp->charcnt += (int)(dstlen + 1);
d1369 1
a1369 1
	(void) strncpy(cp, stdname, stdlen);
d1373 1
a1373 1
		(void) strncpy(cp, dstname, dstlen);
d1380 1
a1380 1
gmtload(timezone_t sp)
d1382 2
a1383 2
	if (tzload(sp, gmt, TRUE) != 0)
		(void) tzparse(sp, gmt, TRUE);
d1394 1
a1394 1
tzsetwall (void)
d1400 1
d1402 1
a1402 1
		lclptr = (timezone_t) calloc(1, sizeof *lclptr);
d1408 1
d1473 1
a1473 1
	    if (tzparse(lclptr, buf, FALSE) == 0) {
d1486 1
a1486 1
	if (tzload(lclptr, NULL, TRUE) != 0)
d1493 2
a1494 9
#ifndef STD_INSPIRED
/*
** A non-static declaration of tzsetwall in a system header file
** may cause a warning about this upcoming static declaration...
*/
static
#endif /* !defined STD_INSPIRED */
void
tzset_unlocked(void)
d1496 2
a1497 1
	const char *	name;
a1498 1
	name = getenv("TZ");
d1502 1
a1502 1
		return;
d1506 1
a1506 1
		return;
d1511 1
d1513 1
a1513 2
		save_errno save;
		lclptr = (timezone_t) calloc(1, sizeof *lclptr);
d1516 1
a1516 1
			return;
d1519 1
a1525 2
		lclptr->typecnt = 0;
		lclptr->ttis[0].tt_isdst = 0;
d1528 5
a1532 4
		(void) strlcpy(lclptr->chars, gmt, sizeof(lclptr->chars));
	} else if (tzload(lclptr, name, TRUE) != 0)
		if (name[0] == ':' || tzparse(lclptr, name, FALSE) != 0)
			(void) gmtload(lclptr);
d1534 1
a1534 7
}

extern "C" void
tzset(void)
{
	tzset_guard.init ("tzset_guard")->acquire ();
	tzset_unlocked();
d1541 1
a1541 1
** freely called. (And no, the PANS doesn't require the above behavior--
d1548 8
a1555 7
static struct tm *
localsub(const timezone_t sp, const time_t * const timep, const long offset,
    struct tm *const tmp)
{
	const struct ttinfo *	ttisp;
	int			i;
	struct tm *		result;
d1558 5
a1562 39
	if ((sp->goback && t < sp->ats[0]) ||
		(sp->goahead && t > sp->ats[sp->timecnt - 1])) {
			time_t			newt = t;
			time_t		seconds;
			time_t		tcycles;
			int_fast64_t	icycles;

			if (t < sp->ats[0])
				seconds = sp->ats[0] - t;
			else	seconds = t - sp->ats[sp->timecnt - 1];
			--seconds;
			tcycles = (time_t)
			    (seconds / YEARSPERREPEAT / AVGSECSPERYEAR);
			++tcycles;
			icycles = tcycles;
			if (tcycles - icycles >= 1 || icycles - tcycles >= 1)
				return NULL;
			seconds = (time_t) icycles;
			seconds *= YEARSPERREPEAT;
			seconds *= AVGSECSPERYEAR;
			if (t < sp->ats[0])
				newt += seconds;
			else	newt -= seconds;
			if (newt < sp->ats[0] ||
				newt > sp->ats[sp->timecnt - 1])
					return NULL;	/* "cannot happen" */
			result = localsub(sp, &newt, offset, tmp);
			if (result == tmp) {
				time_t	newy;

				newy = tmp->tm_year;
				if (t < sp->ats[0])
					newy -= (time_t)icycles * YEARSPERREPEAT;
				else	newy += (time_t)icycles * YEARSPERREPEAT;
				tmp->tm_year = (int)newy;
				if (tmp->tm_year != newy)
					return NULL;
			}
			return result;
d1564 1
d1573 4
a1576 11
		int	lo = 1;
		int	hi = sp->timecnt;

		while (lo < hi) {
			int	mid = (lo + hi) / 2;

			if (t < sp->ats[mid])
				hi = mid;
			else	lo = mid + 1;
		}
		i = (int) sp->types[lo - 1];
d1585 1
a1585 1
	result = timesub(sp, &t, ttisp->tt_gmtoff, tmp);
d1587 1
a1587 2
	if (sp == lclptr)
		tzname[tmp->tm_isdst] = &sp->chars[ttisp->tt_abbrind];
a1590 1
	return result;
a1592 3
/*
** Re-entrant version of localtime.
*/
d1594 1
a1594 1
localtime_r(const time_t *timep, struct tm *tmp)
d1596 3
a1598 7
	tzset_guard.init ("tzset_guard")->acquire ();
	tzset_unlocked();
	tmp = localsub(lclptr, timep, 0L, tmp);
	tzset_guard.release ();
	if (tmp == NULL)
		errno = EOVERFLOW;
	return tmp;
d1601 3
d1605 1
a1605 1
localtime(const time_t *const timep)
d1607 3
a1609 1
	return localtime_r(timep, &tm);
a1614 1
static NO_COPY muto gmt_guard;
d1616 2
a1617 3
static struct tm *
gmtsub(const timezone_t sp, const time_t *const timep, const long offset,
    struct tm *tmp)
a1618 3
	struct tm *	result;

	gmt_guard.init ("gmt_guard")->acquire ();
d1620 3
a1622 3
		save_errno save;
		gmt_is_set = TRUE;
		gmtptr = (timezone_t) calloc(1, sizeof *gmtptr);
d1624 1
d1627 1
a1627 2
	gmt_guard.release ();
	result = timesub(gmtptr, timep, offset, tmp);
d1637 1
d1641 4
a1646 1
	return result;
d1650 1
a1650 1
gmtime(const time_t *const timep)
d1652 2
a1653 6
	struct tm *tmp = gmtsub(NULL, timep, 0L, &tm);

	if (tmp == NULL)
		errno = EOVERFLOW;

	return tmp;
d1657 2
a1658 3
** Re-entrant version of gmtime.
*/

d1660 1
a1660 1
gmtime_r(const time_t * const timep, struct tm *tmp)
d1662 2
a1663 6
	tmp = gmtsub(NULL, timep, 0L, tmp);

	if (tmp == NULL)
		errno = EOVERFLOW;

	return tmp;
d1669 1
a1669 1
offtime(const time_t *const timep, long offset)
d1671 2
a1672 6
	struct tm *tmp = gmtsub(NULL, timep, offset, &tm);

	if (tmp == NULL)
		errno = EOVERFLOW;

	return tmp;
d1677 3
a1679 7
/*
** Return the number of leap years through the end of the given year
** where, to make the math easy, the answer for year zero is defined as zero.
*/

static int
leaps_thru_end_of(const int y)
d1681 9
a1689 17
	return (y >= 0) ? (y / 4 - y / 100 + y / 400) :
		-(leaps_thru_end_of(-(y + 1)) + 1);
}

static struct tm *
timesub(const timezone_t sp, const time_t *const timep, const long offset,
    struct tm *const tmp)
{
	const struct lsinfo *	lp;
	time_t			tdays;
	int			idays;	/* unsigned would be so 2003 */
	long			rem;
	int			y;
	const int *		ip;
	long			corr;
	int			hit;
	int			i;
d1693 1
d1695 4
d1719 9
a1727 23
	y = EPOCH_YEAR;
	tdays = (time_t)(*timep / SECSPERDAY);
	rem = (long) (*timep - tdays * SECSPERDAY);
	while (tdays < 0 || tdays >= year_lengths[isleap(y)]) {
		int		newy;
		time_t	tdelta;
		int	idelta;
		int	leapdays;

		tdelta = tdays / DAYSPERLYEAR;
		idelta = (int) tdelta;
		if (tdelta - idelta >= 1 || idelta - tdelta >= 1)
			return NULL;
		if (idelta == 0)
			idelta = (tdays < 0) ? -1 : 1;
		newy = y;
		if (increment_overflow(&newy, idelta))
			return NULL;
		leapdays = leaps_thru_end_of(newy - 1) -
			leaps_thru_end_of(y - 1);
		tdays -= ((time_t) newy - y) * DAYSPERNYEAR;
		tdays -= leapdays;
		y = newy;
d1729 2
a1730 12
	{
		long	seconds;

		seconds = tdays * SECSPERDAY + 0.5;
		tdays = (time_t)(seconds / SECSPERDAY);
		rem += (long) (seconds - tdays * SECSPERDAY);
	}
	/*
	** Given the range, we can now fearlessly cast...
	*/
	idays = (int) tdays;
	rem += offset - corr;
d1733 1
a1733 1
		--idays;
d1737 1
a1737 11
		++idays;
	}
	while (idays < 0) {
		if (increment_overflow(&y, -1))
			return NULL;
		idays += year_lengths[isleap(y)];
	}
	while (idays >= year_lengths[isleap(y)]) {
		idays -= year_lengths[isleap(y)];
		if (increment_overflow(&y, 1))
			return NULL;
a1738 16
	tmp->tm_year = y;
	if (increment_overflow(&tmp->tm_year, -TM_YEAR_BASE))
		return NULL;
	tmp->tm_yday = idays;
	/*
	** The "extra" mods below avoid overflow problems.
	*/
	tmp->tm_wday = EPOCH_WDAY +
		((y - EPOCH_YEAR) % DAYSPERWEEK) *
		(DAYSPERNYEAR % DAYSPERWEEK) +
		leaps_thru_end_of(y - 1) -
		leaps_thru_end_of(EPOCH_YEAR - 1) +
		idays;
	tmp->tm_wday %= DAYSPERWEEK;
	if (tmp->tm_wday < 0)
		tmp->tm_wday += DAYSPERWEEK;
d1740 1
a1740 1
	rem %= SECSPERHOUR;
d1744 1
a1744 1
	** representation. This uses "... ??:59:60" et seq.
d1747 22
a1768 4
	ip = mon_lengths[isleap(y)];
	for (tmp->tm_mon = 0; idays >= ip[tmp->tm_mon]; ++(tmp->tm_mon))
		idays -= ip[tmp->tm_mon];
	tmp->tm_mday = (int) (idays + 1);
a1772 1
	return tmp;
d1776 1
a1776 1
ctime(const time_t *const timep)
d1781 1
a1781 1
**	to local time in the form of a string. It is equivalent to
d1784 1
a1784 4
	struct tm *rtm = localtime(timep);
	if (rtm == NULL)
		return NULL;
	return asctime(rtm);
d1788 1
a1788 1
ctime_r(const time_t *const timep, char *buf)
d1790 1
a1790 1
	struct tm	mytm, *rtm;
d1792 1
a1792 4
	rtm = localtime_r(timep, &mytm);
	if (rtm == NULL)
		return NULL;
	return asctime_r(rtm, buf);
d1799 2
a1800 1
**	It does a binary search of the time_t space. Since time_t's are
d1806 1
a1806 1
#define WRONG	((time_t)-1)
d1810 1
a1810 1
** Simplified normalize logic courtesy Paul Eggert.
d1813 3
a1815 19
static int
increment_overflow(int *const ip, int j)
{
	int	i = *ip;

	/*
	** If i >= 0 there can only be overflow if i + j > INT_MAX
	** or if j > INT_MAX - i; given i >= 0, INT_MAX - i cannot overflow.
	** If i < 0 there can only be overflow if i + j < INT_MIN
	** or if j < INT_MIN - i; given i < 0, INT_MIN - i cannot overflow.
	*/
	if ((i >= 0) ? (j > INT_MAX - i) : (j < INT_MIN - i))
		return TRUE;
	*ip += j;
	return FALSE;
}

static int
long_increment_overflow(long *const lp, int m)
d1817 1
a1817 1
	long l = *lp;
d1819 3
a1821 4
	if ((l >= 0) ? (m > LONG_MAX - l) : (m < LONG_MIN - l))
		return TRUE;
	*lp += m;
	return FALSE;
d1825 1
a1825 1
normalize_overflow(int *const tensptr, int *const unitsptr, const int base)
d1827 1
a1827 1
	int	tensdelta;
d1837 1
a1837 14
long_normalize_overflow(long *const tensptr, int *const unitsptr,
    const int base)
{
	int	tensdelta;

	tensdelta = (*unitsptr >= 0) ?
		(*unitsptr / base) :
		(-1 - (-1 - *unitsptr) / base);
	*unitsptr -= tensdelta * base;
	return long_increment_overflow(tensptr, tensdelta);
}

static int
tmcomp(const struct tm *const atmp, const struct tm *const btmp)
d1839 1
a1839 1
	int	result;
d1851 2
a1852 2
time2sub(const timezone_t sp, struct tm *const tmp, subfun_t funcp,
    const long offset, int *const okayp, const int do_norm_secs)
d1854 5
a1858 10
	int			dir;
	int			i, j;
	int			saved_seconds;
	long			li;
	time_t			lo;
	time_t			hi;
#ifdef NO_ERROR_IN_DST_GAP
	time_t			ilo;
#endif
	long				y;
d1863 1
a1863 1
	*okayp = FALSE;
a1864 3
#ifdef NO_ERROR_IN_DST_GAP
again:
#endif
d1867 2
a1868 2
		    SECSPERMIN))
			goto overflow;
d1871 1
a1871 1
		goto overflow;
d1873 3
a1875 4
		goto overflow;
	y = yourtm.tm_year;
	if (long_normalize_overflow(&y, &yourtm.tm_mon, MONSPERYEAR))
		goto overflow;
d1877 1
a1877 1
	** Turn y into an actual year number for now.
d1880 2
a1881 2
	if (long_increment_overflow(&y, TM_YEAR_BASE))
		goto overflow;
d1883 4
a1886 4
		if (long_increment_overflow(&y, -1))
			goto overflow;
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday += year_lengths[isleap(li)];
d1889 4
a1892 4
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday -= year_lengths[isleap(li)];
		if (long_increment_overflow(&y, 1))
			goto overflow;
d1895 1
a1895 1
		i = mon_lengths[isleap(y)][yourtm.tm_mon];
d1901 2
a1902 2
			if (long_increment_overflow(&y, 1))
				goto overflow;
d1905 3
a1907 8
	if (long_increment_overflow(&y, -TM_YEAR_BASE))
		goto overflow;
	yourtm.tm_year = (int)y;
	if (yourtm.tm_year != y)
		goto overflow;
	if (yourtm.tm_sec >= 0 && yourtm.tm_sec < SECSPERMIN)
		saved_seconds = 0;
	else if (y + TM_YEAR_BASE < EPOCH_YEAR) {
d1917 1
a1917 1
			goto overflow;
d1925 8
a1932 1
	** Do a binary search (this works whatever time_t's type is).
d1934 1
a1934 14
	/* LINTED const not */
	if (!TYPE_SIGNED(time_t)) {
		lo = 0;
		hi = lo - 1;
	/* LINTED const not */
	} else {
		lo = 1;
		for (i = 0; i < (int) TYPE_BIT(time_t) - 1; ++i)
			lo *= 2;
		hi = -(lo + 1);
	}
#ifdef NO_ERROR_IN_DST_GAP
	ilo = lo;
#endif
d1936 2
a1937 13
		t = lo / 2 + hi / 2;
		if (t < lo)
			t = lo;
		else if (t > hi)
			t = hi;
		if ((*funcp)(sp, &t, offset, &mytm) == NULL) {
			/*
			** Assume that t is too extreme to be represented in
			** a struct tm; arrange things so that it is less
			** extreme on the next pass.
			*/
			dir = (t > 0) ? 1 : -1;
		} else	dir = tmcomp(&mytm, &yourtm);
d1939 7
a1945 34
			if (t == lo) {
				++t;
				if (t <= lo)
					goto overflow;
				++lo;
			} else if (t == hi) {
				--t;
				if (t >= hi)
					goto overflow;
				--hi;
			}
#ifdef NO_ERROR_IN_DST_GAP
			if (ilo != lo && lo - 1 == hi && yourtm.tm_isdst < 0 &&
			    do_norm_secs) {
				for (i = sp->typecnt - 1; i >= 0; --i) {
					for (j = sp->typecnt - 1; j >= 0; --j) {
						time_t off;
						if (sp->ttis[j].tt_isdst ==
						    sp->ttis[i].tt_isdst)
							continue;
						off = sp->ttis[j].tt_gmtoff -
						    sp->ttis[i].tt_gmtoff;
						yourtm.tm_sec += off < 0 ?
						    -off : off;
						goto again;
					}
				}
			}
#endif
			if (lo > hi)
				goto invalid;
			if (dir > 0)
				hi = t;
			else	lo = t;
d1956 7
d1964 2
a1965 1
			goto invalid;
d1972 3
a1974 4
				newt = (time_t)(t + sp->ttis[j].tt_gmtoff -
				    sp->ttis[i].tt_gmtoff);
				if ((*funcp)(sp, &newt, offset, &mytm) == NULL)
					continue;
d1986 1
a1986 1
		goto invalid;
d1991 1
a1991 1
		goto overflow;
d1993 3
a1995 10
	if ((*funcp)(sp, &t, offset, tmp)) {
		*okayp = TRUE;
		return t;
	}
overflow:
	errno = EOVERFLOW;
	return WRONG;
invalid:
	errno = EINVAL;
	return WRONG;
d1999 2
a2000 2
time2(const timezone_t sp, struct tm *const tmp, subfun_t funcp,
    const long offset, int *const okayp)
d2009 23
a2031 2
	t = time2sub(sp, tmp, funcp, offset, okayp, FALSE);
	return *okayp ? t : time2sub(sp, tmp, funcp, offset, okayp, TRUE);
d2035 2
a2036 2
time1(const timezone_t sp, struct tm *const tmp, subfun_t funcp,
    const long offset)
d2038 3
a2040 7
	time_t			t;
	int			samei, otheri;
	int			sameind, otherind;
	int			i;
	int			nseen;
	int				seen[TZ_MAX_TYPES];
	int				types[TZ_MAX_TYPES];
a2042 4
	if (tmp == NULL) {
		errno = EINVAL;
		return WRONG;
	}
d2045 1
a2045 1
	t = time2(sp, tmp, funcp, offset, &okay);
d2048 1
a2048 1
	** PCTS code courtesy Grant Sullivan.
d2065 7
a2071 2
	if (sp == NULL) {
		errno = EINVAL;
d2073 2
a2074 11
	}
	for (i = 0; i < sp->typecnt; ++i)
		seen[i] = FALSE;
	nseen = 0;
	for (i = sp->timecnt - 1; i >= 0; --i)
		if (!seen[sp->types[i]]) {
			seen[sp->types[i]] = TRUE;
			types[nseen++] = sp->types[i];
		}
	for (sameind = 0; sameind < nseen; ++sameind) {
		samei = types[sameind];
d2077 1
a2077 2
		for (otherind = 0; otherind < nseen; ++otherind) {
			otheri = types[otherind];
d2080 2
a2081 2
			tmp->tm_sec += (int)(sp->ttis[otheri].tt_gmtoff -
					sp->ttis[samei].tt_gmtoff);
d2083 1
a2083 1
			t = time2(sp, tmp, funcp, offset, &okay);
d2086 2
a2087 2
			tmp->tm_sec -= (int)(sp->ttis[otheri].tt_gmtoff -
					sp->ttis[samei].tt_gmtoff);
a2090 1
	errno = EOVERFLOW;
d2095 1
a2095 1
mktime(struct tm *const tmp)
d2097 2
a2098 7
	time_t result;

	tzset_guard.init ("tzset_guard")->acquire ();
	tzset_unlocked();
	result = time1(lclptr, tmp, localsub, 0L);
	tzset_guard.release ();
	return result;
d2104 1
a2104 1
timelocal(struct tm *const tmp)
d2106 1
a2106 2
	if (tmp != NULL)
		tmp->tm_isdst = -1;	/* in case it wasn't initialized */
d2111 1
a2111 1
timegm(struct tm *const tmp)
d2113 2
a2114 6
	time_t t;

	if (tmp != NULL)
		tmp->tm_isdst = 0;
	t = time1(gmtptr, tmp, gmtsub, 0L);
	return t;
d2118 1
a2118 1
timeoff(struct tm *const tmp, const long offset)
d2120 2
a2121 6
	time_t t;

	if (tmp != NULL)
		tmp->tm_isdst = 0;
	t = time1(gmtptr, tmp, gmtsub, offset);
	return t;
d2134 1
a2134 1
gtime(struct tm *const tmp)
d2136 1
a2136 1
	const time_t t = mktime(tmp);
d2162 3
a2164 3
	timezone_t	sp;
	struct lsinfo * lp;
	int		i;
d2179 2
a2180 6
	time_t result;
	tzset_guard.init ("tzset_guard")->acquire ();
	tzset_unlocked();
	result = t - leapcorr(&t);
	tzset_guard.release ();
	return (result);
d2189 1
a2189 2
	tzset_guard.init ("tzset_guard")->acquire ();
	tzset_unlocked();
d2192 1
a2192 1
	** is not unique. For a negative leap second
d2196 2
a2197 2
	x = (time_t)(t + leapcorr(&t));
	y = (time_t)(x - leapcorr(&x));
d2201 1
a2201 1
			y = (time_t)(x - leapcorr(&x));
d2203 1
a2203 1
		if (t != y) {
a2204 1
		}
d2208 1
a2208 1
			y = (time_t)(x - leapcorr(&x));
d2210 1
a2210 1
		if (t != y) {
a2211 1
		}
a2212 1
	tzset_guard.release ();
@


1.27.4.3
log
@	* localtime.cc: Add comment.
@
text
@a1 7

/* Don't reformat the code arbitrarily.

   It uses in wide parts the exact formatting as the upstream NetBSD
   versions.  The purpose is to simplify subsequent diffs to the NetBSD
   version, should the need arise again at one point. */

@


1.26
log
@* localtime.cc (is_upper): Rename to isupper and include ctype.h to pull in
standard macro.
(lcl_is_set): Define as an enum.
(tzsetwall): Assign lcl_is_set to correct enum values.
(tzset): Ditto.  Copy as much of TZ as will fit to TZ buffer.
@
text
@d869 7
a875 4
	__gettzinfo ()->__tzrule[0].offset
				= -sp->ttis[1].tt_gmtoff;
	__gettzinfo ()->__tzrule[1].offset
				= -sp->ttis[0].tt_gmtoff;
d1249 7
a1255 4
			__gettzinfo ()->__tzrule[0].offset
						= -sp->ttis[1].tt_gmtoff;
			__gettzinfo ()->__tzrule[1].offset
						= -sp->ttis[0].tt_gmtoff;
d1342 7
a1348 4
			__gettzinfo ()->__tzrule[0].offset
						= -sp->ttis[0].tt_gmtoff;
			__gettzinfo ()->__tzrule[1].offset
						= -sp->ttis[1].tt_gmtoff;
d1357 5
a1361 2
		__gettzinfo ()->__tzrule[0].offset = -sp->ttis[0].tt_gmtoff;
		__gettzinfo ()->__tzrule[1].offset = -sp->ttis[0].tt_gmtoff;
@


1.25
log
@	* localtime.cc (time2): Take another stab at fixing a compiler warning.
@
text
@d10 1
d599 7
a605 1
static int		lcl_is_set;
d1384 1
a1384 1
	if (lcl_is_set < 0)
d1386 1
a1386 1
	lcl_is_set = -1;
d1397 1
a1397 2
#if defined (_WIN32) || defined (__CYGWIN__)
#define is_upper(c) ((unsigned)(c) - 'A' <= 26)
d1407 1
a1407 1
	      if (is_upper(*src)) *dst++ = *src;
d1425 1
a1425 1
		  if (is_upper(*src)) *dst++ = *src;
d1463 1
a1463 1
		lcl_is_set = 1;
d1488 1
a1488 1
		if (!lcl_is_set)
d1493 1
a1493 1
	if (lcl_is_set > 0  &&  strcmp(lcl_TZname, name) == 0)
d1495 3
a1497 3
	lcl_is_set = (strlen(name) < sizeof (lcl_TZname));
	if (lcl_is_set)
		strcpy(lcl_TZname, name);
@


1.24
log
@* localtime.cc (time2): Take a stab at fixing a compiler warning.
@
text
@d2009 1
a2009 1
	    if (tmp2.tm_sec + 3600 < t)	/* Sanity check */
@


1.23
log
@	* localtime.cc (time2): Change "spring gap" to "spring forward gap"
	in comment.
@
text
@d2009 1
a2009 1
	    if (t + 3600 < t)	/* Sanity check */
@


1.22
log
@	* localtime.cc (time2): Add workaround for spring gap problem.  Add
	explaining comment.
@
text
@d1997 2
a1998 2
	/* Workaround for the spring gap problem which results in the
	   autoconf mktime usability test failing.
d2003 1
a2003 1
	   spring gap and we can give up. */
@


1.21
log
@	* localtime.cc (tzload): Implement setting __tzrule's offset member
	using newlib's __gettzinfo () interface also when tzload returns
	successfully.
@
text
@d1992 22
a2013 1
	return *okayp ? t : time2sub(tmp, funcp, offset, okayp, true);
@


1.20
log
@* localtime.cc (increment_overflow): Mark as non-inline to prevent compiler
from complaining about the very thing we're trying to test.
* ntea.cc (read_ea): Reorganize to avoid a new compiler warning/error.
* sched.cc (sched_rr_get_interval): Ditto.
* select.cc (peek_serial): Ditto.
* libc/rexec.cc (ruserpass): Ditto.
* posix_ipc.cc (ipc_names): Make static to avoid a compiler warning
(and it's the right thing to do anyway).
@
text
@d862 4
@


1.19
log
@Remove unneeded header files from source files throughout.
@
text
@d1791 2
a1792 1
static int
@


1.18
log
@	* localtime.cc (tzset): Guard by a muto for thread safety.
@
text
@a9 1
#include <windows.h>
a96 1
#include "sys/types.h"	/* for time_t */
a98 1
#include "time.h"
a101 1
#include "libintl.h"
a170 1
#include "sys/param.h"
@


1.17
log
@	* localtime.cc (tzset): Call tzsetwall only if it hasn't been
	called before.
@
text
@d9 1
d1474 2
d1479 1
d1485 1
a1485 1
		return;
d1489 1
a1489 1
		return;
d1499 1
a1499 1
			return;
d1517 2
@


1.16
log
@	* localtime.cc (tzsetwall): Don't set TZ.
@
text
@d1479 2
a1480 1
		tzsetwall();
@


1.15
log
@	* libc: Add subdirectory.
	* Makefile.in (VPATH): Add libc subdir.
	(DLL_OFILES): Add strptime.o and timelocal.o.
	* cygwin.din: Export timelocal and timegm.
	* localtime.cc: Define STD_INSPIRED unconditionally.
	* include/cygwin/time.h (timelocal): Add declaration.
	(timegm): Ditto.
	* include/cygwin/version.h: Bump API minor version.
	* libc/strptime.cc: New file.
	* libc/timelocal.cc: New file.
	* libc/timelocal.h: New file.
@
text
@d1459 3
d1463 1
@


1.15.8.1
log
@2007-11-08  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dllfixdbg: Eliminate extra objcopy step.

2007-11-07  Pedro Alves  <pedro_alves@@portugalmail.pt>

	* dllfixdbg: Pass --only-keep-debug to objcopy, instead of
	selecting the sections manually.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* thread.cc (pthread_key_create): Drop check for incoming valid object.

2007-11-06  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc: Include sync.h
	(struct shm_shmid_list): Add ref_count member.
	(struct shm_attached_list): Remove hdl and size members.  Add a parent
	member pointing to referenced shm_shmid_list entry.
	(shm_guard): New muto.
	(SLIST_LOCK): Define.
	(SLIST_UNLOCK): Define.
	(fixup_shms_after_fork): Use hdl and size members of parent
	shm_shmid_list entry.
	(shmat): Access sequential bookkeeping lists in a thread safe way.
	Accommodate change in list element layout.  Align comments.
	(shmctl): Ditto.
	(shmdt): Ditto.
	(shmget): Ditto.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID don't unmap views and don't close handle
	if the map is still referenced to emulate Linux and BSD behaviour.

2007-11-05  Corinna Vinschen  <corinna@@vinschen.de>

	* shm.cc (shmctl): On IPC_RMID also unmap all views on shared mem
	as well as connected shm_attached_list entry.

2007-10-30  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Don't remove
	write bits for directories with R/O attribute.
	(fhandler_base::fhaccess): Don't shortcircuit R/O attribute with W_OK
	scenarios for directories.

2007-09-26  Corinna Vinschen  <corinna@@vinschen.de>

	* termios.cc (setspeed): Support new baud rates introduced 2007-02-05.

2007-09-18  Corinna Vinschen  <corinna@@vinschen.de>

	* mmap.cc (fh_disk_file): Delete as global static variable and...
	(mmap64): ...define as local pointer to make mmap thread-safe.
	Accommodate throughout.  Only initialize fh_disk_file after file could
	be opened with GENERIC_EXECUTE access.

2007-09-06  Brian Dessent  <brian@@dessent.net>

	* include/sys/stdio.h (_flockfile): Don't try to lock a FILE
	that has the __SSTR flag set.
	(_ftrylockfile): Likewise.
	(_funlockfile): Likewise.

2007-08-24  Corinna Vinschen  <corinna@@vinschen.de>

	* syscalls.cc (open): Don't follow symlinks if O_EXCL is given.

2007-08-09  Ernie Coskrey  <Ernie.Coskrey@@steeleye.com>

	* gendef (sigbe): Reset "incyg" while the stack lock is active to avoid
	a potential race.

2007-08-01  Corinna Vinschen  <corinna@@vinschen.de>

	* localtime.cc (tzsetwall): Don't set TZ.

2007-07-17  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fhaccess): Add check for R/O file system.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Delete.
	(dll_entry): Remove assignment to deleted variable.
	* winsup.h (in_dllentry): Delete declaration.
	* exceptions.cc (inside_kernel): Use another method to see if we are in
	dll_entry phase.

2007-07-14  Christopher Faylor  <me+cygwin@@cgf.cx>

	* init.cc (in_dllentry): Make NO_COPY to avoid spurious false positives.

2007-07-09  Christopher Faylor  <me+cygwin@@cgf.cx>

	* dlfcn.cc (dlclose): Don't close handle returned from
	GetModuleHandle(NULL).

2007-07-06  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc (gettimeofday): Align definition to POSIX.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* times.cc: Define __timezonefunc__ before including time.h to protect
	definition of timezone function.

2007-07-04  Corinna Vinschen  <corinna@@vinschen.de>

	* include/cygwin/time.h: Switch to timezone variable by default.  Add
	comment.

2007-06-27  Corinna Vinschen  <corinna@@vinschen.de>

	* shared_info.h (SHARED_INFO_CB): Accommodate change to shared_info.
	(CURR_SHARED_MAGIC): Ditto.
	(class shared_info): Add heap_slop_inited member.
	* shared.cc (shared_info::heap_slop_size): Use heap_slop_inited to
	track initializing heap_slop since 0 is a valid value for heap_slop.
	Drop useless < 0 consideration.

2007-06-12  Christopher Faylor  <me+cygwin@@cgf.cx>

	* signal.cc (usleep): Use useconds_t for the type as per POSIX.

2007-06-12  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set pipe permission bits more
	correctly.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* dtable.cc (dtable::set_file_pointers_for_exec): Call SetFilePointer
	correctly for 64 bit file access.  Comment out functionality.
	* fhandler.cc (fhandler_base::open): Don't set append_mode.
	(fhandler_base::write): Check for O_APPEND instead of append_mode.
	Call SetFilePointer correctly for 64 bit file access.  Handle
	errors from SetFilePointer.
	* fhandler.h (class fhandler_base): Drop append_mode status flag.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Handle
	seeking correctly for 64 bit file access.

2007-05-21  Christian Franke <franke@@computer.org>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Don't invalidate
	devbuf if new position is within buffered range.

2007-05-21  Eric Blake  <ebb9@@byu.net>

	* include/search.h (hsearch_r): Provide declaration.

2007-05-21  Christian Franke <franke@@computer.org>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_floppy.cc (fhandler_dev_floppy::lseek): Set buf size to
	sector size.  Simplify non-sector aligned case.  Handle errors from
	raw_read.

2007-05-15  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (adjust_socket_file_mode): New inline function.
	(fhandler_socket::fchmod): Squeeze mode through adjust_socket_file_mode
	before using it.
	(fhandler_socket::bind): Ditto.

2007-04-18  Brian Dessent  <brian@@dessent.net>

	* cygwin.sc: Remove duplicated .debug_macinfo section.
	* dllfixdbg: Also copy DWARF-2 sections into .dbg file.

2007-04-06  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN): Fix sign.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* include/stdint.h (WINT_MIN, WINT_MAX): Fix definition.

2007-03-28  Christopher Faylor  <me@@cgf.cx>

	* spawn.cc (spawn_guts): Start pure-windows processes in a suspended
	state to avoid potential DuplicateHandle problems.

2007-03-07  Christopher Faylor  <me@@cgf.cx>

	* signal.cc (handle_sigprocmask): Remove extraneous
	sig_dispatch_pending.

2007-02-26  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.cc (fhandler_base::fstat): Set all file times to arbitrary
	fixed value.

2007-02-20  Christopher Faylor  <me@@cgf.cx>

	* exceptions.cc (_cygtls::signal_exit): Only call myself.exit when when
	exit_state indicates that we've visited do_exit.
	* sync.h (lock_process::lock_process): Use renamed exit_state -
	ES_PROCESS_LOCKED.
	* winsup.h: Rename ES_MUTO_SET to ES_PROCESS_LOCKED.

2007-02-20  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_socket.cc (fhandler_socket::bind): Remove printing wrong
	errno in debug output.

2007-02-05  Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler_serial.cc (fhandler_serial::tcsetattr): Add support for
	baud rates up to 3000000 baud.  Add missing 128K and 256K cases.
	(fhandler_serial::tcgetattr): Ditto.
	* include/sys/termios.h: Add baud rate definitions from B460800 up to
	B3000000.

2007-01-04  Brian Ford  <Brian.Ford@@FlightSafety.com>
	     Corinna Vinschen  <corinna@@vinschen.de>

	* fhandler.h (PREFERRED_IO_BLKSIZE): Define as 64K.
	* fhandler.cc (fhandler_base::fstat): Set st_blksize to
	PREFERRED_IO_BLKSIZE.
	* fhandler_disk_file.cc (fhandler_base::fstat_helper): Ditto.
	* fhandler_mailslot.cc (fhandler_mailslot::fstat): Ditto.
	* fhandler_raw.cc (fhandler_dev_raw::fstat): Ditto.

2006-11-08  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the local
	group to the token.

2006-07-14  Corinna Vinschen  <corinna@@vinschen.de>

	* security.cc (get_token_group_sidlist): Always add the interactive
	group to the token.  Create logon_id group SID by copying it from
	incoming group list.
@
text
@a1458 3
#if 0
		/* Huh?  POSIX doesn't mention anywhere that tzset should
		   set $TZ.  That's not right. */
a1459 1
#endif
@


1.15.8.2
log
@	* localtime.cc (tzset): Call tzsetwall only if it hasn't been
	called before.
@
text
@d1479 1
a1479 2
		if (!lcl_is_set)
			tzsetwall();
@


1.15.8.3
log
@	* localtime.cc (tzset): Guard by a muto for thread safety.
@
text
@a8 1
#include "sync.h"
a1472 2
static NO_COPY muto tzset_guard;

a1475 1
	tzset_guard.init ("tzset_guard")->acquire ();
d1481 1
a1481 1
		goto out;
d1485 1
a1485 1
		goto out;
d1495 1
a1495 1
			goto out;
a1512 2
out:
	tzset_guard.release ();
@


1.14
log
@Eliminate (void) cast on standalone function calls throughout.
@
text
@d10 1
@


1.13
log
@	* localtime.cc: Implement setting __tzrule's offset member using
	newlib's __gettzinfo () interface.
	(__tzrule): Remove.
	(timezone): Define as long according to POSIX.
@
text
@d733 3
a735 3
			(void) strcpy(fullname, p);
			(void) strcat(fullname, "/");
			(void) strcat(fullname, name);
d1349 1
a1349 1
	(void) strncpy(cp, stdname, stdlen);
d1353 1
a1353 1
		(void) strncpy(cp, dstname, dstlen);
d1363 1
a1363 1
		(void) tzparse(gmt, sp, true);
d1482 1
a1482 1
		(void) strcpy(lcl_TZname, name);
d1501 1
a1501 1
		(void) strcpy(lclptr->chars, gmt);
d1504 1
a1504 1
			(void) gmtload(lclptr);
@


1.12
log
@	* localtime.cc: Temporary implementation of setting __tzrule's offset
	member to be used by strftime.
	(__tzrule): New global variable.
	(tzparse): Set __tzrule's offset member appropriately.
@
text
@d632 2
a633 2
time_t			timezone;
int			daylight;
d637 1
a637 1
time_t			altzone;
a639 14
/* Must be equivalent to definiton in newlib/libc/time/local.h */
typedef struct __tzrule_struct
{
  char ch;
  int m;
  int n;
  int d;
  int s;
  time_t change;
  int offset;
} __tzrule_type;
__tzrule_type __tzrule[2] = { {'J', 0, 0, 0, 0, (time_t)0, 0 }, 
			      {'J', 0, 0, 0, 0, (time_t)0, 0 } };

d1238 4
a1241 2
			__tzrule[0].offset = -sp->ttis[1].tt_gmtoff;
			__tzrule[1].offset = -sp->ttis[0].tt_gmtoff;
d1328 4
a1331 2
			__tzrule[0].offset = -sp->ttis[0].tt_gmtoff;
			__tzrule[1].offset = -sp->ttis[1].tt_gmtoff;
d1340 2
a1341 2
		__tzrule[0].offset = -sp->ttis[0].tt_gmtoff;
		__tzrule[1].offset = -sp->ttis[0].tt_gmtoff;
@


1.11
log
@* localtime.cc (localtime_r): Call tzset.
* Makefile.in: Make version.h/cygwin.din version check a warning since it is
not foolproof.
* cygheap.h (CYGHEAPSIZE): Bump size down.
* cygtls.h (_threadinfo::stacklock): New element.
(_threadinfo::pop): Make regparm.
(_threadinfo::lock): New function.
(_threadinfo::unlock): New function.
* cygtls.cc (_threadinfo::push): Wait for a lock on the stack before performing
the operation.
(_threadinfo::pop): Move to another file.
* cygwin.din: More SIGFE changes.
* exceptions.cc (try_to_debug): Always display messages on console.
(handle_exceptions): Unwind stack only when actually about to call sig_send.
(setup_handler): Lock stack prior to performing any operations.
* gendef (_sigfe): Ditto.
(_sigbe): Ditto.
(_threadinfo::pop): Ditto.  Move here.
* gen_tlsoffsets: Generate positive offsets.
* tlsoffsets.h: Regenerate.
@
text
@d640 14
d1252 2
d1340 2
d1350 2
@


1.10
log
@Change use of BOOL, TRUE, FALSE to bool, true, false, as appropriate,
throughout.
* tty.cc (tty::common_init): Remove call to SetKernelObjectSecurity and edit
some comments.
* cygheap.h (init_cygheap::ctty): Add new element.
* devices.in (device::parse): Remove special handling for /dev/tty.
* devices.cc: Regenerate.
* dtable.cc (build_fh_pc): Don't reset /dev/tty device.  Let the device opener
do that.
* fhandler_termios.cc (tty_min::set_ctty): Redefine to _pinfo class.
* fhandler_tty.cc (fhandler_tty_common::set_close_on_exec): Avoid setting
noninherit flag for ctty.
* tty.h: Move BOOLs to bools.
(tty_min::set_ctty): Redeclare to _pinfo class.
* pinfo.cc (_pinfo::set_ctty): Define new function based on tty_min::set_ctty.
Change first argument from tty number to tty_min class.
* pinfo.h (_pinfo::set_ctty): Declare.
* fhandler_console.cc (fhandler_console::get_tty_stuff): Reflect move of
set_ctty to _pinfo class.
* fhandler_tty.cc (fhandler_tty_slave::open): Treat FH_TTY specially.  Use
saved cygheap value if it exists.  Otherwise convert to real device and save on
first time open.
(fhandler_tty_common::dup): Potentially set controlling tty if duping a slave
tty.
* syscalls.cc (setsid): Close controlling tty in cygheap.
* tty.cc: Change some BOOLs to bools.
@
text
@d1568 1
@


1.9
log
@	* include/tzfile.h: Remove duplicate definition of TM_SUNDAY.
	* localtime.cc: Point TZDIR to the /usr/share/zoneinfo directory used
	by the tzcode package.
@
text
@a198 8
#ifndef TRUE
#define TRUE	1
#endif /* !defined TRUE */

#ifndef FALSE
#define FALSE	0
#endif /* !defined FALSE */

d339 2
a340 2
**	tzh_ttisstdcnt (char)s		indexed by type; if TRUE, transition
**					time is standard time, if FALSE,
d344 2
a345 2
**	tzh_ttisgmtcnt (char)s		indexed by type; if TRUE, transition
**					time is UTC, if FALSE,
d499 2
a500 2
	int		tt_ttisstd;	/* TRUE if transition is std time */
	int		tt_ttisgmt;	/* TRUE if transition is UTC */
d740 1
a740 1
				doaccess = TRUE;
d843 1
a843 1
				ttisp->tt_ttisstd = FALSE;
d846 2
a847 2
				if (ttisp->tt_ttisstd != TRUE &&
					ttisp->tt_ttisstd != FALSE)
d856 1
a856 1
				ttisp->tt_ttisgmt = FALSE;
d859 2
a860 2
				if (ttisp->tt_ttisgmt != TRUE &&
					ttisp->tt_ttisgmt != FALSE)
d1274 1
a1274 1
			isdst = FALSE;
d1318 1
a1318 1
			sp->ttis[0].tt_isdst = FALSE;
d1321 1
a1321 1
			sp->ttis[1].tt_isdst = TRUE;
d1353 1
a1353 1
		(void) tzparse(gmt, sp, TRUE);
d1444 1
a1444 1
	    if (tzparse(buf, lclptr, FALSE) == 0) {
d1493 1
a1493 1
		if (name[0] == ':' || tzparse(name, lclptr, FALSE) != 0)
d1580 1
a1580 1
		gmt_is_set = TRUE;
d1822 1
a1822 1
	*okayp = FALSE;
d1953 1
a1953 1
	*okayp = TRUE;
d1968 2
a1969 2
	t = time2sub(tmp, funcp, offset, okayp, FALSE);
	return *okayp ? t : time2sub(tmp, funcp, offset, okayp, TRUE);
@


1.8
log
@
2002-12-19  Pierre Humblet <pierre.humblet@@ieee.org>

        * localtime.cc (tzsetwall): Set lcl_is_set and lcl_TZname
        in the Cygwin specific part of the routine.
@
text
@d306 1
a306 1
#define TZDIR	"/usr/local/etc/zoneinfo" /* Time zone object file directory */
@


1.7
log
@More GNUify non-GNU formatted functions calls throughout.
@
text
@d1454 3
a1456 1
		setenv("TZ", buf, 1);
@


1.6
log
@	* localtime.cc (tzsetwall): Use wildabbr if generated timezone name
	length < 3.
@
text
@d780 2
a781 2
		    memcpy(u.buf, _posixrules_data, sizeof(_posixrules_data));
		    i = sizeof(_posixrules_data);
d1476 1
a1476 1
	lcl_is_set = (strlen(name) < sizeof(lcl_TZname));
@


1.5
log
@Fix up comments.
@
text
@d1399 1
a1399 1
	    if (cp == dst)
d1401 2
a1402 2
		/* In Asian Windows, tz.StandardName may not contain
		   the timezone name. */
d1417 1
a1417 1
		if (cp == dst)
d1419 3
a1421 3
		    /* In Asian Windows, tz.StandardName may not contain
		       the daylight name. */
		    strcpy(buf, wildabbr);
@


1.4
log
@* autoload.cc (wsock_init): Reorganize slightly to accomodate a new compiler.
@
text
@a6 1
/* CYGNUS LOCAL */
a12 2

/* END CYGNUS LOCAL */
@


1.3
log
@Move appropriate variables to NO_COPY segment, throughout.
@
text
@d504 1
a504 1
static const char gmt[] NO_COPY = "GMT";
@


1.3.4.1
log
@Merged changes from HEAD
@
text
@d7 1
d15 2
d504 1
a504 1
static char gmt[] NO_COPY = "GMT";
@


1.3.4.2
log
@Merged changes from HEAD
@
text
@d1399 1
a1399 1
	    if ((dst - cp) < 3)
d1401 2
a1402 2
		/* In non-english Windows, converted tz.StandardName
		   may not contain a valid standard timezone name. */
d1417 1
a1417 1
		if ((dst - cp) < 3)
d1419 3
a1421 3
		    /* In non-english Windows, converted tz.DaylightName
		       may not contain a valid daylight timezone name. */
		    strcpy(cp, wildabbr);
@


1.2
log
@Remove initialization of static or global values to zero, throughout.  This
just needlessly grows the size of the DLL.
* tty.cc (tty::alive): Make inuse handle non-inheriting on open, just for
thread safety.
@
text
@d502 1
a502 1
static char		wildabbr[] = WILDABBR;
d504 1
a504 1
static const char	gmt[] = "GMT";
@


1.1
log
@        * localtime.c: Changed whole file to become C++ clean. Rename to
        localtime.cc.
        * localtime.cc (tzload): Preserve errno.
@
text
@d643 2
a644 2
time_t			timezone = 0;
int			daylight = 0;
d648 1
a648 1
time_t			altzone = 0;
@

